<!-- doc/src/sgml/test-shm-mq.sgml -->

<sect1 id="test-shm-mq" xreflabel="test_shm_mq">
 <title>test_shm_mq</title>

 <indexterm zone="test-shm-mq">
  <primary>test_shm_mq</primary>
 </indexterm>

<!-- 
 <para>
  <filename>test_shm_mq</> is an example of how to use dynamic shared memory
  and the shared memory message queue facilities to coordinate a user backend
  with the efforts of one or more background workers.  It is not intended to
  do anything useful on its own; rather, it is a demonstration of how these
  facilities can be used, and a unit test of those facilities.
 </para> 
-->
 <para>
  <filename>test_shm_mq</>是一个如何使用动态共享内存和共享内存消息队列工具的示例，
  协调有一个或多个后端进程的用户后台。它并不打算在它自身上做任何有用的事情；
  而是，作为一个如何使用这些工具的示范，也是这些工具的一个单元测试。
 </para>

<!--
  <para>
  The function is this extension send the same message repeatedly through
  a loop of processes.  The message payload, the size of the message queue
  through which it is sent, and the number of processes in the loop are
  configurable.  At the end, the message may be verified to ensure that it
  has not been corrupted in transmission.
 </para>
 -->
  <para>
  这个扩展函数在一个循环进程中重复的发送相同的消息。消息负载、发送的消息队列大小、
  在循环中可配置的进程号。在末尾，可能会验证消息，以确保它在传输中没有损坏。
 </para>

 <sect2>
  <!--
  <title>Functions</title>
  -->
  <title>函数</title>

<synopsis>
test_shm_mq(queue_size int8, message text,
            repeat_count int4 default 1, num_workers int4 default 1)
    RETURNS void
</synopsis>

  <!--
  <para>
   This function sends and receives messages synchronously.  The user
   backend sends the provided message to the first background worker using
   a message queue of the given size.  The first background worker sends
   the message to the second background worker, if the number of workers
   is greater than one, and so forth.  Eventually, the last background
   worker sends the message back to the user backend.  If the repeat count
   is greater than one, the user backend then sends the message back to
   the first worker.  Once the message has been sent and received by all
   the coordinating processes a number of times equal to the repeat count,
   the user backend verifies that the message finally received matches the
   one originally sent and throws an error if not.
  </para>
  -->
  <para>
   这个函数同步的发送和接收消息。用户后台使用给定大小的消息队列发送提供的消息到第一个后端进程。
   第一个后端进程发送该消息到第二个后端进程，如果进程数量大于一，等等。
   最终，最后一个后端进程发送该消息回到用户后台。如果重复计数大于一，
   那么用户后台发送该消息回到第一个进程。一旦所有协调进程发送并接受该消息的次数等于重复计数，
   用户后台验证最后接收到的消息匹配最初发送的消息，如果不匹配，则抛出一个错误。
   </para>

<synopsis>
test_shm_mq_pipelined(queue_size int8, message text,
                      repeat_count int4 default 1, num_workers int4 default 1,
                      verify bool default true)
    RETURNS void
</synopsis>

<!-- 
  <para>
   This function sends the same message multiple times, as specified by the
   repeat count, to the first background worker using a queue of the given
   size.  These messages are then forwarded to each background worker in
   turn, in each case using a queue of the given size.  Finally, the last
   background worker sends the messages back to the user backend.  The user
   backend uses non-blocking sends and receives, so that it may begin receiving
   copies of the message before it has finished sending all copies of the
   message.  The <literal>verify</> argument controls whether or not the
   received copies are checked against the message that was sent.  (This
   takes nontrivial time so it may be useful to disable it for benchmarking
   purposes.)
  </para> 
  -->
   <para>
   这个函数多次发送同一个消息，由重复计数声明次数，到第一个后端进程，
   使用给定大小的序列。这些消息然后依次发送到每个后端进程，使用给定大小的序列。
   最终，最后一个后端进程发送消息到用户后台。用户后台使用非阻塞的发送和接收，
   这样它可以在发送完所有该消息的拷贝之前，就开始接收该消息的拷贝。
   <literal>verify</>参数控制接收到的拷贝是否与发送的消息对照。
   （它花费大量的时间，所以为了基准测试的目的，禁用它会非常有用。）
  </para>

 </sect2>
</sect1>
