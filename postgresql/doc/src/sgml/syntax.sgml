<!-- doc/src/sgml/syntax.sgml -->

<chapter id="sql-syntax">
<!--==========================orignal english content==========================
 <title>SQL Syntax</title>
____________________________________________________________________________-->
 <title>SQL语法</title>

<!--==========================orignal english content==========================
 <indexterm zone="sql-syntax">
  <primary>syntax</primary>
  <secondary>SQL</secondary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="sql-syntax">
  <primary>syntax</primary>
  <secondary>SQL</secondary>
 </indexterm>

<!--==========================orignal english content==========================
 <para>
  This chapter describes the syntax of SQL.  It forms the foundation
  for understanding the following chapters which will go into detail
  about how SQL commands are applied to define and modify data.
 </para>
____________________________________________________________________________-->
 <para>
  这一章描述了SQL的语法。它构成了理解后续具体介绍如何使用SQL定义和修改数据的章节的基础 。
 </para>

<!--==========================orignal english content==========================
 <para>
  We also advise users who are already familiar with SQL to read this
  chapter carefully because it contains several rules and concepts that
  are implemented inconsistently among SQL databases or that are
  specific to <productname>PostgreSQL</productname>.
 </para>
____________________________________________________________________________-->
 <para>
  我们同时建议已经熟悉SQL的用户仔细阅读本章，因为本章包含一些在SQL数据库中实现得不一致的以及<productname>PostgreSQL</productname>中特有的规则和概念。
 </para>

 <sect1 id="sql-syntax-lexical">
<!--==========================orignal english content==========================
  <title>Lexical Structure</title>
____________________________________________________________________________-->
  <title>词法结构</title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>token</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>token</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   SQL input consists of a sequence of
   <firstterm>commands</firstterm>.  A command is composed of a
   sequence of <firstterm>tokens</firstterm>, terminated by a
   semicolon (<quote>;</quote>).  The end of the input stream also
   terminates a command.  Which tokens are valid depends on the syntax
   of the particular command.
  </para>
____________________________________________________________________________-->
  <para>
   SQL输入由一个<firstterm>命令</firstterm>序列组成。一个命令由一个<firstterm>记号</firstterm>的序列构成，并由一个分号（<quote>;</quote>）终结。输入流的末端也会标志一个命令的结束。具体哪些记号是合法的与具体命令的语法有关。
  </para>

<!--==========================orignal english content==========================
  <para>
   A token can be a <firstterm>key word</firstterm>, an
   <firstterm>identifier</firstterm>, a <firstterm>quoted
   identifier</firstterm>, a <firstterm>literal</firstterm> (or
   constant), or a special character symbol.  Tokens are normally
   separated by whitespace (space, tab, newline), but need not be if
   there is no ambiguity (which is generally only the case if a
   special character is adjacent to some other token type).
  </para>
____________________________________________________________________________-->
  <para>
   一个记号可以是一个<firstterm>关键词</firstterm>、一个<firstterm>标识符</firstterm>、一个<firstterm>带引号的标识符</firstterm>、一个<firstterm>literal</firstterm>（或常量）或者一个特殊字符符号。记号通常以空白（空格、制表符、新行）来分隔，但在无歧义时并不强制要求如此（唯一的例子是一个特殊字符紧挨着其他记号）。
  </para>

<!--==========================orignal english content==========================
   <para>
    For example, the following is (syntactically) valid SQL input:
<programlisting>
SELECT * FROM MY_TABLE;
UPDATE MY_TABLE SET A = 5;
INSERT INTO MY_TABLE VALUES (3, 'hi there');
</programlisting>
    This is a sequence of three commands, one per line (although this
    is not required; more than one command can be on a line, and
    commands can usefully be split across lines).
   </para>
____________________________________________________________________________-->
   <para>
    例如，下面是一个（语法上）合法的SQL输入：
<programlisting>
SELECT * FROM MY_TABLE;
UPDATE MY_TABLE SET A = 5;
INSERT INTO MY_TABLE VALUES (3, 'hi there');
</programlisting>
    这是一个由三个命令组成的序列，每一行一个命令（尽管这不是必须地，在同一行中可以有超过一个命令，而且命令还可以被跨行分割）。
   </para>

<!--==========================orignal english content==========================
  <para>
   Additionally, <firstterm>comments</firstterm> can occur in SQL
   input.  They are not tokens, they are effectively equivalent to
   whitespace.
  </para>
____________________________________________________________________________-->
  <para>
   另外，<firstterm>注释</firstterm>也可以出现在SQL输入中。它们不是记号，它们和空白完全一样。
  </para>

<!--==========================orignal english content==========================
  <para>
   The SQL syntax is not very consistent regarding what tokens
   identify commands and which are operands or parameters.  The first
   few tokens are generally the command name, so in the above example
   we would usually speak of a <quote>SELECT</quote>, an
   <quote>UPDATE</quote>, and an <quote>INSERT</quote> command.  But
   for instance the <command>UPDATE</command> command always requires
   a <token>SET</token> token to appear in a certain position, and
   this particular variation of <command>INSERT</command> also
   requires a <token>VALUES</token> in order to be complete.  The
   precise syntax rules for each command are described in <xref linkend="reference">.
  </para>
____________________________________________________________________________-->
  <para>
   根据标识命令、操作符、参数的记号不同，SQL的语法不很一致。最前面的一些记号通常是命令名，因此在上面的例子中我们通常会说一个<quote>SELECT</quote>、一个<quote>UPDATE</quote>和一个<quote>INSERT</quote>命令。但是例如<command>UPDATE</command>命令总是要求一个<token>SET</token>记号出现在一个特定位置，而<command>INSERT</command>则要求一个<token>VALUES</token>来完成命令。每个命令的精确语法规则在<xref linkend="reference">中介绍。
  </para>

  <sect2 id="sql-syntax-identifiers">
<!--==========================orignal english content==========================
   <title>Identifiers and Key Words</title>
____________________________________________________________________________-->
   <title>标识符和关键词</title>

<!--==========================orignal english content==========================
   <indexterm zone="sql-syntax-identifiers">
    <primary>identifier</primary>
    <secondary>syntax of</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="sql-syntax-identifiers">
    <primary>identifier</primary>
    <secondary>syntax of</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="sql-syntax-identifiers">
    <primary>name</primary>
    <secondary>syntax of</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="sql-syntax-identifiers">
    <primary>name</primary>
    <secondary>syntax of</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="sql-syntax-identifiers">
    <primary>key word</primary>
    <secondary>syntax of</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="sql-syntax-identifiers">
    <primary>key word</primary>
    <secondary>syntax of</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    Tokens such as <token>SELECT</token>, <token>UPDATE</token>, or
    <token>VALUES</token> in the example above are examples of
    <firstterm>key words</firstterm>, that is, words that have a fixed
    meaning in the SQL language.  The tokens <token>MY_TABLE</token>
    and <token>A</token> are examples of
    <firstterm>identifiers</firstterm>.  They identify names of
    tables, columns, or other database objects, depending on the
    command they are used in.  Therefore they are sometimes simply
    called <quote>names</quote>.  Key words and identifiers have the
    same lexical structure, meaning that one cannot know whether a
    token is an identifier or a key word without knowing the language.
    A complete list of key words can be found in <xref
    linkend="sql-keywords-appendix">.
   </para>
____________________________________________________________________________-->
   <para>
    上例中的<token>SELECT</token>、<token>UPDATE</token>或<token>VALUES</token>记号是<firstterm>关键词</firstterm>的例子，即SQL语言中具有特定意义的词。记号<token>MY_TABLE</token>和<token>A</token>则是<firstterm>标识符</firstterm>的例子。它们标识表、列或者其他数据库对象的名字，取决于使用它们的命令。因此它们有时也被简称为<quote>名字</quote>。关键词和标识符具有相同的词法结构，这意味着我们无法在没有语言知识的前提下区分一个标识符和关键词。一个关键词的完整列表可以在<xref
    linkend="sql-keywords-appendix">中找到。
   </para>

<!--==========================orignal english content==========================
   <para>
    SQL identifiers and key words must begin with a letter
    (<literal>a</literal>-<literal>z</literal>, but also letters with
    diacritical marks and non-Latin letters) or an underscore
    (<literal>_</literal>).  Subsequent characters in an identifier or
    key word can be letters, underscores, digits
    (<literal>0</literal>-<literal>9</literal>), or dollar signs
    (<literal>$</>).  Note that dollar signs are not allowed in identifiers
    according to the letter of the SQL standard, so their use might render
    applications less portable.
    The SQL standard will not define a key word that contains
    digits or starts or ends with an underscore, so identifiers of this
    form are safe against possible conflict with future extensions of the
    standard.
   </para>
____________________________________________________________________________-->
   <para>
    SQL标识符和关键词必须以一个字母（<literal>a</literal>-<literal>z</literal>，也可以是带变音符的字母和非拉丁字母）或一个下划线（_）开始。后续字符可以是字母、下划线（<literal>_</literal>）、数字（<literal>0</literal>-<literal>9</literal>）或美元符号（<literal>$</>）。注意根据SQL标准的字母规定，美元符号是不允许出现在标识符中的，因此它们的使用可能会降低应用的可移植性。SQL标准不会定义包含数字或者以下划线开头或结尾的关键词，因此这种形式的标识符不会与未来可能的标准扩展冲突 。
   </para>

<!--==========================orignal english content==========================
   <para>
    <indexterm><primary>identifier</primary><secondary>length</secondary></indexterm>
    The system uses no more than <symbol>NAMEDATALEN</symbol>-1
    bytes of an identifier; longer names can be written in
    commands, but they will be truncated.  By default,
    <symbol>NAMEDATALEN</symbol> is 64 so the maximum identifier
    length is 63 bytes. If this limit is problematic, it can be raised by
    changing the <symbol>NAMEDATALEN</symbol> constant in
    <filename>src/include/pg_config_manual.h</filename>.
   </para>
____________________________________________________________________________-->
   <para>
    <indexterm><primary>identifier</primary><secondary>length</secondary></indexterm>
    系统中一个标识符的长度不能超过 <symbol>NAMEDATALEN</symbol>-1 字节，在命令中可以写超过此长度的标识符，但是它们会被截断。默认情况下，<symbol>NAMEDATALEN</symbol> 的值为64，因此标识符的长度上限为63字节。如果这个限制有问题，可以在<filename>src/include/pg_config_manual.h</filename>中修改 <symbol>NAMEDATALEN</symbol> 常量。
   </para>

<!--==========================orignal english content==========================
   <para>
    <indexterm>
     <primary>case sensitivity</primary>
     <secondary>of SQL commands</secondary>
    </indexterm>
    Key words and unquoted identifiers are case insensitive.  Therefore:
<programlisting>
UPDATE MY_TABLE SET A = 5;
</programlisting>
    can equivalently be written as:
<programlisting>
uPDaTE my_TabLE SeT a = 5;
</programlisting>
    A convention often used is to write key words in upper
    case and names in lower case, e.g.:
<programlisting>
UPDATE my_table SET a = 5;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    <indexterm>
     <primary>case sensitivity</primary>
     <secondary>of SQL commands</secondary>
    </indexterm>
    关键词和不被引号修饰的标识符是大小写不敏感的。因此：
<programlisting>
UPDATE MY_TABLE SET A = 5;
</programlisting>
    可以等价地写成：
<programlisting>
uPDaTE my_TabLE SeT a = 5;
</programlisting>
    一个常见的习惯是将关键词写成大写，而名称写成小写，例如：
<programlisting>
UPDATE my_table SET a = 5;
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    <indexterm>
     <primary>quotation marks</primary>
     <secondary>and identifiers</secondary>
    </indexterm>
    There is a second kind of identifier:  the <firstterm>delimited
    identifier</firstterm> or <firstterm>quoted
    identifier</firstterm>.  It is formed by enclosing an arbitrary
    sequence of characters in double-quotes
    (<literal>"</literal>). <!-&minus; " font-lock mania -&minus;> A delimited
    identifier is always an identifier, never a key word.  So
    <literal>"select"</literal> could be used to refer to a column or
    table named <quote>select</quote>, whereas an unquoted
    <literal>select</literal> would be taken as a key word and
    would therefore provoke a parse error when used where a table or
    column name is expected.  The example can be written with quoted
    identifiers like this:
<programlisting>
UPDATE "my_table" SET "a" = 5;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    <indexterm>
     <primary>quotation marks</primary>
     <secondary>and identifiers</secondary>
    </indexterm>
    这里还有第二种形式的标识符：<firstterm>受限标识符</firstterm>或<firstterm>被引号修饰的标识符</firstterm>。它是由双引号（<literal>"</literal>）包围的一个任意字符序列。一个受限标识符总是一个标识符而不会是一个关键字。因此<literal>"select"</literal>可以用于引用一个名为<quote>select</quote>的列或者表，而一个没有引号修饰的<literal>select</literal>则会被当作一个关键词，从而在本应使用表或列名的地方引起解析错误。在上例中使用受限标识符的例子如下：
<programlisting>
UPDATE "my_table" SET "a" = 5;
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    Quoted identifiers can contain any character, except the character
    with code zero.  (To include a double quote, write two double quotes.)
    This allows constructing table or column names that would
    otherwise not be possible, such as ones containing spaces or
    ampersands.  The length limitation still applies.
   </para>
____________________________________________________________________________-->
   <para>
    受限标识符可以包含任何字符，除了代码为0的字符（如果要包含一个双引号，则写两个双引号）。这使得可以构建原本不被允许的表或列的名称，例如包含空格或花号的名字。但是长度限制依然有效。
   </para>

<!--==========================orignal english content==========================
   <indexterm>
     <primary>Unicode escape</primary>
     <secondary>in identifiers</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
     <primary>Unicode escape</primary>
     <secondary>in identifiers</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    A variant of quoted
    identifiers allows including escaped Unicode characters identified
    by their code points.  This variant starts
    with <literal>U&amp;</literal> (upper or lower case U followed by
    ampersand) immediately before the opening double quote, without
    any spaces in between, for example <literal>U&amp;"foo"</literal>.
    (Note that this creates an ambiguity with the
    operator <literal>&amp;</literal>.  Use spaces around the operator to
    avoid this problem.)  Inside the quotes, Unicode characters can be
    specified in escaped form by writing a backslash followed by the
    four-digit hexadecimal code point number or alternatively a
    backslash followed by a plus sign followed by a six-digit
    hexadecimal code point number.  For example, the
    identifier <literal>"data"</literal> could be written as
<programlisting>
U&amp;"d\0061t\+000061"
</programlisting>
    The following less trivial example writes the Russian
    word <quote>slon</quote> (elephant) in Cyrillic letters:
<programlisting>
U&amp;"\0441\043B\043E\043D"
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    一种受限标识符的变体允许包括转义的用代码点标识的Unicode字符。这种变体以<literal>U&amp;</literal>（大写或小写U跟上一个花号）开始，后面紧跟双引号修饰的名称，两者之间没有任何空白，如<literal>U&amp;"foo"</literal>（注意这里与操作符<literal>&amp;</literal>似乎有一些混淆，但是在<literal>&amp;</literal>操作符周围使用空白避免了这个问题） 。在引号内，Unicode字符可以以转义的形式指定：反斜线接上4位16进制代码点号码或者反斜线和加号接上6位16进制代码点号码。例如，标识符<literal>"data"</literal>可以写成：
<programlisting>
U&amp;"d\0061t\+000061"
</programlisting>
    下面的例子用斯拉夫语字母写出了俄语单词 <quote>slon</quote>（大象）：
<programlisting>
U&amp;"\0441\043B\043E\043D"
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    If a different escape character than backslash is desired, it can
    be specified using
    the <literal>UESCAPE</literal><indexterm><primary>UESCAPE</primary></indexterm>
    clause after the string, for example:
<programlisting>
U&amp;"d!0061t!+000061" UESCAPE '!'
</programlisting>
    The escape character can be any single character other than a
    hexadecimal digit, the plus sign, a single quote, a double quote,
    or a whitespace character.  Note that the escape character is
    written in single quotes, not double quotes.
   </para>
____________________________________________________________________________-->
   <para>
    如果希望使用其他转义字符来代替反斜线，可以在字符串后使用<literal>UESCAPE</literal><indexterm><primary>UESCAPE</primary></indexterm>子句，例如：
<programlisting>
U&amp;"d!0061t!+000061" UESCAPE '!'
</programlisting>
    转义字符可以是除了16进制位、加号、单引号、双引号、空白字符之外的任意单个字符。注意转义字符是被写在单引号而不是双引号内。
   </para>

<!--==========================orignal english content==========================
   <para>
    To include the escape character in the identifier literally, write
    it twice.
   </para>
____________________________________________________________________________-->
   <para>
    为了在标识符中包括转义字符本身，将其写两次即可。
   </para>

<!--==========================orignal english content==========================
   <para>
    The Unicode escape syntax works only when the server encoding is
    <literal>UTF8</>.  When other server encodings are used, only code
    points in the ASCII range (up to <literal>\007F</literal>) can be
    specified.  Both the 4-digit and the 6-digit form can be used to
    specify UTF-16 surrogate pairs to compose characters with code
    points larger than U+FFFF, although the availability of the
    6-digit form technically makes this unnecessary.  (Surrogate
    pairs are not stored directly, but combined into a single
    code point that is then encoded in UTF-8.)
   </para>
____________________________________________________________________________-->
   <para>
    Unicode转义语法只有在服务器编码为<literal>UTF8</>时才起效。当使用其他服务器编码时，只有在ASCII范围内（最高到<literal>\007F</literal>）的编码点才能被使用。4位和6位形式都可以被用来定义UTF-16代理对来组成代码点大于U+FFFF的字符，尽管6位形式的存在使得这种做法变得不必要（代理对并不被直接存储，而是被被绑定到一个单独的代码点然后被编码到UTF-8）。
   </para>

<!--==========================orignal english content==========================
   <para>
    Quoting an identifier also makes it case-sensitive, whereas
    unquoted names are always folded to lower case.  For example, the
    identifiers <literal>FOO</literal>, <literal>foo</literal>, and
    <literal>"foo"</literal> are considered the same by
    <productname>PostgreSQL</productname>, but
    <literal>"Foo"</literal> and <literal>"FOO"</literal> are
    different from these three and each other.  (The folding of
    unquoted names to lower case in <productname>PostgreSQL</> is
    incompatible with the SQL standard, which says that unquoted names
    should be folded to upper case.  Thus, <literal>foo</literal>
    should be equivalent to <literal>"FOO"</literal> not
    <literal>"foo"</literal> according to the standard.  If you want
    to write portable applications you are advised to always quote a
    particular name or never quote it.)
   </para>
____________________________________________________________________________-->
   <para>
    将一个标识符变得受限同时也使它变成大小写敏感的，反之非受限名称总是被转换成小写形 式。例如，标识符<literal>FOO</literal>、<literal>foo</literal>和<literal>"foo"</literal>在<productname>PostgreSQL</productname>中被认为是相同的，而<literal>"Foo"</literal>和<literal>"FOO"</literal>则互 不相同且也不同于前面三个标识符（<productname>PostgreSQL</>将非受限名字转换为小写形式与SQL标准是不兼容 
的，SQL标准中要求将非受限名称转换为大写形式。这样根据标准， <literal>foo</literal>应该和 <literal>"FOO"</literal>而不是<literal>"foo"</literal>相同。如果希望写一个可移植的应用，我们应该总是用引号修饰一个特定名字或者 从不使用 引号修饰）。
   </para>
  </sect2>


  <sect2 id="sql-syntax-constants">
<!--==========================orignal english content==========================
   <title>Constants</title>
____________________________________________________________________________-->
   <title>常量</title>

<!--==========================orignal english content==========================
   <indexterm zone="sql-syntax-constants">
    <primary>constant</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="sql-syntax-constants">
    <primary>constant</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    There are three kinds of <firstterm>implicitly-typed
    constants</firstterm> in <productname>PostgreSQL</productname>:
    strings, bit strings, and numbers.
    Constants can also be specified with explicit types, which can
    enable more accurate representation and more efficient handling by
    the system. These alternatives are discussed in the following
    subsections.
   </para>
____________________________________________________________________________-->
   <para>
    在<productname>PostgreSQL</productname>中有三种<firstterm>隐式类型常量</firstterm>：字符串、位串和数字。常量也可以被指定显示类型，这可以使得它被更精确地展示以及更有效地处理。这些选择将会在后续小节中讨论。
   </para>

   <sect3 id="sql-syntax-strings">
<!--==========================orignal english content==========================
    <title>String Constants</title>
____________________________________________________________________________-->
    <title>字符串常量</title>

<!--==========================orignal english content==========================
    <indexterm zone="sql-syntax-strings">
     <primary>character string</primary>
     <secondary>constant</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm zone="sql-syntax-strings">
     <primary>character string</primary>
     <secondary>constant</secondary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     <indexterm>
      <primary>quotation marks</primary>
      <secondary>escaping</secondary>
     </indexterm>
     A string constant in SQL is an arbitrary sequence of characters
     bounded by single quotes (<literal>'</literal>), for example
     <literal>'This is a string'</literal>.  To include
     a single-quote character within a string constant,
     write two adjacent single quotes, e.g.,
     <literal>'Dianne''s horse'</literal>.
     Note that this is <emphasis>not</> the same as a double-quote
     character (<literal>"</>). <!-&minus; font-lock sanity: " -&minus;>
    </para>
____________________________________________________________________________-->
    <para>
     <indexterm>
      <primary>quotation marks</primary>
      <secondary>escaping</secondary>
     </indexterm>
     
     在SQL中，一个字符串常量是一个由单引号（<literal>'</literal>）包围的任意字符序列，例如<literal>'This is a string'</literal>。为了在一个字符串中包括一个单引号，可以写两个相连的单引号，例如<literal>'Dianne''s horse'</literal>。注意这和一个双引号（<literal>"</>）<emphasis>不</>同。
    </para>

<!--==========================orignal english content==========================
    <para>
     Two string constants that are only separated by whitespace
     <emphasis>with at least one newline</emphasis> are concatenated
     and effectively treated as if the string had been written as one
     constant.  For example:
<programlisting>
SELECT 'foo'
'bar';
</programlisting>
     is equivalent to:
<programlisting>
SELECT 'foobar';
</programlisting>
     but:
<programlisting>
SELECT 'foo'      'bar';
</programlisting>
     is not valid syntax.  (This slightly bizarre behavior is specified
     by <acronym>SQL</acronym>; <productname>PostgreSQL</productname> is
     following the standard.)
    </para>
____________________________________________________________________________-->
    <para>
     两个只由空白及<emphasis>至少一个新行</emphasis>分隔的字符串常量会被连接在一起，并且将作为一个写在一起的字符串常量来对待。例如：
<programlisting>
SELECT 'foo'
'bar';
</programlisting>
     等同于：
<programlisting>
SELECT 'foobar';
</programlisting>
     但是：
<programlisting>
SELECT 'foo'      'bar';
</programlisting>
     则不是合法的语法（这种有些奇怪的行为是<acronym>SQL</acronym>指定的，<productname>PostgreSQL</productname>遵循了该标准）。
    </para>
   </sect3>

   <sect3 id="sql-syntax-strings-escape">
<!--==========================orignal english content==========================
    <title>String Constants with C-style Escapes</title>
____________________________________________________________________________-->
    <title>C风格转义的字符串常量</title>

<!--==========================orignal english content==========================
     <indexterm zone="sql-syntax-strings-escape">
      <primary>escape string syntax</primary>
     </indexterm>
____________________________________________________________________________-->
     <indexterm zone="sql-syntax-strings-escape">
      <primary>escape string syntax</primary>
     </indexterm>
<!--==========================orignal english content==========================
     <indexterm zone="sql-syntax-strings-escape">
      <primary>backslash escapes</primary>
     </indexterm>
____________________________________________________________________________-->
     <indexterm zone="sql-syntax-strings-escape">
      <primary>backslash escapes</primary>
     </indexterm>

<!--==========================orignal english content==========================
    <para>
     <productname>PostgreSQL</productname> also accepts <quote>escape</>
     string constants, which are an extension to the SQL standard.
     An escape string constant is specified by writing the letter
     <literal>E</literal> (upper or lower case) just before the opening single
     quote, e.g., <literal>E'foo'</>.  (When continuing an escape string
     constant across lines, write <literal>E</> only before the first opening
     quote.)
     Within an escape string, a backslash character (<literal>\</>) begins a
     C-like <firstterm>backslash escape</> sequence, in which the combination
     of backslash and following character(s) represent a special byte
     value, as shown in <xref linkend="sql-backslash-table">.
    </para>
____________________________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>也接受<quote>转义</>字符串常量，这也是SQL标准的一个扩展。一个转义字符串常量可以通过在开单引号前面写一个字母<literal>E</literal>（大写或小写形式）来指定，例如<literal>E'foo'</>（当一个转义字符串常量跨行时，只在第一个开引号之前写<literal>E</>）。在一个转义字符串内部，一个反斜线字符（<literal>\</>）会开始一个 C 风格的<firstterm>反斜线转义</>序列，在其中反斜线和后续字符的组合表示一个特殊的字节值（如<xref linkend="sql-backslash-table">中所示）。
    </para>

     <table id="sql-backslash-table">
<!--==========================orignal english content==========================
      <title>Backslash Escape Sequences</title>
____________________________________________________________________________-->
      <title>反斜线转义序列</title>
      <tgroup cols="2">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry>Backslash Escape Sequence</>
        <entry>Interpretation</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>反斜线转义序列</>
        <entry>解释</entry>
       </row>
      </thead>

      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>\b</literal></entry>
        <entry>backspace</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>\b</literal></entry>
        <entry>退格</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>\f</literal></entry>
        <entry>form feed</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>\f</literal></entry>
        <entry>换页</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>\n</literal></entry>
        <entry>newline</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>\n</literal></entry>
        <entry>换行</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>\r</literal></entry>
        <entry>carriage return</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>\r</literal></entry>
        <entry>回车</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>\t</literal></entry>
        <entry>tab</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>\t</literal></entry>
        <entry>制表符</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry>
         <literal>\<replaceable>o</replaceable></literal>,
         <literal>\<replaceable>oo</replaceable></literal>,
         <literal>\<replaceable>ooo</replaceable></literal>
         (<replaceable>o</replaceable> = 0 - 7)
        </entry>
        <entry>octal byte value</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>
         <literal>\<replaceable>o</replaceable></literal>,
         <literal>\<replaceable>oo</replaceable></literal>,
         <literal>\<replaceable>ooo</replaceable></literal>
         (<replaceable>o</replaceable> = 0 - 7)
        </entry>
        <entry>八进制字节值</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry>
         <literal>\x<replaceable>h</replaceable></literal>,
         <literal>\x<replaceable>hh</replaceable></literal>
         (<replaceable>h</replaceable> = 0 - 9, A - F)
        </entry>
        <entry>hexadecimal byte value</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>
         <literal>\x<replaceable>h</replaceable></literal>,
         <literal>\x<replaceable>hh</replaceable></literal>
         (<replaceable>h</replaceable> = 0 - 9, A - F)
        </entry>
        <entry>十六进制字节值</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry>
         <literal>\u<replaceable>xxxx</replaceable></literal>,
         <literal>\U<replaceable>xxxxxxxx</replaceable></literal>
         (<replaceable>x</replaceable> = 0 - 9, A - F)
        </entry>
        <entry>16 or 32-bit hexadecimal Unicode character value</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>
         <literal>\u<replaceable>xxxx</replaceable></literal>,
         <literal>\U<replaceable>xxxxxxxx</replaceable></literal>
         (<replaceable>x</replaceable> = 0 - 9, A - F)
        </entry>
        <entry>16 或 32-位十六进制 Unicode 字符值</entry>
       </row>
      </tbody>
      </tgroup>
     </table>

<!--==========================orignal english content==========================
    <para>
     Any other
     character following a backslash is taken literally. Thus, to
     include a backslash character, write two backslashes (<literal>\\</>).
     Also, a single quote can be included in an escape string by writing
     <literal>\'</literal>, in addition to the normal way of <literal>''</>.
    </para>
____________________________________________________________________________-->
    <para>
     跟随在一个反斜线后面的任何其他字符被当做其字面意思。因此，要包括一个反斜线字符，请写两个反斜线（<literal>\\</>）。在一个转义字符串中包括一个单引号除了普通方法<literal>''</>之外，还可以写成<literal>\'</literal>。
    </para>

<!--==========================orignal english content==========================
    <para>
     It is your responsibility that the byte sequences you create,
     especially when using the octal or hexadecimal escapes, compose
     valid characters in the server character set encoding.  When the
     server encoding is UTF-8, then the Unicode escapes or the
     alternative Unicode escape syntax, explained
     in <xref linkend="sql-syntax-strings-uescape">, should be used
     instead.  (The alternative would be doing the UTF-8 encoding by
     hand and writing out the bytes, which would be very cumbersome.)
    </para>
____________________________________________________________________________-->
    <para>
     你要负责保证你创建的字节序列由服务器字符集编码中合法的字符组成，特别是在使用八进制或十六进制转义时。如果服务器编码为 UTF-8，那么应该使用 Unicode 转义或替代的 Unicode 转义语法（在<xref linkend="sql-syntax-strings-uescape">中解释）。替代方案可能是手工写出 UTF-8 编码字节，这可能会非常麻烦。
    </para>

<!--==========================orignal english content==========================
    <para>
     The Unicode escape syntax works fully only when the server
     encoding is <literal>UTF8</>.  When other server encodings are
     used, only code points in the ASCII range (up
     to <literal>\u007F</>) can be specified.  Both the 4-digit and
     the 8-digit form can be used to specify UTF-16 surrogate pairs to
     compose characters with code points larger than U+FFFF, although
     the availability of the 8-digit form technically makes this
     unnecessary.  (When surrogate pairs are used when the server
     encoding is <literal>UTF8</>, they are first combined into a
     single code point that is then encoded in UTF-8.)
    </para>
____________________________________________________________________________-->
    <para>
     只有当服务器编码是<literal>UTF8</>时，Unicode 转义语法才能完全工作。当使用其他服务器编码时，只有在 ASCII 范围（低于<literal>\u007F</>）内的代码点能够被指定。4 位和 8 位形式都能被用来指定 UTF-16 代理对，用来组成代码点超过 U+FFFF 的字符，不过 8 位形式的可用从技术上使得这种做法不再是必须的（当服务器编码为<literal>UTF8</>并使用代理对时，它们首先被结合到一个单一代码点，然后会被用 UTF-8 编码）。
    </para>

    <caution>
<!--==========================orignal english content==========================
    <para>
     If the configuration parameter
     <xref linkend="guc-standard-conforming-strings"> is <literal>off</>,
     then <productname>PostgreSQL</productname> recognizes backslash escapes
     in both regular and escape string constants.  However, as of
     <productname>PostgreSQL</> 9.1, the default is <literal>on</>, meaning
     that backslash escapes are recognized only in escape string constants.
     This behavior is more standards-compliant, but might break applications
     which rely on the historical behavior, where backslash escapes
     were always recognized.  As a workaround, you can set this parameter
     to <literal>off</>, but it is better to migrate away from using backslash
     escapes.  If you need to use a backslash escape to represent a special
     character, write the string constant with an <literal>E</>.
    </para>
____________________________________________________________________________-->
    <para>
     如果配置参数<xref linkend="guc-standard-conforming-strings">为<literal>off</>，那么<productname>PostgreSQL</productname>对常规字符串常量和转义字符串常量中的反斜线转义都识别。不过，从<productname>PostgreSQL</> 9.1 开始，该参数的默认值为<literal>on</>，意味着只在转义字符串常量中识别反斜线转义。这种行为更兼容标准，但是可能打断依赖于历史行为（反斜线转义总是会被识别）的应用。作为一种变通，你可以设置该参数为<literal>off</>，但是最好迁移到符合新的行为。如果你需要使用一个反斜线转义来表示一个特殊字符，为该字符串常量写上一个<literal>E</>。
    </para>

<!--==========================orignal english content==========================
    <para>
     In addition to <varname>standard_conforming_strings</>, the configuration
     parameters <xref linkend="guc-escape-string-warning"> and
     <xref linkend="guc-backslash-quote"> govern treatment of backslashes
     in string constants.
    </para>
____________________________________________________________________________-->
    <para>
     在<varname>standard_conforming_strings</>之外，配置参数<xref linkend="guc-escape-string-warning">和<xref linkend="guc-backslash-quote">也决定了如何对待字符串常量中的反斜线。
    </para>
    </caution>

<!--==========================orignal english content==========================
    <para>
     The character with the code zero cannot be in a string constant.
    </para>
____________________________________________________________________________-->
    <para>
     代码零的字符不能出现在一个字符串常量中。
    </para>
   </sect3>

   <sect3 id="sql-syntax-strings-uescape">
<!--==========================orignal english content==========================
    <title>String Constants with Unicode Escapes</title>
____________________________________________________________________________-->
    <title>带有 Unicode 转义的字符串常量</title>

<!--==========================orignal english content==========================
    <indexterm  zone="sql-syntax-strings-uescape">
     <primary>Unicode escape</primary>
     <secondary>in string constants</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm  zone="sql-syntax-strings-uescape">
     <primary>Unicode escape</primary>
     <secondary>in string constants</secondary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     <productname>PostgreSQL</productname> also supports another type
     of escape syntax for strings that allows specifying arbitrary
     Unicode characters by code point.  A Unicode escape string
     constant starts with <literal>U&amp;</literal> (upper or lower case
     letter U followed by ampersand) immediately before the opening
     quote, without any spaces in between, for
     example <literal>U&amp;'foo'</literal>.  (Note that this creates an
     ambiguity with the operator <literal>&amp;</literal>.  Use spaces
     around the operator to avoid this problem.)  Inside the quotes,
     Unicode characters can be specified in escaped form by writing a
     backslash followed by the four-digit hexadecimal code point
     number or alternatively a backslash followed by a plus sign
     followed by a six-digit hexadecimal code point number.  For
     example, the string <literal>'data'</literal> could be written as
<programlisting>
U&amp;'d\0061t\+000061'
</programlisting>
     The following less trivial example writes the Russian
     word <quote>slon</quote> (elephant) in Cyrillic letters:
<programlisting>
U&amp;'\0441\043B\043E\043D'
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>也支持另一种类型的字符串转义语法，它允许用代码点指定任意 Unicode 字符。一个 Unicode 转义字符串常量开始于<literal>U&amp;</literal>（大写或小写形式的字母 U，后跟花号），后面紧跟着开引号，之间没有任何空白，例如<literal>U&amp;'foo'</literal>（注意这产生了与操作符<literal>&amp;</literal>的混淆。在操作符周围使用空白来避免这个问题）。在引号内，Unicode 字符可以通过写一个后跟 4 位十六进制代码点编号或者一个前面有加号的 6 位十六进制代码点编号的反斜线来指定。例如，字符串<literal>'data'</literal>可以被写为
<programlisting>
U&amp;'d\0061t\+000061'
</programlisting>
     下面的例子用斯拉夫字母写出了俄语的单词<quote>slon</quote>（大象）：
<programlisting>
U&amp;'\0441\043B\043E\043D'
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     If a different escape character than backslash is desired, it can
     be specified using
     the <literal>UESCAPE</literal><indexterm><primary>UESCAPE</primary></indexterm>
     clause after the string, for example:
<programlisting>
U&amp;'d!0061t!+000061' UESCAPE '!'
</programlisting>
     The escape character can be any single character other than a
     hexadecimal digit, the plus sign, a single quote, a double quote,
     or a whitespace character.
    </para>
____________________________________________________________________________-->
    <para>
     如果想要一个不是反斜线的转义字符，可以在字符串之后使用<literal>UESCAPE</literal><indexterm><primary>UESCAPE</primary></indexterm>子句来指定，例如：
<programlisting>
U&amp;'d!0061t!+000061' UESCAPE '!'
</programlisting>
     转义字符可以是出一个十六进制位、加号、单引号、双引号或空白字符之外的任何单一字符。
    </para>

<!--==========================orignal english content==========================
    <para>
     The Unicode escape syntax works only when the server encoding is
     <literal>UTF8</>.  When other server encodings are used, only
     code points in the ASCII range (up to <literal>\007F</literal>)
     can be specified.  Both the 4-digit and the 6-digit form can be
     used to specify UTF-16 surrogate pairs to compose characters with
     code points larger than U+FFFF, although the availability of the
     6-digit form technically makes this unnecessary.  (When surrogate
     pairs are used when the server encoding is <literal>UTF8</>, they
     are first combined into a single code point that is then encoded
     in UTF-8.)
    </para>
____________________________________________________________________________-->
    <para>
     只有当服务器编码是<literal>UTF8</>时，Unicode 转义语法才能完全工作。当使用其他服务器编码时，只有在 ASCII 范围（低于<literal>\u007F</>）内的代码点能够被指定。4 位和 8 位形式都能被用来指定 UTF-16 代理对，用来组成代码点超过 U+FFFF 的字符，不过 8 位形式的可用从技术上使得这种做法不再是必须的（当服务器编码为<literal>UTF8</>并使用代理对时，它们首先被结合到一个单一代码点，然后会被用 UTF-8 编码）。
    </para>

<!--==========================orignal english content==========================
    <para>
     Also, the Unicode escape syntax for string constants only works
     when the configuration
     parameter <xref linkend="guc-standard-conforming-strings"> is
     turned on.  This is because otherwise this syntax could confuse
     clients that parse the SQL statements to the point that it could
     lead to SQL injections and similar security issues.  If the
     parameter is set to off, this syntax will be rejected with an
     error message.
    </para>
____________________________________________________________________________-->
    <para>
     还有，只有当配置参数<xref linkend="guc-standard-conforming-strings">被打开时，用于字符串常量的 Unicode 转义语法才能工作。这是因为否则这种语法将迷惑客户端中肯地解析 SQL 语句，进而会导致 SQL 注入以及类似的安全性问题。如果这个参数被设置为关闭，这种语法将被拒绝并且报告一个错误消息。
    </para>

<!--==========================orignal english content==========================
    <para>
     To include the escape character in the string literally, write it
     twice.
    </para>
____________________________________________________________________________-->
    <para>
     要在一个字符串中包括一个表示其字面意思的转义字符，把它写两次。
    </para>
   </sect3>

   <sect3 id="sql-syntax-dollar-quoting">
<!--==========================orignal english content==========================
    <title>Dollar-quoted String Constants</title>
____________________________________________________________________________-->
    <title>美元引用的字符串常量</title>

<!--==========================orignal english content==========================
     <indexterm>
      <primary>dollar quoting</primary>
     </indexterm>
____________________________________________________________________________-->
     <indexterm>
      <primary>dollar quoting</primary>
     </indexterm>

<!--==========================orignal english content==========================
    <para>
     While the standard syntax for specifying string constants is usually
     convenient, it can be difficult to understand when the desired string
     contains many single quotes or backslashes, since each of those must
     be doubled. To allow more readable queries in such situations,
     <productname>PostgreSQL</productname> provides another way, called
     <quote>dollar quoting</quote>, to write string constants.
     A dollar-quoted string constant
     consists of a dollar sign (<literal>$</literal>), an optional
     <quote>tag</quote> of zero or more characters, another dollar
     sign, an arbitrary sequence of characters that makes up the
     string content, a dollar sign, the same tag that began this
     dollar quote, and a dollar sign. For example, here are two
     different ways to specify the string <quote>Dianne's horse</>
     using dollar quoting:
<programlisting>
$$Dianne's horse$$
$SomeTag$Dianne's horse$SomeTag$
</programlisting>
     Notice that inside the dollar-quoted string, single quotes can be
     used without needing to be escaped.  Indeed, no characters inside
     a dollar-quoted string are ever escaped: the string content is always
     written literally.  Backslashes are not special, and neither are
     dollar signs, unless they are part of a sequence matching the opening
     tag.
    </para>
____________________________________________________________________________-->
    <para>
     虽然用于指定字符串常量的标准语法通常都很方便，但是当字符串中包含了很多单引号或反斜线时很难理解它，因为每一个都需要被双写。要在这种情形下允许可读性更好的查询，<productname>PostgreSQL</productname>提供了另一种被称为<quote>美元引用</quote>的方式来书写字符串常量。一个美元引用的字符串常量由一个美元符号（<literal>$</literal>）、一个可选的另个或更多字符的<quote>标签</quote>、另一个美元符号、一个构成字符串内容的任意字符序列、一个美元符号、开始这个美元引用的相同标签和一个美元符号组成。例如，这里有两种不同的方法使用美元引用指定字符串<quote>Dianne's horse</>：
<programlisting>
$$Dianne's horse$$
$SomeTag$Dianne's horse$SomeTag$
</programlisting>
     注意在美元引用字符串中，单引号可以在不被转义的情况下使用。事实上，在一个美元引用字符串中不需要对字符进行转义：字符串内容总是按其字面意思写出。反斜线不是特殊的，并且美元符号也不是特殊的，除非它们是匹配开标签的一个序列的一部分。
    </para>

<!--==========================orignal english content==========================
    <para>
     It is possible to nest dollar-quoted string constants by choosing
     different tags at each nesting level.  This is most commonly used in
     writing function definitions.  For example:
<programlisting>
$function$
BEGIN
    RETURN ($1 ~ $q$[\t\r\n\v\\]$q$);
END;
$function$
</programlisting>
     Here, the sequence <literal>$q$[\t\r\n\v\\]$q$</> represents a
     dollar-quoted literal string <literal>[\t\r\n\v\\]</>, which will
     be recognized when the function body is executed by
     <productname>PostgreSQL</>.  But since the sequence does not match
     the outer dollar quoting delimiter <literal>$function$</>, it is
     just some more characters within the constant so far as the outer
     string is concerned.
    </para>
____________________________________________________________________________-->
    <para>
     可以通过在每一个嵌套级别上选择不同的标签来嵌套美元引用字符串常量。这最常被用在编写函数定义上。例如：
<programlisting>
$function$
BEGIN
    RETURN ($1 ~ $q$[\t\r\n\v\\]$q$);
END;
$function$
</programlisting>
     这里，序列<literal>$q$[\t\r\n\v\\]$q$</>表示一个美元引用的文字串<literal>[\t\r\n\v\\]</>，当该函数体被<productname>PostgreSQL</>执行时它将被识别。但是因为该序列不匹配外层的美元引用的定界符<literal>$function$</>，它只是一些在外层字符串所关注的常量中的字符而已。
    </para>

<!--==========================orignal english content==========================
    <para>
     The tag, if any, of a dollar-quoted string follows the same rules
     as an unquoted identifier, except that it cannot contain a dollar sign.
     Tags are case sensitive, so <literal>$tag$String content$tag$</literal>
     is correct, but <literal>$TAG$String content$tag$</literal> is not.
    </para>
____________________________________________________________________________-->
    <para>
     一个美元引用字符串的标签（如果有）遵循一个未被引用标识符的相同规则，除了它不能包含一个美元符号之外。标签是大小写敏感的，因此<literal>$tag$String content$tag$</literal>是正确的，但是<literal>$TAG$String content$tag$</literal>不正确。
    </para>

<!--==========================orignal english content==========================
    <para>
     A dollar-quoted string that follows a keyword or identifier must
     be separated from it by whitespace; otherwise the dollar quoting
     delimiter would be taken as part of the preceding identifier.
    </para>
____________________________________________________________________________-->
    <para>
     一个跟着一个关键词或标识符的美元引用字符串必须用空白与之分隔开，否则美元引用定界符可能会被作为前面标识符的一部分。
    </para>

<!--==========================orignal english content==========================
    <para>
     Dollar quoting is not part of the SQL standard, but it is often a more
     convenient way to write complicated string literals than the
     standard-compliant single quote syntax.  It is particularly useful when
     representing string constants inside other constants, as is often needed
     in procedural function definitions.  With single-quote syntax, each
     backslash in the above example would have to be written as four
     backslashes, which would be reduced to two backslashes in parsing the
     original string constant, and then to one when the inner string constant
     is re-parsed during function execution.
    </para>
____________________________________________________________________________-->
    <para>
     美元引用不是 SQL 标准的一部分，但是在书写复杂字符串文字方面，它常常是一种比兼容标准的单引号语法更方便的方法。当要表示的字符串常量位于其他常量中时它特别有用，这种情况常常在过程函数定义中出现。如果用单引号语法，上一个例子中的每个反斜线将必须被写成四个反斜线，这在解析原始字符串常量时会被缩减到两个反斜线，并且接着在函数执行期间重新解析内层字符串常量时变成一个。
    </para>
   </sect3>

   <sect3 id="sql-syntax-bit-strings">
<!--==========================orignal english content==========================
    <title>Bit-string Constants</title>
____________________________________________________________________________-->
    <title>位串常量</title>

<!--==========================orignal english content==========================
    <indexterm zone="sql-syntax-bit-strings">
     <primary>bit string</primary>
     <secondary>constant</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm zone="sql-syntax-bit-strings">
     <primary>bit string</primary>
     <secondary>constant</secondary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     Bit-string constants look like regular string constants with a
     <literal>B</literal> (upper or lower case) immediately before the
     opening quote (no intervening whitespace), e.g.,
     <literal>B'1001'</literal>.  The only characters allowed within
     bit-string constants are <literal>0</literal> and
     <literal>1</literal>.
    </para>
____________________________________________________________________________-->
    <para>
     位串常量看起来像常规字符串常量在开引号之前（中间无空白）加了一个<literal>B</literal>（大写或小写形式），例如<literal>B'1001'</literal>。位串常量中允许的字符只有<literal>0</literal>和<literal>1</literal>。
    </para>

<!--==========================orignal english content==========================
    <para>
     Alternatively, bit-string constants can be specified in hexadecimal
     notation, using a leading <literal>X</literal> (upper or lower case),
     e.g., <literal>X'1FF'</literal>.  This notation is equivalent to
     a bit-string constant with four binary digits for each hexadecimal digit.
    </para>
____________________________________________________________________________-->
    <para>
     作为一种选择，位串常量可以用十六进制记号法指定，使用一个前导<literal>X</literal>（大写或小写形式）,例如<literal>X'1FF'</literal>。这种记号法等价于一个用四个二进制位取代每个十六进制位的位串常量。
    </para>

<!--==========================orignal english content==========================
    <para>
     Both forms of bit-string constant can be continued
     across lines in the same way as regular string constants.
     Dollar quoting cannot be used in a bit-string constant.
    </para>
____________________________________________________________________________-->
    <para>
     两种形式的位串常量可以以常规字符串常量相同的方式跨行继续。美元引用不能被用在位串常量中。
    </para>
   </sect3>

   <sect3 id="sql-syntax-constants-numeric">
<!--==========================orignal english content==========================
    <title>Numeric Constants</title>
____________________________________________________________________________-->
    <title>数字常量</title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>number</primary>
     <secondary>constant</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>number</primary>
     <secondary>constant</secondary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     Numeric constants are accepted in these general forms:
<synopsis>
<replaceable>digits</replaceable>
<replaceable>digits</replaceable>.<optional><replaceable>digits</replaceable></optional><optional>e<optional>+-</optional><replaceable>digits</replaceable></optional>
<optional><replaceable>digits</replaceable></optional>.<replaceable>digits</replaceable><optional>e<optional>+-</optional><replaceable>digits</replaceable></optional>
<replaceable>digits</replaceable>e<optional>+-</optional><replaceable>digits</replaceable>
</synopsis>
     where <replaceable>digits</replaceable> is one or more decimal
     digits (0 through 9).  At least one digit must be before or after the
     decimal point, if one is used.  At least one digit must follow the
     exponent marker (<literal>e</literal>), if one is present.
     There cannot be any spaces or other characters embedded in the
     constant.  Note that any leading plus or minus sign is not actually
     considered part of the constant; it is an operator applied to the
     constant.
    </para>
____________________________________________________________________________-->
    <para>
     在这些一般形式中可以接受数字常量：
<synopsis>
<replaceable>digits</replaceable>
<replaceable>digits</replaceable>.<optional><replaceable>digits</replaceable></optional><optional>e<optional>+-</optional><replaceable>digits</replaceable></optional>
<optional><replaceable>digits</replaceable></optional>.<replaceable>digits</replaceable><optional>e<optional>+-</optional><replaceable>digits</replaceable></optional>
<replaceable>digits</replaceable>e<optional>+-</optional><replaceable>digits</replaceable>
</synopsis>
     其中<replaceable>digits</replaceable>是一个或多个十进制数字（0 到 9）。如果使用了小数点，在小数点前面或后面必须至少有一个数字。如果存在一个指数标记（<literal>e</literal>），在其后必须跟着至少一个数字。在该常量中不能嵌入任何空白或其他字符。注意任何前导的加号或减号并不实际被考虑为常量的一部分，它是一个应用到该常量的操作符。
    </para>

<!--==========================orignal english content==========================
    <para>
     These are some examples of valid numeric constants:
<literallayout>
42
3.5
4.
.001
5e2
1.925e-3
</literallayout>
    </para>
____________________________________________________________________________-->
    <para>
     这些是合法数字常量的例子：
<literallayout>
42
3.5
4.
.001
5e2
1.925e-3
</literallayout>
    </para>

<!--==========================orignal english content==========================
    <para>
     <indexterm><primary>integer</primary></indexterm>
     <indexterm><primary>bigint</primary></indexterm>
     <indexterm><primary>numeric</primary></indexterm>
     A numeric constant that contains neither a decimal point nor an
     exponent is initially presumed to be type <type>integer</> if its
     value fits in type <type>integer</> (32 bits); otherwise it is
     presumed to be type <type>bigint</> if its
     value fits in type <type>bigint</> (64 bits); otherwise it is
     taken to be type <type>numeric</>.  Constants that contain decimal
     points and/or exponents are always initially presumed to be type
     <type>numeric</>.
    </para>
____________________________________________________________________________-->
    <para>
     <indexterm><primary>integer</primary></indexterm>
     <indexterm><primary>bigint</primary></indexterm>
     <indexterm><primary>numeric</primary></indexterm>
     如果一个不包含小数点和指数的数字常量的值适合类型<type>integer</>（32 位），它首先被假定为类型<type>integer</>。否则如果它的值适合类型<type>bigint</>（64 位），它被假定为类型<type>bigint</>。再否则它会被取做类型<type>numeric</>。包含小数点和/或指数的常量总是首先被假定为类型<type>numeric</>。
    </para>

<!--==========================orignal english content==========================
    <para>
     The initially assigned data type of a numeric constant is just a
     starting point for the type resolution algorithms.  In most cases
     the constant will be automatically coerced to the most
     appropriate type depending on context.  When necessary, you can
     force a numeric value to be interpreted as a specific data type
     by casting it.<indexterm><primary>type cast</primary></indexterm>
     For example, you can force a numeric value to be treated as type
     <type>real</> (<type>float4</>) by writing:

<programlisting>
REAL '1.23'  -&minus; string style
1.23::REAL   -&minus; PostgreSQL (historical) style
</programlisting>

     These are actually just special cases of the general casting
     notations discussed next.
    </para>
____________________________________________________________________________-->
    <para>
     一个数字常量初始指派的数据类型只是类型转换算法的一个开始点。在大部分情况中，常量将被根据上下文自动被强制到最合适的类型。必要时，你可以通过造型它来强制一个数字值被解释为一种指定数据类型。<indexterm><primary>type cast</primary></indexterm>例如，你可以这样强制一个数字值被当做类型<type>real</>（<type>float4</>）：

<programlisting>
REAL '1.23'  -- string style
1.23::REAL   -- PostgreSQL (historical) style
</programlisting>

     这些实际上只是接下来要讨论的一般造型记号的特例。
    </para>
   </sect3>

   <sect3 id="sql-syntax-constants-generic">
<!--==========================orignal english content==========================
    <title>Constants of Other Types</title>
____________________________________________________________________________-->
    <title>其他类型的常量</title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>data type</primary>
     <secondary>constant</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>data type</primary>
     <secondary>constant</secondary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     A constant of an <emphasis>arbitrary</emphasis> type can be
     entered using any one of the following notations:
<synopsis>
<replaceable>type</replaceable> '<replaceable>string</replaceable>'
'<replaceable>string</replaceable>'::<replaceable>type</replaceable>
CAST ( '<replaceable>string</replaceable>' AS <replaceable>type</replaceable> )
</synopsis>
     The string constant's text is passed to the input conversion
     routine for the type called <replaceable>type</replaceable>. The
     result is a constant of the indicated type.  The explicit type
     cast can be omitted if there is no ambiguity as to the type the
     constant must be (for example, when it is assigned directly to a
     table column), in which case it is automatically coerced.
    </para>
____________________________________________________________________________-->
    <para>
      一种<emphasis>任意</emphasis>类型的一个常量可以使用下列记号中的任意一种输入：
<synopsis>
<replaceable>type</replaceable> '<replaceable>string</replaceable>'
'<replaceable>string</replaceable>'::<replaceable>type</replaceable>
CAST ( '<replaceable>string</replaceable>' AS <replaceable>type</replaceable> )
</synopsis>
     字符串常量的文本被传递到名为<replaceable>type</replaceable>的类型的输入转换例程中。其结果是指定类型的一个常量。如果对该常量的类型没有歧义（例如，当它被直接指派给一个表列时），显式类型造型可以被忽略，在那种情况下它会被自动强制。
    </para>

<!--==========================orignal english content==========================
    <para>
     The string constant can be written using either regular SQL
     notation or dollar-quoting.
    </para>
____________________________________________________________________________-->
    <para>
     字符串常量可以使用常规 SQL 记号或美元引用书写。
    </para>

<!--==========================orignal english content==========================
    <para>
     It is also possible to specify a type coercion using a function-like
     syntax:
<synopsis>
<replaceable>typename</replaceable> ( '<replaceable>string</replaceable>' )
</synopsis>
     but not all type names can be used in this way; see <xref
     linkend="sql-syntax-type-casts"> for details.
    </para>
____________________________________________________________________________-->
    <para>
     也可以使用一个类似函数的语法来指定一个类型强制：
<synopsis>
<replaceable>typename</replaceable> ( '<replaceable>string</replaceable>' )
</synopsis>
     但是并非所有类型名都可以用在这种方法中，详见<xref linkend="sql-syntax-type-casts">。
    </para>

<!--==========================orignal english content==========================
    <para>
     The <literal>::</literal>, <literal>CAST()</literal>, and
     function-call syntaxes can also be used to specify run-time type
     conversions of arbitrary expressions, as discussed in <xref
     linkend="sql-syntax-type-casts">.  To avoid syntactic ambiguity, the
     <literal><replaceable>type</> '<replaceable>string</>'</literal>
     syntax can only be used to specify the type of a simple literal constant.
     Another restriction on the
     <literal><replaceable>type</> '<replaceable>string</>'</literal>
     syntax is that it does not work for array types; use <literal>::</literal>
     or <literal>CAST()</literal> to specify the type of an array constant.
    </para>
____________________________________________________________________________-->
    <para>
     如<xref linkend="sql-syntax-type-casts">中讨论的，<literal>::</literal>、<literal>CAST()</literal>以及函数调用语法也可以被用来指定任意表达式的运行时类型转换。要避免语法歧义，<literal><replaceable>type</> '<replaceable>string</>'</literal>语法只能被用来指定简单文字常量的类型。<literal><replaceable>type</> '<replaceable>string</>'</literal>语法上的另一个限制是它无法对数组类型工作，指定一个数组常量的类型可使用<literal>::</literal>或<literal>CAST()</literal>。
    </para>

<!--==========================orignal english content==========================
    <para>
     The <literal>CAST()</> syntax conforms to SQL.  The
     <literal><replaceable>type</> '<replaceable>string</>'</literal>
     syntax is a generalization of the standard: SQL specifies this syntax only
     for a few data types, but <productname>PostgreSQL</productname> allows it
     for all types.  The syntax with
     <literal>::</literal> is historical <productname>PostgreSQL</productname>
     usage, as is the function-call syntax.
    </para>
____________________________________________________________________________-->
    <para>
     <literal>CAST()</>语法符合 SQL。<literal><replaceable>type</> '<replaceable>string</>'</literal>语法是该标准的一般化：SQL 指定这种语法只用于一些数据类型，但是<productname>PostgreSQL</productname>允许它用于所有类型。带有<literal>::</literal>的语法是<productname>PostgreSQL</productname>的历史用法，就像函数调用语法一样。
    </para>
   </sect3>
  </sect2>

  <sect2 id="sql-syntax-operators">
<!--==========================orignal english content==========================
   <title>Operators</title>
____________________________________________________________________________-->
   <title>操作符</title>

<!--==========================orignal english content==========================
   <indexterm zone="sql-syntax-operators">
    <primary>operator</primary>
    <secondary>syntax</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="sql-syntax-operators">
    <primary>operator</primary>
    <secondary>syntax</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    An operator name is a sequence of up to <symbol>NAMEDATALEN</symbol>-1
    (63 by default) characters from the following list:
<literallayout>
+ - * / &lt; &gt; = ~ ! @ # % ^ &amp; | ` ?
</literallayout>

    There are a few restrictions on operator names, however:
    <itemizedlist>
     <listitem>
      <para>
       <literal>-&minus;</literal> and <literal>/*</literal> cannot appear
       anywhere in an operator name, since they will be taken as the
       start of a comment.
      </para>
     </listitem>

     <listitem>
      <para>
       A multiple-character operator name cannot end in <literal>+</> or <literal>-</>,
       unless the name also contains at least one of these characters:
<literallayout>
~ ! @ # % ^ &amp; | ` ?
</literallayout>
       For example, <literal>@-</literal> is an allowed operator name,
       but <literal>*-</literal> is not.  This restriction allows
       <productname>PostgreSQL</productname> to parse SQL-compliant
       queries without requiring spaces between tokens.
      </para>
     </listitem>
    </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    一个操作符名是最多<symbol>NAMEDATALEN</symbol>-1（默认为 63）的一个字符序列，其中的字符来自下面的列表：
<literallayout>
+ - * / &lt; &gt; = ~ ! @ # % ^ &amp; | ` ?
</literallayout>

    不过，在操作符名上有一些限制：
    <itemizedlist>
     <listitem>
      <para>
       <literal>--</literal> 和 <literal>/*</literal>不能在一个操作符名的任何地方出现，因为它们将被作为一段注释的开始。
      </para>
     </listitem>

     <listitem>
      <para>
       一个多字符操作符名不能以<literal>+</>或<literal>-</>结尾，除非该名称也至少包含这些字符中的一个：
<literallayout>
~ ! @ # % ^ &amp; | ` ?
</literallayout>
       例如，<literal>@-</literal>是一个被允许的操作符名，但<literal>*-</literal>不是。这些限制允许<productname>PostgreSQL</productname>解析 SQL 兼容的查询而不需要在记号之间有空格。
      </para>
     </listitem>
    </itemizedlist>
   </para>

<!--==========================orignal english content==========================
   <para>
    When working with non-SQL-standard operator names, you will usually
    need to separate adjacent operators with spaces to avoid ambiguity.
    For example, if you have defined a left unary operator named <literal>@</literal>,
    you cannot write <literal>X*@Y</literal>; you must write
    <literal>X* @Y</literal> to ensure that
    <productname>PostgreSQL</productname> reads it as two operator names
    not one.
   </para>
____________________________________________________________________________-->
   <para>
    当使用非 SQL 标准的操作符名时，你通常需要用空格分隔相邻的操作符来避免歧义。例如，如果你定义了一个名为<literal>@</literal>的左一元操作符，你不能写<literal>X*@Y</literal>，你必须写<literal>X* @Y</literal>来确保<productname>PostgreSQL</productname>把它读作两个操作符名而不是一个。
   </para>
  </sect2>

  <sect2 id="sql-syntax-special-chars">
<!--==========================orignal english content==========================
   <title>Special Characters</title>
____________________________________________________________________________-->
   <title>特殊字符</title>

<!--==========================orignal english content==========================
  <para>
   Some characters that are not alphanumeric have a special meaning
   that is different from being an operator.  Details on the usage can
   be found at the location where the respective syntax element is
   described.  This section only exists to advise the existence and
   summarize the purposes of these characters.

   <itemizedlist>
    <listitem>
     <para>
      A dollar sign (<literal>$</literal>) followed by digits is used
      to represent a positional parameter in the body of a function
      definition or a prepared statement.  In other contexts the
      dollar sign can be part of an identifier or a dollar-quoted string
      constant.
     </para>
    </listitem>

    <listitem>
     <para>
      Parentheses (<literal>()</literal>) have their usual meaning to
      group expressions and enforce precedence.  In some cases
      parentheses are required as part of the fixed syntax of a
      particular SQL command.
     </para>
    </listitem>

    <listitem>
     <para>
      Brackets (<literal>[]</literal>) are used to select the elements
      of an array.  See <xref linkend="arrays"> for more information
      on arrays.
     </para>
    </listitem>

    <listitem>
     <para>
      Commas (<literal>,</literal>) are used in some syntactical
      constructs to separate the elements of a list.
     </para>
    </listitem>

    <listitem>
     <para>
      The semicolon (<literal>;</literal>) terminates an SQL command.
      It cannot appear anywhere within a command, except within a
      string constant or quoted identifier.
     </para>
    </listitem>

    <listitem>
     <para>
      The colon (<literal>:</literal>) is used to select
      <quote>slices</quote> from arrays. (See <xref
      linkend="arrays">.)  In certain SQL dialects (such as Embedded
      SQL), the colon is used to prefix variable names.
     </para>
    </listitem>

    <listitem>
     <para>
      The asterisk (<literal>*</literal>) is used in some contexts to denote
      all the fields of a table row or composite value.  It also
      has a special meaning when used as the argument of an
      aggregate function, namely that the aggregate does not require
      any explicit parameter.
     </para>
    </listitem>

    <listitem>
     <para>
      The period (<literal>.</literal>) is used in numeric
      constants, and to separate schema, table, and column names.
     </para>
    </listitem>
   </itemizedlist>

   </para>
____________________________________________________________________________-->
  <para>
   一些不是数字字母的字符有一种不同于作为操作符的特殊含义。这些字符的详细用法可以在描述相应语法元素的地方找到。这一节只是为了告知它们的存在以及总结这些字符的目的。

   <itemizedlist>
    <listitem>
     <para>
      跟随在一个美元符号（<literal>$</literal>）后面的数字被用来表示在一个函数定义或一个预备语句中的位置参数。在其他上下文中该美元符号可以作为一个标识符或者一个美元引用字符串常量的一部分。
     </para>
    </listitem>

    <listitem>
     <para>
      圆括号（<literal>()</literal>）具有它们通常的含义，用来分组表达式并且强制优先。在某些情况中，圆括号被要求作为一个特定 SQL 命令的固定语法的一部分。
     </para>
    </listitem>

    <listitem>
     <para>
      方括号（<literal>[]</literal>）被用来选择一个数组中的元素。更多关于数组的信息见<xref linkend="arrays">。
     </para>
    </listitem>

    <listitem>
     <para>
      逗号（<literal>,</literal>）被用在某些语法结构中来分割一个列表的元素。
     </para>
    </listitem>

    <listitem>
     <para>
      分号（<literal>;</literal>）结束一个 SQL 命令。它不能出现在一个命令中间的任何位置，除了在一个字符串常量中或者一个被引用的标识符中。
     </para>
    </listitem>

    <listitem>
     <para>
      冒号（<literal>:</literal>）被用来从数组中选择<quote>切片</quote>（见<xref linkend="arrays">）。在某些 SQL 的“方言”（例如嵌入式 SQL）中，冒号被用来作为变量名的前缀。
     </para>
    </listitem>

    <listitem>
     <para>
      星号（<literal>*</literal>）被用在某些上下文中标记一个表的所有域或者组合值。当它被用作一个聚合函数的参数时，它还有一种特殊的含义，即该聚合不要求任何显式参数。
     </para>
    </listitem>

    <listitem>
     <para>
      句点（<literal>.</literal>）被用在数字常量中，并且被用来分割模式、表和列名。
     </para>
    </listitem>
   </itemizedlist>

   </para>
  </sect2>

  <sect2 id="sql-syntax-comments">
<!--==========================orignal english content==========================
   <title>Comments</title>
____________________________________________________________________________-->
   <title>注释</title>

<!--==========================orignal english content==========================
   <indexterm zone="sql-syntax-comments">
    <primary>comment</primary>
    <secondary sortas="SQL">in SQL</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="sql-syntax-comments">
    <primary>comment</primary>
    <secondary sortas="SQL">in SQL</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    A comment is a sequence of characters beginning with
    double dashes and extending to the end of the line, e.g.:
<programlisting>
-&minus; This is a standard SQL comment
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    一段注释是以双斜线开始并且延伸到行结尾的一个字符序列，例如：
<programlisting>
-- This is a standard SQL comment
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    Alternatively, C-style block comments can be used:
<programlisting>
/* multiline comment
 * with nesting: /* nested block comment */
 */
</programlisting>
    where the comment begins with <literal>/*</literal> and extends to
    the matching occurrence of <literal>*/</literal>. These block
    comments nest, as specified in the SQL standard but unlike C, so that one can
    comment out larger blocks of code that might contain existing block
    comments.
   </para>
____________________________________________________________________________-->
   <para>
    另外，也可以使用 C 风格注释块：
<programlisting>
/* multiline comment
 * with nesting: /* nested block comment */
 */
</programlisting>
    这里该注释开始于<literal>/*</literal>并且延伸到匹配出现的<literal>*/</literal>。这些注释块可按照 SQL 标准中指定的方式嵌套，但和 C 中不同。这样我们可以注释掉一大段可能包含注释块的代码。
   </para>

<!--==========================orignal english content==========================
   <para>
    A comment is removed from the input stream before further syntax
    analysis and is effectively replaced by whitespace.
   </para>
____________________________________________________________________________-->
   <para>
    在进一步的语法分析前，注释会被从输入流中被移除并且实际被替换为空白。
   </para>
  </sect2>

  <sect2 id="sql-precedence">
<!--==========================orignal english content==========================
   <title>Operator Precedence</title>
____________________________________________________________________________-->
   <title>操作符优先级</title>

<!--==========================orignal english content==========================
   <indexterm zone="sql-precedence">
    <primary>operator</primary>
    <secondary>precedence</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="sql-precedence">
    <primary>operator</primary>
    <secondary>precedence</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    <xref linkend="sql-precedence-table"> shows the precedence and
    associativity of the operators in <productname>PostgreSQL</>.
    Most operators have the same precedence and are left-associative.
    The precedence and associativity of the operators is hard-wired
    into the parser.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="sql-precedence-table">显示了<productname>PostgreSQL</>
    中操作符的优先级和结合性。大部分操作符具有相同的优先并且是左结合的。
    操作符的优先级和结合性被硬写在解析器中。
    </para>
<!--==========================orignal english content==========================
   <para>
    You will
    sometimes need to add parentheses when using combinations of
    binary and unary operators.  For instance:
<programlisting>
SELECT 5 ! - 6;
</programlisting>
   will be parsed as:
<programlisting>
SELECT 5 ! (- 6);
</programlisting>
    because the parser has no idea &mdash; until it is too late
    &mdash; that <token>!</token> is defined as a postfix operator,
    not an infix one.  To get the desired behavior in this case, you
    must write:
<programlisting>
SELECT (5 !) - 6;
</programlisting>
    This is the price one pays for extensibility.
   </para>
____________________________________________________________________________-->
   <para>
    当使用二元和一元操作符的组合时，有时你将需要增加圆括号。例如：
<programlisting>
SELECT 5 ! - 6;
</programlisting>
   将被解析为：
<programlisting>
SELECT 5 ! (- 6);
</programlisting>
    因为解析器不知道 &mdash; 知道时就为时已晚 &mdash; <token>!</token>被定义为一个后缀操作符而不是一个中缀操作符。在这种情况下要得到想要的行为，你必须写成：
<programlisting>
SELECT (5 !) - 6;
</programlisting>
    只是为了扩展性必须付出的代价。
   </para>

   <table id="sql-precedence-table">
<!--==========================orignal english content==========================
    <title>Operator Precedence (highest to lowest)</title>
____________________________________________________________________________-->
    <title>操作符优先级（最高到最低）</title>

    <tgroup cols="3">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Operator/Element</entry>
       <entry>Associativity</entry>
       <entry>Description</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>操作符/元素</entry>
       <entry>结合性</entry>
       <entry>描述</entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry><token>.</token></entry>
       <entry>left</entry>
       <entry>table/column name separator</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><token>.</token></entry>
       <entry>左</entry>
       <entry>表/列名分隔符</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><token>::</token></entry>
       <entry>left</entry>
       <entry><productname>PostgreSQL</productname>-style typecast</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><token>::</token></entry>
       <entry>左</entry>
       <entry><productname>PostgreSQL</productname>-风格的类型转换</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><token>[</token> <token>]</token></entry>
       <entry>left</entry>
       <entry>array element selection</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><token>[</token> <token>]</token></entry>
       <entry>左</entry>
       <entry>数组元素选择</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><token>+</token> <token>-</token></entry>
       <entry>right</entry>
       <entry>unary plus, unary minus</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><token>+</token> <token>-</token></entry>
       <entry>右</entry>
       <entry>一元加、一元减</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><token>^</token></entry>
       <entry>left</entry>
       <entry>exponentiation</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><token>^</token></entry>
       <entry>左</entry>
       <entry>指数</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><token>*</token> <token>/</token> <token>%</token></entry>
       <entry>left</entry>
       <entry>multiplication, division, modulo</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><token>*</token> <token>/</token> <token>%</token></entry>
       <entry>左</entry>
       <entry>乘、除、模</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><token>+</token> <token>-</token></entry>
       <entry>left</entry>
       <entry>addition, subtraction</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><token>+</token> <token>-</token></entry>
       <entry>左</entry>
       <entry>加、减</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry>(any other operator)</entry>
       <entry>left</entry>
       <entry>all other native and user-defined operators</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <!-- <entry>(any other operator)</entry> -->
       <entry>（任意其他操作符）</entry>
       <entry>左</entry>
       <entry>所有其他本地以及用户定义的操作符</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><token>BETWEEN</token> <token>IN</token> <token>LIKE</token> <token>ILIKE</token> <token>SIMILAR</token></entry>
       <entry></entry>
       <entry>range containment, set membership, string matching</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><token>BETWEEN</token> <token>IN</token> <token>LIKE</token> <token>ILIKE</token> <token>SIMILAR</token></entry>
       <entry></entry>
       <entry>范围包含，设置成员，字符串匹配</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><token>&lt;</token> <token>&gt;</token> <token>=</token> <token>&lt;=</token> <token>&gt;=</token> <token>&lt;&gt;</token>
</entry>
       <entry></entry>
       <entry>comparison operators</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><token>&lt;</token> <token>&gt;</token> <token>=</token> <token>&lt;=</token> <token>&gt;=</token> <token>&lt;&gt;</token>
</entry>
       <entry></entry>
       <entry>比较操作符</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><token>IS</token> <token>ISNULL</token> <token>NOTNULL</token></entry>
       <entry></entry>
       <entry><literal>IS TRUE</>, <literal>IS FALSE</>, <literal>IS
       NULL</>, <literal>IS DISTINCT FROM</>, etc</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><token>IS</token> <token>ISNULL</token> <token>NOTNULL</token></entry>
       <entry></entry>
       <entry><literal>IS TRUE</>、<literal>IS FALSE</>、<literal>IS
       NULL</>、<literal>IS DISTINCT FROM</>等</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><token>NOT</token></entry>
       <entry>right</entry>
       <entry>logical negation</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><token>NOT</token></entry>
       <entry>右</entry>
       <entry>逻辑否定</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><token>AND</token></entry>
       <entry>left</entry>
       <entry>logical conjunction</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><token>AND</token></entry>
       <entry>左</entry>
       <entry>逻辑合取</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><token>OR</token></entry>
       <entry>left</entry>
       <entry>logical disjunction</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><token>OR</token></entry>
       <entry>左</entry>
       <entry>逻辑析取</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    Note that the operator precedence rules also apply to user-defined
    operators that have the same names as the built-in operators
    mentioned above.  For example, if you define a
    <quote>+</quote> operator for some custom data type it will have
    the same precedence as the built-in <quote>+</quote> operator, no
    matter what yours does.
   </para>
____________________________________________________________________________-->
   <para>
    注意该操作符有限规则也适用于与上述内建操作符具有相同名称的用户定义的操作符。例如，如果你为某种自定义数据类型定义了一个<quote>+</quote>操作符，它将具有和内建的<quote>+</quote>操作符相同的优先级，不管你的操作符要做什么。
   </para>

<!--==========================orignal english content==========================
   <para>
    When a schema-qualified operator name is used in the
    <literal>OPERATOR</> syntax, as for example in:
<programlisting>
SELECT 3 OPERATOR(pg_catalog.+) 4;
</programlisting>
    the <literal>OPERATOR</> construct is taken to have the default precedence
    shown in <xref linkend="sql-precedence-table"> for
    <quote>any other operator</>.  This is true no matter
    which specific operator appears inside <literal>OPERATOR()</>.
   </para>
____________________________________________________________________________-->
   <para>
    当一个模式限定的操作符名被用在<literal>OPERATOR</>语法中时，如下面的例子：
<programlisting>
SELECT 3 OPERATOR(pg_catalog.+) 4;
</programlisting>
    <literal>OPERATOR</>结构被用来为<quote>任意其他操作符</>获得
    <xref linkend="sql-precedence-table">中默认的优先级。不管出现在
    <literal>OPERATOR()</>中的是哪个指定操作符，这都是真的。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     <productname>PostgreSQL</> versions before 9.5 used slightly different
     operator precedence rules.  In particular, <token>&lt;=</token>
     <token>&gt;=</token> and <token>&lt;&gt;</token> used to be treated as
     generic operators; <literal>IS</> tests used to have higher priority;
     and <literal>NOT BETWEEN</> and related constructs acted inconsistently,
     being taken in some cases as having the precedence of <literal>NOT</>
     rather than <literal>BETWEEN</>.  These rules were changed for better
     compliance with the SQL standard and to reduce confusion from
     inconsistent treatment of logically equivalent constructs.  In most
     cases, these changes will result in no behavioral change, or perhaps
     in <quote>no such operator</> failures which can be resolved by adding
     parentheses.  However there are corner cases in which a query might
     change behavior without any parsing error being reported.  If you are
     concerned about whether these changes have silently broken something,
     you can test your application with the configuration
     parameter <xref linkend="guc-operator-precedence-warning"> turned on
     to see if any warnings are logged.
    </para>
____________________________________________________________________________-->
    <para>
     版本 9.5 之前的<productname>PostgreSQL</>使用的操作符优先级规则略有不同。
     特别是，<token>&lt;=</token>、<token>&gt;=</token>和<token>&lt;&gt;</token>
     习惯于被当作普通操作符，<literal>IS</>测试习惯于具有较高的优先级。
     并且在一些具有<literal>NOT</>而不是<literal>BETWEEN</>优先级的情况下，
     <literal>NOT BETWEEN</>和相关的结构的行为不一致。
     为了更好地兼容 SQL 标准并且减少对逻辑上等价的结构不一致的处理，
     这些规则也得到了修改。在大部分情况下，这些变化不会导致行为上的变化，
     或者可能会产生<quote>no such operator</>错误，但可以通过增加圆括号解决。
     不过在一些极端情况中，查询可能在没有被报告解析错误的情况下发生行为的改变。
     如果你担心这些改变悄悄地破坏了一些事情，可以打开
     <xref linkend="guc-operator-precedence-warning">配置参数，
     然后测试你的应用看看有没有一些警告被记录。

    </para>
   </note>
   </sect2>
 </sect1>

 <sect1 id="sql-expressions">
<!--==========================orignal english content==========================
  <title>Value Expressions</title>
____________________________________________________________________________-->
  <title>值表达式</title>

<!--==========================orignal english content==========================
  <indexterm zone="sql-expressions">
   <primary>expression</primary>
   <secondary>syntax</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="sql-expressions">
   <primary>表达式</primary>
   <secondary>语法</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm zone="sql-expressions">
   <primary>value expression</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="sql-expressions">
   <primary>值表达式</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>scalar</primary>
   <see>expression</see>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>标量</primary>
   <see>表达式</see>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   Value expressions are used in a variety of contexts, such
   as in the target list of the <command>SELECT</command> command, as
   new column values in <command>INSERT</command> or
   <command>UPDATE</command>, or in search conditions in a number of
   commands.  The result of a value expression is sometimes called a
   <firstterm>scalar</firstterm>, to distinguish it from the result of
   a table expression (which is a table).  Value expressions are
   therefore also called <firstterm>scalar expressions</firstterm> (or
   even simply <firstterm>expressions</firstterm>).  The expression
   syntax allows the calculation of values from primitive parts using
   arithmetic, logical, set, and other operations.
  </para>
____________________________________________________________________________-->
  <para>
   值表达式被用于各种各样的环境中，例如在<command>SELECT</command>命令的目标列表中、作为<command>INSERT</command>或<command>UPDATE</command>中的新列值或者若干命令中的搜索条件。为了区别于一个表表达式（是一个表）的结果，一个值表达式的结果有时候被称为一个<firstterm>标量</firstterm>。值表达式因此也被称为<firstterm>标量表达式</firstterm>（或者甚至简称为<firstterm>表达式</firstterm>）。表达式语法允许使用算数、逻辑、集合和其他操作从原始部分计算值。
  </para>

<!--==========================orignal english content==========================
  <para>
   A value expression is one of the following:

   <itemizedlist>
    <listitem>
     <para>
      A constant or literal value
     </para>
    </listitem>

    <listitem>
     <para>
      A column reference
     </para>
    </listitem>

    <listitem>
     <para>
      A positional parameter reference, in the body of a function definition
      or prepared statement
     </para>
    </listitem>

    <listitem>
     <para>
      A subscripted expression
     </para>
    </listitem>

    <listitem>
     <para>
      A field selection expression
     </para>
    </listitem>

    <listitem>
     <para>
      An operator invocation
     </para>
    </listitem>

    <listitem>
     <para>
      A function call
     </para>
    </listitem>

    <listitem>
     <para>
      An aggregate expression
     </para>
    </listitem>

    <listitem>
     <para>
      A window function call
     </para>
    </listitem>

    <listitem>
     <para>
      A type cast
     </para>
    </listitem>

    <listitem>
     <para>
      A collation expression
     </para>
    </listitem>

    <listitem>
     <para>
      A scalar subquery
     </para>
    </listitem>

    <listitem>
     <para>
      An array constructor
     </para>
    </listitem>

    <listitem>
     <para>
      A row constructor
     </para>
    </listitem>

    <listitem>
     <para>
      Another value expression in parentheses (used to group
      subexpressions and override
      precedence<indexterm><primary>parenthesis</></>)
     </para>
    </listitem>
   </itemizedlist>
  </para>
____________________________________________________________________________-->
  <para>
   一个值表达式是下列之一：

   <itemizedlist>
    <listitem>
     <para>
      一个常量或文字值
     </para>
    </listitem>

    <listitem>
     <para>
      一个列引用
     </para>
    </listitem>

    <listitem>
     <para>
      在一个函数定义体或预备语句中的一个位置参数引用
     </para>
    </listitem>

    <listitem>
     <para>
      一个下标表达式
     </para>
    </listitem>

    <listitem>
     <para>
      一个域选择表达式
     </para>
    </listitem>

    <listitem>
     <para>
      一个操作符调用
     </para>
    </listitem>

    <listitem>
     <para>
      一个函数调用
     </para>
    </listitem>

    <listitem>
     <para>
      一个聚合表达式
     </para>
    </listitem>

    <listitem>
     <para>
      一个窗口函数调用
     </para>
    </listitem>

    <listitem>
     <para>
      一个类型转换
     </para>
    </listitem>

    <listitem>
     <para>
      一个排序规则表达式
     </para>
    </listitem>

    <listitem>
     <para>
      一个标量子查询
     </para>
    </listitem>

    <listitem>
     <para>
      一个数组构造器
     </para>
    </listitem>

    <listitem>
     <para>
      一个行构造器
     </para>
    </listitem>

    <listitem>
     <para>
      另一个在圆括号（用来分组子表达式以及重载优先级<indexterm><primary>圆括号</></>）中的值表达式
     </para>
    </listitem>
   </itemizedlist>
  </para>

<!--==========================orignal english content==========================
  <para>
   In addition to this list, there are a number of constructs that can
   be classified as an expression but do not follow any general syntax
   rules.  These generally have the semantics of a function or
   operator and are explained in the appropriate location in <xref
   linkend="functions">.  An example is the <literal>IS NULL</literal>
   clause.
  </para>
____________________________________________________________________________-->
  <para>
   在这个列表之外，还有一些结构可以被分类为一个表达式，但是它们不遵循任何一般语法规则。这些通常具有一个函数或操作符的语义并且在<xref linkend="functions">中的合适位置解释。一个例子是<literal>IS NULL</literal>子句。
  </para>

<!--==========================orignal english content==========================
  <para>
   We have already discussed constants in <xref
   linkend="sql-syntax-constants">.  The following sections discuss
   the remaining options.
  </para>
____________________________________________________________________________-->
  <para>
   我们已经在<xref linkend="sql-syntax-constants">中讨论过常量。下面的小节会讨论剩下的选项。
  </para>

  <sect2 id="sql-expressions-column-refs">
<!--==========================orignal english content==========================
   <title>Column References</title>
____________________________________________________________________________-->
   <title>列引用</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>column reference</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>列引用</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    A column can be referenced in the form:
<synopsis>
<replaceable>correlation</replaceable>.<replaceable>columnname</replaceable>
</synopsis>
   </para>
____________________________________________________________________________-->
   <para>
    一个列可以以下面的形式被引用：
<synopsis>
<replaceable>correlation</replaceable>.<replaceable>columnname</replaceable>
</synopsis>
   </para>

<!--==========================orignal english content==========================
   <para>
    <replaceable>correlation</replaceable> is the name of a
    table (possibly qualified with a schema name), or an alias for a table
    defined by means of a <literal>FROM</literal> clause.
    The correlation name and separating dot can be omitted if the column name
    is unique across all the tables being used in the current query.  (See also <xref linkend="queries">.)
   </para>
____________________________________________________________________________-->
   <para>
    <replaceable>correlation</replaceable>是一个表（有可能以一个模式名限定）的名字，或者是在<literal>FROM</literal>子句中为一个表定义的别名。如果列名在当前索引所使用的表中都是唯一的，关联名称和分隔用的句点可以被忽略（另见<xref linkend="queries">）。
   </para>
  </sect2>

  <sect2 id="sql-expressions-parameters-positional">
<!--==========================orignal english content==========================
   <title>Positional Parameters</title>
____________________________________________________________________________-->
   <title>位置参数</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>parameter</primary>
    <secondary>syntax</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>参数</primary>
    <secondary>语法</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>$</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>$</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    A positional parameter reference is used to indicate a value
    that is supplied externally to an SQL statement.  Parameters are
    used in SQL function definitions and in prepared queries.  Some
    client libraries also support specifying data values separately
    from the SQL command string, in which case parameters are used to
    refer to the out-of-line data values.
    The form of a parameter reference is:
<synopsis>
$<replaceable>number</replaceable>
</synopsis>
   </para>
____________________________________________________________________________-->
   <para>
    一个位置参数引用被用来指示一个由 SQL 语句外部提供的值。参数被用于 SQL 函数定义和预备查询中。某些客户端库还支持独立于 SQL 命令字符串来指定数据值，在这种情况中参数被用来引用那些线外数据值。一个参数引用的形式是：
<synopsis>
$<replaceable>number</replaceable>
</synopsis>
   </para>

<!--==========================orignal english content==========================
   <para>
    For example, consider the definition of a function,
    <function>dept</function>, as:

<programlisting>
CREATE FUNCTION dept(text) RETURNS dept
    AS $$ SELECT * FROM dept WHERE name = $1 $$
    LANGUAGE SQL;
</programlisting>

    Here the <literal>$1</literal> references the value of the first
    function argument whenever the function is invoked.
   </para>
____________________________________________________________________________-->
   <para>
    例如，考虑一个函数<function>dept</function>的定义：

<programlisting>
CREATE FUNCTION dept(text) RETURNS dept
    AS $$ SELECT * FROM dept WHERE name = $1 $$
    LANGUAGE SQL;
</programlisting>

    这里<literal>$1</literal>引用函数被调用时第一个函数参数的值。
   </para>
  </sect2>

  <sect2 id="sql-expressions-subscripts">
<!--==========================orignal english content==========================
   <title>Subscripts</title>
____________________________________________________________________________-->
   <title>下标</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>subscript</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>下标</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    If an expression yields a value of an array type, then a specific
    element of the array value can be extracted by writing
<synopsis>
<replaceable>expression</replaceable>[<replaceable>subscript</replaceable>]
</synopsis>
    or multiple adjacent elements (an <quote>array slice</>) can be extracted
    by writing
<synopsis>
<replaceable>expression</replaceable>[<replaceable>lower_subscript</replaceable>:<replaceable>upper_subscript</replaceable>]
</synopsis>
    (Here, the brackets <literal>[ ]</literal> are meant to appear literally.)
    Each <replaceable>subscript</replaceable> is itself an expression,
    which must yield an integer value.
   </para>
____________________________________________________________________________-->
   <para>
    如果一个表达式得到了一个数组类型的值，那么可以抽取出该数组值的一个特定元素：
<synopsis>
<replaceable>expression</replaceable>[<replaceable>subscript</replaceable>]
</synopsis>
    或者抽取出多个相邻元素（一个<quote>数组切片</>）：
<synopsis>
<replaceable>expression</replaceable>[<replaceable>lower_subscript</replaceable>:<replaceable>upper_subscript</replaceable>]
</synopsis>
    （这里，方括号<literal>[ ]</literal>表示其字面意思）。每一个<replaceable>下标</replaceable>自身是一个表达式，它必须得到一个整数值。
   </para>

<!--==========================orignal english content==========================
   <para>
    In general the array <replaceable>expression</replaceable> must be
    parenthesized, but the parentheses can be omitted when the expression
    to be subscripted is just a column reference or positional parameter.
    Also, multiple subscripts can be concatenated when the original array
    is multidimensional.
    For example:

<programlisting>
mytable.arraycolumn[4]
mytable.two_d_column[17][34]
$1[10:42]
(arrayfunction(a,b))[42]
</programlisting>

    The parentheses in the last example are required.
    See <xref linkend="arrays"> for more about arrays.
   </para>
____________________________________________________________________________-->
   <para>
    通常，数组<replaceable>表达式</replaceable>必须被加上括号，但是当要被加下标的表达式只是一个列引用或位置参数时，括号可以被忽略。还有，当原始数组是多维时，多个下标可以被连接起来。例如：

<programlisting>
mytable.arraycolumn[4]
mytable.two_d_column[17][34]
$1[10:42]
(arrayfunction(a,b))[42]
</programlisting>

    最后一个例子中的圆括号是必需的。详见<xref linkend="arrays">。
   </para>
  </sect2>

  <sect2 id="field-selection">
<!--==========================orignal english content==========================
   <title>Field Selection</title>
____________________________________________________________________________-->
   <title>域选择</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>field selection</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>域选择</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    If an expression yields a value of a composite type (row type), then a
    specific field of the row can be extracted by writing
<synopsis>
<replaceable>expression</replaceable>.<replaceable>fieldname</replaceable>
</synopsis>
   </para>
____________________________________________________________________________-->
   <para>
    如果一个表达式得到一个组合类型（行类型）的值，那么可以抽取该行的指定域
<synopsis>
<replaceable>expression</replaceable>.<replaceable>fieldname</replaceable>
</synopsis>
   </para>

<!--==========================orignal english content==========================
   <para>
    In general the row <replaceable>expression</replaceable> must be
    parenthesized, but the parentheses can be omitted when the expression
    to be selected from is just a table reference or positional parameter.
    For example:

<programlisting>
mytable.mycolumn
$1.somecolumn
(rowfunction(a,b)).col3
</programlisting>

    (Thus, a qualified column reference is actually just a special case
    of the field selection syntax.)  An important special case is
    extracting a field from a table column that is of a composite type:

<programlisting>
(compositecol).somefield
(mytable.compositecol).somefield
</programlisting>

    The parentheses are required here to show that
    <structfield>compositecol</> is a column name not a table name,
    or that <structname>mytable</> is a table name not a schema name
    in the second case.
   </para>
____________________________________________________________________________-->
   <para>
    通常行<replaceable>表达式</replaceable>必须被加上括号，但是当该表达式是仅从一个表引用或位置参数选择时，圆括号可以被忽略。例如：

<programlisting>
mytable.mycolumn
$1.somecolumn
(rowfunction(a,b)).col3
</programlisting>

    （因此，一个被限定的列引用实际上只是域选择语法的一种特例）。一种重要的特例是从一个组合类型的表列中抽取一个域：

<programlisting>
(compositecol).somefield
(mytable.compositecol).somefield
</programlisting>

    这里需要圆括号来显示<structfield>compositecol</>是一个列名而不是一个表名，在第二种情况中则是显示<structname>mytable</>是一个表名而不是一个模式名。
   </para>

<!--==========================orignal english content==========================
   <para>
    You can ask for all fields of a composite value by
    writing <literal>.*</literal>:
<programlisting>
(compositecol).*
</programlisting>
    This notation behaves differently depending on context;
    see <xref linkend="rowtypes-usage"> for details.
   </para>
____________________________________________________________________________-->
   <para>
    你可以通过书写<literal>.*</literal>来请求一个组合值的所有域：
<programlisting>
(compositecol).*
</programlisting>
    这种表示法根据上下文而表现不同；有关详细信息，请参见<xref linkend="rowtypes-usage">。
   </para>
  </sect2>

  <sect2 id="sql-expressions-operator-calls">
<!--==========================orignal english content==========================
   <title>Operator Invocations</title>
____________________________________________________________________________-->
   <title>操作符调用</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>operator</primary>
    <secondary>invocation</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>操作符</primary>
    <secondary>调用</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    There are three possible syntaxes for an operator invocation:
    <simplelist>
     <member><replaceable>expression</replaceable> <replaceable>operator</replaceable> <replaceable>expression</replaceable> (binary infix operator)</member>
     <member><replaceable>operator</replaceable> <replaceable>expression</replaceable> (unary prefix operator)</member>
     <member><replaceable>expression</replaceable> <replaceable>operator</replaceable> (unary postfix operator)</member>
    </simplelist>
    where the <replaceable>operator</replaceable> token follows the syntax
    rules of <xref linkend="sql-syntax-operators">, or is one of the
    key words <token>AND</token>, <token>OR</token>, and
    <token>NOT</token>, or is a qualified operator name in the form:
<synopsis>
<literal>OPERATOR(</><replaceable>schema</><literal>.</><replaceable>operatorname</><literal>)</>
</synopsis>
    Which particular operators exist and whether
    they are unary or binary depends on what operators have been
    defined by the system or the user.  <xref linkend="functions">
    describes the built-in operators.
   </para>
____________________________________________________________________________-->
   <para>
    对于一次操作符调用，有三种可能的语法：
    <simplelist>
     <member><replaceable>expression</replaceable> <replaceable>operator</replaceable> <replaceable>expression</replaceable>（二元中缀操作符）</member>
     <member><replaceable>operator</replaceable> <replaceable>expression</replaceable>（一元前缀操作符）</member>
     <member><replaceable>expression</replaceable> <replaceable>operator</replaceable>（一元后缀操作符）</member>
    </simplelist>
    其中<replaceable>operator</replaceable>记号遵循<xref linkend="sql-syntax-operators">的语法规则，或者是关键词<token>AND</token>、<token>OR</token>和<token>NOT</token>之一，或者是一个如下形式的受限定操作符名：
<synopsis>
<literal>OPERATOR(</><replaceable>schema</><literal>.</><replaceable>operatorname</><literal>)</>
</synopsis>
    哪个特定操作符存在以及它们是一元的还是二元的取决于由系统或用户定义的那些操作符。<xref linkend="functions">描述了内建操作符。
   </para>
  </sect2>

  <sect2 id="sql-expressions-function-calls">
<!--==========================orignal english content==========================
   <title>Function Calls</title>
____________________________________________________________________________-->
   <title>函数调用</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>function</primary>
    <secondary>invocation</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>函数</primary>
    <secondary>调用</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The syntax for a function call is the name of a function
    (possibly qualified with a schema name), followed by its argument list
    enclosed in parentheses:

<synopsis>
<replaceable>function_name</replaceable> (<optional><replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ... </optional></optional> )
</synopsis>
   </para>
____________________________________________________________________________-->
   <para>
    一个函数调用的语法是一个函数的名称（可能受限于一个模式名）后面跟上封闭于圆括号中的参数列表：

<synopsis>
<replaceable>function_name</replaceable> (<optional><replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ... </optional></optional> )
</synopsis>
   </para>

<!--==========================orignal english content==========================
   <para>
    For example, the following computes the square root of 2:
<programlisting>
sqrt(2)
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    例如，下面会计算 2 的平方根：
<programlisting>
sqrt(2)
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    The list of built-in functions is in <xref linkend="functions">.
    Other functions can be added by the user.
   </para>
____________________________________________________________________________-->
   <para>
    内建函数的列表在<xref linkend="functions">中。其他函数可以由用户增加。
   </para>

<!--==========================orignal english content==========================
   <para>
    The arguments can optionally have names attached.
    See <xref linkend="sql-syntax-calling-funcs"> for details.
   </para>
____________________________________________________________________________-->
   <para>
    参数可以有选择地被附加名称。详见<xref linkend="sql-syntax-calling-funcs">。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     A function that takes a single argument of composite type can
     optionally be called using field-selection syntax, and conversely
     field selection can be written in functional style.  That is, the
     notations <literal>col(table)</> and <literal>table.col</> are
     interchangeable.  This behavior is not SQL-standard but is provided
     in <productname>PostgreSQL</> because it allows use of functions to
     emulate <quote>computed fields</>.  For more information see
     <xref linkend="rowtypes-usage">.
    </para>
____________________________________________________________________________-->
    <para>
     一个采用单一组合类型参数的函数可以被有选择地称为域选择语法，并且反过来域选择可以被写成函数的风格。也就是说，记号<literal>col(table)</>和<literal>table.col</>是可以互换的。这种行为是非 SQL 标准的但是在<productname>PostgreSQL</>中被提供，因为它允许函数的使用来模拟<quote>计算域</>。详见<xref linkend="rowtypes-usage">。
    </para>
   </note>
  </sect2>

  <sect2 id="syntax-aggregates">
<!--==========================orignal english content==========================
   <title>Aggregate Expressions</title>
____________________________________________________________________________-->
   <title>聚合表达式</title>

<!--==========================orignal english content==========================
   <indexterm zone="syntax-aggregates">
    <primary>aggregate function</primary>
    <secondary>invocation</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="syntax-aggregates">
    <primary>聚合函数</primary>
    <secondary>调用</secondary>
   </indexterm>
   
<!--==========================orignal english content==========================
   <indexterm zone="syntax-aggregates">
    <primary>ordered-set aggregate</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="syntax-aggregates">
    <primary>有序集聚合</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="syntax-aggregates">
    <primary>WITHIN GROUP</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="syntax-aggregates">
    <primary>WITHIN GROUP</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="syntax-aggregates">
    <primary>FILTER</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="syntax-aggregates">
    <primary>FILTER</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    An <firstterm>aggregate expression</firstterm> represents the
    application of an aggregate function across the rows selected by a
    query.  An aggregate function reduces multiple inputs to a single
    output value, such as the sum or average of the inputs.  The
    syntax of an aggregate expression is one of the following:

<synopsis>
<replaceable>aggregate_name</replaceable> (<replaceable>expression</replaceable> [ , ... ] [ <replaceable>order_by_clause</replaceable> ] ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ]
<replaceable>aggregate_name</replaceable> (ALL <replaceable>expression</replaceable> [ , ... ] [ <replaceable>order_by_clause</replaceable> ] ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ]
<replaceable>aggregate_name</replaceable> (DISTINCT <replaceable>expression</replaceable> [ , ... ] [ <replaceable>order_by_clause</replaceable> ] ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ]
<replaceable>aggregate_name</replaceable> ( * ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ]
<replaceable>aggregate_name</replaceable> ( [ <replaceable>expression</replaceable> [ , ... ] ] ) WITHIN GROUP ( <replaceable>order_by_clause</replaceable> ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ]
</synopsis>

    where <replaceable>aggregate_name</replaceable> is a previously
    defined aggregate (possibly qualified with a schema name) and
    <replaceable>expression</replaceable> is
    any value expression that does not itself contain an aggregate
    expression or a window function call.  The optional
    <replaceable>order_by_clause</replaceable> and
    <replaceable>filter_clause</replaceable> are described below.
   </para>
____________________________________________________________________________-->
   <para>
    一个<firstterm>聚合表达式</firstterm>表示在由一个查询选择的行上应用一个聚合函数。一个聚合函数将多个输入减少到一个单一输出值，例如对输入的求和或平均。一个聚合表达式的语法是下列之一：

<synopsis>
<replaceable>aggregate_name</replaceable> (<replaceable>expression</replaceable> [ , ... ] [ <replaceable>order_by_clause</replaceable> ] ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ]
<replaceable>aggregate_name</replaceable> (ALL <replaceable>expression</replaceable> [ , ... ] [ <replaceable>order_by_clause</replaceable> ] ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ]
<replaceable>aggregate_name</replaceable> (DISTINCT <replaceable>expression</replaceable> [ , ... ] [ <replaceable>order_by_clause</replaceable> ] ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ]
<replaceable>aggregate_name</replaceable> ( * ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ]
<replaceable>aggregate_name</replaceable> ( [ <replaceable>expression</replaceable> [ , ... ] ] ) WITHIN GROUP ( <replaceable>order_by_clause</replaceable> ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ]
</synopsis>

    这里<replaceable>aggregate_name</replaceable>是一个之前定义的聚合（可能带有一个模式名限定），并且<replaceable>expression</replaceable>是任意自身不包含聚合表达式的值表达式或一个窗口函数调用。可选的<replaceable>order_by_clause</replaceable>和<replaceable>filter_clause</replaceable>描述如下。
   </para>

<!--==========================orignal english content==========================
   <para>
    The first form of aggregate expression invokes the aggregate
    once for each input row.
    The second form is the same as the first, since
    <literal>ALL</literal> is the default.
    The third form invokes the aggregate once for each distinct value
    of the expression (or distinct set of values, for multiple expressions)
    found in the input rows.
    The fourth form invokes the aggregate once for each input row; since no
    particular input value is specified, it is generally only useful
    for the <function>count(*)</function> aggregate function.
    The last form is used with <firstterm>ordered-set</> aggregate
    functions, which are described below.
   </para>
____________________________________________________________________________-->
   <para>
    第一种形式的聚合表达式为每一个输入行调用一次聚合。第二种形式和第一种相同，因为<literal>ALL</literal>是默认选项。第三种形式为输入行中表达式的每一个可区分值（或者对于多个表达式是值的可区分集合）调用一次聚合。第四种形式为每一个输入行调用一次聚合，因为没有特定的输入值被指定，它通常只对于<function>count(*)</function>聚合函数有用。最后一种形式被用于<firstterm>有序集</>聚合函数，其描述如下。
   </para>

<!--==========================orignal english content==========================
   <para>
    Most aggregate functions ignore null inputs, so that rows in which
    one or more of the expression(s) yield null are discarded.  This
    can be assumed to be true, unless otherwise specified, for all
    built-in aggregates.
   </para>
____________________________________________________________________________-->
   <para>
    大部分聚合函数忽略空输入，这样其中一个或多个表达式得到空值的行将被丢弃。除非另有说明，对于所有内建聚合都是这样。
   </para>

<!--==========================orignal english content==========================
   <para>
    For example, <literal>count(*)</literal> yields the total number
    of input rows; <literal>count(f1)</literal> yields the number of
    input rows in which <literal>f1</literal> is non-null, since
    <function>count</> ignores nulls; and
    <literal>count(distinct f1)</literal> yields the number of
    distinct non-null values of <literal>f1</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    例如，<literal>count(*)</literal>得到输入行的总数。<literal>count(f1)</literal>得到输入行中<literal>f1</literal>为非空的数量，因为<function>count</>忽略空值。而<literal>count(distinct f1)</literal>得到<literal>f1</literal>的非空可区分值的数量。
   </para>

<!--==========================orignal english content==========================
   <para>
    Ordinarily, the input rows are fed to the aggregate function in an
    unspecified order.  In many cases this does not matter; for example,
    <function>min</> produces the same result no matter what order it
    receives the inputs in.  However, some aggregate functions
    (such as <function>array_agg</> and <function>string_agg</>) produce
    results that depend on the ordering of the input rows.  When using
    such an aggregate, the optional <replaceable>order_by_clause</> can be
    used to specify the desired ordering.  The <replaceable>order_by_clause</>
    has the same syntax as for a query-level <literal>ORDER BY</> clause, as
    described in <xref linkend="queries-order">, except that its expressions
    are always just expressions and cannot be output-column names or numbers.
    For example:
<programlisting>
SELECT array_agg(a ORDER BY b DESC) FROM table;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    一般地，交给聚合函数的输入行是未排序的。在很多情况中这没有关系，例如不管接收到什么样的输入，<function>min</>总是产生相同的结果。但是，某些聚合函数（例如<function>array_agg</> 和<function>string_agg</>）依据输入行的排序产生结果。当使用这类聚合时，可选的<replaceable>order_by_clause</>可以被用来指定想要的顺序。<replaceable>order_by_clause</>与查询级别的<literal>ORDER BY</>子句（如<xref linkend="queries-order">所述）具有相同的语法，除非它的表达式总是仅有表达式并且不能是输出列名称或编号。例如：
<programlisting>
SELECT array_agg(a ORDER BY b DESC) FROM table;
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    When dealing with multiple-argument aggregate functions, note that the
    <literal>ORDER BY</> clause goes after all the aggregate arguments.
    For example, write this:
<programlisting>
SELECT string_agg(a, ',' ORDER BY a) FROM table;
</programlisting>
    not this:
<programlisting>
SELECT string_agg(a ORDER BY a, ',') FROM table;  -&minus; incorrect
</programlisting>
    The latter is syntactically valid, but it represents a call of a
    single-argument aggregate function with two <literal>ORDER BY</> keys
    (the second one being rather useless since it's a constant).
   </para>
____________________________________________________________________________-->
   <para>
    在处理多参数聚合函数时，注意<literal>ORDER BY</>出现在所有聚合参数之后。例如，要这样写：
<programlisting>
SELECT string_agg(a, ',' ORDER BY a) FROM table;
</programlisting>
    而不能这样写：
<programlisting>
SELECT string_agg(a ORDER BY a, ',') FROM table;  -- 不正确
</programlisting>
    后者在语法上是合法的，但是它表示用两个<literal>ORDER BY</>键来调用一个单一参数聚合函数（第二个是无用的，因为它是一个常量）。
   </para>

<!--==========================orignal english content==========================
   <para>
    If <literal>DISTINCT</> is specified in addition to an
    <replaceable>order_by_clause</>, then all the <literal>ORDER BY</>
    expressions must match regular arguments of the aggregate; that is,
    you cannot sort on an expression that is not included in the
    <literal>DISTINCT</> list.
   </para>
____________________________________________________________________________-->
   <para>
    如果在<replaceable>order_by_clause</>之外指定了<literal>DISTINCT</>，那么所有的<literal>ORDER BY</>表达式必须匹配聚合的常规参数。也就是说，你不能在<literal>DISTINCT</>列表没有包括的表达式上排序。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     The ability to specify both <literal>DISTINCT</> and <literal>ORDER BY</>
     in an aggregate function is a <productname>PostgreSQL</> extension.
    </para>
____________________________________________________________________________-->
    <para>
     在一个聚合函数中指定<literal>DISTINCT</>以及<literal>ORDER BY</>的能力是一种<productname>PostgreSQL</>扩展。
    </para>
   </note>
   
<!--==========================orignal english content==========================
   <para>
    Placing <literal>ORDER BY</> within the aggregate's regular argument
    list, as described so far, is used when ordering the input rows for
    a <quote>normal</> aggregate for which ordering is optional.  There is a
    subclass of aggregate functions called <firstterm>ordered-set
    aggregates</> for which an <replaceable>order_by_clause</replaceable>
    is <emphasis>required</>, usually because the aggregate's computation is
    only sensible in terms of a specific ordering of its input rows.
    Typical examples of ordered-set aggregates include rank and percentile
    calculations.  For an ordered-set aggregate,
    the <replaceable>order_by_clause</replaceable> is written
    inside <literal>WITHIN GROUP (...)</>, as shown in the final syntax
    alternative above.  The expressions in
    the <replaceable>order_by_clause</replaceable> are evaluated once per
    input row just like regular aggregate arguments, sorted as per
    the <replaceable>order_by_clause</replaceable>'s requirements, and fed
    to the aggregate function as input arguments.  (This is unlike the case
    for a non-<literal>WITHIN GROUP</> <replaceable>order_by_clause</>,
    which is not treated as argument(s) to the aggregate function.)  The
    argument expressions preceding <literal>WITHIN GROUP</>, if any, are
    called <firstterm>direct arguments</> to distinguish them from
    the <firstterm>aggregated arguments</> listed in
    the <replaceable>order_by_clause</replaceable>.  Unlike regular aggregate
    arguments, direct arguments are evaluated only once per aggregate call,
    not once per input row.  This means that they can contain variables only
    if those variables are grouped by <literal>GROUP BY</>; this restriction
    is the same as if the direct arguments were not inside an aggregate
    expression at all.  Direct arguments are typically used for things like
    percentile fractions, which only make sense as a single value per
    aggregation calculation.  The direct argument list can be empty; in this
    case, write just <literal>()</> not <literal>(*)</>.
    (<productname>PostgreSQL</> will actually accept either spelling, but
    only the first way conforms to the SQL standard.)
   </para>
____________________________________________________________________________-->
   <para>
    如上所述，如果通用和统计聚合中排序是可选的，
	在要为它排序输入行时可以在该聚合的常规参数
    列表中放置<literal>ORDER BY</>。有一个聚合函数的子集叫
    做<firstterm>有序集聚合</>，它<emphasis>要求</>一个
    <replaceable>order_by_clause</replaceable>，通常是因为
    该聚合的计算只对其输入行的特定顺序有意义。有序集聚合的典
    型例子包括排名和百分位计算。按照上文的最后一种语法，对于
    一个有序集聚合，
    <replaceable>order_by_clause</replaceable>被写在
    <literal>WITHIN GROUP (...)</>中。
     <replaceable>order_by_clause</replaceable>中的表达式
     会像常规聚合参数一样对每一个输入行计算一次，按照每个
     <replaceable>order_by_clause</replaceable>的要求排序并
     且交给该聚合函数作为输入参数（这和非
     <literal>WITHIN GROUP</> 
     <replaceable>order_by_clause</>的情况不同，在其中表达
     式的结果不会被作为聚合函数的参数）。如果有在
     <literal>WITHIN GROUP</>之前的参数表达式，会把它们称
     为<firstterm>直接参数</>以便与列在
     <replaceable>order_by_clause</replaceable>中的
     <firstterm>聚合参数</>相区分。与常规聚合参数不同，针对
     每次聚合调用只会计算一次直接参数，而不是为每一个输入行
     计算一次。这意味着只有那些变量被<literal>GROUP BY</>
     分组时，它们才能包含这些变量。这个限制同样适用于根本不在
     一个聚合表达式内部的直接参数。直接参数通常被用于百分数
     之类的东西，它们只有作为每次聚合计算用一次的单一值才有意
     义。直接参数列表可以为空，在这种情况下，写成<literal>()</>
     而不是<literal>(*)</>（实际上
     <productname>PostgreSQL</>接受两种拼写，但是只有第一
     种符合 SQL 标准）。
   </para>
<!--==========================orignal english content==========================
   <para>
    <indexterm>
     <primary>median</primary>
     <seealso>percentile</seealso>
    </indexterm>
    An example of an ordered-set aggregate call is:

<programlisting>
SELECT percentile_cont(0.5) WITHIN GROUP (ORDER BY income) FROM households;
 percentile_cont
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
           50489
</programlisting>

   which obtains the 50th percentile, or median, value of
   the <structfield>income</> column from table <structname>households</>.
   Here, <literal>0.5</> is a direct argument; it would make no sense
   for the percentile fraction to be a value varying across rows.
   </para>
____________________________________________________________________________-->
   <para>
    <indexterm>
     <primary>median</primary>
     <seealso>percentile</seealso>
    </indexterm>
	有序集聚合的调用例子：

<programlisting>
SELECT percentile_cont(0.5) WITHIN GROUP (ORDER BY income) FROM households;
 percentile_cont
-----------------
           50489
</programlisting>

   这会从表<structname>households</>的
   <structfield>income</>列得到第 50 个百分位或者中位的值。
   这里<literal>0.5</>是一个直接参数，对于百分位部分是一个
   在不同行之间变化的值的情况它没有意义。
   </para>

<!--==========================orignal english content==========================
   <para>
    If <literal>FILTER</literal> is specified, then only the input
    rows for which the <replaceable>filter_clause</replaceable>
    evaluates to true are fed to the aggregate function; other rows
    are discarded.  For example:
<programlisting>
SELECT
    count(*) AS unfiltered,
    count(*) FILTER (WHERE i < 5) AS filtered
FROM generate_series(1,10) AS s(i);
 unfiltered | filtered
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;
         10 |        4
(1 row)
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    如果指定了<literal>FILTER</literal>，那么只有对<replaceable>filter_clause</replaceable>计算为真的输入行会被交给该聚合函数，其他行会被丢弃。例如：
<programlisting>
SELECT
    count(*) AS unfiltered,
    count(*) FILTER (WHERE i < 5) AS filtered
FROM generate_series(1,10) AS s(i);
 unfiltered | filtered
------------+----------
         10 |        4
(1 row)
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    The predefined aggregate functions are described in <xref
    linkend="functions-aggregate">.  Other aggregate functions can be added
    by the user.
   </para>
____________________________________________________________________________-->
   <para>
    预定义的聚合函数在<xref linkend="functions-aggregate">中描述。其他聚合函数可以由用户增加。
   </para>

<!--==========================orignal english content==========================
   <para>
    An aggregate expression can only appear in the result list or
    <literal>HAVING</> clause of a <command>SELECT</> command.
    It is forbidden in other clauses, such as <literal>WHERE</>,
    because those clauses are logically evaluated before the results
    of aggregates are formed.
   </para>
____________________________________________________________________________-->
   <para>
    一个聚合表达式只能出现在<command>SELECT</>命令的结果列表或是<literal>HAVING</>子句中。在其他子句（如<literal>WHERE</>）中禁止使用它，因为那些子句的计算在逻辑上是在聚合的结果被形成之前。
   </para>

<!--==========================orignal english content==========================
   <para>
    When an aggregate expression appears in a subquery (see
    <xref linkend="sql-syntax-scalar-subqueries"> and
    <xref linkend="functions-subquery">), the aggregate is normally
    evaluated over the rows of the subquery.  But an exception occurs
    if the aggregate's arguments (and <replaceable>filter_clause</replaceable>
    if any) contain only outer-level variables:
    the aggregate then belongs to the nearest such outer level, and is
    evaluated over the rows of that query.  The aggregate expression
    as a whole is then an outer reference for the subquery it appears in,
    and acts as a constant over any one evaluation of that subquery.
    The restriction about
    appearing only in the result list or <literal>HAVING</> clause
    applies with respect to the query level that the aggregate belongs to.
   </para>
____________________________________________________________________________-->
   <para>
    当一个聚合表达式出现在一个子查询中（见<xref linkend="sql-syntax-scalar-subqueries">和<xref linkend="functions-subquery">），聚合通常在该子查询的行上被计算。但是如果该聚合的参数（以及<replaceable>filter_clause</replaceable>，如果有）只包含外层变量则会产生一个异常：该聚合则属于最近的那个外层，并且会在那个查询的行上被计算。该聚合表达式从整体上则是对其所出现于的子查询的一种外层引用，并且在那个子查询的任意一次计算中都作为一个常量。只出现在结果列表或<literal>HAVING</>子句的限制适用于该聚合所属的查询层次。
   </para>
  </sect2>

  <sect2 id="syntax-window-functions">
<!--==========================orignal english content==========================
   <title>Window Function Calls</title>
____________________________________________________________________________-->
   <title>窗口函数调用</title>

<!--==========================orignal english content==========================
   <indexterm zone="syntax-window-functions">
    <primary>window function</primary>
    <secondary>invocation</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="syntax-window-functions">
    <primary>窗口函数</primary>
    <secondary>invocation</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="syntax-window-functions">
    <primary>OVER clause</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="syntax-window-functions">
    <primary>OVER clause</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    A <firstterm>window function call</firstterm> represents the application
    of an aggregate-like function over some portion of the rows selected
    by a query.  Unlike non-window aggregate calls, this is not tied
    to grouping of the selected rows into a single output row &mdash; each
    row remains separate in the query output.  However the window function
    has access to all the rows that would be part of the current row's
    group according to the grouping specification (<literal>PARTITION BY</>
    list) of the window function call.
    The syntax of a window function call is one of the following:

<synopsis>
<replaceable>function_name</replaceable> (<optional><replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ... </optional></optional>) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ] OVER <replaceable>window_name</replaceable>
<replaceable>function_name</replaceable> (<optional><replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ... </optional></optional>) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ] OVER ( <replaceable class="parameter">window_definition</replaceable> )
<replaceable>function_name</replaceable> ( * ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ] OVER <replaceable>window_name</replaceable>
<replaceable>function_name</replaceable> ( * ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ] OVER ( <replaceable class="parameter">window_definition</replaceable> )
</synopsis>
    where <replaceable class="parameter">window_definition</replaceable>
    has the syntax
<synopsis>
[ <replaceable class="parameter">existing_window_name</replaceable> ]
[ PARTITION BY <replaceable class="parameter">expression</replaceable> [, ...] ]
[ ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC | USING <replaceable class="parameter">operator</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...] ]
[ <replaceable class="parameter">frame_clause</replaceable> ]
</synopsis>
    and the optional <replaceable class="parameter">frame_clause</replaceable>
    can be one of
<synopsis>
{ RANGE | ROWS } <replaceable>frame_start</>
{ RANGE | ROWS } BETWEEN <replaceable>frame_start</> AND <replaceable>frame_end</>
</synopsis>
    where <replaceable>frame_start</> and <replaceable>frame_end</> can be
    one of
<synopsis>
UNBOUNDED PRECEDING
<replaceable>value</replaceable> PRECEDING
CURRENT ROW
<replaceable>value</replaceable> FOLLOWING
UNBOUNDED FOLLOWING
</synopsis>
   </para>
____________________________________________________________________________-->
   <para>
    一个<firstterm>窗口函数调用</firstterm>表示在一个查询选择的行的某个部分上应用一个聚合类的函数。和非窗口聚合调用不同，这不会被约束为将被选择的行分组为一个单一的输出行 &mdash; 在查询输出中每一个行仍保持独立。
	但是，根据窗口函数调用的分组规范（<literal>PARTITION BY</>列表），
	窗口函数可以访问将成为当前行组的一部分的所有行。
	一个窗口函数调用的语法是下列之一：

<synopsis>
<replaceable>function_name</replaceable> (<optional><replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ... </optional></optional>) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ] OVER <replaceable>window_name</replaceable>
<replaceable>function_name</replaceable> (<optional><replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ... </optional></optional>) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ] OVER ( <replaceable class="parameter">window_definition</replaceable> )
<replaceable>function_name</replaceable> ( * ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ] OVER <replaceable>window_name</replaceable>
<replaceable>function_name</replaceable> ( * ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ] OVER ( <replaceable class="parameter">window_definition</replaceable> )
</synopsis>
    其中<replaceable class="parameter">window_definition</replaceable>的语法是
<synopsis>
[ <replaceable class="parameter">existing_window_name</replaceable> ]
[ PARTITION BY <replaceable class="parameter">expression</replaceable> [, ...] ]
[ ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC | USING <replaceable class="parameter">operator</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...] ]
[ <replaceable class="parameter">frame_clause</replaceable> ]
</synopsis>
    而可选的<replaceable class="parameter">frame_clause</replaceable>是下列之一
<synopsis>
{ RANGE | ROWS } <replaceable>frame_start</>
{ RANGE | ROWS } BETWEEN <replaceable>frame_start</> AND <replaceable>frame_end</>
</synopsis>
    其中<replaceable>frame_start</>和<replaceable>frame_end</>可以是下面形式中的一种
<synopsis>
UNBOUNDED PRECEDING
<replaceable>value</replaceable> PRECEDING
CURRENT ROW
<replaceable>value</replaceable> FOLLOWING
UNBOUNDED FOLLOWING
</synopsis>
   </para>

<!--==========================orignal english content==========================
   <para>
    Here, <replaceable>expression</replaceable> represents any value
    expression that does not itself contain window function calls.
   </para>
____________________________________________________________________________-->
   <para>
    这里，<replaceable>expression</replaceable>表示任何自身不含有窗口函数调用的值表达式。
   </para>

<!--==========================orignal english content==========================
   <para>
    <replaceable>window_name</replaceable> is a reference to a named window
    specification defined in the query's <literal>WINDOW</literal> clause.
    Alternatively, a full <replaceable>window_definition</replaceable> can
    be given within parentheses, using the same syntax as for defining a
    named window in the <literal>WINDOW</literal> clause; see the
    <xref linkend="sql-select"> reference page for details.  It's worth
    pointing out that <literal>OVER wname</> is not exactly equivalent to
    <literal>OVER (wname ...)</>; the latter implies copying and modifying the
    window definition, and will be rejected if the referenced window
    specification includes a frame clause.
   </para>
____________________________________________________________________________-->
   <para>
    <replaceable>window_name</replaceable>是对定义在查询的<literal>WINDOW</literal>子句中的一个命名窗口声明的引用。还可以使用在<literal>WINDOW</literal>子句中定义命名窗口的相同语法在圆括号内给定一个完整的<replaceable>window_definition</replaceable>，详见<xref linkend="sql-select">参考页。值得指出的是，<literal>OVER wname</>并不严格地等价于<literal>OVER (wname ...)</>，后者表示复制并修改窗口定义，并且在被引用窗口声明包括一个帧子句时会被拒绝。
   </para>

<!--==========================orignal english content==========================
   <para>
    The <literal>PARTITION BY</> clause groups the rows of the query into
    <firstterm>partitions</>, which are processed separately by the window
    function.  <literal>PARTITION BY</> works similarly to a query-level
    <literal>GROUP BY</> clause, except that its expressions are always just
    expressions and cannot be output-column names or numbers.
    Without <literal>PARTITION BY</>, all rows produced by the query are
    treated as a single partition.
    The <literal>ORDER BY</> clause determines the order in which the rows
    of a partition are processed by the window function.  It works similarly
    to a query-level <literal>ORDER BY</> clause, but likewise cannot use
    output-column names or numbers.  Without <literal>ORDER BY</>, rows are
    processed in an unspecified order.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>PARTITION BY</>子句将查询的行分组成为<firstterm>分区</>，窗口函数会独立地处理它们。<literal>PARTITION BY</>工作起来类似于一个查询级别的<literal>GROUP BY</>子句，不过它的表达式总是只是表达式并且不能是输出列的名称或编号。如果没有<literal>PARTITION BY</>，该查询产生的所有行被当作一个单一分区来处理。<literal>ORDER BY</>子句决定被窗口函数处理的一个分区中的行的顺序。它工作起来类似于一个查询级别的<literal>ORDER BY</>子句，但是同样不能使用输出列的名称或编号。如果没有<literal>ORDER BY</>，行将被以未指定的顺序被处理。
   </para>

<!--==========================orignal english content==========================
   <para>
    The <replaceable class="parameter">frame_clause</replaceable> specifies
    the set of rows constituting the <firstterm>window frame</>, which is a
    subset of the current partition, for those window functions that act on
    the frame instead of the whole partition.  The frame can be specified in
    either <literal>RANGE</> or <literal>ROWS</> mode; in either case, it
    runs from the <replaceable>frame_start</> to the
    <replaceable>frame_end</>.  If <replaceable>frame_end</> is omitted,
    it defaults to <literal>CURRENT ROW</>.
   </para>
____________________________________________________________________________-->
   <para>
    <replaceable class="parameter">frame_clause</replaceable>指定构成<firstterm>窗口帧</>的行集合，它是当前分区的一个子集，窗口函数将作用在该帧而不是整个分区。 帧可以被指定为<literal>RANGE</>或<literal>ROWS</>模式，在两种情况中它都从<replaceable>frame_start</>运行到<replaceable>frame_end</>。如果<replaceable>frame_end</>被忽略，它默认运行到<literal>CURRENT ROW</>。
   </para>

<!--==========================orignal english content==========================
   <para>
    A <replaceable>frame_start</> of <literal>UNBOUNDED PRECEDING</> means
    that the frame starts with the first row of the partition, and similarly
    a <replaceable>frame_end</> of <literal>UNBOUNDED FOLLOWING</> means
    that the frame ends with the last row of the partition.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>UNBOUNDED PRECEDING</>的一个<replaceable>frame_start</>表示该帧开始于分区的第一行，类似地<literal>UNBOUNDED FOLLOWING</>的一个<replaceable>frame_end</>表示该帧结束于分区的最后一行。
   </para>

<!--==========================orignal english content==========================
   <para>
    In <literal>RANGE</> mode, a <replaceable>frame_start</> of
    <literal>CURRENT ROW</> means the frame starts with the current row's
    first <firstterm>peer</> row (a row that <literal>ORDER BY</> considers
    equivalent to the current row), while a <replaceable>frame_end</> of
    <literal>CURRENT ROW</> means the frame ends with the last equivalent
    <literal>ORDER BY</> peer.  In <literal>ROWS</> mode, <literal>CURRENT ROW</> simply means
    the current row.
   </para>
____________________________________________________________________________-->
   <para>
    在<literal>RANGE</>模式下， <literal>CURRENT ROW</>的一个<replaceable>frame_start</>表示该帧开始于当前行的第一个<firstterm>平级</>行（一个被<literal>ORDER BY</>认为与当前行等效的行），而<literal>CURRENT ROW</>的一个<replaceable>frame_end</>表示该帧结束于最后一个等效的<literal>ORDER BY</>平级行。在<literal>ROWS</>模式下，<literal>CURRENT ROW</>仅表示当前行。
   </para>

<!--==========================orignal english content==========================
   <para>
    The <replaceable>value</> <literal>PRECEDING</> and
    <replaceable>value</> <literal>FOLLOWING</> cases are currently only
    allowed in <literal>ROWS</> mode.  They indicate that the frame starts
    or ends the specified number of rows before or after the current row.
    <replaceable>value</replaceable> must be an integer expression not
    containing any variables, aggregate functions, or window functions.
    The value must not be null or negative; but it can be zero, which
    just selects the current row.
   </para>
____________________________________________________________________________-->
   <para>
    <replaceable>value</> <literal>PRECEDING</>和<replaceable>value</> <literal>FOLLOWING</>情况当前只在<literal>ROWS</>模式中被允许。它们指示帧开始或结束于当前行之前或之后的指定数量的行。<replaceable>value</replaceable>必须是一个不包含任何变量、聚合函数或窗口函数的整数表达式。该值不能为空或负，但是可以为零，零表示只选择当前行。
   </para>

<!--==========================orignal english content==========================
   <para>
    The default framing option is <literal>RANGE UNBOUNDED PRECEDING</>,
    which is the same as <literal>RANGE BETWEEN UNBOUNDED PRECEDING AND
    CURRENT ROW</>.  With <literal>ORDER BY</>, this sets the frame to be
    all rows from the partition start up through the current row's last
    <literal>ORDER BY</> peer.  Without <literal>ORDER BY</>, all rows of the partition are
    included in the window frame, since all rows become peers of the current
    row.
   </para>
____________________________________________________________________________-->
   <para>
    默认的帧选项是<literal>RANGE UNBOUNDED PRECEDING</>，它和<literal>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</>相同。如果使用<literal>ORDER BY</>，这会把该帧设置为从分区开始一直到当前行的最后一个<literal>ORDER BY</>平级行的所有行。如果不使用<literal>ORDER BY</>，分区中所有的行都被包括在窗口帧中，因为所有行都成为了当前行的平级行。
   </para>

<!--==========================orignal english content==========================
   <para>
    Restrictions are that
    <replaceable>frame_start</> cannot be <literal>UNBOUNDED FOLLOWING</>,
    <replaceable>frame_end</> cannot be <literal>UNBOUNDED PRECEDING</>,
    and the <replaceable>frame_end</> choice cannot appear earlier in the
    above list than the <replaceable>frame_start</> choice &mdash; for example
    <literal>RANGE BETWEEN CURRENT ROW AND <replaceable>value</>
    PRECEDING</literal> is not allowed.
   </para>
____________________________________________________________________________-->
   <para>
    限制是<replaceable>frame_start</>不能为<literal>UNBOUNDED FOLLOWING</>、<replaceable>frame_end</>不能为<literal>UNBOUNDED PRECEDING</>并且在上述列表中<replaceable>frame_end</>的选择不能早于<replaceable>frame_start</>的选择出现 &mdash; 例如<literal>RANGE BETWEEN CURRENT ROW AND <replaceable>value</> PRECEDING</literal>是不被允许的。
   </para>
   
<!--==========================orignal english content==========================
   <para>
    If <literal>FILTER</literal> is specified, then only the input
    rows for which the <replaceable>filter_clause</replaceable>
    evaluates to true are fed to the window function; other rows
    are discarded.  Only window functions that are aggregates accept
    a <literal>FILTER</literal> clause.
   </para>
____________________________________________________________________________-->
   <para>
    如果指定了<literal>FILTER</literal>，那么只有对<replaceable>filter_clause</replaceable>计算为真的输入行会被交给该窗口函数，其他行会被丢弃。只有是聚合的窗口函数才接受<literal>FILTER</literal> 。
   </para>

<!--==========================orignal english content==========================
   <para>
    The built-in window functions are described in <xref
    linkend="functions-window-table">.  Other window functions can be added by
    the user.  Also, any built-in or user-defined general-purpose or
    statistical aggregate can be used as a window function.  (Ordered-set
    and hypothetical-set aggregates cannot presently be used as window functions.)
   </para>
____________________________________________________________________________-->
   <para>
    内建的窗口函数在<xref linkend="functions-window-table">中描述。
    用户可以增加其他的窗口函数。还有，任何内建或用户定义的通用或统计聚合
    函数可以被用作窗口函数。（有序聚合和假设集聚合目前不能用作窗口函数。）
   </para>

<!--==========================orignal english content==========================
   <para>
    The syntaxes using <literal>*</> are used for calling parameter-less
    aggregate functions as window functions, for example
    <literal>count(*) OVER (PARTITION BY x ORDER BY y)</>.
    The asterisk (<literal>*</>) is customarily not used for
    window-specific functions.  Window-specific functions do not
    allow <literal>DISTINCT</> or <literal>ORDER BY</> to be used within the
    function argument list.
   </para>
____________________________________________________________________________-->
   <para>
    使用<literal>*</>的语法被用来把参数较少的聚合函数当作窗口函数调用，
	例如<literal>count(*) OVER (PARTITION BY x ORDER BY y)</>。
	星号（<literal>*</>）通常通常不用于窗口特定的函数。窗口特定的函数不允许在函数参数列表中使用<literal>DISTINCT</>或<literal>ORDER BY</>。
   </para>

<!--==========================orignal english content==========================
   <para>
    Window function calls are permitted only in the <literal>SELECT</literal>
    list and the <literal>ORDER BY</> clause of the query.
   </para>
____________________________________________________________________________-->
   <para>
    只有在<literal>SELECT</literal>列表和查询的<literal>ORDER BY</>子句中才允许窗口函数调用。
   </para>

<!--==========================orignal english content==========================
   <para>
    More information about window functions can be found in
    <xref linkend="tutorial-window">,
    <xref linkend="functions-window">, and
    <xref linkend="queries-window">.
   </para>
____________________________________________________________________________-->
   <para>
    更多关于窗口函数的信息可以在<xref linkend="tutorial-window">、<xref linkend="functions-window">以及<xref linkend="queries-window">中找到。
   </para>
  </sect2>

  <sect2 id="sql-syntax-type-casts">
<!--==========================orignal english content==========================
   <title>Type Casts</title>
____________________________________________________________________________-->
   <title>类型转换</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>data type</primary>
    <secondary>type cast</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>data type</primary>
    <secondary>type cast</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>type cast</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>type cast</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>::</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>::</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    A type cast specifies a conversion from one data type to another.
    <productname>PostgreSQL</productname> accepts two equivalent syntaxes
    for type casts:
<synopsis>
CAST ( <replaceable>expression</replaceable> AS <replaceable>type</replaceable> )
<replaceable>expression</replaceable>::<replaceable>type</replaceable>
</synopsis>
    The <literal>CAST</> syntax conforms to SQL; the syntax with
    <literal>::</literal> is historical <productname>PostgreSQL</productname>
    usage.
   </para>
____________________________________________________________________________-->
   <para>
    一个类型造型指定从一种数据类型到另一种数据类型的转换。<productname>PostgreSQL</productname>接受两种等价的类型造型语法：
<synopsis>
CAST ( <replaceable>expression</replaceable> AS <replaceable>type</replaceable> )
<replaceable>expression</replaceable>::<replaceable>type</replaceable>
</synopsis>
    <literal>CAST</>语法遵从 SQL，而用<literal>::</literal>的语法是<productname>PostgreSQL</productname>的历史用法。
   </para>

<!--==========================orignal english content==========================
   <para>
    When a cast is applied to a value expression of a known type, it
    represents a run-time type conversion.  The cast will succeed only
    if a suitable type conversion operation has been defined.  Notice that this
    is subtly different from the use of casts with constants, as shown in
    <xref linkend="sql-syntax-constants-generic">.  A cast applied to an
    unadorned string literal represents the initial assignment of a type
    to a literal constant value, and so it will succeed for any type
    (if the contents of the string literal are acceptable input syntax for the
    data type).
   </para>
____________________________________________________________________________-->
   <para>
    当一个造型被应用到一种未知类型的值表达式上时，它表示一种运行时类型转换。只有已经定义了一种合适的类型转换操作时，该造型才会成功。注意这和常量的造型（如<xref linkend="sql-syntax-constants-generic">中所示）使用不同。应用于一个未修饰串文字的造型表示一种类型到一个文字常量值的初始赋值，并且因此它将对任意类型都成功（如果该串文字的内容对于该数据类型的输入语法是可接受的）。
   </para>

<!--==========================orignal english content==========================
   <para>
    An explicit type cast can usually be omitted if there is no ambiguity as
    to the type that a value expression must produce (for example, when it is
    assigned to a table column); the system will automatically apply a
    type cast in such cases.  However, automatic casting is only done for
    casts that are marked <quote>OK to apply implicitly</>
    in the system catalogs.  Other casts must be invoked with
    explicit casting syntax.  This restriction is intended to prevent
    surprising conversions from being applied silently.
   </para>
____________________________________________________________________________-->
   <para>
    如果一个值表达式必须产生的类型没有歧义（例如当它被指派给一个表列），通常可以省略显式类型造型，在这种情况下系统会自动应用一个类型造型。但是，只有对在系统目录中被标记为<quote>OK to apply implicitly</>的造型才会执行自动造型。其他造型必须使用显式造型语法调用。这种限制是为了防止出人意料的转换被无声无息地应用。
   </para>

<!--==========================orignal english content==========================
   <para>
    It is also possible to specify a type cast using a function-like
    syntax:
<synopsis>
<replaceable>typename</replaceable> ( <replaceable>expression</replaceable> )
</synopsis>
    However, this only works for types whose names are also valid as
    function names.  For example, <literal>double precision</literal>
    cannot be used this way, but the equivalent <literal>float8</literal>
    can.  Also, the names <literal>interval</>, <literal>time</>, and
    <literal>timestamp</> can only be used in this fashion if they are
    double-quoted, because of syntactic conflicts.  Therefore, the use of
    the function-like cast syntax leads to inconsistencies and should
    probably be avoided.
   </para>
____________________________________________________________________________-->
   <para>
    还可以用像函数的语法来指定一次类型造型：
<synopsis>
<replaceable>typename</replaceable> ( <replaceable>expression</replaceable> )
</synopsis>
    不过，这只对那些名字也作为函数名可用的类型有效。例如，<literal>double precision</literal>不能以这种方式使用，但是等效的<literal>float8</literal>可以。还有，如果名称<literal>interval</>、<literal>time</>和<literal>timestamp</>被用双引号引用，那么由于语法冲突的原因，它们只能以这种风格使用。因此，函数风格的造型语法的使用会导致不一致性并且应该尽可能被避免。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     The function-like syntax is in fact just a function call.  When
     one of the two standard cast syntaxes is used to do a run-time
     conversion, it will internally invoke a registered function to
     perform the conversion.  By convention, these conversion functions
     have the same name as their output type, and thus the <quote>function-like
     syntax</> is nothing more than a direct invocation of the underlying
     conversion function.  Obviously, this is not something that a portable
     application should rely on.  For further details see
     <xref linkend="sql-createcast">.
    </para>
____________________________________________________________________________-->
    <para>
     函数风格的语法事实上只是一次函数调用。当两种标准造型语法之一被用来做一次运行时转换时，它将在内部调用一个已注册的函数来执行该转换。简而言之，这些转换函数具有和它们的输出类型相同的名字，并且因此<quote>函数风格的语法</>无非是对底层转换函数的一次直接调用。显然，一个可移植的应用不应当依赖于它。详见<xref linkend="sql-createcast">。
    </para>
   </note>
  </sect2>

  <sect2 id="sql-syntax-collate-exprs">
<!--==========================orignal english content==========================
   <title>Collation Expressions</title>
____________________________________________________________________________-->
   <title>排序规则表达式</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>COLLATE</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>COLLATE</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The <literal>COLLATE</literal> clause overrides the collation of
    an expression.  It is appended to the expression it applies to:
<synopsis>
<replaceable>expr</replaceable> COLLATE <replaceable>collation</replaceable>
</synopsis>
    where <replaceable>collation</replaceable> is a possibly
    schema-qualified identifier.  The <literal>COLLATE</literal>
    clause binds tighter than operators; parentheses can be used when
    necessary.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>COLLATE</literal>子句会重载一个表达式的排序规则。它被追加到它适用的表达式：
<synopsis>
<replaceable>expr</replaceable> COLLATE <replaceable>collation</replaceable>
</synopsis>
    这里<replaceable>collation</replaceable>可能是一个受模式限定的标识符。<literal>COLLATE</literal>子句比操作符绑得更紧，需要时可以使用圆括号。
   </para>

<!--==========================orignal english content==========================
   <para>
    If no collation is explicitly specified, the database system
    either derives a collation from the columns involved in the
    expression, or it defaults to the default collation of the
    database if no column is involved in the expression.
   </para>
____________________________________________________________________________-->
   <para>
    如果没有显式指定排序规则，数据库系统会从表达式所涉及的列中得到一个排序规则，如果该表达式没有涉及列，则会默认采用数据库的默认排序规则。
   </para>

<!--==========================orignal english content==========================
   <para>
    The two common uses of the <literal>COLLATE</literal> clause are
    overriding the sort order in an <literal>ORDER BY</> clause, for
    example:
<programlisting>
SELECT a, b, c FROM tbl WHERE ... ORDER BY a COLLATE "C";
</programlisting>
    and overriding the collation of a function or operator call that
    has locale-sensitive results, for example:
<programlisting>
SELECT * FROM tbl WHERE a &gt; 'foo' COLLATE "C";
</programlisting>
    Note that in the latter case the <literal>COLLATE</> clause is
    attached to an input argument of the operator we wish to affect.
    It doesn't matter which argument of the operator or function call the
    <literal>COLLATE</> clause is attached to, because the collation that is
    applied by the operator or function is derived by considering all
    arguments, and an explicit <literal>COLLATE</> clause will override the
    collations of all other arguments.  (Attaching non-matching
    <literal>COLLATE</> clauses to more than one argument, however, is an
    error.  For more details see <xref linkend="collation">.)
    Thus, this gives the same result as the previous example:
<programlisting>
SELECT * FROM tbl WHERE a COLLATE "C" &gt; 'foo';
</programlisting>
    But this is an error:
<programlisting>
SELECT * FROM tbl WHERE (a &gt; 'foo') COLLATE "C";
</programlisting>
    because it attempts to apply a collation to the result of the
    <literal>&gt;</> operator, which is of the non-collatable data type
    <type>boolean</>.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>COLLATE</literal>子句的两种常见使用是重载<literal>ORDER BY</>子句中的排序顺序，例如：
<programlisting>
SELECT a, b, c FROM tbl WHERE ... ORDER BY a COLLATE "C";
</programlisting>
    以及重载具有区域敏感结果的函数或操作符调用的排序规则，例如：
<programlisting>
SELECT * FROM tbl WHERE a &gt; 'foo' COLLATE "C";
</programlisting>
    注意在后一种情况中，<literal>COLLATE</>子句被附加到我们希望影响的操作符的一个输入参数上。<literal>COLLATE</>子句被附加到该操作符或函数调用的哪个参数上无关紧要，因为被操作符或函数应用的排序规则是考虑所有参数得来的，并且一个显式的<literal>COLLATE</>子句将重载所有其他参数的排序规则（不过，附加非匹配<literal>COLLATE</>子句到多于一个参数是一种错误。详见<xref linkend="collation">）。因此，这会给出和前一个例子相同的结果：
<programlisting>
SELECT * FROM tbl WHERE a COLLATE "C" &gt; 'foo';
</programlisting>
    但是这是一个错误：
<programlisting>
SELECT * FROM tbl WHERE (a &gt; 'foo') COLLATE "C";
</programlisting>
    因为它尝试把一个排序规则应用到<literal>&gt;</>操作符的结果，而它的数据类型是非可排序数据类型<type>boolean</>。
   </para>
  </sect2>

  <sect2 id="sql-syntax-scalar-subqueries">
<!--==========================orignal english content==========================
   <title>Scalar Subqueries</title>
____________________________________________________________________________-->
   <title>标量子查询</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>subquery</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>子查询</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    A scalar subquery is an ordinary
    <command>SELECT</command> query in parentheses that returns exactly one
    row with one column.  (See <xref linkend="queries"> for information about writing queries.)
    The <command>SELECT</command> query is executed
    and the single returned value is used in the surrounding value expression.
    It is an error to use a query that
    returns more than one row or more than one column as a scalar subquery.
    (But if, during a particular execution, the subquery returns no rows,
    there is no error; the scalar result is taken to be null.)
    The subquery can refer to variables from the surrounding query,
    which will act as constants during any one evaluation of the subquery.
    See also <xref linkend="functions-subquery"> for other expressions involving subqueries.
   </para>
____________________________________________________________________________-->
   <para>
    一个标量子查询是一种圆括号内的普通<command>SELECT</command>查询，它刚好返回一行一列（关于书写查询可见<xref linkend="queries">）。<command>SELECT</command>查询被执行并且该单一返回值被使用在周围的值表达式中。将一个返回超过一行或一列的查询作为一个标量子查询使用是一种错误（但是如果在一次特定执行期间该子查询没有返回行则不是错误，该标量结果被当做为空）。该子查询可以从周围的查询中引用变量，这些变量在该子查询的任何一次计算中都将作为常量。对于其他涉及子查询的表达式还可见<xref linkend="functions-subquery">。
   </para>

<!--==========================orignal english content==========================
   <para>
    For example, the following finds the largest city population in each
    state:
<programlisting>
SELECT name, (SELECT max(pop) FROM cities WHERE cities.state = states.name)
    FROM states;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    例如，下列语句会寻找每个州中最大的城市人口：
<programlisting>
SELECT name, (SELECT max(pop) FROM cities WHERE cities.state = states.name)
    FROM states;
</programlisting>
   </para>
  </sect2>

  <sect2 id="sql-syntax-array-constructors">
<!--==========================orignal english content==========================
   <title>Array Constructors</title>
____________________________________________________________________________-->
   <title>数组构造器</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>array</primary>
    <secondary>constructor</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>数组</primary>
    <secondary>构造器</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>ARRAY</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>ARRAY</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    An array constructor is an expression that builds an
    array value using values for its member elements.  A simple array
    constructor
    consists of the key word <literal>ARRAY</literal>, a left square bracket
    <literal>[</>, a list of expressions (separated by commas) for the
    array element values, and finally a right square bracket <literal>]</>.
    For example:
<programlisting>
SELECT ARRAY[1,2,3+4];
  array
-&minus;-&minus;-&minus;-&minus;-
 {1,2,7}
(1 row)
</programlisting>
    By default,
    the array element type is the common type of the member expressions,
    determined using the same rules as for <literal>UNION</> or
    <literal>CASE</> constructs (see <xref linkend="typeconv-union-case">).
    You can override this by explicitly casting the array constructor to the
    desired type, for example:
<programlisting>
SELECT ARRAY[1,2,22.7]::integer[];
  array
-&minus;-&minus;-&minus;-&minus;-&minus;
 {1,2,23}
(1 row)
</programlisting>
    This has the same effect as casting each expression to the array
    element type individually.
    For more on casting, see <xref linkend="sql-syntax-type-casts">.
   </para>
____________________________________________________________________________-->
   <para>
    一个数组构造器是一个能构建一个数组值并且将值用于它的成员元素的表达式。一个简单的数组构造器由关键词<literal>ARRAY</literal>、一个左方括号<literal>[</>、一个用于数组元素值的表达式列表（用逗号分隔）以及最后的一个右方括号<literal>]</>组成。例如：
<programlisting>
SELECT ARRAY[1,2,3+4];
  array
---------
 {1,2,7}
(1 row)
</programlisting>
    默认情况下，数组元素类型是成员表达式的公共类型，使用和<literal>UNION</>或<literal>CASE</>结构（见<xref linkend="typeconv-union-case">）相同的规则决定。你可以通过显式将数组构造器造型为想要的类型来重载，例如：
<programlisting>
SELECT ARRAY[1,2,22.7]::integer[];
  array
----------
 {1,2,23}
(1 row)
</programlisting>
    这和把每一个表达式单独地造型为数组元素类型的效果相同。关于造型的更多信息请见<xref linkend="sql-syntax-type-casts">。
   </para>

<!--==========================orignal english content==========================
   <para>
    Multidimensional array values can be built by nesting array
    constructors.
    In the inner constructors, the key word <literal>ARRAY</literal> can
    be omitted.  For example, these produce the same result:

<programlisting>
SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];
     array
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 {{1,2},{3,4}}
(1 row)

SELECT ARRAY[[1,2],[3,4]];
     array
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 {{1,2},{3,4}}
(1 row)
</programlisting>

    Since multidimensional arrays must be rectangular, inner constructors
    at the same level must produce sub-arrays of identical dimensions.
    Any cast applied to the outer <literal>ARRAY</> constructor propagates
    automatically to all the inner constructors.
  </para>
____________________________________________________________________________-->
   <para>
    多维数组值可以通过嵌套数组构造器来构建。在内层的构造器中，关键词<literal>ARRAY</literal>可以被忽略。例如，这些语句产生相同的结果：

<programlisting>
SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];
     array
---------------
 {{1,2},{3,4}}
(1 row)

SELECT ARRAY[[1,2],[3,4]];
     array
---------------
 {{1,2},{3,4}}
(1 row)
</programlisting>

    因为多维数组必须是矩形的，处于同一层次的内层构造器必须产生相同维度的子数组。任何被应用于外层<literal>ARRAY</>构造器的造型会自动传播到所有的内层构造器。
  </para>

<!--==========================orignal english content==========================
  <para>
    Multidimensional array constructor elements can be anything yielding
    an array of the proper kind, not only a sub-<literal>ARRAY</> construct.
    For example:
<programlisting>
CREATE TABLE arr(f1 int[], f2 int[]);

INSERT INTO arr VALUES (ARRAY[[1,2],[3,4]], ARRAY[[5,6],[7,8]]);

SELECT ARRAY[f1, f2, '{{9,10},{11,12}}'::int[]] FROM arr;
                     array
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 {{{1,2},{3,4}},{{5,6},{7,8}},{{9,10},{11,12}}}
(1 row)
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
    多维数组构造器元素可以是任何得到一个正确种类数组的任何东西，而不仅仅是一个子-<literal>ARRAY</>结构。例如：
<programlisting>
CREATE TABLE arr(f1 int[], f2 int[]);

INSERT INTO arr VALUES (ARRAY[[1,2],[3,4]], ARRAY[[5,6],[7,8]]);

SELECT ARRAY[f1, f2, '{{9,10},{11,12}}'::int[]] FROM arr;
                     array
------------------------------------------------
 {{{1,2},{3,4}},{{5,6},{7,8}},{{9,10},{11,12}}}
(1 row)
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   You can construct an empty array, but since it's impossible to have an
   array with no type, you must explicitly cast your empty array to the
   desired type.  For example:
<programlisting>
SELECT ARRAY[]::integer[];
 array
-&minus;-&minus;-&minus;-
 {}
(1 row)
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   你可以构造一个空数组，但是因为无法得到一个无类型的数组，你必须显式地把你的空数组造型成想要的类型。例如：
<programlisting>
SELECT ARRAY[]::integer[];
 array
-------
 {}
(1 row)
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   It is also possible to construct an array from the results of a
   subquery.  In this form, the array constructor is written with the
   key word <literal>ARRAY</literal> followed by a parenthesized (not
   bracketed) subquery. For example:
<programlisting>
SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE 'bytea%');
                                 array
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 {2011,1954,1948,1952,1951,1244,1950,2005,1949,1953,2006,31,2412,2413}
(1 row)

SELECT ARRAY(SELECT ARRAY[i, i*2] FROM generate_series(1,5) AS a(i));
              array
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 {{1,2},{2,4},{3,6},{4,8},{5,10}}
(1 row)
</programlisting>
   The subquery must return a single column.
   If the subquery's output column is of a non-array type, the resulting
   one-dimensional array will have an element for each row in the
   subquery result, with an element type matching that of the
   subquery's output column.
   If the subquery's output column is of an array type, the result will be
   an array of the same type but one higher dimension; in this case all
   the subquery rows must yield arrays of identical dimensionality, else
   the result would not be rectangular.
  </para>
____________________________________________________________________________-->
  <para>
   也可以从一个子查询的结果构建一个数组。在这种形式中，数组构造器被写为关键词<literal>ARRAY</literal>后跟着一个加了圆括号（不是方括号）的子查询。例如：
<programlisting>
SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE 'bytea%');
                                 array
-----------------------------------------------------------------------
 {2011,1954,1948,1952,1951,1244,1950,2005,1949,1953,2006,31,2412,2413}
(1 row)
</programlisting>
   子查询必须返回一个单一列。如果子查询的输出列是非数组类型，
   结果的一维数组将为该子查询结果中的每一行有一个元素，
   并且有一个与子查询的输出列匹配的元素类型。
   如果子查询的输出列是一种数组类型，结果将是同类型的一个数组，
   但是要高一个维度。在这种情况下，该子查询的所有行必须产生同样维度的数组，
   否则结果就不会是矩形形式。
  </para>

<!--==========================orignal english content==========================
  <para>
   The subscripts of an array value built with <literal>ARRAY</literal>
   always begin with one.  For more information about arrays, see
   <xref linkend="arrays">.
  </para>
____________________________________________________________________________-->
  <para>
   用<literal>ARRAY</literal>构建的一个数组值的下标总是从一开始。更多关于数组的信息，请见<xref linkend="arrays">。
  </para>

  </sect2>

  <sect2 id="sql-syntax-row-constructors">
<!--==========================orignal english content==========================
   <title>Row Constructors</title>
____________________________________________________________________________-->
   <title>行构造器</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>composite type</primary>
    <secondary>constructor</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>组合类型</primary>
    <secondary>构造器</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>row type</primary>
    <secondary>constructor</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>行类型</primary>
    <secondary>构造器</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>ROW</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>ROW</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    A row constructor is an expression that builds a row value (also
    called a composite value) using values
    for its member fields.  A row constructor consists of the key word
    <literal>ROW</literal>, a left parenthesis, zero or more
    expressions (separated by commas) for the row field values, and finally
    a right parenthesis.  For example:
<programlisting>
SELECT ROW(1,2.5,'this is a test');
</programlisting>
    The key word <literal>ROW</> is optional when there is more than one
    expression in the list.
   </para>
____________________________________________________________________________-->
   <para>
    一个行构造器是能够构建一个行值（也称作一个组合类型）并用值作为其成员域的表达式。一个行构造器由关键词<literal>ROW</literal>、一个左圆括号、用于行的域值的零个或多个表达式（用逗号分隔）以及最后的一个右圆括号组成。例如：
<programlisting>
SELECT ROW(1,2.5,'this is a test');
</programlisting>
    当在列表中有超过一个表达式时，关键词<literal>ROW</>是可选的。
   </para>

<!--==========================orignal english content==========================
   <para>
    A row constructor can include the syntax
    <replaceable>rowvalue</replaceable><literal>.*</literal>,
    which will be expanded to a list of the elements of the row value,
    just as occurs when the <literal>.*</> syntax is used at the top level
    of a <command>SELECT</> list (see <xref linkend="rowtypes-usage">).
    For example, if table <literal>t</> has
    columns <literal>f1</> and <literal>f2</>, these are the same:
<programlisting>
SELECT ROW(t.*, 42) FROM t;
SELECT ROW(t.f1, t.f2, 42) FROM t;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    一个行构造器可以包括语法<replaceable>rowvalue</replaceable><literal>.*</literal>，
	它将被扩展为该行值的元素的一个列表，就像在一个顶层<command>SELECT</>列表中使用<literal>.*</>
	时(参阅<xref linkend="rowtypes-usage">)发生的事情一样。例如，如果表<literal>t</>有列<literal>f1</>和<literal>f2</>，那么这些是相同的：
<programlisting>
SELECT ROW(t.*, 42) FROM t;
SELECT ROW(t.f1, t.f2, 42) FROM t;
</programlisting>
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     Before <productname>PostgreSQL</productname> 8.2, the
     <literal>.*</literal> syntax was not expanded in row constructors, so
     that writing <literal>ROW(t.*, 42)</> created a two-field row whose first
     field was another row value.  The new behavior is usually more useful.
     If you need the old behavior of nested row values, write the inner
     row value without <literal>.*</literal>, for instance
     <literal>ROW(t, 42)</>.
    </para>
____________________________________________________________________________-->
    <para>
     在<productname>PostgreSQL</productname> 8.2 以前，<literal>.*</literal>语法在行构造函数中不会被扩展，
	 这样写<literal>ROW(t.*, 42)</>会创建一个有两个域的行，其第一个域是另一个行值。新的行为通常更有用。如果你需要嵌套行值的旧行为，写内层行值时不要用<literal>.*</literal>，例如<literal>ROW(t, 42)</>。
    </para>
   </note>

<!--==========================orignal english content==========================
   <para>
    By default, the value created by a <literal>ROW</> expression is of
    an anonymous record type.  If necessary, it can be cast to a named
    composite type &mdash; either the row type of a table, or a composite type
    created with <command>CREATE TYPE AS</>.  An explicit cast might be needed
    to avoid ambiguity.  For example:
<programlisting>
CREATE TABLE mytable(f1 int, f2 float, f3 text);

CREATE FUNCTION getf1(mytable) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

-&minus; No cast needed since only one getf1() exists
SELECT getf1(ROW(1,2.5,'this is a test'));
 getf1
-&minus;-&minus;-&minus;-
     1
(1 row)

CREATE TYPE myrowtype AS (f1 int, f2 text, f3 numeric);

CREATE FUNCTION getf1(myrowtype) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

-&minus; Now we need a cast to indicate which function to call:
SELECT getf1(ROW(1,2.5,'this is a test'));
ERROR:  function getf1(record) is not unique

SELECT getf1(ROW(1,2.5,'this is a test')::mytable);
 getf1
-&minus;-&minus;-&minus;-
     1
(1 row)

SELECT getf1(CAST(ROW(11,'this is a test',2.5) AS myrowtype));
 getf1
-&minus;-&minus;-&minus;-
    11
(1 row)
</programlisting>
  </para>
____________________________________________________________________________-->
   <para>
    默认情况下，由一个<literal>ROW</>表达式创建的值是一种匿名记录类型。如果必要，它可以被造型为一种命名的组合类型 &mdash; 或者是一个表的行类型，或者是一种用<command>CREATE TYPE AS</>创建的组合类型。为了避免歧义，可能需要一个显式造型。例如：
<programlisting>
CREATE TABLE mytable(f1 int, f2 float, f3 text);

CREATE FUNCTION getf1(mytable) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

-- 不需要造型因为只有一个 getf1() 存在
SELECT getf1(ROW(1,2.5,'this is a test'));
 getf1
-------
     1
(1 row)

CREATE TYPE myrowtype AS (f1 int, f2 text, f3 numeric);

CREATE FUNCTION getf1(myrowtype) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

-- 现在我们需要一个造型来指示要调用哪个函数：
SELECT getf1(ROW(1,2.5,'this is a test'));
ERROR:  function getf1(record) is not unique

SELECT getf1(ROW(1,2.5,'this is a test')::mytable);
 getf1
-------
     1
(1 row)

SELECT getf1(CAST(ROW(11,'this is a test',2.5) AS myrowtype));
 getf1
-------
    11
(1 row)
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Row constructors can be used to build composite values to be stored
   in a composite-type table column, or to be passed to a function that
   accepts a composite parameter.  Also,
   it is possible to compare two row values or test a row with
   <literal>IS NULL</> or <literal>IS NOT NULL</>, for example:
<programlisting>
SELECT ROW(1,2.5,'this is a test') = ROW(1, 3, 'not the same');

SELECT ROW(table.*) IS NULL FROM table;  -&minus; detect all-null rows
</programlisting>
   For more detail see <xref linkend="functions-comparisons">.
   Row constructors can also be used in connection with subqueries,
   as discussed in <xref linkend="functions-subquery">.
  </para>
____________________________________________________________________________-->
  <para>
   行构造器可以被用来构建存储在一个组合类型表列中的组合值，或者被传递给一个接受组合参数的函数。还有，可以比较两个行值，或者用<literal>IS NULL</>或<literal>IS NOT NULL</>测试一个行，例如：
<programlisting>
SELECT ROW(1,2.5,'this is a test') = ROW(1, 3, 'not the same');

SELECT ROW(table.*) IS NULL FROM table;  -- detect all-null rows
</programlisting>
   详见<xref linkend="functions-comparisons">。如<xref linkend="functions-subquery">中所讨论的，行构造器也可以被用来与子查询相连接。
  </para>

  </sect2>

  <sect2 id="syntax-express-eval">
<!--==========================orignal english content==========================
   <title>Expression Evaluation Rules</title>
____________________________________________________________________________-->
   <title>表达式计算规则</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>expression</primary>
    <secondary>order of evaluation</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>表达式</primary>
    <secondary>计算的顺序</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The order of evaluation of subexpressions is not defined.  In
    particular, the inputs of an operator or function are not necessarily
    evaluated left-to-right or in any other fixed order.
   </para>
____________________________________________________________________________-->
   <para>
    子表达式的计算顺序没有被定义。特别地，一个操作符或函数的输入不必按照从左至右或其他任何固定顺序进行计算。
   </para>

<!--==========================orignal english content==========================
   <para>
    Furthermore, if the result of an expression can be determined by
    evaluating only some parts of it, then other subexpressions
    might not be evaluated at all.  For instance, if one wrote:
<programlisting>
SELECT true OR somefunc();
</programlisting>
    then <literal>somefunc()</literal> would (probably) not be called
    at all. The same would be the case if one wrote:
<programlisting>
SELECT somefunc() OR true;
</programlisting>
    Note that this is not the same as the left-to-right
    <quote>short-circuiting</quote> of Boolean operators that is found
    in some programming languages.
   </para>
____________________________________________________________________________-->
   <para>
    此外，如果一个表达式的结果可以通过只计算其一部分来决定，那么其他子表达式可能完全不需要被计算。例如，如果我们写：
<programlisting>
SELECT true OR somefunc();
</programlisting>
    那么<literal>somefunc()</literal>将（可能）完全不被调用。如果我们写成下面这样也是一样：
<programlisting>
SELECT somefunc() OR true;
</programlisting>
    注意这和一些编程语言中布尔操作符从左至右的<quote>短路</quote>不同。
   </para>

<!--==========================orignal english content==========================
   <para>
    As a consequence, it is unwise to use functions with side effects
    as part of complex expressions.  It is particularly dangerous to
    rely on side effects or evaluation order in <literal>WHERE</> and <literal>HAVING</> clauses,
    since those clauses are extensively reprocessed as part of
    developing an execution plan.  Boolean
    expressions (<literal>AND</>/<literal>OR</>/<literal>NOT</> combinations) in those clauses can be reorganized
    in any manner allowed by the laws of Boolean algebra.
   </para>
____________________________________________________________________________-->
   <para>
    因此，在复杂表达式中使用带有副作用的函数是不明智的。在<literal>WHERE</>和<literal>HAVING</>子句中依赖副作用或计算顺序尤其危险，因为在建立一个执行计划时这些子句会被广泛地重新处理。这些子句中布尔表达式（<literal>AND</>/<literal>OR</>/<literal>NOT</>的组合）可能会以布尔代数定律所允许的任何方式被重组。
   </para>

<!--==========================orignal english content==========================
   <para>
    When it is essential to force evaluation order, a <literal>CASE</>
    construct (see <xref linkend="functions-conditional">) can be
    used.  For example, this is an untrustworthy way of trying to
    avoid division by zero in a <literal>WHERE</> clause:
<programlisting>
SELECT ... WHERE x &gt; 0 AND y/x &gt; 1.5;
</programlisting>
    But this is safe:
<programlisting>
SELECT ... WHERE CASE WHEN x &gt; 0 THEN y/x &gt; 1.5 ELSE false END;
</programlisting>
    A <literal>CASE</> construct used in this fashion will defeat optimization
    attempts, so it should only be done when necessary.  (In this particular
    example, it would be better to sidestep the problem by writing
    <literal>y &gt; 1.5*x</> instead.)
   </para>
____________________________________________________________________________-->
   <para>
    当有必要强制计算顺序时，可以使用一个<literal>CASE</>结构（见<xref linkend="functions-conditional">）。例如，在一个<literal>WHERE</>子句中使用下面的方法尝试避免除零是不可靠的：
<programlisting>
SELECT ... WHERE x &gt; 0 AND y/x &gt; 1.5;
</programlisting>
    但是这是安全的：
<programlisting>
SELECT ... WHERE CASE WHEN x &gt; 0 THEN y/x &gt; 1.5 ELSE false END;
</programlisting>
    一个以这种风格使用的<literal>CASE</>结构将使得优化尝试失败，因此只有必要时才这样做（在这个特别的例子中，最好通过写<literal>y &gt; 1.5*x</>来回避这个问题）。
   </para>
   
<!--==========================orignal english content==========================
   <para>
    <literal>CASE</> is not a cure-all for such issues, however.
    One limitation of the technique illustrated above is that it does not
    prevent early evaluation of constant subexpressions.
    As described in <xref linkend="xfunc-volatility">, functions and
    operators marked <literal>IMMUTABLE</literal> can be evaluated when
    the query is planned rather than when it is executed.  Thus for example
<programlisting>
SELECT CASE WHEN x &gt; 0 THEN x ELSE 1/0 END FROM tab;
</programlisting>
    is likely to result in a division-by-zero failure due to the planner
    trying to simplify the constant subexpression,
    even if every row in the table has <literal>x &gt; 0</> so that the
    <literal>ELSE</> arm would never be entered at run time.
   </para>
____________________________________________________________________________-->
   <para>
    不过，<literal>CASE</>不是这类问题的万灵药。上述技术的一个限制是，
    它无法阻止常量子表达式的提早计算。如<xref linkend="xfunc-volatility">
    中所述，当查询被规划而不是被执行时，被标记成
    <literal>IMMUTABLE</literal>的函数和操作符可以被计算。因此
<programlisting>
SELECT CASE WHEN x &gt; 0 THEN x ELSE 1/0 END FROM tab;
</programlisting>
    很可能会导致一次除零失败，因为规划器尝试简化常量子表达式。即便是
    表中的每一行都有<literal>x &gt; 0</>（这样运行时永远不会进入到
    <literal>ELSE</>分支）也是这样。
   </para>

<!--==========================orignal english content==========================
   <para>
    While that particular example might seem silly, related cases that don't
    obviously involve constants can occur in queries executed within
    functions, since the values of function arguments and local variables
    can be inserted into queries as constants for planning purposes.
    Within <application>PL/pgSQL</> functions, for example, using an
    <literal>IF</>-<literal>THEN</>-<literal>ELSE</> statement to protect
    a risky computation is much safer than just nesting it in a
    <literal>CASE</> expression.
   </para>
____________________________________________________________________________-->
   <para>
    虽然这个特别的例子可能看起来愚蠢，没有明显涉及常量的情况可能会发生
    在函数内执行的查询中，因为因为函数参数的值和本地变量可以作为常量
    被插入到查询中用于规划目的。例如，在<application>PL/pgSQL</>函数
    中，使用一个<literal>IF</>-<literal>THEN</>-<literal>ELSE</>语句来
    保护一种有风险的计算比把它嵌在一个<literal>CASE</>表达式中要安全得多。
   </para>

<!--==========================orignal english content==========================
   <para>
    Another limitation of the same kind is that a <literal>CASE</> cannot
    prevent evaluation of an aggregate expression contained within it,
    because aggregate expressions are computed before other
    expressions in a <literal>SELECT</> list or <literal>HAVING</> clause
    are considered.  For example, the following query can cause a
    division-by-zero error despite seemingly having protected against it:
<programlisting>
SELECT CASE WHEN min(employees) > 0
            THEN avg(expenses / employees)
       END
    FROM departments;
</programlisting>
    The <function>min()</> and <function>avg()</> aggregates are computed
    concurrently over all the input rows, so if any row
    has <structfield>employees</> equal to zero, the division-by-zero error
    will occur before there is any opportunity to test the result of
    <function>min()</>.  Instead, use a <literal>WHERE</>
    or <literal>FILTER</> clause to prevent problematic input rows from
    reaching an aggregate function in the first place.
   </para>
____________________________________________________________________________-->
   <para>
    另一个同类型的限制是，一个<literal>CASE</>无法阻止其所包含的聚合表达式
    的计算，因为在考虑<literal>SELECT</>列表或<literal>HAVING</>子句中的
    其他表达式之前，会先计算聚合表达式。例如，下面的查询会导致一个除零错误，
    虽然看起来好像已经这种情况加以了保护：
<programlisting>
SELECT CASE WHEN min(employees) > 0
            THEN avg(expenses / employees)
       END
    FROM departments;
</programlisting>
    <function>min()</>和<function>avg()</>聚合会在所有输入行上并行地计算，
    因此如果任何行有<structfield>employees</>等于零，在有机会测试
    <function>min()</>的结果之前，就会发生除零错误。取而代之的是，可以使用
    一个<literal>WHERE</>或<literal>FILTER</>子句来首先阻止有问题的输入行到达
    一个聚合函数。
   </para>
  </sect2>
 </sect1>

 <sect1 id="sql-syntax-calling-funcs">
<!--==========================orignal english content==========================
  <title>Calling Functions</title>
____________________________________________________________________________-->
  <title>调用函数</title>

<!--==========================orignal english content==========================
   <indexterm zone="sql-syntax-calling-funcs">
    <primary>notation</primary>
    <secondary>functions</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="sql-syntax-calling-funcs">
    <primary>notation</primary>
    <secondary>functions</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</productname> allows functions that have named
    parameters to be called using either <firstterm>positional</firstterm> or
    <firstterm>named</firstterm> notation.  Named notation is especially
    useful for functions that have a large number of parameters, since it
    makes the associations between parameters and actual arguments more
    explicit and reliable.
    In positional notation, a function call is written with
    its argument values in the same order as they are defined in the function
    declaration.  In named notation, the arguments are matched to the
    function parameters by name and can be written in any order.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>允许带有命名参数的函数被使用<firstterm>位置</firstterm>或<firstterm>命名</firstterm>记号法调用。命名记号法对于有大量参数的函数特别有用，因为它让参数和实际参数之间的关联更明显和可靠。在位置记号法中，书写一个函数调用时，其参数值要按照它们在函数声明中被定义的顺序书写。在命名记号法中，参数根据名称匹配函数参数，并且可以以任何顺序书写。
   </para>

<!--==========================orignal english content==========================
   <para>
    In either notation, parameters that have default values given in the
    function declaration need not be written in the call at all.  But this
    is particularly useful in named notation, since any combination of
    parameters can be omitted; while in positional notation parameters can
    only be omitted from right to left.
   </para>
____________________________________________________________________________-->
   <para>
    在任意一种记号法中，在函数声明中给出了默认值的参数根本不需要在调用中写出。但是这在命名记号法中特别有用，因为任何参数的组合都可以被忽略。而在位置记号法中参数只能从右往左忽略。
   </para>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</productname> also supports
    <firstterm>mixed</firstterm> notation, which combines positional and
    named notation.  In this case, positional parameters are written first
    and named parameters appear after them.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>也支持<firstterm>混合</firstterm>记号法，它组合了位置和命名记号法。在这种情况中，位置参数被首先写出并且命名参数出现在其后。
   </para>

<!--==========================orignal english content==========================
   <para>
    The following examples will illustrate the usage of all three
    notations, using the following function definition:
<programlisting>
CREATE FUNCTION concat_lower_or_upper(a text, b text, uppercase boolean DEFAULT false)
RETURNS text
AS
$$
 SELECT CASE
        WHEN $3 THEN UPPER($1 || ' ' || $2)
        ELSE LOWER($1 || ' ' || $2)
        END;
$$
LANGUAGE SQL IMMUTABLE STRICT;
</programlisting>
    Function <function>concat_lower_or_upper</function> has two mandatory
    parameters, <literal>a</literal> and <literal>b</literal>.  Additionally
    there is one optional parameter <literal>uppercase</literal> which defaults
    to <literal>false</literal>.  The <literal>a</literal> and
    <literal>b</literal> inputs will be concatenated, and forced to either
    upper or lower case depending on the <literal>uppercase</literal>
    parameter.  The remaining details of this function
    definition are not important here (see <xref linkend="extend"> for
    more information).
   </para>
____________________________________________________________________________-->
   <para>
    下列例子将展示所有三种记号法的用法：
<programlisting>
CREATE FUNCTION concat_lower_or_upper(a text, b text, uppercase boolean DEFAULT false)
RETURNS text
AS
$$
 SELECT CASE
        WHEN $3 THEN UPPER($1 || ' ' || $2)
        ELSE LOWER($1 || ' ' || $2)
        END;
$$
LANGUAGE SQL IMMUTABLE STRICT;
</programlisting>
    函数<function>concat_lower_or_upper</function>有两个强制参数，<literal>a</literal>和<literal>b</literal>。此外，有一个可选的参数<literal>uppercase</literal>，其默认值为<literal>false</literal>。<literal>a</literal>和<literal>b</literal>输入将被串接，并且根据<literal>uppercase</literal>参数被强制为大写或小写形式。这个函数的剩余细节对这里并不重要（详见<xref linkend="extend">）。
   </para>

   <sect2 id="sql-syntax-calling-funcs-positional">
<!--==========================orignal english content==========================
    <title>Using Positional Notation</title>
____________________________________________________________________________-->
    <title>使用位置记号</title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>function</primary>
     <secondary>positional notation</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>函数</primary>
     <secondary>位置记号法</secondary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     Positional notation is the traditional mechanism for passing arguments
     to functions in <productname>PostgreSQL</productname>.  An example is:
<screen>
SELECT concat_lower_or_upper('Hello', 'World', true);
 concat_lower_or_upper 
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 HELLO WORLD
(1 row)
</screen>
     All arguments are specified in order.  The result is upper case since
     <literal>uppercase</literal> is specified as <literal>true</literal>.
     Another example is:
<screen>
SELECT concat_lower_or_upper('Hello', 'World');
 concat_lower_or_upper 
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 hello world
(1 row)
</screen>
     Here, the <literal>uppercase</literal> parameter is omitted, so it
     receives its default value of <literal>false</literal>, resulting in
     lower case output.  In positional notation, arguments can be omitted
     from right to left so long as they have defaults.
    </para>
____________________________________________________________________________-->
    <para>
     在<productname>PostgreSQL</productname>中，位置记号法是给函数传递参数的传统机制。一个例子：
<screen>
SELECT concat_lower_or_upper('Hello', 'World', true);
 concat_lower_or_upper 
-----------------------
 HELLO WORLD
(1 row)
</screen>
     所有参数被按照顺序指定。结果是大写形式，因为<literal>uppercase</literal>被指定为<literal>true</literal>。另一个例子：
<screen>
SELECT concat_lower_or_upper('Hello', 'World');
 concat_lower_or_upper 
-----------------------
 hello world
(1 row)
</screen>
     这里，<literal>uppercase</literal>参数被忽略，因此它接收它的默认值<literal>false</literal>，并导致小写形式的输出。在位置记号法中，参数可以按照从右往左被忽略并且因此而得到默认值。
    </para>
   </sect2>

   <sect2 id="sql-syntax-calling-funcs-named">
<!--==========================orignal english content==========================
    <title>Using Named Notation</title>
____________________________________________________________________________-->
    <title>使用命名记号</title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>function</primary>
     <secondary>named notation</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>函数</primary>
     <secondary>命名记号法</secondary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     In named notation, each argument's name is specified using
     <literal>=&gt;</literal> to separate it from the argument expression.
     For example:
<screen>
SELECT concat_lower_or_upper(a =&gt; 'Hello', b =&gt; 'World');
 concat_lower_or_upper 
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 hello world
(1 row)
</screen>
     Again, the argument <literal>uppercase</literal> was omitted
     so it is set to <literal>false</literal> implicitly.  One advantage of
     using named notation is that the arguments may be specified in any
     order, for example:
<screen>
SELECT concat_lower_or_upper(a =&gt; 'Hello', b =&gt; 'World', uppercase =&gt; true);
 concat_lower_or_upper 
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 HELLO WORLD
(1 row)

SELECT concat_lower_or_upper(a =&gt; 'Hello', uppercase =&gt; true, b =&gt; 'World');
 concat_lower_or_upper 
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 HELLO WORLD
(1 row)
</screen>
    </para>
____________________________________________________________________________-->
    <para>
     在命名记号法中，每一个参数名都用<literal>=></literal>
     指定来把它与参数表达式分隔开。例如：
<screen>
SELECT concat_lower_or_upper(a => 'Hello', b => 'World');
 concat_lower_or_upper 
-----------------------
 hello world
(1 row)
</screen>
     再次，参数<literal>uppercase</literal>被忽略，因此它被隐式地设置为<literal>false</literal>。使用命名记号法的一个优点是参数可以用任何顺序指定，例如：
<screen>
SELECT concat_lower_or_upper(a => 'Hello', b => 'World', uppercase => true);
 concat_lower_or_upper 
-----------------------
 HELLO WORLD
(1 row)

SELECT concat_lower_or_upper(a => 'Hello', uppercase => true, b => 'World');
 concat_lower_or_upper 
-----------------------
 HELLO WORLD
(1 row)
</screen>
    </para>

<!--==========================orignal english content==========================
    <para>
      An older syntax based on ":=" is supported for backward compatibility:
<screen>
SELECT concat_lower_or_upper(a := 'Hello', uppercase := true, b := 'World');
 concat_lower_or_upper 
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 HELLO WORLD
(1 row)
</screen>
    </para>
____________________________________________________________________________-->
    <para>
      为了向后兼容性，基于 ":=" 的旧语法仍被支持：
<screen>
SELECT concat_lower_or_upper(a := 'Hello', uppercase := true, b := 'World');
 concat_lower_or_upper 
-----------------------
 HELLO WORLD
(1 row)
</screen>
    </para>
   </sect2>

  <sect2 id="sql-syntax-calling-funcs-mixed">
<!--==========================orignal english content==========================
   <title>Using Mixed Notation</title>
____________________________________________________________________________-->
   <title>使用混合记号</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>function</primary>
    <secondary>mixed notation</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>函数</primary>
    <secondary>混合记号法</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The mixed notation combines positional and named notation. However, as
    already mentioned, named arguments cannot precede positional arguments.
    For example:
<screen>
SELECT concat_lower_or_upper('Hello', 'World', uppercase =&gt; true);
 concat_lower_or_upper 
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 HELLO WORLD
(1 row)
</screen>
    In the above query, the arguments <literal>a</literal> and
    <literal>b</literal> are specified positionally, while
    <literal>uppercase</> is specified by name.  In this example,
    that adds little except documentation.  With a more complex function
    having numerous parameters that have default values, named or mixed
    notation can save a great deal of writing and reduce chances for error.
   </para>
____________________________________________________________________________-->
   <para>
    混合记号法组合了位置和命名记号法。不过，正如已经提到过的，命名参数不能超越位置参数。例如：
<screen>
SELECT concat_lower_or_upper('Hello', 'World', uppercase => true);
 concat_lower_or_upper 
-----------------------
 HELLO WORLD
(1 row)
</screen>
    在上述查询中，参数<literal>a</literal>和<literal>b</literal>被以位置指定，而<literal>uppercase</>通过名字指定。在这个例子中，这只增加了一点文档。在一个具有大量带默认值参数的复杂函数中，命名的或混合的记号法可以节省大量的书写并且减少出错的机会。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     Named and mixed call notations currently cannot be used when calling an
     aggregate function (but they do work when an aggregate function is used
     as a window function).
    </para>
____________________________________________________________________________-->
    <para>
     命名的和混合的调用记号法当前不能在调用聚合函数时使用（但是当聚合函数被用作窗口函数时它们可以被使用）。
    </para>
   </note>
  </sect2>
 </sect1>

</chapter>
