<!-- doc/src/sgml/monitoring.sgml -->

<chapter id="monitoring">
 <title>监控数据库活动</title>

 <indexterm zone="monitoring">
  <primary>监控</primary>
  <secondary>数据库活动</secondary>
 </indexterm>

 <indexterm zone="monitoring">
  <primary>数据库活动</primary>
  <secondary>监控</secondary>
 </indexterm>

 <para>
  一个数据库管理员常常会疑惑，<quote>系统现在正在做什么？</quote>这一章会讨论如何搞清楚这个问题。
 </para>

  <para>
   一些工具可以用来监控数据库活动并且分析性能。这一章的大部分都致力于描述<productname>PostgreSQL</productname>的统计收集器，但是我们也不能忽视常规的 Unix 监控程序，如<command>ps</>、<command>top</>、<command>iostat</>和<command>vmstat</>。另外，一旦我们发现了一个性能差的查询，可能需要<productname>PostgreSQL</productname>的<xref linkend="sql-explain">命令来进行进一步的调查。<xref linkend="using-explain">会讨论<command>EXPLAIN</>以及其他用来理解个体查询行为的方法。
  </para>

 <sect1 id="monitoring-ps">
  <title>标准 Unix 工具</title>

  <indexterm zone="monitoring-ps">
   <primary>ps</primary>
   <secondary>to monitor activity</secondary>
  </indexterm>

  <para>
   在大部分 Unix 平台上，<productname>PostgreSQL</productname>会修改由<command>ps</>报告的命令标题，这样个体服务器进程可以被标识。一个显示样例是

<screen>
$ ps auxww | grep ^postgres
postgres  15551  0.0  0.1  57536  7132 pts/0    S    18:02   0:00 postgres -i
postgres  15554  0.0  0.0  57536  1184 ?        Ss   18:02   0:00 postgres: writer process
postgres  15555  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: checkpointer process
postgres  15556  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: wal writer process
postgres  15557  0.0  0.0  58504  2244 ?        Ss   18:02   0:00 postgres: autovacuum launcher process
postgres  15558  0.0  0.0  17512  1068 ?        Ss   18:02   0:00 postgres: stats collector process
postgres  15582  0.0  0.0  58772  3080 ?        Ss   18:04   0:00 postgres: joe runbug 127.0.0.1 idle
postgres  15606  0.0  0.0  58772  3052 ?        Ss   18:07   0:00 postgres: tgl regression [local] SELECT waiting
postgres  15610  0.0  0.0  58772  3056 ?        Ss   18:07   0:00 postgres: tgl regression [local] idle in transaction
</screen>

   （<command>ps</>的调用方式随不同的平台而变，但是显示的细节都差不多。这个例子来自于一个最近的 Linux 系统）。列在这里的第一个进程是主服务器进程。为它显示的命令参数是当它被启动时使用的那些。接下来的五个进程是由主进程自动启动的后台工作者进程（如果你已经设置系统为不启动统计收集器，<quote>统计收集器</>进程将不会出现；同样<quote>自动清理发动</>进程也可以被禁用）。剩余的每一个进程都是一个处理一个客户端连接的服务器进程。每个这种进程都会把它的命令行显示设置为这种形式

<screen>
postgres: <replaceable>user</> <replaceable>database</> <replaceable>host</> <replaceable>activity</>
</screen>

  在该客户端连接的生命期中，用户、数据库以及（客户端）主机项保持不变，但是活动指示器会改变。活动可以是<literal>闲置</>（即等待一个客户端命令）、<literal>在事务中闲置</>（在一个<command>BEGIN</>块里等待客户端）或者一个命令类型名，例如<literal>SELECT</>。还有，如果服务器进程正在等待一个其它会话持有的锁， <literal>等待中</>会被追加到上述信息中。在上面的例子中，我们可以推断：进程 15606 正在等待进程 15610 完成其事务并且因此释放一些锁（进程 15610 必定是阻塞者，因为没有其他活动会话。在更复杂的情况中，可能需要查看<link linkend="view-pg-locks"><structname>pg_locks</structname></link>系统视图来决定谁阻塞了谁）。
  </para>

  <para>
   如果你已经关闭了<xref linkend="guc-update-process-title">，那么活动指示器将不会被更新，进程标题仅在新进程被启动的时候设置一次。 在某些平台上这样做可以为每个命令节省可观的开销，但在其它平台上却不明显。
  </para>

  <tip>
  <para>
  <productname>Solaris</productname>需要特别的处理。你必需使用<command>/usr/ucb/ps</command>而不是<command>/bin/ps</command>。 你还必需使用两个<option>w</option>标志，而不是一个。另外，你对<command>postgres</command>命令的最初调用必须用一个比服务器进程提供的短的<command>ps</command>状态显示。如果你没有满足全部三个要求，每个服务器进程的<command>ps</>输出将是原始的<command>postgres</>命令行。
  command line.
  </para>
  </tip>
 </sect1>

 <sect1 id="monitoring-stats">
  <title>统计收集器</title>

  <indexterm zone="monitoring-stats">
   <primary>statistics</primary>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname>的<firstterm>统计收集器</>是一个支持收集和报告服务器活动信息的子系统。 目前，这个收集器可以对表和索引的访问计数，计数可以按磁盘块和个体行来进行。它还跟踪每个表中的总行数、每个表的清理和分析动作的信息。它也统计调用用户定义函数的次数以及在每次调用中花费的总时间。
  </para>

  <para>
   <productname>PostgreSQL</productname>还支持报告当前其它服务器进程正在执行的命令。这是独立于收集器进程的功能。
  </para>

 <sect2 id="monitoring-stats-setup">
  <title>统计收集配置</title>

  <para>
   因为统计收集给查询执行增加了一些负荷，系统可以被配置为收集或不收集信息。这由配置参数控制，它们通常在<filename>postgresql.conf</>中设置（关于设置配置参数的细节请见<xref linkend="runtime-config">）。
  </para>

  <para>
   参数<xref linkend="guc-track-activities">允许监控当前被任意服务器进程执行的命令。
  </para>

  <para>
   参数<xref linkend="guc-track-counts">控制是否收集关于表和索引访问的统计信息。
  </para>

  <para>
   参数<xref linkend="guc-track-functions">启用对用户定义函数使用的跟踪。
  </para>

  <para>
   参数<xref linkend="guc-track-io-timing">启用对块读写次数的监控。
  </para>

  <para>
   通常这些参数被设置在<filename>postgresql.conf</>中，这样它们会应用于所有服务器进程，但是可以在单个会话中使用<xref linkend="sql-set">命令打开或关闭它们（为了阻止普通用户对管理员隐藏他们的活动，只有超级用户被允许使用<command>SET</>来改变这些参数）。
  </para>

  <para>
   统计收集器通过临时文件将收集到的信息传送给其他<productname>PostgreSQL</productname>进程。这些文件被存储在名字由<xref linkend="guc-stats-temp-directory">参数指定的目录中，默认是<filename>pg_stat_tmp</filename>。为了得到更好的性能，<varname>stats_temp_directory</>可以被指向一个基于 RAM 的文件系统来降低物理 I/O 需求。当服务器被干净地关闭时，一份统计数据的永久拷贝被存储在<filename>pg_stat</filename>子目录中，这样在服务器重启后统计信息能被保持。当在服务器启动时执行恢复时（例如立即关闭、服务器崩溃以及时间点恢复之后），所有统计计数器会被重置。
  </para>

 </sect2>

 <sect2 id="monitoring-stats-views">
  <title>查看收集到的统计信息</title>

  <para>
   <xref linkend="monitoring-stats-views-table">中列出了一些预定义视图可以用来显示统计收集的结果。你也可以使用底层统计函数（在<xref linkend="monitoring-stats-functions">中讨论）来建立自定义的视图。
  </para>

  <para>
   在使用统计信息监控当前活动时，你必须了解这些信息并非是实时更新的。每个独立的服务器进程只在进入闲置状态之前才向收集器传送新的统计计数；因此正在进行的查询或事务并不影响显示出来的总数。同样，收集器本身也最多每<varname>PGSTAT_STAT_INTERVAL</varname>毫秒（缺省为 500ms，除非在编译服务器的时候修改过）发送一 次新的报告。因此显示的信息总是落后于实际活动。但是由<varname>track_activities</varname>收集的当前查询信息总是最新的。
  </para>

  <para>
   另一个重点是当一个服务器进程被要求显示任何这些统计信息时，它首先取得收集器进程最近发出的报告并且接着为所有统计视图和函数使用这个快照，直到它的当前事务的结尾。因此只要你继续当前事务，统计数据将会一直显示静态信息。相似地，当任何关于所有会话的当前查询的信息在一个事务中第一次被请求时，这样的信息将被收集。并且在整个事务期间将显示相同的信息。这是一种特性而非缺陷，因为它允许你在该统计信息上执行多个查询并且关联结果而不用担心那些数字会在你不知情的情况下改变。但是如果你希望用每个查询都看到新结果，要确保在任何事务块之外做那些查询。或者，你可以调用<function>pg_stat_clear_snapshot</function>()，那将丢弃当前事务的统计快照（如果有）。下一次对统计性信息的使用将导致获取一个新的快照。
  </para>

  <para>
   一个事务也可以在视图<structname>pg_stat_xact_all_tables</>、<structname>pg_stat_xact_sys_tables</>、<structname>pg_stat_xact_user_tables</>和<structname>pg_stat_xact_user_functions</>中看到它自己的统计信息（还没有被传送给收集器）。这些数字并不像上面所述的那样行动，相反它们在事务期间持续被更新。
  </para>

  <table id="monitoring-stats-views-table">
   <title>标准统计视图</title>

   <tgroup cols="2">
    <thead>
     <row>
      <entry>视图名称</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <structname>pg_stat_activity</structname>
       <indexterm><primary>pg_stat_activity</primary></indexterm>
      </entry>
      <entry>
       每个服务器进程一行，显示与那个进程的当前活动相关的信息，例如状态和当前查询。详见<xref linkend="pg-stat-activity-view">。
      </entry>
     </row>
     
     <row>
      <entry><structname>pg_stat_archiver</><indexterm><primary>pg_stat_archiver</primary></indexterm></entry>
      <entry>只有一行，显示有关 WAL 归档进程活动的统计信息。详见<xref linkend="pg-stat-archiver-view">。
      </entry>
     </row>

     <row>      
      <entry><structname>pg_stat_bgwriter</><indexterm><primary>pg_stat_bgwriter</primary></indexterm></entry>
      <entry>只有一行，显示有关后台写进程的活动的统计信息。详见<xref linkend="pg-stat-bgwriter-view">。
     </entry>
     </row>

     <row>
      <entry><structname>pg_stat_database</><indexterm><primary>pg_stat_database</primary></indexterm></entry>
      <entry>每个数据库一行，显示数据库范围的统计信息。详见<xref linkend="pg-stat-database-view">。
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_all_tables</><indexterm><primary>pg_stat_all_tables</primary></indexterm></entry>
      <entry>
       当前数据库中每个表一行，显示有关访问指定表的统计信息。详见<xref linkend="pg-stat-all-tables-view">。
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_sys_tables</><indexterm><primary>pg_stat_sys_tables</primary></indexterm></entry>
      <entry>和<structname>pg_stat_all_tables</>一样，但只显示系统表。</entry>
     </row>

     <row>
      <entry><structname>pg_stat_user_tables</><indexterm><primary>pg_stat_user_tables</primary></indexterm></entry>
      <entry>和<structname>pg_stat_all_tables</>一样，但只显示用户表。</entry>
     </row>

     <row>
      <entry><structname>pg_stat_xact_all_tables</><indexterm><primary>pg_stat_xact_all_tables</primary></indexterm></entry>
      <entry>和<structname>pg_stat_all_tables</>相似，但计数动作只在当前事务内发生（还<emphasis>没有</>被包括在<structname>pg_stat_all_tables</>和相关视图中）。用于生存和死亡行数量的列以及清理和分析动作在此视图中不出现。</entry>
     </row>

     <row>
      <entry><structname>pg_stat_xact_sys_tables</><indexterm><primary>pg_stat_xact_sys_tables</primary></indexterm></entry>
      <entry>和<structname>pg_stat_xact_all_tables</>一样，但只显示系统表。</entry>
     </row>

     <row>
      <entry><structname>pg_stat_xact_user_tables</><indexterm><primary>pg_stat_xact_user_tables</primary></indexterm></entry>
      <entry>和<structname>pg_stat_xact_all_tables</>一样，但只显示用户表。</entry>
     </row>

     <row>
      <entry><structname>pg_stat_all_indexes</><indexterm><primary>pg_stat_all_indexes</primary></indexterm></entry>
      <entry>
       当前数据库中的每个索引一行，显示：表OID、索引OID、模式名、表名、索引名、 使用了该索引的索引扫描总数、索引扫描返回的索引记录数、使用该索引的简 单索引扫描抓取的活表(livetable)中数据行数。
       当前数据库中的每个索引一行，显示与访问指定索引有关的统计信息。详见<xref linkend="pg-stat-all-indexes-view">。
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_sys_indexes</><indexterm><primary>pg_stat_sys_indexes</primary></indexterm></entry>
      <entry>和<structname>pg_stat_all_indexes</>一样，但只显示系统表上的索引。</entry>
     </row>

     <row>
      <entry><structname>pg_stat_user_indexes</><indexterm><primary>pg_stat_user_indexes</primary></indexterm></entry>
      <entry>和<structname>pg_stat_all_indexes</>一样，但只显示用户表上的索引。</entry>
     </row>

     <row>
      <entry><structname>pg_statio_all_tables</><indexterm><primary>pg_statio_all_tables</primary></indexterm></entry>
      <entry>
       当前数据库中每个表一行(包括TOAST表)，显示：表OID、模式名、表名、 从该表中读取的磁盘块总数、缓冲区命中次数、该表上所有索引的磁盘块读取总数、 该表上所有索引的缓冲区命中总数、在该表的辅助TOAST表(如果存在)上的磁盘块读取总数、 在该表的辅助TOAST表(如果存在)上的缓冲区命中总数、TOAST表的索引的磁盘块读 取总数、TOAST表的索引的缓冲区命中总数。
       当前数据库中的每个表一行，显示有关在指定表上 I/O 的统计信息。详见<xref linkend="pg-statio-all-tables-view">。
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_sys_tables</><indexterm><primary>pg_statio_sys_tables</primary></indexterm></entry>
      <entry>和<structname>pg_statio_all_tables</>一样，但只显示系统表。</entry>
     </row>

     <row>
      <entry><structname>pg_statio_user_tables</><indexterm><primary>pg_statio_user_tables</primary></indexterm></entry>
      <entry>和<structname>pg_statio_all_tables</>一样，但只显示用户表。</entry>
     </row>

     <row>
      <entry><structname>pg_statio_all_indexes</><indexterm><primary>pg_statio_all_indexes</primary></indexterm></entry>
      <entry>
       当前数据库中每个索引一行，显示：表OID、索引OID、模式名、 表名、索引名、该索引的磁盘块读取总数、该索引的缓冲区命中总数。
       当前数据库中的每个索引一行，显示与指定索引上的 I/O 有关的统计信息。详见<xref linkend="pg-statio-all-indexes-view">。
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_sys_indexes</><indexterm><primary>pg_statio_sys_indexes</primary></indexterm></entry>
      <entry>和<structname>pg_statio_all_indexes</>一样，但只显示系统表上的索引。</entry>
     </row>

     <row>
      <entry><structname>pg_statio_user_indexes</><indexterm><primary>pg_statio_user_indexes</primary></indexterm></entry>
      <entry>和<structname>pg_statio_all_indexes</>一样，但只显示用户表上的索引。</entry>
     </row>

     <row>
      <entry><structname>pg_statio_all_sequences</><indexterm><primary>pg_statio_all_sequences</primary></indexterm></entry>
     <entry>
       当前数据库中每个序列对象一行，显示：序列OID、模式名、序列名、序列的磁盘读取总数、序列的缓冲区命中总数。
       当前数据库中的每个序列一行，显示与指定序列上的 I/O 有关的统计信息。详见<xref linkend="pg-statio-all-sequences-view">。
     </entry>
     </row>

     <row>
      <entry><structname>pg_statio_sys_sequences</><indexterm><primary>pg_statio_sys_sequences</primary></indexterm></entry>
      <entry>和<structname>pg_statio_all_sequences</>一样，但只显示系统序列（目前没有定义系统序列，因此这个视图总是为空）。</entry>
     </row>

     <row>
      <entry><structname>pg_statio_user_sequences</><indexterm><primary>pg_statio_user_sequences</primary></indexterm></entry>
      <entry>和<structname>pg_statio_all_sequences</>一样，但只显示用户序列。</entry>
     </row>

     <row>
      <entry><structname>pg_stat_user_functions</><indexterm><primary>pg_stat_user_functions</primary></indexterm></entry>
      <entry>
       对于所有跟踪功能，函数的OID，模式，名称，数量 通话总时间，和自我的时间。自我时间是 在函数本身所花费的时间量，总时间包括 它调用函数所花费的时间。时间值以毫秒为单位。
       每一个被跟踪的函数一行，显示与执行该函数有关的统计信息。详见<xref linkend="pg-stat-user-functions-view">。
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_xact_user_functions</><indexterm><primary>pg_stat_xact_user_functions</primary></indexterm></entry>
      <entry>和<structname>pg_stat_user_functions</>相似，但是只统计在当前事务期间的调用（还<emphasis>没有</>被包括在<structname>pg_stat_user_functions</>中）。</entry>
     </row>

     <row>
      <entry><structname>pg_stat_replication</><indexterm><primary>pg_stat_replication</primary></indexterm></entry>
      <entry>每个 WAL 发送者进程一行，显示与到该发送者连接到的后备服务器的复制相关的统计信息。详见<xref linkend="pg-stat-replication-view">。
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_database_conflicts</><indexterm><primary>pg_stat_database_conflicts</primary></indexterm></entry>
      <entry>
       每个数据库一行，显示数据库范围内由于与后备服务器上的恢复冲突而取消的查询有关的统计信息。详见<xref linkend="pg-stat-database-conflicts-view">。
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   针对每个索引的统计信息对于判断哪个索引正被使用以及它们的效果特别有用。
  </para>

  <para>
   <structname>pg_statio_</>系列视图主要用于判断缓冲区的效果。当实际磁盘读取数远小于缓冲区命中时，这个缓冲能满足大部分读请求而无需进行内核调用。但是，这些统计信息并没有给出所有的事情：由于<productname>PostgreSQL</>处理磁盘 I/O 的方式，不在<productname>PostgreSQL</>缓冲区中的数据库仍然驻留在内核的 I/O 缓存中，并且因此可以被再次读取而不需要物理磁盘读取。我们建议希望了解<productname>PostgreSQL</> I/O 行为更多细节的用户将<productname>PostgreSQL</>统计收集器和操作系统中允许观察内核处理 I/O 的工具一起使用。
  </para>


  <table id="pg-stat-activity-view" xreflabel="pg_stat_activity">
   <title><structname>pg_stat_activity</structname> 视图</title>

   <tgroup cols="3">
    <thead>
    <row>
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>datid</></entry>
     <entry><type>oid</></entry>
     <entry>这个后端连接到的数据库的OID</entry>
    </row>
    <row>
     <entry><structfield>datname</></entry>
     <entry><type>name</></entry>
     <entry>这个后端连接到的数据库的名称</entry>
    </row>
    <row>
     <entry><structfield>pid</></entry>
     <entry><type>integer</></entry>
     <entry>这个后端的进程 ID</entry>
    </row>
    <row>
     <entry><structfield>usesysid</></entry>
     <entry><type>oid</></entry>
     <entry>登录到这个后端的用户的 OID</entry>
    </row>
    <row>
     <entry><structfield>usename</></entry>
     <entry><type>name</></entry>
     <entry>登录到这个后端的用户的名称</entry>
    </row>
    <row>
     <entry><structfield>application_name</></entry>
     <entry><type>text</></entry>
     <entry>连接到这个后端的应用的名称</entry>
    </row>
    <row>
     <entry><structfield>client_addr</></entry>
     <entry><type>inet</></entry>
     <entry>连接到这个后端的客户端的 IP 地址。如果这个域为空，它表示客户端通过服务器机器上的一个 Unix 套接字连接或者这是一个内部进程（如自动清理）。
     </entry>
    </row>
    <row>
     <entry><structfield>client_hostname</></entry>
     <entry><type>text</></entry>
     <entry>已连接的客户端的主机名，由<structfield>client_addr</>的反向 DNS 查找报告。这个域将只对 IP 连接非空，并且只有<xref linkend="guc-log-hostname">被启用时才会非空。
     </entry>
    </row>
    <row>
     <entry><structfield>client_port</></entry>
     <entry><type>integer</></entry>
     <entry>客户端用以和这个后端通信的 TCP 端口号，如果使用 Unix 套接字则为<literal>-1</>
     </entry>
    </row>
    <row>
     <entry><structfield>backend_start</></entry>
     <entry><type>timestamp with time zone</></entry>
     <entry>这个进程被启动的时间，即客户端是什么时候连接到服务器的
     </entry>
    </row>
    <row>
     <entry><structfield>xact_start</></entry>
     <entry><type>timestamp with time zone</></entry>
     <entry>这个进程的当前事务被启动的时间，如果没有活动事务则为空。如果当前查询是它的第一个事务，这一列等于<structfield>query_start</>。
     </entry>
    </row>
    <row>
     <entry><structfield>query_start</></entry>
     <entry><type>timestamp with time zone</></entry>
     <entry>当前活动查询被开始的时间，如果<structfield>state</>不是<literal>active</>，这个域为上一个查询被开始的时间
     </entry>
    </row>
    <row>
     <entry><structfield>state_change</></entry>
     <entry><type>timestamp with time zone</></entry>
     <entry><structfield>state</>上一次被改变的时间</entry>
    </row>
    <row>
     <entry><structfield>waiting</></entry>
     <entry><type>boolean</></entry>
     <entry>如果这个后端正在等待一个锁则为真</entry>
    </row>
    <row>
     <entry><structfield>state</></entry>
     <entry><type>text</></entry>
     <entry>这个后端的当前总体状态。可能的值是：
       <itemizedlist>
         <listitem>
          <para>
           <literal>active</>：后端正在执行一个查询。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>idle</>：后端正在等待一个新的客户端命令。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>idle in transaction</>：后端在一个事务中，但是当前没有正在执行一个查询。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>idle in transaction (aborted)</>：这个状态与<literal>idle in transaction</>相似，不过在该事务中的一个语句导致了一个错误。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>fastpath function call</>：后端正在执行一个 fast-path 函数。
          </para>
         </listitem>
         <listitem>
           <para>
           <literal>disabled</>：如果在这个后端中<xref linkend="guc-track-activities">被禁用，则报告这个状态。
          </para>
         </listitem>
       </itemizedlist>
     </entry>
    </row>
    <row>
     <entry><structfield>backend_xid</structfield></entry>
     <entry><type>xid</type></entry>
     <entry>这个后端的顶层事务标识符（如果存在）。</entry>
    </row>
    <row>
     <entry><structfield>backend_xmin</structfield></entry>
     <entry><type>xid</type></entry>
     <entry>当前后端的<literal>xmin</>范围。</entry>
    </row>
    <row>
     <entry><structfield>query</></entry>
     <entry><type>text</></entry>
     <entry>这个后端最近查询的文本。如果<structfield>state</>为<literal>active</>，这个域显示当前正在执行的查询。在所有其他状态下，它显示上一个被执行的查询。
     </entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_stat_activity</structname>视图将为每一个服务器进程有一行，显示与该进程的当前活动相关的信息。
  </para>

  <note>
   <para>
    <structfield>waiting</>和<structfield>state</>列是独立的。如果一个后端处于<literal>active</>状态，它可能是也可能不是<literal>waiting</>。如果状态是<literal>active</>并且<structfield>waiting</>为真，它意味着一个查询正在被执行，但是它被系统中某处的一个锁所阻塞。
   </para>
  </note>
  
  <table id="pg-stat-archiver-view" xreflabel="pg_stat_archiver">
   <title><structname>pg_stat_archiver</structname>视图</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>archived_count</></entry>
      <entry><type>bigint</type></entry>
      <entry>已被成功归档的 WAL 文件数量</entry>
     </row>
     <row>
      <entry><structfield>last_archived_wal</></entry>
      <entry><type>text</type></entry>
      <entry>最后一个被成功归档的 WAL 文件名称</entry>
     </row>
     <row>
      <entry><structfield>last_archived_time</></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>最后一次成功归档操作的时间</entry>
     </row>
     <row>
      <entry><structfield>failed_count</></entry>
      <entry><type>bigint</type></entry>
      <entry>失败的归档 WAL 文件尝试的数量</entry>
     </row>
     <row>
      <entry><structfield>last_failed_wal</></entry>
      <entry><type>text</type></entry>
      <entry>最后一次失败的归档操作的 WAL 文件名称</entry>
     </row>
     <row>
      <entry><structfield>last_failed_time</></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>最后一次失败的归档操作的时间</entry>
     </row>
     <row>
      <entry><structfield>stats_reset</></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>这些统计信息最后一次被重置的时间</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   The <structname>pg_stat_archiver</structname>视图将总是一个单一的行，
   该行包含着有关集簇的归档进程的数据。
  </para>

  <table id="pg-stat-bgwriter-view" xreflabel="pg_stat_bgwriter">
   <title><structname>pg_stat_bgwriter</structname>视图</title>

   <tgroup cols="3">
    <thead>
    <row>
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>checkpoints_timed</></entry>
      <entry><type>bigint</type></entry>
      <entry>已经被执行的计划中检查点的数量</entry>
     </row>
     <row>
      <entry><structfield>checkpoints_req</></entry>
      <entry><type>bigint</type></entry>
      <entry>已经被执行的请求检查点的数量</entry>
     </row>
     <row>
      <entry><structfield>checkpoint_write_time</></entry>
      <entry><type>double precision</type></entry>
      <entry>在文件被写入磁盘的检查点处理部分花费的总时间，以毫秒计
      </entry>
     </row>
     <row>
      <entry><structfield>checkpoint_sync_time</></entry>
      <entry><type>double precision</type></entry>
      <entry>在文件被同步到磁盘中的检查点处理部分花费的总时间，以毫秒计
      </entry>
     </row>
     <row>
      <entry><structfield>buffers_checkpoint</></entry>
      <entry><type>bigint</type></entry>
      <entry>在检查点期间被写的缓冲区数目</entry>
     </row>
     <row>
      <entry><structfield>buffers_clean</></entry>
      <entry><type>bigint</type></entry>
      <entry>被后台写进程写的缓冲区数目</entry>
     </row>
     <row>
      <entry><structfield>maxwritten_clean</></entry>
      <entry><type>bigint</type></entry>
      <entry>后台写进程由于已经写了太多缓冲区而停止清洁扫描的次数</entry>
     </row>
     <row>
      <entry><structfield>buffers_backend</></entry>
      <entry><type>bigint</type></entry>
      <entry>被一个后端直接写的缓冲区数量</entry>
     </row>
     <row>
      <entry><structfield>buffers_backend_fsync</></entry>
      <entry><type>bigint</type></entry>
      <entry>一个后端不得不自己执行<function>fsync</>调用的次数（通常即使后端自己进行写操作，后台写进程也会处理这些）</entry>
     </row>
     <row>
      <entry><structfield>buffers_alloc</></entry>
      <entry><type>bigint</type></entry>
      <entry>被分配的缓冲区数量</entry>
     </row>
     <row>
      <entry><structfield>stats_reset</></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>这些统计信息上次被重置的时间</entry>
     </row>
    </tbody>
    </tgroup>
  </table>

  <para>
   <structname>pg_stat_bgwriter</structname>视图将总是只有单独的一行，它包含集簇的全局数据。
  </para>

  <table id="pg-stat-database-view" xreflabel="pg_stat_database">
   <title><structname>pg_stat_database</structname>视图</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>datid</></entry>
     <entry><type>oid</></entry>
     <entry>一个数据库的 OID</entry>
    </row>
    <row>
     <entry><structfield>datname</></entry>
     <entry><type>name</></entry>
     <entry>这个数据库的名称</entry>
    </row>
    <row>
     <entry><structfield>numbackends</></entry>
     <entry><type>integer</></entry>
     <entry>当前连接到这个数据库的后端数量。这是在这个视图中唯一一个返回反映当前状态值的列。所有其他列返回从上次重置以来积累的值。</entry>
    </row>
    <row>
     <entry><structfield>xact_commit</></entry>
     <entry><type>bigint</></entry>
     <entry>在这个数据库中已经被提交的事务的数量</entry>
    </row>
    <row>
     <entry><structfield>xact_rollback</></entry>
     <entry><type>bigint</></entry>
     <entry>在这个数据库中已经被回滚的事务的数量</entry>
    </row>
    <row>
     <entry><structfield>blks_read</></entry>
     <entry><type>bigint</></entry>
     <entry>在这个数据库中被读取的磁盘块的数量</entry>
    </row>
    <row>
     <entry><structfield>blks_hit</></entry>
     <entry><type>bigint</></entry>
     <entry>磁盘块被发现已经在缓冲区中的次数，这样不需要一次读取（这只包括 PostgreSQL 缓冲区中的命中，而不包括在操作系统文件系统缓冲区中的命中）
     </entry>
    </row>
    <row>
     <entry><structfield>tup_returned</></entry>
     <entry><type>bigint</></entry>
     <entry>在这个数据库中被查询返回的行数</entry>
    </row>
    <row>
     <entry><structfield>tup_fetched</></entry>
     <entry><type>bigint</></entry>
     <entry>在这个数据库中被查询取出的行数</entry>
    </row>
    <row>
     <entry><structfield>tup_inserted</></entry>
     <entry><type>bigint</></entry>
     <entry>在这个数据库中被查询插入的行数</entry>
    </row>
    <row>
     <entry><structfield>tup_updated</></entry>
     <entry><type>bigint</></entry>
     <entry>在这个数据库中被查询更新的行数</entry>
    </row>
    <row>
     <entry><structfield>tup_deleted</></entry>
     <entry><type>bigint</></entry>
     <entry>在这个数据库中被查询删除的行数</entry>
    </row>
    <row>
     <entry><structfield>conflicts</></entry>
     <entry><type>bigint</></entry>
     <entry>由于与恢复冲突而在这个数据库中被取消的查询的数目（冲突只发生在后备服务器上，详见<xref linkend="pg-stat-database-conflicts-view">）。
     </entry>
    </row>
    <row>
     <entry><structfield>temp_files</></entry>
     <entry><type>bigint</></entry>
     <entry>在这个数据库中被查询创建的临时文件的数量。所有临时文件都被统计，不管为什么创建这些临时文件（如排序或哈希），并且不管<xref linkend="guc-log-temp-files">设置。
     </entry>
    </row>
    <row>
     <entry><structfield>temp_bytes</></entry>
     <entry><type>bigint</></entry>
     <entry>在这个数据库中被查询写到临时文件中的数据总量。所有临时文件都被统计，不管为什么创建这些临时文件（如排序或哈希），并且不管<xref linkend="guc-log-temp-files">设置。
     </entry>
    </row>
    <row>
     <entry><structfield>deadlocks</></entry>
     <entry><type>bigint</></entry>
     <entry>在这个数据库中被检测到的死锁数</entry>
    </row>
    <row>
     <entry><structfield>blk_read_time</></entry>
     <entry><type>double precision</></entry>
     <entry>在这个数据库中后端花费在读取数据文件块的时间，以毫秒计</entry>
    </row>
    <row>
     <entry><structfield>blk_write_time</></entry>
     <entry><type>double precision</></entry>
     <entry>在这个数据库中后端花费在写数据文件块的时间，以毫秒计</entry>
    </row>
    <row>
     <entry><structfield>stats_reset</></entry>
     <entry><type>timestamp with time zone</></entry>
     <entry>这些统计信息上次被重置的时间</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_stat_database</structname>视图将为集簇中的每一个数据库包含有一行，每一行显示数据库范围的统计信息。
  </para>

  <table id="pg-stat-all-tables-view" xreflabel="pg_stat_all_tables">
   <title><structname>pg_stat_all_tables</structname>视图</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>relid</></entry>
     <entry><type>oid</></entry>
     <entry>一个表的 OID</entry>
    </row>
    <row>
     <entry><structfield>schemaname</></entry>
     <entry><type>name</></entry>
     <entry>这个表所在的模式的名称</entry>
    </row>
    <row>
     <entry><structfield>relname</></entry>
     <entry><type>name</></entry>
     <entry>这个表的名称</entry>
    </row>
    <row>
     <entry><structfield>seq_scan</></entry>
     <entry><type>bigint</></entry>
     <entry>在这个表上发起的顺序扫描的次数</entry>
    </row>
    <row>
     <entry><structfield>seq_tup_read</></entry>
     <entry><type>bigint</></entry>
     <entry>被顺序扫描取得的活着的行的数量</entry>
    </row>
    <row>
     <entry><structfield>idx_scan</></entry>
     <entry><type>bigint</></entry>
     <entry>在这个表上发起的索引扫描的次数</entry>
    </row>
    <row>
     <entry><structfield>idx_tup_fetch</></entry>
     <entry><type>bigint</></entry>
     <entry>被索引扫描取得的活着的行的数量</entry>
    </row>
    <row>
     <entry><structfield>n_tup_ins</></entry>
     <entry><type>bigint</></entry>
     <entry>被插入的行数</entry>
    </row>
    <row>
     <entry><structfield>n_tup_upd</></entry>
     <entry><type>bigint</></entry>
     <entry>被更新的行数</entry>
    </row>
    <row>
     <entry><structfield>n_tup_del</></entry>
     <entry><type>bigint</></entry>
     <entry>被删除的行数</entry>
    </row>
    <row>
     <entry><structfield>n_tup_hot_upd</></entry>
     <entry><type>bigint</></entry>
     <entry>被更新的 HOT 行数（即不要求独立索引更新的行更新）</entry>
    </row>
    <row>
     <entry><structfield>n_live_tup</></entry>
     <entry><type>bigint</></entry>
     <entry>活着的行的估计数量</entry>
    </row>
    <row>
     <entry><structfield>n_dead_tup</></entry>
     <entry><type>bigint</></entry>
     <entry>死亡行的估计数量</entry>
    </row>
    <row>
     <entry><structfield>n_mod_since_analyze</></entry>
     <entry><type>bigint</></entry>
     <entry>从这个表最后一次被分析后备修改的行的估计数量</entry>
    </row>
    <row>
     <entry><structfield>last_vacuum</></entry>
     <entry><type>timestamp with time zone</></entry>
     <entry>上次这个表被手动清理的时间（不统计<command>VACUUM FULL</>）</entry>
    </row>
    <row>
     <entry><structfield>last_autovacuum</></entry>
     <entry><type>timestamp with time zone</></entry>
     <entry>上次这个表被自动清理守护进程清理的时间</entry>
    </row>
    <row>
     <entry><structfield>last_analyze</></entry>
     <entry><type>timestamp with time zone</></entry>
     <entry>上次这个表被手动分析的时间</entry>
    </row>
    <row>
     <entry><structfield>last_autoanalyze</></entry>
     <entry><type>timestamp with time zone</></entry>
     <entry>上次这个表被自动清理守护进程分析的时间</entry>
    </row>
    <row>
     <entry><structfield>vacuum_count</></entry>
     <entry><type>bigint</></entry>
     <entry>这个表已被手工清理的次数（不统计<command>VACUUM FULL</>）</entry>
    </row>
    <row>
     <entry><structfield>autovacuum_count</></entry>
     <entry><type>bigint</></entry>
     <entry>这个表已被自动清理守护进程清理的次数</entry>
    </row>
    <row>
     <entry><structfield>analyze_count</></entry>
     <entry><type>bigint</></entry>
     <entry>这个表已被手工分析的次数</entry>
    </row>
    <row>
     <entry><structfield>autoanalyze_count</></entry>
     <entry><type>bigint</></entry>
     <entry>这个表已被自动清理守护进程分析的次数</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_stat_all_tables</structname>视图将为当前数据库中的每一个表（包括 TOAST 表）包含一行，该行显示与对该表的访问相关的统计信息。<structname>pg_stat_user_tables</structname>和<structname>pg_stat_sys_tables</structname>视图包含相同的信息，但是被过滤得分别只显示用户和系统表。
  </para>

  <table id="pg-stat-all-indexes-view" xreflabel="pg_stat_all_indexes">
   <title><structname>pg_stat_all_indexes</structname>视图</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>relid</></entry>
     <entry><type>oid</></entry>
     <entry>这个索引的基表的 OID</entry>
    </row>
    <row>
     <entry><structfield>indexrelid</></entry>
     <entry><type>oid</></entry>
     <entry>这个索引的 OID</entry>
    </row>
    <row>
     <entry><structfield>schemaname</></entry>
     <entry><type>name</></entry>
     <entry>这个索引所在的模式的名称</entry>
    </row>
    <row>
     <entry><structfield>relname</></entry>
     <entry><type>name</></entry>
     <entry>这个索引的基表的名称</entry>
    </row>
    <row>
     <entry><structfield>indexrelname</></entry>
     <entry><type>name</></entry>
     <entry>这个索引的名称</entry>
    </row>
    <row>
     <entry><structfield>idx_scan</></entry>
     <entry><type>bigint</></entry>
     <entry>在这个索引上发起的索引扫描次数</entry>
    </row>
    <row>
     <entry><structfield>idx_tup_read</></entry>
     <entry><type>bigint</></entry>
     <entry>在这个索引上由扫描返回的索引项数量</entry>
    </row>
    <row>
     <entry><structfield>idx_tup_fetch</></entry>
     <entry><type>bigint</></entry>
     <entry>被使用这个索引的简单索引扫描取得的活着的表行数量</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_stat_all_indexes</structname>视图将为当前数据库中的每个索引包含一行，该行显示关于对该索引访问的统计信息。<structname>pg_stat_user_indexes</structname>和<structname>pg_stat_sys_indexes</structname>视图包含相同的信息，但是被过滤得只分别显示用户和系统索引。
  </para>

  <para>
   索引可以通过简单索引扫描或<quote>位图</>索引扫描使用。在一次位图扫描中，多个索引的输出可以被通过 AND 或 OR 规则组合，因此当使用一次位图扫描时难以将取得的个体堆行与特定的索引关联起来。因此，一次位图扫描会增加它使用的索引的<structname>pg_stat_all_indexes</>.<structfield>idx_tup_read</>计数，并且为每个表增加<structname>pg_stat_all_tables</>.<structfield>idx_tup_fetch</>计数，但是它不影响<structname>pg_stat_all_indexes</>.<structfield>idx_tup_fetch</>。
  </para>

  <note>
   <para>
    即使不用位图扫描，<structfield>idx_tup_read</>和<structfield>idx_tup_fetch</>计数也可能不同，因为<structfield>idx_tup_read</>统计从该索引取得的索引项而<structfield>idx_tup_fetch</>统计从表取得的或者的行。如果使用该索引取得了任何死亡行或还未提交的行，或者如果通过一次只用索引扫描的方式避免了任何堆获取，后者将较小。
   </para>
  </note>

  <table id="pg-statio-all-tables-view" xreflabel="pg_statio_all_tables">
   <title><structname>pg_statio_all_tables</structname>视图</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>relid</></entry>
     <entry><type>oid</></entry>
     <entry>一个表的 OID</entry>
    </row>
    <row>
     <entry><structfield>schemaname</></entry>
     <entry><type>name</></entry>
     <entry>这个表所在的模式的名称</entry>
    </row>
    <row>
     <entry><structfield>relname</></entry>
     <entry><type>name</></entry>
     <entry>这个表的名称</entry>
    </row>
    <row>
     <entry><structfield>heap_blks_read</></entry>
     <entry><type>bigint</></entry>
     <entry>从这个表读取的磁盘块数量</entry>
    </row>
    <row>
     <entry><structfield>heap_blks_hit</></entry>
     <entry><type>bigint</></entry>
     <entry>在这个表中的缓冲区命中数量</entry>
    </row>
    <row>
     <entry><structfield>idx_blks_read</></entry>
     <entry><type>bigint</></entry>
     <entry>从这个表上所有索引中读取的磁盘块数</entry>
    </row>
    <row>
     <entry><structfield>idx_blks_hit</></entry>
     <entry><type>bigint</></entry>
     <entry>在这个表上的所有索引中的缓冲区命中数量</entry>
    </row>
    <row>
     <entry><structfield>toast_blks_read</></entry>
     <entry><type>bigint</></entry>
     <entry>从这个表的 TOAST 表（如果有）读取的磁盘块数</entry>
    </row>
    <row>
     <entry><structfield>toast_blks_hit</></entry>
     <entry><type>bigint</></entry>
     <entry>在这个表的 TOAST 表（如果有）中的缓冲区命中数量</entry>
    </row>
    <row>
     <entry><structfield>tidx_blks_read</></entry>
     <entry><type>bigint</></entry>
     <entry>从这个表的 TOAST 表索引（如果有）中读取的磁盘块数</entry>
    </row>
    <row>
     <entry><structfield>tidx_blks_hit</></entry>
     <entry><type>bigint</></entry>
     <entry>在这个表的 TOAST 表索引（如果有）中的缓冲区命中数量</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_statio_all_tables</structname>视图将为当前数据库中的每个表（包括 TOAST 表）包含一行，该行显示指定表上有关 I/O 的统计信息。<structname>pg_statio_user_tables</structname>和<structname>pg_statio_sys_tables</structname>视图包含相同的信息，但是被过滤得分别只显示用户表和系统表。
  </para>

  <table id="pg-statio-all-indexes-view" xreflabel="pg_statio_all_indexes">
   <title><structname>pg_statio_all_indexes</structname>视图</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>relid</></entry>
     <entry><type>oid</></entry>
     <entry>这个索引的基表的 OID</entry>
    </row>
    <row>
     <entry><structfield>indexrelid</></entry>
     <entry><type>oid</></entry>
     <entry>这个索引的 OID</entry>
    </row>
    <row>
     <entry><structfield>schemaname</></entry>
     <entry><type>name</></entry>
     <entry>这个索引所在的模式的名称</entry>
    </row>
    <row>
     <entry><structfield>relname</></entry>
     <entry><type>name</></entry>
     <entry>这个索引的基表的名称</entry>
    </row>
    <row>
     <entry><structfield>indexrelname</></entry>
     <entry><type>name</></entry>
     <entry>这个索引的名称</entry>
    </row>
    <row>
     <entry><structfield>idx_blks_read</></entry>
     <entry><type>bigint</></entry>
     <entry>从这个索引读取的磁盘块数</entry>
    </row>
    <row>
     <entry><structfield>idx_blks_hit</></entry>
     <entry><type>bigint</></entry>
     <entry>在这个索引中的缓冲区命中数量</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_statio_all_indexes</structname>视图将为当前数据库中的每个索引包含一行，该行显示指定索引上有关 I/O 的统计信息。<structname>pg_statio_user_indexes</structname>和<structname>pg_statio_sys_indexes</structname>视图包含相同的信息，但是被过滤得分别只显示用户索引和系统索引。
  </para>

  <table id="pg-statio-all-sequences-view" xreflabel="pg_statio_all_sequences">
   <title><structname>pg_statio_all_sequences</structname>视图</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>relid</></entry>
     <entry><type>oid</></entry>
     <entry>一个序列的 OID</entry>
    </row>
    <row>
     <entry><structfield>schemaname</></entry>
     <entry><type>name</></entry>
     <entry>这个序列所在的模式的名称</entry>
    </row>
    <row>
     <entry><structfield>relname</></entry>
     <entry><type>name</></entry>
     <entry>这个序列的名称</entry>
    </row>
    <row>
     <entry><structfield>blks_read</></entry>
     <entry><type>bigint</></entry>
     <entry>从这个序列中读取的磁盘块数</entry>
    </row>
    <row>
     <entry><structfield>blks_hit</></entry>
     <entry><type>bigint</></entry>
     <entry>在这个序列中的缓冲区命中数量</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_statio_all_sequences</structname>视图将为当前数据库中的每个序列包含一行，该行显示在指定序列上有关 I/O 的统计信息。
  </para>

  <table id="pg-stat-user-functions-view" xreflabel="pg_stat_user_functions">
   <title><structname>pg_stat_user_functions</structname>视图</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>funcid</></entry>
     <entry><type>oid</></entry>
     <entry>一个函数的 OID</entry>
    </row>
    <row>
     <entry><structfield>schemaname</></entry>
     <entry><type>name</></entry>
     <entry>这个函数所在的模式的名称</entry>
    </row>
    <row>
     <entry><structfield>funcname</></entry>
     <entry><type>name</></entry>
     <entry>这个函数的名称</entry>
    </row>
    <row>
     <entry><structfield>calls</></entry>
     <entry><type>bigint</></entry>
     <entry>这个函数已经被调用的次数</entry>
    </row>
    <row>
     <entry><structfield>total_time</></entry>
     <entry><type>double precision</></entry>
     <entry>在这个函数以及它所调用的其他函数中花费的总时间，以毫秒计</entry>
    </row>
    <row>
     <entry><structfield>self_time</></entry>
     <entry><type>double precision</></entry>
     <entry>在这个函数本身花费的总时间，不包括被它调用的其他函数，以毫秒计</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_stat_user_functions</structname>视图将为每一个被追踪的函数包含一行，该行显示有关该函数执行的统计信息。<xref linkend="guc-track-functions">参数控制到底哪些函数被跟踪。
  </para>

  <table id="pg-stat-replication-view" xreflabel="pg_stat_replication">
   <title><structname>pg_stat_replication</structname>视图</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>pid</></entry>
     <entry><type>integer</></entry>
     <entry>一个 WAL 发送者进程的进程 ID</entry>
    </row>
    <row>
     <entry><structfield>usesysid</></entry>
     <entry><type>oid</></entry>
     <entry>登入到这个 WAL 发送者进程的用户 OID</entry>
    </row>
    <row>
     <entry><structfield>usename</></entry>
     <entry><type>name</></entry>
     <entry>登入到这个 WAL 发送者进程的用户名</entry>
    </row>
    <row>
     <entry><structfield>application_name</></entry>
     <entry><type>text</></entry>
     <entry>连接到这个 WAL 发送者的应用名称</entry>
    </row>
    <row>
     <entry><structfield>client_addr</></entry>
     <entry><type>inet</></entry>
     <entry>连接到这个 WAL 发送者的客户端的 IP 地址。如果这个域为空，它指示该客户端是通过一个服务器机器上的 Unix 套接字连接的。
     </entry>
    </row>
    <row>
     <entry><structfield>client_hostname</></entry>
     <entry><type>text</></entry>
     <entry>已连接客户端的主机名，由<structfield>client_addr</>的一次反向 DNS 查找报告。这个域对于 IP 连接将只为非空，并且只有当<xref linkend="guc-log-hostname">被启用时才为非空。
     </entry>
    </row>
    <row>
     <entry><structfield>client_port</></entry>
     <entry><type>integer</></entry>
     <entry>客户端用来和这个 WAL 发送者通信的 TCP 端口号，或者在使用一个 Unix 套接字时为<literal>-1</>
     </entry>
    </row>
    <row>
     <entry><structfield>backend_start</></entry>
     <entry><type>timestamp with time zone</></entry>
     <entry>这个进程被启动的时间，即当客户端连接到这个 WAL 发送者时
     </entry>
    </row>
    <row>
     <entry><structfield>backend_xmin</structfield></entry>
     <entry><type>xid</type></entry>
     <entry><xref linkend="guc-hot-standby-feedback">报告的这个后备机的<literal>xmin</>范围。</entry>
    </row>
    <row>
     <entry><structfield>state</></entry>
     <entry><type>text</></entry>
     <entry>当前 WAL 发送者的状态</entry>
    </row>
    <row>
     <entry><structfield>sent_location</></entry>
     <entry><type>pg_lsn</></entry>
     <entry>在这个连接上被发送的最后的事务日志位置</entry>
    </row>
    <row>
     <entry><structfield>write_location</></entry>
     <entry><type>pg_lsn</></entry>
     <entry>被这个后备服务器写入到磁盘的最后的事务日志位置</entry>
    </row>
    <row>
     <entry><structfield>flush_location</></entry>
     <entry><type>pg_lsn</></entry>
     <entry>被这个后备服务器刷入到磁盘的最后的事务日志位置</entry>
    </row>
    <row>
     <entry><structfield>replay_location</></entry>
     <entry><type>pg_lsn</></entry>
     <entry>被这个后备服务器重放到数据库中的最后的事务日志位置</entry>
    </row>
    <row>
     <entry><structfield>sync_priority</></entry>
     <entry><type>integer</></entry>
     <entry>这个后备服务器被选中为同步后备的优先级</entry>
    </row>
    <row>
     <entry><structfield>sync_state</></entry>
     <entry><type>text</></entry>
     <entry>这个后备服务器的同步状态</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_stat_replication</structname>视图将为每个 WAL 发送者进程包含一行，该行显示连接到发送者的后备服务器的复制的统计信息。只列出直接连接的后备服务器，关于下游后备服务器的信息不可用。
  </para>

  <table id="pg-stat-database-conflicts-view" xreflabel="pg_stat_database_conflicts">
   <title><structname>pg_stat_database_conflicts</structname>视图</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>datid</></entry>
     <entry><type>oid</></entry>
     <entry>一个数据库的 OID</entry>
    </row>
    <row>
     <entry><structfield>datname</></entry>
     <entry><type>name</></entry>
     <entry>这个数据库的名称</entry>
    </row>
    <row>
     <entry><structfield>confl_tablespace</></entry>
     <entry><type>bigint</></entry>
     <entry>在这个数据库中由于已删除表空间而被取消的查询数量</entry>
    </row>
    <row>
     <entry><structfield>confl_lock</></entry>
     <entry><type>bigint</></entry>
     <entry>在这个数据库中由于锁超时而被取消的查询数量</entry>
    </row>
    <row>
     <entry><structfield>confl_snapshot</></entry>
     <entry><type>bigint</></entry>
     <entry>在这个数据库中由于老旧快照而被取消的查询数量</entry>
    </row>
    <row>
     <entry><structfield>confl_bufferpin</></entry>
     <entry><type>bigint</></entry>
     <entry>在这个数据库中由于被占用的缓冲区而被取消的查询数量</entry>
    </row>
    <row>
     <entry><structfield>confl_deadlock</></entry>
     <entry><type>bigint</></entry>
     <entry>在这个数据库中由于死锁而被取消的查询数量</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_stat_database_conflicts</structname>视图将为每一个数据库包含一行，该行显示数据库范围发生的由于与后备服务器上的恢复冲突而取消的查询相关的统计信息。这个视图将只包含在后备服务器上的信息，因为在主服务器上不会发生冲突。
  </para>

 </sect2>

 <sect2 id="monitoring-stats-functions">
  <title>统计函数</title>

  <para>
   其他查看统计信息的方法是直接使用查询，这些查询使用上述标准视图用到的底层统计信息访问函数。如要了解如函数名等细节，可参考标准视图的定义（例如，在<application>psql</>中你可以发出<literal>\d+ pg_stat_activity</>）。针对每一个数据库统计信息的访问函数把一个数据库 OID 作为参数来标识要报告哪个数据库。而针对每个表和每个索引的函数要求表或索引 OID。针对每个函数统计信息的函数用一个函数 OID。注意只有在当前数据库中的表、索引和函数才能被这些函数看到。
  </para>

  <para>
   与统计收集相关的额外函数被列举在<xref linkend="monitoring-stats-funcs-table">中。
  </para>

  <table id="monitoring-stats-funcs-table">
   <title>额外统计函数</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>函数</entry>
      <entry>返回类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>

     <row>
       <!-- See also the entry for this in func.sgml -->
      <entry><literal><function>pg_backend_pid()</function></literal></entry>
      <entry><type>integer</type></entry>
      <entry>
       处理当前会话的服务器进程的进程 ID
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_activity</function>(<type>integer</type>)</literal><indexterm><primary>pg_stat_get_activity</primary></indexterm></entry>
      <entry><type>setof record</type></entry>
      <entry>
       返回具有指定 PID 的后端相关的一个记录，或者在指定<symbol>NULL</symbol>的情况下为系统中每一个活动后端返回一个记录。被返回的域是<structname>pg_stat_activity</structname>视图中的那些域的一个子集。
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_clear_snapshot()</function></literal><indexterm><primary>pg_stat_clear_snapshot</primary></indexterm></entry>
      <entry><type>void</type></entry>
      <entry>
       抛弃当前的统计快照
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_reset()</function></literal><indexterm><primary>pg_stat_reset</primary></indexterm></entry>
      <entry><type>void</type></entry>
      <entry>
       把用于当前数据库的所有统计计数器重置为零（要求超级用户权限）
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_reset_shared</function>(text)</literal><indexterm><primary>pg_stat_reset_shared</primary></indexterm></entry>
      <entry><type>void</type></entry>
      <entry>
       把某些集簇范围的统计计数器重置为零，具体哪些取决于参数（要求超级用户权限）。
       调用<literal>pg_stat_reset_shared('bgwriter')</>把<structname>pg_stat_bgwriter</>
       视图中显示的所有计数器清零。调用<literal>pg_stat_reset_shared('archiver')</>
       将会把<structname>pg_stat_archiver</>视图中展示的所有计数器清零。
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_reset_single_table_counters</function>(oid)</literal><indexterm><primary>pg_stat_reset_single_table_counters</primary></indexterm></entry>
      <entry><type>void</type></entry>
      <entry>
       把当前数据库中用于单个表或索引的统计数据重置为零（要求超级用户权限）
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_reset_single_function_counters</function>(oid)</literal><indexterm><primary>pg_stat_reset_single_function_counters</primary></indexterm></entry>
      <entry><type>void</type></entry>
      <entry>
       把当前数据库中用于单个函数的统计信息重置为零（要求超级用户权限）
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   <function>pg_stat_get_activity</function>是<structname>pg_stat_activity</>视图的底层函数，它返回一个行集合，其中包含有关每个后端进程所有可用的信息。有时只获得该信息的一个子集可能会更方便。在那些情况中，可以使用一组更老的针对每个后端的统计访问函数，这些显示在<xref linkend="monitoring-stats-backend-funcs-table">中。这些访问函数使用一个后端 ID 号，范围从 1 到当前活动后端数目。函数<function>pg_stat_get_backend_idset</function>提供了一种方便的方法为每个活动后端产生一行来调用这些函数。例如，要显示<acronym>PID</>以及所有后端当前的查询：

<programlisting>
SELECT pg_stat_get_backend_pid(s.backendid) AS pid,
       pg_stat_get_backend_activity(s.backendid) AS query
    FROM (SELECT pg_stat_get_backend_idset() AS backendid) AS s;
</programlisting>
  </para>

  <table id="monitoring-stats-backend-funcs-table">
   <title>针对每个后端的统计函数</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>函数</entry>
      <entry>返回类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry><literal><function>pg_stat_get_backend_idset()</function></literal></entry>
      <entry><type>setof integer</type></entry>
      <entry>当前活动后端 ID 号的集合（从 1 到活动后端数目）</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_activity(integer)</function></literal></entry>
      <entry><type>text</type></entry>
      <entry>这个后端最近查询的文本</>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_activity_start(integer)</function></literal></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>最近查询被开始的时间</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_client_addr(integer)</function></literal></entry>
      <entry><type>inet</type></entry>
      <entry>该客户端连接到这个后端的 IP 地址</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_client_port(integer)</function></literal></entry>
      <entry><type>integer</type></entry>
      <entry>该客户端用来通信的 TCP 端口号</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_dbid(integer)</function></literal></entry>
      <entry><type>oid</type></entry>
      <entry>这个后端连接到的数据库的 OID</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_pid(integer)</function></literal></entry>
      <entry><type>integer</type></entry>
      <entry>这个后端的进程 ID</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_start(integer)</function></literal></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>这个进程被开始的时间</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_userid(integer)</function></literal></entry>
      <entry><type>oid</type></entry>
      <entry>登录到这个后端的用户的 OID</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_waiting(integer)</function></literal></entry>
      <entry><type>boolean</type></entry>
      <entry>如果这个后端当前正在等待一个锁，则为真</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_xact_start(integer)</function></literal></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>当前事务被开始的时间</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect2>
 </sect1>

 <sect1 id="monitoring-locks">
  <title>查看锁</title>

  <indexterm zone="monitoring-locks">
   <primary>lock</primary>
   <secondary>monitoring</secondary>
  </indexterm>

  <para>
   监控数据库活动的另外一个有用的工具是<structname>pg_locks</structname>系统表。这样就允许数据库管理员查看在锁管理器里面未解决的锁的信息。例如，这个功能可以被用于：

   <itemizedlist>
    <listitem>
     <para>
      查看当前所有未解决的锁、在一个特定数据库中的关系上所有的锁、在一个特定关系上所有的锁，或者由一个特定<productname>PostgreSQL</productname>会话持有的所有的锁。
     </para>
    </listitem>

    <listitem>
     <para>
      判断当前数据库中带有最多未授予锁的关系（它很可能是数据库客户端的竞争源）。
     </para>
    </listitem>

    <listitem>
     <para>
      判断锁竞争给数据库总体性能带来的影响，以及锁竞争随着整个数据库流量的变化范围。
     </para>
    </listitem>
   </itemizedlist>

   <structname>pg_locks</structname>视图的细节在<xref linkend="view-pg-locks">中。更多有关<productname>PostgreSQL</productname>的锁和管理并发性的信息，请参考<xref linkend="mvcc">。
  </para>
 </sect1>

 <sect1 id="dynamic-trace">
  <title>动态追踪</title>

 <indexterm zone="dynamic-trace">
  <primary>DTrace</primary>
 </indexterm>

  <para>
   <productname>PostgreSQL</productname>提供了功能来支持数据库服务器的动态追踪。这样就允许在代码中的特 定点上调用外部工具来追踪执行过程。
  </para>

  <para>
   一些探针或追踪点已经被插入在源代码中。这些探针的目的是被数据库开发者和管理员使用。默认情况下，探针不被编译到<productname>PostgreSQL</productname>中；用户需要显式地告诉配置脚本使得探针可用。
  </para>

  <para>
   目前，在写本文当时<ulink url="https://en.wikipedia.org/wiki/DTrace">DTrace</ulink>已被支持，它在 Solaris、OS X、FreeBSD、NetBSD 和 Oracle Linux 上可用。Linux 的<ulink url="http://sourceware.org/systemtap/">SystemTap</ulink>项目提供了一种可用的 DTrace 等价物。支持其他动态追踪工具在理论上可以通过改变<filename>src/include/utils/probes.h</>中的宏定义实现。
  </para>

  <sect2 id="compiling-for-trace">
   <title>动态追踪的编译</title>

  <para>
   默认情况下，探针是不可用的，因此你将需要显式地告诉配置脚本让探针在<productname>PostgreSQL</productname>中可用。要包括 DTrace 支持，在配置时指定<option>--enable-dtrace</>。更多信息请见<xref linkend="install-procedure">。
  </para>
  </sect2>

  <sect2 id="trace-points">
   <title>内建探针</title>

  <para>
   如<xref linkend="dtrace-probe-point-table">所示，源代码中提供了一些标准探针。<xref linkend="typedefs-table">显式了在探针中使用的类型。当然，可以增加更多探针来增强<productname>PostgreSQL</>的可观测性。
  </para>

 <table id="dtrace-probe-point-table">
  <title>内建 DTrace 探针</title>
  <tgroup cols="3">
   <thead>
    <row>
     <entry>名称</entry>
     <entry>参数</entry>
     <entry>描述</entry>
    </row>
   </thead>

   <tbody>

    <row>
     <entry>transaction-start</entry>
     <entry>(LocalTransactionId)</entry>
     <entry>在一个新事务开始时触发的探针。arg0 是事务 ID。</entry>
    </row>
    <row>
     <entry>transaction-commit</entry>
     <entry>(LocalTransactionId)</entry>
     <entry>在一个事务成功完成时触发的探针。arg0 是事务 ID。</entry>
    </row>
    <row>
     <entry>transaction-abort</entry>
     <entry>(LocalTransactionId)</entry>
     <entry>当一个事务失败完成时触发的探针。arg0 是事务 ID。</entry>
    </row>
    <row>
     <entry>query-start</entry>
     <entry>(const char *)</entry>
     <entry>当一个查询的处理被开始时触发的探针。arg0 是查询字符串。</entry>
    </row>
    <row>
     <entry>query-done</entry>
     <entry>(const char *)</entry>
     <entry>当一个查询的处理完成时触发的探针。arg0 是查询字符串。</entry>
    </row>
    <row>
     <entry>query-parse-start</entry>
     <entry>(const char *)</entry>
     <entry>当一个查询的解析被开始时触发的探针。arg0 是查询字符串。</entry>
    </row>
    <row>
     <entry>query-parse-done</entry>
     <entry>(const char *)</entry>
     <entry>当一个查询的解析完成时触发的探针。arg0 是查询字符串。</entry>
    </row>
    <row>
     <entry>query-rewrite-start</entry>
     <entry>(const char *)</entry>
     <entry>当一个查询的重写被开始时触发的探针。arg0 是查询字符串。</entry>
    </row>
    <row>
     <entry>query-rewrite-done</entry>
     <entry>(const char *)</entry>
     <entry>当一个查询的重写完成时触发的探针。arg0 是查询字符串。</entry>
    </row>
    <row>
     <entry>query-plan-start</entry>
     <entry>()</entry>
     <entry>当一个查询的规划被开始时触发的探针。</entry>
    </row>
    <row>
     <entry>query-plan-done</entry>
     <entry>()</entry>
     <entry>当一个查询的规划完成时触发的探针。</entry>
    </row>
    <row>
     <entry>query-execute-start</entry>
     <entry>()</entry>
     <entry>当一个查询的执行被开始时触发的探针。</entry>
    </row>
    <row>
     <entry>query-execute-done</entry>
     <entry>()</entry>
     <entry>当一个查询的执行完成时触发的探针。</entry>
    </row>
    <row>
     <entry>statement-status</entry>
     <entry>(const char *)</entry>
     <entry>任何时候当服务器进程更新它的<structname>pg_stat_activity</>.<structfield>status</>时触发的探针。arg0 是新的状态字符串。</entry>
    </row>
    <row>
     <entry>checkpoint-start</entry>
     <entry>(int)</entry>
     <entry>当一个检查点被开始时触发的探针。arg0 保持逐位标志来区分不同的检查点类型，例如关闭（shutdown）、立即（immediate）或强制（force）。</entry>
    </row>
    <row>
     <entry>checkpoint-done</entry>
     <entry>(int, int, int, int, int)</entry>
     <entry>当一个检查点完成时触发的探针（检查点处理过程中序列中列出的下一个触发的探针）。arg0 是要写的缓冲区数量。arg1 是缓冲区的总数。arg2、arg3 和 arg4 分别包含了增加、删除和循环回收的 xlog 文件的数量。</entry>
    </row>
    <row>
     <entry>clog-checkpoint-start</entry>
     <entry>(bool)</entry>
     <entry>当一个检查点的 CLOG 部分被开始时触发的探针。arg0 为真表示正常检查点，为假表示关闭检查点。</entry>
    </row>
    <row>
     <entry>clog-checkpoint-done</entry>
     <entry>(bool)</entry>
     <entry>当一个检查点的 CLOG 部分完成时触发的探针。arg0 的含义与 clog-checkpoint-start 中相同。</entry>
    </row>
    <row>
     <entry>subtrans-checkpoint-start</entry>
     <entry>(bool)</entry>
     <entry>当一个检查点的 SUBTRANS 部分被开始时触发的探针。arg0 为真表示正常检查点，为假表示关闭检查点。</entry>
    </row>
    <row>
     <entry>subtrans-checkpoint-done</entry>
     <entry>(bool)</entry>
     <entry>当一个检查点的 SUBTRANS 部分完成时触发的探针。arg0 的含义与 subtrans-checkpoint-start 中相同。</entry>
    </row>
    <row>
     <entry>multixact-checkpoint-start</entry>
     <entry>(bool)</entry>
     <entry>当一个检查点的 MultiXact 部分被开始时触发的探针。arg0 为真表示正常检查点，为假表示关闭检查点。</entry>
    </row>
    <row>
     <entry>multixact-checkpoint-done</entry>
     <entry>(bool)</entry>
     <entry>当一个检查点的 MultiXact 部分完成时触发的探针。arg0 的含义与 multixact-checkpoint-start 中相同。</entry>
    </row>
    <row>
     <entry>buffer-checkpoint-start</entry>
     <entry>(int)</entry>
     <entry>当一个检查点的写缓冲区部分被开始时触发的探针。arg0 保持逐位标志来区分不同的检查点类型，例如关闭（shutdown）、立即（immediate）或强制（force）。</entry>
    </row>
    <row>
     <entry>buffer-sync-start</entry>
     <entry>(int, int)</entry>
     <entry>当我们在检查点期间开始写脏缓冲区时（在标识哪些缓冲区必须被写之后）触发的探针。arg0 是缓冲区总数，arg1 是当前为脏并且需要被写的缓冲区数量。</entry>
    </row>
    <row>
     <entry>buffer-sync-written</entry>
     <entry>(int)</entry>
     <entry>在检查点期间当每个缓冲区被写完之后触发的探针。arg0 是缓冲区的 ID。</entry>
    </row>
    <row>
     <entry>buffer-sync-done</entry>
     <entry>(int, int, int)</entry>
     <entry>当所有脏缓冲区被写之后触发的探针。arg0 是缓冲区总数。arg1 是检查点进程实际写的缓冲区数量。arg2 是期望写的数目（buffer-sync-start 的 arg1）；arg1 和 arg2 的任何的不同反映在该检查点期间有其他进程刷写了缓冲区。</entry>
    </row>
    <row>
     <entry>buffer-checkpoint-sync-start</entry>
     <entry>()</entry>
     <entry>在脏缓冲区被写入到内核之后并且在开始发出 fsync 请求之前触发的探针。</entry>
    </row>
    <row>
     <entry>buffer-checkpoint-done</entry>
     <entry>()</entry>
     <entry>当同步缓冲区到磁盘完成时触发的探针。</entry>
    </row>
    <row>
     <entry>twophase-checkpoint-start</entry>
     <entry>()</entry>
     <entry>当一个检查点的两阶段部分被开始时触发的探针。</entry>
    </row>
    <row>
     <entry>twophase-checkpoint-done</entry>
     <entry>()</entry>
     <entry>当一个检查点的两阶段部分完成时触发的探针。</entry>
    </row>
    <row>
     <entry>buffer-read-start</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool)</entry>
     <entry>当一次缓冲区读被开始时触发的探针。arg0 和 arg1 包含该页的分叉号和块号（如果这是一次关系扩展请求，arg1 为 -1）。arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。对一个本地缓冲区，arg5 是创建临时关系的后端的 ID；对于一个共享缓冲区，arg5 是 InvalidBackendId（-1）。表示真，对共享缓冲区表示假。 arg6 为真表示一次关系扩展请求，为假表示正常读。</entry>
    </row>
    <row>
     <entry>buffer-read-done</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool, bool)</entry>
     <entry>当一次缓冲区读完成时触发的探测器。arg0 和 arg1 包含该页的分叉号和块号（如果这是一次关系扩展请求，arg1 现在包含新增加块的块号）。arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。对一个本地缓冲区，arg5 是创建临时关系的后端的 ID；对于一个共享缓冲区，arg5 是 InvalidBackendId（-1）。表示真，对共享缓冲区表示假。 arg6 为真表示一次关系扩展请求，为假表示正常读。arg7 为真表示在池中找到该缓冲区，为假表示没有找到。</entry>
    </row>
    <row>
     <entry>buffer-flush-start</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid)</entry>
     <entry>在发出对一个共享缓冲区的任意写请求之前触发的探针。arg0 和 arg1 包含该页的分叉号和块号。arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。</entry>
    </row>
    <row>
     <entry>buffer-flush-done</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid)</entry>
     <entry>当一个写请求完成时触发的探针（注意这只反映传递数据给内核的时间，它通常并没有实际地被写入到磁盘）。参数和 buffer-flush-start 的相同。</entry>
    </row>
    <row>
     <entry>buffer-write-dirty-start</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid)</entry>
     <entry>当一个服务器进程开始写一个脏缓冲区时触发的探针（如果这经常发生，表示<xref linkend="guc-shared-buffers">太小，或需要调整 bgwriter 的控制参数）。arg0 和 arg1 包含该页的分叉号和块号。arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。</entry>
    </row>
    <row>
     <entry>buffer-write-dirty-done</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid)</entry>
     <entry>当一次脏缓冲区写完成时触发的探针。参数与 buffer-write-dirty-start 相同。</entry>
    </row>
    <row>
     <entry>wal-buffer-write-dirty-start</entry>
     <entry>()</entry>
     <entry>当一个服务器进程因为没有可用 WAL 缓冲区空间开始写一个脏 WAL 缓冲区时触发的探针（如果这经常发生，表示<xref linkend="guc-wal-buffers">太小）。</entry>
    </row>
    <row>
     <entry>wal-buffer-write-dirty-done</entry>
     <entry>()</entry>
     <entry>当一次脏 WAL 缓冲区完成时触发的探针。</entry>
    </row>
    <row>
     <entry>xlog-insert</entry>
     <entry>(unsigned char, unsigned char)</entry>
     <entry>当一个 WAL 记录被插入时触发的探针。arg0 是该记录的资源管理者（rmid）。arg1 包含 info 标志。</entry>
    </row>
    <row>
     <entry>xlog-switch</entry>
     <entry>()</entry>
     <entry>当请求一次 WAL 段切换时触发的探针。</entry>
    </row>
    <row>
     <entry>smgr-md-read-start</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</entry>
     <entry>当开始从一个关系读取一块时触发的探针。arg0 和 arg1 包含该页的分叉号和块号。arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。对一个本地缓冲区，arg5 是创建临时关系的后端的 ID；对于一个共享缓冲区，arg5 是 InvalidBackendId（-1）。</entry>
    </row>
    <row>
     <entry>smgr-md-read-done</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)</entry>
     <entry>当一次块读取完成时触发的探针。arg0 和 arg1 包含该页的分叉号和块号。arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。对一个本地缓冲区，arg5 是创建临时关系的后端的 ID；对于一个共享缓冲区，arg5 是 InvalidBackendId（-1）。arg6 是实际读取的字节数，而 arg7 是请求读取的字节数（如果两者不同就意味着麻烦）。</entry>
    </row>
    <row>
     <entry>smgr-md-write-start</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</entry>
     <entry>当开始向一个关系中写入一个块时触发的探针。arg0 和 arg1 包含该页的分叉号和块号。arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。对一个本地缓冲区，arg5 是创建临时关系的后端的 ID；对于一个共享缓冲区，arg5 是 InvalidBackendId（-1）。</entry>
    </row>
    <row>
     <entry>smgr-md-write-done</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)</entry>
     <entry>当一个块写操作完成时触发的探针。arg0 和 arg1 包含该页的分叉号和块号。arg2、arg3和arg4 包含表空间、数据库和关系 OID来标识该关系。对于一个本地缓冲区，arg5 是创建临时关系的后端 ID；对于一个共享缓冲区，arg5 是 InvalidBackendId（-1）。arg6 是实际写的字节数，而 arg7 是要求写的字节数（如果这两者不同，则意味着麻烦）。</entry>
    </row>
    <row>
     <entry>sort-start</entry>
     <entry>(int, bool, int, int, bool)</entry>
     <entry>当一次排序操作开始时触发的探针。arg0 指示是堆排序、索引排序或数据排序。arg1 为真表示唯一值强制。arg2 是键列的数目。arg3 是允许使用的工作内存数（以千字节计）。如果要求随机访问排序结果，那么 arg4 为真。</entry>
    </row>
    <row>
     <entry>sort-done</entry>
     <entry>(bool, long)</entry>
     <entry>当一次排序完成时触发的探针。arg0 为真表示外排序，为假表示内排序。arg1 是用于一次外排序的磁盘块的数目，或用于一次内排序的以千字节计的内存。</entry>
    </row>
    <row>
     <entry>lwlock-acquire</entry>
     <entry>(char *, int, LWLockMode)</entry>
     <entry>当成功获得一个 LWLock 时触发的探针。
      arg0 是该 LWLock 所在的批（Tranche）。
      arg1 是该 LWLock 在其所在批中的偏移量。
      arg2 所请求的锁模式，是排他或共享。</entry>
    </row>
    <row>
     <entry>lwlock-release</entry>
     <entry>(char *, int)</entry>
     <entry>当一个 LWLock 被释放时（但是注意还没有唤醒任何一个被释放的等待者）触发的探针。
     arg0 是该 LWLock 所在的批（Tranche）。
     arg1 是该 LWLock 在其所在批中的偏移量。</entry>
    </row>
    <row>
     <entry>lwlock-wait-start</entry>
     <entry>(char *, int, LWLockMode)</entry>
     <entry>当一个 LWLock不是当即可用并且一个服务器进程因此开始等待该锁变为可用时触发的探针。
     arg0 是该 LWLock 所在的批（Tranche）。
      arg1 是该 LWLock 在其所在批中的偏移量。
      arg2 所请求的锁模式，是排他或共享。</entry>
    </row>
    <row>
     <entry>lwlock-wait-done</entry>
     <entry>(char *, int, LWLockMode)</entry>
     <entry>当一个进程从对一个 LWLock 的等待中被释放时（它实际还没有得到该锁）时触发的探针。arg0 是该 LWLock 所在的批（Tranche）。
      arg1 是该 LWLock 在其所在批中的偏移量。
      arg2 所请求的锁模式，是排他或共享。</entry>
    </row>
    <row>
     <entry>lwlock-condacquire</entry>
     <entry>(char *, int, LWLockMode)</entry>
     <entry>当调用者指定无需等待而成功获得一个 LWLock 时触发的探针。arg0 是该 LWLock 所在的批（Tranche）。
      arg1 是该 LWLock 在其所在批中的偏移量。
      arg2 所请求的锁模式，是排他或共享。</entry>
    </row>
    <row>
     <entry>lwlock-condacquire-fail</entry>
     <entry>(char *, int, LWLockMode)</entry>
     <entry>当调用者指定无需等待而没有成功获得一个 LWLock 时触发的探针。arg0 是该 LWLock 所在的批（Tranche）。
      arg1 是该 LWLock 在其所在批中的偏移量。
      arg2 所请求的锁模式，是排他或共享。</entry>
    </row>
    <row>
     <entry>lock-wait-start</entry>
     <entry>(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE)</entry>
     <entry>当一个重量级锁（lmgr锁）的请求由于锁不可用开始等待时触发的探针。arg0 到 arg3 是标识被锁定对象的标签域。arg4 指示被锁对象的类型。arg5 表示被请求的锁类型。</entry>
    </row>
    <row>
     <entry>lock-wait-done</entry>
     <entry>(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE)</entry>
     <entry>当一个重量级锁（lmgr 锁）的请求结束等待时（即已经得到锁）触发的探针。参数与 lock-wait-start 一样。</entry>
    </row>
    <row>
     <entry>deadlock-found</entry>
     <entry>()</entry>
     <entry>当死锁检测器发现死锁时触发的探针。</entry>
    </row>

   </tbody>
   </tgroup>
  </table>

 <table id="typedefs-table">
  <title>定义用在探针参数中的类型</title>
  <tgroup cols="2">
   <thead>
    <row>
     <entry>类型</entry>
     <entry>定义</entry>
    </row>
   </thead>

   <tbody>

    <row>
     <entry>LocalTransactionId</entry>
     <entry>unsigned int</entry>
    </row>
    <row>
     <entry>LWLockMode</entry>
     <entry>int</entry>
    </row>
    <row>
     <entry>LOCKMODE</entry>
     <entry>int</entry>
    </row>
    <row>
     <entry>BlockNumber</entry>
     <entry>unsigned int</entry>
    </row>
    <row>
     <entry>Oid</entry>
     <entry>unsigned int</entry>
    </row>
    <row>
     <entry>ForkNumber</entry>
     <entry>int</entry>
    </row>
    <row>
     <entry>bool</entry>
     <entry>char</entry>
    </row>

   </tbody>
   </tgroup>
  </table>


  </sect2>

  <sect2 id="using-trace-points">
   <title>使用探针</title>

  <para>
   下面的例子展示了一个分析系统中事务计数的 DTrace 脚本，可以用来代替一次性能测试之前和之后的<structname>pg_stat_database</>快照：
<programlisting>
#!/usr/sbin/dtrace -qs

postgresql$1:::transaction-start
{
      @start["Start"] = count();
      self->ts  = timestamp;
}

postgresql$1:::transaction-abort
{
      @abort["Abort"] = count();
}

postgresql$1:::transaction-commit
/self->ts/
{
      @commit["Commit"] = count();
      @time["Total time (ns)"] = sum(timestamp - self->ts);
      self->ts=0;
}
</programlisting>
   当被执行时，该例子 D 脚本给出这样的输出：
<screen>
# ./txn_count.d `pgrep -n postgres` or ./txn_count.d &lt;PID&gt;
^C

Start                                          71
Commit                                         70
Total time (ns)                        2312105013
</screen>
  </para>

  <note>
   <para>
    SystemTap 为追踪脚本使用一个不同于 DTrace 的标记，但是底层的探针是兼容的。值得注意的是，在这样写的时候，SystemTap 脚本必须使用双下划线代替连字符来引用探针名。在未来的 SystemTap 发行中这很可能会被修复。
   </para>
  </note>

  <para>
   你应该记住，DTrace 脚本需要细心地编写和调试，否则被收集的追踪信息可能会毫无意义。在大部分发现问题的情况中，它就是发生问题的部件，而不是底层系统。当讨论使用动态追踪发现的信息时，一定要封闭使用的脚本来允许这些以便被检查和讨论。
  </para>

  <para>
   更多示例脚本可以在 PgFoundry 的<ulink url="http://pgfoundry.org/projects/dtrace/">dtrace project</ulink>中找到。
  </para>
  </sect2>

  <sect2 id="defining-trace-points">
   <title>定义新探针</title>

  <para>
   开发者可以在代码中任意位置定义新的探针，当然这要重新编译之后才能生效。下面是插入新探针的步骤：
  </para>

  <procedure>
   <step>
    <para>
     决定探针名称以及探针可用的数据
    </para>
   </step>

   <step>
    <para>
     把该探针定义加入到<filename>src/backend/utils/probes.d</>
    </para>
   </step>

   <step>
    <para>
     如果<filename>pg_trace.h</>还不存在于包含该探针点的模块中，包括它，并且在源代码中期望的位置插入<literal>TRACE_POSTGRESQL</>探针宏
    </para>
   </step>

   <step>
    <para>
     重新编译并验证新探针是可用的
    </para>
   </step>
  </procedure>

  <formalpara>
   <title>例子：</title>
   <para>
    这里是一个如何增加一个探针来用事务 ID 追踪所有新事务的例子。
   </para>
  </formalpara>

  <procedure>
   <step>
    <para>
     决定探针将被命名为<literal>transaction-start</>并且需要一个 LocalTransactionId 类型的参数
    </para>
   </step>

   <step>
    <para>
     将该探针定义加入到<filename>src/backend/utils/probes.d</>：
<programlisting>
probe transaction__start(LocalTransactionId);
</programlisting>
     注意探针名字中双下划线的使用。在一个使用探针的 DTrace 脚本中，双下划线需要被替换为一个连字符，因此 ，对用户而言<literal>transaction-start</>是文档名。
    </para>
   </step>

   <step>
    <para>
     在编译时，<literal>transaction__start</>被转换成一个宏调用<literal>TRACE_POSTGRESQL_TRANSACTION_START</>（注意这里是单下划线），可以通过包括头文件<filename>pg_trace.h</>获得。将宏调用加入到源代码中的合适位置。在这种情况下，看起来类似：

<programlisting>
TRACE_POSTGRESQL_TRANSACTION_START(vxid.localTransactionId);
</programlisting>
    </para>
   </step>

   <step>
    <para>
     在重新编译和运行新的二进制文件之后，通过运行下面的 DTrace 命令来检查新增的探针是否可用。你应该看到类似下面的输出：
<screen>
# dtrace -ln transaction-start
   ID    PROVIDER          MODULE           FUNCTION NAME
18705 postgresql49878     postgres     StartTransactionCommand transaction-start
18755 postgresql49877     postgres     StartTransactionCommand transaction-start
18805 postgresql49876     postgres     StartTransactionCommand transaction-start
18855 postgresql49875     postgres     StartTransactionCommand transaction-start
18986 postgresql49873     postgres     StartTransactionCommand transaction-start
</screen>
    </para>
   </step>
  </procedure>

  <para>
   向C代码中添加追踪宏时，有一些事情需要注意：

   <itemizedlist>
    <listitem>
     <para>
      需要小心的是，为探针参数指定的数据类型要匹配宏中使用的变量的数据类型，否则会发生编译错误。
     </para>
    </listitem>


    <listitem>
     <para>
      在大多数平台上，如果用<option>--enable-dtrace</>编译了<productname>PostgreSQL</productname>，无论何时当控制经过一个追踪宏时，都会评估该宏的参数，<emphasis>即使没有进行追踪也会这样做</>。通常不需要担心你是否只在报告一些局部变量的值。但要注意将开销大的函数调用放置在这些参数中。如果你需要这样做，考虑通过检查追踪是否真的被启用来保护该宏：

<programlisting>
if (TRACE_POSTGRESQL_TRANSACTION_START_ENABLED())
    TRACE_POSTGRESQL_TRANSACTION_START(some_function(...));
</programlisting>

      每个追踪宏有一个对应的<literal>ENABLED</>宏。
     </para>
    </listitem>
   </itemizedlist>

  </para>

  </sect2>

 </sect1>

</chapter>
