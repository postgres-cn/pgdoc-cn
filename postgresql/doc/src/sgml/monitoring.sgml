<!-- doc/src/sgml/monitoring.sgml -->

<chapter id="monitoring">
<!-- pgdoc-cn_start sig_en=d6b1a7e83f5f163c04adc09d8cdd0ced sig_cn_org=None source=14.1 
 <title>Monitoring Database Activity</title>
________________________________________________________-->
 <title>监控数据库活动</title>
<!-- pgdoc-cn_end sig_en=d6b1a7e83f5f163c04adc09d8cdd0ced -->

<!-- pgdoc-cn_start sig_en=8cd0b2cb6fbbe2105fe7eecd3e6320a3 sig_cn_org=None source=14.1 
 <indexterm zone="monitoring">
  <primary>monitoring</primary>
  <secondary>database activity</secondary>
 </indexterm>
________________________________________________________-->
 <indexterm zone="monitoring">
  <primary>监控</primary>
  <secondary>数据库活动</secondary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=8cd0b2cb6fbbe2105fe7eecd3e6320a3 -->

<!-- pgdoc-cn_start sig_en=475788aa47547477919dff8dadbe6223 sig_cn_org=None source=14.1 
 <indexterm zone="monitoring">
  <primary>database activity</primary>
  <secondary>monitoring</secondary>
 </indexterm>
________________________________________________________-->
 <indexterm zone="monitoring">
  <primary>数据库活动</primary>
  <secondary>监控</secondary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=475788aa47547477919dff8dadbe6223 -->

<!-- pgdoc-cn_start sig_en=76d7b49b78c753ae65e11f9f816bf520 sig_cn_org=None source=14.1 
 <para>
  A database administrator frequently wonders, <quote>What is the system
  doing right now?</quote>
  This chapter discusses how to find that out.
 </para>
________________________________________________________-->
 <para>
  一个数据库管理员常常会疑惑，<quote>系统现在正在做什么？</quote>这一章会讨论如何搞清楚这个问题。
 </para>
<!-- pgdoc-cn_end sig_en=76d7b49b78c753ae65e11f9f816bf520 -->

<!-- pgdoc-cn_start sig_en=d270ef2a944450cdbd838e4540d65952 sig_cn_org=298135b384f5118c45e9bb26c37140da source=15.7 
  <para>
   Several tools are available for monitoring database activity and
   analyzing performance.  Most of this chapter is devoted to describing
   <productname>PostgreSQL</productname>'s cumulative statistics system,
   but one should not neglect regular Unix monitoring programs such as
   <command>ps</command>, <command>top</command>, <command>iostat</command>, and <command>vmstat</command>.
   Also, once one has identified a
   poorly-performing query, further investigation might be needed using
   <productname>PostgreSQL</productname>'s <link linkend="sql-explain"><command>EXPLAIN</command></link> command.
   <xref linkend="using-explain"/> discusses <command>EXPLAIN</command>
   and other methods for understanding the behavior of an individual
   query.
  </para>
________________________________________________________-->
  <para>
   有几种工具可用于监视数据库活动和分析性能。本章大部分内容都用于描述<productname>PostgreSQL</productname>的累积统计系统，
   但不应忽视常规的Unix监控程序，如<command>ps</command>、<command>top</command>、<command>iostat</command>和<command>vmstat</command>。
   此外，一旦确定了性能不佳的查询，可能需要进一步调查，使用<productname>PostgreSQL</productname>的<link linkend="sql-explain"><command>EXPLAIN</command></link>命令。
   <xref linkend="using-explain"/>讨论了<command>EXPLAIN</command>和其他方法，以了解单个查询的行为。
</para>
<!-- pgdoc-cn_end sig_en=d270ef2a944450cdbd838e4540d65952 -->

 <sect1 id="monitoring-ps">
<!-- pgdoc-cn_start sig_en=9c8d8b6ab3d6f09f8baeeaaa1b1484f2 sig_cn_org=None source=14.1 
  <title>Standard Unix Tools</title>
________________________________________________________-->
  <title>标准 Unix 工具</title>
<!-- pgdoc-cn_end sig_en=9c8d8b6ab3d6f09f8baeeaaa1b1484f2 -->

<!-- pgdoc-cn_start sig_en=8ba53cbd583a44c86c1b37a182ab04ad sig_cn_org=None source=14.1 
  <indexterm zone="monitoring-ps">
   <primary>ps</primary>
   <secondary>to monitor activity</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="monitoring-ps">
   <primary>ps</primary>
   <secondary>to monitor activity</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=8ba53cbd583a44c86c1b37a182ab04ad -->

<!-- pgdoc-cn_start sig_en=99627a0cc9ad1e721b532cd0a41594ff sig_cn_org=fa0481895e59c43fd49d13cc03a3a634 source=15.7 
  <para>
   On most Unix platforms, <productname>PostgreSQL</productname> modifies its
   command title as reported by <command>ps</command>, so that individual server
   processes can readily be identified.  A sample display is

<screen>
$ ps auxww | grep ^postgres
postgres  15551  0.0  0.1  57536  7132 pts/0    S    18:02   0:00 postgres -i
postgres  15554  0.0  0.0  57536  1184 ?        Ss   18:02   0:00 postgres: background writer
postgres  15555  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: checkpointer
postgres  15556  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: walwriter
postgres  15557  0.0  0.0  58504  2244 ?        Ss   18:02   0:00 postgres: autovacuum launcher
postgres  15582  0.0  0.0  58772  3080 ?        Ss   18:04   0:00 postgres: joe runbug 127.0.0.1 idle
postgres  15606  0.0  0.0  58772  3052 ?        Ss   18:07   0:00 postgres: tgl regression [local] SELECT waiting
postgres  15610  0.0  0.0  58772  3056 ?        Ss   18:07   0:00 postgres: tgl regression [local] idle in transaction
</screen>

   (The appropriate invocation of <command>ps</command> varies across different
   platforms, as do the details of what is shown.  This example is from a
   recent Linux system.)  The first process listed here is the
   primary server process.  The command arguments
   shown for it are the same ones used when it was launched.  The next four
   processes are background worker processes automatically launched by the
   primary process.  (The <quote>autovacuum launcher</quote> process will not
   be present if you have set the system not to run autovacuum.)
   Each of the remaining
   processes is a server process handling one client connection.  Each such
   process sets its command line display in the form

<screen>
postgres: <replaceable>user</replaceable> <replaceable>database</replaceable> <replaceable>host</replaceable> <replaceable>activity</replaceable>
</screen>

  The user, database, and (client) host items remain the same for
  the life of the client connection, but the activity indicator changes.
  The activity can be <literal>idle</literal> (i.e., waiting for a client command),
  <literal>idle in transaction</literal> (waiting for client inside a <command>BEGIN</command> block),
  or a command type name such as <literal>SELECT</literal>.  Also,
  <literal>waiting</literal> is appended if the server process is presently waiting
  on a lock held by another session.  In the above example we can infer
  that process 15606 is waiting for process 15610 to complete its transaction
  and thereby release some lock.  (Process 15610 must be the blocker, because
  there is no other active session.  In more complicated cases it would be
  necessary to look into the
  <link linkend="view-pg-locks"><structname>pg_locks</structname></link>
  system view to determine who is blocking whom.)
  </para>
________________________________________________________-->
  <para>
   在大多数Unix平台上，<productname>PostgreSQL</productname>修改了<command>ps</command>报告的命令标题，以便可以轻松识别各个服务器进程。一个示例显示如下：

<screen>
$ ps auxww | grep ^postgres
postgres  15551  0.0  0.1  57536  7132 pts/0    S    18:02   0:00 postgres -i
postgres  15554  0.0  0.0  57536  1184 ?        Ss   18:02   0:00 postgres: background writer
postgres  15555  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: checkpointer
postgres  15556  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: walwriter
postgres  15557  0.0  0.0  58504  2244 ?        Ss   18:02   0:00 postgres: autovacuum launcher
postgres  15582  0.0  0.0  58772  3080 ?        Ss   18:04   0:00 postgres: joe runbug 127.0.0.1 idle
postgres  15606  0.0  0.0  58772  3052 ?        Ss   18:07   0:00 postgres: tgl regression [local] SELECT waiting
postgres  15610  0.0  0.0  58772  3056 ?        Ss   18:07   0:00 postgres: tgl regression [local] idle in transaction
</screen>

   （<command>ps</command>的适当调用在不同平台上有所不同，显示的细节也不同。此示例来自最近的Linux系统。）这里列出的第一个进程是主服务器进程。显示的命令参数与启动时使用的相同。接下来的四个进程是主进程自动启动的后台工作进程。（如果您设置系统不运行自动清理，则<quote>autovacuum launcher</quote>进程将不存在。）其余的每个进程都是处理一个客户端连接的服务器进程。每个这样的进程将其命令行显示为

<screen>
postgres: <replaceable>user</replaceable> <replaceable>database</replaceable> <replaceable>host</replaceable> <replaceable>activity</replaceable>
</screen>

  用户、数据库和（客户端）主机项目在客户端连接的生命周期内保持不变，但活动指示器会更改。活动可以是<literal>idle</literal>（即等待客户端命令）、<literal>idle in transaction</literal>（在<command>BEGIN</command>块内等待客户端）、或命令类型名称，如<literal>SELECT</literal>。此外，如果服务器进程当前正在等待另一个会话持有的锁，则会附加<literal>waiting</literal>。在上面的示例中，我们可以推断进程15606正在等待进程15610完成其事务，从而释放一些锁。（进程15610必须是阻塞进程，因为没有其他活动会话。
  在更复杂的情况下，需要查看<link linkend="view-pg-locks"><structname>pg_locks</structname></link>系统视图，以确定谁在阻塞谁。）
  </para>
<!-- pgdoc-cn_end sig_en=99627a0cc9ad1e721b532cd0a41594ff -->

<!-- pgdoc-cn_start sig_en=4ca6a5e684819974d1e35f455c7d2a0a sig_cn_org=None source=14.1 
  <para>
   If <xref linkend="guc-cluster-name"/> has been configured the
   cluster name will also be shown in <command>ps</command> output:
<screen>
$ psql -c 'SHOW cluster_name'
 cluster_name
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 server1
(1 row)

$ ps aux|grep server1
postgres   27093  0.0  0.0  30096  2752 ?        Ss   11:34   0:00 postgres: server1: background writer
...
</screen>
  </para>
________________________________________________________-->
  <para>
   如果配置了<xref linkend="guc-cluster-name"/>，则集簇的名字
   也将会显示在<command>ps</command>的输出中：
<screen>
$ psql -c 'SHOW cluster_name'
 cluster_name
--------------
 server1
(1 row)

$ ps aux|grep server1
postgres   27093  0.0  0.0  30096  2752 ?        Ss   11:34   0:00 postgres: server1: background writer
...
</screen>
  </para>
<!-- pgdoc-cn_end sig_en=4ca6a5e684819974d1e35f455c7d2a0a -->

<!-- pgdoc-cn_start sig_en=5e97327c0cf6e5d8433f0f3835859fde sig_cn_org=None source=14.1 
  <para>
   If you have turned off <xref linkend="guc-update-process-title"/> then the
   activity indicator is not updated; the process title is set only once
   when a new process is launched.  On some platforms this saves a measurable
   amount of per-command overhead;  on others it's insignificant.
  </para>
________________________________________________________-->
  <para>
   如果你已经关闭了<xref linkend="guc-update-process-title"/>，那么活动指示器将不会被更新，进程标题仅在新进程被启动的时候设置一次。 在某些平台上这样做可以为每个命令节省可观的开销，但在其它平台上却不明显。
  </para>
<!-- pgdoc-cn_end sig_en=5e97327c0cf6e5d8433f0f3835859fde -->

  <tip>
<!-- pgdoc-cn_start sig_en=018844e874565dc13e826a68399198a1 sig_cn_org=None source=14.1 
  <para>
  <productname>Solaris</productname> requires special handling. You must
  use <command>/usr/ucb/ps</command>, rather than
  <command>/bin/ps</command>. You also must use two <option>w</option>
  flags, not just one. In addition, your original invocation of the
  <command>postgres</command> command must have a shorter
  <command>ps</command> status display than that provided by each
  server process.  If you fail to do all three things, the <command>ps</command>
  output for each server process will be the original <command>postgres</command>
  command line.
  </para>
________________________________________________________-->
  <para>
  <productname>Solaris</productname>需要特别的处理。你必需使用<command>/usr/ucb/ps</command>而不是<command>/bin/ps</command>。 你还必需使用两个<option>w</option>标志，而不是一个。另外，你对<command>postgres</command>命令的最初调用必须用一个比服务器进程提供的短的<command>ps</command>状态显示。如果你没有满足全部三个要求，每个服务器进程的<command>ps</command>输出将是原始的<command>postgres</command>命令行。
  command line.
  </para>
<!-- pgdoc-cn_end sig_en=018844e874565dc13e826a68399198a1 -->
  </tip>
 </sect1>

 <sect1 id="monitoring-stats">
<!-- pgdoc-cn_start sig_en=fe50f869df6f71ddaffef73e3baf8770 sig_cn_org=41f59b5d7fa7d3abfaa26f00365505f9 source=15.7 
  <title>The Cumulative Statistics System</title>
________________________________________________________-->
  <title>累计统计系统</title>
<!-- pgdoc-cn_end sig_en=fe50f869df6f71ddaffef73e3baf8770 -->

<!-- pgdoc-cn_start sig_en=c096d47484849c114ab2927b2ada86f6 sig_cn_org=None source=14.1 
  <indexterm zone="monitoring-stats">
   <primary>statistics</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="monitoring-stats">
   <primary>statistics</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=c096d47484849c114ab2927b2ada86f6 -->

<!-- pgdoc-cn_start sig_en=789a3581c9dc577b6bf5062509ae6975 sig_cn_org=fcb3949ccce0df3b1149b1cb7eeab37c source=15.7 
  <para>
   <productname>PostgreSQL</productname>'s <firstterm>cumulative statistics
   system</firstterm> supports collection and reporting of information about
   server activity.  Presently, accesses to tables and indexes in both
   disk-block and individual-row terms are counted.  The total number of rows
   in each table, and information about vacuum and analyze actions for each
   table are also counted.  If enabled, calls to user-defined functions and
   the total time spent in each one are counted as well.
  </para>
________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>的<firstterm>累积统计系统</firstterm>支持收集和报告有关服务器活动的信息。
   目前，对表和索引的访问以磁盘块和单个行的术语进行计数。每个表中的总行数，
   以及每个表的清理和分析操作的信息也被计数。如果启用，对用户定义函数的调用
   和每个函数中花费的总时间也会被计数。
</para>
<!-- pgdoc-cn_end sig_en=789a3581c9dc577b6bf5062509ae6975 -->

<!-- pgdoc-cn_start sig_en=5ac35f1afae8c60b52fb465fc3575cdc sig_cn_org=8a3dc39d820f208ad8871805f4fd666a source=15.7 
  <para>
   <productname>PostgreSQL</productname> also supports reporting dynamic
   information about exactly what is going on in the system right now, such as
   the exact command currently being executed by other server processes, and
   which other connections exist in the system.  This facility is independent
   of the cumulative statistics system.
  </para>
________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>也支持报告关于系统当前正在发生的情况的动态信息，
   例如其他服务器进程当前正在执行的确切命令，以及系统中存在哪些其他连接。此功能独立于累积统计系统。
</para>
<!-- pgdoc-cn_end sig_en=5ac35f1afae8c60b52fb465fc3575cdc -->

 <sect2 id="monitoring-stats-setup">
<!-- pgdoc-cn_start sig_en=bb1cfd84aab38cf70709b209fc310c79 sig_cn_org=None source=14.1 
  <title>Statistics Collection Configuration</title>
________________________________________________________-->
  <title>统计收集配置</title>
<!-- pgdoc-cn_end sig_en=bb1cfd84aab38cf70709b209fc310c79 -->

<!-- pgdoc-cn_start sig_en=2bbc7c3517e0972a115d062cd1868293 sig_cn_org=None source=14.1 
  <para>
   Since collection of statistics adds some overhead to query execution,
   the system can be configured to collect or not collect information.
   This is controlled by configuration parameters that are normally set in
   <filename>postgresql.conf</filename>.  (See <xref linkend="runtime-config"/> for
   details about setting configuration parameters.)
  </para>
________________________________________________________-->
  <para>
   因为统计收集给查询执行增加了一些负荷，系统可以被配置为收集或不收集信息。这由配置参数控制，它们通常在<filename>postgresql.conf</filename>中设置（关于设置配置参数的细节请见<xref linkend="runtime-config"/>）。
  </para>
<!-- pgdoc-cn_end sig_en=2bbc7c3517e0972a115d062cd1868293 -->

<!-- pgdoc-cn_start sig_en=30f85208ee8d17540c7922d108737a50 sig_cn_org=None source=14.1 
  <para>
   The parameter <xref linkend="guc-track-activities"/> enables monitoring
   of the current command being executed by any server process.
  </para>
________________________________________________________-->
  <para>
   参数<xref linkend="guc-track-activities"/>允许监控当前被任意服务器进程执行的命令。
  </para>
<!-- pgdoc-cn_end sig_en=30f85208ee8d17540c7922d108737a50 -->

<!-- pgdoc-cn_start sig_en=c873f18fa449c982341b2548a95d9559 sig_cn_org=67d0308061e3ee19ee329ccf0dbb3842 source=15.7 
  <para>
   The parameter <xref linkend="guc-track-counts"/> controls whether
   cumulative statistics are collected about table and index accesses.
  </para>
________________________________________________________-->
  <para>
   参数<xref linkend="guc-track-counts"/>控制是否收集关于表和索引访问的累积统计信息。
</para>
<!-- pgdoc-cn_end sig_en=c873f18fa449c982341b2548a95d9559 -->

<!-- pgdoc-cn_start sig_en=4a36fabd9fbd017de14e5e2e6fda0c9e sig_cn_org=None source=14.1 
  <para>
   The parameter <xref linkend="guc-track-functions"/> enables tracking of
   usage of user-defined functions.
  </para>
________________________________________________________-->
  <para>
   参数<xref linkend="guc-track-functions"/>启用对用户定义函数使用的跟踪。
  </para>
<!-- pgdoc-cn_end sig_en=4a36fabd9fbd017de14e5e2e6fda0c9e -->

<!-- pgdoc-cn_start sig_en=b6c65f1ed1ac371168014b67ae9e0f3c sig_cn_org=None source=14.1 
  <para>
   The parameter <xref linkend="guc-track-io-timing"/> enables monitoring
   of block read and write times.
  </para>
________________________________________________________-->
  <para>
   参数<xref linkend="guc-track-io-timing"/>启用对块读写次数的监控。
  </para>
<!-- pgdoc-cn_end sig_en=b6c65f1ed1ac371168014b67ae9e0f3c -->

<!-- pgdoc-cn_start sig_en=876c600f11989d6c62e991a96c8aeaf3 sig_cn_org=None source=14.1 
  <para>
   The parameter <xref linkend="guc-track-wal-io-timing"/> enables monitoring
   of WAL write times.
  </para>
________________________________________________________-->
  <para>
   参数 <xref linkend="guc-track-wal-io-timing"/> 启用WAL写时间的监控。
  </para>
<!-- pgdoc-cn_end sig_en=876c600f11989d6c62e991a96c8aeaf3 -->

<!-- pgdoc-cn_start sig_en=700902d21113bb33fa992d5c85a9ecf0 sig_cn_org=None source=14.1 
  <para>
   Normally these parameters are set in <filename>postgresql.conf</filename> so
   that they apply to all server processes, but it is possible to turn
   them on or off in individual sessions using the <xref
   linkend="sql-set"/> command. (To prevent
   ordinary users from hiding their activity from the administrator,
   only superusers are allowed to change these parameters with
   <command>SET</command>.)
  </para>
________________________________________________________-->
  <para>
   通常这些参数被设置在<filename>postgresql.conf</filename>中，这样它们会应用于所有服务器进程，但是可以在单个会话中使用<xref linkend="sql-set"/>命令打开或关闭它们（为了阻止普通用户对管理员隐藏他们的活动，只有超级用户被允许使用<command>SET</command>来改变这些参数）。
  </para>
<!-- pgdoc-cn_end sig_en=700902d21113bb33fa992d5c85a9ecf0 -->

<!-- pgdoc-cn_start sig_en=1b30ddf3a8a27c7d9b2437649443dfb5 sig_cn_org=5d252b5042489ab1dbe9e39f8ac68900 source=15.7 
  <para>
   Cumulative statistics are collected in shared memory. Every
   <productname>PostgreSQL</productname> process collects statistics locally,
   then updates the shared data at appropriate intervals.  When a server,
   including a physical replica, shuts down cleanly, a permanent copy of the
   statistics data is stored in the <filename>pg_stat</filename> subdirectory,
   so that statistics can be retained across server restarts.  In contrast,
   when starting from an unclean shutdown (e.g., after an immediate shutdown,
   a server crash, starting from a base backup, and point-in-time recovery),
   all statistics counters are reset.
  </para>
________________________________________________________-->
  <para>
   累积统计数据存储在共享内存中。每个<productname>PostgreSQL</productname>进程在本地收集统计数据，
   然后在适当的间隔更新共享数据。当服务器，包括物理副本，正常关闭时，统计数据的永久副本存储在
   <filename>pg_stat</filename>子目录中，以便统计数据可以在服务器重新启动时保留。相反，当从不干净的
   关闭开始（例如，立即关闭后，服务器崩溃，从基本备份开始和时间点恢复），所有统计计数器都会被重置。
</para>
<!-- pgdoc-cn_end sig_en=1b30ddf3a8a27c7d9b2437649443dfb5 -->

 </sect2>

 <sect2 id="monitoring-stats-views">
<!-- pgdoc-cn_start sig_en=68d6fd19395aec3ba1255be9773ef3d4 sig_cn_org=None source=14.1 
  <title>Viewing Statistics</title>
________________________________________________________-->
  <title>查看统计信息</title>
<!-- pgdoc-cn_end sig_en=68d6fd19395aec3ba1255be9773ef3d4 -->

<!-- pgdoc-cn_start sig_en=31a1e72867cec2d4d58f5ce96492a974 sig_cn_org=5e195f8647e7dde865d0bca44886572e source=15.7 
  <para>
   Several predefined views, listed in <xref
   linkend="monitoring-stats-dynamic-views-table"/>, are available to show
   the current state of the system. There are also several other
   views, listed in <xref
   linkend="monitoring-stats-views-table"/>, available to show the accumulated
   statistics.  Alternatively, one can
   build custom views using the underlying cumulative statistics functions, as
   discussed in <xref linkend="monitoring-stats-functions"/>.
  </para>
________________________________________________________-->
  <para>
   有几个预定义的视图，列在<xref linkend="monitoring-stats-dynamic-views-table"/>中，
   可用于显示系统的当前状态。还有几个其他视图，列在<xref
   linkend="monitoring-stats-views-table"/>中，可用于显示累积统计信息。
   或者，可以使用底层的累积统计函数构建自定义视图，如在<xref
   linkend="monitoring-stats-functions"/>中讨论的那样。
</para>
<!-- pgdoc-cn_end sig_en=31a1e72867cec2d4d58f5ce96492a974 -->

<!-- pgdoc-cn_start sig_en=799d8149b8d44a937e559bc0f4f37af0 sig_cn_org=fba9a71627595e65d1f762972e0b3bed source=15.7 
  <para>
   When using the cumulative statistics views and functions to monitor
   collected data, it is important to realize that the information does not
   update instantaneously.  Each individual server process flushes out
   accumulated statistics to shared memory just before going idle, but not
   more frequently than once per <varname>PGSTAT_MIN_INTERVAL</varname>
   milliseconds (1 second unless altered while building the server); so a
   query or transaction still in progress does not affect the displayed totals
   and the displayed information lags behind actual activity.  However,
   current-query information collected by <varname>track_activities</varname>
   is always up-to-date.
  </para>
________________________________________________________-->
  <para>
   当使用累积统计视图和函数来监视收集的数据时，重要的是要意识到信息不会立即更新。每个单独的服务器进程在空闲之前将累积的统计信息刷新到共享内存中，但不会频繁于每<varname>PGSTAT_MIN_INTERVAL</varname>毫秒（1秒，除非在构建服务器时更改）一次；因此，仍在进行中的查询或事务不会影响显示的总计，显示的信息滞后于实际活动。然而，由<varname>track_activities</varname>收集的当前查询信息始终是最新的。
  </para>
<!-- pgdoc-cn_end sig_en=799d8149b8d44a937e559bc0f4f37af0 -->

<!-- pgdoc-cn_start sig_en=fa6727fccdd18c1f631fb0083bf58eb4 sig_cn_org=c295d1227b93691071021fe89aa28250 source=15.7 
  <para>
   Another important point is that when a server process is asked to display
   any of the accumulated statistics, accessed values are cached until the end
   of its current transaction in the default configuration. So the statistics
   will show static information as long as you continue the current
   transaction. Similarly, information about the current queries of all
   sessions is collected when any such information is first requested within a
   transaction, and the same information will be displayed throughout the
   transaction. This is a feature, not a bug, because it allows you to perform
   several queries on the statistics and correlate the results without
   worrying that the numbers are changing underneath you.

   When analyzing statistics interactively, or with expensive queries, the
   time delta between accesses to individual statistics can lead to
   significant skew in the cached statistics. To minimize skew,
   <varname>stats_fetch_consistency</varname> can be set to
   <literal>snapshot</literal>, at the price of increased memory usage for
   caching not-needed statistics data.  Conversely, if it's known that
   statistics are only accessed once, caching accessed statistics is
   unnecessary and can be avoided by setting
   <varname>stats_fetch_consistency</varname> to <literal>none</literal>.

   You can invoke <function>pg_stat_clear_snapshot</function>() to discard the
   current transaction's statistics snapshot or cached values (if any).  The
   next use of statistical information will (when in snapshot mode) cause a
   new snapshot to be built or (when in cache mode) accessed statistics to be
   cached.
  </para>
________________________________________________________-->
  <para>
   另一个重要的观点是，当服务器进程被要求显示任何累积的统计信息时，在默认配置中，访问的值会被缓存直到当前事务结束。因此，只要您继续当前事务，统计信息将显示静态信息。类似地，当在事务中首次请求任何当前会话的查询信息时，会收集关于所有会话当前查询的信息，并且相同的信息将在整个事务中显示。这是一个特性，而不是一个错误，因为它允许您在统计信息上执行多个查询并将结果相关联，而不必担心数字在您眼前发生变化。

   在交互式分析统计信息或使用昂贵的查询时，访问各个统计信息之间的时间差可能导致缓存统计信息中出现显著的偏差。为了最小化偏差，可以将<varname>stats_fetch_consistency</varname>设置为<literal>snapshot</literal>，但这会增加用于缓存不需要的统计数据的内存使用量。相反，如果已知统计信息只被访问一次，那么缓存访问的统计信息是不必要的，可以通过将<varname>stats_fetch_consistency</varname>设置为<literal>none</literal>来避免。

   您可以调用<function>pg_stat_clear_snapshot</function>()来丢弃当前事务的统计快照或缓存的值（如果有）。下一次使用统计信息时（在快照模式下），将会创建一个新的快照，或者（在缓存模式下）将访问的统计信息缓存起来。
</para>
<!-- pgdoc-cn_end sig_en=fa6727fccdd18c1f631fb0083bf58eb4 -->

<!-- pgdoc-cn_start sig_en=52eaca964eeca9e32ff91eda99c21f09 sig_cn_org=36768ca20216b9fdd16a29e466498d82 source=15.7 
  <para>
   A transaction can also see its own statistics (not yet flushed out to the
   shared memory statistics) in the views
   <structname>pg_stat_xact_all_tables</structname>,
   <structname>pg_stat_xact_sys_tables</structname>,
   <structname>pg_stat_xact_user_tables</structname>, and
   <structname>pg_stat_xact_user_functions</structname>.  These numbers do not act as
   stated above; instead they update continuously throughout the transaction.
  </para>
________________________________________________________-->
  <para>
   事务还可以在视图<structname>pg_stat_xact_all_tables</structname>、
   <structname>pg_stat_xact_sys_tables</structname>、
   <structname>pg_stat_xact_user_tables</structname>和
   <structname>pg_stat_xact_user_functions</structname>中看到自己的统计信息
   （尚未刷新到共享内存统计信息）。这些数字不像上面所述那样起作用；
   相反，它们在事务期间持续更新。
</para>
<!-- pgdoc-cn_end sig_en=52eaca964eeca9e32ff91eda99c21f09 -->

<!-- pgdoc-cn_start sig_en=a4814f148d789ba369c31868eda87c21 sig_cn_org=484442c9f39cbc4cceed3a832a858fff source=15.7 
  <para>
   Some of the information in the dynamic statistics views shown in <xref
   linkend="monitoring-stats-dynamic-views-table"/> is security restricted.
   Ordinary users can only see all the information about their own sessions
   (sessions belonging to a role that they are a member of).  In rows about
   other sessions, many columns will be null.  Note, however, that the
   existence of a session and its general properties such as its sessions user
   and database are visible to all users.  Superusers and roles with privileges of
   built-in role <literal>pg_read_all_stats</literal> (see also <xref
   linkend="predefined-roles"/>) can see all the information about all sessions.
  </para>
________________________________________________________-->
  <para>
   动态统计视图中显示的一些信息在<xref linkend="monitoring-stats-dynamic-views-table"/>中受到安全限制。
   普通用户只能查看关于他们自己会话的所有信息（属于他们是成员的角色的会话）。在关于其他会话的行中，许多列将为空。
   但是，请注意，所有用户都可以看到会话的存在以及其一般属性，如会话用户和数据库。超级用户和具有内置角色<literal>pg_read_all_stats</literal>特权的角色（另请参阅<xref linkend="predefined-roles"/>)可以查看所有会话的所有信息。
  </para>
<!-- pgdoc-cn_end sig_en=a4814f148d789ba369c31868eda87c21 -->

  <table id="monitoring-stats-dynamic-views-table">
<!-- pgdoc-cn_start sig_en=de5ec6e85f7cc0fd9e92026ea5492dc1 sig_cn_org=None source=14.1 
   <title>Dynamic Statistics Views</title>
________________________________________________________-->
   <title>动态统计视图</title>
<!-- pgdoc-cn_end sig_en=de5ec6e85f7cc0fd9e92026ea5492dc1 -->

   <tgroup cols="2">
    <thead>
<!-- pgdoc-cn_start sig_en=e33ffaa0c3268f850a02d3b4c80b127e sig_cn_org=None source=14.1 
     <row>
      <entry>View Name</entry>
      <entry>Description</entry>
     </row>
________________________________________________________-->
     <row>
      <entry>视图名称</entry>
      <entry>描述</entry>
     </row>
<!-- pgdoc-cn_end sig_en=e33ffaa0c3268f850a02d3b4c80b127e -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=6d447dc640a36955f714b61a8bb99580 sig_cn_org=None source=14.1 
     <row>
      <entry>
       <structname>pg_stat_activity</structname>
       <indexterm><primary>pg_stat_activity</primary></indexterm>
      </entry>
      <entry>
       One row per server process, showing information related to
       the current activity of that process, such as state and current query.
       See <link linkend="monitoring-pg-stat-activity-view">
       <structname>pg_stat_activity</structname></link> for details.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry>
       <structname>pg_stat_activity</structname>
       <indexterm><primary>pg_stat_activity</primary></indexterm>
      </entry>
      <entry>
       每个服务器进程一行，显示与那个进程的当前活动相关的信息，例如状态和当前查询。详见<link linkend="monitoring-pg-stat-activity-view"><structname>pg_stat_activity</structname></link> 。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=6d447dc640a36955f714b61a8bb99580 -->

<!-- pgdoc-cn_start sig_en=b8d630e71d0d8cdfd06d72a5d6ab3e31 sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_stat_replication</structname><indexterm><primary>pg_stat_replication</primary></indexterm></entry>
      <entry>One row per WAL sender process, showing statistics about
       replication to that sender's connected standby server.
       See <link linkend="monitoring-pg-stat-replication-view">
       <structname>pg_stat_replication</structname></link> for details.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_stat_replication</structname><indexterm><primary>pg_stat_replication</primary></indexterm></entry>
      <entry>每一个 WAL 发送进程一行，显示有关到该发送进程连接的后备服务器的复制的统计信息。
       详见<link linkend="monitoring-pg-stat-replication-view"><structname>pg_stat_replication</structname></link>.
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=b8d630e71d0d8cdfd06d72a5d6ab3e31 -->

<!-- pgdoc-cn_start sig_en=a3e824f66551af9211aeab7bff4c111f sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_stat_wal_receiver</structname><indexterm><primary>pg_stat_wal_receiver</primary></indexterm></entry>
      <entry>Only one row, showing statistics about the WAL receiver from
       that receiver's connected server.
       See <link linkend="monitoring-pg-stat-wal-receiver-view">
       <structname>pg_stat_wal_receiver</structname></link> for details.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_stat_wal_receiver</structname><indexterm><primary>pg_stat_wal_receiver</primary></indexterm></entry>
      <entry>只有一行，显示来自 WAL 接收器所连接服务器的有关该接收器的统计信息。详见<link linkend="monitoring-pg-stat-wal-receiver-view">
       <structname>pg_stat_wal_receiver</structname></link>。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=a3e824f66551af9211aeab7bff4c111f -->

<!-- pgdoc-cn_start sig_en=f1dcabd466f10ca2103474c83ca39b18 sig_cn_org=205a584ebba4add36e22f28a79f7a070 source=15.7 
     <row>
      <entry><structname>pg_stat_recovery_prefetch</structname><indexterm><primary>pg_stat_recovery_prefetch</primary></indexterm></entry>
      <entry>Only one row, showing statistics about blocks prefetched during recovery.
       See <link linkend="monitoring-pg-stat-recovery-prefetch">
       <structname>pg_stat_recovery_prefetch</structname></link> for details.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_stat_recovery_prefetch</structname><indexterm><primary>pg_stat_recovery_prefetch</primary></indexterm></entry>
      <entry>只有一行，显示了恢复过程中预取的块的统计信息。
       详细信息请参见<link linkend="monitoring-pg-stat-recovery-prefetch">
       <structname>pg_stat_recovery_prefetch</structname></link>。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=f1dcabd466f10ca2103474c83ca39b18 -->

<!-- pgdoc-cn_start sig_en=b38414bcbd39ed86a45175f36f5bfd01 sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_stat_subscription</structname><indexterm><primary>pg_stat_subscription</primary></indexterm></entry>
      <entry>At least one row per subscription, showing information about
       the subscription workers.
       See <link linkend="monitoring-pg-stat-subscription">
       <structname>pg_stat_subscription</structname></link> for details.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_stat_subscription</structname><indexterm><primary>pg_stat_subscription</primary></indexterm></entry>
      <entry>每个订阅至少一行，显示有关该订阅的工作者的信息。详见<link linkend="monitoring-pg-stat-subscription">
       <structname>pg_stat_subscription</structname></link>。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=b38414bcbd39ed86a45175f36f5bfd01 -->

<!-- pgdoc-cn_start sig_en=3dd7664dc5b22b665f8d106e47c14ceb sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_stat_ssl</structname><indexterm><primary>pg_stat_ssl</primary></indexterm></entry>
      <entry>One row per connection (regular and replication), showing information about
       SSL used on this connection.
       See <link linkend="monitoring-pg-stat-ssl-view">
       <structname>pg_stat_ssl</structname></link> for details.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_stat_ssl</structname><indexterm><primary>pg_stat_ssl</primary></indexterm></entry>
      <entry>每个连接（常规的或者复制）一行，显示在这个连接上使用的SSL的信息。详见<link linkend="monitoring-pg-stat-ssl-view">
       <structname>pg_stat_ssl</structname></link>。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=3dd7664dc5b22b665f8d106e47c14ceb -->

<!-- pgdoc-cn_start sig_en=141ab3ad323536fa12090fcba9b5d841 sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_stat_gssapi</structname><indexterm><primary>pg_stat_gssapi</primary></indexterm></entry>
      <entry>One row per connection (regular and replication), showing information about
       GSSAPI authentication and encryption used on this connection.
       See <link linkend="monitoring-pg-stat-gssapi-view">
       <structname>pg_stat_gssapi</structname></link> for details.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_stat_gssapi</structname><indexterm><primary>pg_stat_gssapi</primary></indexterm></entry>
      <entry>每个连接（常规和复制）有一行，显示关于GSSAPI验证和加密的信息。详情请参阅 <link linkend="monitoring-pg-stat-gssapi-view">
       <structname>pg_stat_gssapi</structname></link>。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=141ab3ad323536fa12090fcba9b5d841 -->

<!-- pgdoc-cn_start sig_en=9400abedff51a6a128f313b3711db7c8 sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_stat_progress_analyze</structname><indexterm><primary>pg_stat_progress_analyze</primary></indexterm></entry>
      <entry>One row for each backend (including autovacuum worker processes) running
       <command>ANALYZE</command>, showing current progress.
       See <xref linkend='analyze-progress-reporting'/>.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_stat_progress_analyze</structname><indexterm><primary>pg_stat_progress_analyze</primary></indexterm></entry>
      <entry>每个运行<command>ANALYZE</command>的后端(包括自动清理工作者进程)的行，显示当前进度。参见<xref linkend='analyze-progress-reporting'/>。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=9400abedff51a6a128f313b3711db7c8 -->

<!-- pgdoc-cn_start sig_en=c2ccd7c0a790fd8562caf7c803cbacdd sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_stat_progress_create_index</structname><indexterm><primary>pg_stat_progress_create_index</primary></indexterm></entry>
      <entry>One row for each backend running <command>CREATE INDEX</command> or <command>REINDEX</command>, showing
      current progress.
      See <xref linkend='create-index-progress-reporting'/>.
     </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_stat_progress_create_index</structname><indexterm><primary>pg_stat_progress_create_index</primary></indexterm></entry>
      <entry>每个后台运行<command>CREATE INDEX</command>或<command>REINDEX</command>的后端都有一行，显示当前的进度。参见<xref linkend='create-index-progress-reporting'/>。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=c2ccd7c0a790fd8562caf7c803cbacdd -->

<!-- pgdoc-cn_start sig_en=068817d5d718bab6877cd6d4d1566467 sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_stat_progress_vacuum</structname><indexterm><primary>pg_stat_progress_vacuum</primary></indexterm></entry>
      <entry>One row for each backend (including autovacuum worker processes) running
       <command>VACUUM</command>, showing current progress.
       See <xref linkend='vacuum-progress-reporting'/>.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_stat_progress_vacuum</structname><indexterm><primary>pg_stat_progress_vacuum</primary></indexterm></entry>
      <entry>每个运行着<command>VACUUM</command>的后端（包括autovacuum工作者进程）一行，显示当前的进度。详见<xref linkend='vacuum-progress-reporting'/>。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=068817d5d718bab6877cd6d4d1566467 -->

<!-- pgdoc-cn_start sig_en=f990d8903c9468670cb42363a52b9c09 sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_stat_progress_cluster</structname><indexterm><primary>pg_stat_progress_cluster</primary></indexterm></entry>
      <entry>One row for each backend running
       <command>CLUSTER</command> or <command>VACUUM FULL</command>, showing current progress.
       See <xref linkend='cluster-progress-reporting'/>.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_stat_progress_cluster</structname><indexterm><primary>pg_stat_progress_cluster</primary></indexterm></entry>
      <entry>每个运行着<command>CLUSTER</command>或<command>VACUUM FULL</command>的后端一行，显示当前进度。参见 <xref linkend='cluster-progress-reporting'/>。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=f990d8903c9468670cb42363a52b9c09 -->

<!-- pgdoc-cn_start sig_en=00afff4d33c96baa3c2ec805a10e5b8a sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_stat_progress_basebackup</structname><indexterm><primary>pg_stat_progress_basebackup</primary></indexterm></entry>
      <entry>One row for each WAL sender process streaming a base backup,
       showing current progress.
       See <xref linkend='basebackup-progress-reporting'/>.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_stat_progress_basebackup</structname><indexterm><primary>pg_stat_progress_basebackup</primary></indexterm></entry>
      <entry>每一个WAL发送者进程的行显示一个基础备份，显示当前进度。参见<xref linkend='basebackup-progress-reporting'/>。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=00afff4d33c96baa3c2ec805a10e5b8a -->

<!-- pgdoc-cn_start sig_en=cbe10dec67cf3e2f7e21f35c51747620 sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_stat_progress_copy</structname><indexterm><primary>pg_stat_progress_copy</primary></indexterm></entry>
      <entry>One row for each backend running <command>COPY</command>, showing current progress.
       See <xref linkend='copy-progress-reporting'/>.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_stat_progress_copy</structname><indexterm><primary>pg_stat_progress_copy</primary></indexterm></entry>
      <entry>对每个后端运行<command>COPY</command>的行, 显示当前进度。
       参见 <xref linkend='copy-progress-reporting'/>。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=cbe10dec67cf3e2f7e21f35c51747620 -->
    </tbody>
   </tgroup>
  </table>

  <table id="monitoring-stats-views-table">
<!-- pgdoc-cn_start sig_en=4aaf7f642d5d1b9d209d58e7f95a7b0a sig_cn_org=None source=14.1 
   <title>Collected Statistics Views</title>
________________________________________________________-->
   <title>已收集统计信息的视图</title>
<!-- pgdoc-cn_end sig_en=4aaf7f642d5d1b9d209d58e7f95a7b0a -->

   <tgroup cols="2">
    <thead>
<!-- pgdoc-cn_start sig_en=e33ffaa0c3268f850a02d3b4c80b127e sig_cn_org=None source=14.1 
     <row>
      <entry>View Name</entry>
      <entry>Description</entry>
     </row>
________________________________________________________-->
     <row>
      <entry>视图名称</entry>
      <entry>描述</entry>
     </row>
<!-- pgdoc-cn_end sig_en=e33ffaa0c3268f850a02d3b4c80b127e -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=02a95b6800ca412fe45ebdf340cb1fb7 sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_stat_archiver</structname><indexterm><primary>pg_stat_archiver</primary></indexterm></entry>
      <entry>One row only, showing statistics about the
       WAL archiver process's activity. See
       <link linkend="monitoring-pg-stat-archiver-view">
       <structname>pg_stat_archiver</structname></link> for details.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_stat_archiver</structname><indexterm><primary>pg_stat_archiver</primary></indexterm></entry>
      <entry>只有一行，显示有关 WAL 归档进程活动的统计信息。详见<link linkend="monitoring-pg-stat-archiver-view">
       <structname>pg_stat_archiver</structname></link>。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=02a95b6800ca412fe45ebdf340cb1fb7 -->

<!-- pgdoc-cn_start sig_en=f6267c33876cad88c6df4afee80567a1 sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_stat_bgwriter</structname><indexterm><primary>pg_stat_bgwriter</primary></indexterm></entry>
      <entry>One row only, showing statistics about the
       background writer process's activity. See
       <link linkend="monitoring-pg-stat-bgwriter-view">
       <structname>pg_stat_bgwriter</structname></link> for details.
     </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_stat_bgwriter</structname><indexterm><primary>pg_stat_bgwriter</primary></indexterm></entry>
      <entry>只有一行，显示有关后台写进程的活动的统计信息。详见<link linkend="monitoring-pg-stat-bgwriter-view">
       <structname>pg_stat_bgwriter</structname></link>。
     </entry>
     </row>
<!-- pgdoc-cn_end sig_en=f6267c33876cad88c6df4afee80567a1 -->

<!-- pgdoc-cn_start sig_en=12b9be470c2625d0d39521cfd56fca8a sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_stat_wal</structname><indexterm><primary>pg_stat_wal</primary></indexterm></entry>
      <entry>One row only, showing statistics about WAL activity. See
       <link linkend="monitoring-pg-stat-wal-view">
       <structname>pg_stat_wal</structname></link> for details.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_stat_wal</structname><indexterm><primary>pg_stat_wal</primary></indexterm></entry>
      <entry>仅一行，显示WAL活动的统计信息。
       详请参见 <link linkend="monitoring-pg-stat-wal-view"> <structname>pg_stat_wal</structname></link> 。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=12b9be470c2625d0d39521cfd56fca8a -->

<!-- pgdoc-cn_start sig_en=c3f9b3737a40cc5755f997df1a946444 sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_stat_database</structname><indexterm><primary>pg_stat_database</primary></indexterm></entry>
      <entry>One row per database, showing database-wide statistics. See
       <link linkend="monitoring-pg-stat-database-view">
       <structname>pg_stat_database</structname></link> for details.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_stat_database</structname><indexterm><primary>pg_stat_database</primary></indexterm></entry>
      <entry>每个数据库一行，显示数据库范围的统计信息。详见<link linkend="monitoring-pg-stat-database-view">
       <structname>pg_stat_database</structname></link>。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=c3f9b3737a40cc5755f997df1a946444 -->

<!-- pgdoc-cn_start sig_en=cb57059bbd6e0b81e1ee9e33cfd93af1 sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_stat_database_conflicts</structname><indexterm><primary>pg_stat_database_conflicts</primary></indexterm></entry>
      <entry>
       One row per database, showing database-wide statistics about
       query cancels due to conflict with recovery on standby servers.
       See <link linkend="monitoring-pg-stat-database-conflicts-view">
       <structname>pg_stat_database_conflicts</structname></link> for details.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_stat_database_conflicts</structname><indexterm><primary>pg_stat_database_conflicts</primary></indexterm></entry>
      <entry>
       每个数据库一行，显示数据库范围的统计信息，
       这些信息的内容是关于由于与后备服务器的恢复过程
       发生冲突而被取消的查询。详见<link linkend="monitoring-pg-stat-database-conflicts-view">
       <structname>pg_stat_database_conflicts</structname></link>。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=cb57059bbd6e0b81e1ee9e33cfd93af1 -->

<!-- pgdoc-cn_start sig_en=bd582d09fc8921137cc7c79f7e5a1ec4 sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_stat_all_tables</structname><indexterm><primary>pg_stat_all_tables</primary></indexterm></entry>
      <entry>
       One row for each table in the current database, showing statistics
       about accesses to that specific table.
       See <link linkend="monitoring-pg-stat-all-tables-view">
       <structname>pg_stat_all_tables</structname></link> for details.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_stat_all_tables</structname><indexterm><primary>pg_stat_all_tables</primary></indexterm></entry>
      <entry>
       当前数据库中每个表一行，显示有关访问指定表的统计信息。详见<link linkend="monitoring-pg-stat-all-tables-view">
       <structname>pg_stat_all_tables</structname></link>。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=bd582d09fc8921137cc7c79f7e5a1ec4 -->

<!-- pgdoc-cn_start sig_en=82fc956f1d1ac1972688c33ee5dd3047 sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_stat_sys_tables</structname><indexterm><primary>pg_stat_sys_tables</primary></indexterm></entry>
      <entry>Same as <structname>pg_stat_all_tables</structname>, except that only
      system tables are shown.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_stat_sys_tables</structname><indexterm><primary>pg_stat_sys_tables</primary></indexterm></entry>
      <entry>和<structname>pg_stat_all_tables</structname>一样，但只显示系统表。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=82fc956f1d1ac1972688c33ee5dd3047 -->

<!-- pgdoc-cn_start sig_en=12ab6fcfff41b0fa4579cd35389a58f2 sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_stat_user_tables</structname><indexterm><primary>pg_stat_user_tables</primary></indexterm></entry>
      <entry>Same as <structname>pg_stat_all_tables</structname>, except that only user
      tables are shown.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_stat_user_tables</structname><indexterm><primary>pg_stat_user_tables</primary></indexterm></entry>
      <entry>和<structname>pg_stat_all_tables</structname>一样，但只显示用户表。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=12ab6fcfff41b0fa4579cd35389a58f2 -->

<!-- pgdoc-cn_start sig_en=f630facf819a165f9272ace4d2838224 sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_stat_xact_all_tables</structname><indexterm><primary>pg_stat_xact_all_tables</primary></indexterm></entry>
      <entry>Similar to <structname>pg_stat_all_tables</structname>, but counts actions
      taken so far within the current transaction (which are <emphasis>not</emphasis>
      yet included in <structname>pg_stat_all_tables</structname> and related views).
      The columns for numbers of live and dead rows and vacuum and
      analyze actions are not present in this view.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_stat_xact_all_tables</structname><indexterm><primary>pg_stat_xact_all_tables</primary></indexterm></entry>
      <entry>和<structname>pg_stat_all_tables</structname>相似，但计数动作只在当前事务内发生（还<emphasis>没有</emphasis>被包括在<structname>pg_stat_all_tables</structname>和相关视图中）。用于生存和死亡行数量的列以及清理和分析动作在此视图中不出现。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=f630facf819a165f9272ace4d2838224 -->

<!-- pgdoc-cn_start sig_en=ec3751dbbccf0105c2d55ee892df0608 sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_stat_xact_sys_tables</structname><indexterm><primary>pg_stat_xact_sys_tables</primary></indexterm></entry>
      <entry>Same as <structname>pg_stat_xact_all_tables</structname>, except that only
      system tables are shown.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_stat_xact_sys_tables</structname><indexterm><primary>pg_stat_xact_sys_tables</primary></indexterm></entry>
      <entry>和<structname>pg_stat_xact_all_tables</structname>一样，但只显示系统表。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=ec3751dbbccf0105c2d55ee892df0608 -->

<!-- pgdoc-cn_start sig_en=c83f57382e5347ec86f8e04104d8c8f5 sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_stat_xact_user_tables</structname><indexterm><primary>pg_stat_xact_user_tables</primary></indexterm></entry>
      <entry>Same as <structname>pg_stat_xact_all_tables</structname>, except that only
      user tables are shown.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_stat_xact_user_tables</structname><indexterm><primary>pg_stat_xact_user_tables</primary></indexterm></entry>
      <entry>和<structname>pg_stat_xact_all_tables</structname>一样，但只显示用户表。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=c83f57382e5347ec86f8e04104d8c8f5 -->

<!-- pgdoc-cn_start sig_en=f7c9de605ce143ff96b3cc8d530ead57 sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_stat_all_indexes</structname><indexterm><primary>pg_stat_all_indexes</primary></indexterm></entry>
      <entry>
       One row for each index in the current database, showing statistics
       about accesses to that specific index.
       See <link linkend="monitoring-pg-stat-all-indexes-view">
       <structname>pg_stat_all_indexes</structname></link> for details.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_stat_all_indexes</structname><indexterm><primary>pg_stat_all_indexes</primary></indexterm></entry>
      <entry>
       当前数据库中的每个索引一行，显示：表OID、索引OID、模式名、表名、索引名、 使用了该索引的索引扫描总数、索引扫描返回的索引记录数、使用该索引的简 单索引扫描抓取的活表(livetable)中数据行数。
       当前数据库中的每个索引一行，显示与访问指定索引有关的统计信息。详见<link linkend="monitoring-pg-stat-all-indexes-view">
       <structname>pg_stat_all_indexes</structname></link>。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=f7c9de605ce143ff96b3cc8d530ead57 -->

<!-- pgdoc-cn_start sig_en=432cb6b2a5b4c560e1b09eccdaa6bcd9 sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_stat_sys_indexes</structname><indexterm><primary>pg_stat_sys_indexes</primary></indexterm></entry>
      <entry>Same as <structname>pg_stat_all_indexes</structname>, except that only
      indexes on system tables are shown.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_stat_sys_indexes</structname><indexterm><primary>pg_stat_sys_indexes</primary></indexterm></entry>
      <entry>和<structname>pg_stat_all_indexes</structname>一样，但只显示系统表上的索引。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=432cb6b2a5b4c560e1b09eccdaa6bcd9 -->

<!-- pgdoc-cn_start sig_en=0958ed40840afe78bc3db94485de3dff sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_stat_user_indexes</structname><indexterm><primary>pg_stat_user_indexes</primary></indexterm></entry>
      <entry>Same as <structname>pg_stat_all_indexes</structname>, except that only
      indexes on user tables are shown.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_stat_user_indexes</structname><indexterm><primary>pg_stat_user_indexes</primary></indexterm></entry>
      <entry>和<structname>pg_stat_all_indexes</structname>一样，但只显示用户表上的索引。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=0958ed40840afe78bc3db94485de3dff -->

<!-- pgdoc-cn_start sig_en=2678d101c931694a4ea90016e5500e07 sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_statio_all_tables</structname><indexterm><primary>pg_statio_all_tables</primary></indexterm></entry>
      <entry>
       One row for each table in the current database, showing statistics
       about I/O on that specific table.
       See <link linkend="monitoring-pg-statio-all-tables-view">
       <structname>pg_statio_all_tables</structname></link> for details.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_statio_all_tables</structname><indexterm><primary>pg_statio_all_tables</primary></indexterm></entry>
      <entry>
       当前数据库中每个表一行(包括TOAST表)，显示：表OID、模式名、表名、 从该表中读取的磁盘块总数、缓冲区命中次数、该表上所有索引的磁盘块读取总数、 该表上所有索引的缓冲区命中总数、在该表的辅助TOAST表(如果存在)上的磁盘块读取总数、 在该表的辅助TOAST表(如果存在)上的缓冲区命中总数、TOAST表的索引的磁盘块读 取总数、TOAST表的索引的缓冲区命中总数。
       当前数据库中的每个表一行，显示有关在指定表上 I/O 的统计信息。详见<link linkend="monitoring-pg-statio-all-tables-view">
       <structname>pg_statio_all_tables</structname></link>。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=2678d101c931694a4ea90016e5500e07 -->

<!-- pgdoc-cn_start sig_en=0dd8f88c821b8ae40efc4b71c20c3c96 sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_statio_sys_tables</structname><indexterm><primary>pg_statio_sys_tables</primary></indexterm></entry>
      <entry>Same as <structname>pg_statio_all_tables</structname>, except that only
      system tables are shown.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_statio_sys_tables</structname><indexterm><primary>pg_statio_sys_tables</primary></indexterm></entry>
      <entry>和<structname>pg_statio_all_tables</structname>一样，但只显示系统表。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=0dd8f88c821b8ae40efc4b71c20c3c96 -->

<!-- pgdoc-cn_start sig_en=4702919aa7837a95f84cb3ef684daab6 sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_statio_user_tables</structname><indexterm><primary>pg_statio_user_tables</primary></indexterm></entry>
      <entry>Same as <structname>pg_statio_all_tables</structname>, except that only
      user tables are shown.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_statio_user_tables</structname><indexterm><primary>pg_statio_user_tables</primary></indexterm></entry>
      <entry>和<structname>pg_statio_all_tables</structname>一样，但只显示用户表。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=4702919aa7837a95f84cb3ef684daab6 -->

<!-- pgdoc-cn_start sig_en=4d45beff63463eae07c0a74b58e8d6ea sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_statio_all_indexes</structname><indexterm><primary>pg_statio_all_indexes</primary></indexterm></entry>
      <entry>
       One row for each index in the current database,
       showing statistics about I/O on that specific index.
       See <link linkend="monitoring-pg-statio-all-indexes-view">
       <structname>pg_statio_all_indexes</structname></link> for details.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_statio_all_indexes</structname><indexterm><primary>pg_statio_all_indexes</primary></indexterm></entry>
      <entry>
       当前数据库中每个索引一行，显示：表OID、索引OID、模式名、 表名、索引名、该索引的磁盘块读取总数、该索引的缓冲区命中总数。
       当前数据库中的每个索引一行，显示与指定索引上的 I/O 有关的统计信息。详见<link linkend="monitoring-pg-statio-all-indexes-view">
       <structname>pg_statio_all_indexes</structname></link>。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=4d45beff63463eae07c0a74b58e8d6ea -->

<!-- pgdoc-cn_start sig_en=faa9f376ae4dabd5a9b704ef1601a969 sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_statio_sys_indexes</structname><indexterm><primary>pg_statio_sys_indexes</primary></indexterm></entry>
      <entry>Same as <structname>pg_statio_all_indexes</structname>, except that only
      indexes on system tables are shown.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_statio_sys_indexes</structname><indexterm><primary>pg_statio_sys_indexes</primary></indexterm></entry>
      <entry>和<structname>pg_statio_all_indexes</structname>一样，但只显示系统表上的索引。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=faa9f376ae4dabd5a9b704ef1601a969 -->

<!-- pgdoc-cn_start sig_en=9a25a98c867365cd600bdfd04d43ad6e sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_statio_user_indexes</structname><indexterm><primary>pg_statio_user_indexes</primary></indexterm></entry>
      <entry>Same as <structname>pg_statio_all_indexes</structname>, except that only
      indexes on user tables are shown.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_statio_user_indexes</structname><indexterm><primary>pg_statio_user_indexes</primary></indexterm></entry>
      <entry>和<structname>pg_statio_all_indexes</structname>一样，但只显示用户表上的索引。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=9a25a98c867365cd600bdfd04d43ad6e -->

<!-- pgdoc-cn_start sig_en=5ec35c41d08511990b2de5beb909ff1e sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_statio_all_sequences</structname><indexterm><primary>pg_statio_all_sequences</primary></indexterm></entry>
     <entry>
       One row for each sequence in the current database,
       showing statistics about I/O on that specific sequence.
       See <link linkend="monitoring-pg-statio-all-sequences-view">
       <structname>pg_statio_all_sequences</structname></link> for details.
     </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_statio_all_sequences</structname><indexterm><primary>pg_statio_all_sequences</primary></indexterm></entry>
     <entry>
       当前数据库中每个序列对象一行，显示：序列OID、模式名、序列名、序列的磁盘读取总数、序列的缓冲区命中总数。
       当前数据库中的每个序列一行，显示与指定序列上的 I/O 有关的统计信息。详见<link linkend="monitoring-pg-statio-all-sequences-view">
       <structname>pg_statio_all_sequences</structname></link>。
     </entry>
     </row>
<!-- pgdoc-cn_end sig_en=5ec35c41d08511990b2de5beb909ff1e -->

<!-- pgdoc-cn_start sig_en=4b6a74970c7b9ffdb756892e1b5a1c94 sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_statio_sys_sequences</structname><indexterm><primary>pg_statio_sys_sequences</primary></indexterm></entry>
      <entry>Same as <structname>pg_statio_all_sequences</structname>, except that only
      system sequences are shown.  (Presently, no system sequences are defined,
      so this view is always empty.)</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_statio_sys_sequences</structname><indexterm><primary>pg_statio_sys_sequences</primary></indexterm></entry>
      <entry>和<structname>pg_statio_all_sequences</structname>一样，但只显示系统序列（目前没有定义系统序列，因此这个视图总是为空）。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=4b6a74970c7b9ffdb756892e1b5a1c94 -->

<!-- pgdoc-cn_start sig_en=7de0ffe37ef56778363f3b6c866fc2c5 sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_statio_user_sequences</structname><indexterm><primary>pg_statio_user_sequences</primary></indexterm></entry>
      <entry>Same as <structname>pg_statio_all_sequences</structname>, except that only
      user sequences are shown.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_statio_user_sequences</structname><indexterm><primary>pg_statio_user_sequences</primary></indexterm></entry>
      <entry>和<structname>pg_statio_all_sequences</structname>一样，但只显示用户序列。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=7de0ffe37ef56778363f3b6c866fc2c5 -->

<!-- pgdoc-cn_start sig_en=7e2a8a1bab094c6b748335b6310238be sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_stat_user_functions</structname><indexterm><primary>pg_stat_user_functions</primary></indexterm></entry>
      <entry>
       One row for each tracked function, showing statistics
       about executions of that function. See
       <link linkend="monitoring-pg-stat-user-functions-view">
       <structname>pg_stat_user_functions</structname></link> for details.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_stat_user_functions</structname><indexterm><primary>pg_stat_user_functions</primary></indexterm></entry>
      <entry>
       对于所有跟踪功能，函数的OID，模式，名称，数量 通话总时间，和自我的时间。自我时间是 在函数本身所花费的时间量，总时间包括 它调用函数所花费的时间。时间值以毫秒为单位。
       每一个被跟踪的函数一行，显示与执行该函数有关的统计信息。详见<link linkend="monitoring-pg-stat-user-functions-view">
       <structname>pg_stat_user_functions</structname></link>。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=7e2a8a1bab094c6b748335b6310238be -->

<!-- pgdoc-cn_start sig_en=2f228480ddd771fa19b14f3229bb9198 sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_stat_xact_user_functions</structname><indexterm><primary>pg_stat_xact_user_functions</primary></indexterm></entry>
      <entry>Similar to <structname>pg_stat_user_functions</structname>, but counts only
      calls during the current transaction (which are <emphasis>not</emphasis>
      yet included in <structname>pg_stat_user_functions</structname>).</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_stat_xact_user_functions</structname><indexterm><primary>pg_stat_xact_user_functions</primary></indexterm></entry>
      <entry>和<structname>pg_stat_user_functions</structname>相似，但是只统计在当前事务期间的调用（还<emphasis>没有</emphasis>被包括在<structname>pg_stat_user_functions</structname>中）。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=2f228480ddd771fa19b14f3229bb9198 -->

<!-- pgdoc-cn_start sig_en=7104abe17d581e770cdb61eed27f78af sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_stat_slru</structname><indexterm><primary>pg_stat_slru</primary></indexterm></entry>
      <entry>One row per SLRU, showing statistics of operations. See
       <link linkend="monitoring-pg-stat-slru-view">
       <structname>pg_stat_slru</structname></link> for details.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_stat_slru</structname><indexterm><primary>pg_stat_slru</primary></indexterm></entry>
      <entry>每个SLRU一行, 显示操作的统计信息。参见<link linkend="monitoring-pg-stat-slru-view">
       <structname>pg_stat_slru</structname></link> for details.
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=7104abe17d581e770cdb61eed27f78af -->

<!-- pgdoc-cn_start sig_en=3a0d34d8828eed265569b8feb3e1efb2 sig_cn_org=None source=14.1 
     <row>
      <entry><structname>pg_stat_replication_slots</structname><indexterm><primary>pg_stat_replication_slots</primary></indexterm></entry>
      <entry>One row per replication slot, showing statistics about the
       replication slot's usage. See
       <link linkend="monitoring-pg-stat-replication-slots-view">
       <structname>pg_stat_replication_slots</structname></link> for details.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_stat_replication_slots</structname><indexterm><primary>pg_stat_replication_slots</primary></indexterm></entry>
      <entry>每个复制槽一行，显示关于复制槽的利用率的统计信息。
       详请参见<link linkend="monitoring-pg-stat-replication-slots-view"> <structname>pg_stat_replication_slots</structname></link>。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=3a0d34d8828eed265569b8feb3e1efb2 -->

<!-- pgdoc-cn_start sig_en=87b6e091dd1a5e7b9f8ee6ec58a0f9fb sig_cn_org=71e404f88ef55ad260936f08e7edee19 source=15.7 
     <row>
      <entry><structname>pg_stat_subscription_stats</structname><indexterm><primary>pg_stat_subscription_stats</primary></indexterm></entry>
      <entry>One row per subscription, showing statistics about errors.
      See <link linkend="monitoring-pg-stat-subscription-stats">
      <structname>pg_stat_subscription_stats</structname></link> for details.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><structname>pg_stat_subscription_stats</structname><indexterm><primary>pg_stat_subscription_stats</primary></indexterm></entry>
      <entry>每个订阅的一行，显示有关错误的统计信息。
      有关详细信息，请参见<link linkend="monitoring-pg-stat-subscription-stats">
      <structname>pg_stat_subscription_stats</structname></link>。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=87b6e091dd1a5e7b9f8ee6ec58a0f9fb -->

    </tbody>
   </tgroup>
  </table>

<!-- pgdoc-cn_start sig_en=27eed4e96a23fa164d0104927c6eab0d sig_cn_org=None source=14.1 
  <para>
   The per-index statistics are particularly useful to determine which
   indexes are being used and how effective they are.
  </para>
________________________________________________________-->
  <para>
   针对每个索引的统计信息对于判断哪个索引正被使用以及它们的效果特别有用。
  </para>
<!-- pgdoc-cn_end sig_en=27eed4e96a23fa164d0104927c6eab0d -->

<!-- pgdoc-cn_start sig_en=81ee719a1837596e68b967b60ebdca0a sig_cn_org=cf87b7a2420f79a5082696070cb67c57 source=15.7 
  <para>
   The <structname>pg_statio_</structname> views are primarily useful to
   determine the effectiveness of the buffer cache.  When the number
   of actual disk reads is much smaller than the number of buffer
   hits, then the cache is satisfying most read requests without
   invoking a kernel call. However, these statistics do not give the
   entire story: due to the way in which <productname>PostgreSQL</productname>
   handles disk I/O, data that is not in the
   <productname>PostgreSQL</productname> buffer cache might still reside in the
   kernel's I/O cache, and might therefore still be fetched without
   requiring a physical read. Users interested in obtaining more
   detailed information on <productname>PostgreSQL</productname> I/O behavior are
   advised to use the <productname>PostgreSQL</productname> statistics views
   in combination with operating system utilities that allow insight
   into the kernel's handling of I/O.
  </para>
________________________________________________________-->
  <para>
   <structname>pg_statio_</structname>视图主要用于确定缓存的有效性。当实际磁盘读取次数远小于缓存命中次数时，
   则缓存可以满足大多数读取请求而不需要调用内核。然而，这些统计数据并不能完全说明问题：由于<productname>PostgreSQL</productname>
   处理磁盘I/O的方式，不在<productname>PostgreSQL</productname>缓存中的数据可能仍然驻留在内核的I/O缓存中，因此可能仍然可以在不需要
   物理读取的情况下获取。有兴趣获取更详细的<productname>PostgreSQL</productname> I/O行为信息的用户建议结合操作系统工具使用
   <productname>PostgreSQL</productname>统计视图，以了解内核对I/O的处理方式。
</para>
<!-- pgdoc-cn_end sig_en=81ee719a1837596e68b967b60ebdca0a -->

 </sect2>

 <sect2 id="monitoring-pg-stat-activity-view">
  <title><structname>pg_stat_activity</structname></title>

<!-- pgdoc-cn_start sig_en=0bfe8984e18a2011e9db1a43fe934179 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>pg_stat_activity</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>pg_stat_activity</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=0bfe8984e18a2011e9db1a43fe934179 -->

<!-- pgdoc-cn_start sig_en=9d4bd9784e5831728130a5fc53c17819 sig_cn_org=None source=14.1 
  <para>
   The <structname>pg_stat_activity</structname> view will have one row
   per server process, showing information related to
   the current activity of that process.
  </para>
________________________________________________________-->
  <para>
   <structname>pg_stat_activity</structname>视图每个服务器进程将有一行，显示与该进程当前活动相关的信息。
  </para>
<!-- pgdoc-cn_end sig_en=9d4bd9784e5831728130a5fc53c17819 -->

  <table id="pg-stat-activity-view" xreflabel="pg_stat_activity">
<!-- pgdoc-cn_start sig_en=82c23b62ec1e334c5242da473de83459 sig_cn_org=None source=14.1 
   <title><structname>pg_stat_activity</structname> View</title>
________________________________________________________-->
   <title><structname>pg_stat_activity</structname> 视图</title>
<!-- pgdoc-cn_end sig_en=82c23b62ec1e334c5242da473de83459 -->
   <tgroup cols="1">
    <thead>
<!-- pgdoc-cn_start sig_en=19eb14a155d7416c3b9cad7829c11a9d sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=19eb14a155d7416c3b9cad7829c11a9d -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=566c254b0ef90f69c882ce1faf83f6cc sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the database this backend is connected to
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datid</structfield> <type>oid</type>
      </para>
      <para>
       这个后端连接到的数据库的OID
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=566c254b0ef90f69c882ce1faf83f6cc -->

<!-- pgdoc-cn_start sig_en=499277e8052a87b05ae8db471c401d03 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datname</structfield> <type>name</type>
      </para>
      <para>
       Name of the database this backend is connected to
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datname</structfield> <type>name</type>
      </para>
      <para>
       这个后端连接到的数据库的名称
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=499277e8052a87b05ae8db471c401d03 -->

<!-- pgdoc-cn_start sig_en=0c4afd422df8d12f439466d6494b523f sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       Process ID of this backend
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       这个后端的进程 ID
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=0c4afd422df8d12f439466d6494b523f -->

<!-- pgdoc-cn_start sig_en=76942431718281fef610b068aa46aad1 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>leader_pid</structfield> <type>integer</type>
      </para>
      <para>
       Process ID of the parallel group leader, if this process is a
       parallel query worker.  <literal>NULL</literal> if this process is a
       parallel group leader or does not participate in parallel query.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>leader_pid</structfield> <type>integer</type>
      </para>
      <para>
       并行组组长的进程ID，如果该进程是并行查询工作者。如果该进程是一个并行组的组长或不参与并行查询，则为<literal>NULL</literal>。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=76942431718281fef610b068aa46aad1 -->

<!-- pgdoc-cn_start sig_en=00151c86ff666a110defd55a8dee11a8 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>usesysid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the user logged into this backend
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>usesysid</structfield> <type>oid</type>
      </para>
      <para>
       登录到这个后端的用户的 OID
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=00151c86ff666a110defd55a8dee11a8 -->

<!-- pgdoc-cn_start sig_en=e53f18118f3bbaef1c47574ea0f71af6 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>usename</structfield> <type>name</type>
      </para>
      <para>
       Name of the user logged into this backend
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>usename</structfield> <type>name</type>
      </para>
      <para>
       登录到这个后端的用户的 OID
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=e53f18118f3bbaef1c47574ea0f71af6 -->

<!-- pgdoc-cn_start sig_en=6a62a8454daa4eb7e7b05773713721de sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>application_name</structfield> <type>text</type>
      </para>
      <para>
       Name of the application that is connected
       to this backend
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>application_name</structfield> <type>text</type>
      </para>
      <para>
       连接到这个后端的应用的名称
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=6a62a8454daa4eb7e7b05773713721de -->

<!-- pgdoc-cn_start sig_en=695a11c751e678684d2dc096375e6124 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>client_addr</structfield> <type>inet</type>
      </para>
      <para>
       IP address of the client connected to this backend.
       If this field is null, it indicates either that the client is
       connected via a Unix socket on the server machine or that this is an
       internal process such as autovacuum.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>client_addr</structfield> <type>inet</type>
      </para>
      <para>
       连接到这个后端的客户端的 IP 地址。如果这个字段为空，它表示客户端通过服务器机器上的一个 Unix 套接字连接或者这是一个内部进程，如自动清理。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=695a11c751e678684d2dc096375e6124 -->

<!-- pgdoc-cn_start sig_en=7561658978a029896fae99f88c322c36 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>client_hostname</structfield> <type>text</type>
      </para>
      <para>
       Host name of the connected client, as reported by a
       reverse DNS lookup of <structfield>client_addr</structfield>. This field will
       only be non-null for IP connections, and only when <xref linkend="guc-log-hostname"/> is enabled.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>client_hostname</structfield> <type>text</type>
      </para>
      <para>
       已连接的客户端的主机名，由<structfield>client_addr</structfield>的反向 DNS 查找报告。
	   这个字段将只对 IP 连接非空，并且只有 <xref linkend="guc-log-hostname"/>被启用时才会非空。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=7561658978a029896fae99f88c322c36 -->

<!-- pgdoc-cn_start sig_en=e1fd7fd957c669ad775ba99325ce09dd sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>client_port</structfield> <type>integer</type>
      </para>
      <para>
       TCP port number that the client is using for communication
       with this backend, or <literal>-1</literal> if a Unix socket is used.
       If this field is null, it indicates that this is an internal server process.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>client_port</structfield> <type>integer</type>
      </para>
      <para>
       客户端用于与此后端通信的TCP端口号，如果使用Unix套接字，则为<literal>-1</literal>。如果该字段为空，它表示这是一个内部服务器进程。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=e1fd7fd957c669ad775ba99325ce09dd -->

<!-- pgdoc-cn_start sig_en=8fccbe8d33d296a15136d4798d1be077 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>backend_start</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time when this process was started.  For client backends,
       this is the time the client connected to the server.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>backend_start</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       这个进程被启动的时间。对客户端后端来说，这就是客户端连接到服务器的时间。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=8fccbe8d33d296a15136d4798d1be077 -->

<!-- pgdoc-cn_start sig_en=89bb4303559f115f6b9d65df7802cd30 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>xact_start</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time when this process' current transaction was started, or null
       if no transaction is active. If the current
       query is the first of its transaction, this column is equal to the
       <structfield>query_start</structfield> column.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>xact_start</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       这个进程的当前事务被启动的时间，如果没有活动事务则为空。
       如果当前查询是它的第一个事务，这一列等于<structfield>query_start</structfield>列。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=89bb4303559f115f6b9d65df7802cd30 -->

<!-- pgdoc-cn_start sig_en=f785197c5c9cfa2130a388bd7dd62ad1 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>query_start</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time when the currently active query was started, or if
       <structfield>state</structfield> is not <literal>active</literal>, when the last query
       was started
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>query_start</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       当前活动查询被开始的时间，如果<structfield>state</structfield>不是<literal>active</literal>，则为上一个查询开始的时间
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=f785197c5c9cfa2130a388bd7dd62ad1 -->

<!-- pgdoc-cn_start sig_en=ab1460b406f38439c11c77df45fd602e sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>state_change</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time when the <structfield>state</structfield> was last changed
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>state_change</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       <structfield>state</structfield>上一次被改变的时间
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=ab1460b406f38439c11c77df45fd602e -->

<!-- pgdoc-cn_start sig_en=4e5e3ab7a7b66d7b6ec488ab0fef2080 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wait_event_type</structfield> <type>text</type>
      </para>
      <para>
       The type of event for which the backend is waiting, if any;
       otherwise NULL.  See <xref linkend="wait-event-table"/>.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wait_event_type</structfield> <type>text</type>
      </para>
      <para>
       后端等待的事件类型，如果有的话;否则NULL。参见<xref linkend="wait-event-table"/>。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=4e5e3ab7a7b66d7b6ec488ab0fef2080 -->

<!-- pgdoc-cn_start sig_en=6c9642b78973549d5afac3144d1ebf7c sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wait_event</structfield> <type>text</type>
      </para>
      <para>
       Wait event name if backend is currently waiting, otherwise NULL.
       See <xref linkend="wait-event-activity-table"/> through
       <xref linkend="wait-event-timeout-table"/>.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wait_event</structfield> <type>text</type>
      </para>
      <para>
       如果后端当前正在等待，则等待事件名称，否则为NULL。参见<xref linkend="wait-event-activity-table"/> 到
       <xref linkend="wait-event-timeout-table"/>。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=6c9642b78973549d5afac3144d1ebf7c -->

<!-- pgdoc-cn_start sig_en=c61e0684147e9256a1d4383227979202 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>state</structfield> <type>text</type>
      </para>
      <para>
       Current overall state of this backend.
       Possible values are:
       <itemizedlist>
        <listitem>
        <para>
          <literal>active</literal>: The backend is executing a query.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>idle</literal>: The backend is waiting for a new client command.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>idle in transaction</literal>: The backend is in a transaction,
          but is not currently executing a query.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>idle in transaction (aborted)</literal>: This state is similar to
          <literal>idle in transaction</literal>, except one of the statements in
          the transaction caused an error.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>fastpath function call</literal>: The backend is executing a
          fast-path function.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>disabled</literal>: This state is reported if <xref linkend="guc-track-activities"/> is disabled in this backend.
         </para>
       </listitem>
       </itemizedlist>
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>state</structfield> <type>text</type>
      </para>
      <para>
       这个后端的当前总体状态。可能的值为：
       <itemizedlist>
        <listitem>
        <para>
          <literal>active</literal>: 后端正在执行一个查询。
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>idle</literal>: 后端正在等待一个新的客户端命令。
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>idle in transaction</literal>: 后端在一个事务中，但是当前没有正在执行一个查询。
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>idle in transaction (aborted)</literal>: 这个状态与
          <literal>idle in transaction</literal>相似，除了在该事务中的一个语句导致了一个错误。
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>fastpath function call</literal>: 后端正在执行一个 fast-path 函数。
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>disabled</literal>: 如果在这个后端中<xref linkend="guc-track-activities"/>被禁用，则报告这个状态。
         </para>
       </listitem>
       </itemizedlist>
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=c61e0684147e9256a1d4383227979202 -->

<!-- pgdoc-cn_start sig_en=42ca02e1973e716e69d05b075d4c930b sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>backend_xid</structfield> <type>xid</type>
      </para>
      <para>
       Top-level transaction identifier of this backend, if any.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>backend_xid</structfield> <type>xid</type>
      </para>
      <para>
       这个后端的顶层事务标识符，如果存在。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=42ca02e1973e716e69d05b075d4c930b -->

<!-- pgdoc-cn_start sig_en=bb4c5accc63d1ae9b68432c53e2d85dc sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>backend_xmin</structfield> <type>xid</type>
      </para>
      <para>
       The current backend's <literal>xmin</literal> horizon.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>backend_xmin</structfield> <type>xid</type>
      </para>
      <para>
       当前后端的<literal>xmin</literal>范围。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=bb4c5accc63d1ae9b68432c53e2d85dc -->

<!-- pgdoc-cn_start sig_en=2a991baaf5d3f994607945d8e2def9b0 sig_cn_org=None source=14.1 
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>query_id</structfield> <type>bigint</type>
     </para>
     <para>
      Identifier of this backend's most recent query. If
      <structfield>state</structfield> is <literal>active</literal> this
      field shows the identifier of the currently executing query. In
      all other states, it shows the identifier of last query that was
      executed.  Query identifiers are not computed by default so this
      field will be null unless <xref linkend="guc-compute-query-id"/>
      parameter is enabled or a third-party module that computes query
      identifiers is configured.
     </para></entry>
    </row>
________________________________________________________-->
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>query_id</structfield> <type>bigint</type>
     </para>
     <para>
      这个后端的最近查询的标识符。
      如果<structfield>state</structfield>是<literal>active</literal>，这个字段显示当前正在执行的查询的标识符。
      在所有其他状态，它显示执行的最后一个查询的标识符。
      默认不计算查询标识符，因此该字段将为空，除非启用<xref linkend="guc-compute-query-id"/>参数或配置了计算查询标识符的第三方模块。
     </para></entry>
    </row>
<!-- pgdoc-cn_end sig_en=2a991baaf5d3f994607945d8e2def9b0 -->

<!-- pgdoc-cn_start sig_en=514fc06e9641570535755a065de68ddd sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>query</structfield> <type>text</type>
      </para>
      <para>
       Text of this backend's most recent query. If
       <structfield>state</structfield> is <literal>active</literal> this field shows the
       currently executing query. In all other states, it shows the last query
       that was executed. By default the query text is truncated at 1024
       bytes; this value can be changed via the parameter
       <xref linkend="guc-track-activity-query-size"/>.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>query</structfield> <type>text</type>
      </para>
      <para>
       这个后端最近查询的文本。如果<structfield>state</structfield>为<literal>active</literal>，这个字段显示当前正在执行的查询。
       在所有其他状态下，它显示上一个被执行的查询。默认情况下，查询文本会被截断至1024个字节，这个值可以通过参数<xref linkend="guc-track-activity-query-size"/>更改。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=514fc06e9641570535755a065de68ddd -->

<!-- pgdoc-cn_start sig_en=9de208094be10471879efb223c2de60f sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>backend_type</structfield> <type>text</type>
      </para>
      <para>
       Type of current backend. Possible types are
       <literal>autovacuum launcher</literal>, <literal>autovacuum worker</literal>,
       <literal>logical replication launcher</literal>,
       <literal>logical replication worker</literal>,
       <literal>parallel worker</literal>, <literal>background writer</literal>,
       <literal>client backend</literal>, <literal>checkpointer</literal>,
       <literal>archiver</literal>,
       <literal>startup</literal>, <literal>walreceiver</literal>,
       <literal>walsender</literal> and <literal>walwriter</literal>.
       In addition, background workers registered by extensions may have
       additional types.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>backend_type</structfield> <type>text</type>
      </para>
      <para>
       当前后端的类型。可能的类型为
       <literal>autovacuum launcher</literal>, <literal>autovacuum worker</literal>,
       <literal>logical replication launcher</literal>,
       <literal>logical replication worker</literal>,
       <literal>parallel worker</literal>, <literal>background writer</literal>,
       <literal>client backend</literal>, <literal>checkpointer</literal>,
       <literal>archiver</literal>,
       <literal>startup</literal>, <literal>walreceiver</literal>,
       <literal>walsender</literal> and <literal>walwriter</literal>.
       除此以外，由扩展注册的后台Worker可能有额外的类型。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=9de208094be10471879efb223c2de60f -->
    </tbody>
   </tgroup>
  </table>

  <note>
<!-- pgdoc-cn_start sig_en=1b383694727dcdf26cf903bb6dfcc6d8 sig_cn_org=None source=14.1 
   <para>
    The <structfield>wait_event</structfield> and <structfield>state</structfield> columns are
    independent.  If a backend is in the <literal>active</literal> state,
    it may or may not be <literal>waiting</literal> on some event.  If the state
    is <literal>active</literal> and <structfield>wait_event</structfield> is non-null, it
    means that a query is being executed, but is being blocked somewhere
    in the system.
   </para>
________________________________________________________-->
   <para>
    <structfield>wait_event</structfield>和<structfield>state</structfield>列是独立的。如果一个后端处于<literal>active</literal>状态，它可能是也可能不是某个事件上的<literal>waiting</literal>。如果状态是<literal>active</literal>并且<structfield>wait_event</structfield>为非空，它意味着一个查询正在被执行，但是它被阻塞在系统中某处。
   </para>
<!-- pgdoc-cn_end sig_en=1b383694727dcdf26cf903bb6dfcc6d8 -->
  </note>

  <table id="wait-event-table">
<!-- pgdoc-cn_start sig_en=e210eafb99711369e3fffe069be775e3 sig_cn_org=None source=14.1 
   <title>Wait Event Types</title>
________________________________________________________-->
   <title>等待事件类型</title>
<!-- pgdoc-cn_end sig_en=e210eafb99711369e3fffe069be775e3 -->
   <tgroup cols="2">
    <thead>
<!-- pgdoc-cn_start sig_en=15ae400a87642adaf0c7ed57cf7e7894 sig_cn_org=None source=14.1 
     <row>
      <entry>Wait Event Type</entry>
      <entry>Description</entry>
     </row>
________________________________________________________-->
     <row>
      <entry>等待事件类型</entry>
      <entry>描述</entry>
     </row>
<!-- pgdoc-cn_end sig_en=15ae400a87642adaf0c7ed57cf7e7894 -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=830dc85490631ac818488814bf5bac7e sig_cn_org=None source=14.1 
     <row>
      <entry><literal>Activity</literal></entry>
      <entry>The server process is idle.  This event type indicates a process
       waiting for activity in its main processing loop.
       <literal>wait_event</literal> will identify the specific wait point;
       see <xref linkend="wait-event-activity-table"/>.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>Activity</literal></entry>
      <entry>服务器进程空闲。此事件类型表示在其主处理循环中等待活动的进程。
       <literal>wait_event</literal>将识别特定的等待点;参见<xref linkend="wait-event-activity-table"/>。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=830dc85490631ac818488814bf5bac7e -->
<!-- pgdoc-cn_start sig_en=e427012224ed912c092449aa31a86547 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>BufferPin</literal></entry>
      <entry>The server process is waiting for exclusive access to
       a data buffer.  Buffer pin waits can be protracted if
       another process holds an open cursor that last read data from the
       buffer in question. See <xref linkend="wait-event-bufferpin-table"/>.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>BufferPin</literal></entry>
      <entry>服务器进程正在等待对数据缓冲的独占访问。
       如果另一个进程持有一个打开的游标，该游标最后一次从相关缓冲区读取数据，则缓冲区销等待可能是漫长的。
       参见<xref linkend="wait-event-bufferpin-table"/>。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=e427012224ed912c092449aa31a86547 -->
<!-- pgdoc-cn_start sig_en=1d0f4fde22a9011a11a138a4d6f95a3b sig_cn_org=None source=14.1 
     <row>
      <entry><literal>Client</literal></entry>
      <entry>The server process is waiting for activity on a socket
       connected to a user application.  Thus, the server expects something
       to happen that is independent of its internal processes.
       <literal>wait_event</literal> will identify the specific wait point;
       see <xref linkend="wait-event-client-table"/>.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>Client</literal></entry>
      <entry>服务器进程正在等待连接到用户应用程序的套接字上的活动。
       因此，服务器预计发生一些独立于其内部进程的事情。<literal>wait_event</literal>将识别特定的等待点；参见<xref linkend="wait-event-client-table"/>。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=1d0f4fde22a9011a11a138a4d6f95a3b -->
<!-- pgdoc-cn_start sig_en=1929430f1da8a9fe909b03b89e955373 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>Extension</literal></entry>
      <entry>The server process is waiting for some condition defined by an
       extension module.
       See <xref linkend="wait-event-extension-table"/>.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>Extension</literal></entry>
      <entry>服务器进程正在等待扩展模块定义的某个条件。参见<xref linkend="wait-event-extension-table"/>。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=1929430f1da8a9fe909b03b89e955373 -->
<!-- pgdoc-cn_start sig_en=68e8f3405308a60f8409b77b0921c45a sig_cn_org=None source=14.1 
     <row>
      <entry><literal>IO</literal></entry>
      <entry>The server process is waiting for an I/O operation to complete.
       <literal>wait_event</literal> will identify the specific wait point;
       see <xref linkend="wait-event-io-table"/>.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>IO</literal></entry>
      <entry>服务器进程正在等待一个I/O操作完成。<literal>wait_event</literal>将识别特定的等待点；参见<xref linkend="wait-event-io-table"/>。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=68e8f3405308a60f8409b77b0921c45a -->
<!-- pgdoc-cn_start sig_en=ec39beddc40a02d539716da076e83bf0 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>IPC</literal></entry>
      <entry>The server process is waiting for some interaction with
       another server process.  <literal>wait_event</literal> will
       identify the specific wait point;
       see <xref linkend="wait-event-ipc-table"/>.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>IPC</literal></entry>
      <entry>服务器进程正在等待与另一个服务器进程进行交互。<literal>wait_event</literal>将识别特定的等待点;参见<xref linkend="wait-event-ipc-table"/>。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=ec39beddc40a02d539716da076e83bf0 -->
<!-- pgdoc-cn_start sig_en=52811f68966fcc2c9f3f81e1122df1f6 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>Lock</literal></entry>
      <entry>The server process is waiting for a heavyweight lock.
       Heavyweight locks, also known as lock manager locks or simply locks,
       primarily protect SQL-visible objects such as tables.  However,
       they are also used to ensure mutual exclusion for certain internal
       operations such as relation extension.  <literal>wait_event</literal>
       will identify the type of lock awaited;
       see <xref linkend="wait-event-lock-table"/>.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>Lock</literal></entry>
      <entry>服务器进程正在等待一个重量级锁。重量级锁，也称为锁管理器锁或简单锁，主要保护表等SQL可见对象。
       然而，它们也用于确保某些内部操作的互斥，例如关系扩展。<literal>wait_event</literal>将识别等待的锁的类型；参见<xref linkend="wait-event-lock-table"/>。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=52811f68966fcc2c9f3f81e1122df1f6 -->
<!-- pgdoc-cn_start sig_en=343750b53c2e9f32f061bcbc007a0703 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>LWLock</literal></entry>
      <entry> The server process is waiting for a lightweight lock.
       Most such locks protect a particular data structure in shared memory.
       <literal>wait_event</literal> will contain a name identifying the purpose
       of the lightweight lock.  (Some locks have specific names; others
       are part of a group of locks each with a similar purpose.)
       See <xref linkend="wait-event-lwlock-table"/>.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>LWLock</literal></entry>
      <entry> 服务器进程正在等待一个轻量级锁。大多数这样的锁保护共享内存中的特定数据结构。
       <literal>wait_event</literal>将包含标识轻量级锁用途的名称。
       (有些锁有特定的名称；其他锁是一组锁的一部分，每个锁具有类似的目的。)参见<xref linkend="wait-event-lwlock-table"/>。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=343750b53c2e9f32f061bcbc007a0703 -->
<!-- pgdoc-cn_start sig_en=904c2a1f1b483107a35d70dcb6a56fe5 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>Timeout</literal></entry>
      <entry>The server process is waiting for a timeout
       to expire.  <literal>wait_event</literal> will identify the specific wait
       point; see <xref linkend="wait-event-timeout-table"/>.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>Timeout</literal></entry>
      <entry>服务器进程正在等待超时过期。<literal>wait_event</literal>将识别特定的等待点；参见<xref linkend="wait-event-timeout-table"/>。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=904c2a1f1b483107a35d70dcb6a56fe5 -->
    </tbody>
   </tgroup>
  </table>

  <table id="wait-event-activity-table">
<!-- pgdoc-cn_start sig_en=54e60577c0512ba980f4bf0493321819 sig_cn_org=None source=14.1 
   <title>Wait Events of Type <literal>Activity</literal></title>
________________________________________________________-->
   <title><literal>Activity</literal>类型的等待事件</title>
<!-- pgdoc-cn_end sig_en=54e60577c0512ba980f4bf0493321819 -->
   <tgroup cols="2">
    <thead>
<!-- pgdoc-cn_start sig_en=8af5af175957aa55ac26a254a90fc12f sig_cn_org=None source=14.1 
     <row>
      <entry><literal>Activity</literal> Wait Event</entry>
      <entry>Description</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>Activity</literal> 等待事件</entry>
      <entry>描述</entry>
     </row>
<!-- pgdoc-cn_end sig_en=8af5af175957aa55ac26a254a90fc12f -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=e53d73d73b82e5ad8a8f68bde58ef957 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>ArchiverMain</literal></entry>
      <entry>Waiting in main loop of archiver process.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ArchiverMain</literal></entry>
      <entry>在归档进程的主循环中等待。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=e53d73d73b82e5ad8a8f68bde58ef957 -->
<!-- pgdoc-cn_start sig_en=8a06f51d63622d457f78ac563fd9f6b2 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>AutoVacuumMain</literal></entry>
      <entry>Waiting in main loop of autovacuum launcher process.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>AutoVacuumMain</literal></entry>
      <entry>在自动清理启动过程的主循环中等待。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=8a06f51d63622d457f78ac563fd9f6b2 -->
<!-- pgdoc-cn_start sig_en=b6baac1cc620a4221750eb35f8534661 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>BgWriterHibernate</literal></entry>
      <entry>Waiting in background writer process, hibernating.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>BgWriterHibernate</literal></entry>
      <entry>在后台写进程中等待，休眠状态。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=b6baac1cc620a4221750eb35f8534661 -->
<!-- pgdoc-cn_start sig_en=9c822157cf50e52b78bfaf626db831d0 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>BgWriterMain</literal></entry>
      <entry>Waiting in main loop of background writer process.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>BgWriterMain</literal></entry>
      <entry>在后台写进程主循环中等待。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=9c822157cf50e52b78bfaf626db831d0 -->
<!-- pgdoc-cn_start sig_en=4cd16bcf401ead7b7febd7e7e0b4b65c sig_cn_org=None source=14.1 
     <row>
      <entry><literal>CheckpointerMain</literal></entry>
      <entry>Waiting in main loop of checkpointer process.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>CheckpointerMain</literal></entry>
      <entry>在校验指针进程的主循环中等待。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=4cd16bcf401ead7b7febd7e7e0b4b65c -->
<!-- pgdoc-cn_start sig_en=0a06a0cd02f35226362898e0ba746e0b sig_cn_org=None source=14.1 
     <row>
      <entry><literal>LogicalApplyMain</literal></entry>
      <entry>Waiting in main loop of logical replication apply process.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>LogicalApplyMain</literal></entry>
      <entry>在逻辑复制应用进程的主循环中等待。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=0a06a0cd02f35226362898e0ba746e0b -->
<!-- pgdoc-cn_start sig_en=81b0294077ae236bd73d1e8e0a858eb5 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>LogicalLauncherMain</literal></entry>
      <entry>Waiting in main loop of logical replication launcher process.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>LogicalLauncherMain</literal></entry>
      <entry>在逻辑复制启动器进程的主循环中等待。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=81b0294077ae236bd73d1e8e0a858eb5 -->
<!-- pgdoc-cn_start sig_en=9e46ace9f5b6589b097e72bad2806c91 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>RecoveryWalStream</literal></entry>
      <entry>Waiting in main loop of startup process for WAL to arrive, during
       streaming recovery.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>RecoveryWalStream</literal></entry>
      <entry>流恢复期间，在启动进程主循环等待WAL到达。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=9e46ace9f5b6589b097e72bad2806c91 -->
<!-- pgdoc-cn_start sig_en=75d3446d2fa54bf7c2be4c323bb32410 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>SysLoggerMain</literal></entry>
      <entry>Waiting in main loop of syslogger process.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>SysLoggerMain</literal></entry>
      <entry>在syslogger进程的主循环中等待。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=75d3446d2fa54bf7c2be4c323bb32410 -->
<!-- pgdoc-cn_start sig_en=cf0eb5f2bf4f987c398f47251e88ad8a sig_cn_org=None source=14.1 
     <row>
      <entry><literal>WalReceiverMain</literal></entry>
      <entry>Waiting in main loop of WAL receiver process.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>WalReceiverMain</literal></entry>
      <entry>在WAL接收器进程的主循环中等待。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=cf0eb5f2bf4f987c398f47251e88ad8a -->
<!-- pgdoc-cn_start sig_en=c1f661ec9e53ae994bb4ae08dd371110 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>WalSenderMain</literal></entry>
      <entry>Waiting in main loop of WAL sender process.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>WalSenderMain</literal></entry>
      <entry>在WAL发送者进程的主循环中等待。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=c1f661ec9e53ae994bb4ae08dd371110 -->
<!-- pgdoc-cn_start sig_en=a0ed0afc6991a7cac4cb59578f775406 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>WalWriterMain</literal></entry>
      <entry>Waiting in main loop of WAL writer process.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>WalWriterMain</literal></entry>
      <entry>在WAL写入进程的主循环中等待。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=a0ed0afc6991a7cac4cb59578f775406 -->
    </tbody>
   </tgroup>
  </table>

  <table id="wait-event-bufferpin-table">
<!-- pgdoc-cn_start sig_en=424a3722d2a538af8b478c5d8c80b37e sig_cn_org=None source=14.1 
   <title>Wait Events of Type <literal>BufferPin</literal></title>
________________________________________________________-->
   <title><literal>BufferPin</literal>类型的等待事件</title>
<!-- pgdoc-cn_end sig_en=424a3722d2a538af8b478c5d8c80b37e -->
   <tgroup cols="2">
    <thead>
<!-- pgdoc-cn_start sig_en=880119ed64717932b75edd0b9cea4a05 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>BufferPin</literal> Wait Event</entry>
      <entry>Description</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>BufferPin</literal> 等待事件</entry>
      <entry>描述</entry>
     </row>
<!-- pgdoc-cn_end sig_en=880119ed64717932b75edd0b9cea4a05 -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=b7c712948173684b20c193f31b03f494 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>BufferPin</literal></entry>
      <entry>Waiting to acquire an exclusive pin on a buffer.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>BufferPin</literal></entry>
      <entry>等待获得缓冲区上的独占销。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=b7c712948173684b20c193f31b03f494 -->
    </tbody>
   </tgroup>
  </table>

  <table id="wait-event-client-table">
<!-- pgdoc-cn_start sig_en=7ba84760e9610fcca059b9f6a8c3a6fa sig_cn_org=None source=14.1 
   <title>Wait Events of Type <literal>Client</literal></title>
________________________________________________________-->
   <title><literal>Client</literal>类型的等待事件</title>
<!-- pgdoc-cn_end sig_en=7ba84760e9610fcca059b9f6a8c3a6fa -->
   <tgroup cols="2">
    <thead>
<!-- pgdoc-cn_start sig_en=0ca4a4c999995c569a7a6ccd3f998210 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>Client</literal> Wait Event</entry>
      <entry>Description</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>Client</literal> 等待事件</entry>
      <entry>描述</entry>
     </row>
<!-- pgdoc-cn_end sig_en=0ca4a4c999995c569a7a6ccd3f998210 -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=045873c99b5c708b3a053212c987546a sig_cn_org=None source=14.1 
     <row>
      <entry><literal>ClientRead</literal></entry>
      <entry>Waiting to read data from the client.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ClientRead</literal></entry>
      <entry>等待从客户端读取数据。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=045873c99b5c708b3a053212c987546a -->
<!-- pgdoc-cn_start sig_en=654062716498f172c98b09b10a269e79 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>ClientWrite</literal></entry>
      <entry>Waiting to write data to the client.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ClientWrite</literal></entry>
      <entry>等待写入数据到客户端。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=654062716498f172c98b09b10a269e79 -->
<!-- pgdoc-cn_start sig_en=bf0d6cccff1699c46f077ac2da0df8f2 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>GSSOpenServer</literal></entry>
      <entry>Waiting to read data from the client while establishing a GSSAPI
       session.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>GSSOpenServer</literal></entry>
      <entry>在建立GSSAPI会话时等待从客户端读取数据。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=bf0d6cccff1699c46f077ac2da0df8f2 -->
<!-- pgdoc-cn_start sig_en=501857511e9311e7ce3313af739e4eeb sig_cn_org=None source=14.1 
     <row>
      <entry><literal>LibPQWalReceiverConnect</literal></entry>
      <entry>Waiting in WAL receiver to establish connection to remote
       server.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>LibPQWalReceiverConnect</literal></entry>
      <entry>在WAL接收器等待与远程服务器建立连接。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=501857511e9311e7ce3313af739e4eeb -->
<!-- pgdoc-cn_start sig_en=65e77990d4fdd042f2a59f8e196cd278 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>LibPQWalReceiverReceive</literal></entry>
      <entry>Waiting in WAL receiver to receive data from remote server.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>LibPQWalReceiverReceive</literal></entry>
      <entry>在WAL接收器中等待从远程服务器接收数据。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=65e77990d4fdd042f2a59f8e196cd278 -->
<!-- pgdoc-cn_start sig_en=8148801577bf18fe1727782aac15a3f0 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>SSLOpenServer</literal></entry>
      <entry>Waiting for SSL while attempting connection.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>SSLOpenServer</literal></entry>
      <entry>在尝试连接时等待SSL。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=8148801577bf18fe1727782aac15a3f0 -->
<!-- pgdoc-cn_start sig_en=3b4e286da367823a50e8558c1113e5c1 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>WalSenderWaitForWAL</literal></entry>
      <entry>Waiting for WAL to be flushed in WAL sender process.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>WalSenderWaitForWAL</literal></entry>
      <entry>在WAL发送器进程中等待WAL被刷新。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=3b4e286da367823a50e8558c1113e5c1 -->
<!-- pgdoc-cn_start sig_en=e1a34784d372c7c00c24eaead1e65dcc sig_cn_org=None source=14.1 
     <row>
      <entry><literal>WalSenderWriteData</literal></entry>
      <entry>Waiting for any activity when processing replies from WAL
       receiver in WAL sender process.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>WalSenderWriteData</literal></entry>
      <entry>在WAL发送器进程中处理WAL接收器的回复时，等待任何活动。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=e1a34784d372c7c00c24eaead1e65dcc -->
    </tbody>
   </tgroup>
  </table>

  <table id="wait-event-extension-table">
<!-- pgdoc-cn_start sig_en=d8dd9833386268f52a1475a11076ec1e sig_cn_org=None source=14.1 
   <title>Wait Events of Type <literal>Extension</literal></title>
________________________________________________________-->
   <title><literal>Extension</literal>类型的等待事件</title>
<!-- pgdoc-cn_end sig_en=d8dd9833386268f52a1475a11076ec1e -->
   <tgroup cols="2">
    <thead>
<!-- pgdoc-cn_start sig_en=3e313a39640b6c9f1df230d25758ed17 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>Extension</literal> Wait Event</entry>
      <entry>Description</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>Extension</literal> 等待事件</entry>
      <entry>描述</entry>
     </row>
<!-- pgdoc-cn_end sig_en=3e313a39640b6c9f1df230d25758ed17 -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=fd3c9e7512ec0a55641ae1b1223ed463 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>Extension</literal></entry>
      <entry>Waiting in an extension.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>Extension</literal></entry>
      <entry>在扩展中等待。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=fd3c9e7512ec0a55641ae1b1223ed463 -->
    </tbody>
   </tgroup>
  </table>

  <table id="wait-event-io-table">
<!-- pgdoc-cn_start sig_en=415346c6317f934dcab7c83e286308a5 sig_cn_org=None source=14.1 
   <title>Wait Events of Type <literal>IO</literal></title>
________________________________________________________-->
   <title><literal>IO</literal>类型的等待事件</title>
<!-- pgdoc-cn_end sig_en=415346c6317f934dcab7c83e286308a5 -->
   <tgroup cols="2">
    <thead>
<!-- pgdoc-cn_start sig_en=a5a61252affcc11ab49a47076c8815e3 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>IO</literal> Wait Event</entry>
      <entry>Description</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>IO</literal> 等待事件</entry>
      <entry>描述</entry>
     </row>
<!-- pgdoc-cn_end sig_en=a5a61252affcc11ab49a47076c8815e3 -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=ec84adc5834658d370d124fce268d3e5 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>BaseBackupRead</literal></entry>
      <entry>Waiting for base backup to read from a file.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>BaseBackupRead</literal></entry>
      <entry>等待基础备份从文件中读取。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=ec84adc5834658d370d124fce268d3e5 -->
<!-- pgdoc-cn_start sig_en=014dbe6fd1211979ea499935d70bdb10 sig_cn_org=21e2dbef8ea9ab4f5d46db8a32e675eb source=15.7 
     <row>
      <entry><literal>BaseBackupSync</literal></entry>
      <entry>Waiting for data written by a base backup to reach durable storage.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>BaseBackupSync</literal></entry>
      <entry>等待由基本备份写入的数据达到持久存储。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=014dbe6fd1211979ea499935d70bdb10 -->
<!-- pgdoc-cn_start sig_en=59d24fb9650ac15882f8cfa928c581ef sig_cn_org=9bfd290cf7bf544994a471c212fe2a58 source=15.7 
     <row>
      <entry><literal>BaseBackupWrite</literal></entry>
      <entry>Waiting for base backup to write to a file.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>BaseBackupWrite</literal></entry>
      <entry>等待基本备份写入文件。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=59d24fb9650ac15882f8cfa928c581ef -->
<!-- pgdoc-cn_start sig_en=5d0c041ddd3172cc6b76b06684fbbc6f sig_cn_org=None source=14.1 
     <row>
      <entry><literal>BufFileRead</literal></entry>
      <entry>Waiting for a read from a buffered file.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>BufFileRead</literal></entry>
      <entry>等待从缓冲文件中读取。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=5d0c041ddd3172cc6b76b06684fbbc6f -->
<!-- pgdoc-cn_start sig_en=26b71f742833834da26f6feee7979b11 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>BufFileWrite</literal></entry>
      <entry>Waiting for a write to a buffered file.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>BufFileWrite</literal></entry>
      <entry>等待对缓冲文件的写入。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=26b71f742833834da26f6feee7979b11 -->
<!-- pgdoc-cn_start sig_en=09014a551f2ea0c5c6c4abbc03bd4ea2 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>BufFileTruncate</literal></entry>
      <entry>Waiting for a buffered file to be truncated.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>BufFileTruncate</literal></entry>
      <entry>等待一个缓冲文件被截断。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=09014a551f2ea0c5c6c4abbc03bd4ea2 -->
<!-- pgdoc-cn_start sig_en=6438f496c82ede374c69df5d3071e9d1 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>ControlFileRead</literal></entry>
      <entry>Waiting for a read from the <filename>pg_control</filename>
       file.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ControlFileRead</literal></entry>
      <entry>等待读取<filename>pg_control</filename>文件。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=6438f496c82ede374c69df5d3071e9d1 -->
<!-- pgdoc-cn_start sig_en=cdc2875118126664ec9d5e459265b9a1 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>ControlFileSync</literal></entry>
      <entry>Waiting for the <filename>pg_control</filename> file to reach
       durable storage.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ControlFileSync</literal></entry>
      <entry>等待<filename>pg_control</filename>文件到达持久存储。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=cdc2875118126664ec9d5e459265b9a1 -->
<!-- pgdoc-cn_start sig_en=78bea44befa17f73e0b1c7bde27a767c sig_cn_org=None source=14.1 
     <row>
      <entry><literal>ControlFileSyncUpdate</literal></entry>
      <entry>Waiting for an update to the <filename>pg_control</filename> file
       to reach durable storage.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ControlFileSyncUpdate</literal></entry>
      <entry>等待更新<filename>pg_control</filename>文件以达到持久存储。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=78bea44befa17f73e0b1c7bde27a767c -->
<!-- pgdoc-cn_start sig_en=08213e467880dc1116a496a7ce40ff82 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>ControlFileWrite</literal></entry>
      <entry>Waiting for a write to the <filename>pg_control</filename>
       file.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ControlFileWrite</literal></entry>
      <entry>等待写入<filename>pg_control</filename>文件。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=08213e467880dc1116a496a7ce40ff82 -->
<!-- pgdoc-cn_start sig_en=e54d9a4f20e64147bb776f8276700504 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>ControlFileWriteUpdate</literal></entry>
      <entry>Waiting for a write to update the <filename>pg_control</filename>
       file.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ControlFileWriteUpdate</literal></entry>
      <entry>等待写入更新<filename>pg_control</filename>文件。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=e54d9a4f20e64147bb776f8276700504 -->
<!-- pgdoc-cn_start sig_en=b28ee35fe6944494f0e11729bda769f7 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>CopyFileRead</literal></entry>
      <entry>Waiting for a read during a file copy operation.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>CopyFileRead</literal></entry>
      <entry>在文件复制操作期间等待读取。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=b28ee35fe6944494f0e11729bda769f7 -->
<!-- pgdoc-cn_start sig_en=a5dedca27c24026b02b3ec3f3c57798f sig_cn_org=None source=14.1 
     <row>
      <entry><literal>CopyFileWrite</literal></entry>
      <entry>Waiting for a write during a file copy operation.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>CopyFileWrite</literal></entry>
      <entry>在文件拷贝操作期间等待写入。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=a5dedca27c24026b02b3ec3f3c57798f -->
<!-- pgdoc-cn_start sig_en=1fc17d3e1cac3c10810379ad7b1124ca sig_cn_org=None source=14.1 
     <row>
      <entry><literal>DSMFillZeroWrite</literal></entry>
      <entry>Waiting to fill a dynamic shared memory backing file with
       zeroes.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>DSMFillZeroWrite</literal></entry>
      <entry>等待用零填充动态共享内存备份(backing)文件。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=1fc17d3e1cac3c10810379ad7b1124ca -->
<!-- pgdoc-cn_start sig_en=b489ebc64615dd693aaec8679ab74a67 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>DataFileExtend</literal></entry>
      <entry>Waiting for a relation data file to be extended.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>DataFileExtend</literal></entry>
      <entry>等待关系数据文件被扩展。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=b489ebc64615dd693aaec8679ab74a67 -->
<!-- pgdoc-cn_start sig_en=f6d3d1d7f4fb7e8d3755d006ecaef658 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>DataFileFlush</literal></entry>
      <entry>Waiting for a relation data file to reach durable storage.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>DataFileFlush</literal></entry>
      <entry>等待关系数据文件达到持久存储。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=f6d3d1d7f4fb7e8d3755d006ecaef658 -->
<!-- pgdoc-cn_start sig_en=cc40f4c2c626795341c5b99f535fcc8a sig_cn_org=None source=14.1 
     <row>
      <entry><literal>DataFileImmediateSync</literal></entry>
      <entry>Waiting for an immediate synchronization of a relation data file to
       durable storage.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>DataFileImmediateSync</literal></entry>
      <entry>等待关系数据文件到持久存储的立即同步。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=cc40f4c2c626795341c5b99f535fcc8a -->
<!-- pgdoc-cn_start sig_en=9c0fe117742b18edb9aadc52a4357dcf sig_cn_org=None source=14.1 
     <row>
      <entry><literal>DataFilePrefetch</literal></entry>
      <entry>Waiting for an asynchronous prefetch from a relation data
       file.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>DataFilePrefetch</literal></entry>
      <entry>等待关系数据文件的异步预取。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=9c0fe117742b18edb9aadc52a4357dcf -->
<!-- pgdoc-cn_start sig_en=d8d8e6644c48ee4a266766409cb9aa7c sig_cn_org=None source=14.1 
     <row>
      <entry><literal>DataFileRead</literal></entry>
      <entry>Waiting for a read from a relation data file.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>DataFileRead</literal></entry>
      <entry>等待对关系数据文件的读取。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=d8d8e6644c48ee4a266766409cb9aa7c -->
<!-- pgdoc-cn_start sig_en=0d9b205ce7861c3268410b501dbd5f06 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>DataFileSync</literal></entry>
      <entry>Waiting for changes to a relation data file to reach durable storage.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>DataFileSync</literal></entry>
      <entry>等待对关系数据文件的更改达到持久存储。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=0d9b205ce7861c3268410b501dbd5f06 -->
<!-- pgdoc-cn_start sig_en=c1e2f415f46de058c617d5ff0ae1548f sig_cn_org=None source=14.1 
     <row>
      <entry><literal>DataFileTruncate</literal></entry>
      <entry>Waiting for a relation data file to be truncated.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>DataFileTruncate</literal></entry>
      <entry>等待关系数据文件被截断。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=c1e2f415f46de058c617d5ff0ae1548f -->
<!-- pgdoc-cn_start sig_en=499bcb4718b622a9652190fd87ddc651 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>DataFileWrite</literal></entry>
      <entry>Waiting for a write to a relation data file.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>DataFileWrite</literal></entry>
      <entry>等待对关系数据文件的写入。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=499bcb4718b622a9652190fd87ddc651 -->
<!-- pgdoc-cn_start sig_en=3e22461ae7b52e2f16326b083bc08121 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>LockFileAddToDataDirRead</literal></entry>
      <entry>Waiting for a read while adding a line to the data directory lock
       file.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>LockFileAddToDataDirRead</literal></entry>
      <entry>在向数据目录锁文件中添加一行时等待读取。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=3e22461ae7b52e2f16326b083bc08121 -->
<!-- pgdoc-cn_start sig_en=5ac1f1b5ee899cbdcf95756e9f41b840 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>LockFileAddToDataDirSync</literal></entry>
      <entry>Waiting for data to reach durable storage while adding a line to the
       data directory lock file.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>LockFileAddToDataDirSync</literal></entry>
      <entry>等待数据到达持久存储，同时向数据目录锁文件添加一行。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=5ac1f1b5ee899cbdcf95756e9f41b840 -->
<!-- pgdoc-cn_start sig_en=6837a5768534341d018fcabe97003f90 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>LockFileAddToDataDirWrite</literal></entry>
      <entry>Waiting for a write while adding a line to the data directory
       lock file.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>LockFileAddToDataDirWrite</literal></entry>
      <entry>在向数据目录锁文件中添加一行时等待写操作。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=6837a5768534341d018fcabe97003f90 -->
<!-- pgdoc-cn_start sig_en=40a15707093efe256e87f30f869c9269 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>LockFileCreateRead</literal></entry>
      <entry>Waiting to read while creating the data directory lock
       file.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>LockFileCreateRead</literal></entry>
      <entry>创建数据目录锁文件时等待读取。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=40a15707093efe256e87f30f869c9269 -->
<!-- pgdoc-cn_start sig_en=394ee6158e5a4e48312ccc45b29ecee2 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>LockFileCreateSync</literal></entry>
      <entry>Waiting for data to reach durable storage while creating the data
       directory lock file.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>LockFileCreateSync</literal></entry>
      <entry>在创建数据目录锁文件时等待数据到达持久存储。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=394ee6158e5a4e48312ccc45b29ecee2 -->
<!-- pgdoc-cn_start sig_en=5fcfc465e1dd899906e2e1d7649ae7a6 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>LockFileCreateWrite</literal></entry>
      <entry>Waiting for a write while creating the data directory lock
       file.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>LockFileCreateWrite</literal></entry>
      <entry>在创建数据目录锁文件时等待写操作。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=5fcfc465e1dd899906e2e1d7649ae7a6 -->
<!-- pgdoc-cn_start sig_en=a1af10d92a26800629c1eb8c54fc6295 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>LockFileReCheckDataDirRead</literal></entry>
      <entry>Waiting for a read during recheck of the data directory lock
       file.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>LockFileReCheckDataDirRead</literal></entry>
      <entry>在重新检查数据目录锁文件期间等待读取。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=a1af10d92a26800629c1eb8c54fc6295 -->
<!-- pgdoc-cn_start sig_en=65e015a6f7e843e03c8e2eb6adeb6825 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>LogicalRewriteCheckpointSync</literal></entry>
      <entry>Waiting for logical rewrite mappings to reach durable storage
       during a checkpoint.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>LogicalRewriteCheckpointSync</literal></entry>
      <entry>等待逻辑重写映射到在检查点到达持久存储。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=65e015a6f7e843e03c8e2eb6adeb6825 -->
<!-- pgdoc-cn_start sig_en=ce179459e85b5b7db4dfc039dbf0f931 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>LogicalRewriteMappingSync</literal></entry>
      <entry>Waiting for mapping data to reach durable storage during a logical
       rewrite.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>LogicalRewriteMappingSync</literal></entry>
      <entry>在逻辑重写期间等待映射数据到达持久存储</entry>
     </row>
<!-- pgdoc-cn_end sig_en=ce179459e85b5b7db4dfc039dbf0f931 -->
<!-- pgdoc-cn_start sig_en=b6111a73ba26109587226b98b07c2e03 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>LogicalRewriteMappingWrite</literal></entry>
      <entry>Waiting for a write of mapping data during a logical
       rewrite.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>LogicalRewriteMappingWrite</literal></entry>
      <entry>在逻辑重写期间等待映射数据的写入。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=b6111a73ba26109587226b98b07c2e03 -->
<!-- pgdoc-cn_start sig_en=867b5cc3aaa24bb486db2f2746a956d9 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>LogicalRewriteSync</literal></entry>
      <entry>Waiting for logical rewrite mappings to reach durable
       storage.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>LogicalRewriteSync</literal></entry>
      <entry>等待逻辑重写映射到达持久存储。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=867b5cc3aaa24bb486db2f2746a956d9 -->
<!-- pgdoc-cn_start sig_en=ba8553ba16e12d24e6e3b4ee0439ced9 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>LogicalRewriteTruncate</literal></entry>
      <entry>Waiting for truncate of mapping data during a logical
       rewrite.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>LogicalRewriteTruncate</literal></entry>
      <entry>等待在逻辑重写期间截断映射数据。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=ba8553ba16e12d24e6e3b4ee0439ced9 -->
<!-- pgdoc-cn_start sig_en=22c958e7d3d29190f8b0034b63c478cd sig_cn_org=None source=14.1 
     <row>
      <entry><literal>LogicalRewriteWrite</literal></entry>
      <entry>Waiting for a write of logical rewrite mappings.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>LogicalRewriteWrite</literal></entry>
      <entry>等待逻辑重写映射的写入。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=22c958e7d3d29190f8b0034b63c478cd -->
<!-- pgdoc-cn_start sig_en=71914057c5db13034ee038ff37ad6d44 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>RelationMapRead</literal></entry>
      <entry>Waiting for a read of the relation map file.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>RelationMapRead</literal></entry>
      <entry>等待关系映射文件的读取。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=71914057c5db13034ee038ff37ad6d44 -->
<!-- pgdoc-cn_start sig_en=63f99d902360c304a65efd18f21c2b3a sig_cn_org=None source=14.1 
     <row>
      <entry><literal>RelationMapSync</literal></entry>
      <entry>Waiting for the relation map file to reach durable storage.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>RelationMapSync</literal></entry>
      <entry>等待关系映射文件到达持久存储。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=63f99d902360c304a65efd18f21c2b3a -->
<!-- pgdoc-cn_start sig_en=cf0a92f1a4e770494a16f90c8c4755c1 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>RelationMapWrite</literal></entry>
      <entry>Waiting for a write to the relation map file.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>RelationMapWrite</literal></entry>
      <entry>等待对关系映射文件的写入。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=cf0a92f1a4e770494a16f90c8c4755c1 -->
<!-- pgdoc-cn_start sig_en=524d75b8a943b77f5afd8ddfc0d38b22 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>ReorderBufferRead</literal></entry>
      <entry>Waiting for a read during reorder buffer management.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ReorderBufferRead</literal></entry>
      <entry>在重新排序缓冲区管理期间等待读取。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=524d75b8a943b77f5afd8ddfc0d38b22 -->
<!-- pgdoc-cn_start sig_en=70ab81d28e0f6efeeedf7ca383e639bc sig_cn_org=None source=14.1 
     <row>
      <entry><literal>ReorderBufferWrite</literal></entry>
      <entry>Waiting for a write during reorder buffer management.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ReorderBufferWrite</literal></entry>
      <entry>在重新排序缓冲区管理期间等待写操作。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=70ab81d28e0f6efeeedf7ca383e639bc -->
<!-- pgdoc-cn_start sig_en=a4eae405352851a7032e150afda6ec34 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>ReorderLogicalMappingRead</literal></entry>
      <entry>Waiting for a read of a logical mapping during reorder buffer
       management.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ReorderLogicalMappingRead</literal></entry>
      <entry>在重新排序缓冲区管理期间等待读取逻辑映射。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=a4eae405352851a7032e150afda6ec34 -->
<!-- pgdoc-cn_start sig_en=1e8d0547ea33812f507dc12255cfe2ad sig_cn_org=None source=14.1 
     <row>
      <entry><literal>ReplicationSlotRead</literal></entry>
      <entry>Waiting for a read from a replication slot control file.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ReplicationSlotRead</literal></entry>
      <entry>等待从复制槽位控制文件读取。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=1e8d0547ea33812f507dc12255cfe2ad -->
<!-- pgdoc-cn_start sig_en=eb9cf0445f68d61aa1ca3f8e254b84ad sig_cn_org=None source=14.1 
     <row>
      <entry><literal>ReplicationSlotRestoreSync</literal></entry>
      <entry>Waiting for a replication slot control file to reach durable storage
       while restoring it to memory.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ReplicationSlotRestoreSync</literal></entry>
      <entry>等待复制槽控制文件到达持久存储，同时将其恢复到内存中。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=eb9cf0445f68d61aa1ca3f8e254b84ad -->
<!-- pgdoc-cn_start sig_en=e8c0f320b17f3aaf71f0449e89dbbf0e sig_cn_org=None source=14.1 
     <row>
      <entry><literal>ReplicationSlotSync</literal></entry>
      <entry>Waiting for a replication slot control file to reach durable
       storage.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ReplicationSlotSync</literal></entry>
      <entry>等待复制槽控制文件到达持久存储。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=e8c0f320b17f3aaf71f0449e89dbbf0e -->
<!-- pgdoc-cn_start sig_en=4e772c4d0a5f60a9612f426c27cc7f4e sig_cn_org=None source=14.1 
     <row>
      <entry><literal>ReplicationSlotWrite</literal></entry>
      <entry>Waiting for a write to a replication slot control file.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ReplicationSlotWrite</literal></entry>
      <entry>等待对复制槽控制文件的写入。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=4e772c4d0a5f60a9612f426c27cc7f4e -->
<!-- pgdoc-cn_start sig_en=5c58bc45148c9c4dcb79d5826d7bd4bc sig_cn_org=None source=14.1 
     <row>
      <entry><literal>SLRUFlushSync</literal></entry>
      <entry>Waiting for SLRU data to reach durable storage during a checkpoint
       or database shutdown.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>SLRUFlushSync</literal></entry>
      <entry>在检查点或数据库关闭期间等待SLRU数据到达持久存储。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=5c58bc45148c9c4dcb79d5826d7bd4bc -->
<!-- pgdoc-cn_start sig_en=4f70c8bc70db196f68bbe2e55be13aef sig_cn_org=None source=14.1 
     <row>
      <entry><literal>SLRURead</literal></entry>
      <entry>Waiting for a read of an SLRU page.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>SLRURead</literal></entry>
      <entry>等待读取SLRU页面。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=4f70c8bc70db196f68bbe2e55be13aef -->
<!-- pgdoc-cn_start sig_en=b1101b8e14837bc7c5575d172267acf1 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>SLRUSync</literal></entry>
      <entry>Waiting for SLRU data to reach durable storage following a page
       write.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>SLRUSync</literal></entry>
      <entry>在写页面后等待SLRU数据到达持久存储。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=b1101b8e14837bc7c5575d172267acf1 -->
<!-- pgdoc-cn_start sig_en=f383a61ded9ff47e1896e7cb7d8929f5 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>SLRUWrite</literal></entry>
      <entry>Waiting for a write of an SLRU page.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>SLRUWrite</literal></entry>
      <entry>等待SLRU页面的写入。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=f383a61ded9ff47e1896e7cb7d8929f5 -->
<!-- pgdoc-cn_start sig_en=5ef7f2b1bfcfa6e37553f060e1610c44 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>SnapbuildRead</literal></entry>
      <entry>Waiting for a read of a serialized historical catalog
       snapshot.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>SnapbuildRead</literal></entry>
      <entry>等待读取序列化的历史目录快照。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=5ef7f2b1bfcfa6e37553f060e1610c44 -->
<!-- pgdoc-cn_start sig_en=ffaaa4cd252bdfec50992db6316cd7c3 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>SnapbuildSync</literal></entry>
      <entry>Waiting for a serialized historical catalog snapshot to reach
       durable storage.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>SnapbuildSync</literal></entry>
      <entry>等待序列化历史目录快照到达持久存储。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=ffaaa4cd252bdfec50992db6316cd7c3 -->
<!-- pgdoc-cn_start sig_en=a08f49f8caec71af801bdfd8af9e1459 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>SnapbuildWrite</literal></entry>
      <entry>Waiting for a write of a serialized historical catalog
       snapshot.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>SnapbuildWrite</literal></entry>
      <entry>等待串行历史目录快照的写入。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=a08f49f8caec71af801bdfd8af9e1459 -->
<!-- pgdoc-cn_start sig_en=cb96d18e897a3b108e6a3e222fcb347a sig_cn_org=None source=14.1 
     <row>
      <entry><literal>TimelineHistoryFileSync</literal></entry>
      <entry>Waiting for a timeline history file received via streaming
       replication to reach durable storage.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>TimelineHistoryFileSync</literal></entry>
      <entry>等待通过流复制接收的时间线历史文件到达持久存储。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=cb96d18e897a3b108e6a3e222fcb347a -->
<!-- pgdoc-cn_start sig_en=6be469a349badf74427576c4e7a44c90 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>TimelineHistoryFileWrite</literal></entry>
      <entry>Waiting for a write of a timeline history file received via
       streaming replication.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>TimelineHistoryFileWrite</literal></entry>
      <entry>等待通过流复制接收的时间线历史文件的写入。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=6be469a349badf74427576c4e7a44c90 -->
<!-- pgdoc-cn_start sig_en=180b620599157d009088e5409e0a07d5 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>TimelineHistoryRead</literal></entry>
      <entry>Waiting for a read of a timeline history file.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>TimelineHistoryRead</literal></entry>
      <entry>等待读取时间线历史文件。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=180b620599157d009088e5409e0a07d5 -->
<!-- pgdoc-cn_start sig_en=237ffc79f8b5a99ca05091e3c034450e sig_cn_org=None source=14.1 
     <row>
      <entry><literal>TimelineHistorySync</literal></entry>
      <entry>Waiting for a newly created timeline history file to reach durable
       storage.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>TimelineHistorySync</literal></entry>
      <entry>等待新创建的时间线历史文件到达持久存储。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=237ffc79f8b5a99ca05091e3c034450e -->
<!-- pgdoc-cn_start sig_en=8d0b08af12fec165e9bc095c445e8c99 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>TimelineHistoryWrite</literal></entry>
      <entry>Waiting for a write of a newly created timeline history
       file.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>TimelineHistoryWrite</literal></entry>
      <entry>等待写入新创建的时间线历史文件。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=8d0b08af12fec165e9bc095c445e8c99 -->
<!-- pgdoc-cn_start sig_en=e77fc87b82a85e9fb536b9e2c57c31d5 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>TwophaseFileRead</literal></entry>
      <entry>Waiting for a read of a two phase state file.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>TwophaseFileRead</literal></entry>
      <entry>等待读取两阶段状态文件。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=e77fc87b82a85e9fb536b9e2c57c31d5 -->
<!-- pgdoc-cn_start sig_en=74d4de2b8f19516986876dd4de470451 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>TwophaseFileSync</literal></entry>
      <entry>Waiting for a two phase state file to reach durable storage.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>TwophaseFileSync</literal></entry>
      <entry>等待两阶段状态文件到达持久存储。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=74d4de2b8f19516986876dd4de470451 -->
<!-- pgdoc-cn_start sig_en=1815fc69a447857692b5b98095f5a2e5 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>TwophaseFileWrite</literal></entry>
      <entry>Waiting for a write of a two phase state file.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>TwophaseFileWrite</literal></entry>
      <entry>等待对两阶段状态文件的写入。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=1815fc69a447857692b5b98095f5a2e5 -->
<!-- pgdoc-cn_start sig_en=715ec7b9ba120712c2c9b71b78113528 sig_cn_org=b8c2547a7128c836542b68eb008e60c8 source=15.7 
     <row>
      <entry><literal>VersionFileSync</literal></entry>
      <entry>Waiting for the version file to reach durable storage while
       creating a database.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>VersionFileSync</literal></entry>
      <entry>等待版本文件达到持久存储，同时创建数据库。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=715ec7b9ba120712c2c9b71b78113528 -->
<!-- pgdoc-cn_start sig_en=1a2d13ba85e6b4b439dea452e61f6a55 sig_cn_org=04f778d560ff2eb701f65f9ed502cc5b source=15.7 
     <row>
      <entry><literal>VersionFileWrite</literal></entry>
      <entry>Waiting for the version file to be written while creating a database.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>VersionFileWrite</literal></entry>
      <entry>在创建数据库时等待版本文件被写入。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=1a2d13ba85e6b4b439dea452e61f6a55 -->
<!-- pgdoc-cn_start sig_en=8b664ee6f991627a8fe57d6b7ad8bb95 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>WALBootstrapSync</literal></entry>
      <entry>Waiting for WAL to reach durable storage during
       bootstrapping.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>WALBootstrapSync</literal></entry>
      <entry>在引导过程中等待WAL达到持久存储。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=8b664ee6f991627a8fe57d6b7ad8bb95 -->
<!-- pgdoc-cn_start sig_en=b94027c3456b443db0cc3a7e14ae6684 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>WALBootstrapWrite</literal></entry>
      <entry>Waiting for a write of a WAL page during bootstrapping.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>WALBootstrapWrite</literal></entry>
      <entry>在引导过程中等待WAL页面的写入。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=b94027c3456b443db0cc3a7e14ae6684 -->
<!-- pgdoc-cn_start sig_en=a3c204e7a4ceb157c7a40e2c009af0aa sig_cn_org=None source=14.1 
     <row>
      <entry><literal>WALCopyRead</literal></entry>
      <entry>Waiting for a read when creating a new WAL segment by copying an
       existing one.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>WALCopyRead</literal></entry>
      <entry>通过复制一个已有WAL段来创建一个新的WAL段时等待读取。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=a3c204e7a4ceb157c7a40e2c009af0aa -->
<!-- pgdoc-cn_start sig_en=7088a9e4a143dfdd1a10126e49f0c1ba sig_cn_org=None source=14.1 
     <row>
      <entry><literal>WALCopySync</literal></entry>
      <entry>Waiting for a new WAL segment created by copying an existing one to
       reach durable storage.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>WALCopySync</literal></entry>
      <entry>等待通过复制一个已有WAL段到持久存储来创建一个新的WAL段。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=7088a9e4a143dfdd1a10126e49f0c1ba -->
<!-- pgdoc-cn_start sig_en=fa620520bfabe1655727b99f4149880a sig_cn_org=None source=14.1 
     <row>
      <entry><literal>WALCopyWrite</literal></entry>
      <entry>Waiting for a write when creating a new WAL segment by copying an
       existing one.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>WALCopyWrite</literal></entry>
      <entry>通过复制一个已有WAL段来创建一个新的WAL段时等待写入。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=fa620520bfabe1655727b99f4149880a -->
<!-- pgdoc-cn_start sig_en=e7563a181177cb1f9cc51e9bf62b1377 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>WALInitSync</literal></entry>
      <entry>Waiting for a newly initialized WAL file to reach durable
       storage.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>WALInitSync</literal></entry>
      <entry>等待一个新初始化的WAL文件到持久存储。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=e7563a181177cb1f9cc51e9bf62b1377 -->
<!-- pgdoc-cn_start sig_en=1c5a6339a8970313675113dd0b564b82 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>WALInitWrite</literal></entry>
      <entry>Waiting for a write while initializing a new WAL file.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>WALInitWrite</literal></entry>
      <entry>在初始化一个新的WAL文件时等待写入。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=1c5a6339a8970313675113dd0b564b82 -->
<!-- pgdoc-cn_start sig_en=de19b18d6edb30cf05297b151a3eb6d8 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>WALRead</literal></entry>
      <entry>Waiting for a read from a WAL file.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>WALRead</literal></entry>
      <entry>等待WAL文件的读取。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=de19b18d6edb30cf05297b151a3eb6d8 -->
<!-- pgdoc-cn_start sig_en=bfb81db0af16b3bf3967e727f588e28e sig_cn_org=None source=14.1 
     <row>
      <entry><literal>WALSenderTimelineHistoryRead</literal></entry>
      <entry>Waiting for a read from a timeline history file during a walsender
       timeline command.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>WALSenderTimelineHistoryRead</literal></entry>
      <entry>在walsender时间线命令期间等待从时间线历史文件读取。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=bfb81db0af16b3bf3967e727f588e28e -->
<!-- pgdoc-cn_start sig_en=b9133ef8ef331a81835dd9043617636f sig_cn_org=None source=14.1 
     <row>
      <entry><literal>WALSync</literal></entry>
      <entry>Waiting for a WAL file to reach durable storage.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>WALSync</literal></entry>
      <entry>等待WAL文件到达持久存储。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=b9133ef8ef331a81835dd9043617636f -->
<!-- pgdoc-cn_start sig_en=916dd33d2418ef5072ddd303eec8ef6f sig_cn_org=None source=14.1 
     <row>
      <entry><literal>WALSyncMethodAssign</literal></entry>
      <entry>Waiting for data to reach durable storage while assigning a new
       WAL sync method.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>WALSyncMethodAssign</literal></entry>
      <entry>等待数据到达持久存储，同时分配一个新的WAL同步方法。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=916dd33d2418ef5072ddd303eec8ef6f -->
<!-- pgdoc-cn_start sig_en=4b71970cf743ad4befe448f6f66b408e sig_cn_org=None source=14.1 
     <row>
      <entry><literal>WALWrite</literal></entry>
      <entry>Waiting for a write to a WAL file.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>WALWrite</literal></entry>
      <entry>等待写入WAL文件。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=4b71970cf743ad4befe448f6f66b408e -->
    </tbody>
   </tgroup>
  </table>

  <table id="wait-event-ipc-table">
<!-- pgdoc-cn_start sig_en=bf274248bf7ab11ee25879c94eed1421 sig_cn_org=None source=14.1 
   <title>Wait Events of Type <literal>IPC</literal></title>
________________________________________________________-->
   <title><literal>IPC</literal>类型的等待事件</title>
<!-- pgdoc-cn_end sig_en=bf274248bf7ab11ee25879c94eed1421 -->
   <tgroup cols="2">
    <thead>
<!-- pgdoc-cn_start sig_en=1b0c052c129380830301199a4f654785 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>IPC</literal> Wait Event</entry>
      <entry>Description</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>IPC</literal> 等待事件</entry>
      <entry>描述</entry>
     </row>
<!-- pgdoc-cn_end sig_en=1b0c052c129380830301199a4f654785 -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=5f254d45e2a591559ad1af08e5eef035 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>AppendReady</literal></entry>
      <entry>Waiting for subplan nodes of an <literal>Append</literal> plan
       node to be ready.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>AppendReady</literal></entry>
      <entry>等待 <literal>Append</literal> 计划节点的子计划节点准备好。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=5f254d45e2a591559ad1af08e5eef035 -->
<!-- pgdoc-cn_start sig_en=854c16e448cedd94279237743e8ed64f sig_cn_org=d6da45a00c4417695cf006bd7826dddf source=15.7 
     <row>
      <entry><literal>ArchiveCleanupCommand</literal></entry>
      <entry>Waiting for <xref linkend="guc-archive-cleanup-command"/> to
       complete.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ArchiveCleanupCommand</literal></entry>
      <entry>等待<xref linkend="guc-archive-cleanup-command"/>完成。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=854c16e448cedd94279237743e8ed64f -->
<!-- pgdoc-cn_start sig_en=a41aed6e150e2d97307179028f1b2a66 sig_cn_org=ce6488db31c7cd1a3fe3720fe506846f source=15.7 
     <row>
      <entry><literal>ArchiveCommand</literal></entry>
      <entry>Waiting for <xref linkend="guc-archive-command"/> to
       complete.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ArchiveCommand</literal></entry>
      <entry>等待<xref linkend="guc-archive-command"/>完成。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=a41aed6e150e2d97307179028f1b2a66 -->
<!-- pgdoc-cn_start sig_en=282bd46ebcd98f0466adfb81b482ae9e sig_cn_org=None source=14.1 
     <row>
      <entry><literal>BackendTermination</literal></entry>
      <entry>Waiting for the termination of another backend.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>BackendTermination</literal></entry>
      <entry>等待另一个后端终止。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=282bd46ebcd98f0466adfb81b482ae9e -->
<!-- pgdoc-cn_start sig_en=da6de3bdba76d384de357df823a55076 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>BackupWaitWalArchive</literal></entry>
      <entry>Waiting for WAL files required for a backup to be successfully
       archived.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>BackupWaitWalArchive</literal></entry>
      <entry>等待备份所需的WAL文件成功存档。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=da6de3bdba76d384de357df823a55076 -->
<!-- pgdoc-cn_start sig_en=d3a299d9116b91aa4b90dc8462365fdf sig_cn_org=None source=14.1 
     <row>
      <entry><literal>BgWorkerShutdown</literal></entry>
      <entry>Waiting for background worker to shut down.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>BgWorkerShutdown</literal></entry>
      <entry>等待后台工作者关闭。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=d3a299d9116b91aa4b90dc8462365fdf -->
<!-- pgdoc-cn_start sig_en=97a5b2d0e06c01ed7711a5e43bb3e937 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>BgWorkerStartup</literal></entry>
      <entry>Waiting for background worker to start up.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>BgWorkerStartup</literal></entry>
      <entry>等待后台工作者启动。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=97a5b2d0e06c01ed7711a5e43bb3e937 -->
<!-- pgdoc-cn_start sig_en=f05b731cdf4bbba54975c5d056365b8e sig_cn_org=None source=14.1 
     <row>
      <entry><literal>BtreePage</literal></entry>
      <entry>Waiting for the page number needed to continue a parallel B-tree
       scan to become available.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>BtreePage</literal></entry>
      <entry>正等待继续并行B-树扫描所需的页号变得可用。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=f05b731cdf4bbba54975c5d056365b8e -->
<!-- pgdoc-cn_start sig_en=787a8ba354599ca915a7b38b4f3ecf05 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>BufferIO</literal></entry>
      <entry>Waiting for buffer I/O to complete.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>BufferIO</literal></entry>
      <entry>等待缓冲I/O结束。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=787a8ba354599ca915a7b38b4f3ecf05 -->
<!-- pgdoc-cn_start sig_en=0ce2a6019d7249eddc072b1c9cb7ead9 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>CheckpointDone</literal></entry>
      <entry>Waiting for a checkpoint to complete.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>CheckpointDone</literal></entry>
      <entry>等待检查点完成。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=0ce2a6019d7249eddc072b1c9cb7ead9 -->
<!-- pgdoc-cn_start sig_en=38893e94a5d1189514beeeda343afb92 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>CheckpointStart</literal></entry>
      <entry>Waiting for a checkpoint to start.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>CheckpointStart</literal></entry>
      <entry>等待检查点开始。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=38893e94a5d1189514beeeda343afb92 -->
<!-- pgdoc-cn_start sig_en=31551c4d0857a36f0cbec244a49f35a9 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>ExecuteGather</literal></entry>
      <entry>Waiting for activity from a child process while
       executing a <literal>Gather</literal> plan node.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ExecuteGather</literal></entry>
      <entry>在执行<literal>Gather</literal> 计划节点时，等待子进程的活动。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=31551c4d0857a36f0cbec244a49f35a9 -->
<!-- pgdoc-cn_start sig_en=be2db6ed0b37d0bb0640beb0ca422a3c sig_cn_org=None source=14.1 
     <row>
      <entry><literal>HashBatchAllocate</literal></entry>
      <entry>Waiting for an elected Parallel Hash participant to allocate a hash
       table.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>HashBatchAllocate</literal></entry>
      <entry>等待一个选定的并行哈希参与者分配哈希表。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=be2db6ed0b37d0bb0640beb0ca422a3c -->
<!-- pgdoc-cn_start sig_en=d640c9c32b2c88435de22beaa837f38c sig_cn_org=None source=14.1 
     <row>
      <entry><literal>HashBatchElect</literal></entry>
      <entry>Waiting to elect a Parallel Hash participant to allocate a hash
       table.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>HashBatchElect</literal></entry>
      <entry>等待选择一个并行哈希参与者来分配哈希表。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=d640c9c32b2c88435de22beaa837f38c -->
<!-- pgdoc-cn_start sig_en=8db1f1faf4f73d738cbaed5c014d428a sig_cn_org=None source=14.1 
     <row>
      <entry><literal>HashBatchLoad</literal></entry>
      <entry>Waiting for other Parallel Hash participants to finish loading a
       hash table.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>HashBatchLoad</literal></entry>
      <entry>等待其他并行哈希参与者完成哈希表的加载。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=8db1f1faf4f73d738cbaed5c014d428a -->
<!-- pgdoc-cn_start sig_en=b2c6f602013195c1408170919f1c3492 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>HashBuildAllocate</literal></entry>
      <entry>Waiting for an elected Parallel Hash participant to allocate the
       initial hash table.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>HashBuildAllocate</literal></entry>
      <entry>等待一个选定的并行哈希参与者分配初始哈希表。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=b2c6f602013195c1408170919f1c3492 -->
<!-- pgdoc-cn_start sig_en=0fe0102ccaf43637813293f9296a9101 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>HashBuildElect</literal></entry>
      <entry>Waiting to elect a Parallel Hash participant to allocate the
       initial hash table.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>HashBuildElect</literal></entry>
      <entry>等待选择一个并行哈希参与者来分配初始哈希表。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=0fe0102ccaf43637813293f9296a9101 -->
<!-- pgdoc-cn_start sig_en=727723f4c2d40e03351de3a9ffa9ae78 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>HashBuildHashInner</literal></entry>
      <entry>Waiting for other Parallel Hash participants to finish hashing the
       inner relation.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>HashBuildHashInner</literal></entry>
      <entry>等待其他并行哈希参与者完成内部关系的散列。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=727723f4c2d40e03351de3a9ffa9ae78 -->
<!-- pgdoc-cn_start sig_en=bcb6058b435f403efba39b95dde37859 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>HashBuildHashOuter</literal></entry>
      <entry>Waiting for other Parallel Hash participants to finish partitioning
       the outer relation.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>HashBuildHashOuter</literal></entry>
      <entry>等待其他Parallel 哈希参与者完成对外部关系的分区。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=bcb6058b435f403efba39b95dde37859 -->
<!-- pgdoc-cn_start sig_en=1949328c65db4d600ab67ac1bc7fc1ca sig_cn_org=None source=14.1 
     <row>
      <entry><literal>HashGrowBatchesAllocate</literal></entry>
      <entry>Waiting for an elected Parallel Hash participant to allocate more
       batches.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>HashGrowBatchesAllocate</literal></entry>
      <entry>等待选定的并行哈希参与者分配更多批处理。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=1949328c65db4d600ab67ac1bc7fc1ca -->
<!-- pgdoc-cn_start sig_en=9b91d71c117dfe534cf6d2a2c21ca303 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>HashGrowBatchesDecide</literal></entry>
      <entry>Waiting to elect a Parallel Hash participant to decide on future
       batch growth.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>HashGrowBatchesDecide</literal></entry>
      <entry>等待选择一个并行哈希参与者来决定未来的批处理增长。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=9b91d71c117dfe534cf6d2a2c21ca303 -->
<!-- pgdoc-cn_start sig_en=4f96cc7ce4ffee33b15efc54315c0c1e sig_cn_org=None source=14.1 
     <row>
      <entry><literal>HashGrowBatchesElect</literal></entry>
      <entry>Waiting to elect a Parallel Hash participant to allocate more
       batches.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>HashGrowBatchesElect</literal></entry>
      <entry>等待选择一个Parallel 哈希参与者来分配更多批处理。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=4f96cc7ce4ffee33b15efc54315c0c1e -->
<!-- pgdoc-cn_start sig_en=27677e6d664f7573b0cc47ff4ab8d3cf sig_cn_org=None source=14.1 
     <row>
      <entry><literal>HashGrowBatchesFinish</literal></entry>
      <entry>Waiting for an elected Parallel Hash participant to decide on
       future batch growth.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>HashGrowBatchesFinish</literal></entry>
      <entry>Waiting for an elected Parallel Hash participant to decide on
       future batch growth.</entry>
     </row>
<!-- pgdoc-cn_end sig_en=27677e6d664f7573b0cc47ff4ab8d3cf -->
<!-- pgdoc-cn_start sig_en=0ffe95cd5e02816ce014b977425c0710 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>HashGrowBatchesRepartition</literal></entry>
      <entry>Waiting for other Parallel Hash participants to finish
       repartitioning.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>HashGrowBatchesRepartition</literal></entry>
      <entry>等待一个选定的并行哈希参与者决定未来的批处理增长。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=0ffe95cd5e02816ce014b977425c0710 -->
<!-- pgdoc-cn_start sig_en=9efd1e4c026819093d425e71e9f0457c sig_cn_org=None source=14.1 
     <row>
      <entry><literal>HashGrowBucketsAllocate</literal></entry>
      <entry>Waiting for an elected Parallel Hash participant to finish
       allocating more buckets.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>HashGrowBucketsAllocate</literal></entry>
      <entry>等待选定的并行哈希参与者完成更多bucket的分配。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=9efd1e4c026819093d425e71e9f0457c -->
<!-- pgdoc-cn_start sig_en=203a67b9dd6de4f89585018c54192292 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>HashGrowBucketsElect</literal></entry>
      <entry>Waiting to elect a Parallel Hash participant to allocate more
       buckets.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>HashGrowBucketsElect</literal></entry>
      <entry>等待选择一个并行哈希参与者来分配更多的buckets。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=203a67b9dd6de4f89585018c54192292 -->
<!-- pgdoc-cn_start sig_en=9bd2a8e138b6c3d725a460f804dae360 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>HashGrowBucketsReinsert</literal></entry>
      <entry>Waiting for other Parallel Hash participants to finish inserting
       tuples into new buckets.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>HashGrowBucketsReinsert</literal></entry>
      <entry>等待其他Parallel 哈希参与者完成将元组插入到新buckets中。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=9bd2a8e138b6c3d725a460f804dae360 -->
<!-- pgdoc-cn_start sig_en=84189ce2b820a4b91e76dc7245fc57a5 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>LogicalSyncData</literal></entry>
      <entry>Waiting for a logical replication remote server to send data for
       initial table synchronization.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>LogicalSyncData</literal></entry>
      <entry>等待逻辑复制远程服务器发送用于初始表同步的数据。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=84189ce2b820a4b91e76dc7245fc57a5 -->
<!-- pgdoc-cn_start sig_en=766c5a900b2243a701a52087bd860aac sig_cn_org=None source=14.1 
     <row>
      <entry><literal>LogicalSyncStateChange</literal></entry>
      <entry>Waiting for a logical replication remote server to change
       state.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>LogicalSyncStateChange</literal></entry>
      <entry>等待逻辑复制远程服务器更改状态。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=766c5a900b2243a701a52087bd860aac -->
<!-- pgdoc-cn_start sig_en=12f71684395783356010970e6a892b57 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>MessageQueueInternal</literal></entry>
      <entry>Waiting for another process to be attached to a shared message
       queue.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>MessageQueueInternal</literal></entry>
      <entry>等待另一个进程附加到共享消息队列。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=12f71684395783356010970e6a892b57 -->
<!-- pgdoc-cn_start sig_en=d07f441708980b6a6f75d12a84f52445 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>MessageQueuePutMessage</literal></entry>
      <entry>Waiting to write a protocol message to a shared message queue.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>MessageQueuePutMessage</literal></entry>
      <entry>等待将协议消息写入共享消息队列。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=d07f441708980b6a6f75d12a84f52445 -->
<!-- pgdoc-cn_start sig_en=cc8015d0a46612c5e3213ec73d759019 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>MessageQueueReceive</literal></entry>
      <entry>Waiting to receive bytes from a shared message queue.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>MessageQueueReceive</literal></entry>
      <entry>等待从共享消息队列接收字节。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=cc8015d0a46612c5e3213ec73d759019 -->
<!-- pgdoc-cn_start sig_en=b631bd5527170d1bff573651d2103f36 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>MessageQueueSend</literal></entry>
      <entry>Waiting to send bytes to a shared message queue.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>MessageQueueSend</literal></entry>
      <entry>等待将字节发送到共享消息队列。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=b631bd5527170d1bff573651d2103f36 -->
<!-- pgdoc-cn_start sig_en=754606170411695bcd99c58c422e187f sig_cn_org=None source=14.1 
     <row>
      <entry><literal>ParallelBitmapScan</literal></entry>
      <entry>Waiting for parallel bitmap scan to become initialized.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ParallelBitmapScan</literal></entry>
      <entry>等待并行位图扫描被初始化。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=754606170411695bcd99c58c422e187f -->
<!-- pgdoc-cn_start sig_en=9ea752f9acbdcfd224138b5d57f4f7dc sig_cn_org=None source=14.1 
     <row>
      <entry><literal>ParallelCreateIndexScan</literal></entry>
      <entry>Waiting for parallel <command>CREATE INDEX</command> workers to
       finish heap scan.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ParallelCreateIndexScan</literal></entry>
      <entry>等待并行<command>CREATE INDEX</command> 工作者完成堆扫描。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=9ea752f9acbdcfd224138b5d57f4f7dc -->
<!-- pgdoc-cn_start sig_en=5ca08d377c45fe61c741b5bf857fc459 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>ParallelFinish</literal></entry>
      <entry>Waiting for parallel workers to finish computing.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ParallelFinish</literal></entry>
      <entry>等待并行工作人员完成计算。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=5ca08d377c45fe61c741b5bf857fc459 -->
<!-- pgdoc-cn_start sig_en=3447aebcf52e1ec65c7b6a52cb0174b9 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>ProcArrayGroupUpdate</literal></entry>
      <entry>Waiting for the group leader to clear the transaction ID at
       end of a parallel operation.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ProcArrayGroupUpdate</literal></entry>
      <entry>等待组领导在并行操作结束时清除事务ID。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=3447aebcf52e1ec65c7b6a52cb0174b9 -->
<!-- pgdoc-cn_start sig_en=fe71f863c953184869249e20c8610516 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>ProcSignalBarrier</literal></entry>
      <entry>Waiting for a barrier event to be processed by all
       backends.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ProcSignalBarrier</literal></entry>
      <entry>等待屏障事件被所有后端处理。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=fe71f863c953184869249e20c8610516 -->
<!-- pgdoc-cn_start sig_en=ba15e468fa65c9886d542ccc2c5a0f0a sig_cn_org=None source=14.1 
     <row>
      <entry><literal>Promote</literal></entry>
      <entry>Waiting for standby promotion.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>Promote</literal></entry>
      <entry>等待备用系统提升。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=ba15e468fa65c9886d542ccc2c5a0f0a -->
<!-- pgdoc-cn_start sig_en=335770b0da4fc2ae36e3c8bd45e46d18 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>RecoveryConflictSnapshot</literal></entry>
      <entry>Waiting for recovery conflict resolution for a vacuum
       cleanup.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>RecoveryConflictSnapshot</literal></entry>
      <entry>等待vacuum清理的恢复冲突解决。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=335770b0da4fc2ae36e3c8bd45e46d18 -->
<!-- pgdoc-cn_start sig_en=850999a0818dd5d45d1486546f3778cf sig_cn_org=None source=14.1 
     <row>
      <entry><literal>RecoveryConflictTablespace</literal></entry>
      <entry>Waiting for recovery conflict resolution for dropping a
       tablespace.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>RecoveryConflictTablespace</literal></entry>
      <entry>等待恢复冲突解决删除表空间。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=850999a0818dd5d45d1486546f3778cf -->
<!-- pgdoc-cn_start sig_en=e5c58130270d2aa01a9654e8b0a2e77b sig_cn_org=424d44b3ab7f73a334727f05ca8404cd source=15.7 
     <row>
      <entry><literal>RecoveryEndCommand</literal></entry>
      <entry>Waiting for <xref linkend="guc-recovery-end-command"/> to
       complete.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>RecoveryEndCommand</literal></entry>
      <entry>等待<xref linkend="guc-recovery-end-command"/>完成。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=e5c58130270d2aa01a9654e8b0a2e77b -->
<!-- pgdoc-cn_start sig_en=28d20625c4e3ad2d6cdbb0b93169409d sig_cn_org=None source=14.1 
     <row>
      <entry><literal>RecoveryPause</literal></entry>
      <entry>Waiting for recovery to be resumed.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>RecoveryPause</literal></entry>
      <entry>等待恢复继续进行。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=28d20625c4e3ad2d6cdbb0b93169409d -->
<!-- pgdoc-cn_start sig_en=986cf2237292553ffed40dd63a0e7f12 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>ReplicationOriginDrop</literal></entry>
      <entry>Waiting for a replication origin to become inactive so it can be
       dropped.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ReplicationOriginDrop</literal></entry>
      <entry>等待复制源变为非活动状态，以便可以删除它。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=986cf2237292553ffed40dd63a0e7f12 -->
<!-- pgdoc-cn_start sig_en=ce508a2c69d8de1ef8f0be379285d859 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>ReplicationSlotDrop</literal></entry>
      <entry>Waiting for a replication slot to become inactive so it can be
       dropped.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ReplicationSlotDrop</literal></entry>
      <entry>等待复制槽变为非活动状态，以便可以删除它。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=ce508a2c69d8de1ef8f0be379285d859 -->
<!-- pgdoc-cn_start sig_en=3873f8c0f8c52a76d527def252d53867 sig_cn_org=6bde2df19e73d673224bfbc188629316 source=15.7 
     <row>
      <entry><literal>RestoreCommand</literal></entry>
      <entry>Waiting for <xref linkend="guc-restore-command"/> to
       complete.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>RestoreCommand</literal></entry>
      <entry>等待<xref linkend="guc-restore-command"/>完成。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=3873f8c0f8c52a76d527def252d53867 -->
<!-- pgdoc-cn_start sig_en=c3cba8b33e4b27c4c47300676d7c039d sig_cn_org=None source=14.1 
     <row>
      <entry><literal>SafeSnapshot</literal></entry>
      <entry>Waiting to obtain a valid snapshot for a <literal>READ ONLY
       DEFERRABLE</literal> transaction.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>SafeSnapshot</literal></entry>
      <entry>等待获取<literal>READ ONLY DEFERRABLE</literal>事务的有效快照。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=c3cba8b33e4b27c4c47300676d7c039d -->
<!-- pgdoc-cn_start sig_en=b79f9e9c411027284bcd322b6552ea3f sig_cn_org=None source=14.1 
     <row>
      <entry><literal>SyncRep</literal></entry>
      <entry>Waiting for confirmation from a remote server during synchronous
       replication.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>SyncRep</literal></entry>
      <entry>在同步复制期间等待远程服务器的确认。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=b79f9e9c411027284bcd322b6552ea3f -->
<!-- pgdoc-cn_start sig_en=6d3c319620772861a845b7d6ef9d8bcf sig_cn_org=None source=14.1 
     <row>
      <entry><literal>WalReceiverExit</literal></entry>
      <entry>Waiting for the WAL receiver to exit.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>WalReceiverExit</literal></entry>
      <entry>等待WAL接收器退出。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=6d3c319620772861a845b7d6ef9d8bcf -->
<!-- pgdoc-cn_start sig_en=3b93fdee849e4d1016b0f561ad6ad746 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>WalReceiverWaitStart</literal></entry>
      <entry>Waiting for startup process to send initial data for streaming
       replication.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>WalReceiverWaitStart</literal></entry>
      <entry>等待启动进程为流复制发送初始数据。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=3b93fdee849e4d1016b0f561ad6ad746 -->
<!-- pgdoc-cn_start sig_en=6c61ed2eade0eaab7022182384a17516 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>XactGroupUpdate</literal></entry>
      <entry>Waiting for the group leader to update transaction status at
       end of a parallel operation.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>XactGroupUpdate</literal></entry>
      <entry>等待分组组长在并行操作结束时更新事务状态。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=6c61ed2eade0eaab7022182384a17516 -->
    </tbody>
   </tgroup>
  </table>

  <table id="wait-event-lock-table">
<!-- pgdoc-cn_start sig_en=99eb92ec2d54fb64f618eea20643091b sig_cn_org=None source=14.1 
   <title>Wait Events of Type <literal>Lock</literal></title>
________________________________________________________-->
   <title><literal>Lock</literal>类型的等待事件</title>
<!-- pgdoc-cn_end sig_en=99eb92ec2d54fb64f618eea20643091b -->
   <tgroup cols="2">
    <thead>
<!-- pgdoc-cn_start sig_en=07764ff6aae67faf6747968e3cfb7d4d sig_cn_org=None source=14.1 
     <row>
      <entry><literal>Lock</literal> Wait Event</entry>
      <entry>Description</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>Lock</literal> 等待事件</entry>
      <entry>描述</entry>
     </row>
<!-- pgdoc-cn_end sig_en=07764ff6aae67faf6747968e3cfb7d4d -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=eb83b9fb3aa4fe0393c83630c9ccfa4f sig_cn_org=None source=14.1 
     <row>
      <entry><literal>advisory</literal></entry>
      <entry>Waiting to acquire an advisory user lock.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>advisory</literal></entry>
      <entry>等待获得一个建议用户锁。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=eb83b9fb3aa4fe0393c83630c9ccfa4f -->
<!-- pgdoc-cn_start sig_en=778290fd16e0e98d400b64468ebc90f5 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>extend</literal></entry>
      <entry>Waiting to extend a relation.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>extend</literal></entry>
      <entry>等待扩展一个关系。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=778290fd16e0e98d400b64468ebc90f5 -->
<!-- pgdoc-cn_start sig_en=f4a31eced344e7de354e4a907e30898f sig_cn_org=None source=14.1 
     <row>
      <entry><literal>frozenid</literal></entry>
      <entry>Waiting to
       update <structname>pg_database</structname>.<structfield>datfrozenxid</structfield>
       and <structname>pg_database</structname>.<structfield>datminmxid</structfield>.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>frozenid</literal></entry>
      <entry>等待升级 <structname>pg_database</structname>.<structfield>datfrozenxid</structfield>
       和 <structname>pg_database</structname>.<structfield>datminmxid</structfield>.</entry>
     </row>
<!-- pgdoc-cn_end sig_en=f4a31eced344e7de354e4a907e30898f -->
<!-- pgdoc-cn_start sig_en=4c9712130c18b9a8552724bb5e38c9e0 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>object</literal></entry>
      <entry>Waiting to acquire a lock on a non-relation database object.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>object</literal></entry>
      <entry>等待获取非关系数据库对象上的锁。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=4c9712130c18b9a8552724bb5e38c9e0 -->
<!-- pgdoc-cn_start sig_en=9d8b64f1893b1daf8ee7ef4404baedbf sig_cn_org=None source=14.1 
     <row>
      <entry><literal>page</literal></entry>
      <entry>Waiting to acquire a lock on a page of a relation.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>page</literal></entry>
      <entry>等待获取一个关系页面上的锁。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=9d8b64f1893b1daf8ee7ef4404baedbf -->
<!-- pgdoc-cn_start sig_en=d7044dd3c0395dd8db678823e4ce3458 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>relation</literal></entry>
      <entry>Waiting to acquire a lock on a relation.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>relation</literal></entry>
      <entry>等待获得一个关系的锁。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=d7044dd3c0395dd8db678823e4ce3458 -->
<!-- pgdoc-cn_start sig_en=6b1aa38687be3801b1cddca1d4d25999 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>spectoken</literal></entry>
      <entry>Waiting to acquire a speculative insertion lock.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>spectoken</literal></entry>
      <entry>等待获取推测的插入锁。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=6b1aa38687be3801b1cddca1d4d25999 -->
<!-- pgdoc-cn_start sig_en=a166653b3797003fb9f9a8d8d67f0b19 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>transactionid</literal></entry>
      <entry>Waiting for a transaction to finish.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>transactionid</literal></entry>
      <entry>等待事务完成。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=a166653b3797003fb9f9a8d8d67f0b19 -->
<!-- pgdoc-cn_start sig_en=543eb9ca48308e4c0224604a3737115d sig_cn_org=None source=14.1 
     <row>
      <entry><literal>tuple</literal></entry>
      <entry>Waiting to acquire a lock on a tuple.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>tuple</literal></entry>
      <entry>等待获取元组上的锁。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=543eb9ca48308e4c0224604a3737115d -->
<!-- pgdoc-cn_start sig_en=17ae44c19ff9633f822df108665a4329 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>userlock</literal></entry>
      <entry>Waiting to acquire a user lock.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>userlock</literal></entry>
      <entry>等待获取用户锁。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=17ae44c19ff9633f822df108665a4329 -->
<!-- pgdoc-cn_start sig_en=6b0f5d96ac6feeba900cc453fabe0365 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>virtualxid</literal></entry>
      <entry>Waiting to acquire a virtual transaction ID lock.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>virtualxid</literal></entry>
      <entry>等待获取虚拟事务ID锁。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=6b0f5d96ac6feeba900cc453fabe0365 -->
    </tbody>
   </tgroup>
  </table>

  <table id="wait-event-lwlock-table">
<!-- pgdoc-cn_start sig_en=d76adc623444322b31b4377c6bbb4e00 sig_cn_org=None source=14.1 
   <title>Wait Events of Type <literal>LWLock</literal></title>
________________________________________________________-->
   <title><literal>LWLock</literal>类型的等待事件</title>
<!-- pgdoc-cn_end sig_en=d76adc623444322b31b4377c6bbb4e00 -->
   <tgroup cols="2">
    <thead>
<!-- pgdoc-cn_start sig_en=8e0ffd35f32a1b4090360d45295d9370 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>LWLock</literal> Wait Event</entry>
      <entry>Description</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>LWLock</literal> 等待事件</entry>
      <entry>描述</entry>
     </row>
<!-- pgdoc-cn_end sig_en=8e0ffd35f32a1b4090360d45295d9370 -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=ac02a3d45cef1e7d10fd6587ee5fdc61 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>AddinShmemInit</literal></entry>
      <entry>Waiting to manage an extension's space allocation in shared
       memory.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>AddinShmemInit</literal></entry>
      <entry>等待管理共享内存中的扩展空间分配。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=ac02a3d45cef1e7d10fd6587ee5fdc61 -->
<!-- pgdoc-cn_start sig_en=704ff435d7df905816d97cf3b8c4b247 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>AutoFile</literal></entry>
      <entry>Waiting to update the <filename>postgresql.auto.conf</filename>
       file.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>AutoFile</literal></entry>
      <entry>等待更新<filename>postgresql.auto.conf</filename>文件。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=704ff435d7df905816d97cf3b8c4b247 -->
<!-- pgdoc-cn_start sig_en=78f5f7b851f9db504a9891fd21c6c0bd sig_cn_org=None source=14.1 
     <row>
      <entry><literal>Autovacuum</literal></entry>
      <entry>Waiting to read or update the current state of autovacuum
       workers.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>Autovacuum</literal></entry>
      <entry>等待读取或更新自动清理工作者的当前状态。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=78f5f7b851f9db504a9891fd21c6c0bd -->
<!-- pgdoc-cn_start sig_en=da8692e000515bc6a7afa15eae5d6e84 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>AutovacuumSchedule</literal></entry>
      <entry>Waiting to ensure that a table selected for autovacuum
       still needs vacuuming.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>AutovacuumSchedule</literal></entry>
      <entry>等待确保选择为自动清理的表仍然需要清理。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=da8692e000515bc6a7afa15eae5d6e84 -->
<!-- pgdoc-cn_start sig_en=877e70b55484812890230baf2fef567a sig_cn_org=None source=14.1 
     <row>
      <entry><literal>BackgroundWorker</literal></entry>
      <entry>Waiting to read or update background worker state.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>BackgroundWorker</literal></entry>
      <entry>等待读取或更新后台工作者状态。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=877e70b55484812890230baf2fef567a -->
<!-- pgdoc-cn_start sig_en=9bb19ab8ea58b92e9f150d74c6621953 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>BtreeVacuum</literal></entry>
      <entry>Waiting to read or update vacuum-related information for a
       B-tree index.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>BtreeVacuum</literal></entry>
      <entry>等待读取或更新b-树索引的清理相关信息。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=9bb19ab8ea58b92e9f150d74c6621953 -->
<!-- pgdoc-cn_start sig_en=5c086b1c41f02b29d10595b6fc0ab875 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>BufferContent</literal></entry>
      <entry>Waiting to access a data page in memory.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>BufferContent</literal></entry>
      <entry>等待访问内存中的数据页。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=5c086b1c41f02b29d10595b6fc0ab875 -->
<!-- pgdoc-cn_start sig_en=a3fc3a0d2e98824922a68f5c8f1040a0 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>BufferMapping</literal></entry>
      <entry>Waiting to associate a data block with a buffer in the buffer
       pool.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>BufferMapping</literal></entry>
      <entry>等待将数据块与缓冲池中的缓冲区关联。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=a3fc3a0d2e98824922a68f5c8f1040a0 -->
<!-- pgdoc-cn_start sig_en=c19c19305c8aba366a09d236c4480617 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>CheckpointerComm</literal></entry>
      <entry>Waiting to manage fsync requests.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>CheckpointerComm</literal></entry>
      <entry>等待管理fsync请求。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=c19c19305c8aba366a09d236c4480617 -->
<!-- pgdoc-cn_start sig_en=ba8a07aa8e6acfdd82fd7a6ad00643f1 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>CommitTs</literal></entry>
      <entry>Waiting to read or update the last value set for a
       transaction commit timestamp.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>CommitTs</literal></entry>
      <entry>等待读取或更新事务提交时间戳的最后一个值集。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=ba8a07aa8e6acfdd82fd7a6ad00643f1 -->
<!-- pgdoc-cn_start sig_en=0170fac6a4c1f8995cdfbf13f1fe28bb sig_cn_org=None source=14.1 
     <row>
      <entry><literal>CommitTsBuffer</literal></entry>
      <entry>Waiting for I/O on a commit timestamp SLRU buffer.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>CommitTsBuffer</literal></entry>
      <entry>在提交时间戳SLRU缓冲区上等待I/O。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=0170fac6a4c1f8995cdfbf13f1fe28bb -->
<!-- pgdoc-cn_start sig_en=df6b65f72041b913f652a57954b1486d sig_cn_org=None source=14.1 
     <row>
      <entry><literal>CommitTsSLRU</literal></entry>
      <entry>Waiting to access the commit timestamp SLRU cache.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>CommitTsSLRU</literal></entry>
      <entry>等待访问提交时间戳SLRU缓存。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=df6b65f72041b913f652a57954b1486d -->
<!-- pgdoc-cn_start sig_en=40007b8e11332674518a7c8bddeeecf6 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>ControlFile</literal></entry>
      <entry>Waiting to read or update the <filename>pg_control</filename>
       file or create a new WAL file.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ControlFile</literal></entry>
      <entry>等待读取或更新<filename>pg_control</filename>文件或创建一个新的WAL文件。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=40007b8e11332674518a7c8bddeeecf6 -->
<!-- pgdoc-cn_start sig_en=fe6f07979219c5717e0bb44bfbf75c15 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>DynamicSharedMemoryControl</literal></entry>
      <entry>Waiting to read or update dynamic shared memory allocation
       information.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>DynamicSharedMemoryControl</literal></entry>
      <entry>等待读取或更新动态共享内存分配信息。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=fe6f07979219c5717e0bb44bfbf75c15 -->
<!-- pgdoc-cn_start sig_en=fd72dadac0289014c3f10e62b4791b0f sig_cn_org=None source=14.1 
     <row>
      <entry><literal>LockFastPath</literal></entry>
      <entry>Waiting to read or update a process' fast-path lock
       information.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>LockFastPath</literal></entry>
      <entry>等待读取或更新进程的快速路径锁信息。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=fd72dadac0289014c3f10e62b4791b0f -->
<!-- pgdoc-cn_start sig_en=1d76d31110ebf7f974c5879194156d32 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>LockManager</literal></entry>
      <entry>Waiting to read or update information
       about <quote>heavyweight</quote> locks.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>LockManager</literal></entry>
      <entry>等待读取或更新关于<quote>heavyweight</quote>锁。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=1d76d31110ebf7f974c5879194156d32 -->
<!-- pgdoc-cn_start sig_en=d77badea4cde04f52bb9e0d0217e548a sig_cn_org=None source=14.1 
     <row>
      <entry><literal>LogicalRepWorker</literal></entry>
      <entry>Waiting to read or update the state of logical replication
       workers.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>LogicalRepWorker</literal></entry>
      <entry>等待读取或更新逻辑复制工作器的状态。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=d77badea4cde04f52bb9e0d0217e548a -->
<!-- pgdoc-cn_start sig_en=5ae28373cbf1cea97acc512b64e1e103 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>MultiXactGen</literal></entry>
      <entry>Waiting to read or update shared multixact state.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>MultiXactGen</literal></entry>
      <entry>等待读取或更新共享的multixact状态。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=5ae28373cbf1cea97acc512b64e1e103 -->
<!-- pgdoc-cn_start sig_en=e170de1f7d5a277ab8b76f02d6a24d5b sig_cn_org=None source=14.1 
     <row>
      <entry><literal>MultiXactMemberBuffer</literal></entry>
      <entry>Waiting for I/O on a multixact member SLRU buffer.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>MultiXactMemberBuffer</literal></entry>
      <entry>在multixact成员SLRU缓冲区上等待I/O。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=e170de1f7d5a277ab8b76f02d6a24d5b -->
<!-- pgdoc-cn_start sig_en=de314a1d28a23dc23b35ac540284d3dc sig_cn_org=None source=14.1 
     <row>
      <entry><literal>MultiXactMemberSLRU</literal></entry>
      <entry>Waiting to access the multixact member SLRU cache.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>MultiXactMemberSLRU</literal></entry>
      <entry>等待访问multixact成员SLRU缓存。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=de314a1d28a23dc23b35ac540284d3dc -->
<!-- pgdoc-cn_start sig_en=e6ab20c2acc5cabbb9bf1c66fe000af0 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>MultiXactOffsetBuffer</literal></entry>
      <entry>Waiting for I/O on a multixact offset SLRU buffer.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>MultiXactOffsetBuffer</literal></entry>
      <entry>在multixact 偏移 SLRU缓冲区上等待I/O。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=e6ab20c2acc5cabbb9bf1c66fe000af0 -->
<!-- pgdoc-cn_start sig_en=8a64a4549a38aeec0d8171c9532ea918 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>MultiXactOffsetSLRU</literal></entry>
      <entry>Waiting to access the multixact offset SLRU cache.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>MultiXactOffsetSLRU</literal></entry>
      <entry>等待访问multixact 偏移 SLRU缓存。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=8a64a4549a38aeec0d8171c9532ea918 -->
<!-- pgdoc-cn_start sig_en=0c06d3b3af1a086ada00bf85d64bfa71 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>MultiXactTruncation</literal></entry>
      <entry>Waiting to read or truncate multixact information.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>MultiXactTruncation</literal></entry>
      <entry>等待读取或截断multixact信息。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=0c06d3b3af1a086ada00bf85d64bfa71 -->
<!-- pgdoc-cn_start sig_en=31d0237efd4aff3689aa3b67577797b9 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>NotifyBuffer</literal></entry>
      <entry>Waiting for I/O on a <command>NOTIFY</command> message SLRU
       buffer.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>NotifyBuffer</literal></entry>
      <entry>在<command>NOTIFY</command> 消息 SLRU缓冲区上等待I/O。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=31d0237efd4aff3689aa3b67577797b9 -->
<!-- pgdoc-cn_start sig_en=d0e3db99776bfc018f08bad018f62902 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>NotifyQueue</literal></entry>
      <entry>Waiting to read or update <command>NOTIFY</command> messages.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>NotifyQueue</literal></entry>
      <entry>等待读取或更新<command>NOTIFY</command> 消息。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=d0e3db99776bfc018f08bad018f62902 -->
<!-- pgdoc-cn_start sig_en=a5a8f107239c0c8f174dd5955014f739 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>NotifyQueueTail</literal></entry>
      <entry>Waiting to update limit on <command>NOTIFY</command> message
       storage.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>NotifyQueueTail</literal></entry>
      <entry>等待<command>NOTIFY</command>消息存储上的更新限制。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=a5a8f107239c0c8f174dd5955014f739 -->
<!-- pgdoc-cn_start sig_en=f4f46e483427c7b1cab7b46bc0d645e5 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>NotifySLRU</literal></entry>
      <entry>Waiting to access the <command>NOTIFY</command> message SLRU
       cache.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>NotifySLRU</literal></entry>
      <entry>等待访问<command>NOTIFY</command>消息SLRU缓存。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=f4f46e483427c7b1cab7b46bc0d645e5 -->
<!-- pgdoc-cn_start sig_en=5f495de432a66a86e9e9e319166b7f44 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>OidGen</literal></entry>
      <entry>Waiting to allocate a new OID.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>OidGen</literal></entry>
      <entry>等待分配一个新的OID。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=5f495de432a66a86e9e9e319166b7f44 -->
<!-- pgdoc-cn_start sig_en=70cd00ec1873d5cdc85422081613cf8c sig_cn_org=None source=14.1 
     <row>
      <entry><literal>OldSnapshotTimeMap</literal></entry>
      <entry>Waiting to read or update old snapshot control information.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>OldSnapshotTimeMap</literal></entry>
      <entry>等待读取或更新旧的快照控制信息。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=70cd00ec1873d5cdc85422081613cf8c -->
<!-- pgdoc-cn_start sig_en=309e4e7204f79df5019260678632ee9c sig_cn_org=None source=14.1 
     <row>
      <entry><literal>ParallelAppend</literal></entry>
      <entry>Waiting to choose the next subplan during Parallel Append plan
       execution.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ParallelAppend</literal></entry>
      <entry>在并行附加计划执行期间等待选择下一个子计划。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=309e4e7204f79df5019260678632ee9c -->
<!-- pgdoc-cn_start sig_en=1fa3fa6f2296df3a70984ec15f738c63 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>ParallelHashJoin</literal></entry>
      <entry>Waiting to synchronize workers during Parallel Hash Join plan
       execution.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ParallelHashJoin</literal></entry>
      <entry>在并行哈希连接计划执行期间等待同步工作器。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=1fa3fa6f2296df3a70984ec15f738c63 -->
<!-- pgdoc-cn_start sig_en=d0fd0d8b779265675518af2a0fc25531 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>ParallelQueryDSA</literal></entry>
      <entry>Waiting for parallel query dynamic shared memory allocation.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ParallelQueryDSA</literal></entry>
      <entry>等待并行查询动态共享内存分配。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=d0fd0d8b779265675518af2a0fc25531 -->
<!-- pgdoc-cn_start sig_en=343b95b59fae5fd578dfa0fe16ca80a2 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>PerSessionDSA</literal></entry>
      <entry>Waiting for parallel query dynamic shared memory allocation.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>PerSessionDSA</literal></entry>
      <entry>等待并行查询动态共享内存分配。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=343b95b59fae5fd578dfa0fe16ca80a2 -->
<!-- pgdoc-cn_start sig_en=78bc5e70566c3f00901bba25fbd4a944 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>PerSessionRecordType</literal></entry>
      <entry>Waiting to access a parallel query's information about composite
       types.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>PerSessionRecordType</literal></entry>
      <entry>等待访问有关复合类型的并行查询信息。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=78bc5e70566c3f00901bba25fbd4a944 -->
<!-- pgdoc-cn_start sig_en=ea79fe2a92203bf66cb08387067a0286 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>PerSessionRecordTypmod</literal></entry>
      <entry>Waiting to access a parallel query's information about type
       modifiers that identify anonymous record types.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>PerSessionRecordTypmod</literal></entry>
      <entry>等待访问有关标识匿名记录类型的类型修饰符的并行查询信息。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=ea79fe2a92203bf66cb08387067a0286 -->
<!-- pgdoc-cn_start sig_en=a5aae432c32eb28a95dc24c36c30bbd3 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>PerXactPredicateList</literal></entry>
      <entry>Waiting to access the list of predicate locks held by the current
       serializable transaction during a parallel query.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>PerXactPredicateList</literal></entry>
      <entry>在并行查询期间等待访问当前可序列化事务持有的谓词锁列表。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=a5aae432c32eb28a95dc24c36c30bbd3 -->
<!-- pgdoc-cn_start sig_en=40316dcdc93efe331de215e00238223c sig_cn_org=None source=14.1 
     <row>
      <entry><literal>PredicateLockManager</literal></entry>
      <entry>Waiting to access predicate lock information used by
       serializable transactions.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>PredicateLockManager</literal></entry>
      <entry>等待访问可序列化事务使用的谓词锁信息。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=40316dcdc93efe331de215e00238223c -->
<!-- pgdoc-cn_start sig_en=a59626d2cfefc8fd5a6da3390f9835c6 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>ProcArray</literal></entry>
      <entry>Waiting to access the shared per-process data structures
       (typically, to get a snapshot or report a session's transaction
       ID).</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ProcArray</literal></entry>
      <entry>等待访问每个进程共享的数据结构(通常情况，是获取快照或报告会话的事务ID)。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=a59626d2cfefc8fd5a6da3390f9835c6 -->
<!-- pgdoc-cn_start sig_en=7ba4f645c218dc565fc70e993bb01d8b sig_cn_org=None source=14.1 
     <row>
      <entry><literal>RelationMapping</literal></entry>
      <entry>Waiting to read or update
       a <filename>pg_filenode.map</filename> file (used to track the
       filenode assignments of certain system catalogs).</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>RelationMapping</literal></entry>
      <entry>等待读取或更新<filename>pg_filenode.map</filename>文件(用于跟踪某些系统目录的文件节点分配)。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=7ba4f645c218dc565fc70e993bb01d8b -->
<!-- pgdoc-cn_start sig_en=00c4795af4fca0142a3ff0864d4014f3 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>RelCacheInit</literal></entry>
      <entry>Waiting to read or update a <filename>pg_internal.init</filename>
       relation cache initialization file.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>RelCacheInit</literal></entry>
      <entry>等待读取或更新<filename>pg_internal.init</filename>关系缓存初始化文件。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=00c4795af4fca0142a3ff0864d4014f3 -->
<!-- pgdoc-cn_start sig_en=e012dcfe188b8f5c90d1c15ee8b4f3f8 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>ReplicationOrigin</literal></entry>
      <entry>Waiting to create, drop or use a replication origin.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ReplicationOrigin</literal></entry>
      <entry>等待创建、删除或使用复制源。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=e012dcfe188b8f5c90d1c15ee8b4f3f8 -->
<!-- pgdoc-cn_start sig_en=141e7cbabfd3de4fa7fe17d931d201cc sig_cn_org=None source=14.1 
     <row>
      <entry><literal>ReplicationOriginState</literal></entry>
      <entry>Waiting to read or update the progress of one replication
       origin.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ReplicationOriginState</literal></entry>
      <entry>等待读取或更新一个复制源的进度。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=141e7cbabfd3de4fa7fe17d931d201cc -->
<!-- pgdoc-cn_start sig_en=550a1bbb4dbd65a68a1e0eb10b946542 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>ReplicationSlotAllocation</literal></entry>
      <entry>Waiting to allocate or free a replication slot.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ReplicationSlotAllocation</literal></entry>
      <entry>等待分配或释放复制槽。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=550a1bbb4dbd65a68a1e0eb10b946542 -->
<!-- pgdoc-cn_start sig_en=36ab2f6e9677fa4cd4666e412dbb7c6e sig_cn_org=None source=14.1 
     <row>
      <entry><literal>ReplicationSlotControl</literal></entry>
      <entry>Waiting to read or update replication slot state.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ReplicationSlotControl</literal></entry>
      <entry>等待读取或更新复制槽状态。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=36ab2f6e9677fa4cd4666e412dbb7c6e -->
<!-- pgdoc-cn_start sig_en=ad54a8c7136fba2d843faf6f1ea16fca sig_cn_org=None source=14.1 
     <row>
      <entry><literal>ReplicationSlotIO</literal></entry>
      <entry>Waiting for I/O on a replication slot.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ReplicationSlotIO</literal></entry>
      <entry>在复制槽位上等待I/O。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=ad54a8c7136fba2d843faf6f1ea16fca -->
<!-- pgdoc-cn_start sig_en=1d3b37d51f02ff5a2812cd4fb3f780a4 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>SerialBuffer</literal></entry>
      <entry>Waiting for I/O on a serializable transaction conflict SLRU
       buffer.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>SerialBuffer</literal></entry>
      <entry>在可串行事务冲突的SLRU缓冲区上等待I/O。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=1d3b37d51f02ff5a2812cd4fb3f780a4 -->
<!-- pgdoc-cn_start sig_en=bc4d98d5d9e0beab1d44817e1e35cb1c sig_cn_org=None source=14.1 
     <row>
      <entry><literal>SerializableFinishedList</literal></entry>
      <entry>Waiting to access the list of finished serializable
       transactions.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>SerializableFinishedList</literal></entry>
      <entry>等待访问已完成的可序列化事务列表。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=bc4d98d5d9e0beab1d44817e1e35cb1c -->
<!-- pgdoc-cn_start sig_en=e7da589e4b8f48c9ee23d06f797a6656 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>SerializablePredicateList</literal></entry>
      <entry>Waiting to access the list of predicate locks held by
       serializable transactions.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>SerializablePredicateList</literal></entry>
      <entry>等待访问可序列化事务持有的谓词锁列表。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=e7da589e4b8f48c9ee23d06f797a6656 -->
<!-- pgdoc-cn_start sig_en=7d7161cc411f9a9a39b075309c11ae57 sig_cn_org=b4f971df71e206d983f43e8fb4a1c180 source=15.7 
     <row>
      <entry><literal>PgStatsDSA</literal></entry>
      <entry>Waiting for stats dynamic shared memory allocator access</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>PgStatsDSA</literal></entry>
      <entry>等待统计动态共享内存分配器访问</entry>
     </row>
<!-- pgdoc-cn_end sig_en=7d7161cc411f9a9a39b075309c11ae57 -->
<!-- pgdoc-cn_start sig_en=f208e14cc98342d295a1bdb97c5cfaa1 sig_cn_org=5063963afdc6edf2e567af9221d14cbb source=15.7 
     <row>
      <entry><literal>PgStatsHash</literal></entry>
      <entry>Waiting for stats shared memory hash table access</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>PgStatsHash</literal></entry>
      <entry>等待统计共享内存哈希表访问</entry>
     </row>
<!-- pgdoc-cn_end sig_en=f208e14cc98342d295a1bdb97c5cfaa1 -->
<!-- pgdoc-cn_start sig_en=b4becd043271a8e3e0b21621cac57648 sig_cn_org=83704dcaa562aa2e824497251314b066 source=15.7 
     <row>
      <entry><literal>PgStatsData</literal></entry>
      <entry>Waiting for shared memory stats data access</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>PgStatsData</literal></entry>
      <entry>等待共享内存统计数据访问</entry>
     </row>
<!-- pgdoc-cn_end sig_en=b4becd043271a8e3e0b21621cac57648 -->
<!-- pgdoc-cn_start sig_en=7f0b4543ef5b0fca7ad99accb63c1bc2 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>SerializableXactHash</literal></entry>
      <entry>Waiting to read or update information about serializable
       transactions.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>SerializableXactHash</literal></entry>
      <entry>等待读取或更新关于可序列化事务的信息。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=7f0b4543ef5b0fca7ad99accb63c1bc2 -->
<!-- pgdoc-cn_start sig_en=9d3c5436c256e80e6d5f883511457602 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>SerialSLRU</literal></entry>
      <entry>Waiting to access the serializable transaction conflict SLRU
       cache.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>SerialSLRU</literal></entry>
      <entry>等待访问可序列化事务冲突SLRU缓存。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=9d3c5436c256e80e6d5f883511457602 -->
<!-- pgdoc-cn_start sig_en=6194d16b74bae2a8faf92c3826888e52 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>SharedTidBitmap</literal></entry>
      <entry>Waiting to access a shared TID bitmap during a parallel bitmap
       index scan.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>SharedTidBitmap</literal></entry>
      <entry>在并行位图索引扫描期间等待访问共享的TID位图。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=6194d16b74bae2a8faf92c3826888e52 -->
<!-- pgdoc-cn_start sig_en=568f8e83c4e610dc20a48ed926071e9a sig_cn_org=None source=14.1 
     <row>
      <entry><literal>SharedTupleStore</literal></entry>
      <entry>Waiting to access a shared tuple store during parallel
       query.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>SharedTupleStore</literal></entry>
      <entry>在并行查询期间等待访问共享元组存储。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=568f8e83c4e610dc20a48ed926071e9a -->
<!-- pgdoc-cn_start sig_en=6aad4189061ddef418b30450a0331376 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>ShmemIndex</literal></entry>
      <entry>Waiting to find or allocate space in shared memory.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>ShmemIndex</literal></entry>
      <entry>等待在共享内存中找到或分配空间。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=6aad4189061ddef418b30450a0331376 -->
<!-- pgdoc-cn_start sig_en=b939de6f77481db6a1f3cb69c2a9969c sig_cn_org=None source=14.1 
     <row>
      <entry><literal>SInvalRead</literal></entry>
      <entry>Waiting to retrieve messages from the shared catalog invalidation
       queue.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>SInvalRead</literal></entry>
      <entry>等待从共享目录失效队列中检索消息。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=b939de6f77481db6a1f3cb69c2a9969c -->
<!-- pgdoc-cn_start sig_en=d3e2aff77f8716747db37e4205eb17e6 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>SInvalWrite</literal></entry>
      <entry>Waiting to add a message to the shared catalog invalidation
      queue.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>SInvalWrite</literal></entry>
      <entry>等待向共享编目失效队列添加消息。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=d3e2aff77f8716747db37e4205eb17e6 -->
<!-- pgdoc-cn_start sig_en=57c233f2dd84f664bfe37448d0bd31a1 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>SubtransBuffer</literal></entry>
      <entry>Waiting for I/O on a sub-transaction SLRU buffer.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>SubtransBuffer</literal></entry>
      <entry>在子事务SLRU缓冲区上等待I/O。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=57c233f2dd84f664bfe37448d0bd31a1 -->
<!-- pgdoc-cn_start sig_en=1302a44c52d812cc041985f855a8f462 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>SubtransSLRU</literal></entry>
      <entry>Waiting to access the sub-transaction SLRU cache.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>SubtransSLRU</literal></entry>
      <entry>等待访问子事务SLRU缓存。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=1302a44c52d812cc041985f855a8f462 -->
<!-- pgdoc-cn_start sig_en=1be40a1227bb626bd26ac5c3800558a6 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>SyncRep</literal></entry>
      <entry>Waiting to read or update information about the state of
       synchronous replication.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>SyncRep</literal></entry>
      <entry>等待读取或更新有关同步复制状态的信息。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=1be40a1227bb626bd26ac5c3800558a6 -->
<!-- pgdoc-cn_start sig_en=4f4dbc8826223af955136649ab0fe4e7 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>SyncScan</literal></entry>
      <entry>Waiting to select the starting location of a synchronized table
       scan.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>SyncScan</literal></entry>
      <entry>等待选择同步表扫描的起始位置。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=4f4dbc8826223af955136649ab0fe4e7 -->
<!-- pgdoc-cn_start sig_en=53d95ed8fd20e5d5ad7aca152988a127 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>TablespaceCreate</literal></entry>
      <entry>Waiting to create or drop a tablespace.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>TablespaceCreate</literal></entry>
      <entry>等待创建或删除表空间。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=53d95ed8fd20e5d5ad7aca152988a127 -->
<!-- pgdoc-cn_start sig_en=aeceb4fdef083484b54ee6f03911057f sig_cn_org=None source=14.1 
     <row>
      <entry><literal>TwoPhaseState</literal></entry>
      <entry>Waiting to read or update the state of prepared transactions.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>TwoPhaseState</literal></entry>
      <entry>等待读取或更新已准备事务的状态。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=aeceb4fdef083484b54ee6f03911057f -->
<!-- pgdoc-cn_start sig_en=58bd2b0f0127b4a6c643305e6596134c sig_cn_org=None source=14.1 
     <row>
      <entry><literal>WALBufMapping</literal></entry>
      <entry>Waiting to replace a page in WAL buffers.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>WALBufMapping</literal></entry>
      <entry>等待在WAL缓冲区中替换一个页面。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=58bd2b0f0127b4a6c643305e6596134c -->
<!-- pgdoc-cn_start sig_en=787541ae085a46e54dda511377480240 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>WALInsert</literal></entry>
      <entry>Waiting to insert WAL data into a memory buffer.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>WALInsert</literal></entry>
      <entry>等待将WAL数据插入内存缓冲区。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=787541ae085a46e54dda511377480240 -->
<!-- pgdoc-cn_start sig_en=0f517672d63e73494f3e5704ebd5353b sig_cn_org=None source=14.1 
     <row>
      <entry><literal>WALWrite</literal></entry>
      <entry>Waiting for WAL buffers to be written to disk.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>WALWrite</literal></entry>
      <entry>等待WAL缓冲区写入磁盘。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=0f517672d63e73494f3e5704ebd5353b -->
<!-- pgdoc-cn_start sig_en=cafce7e3438e3fdc4f02b63fa80ac6ff sig_cn_org=None source=14.1 
     <row>
      <entry><literal>WrapLimitsVacuum</literal></entry>
      <entry>Waiting to update limits on transaction id and multixact
       consumption.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>WrapLimitsVacuum</literal></entry>
      <entry>等待更新事务id和multixact消费的限制。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=cafce7e3438e3fdc4f02b63fa80ac6ff -->
<!-- pgdoc-cn_start sig_en=d5f2f65e46d75bf1842d27cf61188ec8 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>XactBuffer</literal></entry>
      <entry>Waiting for I/O on a transaction status SLRU buffer.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>XactBuffer</literal></entry>
      <entry>在事务状态的SLRU缓冲区上等待I/O。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=d5f2f65e46d75bf1842d27cf61188ec8 -->
<!-- pgdoc-cn_start sig_en=daa3ce023bae772e34e317804c7acd2a sig_cn_org=None source=14.1 
     <row>
      <entry><literal>XactSLRU</literal></entry>
      <entry>Waiting to access the transaction status SLRU cache.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>XactSLRU</literal></entry>
      <entry>等待访问事务状态的SLRU缓存。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=daa3ce023bae772e34e317804c7acd2a -->
<!-- pgdoc-cn_start sig_en=d697c78e2dafe188ca8043f917649d1d sig_cn_org=None source=14.1 
     <row>
      <entry><literal>XactTruncation</literal></entry>
      <entry>Waiting to execute <function>pg_xact_status</function> or update
       the oldest transaction ID available to it.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>XactTruncation</literal></entry>
      <entry>等待执行<function>pg_xact_status</function>或更新它可用的最早的事务ID。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=d697c78e2dafe188ca8043f917649d1d -->
<!-- pgdoc-cn_start sig_en=397490dcc944359ddbcf690f513ccee9 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>XidGen</literal></entry>
      <entry>Waiting to allocate a new transaction ID.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>XidGen</literal></entry>
      <entry>等待分配新的事务ID。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=397490dcc944359ddbcf690f513ccee9 -->
    </tbody>
   </tgroup>
  </table>

   <note>
<!-- pgdoc-cn_start sig_en=70f958bf4e8a729ca8912b5565979c90 sig_cn_org=None source=14.1 
    <para>
     Extensions can add <literal>LWLock</literal> types to the list shown in
     <xref linkend="wait-event-lwlock-table"/>.  In some cases, the name
     assigned by an extension will not be available in all server processes;
     so an <literal>LWLock</literal> wait event might be reported as
     just <quote><literal>extension</literal></quote> rather than the
     extension-assigned name.
    </para>
________________________________________________________-->
    <para>
     扩展可以将<literal>LWLock</literal>类型添加到<xref linkend="wait-event-lwlock-table"/>所示的列表中。
     在某些情况下，扩展名分配的名称不能在所有服务器进程中使用;因此<literal>LWLock</literal>等待事件可能只被报告为<quote><literal>extension</literal></quote>，而不是扩展名分配的名称。
    </para>
<!-- pgdoc-cn_end sig_en=70f958bf4e8a729ca8912b5565979c90 -->
   </note>

  <table id="wait-event-timeout-table">
<!-- pgdoc-cn_start sig_en=0d91cc7a1fabe1225d6d7f948e54d317 sig_cn_org=None source=14.1 
   <title>Wait Events of Type <literal>Timeout</literal></title>
________________________________________________________-->
   <title> <literal>Timeout</literal>类型的等待事件</title>
<!-- pgdoc-cn_end sig_en=0d91cc7a1fabe1225d6d7f948e54d317 -->
   <tgroup cols="2">
    <thead>
<!-- pgdoc-cn_start sig_en=9ec92d197af5f870005ca2afb5c132a5 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>Timeout</literal> Wait Event</entry>
      <entry>Description</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>Timeout</literal> 等待事件</entry>
      <entry>描述</entry>
     </row>
<!-- pgdoc-cn_end sig_en=9ec92d197af5f870005ca2afb5c132a5 -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=2b7f410f426cc5e965916d2c86a9f997 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>BaseBackupThrottle</literal></entry>
      <entry>Waiting during base backup when throttling activity.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>BaseBackupThrottle</literal></entry>
      <entry>当有限流活动时在基础备份期间等待。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=2b7f410f426cc5e965916d2c86a9f997 -->
<!-- pgdoc-cn_start sig_en=6e89d5673ded647aba88e5fbed1c0690 sig_cn_org=eb24c59c0ff00ccb073293a8e51d9a25 source=15.7 
     <row>
      <entry><literal>CheckpointWriteDelay</literal></entry>
      <entry>Waiting between writes while performing a checkpoint.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>CheckpointWriteDelay</literal></entry>
      <entry>在执行检查点时写入之间的等待时间。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=6e89d5673ded647aba88e5fbed1c0690 -->
<!-- pgdoc-cn_start sig_en=a2d41cf5510c9371fbeaa2d22fd62e0e sig_cn_org=None source=14.1 
     <row>
      <entry><literal>PgSleep</literal></entry>
      <entry>Waiting due to a call to <function>pg_sleep</function> or
       a sibling function.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>PgSleep</literal></entry>
      <entry>由于调用<function>pg_sleep</function>或同类函数而等待。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=a2d41cf5510c9371fbeaa2d22fd62e0e -->
<!-- pgdoc-cn_start sig_en=c26196e7f43ea0f2b78bcd8ebb3b8405 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>RecoveryApplyDelay</literal></entry>
      <entry>Waiting to apply WAL during recovery because of a delay
       setting.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>RecoveryApplyDelay</literal></entry>
      <entry>由于延迟设置，在恢复期间等待应用WAL。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=c26196e7f43ea0f2b78bcd8ebb3b8405 -->
<!-- pgdoc-cn_start sig_en=822bbfb3d872f0618b262b212ba52bcc sig_cn_org=None source=14.1 
     <row>
      <entry><literal>RecoveryRetrieveRetryInterval</literal></entry>
      <entry>Waiting during recovery when WAL data is not available from any
       source (<filename>pg_wal</filename>, archive or stream).</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>RecoveryRetrieveRetryInterval</literal></entry>
      <entry>当WAL数据无法从任何来源(<filename>pg_wal</filename>，存档或流)获得时，在恢复期间等待。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=822bbfb3d872f0618b262b212ba52bcc -->
<!-- pgdoc-cn_start sig_en=a22c80a47118d5b9c5a7ced612773a6d sig_cn_org=668df012ca7d8c2d5bb7fd70467d4921 source=15.7 
     <row>
      <entry><literal>RegisterSyncRequest</literal></entry>
      <entry>Waiting while sending synchronization requests to the
       checkpointer, because the request queue is full.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>RegisterSyncRequest</literal></entry>
      <entry>在发送同步请求到检查点程序时等待，因为请求队列已满。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=a22c80a47118d5b9c5a7ced612773a6d -->
<!-- pgdoc-cn_start sig_en=6e0dd7c1a7690cdf53690ffedaab746c sig_cn_org=None source=14.1 
     <row>
      <entry><literal>VacuumDelay</literal></entry>
      <entry>Waiting in a cost-based vacuum delay point.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>VacuumDelay</literal></entry>
      <entry>在一个基于代价的清理延迟点。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=6e0dd7c1a7690cdf53690ffedaab746c -->
<!-- pgdoc-cn_start sig_en=7563ca1ea694aec869a7fbc22949a055 sig_cn_org=92b53221b0a55a3f6d04771930f85141 source=15.7 
     <row>
      <entry><literal>VacuumTruncate</literal></entry>
      <entry>Waiting to acquire an exclusive lock to truncate off any
       empty pages at the end of a table vacuumed.</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>VacuumTruncate</literal></entry>
      <entry>等待获取独占锁以截断被清理的表末尾的空页面。</entry>
     </row>
<!-- pgdoc-cn_end sig_en=7563ca1ea694aec869a7fbc22949a055 -->
    </tbody>
   </tgroup>
  </table>

<!-- pgdoc-cn_start sig_en=2e7cf8b9aebe98bf86ded8724b50a43a sig_cn_org=fb7c90bafdec9cab44c505f56886eae8 source=15.7 
   <para>
     Here is an example of how wait events can be viewed:

<programlisting>
SELECT pid, wait_event_type, wait_event FROM pg_stat_activity WHERE wait_event is NOT NULL;
 pid  | wait_event_type | wait_event
-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 2540 | Lock            | relation
 6644 | LWLock          | ProcArray
(2 rows)
</programlisting>
   </para>
________________________________________________________-->
   <para>
     这里是一个查看等待事件的示例：

<programlisting>
SELECT pid, wait_event_type, wait_event FROM pg_stat_activity WHERE wait_event is NOT NULL;
 pid  | wait_event_type | wait_event
------+-----------------+------------
 2540 | Lock            | relation
 6644 | LWLock          | ProcArray
(2 rows)
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=2e7cf8b9aebe98bf86ded8724b50a43a -->

 </sect2>

 <sect2 id="monitoring-pg-stat-replication-view">
  <title><structname>pg_stat_replication</structname></title>

<!-- pgdoc-cn_start sig_en=ca203192e9dc404319c753e02973ed1f sig_cn_org=None source=14.1 
  <indexterm>
   <primary>pg_stat_replication</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>pg_stat_replication</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=ca203192e9dc404319c753e02973ed1f -->

<!-- pgdoc-cn_start sig_en=4feaca15b9d3808168567ae26b775eac sig_cn_org=None source=14.1 
   <para>
   The <structname>pg_stat_replication</structname> view will contain one row
   per WAL sender process, showing statistics about replication to that
   sender's connected standby server.  Only directly connected standbys are
   listed; no information is available about downstream standby servers.
  </para>
________________________________________________________-->
   <para>
   <structname>pg_stat_replication</structname>视图将在每个WAL发送方进程中包含一行，显示关于复制到发送方连接的备用服务器的统计信息。
   只有直接连接的备用设备被列出;没有关于下游备用服务器的信息。
  </para>
<!-- pgdoc-cn_end sig_en=4feaca15b9d3808168567ae26b775eac -->

  <table id="pg-stat-replication-view" xreflabel="pg_stat_replication">
<!-- pgdoc-cn_start sig_en=30cf410052420266f92be4595fb4db06 sig_cn_org=None source=14.1 
   <title><structname>pg_stat_replication</structname> View</title>
________________________________________________________-->
   <title><structname>pg_stat_replication</structname> 视图</title>
<!-- pgdoc-cn_end sig_en=30cf410052420266f92be4595fb4db06 -->
   <tgroup cols="1">
    <thead>
<!-- pgdoc-cn_start sig_en=19eb14a155d7416c3b9cad7829c11a9d sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=19eb14a155d7416c3b9cad7829c11a9d -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=11ebca575e41d0a66df5d6c2d988568c sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       Process ID of a WAL sender process
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       一个 WAL 发送进程的进程 ID
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=11ebca575e41d0a66df5d6c2d988568c -->

<!-- pgdoc-cn_start sig_en=1296c42329e2479452766329fc40a521 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>usesysid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the user logged into this WAL sender process
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>usesysid</structfield> <type>oid</type>
      </para>
      <para>
       登录到这个 WAL 发送进程的用户的 OID
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=1296c42329e2479452766329fc40a521 -->

<!-- pgdoc-cn_start sig_en=01f35b622a6437bb0101fe98cd1660b8 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>usename</structfield> <type>name</type>
      </para>
      <para>
       Name of the user logged into this WAL sender process
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>usename</structfield> <type>name</type>
      </para>
      <para>
       登录到这个 WAL 发送进程的用户的名称
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=01f35b622a6437bb0101fe98cd1660b8 -->

<!-- pgdoc-cn_start sig_en=4804016fb1f74443898c4cbee71bc2a7 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>application_name</structfield> <type>text</type>
      </para>
      <para>
       Name of the application that is connected
       to this WAL sender
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>application_name</structfield> <type>text</type>
      </para>
      <para>
       连接到这个 WAL 发送进程的应用的名称
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=4804016fb1f74443898c4cbee71bc2a7 -->

<!-- pgdoc-cn_start sig_en=1d3dd7a02db378cc6ebecc7f4eaf642f sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>client_addr</structfield> <type>inet</type>
      </para>
      <para>
       IP address of the client connected to this WAL sender.
       If this field is null, it indicates that the client is
       connected via a Unix socket on the server machine.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>client_addr</structfield> <type>inet</type>
      </para>
      <para>
       连接到这个 WAL 发送进程的客户端的 IP 地址。
       如果这个域为空，它表示该客户端通过服务器机器上的一个Unix 套接字连接。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=1d3dd7a02db378cc6ebecc7f4eaf642f -->

<!-- pgdoc-cn_start sig_en=7561658978a029896fae99f88c322c36 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>client_hostname</structfield> <type>text</type>
      </para>
      <para>
       Host name of the connected client, as reported by a
       reverse DNS lookup of <structfield>client_addr</structfield>. This field will
       only be non-null for IP connections, and only when <xref linkend="guc-log-hostname"/> is enabled.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>client_hostname</structfield> <type>text</type>
      </para>
      <para>
       已连接的客户端的主机名，由<structfield>client_addr</structfield>的反向 DNS 查找报告。
	   这个字段将只对 IP 连接非空，并且只有 <xref linkend="guc-log-hostname"/>被启用时才会非空。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=7561658978a029896fae99f88c322c36 -->

<!-- pgdoc-cn_start sig_en=71c7d14dea84f0bf2c693ed4afcce251 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>client_port</structfield> <type>integer</type>
      </para>
      <para>
       TCP port number that the client is using for communication
       with this WAL sender, or <literal>-1</literal> if a Unix socket is used
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>client_port</structfield> <type>integer</type>
      </para>
      <para>
       客户端用来与这个 WAL 发送进程通讯的 TCP 端口号，如果使用 Unix 套接字则为<literal>-1</literal>
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=71c7d14dea84f0bf2c693ed4afcce251 -->

<!-- pgdoc-cn_start sig_en=e1153cd3f9e35076e464b3bf4cade273 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>backend_start</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time when this process was started, i.e., when the
       client connected to this WAL sender
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>backend_start</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       这个进程开始的时间，即客户端是何时连接到这个WAL 发送进程的。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=e1153cd3f9e35076e464b3bf4cade273 -->

<!-- pgdoc-cn_start sig_en=9efeecb82cab17238d0c67b9d5f50eb2 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>backend_xmin</structfield> <type>xid</type>
      </para>
      <para>
       This standby's <literal>xmin</literal> horizon reported
       by <xref linkend="guc-hot-standby-feedback"/>.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>backend_xmin</structfield> <type>xid</type>
      </para>
      <para>
       由<xref linkend="guc-hot-standby-feedback"/>报告的这个后备机的<literal>xmin</literal>水平线。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=9efeecb82cab17238d0c67b9d5f50eb2 -->

<!-- pgdoc-cn_start sig_en=53de4f0fd4f2c628d85e87f1371d8dfd sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>state</structfield> <type>text</type>
      </para>
      <para>
       Current WAL sender state.
       Possible values are:
       <itemizedlist>
        <listitem>
         <para>
          <literal>startup</literal>: This WAL sender is starting up.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>catchup</literal>: This WAL sender's connected standby is
          catching up with the primary.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>streaming</literal>: This WAL sender is streaming changes
          after its connected standby server has caught up with the primary.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>backup</literal>: This WAL sender is sending a backup.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>stopping</literal>: This WAL sender is stopping.
         </para>
        </listitem>
       </itemizedlist>
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>state</structfield> <type>text</type>
      </para>
      <para>
       当前的 WAL 发送进程状态。
       可能的值是：
       <itemizedlist>
        <listitem>
         <para>
          <literal>startup</literal>: 这个WAL发送器正在启动。
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>catchup</literal>: 这个WAL发送者连接的备用服务器正在赶上主服务器。
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>streaming</literal>: 在其连接的备用服务器赶上主服务器之后，这个WAL发送方正在流化变化。
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>backup</literal>: 这个WAL发送器正在发送一个备份。
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>stopping</literal>: 这个WAL发送器正在停止。
         </para>
        </listitem>
       </itemizedlist>
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=53de4f0fd4f2c628d85e87f1371d8dfd -->

<!-- pgdoc-cn_start sig_en=e3aae0c9674e388400813a15ebd472c0 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sent_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       Last write-ahead log location sent on this connection
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sent_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       在这个连接上发送的最后一个预写式日志的位置
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=e3aae0c9674e388400813a15ebd472c0 -->

<!-- pgdoc-cn_start sig_en=ad76a274ab68af3a6b19c18dfb591045 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>write_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       Last write-ahead log location written to disk by this standby
       server
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>write_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       被这个后备服务器写入到磁盘的最后一个预写式日志的位置
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=ad76a274ab68af3a6b19c18dfb591045 -->

<!-- pgdoc-cn_start sig_en=5201959a1ae9f430368ba4341234f33a sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>flush_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       Last write-ahead log location flushed to disk by this standby
       server
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>flush_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       被这个后备服务器刷入到磁盘的最后一个预写式日志的位置
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=5201959a1ae9f430368ba4341234f33a -->

<!-- pgdoc-cn_start sig_en=7ab6184a7b99adbaab6921d55df9b407 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>replay_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       Last write-ahead log location replayed into the database on this
       standby server
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>replay_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       被重放到这个后备服务器上的数据库中的最后一个预写式日志的位置
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=7ab6184a7b99adbaab6921d55df9b407 -->

<!-- pgdoc-cn_start sig_en=0102eca86ee4d3ae9385e0793aed195b sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>write_lag</structfield> <type>interval</type>
      </para>
      <para>
       Time elapsed between flushing recent WAL locally and receiving
       notification that this standby server has written it (but not yet
       flushed it or applied it).  This can be used to gauge the delay that
       <literal>synchronous_commit</literal> level
       <literal>remote_write</literal> incurred while committing if this
       server was configured as a synchronous standby.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>write_lag</structfield> <type>interval</type>
      </para>
      <para>
       从本地刷新近期的WAL与接收到此备用服务器已写入WAL的通知(但尚未刷新或应用它)之间的时间经过。
       如果将此服务器配置为同步备用服务器，则可以使用此参数来衡量在提交时<literal>synchronous_commit</literal>级别<literal>remote_write</literal>所导致的延迟。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=0102eca86ee4d3ae9385e0793aed195b -->

<!-- pgdoc-cn_start sig_en=39e76a51c11b75cdb6eadc98d355d6a7 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>flush_lag</structfield> <type>interval</type>
      </para>
      <para>
       Time elapsed between flushing recent WAL locally and receiving
       notification that this standby server has written and flushed it
       (but not yet applied it).  This can be used to gauge the delay that
       <literal>synchronous_commit</literal> level
       <literal>on</literal> incurred while committing if this
       server was configured as a synchronous standby.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>flush_lag</structfield> <type>interval</type>
      </para>
      <para>
       在本地刷写近期的WAL与接收到后备服务器已经写入并且刷写它（但还没有应用）的通知之间流逝的时间。
       如果这台服务器被配置为一个同步后备，这可以用来计量在提交时<literal>synchronous_commit</literal>的级别<literal>on</literal>所导致的延迟。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=39e76a51c11b75cdb6eadc98d355d6a7 -->

<!-- pgdoc-cn_start sig_en=676d991e00a448df50b0ade071cc2760 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>replay_lag</structfield> <type>interval</type>
      </para>
      <para>
       Time elapsed between flushing recent WAL locally and receiving
       notification that this standby server has written, flushed and
       applied it.  This can be used to gauge the delay that
       <literal>synchronous_commit</literal> level
       <literal>remote_apply</literal> incurred while committing if this
       server was configured as a synchronous standby.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>replay_lag</structfield> <type>interval</type>
      </para>
      <para>
       在本地刷写近期的WAL与接收到后备服务器已经写入它、刷写它并且应用它的通知之间流逝的时间。
       如果这台服务器被配置为一个同步后备，这可以用来计量在提交时<literal>synchronous_commit</literal>的级别<literal>remote_apply</literal>所导致的延迟。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=676d991e00a448df50b0ade071cc2760 -->

<!-- pgdoc-cn_start sig_en=cbd608b1cded4c55e1349c6ddc637571 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sync_priority</structfield> <type>integer</type>
      </para>
      <para>
       Priority of this standby server for being chosen as the
       synchronous standby in a priority-based synchronous replication.
       This has no effect in a quorum-based synchronous replication.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sync_priority</structfield> <type>integer</type>
      </para>
      <para>
       在基于优先的同步复制中，这台后备服务器被选为同步后备的优先级。在基于规定数量的同步复制中，这个值没有效果。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=cbd608b1cded4c55e1349c6ddc637571 -->

<!-- pgdoc-cn_start sig_en=854cb0e62ebcee2b7ce0f6f80f4b9ae4 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sync_state</structfield> <type>text</type>
      </para>
      <para>
       Synchronous state of this standby server.
       Possible values are:
       <itemizedlist>
        <listitem>
         <para>
          <literal>async</literal>: This standby server is asynchronous.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>potential</literal>: This standby server is now asynchronous,
          but can potentially become synchronous if one of current
          synchronous ones fails.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>sync</literal>: This standby server is synchronous.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>quorum</literal>: This standby server is considered as a candidate
          for quorum standbys.
         </para>
        </listitem>
       </itemizedlist>
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sync_state</structfield> <type>text</type>
      </para>
      <para>
       这一台后备服务器的同步状态。
       可能的值是：
       <itemizedlist>
        <listitem>
         <para>
          <literal>async</literal>: 这台后备服务器是异步的。
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>potential</literal>: 这台后备服务器现在是异步的，但可能在当前的同步后备失效时变成同步的。
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>sync</literal>: 这台后备服务器是同步的。
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>quorum</literal>: 这台后备服务器被当做规定数量后备服务器的候选。
         </para>
        </listitem>
       </itemizedlist>
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=854cb0e62ebcee2b7ce0f6f80f4b9ae4 -->

<!-- pgdoc-cn_start sig_en=6ec460f0be0b3fafa2da42b47eda4c77 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>reply_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Send time of last reply message received from standby server
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>reply_time</structfield> <type>带时区的时间戳</type>
      </para>
      <para>
       从备用服务器收到的最后一条回复信息的发送时间
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=6ec460f0be0b3fafa2da42b47eda4c77 -->
    </tbody>
   </tgroup>
  </table>

<!-- pgdoc-cn_start sig_en=d4a805e0579b4cdbf243895425726997 sig_cn_org=None source=14.1 
  <para>
   The lag times reported in the <structname>pg_stat_replication</structname>
   view are measurements of the time taken for recent WAL to be written,
   flushed and replayed and for the sender to know about it.  These times
   represent the commit delay that was (or would have been) introduced by each
   synchronous commit level, if the remote server was configured as a
   synchronous standby.  For an asynchronous standby, the
   <structfield>replay_lag</structfield> column approximates the delay
   before recent transactions became visible to queries.  If the standby
   server has entirely caught up with the sending server and there is no more
   WAL activity, the most recently measured lag times will continue to be
   displayed for a short time and then show NULL.
  </para>
________________________________________________________-->
  <para>
   <structname>pg_stat_replication</structname>视图中报告的滞后时间近期的WAL被写入、刷写并且重放以及发送器知道这一切所花的时间的度量。如果远程服务器被配置为一台同步后备，这些时间表示由每一种同步提交级别所带来（或者是可能带来）的提交延迟。对于一台异步后备，<structfield>replay_lag</structfield>列是最近的事务变得对查询可见的延迟时间的近似值。如果后备服务器已经完全追上了发送服务器并且没有WAL活动，在短时间内将继续显示最近测到的滞后时间，再然后就会显示为NULL。
  </para>
<!-- pgdoc-cn_end sig_en=d4a805e0579b4cdbf243895425726997 -->

<!-- pgdoc-cn_start sig_en=b374993e998b6e359cf02a2c6ca4d1d1 sig_cn_org=None source=14.1 
  <para>
   Lag times work automatically for physical replication. Logical decoding
   plugins may optionally emit tracking messages; if they do not, the tracking
   mechanism will simply display NULL lag.
  </para>
________________________________________________________-->
  <para>
   对于物理复制会自动测量滞后时间。逻辑解码插件可能会选择性地发出跟踪消息，如果它们没有这样做，跟踪机制将把滞后显示为NULL。
  </para>
<!-- pgdoc-cn_end sig_en=b374993e998b6e359cf02a2c6ca4d1d1 -->

  <note>
<!-- pgdoc-cn_start sig_en=784be66ea10bfef6d341fe1a1ab35085 sig_cn_org=None source=14.1 
   <para>
    The reported lag times are not predictions of how long it will take for
    the standby to catch up with the sending server assuming the current
    rate of replay.  Such a system would show similar times while new WAL is
    being generated, but would differ when the sender becomes idle.  In
    particular, when the standby has caught up completely,
    <structname>pg_stat_replication</structname> shows the time taken to
    write, flush and replay the most recent reported WAL location rather than
    zero as some users might expect.  This is consistent with the goal of
    measuring synchronous commit and transaction visibility delays for
    recent write transactions.
    To reduce confusion for users expecting a different model of lag, the
    lag columns revert to NULL after a short time on a fully replayed idle
    system. Monitoring systems should choose whether to represent this
    as missing data, zero or continue to display the last known value.
   </para>
________________________________________________________-->
   <para>
    报告的滞后时间并非按照当前的重放速率该后备还有多久才能追上发送服务器的预测。在新的WAL被生成期间，这样一种系统将显示类似的时间，但是当发送器变为闲置时会显示不同的值。特别是当后备服务器完全追上时，<structname>pg_stat_replication</structname>显示的是写入、刷写及重放最近报告的WAL位置所花的时间而不是一些用户可能预期的零。这种做法与为近期的写事务测量同步提交和事务可见性延迟的目的一致。为了降低用户预期一种不同的滞后模型带来的混淆，在一个完全重放完的闲置系统上，lag列会在一段比较短的时间后回复成NULL。监控系统应该选择将这种情况表示为缺失数据、零或者继续显示最近的已知值。
   </para>
<!-- pgdoc-cn_end sig_en=784be66ea10bfef6d341fe1a1ab35085 -->
  </note>

 </sect2>

 <sect2 id="monitoring-pg-stat-replication-slots-view">
  <title><structname>pg_stat_replication_slots</structname></title>

<!-- pgdoc-cn_start sig_en=4b82ba385a2eb521f4fff0221fb6a180 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>pg_stat_replication_slots</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>pg_stat_replication_slots</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=4b82ba385a2eb521f4fff0221fb6a180 -->

<!-- pgdoc-cn_start sig_en=6ce3152aae6709365847297d4c6a5238 sig_cn_org=None source=14.1 
  <para>
   The <structname>pg_stat_replication_slots</structname> view will contain
   one row per logical replication slot, showing statistics about its usage.
  </para>
________________________________________________________-->
  <para>
   <structname>pg_stat_replication_slots</structname>视图将包含每个逻辑复制槽的一行，显示关于其使用情况的统计信息。
  </para>
<!-- pgdoc-cn_end sig_en=6ce3152aae6709365847297d4c6a5238 -->

  <table id="pg-stat-replication-slots-view" xreflabel="pg_stat_replication_slots">
<!-- pgdoc-cn_start sig_en=e5bcb06d78d4c8da9b8d2d17cf6eeb4a sig_cn_org=None source=14.1 
   <title><structname>pg_stat_replication_slots</structname> View</title>
________________________________________________________-->
   <title><structname>pg_stat_replication_slots</structname> View</title>
<!-- pgdoc-cn_end sig_en=e5bcb06d78d4c8da9b8d2d17cf6eeb4a -->
   <tgroup cols="1">
    <thead>
<!-- pgdoc-cn_start sig_en=acb9e72ba1dd97377ce13778420650a1 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Column Type
       </para>
       <para>
        Description
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        列类型
       </para>
       <para>
        描述
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=acb9e72ba1dd97377ce13778420650a1 -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=267bcec200941ace3b0872021eb9f831 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>slot_name</structfield> <type>text</type>
       </para>
       <para>
        A unique, cluster-wide identifier for the replication slot
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>slot_name</structfield> <type>text</type>
       </para>
       <para>
        唯一的，复制槽的集群范围标识符
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=267bcec200941ace3b0872021eb9f831 -->

<!-- pgdoc-cn_start sig_en=88fa5b0b9ed2433721013a14459e287d sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>spill_txns</structfield> <type>bigint</type>
       </para>
       <para>
        Number of transactions spilled to disk once the memory used by
        logical decoding to decode changes from WAL has exceeded
        <literal>logical_decoding_work_mem</literal>. The counter gets
        incremented for both top-level transactions and subtransactions.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>spill_txns</structfield> <type>bigint</type>
       </para>
       <para>
        当逻辑解码在解码来自WAL的更改时所使用的内存超过<literal>logical_decoding_work_mem</literal>，溢出到磁盘的事务数。
        顶级事务和子事务的计数器都是递增的。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=88fa5b0b9ed2433721013a14459e287d -->

<!-- pgdoc-cn_start sig_en=a96d727ebecbb0d95100fffba8cb6497 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>spill_count</structfield> <type>bigint</type>
       </para>
       <para>
        Number of times transactions were spilled to disk while decoding
        changes from WAL for this slot. This counter is incremented each time
        a transaction is spilled, and the same transaction may be spilled
        multiple times.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>spill_count</structfield> <type>bigint</type>
       </para>
       <para>
        在为该槽位解码来自WAL的更改时，事务溢出到磁盘的次数。
        此计数器在每次事务被溢出时递增，并且同一事务可能被溢出多次。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=a96d727ebecbb0d95100fffba8cb6497 -->

<!-- pgdoc-cn_start sig_en=c75329dbac3f65c78c0d65162ea69a5b sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>spill_bytes</structfield> <type>bigint</type>
       </para>
       <para>
        Amount of decoded transaction data spilled to disk while performing
        decoding of changes from WAL for this slot. This and other spill
        counters can be used to gauge the I/O which occurred during logical
        decoding and allow tuning <literal>logical_decoding_work_mem</literal>.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>spill_bytes</structfield> <type>bigint</type>
       </para>
       <para>
        在对来自WAL的更改执行解码时，已解码的事务数据溢出到磁盘的数量。
        这个和其他溢出计数器可用于测量逻辑解码期间发生的I/O，并且允许调优<literal>logical_decoding_work_mem</literal>。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=c75329dbac3f65c78c0d65162ea69a5b -->

<!-- pgdoc-cn_start sig_en=9b217716532bcba4d6ffa84ab815920a sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stream_txns</structfield> <type>bigint</type>
       </para>
       <para>
        Number of in-progress transactions streamed to the decoding output
        plugin after the memory used by logical decoding to decode changes
        from WAL for this slot has exceeded
        <literal>logical_decoding_work_mem</literal>. Streaming only
        works with top-level transactions (subtransactions can't be streamed
        independently), so the counter is not incremented for subtransactions.
       </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stream_txns</structfield> <type>bigint</type>
       </para>
       <para>
        在逻辑解码在解码来自该槽位的WAL更改的时候，所使用的内存超过<literal>logical_decoding_work_mem</literal>之后，流到解码输出插件的正在进行的事务数。
        流仅对顶级事务有效(子事务不能独立流)，因此子事务的计数器不会增加。
       </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=9b217716532bcba4d6ffa84ab815920a -->

<!-- pgdoc-cn_start sig_en=f948af33ddecb640d369958986237968 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stream_count</structfield><type>bigint</type>
       </para>
       <para>
        Number of times in-progress transactions were streamed to the decoding
        output plugin while decoding changes from WAL for this slot. This
        counter is incremented each time a transaction is streamed, and the
        same transaction may be streamed multiple times.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stream_count</structfield><type>bigint</type>
       </para>
       <para>
        在为该槽位解码来自WAL的更改时，将正在进行的事务流到解码输出插件的次数。
        此计数器在每次事务流化时递增，并且同一事务可能被流化多次。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=f948af33ddecb640d369958986237968 -->

<!-- pgdoc-cn_start sig_en=eb0119d7aac3e530523551285c120a35 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stream_bytes</structfield><type>bigint</type>
       </para>
       <para>
        Amount of transaction data decoded for streaming in-progress
        transactions to the decoding output plugin while decoding changes from
        WAL for this slot. This and other streaming counters for this slot can
        be used to tune <literal>logical_decoding_work_mem</literal>.
       </para>
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stream_bytes</structfield><type>bigint</type>
       </para>
       <para>
        在为该槽位解码来自WAL的更改时，为将正在进行的事务流到解码输出插件而解码的事务数据的数量。
        这个和针对此槽位的其他流计数器可用于调优<literal>logical_decoding_work_mem</literal>。
       </para>
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=eb0119d7aac3e530523551285c120a35 -->

<!-- pgdoc-cn_start sig_en=1c5112319ca1428ccf9b2e21d0720f4b sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>total_txns</structfield> <type>bigint</type>
       </para>
       <para>
        Number of decoded transactions sent to the decoding output plugin for
        this slot. This counts top-level transactions only, and is not incremented
        for subtransactions. Note that this includes the transactions that are
        streamed and/or spilled.
       </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>total_txns</structfield> <type>bigint</type>
       </para>
       <para>
        针对此槽的，发送到解码输出插件的已解码事务数。
        这只计算顶级事务，对子事务不会增加。
        注意，这包括流化和/或溢出的事务。
       </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=1c5112319ca1428ccf9b2e21d0720f4b -->

<!-- pgdoc-cn_start sig_en=7010ae81bde282731aa2617666174100 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>total_bytes</structfield><type>bigint</type>
       </para>
       <para>
        Amount of transaction data decoded for sending transactions to the
        decoding output plugin while decoding changes from WAL for this slot.
        Note that this includes data that is streamed and/or spilled.
       </para>
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>total_bytes</structfield><type>bigint</type>
       </para>
       <para>
        在对此槽位的WAL进行解码时，为将事务发送到解码输出插件而解码的事务数据量。
        注意这包括流和/或溢出的数据。
       </para>
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=7010ae81bde282731aa2617666174100 -->

<!-- pgdoc-cn_start sig_en=3596d2a23c29ef2b7913740e22d00195 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
       </para>
       <para>
        Time at which these statistics were last reset
       </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
       </para>
       <para>
        这些统计最后重置的时间
       </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=3596d2a23c29ef2b7913740e22d00195 -->
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="monitoring-pg-stat-wal-receiver-view">
  <title><structname>pg_stat_wal_receiver</structname></title>

<!-- pgdoc-cn_start sig_en=12c4c473140d02587f743eb960e1137f sig_cn_org=None source=14.1 
  <indexterm>
   <primary>pg_stat_wal_receiver</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>pg_stat_wal_receiver</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=12c4c473140d02587f743eb960e1137f -->

<!-- pgdoc-cn_start sig_en=6117e51ef064106e9451d7f57f8b052a sig_cn_org=None source=14.1 
  <para>
   The <structname>pg_stat_wal_receiver</structname> view will contain only
   one row, showing statistics about the WAL receiver from that receiver's
   connected server.
  </para>
________________________________________________________-->
  <para>
   <structname>pg_stat_wal_receiver</structname>事务只包含一行，它显示了从 WAL 接收器所连接的服务器得到的有关该接收器的统计信息。
  </para>
<!-- pgdoc-cn_end sig_en=6117e51ef064106e9451d7f57f8b052a -->

  <table id="pg-stat-wal-receiver-view" xreflabel="pg_stat_wal_receiver">
<!-- pgdoc-cn_start sig_en=08c918bd47e6da3ea181109f33fa947b sig_cn_org=None source=14.1 
   <title><structname>pg_stat_wal_receiver</structname> View</title>
________________________________________________________-->
   <title><structname>pg_stat_wal_receiver</structname> 视图</title>
<!-- pgdoc-cn_end sig_en=08c918bd47e6da3ea181109f33fa947b -->
   <tgroup cols="1">
    <thead>
<!-- pgdoc-cn_start sig_en=19eb14a155d7416c3b9cad7829c11a9d sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=19eb14a155d7416c3b9cad7829c11a9d -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=f18c72f0d35edb0d6113051941063b9f sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       Process ID of the WAL receiver process
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       WAL接收器进程的进程ID
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=f18c72f0d35edb0d6113051941063b9f -->

<!-- pgdoc-cn_start sig_en=b3d362402dbcd8fdbfd171099093a62d sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>status</structfield> <type>text</type>
      </para>
      <para>
       Activity status of the WAL receiver process
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>status</structfield> <type>text</type>
      </para>
      <para>
       WAL接收进程的活动状态
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=b3d362402dbcd8fdbfd171099093a62d -->

<!-- pgdoc-cn_start sig_en=d9f63e824a9a107c15978bac4e485543 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>receive_start_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       First write-ahead log location used when WAL receiver is
       started
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>receive_start_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       WAL接收器启动时使用的第一个写前日志位置
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=d9f63e824a9a107c15978bac4e485543 -->

<!-- pgdoc-cn_start sig_en=368302212feaaf1f5afb82c3a9ef9858 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>receive_start_tli</structfield> <type>integer</type>
      </para>
      <para>
       First timeline number used when WAL receiver is started
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>receive_start_tli</structfield> <type>integer</type>
      </para>
      <para>
       WAL接收器启动时使用的第一个时间线数字
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=368302212feaaf1f5afb82c3a9ef9858 -->

<!-- pgdoc-cn_start sig_en=2e72f6c114fd9520c243c53ec01621fa sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>written_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       Last write-ahead log location already received and written to disk,
       but not flushed. This should not be used for data integrity checks.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>written_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       已经接收并写入磁盘的最后一个预写式日志位置，但没有刷入。这不能用于数据完整性检查。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=2e72f6c114fd9520c243c53ec01621fa -->

<!-- pgdoc-cn_start sig_en=af6c193c2bdb031b4261860020961851 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>flushed_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       Last write-ahead log location already received and flushed to
       disk, the initial value of this field being the first log location used
       when WAL receiver is started
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>flushed_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       已经接收并刷入到磁盘的最后一个预写式日志位置，该字段的初始值是启动WAL接收器时使用的第一个日志位置
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=af6c193c2bdb031b4261860020961851 -->

<!-- pgdoc-cn_start sig_en=d727453b19f1abc9543a77deb30b10a3 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>received_tli</structfield> <type>integer</type>
      </para>
      <para>
       Timeline number of last write-ahead log location received and
       flushed to disk, the initial value of this field being the timeline
       number of the first log location used when WAL receiver is started
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>received_tli</structfield> <type>integer</type>
      </para>
      <para>
       接收并刷入到磁盘的最后一个预写式日志位置的时间线数字，该字段的初始值为启动WAL接收器时使用的第一个日志位置的时间线数字
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=d727453b19f1abc9543a77deb30b10a3 -->

<!-- pgdoc-cn_start sig_en=a247e051a97a9cecccb82a12f509ba0a sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_msg_send_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Send time of last message received from origin WAL sender
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_msg_send_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       从源头WAL发送器收到的最后一条信息的发送时间
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=a247e051a97a9cecccb82a12f509ba0a -->

<!-- pgdoc-cn_start sig_en=3c2001470a4a8defd03da2001cb67788 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_msg_receipt_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Receipt time of last message received from origin WAL sender
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_msg_receipt_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       从源头WAL发送器收到的最后一条信息的接收时间
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=3c2001470a4a8defd03da2001cb67788 -->

<!-- pgdoc-cn_start sig_en=08fb76d3b9dab6a06e0303cb65cd4109 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>latest_end_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       Last write-ahead log location reported to origin WAL sender
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>latest_end_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       向源头WAL发送器报告的最后的预写式日志位置
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=08fb76d3b9dab6a06e0303cb65cd4109 -->

<!-- pgdoc-cn_start sig_en=ea925e8c082a00fe746a32940e9212f3 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>latest_end_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time of last write-ahead log location reported to origin WAL sender
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>latest_end_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       向源头WAL发送方报告的最后一次写前日志位置的时间
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=ea925e8c082a00fe746a32940e9212f3 -->

<!-- pgdoc-cn_start sig_en=4ccc4f8237f2bfc38b565b45b7352650 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>slot_name</structfield> <type>text</type>
      </para>
      <para>
       Replication slot name used by this WAL receiver
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>slot_name</structfield> <type>text</type>
      </para>
      <para>
       这个WAL接收器使用的复制槽的名称
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=4ccc4f8237f2bfc38b565b45b7352650 -->

<!-- pgdoc-cn_start sig_en=ab3376778587cde7b567459ca4f78965 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sender_host</structfield> <type>text</type>
      </para>
      <para>
       Host of the <productname>PostgreSQL</productname> instance
       this WAL receiver is connected to. This can be a host name,
       an IP address, or a directory path if the connection is via
       Unix socket.  (The path case can be distinguished because it
       will always be an absolute path, beginning with <literal>/</literal>.)
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sender_host</structfield> <type>text</type>
      </para>
      <para>
       这个WAL接收器连接到的<productname>PostgreSQL</productname>实例的主机。
	   这可以是主机名、IP地址，或者目录路径，如果连接是通过Unix套接字进行的。(路径的情况可以区分，因为它总是以<literal>/</literal>开头的绝对路径。)
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=ab3376778587cde7b567459ca4f78965 -->

<!-- pgdoc-cn_start sig_en=44a4b64f5ea803428ba713c7ce7f37f0 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sender_port</structfield> <type>integer</type>
      </para>
      <para>
       Port number of the <productname>PostgreSQL</productname> instance
       this WAL receiver is connected to.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sender_port</structfield> <type>integer</type>
      </para>
      <para>
       这个WAL接收器连接的<productname>PostgreSQL</productname>实例的端口号。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=44a4b64f5ea803428ba713c7ce7f37f0 -->

<!-- pgdoc-cn_start sig_en=e9c0331ed653215e12fd69b9d353049d sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>conninfo</structfield> <type>text</type>
      </para>
      <para>
       Connection string used by this WAL receiver,
       with security-sensitive fields obfuscated.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>conninfo</structfield> <type>text</type>
      </para>
      <para>
       这个WAL接收器使用的连接字符串，对安全敏感的字段进行了模糊处理。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=e9c0331ed653215e12fd69b9d353049d -->
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="monitoring-pg-stat-recovery-prefetch">
  <title><structname>pg_stat_recovery_prefetch</structname></title>

<!-- pgdoc-cn_start sig_en=09ce6e195e760d9597ab6b0a1f4fff57 sig_cn_org=efb4b1d7e03a84ef27834b4896730719 source=15.7 
  <indexterm>
   <primary>pg_stat_recovery_prefetch</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>pg_stat_recovery_prefetch</primary>
</indexterm>
<!-- pgdoc-cn_end sig_en=09ce6e195e760d9597ab6b0a1f4fff57 -->

<!-- pgdoc-cn_start sig_en=f4257144c9c93f10f15a6cf5b8a7c0b1 sig_cn_org=ff875bed8f563cdb7165c9fb725e1848 source=15.7 
  <para>
   The <structname>pg_stat_recovery_prefetch</structname> view will contain
   only one row.  The columns <structfield>wal_distance</structfield>,
   <structfield>block_distance</structfield> and
   <structfield>io_depth</structfield> show current values, and the
   other columns show cumulative counters that can be reset
   with the <function>pg_stat_reset_shared</function> function.
  </para>
________________________________________________________-->
  <para>
   <structname>pg_stat_recovery_prefetch</structname>视图将只包含一行。
   <structfield>wal_distance</structfield>、<structfield>block_distance</structfield>和
   <structfield>io_depth</structfield>列显示当前值，其他列显示可以使用
   <function>pg_stat_reset_shared</function>函数重置的累积计数器。
</para>
<!-- pgdoc-cn_end sig_en=f4257144c9c93f10f15a6cf5b8a7c0b1 -->

  <table id="pg-stat-recovery-prefetch-view" xreflabel="pg_stat_recovery_prefetch">
<!-- pgdoc-cn_start sig_en=30d8c215165f78e587ec76085a648f58 sig_cn_org=527414742bfc017d9361f4ac913d50cf source=15.7 
   <title><structname>pg_stat_recovery_prefetch</structname> View</title>
________________________________________________________-->
   <title><structname>pg_stat_recovery_prefetch</structname> 视图</title>
<!-- pgdoc-cn_end sig_en=30d8c215165f78e587ec76085a648f58 -->
   <tgroup cols="1">
    <thead>
<!-- pgdoc-cn_start sig_en=19eb14a155d7416c3b9cad7829c11a9d sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=19eb14a155d7416c3b9cad7829c11a9d -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=6fb8e6641b212c6d9b13e8d34ba40a38 sig_cn_org=fe91c1a10ded5238b48387740d920250 source=15.7 
     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
       </para>
       <para>
        Time at which these statistics were last reset
       </para>
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>stats_reset</structfield> <type>时间戳与时区</type>
       </para>
       <para>
        这些统计数据上次重置的时间
       </para>
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=6fb8e6641b212c6d9b13e8d34ba40a38 -->

<!-- pgdoc-cn_start sig_en=2eb634b1bf9dbc5d11486a1b55b0f832 sig_cn_org=56897b51857ffa032585d4c7b60bdad5 source=15.7 
     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>prefetch</structfield> <type>bigint</type>
       </para>
       <para>
        Number of blocks prefetched because they were not in the buffer pool
       </para>
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>prefetch</structfield> <type>bigint</type>
       </para>
       <para>
        因为不在缓冲池中，所以预取的块数
       </para>
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=2eb634b1bf9dbc5d11486a1b55b0f832 -->

<!-- pgdoc-cn_start sig_en=1c66383ba1770e796ebce26bf45914c9 sig_cn_org=22ecc8f54adef3df072a85878544bde1 source=15.7 
     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>hit</structfield> <type>bigint</type>
       </para>
       <para>
        Number of blocks not prefetched because they were already in the buffer pool
       </para>
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>hit</structfield> <type>bigint</type>
       </para>
       <para>
        因为它们已经在缓冲池中，所以未预取的块数
       </para>
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=1c66383ba1770e796ebce26bf45914c9 -->

<!-- pgdoc-cn_start sig_en=9ccba5ad26c2a73621010402f51481bd sig_cn_org=c3a8083dfa3f2815e0cb63a6cd4d00cc source=15.7 
     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>skip_init</structfield> <type>bigint</type>
       </para>
       <para>
        Number of blocks not prefetched because they would be zero-initialized
       </para>
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>skip_init</structfield> <type>bigint</type>
       </para>
       <para>
        未预取的块数，因为它们将被初始化为零
       </para>
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=9ccba5ad26c2a73621010402f51481bd -->

<!-- pgdoc-cn_start sig_en=7fd7a06e054cddaa862581655b183e56 sig_cn_org=385f2ea45f3b93e2f87fed13f1107f42 source=15.7 
     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>skip_new</structfield> <type>bigint</type>
       </para>
       <para>
        Number of blocks not prefetched because they didn't exist yet
       </para>
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>skip_new</structfield> <type>bigint</type>
       </para>
       <para>
        未预取的块数，因为它们尚不存在
       </para>
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=7fd7a06e054cddaa862581655b183e56 -->

<!-- pgdoc-cn_start sig_en=eb879c1d2596a962b406b80cb02c379f sig_cn_org=0709351f042b3aab94e1d2f2d7d50562 source=15.7 
     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>skip_fpw</structfield> <type>bigint</type>
       </para>
       <para>
        Number of blocks not prefetched because a full page image was included in the WAL
       </para>
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>skip_fpw</structfield> <type>bigint</type>
       </para>
       <para>
        由于WAL中包含完整页图像而未预取的块数
       </para>
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=eb879c1d2596a962b406b80cb02c379f -->

<!-- pgdoc-cn_start sig_en=81d178437e2855a72c7ad989484f3bf1 sig_cn_org=af27b8f1419ae1d8efe3bbc13c312797 source=15.7 
     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>skip_rep</structfield> <type>bigint</type>
       </para>
       <para>
        Number of blocks not prefetched because they were already recently prefetched
       </para>
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>skip_rep</structfield> <type>bigint</type>
       </para>
       <para>
        由于最近已经预取过而未预取的块数
       </para>
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=81d178437e2855a72c7ad989484f3bf1 -->

<!-- pgdoc-cn_start sig_en=7744ffb69ae5a69462162f8389582cd5 sig_cn_org=fae9ccdb95b41b82c3bfc770a42acea4 source=15.7 
     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>wal_distance</structfield> <type>int</type>
       </para>
       <para>
        How many bytes ahead the prefetcher is looking
       </para>
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>wal_distance</structfield> <type>int</type>
       </para>
       <para>
        预取器向前查看多少字节
       </para>
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=7744ffb69ae5a69462162f8389582cd5 -->

<!-- pgdoc-cn_start sig_en=beb7bbfa0775997472f13ca2f0c81486 sig_cn_org=915af6e4881f2224066d48ae465d1ecc source=15.7 
     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>block_distance</structfield> <type>int</type>
       </para>
       <para>
        How many blocks ahead the prefetcher is looking
       </para>
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>block_distance</structfield> <type>int</type>
       </para>
       <para>
        预取器正在查看多少个块之前
       </para>
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=beb7bbfa0775997472f13ca2f0c81486 -->

<!-- pgdoc-cn_start sig_en=ac1549b318d8cfa92a26a2dfc29e2474 sig_cn_org=caa50562fed1e02008bd4552d8c5311a source=15.7 
     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>io_depth</structfield> <type>int</type>
       </para>
       <para>
        How many prefetches have been initiated but are not yet known to have completed
       </para>
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry">
       <para role="column_definition">
        <structfield>io_depth</structfield> <type>int</type>
       </para>
       <para>
        已启动但尚未完成的预取数量
       </para>
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=ac1549b318d8cfa92a26a2dfc29e2474 -->
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="monitoring-pg-stat-subscription">
  <title><structname>pg_stat_subscription</structname></title>

<!-- pgdoc-cn_start sig_en=fbb2b9e7c5f9e9a328c28f3515add5f5 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>pg_stat_subscription</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>pg_stat_subscription</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=fbb2b9e7c5f9e9a328c28f3515add5f5 -->

  <table id="pg-stat-subscription" xreflabel="pg_stat_subscription">
<!-- pgdoc-cn_start sig_en=dcc5dd111f29d33742a5518dc70bd111 sig_cn_org=None source=14.1 
   <title><structname>pg_stat_subscription</structname> View</title>
________________________________________________________-->
   <title><structname>pg_stat_subscription</structname> View</title>
<!-- pgdoc-cn_end sig_en=dcc5dd111f29d33742a5518dc70bd111 -->
   <tgroup cols="1">
    <thead>
<!-- pgdoc-cn_start sig_en=19eb14a155d7416c3b9cad7829c11a9d sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=19eb14a155d7416c3b9cad7829c11a9d -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=f1fee0c60c03c86a10674c4394064ba6 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>subid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the subscription
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>subid</structfield> <type>oid</type>
      </para>
      <para>
       订阅的OID
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=f1fee0c60c03c86a10674c4394064ba6 -->

<!-- pgdoc-cn_start sig_en=ffd64e5bd7e734c356987f415bc938d9 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>subname</structfield> <type>name</type>
      </para>
      <para>
       Name of the subscription
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>subname</structfield> <type>name</type>
      </para>
      <para>
       订阅的名称
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=ffd64e5bd7e734c356987f415bc938d9 -->

<!-- pgdoc-cn_start sig_en=157c3cbb151ccbeaa716640d303cad6b sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       Process ID of the subscription worker process
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       订阅工作者进程的进程ID
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=157c3cbb151ccbeaa716640d303cad6b -->

<!-- pgdoc-cn_start sig_en=6299471d1e483f51e6947d561858e22f sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the relation that the worker is synchronizing; null for the
       main apply worker
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       工作器正在同步的关系的OID;Null用于主应用工作器
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=6299471d1e483f51e6947d561858e22f -->

<!-- pgdoc-cn_start sig_en=98dd4f19d76dcb23090ce54ed2727174 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>received_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       Last write-ahead log location received, the initial value of
       this field being 0
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>received_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       接收到的最后一个预写式日志位置，该字段的初始值为0
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=98dd4f19d76dcb23090ce54ed2727174 -->

<!-- pgdoc-cn_start sig_en=a247e051a97a9cecccb82a12f509ba0a sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_msg_send_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Send time of last message received from origin WAL sender
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_msg_send_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       从源头WAL发送器收到的最后一条信息的发送时间
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=a247e051a97a9cecccb82a12f509ba0a -->

<!-- pgdoc-cn_start sig_en=3c2001470a4a8defd03da2001cb67788 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_msg_receipt_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Receipt time of last message received from origin WAL sender
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_msg_receipt_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       从源头WAL发送器收到的最后一条信息的接收时间
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=3c2001470a4a8defd03da2001cb67788 -->

<!-- pgdoc-cn_start sig_en=08fb76d3b9dab6a06e0303cb65cd4109 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>latest_end_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       Last write-ahead log location reported to origin WAL sender
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>latest_end_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       向源头WAL发送器报告的最后的预写式日志位置
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=08fb76d3b9dab6a06e0303cb65cd4109 -->

<!-- pgdoc-cn_start sig_en=68b2da858fe103c6810bb1f5b390f290 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>latest_end_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time of last write-ahead log location reported to origin WAL
       sender
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>latest_end_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       向WAL发送器报告的最后一次预写式日志位置的时间
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=68b2da858fe103c6810bb1f5b390f290 -->
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="monitoring-pg-stat-subscription-stats">
  <title><structname>pg_stat_subscription_stats</structname></title>

<!-- pgdoc-cn_start sig_en=6e0fdc9f834053450a8e7d465b63460c sig_cn_org=6a3def47ec43a951b479389214b906c9 source=15.7 
  <indexterm>
   <primary>pg_stat_subscription_stats</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>pg_stat_subscription_stats</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=6e0fdc9f834053450a8e7d465b63460c -->

<!-- pgdoc-cn_start sig_en=e6f37fe834396ef9669d00d54e1fd199 sig_cn_org=4c111e3d029521dc99b82dea0590d529 source=15.7 
  <para>
   The <structname>pg_stat_subscription_stats</structname> view will contain
   one row per subscription.
  </para>
________________________________________________________-->
  <para>
   <structname>pg_stat_subscription_stats</structname>视图将包含每个订阅的一行。
</para>
<!-- pgdoc-cn_end sig_en=e6f37fe834396ef9669d00d54e1fd199 -->

  <table id="pg-stat-subscription-stats" xreflabel="pg_stat_subscription_stats">
<!-- pgdoc-cn_start sig_en=9eaabdca4d432ae3b5ccd8deb35212ba sig_cn_org=bf614a5288a90b4c83be54d8b45abed3 source=15.7 
   <title><structname>pg_stat_subscription_stats</structname> View</title>
________________________________________________________-->
<title><structname>pg_stat_subscription_stats</structname> 视图</title>
<!-- pgdoc-cn_end sig_en=9eaabdca4d432ae3b5ccd8deb35212ba -->
   <tgroup cols="1">
    <thead>
<!-- pgdoc-cn_start sig_en=19eb14a155d7416c3b9cad7829c11a9d sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=19eb14a155d7416c3b9cad7829c11a9d -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=f1fee0c60c03c86a10674c4394064ba6 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>subid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the subscription
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>subid</structfield> <type>oid</type>
      </para>
      <para>
       订阅的OID
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=f1fee0c60c03c86a10674c4394064ba6 -->

<!-- pgdoc-cn_start sig_en=ffd64e5bd7e734c356987f415bc938d9 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>subname</structfield> <type>name</type>
      </para>
      <para>
       Name of the subscription
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>subname</structfield> <type>name</type>
      </para>
      <para>
       订阅的名称
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=ffd64e5bd7e734c356987f415bc938d9 -->

<!-- pgdoc-cn_start sig_en=37c65225890fe81a86f7c82461d0d616 sig_cn_org=c57f6846ca8319a5535471ec474a6673 source=15.7 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>apply_error_count</structfield> <type>bigint</type>
      </para>
      <para>
       Number of times an error occurred while applying changes
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>apply_error_count</structfield> <type>bigint</type>
      </para>
      <para>
       应用更改时发生错误的次数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=37c65225890fe81a86f7c82461d0d616 -->

<!-- pgdoc-cn_start sig_en=c17aa22093e6e38704cd9884c158d849 sig_cn_org=dde2fce1b81c72821075e2294e9c8738 source=15.7 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sync_error_count</structfield> <type>bigint</type>
      </para>
      <para>
       Number of times an error occurred during the initial table
       synchronization
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sync_error_count</structfield> <type>bigint</type>
      </para>
      <para>
       在初始表同步期间发生错误的次数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=c17aa22093e6e38704cd9884c158d849 -->

<!-- pgdoc-cn_start sig_en=697bdc46a94ebbbd23b237e62a49caec sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time at which these statistics were last reset
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       这些统计数据最后一次重置的时间
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=697bdc46a94ebbbd23b237e62a49caec -->
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="monitoring-pg-stat-ssl-view">
  <title><structname>pg_stat_ssl</structname></title>

<!-- pgdoc-cn_start sig_en=7c094d3230cbf549fe8329630ee722e0 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>pg_stat_ssl</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>pg_stat_ssl</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=7c094d3230cbf549fe8329630ee722e0 -->

<!-- pgdoc-cn_start sig_en=0366314a5242ea29a991e2f844706e14 sig_cn_org=None source=14.1 
  <para>
   The <structname>pg_stat_ssl</structname> view will contain one row per
   backend or WAL sender process, showing statistics about SSL usage on
   this connection. It can be joined to <structname>pg_stat_activity</structname>
   or <structname>pg_stat_replication</structname> on the
   <structfield>pid</structfield> column to get more details about the
   connection.
  </para>
________________________________________________________-->
  <para>
   <structname>pg_stat_ssl</structname>视图将为每一个后端或者 WAL 发送进程包含一行，用来显示这个连接上的 SSL 使用情况。
   可以把它与<structname>pg_stat_activity</structname>或者<structname>pg_stat_replication</structname>通过<structfield>pid</structfield>列连接来得到更多有关该连接的细节。
  </para>
<!-- pgdoc-cn_end sig_en=0366314a5242ea29a991e2f844706e14 -->

  <table id="pg-stat-ssl-view" xreflabel="pg_stat_ssl">
<!-- pgdoc-cn_start sig_en=317b7ffacece340d5b32bf6a9051341e sig_cn_org=None source=14.1 
   <title><structname>pg_stat_ssl</structname> View</title>
________________________________________________________-->
   <title><structname>pg_stat_ssl</structname> 视图</title>
<!-- pgdoc-cn_end sig_en=317b7ffacece340d5b32bf6a9051341e -->
   <tgroup cols="1">
    <thead>
<!-- pgdoc-cn_start sig_en=19eb14a155d7416c3b9cad7829c11a9d sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=19eb14a155d7416c3b9cad7829c11a9d -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=7f34a0b318d22935787a3cb5563e92d6 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       Process ID of a backend or WAL sender process
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       后端或WAL发送器进程ID
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=7f34a0b318d22935787a3cb5563e92d6 -->

<!-- pgdoc-cn_start sig_en=49b11c8faa93b67b56b6b6abb92a5d4f sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>ssl</structfield> <type>boolean</type>
      </para>
      <para>
       True if SSL is used on this connection
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>ssl</structfield> <type>boolean</type>
      </para>
      <para>
       如果在此连接上使用SSL，则为真
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=49b11c8faa93b67b56b6b6abb92a5d4f -->

<!-- pgdoc-cn_start sig_en=8d7574d9b91a0a4c78ee730eef6fd3af sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>version</structfield> <type>text</type>
      </para>
      <para>
       Version of SSL in use, or NULL if SSL is not in use
       on this connection
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>version</structfield> <type>text</type>
      </para>
      <para>
       使用SSL的版本，如果此连接上没有使用SSL则为NULL
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=8d7574d9b91a0a4c78ee730eef6fd3af -->

<!-- pgdoc-cn_start sig_en=7f57dcb211bdc7e316c86e6d8812d4ca sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>cipher</structfield> <type>text</type>
      </para>
      <para>
       Name of SSL cipher in use, or NULL if SSL is not in use
       on this connection
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>cipher</structfield> <type>text</type>
      </para>
      <para>
       正在使用的SSL密码的名称，如果此连接上没有使用SSL则为NULL
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=7f57dcb211bdc7e316c86e6d8812d4ca -->

<!-- pgdoc-cn_start sig_en=ca4690dfc3856331bf70313706b6ee84 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>bits</structfield> <type>integer</type>
      </para>
      <para>
       Number of bits in the encryption algorithm used, or NULL
       if SSL is not used on this connection
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>bits</structfield> <type>integer</type>
      </para>
      <para>
       使用的加密算法中的位数，如果此连接上没有使用SSL则为NULL
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=ca4690dfc3856331bf70313706b6ee84 -->

<!-- pgdoc-cn_start sig_en=dda02012c8fc05d45366e602fad74a15 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>client_dn</structfield> <type>text</type>
      </para>
      <para>
       Distinguished Name (DN) field from the client certificate
       used, or NULL if no client certificate was supplied or if SSL
       is not in use on this connection. This field is truncated if the
       DN field is longer than <symbol>NAMEDATALEN</symbol> (64 characters
       in a standard build).
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>client_dn</structfield> <type>text</type>
      </para>
      <para>
       区别名称(DN，Distinguished Name)字段与使用的客户端证书，如果没有提供客户端证书或在此连接上没有使用SSL，则为NULL。
       如果DN字段长于<symbol>NAMEDATALEN</symbol>(标准构建中为64个字符)，则该字段将被截断。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=dda02012c8fc05d45366e602fad74a15 -->

<!-- pgdoc-cn_start sig_en=51fbf5f48a2b22ba90d9b7b23bfcbb61 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>client_serial</structfield> <type>numeric</type>
      </para>
      <para>
       Serial number of the client certificate, or NULL if no client
       certificate was supplied or if SSL is not in use on this connection.  The
       combination of certificate serial number and certificate issuer uniquely
       identifies a certificate (unless the issuer erroneously reuses serial
       numbers).
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>client_serial</structfield> <type>numeric</type>
      </para>
      <para>
       客户端证书的序列号，如果没有提供客户端证书或在此连接上没有使用SSL，则为NULL。
       证书序列号和证书颁发者的组合唯一标识一个证书(除非颁发者错误地重用序列号)。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=51fbf5f48a2b22ba90d9b7b23bfcbb61 -->

<!-- pgdoc-cn_start sig_en=0e4a8d21abe5307d8761dc6b00977210 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>issuer_dn</structfield> <type>text</type>
      </para>
      <para>
       DN of the issuer of the client certificate, or NULL if no client
       certificate was supplied or if SSL is not in use on this connection.
       This field is truncated like <structfield>client_dn</structfield>.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>issuer_dn</structfield> <type>text</type>
      </para>
      <para>
       客户端证书颁发者的区别名称(DN，Distinguished Name)，如果没有提供客户端证书或在此连接上没有使用SSL，则为NULL。该字段像<structfield>client_dn</structfield>一样被截断。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=0e4a8d21abe5307d8761dc6b00977210 -->
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="monitoring-pg-stat-gssapi-view">
  <title><structname>pg_stat_gssapi</structname></title>

<!-- pgdoc-cn_start sig_en=c081c637b42af7a2437f37f6d21a967a sig_cn_org=None source=14.1 
  <indexterm>
   <primary>pg_stat_gssapi</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>pg_stat_gssapi</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=c081c637b42af7a2437f37f6d21a967a -->

<!-- pgdoc-cn_start sig_en=ef7162d866d891d0605d61c220b1f6b1 sig_cn_org=None source=14.1 
  <para>
   The <structname>pg_stat_gssapi</structname> view will contain one row per
   backend, showing information about GSSAPI usage on this connection. It can
   be joined to <structname>pg_stat_activity</structname> or
   <structname>pg_stat_replication</structname> on the
   <structfield>pid</structfield> column to get more details about the
   connection.
  </para>
________________________________________________________-->
  <para>
   <structname>pg_stat_gssapi</structname>视图将包含每一个后端一个行，显示该连接上的GSSAPI使用情况。
   它可以加入到<structname>pg_stat_activity</structname>或<structname>pg_stat_replication</structname>上的<structfield>pid</structfield>列，获取更多关于连接的详细信息。
  </para>
<!-- pgdoc-cn_end sig_en=ef7162d866d891d0605d61c220b1f6b1 -->

  <table id="pg-stat-gssapi-view" xreflabel="pg_stat_gssapi">
<!-- pgdoc-cn_start sig_en=bd559b8b7b92d5c7599ed6555f57c10a sig_cn_org=None source=14.1 
   <title><structname>pg_stat_gssapi</structname> View</title>
________________________________________________________-->
   <title><structname>pg_stat_gssapi</structname> 视图</title>
<!-- pgdoc-cn_end sig_en=bd559b8b7b92d5c7599ed6555f57c10a -->
   <tgroup cols="1">
    <thead>
<!-- pgdoc-cn_start sig_en=19eb14a155d7416c3b9cad7829c11a9d sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=19eb14a155d7416c3b9cad7829c11a9d -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=036d9b951bef7bf9129271f16a7706b5 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       Process ID of a backend
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       后端进程ID
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=036d9b951bef7bf9129271f16a7706b5 -->

<!-- pgdoc-cn_start sig_en=7f44faed58c3cb12a87587f08693d0f4 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>gss_authenticated</structfield> <type>boolean</type>
      </para>
      <para>
       True if GSSAPI authentication was used for this connection
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>gss_authenticated</structfield> <type>boolean</type>
      </para>
      <para>
       如果此连接使用了GSSAPI身份验证，则为True
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=7f44faed58c3cb12a87587f08693d0f4 -->

<!-- pgdoc-cn_start sig_en=56b9433e1c7a4ef920ff4d658ad7f3e0 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>principal</structfield> <type>text</type>
      </para>
      <para>
       Principal used to authenticate this connection, or NULL
       if GSSAPI was not used to authenticate this connection.  This
       field is truncated if the principal is longer than
       <symbol>NAMEDATALEN</symbol> (64 characters in a standard build).
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>principal</structfield> <type>text</type>
      </para>
      <para>
       用于验证此连接的主体，如果未使用GSSAPI对此连接进行身份验证，则为NULL。
       如果主体长度超过<symbol>NAMEDATALEN</symbol>(标准构建中为64个字符)，则该字段被截断。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=56b9433e1c7a4ef920ff4d658ad7f3e0 -->

<!-- pgdoc-cn_start sig_en=22fd8ba0efccc01aed3377f8252939d5 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>encrypted</structfield> <type>boolean</type>
      </para>
      <para>
       True if GSSAPI encryption is in use on this connection
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>encrypted</structfield> <type>boolean</type>
      </para>
      <para>
       如果在此连接上使用了GSSAPI加密，则为真
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=22fd8ba0efccc01aed3377f8252939d5 -->
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="monitoring-pg-stat-archiver-view">
  <title><structname>pg_stat_archiver</structname></title>

<!-- pgdoc-cn_start sig_en=bc77e602aa0de20546d145a63c33ff43 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>pg_stat_archiver</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>pg_stat_archiver</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=bc77e602aa0de20546d145a63c33ff43 -->

<!-- pgdoc-cn_start sig_en=aa26eea923fe6f26f4de8aeea03f50e9 sig_cn_org=None source=14.1 
  <para>
   The <structname>pg_stat_archiver</structname> view will always have a
   single row, containing data about the archiver process of the cluster.
  </para>
________________________________________________________-->
  <para>
   <structname>pg_stat_archiver</structname>视图总是有一行，其中包含关于集群的存档进程的数据。
  </para>
<!-- pgdoc-cn_end sig_en=aa26eea923fe6f26f4de8aeea03f50e9 -->

  <table id="pg-stat-archiver-view" xreflabel="pg_stat_archiver">
<!-- pgdoc-cn_start sig_en=55c0ac0987932d7170f9cca1b5873f9a sig_cn_org=None source=14.1 
   <title><structname>pg_stat_archiver</structname> View</title>
________________________________________________________-->
   <title><structname>pg_stat_archiver</structname> 视图</title>
<!-- pgdoc-cn_end sig_en=55c0ac0987932d7170f9cca1b5873f9a -->
   <tgroup cols="1">
    <thead>
<!-- pgdoc-cn_start sig_en=19eb14a155d7416c3b9cad7829c11a9d sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=19eb14a155d7416c3b9cad7829c11a9d -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=e63d1d39a29c107e3885e523279334de sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>archived_count</structfield> <type>bigint</type>
      </para>
      <para>
       Number of WAL files that have been successfully archived
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>archived_count</structfield> <type>bigint</type>
      </para>
      <para>
       已成功存档的WAL文件数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=e63d1d39a29c107e3885e523279334de -->

<!-- pgdoc-cn_start sig_en=0878d5491ad26bd2f01278d276413393 sig_cn_org=63016bb1fb0a5eb0163ecd4a963d55c9 source=15.7 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_archived_wal</structfield> <type>text</type>
      </para>
      <para>
       Name of the WAL file most recently successfully archived
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_archived_wal</structfield> <type>text</type>
      </para>
      <para>
       最近成功归档的WAL文件的名称
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=0878d5491ad26bd2f01278d276413393 -->

<!-- pgdoc-cn_start sig_en=b5cffb0b9c9ce10e44e193bd98c47918 sig_cn_org=083fec287f6a146404a91f60f9a86696 source=15.7 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_archived_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time of the most recent successful archive operation
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_archived_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       最近成功归档操作的时间
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=b5cffb0b9c9ce10e44e193bd98c47918 -->

<!-- pgdoc-cn_start sig_en=dd2e7251eed536e3e78abdd4947f511e sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>failed_count</structfield> <type>bigint</type>
      </para>
      <para>
       Number of failed attempts for archiving WAL files
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>failed_count</structfield> <type>bigint</type>
      </para>
      <para>
       记录WAL文件归档失败次数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=dd2e7251eed536e3e78abdd4947f511e -->

<!-- pgdoc-cn_start sig_en=18fc7a75525bebe19620bd709170cb15 sig_cn_org=b5135446955f0996879d1dfed3f63b2f source=15.7 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_failed_wal</structfield> <type>text</type>
      </para>
      <para>
       Name of the WAL file of the most recent failed archival operation
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_failed_wal</structfield> <type>text</type>
      </para>
      <para>
       最近一次归档操作失败的WAL文件的名称
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=18fc7a75525bebe19620bd709170cb15 -->

<!-- pgdoc-cn_start sig_en=deae30a087ea638908888e7039ae444a sig_cn_org=cac5db6861b79eade45ae2f9e6727331 source=15.7 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_failed_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time of the most recent failed archival operation
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_failed_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       最近一次归档操作失败的时间
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=deae30a087ea638908888e7039ae444a -->

<!-- pgdoc-cn_start sig_en=697bdc46a94ebbbd23b237e62a49caec sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time at which these statistics were last reset
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       这些统计数据最后一次重置的时间
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=697bdc46a94ebbbd23b237e62a49caec -->
    </tbody>
   </tgroup>
  </table>

<!-- pgdoc-cn_start sig_en=7775c70f463fcdd31edc390ac5966780 sig_cn_org=a18234949c131ff9734a0d2db954b1d3 source=15.7 
  <para>
    Normally, WAL files are archived in order, oldest to newest, but that is
    not guaranteed, and does not hold under special circumstances like when
    promoting a standby or after crash recovery. Therefore it is not safe to
    assume that all files older than
    <structfield>last_archived_wal</structfield> have also been successfully
    archived.
  </para>
________________________________________________________-->
  <para>
    通常，WAL文件按照顺序进行归档，从最旧到最新，但这并不是保证，也不适用于特殊情况，比如在推广备用机或崩溃恢复后。因此，不能安全地假设所有早于
    <structfield>last_archived_wal</structfield>的文件也已成功归档。
  </para>
<!-- pgdoc-cn_end sig_en=7775c70f463fcdd31edc390ac5966780 -->

 </sect2>

 <sect2 id="monitoring-pg-stat-bgwriter-view">
  <title><structname>pg_stat_bgwriter</structname></title>

<!-- pgdoc-cn_start sig_en=5d13931a758bbee7a259b05e94b60bf9 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>pg_stat_bgwriter</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>pg_stat_bgwriter</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=5d13931a758bbee7a259b05e94b60bf9 -->

<!-- pgdoc-cn_start sig_en=9eeeec01d7c793a40045d0039ad30d83 sig_cn_org=None source=14.1 
  <para>
   The <structname>pg_stat_bgwriter</structname> view will always have a
   single row, containing global data for the cluster.
  </para>
________________________________________________________-->
  <para>
   <structname>pg_stat_bgwriter</structname>视图始终只有一行，其中包含集群的全局数据。
  </para>
<!-- pgdoc-cn_end sig_en=9eeeec01d7c793a40045d0039ad30d83 -->

  <table id="pg-stat-bgwriter-view" xreflabel="pg_stat_bgwriter">
<!-- pgdoc-cn_start sig_en=29b5fb91f3c8c408268c7021f306a89e sig_cn_org=None source=14.1 
   <title><structname>pg_stat_bgwriter</structname> View</title>
________________________________________________________-->
   <title><structname>pg_stat_bgwriter</structname> View</title>
<!-- pgdoc-cn_end sig_en=29b5fb91f3c8c408268c7021f306a89e -->
   <tgroup cols="1">
    <thead>
<!-- pgdoc-cn_start sig_en=19eb14a155d7416c3b9cad7829c11a9d sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=19eb14a155d7416c3b9cad7829c11a9d -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=72ab3dff1d5ebca2204b0277b0846531 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>checkpoints_timed</structfield> <type>bigint</type>
      </para>
      <para>
       Number of scheduled checkpoints that have been performed
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>checkpoints_timed</structfield> <type>bigint</type>
      </para>
      <para>
       已执行的预定检查点数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=72ab3dff1d5ebca2204b0277b0846531 -->

<!-- pgdoc-cn_start sig_en=99f2a7f962af515a224d540ce75ace78 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>checkpoints_req</structfield> <type>bigint</type>
      </para>
      <para>
       Number of requested checkpoints that have been performed
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>checkpoints_req</structfield> <type>bigint</type>
      </para>
      <para>
       请求已执行的检查点数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=99f2a7f962af515a224d540ce75ace78 -->

<!-- pgdoc-cn_start sig_en=9282ae48928657944726971a4c8641f6 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>checkpoint_write_time</structfield> <type>double precision</type>
      </para>
      <para>
       Total amount of time that has been spent in the portion of
       checkpoint processing where files are written to disk, in milliseconds
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>checkpoint_write_time</structfield> <type>double precision</type>
      </para>
      <para>
       检查点处理中将文件写入磁盘的部分所花费的总时间，以毫秒为单位
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=9282ae48928657944726971a4c8641f6 -->

<!-- pgdoc-cn_start sig_en=181a75641ac18879b9a0e1b1855a4302 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>checkpoint_sync_time</structfield> <type>double precision</type>
      </para>
      <para>
       Total amount of time that has been spent in the portion of
       checkpoint processing where files are synchronized to disk, in
       milliseconds
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>checkpoint_sync_time</structfield> <type>double precision</type>
      </para>
      <para>
       检查点处理中将文件同步到磁盘的部分所花费的总时间，以毫秒为单位
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=181a75641ac18879b9a0e1b1855a4302 -->

<!-- pgdoc-cn_start sig_en=48518c66479be989800babef864d5467 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>buffers_checkpoint</structfield> <type>bigint</type>
      </para>
      <para>
       Number of buffers written during checkpoints
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>buffers_checkpoint</structfield> <type>bigint</type>
      </para>
      <para>
       检查点期间写入的缓冲区数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=48518c66479be989800babef864d5467 -->

<!-- pgdoc-cn_start sig_en=4599105f92a31fab302c099708b9a5aa sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>buffers_clean</structfield> <type>bigint</type>
      </para>
      <para>
       Number of buffers written by the background writer
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>buffers_clean</structfield> <type>bigint</type>
      </para>
      <para>
       后台写入器写入的缓冲区数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=4599105f92a31fab302c099708b9a5aa -->

<!-- pgdoc-cn_start sig_en=4157066a6686b184185f1a064eb9ebf9 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>maxwritten_clean</structfield> <type>bigint</type>
      </para>
      <para>
       Number of times the background writer stopped a cleaning
       scan because it had written too many buffers
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>maxwritten_clean</structfield> <type>bigint</type>
      </para>
      <para>
       后台写入器因为写入太多缓冲区而停止清理扫描的次数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=4157066a6686b184185f1a064eb9ebf9 -->

<!-- pgdoc-cn_start sig_en=8fd2211582d91a73f8eba42fe29992f5 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>buffers_backend</structfield> <type>bigint</type>
      </para>
      <para>
       Number of buffers written directly by a backend
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>buffers_backend</structfield> <type>bigint</type>
      </para>
      <para>
       后端直接写入的缓冲区数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=8fd2211582d91a73f8eba42fe29992f5 -->

<!-- pgdoc-cn_start sig_en=c9a5797ad7040e94a37621347bdaecdc sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>buffers_backend_fsync</structfield> <type>bigint</type>
      </para>
      <para>
       Number of times a backend had to execute its own
       <function>fsync</function> call (normally the background writer handles those
       even when the backend does its own write)
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>buffers_backend_fsync</structfield> <type>bigint</type>
      </para>
      <para>
       后端必须执行自己的<function>fsync</function>调用的次数(通常后台写入器处理这些，即使后端执行自己的写入)
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=c9a5797ad7040e94a37621347bdaecdc -->

<!-- pgdoc-cn_start sig_en=072a7ed7d2ebe8d5ef5fc09ebaefdd15 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>buffers_alloc</structfield> <type>bigint</type>
      </para>
      <para>
       Number of buffers allocated
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>buffers_alloc</structfield> <type>bigint</type>
      </para>
      <para>
       分配的缓冲区数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=072a7ed7d2ebe8d5ef5fc09ebaefdd15 -->

<!-- pgdoc-cn_start sig_en=697bdc46a94ebbbd23b237e62a49caec sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time at which these statistics were last reset
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       这些统计数据最后一次重置的时间
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=697bdc46a94ebbbd23b237e62a49caec -->
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="monitoring-pg-stat-wal-view">
   <title><structname>pg_stat_wal</structname></title>

<!-- pgdoc-cn_start sig_en=d005503eacc91b61d48f5ccc0adff7a2 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>pg_stat_wal</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>pg_stat_wal</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=d005503eacc91b61d48f5ccc0adff7a2 -->

<!-- pgdoc-cn_start sig_en=470100de02299e1f016d79f27ca6fa63 sig_cn_org=None source=14.1 
  <para>
   The <structname>pg_stat_wal</structname> view will always have a
   single row, containing data about WAL activity of the cluster.
  </para>
________________________________________________________-->
  <para>
   <structname>pg_stat_wal</structname> 视图一直有一行，包含关于集群的WAL活动的数据。
  </para>
<!-- pgdoc-cn_end sig_en=470100de02299e1f016d79f27ca6fa63 -->

  <table id="pg-stat-wal-view" xreflabel="pg_stat_wal">
<!-- pgdoc-cn_start sig_en=4a770115113e6bee848251891b8c3df2 sig_cn_org=None source=14.1 
   <title><structname>pg_stat_wal</structname> View</title>
________________________________________________________-->
   <title><structname>pg_stat_wal</structname> View</title>
<!-- pgdoc-cn_end sig_en=4a770115113e6bee848251891b8c3df2 -->
   <tgroup cols="1">
    <thead>
<!-- pgdoc-cn_start sig_en=19eb14a155d7416c3b9cad7829c11a9d sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=19eb14a155d7416c3b9cad7829c11a9d -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=49e3209dacd1a98b44dbc1b5adebd236 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_records</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of WAL records generated
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_records</structfield> <type>bigint</type>
      </para>
      <para>
       生成的WAL记录的总数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=49e3209dacd1a98b44dbc1b5adebd236 -->

<!-- pgdoc-cn_start sig_en=49ebd8e16bdc2f231e4f5e373ab369ec sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_fpi</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of WAL full page images generated
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_fpi</structfield> <type>bigint</type>
      </para>
      <para>
       生成的WAL全页映像的总数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=49ebd8e16bdc2f231e4f5e373ab369ec -->

<!-- pgdoc-cn_start sig_en=6a6a12cae66c0cdded75b0454ca8d75f sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_bytes</structfield> <type>numeric</type>
      </para>
      <para>
       Total amount of WAL generated in bytes
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_bytes</structfield> <type>numeric</type>
      </para>
      <para>
       生成的WAL总数，以字节计
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=6a6a12cae66c0cdded75b0454ca8d75f -->

<!-- pgdoc-cn_start sig_en=d5e6c635b242616233788aa4a2e22bd2 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_buffers_full</structfield> <type>bigint</type>
      </para>
      <para>
       Number of times WAL data was written to disk because WAL buffers became full
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_buffers_full</structfield> <type>bigint</type>
      </para>
      <para>
       因为缓冲区已满，WAL数据被写入磁盘的次数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=d5e6c635b242616233788aa4a2e22bd2 -->

<!-- pgdoc-cn_start sig_en=19812b2e025cc24dff2719781907fbff sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_write</structfield> <type>bigint</type>
      </para>
      <para>
       Number of times WAL buffers were written out to disk via
       <function>XLogWrite</function> request.
       See <xref linkend="wal-configuration"/> for more information about
       the internal WAL function <function>XLogWrite</function>.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_write</structfield> <type>bigint</type>
      </para>
      <para>
       通过<function>XLogWrite</function>请求，WAL缓冲区被写入到磁盘的次数。
       有关内部WAL函数<function>XLogWrite</function>的更多信息，请参见<xref linkend="wal-configuration"/>。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=19812b2e025cc24dff2719781907fbff -->

<!-- pgdoc-cn_start sig_en=09f05ed676186d1283f2b27a790e09fa sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_sync</structfield> <type>bigint</type>
      </para>
      <para>
       Number of times WAL files were synced to disk via
       <function>issue_xlog_fsync</function> request
       (if <xref linkend="guc-fsync"/> is <literal>on</literal> and
       <xref linkend="guc-wal-sync-method"/> is either
       <literal>fdatasync</literal>, <literal>fsync</literal> or
       <literal>fsync_writethrough</literal>, otherwise zero).
       See <xref linkend="wal-configuration"/> for more information about
       the internal WAL function <function>issue_xlog_fsync</function>.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_sync</structfield> <type>bigint</type>
      </para>
      <para>
       通过<function>issue_xlog_fsync</function> 请求将WAL文件同步到磁盘的次数(如果<xref linkend="guc-fsync"/> 是 <literal>on</literal>且<xref linkend="guc-wal-sync-method"/>是<literal>fdatasync</literal>, <literal>fsync</literal> 或 <literal>fsync_writethrough</literal>，否则为零)。
       有关内部WAL函数<function>issue_xlog_fsync</function>的更多信息，参见<xref linkend="wal-configuration"/>。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=09f05ed676186d1283f2b27a790e09fa -->

<!-- pgdoc-cn_start sig_en=63c20e7a9fdbf39258e015e530e21019 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_write_time</structfield> <type>double precision</type>
      </para>
      <para>
       Total amount of time spent writing WAL buffers to disk via
       <function>XLogWrite</function> request, in milliseconds
       (if <xref linkend="guc-track-wal-io-timing"/> is enabled,
       otherwise zero).  This includes the sync time when
       <varname>wal_sync_method</varname> is either
       <literal>open_datasync</literal> or <literal>open_sync</literal>.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_write_time</structfield> <type>double precision</type>
      </para>
      <para>
       通过<function>XLogWrite</function>请求将WAL缓冲区写入磁盘所消耗的总时间，以毫秒计(如果<xref linkend="guc-track-wal-io-timing"/>是启用的，否则为零)。
       这包括当<varname>wal_sync_method</varname>为<literal>open_datasync</literal> 或 <literal>open_sync</literal>时的同步时间。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=63c20e7a9fdbf39258e015e530e21019 -->

<!-- pgdoc-cn_start sig_en=3f9b4244900bc8aaa31478d7b8d156e7 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_sync_time</structfield> <type>double precision</type>
      </para>
      <para>
       Total amount of time spent syncing WAL files to disk via
       <function>issue_xlog_fsync</function> request, in milliseconds
       (if <varname>track_wal_io_timing</varname> is enabled,
       <varname>fsync</varname> is <literal>on</literal>, and
       <varname>wal_sync_method</varname> is either
       <literal>fdatasync</literal>, <literal>fsync</literal> or
       <literal>fsync_writethrough</literal>, otherwise zero).
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_sync_time</structfield> <type>double precision</type>
      </para>
      <para>
       通过<function>issue_xlog_fsync</function>请求将WAL文件同步到磁盘所消耗的总时间，以毫秒计(如果 <varname>track_wal_io_timing</varname> 被启用，<varname>fsync</varname> is <literal>on</literal>, 和 <varname>wal_sync_method</varname> 为 <literal>fdatasync</literal>, <literal>fsync</literal> 或 <literal>fsync_writethrough</literal>, 否则为零).
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=3f9b4244900bc8aaa31478d7b8d156e7 -->

<!-- pgdoc-cn_start sig_en=697bdc46a94ebbbd23b237e62a49caec sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time at which these statistics were last reset
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       这些统计数据最后一次重置的时间
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=697bdc46a94ebbbd23b237e62a49caec -->
     </tbody>
   </tgroup>
  </table>

</sect2>

 <sect2 id="monitoring-pg-stat-database-view">
  <title><structname>pg_stat_database</structname></title>

<!-- pgdoc-cn_start sig_en=fe12a71bc9930b3ab9d3d1fae3db89e6 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>pg_stat_database</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>pg_stat_database</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=fe12a71bc9930b3ab9d3d1fae3db89e6 -->

<!-- pgdoc-cn_start sig_en=ead694c80bd3a9423f8913e6420c7f4b sig_cn_org=None source=14.1 
  <para>
   The <structname>pg_stat_database</structname> view will contain one row
   for each database in the cluster, plus one for shared objects, showing
   database-wide statistics.
  </para>
________________________________________________________-->
  <para>
   <structname>pg_stat_database</structname>视图将包含一行用于集群中的每个数据库，加一行用于共享对象，显示数据库范围的统计信息。
  </para>
<!-- pgdoc-cn_end sig_en=ead694c80bd3a9423f8913e6420c7f4b -->

  <table id="pg-stat-database-view" xreflabel="pg_stat_database">
<!-- pgdoc-cn_start sig_en=7dfb3d64ba72ba4f6b229352e5e7b82c sig_cn_org=None source=14.1 
   <title><structname>pg_stat_database</structname> View</title>
________________________________________________________-->
   <title><structname>pg_stat_database</structname> 视图</title>
<!-- pgdoc-cn_end sig_en=7dfb3d64ba72ba4f6b229352e5e7b82c -->
   <tgroup cols="1">
    <thead>
<!-- pgdoc-cn_start sig_en=19eb14a155d7416c3b9cad7829c11a9d sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=19eb14a155d7416c3b9cad7829c11a9d -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=6ac86a6b5cd49fdcf64a3077f8e25bd5 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datid</structfield> <type>oid</type>
      </para>
      <para>
       OID of this database, or 0 for objects belonging to a shared
       relation
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datid</structfield> <type>oid</type>
      </para>
      <para>
       该数据库的OID，属于共享关系的对象为0
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=6ac86a6b5cd49fdcf64a3077f8e25bd5 -->

<!-- pgdoc-cn_start sig_en=a7f6ad74bfb13ee4f41c85969c13db66 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datname</structfield> <type>name</type>
      </para>
      <para>
       Name of this database, or <literal>NULL</literal> for shared
       objects.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datname</structfield> <type>name</type>
      </para>
      <para>
       这个数据库的名称，或者共享对象为<literal>NULL</literal>。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=a7f6ad74bfb13ee4f41c85969c13db66 -->

<!-- pgdoc-cn_start sig_en=79aad7240a2ea3d08bc1af0f13995ba0 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>numbackends</structfield> <type>integer</type>
      </para>
      <para>
       Number of backends currently connected to this database, or
       <literal>NULL</literal> for shared objects.  This is the only column
       in this view that returns a value reflecting current state; all other
       columns return the accumulated values since the last reset.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>numbackends</structfield> <type>integer</type>
      </para>
      <para>
       当前连接到此数据库的后端数，对于共享对象则为<literal>NULL</literal>。
       这是该视图中唯一返回反映当前状态的值的列;所有其他列返回自上次重置以来累积的值。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=79aad7240a2ea3d08bc1af0f13995ba0 -->

<!-- pgdoc-cn_start sig_en=c396d685320f6892bb540c9a4fdc59b2 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>xact_commit</structfield> <type>bigint</type>
      </para>
      <para>
       Number of transactions in this database that have been
       committed
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>xact_commit</structfield> <type>bigint</type>
      </para>
      <para>
       此数据库中已提交的事务数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=c396d685320f6892bb540c9a4fdc59b2 -->

<!-- pgdoc-cn_start sig_en=1feb075d0fe7f0a2d2faf1c3950bfca6 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>xact_rollback</structfield> <type>bigint</type>
      </para>
      <para>
       Number of transactions in this database that have been
       rolled back
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>xact_rollback</structfield> <type>bigint</type>
      </para>
      <para>
       该数据库中已回滚的事务数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=1feb075d0fe7f0a2d2faf1c3950bfca6 -->

<!-- pgdoc-cn_start sig_en=47f661dcf260d35e9c88f421a7d56293 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       Number of disk blocks read in this database
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       在该数据库中读取的磁盘块数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=47f661dcf260d35e9c88f421a7d56293 -->

<!-- pgdoc-cn_start sig_en=710e0c146c230f68211bf2107ed260f9 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       Number of times disk blocks were found already in the buffer
       cache, so that a read was not necessary (this only includes hits in the
       PostgreSQL buffer cache, not the operating system's file system cache)
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       在缓存中发现磁盘块的次数，因此读取不是必需的(这只包括在PostgreSQL缓存中，而不是在操作系统的文件系统缓存中)
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=710e0c146c230f68211bf2107ed260f9 -->

<!-- pgdoc-cn_start sig_en=ad12d511749a6228fea7186d09bf9cd3 sig_cn_org=623821e7f79177edd31d56e23f5b5d15 source=15.7 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tup_returned</structfield> <type>bigint</type>
      </para>
      <para>
       Number of live rows fetched by sequential scans and index entries returned by index scans in this database
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tup_returned</structfield> <type>bigint</type>
      </para>
      <para>
       由顺序扫描获取的活动行数和由索引扫描返回的索引条目数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=ad12d511749a6228fea7186d09bf9cd3 -->

<!-- pgdoc-cn_start sig_en=4a0eb97262f227c7e14237e97d21494e sig_cn_org=eae63d5f02c6492e2f2f14a1019a2c62 source=15.7 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tup_fetched</structfield> <type>bigint</type>
      </para>
      <para>
       Number of live rows fetched by index scans in this database
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tup_fetched</structfield> <type>bigint</type>
      </para>
      <para>
       该数据库中由索引扫描检索的活动行数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=4a0eb97262f227c7e14237e97d21494e -->

<!-- pgdoc-cn_start sig_en=1db2c7759c26a005335910bc135af539 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tup_inserted</structfield> <type>bigint</type>
      </para>
      <para>
       Number of rows inserted by queries in this database
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tup_inserted</structfield> <type>bigint</type>
      </para>
      <para>
       查询在该数据库中插入的行数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=1db2c7759c26a005335910bc135af539 -->

<!-- pgdoc-cn_start sig_en=1436158d83840dc4bd1a1b873d214fae sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tup_updated</structfield> <type>bigint</type>
      </para>
      <para>
       Number of rows updated by queries in this database
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tup_updated</structfield> <type>bigint</type>
      </para>
      <para>
       这个数据库中查询更新的行数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=1436158d83840dc4bd1a1b873d214fae -->

<!-- pgdoc-cn_start sig_en=30d4fbc484df0bdf616038c303695a41 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tup_deleted</structfield> <type>bigint</type>
      </para>
      <para>
       Number of rows deleted by queries in this database
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tup_deleted</structfield> <type>bigint</type>
      </para>
      <para>
       这个数据库中被查询删除的行数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=30d4fbc484df0bdf616038c303695a41 -->

<!-- pgdoc-cn_start sig_en=b1d99d9193818835a3f562bd02f2d2d3 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>conflicts</structfield> <type>bigint</type>
      </para>
      <para>
       Number of queries canceled due to conflicts with recovery
       in this database. (Conflicts occur only on standby servers; see
       <link linkend="monitoring-pg-stat-database-conflicts-view">
       <structname>pg_stat_database_conflicts</structname></link> for details.)
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>conflicts</structfield> <type>bigint</type>
      </para>
      <para>
       由于与此数据库中的恢复冲突而取消的查询数。(冲突只发生在备用服务器上;详请参见<link linkend="monitoring-pg-stat-database-conflicts-view">
       <structname>pg_stat_database_conflicts</structname></link>。)
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=b1d99d9193818835a3f562bd02f2d2d3 -->

<!-- pgdoc-cn_start sig_en=5242a8d3454fe7ee9d458b919adfa607 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>temp_files</structfield> <type>bigint</type>
      </para>
      <para>
       Number of temporary files created by queries in this database.
       All temporary files are counted, regardless of why the temporary file
       was created (e.g., sorting or hashing), and regardless of the
       <xref linkend="guc-log-temp-files"/> setting.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>temp_files</structfield> <type>bigint</type>
      </para>
      <para>
       这个数据库中查询创建的临时文件的数量。所有临时文件都将被计数，而不顾及临时文件为什么被创建(例如，排序或散列)，也不考虑<xref linkend="guc-log-temp-files"/>设置。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=5242a8d3454fe7ee9d458b919adfa607 -->

<!-- pgdoc-cn_start sig_en=0d5b58086e65eb7c5a462f055520aecd sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>temp_bytes</structfield> <type>bigint</type>
      </para>
      <para>
       Total amount of data written to temporary files by queries in
       this database. All temporary files are counted, regardless of why
       the temporary file was created, and
       regardless of the <xref linkend="guc-log-temp-files"/> setting.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>temp_bytes</structfield> <type>bigint</type>
      </para>
      <para>
       这个数据库中的查询写入临时文件的数据总量。所有临时文件都将被计数，而不考虑临时文件为什么被创建，也不考虑<xref linkend="guc-log-temp-files"/>设置。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=0d5b58086e65eb7c5a462f055520aecd -->

<!-- pgdoc-cn_start sig_en=d8e234c0231a3e3dbfc7e3f4af3ea507 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>deadlocks</structfield> <type>bigint</type>
      </para>
      <para>
       Number of deadlocks detected in this database
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>deadlocks</structfield> <type>bigint</type>
      </para>
      <para>
       在此数据库中检测到的死锁数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=d8e234c0231a3e3dbfc7e3f4af3ea507 -->

<!-- pgdoc-cn_start sig_en=321f8a24fe53a591239e735b9500625c sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>checksum_failures</structfield> <type>bigint</type>
      </para>
      <para>
       Number of data page checksum failures detected in this
       database (or on a shared object), or NULL if data checksums are not
       enabled.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>checksum_failures</structfield> <type>bigint</type>
      </para>
      <para>
       在此数据库(或共享对象)中检测到的数据页校验码失败数，如果没有启用数据校验码则为NULL。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=321f8a24fe53a591239e735b9500625c -->

<!-- pgdoc-cn_start sig_en=6fab103fc40a56c7af5ef483d964de95 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>checksum_last_failure</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time at which the last data page checksum failure was detected in
       this database (or on a shared object), or NULL if data checksums are not
       enabled.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>checksum_last_failure</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       在此数据库(或共享对象)中检测到最后一个数据页校验码失败的时间，如果没有启用数据校验码则为NULL。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=6fab103fc40a56c7af5ef483d964de95 -->

<!-- pgdoc-cn_start sig_en=2953564caf0464a5784b98299c1aeea9 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blk_read_time</structfield> <type>double precision</type>
      </para>
      <para>
       Time spent reading data file blocks by backends in this database,
       in milliseconds (if <xref linkend="guc-track-io-timing"/> is enabled,
       otherwise zero)
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blk_read_time</structfield> <type>double precision</type>
      </para>
      <para>
       在这个数据库中通过后端读取数据文件块所花费的时间，以毫秒为单位(如果启用了<xref linkend="guc-track-io-timing"/>，否则为零)
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=2953564caf0464a5784b98299c1aeea9 -->

<!-- pgdoc-cn_start sig_en=1b189066fab974a15b4a1a3343fed3c4 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blk_write_time</structfield> <type>double precision</type>
      </para>
      <para>
       Time spent writing data file blocks by backends in this database,
       in milliseconds (if <xref linkend="guc-track-io-timing"/> is enabled,
       otherwise zero)
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blk_write_time</structfield> <type>double precision</type>
      </para>
      <para>
       在这个数据库中通过后端写数据文件块所花费的时间，以毫秒为单位(如果启用了<xref linkend="guc-track-io-timing"/>，否则为零)
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=1b189066fab974a15b4a1a3343fed3c4 -->

<!-- pgdoc-cn_start sig_en=bc6175c05d9ae49c8d3e5d039db6ba2b sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>session_time</structfield> <type>double precision</type>
      </para>
      <para>
       Time spent by database sessions in this database, in milliseconds
       (note that statistics are only updated when the state of a session
       changes, so if sessions have been idle for a long time, this idle time
       won't be included)
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>session_time</structfield> <type>double precision</type>
      </para>
      <para>
       此数据库中数据库会话所消耗的时间，以毫秒计(注意统计信息仅在会话状态发生变化时更新，因此如果会话空闲很长时间，则不包括此空闲时间)
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=bc6175c05d9ae49c8d3e5d039db6ba2b -->

<!-- pgdoc-cn_start sig_en=a6789c8e8044daf4bfd95d4b17c7dcb2 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>active_time</structfield> <type>double precision</type>
      </para>
      <para>
       Time spent executing SQL statements in this database, in milliseconds
       (this corresponds to the states <literal>active</literal> and
       <literal>fastpath function call</literal> in
       <link linkend="monitoring-pg-stat-activity-view">
       <structname>pg_stat_activity</structname></link>)
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>active_time</structfield> <type>double precision</type>
      </para>
      <para>
       此数据库中执行SQL语句所消耗的时间，以毫秒计(这对应于<link linkend="monitoring-pg-stat-activity-view"> <structname>pg_stat_activity</structname></link>中的 <literal>active</literal> 和 <literal>fastpath function call</literal> 状态)
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=a6789c8e8044daf4bfd95d4b17c7dcb2 -->

<!-- pgdoc-cn_start sig_en=4273fa7f4cb660798f284cc32a934ffc sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idle_in_transaction_time</structfield> <type>double precision</type>
      </para>
      <para>
       Time spent idling while in a transaction in this database, in milliseconds
       (this corresponds to the states <literal>idle in transaction</literal> and
       <literal>idle in transaction (aborted)</literal> in
       <link linkend="monitoring-pg-stat-activity-view">
       <structname>pg_stat_activity</structname></link>)
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idle_in_transaction_time</structfield> <type>double precision</type>
      </para>
      <para>
       此数据库中事务空闲所消耗的时间，以毫秒计(这对应于<link linkend="monitoring-pg-stat-activity-view"> <structname>pg_stat_activity</structname></link>中的 <literal>idle in transaction</literal> 和 <literal>idle in transaction (aborted)</literal> 状态)
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=4273fa7f4cb660798f284cc32a934ffc -->

<!-- pgdoc-cn_start sig_en=4462e853f57e093b64afa38a1a0beb55 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sessions</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of sessions established to this database
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sessions</structfield> <type>bigint</type>
      </para>
      <para>
       此数据库建立的会话总数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=4462e853f57e093b64afa38a1a0beb55 -->

<!-- pgdoc-cn_start sig_en=d4a93e62806e466c9e916fcea5723a7b sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sessions_abandoned</structfield> <type>bigint</type>
      </para>
      <para>
       Number of database sessions to this database that were terminated
       because connection to the client was lost
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sessions_abandoned</structfield> <type>bigint</type>
      </para>
      <para>
       此数据库因为到客户端的连接丢失而被终止的数据库会话数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=d4a93e62806e466c9e916fcea5723a7b -->

<!-- pgdoc-cn_start sig_en=1caa00f75a7cb944a711380a0be3c911 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sessions_fatal</structfield> <type>bigint</type>
      </para>
      <para>
       Number of database sessions to this database that were terminated
       by fatal errors
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sessions_fatal</structfield> <type>bigint</type>
      </para>
      <para>
       此数据库因为致命错误而被终止的数据库会话数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=1caa00f75a7cb944a711380a0be3c911 -->

<!-- pgdoc-cn_start sig_en=55282f90151cdc08e3d5fca65e3e57e6 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sessions_killed</structfield> <type>bigint</type>
      </para>
      <para>
       Number of database sessions to this database that were terminated
       by operator intervention
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sessions_killed</structfield> <type>bigint</type>
      </para>
      <para>
       此数据库因为操作者介入而被终止的数据库会话数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=55282f90151cdc08e3d5fca65e3e57e6 -->

<!-- pgdoc-cn_start sig_en=697bdc46a94ebbbd23b237e62a49caec sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time at which these statistics were last reset
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       这些统计数据最后一次重置的时间
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=697bdc46a94ebbbd23b237e62a49caec -->
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="monitoring-pg-stat-database-conflicts-view">
  <title><structname>pg_stat_database_conflicts</structname></title>

<!-- pgdoc-cn_start sig_en=5d85ae92684740dff82b9f300da73465 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>pg_stat_database_conflicts</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>pg_stat_database_conflicts</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=5d85ae92684740dff82b9f300da73465 -->

<!-- pgdoc-cn_start sig_en=a51fdf394f7e5420c1280a68472dd6d8 sig_cn_org=None source=14.1 
  <para>
   The <structname>pg_stat_database_conflicts</structname> view will contain
   one row per database, showing database-wide statistics about
   query cancels occurring due to conflicts with recovery on standby servers.
   This view will only contain information on standby servers, since
   conflicts do not occur on primary servers.
  </para>
________________________________________________________-->
  <para>
   <structname>pg_stat_database_conflicts</structname>视图为每一个数据库包含一行，用来显示数据库范围内由于与后备服务器上的恢复过程冲突而被取消的查询的统计信息。 
   这个视图将只包含后备服务器上的信息，因为冲突会不发生在主服务器上。
  </para>
<!-- pgdoc-cn_end sig_en=a51fdf394f7e5420c1280a68472dd6d8 -->

  <table id="pg-stat-database-conflicts-view" xreflabel="pg_stat_database_conflicts">
<!-- pgdoc-cn_start sig_en=eb327bb021b1c94694dcf86881e3be7e sig_cn_org=None source=14.1 
   <title><structname>pg_stat_database_conflicts</structname> View</title>
________________________________________________________-->
   <title><structname>pg_stat_database_conflicts</structname> 视图</title>
<!-- pgdoc-cn_end sig_en=eb327bb021b1c94694dcf86881e3be7e -->
   <tgroup cols="1">
    <thead>
<!-- pgdoc-cn_start sig_en=19eb14a155d7416c3b9cad7829c11a9d sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=19eb14a155d7416c3b9cad7829c11a9d -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=24deeeae13dd351cd8de1fb7fe2c65be sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datid</structfield> <type>oid</type>
      </para>
      <para>
       OID of a database
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datid</structfield> <type>oid</type>
      </para>
      <para>
       数据库的OID
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=24deeeae13dd351cd8de1fb7fe2c65be -->

<!-- pgdoc-cn_start sig_en=d67bce332253dd7b729ed403c0d6619a sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datname</structfield> <type>name</type>
      </para>
      <para>
       Name of this database
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datname</structfield> <type>name</type>
      </para>
      <para>
       数据库的名称
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=d67bce332253dd7b729ed403c0d6619a -->

<!-- pgdoc-cn_start sig_en=a02478511d23542d29cf6e1ffd5bb041 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>confl_tablespace</structfield> <type>bigint</type>
      </para>
      <para>
       Number of queries in this database that have been canceled due to
       dropped tablespaces
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>confl_tablespace</structfield> <type>bigint</type>
      </para>
      <para>
       这个数据库中由于删除表空间而取消的查询的数量
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=a02478511d23542d29cf6e1ffd5bb041 -->

<!-- pgdoc-cn_start sig_en=ab88c435b6b1c613dcad03fbf63d2943 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>confl_lock</structfield> <type>bigint</type>
      </para>
      <para>
       Number of queries in this database that have been canceled due to
       lock timeouts
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>confl_lock</structfield> <type>bigint</type>
      </para>
      <para>
       此数据库中由于锁定超时而被取消的查询数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=ab88c435b6b1c613dcad03fbf63d2943 -->

<!-- pgdoc-cn_start sig_en=3de4f55700152ad715cba7ff219e41c2 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>confl_snapshot</structfield> <type>bigint</type>
      </para>
      <para>
       Number of queries in this database that have been canceled due to
       old snapshots
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>confl_snapshot</structfield> <type>bigint</type>
      </para>
      <para>
       此数据库中由于旧快照而取消的查询数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=3de4f55700152ad715cba7ff219e41c2 -->

<!-- pgdoc-cn_start sig_en=e57958b7b02134502ff58418650aaccd sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>confl_bufferpin</structfield> <type>bigint</type>
      </para>
      <para>
       Number of queries in this database that have been canceled due to
       pinned buffers
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>confl_bufferpin</structfield> <type>bigint</type>
      </para>
      <para>
       此数据库中由于固定缓冲区而被取消的查询数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=e57958b7b02134502ff58418650aaccd -->

<!-- pgdoc-cn_start sig_en=3e4e6adb0f0343acfa0ea047e9143d0d sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>confl_deadlock</structfield> <type>bigint</type>
      </para>
      <para>
       Number of queries in this database that have been canceled due to
       deadlocks
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>confl_deadlock</structfield> <type>bigint</type>
      </para>
      <para>
       此数据库中由于死锁而被取消的查询数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=3e4e6adb0f0343acfa0ea047e9143d0d -->
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="monitoring-pg-stat-all-tables-view">
  <title><structname>pg_stat_all_tables</structname></title>

<!-- pgdoc-cn_start sig_en=4359104ba433dcbfd3e38b34a5ef0c69 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>pg_stat_all_tables</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>pg_stat_all_tables</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=4359104ba433dcbfd3e38b34a5ef0c69 -->

<!-- pgdoc-cn_start sig_en=47608e0e20d903000586a92c0c0f8997 sig_cn_org=None source=14.1 
  <para>
   The <structname>pg_stat_all_tables</structname> view will contain
   one row for each table in the current database (including TOAST
   tables), showing statistics about accesses to that specific table. The
   <structname>pg_stat_user_tables</structname> and
   <structname>pg_stat_sys_tables</structname> views
   contain the same information,
   but filtered to only show user and system tables respectively.
  </para>
________________________________________________________-->
  <para>
   <structname>pg_stat_all_tables</structname>视图将为当前数据库中的每一个表（包括 TOAST 表）包含一行，该行显示与对该表的访问相关的统计信息。
   <structname>pg_stat_user_tables</structname>和<structname>pg_stat_sys_tables</structname>视图包含相同的信息，但是被过滤得分别只显示用户和系统表。
  </para>
<!-- pgdoc-cn_end sig_en=47608e0e20d903000586a92c0c0f8997 -->

  <table id="pg-stat-all-tables-view" xreflabel="pg_stat_all_tables">
<!-- pgdoc-cn_start sig_en=f9bc321f08721eeca4d0c2012de15e0e sig_cn_org=None source=14.1 
   <title><structname>pg_stat_all_tables</structname> View</title>
________________________________________________________-->
   <title><structname>pg_stat_all_tables</structname> 视图</title>
<!-- pgdoc-cn_end sig_en=f9bc321f08721eeca4d0c2012de15e0e -->
   <tgroup cols="1">
    <thead>
<!-- pgdoc-cn_start sig_en=19eb14a155d7416c3b9cad7829c11a9d sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=19eb14a155d7416c3b9cad7829c11a9d -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=bf21e034c3d2c90837f80f36f05c8303 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       OID of a table
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       表的OID
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=bf21e034c3d2c90837f80f36f05c8303 -->

<!-- pgdoc-cn_start sig_en=46b4699c8ac6dd5c51f67f9297714299 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>schemaname</structfield> <type>name</type>
      </para>
      <para>
       Name of the schema that this table is in
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>schemaname</structfield> <type>name</type>
      </para>
      <para>
       该表所在的模式的名称
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=46b4699c8ac6dd5c51f67f9297714299 -->

<!-- pgdoc-cn_start sig_en=bfaa2eec748c140befd54f2f69ad5047 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relname</structfield> <type>name</type>
      </para>
      <para>
       Name of this table
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relname</structfield> <type>name</type>
      </para>
      <para>
       这个表的名称
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=bfaa2eec748c140befd54f2f69ad5047 -->

<!-- pgdoc-cn_start sig_en=0e587cad7497af3efb76ec49a50b9e32 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>seq_scan</structfield> <type>bigint</type>
      </para>
      <para>
       Number of sequential scans initiated on this table
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>seq_scan</structfield> <type>bigint</type>
      </para>
      <para>
       在此表上启动的顺序扫描数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=0e587cad7497af3efb76ec49a50b9e32 -->

<!-- pgdoc-cn_start sig_en=14f5fba2857744549fcc6c49bbfaac18 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>seq_tup_read</structfield> <type>bigint</type>
      </para>
      <para>
       Number of live rows fetched by sequential scans
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>seq_tup_read</structfield> <type>bigint</type>
      </para>
      <para>
       连续扫描获取的实时行数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=14f5fba2857744549fcc6c49bbfaac18 -->

<!-- pgdoc-cn_start sig_en=7ea27c39068d5655d7bd6e6d52450572 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_scan</structfield> <type>bigint</type>
      </para>
      <para>
       Number of index scans initiated on this table
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_scan</structfield> <type>bigint</type>
      </para>
      <para>
       对这个表发起的索引扫描数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=7ea27c39068d5655d7bd6e6d52450572 -->

<!-- pgdoc-cn_start sig_en=1bce508cb8a53e0146387a8172e176bd sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_tup_fetch</structfield> <type>bigint</type>
      </para>
      <para>
       Number of live rows fetched by index scans
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_tup_fetch</structfield> <type>bigint</type>
      </para>
      <para>
       索引扫描获取的实时行数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=1bce508cb8a53e0146387a8172e176bd -->

<!-- pgdoc-cn_start sig_en=83cd712cac34fcf53ec293da7b844976 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>n_tup_ins</structfield> <type>bigint</type>
      </para>
      <para>
       Number of rows inserted
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>n_tup_ins</structfield> <type>bigint</type>
      </para>
      <para>
       插入的行数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=83cd712cac34fcf53ec293da7b844976 -->

<!-- pgdoc-cn_start sig_en=95d1f5512fd49404cb0d7c07ab059921 sig_cn_org=35e0e31152021ee037b3c2437aebdf3b source=15.7 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>n_tup_upd</structfield> <type>bigint</type>
      </para>
      <para>
       Number of rows updated (includes <link linkend="storage-hot">HOT updated rows</link>)
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>n_tup_upd</structfield> <type>bigint</type>
      </para>
      <para>
       更新的行数（包括<link linkend="storage-hot">HOT更新的行</link>）
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=95d1f5512fd49404cb0d7c07ab059921 -->

<!-- pgdoc-cn_start sig_en=bd8c159a763d4039e5a2caaccbbe8614 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>n_tup_del</structfield> <type>bigint</type>
      </para>
      <para>
       Number of rows deleted
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>n_tup_del</structfield> <type>bigint</type>
      </para>
      <para>
       删除的行数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=bd8c159a763d4039e5a2caaccbbe8614 -->

<!-- pgdoc-cn_start sig_en=d1e5f6e0196ae8274886b85637bd3ba9 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>n_tup_hot_upd</structfield> <type>bigint</type>
      </para>
      <para>
       Number of rows HOT updated (i.e., with no separate index
       update required)
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>n_tup_hot_upd</structfield> <type>bigint</type>
      </para>
      <para>
       HOT更新的行数(即，不需要单独的索引更新)
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=d1e5f6e0196ae8274886b85637bd3ba9 -->

<!-- pgdoc-cn_start sig_en=5b058955ac4d6efdda0b1eaac08b6c70 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>n_live_tup</structfield> <type>bigint</type>
      </para>
      <para>
       Estimated number of live rows
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>n_live_tup</structfield> <type>bigint</type>
      </para>
      <para>
       活的行的估计数量
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=5b058955ac4d6efdda0b1eaac08b6c70 -->

<!-- pgdoc-cn_start sig_en=9a0a47a28be1a724d19874a953736f30 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>n_dead_tup</structfield> <type>bigint</type>
      </para>
      <para>
       Estimated number of dead rows
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>n_dead_tup</structfield> <type>bigint</type>
      </para>
      <para>
       僵死行的估计数量
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=9a0a47a28be1a724d19874a953736f30 -->

<!-- pgdoc-cn_start sig_en=7e90b4a9e284508d79ba47c57c9555ca sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>n_mod_since_analyze</structfield> <type>bigint</type>
      </para>
      <para>
       Estimated number of rows modified since this table was last analyzed
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>n_mod_since_analyze</structfield> <type>bigint</type>
      </para>
      <para>
       自上次分析此表以来修改的行的估计数量
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=7e90b4a9e284508d79ba47c57c9555ca -->

<!-- pgdoc-cn_start sig_en=53ca3c888cb96ab6362fec166d0d1dd9 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>n_ins_since_vacuum</structfield> <type>bigint</type>
      </para>
      <para>
       Estimated number of rows inserted since this table was last vacuumed
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>n_ins_since_vacuum</structfield> <type>bigint</type>
      </para>
      <para>
       自上次清空此表以来插入的行的估计数量
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=53ca3c888cb96ab6362fec166d0d1dd9 -->

<!-- pgdoc-cn_start sig_en=b68fc13f242e86a2ee2bbde6e2441e86 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_vacuum</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Last time at which this table was manually vacuumed
       (not counting <command>VACUUM FULL</command>)
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_vacuum</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       最后一次手动清理这个表(不包括<command>VACUUM FULL</command>)
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=b68fc13f242e86a2ee2bbde6e2441e86 -->

<!-- pgdoc-cn_start sig_en=eddc17454c466eba0f1cf6425af8a98d sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_autovacuum</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Last time at which this table was vacuumed by the autovacuum
       daemon
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_autovacuum</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       这个表最后一次被自动清理守护进程清理的时间
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=eddc17454c466eba0f1cf6425af8a98d -->

<!-- pgdoc-cn_start sig_en=0d2d9efe5935525beacb849c0cf78410 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_analyze</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Last time at which this table was manually analyzed
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_analyze</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       上一次手动分析这个表
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=0d2d9efe5935525beacb849c0cf78410 -->

<!-- pgdoc-cn_start sig_en=d9896adff12f97ecfcea2a35c72feb70 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_autoanalyze</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Last time at which this table was analyzed by the autovacuum
       daemon
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_autoanalyze</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       自动清理守护进程最后一次分析这个表
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=d9896adff12f97ecfcea2a35c72feb70 -->

<!-- pgdoc-cn_start sig_en=7974d0fcd524c3cc29382b993f74f15c sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>vacuum_count</structfield> <type>bigint</type>
      </para>
      <para>
       Number of times this table has been manually vacuumed
       (not counting <command>VACUUM FULL</command>)
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>vacuum_count</structfield> <type>bigint</type>
      </para>
      <para>
       这个表被手动清理的次数(<command>VACUUM FULL</command>不计数)
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=7974d0fcd524c3cc29382b993f74f15c -->

<!-- pgdoc-cn_start sig_en=9fc17fbc88422aa34e3a9c866fb7d7cd sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>autovacuum_count</structfield> <type>bigint</type>
      </para>
      <para>
       Number of times this table has been vacuumed by the autovacuum
       daemon
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>autovacuum_count</structfield> <type>bigint</type>
      </para>
      <para>
       这个表被autovacuum守护进程清理的次数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=9fc17fbc88422aa34e3a9c866fb7d7cd -->

<!-- pgdoc-cn_start sig_en=38e8c05ba8b5aae58eebed31941f4169 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>analyze_count</structfield> <type>bigint</type>
      </para>
      <para>
       Number of times this table has been manually analyzed
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>analyze_count</structfield> <type>bigint</type>
      </para>
      <para>
       手动分析这个表的次数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=38e8c05ba8b5aae58eebed31941f4169 -->

<!-- pgdoc-cn_start sig_en=b8baabe84b3b5c3159799386399847a9 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>autoanalyze_count</structfield> <type>bigint</type>
      </para>
      <para>
       Number of times this table has been analyzed by the autovacuum
       daemon
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>autoanalyze_count</structfield> <type>bigint</type>
      </para>
      <para>
       这个表被autovacuum守护进程分析的次数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=b8baabe84b3b5c3159799386399847a9 -->
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="monitoring-pg-stat-all-indexes-view">
  <title><structname>pg_stat_all_indexes</structname></title>

<!-- pgdoc-cn_start sig_en=3a7272a1498f9fdd6539dc0dc0a0b3b9 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>pg_stat_all_indexes</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>pg_stat_all_indexes</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=3a7272a1498f9fdd6539dc0dc0a0b3b9 -->

<!-- pgdoc-cn_start sig_en=cb32f1e91f6c9a3ba3feb156376bdc65 sig_cn_org=None source=14.1 
  <para>
   The <structname>pg_stat_all_indexes</structname> view will contain
   one row for each index in the current database,
   showing statistics about accesses to that specific index. The
   <structname>pg_stat_user_indexes</structname> and
   <structname>pg_stat_sys_indexes</structname> views
   contain the same information,
   but filtered to only show user and system indexes respectively.
  </para>
________________________________________________________-->
  <para>
   <structname>pg_stat_all_indexes</structname>视图将为当前数据库中的每个索引包含一行，该行显示关于对该索引访问的统计信息。<structname>pg_stat_user_indexes</structname>和<structname>pg_stat_sys_indexes</structname>视图包含相同的信息，但是被过滤得只分别显示用户和系统索引。
  </para>
<!-- pgdoc-cn_end sig_en=cb32f1e91f6c9a3ba3feb156376bdc65 -->

  <table id="pg-stat-all-indexes-view" xreflabel="pg_stat_all_indexes">
<!-- pgdoc-cn_start sig_en=c772475a5887c5d8f79d930fdec6f4a4 sig_cn_org=None source=14.1 
   <title><structname>pg_stat_all_indexes</structname> View</title>
________________________________________________________-->
   <title><structname>pg_stat_all_indexes</structname> 视图</title>
<!-- pgdoc-cn_end sig_en=c772475a5887c5d8f79d930fdec6f4a4 -->
   <tgroup cols="1">
    <thead>
<!-- pgdoc-cn_start sig_en=19eb14a155d7416c3b9cad7829c11a9d sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=19eb14a155d7416c3b9cad7829c11a9d -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=f71dbc06ee3e546c1e7095be3172fa8d sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the table for this index
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       对于此索引的表的OID
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=f71dbc06ee3e546c1e7095be3172fa8d -->

<!-- pgdoc-cn_start sig_en=45169860c6c93a8a19af6d5ecbfade19 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>indexrelid</structfield> <type>oid</type>
      </para>
      <para>
       OID of this index
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>indexrelid</structfield> <type>oid</type>
      </para>
      <para>
       这个索引的OID
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=45169860c6c93a8a19af6d5ecbfade19 -->

<!-- pgdoc-cn_start sig_en=fa24ff926f85131ebad3003e8d3052e4 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>schemaname</structfield> <type>name</type>
      </para>
      <para>
       Name of the schema this index is in
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>schemaname</structfield> <type>name</type>
      </para>
      <para>
       这个索引所在的模式名称
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=fa24ff926f85131ebad3003e8d3052e4 -->

<!-- pgdoc-cn_start sig_en=bde017f4631bd70791f8b492f91af333 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relname</structfield> <type>name</type>
      </para>
      <para>
       Name of the table for this index
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relname</structfield> <type>name</type>
      </para>
      <para>
       这个索引的表的名称
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=bde017f4631bd70791f8b492f91af333 -->

<!-- pgdoc-cn_start sig_en=6ed970c78929f17f22ee85904c9a8939 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>indexrelname</structfield> <type>name</type>
      </para>
      <para>
       Name of this index
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>indexrelname</structfield> <type>name</type>
      </para>
      <para>
       这个索引的名称
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=6ed970c78929f17f22ee85904c9a8939 -->

<!-- pgdoc-cn_start sig_en=f3a434338bdf048c9ac289a873634412 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_scan</structfield> <type>bigint</type>
      </para>
      <para>
       Number of index scans initiated on this index
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_scan</structfield> <type>bigint</type>
      </para>
      <para>
       在这个索引上开启的索引扫描的数量
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=f3a434338bdf048c9ac289a873634412 -->

<!-- pgdoc-cn_start sig_en=4b802d493e0221c0c4fe1f61df5dae3f sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_tup_read</structfield> <type>bigint</type>
      </para>
      <para>
       Number of index entries returned by scans on this index
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_tup_read</structfield> <type>bigint</type>
      </para>
      <para>
       扫描此索引返回的索引项数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=4b802d493e0221c0c4fe1f61df5dae3f -->

<!-- pgdoc-cn_start sig_en=1143f016d2b472feeab1869909cbcf5c sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_tup_fetch</structfield> <type>bigint</type>
      </para>
      <para>
       Number of live table rows fetched by simple index scans using this
       index
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_tup_fetch</structfield> <type>bigint</type>
      </para>
      <para>
       使用此索引进行简单索引扫描获取的活动表行数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=1143f016d2b472feeab1869909cbcf5c -->
    </tbody>
   </tgroup>
  </table>

<!-- pgdoc-cn_start sig_en=0291162d7bb27f033995cc3c5e9f4adc sig_cn_org=None source=14.1 
  <para>
   Indexes can be used by simple index scans, <quote>bitmap</quote> index scans,
   and the optimizer.  In a bitmap scan
   the output of several indexes can be combined via AND or OR rules,
   so it is difficult to associate individual heap row fetches
   with specific indexes when a bitmap scan is used.  Therefore, a bitmap
   scan increments the
   <structname>pg_stat_all_indexes</structname>.<structfield>idx_tup_read</structfield>
   count(s) for the index(es) it uses, and it increments the
   <structname>pg_stat_all_tables</structname>.<structfield>idx_tup_fetch</structfield>
   count for the table, but it does not affect
   <structname>pg_stat_all_indexes</structname>.<structfield>idx_tup_fetch</structfield>.
   The optimizer also accesses indexes to check for supplied constants
   whose values are outside the recorded range of the optimizer statistics
   because the optimizer statistics might be stale.
  </para>
________________________________________________________-->
  <para>
   索引可以被简单索引扫描、<quote>位图</quote>索引扫描以及优化器使用。在一次位图扫描中，多个索引的输出可以被通过 AND 或 OR 规则组合，因此当使用一次位图扫描时难以将取得的个体堆行与特定的索引关联起来。因此，一次位图扫描会增加它使用的索引的<structname>pg_stat_all_indexes</structname>.<structfield>idx_tup_read</structfield>计数，并且为每个表增加<structname>pg_stat_all_tables</structname>.<structfield>idx_tup_fetch</structfield>计数，但是它不影响<structname>pg_stat_all_indexes</structname>.<structfield>idx_tup_fetch</structfield>。如果所提供的常量值不在优化器统计信息记录的范围之内，优化器也会访问索引来检查，因为优化器统计信息可能已经“不新鲜”了。
  </para>
<!-- pgdoc-cn_end sig_en=0291162d7bb27f033995cc3c5e9f4adc -->

  <note>
<!-- pgdoc-cn_start sig_en=15a0272f12f4d2b18b8384792d763eec sig_cn_org=None source=14.1 
   <para>
    The <structfield>idx_tup_read</structfield> and <structfield>idx_tup_fetch</structfield> counts
    can be different even without any use of bitmap scans,
    because <structfield>idx_tup_read</structfield> counts
    index entries retrieved from the index while <structfield>idx_tup_fetch</structfield>
    counts live rows fetched from the table.  The latter will be less if any
    dead or not-yet-committed rows are fetched using the index, or if any
    heap fetches are avoided by means of an index-only scan.
   </para>
________________________________________________________-->
   <para>
    即使不用位图扫描，<structfield>idx_tup_read</structfield>和<structfield>idx_tup_fetch</structfield>计数也可能不同，因为<structfield>idx_tup_read</structfield>统计从该索引取得的索引项而<structfield>idx_tup_fetch</structfield>统计从表取得的活着的行。如果使用该索引取得了任何死亡行或还未提交的行，或者如果通过一次只用索引扫描的方式避免了任何堆获取，后者将较小。
   </para>
<!-- pgdoc-cn_end sig_en=15a0272f12f4d2b18b8384792d763eec -->
  </note>

 </sect2>

 <sect2 id="monitoring-pg-statio-all-tables-view">
  <title><structname>pg_statio_all_tables</structname></title>

<!-- pgdoc-cn_start sig_en=17bd1c49b8571757d374aa925f89586a sig_cn_org=None source=14.1 
  <indexterm>
   <primary>pg_statio_all_tables</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>pg_statio_all_tables</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=17bd1c49b8571757d374aa925f89586a -->

<!-- pgdoc-cn_start sig_en=9b2505d4c54fd2d75381a4bbe2576517 sig_cn_org=None source=14.1 
  <para>
   The <structname>pg_statio_all_tables</structname> view will contain
   one row for each table in the current database (including TOAST
   tables), showing statistics about I/O on that specific table. The
   <structname>pg_statio_user_tables</structname> and
   <structname>pg_statio_sys_tables</structname> views
   contain the same information,
   but filtered to only show user and system tables respectively.
  </para>
________________________________________________________-->
  <para>
   <structname>pg_statio_all_tables</structname>视图将为当前数据库中的每个表（包括 TOAST 表）包含一行，该行显示指定表上有关 I/O 的统计信息。<structname>pg_statio_user_tables</structname>和<structname>pg_statio_sys_tables</structname>视图包含相同的信息，但是被过滤得分别只显示用户表和系统表。
  </para>
<!-- pgdoc-cn_end sig_en=9b2505d4c54fd2d75381a4bbe2576517 -->

  <table id="pg-statio-all-tables-view" xreflabel="pg_statio_all_tables">
<!-- pgdoc-cn_start sig_en=d6a48a4ee05653952956b781fc5598b8 sig_cn_org=None source=14.1 
   <title><structname>pg_statio_all_tables</structname> View</title>
________________________________________________________-->
   <title><structname>pg_statio_all_tables</structname> 视图</title>
<!-- pgdoc-cn_end sig_en=d6a48a4ee05653952956b781fc5598b8 -->
   <tgroup cols="1">
    <thead>
<!-- pgdoc-cn_start sig_en=19eb14a155d7416c3b9cad7829c11a9d sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=19eb14a155d7416c3b9cad7829c11a9d -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=bf21e034c3d2c90837f80f36f05c8303 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       OID of a table
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       表的OID
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=bf21e034c3d2c90837f80f36f05c8303 -->

<!-- pgdoc-cn_start sig_en=46b4699c8ac6dd5c51f67f9297714299 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>schemaname</structfield> <type>name</type>
      </para>
      <para>
       Name of the schema that this table is in
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>schemaname</structfield> <type>name</type>
      </para>
      <para>
       该表所在的模式的名称
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=46b4699c8ac6dd5c51f67f9297714299 -->

<!-- pgdoc-cn_start sig_en=bfaa2eec748c140befd54f2f69ad5047 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relname</structfield> <type>name</type>
      </para>
      <para>
       Name of this table
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relname</structfield> <type>name</type>
      </para>
      <para>
       这个表的名称
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=bfaa2eec748c140befd54f2f69ad5047 -->

<!-- pgdoc-cn_start sig_en=d56ab42f03bdf0059c67913405300fa4 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       Number of disk blocks read from this table
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       从该表中读取的磁盘块的数量
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=d56ab42f03bdf0059c67913405300fa4 -->

<!-- pgdoc-cn_start sig_en=65e7a682f078c577c20e9d45b4d59f86 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       Number of buffer hits in this table
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       该表中的缓冲区命中数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=65e7a682f078c577c20e9d45b4d59f86 -->

<!-- pgdoc-cn_start sig_en=27d671bf97552eaf0e1baff246b4f07e sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       Number of disk blocks read from all indexes on this table
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       从这个表上所有索引读取的磁盘块数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=27d671bf97552eaf0e1baff246b4f07e -->

<!-- pgdoc-cn_start sig_en=7657a60bf51b3f0fff4ec1365dc3942f sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       Number of buffer hits in all indexes on this table
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       这个表上所有索引中的缓冲区命中数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=7657a60bf51b3f0fff4ec1365dc3942f -->

<!-- pgdoc-cn_start sig_en=454171ba41db9e723328fc7cb49dc5c0 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>toast_blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       Number of disk blocks read from this table's TOAST table (if any)
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>toast_blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       从这个表的TOAST表中读取的磁盘块的数量(如果有的话)
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=454171ba41db9e723328fc7cb49dc5c0 -->

<!-- pgdoc-cn_start sig_en=8a3a3e26f64a896d998949ba6ce21a20 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>toast_blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       Number of buffer hits in this table's TOAST table (if any)
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>toast_blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       这个表的TOAST表中的缓冲区命中数(如果有的话)
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=8a3a3e26f64a896d998949ba6ce21a20 -->

<!-- pgdoc-cn_start sig_en=39c386cf4b6ee1c3d056baf69d2bdc2d sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tidx_blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       Number of disk blocks read from this table's TOAST table indexes (if any)
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tidx_blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       从这个表的TOAST表索引中读取的磁盘块的数量(如果有的话)
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=39c386cf4b6ee1c3d056baf69d2bdc2d -->

<!-- pgdoc-cn_start sig_en=79b941a3b14a439b9ca7374e756e7ca0 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tidx_blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       Number of buffer hits in this table's TOAST table indexes (if any)
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tidx_blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       这个表的TOAST表索引中的缓冲区命中数(如果有的话)
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=79b941a3b14a439b9ca7374e756e7ca0 -->
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="monitoring-pg-statio-all-indexes-view">
  <title><structname>pg_statio_all_indexes</structname></title>

<!-- pgdoc-cn_start sig_en=79dd08b1983ceb0dcbf61da4fee8c955 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>pg_statio_all_indexes</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>pg_statio_all_indexes</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=79dd08b1983ceb0dcbf61da4fee8c955 -->

<!-- pgdoc-cn_start sig_en=ee4a367058dfcb1609b988c377bff3e1 sig_cn_org=None source=14.1 
  <para>
   The <structname>pg_statio_all_indexes</structname> view will contain
   one row for each index in the current database,
   showing statistics about I/O on that specific index. The
   <structname>pg_statio_user_indexes</structname> and
   <structname>pg_statio_sys_indexes</structname> views
   contain the same information,
   but filtered to only show user and system indexes respectively.
  </para>
________________________________________________________-->
  <para>
   <structname>pg_statio_all_indexes</structname>视图将为当前数据库中的每个索引包含一行，该行显示指定索引上有关 I/O 的统计信息。
   <structname>pg_statio_user_indexes</structname>和<structname>pg_statio_sys_indexes</structname>视图包含相同的信息，但是被过滤得分别只显示用户索引和系统索引。
  </para>
<!-- pgdoc-cn_end sig_en=ee4a367058dfcb1609b988c377bff3e1 -->

  <table id="pg-statio-all-indexes-view" xreflabel="pg_statio_all_indexes">
<!-- pgdoc-cn_start sig_en=6d0a86ba51393c4eb6dd50701c9f0954 sig_cn_org=None source=14.1 
   <title><structname>pg_statio_all_indexes</structname> View</title>
________________________________________________________-->
   <title><structname>pg_statio_all_indexes</structname> 视图</title>
<!-- pgdoc-cn_end sig_en=6d0a86ba51393c4eb6dd50701c9f0954 -->
   <tgroup cols="1">
    <thead>
<!-- pgdoc-cn_start sig_en=19eb14a155d7416c3b9cad7829c11a9d sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=19eb14a155d7416c3b9cad7829c11a9d -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=f71dbc06ee3e546c1e7095be3172fa8d sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the table for this index
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       对于此索引的表的OID
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=f71dbc06ee3e546c1e7095be3172fa8d -->

<!-- pgdoc-cn_start sig_en=45169860c6c93a8a19af6d5ecbfade19 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>indexrelid</structfield> <type>oid</type>
      </para>
      <para>
       OID of this index
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>indexrelid</structfield> <type>oid</type>
      </para>
      <para>
       这个索引的OID
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=45169860c6c93a8a19af6d5ecbfade19 -->

<!-- pgdoc-cn_start sig_en=fa24ff926f85131ebad3003e8d3052e4 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>schemaname</structfield> <type>name</type>
      </para>
      <para>
       Name of the schema this index is in
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>schemaname</structfield> <type>name</type>
      </para>
      <para>
       这个索引所在的模式名称
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=fa24ff926f85131ebad3003e8d3052e4 -->

<!-- pgdoc-cn_start sig_en=bde017f4631bd70791f8b492f91af333 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relname</structfield> <type>name</type>
      </para>
      <para>
       Name of the table for this index
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relname</structfield> <type>name</type>
      </para>
      <para>
       这个索引的表的名称
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=bde017f4631bd70791f8b492f91af333 -->

<!-- pgdoc-cn_start sig_en=6ed970c78929f17f22ee85904c9a8939 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>indexrelname</structfield> <type>name</type>
      </para>
      <para>
       Name of this index
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>indexrelname</structfield> <type>name</type>
      </para>
      <para>
       这个索引的名称
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=6ed970c78929f17f22ee85904c9a8939 -->

<!-- pgdoc-cn_start sig_en=1d14708a40e7c1f83f70005f8ed04adf sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       Number of disk blocks read from this index
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       从此索引中读取的磁盘块的数量
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=1d14708a40e7c1f83f70005f8ed04adf -->

<!-- pgdoc-cn_start sig_en=51069b2a6eeb5491e23878d52d571e94 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       Number of buffer hits in this index
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       此索引中的缓冲区命中数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=51069b2a6eeb5491e23878d52d571e94 -->
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="monitoring-pg-statio-all-sequences-view">
  <title><structname>pg_statio_all_sequences</structname></title>

<!-- pgdoc-cn_start sig_en=13c37670bec600874d2780b1f65bf4c5 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>pg_statio_all_sequences</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>pg_statio_all_sequences</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=13c37670bec600874d2780b1f65bf4c5 -->

<!-- pgdoc-cn_start sig_en=130b28f43cd7284f072c89974081d58a sig_cn_org=None source=14.1 
  <para>
   The <structname>pg_statio_all_sequences</structname> view will contain
   one row for each sequence in the current database,
   showing statistics about I/O on that specific sequence.
  </para>
________________________________________________________-->
  <para>
   <structname>pg_statio_all_sequences</structname>视图将为当前数据库中的每个序列包含一行，该行显示在指定序列上有关 I/O 的统计信息。
  </para>
<!-- pgdoc-cn_end sig_en=130b28f43cd7284f072c89974081d58a -->

  <table id="pg-statio-all-sequences-view" xreflabel="pg_statio_all_sequences">
<!-- pgdoc-cn_start sig_en=7fb64a249c93e70c9b12ba304e3e3e17 sig_cn_org=None source=14.1 
   <title><structname>pg_statio_all_sequences</structname> View</title>
________________________________________________________-->
   <title><structname>pg_statio_all_sequences</structname> 视图</title>
<!-- pgdoc-cn_end sig_en=7fb64a249c93e70c9b12ba304e3e3e17 -->
   <tgroup cols="1">
    <thead>
<!-- pgdoc-cn_start sig_en=19eb14a155d7416c3b9cad7829c11a9d sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=19eb14a155d7416c3b9cad7829c11a9d -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=d6aa44703a0fd87c21d9eb0cbb1f400b sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       OID of a sequence
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       序列的OID
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=d6aa44703a0fd87c21d9eb0cbb1f400b -->

<!-- pgdoc-cn_start sig_en=a483f067fba08352074f6c265a936267 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>schemaname</structfield> <type>name</type>
      </para>
      <para>
       Name of the schema this sequence is in
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>schemaname</structfield> <type>name</type>
      </para>
      <para>
       此序列所在的模式的名称
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=a483f067fba08352074f6c265a936267 -->

<!-- pgdoc-cn_start sig_en=30f5f6e48be4fa4e86530a7efc396b10 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relname</structfield> <type>name</type>
      </para>
      <para>
       Name of this sequence
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relname</structfield> <type>name</type>
      </para>
      <para>
       此序列的名称
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=30f5f6e48be4fa4e86530a7efc396b10 -->

<!-- pgdoc-cn_start sig_en=a87294b5a43f0a0fd342f7a9f8893421 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       Number of disk blocks read from this sequence
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       从这个序列中读取的磁盘块的数量
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=a87294b5a43f0a0fd342f7a9f8893421 -->

<!-- pgdoc-cn_start sig_en=9ecee648506dd4221417e6581ae6b6c2 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       Number of buffer hits in this sequence
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       在此序列中的缓冲区命中数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=9ecee648506dd4221417e6581ae6b6c2 -->
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="monitoring-pg-stat-user-functions-view">
  <title><structname>pg_stat_user_functions</structname></title>

<!-- pgdoc-cn_start sig_en=126d9bc28716f4f9f41640bc27b5ed30 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>pg_stat_user_functions</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>pg_stat_user_functions</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=126d9bc28716f4f9f41640bc27b5ed30 -->

<!-- pgdoc-cn_start sig_en=8f890e15fe25198ff70c1b7691234c6b sig_cn_org=None source=14.1 
  <para>
   The <structname>pg_stat_user_functions</structname> view will contain
   one row for each tracked function, showing statistics about executions of
   that function.  The <xref linkend="guc-track-functions"/> parameter
   controls exactly which functions are tracked.
  </para>
________________________________________________________-->
  <para>
   <structname>pg_stat_user_functions</structname>视图将为每一个被追踪的函数包含一行，该行显示有关该函数执行的统计信息。
   <xref linkend="guc-track-functions"/>参数控制到底哪些函数被跟踪。
  </para>
<!-- pgdoc-cn_end sig_en=8f890e15fe25198ff70c1b7691234c6b -->

  <table id="pg-stat-user-functions-view" xreflabel="pg_stat_user_functions">
<!-- pgdoc-cn_start sig_en=0e4bd1e6bbd8b4cdd0c5e2bc390f84d5 sig_cn_org=None source=14.1 
   <title><structname>pg_stat_user_functions</structname> View</title>
________________________________________________________-->
   <title><structname>pg_stat_user_functions</structname> 视图</title>
<!-- pgdoc-cn_end sig_en=0e4bd1e6bbd8b4cdd0c5e2bc390f84d5 -->
   <tgroup cols="1">
    <thead>
<!-- pgdoc-cn_start sig_en=19eb14a155d7416c3b9cad7829c11a9d sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=19eb14a155d7416c3b9cad7829c11a9d -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=8d21100bc8c7658d8c6a1aef862bdcf1 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>funcid</structfield> <type>oid</type>
      </para>
      <para>
       OID of a function
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>funcid</structfield> <type>oid</type>
      </para>
      <para>
       函数的OID
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=8d21100bc8c7658d8c6a1aef862bdcf1 -->

<!-- pgdoc-cn_start sig_en=1c0c7b8ff370ddc81abf6121729780a3 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>schemaname</structfield> <type>name</type>
      </para>
      <para>
       Name of the schema this function is in
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>schemaname</structfield> <type>name</type>
      </para>
      <para>
       这个函数所在的模式的名称
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=1c0c7b8ff370ddc81abf6121729780a3 -->

<!-- pgdoc-cn_start sig_en=72ca0c50f1861cedd9cc954cddead159 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>funcname</structfield> <type>name</type>
      </para>
      <para>
       Name of this function
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>funcname</structfield> <type>name</type>
      </para>
      <para>
       这个函数的名称
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=72ca0c50f1861cedd9cc954cddead159 -->

<!-- pgdoc-cn_start sig_en=e30d0101cff5e0b40ccf56888ab52411 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>calls</structfield> <type>bigint</type>
      </para>
      <para>
       Number of times this function has been called
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>calls</structfield> <type>bigint</type>
      </para>
      <para>
       这个函数已经被调用的次数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=e30d0101cff5e0b40ccf56888ab52411 -->

<!-- pgdoc-cn_start sig_en=21bdef9373009b92cd611cc6a39c4f38 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>total_time</structfield> <type>double precision</type>
      </para>
      <para>
       Total time spent in this function and all other functions
       called by it, in milliseconds
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>total_time</structfield> <type>double precision</type>
      </para>
      <para>
       在这个函数以及它所调用的其他函数中花费的总时间，以毫秒计
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=21bdef9373009b92cd611cc6a39c4f38 -->

<!-- pgdoc-cn_start sig_en=920a3ebfc46c0fa049a2320014894e52 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>self_time</structfield> <type>double precision</type>
      </para>
      <para>
       Total time spent in this function itself, not including
       other functions called by it, in milliseconds
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>self_time</structfield> <type>double precision</type>
      </para>
      <para>
       在这个函数本身花费的总时间，不包括被它调用的其他函数，以毫秒计
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=920a3ebfc46c0fa049a2320014894e52 -->
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="monitoring-pg-stat-slru-view">
  <title><structname>pg_stat_slru</structname></title>

<!-- pgdoc-cn_start sig_en=7075e3b3ba3fda69366350fd17b84ae1 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>SLRU</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>SLRU</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=7075e3b3ba3fda69366350fd17b84ae1 -->

<!-- pgdoc-cn_start sig_en=d64b43aedcba375c976b5155e1d18d3c sig_cn_org=None source=14.1 
  <indexterm>
   <primary>pg_stat_slru</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>pg_stat_slru</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=d64b43aedcba375c976b5155e1d18d3c -->

<!-- pgdoc-cn_start sig_en=b873e3ab66d578225c715cd7d1c3f127 sig_cn_org=None source=14.1 
  <para>
   <productname>PostgreSQL</productname> accesses certain on-disk information
   via <firstterm>SLRU</firstterm> (simple least-recently-used) caches.
   The <structname>pg_stat_slru</structname> view will contain
   one row for each tracked SLRU cache, showing statistics about access
   to cached pages.
  </para>
________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>通过<firstterm>SLRU</firstterm>(simple least-recently-used，简单的最近-最少-使用)缓存访问某些磁盘上的信息。
   <structname>pg_stat_slru</structname>视图将为每个被跟踪的SLRU缓存包含一行，显示关于访问缓存页面的统计信息。
  </para>
<!-- pgdoc-cn_end sig_en=b873e3ab66d578225c715cd7d1c3f127 -->

  <table id="pg-stat-slru-view" xreflabel="pg_stat_slru">
<!-- pgdoc-cn_start sig_en=b62b0ec76826c2c1c718b53903d33326 sig_cn_org=None source=14.1 
   <title><structname>pg_stat_slru</structname> View</title>
________________________________________________________-->
   <title><structname>pg_stat_slru</structname> 视图</title>
<!-- pgdoc-cn_end sig_en=b62b0ec76826c2c1c718b53903d33326 -->
   <tgroup cols="1">
    <thead>
<!-- pgdoc-cn_start sig_en=19eb14a155d7416c3b9cad7829c11a9d sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=19eb14a155d7416c3b9cad7829c11a9d -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=dbf1056330fc2df02846869e4b9a7da1 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>name</structfield> <type>text</type>
      </para>
      <para>
       Name of the SLRU
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>name</structfield> <type>text</type>
      </para>
      <para>
       SLRU的名称
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=dbf1056330fc2df02846869e4b9a7da1 -->

<!-- pgdoc-cn_start sig_en=fc849411b279a2c362e71ab786430608 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_zeroed</structfield> <type>bigint</type>
      </para>
      <para>
       Number of blocks zeroed during initializations
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_zeroed</structfield> <type>bigint</type>
      </para>
      <para>
       初始化期间被置零的块数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=fc849411b279a2c362e71ab786430608 -->

<!-- pgdoc-cn_start sig_en=79d9b5ce03a8bdfb98dc4ece250586a8 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       Number of times disk blocks were found already in the SLRU,
       so that a read was not necessary (this only includes hits in the
       SLRU, not the operating system's file system cache)
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       已经在SLRU中的磁盘块被发现的次数，因此不需要读取(这只包括SLRU中的命中，而不是操作系统的文件系统缓存)
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=79d9b5ce03a8bdfb98dc4ece250586a8 -->

<!-- pgdoc-cn_start sig_en=1646c09d1e19b5eb80508943a35654a0 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       Number of disk blocks read for this SLRU
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       为这个SLRU读取的磁盘块数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=1646c09d1e19b5eb80508943a35654a0 -->

<!-- pgdoc-cn_start sig_en=c9f1773bca27941d0339d5cd965dedf3 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_written</structfield> <type>bigint</type>
      </para>
      <para>
       Number of disk blocks written for this SLRU
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_written</structfield> <type>bigint</type>
      </para>
      <para>
       为这个SLRU写入的磁盘块数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=c9f1773bca27941d0339d5cd965dedf3 -->

<!-- pgdoc-cn_start sig_en=73d0405840824598e2e87269679f14f2 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_exists</structfield> <type>bigint</type>
      </para>
      <para>
       Number of blocks checked for existence for this SLRU
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_exists</structfield> <type>bigint</type>
      </para>
      <para>
       为这个SLRU检查是否存在的块数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=73d0405840824598e2e87269679f14f2 -->

<!-- pgdoc-cn_start sig_en=14abc1906fe9c2910d895a37c1011421 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>flushes</structfield> <type>bigint</type>
      </para>
      <para>
       Number of flushes of dirty data for this SLRU
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>flushes</structfield> <type>bigint</type>
      </para>
      <para>
       此SLRU的脏数据刷新数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=14abc1906fe9c2910d895a37c1011421 -->

<!-- pgdoc-cn_start sig_en=3c82fdad09200b17a7df38bcf5ea78a7 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>truncates</structfield> <type>bigint</type>
      </para>
      <para>
       Number of truncates for this SLRU
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>truncates</structfield> <type>bigint</type>
      </para>
      <para>
       这个SLRU的截断数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=3c82fdad09200b17a7df38bcf5ea78a7 -->

<!-- pgdoc-cn_start sig_en=697bdc46a94ebbbd23b237e62a49caec sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time at which these statistics were last reset
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       这些统计数据最后一次重置的时间
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=697bdc46a94ebbbd23b237e62a49caec -->
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="monitoring-stats-functions">
<!-- pgdoc-cn_start sig_en=d315e42ac0c1d9a17432feba0edcb188 sig_cn_org=None source=14.1 
  <title>Statistics Functions</title>
________________________________________________________-->
  <title>Statistics Functions</title>
<!-- pgdoc-cn_end sig_en=d315e42ac0c1d9a17432feba0edcb188 -->

<!-- pgdoc-cn_start sig_en=a5adba0348adcb95c1b11fcb95fef544 sig_cn_org=None source=14.1 
  <para>
   Other ways of looking at the statistics can be set up by writing
   queries that use the same underlying statistics access functions used by
   the standard views shown above.  For details such as the functions' names,
   consult the definitions of the standard views.  (For example, in
   <application>psql</application> you could issue <literal>\d+ pg_stat_activity</literal>.)
   The access functions for per-database statistics take a database OID as an
   argument to identify which database to report on.
   The per-table and per-index functions take a table or index OID.
   The functions for per-function statistics take a function OID.
   Note that only tables, indexes, and functions in the current database
   can be seen with these functions.
  </para>
________________________________________________________-->
  <para>
   其他查看统计信息的方法是直接使用查询，这些查询使用上述标准视图用到的底层统计信息访问函数。
   如要了解如函数名等细节，可参考标准视图的定义（例如，在<application>psql</application>中你可以发出<literal>\d+ pg_stat_activity</literal>）。
   针对每一个数据库统计信息的访问函数把一个数据库 OID 作为参数来标识要报告哪个数据库。而针对每个表和每个索引的函数要求表或索引 OID。
   针对每个函数统计信息的函数用一个函数 OID。注意只有在当前数据库中的表、索引和函数才能被这些函数看到。
  </para>
<!-- pgdoc-cn_end sig_en=a5adba0348adcb95c1b11fcb95fef544 -->

<!-- pgdoc-cn_start sig_en=f477ea52bc169096337ac1af28cfe8c2 sig_cn_org=8e0578da9a738986aa86e2083290e3db source=15.7 
  <para>
   Additional functions related to the cumulative statistics system are listed
   in <xref linkend="monitoring-stats-funcs-table"/>.
  </para>
________________________________________________________-->
  <para>
   与累积统计系统相关的其他功能在<xref linkend="monitoring-stats-funcs-table"/>中列出。
</para>
<!-- pgdoc-cn_end sig_en=f477ea52bc169096337ac1af28cfe8c2 -->

   <table id="monitoring-stats-funcs-table">
<!-- pgdoc-cn_start sig_en=d4cc5a499ac7eb2aea3614526623cf41 sig_cn_org=None source=14.1 
    <title>Additional Statistics Functions</title>
________________________________________________________-->
    <title>Additional Statistics Functions</title>
<!-- pgdoc-cn_end sig_en=d4cc5a499ac7eb2aea3614526623cf41 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=4c899847d3051ef2b6955dda3de51c66 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c899847d3051ef2b6955dda3de51c66 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=1e8a5bda4ce3d3488d9bfad4631ffbb5 sig_cn_org=None source=14.1 
      <row>
       <!-&minus; See also the entry for this in func.sgml -&minus;>
       <entry role="func_table_entry"><para role="func_signature">
        <function>pg_backend_pid</function> ()
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the process ID of the server process attached to the current
        session.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <!-- See also the entry for this in func.sgml -->
       <entry role="func_table_entry"><para role="func_signature">
        <function>pg_backend_pid</function> ()
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回附加到当前会话的服务器进程的进程ID。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=1e8a5bda4ce3d3488d9bfad4631ffbb5 -->

<!-- pgdoc-cn_start sig_en=d70a793d7692db20d8ea53b1a6cc42d2 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_activity</primary>
        </indexterm>
        <function>pg_stat_get_activity</function> ( <type>integer</type> )
        <returnvalue>setof record</returnvalue>
       </para>
       <para>
        Returns a record of information about the backend with the specified
        process ID, or one record for each active backend in the system
        if <literal>NULL</literal> is specified.  The fields returned are a
        subset of those in the <structname>pg_stat_activity</structname> view.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_activity</primary>
        </indexterm>
        <function>pg_stat_get_activity</function> ( <type>integer</type> )
        <returnvalue>setof record</returnvalue>
       </para>
       <para>
        使用指定的进程ID返回有关后端信息的记录，如果指定了<literal>NULL</literal>，则返回系统中每个活动后端的一条记录。
        返回的字段是<structname>pg_stat_activity</structname>视图中字段的子集。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d70a793d7692db20d8ea53b1a6cc42d2 -->

<!-- pgdoc-cn_start sig_en=4577cb3688687a4e89117c971b57eb72 sig_cn_org=8f30028a0d4b05319a2b8ef1ef959fa4 source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_snapshot_timestamp</primary>
        </indexterm>
        <function>pg_stat_get_snapshot_timestamp</function> ()
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        Returns the timestamp of the current statistics snapshot, or NULL if
        no statistics snapshot has been taken. A snapshot is taken the first
        time cumulative statistics are accessed in a transaction if
        <varname>stats_fetch_consistency</varname> is set to
        <literal>snapshot</literal>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_snapshot_timestamp</primary>
        </indexterm>
        <function>pg_stat_get_snapshot_timestamp</function> ()
        <returnvalue>时间戳与时区</returnvalue>
       </para>
       <para>
        返回当前统计快照的时间戳，如果没有统计快照则返回NULL。如果在事务中第一次访问累积统计信息时将快照设置为<varname>stats_fetch_consistency</varname>为<literal>snapshot</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4577cb3688687a4e89117c971b57eb72 -->

<!-- pgdoc-cn_start sig_en=f73e99fd2fc4449f18cee08012d2edb5 sig_cn_org=f50a7b23e8dd409db9b0661061a3a06e source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_xact_blocks_fetched</primary>
        </indexterm>
        <function>pg_stat_get_xact_blocks_fetched</function> ( <type>oid</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Returns the number of block read requests for table or index, in the
        current transaction. This number minus
        <function>pg_stat_get_xact_blocks_hit</function> gives the number of
        kernel <function>read()</function> calls; the number of actual
        physical reads is usually lower due to kernel-level buffering.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_xact_blocks_fetched</primary>
        </indexterm>
        <function>pg_stat_get_xact_blocks_fetched</function> ( <type>oid</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        返回当前事务中表或索引的块读取请求次数。这个数字减去
        <function>pg_stat_get_xact_blocks_hit</function>给出了内核<function>read()</function>调用的次数；
        实际的物理读取次数通常较低，这是由于内核级别的缓冲。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f73e99fd2fc4449f18cee08012d2edb5 -->

<!-- pgdoc-cn_start sig_en=69d3dc9f829fdb70c17676570cefef6a sig_cn_org=f4dbfa048cf8334a6025c222f8691a98 source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_xact_blocks_hit</primary>
        </indexterm>
        <function>pg_stat_get_xact_blocks_hit</function> ( <type>oid</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Returns the number of block read requests for table or index, in the
        current transaction, found in cache (not triggering kernel
        <function>read()</function> calls).
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_xact_blocks_hit</primary>
        </indexterm>
        <function>pg_stat_get_xact_blocks_hit</function> ( <type>oid</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        返回在当前事务中在缓存中找到的表或索引的块读取请求次数（不触发内核<function>read()</function>调用）。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=69d3dc9f829fdb70c17676570cefef6a -->

<!-- pgdoc-cn_start sig_en=efbb1a0f8e62653d3d03b101a3156d47 sig_cn_org=28fba26905b8a22f3c86af794179b2b6 source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_clear_snapshot</primary>
        </indexterm>
        <function>pg_stat_clear_snapshot</function> ()
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Discards the current statistics snapshot or cached information.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_clear_snapshot</primary>
        </indexterm>
        <function>pg_stat_clear_snapshot</function> ()
        <returnvalue>void</returnvalue>
       </para>
       <para>
        丢弃当前的统计快照或缓存信息。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=efbb1a0f8e62653d3d03b101a3156d47 -->

<!-- pgdoc-cn_start sig_en=362410241a8697718c2dd9fffb6c4707 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_reset</primary>
        </indexterm>
        <function>pg_stat_reset</function> ()
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Resets all statistics counters for the current database to zero.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_reset</primary>
        </indexterm>
        <function>pg_stat_reset</function> ()
        <returnvalue>void</returnvalue>
       </para>
       <para>
        将当前数据库的所有统计计数器重置为零。
       </para>
       <para>
        默认情况下该函数仅限于超级用户，但是其他用户可以被授予EXECUTE来运行此函数。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=362410241a8697718c2dd9fffb6c4707 -->

<!-- pgdoc-cn_start sig_en=8e1df6fba954893d7be3224759a5ee44 sig_cn_org=e00d691c76c578c7986ec1187e25b4d2 source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_reset_shared</primary>
        </indexterm>
        <function>pg_stat_reset_shared</function> ( <type>text</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Resets some cluster-wide statistics counters to zero, depending on the
        argument.  The argument can be <literal>bgwriter</literal> to reset
        all the counters shown in
        the <structname>pg_stat_bgwriter</structname>
        view, <literal>archiver</literal> to reset all the counters shown in
        the <structname>pg_stat_archiver</structname> view,
        <literal>wal</literal> to reset all the counters shown in the
        <structname>pg_stat_wal</structname> view or
        <literal>recovery_prefetch</literal> to reset all the counters shown
        in the <structname>pg_stat_recovery_prefetch</structname> view.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_reset_shared</primary>
        </indexterm>
        <function>pg_stat_reset_shared</function> ( <type>text</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        根据参数将一些集群范围的统计计数器重置为零。参数可以是<literal>bgwriter</literal>，
        用于重置在<structname>pg_stat_bgwriter</structname>视图中显示的所有计数器，
        <literal>archiver</literal>，用于重置在<structname>pg_stat_archiver</structname>视图中显示的所有计数器，
        <literal>wal</literal>，用于重置在<structname>pg_stat_wal</structname>视图中显示的所有计数器，
        或<literal>recovery_prefetch</literal>，用于重置在<structname>pg_stat_recovery_prefetch</structname>视图中显示的所有计数器。
       </para>
       <para>
        默认情况下，此函数仅限超级用户使用，但可以授予其他用户EXECUTE权限来运行该函数。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=8e1df6fba954893d7be3224759a5ee44 -->

<!-- pgdoc-cn_start sig_en=fe0d6dd3e45a1f43544fc33877aafd76 sig_cn_org=3990b2b2ad6cdd02ea4f789c26d94388 source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_reset_single_table_counters</primary>
        </indexterm>
        <function>pg_stat_reset_single_table_counters</function> ( <type>oid</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Resets statistics for a single table or index in the current database
        or shared across all databases in the cluster to zero.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_reset_single_table_counters</primary>
        </indexterm>
        <function>pg_stat_reset_single_table_counters</function> ( <type>oid</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        重置当前数据库中的单个表或索引的统计信息，或者在集群中跨所有数据库共享的统计信息为零。
       </para>
       <para>
        默认情况下，此函数仅限超级用户使用，但可以授予其他用户EXECUTE权限来运行该函数。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=fe0d6dd3e45a1f43544fc33877aafd76 -->

<!-- pgdoc-cn_start sig_en=0f2505688498a1901408529b24f8789a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_reset_single_function_counters</primary>
        </indexterm>
        <function>pg_stat_reset_single_function_counters</function> ( <type>oid</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Resets statistics for a single function in the current database to
        zero.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_reset_single_function_counters</primary>
        </indexterm>
        <function>pg_stat_reset_single_function_counters</function> ( <type>oid</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        将当前数据库中单个函数的统计信息重置为零。
       </para>
       <para>
        默认情况下该函数仅限于超级用户，但是其他用户可以被授予EXECUTE来运行此函数。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=0f2505688498a1901408529b24f8789a -->

<!-- pgdoc-cn_start sig_en=dfac523505499baeed7db7e98c0e8357 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_reset_slru</primary>
        </indexterm>
        <function>pg_stat_reset_slru</function> ( <type>text</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Resets statistics to zero for a single SLRU cache, or for all SLRUs in
        the cluster.  If the argument is NULL, all counters shown in
        the <structname>pg_stat_slru</structname> view for all SLRU caches are
        reset.  The argument can be one of
        <literal>CommitTs</literal>,
        <literal>MultiXactMember</literal>,
        <literal>MultiXactOffset</literal>,
        <literal>Notify</literal>,
        <literal>Serial</literal>,
        <literal>Subtrans</literal>, or
        <literal>Xact</literal>
        to reset the counters for only that entry.
        If the argument is <literal>other</literal> (or indeed, any
        unrecognized name), then the counters for all other SLRU caches, such
        as extension-defined caches, are reset.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_reset_slru</primary>
        </indexterm>
        <function>pg_stat_reset_slru</function> ( <type>text</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        将单个SLRU缓存或集群中所有SLRU的统计信息重置为零。
        如果该参数为NULL，则所有SLRU缓存的<structname>pg_stat_slru</structname>视图中显示的计数器将被重置。
        参数可以是<literal>CommitTs</literal>、<literal>MultiXactMember</literal>、<literal>MultiXactOffset</literal>、<literal>Notify</literal>、
        <literal>Serial</literal>、<literal>Subtrans</literal>、 或<literal>Xact</literal>中的一个，以便只重置该条目的计数器。
        如果参数是<literal>other</literal>(或实际上，任何无法识别的名称)，那么所有其他SLRU缓存的计数器，如扩展定义的缓存，将被重置。
       </para>
       <para>
        默认情况下该函数仅限于超级用户，但是其他用户可以被授予EXECUTE来运行此函数。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=dfac523505499baeed7db7e98c0e8357 -->

<!-- pgdoc-cn_start sig_en=d8b9236f66b84e0c8d055337761721f0 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
          <primary>pg_stat_reset_replication_slot</primary>
        </indexterm>
        <function>pg_stat_reset_replication_slot</function> ( <type>text</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Resets statistics of the replication slot defined by the argument. If
        the argument is <literal>NULL</literal>, resets statistics for all
        the replication slots.
       </para>
       <para>
         This function is restricted to superusers by default, but other users
         can be granted EXECUTE to run the function.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
          <primary>pg_stat_reset_replication_slot</primary>
        </indexterm>
        <function>pg_stat_reset_replication_slot</function> ( <type>text</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        重置由参数定义的复制槽的统计信息。
        如果参数为<literal>NULL</literal>，则重置所有复制槽的统计信息。
       </para>
       <para>
         该函数默认仅限于超级用户，但可以授予其他用户EXECUTE权限来运行该函数。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d8b9236f66b84e0c8d055337761721f0 -->

<!-- pgdoc-cn_start sig_en=7b9d4e081ad81f24d9e189198ae36eec sig_cn_org=16a749930df2f07819cb97808ce15d1c source=15.7 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
          <primary>pg_stat_reset_subscription_stats</primary>
        </indexterm>
        <function>pg_stat_reset_subscription_stats</function> ( <type>oid</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Resets statistics for a single subscription shown in the
        <structname>pg_stat_subscription_stats</structname> view to zero. If
        the argument is <literal>NULL</literal>, reset statistics for all
        subscriptions.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
          <primary>pg_stat_reset_subscription_stats</primary>
        </indexterm>
        <function>pg_stat_reset_subscription_stats</function> ( <type>oid</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        重置<structname>pg_stat_subscription_stats</structname>视图中显示的单个订阅的统计信息为零。
        如果参数是<literal>NULL</literal>，则重置所有订阅的统计信息。
       </para>
       <para>
        默认情况下，此函数仅限超级用户使用，但其他用户可以被授予EXECUTE权限来运行该函数。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=7b9d4e081ad81f24d9e189198ae36eec -->
     </tbody>
    </tgroup>
   </table>

  <warning>
<!-- pgdoc-cn_start sig_en=10c581b52a27c36c2db1c47395b0f18e sig_cn_org=ffe14191e4d0f872207e6dc90ca549ef source=15.7 
   <para>
    Using <function>pg_stat_reset()</function> also resets counters that
    autovacuum uses to determine when to trigger a vacuum or an analyze.
    Resetting these counters can cause autovacuum to not perform necessary
    work, which can cause problems such as table bloat or out-dated
    table statistics.  A database-wide <command>ANALYZE</command> is
    recommended after the statistics have been reset.
   </para>
________________________________________________________-->
   <para>
    使用<function>pg_stat_reset()</function>还会重置自动清理使用的计数器，
    以确定何时触发清理或分析。重置这些计数器可能导致自动清理不执行必要的工作，
    这可能会导致问题，如表膨胀或过时的表统计信息。建议在统计信息重置后进行全库<command>ANALYZE</command>。
   </para>
<!-- pgdoc-cn_end sig_en=10c581b52a27c36c2db1c47395b0f18e -->
  </warning>

<!-- pgdoc-cn_start sig_en=77882abe2d305007e5136f90b96da99c sig_cn_org=None source=14.1 
  <para>
   <function>pg_stat_get_activity</function>, the underlying function of
   the <structname>pg_stat_activity</structname> view, returns a set of records
   containing all the available information about each backend process.
   Sometimes it may be more convenient to obtain just a subset of this
   information.  In such cases, an older set of per-backend statistics
   access functions can be used; these are shown in <xref
   linkend="monitoring-stats-backend-funcs-table"/>.
   These access functions use a backend ID number, which ranges from one
   to the number of currently active backends.
   The function <function>pg_stat_get_backend_idset</function> provides a
   convenient way to generate one row for each active backend for
   invoking these functions.  For example, to show the <acronym>PID</acronym>s and
   current queries of all backends:

<programlisting>
SELECT pg_stat_get_backend_pid(s.backendid) AS pid,
       pg_stat_get_backend_activity(s.backendid) AS query
    FROM (SELECT pg_stat_get_backend_idset() AS backendid) AS s;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   <function>pg_stat_get_activity</function>是<structname>pg_stat_activity</structname>视图的底层函数，
   它返回一个行集合，其中包含有关每个后端进程所有可用的信息。有时只获得该信息的一个子集可能会更方便。
   在那些情况中，可以使用一组更老的针对每个后端的统计访问函数，这些显示在<xref linkend="monitoring-stats-backend-funcs-table"/>中。
   这些访问函数使用一个后端 ID 号，范围从 1 到当前活动后端数目。
   函数<function>pg_stat_get_backend_idset</function>提供了一种方便的方法为每个活动后端产生一行来调用这些函数。
   例如，要显示<acronym>PID</acronym>以及所有后端当前的查询：

<programlisting>
SELECT pg_stat_get_backend_pid(s.backendid) AS pid,
       pg_stat_get_backend_activity(s.backendid) AS query
    FROM (SELECT pg_stat_get_backend_idset() AS backendid) AS s;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=77882abe2d305007e5136f90b96da99c -->

   <table id="monitoring-stats-backend-funcs-table">
<!-- pgdoc-cn_start sig_en=6b18d959f84af9f5e8db6994c2b8aa38 sig_cn_org=None source=14.1 
    <title>Per-Backend Statistics Functions</title>
________________________________________________________-->
    <title>Per-Backend Statistics Functions</title>
<!-- pgdoc-cn_end sig_en=6b18d959f84af9f5e8db6994c2b8aa38 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=4c899847d3051ef2b6955dda3de51c66 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=4c899847d3051ef2b6955dda3de51c66 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=d5dd9b0e8319bfac93110f981f75e9f8 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_idset</primary>
        </indexterm>
        <function>pg_stat_get_backend_idset</function> ()
        <returnvalue>setof integer</returnvalue>
       </para>
       <para>
        Returns the set of currently active backend ID numbers (from 1 to the
        number of active backends).
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_idset</primary>
        </indexterm>
        <function>pg_stat_get_backend_idset</function> ()
        <returnvalue>setof integer</returnvalue>
       </para>
       <para>
        返回当前活动后端ID号的集合(从1到活动后端数)。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d5dd9b0e8319bfac93110f981f75e9f8 -->

<!-- pgdoc-cn_start sig_en=c559ca8c6179c820f518a0388698ba53 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_activity</primary>
        </indexterm>
        <function>pg_stat_get_backend_activity</function> ( <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the text of this backend's most recent query.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_activity</primary>
        </indexterm>
        <function>pg_stat_get_backend_activity</function> ( <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回此后端最近查询的文本。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=c559ca8c6179c820f518a0388698ba53 -->

<!-- pgdoc-cn_start sig_en=0a3abd62af4cc4b535afda188237055a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_activity_start</primary>
        </indexterm>
        <function>pg_stat_get_backend_activity_start</function> ( <type>integer</type> )
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        Returns the time when the backend's most recent query was started.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_activity_start</primary>
        </indexterm>
        <function>pg_stat_get_backend_activity_start</function> ( <type>integer</type> )
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        返回后端最近一次查询开始的时间。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=0a3abd62af4cc4b535afda188237055a -->

<!-- pgdoc-cn_start sig_en=32ee9d331a4007226df43bb069d8dca4 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_client_addr</primary>
        </indexterm>
        <function>pg_stat_get_backend_client_addr</function> ( <type>integer</type> )
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Returns the IP address of the client connected to this backend.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_client_addr</primary>
        </indexterm>
        <function>pg_stat_get_backend_client_addr</function> ( <type>integer</type> )
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        返回连接到此后端的客户端的IP地址。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=32ee9d331a4007226df43bb069d8dca4 -->

<!-- pgdoc-cn_start sig_en=c1e4f2bcd14c94a9287204d8a182edac sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_client_port</primary>
        </indexterm>
        <function>pg_stat_get_backend_client_port</function> ( <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the TCP port number that the client is using for communication.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_client_port</primary>
        </indexterm>
        <function>pg_stat_get_backend_client_port</function> ( <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回客户端用于通信的TCP端口号。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=c1e4f2bcd14c94a9287204d8a182edac -->

<!-- pgdoc-cn_start sig_en=519d3f1311fcf1b089f35718c193831e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_dbid</primary>
        </indexterm>
        <function>pg_stat_get_backend_dbid</function> ( <type>integer</type> )
        <returnvalue>oid</returnvalue>
       </para>
       <para>
        Returns the OID of the database this backend is connected to.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_dbid</primary>
        </indexterm>
        <function>pg_stat_get_backend_dbid</function> ( <type>integer</type> )
        <returnvalue>oid</returnvalue>
       </para>
       <para>
        返回此后端连接的数据库的OID。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=519d3f1311fcf1b089f35718c193831e -->

<!-- pgdoc-cn_start sig_en=cefff06b332aa3c0a14f9f3381f7ab19 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_pid</primary>
        </indexterm>
        <function>pg_stat_get_backend_pid</function> ( <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the process ID of this backend.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_pid</primary>
        </indexterm>
        <function>pg_stat_get_backend_pid</function> ( <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回此后端进程ID。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=cefff06b332aa3c0a14f9f3381f7ab19 -->

<!-- pgdoc-cn_start sig_en=5de7dccef1f63cb96dbef09bca4db03d sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_start</primary>
        </indexterm>
        <function>pg_stat_get_backend_start</function> ( <type>integer</type> )
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        Returns the time when this process was started.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_start</primary>
        </indexterm>
        <function>pg_stat_get_backend_start</function> ( <type>integer</type> )
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        返回该进程开始的时间。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=5de7dccef1f63cb96dbef09bca4db03d -->

<!-- pgdoc-cn_start sig_en=421b57aba99cd78d1abcc404b6f98e0d sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_userid</primary>
        </indexterm>
        <function>pg_stat_get_backend_userid</function> ( <type>integer</type> )
        <returnvalue>oid</returnvalue>
       </para>
       <para>
        Returns the OID of the user logged into this backend.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_userid</primary>
        </indexterm>
        <function>pg_stat_get_backend_userid</function> ( <type>integer</type> )
        <returnvalue>oid</returnvalue>
       </para>
       <para>
        返回登录到此后端的用户的OID。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=421b57aba99cd78d1abcc404b6f98e0d -->

<!-- pgdoc-cn_start sig_en=cd33e5995250b1218c48ae58684f4d60 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_wait_event_type</primary>
        </indexterm>
        <function>pg_stat_get_backend_wait_event_type</function> ( <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the wait event type name if this backend is currently waiting,
        otherwise NULL.  See <xref linkend="wait-event-table"/> for details.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_wait_event_type</primary>
        </indexterm>
        <function>pg_stat_get_backend_wait_event_type</function> ( <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        如果后端当前正在等待，返回等待事件类型名称，否则返回NULL。
        详请参见<xref linkend="wait-event-table"/>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=cd33e5995250b1218c48ae58684f4d60 -->

<!-- pgdoc-cn_start sig_en=6e717ca0a7933a2818a9b5adab821716 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_wait_event</primary>
        </indexterm>
        <function>pg_stat_get_backend_wait_event</function> ( <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the wait event name if this backend is currently waiting,
        otherwise NULL. See <xref linkend="wait-event-activity-table"/> through
        <xref linkend="wait-event-timeout-table"/>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_wait_event</primary>
        </indexterm>
        <function>pg_stat_get_backend_wait_event</function> ( <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        如果后端当前正在等待，则返回等待事件名称，否则为NULL。
        参见 <xref linkend="wait-event-activity-table"/> 到 <xref linkend="wait-event-timeout-table"/>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=6e717ca0a7933a2818a9b5adab821716 -->

<!-- pgdoc-cn_start sig_en=d18934af491890f37386b2ea9ea3bc9b sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_xact_start</primary>
        </indexterm>
        <function>pg_stat_get_backend_xact_start</function> ( <type>integer</type> )
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        Returns the time when the backend's current transaction was started.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_xact_start</primary>
        </indexterm>
        <function>pg_stat_get_backend_xact_start</function> ( <type>integer</type> )
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        返回后端当前事务开始的时间。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d18934af491890f37386b2ea9ea3bc9b -->
     </tbody>
    </tgroup>
   </table>

 </sect2>
 </sect1>

 <sect1 id="monitoring-locks">
<!-- pgdoc-cn_start sig_en=18fca79f646ba8a3d9a229810830e007 sig_cn_org=None source=14.1 
  <title>Viewing Locks</title>
________________________________________________________-->
  <title>查看锁</title>
<!-- pgdoc-cn_end sig_en=18fca79f646ba8a3d9a229810830e007 -->

<!-- pgdoc-cn_start sig_en=807c7241c44875070020734feaf56ba2 sig_cn_org=None source=14.1 
  <indexterm zone="monitoring-locks">
   <primary>lock</primary>
   <secondary>monitoring</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="monitoring-locks">
   <primary>lock</primary>
   <secondary>monitoring</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=807c7241c44875070020734feaf56ba2 -->

<!-- pgdoc-cn_start sig_en=61a838234c5d8ef8004cb089ba94ae8e sig_cn_org=None source=14.1 
  <para>
   Another useful tool for monitoring database activity is the
   <structname>pg_locks</structname> system table.  It allows the
   database administrator to view information about the outstanding
   locks in the lock manager. For example, this capability can be used
   to:

   <itemizedlist>
    <listitem>
     <para>
      View all the locks currently outstanding, all the locks on
      relations in a particular database, all the locks on a
      particular relation, or all the locks held by a particular
      <productname>PostgreSQL</productname> session.
     </para>
    </listitem>

    <listitem>
     <para>
      Determine the relation in the current database with the most
      ungranted locks (which might be a source of contention among
      database clients).
     </para>
    </listitem>

    <listitem>
     <para>
      Determine the effect of lock contention on overall database
      performance, as well as the extent to which contention varies
      with overall database traffic.
     </para>
    </listitem>
   </itemizedlist>

   Details of the <structname>pg_locks</structname> view appear in
   <xref linkend="view-pg-locks"/>.
   For more information on locking and managing concurrency with
   <productname>PostgreSQL</productname>, refer to <xref linkend="mvcc"/>.
  </para>
________________________________________________________-->
  <para>
   监控数据库活动的另外一个有用的工具是<structname>pg_locks</structname>系统表。这样就允许数据库管理员查看在锁管理器里面未解决的锁的信息。例如，这个功能可以被用于：

   <itemizedlist>
    <listitem>
     <para>
      查看当前所有未解决的锁、在一个特定数据库中的关系上所有的锁、在一个特定关系上所有的锁，或者由一个特定<productname>PostgreSQL</productname>会话持有的所有的锁。
     </para>
    </listitem>

    <listitem>
     <para>
      判断当前数据库中带有最多未授予锁的关系（它很可能是数据库客户端的竞争源）。
     </para>
    </listitem>

    <listitem>
     <para>
      判断锁竞争给数据库总体性能带来的影响，以及锁竞争随着整个数据库流量的变化范围。
     </para>
    </listitem>
   </itemizedlist>

   <structname>pg_locks</structname>视图的细节在<xref linkend="view-pg-locks"/>中。更多有关<productname>PostgreSQL</productname>的锁和管理并发性的信息，请参考<xref linkend="mvcc"/>。
  </para>
<!-- pgdoc-cn_end sig_en=61a838234c5d8ef8004cb089ba94ae8e -->
 </sect1>

 <sect1 id="progress-reporting">
<!-- pgdoc-cn_start sig_en=cc00aedde3ccc2fcac9d184b5d4b3204 sig_cn_org=None source=14.1 
  <title>Progress Reporting</title>
________________________________________________________-->
  <title>Progress Reporting</title>
<!-- pgdoc-cn_end sig_en=cc00aedde3ccc2fcac9d184b5d4b3204 -->

<!-- pgdoc-cn_start sig_en=0c412d1c69e4e46ab38782fc82d3f68c sig_cn_org=None source=14.1 
  <para>
   <productname>PostgreSQL</productname> has the ability to report the progress of
   certain commands during command execution.  Currently, the only commands
   which support progress reporting are <command>ANALYZE</command>,
   <command>CLUSTER</command>,
   <command>CREATE INDEX</command>, <command>VACUUM</command>,
   <command>COPY</command>,
   and <xref linkend="protocol-replication-base-backup"/> (i.e., replication
   command that <xref linkend="app-pgbasebackup"/> issues to take
   a base backup).
   This may be expanded in the future.
  </para>
________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>具有在命令执行过程中报告某些命令进度的能力。 
   目前，支持进度报告的命令只有<command>ANALYZE</command>,<command>CLUSTER</command>,<command>CREATE INDEX</command>, <command>VACUUM</command>,<command>COPY</command>,
   和 <xref linkend="protocol-replication-base-backup"/>(例如 <xref linkend="app-pgbasebackup"/> 发出的进行基础备份的复制命令)。
   未来可能还会扩展。
  </para>
<!-- pgdoc-cn_end sig_en=0c412d1c69e4e46ab38782fc82d3f68c -->

 <sect2 id="analyze-progress-reporting">
<!-- pgdoc-cn_start sig_en=b3c43120d4f964441cbeab26905c5c77 sig_cn_org=None source=14.1 
  <title>ANALYZE Progress Reporting</title>
________________________________________________________-->
  <title>ANALYZE Progress Reporting</title>
<!-- pgdoc-cn_end sig_en=b3c43120d4f964441cbeab26905c5c77 -->

<!-- pgdoc-cn_start sig_en=b7dd7a7f52edef073757b5211392f82b sig_cn_org=None source=14.1 
  <indexterm>
   <primary>pg_stat_progress_analyze</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>pg_stat_progress_analyze</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=b7dd7a7f52edef073757b5211392f82b -->

<!-- pgdoc-cn_start sig_en=0453d93fa03f9b6ac5783ad4a0985f76 sig_cn_org=None source=14.1 
  <para>
   Whenever <command>ANALYZE</command> is running, the
   <structname>pg_stat_progress_analyze</structname> view will contain a
   row for each backend that is currently running that command.  The tables
   below describe the information that will be reported and provide
   information about how to interpret it.
  </para>
________________________________________________________-->
  <para>
   每当<command>ANALYZE</command>运行时，<structname>pg_stat_progress_analyze</structname>视图将包含当前运行该命令的每个后端的一行。
   下面的表描述了将要报告的信息，并提供了关于如何解释它们的信息。
  </para>
<!-- pgdoc-cn_end sig_en=0453d93fa03f9b6ac5783ad4a0985f76 -->

  <table id="pg-stat-progress-analyze-view" xreflabel="pg_stat_progress_analyze">
<!-- pgdoc-cn_start sig_en=8c6489a8c51bf39c99d715b7395a2ec1 sig_cn_org=None source=14.1 
   <title><structname>pg_stat_progress_analyze</structname> View</title>
________________________________________________________-->
   <title><structname>pg_stat_progress_analyze</structname> 视图</title>
<!-- pgdoc-cn_end sig_en=8c6489a8c51bf39c99d715b7395a2ec1 -->
   <tgroup cols="1">
    <thead>
<!-- pgdoc-cn_start sig_en=19eb14a155d7416c3b9cad7829c11a9d sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=19eb14a155d7416c3b9cad7829c11a9d -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=a916babfb86c58511598ec13c8d23dc6 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       Process ID of backend.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       后端的进程ID。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=a916babfb86c58511598ec13c8d23dc6 -->

<!-- pgdoc-cn_start sig_en=9f5f0957095e7893d5dd902081f00096 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the database to which this backend is connected.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datid</structfield> <type>oid</type>
      </para>
      <para>
       后端连接到的数据库的OID。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=9f5f0957095e7893d5dd902081f00096 -->

<!-- pgdoc-cn_start sig_en=2e7f4e88844e0fdb7cce4de93426a70a sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datname</structfield> <type>name</type>
      </para>
      <para>
       Name of the database to which this backend is connected.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datname</structfield> <type>name</type>
      </para>
      <para>
       后端连接到的数据库的名称。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=2e7f4e88844e0fdb7cce4de93426a70a -->

<!-- pgdoc-cn_start sig_en=57e90aa1c88318703c3057bfc4677e3a sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the table being analyzed.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       被分析的表的OID。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=57e90aa1c88318703c3057bfc4677e3a -->

<!-- pgdoc-cn_start sig_en=408c59d84787d5a566074ee97bec1297 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>phase</structfield> <type>text</type>
      </para>
      <para>
       Current processing phase. See <xref linkend="analyze-phases"/>.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>phase</structfield> <type>text</type>
      </para>
      <para>
       当前处理阶段。参见 <xref linkend="analyze-phases"/>。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=408c59d84787d5a566074ee97bec1297 -->

<!-- pgdoc-cn_start sig_en=c4f8ee7ce6b3df781d7bdf6b8b8a3501 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sample_blks_total</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of heap blocks that will be sampled.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sample_blks_total</structfield> <type>bigint</type>
      </para>
      <para>
       将被采样的堆块的总数。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=c4f8ee7ce6b3df781d7bdf6b8b8a3501 -->

<!-- pgdoc-cn_start sig_en=d8975d54c9af045ebeb3def5ab813823 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sample_blks_scanned</structfield> <type>bigint</type>
      </para>
      <para>
       Number of heap blocks scanned.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sample_blks_scanned</structfield> <type>bigint</type>
      </para>
      <para>
       扫描的堆块数量。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=d8975d54c9af045ebeb3def5ab813823 -->

<!-- pgdoc-cn_start sig_en=9de29711668820b40b1a471225d995cd sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>ext_stats_total</structfield> <type>bigint</type>
      </para>
      <para>
       Number of extended statistics.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>ext_stats_total</structfield> <type>bigint</type>
      </para>
      <para>
       扩展统计信息的数量。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=9de29711668820b40b1a471225d995cd -->

<!-- pgdoc-cn_start sig_en=0ae2e93be6876c4510db5cb0b8a38d32 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>ext_stats_computed</structfield> <type>bigint</type>
      </para>
      <para>
       Number of extended statistics computed. This counter only advances
       when the phase is <literal>computing extended statistics</literal>.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>ext_stats_computed</structfield> <type>bigint</type>
      </para>
      <para>
       已经计算的扩展统计的数量. 此计数器仅在 <literal>computing extended statistics</literal>阶段增进。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=0ae2e93be6876c4510db5cb0b8a38d32 -->

<!-- pgdoc-cn_start sig_en=a3a5758fda01569f706e8e2fe1d3b4c9 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>child_tables_total</structfield> <type>bigint</type>
      </para>
      <para>
       Number of child tables.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>child_tables_total</structfield> <type>bigint</type>
      </para>
      <para>
       子表的数量。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=a3a5758fda01569f706e8e2fe1d3b4c9 -->

<!-- pgdoc-cn_start sig_en=62c610aa8e45568056ed7f68ab1afcc5 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>child_tables_done</structfield> <type>bigint</type>
      </para>
      <para>
       Number of child tables scanned. This counter only advances when the
       phase is <literal>acquiring inherited sample rows</literal>.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>child_tables_done</structfield> <type>bigint</type>
      </para>
      <para>
       扫描的子表数。此计数器只有在<literal>acquiring inherited sample rows</literal>阶段才会增进。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=62c610aa8e45568056ed7f68ab1afcc5 -->

<!-- pgdoc-cn_start sig_en=fa99ed7c9538cdcdd687dcd2e3b26270 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>current_child_table_relid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the child table currently being scanned. This field is
       only valid when the phase is
       <literal>acquiring inherited sample rows</literal>.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>current_child_table_relid</structfield> <type>oid</type>
      </para>
      <para>
       当前正在扫描的子表的OID。此字段仅在<literal>acquiring inherited sample rows</literal>时有效。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=fa99ed7c9538cdcdd687dcd2e3b26270 -->
    </tbody>
   </tgroup>
  </table>

  <table id="analyze-phases">
<!-- pgdoc-cn_start sig_en=52eafb52f2d79ae13e3edfc6ff6af71a sig_cn_org=c43c44d944498162fbba5bf93c300779 source=15.7 
   <title>ANALYZE Phases</title>
________________________________________________________-->
   <title>ANALYZE 阶段</title>
<!-- pgdoc-cn_end sig_en=52eafb52f2d79ae13e3edfc6ff6af71a -->
   <tgroup cols="2">
    <colspec colname="col1" colwidth="1*"/>
    <colspec colname="col2" colwidth="2*"/>
    <thead>
<!-- pgdoc-cn_start sig_en=c1529d0542903711f7b115996688901f sig_cn_org=None source=14.1 
     <row>
      <entry>Phase</entry>
      <entry>Description</entry>
     </row>
________________________________________________________-->
     <row>
      <entry>阶段</entry>
      <entry>描述</entry>
     </row>
<!-- pgdoc-cn_end sig_en=c1529d0542903711f7b115996688901f -->
    </thead>
    <tbody>
<!-- pgdoc-cn_start sig_en=36afb6f2effef11b6aa763388a21eed4 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>initializing</literal></entry>
      <entry>
       The command is preparing to begin scanning the heap.  This phase is
       expected to be very brief.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>initializing</literal></entry>
      <entry>
       命令正在准备开始扫描堆。这个阶段预计会非常短暂。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=36afb6f2effef11b6aa763388a21eed4 -->
<!-- pgdoc-cn_start sig_en=5a14cea4864dd402fdc2f4a34e7cb77c sig_cn_org=None source=14.1 
     <row>
      <entry><literal>acquiring sample rows</literal></entry>
      <entry>
       The command is currently scanning the table given by
       <structfield>relid</structfield> to obtain sample rows.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>acquiring sample rows</literal></entry>
      <entry>
       该命令当前正在扫描<structfield>relid</structfield>给出的表以获得示例行。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=5a14cea4864dd402fdc2f4a34e7cb77c -->
<!-- pgdoc-cn_start sig_en=60400e780409659eb5075fa6e36f7e00 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>acquiring inherited sample rows</literal></entry>
      <entry>
       The command is currently scanning child tables to obtain sample rows.
       Columns <structfield>child_tables_total</structfield>,
       <structfield>child_tables_done</structfield>, and
       <structfield>current_child_table_relid</structfield> contain the
       progress information for this phase.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>acquiring inherited sample rows</literal></entry>
      <entry>
       该命令当前正在扫描子表以获得示例行。列<structfield>child_tables_total</structfield>,<structfield>child_tables_done</structfield>, 
       和<structfield>current_child_table_relid</structfield>包含此阶段的进度信息。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=60400e780409659eb5075fa6e36f7e00 -->
<!-- pgdoc-cn_start sig_en=d1ebfa64ce9eba77c5402b0770540e28 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>computing statistics</literal></entry>
      <entry>
       The command is computing statistics from the sample rows obtained
       during the table scan.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>computing statistics</literal></entry>
      <entry>
       该命令从表扫描期间获得的样例行计算统计信息。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=d1ebfa64ce9eba77c5402b0770540e28 -->
<!-- pgdoc-cn_start sig_en=d3100c24357789cea4743432e5763420 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>computing extended statistics</literal></entry>
      <entry>
       The command is computing extended statistics from the sample rows
       obtained during the table scan.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>computing extended statistics</literal></entry>
      <entry>
       该命令从表扫描期间获得的样例行计算扩展统计信息。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=d3100c24357789cea4743432e5763420 -->
<!-- pgdoc-cn_start sig_en=c522f6819469f613237e7a93e528dfef sig_cn_org=None source=14.1 
     <row>
      <entry><literal>finalizing analyze</literal></entry>
      <entry>
       The command is updating <structname>pg_class</structname>. When this
       phase is completed, <command>ANALYZE</command> will end.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>finalizing analyze</literal></entry>
      <entry>
       该命令在更新<structname>pg_class</structname>。当此阶段完成时，<command>ANALYZE</command> 将结束。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=c522f6819469f613237e7a93e528dfef -->
    </tbody>
   </tgroup>
  </table>

  <note>
<!-- pgdoc-cn_start sig_en=90b2a84f86812d4733fbcf4ebfb4b7b5 sig_cn_org=None source=14.1 
   <para>
    Note that when <command>ANALYZE</command> is run on a partitioned table,
    all of its partitions are also recursively analyzed.
    In that case, <command>ANALYZE</command>
    progress is reported first for the parent table, whereby its inheritance
    statistics are collected, followed by that for each partition.
   </para>
________________________________________________________-->
   <para>
    注意当在分区表上运行<command>ANALYZE</command>时，它的所有分区也会被递归分析。
    在这种情况下，首先报告父表的<command>ANALYZE</command>进度，收集它的继承统计信息，然后是每个分区的(继承统计信息)。
   </para>
<!-- pgdoc-cn_end sig_en=90b2a84f86812d4733fbcf4ebfb4b7b5 -->
  </note>
 </sect2>

 <sect2 id="create-index-progress-reporting">
<!-- pgdoc-cn_start sig_en=dfe1c5b0ad415009306eea961f76b366 sig_cn_org=None source=14.1 
  <title>CREATE INDEX Progress Reporting</title>
________________________________________________________-->
  <title>CREATE INDEX Progress Reporting</title>
<!-- pgdoc-cn_end sig_en=dfe1c5b0ad415009306eea961f76b366 -->

<!-- pgdoc-cn_start sig_en=1fb1ae4436d3261fb5627b4905f796e4 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>pg_stat_progress_create_index</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>pg_stat_progress_create_index</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=1fb1ae4436d3261fb5627b4905f796e4 -->

<!-- pgdoc-cn_start sig_en=ce7b11ae43bb5fd206d91f71b0f1db75 sig_cn_org=None source=14.1 
  <para>
   Whenever <command>CREATE INDEX</command> or <command>REINDEX</command> is running, the
   <structname>pg_stat_progress_create_index</structname> view will contain
   one row for each backend that is currently creating indexes.  The tables
   below describe the information that will be reported and provide information
   about how to interpret it.
  </para>
________________________________________________________-->
  <para>
   每当运行<command>CREATE INDEX</command>或<command>REINDEX</command>时，<structname>pg_stat_progress_create_index</structname>视图将包含当前正在创建索引的每个后端的一行。
   下面的表描述了将要报告的信息，并提供了关于如何解释它的信息。
  </para>
<!-- pgdoc-cn_end sig_en=ce7b11ae43bb5fd206d91f71b0f1db75 -->

  <table id="pg-stat-progress-create-index-view" xreflabel="pg_stat_progress_create_index">
<!-- pgdoc-cn_start sig_en=d9e21a1f8a5849429e6d2a8bc2859b16 sig_cn_org=None source=14.1 
   <title><structname>pg_stat_progress_create_index</structname> View</title>
________________________________________________________-->
   <title><structname>pg_stat_progress_create_index</structname> 视图</title>
<!-- pgdoc-cn_end sig_en=d9e21a1f8a5849429e6d2a8bc2859b16 -->
   <tgroup cols="1">
    <thead>
<!-- pgdoc-cn_start sig_en=19eb14a155d7416c3b9cad7829c11a9d sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=19eb14a155d7416c3b9cad7829c11a9d -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=a916babfb86c58511598ec13c8d23dc6 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       Process ID of backend.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       后端的进程ID。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=a916babfb86c58511598ec13c8d23dc6 -->

<!-- pgdoc-cn_start sig_en=9f5f0957095e7893d5dd902081f00096 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the database to which this backend is connected.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datid</structfield> <type>oid</type>
      </para>
      <para>
       后端连接到的数据库的OID。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=9f5f0957095e7893d5dd902081f00096 -->

<!-- pgdoc-cn_start sig_en=2e7f4e88844e0fdb7cce4de93426a70a sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datname</structfield> <type>name</type>
      </para>
      <para>
       Name of the database to which this backend is connected.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datname</structfield> <type>name</type>
      </para>
      <para>
       后端连接到的数据库的名称。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=2e7f4e88844e0fdb7cce4de93426a70a -->

<!-- pgdoc-cn_start sig_en=a51d90d4dce2cf17dfa89d617e6e7771 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the table on which the index is being created.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       正在创建索引的表的OID。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=a51d90d4dce2cf17dfa89d617e6e7771 -->

<!-- pgdoc-cn_start sig_en=c8655d2f716629aec9367fe264461713 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>index_relid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the index being created or reindexed.  During a
       non-concurrent <command>CREATE INDEX</command>, this is 0.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>index_relid</structfield> <type>oid</type>
      </para>
      <para>
       正在创建或重建索引的OID。在非并发 <command>CREATE INDEX</command>的时候，此为 0。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=c8655d2f716629aec9367fe264461713 -->

<!-- pgdoc-cn_start sig_en=cba520d14375644b0267223924432533 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>command</structfield> <type>text</type>
      </para>
      <para>
       The command that is running: <literal>CREATE INDEX</literal>,
       <literal>CREATE INDEX CONCURRENTLY</literal>,
       <literal>REINDEX</literal>, or <literal>REINDEX CONCURRENTLY</literal>.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>command</structfield> <type>text</type>
      </para>
      <para>
       在运行的命令: <literal>CREATE INDEX</literal>,<literal>CREATE INDEX CONCURRENTLY</literal>,
       <literal>REINDEX</literal>, 或 <literal>REINDEX CONCURRENTLY</literal>.
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=cba520d14375644b0267223924432533 -->

<!-- pgdoc-cn_start sig_en=b2307298f01cab988ad6cb91693172fb sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>phase</structfield> <type>text</type>
      </para>
      <para>
       Current processing phase of index creation.  See <xref linkend="create-index-phases"/>.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>phase</structfield> <type>text</type>
      </para>
      <para>
       索引创建的当前处理阶段。 参见 <xref linkend="create-index-phases"/>。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=b2307298f01cab988ad6cb91693172fb -->

<!-- pgdoc-cn_start sig_en=d624d19c680430e77cb388001a3e8631 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>lockers_total</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of lockers to wait for, when applicable.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>lockers_total</structfield> <type>bigint</type>
      </para>
      <para>
       在适用的情况下，需要等待的储物柜总数
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=d624d19c680430e77cb388001a3e8631 -->

<!-- pgdoc-cn_start sig_en=46620fc859c1521f2f30b2e4850777bc sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>lockers_done</structfield> <type>bigint</type>
      </para>
      <para>
       Number of lockers already waited for.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>lockers_done</structfield> <type>bigint</type>
      </para>
      <para>
       已经等待的储物柜数量。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=46620fc859c1521f2f30b2e4850777bc -->

<!-- pgdoc-cn_start sig_en=7d0b3dfb5fadbe8bd32f62f7eb79bda1 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>current_locker_pid</structfield> <type>bigint</type>
      </para>
      <para>
       Process ID of the locker currently being waited for.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>current_locker_pid</structfield> <type>bigint</type>
      </para>
      <para>
       目前正在等待的储物柜的进程ID。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=7d0b3dfb5fadbe8bd32f62f7eb79bda1 -->

<!-- pgdoc-cn_start sig_en=1b05df273fc9a87bec6175d7f6afd88e sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blocks_total</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of blocks to be processed in the current phase.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blocks_total</structfield> <type>bigint</type>
      </para>
      <para>
       本阶段要处理的区块总数。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=1b05df273fc9a87bec6175d7f6afd88e -->

<!-- pgdoc-cn_start sig_en=a94cabdac849888a1274183ab1142a11 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blocks_done</structfield> <type>bigint</type>
      </para>
      <para>
       Number of blocks already processed in the current phase.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blocks_done</structfield> <type>bigint</type>
      </para>
      <para>
       当前阶段已经处理的区块数量。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=a94cabdac849888a1274183ab1142a11 -->

<!-- pgdoc-cn_start sig_en=6f1bf42b9ce3f203f0ef7a13a3f39c1b sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tuples_total</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of tuples to be processed in the current phase.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tuples_total</structfield> <type>bigint</type>
      </para>
      <para>
       当前阶段要处理的元组总数。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=6f1bf42b9ce3f203f0ef7a13a3f39c1b -->

<!-- pgdoc-cn_start sig_en=7cbdebe13421d835f82292451b7e2b72 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tuples_done</structfield> <type>bigint</type>
      </para>
      <para>
       Number of tuples already processed in the current phase.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tuples_done</structfield> <type>bigint</type>
      </para>
      <para>
       在当前阶段已经处理的元组数量。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=7cbdebe13421d835f82292451b7e2b72 -->

<!-- pgdoc-cn_start sig_en=0c0046ccccba72ff976cce5074ed82d7 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>partitions_total</structfield> <type>bigint</type>
      </para>
      <para>
       When creating an index on a partitioned table, this column is set to
       the total number of partitions on which the index is to be created.
       This field is <literal>0</literal> during a <literal>REINDEX</literal>.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>partitions_total</structfield> <type>bigint</type>
      </para>
      <para>
       在分区表上创建索引时，该列被设置为要在其上创建索引的分区总数。
       在<literal>REINDEX</literal>期间，此字段为<literal>0</literal>。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=0c0046ccccba72ff976cce5074ed82d7 -->

<!-- pgdoc-cn_start sig_en=6067f5f228ce6107a5999669e1cf423f sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>partitions_done</structfield> <type>bigint</type>
      </para>
      <para>
       When creating an index on a partitioned table, this column is set to
       the number of partitions on which the index has been created.
       This field is <literal>0</literal> during a <literal>REINDEX</literal>.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>partitions_done</structfield> <type>bigint</type>
      </para>
      <para>
       当在分区表上创建索引时，该列被设置为在其上建立索引的分区数。
       在<literal>REINDEX</literal>期间，此字段为<literal>0</literal>。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=6067f5f228ce6107a5999669e1cf423f -->
    </tbody>
   </tgroup>
  </table>

  <table id="create-index-phases">
<!-- pgdoc-cn_start sig_en=39c057706dc1040b165167decfe61faf sig_cn_org=None source=14.1 
   <title>CREATE INDEX Phases</title>
________________________________________________________-->
   <title>CREATE INDEX 的阶段</title>
<!-- pgdoc-cn_end sig_en=39c057706dc1040b165167decfe61faf -->
   <tgroup cols="2">
    <colspec colname="col1" colwidth="1*"/>
    <colspec colname="col2" colwidth="2*"/>
    <thead>
<!-- pgdoc-cn_start sig_en=c1529d0542903711f7b115996688901f sig_cn_org=None source=14.1 
     <row>
      <entry>Phase</entry>
      <entry>Description</entry>
     </row>
________________________________________________________-->
     <row>
      <entry>阶段</entry>
      <entry>描述</entry>
     </row>
<!-- pgdoc-cn_end sig_en=c1529d0542903711f7b115996688901f -->
    </thead>
    <tbody>
<!-- pgdoc-cn_start sig_en=cb94dbddb13b4f25d6f7b4c3cd138c55 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>initializing</literal></entry>
      <entry>
       <command>CREATE INDEX</command> or <command>REINDEX</command> is preparing to create the index.  This
       phase is expected to be very brief.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>初始化</literal></entry>
      <entry>
       <command>CREATE INDEX</command>或<command>REINDEX</command>正在准备创建索引。 这个阶段预计会非常短暂。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=cb94dbddb13b4f25d6f7b4c3cd138c55 -->
<!-- pgdoc-cn_start sig_en=eb342cb456c9c8f85f5944c60e09f4c7 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>waiting for writers before build</literal></entry>
      <entry>
       <command>CREATE INDEX CONCURRENTLY</command> or <command>REINDEX CONCURRENTLY</command> is waiting for transactions
       with write locks that can potentially see the table to finish.
       This phase is skipped when not in concurrent mode.
       Columns <structname>lockers_total</structname>, <structname>lockers_done</structname>
       and <structname>current_locker_pid</structname> contain the progress
       information for this phase.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>构建前等待读写器</literal></entry>
      <entry>
       <command>CREATE INDEX CONCURRENTLY</command>或<command>REINDEX CONCURRENTLY</command>正在等待有可能看到表的写锁的事务完成。 当不在并发模式时，这个阶段会被跳过。<structname>lockers_total</structname>、 <structname>lockers_done</structname> 和 <structname>current_locker_pid</structname> 列包含了这个阶段的进度信息。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=eb342cb456c9c8f85f5944c60e09f4c7 -->
<!-- pgdoc-cn_start sig_en=d96bcddaa6563f47d8d3d95f173da0e0 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>building index</literal></entry>
      <entry>
       The index is being built by the access method-specific code.  In this phase,
       access methods that support progress reporting fill in their own progress data,
       and the subphase is indicated in this column.  Typically,
       <structname>blocks_total</structname> and <structname>blocks_done</structname>
       will contain progress data, as well as potentially
       <structname>tuples_total</structname> and <structname>tuples_done</structname>.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>新建索引</literal></entry>
      <entry>
       索引是由访问方法专用代码建立的。 在这一阶段，支持进度报告的访问方法填写自己的进度数据，子阶段在这一栏中表示。 通常情况下，<structname>blocks_total</structname>和<structname>blocks_done</structname>将包含进度数据，也可能包含<structname>tuples_total</structname>和<structname>tuples_done</structname>。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=d96bcddaa6563f47d8d3d95f173da0e0 -->
<!-- pgdoc-cn_start sig_en=ee6abd0be77f55d4c0f555b7454497ab sig_cn_org=None source=14.1 
     <row>
      <entry><literal>waiting for writers before validation</literal></entry>
      <entry>
       <command>CREATE INDEX CONCURRENTLY</command> or <command>REINDEX CONCURRENTLY</command> is waiting for transactions
       with write locks that can potentially write into the table to finish.
       This phase is skipped when not in concurrent mode.
       Columns <structname>lockers_total</structname>, <structname>lockers_done</structname>
       and <structname>current_locker_pid</structname> contain the progress
       information for this phase.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>在验证前等待读写器</literal></entry>
      <entry>
       <command>CREATE INDEX CONCURRENTLY</command>或<command>REINDEX CONCURRENTLY</command>正在等待有可能写入表的事务完成写锁的事务。当不在并发模式时，这个阶段会被跳过。<structname>lockers_total</structname>、 <structname>lockers_done</structname> 和 <structname>current_locker_pid</structname> 列包含了这个阶段的进度信息。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=ee6abd0be77f55d4c0f555b7454497ab -->
<!-- pgdoc-cn_start sig_en=a97a376ff8fa50b3229380d0e8d87dac sig_cn_org=None source=14.1 
     <row>
      <entry><literal>index validation: scanning index</literal></entry>
      <entry>
       <command>CREATE INDEX CONCURRENTLY</command> is scanning the index searching
       for tuples that need to be validated.
       This phase is skipped when not in concurrent mode.
       Columns <structname>blocks_total</structname> (set to the total size of the index)
       and <structname>blocks_done</structname> contain the progress information for this phase.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>索引验证：扫描索引</literal></entry>
      <entry>
       <command>CREATE INDEX CONCURRENTLY</command>正在扫描索引，搜索需要验证的图元组。如果不是在并发模式下，这个阶段会被跳过。列 <structname>blocks_total</structname>（设置为索引的总大小）和 <structname>blocks_done</structname>包含了这个阶段的进度信息。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=a97a376ff8fa50b3229380d0e8d87dac -->
<!-- pgdoc-cn_start sig_en=6080c254e3b65fa0bf3a6824652ceb8e sig_cn_org=None source=14.1 
     <row>
      <entry><literal>index validation: sorting tuples</literal></entry>
      <entry>
       <command>CREATE INDEX CONCURRENTLY</command> is sorting the output of the
       index scanning phase.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>指数验证：排序元组</literal></entry>
      <entry>
       <command>CREATE INDEX CONCURRENTLY</command>正在对索引扫描阶段的输出进行排序。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=6080c254e3b65fa0bf3a6824652ceb8e -->
<!-- pgdoc-cn_start sig_en=33f87dbaa19fd1607808110e6dcf00a4 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>index validation: scanning table</literal></entry>
      <entry>
       <command>CREATE INDEX CONCURRENTLY</command> is scanning the table
       to validate the index tuples collected in the previous two phases.
       This phase is skipped when not in concurrent mode.
       Columns <structname>blocks_total</structname> (set to the total size of the table)
       and <structname>blocks_done</structname> contain the progress information for this phase.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>索引验证：扫描表</literal></entry>
      <entry>
       <command>CREATE INDEX CONCURRENTLY</command>正在扫描表，以验证前两个阶段收集的索引图元。当不在并发模式时，这个阶段被跳过。<structname>blocks_total</structname>列（设置为表的总大小）和<structname>blocks_done</structname>列包含这个阶段的进度信息。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=33f87dbaa19fd1607808110e6dcf00a4 -->
<!-- pgdoc-cn_start sig_en=7f80af1864c82447ec7ecfb8b1a0c10d sig_cn_org=None source=14.1 
     <row>
      <entry><literal>waiting for old snapshots</literal></entry>
      <entry>
       <command>CREATE INDEX CONCURRENTLY</command> or <command>REINDEX CONCURRENTLY</command> is waiting for transactions
       that can potentially see the table to release their snapshots.  This
       phase is skipped when not in concurrent mode.
       Columns <structname>lockers_total</structname>, <structname>lockers_done</structname>
       and <structname>current_locker_pid</structname> contain the progress
       information for this phase.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>等待旧照</literal></entry>
      <entry>
       <command>CREATE INDEX CONCURRENTLY</command>或<command>REINDEX CONCURRENTLY</command>正在等待可能看到表的事务释放快照。 当不处于并发模式时，这个阶段会被跳过。 <structname>lockers_total</structname>、<structname>lockers_done</structname> 和 <structname>current_locker_pid</structname> 列包含了这个阶段的进度信息。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=7f80af1864c82447ec7ecfb8b1a0c10d -->
<!-- pgdoc-cn_start sig_en=ab2c3b1ddae67d46f1723a05295e70b0 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>waiting for readers before marking dead</literal></entry>
      <entry>
       <command>REINDEX CONCURRENTLY</command> is waiting for transactions
       with read locks on the table to finish, before marking the old index dead.
       This phase is skipped when not in concurrent mode.
       Columns <structname>lockers_total</structname>, <structname>lockers_done</structname>
       and <structname>current_locker_pid</structname> contain the progress
       information for this phase.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>标记 dead之前等待readers</literal></entry>
      <entry>
       <command>REINDEX CONCURRENTLY</command>等待表上有读锁的事务完成后，再将旧索引标记为死索引。当不在并发模式时，这个阶段被跳过。<structname>lockers_total</structname>、<structname>lockers_done</structname> 和 <structname>current_locker_pid</structname> 列包含了这个阶段的进度信息。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=ab2c3b1ddae67d46f1723a05295e70b0 -->
<!-- pgdoc-cn_start sig_en=030ceb238660d9548737a36712d6f57e sig_cn_org=None source=14.1 
     <row>
      <entry><literal>waiting for readers before dropping</literal></entry>
      <entry>
       <command>REINDEX CONCURRENTLY</command> is waiting for transactions
       with read locks on the table to finish, before dropping the old index.
       This phase is skipped when not in concurrent mode.
       Columns <structname>lockers_total</structname>, <structname>lockers_done</structname>
       and <structname>current_locker_pid</structname> contain the progress
       information for this phase.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>在 dropping之前等待readers</literal></entry>
      <entry>
       <command>REINDEX CONCURRENTLY</command>等待表上有读锁的事务完成后，再丢弃旧索引。当不在并发模式时，这个阶段被跳过。列 <structname>lockers_total</structname>、<structname>lockers_done</structname> 和 <structname>current_locker_pid</structname>包含了这个阶段的进度信息。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=030ceb238660d9548737a36712d6f57e -->
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="vacuum-progress-reporting">
<!-- pgdoc-cn_start sig_en=043f4b25ce85f10ee646c5a750a4601a sig_cn_org=None source=14.1 
  <title>VACUUM Progress Reporting</title>
________________________________________________________-->
  <title>VACUUM进度报告</title>
<!-- pgdoc-cn_end sig_en=043f4b25ce85f10ee646c5a750a4601a -->

<!-- pgdoc-cn_start sig_en=2ce4272b1ab30ce01108e568b11caa23 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>pg_stat_progress_vacuum</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>pg_stat_progress_vacuum</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=2ce4272b1ab30ce01108e568b11caa23 -->

<!-- pgdoc-cn_start sig_en=9a6dbe5ca95cc88eb736c3f7def08a2e sig_cn_org=None source=14.1 
  <para>
   Whenever <command>VACUUM</command> is running, the
   <structname>pg_stat_progress_vacuum</structname> view will contain
   one row for each backend (including autovacuum worker processes) that is
   currently vacuuming.  The tables below describe the information
   that will be reported and provide information about how to interpret it.
   Progress for <command>VACUUM FULL</command> commands is reported via
   <structname>pg_stat_progress_cluster</structname>
   because both <command>VACUUM FULL</command> and <command>CLUSTER</command>
   rewrite the table, while regular <command>VACUUM</command> only modifies it
   in place. See <xref linkend='cluster-progress-reporting'/>.
  </para>
________________________________________________________-->
  <para>
   只要<command>VACUUM</command>正在运行，每一个当前正在清理的后端（包括autovacuum工作者进程）在<structname>pg_stat_progress_vacuum</structname>视图中都会有一行。下面的表描述了将被报告的信息并且提供了如何解释它们的信息。<command>VACUUM FULL</command>命令的进度是通过<structname>pg_stat_progress_cluster</structname>报告的，因为<command>VACUUM FULL</command>和<command>CLUSTER</command>都是重写表，而普通的<command>VACUUM</command>只是原地修改表。见<xref linkend='cluster-progress-reporting'/>.
  </para>
<!-- pgdoc-cn_end sig_en=9a6dbe5ca95cc88eb736c3f7def08a2e -->

  <table id="pg-stat-progress-vacuum-view" xreflabel="pg_stat_progress_vacuum">
<!-- pgdoc-cn_start sig_en=354a8ffcb2de48deea9e21121b449654 sig_cn_org=None source=14.1 
   <title><structname>pg_stat_progress_vacuum</structname> View</title>
________________________________________________________-->
   <title><structname>pg_stat_progress_vacuum</structname> 视图</title>
<!-- pgdoc-cn_end sig_en=354a8ffcb2de48deea9e21121b449654 -->
   <tgroup cols="1">
    <thead>
<!-- pgdoc-cn_start sig_en=19eb14a155d7416c3b9cad7829c11a9d sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=19eb14a155d7416c3b9cad7829c11a9d -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=a916babfb86c58511598ec13c8d23dc6 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       Process ID of backend.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       后端的进程ID。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=a916babfb86c58511598ec13c8d23dc6 -->

<!-- pgdoc-cn_start sig_en=9f5f0957095e7893d5dd902081f00096 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the database to which this backend is connected.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datid</structfield> <type>oid</type>
      </para>
      <para>
       后端连接到的数据库的OID。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=9f5f0957095e7893d5dd902081f00096 -->

<!-- pgdoc-cn_start sig_en=2e7f4e88844e0fdb7cce4de93426a70a sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datname</structfield> <type>name</type>
      </para>
      <para>
       Name of the database to which this backend is connected.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datname</structfield> <type>name</type>
      </para>
      <para>
       后端连接到的数据库的名称。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=2e7f4e88844e0fdb7cce4de93426a70a -->

<!-- pgdoc-cn_start sig_en=9af0951d9819e9eb51524842b6ee9195 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the table being vacuumed.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       被vacuum的表的OID。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=9af0951d9819e9eb51524842b6ee9195 -->

<!-- pgdoc-cn_start sig_en=c5761008bfc1a7483c9f70dd5162dfae sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>phase</structfield> <type>text</type>
      </para>
      <para>
       Current processing phase of vacuum.  See <xref linkend="vacuum-phases"/>.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>phase</structfield> <type>text</type>
      </para>
      <para>
       vacuum的当前处理阶段。参见 <xref linkend="vacuum-phases"/>。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=c5761008bfc1a7483c9f70dd5162dfae -->

<!-- pgdoc-cn_start sig_en=90e39d41688de03ce6010322234b6073 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_blks_total</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of heap blocks in the table.  This number is reported
       as of the beginning of the scan; blocks added later will not be (and
       need not be) visited by this <command>VACUUM</command>.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_blks_total</structfield> <type>bigint</type>
      </para>
      <para>
       该表中堆块的总数。这个数字在扫描开始时报告，之后增加的块将不会（并且不需要）被这个<command>VACUUM</command>访问。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=90e39d41688de03ce6010322234b6073 -->

<!-- pgdoc-cn_start sig_en=00b6c7927a99029784aa96f992f1624a sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_blks_scanned</structfield> <type>bigint</type>
      </para>
      <para>
       Number of heap blocks scanned.  Because the
       <link linkend="storage-vm">visibility map</link> is used to optimize scans,
       some blocks will be skipped without inspection; skipped blocks are
       included in this total, so that this number will eventually become
       equal to <structfield>heap_blks_total</structfield> when the vacuum is complete.
       This counter only advances when the phase is <literal>scanning heap</literal>.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_blks_scanned</structfield> <type>bigint</type>
      </para>
      <para>
       被扫描的堆块数量。由于<link linkend="storage-vm">visibility map</link>被用来优化扫描，一些块将被跳过而不做检查，
       被跳过的块会被包括在这个总数中，因此当清理完成时这个数字最终将会等于<structfield>heap_blks_total</structfield>。
       仅当处于<literal>扫描堆</literal>阶段时这个计数器才会前进。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=00b6c7927a99029784aa96f992f1624a -->

<!-- pgdoc-cn_start sig_en=2bbcf29ad95d5992ef0057afbf861641 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_blks_vacuumed</structfield> <type>bigint</type>
      </para>
      <para>
       Number of heap blocks vacuumed.  Unless the table has no indexes, this
       counter only advances when the phase is <literal>vacuuming heap</literal>.
       Blocks that contain no dead tuples are skipped, so the counter may
       sometimes skip forward in large increments.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_blks_vacuumed</structfield> <type>bigint</type>
      </para>
      <para>
       被清理的堆块数量。除非表没有索引，这个计数器仅在处于<literal>清理堆</literal>阶段时才会前进。
       不包含死亡元组的块会被跳过，因此这个计数器可能有时会向前跳跃一个比较大的增量。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=2bbcf29ad95d5992ef0057afbf861641 -->

<!-- pgdoc-cn_start sig_en=e890e1ce19e5d8b8bf21034988171bb3 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>index_vacuum_count</structfield> <type>bigint</type>
      </para>
      <para>
       Number of completed index vacuum cycles.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>index_vacuum_count</structfield> <type>bigint</type>
      </para>
      <para>
       已完成的索引清理周期数。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=e890e1ce19e5d8b8bf21034988171bb3 -->

<!-- pgdoc-cn_start sig_en=a8b0287807917f1c777ed33febc3249c sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>max_dead_tuples</structfield> <type>bigint</type>
      </para>
      <para>
       Number of dead tuples that we can store before needing to perform
       an index vacuum cycle, based on
       <xref linkend="guc-maintenance-work-mem"/>.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>max_dead_tuples</structfield> <type>bigint</type>
      </para>
      <para>
       在需要执行一个索引清理周期之前我们可以存储的死亡元组数，取决于<xref linkend="guc-maintenance-work-mem"/>。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=a8b0287807917f1c777ed33febc3249c -->

<!-- pgdoc-cn_start sig_en=cf8ef1d4f15e1c1a05c4e2d6681a845b sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>num_dead_tuples</structfield> <type>bigint</type>
      </para>
      <para>
       Number of dead tuples collected since the last index vacuum cycle.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>num_dead_tuples</structfield> <type>bigint</type>
      </para>
      <para>
       从上一个索引清理周期以来收集的死亡元组数。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=cf8ef1d4f15e1c1a05c4e2d6681a845b -->
    </tbody>
   </tgroup>
  </table>

  <table id="vacuum-phases">
<!-- pgdoc-cn_start sig_en=7b722bb8b3e204d923488035371c39ee sig_cn_org=None source=14.1 
   <title>VACUUM Phases</title>
________________________________________________________-->
   <title>VACUUM的阶段</title>
<!-- pgdoc-cn_end sig_en=7b722bb8b3e204d923488035371c39ee -->
   <tgroup cols="2">
    <colspec colname="col1" colwidth="1*"/>
    <colspec colname="col2" colwidth="2*"/>
    <thead>
<!-- pgdoc-cn_start sig_en=c1529d0542903711f7b115996688901f sig_cn_org=None source=14.1 
    <row>
      <entry>Phase</entry>
      <entry>Description</entry>
     </row>
________________________________________________________-->
    <row>
      <entry>阶段</entry>
      <entry>描述</entry>
     </row>
<!-- pgdoc-cn_end sig_en=c1529d0542903711f7b115996688901f -->
    </thead>

   <tbody>
<!-- pgdoc-cn_start sig_en=61dd771a7cf6a3d263fe48fd05bdaebe sig_cn_org=None source=14.1 
    <row>
     <entry><literal>initializing</literal></entry>
     <entry>
       <command>VACUUM</command> is preparing to begin scanning the heap.  This
       phase is expected to be very brief.
     </entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>初始化</literal></entry>
     <entry>
       <command>VACUUM</command>正在准备开始扫描堆。这个阶段应该很简短。
     </entry>
    </row>
<!-- pgdoc-cn_end sig_en=61dd771a7cf6a3d263fe48fd05bdaebe -->
<!-- pgdoc-cn_start sig_en=2bc31e6a860c90c96aa96b0588db3c20 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>scanning heap</literal></entry>
     <entry>
       <command>VACUUM</command> is currently scanning the heap.  It will prune and
       defragment each page if required, and possibly perform freezing
       activity.  The <structfield>heap_blks_scanned</structfield> column can be used
       to monitor the progress of the scan.
     </entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>扫描堆</literal></entry>
     <entry>
       <command>VACUUM</command>正在扫描堆。如果需要，它将会对每个页面进行修建以及碎片整理，并且可能会执行冻结动作。<structfield>heap_blks_scanned</structfield>列可以用来监控扫描的进度。
     </entry>
    </row>
<!-- pgdoc-cn_end sig_en=2bc31e6a860c90c96aa96b0588db3c20 -->
<!-- pgdoc-cn_start sig_en=58a0b2886d927a6e2ac62a1c118e0508 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>vacuuming indexes</literal></entry>
     <entry>
       <command>VACUUM</command> is currently vacuuming the indexes.  If a table has
       any indexes, this will happen at least once per vacuum, after the heap
       has been completely scanned.  It may happen multiple times per vacuum
       if <xref linkend="guc-maintenance-work-mem"/> (or, in the case of autovacuum,
       <xref linkend="guc-autovacuum-work-mem"/> if set) is insufficient to store
       the number of dead tuples found.
     </entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>清理索引</literal></entry>
     <entry>
       <command>VACUUM</command>当前正在清理索引。
       如果一个表拥有索引，那么每次清理时这个阶段会在堆扫描完成后至少发生一次。
       如果<xref linkend="guc-maintenance-work-mem"/>不足以存放找到的死亡元组(或者, 在autovacuum情况下，如果设置了<xref linkend="guc-autovacuum-work-mem"/>) ，则每次清理时会多次清理索引。
     </entry>
    </row>
<!-- pgdoc-cn_end sig_en=58a0b2886d927a6e2ac62a1c118e0508 -->
<!-- pgdoc-cn_start sig_en=3fe3de754b55a8eb42484580a7c8233b sig_cn_org=None source=14.1 
    <row>
     <entry><literal>vacuuming heap</literal></entry>
     <entry>
       <command>VACUUM</command> is currently vacuuming the heap.  Vacuuming the heap
       is distinct from scanning the heap, and occurs after each instance of
       vacuuming indexes.  If <structfield>heap_blks_scanned</structfield> is less than
       <structfield>heap_blks_total</structfield>, the system will return to scanning
       the heap after this phase is completed; otherwise, it will begin
       cleaning up indexes after this phase is completed.
     </entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>清理堆</literal></entry>
     <entry>
       <command>VACUUM</command>当前正在清理堆。清理堆与扫描堆不是同一个概念，清理堆发生在每一次清理索引的实例之后。如果<structfield>heap_blks_scanned</structfield>小于<structfield>heap_blks_total</structfield>，系统将在这个阶段完成之后回去扫描堆；否则，系统将在这个阶段完成后开始清理索引。
     </entry>
    </row>
<!-- pgdoc-cn_end sig_en=3fe3de754b55a8eb42484580a7c8233b -->
<!-- pgdoc-cn_start sig_en=a3062b04a6f0d411b672cc8aaf14a5c8 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>cleaning up indexes</literal></entry>
     <entry>
       <command>VACUUM</command> is currently cleaning up indexes.  This occurs after
       the heap has been completely scanned and all vacuuming of the indexes
       and the heap has been completed.
     </entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>清除索引</literal></entry>
     <entry>
       <command>VACUUM</command>当前正在清除索引。这个阶段发生在堆被完全扫描并且对堆和索引的所有清理都已经完成以后。
     </entry>
    </row>
<!-- pgdoc-cn_end sig_en=a3062b04a6f0d411b672cc8aaf14a5c8 -->
<!-- pgdoc-cn_start sig_en=597c3987c662ab5884feb87864702301 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>truncating heap</literal></entry>
     <entry>
       <command>VACUUM</command> is currently truncating the heap so as to return
       empty pages at the end of the relation to the operating system.  This
       occurs after cleaning up indexes.
     </entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>截断堆</literal></entry>
     <entry>
       <command>VACUUM</command>正在截断堆，以便把关系尾部的空页面返还给操作系统。这个阶段发生在清除完索引之后。
     </entry>
    </row>
<!-- pgdoc-cn_end sig_en=597c3987c662ab5884feb87864702301 -->
<!-- pgdoc-cn_start sig_en=693f2088d812cbc0d577eae7402fc282 sig_cn_org=8c20971d33749cee55227d31fbb8a516 source=15.7 
    <row>
     <entry><literal>performing final cleanup</literal></entry>
     <entry>
       <command>VACUUM</command> is performing final cleanup.  During this phase,
       <command>VACUUM</command> will vacuum the free space map, update statistics
       in <literal>pg_class</literal>, and report statistics to the cumulative
       statistics system. When this phase is completed, <command>VACUUM</command> will end.
     </entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>执行最终清理</literal></entry>
     <entry>
       <command>VACUUM</command>正在执行最终清理。在此阶段，<command>VACUUM</command>将清理空闲空间映射，
       更新<literal>pg_class</literal>中的统计信息，并向累积统计系统报告统计信息。当此阶段完成时，
       <command>VACUUM</command>将结束。
     </entry>
    </row>
<!-- pgdoc-cn_end sig_en=693f2088d812cbc0d577eae7402fc282 -->
   </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="cluster-progress-reporting">
<!-- pgdoc-cn_start sig_en=83a50fc26eacccdb59b5fb4c39a6face sig_cn_org=None source=14.1 
  <title>CLUSTER Progress Reporting</title>
________________________________________________________-->
  <title>CLUSTER进度报告</title>
<!-- pgdoc-cn_end sig_en=83a50fc26eacccdb59b5fb4c39a6face -->

<!-- pgdoc-cn_start sig_en=838b05ae0955ed3aa21954e3e3c15421 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>pg_stat_progress_cluster</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>pg_stat_progress_cluster</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=838b05ae0955ed3aa21954e3e3c15421 -->

<!-- pgdoc-cn_start sig_en=f2931b6642a80b0db923c830bd807993 sig_cn_org=None source=14.1 
  <para>
   Whenever <command>CLUSTER</command> or <command>VACUUM FULL</command> is
   running, the <structname>pg_stat_progress_cluster</structname> view will
   contain a row for each backend that is currently running either command.
   The tables below describe the information that will be reported and
   provide information about how to interpret it.
  </para>
________________________________________________________-->
  <para>
   每当<command>CLUSTER</command>或<command>VACUUM FULL</command>运行时，<structname>pg_stat_progress_cluster</structname>视图将包含当前正在运行的每一个后台的记录。下面的表格描述了将被报告的信息，并提供了关于如何解释这些信息的信息。
  </para>
<!-- pgdoc-cn_end sig_en=f2931b6642a80b0db923c830bd807993 -->

  <table id="pg-stat-progress-cluster-view" xreflabel="pg_stat_progress_cluster">
<!-- pgdoc-cn_start sig_en=fd611934e1996a2ecc45a97c6d633ce9 sig_cn_org=None source=14.1 
   <title><structname>pg_stat_progress_cluster</structname> View</title>
________________________________________________________-->
   <title><structname>pg_stat_progress_cluster</structname> 视图</title>
<!-- pgdoc-cn_end sig_en=fd611934e1996a2ecc45a97c6d633ce9 -->
   <tgroup cols="1">
    <thead>
<!-- pgdoc-cn_start sig_en=19eb14a155d7416c3b9cad7829c11a9d sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=19eb14a155d7416c3b9cad7829c11a9d -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=a916babfb86c58511598ec13c8d23dc6 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       Process ID of backend.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       后端的进程ID。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=a916babfb86c58511598ec13c8d23dc6 -->

<!-- pgdoc-cn_start sig_en=9f5f0957095e7893d5dd902081f00096 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the database to which this backend is connected.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datid</structfield> <type>oid</type>
      </para>
      <para>
       后端连接到的数据库的OID。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=9f5f0957095e7893d5dd902081f00096 -->

<!-- pgdoc-cn_start sig_en=2e7f4e88844e0fdb7cce4de93426a70a sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datname</structfield> <type>name</type>
      </para>
      <para>
       Name of the database to which this backend is connected.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datname</structfield> <type>name</type>
      </para>
      <para>
       后端连接到的数据库的名称。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=2e7f4e88844e0fdb7cce4de93426a70a -->

<!-- pgdoc-cn_start sig_en=10883ef49341c1347acca8faa62f38c9 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the table being clustered.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       被集群的表的OID。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=10883ef49341c1347acca8faa62f38c9 -->

<!-- pgdoc-cn_start sig_en=5a9193b43fc0456b072731b70f32680f sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>command</structfield> <type>text</type>
      </para>
      <para>
       The command that is running. Either <literal>CLUSTER</literal> or <literal>VACUUM FULL</literal>.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>command</structfield> <type>text</type>
      </para>
      <para>
       正在运行的命令。<literal>CLUSTER</literal>或<literal>VACUUM FULL</literal>。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=5a9193b43fc0456b072731b70f32680f -->

<!-- pgdoc-cn_start sig_en=a711e2eff3810e50390985645ef3057e sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>phase</structfield> <type>text</type>
      </para>
      <para>
       Current processing phase. See <xref linkend="cluster-phases"/>.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>phase</structfield> <type>text</type>
      </para>
      <para>
       当前处理阶段。参见<xref linkend='cluster-phases' />。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=a711e2eff3810e50390985645ef3057e -->

<!-- pgdoc-cn_start sig_en=6168715ca8b1c6cd7aa915257fc86e5a sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>cluster_index_relid</structfield> <type>oid</type>
      </para>
      <para>
       If the table is being scanned using an index, this is the OID of the
       index being used; otherwise, it is zero.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>cluster_index_relid</structfield> <type>oid</type>
      </para>
      <para>
       如果正在使用索引对表进行扫描，这就是正在使用的索引的OID；否则为0。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=6168715ca8b1c6cd7aa915257fc86e5a -->

<!-- pgdoc-cn_start sig_en=fcf0734df3a9a26626d3d2500ee4e871 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_tuples_scanned</structfield> <type>bigint</type>
      </para>
      <para>
       Number of heap tuples scanned.
       This counter only advances when the phase is
       <literal>seq scanning heap</literal>,
       <literal>index scanning heap</literal>
       or <literal>writing new heap</literal>.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_tuples_scanned</structfield> <type>bigint</type>
      </para>
      <para>
       扫描的堆元组数。
       这个计数器只有在阶段为<literal>seq scanning heap</literal>,<literal>index scanning heap</literal>
       或 <literal>writing new heap</literal>时才会增进。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=fcf0734df3a9a26626d3d2500ee4e871 -->

<!-- pgdoc-cn_start sig_en=82c374831bc3ceb8ce82b8b3d4524f6f sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_tuples_written</structfield> <type>bigint</type>
      </para>
      <para>
       Number of heap tuples written.
       This counter only advances when the phase is
       <literal>seq scanning heap</literal>,
       <literal>index scanning heap</literal>
       or <literal>writing new heap</literal>.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_tuples_written</structfield> <type>bigint</type>
      </para>
      <para>
       写入的堆元组的数量。这个计数器只有在阶段为<literal>seq scanning heap</literal>,<literal>index scanning heap</literal>
       或 <literal>writing new heap</literal>时才会前进。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=82c374831bc3ceb8ce82b8b3d4524f6f -->

<!-- pgdoc-cn_start sig_en=e8e3142490b70c21b00a31db7a0a9054 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_blks_total</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of heap blocks in the table.  This number is reported
       as of the beginning of <literal>seq scanning heap</literal>.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_blks_total</structfield> <type>bigint</type>
      </para>
      <para>
       表中的堆块总数。 这个数字是在<literal>seq scanning heap</literal>的开始时报告的。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=e8e3142490b70c21b00a31db7a0a9054 -->

<!-- pgdoc-cn_start sig_en=6aab73acc54fd666a434d733df266569 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_blks_scanned</structfield> <type>bigint</type>
      </para>
      <para>
       Number of heap blocks scanned.  This counter only advances when the
       phase is <literal>seq scanning heap</literal>.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_blks_scanned</structfield> <type>bigint</type>
      </para>
      <para>
       扫描的堆块数量。 这个计数器只有在阶段为<literal>seq scanning heap</literal>时才会增进。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=6aab73acc54fd666a434d733df266569 -->

<!-- pgdoc-cn_start sig_en=f8ee944763acc66fadb855e0bf3b9841 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>index_rebuild_count</structfield> <type>bigint</type>
      </para>
      <para>
       Number of indexes rebuilt.  This counter only advances when the phase
       is <literal>rebuilding index</literal>.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>index_rebuild_count</structfield> <type>bigint</type>
      </para>
      <para>
       重建的索引数。 该计数器仅在<literal>重建索引</literal>阶段时才会增进。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=f8ee944763acc66fadb855e0bf3b9841 -->
    </tbody>
   </tgroup>
  </table>

  <table id="cluster-phases">
<!-- pgdoc-cn_start sig_en=76b2dd2d997fc217555360266bd1eaad sig_cn_org=None source=14.1 
   <title>CLUSTER and VACUUM FULL Phases</title>
________________________________________________________-->
   <title>CLUSTER 和 VACUUM FULL 阶段</title>
<!-- pgdoc-cn_end sig_en=76b2dd2d997fc217555360266bd1eaad -->
   <tgroup cols="2">
    <colspec colname="col1" colwidth="1*"/>
    <colspec colname="col2" colwidth="2*"/>
    <thead>
<!-- pgdoc-cn_start sig_en=c1529d0542903711f7b115996688901f sig_cn_org=None source=14.1 
    <row>
      <entry>Phase</entry>
      <entry>Description</entry>
     </row>
________________________________________________________-->
    <row>
      <entry>阶段</entry>
      <entry>描述</entry>
     </row>
<!-- pgdoc-cn_end sig_en=c1529d0542903711f7b115996688901f -->
    </thead>

   <tbody>
<!-- pgdoc-cn_start sig_en=3f8b29874e167e19a053069654396321 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>initializing</literal></entry>
     <entry>
       The command is preparing to begin scanning the heap.  This phase is
       expected to be very brief.
     </entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>初始化</literal></entry>
     <entry>
       该命令准备开始扫描堆栈。 这个阶段预计会非常短暂。
     </entry>
    </row>
<!-- pgdoc-cn_end sig_en=3f8b29874e167e19a053069654396321 -->
<!-- pgdoc-cn_start sig_en=9691658b0fb361c8be346db2c6ce1274 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>seq scanning heap</literal></entry>
     <entry>
       The command is currently scanning the table using a sequential scan.
     </entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>seq扫描堆</literal></entry>
     <entry>
       该命令目前采用顺序扫描的方式对表进行扫描。
     </entry>
    </row>
<!-- pgdoc-cn_end sig_en=9691658b0fb361c8be346db2c6ce1274 -->
<!-- pgdoc-cn_start sig_en=dfe0af2eed9165abbb794a9e2d0d38ef sig_cn_org=None source=14.1 
    <row>
     <entry><literal>index scanning heap</literal></entry>
     <entry>
       <command>CLUSTER</command> is currently scanning the table using an index scan.
     </entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>索引扫描堆</literal></entry>
     <entry>
       <command>CLUSTER</command>目前正在使用索引扫描表。
     </entry>
    </row>
<!-- pgdoc-cn_end sig_en=dfe0af2eed9165abbb794a9e2d0d38ef -->
<!-- pgdoc-cn_start sig_en=ef76b9f08f2794de67bbbd151f0ac58f sig_cn_org=None source=14.1 
    <row>
     <entry><literal>sorting tuples</literal></entry>
     <entry>
       <command>CLUSTER</command> is currently sorting tuples.
     </entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>元组排序</literal></entry>
     <entry>
       <command>CLUSTER</command>目前正在对元组进行排序。
     </entry>
    </row>
<!-- pgdoc-cn_end sig_en=ef76b9f08f2794de67bbbd151f0ac58f -->
<!-- pgdoc-cn_start sig_en=f83dec86fe26ef45be50589f6a442215 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>writing new heap</literal></entry>
     <entry>
       <command>CLUSTER</command> is currently writing the new heap.
     </entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>新写入堆</literal></entry>
     <entry>
       <command>CLUSTER</command>目前正在编写新的堆。
     </entry>
    </row>
<!-- pgdoc-cn_end sig_en=f83dec86fe26ef45be50589f6a442215 -->
<!-- pgdoc-cn_start sig_en=0ac09b63919454b92a4e9f1037c129ff sig_cn_org=None source=14.1 
    <row>
     <entry><literal>swapping relation files</literal></entry>
     <entry>
       The command is currently swapping newly-built files into place.
     </entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>交换关系文件</literal></entry>
     <entry>
       目前，该命令正在将新建立的文件调换到位。
     </entry>
    </row>
<!-- pgdoc-cn_end sig_en=0ac09b63919454b92a4e9f1037c129ff -->
<!-- pgdoc-cn_start sig_en=28d6d7ee36b00d9431b582f98721c4d2 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>rebuilding index</literal></entry>
     <entry>
       The command is currently rebuilding an index.
     </entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>重建索引</literal></entry>
     <entry>
       该命令目前正在重建一个索引。
     </entry>
    </row>
<!-- pgdoc-cn_end sig_en=28d6d7ee36b00d9431b582f98721c4d2 -->
<!-- pgdoc-cn_start sig_en=30f75574dab8faf793c8effca7266b0d sig_cn_org=None source=14.1 
    <row>
     <entry><literal>performing final cleanup</literal></entry>
     <entry>
       The command is performing final cleanup.  When this phase is
       completed, <command>CLUSTER</command>
       or <command>VACUUM FULL</command> will end.
     </entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>清理</literal></entry>
     <entry>
       该命令正在执行最后的清理工作。 当此阶段完成后，<command>CLUSTER</command>或<command>VACUUM FULL</command>将结束。
     </entry>
    </row>
<!-- pgdoc-cn_end sig_en=30f75574dab8faf793c8effca7266b0d -->
   </tbody>
   </tgroup>
  </table>
 </sect2>

 <sect2 id="basebackup-progress-reporting">
<!-- pgdoc-cn_start sig_en=a1ec5d114c3cc896218a5b6665e878d2 sig_cn_org=None source=14.1 
  <title>Base Backup Progress Reporting</title>
________________________________________________________-->
  <title>基础备份进度报告</title>
<!-- pgdoc-cn_end sig_en=a1ec5d114c3cc896218a5b6665e878d2 -->

<!-- pgdoc-cn_start sig_en=ffa6b83f168dae5916533fd4c5974c10 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>pg_stat_progress_basebackup</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>pg_stat_progress_basebackup</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=ffa6b83f168dae5916533fd4c5974c10 -->

<!-- pgdoc-cn_start sig_en=704d0a7cf8a037f9655575eeda32f5bd sig_cn_org=None source=14.1 
  <para>
   Whenever an application like <application>pg_basebackup</application>
   is taking a base backup, the
   <structname>pg_stat_progress_basebackup</structname>
   view will contain a row for each WAL sender process that is currently
   running the <command>BASE_BACKUP</command> replication command
   and streaming the backup. The tables below describe the information
   that will be reported and provide information about how to interpret it.
  </para>
________________________________________________________-->
  <para>
   每当像<application>pg_basebackup</application>这样的应用程序进行基本备份时，
   <structname>pg_stat_progress_basebackup</structname>视图将包含当前运行<command>BASE_BACKUP</command>复制命令和流备份的每个WAL发送进程的一行。
   下面的表描述了将要报告的信息，并提供了关于如何解释它的信息。
  </para>
<!-- pgdoc-cn_end sig_en=704d0a7cf8a037f9655575eeda32f5bd -->

  <table id="pg-stat-progress-basebackup-view" xreflabel="pg_stat_progress_basebackup">
<!-- pgdoc-cn_start sig_en=c8160abd7e37242805cf0995f7c35c83 sig_cn_org=None source=14.1 
   <title><structname>pg_stat_progress_basebackup</structname> View</title>
________________________________________________________-->
   <title><structname>pg_stat_progress_basebackup</structname> 视图</title>
<!-- pgdoc-cn_end sig_en=c8160abd7e37242805cf0995f7c35c83 -->
   <tgroup cols="1">
    <thead>
<!-- pgdoc-cn_start sig_en=19eb14a155d7416c3b9cad7829c11a9d sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=19eb14a155d7416c3b9cad7829c11a9d -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=53fafc4ec28537015a745d7c27d55882 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       Process ID of a WAL sender process.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       WAL发送方进程ID。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=53fafc4ec28537015a745d7c27d55882 -->

<!-- pgdoc-cn_start sig_en=fbdcdb8a64e6a9378491449065a111c8 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>phase</structfield> <type>text</type>
      </para>
      <para>
       Current processing phase. See <xref linkend="basebackup-phases"/>.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>phase</structfield> <type>text</type>
      </para>
      <para>
       目前的处理阶段。 参见 <xref linkend="basebackup-phases"/>。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=fbdcdb8a64e6a9378491449065a111c8 -->

<!-- pgdoc-cn_start sig_en=385299be6ac2f52def40595377897876 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>backup_total</structfield> <type>bigint</type>
      </para>
      <para>
       Total amount of data that will be streamed. This is estimated and
       reported as of the beginning of
       <literal>streaming database files</literal> phase. Note that
       this is only an approximation since the database
       may change during <literal>streaming database files</literal> phase
       and WAL log may be included in the backup later. This is always
       the same value as <structfield>backup_streamed</structfield>
       once the amount of data streamed exceeds the estimated
       total size. If the estimation is disabled in
       <application>pg_basebackup</application>
       (i.e., <literal>-&minus;no-estimate-size</literal> option is specified),
       this is <literal>NULL</literal>.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>backup_total</structfield> <type>bigint</type>
      </para>
      <para>
       将被流输送的数据总量。这是在<literal>streaming database files</literal>阶段开始时的估计和报告。
       注意，这只是一个近似值，因为在<literal>streaming database files</literal>阶段，数据库可能会改变，而WAL日志可能会在稍后的备份中包含。
       一旦流数据量超过了估计的总大小，该值始终与<structfield>backup_streamed</structfield>相同。
       如果在<application>pg_basebackup</application>中禁用估算(也就是说，指定了<literal>--no-estimate-size</literal>选项)，这为<literal>NULL</literal>。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=385299be6ac2f52def40595377897876 -->

<!-- pgdoc-cn_start sig_en=97d39ec2162f01191e7fe5f4ae258597 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>backup_streamed</structfield> <type>bigint</type>
      </para>
      <para>
       Amount of data streamed. This counter only advances
       when the phase is <literal>streaming database files</literal> or
       <literal>transferring wal files</literal>.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>backup_streamed</structfield> <type>bigint</type>
      </para>
      <para>
       数据流的总量。这个计数器只在<literal>streaming database files</literal>阶段或<literal>transferring wal files</literal>时增进。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=97d39ec2162f01191e7fe5f4ae258597 -->

<!-- pgdoc-cn_start sig_en=98619449b8844e1363d9529285a39f84 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tablespaces_total</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of tablespaces that will be streamed.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tablespaces_total</structfield> <type>bigint</type>
      </para>
      <para>
       要流输送的表空间总数。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=98619449b8844e1363d9529285a39f84 -->

<!-- pgdoc-cn_start sig_en=401294464f9282eaadcace628b97aabf sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tablespaces_streamed</structfield> <type>bigint</type>
      </para>
      <para>
       Number of tablespaces streamed. This counter only
       advances when the phase is <literal>streaming database files</literal>.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tablespaces_streamed</structfield> <type>bigint</type>
      </para>
      <para>
       流输送的表空间数。此计数器仅在<literal>streaming database files</literal>阶段增进。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=401294464f9282eaadcace628b97aabf -->
    </tbody>
   </tgroup>
  </table>

  <table id="basebackup-phases">
<!-- pgdoc-cn_start sig_en=f62196af7d1192fb5766723a2f6553f2 sig_cn_org=e20c5d83821eb27da0114b506b6a3bce source=15.7 
   <title>Base Backup Phases</title>
________________________________________________________-->
   <title>基本备份阶段</title>
<!-- pgdoc-cn_end sig_en=f62196af7d1192fb5766723a2f6553f2 -->
   <tgroup cols="2">
    <colspec colname="col1" colwidth="1*"/>
    <colspec colname="col2" colwidth="2*"/>
    <thead>
<!-- pgdoc-cn_start sig_en=c1529d0542903711f7b115996688901f sig_cn_org=None source=14.1 
     <row>
      <entry>Phase</entry>
      <entry>Description</entry>
     </row>
________________________________________________________-->
     <row>
      <entry>阶段</entry>
      <entry>描述</entry>
     </row>
<!-- pgdoc-cn_end sig_en=c1529d0542903711f7b115996688901f -->
    </thead>
    <tbody>
<!-- pgdoc-cn_start sig_en=a55409e489d2a2c6437777b7a3c7f1d0 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>initializing</literal></entry>
      <entry>
       The WAL sender process is preparing to begin the backup.
       This phase is expected to be very brief.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>initializing</literal></entry>
      <entry>
       WAL发送器进程正在准备开始备份。这个阶段预计会非常短暂。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=a55409e489d2a2c6437777b7a3c7f1d0 -->
<!-- pgdoc-cn_start sig_en=7303dd93b6cb2df7d5a585a5842069fc sig_cn_org=fa7f50d6c20966f13e6088b4adf80f12 source=15.7 
     <row>
      <entry><literal>waiting for checkpoint to finish</literal></entry>
      <entry>
       The WAL sender process is currently performing
       <function>pg_backup_start</function> to prepare to
       take a base backup, and waiting for the start-of-backup
       checkpoint to finish.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>等待检查点完成</literal></entry>
      <entry>
       WAL发送进程当前正在执行<function>pg_backup_start</function>以准备进行基本备份，并等待开始备份的检查点完成。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=7303dd93b6cb2df7d5a585a5842069fc -->
<!-- pgdoc-cn_start sig_en=b5ad96efd38cd1b61eec4c68cdcf0697 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>estimating backup size</literal></entry>
      <entry>
       The WAL sender process is currently estimating the total amount
       of database files that will be streamed as a base backup.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>estimating backup size</literal></entry>
      <entry>
       WAL发送程序目前正在估计将作为基础备份流传输的数据库文件的总量。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=b5ad96efd38cd1b61eec4c68cdcf0697 -->
<!-- pgdoc-cn_start sig_en=6a79a3701ae047fd3e6484ad2d0bb399 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>streaming database files</literal></entry>
      <entry>
       The WAL sender process is currently streaming database files
       as a base backup.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>streaming database files</literal></entry>
      <entry>
       WAL发送器当前正在流数据库文件作为基础备份。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=6a79a3701ae047fd3e6484ad2d0bb399 -->
<!-- pgdoc-cn_start sig_en=da59279be74521f3d1f124f771dfc18b sig_cn_org=f0f2faa57c0d4216666870c20423495d source=15.7 
     <row>
      <entry><literal>waiting for wal archiving to finish</literal></entry>
      <entry>
       The WAL sender process is currently performing
       <function>pg_backup_stop</function> to finish the backup,
       and waiting for all the WAL files required for the base backup
       to be successfully archived.
       If either <literal>-&minus;wal-method=none</literal> or
       <literal>-&minus;wal-method=stream</literal> is specified in
       <application>pg_basebackup</application>, the backup will end
       when this phase is completed.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>等待wal归档完成</literal></entry>
      <entry>
       WAL发送进程当前正在执行<function>pg_backup_stop</function>以完成备份，
       并等待所有用于基本备份的WAL文件成功归档。
       如果在<application>pg_basebackup</application>中指定了<literal>--wal-method=none</literal>或
       <literal>--wal-method=stream</literal>，备份将在此阶段完成时结束。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=da59279be74521f3d1f124f771dfc18b -->
<!-- pgdoc-cn_start sig_en=ef20004d83dd45f40920001613ab46fc sig_cn_org=None source=14.1 
     <row>
      <entry><literal>transferring wal files</literal></entry>
      <entry>
       The WAL sender process is currently transferring all WAL logs
       generated during the backup. This phase occurs after
       <literal>waiting for wal archiving to finish</literal> phase if
       <literal>-&minus;wal-method=fetch</literal> is specified in
       <application>pg_basebackup</application>. The backup will end
       when this phase is completed.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>transferring wal files</literal></entry>
      <entry>
       WAL发送器进程正在传输备份过程中产生的所有WAL日志。
       如果<application>pg_basebackup</application>中指定了<literal>--wal-method=fetch</literal>，
       则该阶段发生在<literal>waiting for wal archiving to finish</literal>阶段之后。当此阶段完成时备份将结束。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=ef20004d83dd45f40920001613ab46fc -->
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="copy-progress-reporting">
<!-- pgdoc-cn_start sig_en=f783d256cc34969c5f855557b514805c sig_cn_org=None source=14.1 
  <title>COPY Progress Reporting</title>
________________________________________________________-->
  <title>COPY Progress Reporting</title>
<!-- pgdoc-cn_end sig_en=f783d256cc34969c5f855557b514805c -->

<!-- pgdoc-cn_start sig_en=9fae14e6de831a5c76c2760a6f3fb881 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>pg_stat_progress_copy</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>pg_stat_progress_copy</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=9fae14e6de831a5c76c2760a6f3fb881 -->

<!-- pgdoc-cn_start sig_en=8bddbfcb16fd178e7840dd3f27850bcc sig_cn_org=None source=14.1 
  <para>
   Whenever <command>COPY</command> is running, the
   <structname>pg_stat_progress_copy</structname> view will contain one row
   for each backend that is currently running a <command>COPY</command> command.
   The table below describes the information that will be reported and provides
   information about how to interpret it.
  </para>
________________________________________________________-->
  <para>
   当<command>COPY</command>正在运行时，<structname>pg_stat_progress_copy</structname>视图将包含一行,为了当前正在运行<command>COPY</command>命令的每个后端。
   下表描述了将被报告的信息，并提供了如何解释它的信息。
  </para>
<!-- pgdoc-cn_end sig_en=8bddbfcb16fd178e7840dd3f27850bcc -->

  <table id="pg-stat-progress-copy-view" xreflabel="pg_stat_progress_copy">
<!-- pgdoc-cn_start sig_en=234e84d51bc7731d94f7a681b402fa78 sig_cn_org=None source=14.1 
   <title><structname>pg_stat_progress_copy</structname> View</title>
________________________________________________________-->
   <title><structname>pg_stat_progress_copy</structname> View</title>
<!-- pgdoc-cn_end sig_en=234e84d51bc7731d94f7a681b402fa78 -->
   <tgroup cols="1">
    <thead>
<!-- pgdoc-cn_start sig_en=19eb14a155d7416c3b9cad7829c11a9d sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=19eb14a155d7416c3b9cad7829c11a9d -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=a916babfb86c58511598ec13c8d23dc6 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       Process ID of backend.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       后端的进程ID。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=a916babfb86c58511598ec13c8d23dc6 -->

<!-- pgdoc-cn_start sig_en=9f5f0957095e7893d5dd902081f00096 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the database to which this backend is connected.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datid</structfield> <type>oid</type>
      </para>
      <para>
       后端连接到的数据库的OID。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=9f5f0957095e7893d5dd902081f00096 -->

<!-- pgdoc-cn_start sig_en=2e7f4e88844e0fdb7cce4de93426a70a sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datname</structfield> <type>name</type>
      </para>
      <para>
       Name of the database to which this backend is connected.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datname</structfield> <type>name</type>
      </para>
      <para>
       后端连接到的数据库的名称。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=2e7f4e88844e0fdb7cce4de93426a70a -->

<!-- pgdoc-cn_start sig_en=576142442daeb83ef661c4526b4193b3 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the table on which the <command>COPY</command> command is
       executed. It is set to <literal>0</literal> if copying from a
       <command>SELECT</command> query.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       执行<command>COPY</command>命令的表的OID。
       如果从<command>SELECT</command>查询中复制，它被设置为<literal>0</literal>。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=576142442daeb83ef661c4526b4193b3 -->

<!-- pgdoc-cn_start sig_en=a4d377a05f40a80efcddb66d0c0cbb3b sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>command</structfield> <type>text</type>
      </para>
      <para>
       The command that is running: <literal>COPY FROM</literal>, or
       <literal>COPY TO</literal>.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>command</structfield> <type>text</type>
      </para>
      <para>
       正在运行的命令: <literal>COPY FROM</literal>, 或 <literal>COPY TO</literal>。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=a4d377a05f40a80efcddb66d0c0cbb3b -->

<!-- pgdoc-cn_start sig_en=dcb80ffa25df297ca8c8ddfe6af5196e sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>type</structfield> <type>text</type>
      </para>
      <para>
       The io type that the data is read from or written to:
       <literal>FILE</literal>, <literal>PROGRAM</literal>,
       <literal>PIPE</literal> (for <command>COPY FROM STDIN</command> and
       <command>COPY TO STDOUT</command>), or <literal>CALLBACK</literal>
       (used for example during the initial table synchronization in
       logical replication).
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>type</structfield> <type>text</type>
      </para>
      <para>
       数据被读取或写入的io类型:<literal>FILE</literal>, <literal>PROGRAM</literal>, <literal>PIPE</literal> (对于<command>COPY FROM STDIN</command> 和 <command>COPY TO STDOUT</command>)，或 <literal>CALLBACK</literal>(例如在逻辑复制中初始表同步期间使用)。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=dcb80ffa25df297ca8c8ddfe6af5196e -->

<!-- pgdoc-cn_start sig_en=9492870e866a65b4060387e0d0381a39 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>bytes_processed</structfield> <type>bigint</type>
      </para>
      <para>
       Number of bytes already processed by <command>COPY</command> command.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>bytes_processed</structfield> <type>bigint</type>
      </para>
      <para>
       已经被<command>COPY</command>命令处理的字节数。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=9492870e866a65b4060387e0d0381a39 -->

<!-- pgdoc-cn_start sig_en=4bf1a319106da846e2ae45415c3861f6 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>bytes_total</structfield> <type>bigint</type>
      </para>
      <para>
       Size of source file for <command>COPY FROM</command> command in bytes.
       It is set to <literal>0</literal> if not available.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>bytes_total</structfield> <type>bigint</type>
      </para>
      <para>
       <command>COPY FROM</command>命令的源文件大小，以字节计。
       如果不可用则设置为<literal>0</literal>。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=4bf1a319106da846e2ae45415c3861f6 -->

<!-- pgdoc-cn_start sig_en=389be8335adf44c9765f30cb97aa7d58 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tuples_processed</structfield> <type>bigint</type>
      </para>
      <para>
       Number of tuples already processed by <command>COPY</command> command.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tuples_processed</structfield> <type>bigint</type>
      </para>
      <para>
       已经被<command>COPY</command>命令处理的元组数。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=389be8335adf44c9765f30cb97aa7d58 -->

<!-- pgdoc-cn_start sig_en=74e640bcc51f1891555256e4d89b7af1 sig_cn_org=None source=14.1 
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tuples_excluded</structfield> <type>bigint</type>
      </para>
      <para>
       Number of tuples not processed because they were excluded by the
       <command>WHERE</command> clause of the <command>COPY</command> command.
      </para></entry>
     </row>
________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tuples_excluded</structfield> <type>bigint</type>
      </para>
      <para>
       没有处理的元组数，因为它们被<command>COPY</command>命令的<command>WHERE</command>子句所排除。
      </para></entry>
     </row>
<!-- pgdoc-cn_end sig_en=74e640bcc51f1891555256e4d89b7af1 -->
    </tbody>
   </tgroup>
  </table>
 </sect2>

 </sect1>

 <sect1 id="dynamic-trace">
<!-- pgdoc-cn_start sig_en=bff68e0d752ff1a9e265fb9752ea8998 sig_cn_org=None source=14.1 
  <title>Dynamic Tracing</title>
________________________________________________________-->
  <title>动态追踪</title>
<!-- pgdoc-cn_end sig_en=bff68e0d752ff1a9e265fb9752ea8998 -->

<!-- pgdoc-cn_start sig_en=ace4ecd9130afe76cfc80f228127c0e2 sig_cn_org=None source=14.1 
 <indexterm zone="dynamic-trace">
  <primary>DTrace</primary>
 </indexterm>
________________________________________________________-->
 <indexterm zone="dynamic-trace">
  <primary>DTrace</primary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=ace4ecd9130afe76cfc80f228127c0e2 -->

<!-- pgdoc-cn_start sig_en=53ec892ec517bb4391a68f3ab7c22147 sig_cn_org=None source=14.1 
  <para>
   <productname>PostgreSQL</productname> provides facilities to support
   dynamic tracing of the database server. This allows an external
   utility to be called at specific points in the code and thereby trace
   execution.
  </para>
________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>提供了功能来支持数据库服务器的动态追踪。这样就允许在代码中的特 定点上调用外部工具来追踪执行过程。
  </para>
<!-- pgdoc-cn_end sig_en=53ec892ec517bb4391a68f3ab7c22147 -->

<!-- pgdoc-cn_start sig_en=6cdd96c1607d771e34c7eba05a5e8146 sig_cn_org=None source=14.1 
  <para>
   A number of probes or trace points are already inserted into the source
   code. These probes are intended to be used by database developers and
   administrators. By default the probes are not compiled into
   <productname>PostgreSQL</productname>; the user needs to explicitly tell
   the configure script to make the probes available.
  </para>
________________________________________________________-->
  <para>
   一些探针或追踪点已经被插入在源代码中。这些探针的目的是被数据库开发者和管理员使用。默认情况下，探针不被编译到<productname>PostgreSQL</productname>中；用户需要显式地告诉配置脚本使得探针可用。
  </para>
<!-- pgdoc-cn_end sig_en=6cdd96c1607d771e34c7eba05a5e8146 -->

<!-- pgdoc-cn_start sig_en=c7c94ef76046a537877136ffbe3c4dfa sig_cn_org=None source=14.1 
  <para>
   Currently, the
   <ulink url="https://en.wikipedia.org/wiki/DTrace">DTrace</ulink>
   utility is supported, which, at the time of this writing, is available
   on Solaris, macOS, FreeBSD, NetBSD, and Oracle Linux.  The
   <ulink url="https://sourceware.org/systemtap/">SystemTap</ulink> project
   for Linux provides a DTrace equivalent and can also be used.  Supporting other dynamic
   tracing utilities is theoretically possible by changing the definitions for
   the macros in <filename>src/include/utils/probes.h</filename>.
  </para>
________________________________________________________-->
  <para>
   目前，在写本文当时<ulink url="https://en.wikipedia.org/wiki/DTrace">DTrace</ulink>已被支持，它在 Solaris、macOS、FreeBSD、NetBSD 和 Oracle Linux 上可用。
   Linux 的<ulink url="https://sourceware.org/systemtap/">SystemTap</ulink>项目提供了一种可用的 DTrace 等价物。支持其他动态追踪工具在理论上可以通过改变<filename>src/include/utils/probes.h</filename>中的宏定义实现。
  </para>
<!-- pgdoc-cn_end sig_en=c7c94ef76046a537877136ffbe3c4dfa -->

  <sect2 id="compiling-for-trace">
<!-- pgdoc-cn_start sig_en=c2358dbe9ae4c93e4fa7f50687d4b7ce sig_cn_org=None source=14.1 
   <title>Compiling for Dynamic Tracing</title>
________________________________________________________-->
   <title>动态追踪的编译</title>
<!-- pgdoc-cn_end sig_en=c2358dbe9ae4c93e4fa7f50687d4b7ce -->

<!-- pgdoc-cn_start sig_en=0f5ce5cb46aca06f88be26b41cb5b2ae sig_cn_org=None source=14.1 
  <para>
   By default, probes are not available, so you will need to
   explicitly tell the configure script to make the probes available
   in <productname>PostgreSQL</productname>. To include DTrace support
   specify <option>-&minus;enable-dtrace</option> to configure.  See <xref
   linkend="install-procedure"/> for further information.
  </para>
________________________________________________________-->
  <para>
   默认情况下，探针是不可用的，因此你将需要显式地告诉配置脚本让探针在<productname>PostgreSQL</productname>中可用。要包括 DTrace 支持，在配置时指定<option>--enable-dtrace</option>。更多信息请见<xref linkend="install-procedure"/>。
  </para>
<!-- pgdoc-cn_end sig_en=0f5ce5cb46aca06f88be26b41cb5b2ae -->
  </sect2>

  <sect2 id="trace-points">
<!-- pgdoc-cn_start sig_en=3766eb3187fcacb49e0acddf025f1855 sig_cn_org=None source=14.1 
   <title>Built-in Probes</title>
________________________________________________________-->
   <title>内建探针</title>
<!-- pgdoc-cn_end sig_en=3766eb3187fcacb49e0acddf025f1855 -->

<!-- pgdoc-cn_start sig_en=accce996b37ab5674e6eaff8d076373f sig_cn_org=None source=14.1 
  <para>
   A number of standard probes are provided in the source code,
   as shown in <xref linkend="dtrace-probe-point-table"/>;
   <xref linkend="typedefs-table"/>
   shows the types used in the probes.  More probes can certainly be
   added to enhance <productname>PostgreSQL</productname>'s observability.
  </para>
________________________________________________________-->
  <para>
   如<xref linkend="dtrace-probe-point-table"/>所示，源代码中提供了一些标准探针。<xref linkend="typedefs-table"/>显式了在探针中使用的类型。当然，可以增加更多探针来增强<productname>PostgreSQL</productname>的可观测性。
  </para>
<!-- pgdoc-cn_end sig_en=accce996b37ab5674e6eaff8d076373f -->

 <table id="dtrace-probe-point-table">
<!-- pgdoc-cn_start sig_en=2cf2b6685e6a2c1429e1967dfa3e6d3c sig_cn_org=None source=14.1 
  <title>Built-in DTrace Probes</title>
________________________________________________________-->
  <title>内建 DTrace 探针</title>
<!-- pgdoc-cn_end sig_en=2cf2b6685e6a2c1429e1967dfa3e6d3c -->
  <tgroup cols="3">
   <colspec colname="col1" colwidth="2*"/>
   <colspec colname="col2" colwidth="3*"/>
   <colspec colname="col3" colwidth="3*"/>
   <thead>
<!-- pgdoc-cn_start sig_en=eed018604389f5581664f52d74c74d06 sig_cn_org=None source=14.1 
    <row>
     <entry>Name</entry>
     <entry>Parameters</entry>
     <entry>Description</entry>
    </row>
________________________________________________________-->
    <row>
     <entry>名称</entry>
     <entry>参数</entry>
     <entry>描述</entry>
    </row>
<!-- pgdoc-cn_end sig_en=eed018604389f5581664f52d74c74d06 -->
   </thead>

   <tbody>

<!-- pgdoc-cn_start sig_en=daddd47a5279948414d5b2be9a7677e7 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>transaction-start</literal></entry>
     <entry><literal>(LocalTransactionId)</literal></entry>
     <entry>Probe that fires at the start of a new transaction.
      arg0 is the transaction ID.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>transaction-start</literal></entry>
     <entry><literal>(LocalTransactionId)</literal></entry>
     <entry>在一个新事务开始时触发的探针。arg0 是事务 ID。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=daddd47a5279948414d5b2be9a7677e7 -->
<!-- pgdoc-cn_start sig_en=b341202597299c974b69087744d3030b sig_cn_org=None source=14.1 
    <row>
     <entry><literal>transaction-commit</literal></entry>
     <entry><literal>(LocalTransactionId)</literal></entry>
     <entry>Probe that fires when a transaction completes successfully.
      arg0 is the transaction ID.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>transaction-commit</literal></entry>
     <entry><literal>(LocalTransactionId)</literal></entry>
     <entry>在一个事务成功完成时触发的探针。arg0 是事务 ID。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=b341202597299c974b69087744d3030b -->
<!-- pgdoc-cn_start sig_en=bea6e23faaba4b1798a2c5d4eba5d1b9 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>transaction-abort</literal></entry>
     <entry><literal>(LocalTransactionId)</literal></entry>
     <entry>Probe that fires when a transaction completes unsuccessfully.
      arg0 is the transaction ID.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>transaction-abort</literal></entry>
     <entry><literal>(LocalTransactionId)</literal></entry>
     <entry>当一个事务失败完成时触发的探针。arg0 是事务 ID。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=bea6e23faaba4b1798a2c5d4eba5d1b9 -->
<!-- pgdoc-cn_start sig_en=0c8833ba23b93e7f2b36df725bbb18ad sig_cn_org=None source=14.1 
    <row>
     <entry><literal>query-start</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>Probe that fires when the processing of a query is started.
      arg0 is the query string.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>query-start</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>当一个查询的处理被开始时触发的探针。arg0 是查询字符串。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=0c8833ba23b93e7f2b36df725bbb18ad -->
<!-- pgdoc-cn_start sig_en=f9fc5bcd6718cdd99b8b2b643d67d035 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>query-done</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>Probe that fires when the processing of a query is complete.
      arg0 is the query string.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>query-done</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>当一个查询的处理完成时触发的探针。arg0 是查询字符串。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=f9fc5bcd6718cdd99b8b2b643d67d035 -->
<!-- pgdoc-cn_start sig_en=7323ca435ac4ae4572cba6478b1e5acf sig_cn_org=None source=14.1 
    <row>
     <entry><literal>query-parse-start</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>Probe that fires when the parsing of a query is started.
      arg0 is the query string.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>query-parse-start</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>当一个查询的解析被开始时触发的探针。arg0 是查询字符串。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=7323ca435ac4ae4572cba6478b1e5acf -->
<!-- pgdoc-cn_start sig_en=01c7d0f1b492a387ed9df64784bd2c9f sig_cn_org=None source=14.1 
    <row>
     <entry><literal>query-parse-done</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>Probe that fires when the parsing of a query is complete.
      arg0 is the query string.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>query-parse-done</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>当一个查询的解析完成时触发的探针。arg0 是查询字符串。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=01c7d0f1b492a387ed9df64784bd2c9f -->
<!-- pgdoc-cn_start sig_en=dbd7ef18a34b5dfba7afa344c9a81129 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>query-rewrite-start</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>Probe that fires when the rewriting of a query is started.
      arg0 is the query string.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>query-rewrite-start</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>当一个查询的重写被开始时触发的探针。arg0 是查询字符串。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=dbd7ef18a34b5dfba7afa344c9a81129 -->
<!-- pgdoc-cn_start sig_en=6131d2babeb78f4fd3997d51adbbf870 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>query-rewrite-done</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>Probe that fires when the rewriting of a query is complete.
      arg0 is the query string.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>query-rewrite-done</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>当一个查询的重写完成时触发的探针。arg0 是查询字符串。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=6131d2babeb78f4fd3997d51adbbf870 -->
<!-- pgdoc-cn_start sig_en=c70b32a8f8edd4344399be69b3370113 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>query-plan-start</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when the planning of a query is started.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>query-plan-start</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>当一个查询的规划被开始时触发的探针。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=c70b32a8f8edd4344399be69b3370113 -->
<!-- pgdoc-cn_start sig_en=eae3078a74d46780a700bafefaa80c29 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>query-plan-done</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when the planning of a query is complete.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>query-plan-done</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>当一个查询的规划完成时触发的探针。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=eae3078a74d46780a700bafefaa80c29 -->
<!-- pgdoc-cn_start sig_en=8eeec1eca8e150fccbc61d7fb21de70d sig_cn_org=None source=14.1 
    <row>
     <entry><literal>query-execute-start</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when the execution of a query is started.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>query-execute-start</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>当一个查询的执行被开始时触发的探针。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=8eeec1eca8e150fccbc61d7fb21de70d -->
<!-- pgdoc-cn_start sig_en=c84ce82ecb879003460b81581fe9fe1c sig_cn_org=None source=14.1 
    <row>
     <entry><literal>query-execute-done</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when the execution of a query is complete.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>query-execute-done</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>当一个查询的执行完成时触发的探针。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=c84ce82ecb879003460b81581fe9fe1c -->
<!-- pgdoc-cn_start sig_en=b766a59555a3b06d2b39b7658d40bf06 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>statement-status</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>Probe that fires anytime the server process updates its
      <structname>pg_stat_activity</structname>.<structfield>status</structfield>.
      arg0 is the new status string.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>statement-status</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>任何时候当服务器进程更新它的<structname>pg_stat_activity</structname>.<structfield>status</structfield>时触发的探针。arg0 是新的状态字符串。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=b766a59555a3b06d2b39b7658d40bf06 -->
<!-- pgdoc-cn_start sig_en=e32d94ad39bd79fca09a299b2ce9a29d sig_cn_org=None source=14.1 
    <row>
     <entry><literal>checkpoint-start</literal></entry>
     <entry><literal>(int)</literal></entry>
     <entry>Probe that fires when a checkpoint is started.
      arg0 holds the bitwise flags used to distinguish different checkpoint
      types, such as shutdown, immediate or force.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>checkpoint-start</literal></entry>
     <entry><literal>(int)</literal></entry>
     <entry>当一个检查点被开始时触发的探针。arg0 传递位标志来区分不同的检查点类型，例如关闭（shutdown）、立即（immediate）或强制（force）。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=e32d94ad39bd79fca09a299b2ce9a29d -->
<!-- pgdoc-cn_start sig_en=91fe8b73abc6715db3a47f10cfa2c521 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>checkpoint-done</literal></entry>
     <entry><literal>(int, int, int, int, int)</literal></entry>
     <entry>Probe that fires when a checkpoint is complete.
      (The probes listed next fire in sequence during checkpoint processing.)
      arg0 is the number of buffers written. arg1 is the total number of
      buffers. arg2, arg3 and arg4 contain the number of WAL files added,
      removed and recycled respectively.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>checkpoint-done</literal></entry>
     <entry><literal>(int, int, int, int, int)</literal></entry>
     <entry>当一个检查点完成时触发的探针（检查点处理过程中序列中列出的下一个触发的探针）。arg0 是要写的缓冲区数量。arg1 是缓冲区的总数。arg2、arg3 和 arg4 分别包含了增加、删除和循环回收的 WAL 文件的数量。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=91fe8b73abc6715db3a47f10cfa2c521 -->
<!-- pgdoc-cn_start sig_en=a37645ed6b1676f1aa8f4690ae7e8e0f sig_cn_org=None source=14.1 
    <row>
     <entry><literal>clog-checkpoint-start</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>Probe that fires when the CLOG portion of a checkpoint is started.
      arg0 is true for normal checkpoint, false for shutdown
      checkpoint.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>clog-checkpoint-start</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>当一个检查点的 CLOG 部分被开始时触发的探针。arg0 为真表示正常检查点，为假表示关闭检查点。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=a37645ed6b1676f1aa8f4690ae7e8e0f -->
<!-- pgdoc-cn_start sig_en=5528b44b830f25d824ca33611b3a73a6 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>clog-checkpoint-done</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>Probe that fires when the CLOG portion of a checkpoint is
      complete. arg0 has the same meaning as for <literal>clog-checkpoint-start</literal>.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>clog-checkpoint-done</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>当一个检查点的 CLOG 部分完成时触发的探针。arg0 的含义与<literal>clog-checkpoint-start</literal>中相同。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=5528b44b830f25d824ca33611b3a73a6 -->
<!-- pgdoc-cn_start sig_en=6f1a1bad7b4ea84beeb88d77abec8564 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>subtrans-checkpoint-start</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>Probe that fires when the SUBTRANS portion of a checkpoint is
      started.
      arg0 is true for normal checkpoint, false for shutdown
      checkpoint.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>subtrans-checkpoint-start</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>当一个检查点的 SUBTRANS 部分被开始时触发的探针。arg0 为真表示正常检查点，为假表示关闭检查点。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=6f1a1bad7b4ea84beeb88d77abec8564 -->
<!-- pgdoc-cn_start sig_en=998bc12fff09ae9a4ddada9cb67e3183 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>subtrans-checkpoint-done</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>Probe that fires when the SUBTRANS portion of a checkpoint is
      complete. arg0 has the same meaning as for
      <literal>subtrans-checkpoint-start</literal>.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>subtrans-checkpoint-done</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>当一个检查点的 SUBTRANS 部分完成时触发的探针。arg0 的含义与<literal>subtrans-checkpoint-start</literal>中相同。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=998bc12fff09ae9a4ddada9cb67e3183 -->
<!-- pgdoc-cn_start sig_en=9660e4c83c28ef0de4d01774e0ac5897 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>multixact-checkpoint-start</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>Probe that fires when the MultiXact portion of a checkpoint is
      started.
      arg0 is true for normal checkpoint, false for shutdown
      checkpoint.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>multixact-checkpoint-start</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>当一个检查点的 MultiXact 部分被开始时触发的探针。arg0 为真表示正常检查点，为假表示关闭检查点。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=9660e4c83c28ef0de4d01774e0ac5897 -->
<!-- pgdoc-cn_start sig_en=fa1179b96dad2240c1ace3b3128ccc23 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>multixact-checkpoint-done</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>Probe that fires when the MultiXact portion of a checkpoint is
      complete. arg0 has the same meaning as for
      <literal>multixact-checkpoint-start</literal>.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>multixact-checkpoint-done</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>当一个检查点的 MultiXact 部分完成时触发的探针。arg0 的含义与<literal>multixact-checkpoint-start</literal>中相同。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=fa1179b96dad2240c1ace3b3128ccc23 -->
<!-- pgdoc-cn_start sig_en=c2a0306852fdd707fe1e1d6fe341df54 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>buffer-checkpoint-start</literal></entry>
     <entry><literal>(int)</literal></entry>
     <entry>Probe that fires when the buffer-writing portion of a checkpoint
      is started.
      arg0 holds the bitwise flags used to distinguish different checkpoint
      types, such as shutdown, immediate or force.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>buffer-checkpoint-start</literal></entry>
     <entry><literal>(int)</literal></entry>
     <entry>当一个检查点的写缓冲区部分被开始时触发的探针。arg0 传递位标志来区分不同的检查点类型，例如关闭（shutdown）、立即（immediate）或强制（force）。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=c2a0306852fdd707fe1e1d6fe341df54 -->
<!-- pgdoc-cn_start sig_en=98b591ed6a041af5cda9f0319e64855a sig_cn_org=None source=14.1 
    <row>
     <entry><literal>buffer-sync-start</literal></entry>
     <entry><literal>(int, int)</literal></entry>
     <entry>Probe that fires when we begin to write dirty buffers during
      checkpoint (after identifying which buffers must be written).
      arg0 is the total number of buffers.
      arg1 is the number that are currently dirty and need to be written.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>buffer-sync-start</literal></entry>
     <entry><literal>(int, int)</literal></entry>
     <entry>当我们在检查点期间开始写脏缓冲区时（在标识哪些缓冲区必须被写之后）触发的探针。arg0 是缓冲区总数，arg1 是当前为脏并且需要被写的缓冲区数量。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=98b591ed6a041af5cda9f0319e64855a -->
<!-- pgdoc-cn_start sig_en=a8eb4d3e636914f82e4a0b1d80e994b8 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>buffer-sync-written</literal></entry>
     <entry><literal>(int)</literal></entry>
     <entry>Probe that fires after each buffer is written during checkpoint.
      arg0 is the ID number of the buffer.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>buffer-sync-written</literal></entry>
     <entry><literal>(int)</literal></entry>
     <entry>在检查点期间当每个缓冲区被写完之后触发的探针。arg0 是缓冲区的 ID。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=a8eb4d3e636914f82e4a0b1d80e994b8 -->
<!-- pgdoc-cn_start sig_en=9da81fbf8fa353d9bb2b51cb9c35092d sig_cn_org=None source=14.1 
    <row>
     <entry><literal>buffer-sync-done</literal></entry>
     <entry><literal>(int, int, int)</literal></entry>
     <entry>Probe that fires when all dirty buffers have been written.
      arg0 is the total number of buffers.
      arg1 is the number of buffers actually written by the checkpoint process.
      arg2 is the number that were expected to be written (arg1 of
      <literal>buffer-sync-start</literal>); any difference reflects other processes flushing
      buffers during the checkpoint.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>buffer-sync-done</literal></entry>
     <entry><literal>(int, int, int)</literal></entry>
     <entry>当所有脏缓冲区被写之后触发的探针。arg0 是缓冲区总数。arg1 是检查点进程实际写的缓冲区数量。arg2 是期望写的数目（<literal>buffer-sync-start</literal>的 arg1）；arg1 和 arg2 的任何的不同反映在该检查点期间有其他进程刷写了缓冲区。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=9da81fbf8fa353d9bb2b51cb9c35092d -->
<!-- pgdoc-cn_start sig_en=82ec8b95bdcebfcf53880b5cc9d3951a sig_cn_org=None source=14.1 
    <row>
     <entry><literal>buffer-checkpoint-sync-start</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires after dirty buffers have been written to the
      kernel, and before starting to issue fsync requests.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>buffer-checkpoint-sync-start</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>在脏缓冲区被写入到内核之后并且在开始发出 fsync 请求之前触发的探针。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=82ec8b95bdcebfcf53880b5cc9d3951a -->
<!-- pgdoc-cn_start sig_en=2e16164c96339dce79e80a1b0377014e sig_cn_org=None source=14.1 
    <row>
     <entry><literal>buffer-checkpoint-done</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when syncing of buffers to disk is
      complete.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>buffer-checkpoint-done</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>当同步缓冲区到磁盘完成时触发的探针。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=2e16164c96339dce79e80a1b0377014e -->
<!-- pgdoc-cn_start sig_en=5d22670c6592165cde2499a64ccee7ef sig_cn_org=None source=14.1 
    <row>
     <entry><literal>twophase-checkpoint-start</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when the two-phase portion of a checkpoint is
      started.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>twophase-checkpoint-start</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>当一个检查点的两阶段部分被开始时触发的探针。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=5d22670c6592165cde2499a64ccee7ef -->
<!-- pgdoc-cn_start sig_en=5ee33a07c16d4eb50be3deebf3986ca1 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>twophase-checkpoint-done</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when the two-phase portion of a checkpoint is
      complete.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>twophase-checkpoint-done</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>当一个检查点的两阶段部分完成时触发的探针。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=5ee33a07c16d4eb50be3deebf3986ca1 -->
<!-- pgdoc-cn_start sig_en=214b9c6ea35bd9b1d49f09f369e6dfd8 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>buffer-read-start</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool)</literal></entry>
     <entry>Probe that fires when a buffer read is started.
      arg0 and arg1 contain the fork and block numbers of the page (but
      arg1 will be -1 if this is a relation extension request).
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or <symbol>InvalidBackendId</symbol> (-1) for a shared buffer.
      arg6 is true for a relation extension request, false for normal
      read.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>buffer-read-start</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool)</literal></entry>
     <entry>当一次缓冲区读被开始时触发的探针。arg0 和 arg1 包含该页的分叉号和块号（如果这是一次关系扩展请求，arg1 为 -1）。arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。对一个本地缓冲区，arg5 是创建临时关系的后端的 ID；对于一个共享缓冲区，arg5 是 <symbol>InvalidBackendId</symbol>（-1）。arg6 为真表示一次关系扩展请求，为假表示正常读。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=214b9c6ea35bd9b1d49f09f369e6dfd8 -->
<!-- pgdoc-cn_start sig_en=37f6502cfcc9b20ce70eb4fe725967a1 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>buffer-read-done</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool, bool)</literal></entry>
     <entry>Probe that fires when a buffer read is complete.
      arg0 and arg1 contain the fork and block numbers of the page (if this
      is a relation extension request, arg1 now contains the block number
      of the newly added block).
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or <symbol>InvalidBackendId</symbol> (-1) for a shared buffer.
      arg6 is true for a relation extension request, false for normal
      read.
      arg7 is true if the buffer was found in the pool, false if not.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>buffer-read-done</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool, bool)</literal></entry>
     <entry>当一次缓冲区读完成时触发的探针。arg0 和 arg1 包含该页的分叉号和块号（如果这是一次关系扩展请求，arg1 现在包含新增加块的块号）。arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。对一个本地缓冲区，arg5 是创建临时关系的后端的 ID；对于一个共享缓冲区，arg5 是 <symbol>InvalidBackendId</symbol>（-1）。arg6 为真表示一次关系扩展请求，为假表示正常读。arg7 为真表示在池中找到该缓冲区，为假表示没有找到。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=37f6502cfcc9b20ce70eb4fe725967a1 -->
<!-- pgdoc-cn_start sig_en=2ec306283010f42058ac469e4cc21ae9 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>buffer-flush-start</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
     <entry>Probe that fires before issuing any write request for a shared
      buffer.
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>buffer-flush-start</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
     <entry>在发出对一个共享缓冲区的任意写请求之前触发的探针。arg0 和 arg1 包含该页的分叉号和块号。arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=2ec306283010f42058ac469e4cc21ae9 -->
<!-- pgdoc-cn_start sig_en=70edadc152bcfd8ef344a012f6917be1 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>buffer-flush-done</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
     <entry>Probe that fires when a write request is complete.  (Note
      that this just reflects the time to pass the data to the kernel;
      it's typically not actually been written to disk yet.)
      The arguments are the same as for <literal>buffer-flush-start</literal>.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>buffer-flush-done</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
     <entry>当一个写请求完成时触发的探针（注意这只反映传递数据给内核的时间，它通常并没有实际地被写入到磁盘）。参数和<literal>buffer-flush-start</literal>的相同。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=70edadc152bcfd8ef344a012f6917be1 -->
<!-- pgdoc-cn_start sig_en=01e7aa8a11c43cc11ffe573b1dbbe24a sig_cn_org=None source=14.1 
    <row>
     <entry><literal>buffer-write-dirty-start</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
     <entry>Probe that fires when a server process begins to write a dirty
      buffer.  (If this happens often, it implies that
      <xref linkend="guc-shared-buffers"/> is too
      small or the background writer control parameters need adjustment.)
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>buffer-write-dirty-start</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
     <entry>当一个服务器进程开始写一个脏缓冲区时触发的探针（如果这经常发生，表示<xref linkend="guc-shared-buffers"/>太小，或需要调整后台写入器的控制参数）。arg0 和 arg1 包含该页的分叉号和块号。arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=01e7aa8a11c43cc11ffe573b1dbbe24a -->
<!-- pgdoc-cn_start sig_en=7aa3a91bd411e09fcfb7077550128f0f sig_cn_org=None source=14.1 
    <row>
     <entry><literal>buffer-write-dirty-done</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
     <entry>Probe that fires when a dirty-buffer write is complete.
      The arguments are the same as for <literal>buffer-write-dirty-start</literal>.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>buffer-write-dirty-done</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
     <entry>当一次脏缓冲区写完成时触发的探针。参数与<literal>buffer-write-dirty-start</literal>相同。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=7aa3a91bd411e09fcfb7077550128f0f -->
<!-- pgdoc-cn_start sig_en=063826594e93498c0de8388a2d573009 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>wal-buffer-write-dirty-start</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when a server process begins to write a
      dirty WAL buffer because no more WAL buffer space is available.
      (If this happens often, it implies that
      <xref linkend="guc-wal-buffers"/> is too small.)</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>wal-buffer-write-dirty-start</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>当一个服务器进程因为没有可用 WAL 缓冲区空间开始写一个脏 WAL 缓冲区时触发的探针（如果这经常发生，表示<xref linkend="guc-wal-buffers"/>太小）。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=063826594e93498c0de8388a2d573009 -->
<!-- pgdoc-cn_start sig_en=53cf01e483a617d1ad3528772fe8c8d6 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>wal-buffer-write-dirty-done</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when a dirty WAL buffer write is complete.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>wal-buffer-write-dirty-done</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>当一次脏 WAL 缓冲区完成时触发的探针。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=53cf01e483a617d1ad3528772fe8c8d6 -->
<!-- pgdoc-cn_start sig_en=4bc9e6df2989bda1a2095966aac7e1d2 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>wal-insert</literal></entry>
     <entry><literal>(unsigned char, unsigned char)</literal></entry>
     <entry>Probe that fires when a WAL record is inserted.
      arg0 is the resource manager (rmid) for the record.
      arg1 contains the info flags.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>wal-insert</literal></entry>
     <entry><literal>(unsigned char, unsigned char)</literal></entry>
     <entry>当一个 WAL 记录被插入时触发的探针。arg0 是该记录的资源管理者（rmid）。arg1 包含 info 标志。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=4bc9e6df2989bda1a2095966aac7e1d2 -->
<!-- pgdoc-cn_start sig_en=f5257bb38837afeabca813c1aab7ad6f sig_cn_org=None source=14.1 
    <row>
     <entry><literal>wal-switch</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when a WAL segment switch is requested.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>wal-switch</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>当请求一次 WAL 段切换时触发的探针。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=f5257bb38837afeabca813c1aab7ad6f -->
<!-- pgdoc-cn_start sig_en=c175b4f2676fc2b7972e12281d66a1cb sig_cn_org=None source=14.1 
    <row>
     <entry><literal>smgr-md-read-start</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</literal></entry>
     <entry>Probe that fires when beginning to read a block from a relation.
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or <symbol>InvalidBackendId</symbol> (-1) for a shared buffer.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>smgr-md-read-start</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</literal></entry>
     <entry>当开始从一个关系读取一块时触发的探针。arg0 和 arg1 包含该页的分叉号和块号。arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。对一个本地缓冲区，arg5 是创建临时关系的后端的 ID；对于一个共享缓冲区，arg5 是<symbol>InvalidBackendId</symbol>（-1）。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=c175b4f2676fc2b7972e12281d66a1cb -->
<!-- pgdoc-cn_start sig_en=fc8e97e271c402bf8e16c9c428f7c896 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>smgr-md-read-done</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)</literal></entry>
     <entry>Probe that fires when a block read is complete.
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or <symbol>InvalidBackendId</symbol> (-1) for a shared buffer.
      arg6 is the number of bytes actually read, while arg7 is the number
      requested (if these are different it indicates trouble).</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>smgr-md-read-done</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)</literal></entry>
     <entry>当一次块读取完成时触发的探针。arg0 和 arg1 包含该页的分叉号和块号。arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。对一个本地缓冲区，arg5 是创建临时关系的后端的 ID；对于一个共享缓冲区，arg5 是<symbol>InvalidBackendId</symbol>（-1）。arg6 是实际读取的字节数，而 arg7 是请求读取的字节数（如果两者不同就意味着麻烦）。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=fc8e97e271c402bf8e16c9c428f7c896 -->
<!-- pgdoc-cn_start sig_en=b9ce4752f5ad69be535bc140efba409c sig_cn_org=None source=14.1 
    <row>
     <entry><literal>smgr-md-write-start</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</literal></entry>
     <entry>Probe that fires when beginning to write a block to a relation.
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or <symbol>InvalidBackendId</symbol> (-1) for a shared buffer.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>smgr-md-write-start</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</literal></entry>
     <entry>当开始向一个关系中写入一个块时触发的探针。arg0 和 arg1 包含该页的分叉号和块号。arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。对一个本地缓冲区，arg5 是创建临时关系的后端的 ID；对于一个共享缓冲区，arg5 是<symbol>InvalidBackendId</symbol>（-1）。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=b9ce4752f5ad69be535bc140efba409c -->
<!-- pgdoc-cn_start sig_en=9ec9d60938e92a8bcaa9eade93140130 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>smgr-md-write-done</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)</literal></entry>
     <entry>Probe that fires when a block write is complete.
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or <symbol>InvalidBackendId</symbol> (-1) for a shared buffer.
      arg6 is the number of bytes actually written, while arg7 is the number
      requested (if these are different it indicates trouble).</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>smgr-md-write-done</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)</literal></entry>
     <entry>当一个块写操作完成时触发的探针。arg0 和 arg1 包含该页的分叉号和块号。arg2、arg3和arg4 包含表空间、数据库和关系 OID来标识该关系。对于一个本地缓冲区，arg5 是创建临时关系的后端 ID；对于一个共享缓冲区，arg5 是<symbol>InvalidBackendId</symbol>（-1）。arg6 是实际写的字节数，而 arg7 是要求写的字节数（如果这两者不同，则意味着麻烦）。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=9ec9d60938e92a8bcaa9eade93140130 -->
<!-- pgdoc-cn_start sig_en=2388a3cef5aafa9eb24a938347d55b63 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>sort-start</literal></entry>
     <entry><literal>(int, bool, int, int, bool, int)</literal></entry>
     <entry>Probe that fires when a sort operation is started.
      arg0 indicates heap, index or datum sort.
      arg1 is true for unique-value enforcement.
      arg2 is the number of key columns.
      arg3 is the number of kilobytes of work memory allowed.
      arg4 is true if random access to the sort result is required.
      arg5 indicates serial when <literal>0</literal>, parallel worker when
      <literal>1</literal>, or parallel leader when <literal>2</literal>.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>sort-start</literal></entry>
     <entry><literal>(int, bool, int, int, bool, int)</literal></entry>
     <entry>当一次排序操作开始时触发的探针。arg0 指示是堆排序、索引排序或数据排序。arg1 为真表示唯一值强制。arg2 是键列的数目。arg3 是允许使用的工作内存数（以千字节计）。如果要求随机访问排序结果，那么 arg4 为真。arg5为<literal>0</literal>时表示串行，为<literal>1</literal>时表示并行工作者，为<literal>2</literal>时表示并行领袖。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=2388a3cef5aafa9eb24a938347d55b63 -->
<!-- pgdoc-cn_start sig_en=54b6c244d0cf28697b66718c20a2a610 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>sort-done</literal></entry>
     <entry><literal>(bool, long)</literal></entry>
     <entry>Probe that fires when a sort is complete.
      arg0 is true for external sort, false for internal sort.
      arg1 is the number of disk blocks used for an external sort,
      or kilobytes of memory used for an internal sort.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>sort-done</literal></entry>
     <entry><literal>(bool, long)</literal></entry>
     <entry>当一次排序完成时触发的探针。arg0 为真表示外排序，为假表示内排序。arg1 是用于一次外排序的磁盘块的数目，或用于一次内排序的以千字节计的内存。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=54b6c244d0cf28697b66718c20a2a610 -->
<!-- pgdoc-cn_start sig_en=e2017fe713da748bb0b03cd365046d46 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>lwlock-acquire</literal></entry>
     <entry><literal>(char *, LWLockMode)</literal></entry>
     <entry>Probe that fires when an LWLock has been acquired.
      arg0 is the LWLock's tranche.
      arg1 is the requested lock mode, either exclusive or shared.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>lwlock-acquire</literal></entry>
     <entry><literal>(char *, LWLockMode)</literal></entry>
     <entry>当成功获得一个 LWLock 时触发的探针。
      arg0 是该 LWLock 所在的切片（Tranche）。
      arg1 所请求的锁模式，是排他或共享。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=e2017fe713da748bb0b03cd365046d46 -->
<!-- pgdoc-cn_start sig_en=898d8f840a37fc83e76328233077818e sig_cn_org=None source=14.1 
    <row>
     <entry><literal>lwlock-release</literal></entry>
     <entry><literal>(char *)</literal></entry>
     <entry>Probe that fires when an LWLock has been released (but note
      that any released waiters have not yet been awakened).
      arg0 is the LWLock's tranche.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>lwlock-release</literal></entry>
     <entry><literal>(char *)</literal></entry>
     <entry>当一个 LWLock 被释放时（但是注意还没有唤醒任何一个被释放的等待者）触发的探针。
     arg0 是该 LWLock 所在的切片（Tranche）。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=898d8f840a37fc83e76328233077818e -->
<!-- pgdoc-cn_start sig_en=3dec13d20f0023d77ffe652fccfb6236 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>lwlock-wait-start</literal></entry>
     <entry><literal>(char *, LWLockMode)</literal></entry>
     <entry>Probe that fires when an LWLock was not immediately available and
      a server process has begun to wait for the lock to become available.
      arg0 is the LWLock's tranche.
      arg1 is the requested lock mode, either exclusive or shared.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>lwlock-wait-start</literal></entry>
     <entry><literal>(char *, LWLockMode)</literal></entry>
     <entry>当一个 LWLock不是当即可用并且一个服务器进程因此开始等待该锁变为可用时触发的探针。
     arg0 是该 LWLock 所在的切片（Tranche）。
      arg1 请求的锁模式，是排他或共享。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=3dec13d20f0023d77ffe652fccfb6236 -->
<!-- pgdoc-cn_start sig_en=b1d078df5eecafd187ba1d728d88d2b8 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>lwlock-wait-done</literal></entry>
     <entry><literal>(char *, LWLockMode)</literal></entry>
     <entry>Probe that fires when a server process has been released from its
      wait for an LWLock (it does not actually have the lock yet).
      arg0 is the LWLock's tranche.
      arg1 is the requested lock mode, either exclusive or shared.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>lwlock-wait-done</literal></entry>
     <entry><literal>(char *, LWLockMode)</literal></entry>
     <entry>当一个进程从对一个 LWLock 的等待中被释放时（它实际还没有得到该锁）时触发的探针。arg0 是该 LWLock 所在的切片（Tranche）。
      arg1 所请求的锁模式，是排他或共享。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=b1d078df5eecafd187ba1d728d88d2b8 -->
<!-- pgdoc-cn_start sig_en=a32aefeaa88761ccae0b78a1353b4481 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>lwlock-condacquire</literal></entry>
     <entry><literal>(char *, LWLockMode)</literal></entry>
     <entry>Probe that fires when an LWLock was successfully acquired when the
      caller specified no waiting.
      arg0 is the LWLock's tranche.
      arg1 is the requested lock mode, either exclusive or shared.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>lwlock-condacquire</literal></entry>
     <entry><literal>(char *, LWLockMode)</literal></entry>
     <entry>当调用者指定无需等待而成功获得一个 LWLock 时触发的探针。arg0 是该 LWLock 所在的切片（Tranche）。
      arg1 所请求的锁模式，是排他或共享。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=a32aefeaa88761ccae0b78a1353b4481 -->
<!-- pgdoc-cn_start sig_en=81f67bb2815209c8fd543b1b97118b9d sig_cn_org=None source=14.1 
    <row>
     <entry><literal>lwlock-condacquire-fail</literal></entry>
     <entry><literal>(char *, LWLockMode)</literal></entry>
     <entry>Probe that fires when an LWLock was not successfully acquired when
      the caller specified no waiting.
      arg0 is the LWLock's tranche.
      arg1 is the requested lock mode, either exclusive or shared.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>lwlock-condacquire-fail</literal></entry>
     <entry><literal>(char *, LWLockMode)</literal></entry>
     <entry>当调用者指定无需等待而没有成功获得一个 LWLock 时触发的探针。arg0 是该 LWLock 所在的切片（Tranche）。
      arg1 所请求的锁模式，是排他或共享。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=81f67bb2815209c8fd543b1b97118b9d -->
<!-- pgdoc-cn_start sig_en=95c82f4dc65f552d4722ce84de286842 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>lock-wait-start</literal></entry>
     <entry><literal>(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE)</literal></entry>
     <entry>Probe that fires when a request for a heavyweight lock (lmgr lock)
      has begun to wait because the lock is not available.
      arg0 through arg3 are the tag fields identifying the object being
      locked.  arg4 indicates the type of object being locked.
      arg5 indicates the lock type being requested.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>lock-wait-start</literal></entry>
     <entry><literal>(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE)</literal></entry>
     <entry>当一个重量级锁（lmgr锁）的请求由于锁不可用开始等待时触发的探针。arg0 到 arg3 是标识被锁定对象的标签域。arg4 指示被锁对象的类型。arg5 表示被请求的锁类型。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=95c82f4dc65f552d4722ce84de286842 -->
<!-- pgdoc-cn_start sig_en=5468cfcc3175b571314946373987b25a sig_cn_org=None source=14.1 
    <row>
     <entry><literal>lock-wait-done</literal></entry>
     <entry><literal>(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE)</literal></entry>
     <entry>Probe that fires when a request for a heavyweight lock (lmgr lock)
      has finished waiting (i.e., has acquired the lock).
      The arguments are the same as for <literal>lock-wait-start</literal>.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>lock-wait-done</literal></entry>
     <entry><literal>(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE)</literal></entry>
     <entry>当一个重量级锁（lmgr 锁）的请求结束等待时（即已经得到锁）触发的探针。参数与<literal>lock-wait-start</literal>一样。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=5468cfcc3175b571314946373987b25a -->
<!-- pgdoc-cn_start sig_en=0ce0841144956c552b6bc3d14c0ea303 sig_cn_org=None source=14.1 
    <row>
     <entry><literal>deadlock-found</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when a deadlock is found by the deadlock
      detector.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry><literal>deadlock-found</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>当死锁检测器发现死锁时触发的探针。</entry>
    </row>
<!-- pgdoc-cn_end sig_en=0ce0841144956c552b6bc3d14c0ea303 -->

   </tbody>
   </tgroup>
  </table>

 <table id="typedefs-table">
<!-- pgdoc-cn_start sig_en=7e6baec8eb096e938261c6bb5def6fec sig_cn_org=None source=14.1 
  <title>Defined Types Used in Probe Parameters</title>
________________________________________________________-->
  <title>定义用在探针参数中的类型</title>
<!-- pgdoc-cn_end sig_en=7e6baec8eb096e938261c6bb5def6fec -->
  <tgroup cols="2">
   <thead>
<!-- pgdoc-cn_start sig_en=c0c04d4971749887cfed6a6b62be78fd sig_cn_org=None source=14.1 
    <row>
     <entry>Type</entry>
     <entry>Definition</entry>
    </row>
________________________________________________________-->
    <row>
     <entry>类型</entry>
     <entry>定义</entry>
    </row>
<!-- pgdoc-cn_end sig_en=c0c04d4971749887cfed6a6b62be78fd -->
   </thead>

   <tbody>

    <row>
     <entry><type>LocalTransactionId</type></entry>
     <entry><type>unsigned int</type></entry>
    </row>
    <row>
     <entry><type>LWLockMode</type></entry>
     <entry><type>int</type></entry>
    </row>
    <row>
     <entry><type>LOCKMODE</type></entry>
     <entry><type>int</type></entry>
    </row>
    <row>
     <entry><type>BlockNumber</type></entry>
     <entry><type>unsigned int</type></entry>
    </row>
    <row>
     <entry><type>Oid</type></entry>
     <entry><type>unsigned int</type></entry>
    </row>
    <row>
     <entry><type>ForkNumber</type></entry>
     <entry><type>int</type></entry>
    </row>
    <row>
     <entry><type>bool</type></entry>
     <entry><type>unsigned char</type></entry>
    </row>

   </tbody>
   </tgroup>
  </table>


  </sect2>

  <sect2 id="using-trace-points">
<!-- pgdoc-cn_start sig_en=b7a7501ed060c9a211a799cf77c340a0 sig_cn_org=None source=14.1 
   <title>Using Probes</title>
________________________________________________________-->
   <title>使用探针</title>
<!-- pgdoc-cn_end sig_en=b7a7501ed060c9a211a799cf77c340a0 -->

<!-- pgdoc-cn_start sig_en=c892f3ccfc90d86dec6bc37194553ec0 sig_cn_org=None source=14.1 
  <para>
   The example below shows a DTrace script for analyzing transaction
   counts in the system, as an alternative to snapshotting
   <structname>pg_stat_database</structname> before and after a performance test:
<programlisting>
#!/usr/sbin/dtrace -qs

postgresql$1:::transaction-start
{
      @start["Start"] = count();
      self->ts  = timestamp;
}

postgresql$1:::transaction-abort
{
      @abort["Abort"] = count();
}

postgresql$1:::transaction-commit
/self->ts/
{
      @commit["Commit"] = count();
      @time["Total time (ns)"] = sum(timestamp - self->ts);
      self->ts=0;
}
</programlisting>
   When executed, the example D script gives output such as:
<screen>
# ./txn_count.d `pgrep -n postgres` or ./txn_count.d &lt;PID&gt;
^C

Start                                          71
Commit                                         70
Total time (ns)                        2312105013
</screen>
  </para>
________________________________________________________-->
  <para>
   下面的例子展示了一个分析系统中事务计数的 DTrace 脚本，可以用来代替一次性能测试之前和之后的<structname>pg_stat_database</structname>快照：
<programlisting>
#!/usr/sbin/dtrace -qs

postgresql$1:::transaction-start
{
      @start["Start"] = count();
      self->ts  = timestamp;
}

postgresql$1:::transaction-abort
{
      @abort["Abort"] = count();
}

postgresql$1:::transaction-commit
/self->ts/
{
      @commit["Commit"] = count();
      @time["Total time (ns)"] = sum(timestamp - self->ts);
      self->ts=0;
}
</programlisting>
   当被执行时，该例子 D 脚本给出这样的输出：
<screen>
# ./txn_count.d `pgrep -n postgres` or ./txn_count.d &lt;PID&gt;
^C

Start                                          71
Commit                                         70
Total time (ns)                        2312105013
</screen>
  </para>
<!-- pgdoc-cn_end sig_en=c892f3ccfc90d86dec6bc37194553ec0 -->

  <note>
<!-- pgdoc-cn_start sig_en=8edda623d7f721ee73a0453a4af2a97f sig_cn_org=None source=14.1 
   <para>
    SystemTap uses a different notation for trace scripts than DTrace does,
    even though the underlying trace points are compatible.  One point worth
    noting is that at this writing, SystemTap scripts must reference probe
    names using double underscores in place of hyphens.  This is expected to
    be fixed in future SystemTap releases.
   </para>
________________________________________________________-->
   <para>
    SystemTap 为追踪脚本使用一个不同于 DTrace 的标记，但是底层的探针是兼容的。值得注意的是，在这样写的时候，SystemTap 脚本必须使用双下划线代替连字符来引用探针名。在未来的 SystemTap 发行中这很可能会被修复。
   </para>
<!-- pgdoc-cn_end sig_en=8edda623d7f721ee73a0453a4af2a97f -->
  </note>

<!-- pgdoc-cn_start sig_en=bda2d99f50120a2676d2b72cf09c7f15 sig_cn_org=None source=14.1 
  <para>
   You should remember that DTrace scripts need to be carefully written and
   debugged, otherwise the trace information collected might
   be meaningless. In most cases where problems are found it is the
   instrumentation that is at fault, not the underlying system. When
   discussing information found using dynamic tracing, be sure to enclose
   the script used to allow that too to be checked and discussed.
  </para>
________________________________________________________-->
  <para>
   你应该记住，DTrace 脚本需要细心地编写和调试，否则被收集的追踪信息可能会毫无意义。在大部分发现问题的情况中，它就是发生问题的部件，而不是底层系统。当讨论使用动态追踪发现的信息时，一定要附上使用的脚本以便其也被检查和讨论。
  </para>
<!-- pgdoc-cn_end sig_en=bda2d99f50120a2676d2b72cf09c7f15 -->
  </sect2>

  <sect2 id="defining-trace-points">
<!-- pgdoc-cn_start sig_en=4e327f02761e2c29a4980f7d3e5a0d6b sig_cn_org=None source=14.1 
   <title>Defining New Probes</title>
________________________________________________________-->
   <title>定义新探针</title>
<!-- pgdoc-cn_end sig_en=4e327f02761e2c29a4980f7d3e5a0d6b -->

<!-- pgdoc-cn_start sig_en=5d4ed28f6a8314ec3f629c64bd3a5b7f sig_cn_org=None source=14.1 
  <para>
   New probes can be defined within the code wherever the developer
   desires, though this will require a recompilation. Below are the steps
   for inserting new probes:
  </para>
________________________________________________________-->
  <para>
   开发者可以在代码中任意位置定义新的探针，当然这要重新编译之后才能生效。下面是插入新探针的步骤：
  </para>
<!-- pgdoc-cn_end sig_en=5d4ed28f6a8314ec3f629c64bd3a5b7f -->

  <procedure>
   <step>
<!-- pgdoc-cn_start sig_en=962f0447aeece2fcab138285173ef2b0 sig_cn_org=None source=14.1 
    <para>
     Decide on probe names and data to be made available through the probes
    </para>
________________________________________________________-->
    <para>
     决定探针名称以及探针可用的数据
    </para>
<!-- pgdoc-cn_end sig_en=962f0447aeece2fcab138285173ef2b0 -->
   </step>

   <step>
<!-- pgdoc-cn_start sig_en=ad664e66ea1811e407d159796b05a811 sig_cn_org=None source=14.1 
    <para>
     Add the probe definitions to <filename>src/backend/utils/probes.d</filename>
    </para>
________________________________________________________-->
    <para>
     把该探针定义加入到<filename>src/backend/utils/probes.d</filename>
    </para>
<!-- pgdoc-cn_end sig_en=ad664e66ea1811e407d159796b05a811 -->
   </step>

   <step>
<!-- pgdoc-cn_start sig_en=2c0c1b375ce4873fb4c6e950fff2bdb6 sig_cn_org=None source=14.1 
    <para>
     Include <filename>pg_trace.h</filename> if it is not already present in the
     module(s) containing the probe points, and insert
     <literal>TRACE_POSTGRESQL</literal> probe macros at the desired locations
     in the source code
    </para>
________________________________________________________-->
    <para>
     如果<filename>pg_trace.h</filename>还不存在于包含该探针点的模块中，包括它，并且在源代码中期望的位置插入<literal>TRACE_POSTGRESQL</literal>探针宏
    </para>
<!-- pgdoc-cn_end sig_en=2c0c1b375ce4873fb4c6e950fff2bdb6 -->
   </step>

   <step>
<!-- pgdoc-cn_start sig_en=9c2c5066d3fe7d6fd6ce66eab5a7f33d sig_cn_org=None source=14.1 
    <para>
     Recompile and verify that the new probes are available
    </para>
________________________________________________________-->
    <para>
     重新编译并验证新探针是可用的
    </para>
<!-- pgdoc-cn_end sig_en=9c2c5066d3fe7d6fd6ce66eab5a7f33d -->
   </step>
  </procedure>

  <formalpara>
<!-- pgdoc-cn_start sig_en=f6f084a607a204bc4b52cf03cc35c067 sig_cn_org=None source=14.1 
   <title>Example:</title>
________________________________________________________-->
   <title>例子：</title>
<!-- pgdoc-cn_end sig_en=f6f084a607a204bc4b52cf03cc35c067 -->
<!-- pgdoc-cn_start sig_en=b387973c92f3b8ad6f16afd090c89323 sig_cn_org=None source=14.1 
   <para>
    Here is an example of how you would add a probe to trace all new
    transactions by transaction ID.
   </para>
________________________________________________________-->
   <para>
    这里是一个如何增加一个探针来用事务 ID 追踪所有新事务的例子。
   </para>
<!-- pgdoc-cn_end sig_en=b387973c92f3b8ad6f16afd090c89323 -->
  </formalpara>

  <procedure>
   <step>
<!-- pgdoc-cn_start sig_en=cb1b1cc1f59e3483e24a8150d99d8c03 sig_cn_org=None source=14.1 
    <para>
     Decide that the probe will be named <literal>transaction-start</literal> and
     requires a parameter of type <type>LocalTransactionId</type>
    </para>
________________________________________________________-->
    <para>
     决定探针将被命名为<literal>transaction-start</literal>并且需要一个<type>LocalTransactionId</type>类型的参数
    </para>
<!-- pgdoc-cn_end sig_en=cb1b1cc1f59e3483e24a8150d99d8c03 -->
   </step>

   <step>
<!-- pgdoc-cn_start sig_en=f26b5a3dd8589eb134d2d5a3567decdb sig_cn_org=None source=14.1 
    <para>
     Add the probe definition to <filename>src/backend/utils/probes.d</filename>:
<programlisting>
probe transaction__start(LocalTransactionId);
</programlisting>
     Note the use of the double underline in the probe name. In a DTrace
     script using the probe, the double underline needs to be replaced with a
     hyphen, so <literal>transaction-start</literal> is the name to document for
     users.
    </para>
________________________________________________________-->
    <para>
     将该探针定义加入到<filename>src/backend/utils/probes.d</filename>：
<programlisting>
probe transaction__start(LocalTransactionId);
</programlisting>
     注意探针名字中双下划线的使用。在一个使用探针的 DTrace 脚本中，双下划线需要被替换为一个连字符，因此 ，对用户而言<literal>transaction-start</literal>是文档名。
    </para>
<!-- pgdoc-cn_end sig_en=f26b5a3dd8589eb134d2d5a3567decdb -->
   </step>

   <step>
<!-- pgdoc-cn_start sig_en=712a8878d873f0fc55ce3ef77375cf98 sig_cn_org=None source=14.1 
    <para>
     At compile time, <literal>transaction__start</literal> is converted to a macro
     called <literal>TRACE_POSTGRESQL_TRANSACTION_START</literal> (notice the
     underscores are single here), which is available by including
     <filename>pg_trace.h</filename>.  Add the macro call to the appropriate location
     in the source code.  In this case, it looks like the following:

<programlisting>
TRACE_POSTGRESQL_TRANSACTION_START(vxid.localTransactionId);
</programlisting>
    </para>
________________________________________________________-->
    <para>
     在编译时，<literal>transaction__start</literal>被转换成一个宏调用<literal>TRACE_POSTGRESQL_TRANSACTION_START</literal>（注意这里是单下划线），可以通过包括头文件<filename>pg_trace.h</filename>获得。将宏调用加入到源代码中的合适位置。在这种情况下，看起来类似：

<programlisting>
TRACE_POSTGRESQL_TRANSACTION_START(vxid.localTransactionId);
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=712a8878d873f0fc55ce3ef77375cf98 -->
   </step>

   <step>
<!-- pgdoc-cn_start sig_en=e092f57fdd18391cce350fd23a2a268c sig_cn_org=None source=14.1 
    <para>
     After recompiling and running the new binary, check that your newly added
     probe is available by executing the following DTrace command.  You
     should see similar output:
<screen>
# dtrace -ln transaction-start
   ID    PROVIDER          MODULE           FUNCTION NAME
18705 postgresql49878     postgres     StartTransactionCommand transaction-start
18755 postgresql49877     postgres     StartTransactionCommand transaction-start
18805 postgresql49876     postgres     StartTransactionCommand transaction-start
18855 postgresql49875     postgres     StartTransactionCommand transaction-start
18986 postgresql49873     postgres     StartTransactionCommand transaction-start
</screen>
    </para>
________________________________________________________-->
    <para>
     在重新编译和运行新的二进制文件之后，通过运行下面的 DTrace 命令来检查新增的探针是否可用。你应该看到类似下面的输出：
<screen>
# dtrace -ln transaction-start
   ID    PROVIDER          MODULE           FUNCTION NAME
18705 postgresql49878     postgres     StartTransactionCommand transaction-start
18755 postgresql49877     postgres     StartTransactionCommand transaction-start
18805 postgresql49876     postgres     StartTransactionCommand transaction-start
18855 postgresql49875     postgres     StartTransactionCommand transaction-start
18986 postgresql49873     postgres     StartTransactionCommand transaction-start
</screen>
    </para>
<!-- pgdoc-cn_end sig_en=e092f57fdd18391cce350fd23a2a268c -->
   </step>
  </procedure>

<!-- pgdoc-cn_start sig_en=58db520cb5ba7f1011c37f03d0bbde38 sig_cn_org=None source=14.1 
  <para>
   There are a few things to be careful about when adding trace macros
   to the C code:

   <itemizedlist>
    <listitem>
     <para>
      You should take care that the data types specified for a probe's
      parameters match the data types of the variables used in the macro.
      Otherwise, you will get compilation errors.
     </para>
    </listitem>


    <listitem>
     <para>
      On most platforms, if <productname>PostgreSQL</productname> is
      built with <option>-&minus;enable-dtrace</option>, the arguments to a trace
      macro will be evaluated whenever control passes through the
      macro, <emphasis>even if no tracing is being done</emphasis>.  This is
      usually not worth worrying about if you are just reporting the
      values of a few local variables.  But beware of putting expensive
      function calls into the arguments.  If you need to do that,
      consider protecting the macro with a check to see if the trace
      is actually enabled:

<programlisting>
if (TRACE_POSTGRESQL_TRANSACTION_START_ENABLED())
    TRACE_POSTGRESQL_TRANSACTION_START(some_function(...));
</programlisting>

      Each trace macro has a corresponding <literal>ENABLED</literal> macro.
     </para>
    </listitem>
   </itemizedlist>

  </para>
________________________________________________________-->
  <para>
   向C代码中添加追踪宏时，有一些事情需要注意：

   <itemizedlist>
    <listitem>
     <para>
      需要小心的是，为探针参数指定的数据类型要匹配宏中使用的变量的数据类型，否则会发生编译错误。
     </para>
    </listitem>


    <listitem>
     <para>
      在大多数平台上，如果用<option>--enable-dtrace</option>编译了<productname>PostgreSQL</productname>，无论何时当控制经过一个追踪宏时，都会评估该宏的参数，<emphasis>即使没有进行追踪也会这样做</emphasis>。通常不需要担心你是否只在报告一些局部变量的值。但是要注意不要将开销大的函数调用放入参数中。如果你需要这样做，考虑通过检查追踪是否真的被启用来保护该宏：

<programlisting>
if (TRACE_POSTGRESQL_TRANSACTION_START_ENABLED())
    TRACE_POSTGRESQL_TRANSACTION_START(some_function(...));
</programlisting>

      每个追踪宏有一个对应的<literal>ENABLED</literal>宏。
     </para>
    </listitem>
   </itemizedlist>

  </para>
<!-- pgdoc-cn_end sig_en=58db520cb5ba7f1011c37f03d0bbde38 -->

  </sect2>

 </sect1>

</chapter>
