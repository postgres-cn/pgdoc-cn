<!-- doc/src/sgml/manage-ag.sgml -->

<chapter id="managing-databases">
<!--==========================orignal english content==========================
 <title>Managing Databases</title>
____________________________________________________________________________-->
 <title>管理数据库</title>

<!--==========================orignal english content==========================
 <indexterm zone="managing-databases"><primary>database</></>
____________________________________________________________________________-->
 <indexterm zone="managing-databases"><primary>database</></>

<!--==========================orignal english content==========================
 <para>
  Every instance of a running <productname>PostgreSQL</productname>
  server manages one or more databases.  Databases are therefore the
  topmost hierarchical level for organizing <acronym>SQL</acronym>
  objects (<quote>database objects</quote>).  This chapter describes
  the properties of databases, and how to create, manage, and destroy
  them.
 </para>
____________________________________________________________________________-->
 <para>
  每个正在运行的<productname>PostgreSQL</productname>服务器实例都管理着一个或多个数据库。因此，在组织<acronym>SQL</acronym>对象（<quote>数据库对象</quote>）的层次中，数据库位于最顶层。本章描述数据库的属性，以及如何创建、管理、删除它们。
 </para>

 <sect1 id="manage-ag-overview">
<!--==========================orignal english content==========================
  <title>Overview</title>
____________________________________________________________________________-->
  <title>概述</title>

<!--==========================orignal english content==========================
  <indexterm zone="manage-ag-overview">
   <primary>schema</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="manage-ag-overview">
   <primary>模式</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   A database is a named collection of <acronym>SQL</acronym> objects
   (<quote>database objects</quote>).  Generally, every database
   object (tables, functions, etc.) belongs to one and only one
   database.  (However there are a few system catalogs, for example
   <literal>pg_database</>, that belong to a whole cluster and
   are accessible from each database within the cluster.)  More
   accurately, a database is a collection of schemas and the schemas
   contain the tables, functions, etc.  So the full hierarchy is:
   server, database, schema, table (or some other kind of object,
   such as a function).
  </para>
____________________________________________________________________________-->
  <para>
   一个数据库是一些<acronym>SQL</acronym>对象（<quote>数据库对象</quote>）的命名集合。通常每个数据库对象（表、函数等） 属于并且只属于一个数据库（不过有几个系统表如<literal>pg_database</>属于整个集簇并且对集簇中的每个数据库都是可访问的）。更准确地说，一个数据库是一个模式的集合， 而模式包含表、函数等等。因此完整的层次是这样的：服务器、数据库、模式、表（或者某些其他对象类型，如函数）。
  </para>

<!--==========================orignal english content==========================
  <para>
   When connecting to the database server, a client must specify in
   its connection request the name of the database it wants to connect
   to. It is not possible to access more than one database per
   connection. However, an application is not restricted in the number of
   connections it opens to the same or other databases.  Databases are
   physically separated and access control is managed at the
   connection level.  If one <productname>PostgreSQL</> server
   instance is to house projects or users that should be separate and
   for the most part unaware of each other, it is therefore
   recommended to put them into separate databases.  If the projects
   or users are interrelated and should be able to use each other's
   resources, they should be put in the same database but possibly
   into separate schemas.  Schemas are a purely logical structure and who can
   access what is managed by the privilege system.  More information about
   managing schemas is in <xref linkend="ddl-schemas">.
  </para>
____________________________________________________________________________-->
  <para>
   当连接到数据库服务器时，客户端必须在它的连接请求中指定它要连接的数据库名。每次连接不能访问超过一个数据库。不过，一个应用能够在同一个或者其他数据库上打开的连接数并没有受到限制。数据库是物理上相互隔离的，并且访问控制是在连接层面进行管理的。 如果一个<productname>PostgreSQL</>服务器实例用于承载那些应该分隔并且相互之间并不知晓的用户 和项目，那么我们建议把它们放在不同的数据库里。如果项目或者用户是相互关联的， 并且可以相互使用对方的资源，那么应该把它们放在同一个数据库里，但可能在不同的模式 中。模式只是一个纯粹的逻辑结构并且谁能访问某个模式由权限系统管理。有关管理模式的更多信息在<xref linkend="ddl-schemas">中。
  </para>

<!--==========================orignal english content==========================
  <para>
   Databases are created with the <command>CREATE DATABASE</> command
   (see <xref linkend="manage-ag-createdb">) and destroyed with the
   <command>DROP DATABASE</> command
   (see <xref linkend="manage-ag-dropdb">).
   To determine the set of existing databases, examine the
   <structname>pg_database</> system catalog, for example
<synopsis>
SELECT datname FROM pg_database;
</synopsis>
   The <xref linkend="app-psql"> program's <literal>\l</> meta-command
   and <option>-l</> command-line option are also useful for listing the
   existing databases.
  </para>
____________________________________________________________________________-->
  <para>
   数据库是使用<command>CREATE DATABASE</>（见<xref linkend="manage-ag-createdb">），并且用<command>DROP DATABASE</>命令删除（见<xref linkend="manage-ag-dropdb">）。要确定现有数据库的集合，可以检查系统目录<structname>pg_database</>，例如
<synopsis>
SELECT datname FROM pg_database;
</synopsis>
   <xref linkend="app-psql">程序的<literal>\l</>元命令和<option>-l</>命令行选项也可以用来列出已有的数据库。
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    The <acronym>SQL</> standard calls databases <quote>catalogs</>, but there
    is no difference in practice.
   </para>
____________________________________________________________________________-->
   <para>
    <acronym>SQL</>标准把数据库称作<quote>目录</>，不过实际上没有区别。
   </para>
  </note>
 </sect1>

 <sect1 id="manage-ag-createdb">
<!--==========================orignal english content==========================
  <title>Creating a Database</title>
____________________________________________________________________________-->
  <title>创建一个数据库</title>

<!--==========================orignal english content==========================
  <indexterm><primary>CREATE DATABASE</></>
____________________________________________________________________________-->
  <indexterm><primary>CREATE DATABASE</></>

<!--==========================orignal english content==========================
  <para>
   In order to create a database, the <productname>PostgreSQL</>
   server must be up and running (see <xref
   linkend="server-start">).
  </para>
____________________________________________________________________________-->
  <para>
   为了创建一个数据库，<productname>PostgreSQL</>服务器必须启动并运行（见<xref linkend="server-start">）。
  </para>

<!--==========================orignal english content==========================
  <para>
   Databases are created with the SQL command
   <xref linkend="sql-createdatabase">:
<synopsis>
CREATE DATABASE <replaceable>name</>;
</synopsis>
   where <replaceable>name</> follows the usual rules for
   <acronym>SQL</acronym> identifiers.  The current role automatically
   becomes the owner of the new database. It is the privilege of the
   owner of a database to remove it later (which also removes all
   the objects in it, even if they have a different owner).
  </para>
____________________________________________________________________________-->
  <para>
   数据库用 SQL 命令<xref linkend="sql-createdatabase">创建：
<synopsis>
CREATE DATABASE <replaceable>name</>;
</synopsis>
   其中<replaceable>name</>遵循<acronym>SQL</acronym>标识符的一般规则。当前角色自动成为该新数据库的拥有者。以后删除这个数据库也是该拥有者的特权（同时还会删除其中的所有对象，即使那些对象有不同的拥有者）。
  </para>

<!--==========================orignal english content==========================
  <para>
   The creation of databases is a restricted operation. See <xref
   linkend="role-attributes"> for how to grant permission.
  </para>
____________________________________________________________________________-->
  <para>
   创建数据库是一个受限的操作。如何授权请见<xref linkend="role-attributes">。
  </para>

<!--==========================orignal english content==========================
  <para>
   Since you need to be connected to the database server in order to
   execute the <command>CREATE DATABASE</command> command, the
   question remains how the <emphasis>first</> database at any given
   site can be created. The first database is always created by the
   <command>initdb</> command when the data storage area is
   initialized. (See <xref linkend="creating-cluster">.)  This
   database is called
   <literal>postgres</>.<indexterm><primary>postgres</></> So to
   create the first <quote>ordinary</> database you can connect to
   <literal>postgres</>.
  </para>
____________________________________________________________________________-->
  <para>
   因为你需要连接到数据库服务器来执行<command>CREATE DATABASE</command>命令， 那么还有一个问题是任意给定站点的<emphasis>第一个</>数据库是怎样创建的？第一个数据库总是由<command>initdb</>命令在初始化数据存储区域时创建的（见<xref linkend="creating-cluster">）。这个数据库被称为<literal>postgres</><indexterm><primary>postgres</></>。因此要创建第一个<quote>普通</>数据库时，你可以连接到<literal>postgres</>。
  </para>

<!--==========================orignal english content==========================
  <para>
   A second database,
   <literal>template1</literal>,<indexterm><primary>template1</></>
   is also created during database cluster initialization.  Whenever a
   new database is created within the
   cluster, <literal>template1</literal> is essentially cloned.
   This means that any changes you make in <literal>template1</> are
   propagated to all subsequently created databases. Because of this,
   avoid creating objects in <literal>template1</> unless you want them
   propagated to every newly created database.  More details
   appear in <xref linkend="manage-ag-templatedbs">.
  </para>
____________________________________________________________________________-->
  <para>
   在数据库集簇初始化期间也会创建第二个数据库<literal>template1</literal>,<indexterm><primary>template1</></>。当在集簇中创建一个新数据库时，实际上就是克隆了<literal>template1</literal>。这就意味着你对<literal>template1</>所做的任 何修改都会体现在所有随后创建的数据库中。因此应避免在<literal>template1</>中创建对象，除非你想把它们传播到每一个新创建的数据库中。详见<xref linkend="manage-ag-templatedbs">。
  </para>

<!--==========================orignal english content==========================
  <para>
   As a convenience, there is a program you can
   execute from the shell to create new databases,
   <command>createdb</>.<indexterm><primary>createdb</></>

<synopsis>
createdb <replaceable class="parameter">dbname</replaceable>
</synopsis>

   <command>createdb</> does no magic. It connects to the <literal>postgres</>
   database and issues the <command>CREATE DATABASE</> command,
   exactly as described above.
   The <xref linkend="app-createdb"> reference page contains the invocation
   details. Note that <command>createdb</> without any arguments will create
   a database with the current user name.
  </para>
____________________________________________________________________________-->
  <para>
   为了方便，你还可以用一个程序来创建新数据库：
   <command>createdb</>。<indexterm><primary>createdb</></>

<synopsis>
createdb <replaceable class="parameter">dbname</replaceable>
</synopsis>

   <command>createdb</>没什么神奇的。它连接到<literal>postgres</>数据库并且发出<command>CREATE DATABASE</>命令，和前面介绍的完全一样。<xref linkend="app-createdb">参考页包含了调用细节。注意不带任何参数的<command>createdb</>将创建一个使用当前用户名的数据库。
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    <xref linkend="client-authentication"> contains information about
    how to restrict who can connect to a given database.
   </para>
____________________________________________________________________________-->
   <para>
     <xref linkend="client-authentication">包含有关如何限制谁能连接到一个给定数据库的信息。
   </para>
  </note>

<!--==========================orignal english content==========================
  <para>
   Sometimes you want to create a database for someone else, and have them
   become the owner of the new database, so they can
   configure and manage it themselves.  To achieve that, use one of the
   following commands:
<programlisting>
CREATE DATABASE <replaceable>dbname</> OWNER <replaceable>rolename</>;
</programlisting>
   from the SQL environment, or:
<programlisting>
createdb -O <replaceable>rolename</> <replaceable>dbname</>
</programlisting>
   from the shell.
   Only the superuser is allowed to create a database for
   someone else (that is, for a role you are not a member of).
  </para>
____________________________________________________________________________-->
  <para>
   有时候你想为其他人创建一个数据库，并且使其成为新数据库的拥有者，
   这样他们就可以自己配置和管理这个数据库。要实现这个目标，使用下列命令之一：
   用于 SQL 环境的
<programlisting>
CREATE DATABASE <replaceable>dbname</> OWNER <replaceable>rolename</>;
</programlisting>
   或者用于 shell 的
<programlisting>
createdb -O <replaceable>rolename</> <replaceable>dbname</>
</programlisting>
   只有超级用户才被允许为其他人（即为一个你不是其成员的角色）创建一个数据库。
  </para>
 </sect1>

 <sect1 id="manage-ag-templatedbs">
<!--==========================orignal english content==========================
  <title>Template Databases</title>
____________________________________________________________________________-->
  <title>模板数据库</title>

<!--==========================orignal english content==========================
  <para>
   <command>CREATE DATABASE</> actually works by copying an existing
   database.  By default, it copies the standard system database named
   <literal>template1</>.<indexterm><primary>template1</></> Thus that
   database is the <quote>template</> from which new databases are
   made.  If you add objects to <literal>template1</>, these objects
   will be copied into subsequently created user databases.  This
   behavior allows site-local modifications to the standard set of
   objects in databases.  For example, if you install the procedural
   language <application>PL/Perl</> in <literal>template1</>, it will
   automatically be available in user databases without any extra
   action being taken when those databases are created.
  </para>
____________________________________________________________________________-->
  <para>
   <command>CREATE DATABASE</>实际上通过拷贝一个已有数据库进行工作。默认情况下，它拷贝名为<literal>template1</><indexterm><primary>template1</></>的标准系统数据库。所以该数据库是创建新数据库的<quote>模板</>。 如果你为<literal>template1</>数据库增加对象，这些对象将被拷贝到后续创建的用户数据库中。 这种行为允许对数据库中标准对象集合的站点本地修改。例如，如果你把过程语言<application>PL/Perl</>安装到 <literal>template1</>中，那么你在创建用户数据库后不需要额外的操作就可以使用该语言。
  </para>

<!--==========================orignal english content==========================
  <para>
   There is a second standard system database named
   <literal>template0</>.<indexterm><primary>template0</></> This
   database contains the same data as the initial contents of
   <literal>template1</>, that is, only the standard objects
   predefined by your version of
   <productname>PostgreSQL</productname>.  <literal>template0</>
   should never be changed after the database cluster has been
   initialized.  By instructing
   <command>CREATE DATABASE</> to copy <literal>template0</> instead
   of <literal>template1</>, you can create a <quote>virgin</> user
   database that contains none of the site-local additions in
   <literal>template1</>.  This is particularly handy when restoring a
   <literal>pg_dump</> dump: the dump script should be restored in a
   virgin database to ensure that one recreates the correct contents
   of the dumped database, without conflicting with objects that
   might have been added to <literal>template1</> later on.
  </para>
____________________________________________________________________________-->
  <para>
   系统里还有名为<literal>template0</><indexterm><primary>template0</></>的第二个标准系统数据库。这个数据库包含和<literal>template1</>初始内容一样的数据，也就是说，只包含你的<productname>PostgreSQL</productname>版本预定义的标准对象。在数据库集簇被初始化之后，不应该对<literal>template0</>做任何修改。通过指示<command>CREATE DATABASE</>使用<literal>template0</>取代<literal>template1</>进行拷贝，你可以创建一个<quote>纯净的</>用户数据库，它不会包含任何<literal>template1</>中的站点本地附加物。 这一点在恢复一个<literal>pg_dump</>转储时非常方便：转储脚本应该在一个纯净的数据库 中恢复以确保我们重建被转储数据库的正确内容，而不和任何现在可能已经被加入到<literal>template1</>中的附加物相冲突。
  </para>

<!--==========================orignal english content==========================
  <para>
   Another common reason for copying <literal>template0</> instead
   of <literal>template1</> is that new encoding and locale settings
   can be specified when copying <literal>template0</>, whereas a copy
   of <literal>template1</> must use the same settings it does.
   This is because <literal>template1</> might contain encoding-specific
   or locale-specific data, while <literal>template0</> is known not to.
  </para>
____________________________________________________________________________-->
  <para>
   另一个从<literal>template0</>而不是<literal>template1</>复制的常见原因是， 可以在复制<literal>template0</>时指定新的编码和区域设置，而一个<literal>template1</>的副本必须使用和它相同的设置。这是因为的<literal>template1</>可能包含编码相关或区域相关的数据，而<literal>template0</>中没有。
  </para>

<!--==========================orignal english content==========================
  <para>
   To create a database by copying <literal>template0</literal>, use:
<programlisting>
CREATE DATABASE <replaceable>dbname</> TEMPLATE template0;
</programlisting>
   from the SQL environment, or:
<programlisting>
createdb -T template0 <replaceable>dbname</>
</programlisting>
   from the shell.
  </para>
____________________________________________________________________________-->
  <para>
   要通过拷贝<literal>template0</literal>来创建一个数据库，使用：SQL 环境中的
<programlisting>
CREATE DATABASE <replaceable>dbname</> TEMPLATE template0;
</programlisting>
   或者 shell 中的
<programlisting>
createdb -T template0 <replaceable>dbname</>
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   It is possible to create additional template databases, and indeed
   one can copy any database in a cluster by specifying its name
   as the template for <command>CREATE DATABASE</>.  It is important to
   understand, however, that this is not (yet) intended as
   a general-purpose <quote><command>COPY DATABASE</command></quote> facility.
   The principal limitation is that no other sessions can be connected to
   the source database while it is being copied.  <command>CREATE
   DATABASE</> will fail if any other connection exists when it starts;
   during the copy operation, new connections to the source database
   are prevented.
  </para>
____________________________________________________________________________-->
  <para>
   可以创建额外的模板数据库，并且实际上可以通过将集簇中任意数据库指定为<command>CREATE DATABASE</>的模板来从该数据库拷贝。不过，我们必需明白，这个功能并不是设计作为一般性的<quote><command>COPY DATABASE</command></quote>功能。主要的限制是当源数据库被拷贝时，不能有其他会话连接到它。如果在<command>CREATE DATABASE</>开始时存在任何其它连接，那么该命令将会失败。在拷贝操作期间，到源数据库的新连接将被阻止。
  </para>

<!--==========================orignal english content==========================
  <para>
   Two useful flags exist in <literal>pg_database</literal><indexterm><primary>pg_database</></> for each
   database: the columns <literal>datistemplate</literal> and
   <literal>datallowconn</literal>.  <literal>datistemplate</literal>
   can be set to indicate that a database is intended as a template for
   <command>CREATE DATABASE</>.  If this flag is set, the database can be
   cloned by any user with <literal>CREATEDB</> privileges; if it is not set,
   only superusers and the owner of the database can clone it.
   If <literal>datallowconn</literal> is false, then no new connections
   to that database will be allowed (but existing sessions are not terminated
   simply by setting the flag false).  The <literal>template0</literal>
   database is normally marked <literal>datallowconn = false</> to prevent its modification.
   Both <literal>template0</literal> and <literal>template1</literal>
   should always be marked with <literal>datistemplate = true</>.
  </para>
____________________________________________________________________________-->
  <para>
   对于每一个数据库在<literal>pg_database</literal><indexterm><primary>pg_database</></>中存在两个有用的标志： <literal>datistemplate</literal>和<literal>datallowconn</literal>列。<literal>datistemplate</literal>可以被设置来指示该数据库是不是要作为<command>CREATE DATABASE</>的模板。如果设置了这个标志，那么该数据库可以被任何有 <literal>CREATEDB</>权限的用户克隆；如果没有被设置，那么只有超级用户和该数据库的拥有者可以克隆它。如果<literal>datallowconn</literal>为假，那么将不允许与该数据库建立任何新的连接（但已有的会话不会因为把该标志设置为假而被中止）。<literal>template0</literal>通常被标记为<literal>datallowconn = false</>来阻止对它的修改。<literal>template0</literal>和<literal>template1</literal>通常总是被标记为<literal>datistemplate = true</>。
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    <literal>template1</> and <literal>template0</> do not have any special
    status beyond the fact that the name <literal>template1</> is the default
    source database name for <command>CREATE DATABASE</>.
    For example, one could drop <literal>template1</> and recreate it from
    <literal>template0</> without any ill effects.  This course of action
    might be advisable if one has carelessly added a bunch of junk in
    <literal>template1</>. (To delete <literal>template1</literal>,
    it must have <literal>pg_database.datistemplate = false</>.)
   </para>
____________________________________________________________________________-->
   <para>
     除了<literal>template1</>是<command>CREATE DATABASE</>的默认源数据库名之外， <literal>template1</>和<literal>template0</>没有任何特殊的状态。例如，我们可以删除<literal>template1</>然后从<literal>template0</>重新创建它而不会有任何不良效果。如果我们不小心在<literal>template1</>中增加了一堆垃圾，那么我们就会建议做这样的操作（要删除<literal>template1</literal>，它必须有<literal>pg_database.datistemplate = false</>）。
   </para>

<!--==========================orignal english content==========================
   <para>
    The <literal>postgres</> database is also created when a database
    cluster is initialized.  This database is meant as a default database for
    users and applications to connect to. It is simply a copy of
    <literal>template1</> and can be dropped and recreated if necessary.
   </para>
____________________________________________________________________________-->
   <para>
    当数据库集簇被初始化时，也会创建<literal>postgres</>数据库。这个数据库用于做为用户和应用连接的默认数据库。它只是 <literal>template1</>的一个拷贝，需要时可以删除并重建。
   </para>
  </note>
 </sect1>

 <sect1 id="manage-ag-config">
<!--==========================orignal english content==========================
  <title>Database Configuration</title>
____________________________________________________________________________-->
  <title>数据库配置</title>

<!--==========================orignal english content==========================
  <para>
   Recall from <xref linkend="runtime-config"> that the
   <productname>PostgreSQL</> server provides a large number of
   run-time configuration variables.  You can set database-specific
   default values for many of these settings.
  </para>
____________________________________________________________________________-->
  <para>
   回顾一下<xref linkend="runtime-config">，<productname>PostgreSQL</>服务器提供了大量的运行时配置变量。你可以为其中的许多设置数据库相关的默认值。
  </para>

<!--==========================orignal english content==========================
  <para>
   For example, if for some reason you want to disable the
   <acronym>GEQO</acronym> optimizer for a given database, you'd
   ordinarily have to either disable it for all databases or make sure
   that every connecting client is careful to issue <literal>SET geqo
   TO off</literal>.  To make this setting the default within a particular
   database, you can execute the command:
<programlisting>
ALTER DATABASE mydb SET geqo TO off;
</programlisting>
   This will save the setting (but not set it immediately).  In
   subsequent connections to this database it will appear as though
   <literal>SET geqo TO off;</literal> had been executed just before the
   session started.
   Note that users can still alter this setting during their sessions; it
   will only be the default.  To undo any such setting, use
   <literal>ALTER DATABASE <replaceable>dbname</> RESET
   <replaceable>varname</></literal>.
  </para>
____________________________________________________________________________-->
  <para>
   例如，如果由于某种原因，你想禁用指定数据库上的<acronym>GEQO</acronym>优化器，正常情况下你不得不对 所有数据库禁用它，或者确保每个连接的客户端小心地发出了<literal>SET geqo TO off</literal>。要令这个设置在一个特定数据库中成为默认值，你可以执行下面的命令：
<programlisting>
ALTER DATABASE mydb SET geqo TO off;
</programlisting>
   这样将保存该设置（但不是立即设置它）。在后续建立的到该数据库的连接中它将表现得像在会话开始后马上调用<literal>SET geqo TO off;</literal>。注意用户仍然可以在该会话中更改这个设置，它只是默认值。要撤消这样的设置，使用<literal>ALTER DATABASE <replaceable>dbname</> RESET
   <replaceable>varname</></literal>。
  </para>
 </sect1>

 <sect1 id="manage-ag-dropdb">
<!--==========================orignal english content==========================
  <title>Destroying a Database</title>
____________________________________________________________________________-->
  <title>销毁一个数据库</title>

<!--==========================orignal english content==========================
  <para>
   Databases are destroyed with the command
   <xref linkend="sql-dropdatabase">:<indexterm><primary>DROP DATABASE</></>
<synopsis>
DROP DATABASE <replaceable>name</>;
</synopsis>
   Only the owner of the database, or
   a superuser, can drop a database. Dropping a database removes all objects
   that were
   contained within the database. The destruction of a database cannot
   be undone.
  </para>
____________________________________________________________________________-->
  <para>
   数据库用<xref linkend="sql-dropdatabase"><indexterm><primary>DROP DATABASE</></>命令删除：
<synopsis>
DROP DATABASE <replaceable>name</>;
</synopsis>
   只有数据库的拥有者或者超级用户才可以删除数据库。删除数据库会移除其中包括的所有对象。数据库的删除不能被撤销。
  </para>

<!--==========================orignal english content==========================
  <para>
   You cannot execute the <command>DROP DATABASE</command> command
   while connected to the victim database. You can, however, be
   connected to any other database, including the <literal>template1</>
   database.
   <literal>template1</> would be the only option for dropping the last user database of a
   given cluster.
  </para>
____________________________________________________________________________-->
  <para>
   你不能在与目标数据库连接时执行<command>DROP DATABASE</command>命令。不过，你可以连接到任何其它数据库，包括 <literal>template1</>数据库。<literal>template1</>也是你删除一个给定集簇中最后一个用户数据库的唯一选项。
  </para>

<!--==========================orignal english content==========================
  <para>
   For convenience, there is also a shell program to drop
   databases, <xref linkend="app-dropdb">:<indexterm><primary>dropdb</></>
<synopsis>
dropdb <replaceable class="parameter">dbname</replaceable>
</synopsis>
   (Unlike <command>createdb</>, it is not the default action to drop
   the database with the current user name.)
  </para>
____________________________________________________________________________-->
  <para>
   为了方便，有一个在 shell 程序可以删除数据库，<xref linkend="app-dropdb">：<indexterm><primary>dropdb</></>
<synopsis>
dropdb <replaceable class="parameter">dbname</replaceable>
</synopsis>
   （和<command>createdb</>不同，删除当前用户名的数据库不是默认动作）。
  </para>
 </sect1>

 <sect1 id="manage-ag-tablespaces">
<!--==========================orignal english content==========================
  <title>Tablespaces</title>
____________________________________________________________________________-->
  <title>表空间</title>

<!--==========================orignal english content==========================
  <indexterm zone="manage-ag-tablespaces">
   <primary>tablespace</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="manage-ag-tablespaces">
   <primary>表空间</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   Tablespaces in <productname>PostgreSQL</> allow database administrators to
   define locations in the file system where the files representing
   database objects can be stored. Once created, a tablespace can be referred
   to by name when creating database objects.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</>中的表空间允许数据库管理员在文件系统中定义用来存放表示数据库对象的文件的位置。一旦被创建，表空间就可以在创建数据库对象时通过名称引用。
  </para>

<!--==========================orignal english content==========================
  <para>
   By using tablespaces, an administrator can control the disk layout
   of a <productname>PostgreSQL</> installation. This is useful in at
   least two ways. First, if the partition or volume on which the
   cluster was initialized runs out of space and cannot be extended,
   a tablespace can be created on a different partition and used
   until the system can be reconfigured.
  </para>
____________________________________________________________________________-->
  <para>
   通过使用表空间，管理员可以控制一个<productname>PostgreSQL</>安装的磁盘布局。 这么做至少有两个用处。首先，如果初始化集簇所在的分区或者卷用光了空间，而又不能在逻辑上扩展或者做别的什么操作，那么表空间可以被创建在一个不同的分区上，直到系统可以被重新配置。
  </para>

<!--==========================orignal english content==========================
  <para>
   Second, tablespaces allow an administrator to use knowledge of the
   usage pattern of database objects to optimize performance. For
   example, an index which is very heavily used can be placed on a
   very fast, highly available disk, such as an expensive solid state
   device. At the same time a table storing archived data which is
   rarely used or not performance critical could be stored on a less
   expensive, slower disk system.
  </para>
____________________________________________________________________________-->
  <para>
  其次，表空间允许管理员根据数据库对象的使用模式来优化性能。例如，一个很频繁使用的索引可以被放在非常快并且非常可靠的磁盘上，如一种非常贵的固态设备。同时，一个很少使用的或者对性能要求不高的存储归档数据的表可以存储在一个便宜但比较慢的磁盘系统上。
  </para>
  
  <warning>
<!--==========================orignal english content==========================
   <para>
     Even though located outside the main PostgreSQL data directory,
     tablespaces are an integral part of the database cluster and
     <emphasis>cannot</emphasis> be treated as an autonomous collection
     of data files. They are dependent on metadata contained in the main
     data directory, and therefore cannot be attached to a different
     database cluster or backed up individually.  Similarly, if you lose
     a tablespace (file deletion, disk failure, etc), the database cluster
     might become unreadable or unable to start.  Placing a tablespace
     on a temporary file system like a RAM disk risks the reliability of
     the entire cluster.
   </para>
____________________________________________________________________________-->
   <para>
     即便是位于主要的 PostgreSQL 数据目录之外，表空间也是数据库集簇的一部分
     并且<emphasis>不能</emphasis>被视作数据文件的一个自治集合。
     它们依赖于包含在主数据目录中的元数据，并且因此不能被附加到一个
     不同的数据库集簇或者单独备份。类似地，如果丢失一个表空间（文件删除、磁盘失效等），
     数据库集簇可能会变成不可读或者无法启动。把一个表空间放在一个临时文件系统
     （如一个内存虚拟盘）上会带来整个集簇的可靠性风险。
   </para>
  </warning>

<!--==========================orignal english content==========================
  <para>
   To define a tablespace, use the <xref
   linkend="sql-createtablespace">
   command, for example:<indexterm><primary>CREATE TABLESPACE</></>:
<programlisting>
CREATE TABLESPACE fastspace LOCATION '/ssd1/postgresql/data';
</programlisting>
   The location must be an existing, empty directory that is owned by
   the <productname>PostgreSQL</> operating system user.  All objects subsequently
   created within the tablespace will be stored in files underneath this
   directory.  The location must not be on removable or transient storage,
   as the cluster might fail to function if the tablespace is missing
   or lost.
  </para>
____________________________________________________________________________-->
  <para>
   要定义一个表空间，使用<xref linkend="sql-createtablespace">命令，例如：<indexterm><primary>CREATE TABLESPACE</></>
<programlisting>
CREATE TABLESPACE fastspace LOCATION '/ssd1/postgresql/data';
</programlisting>
   这个位置必须是一个已有的空目录，并且属于<productname>PostgreSQL</>操作系统用户。
    所有后续在该表空间中创建的对象都将被存放在这个目录下的文件中。该位置不能放在可移动
    或者瞬时存储上，因为如果表空间丢失会导致集簇无法工作。
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    There is usually not much point in making more than one
    tablespace per logical file system, since you cannot control the location
    of individual files within a logical file system.  However,
    <productname>PostgreSQL</> does not enforce any such limitation, and
    indeed it is not directly aware of the file system boundaries on your
    system.  It just stores files in the directories you tell it to use.
   </para>
____________________________________________________________________________-->
   <para>
    通常在每个逻辑文件系统上创建多于一个表空间没有什么意义，因为你无法控制在一个逻辑文件系统中特定文件的位置。不过，<productname>PostgreSQL</>不强制任何这样的限制，并且事实上它不会注意你的系统上的文件系统边界。它只是在你告诉它要使用的目录中存储文件。
   </para>
  </note>

<!--==========================orignal english content==========================
  <para>
   Creation of the tablespace itself must be done as a database superuser,
   but after that you can allow ordinary database users to use it.
   To do that, grant them the <literal>CREATE</> privilege on it.
  </para>
____________________________________________________________________________-->
  <para>
   表空间的创建本身必须作为一个数据库超级用户完成，但在创建完之后之后你可以允许普通数据库用户来使用它。要这样做，给数据库普通用户授予表空间上的<literal>CREATE</>权限。
  </para>

<!--==========================orignal english content==========================
  <para>
   Tables, indexes, and entire databases can be assigned to
   particular tablespaces. To do so, a user with the <literal>CREATE</>
   privilege on a given tablespace must pass the tablespace name as a
   parameter to the relevant command. For example, the following creates
   a table in the tablespace <literal>space1</>:
<programlisting>
CREATE TABLE foo(i int) TABLESPACE space1;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   表、索引和整个数据库都可以被分配到特定的表空间。想这么做，在给定表空间上有 <literal>CREATE</>权限的用户必须把表空间的名字以一个参数的形式传递给相关的命令。例如，下面的命令在表空间<literal>space1</>中创建一个表：
<programlisting>
CREATE TABLE foo(i int) TABLESPACE space1;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Alternatively, use the <xref linkend="guc-default-tablespace"> parameter:
<programlisting>
SET default_tablespace = space1;
CREATE TABLE foo(i int);
</programlisting>
   When <varname>default_tablespace</> is set to anything but an empty
   string, it supplies an implicit <literal>TABLESPACE</> clause for
   <command>CREATE TABLE</> and <command>CREATE INDEX</> commands that
   do not have an explicit one.
  </para>
____________________________________________________________________________-->
  <para>
   另外，还可以使用<xref linkend="guc-default-tablespace">参数：
<programlisting>
SET default_tablespace = space1;
CREATE TABLE foo(i int);
</programlisting>
   当<varname>default_tablespace</>被设置为非空字符串，那么它就为没有显式<literal>TABLESPACE</>子句的<command>CREATE TABLE</>和<command>CREATE INDEX</>命令提供一个隐式<literal>TABLESPACE</>子句。
  </para>

<!--==========================orignal english content==========================
  <para>
   There is also a <xref linkend="guc-temp-tablespaces"> parameter, which
   determines the placement of temporary tables and indexes, as well as
   temporary files that are used for purposes such as sorting large data
   sets.  This can be a list of tablespace names, rather than only one,
   so that the load associated with temporary objects can be spread over
   multiple tablespaces.  A random member of the list is picked each time
   a temporary object is to be created.
  </para>
____________________________________________________________________________-->
  <para>
   还有一个<xref linkend="guc-temp-tablespaces">参数，它决定临时表和索引的位置，以及用于大数据集排序等目的的临时文件的位置。 这可以是一个表空间名的列表，而不是只有一个。因此，与临时对象有关的负载可以散布在多个表空间上。每次要创建一个临时对象时，将从列表中随机取一个成员来存放它。
  </para>

<!--==========================orignal english content==========================
  <para>
   The tablespace associated with a database is used to store the system
   catalogs of that database.  Furthermore, it is the default tablespace
   used for tables, indexes, and temporary files created within the database,
   if no <literal>TABLESPACE</> clause is given and no other selection is
   specified by <varname>default_tablespace</> or
   <varname>temp_tablespaces</> (as appropriate).
   If a database is created without specifying a tablespace for it,
   it uses the same tablespace as the template database it is copied from.
  </para>
____________________________________________________________________________-->
  <para>
   与一个数据库相关联的表空间用来存储该数据库的系统目录。此外，如果没有给出<literal>TABLESPACE</>子句并且没有在<varname>default_tablespace</>或<varname>temp_tablespaces</>（如适用）中指定其他选择，它还是在该数据库中创建的表、索引和临时文件的默认表空间。如果一个数据库被创建时没有指定表空间，它会使用其模板数据库相同的表空间。
  </para>

<!--==========================orignal english content==========================
  <para>
   Two tablespaces are automatically created when the database cluster
   is initialized.  The
   <literal>pg_global</> tablespace is used for shared system catalogs. The
   <literal>pg_default</> tablespace is the default tablespace of the
   <literal>template1</> and <literal>template0</> databases (and, therefore,
   will be the default tablespace for other databases as well, unless
   overridden by a <literal>TABLESPACE</> clause in <command>CREATE
   DATABASE</>).
  </para>
____________________________________________________________________________-->
  <para>
   当初始化数据库集簇时，会自动创建两个表空间。<literal>pg_global</>表空间被用于共享系统目录。<literal>pg_default</>表空间是<literal>template1</>和<literal>template0</>数据库的默认表空间（并且，因此也将是所有其他数据库的默认表空间，除非被一个<command>CREATE DATABASE</>中的<literal>TABLESPACE</>子句覆盖）。
  </para>

<!--==========================orignal english content==========================
  <para>
   Once created, a tablespace can be used from any database, provided
   the requesting user has sufficient privilege. This means that a tablespace
   cannot be dropped until all objects in all databases using the tablespace
   have been removed.
  </para>
____________________________________________________________________________-->
  <para>
   表空间一旦被创建，就可以被任何数据库使用，前提是请求的用户具有足够的权限。这也意味着，一个表空间只有在所有使用它的数据库中所有对象都被删除掉之后才可以被删掉。
  </para>

<!--==========================orignal english content==========================
  <para>
   To remove an empty tablespace, use the <xref
   linkend="sql-droptablespace">
   command.
  </para>
____________________________________________________________________________-->
  <para>
   要删除一个空的表空间，使用<xref linkend="sql-droptablespace">命令。
  </para>

<!--==========================orignal english content==========================
  <para>
   To determine the set of existing tablespaces, examine the
   <link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname>
   </link> system catalog, for example
<synopsis>
SELECT spcname FROM pg_tablespace;
</synopsis>
   The <xref linkend="app-psql"> program's <literal>\db</> meta-command
   is also useful for listing the existing tablespaces.
  </para>
____________________________________________________________________________-->
  <para>
   要确定现有表空间的集合，可检查<link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname>
   </link>系统目录，例如
<synopsis>
SELECT spcname FROM pg_tablespace;
</synopsis>
   <xref linkend="app-psql">程序的<literal>\db</>元命令也可以用来列出现有的表空间。
  </para>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</> makes use of symbolic links
   to simplify the implementation of tablespaces. This
   means that tablespaces can be used <emphasis>only</> on systems
   that support symbolic links.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</>使用符号连接来简化表空间的实现。这就意味着表空间<emphasis>只能</>在支持符号连接的系统上使用。
  </para>

<!--==========================orignal english content==========================
  <para>
   The directory <filename>$PGDATA/pg_tblspc</> contains symbolic links that
   point to each of the non-built-in tablespaces defined in the cluster.
   Although not recommended, it is possible to adjust the tablespace
   layout by hand by redefining these links. Under no circumstances perform
   this operation while the server is running. Note that in PostgreSQL 9.1
   and earlier you will also need to update the <structname>pg_tablespace</>
   catalog with the new locations. (If you do not, <literal>pg_dump</> will
   continue to output the old tablespace locations.)
  </para>
____________________________________________________________________________-->
  <para>
   <filename>$PGDATA/pg_tblspc</>目录包含指向集簇中定义的每个非内建表空间的符号连接。 尽管我们不推荐，但还是可以通过手工重定义这些连接来调整表空间布局。在服务器运行时，绝不要这样做。注意在 PostgreSQL 9.1 及更早的版本中，你将还需要用新位置更新<structname>pg_tablespace</>目录（如果你不更新，<literal>pg_dump</>将继续输出旧的表空间位置）。
  </para>

 </sect1>
</chapter>
