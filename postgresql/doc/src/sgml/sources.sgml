<!-- doc/src/sgml/sources.sgml -->

 <chapter id="source">
  <!--
  <title>PostgreSQL Coding Conventions</title>
  -->
  <title>PostgreSQL 编码约定</title>

  <sect1 id="source-format">
   <!--
   <title>Formatting</title>
   -->
   <title>格式</title>

   <!--
<para>
    Source code formatting uses 4 column tab spacing, with
    tabs preserved (i.e., tabs are not expanded to spaces).
    Each logical indentation level is one additional tab stop.
   </para>
-->
<para>
代码格式使用每个制表符 4 列的空白，目前是保留制表符状态
(也就是说制表符不被展开为空白)。每个逻辑缩进层次都是更多的一个制表符。
</para>

   <!--
<para>
    Layout rules (brace positioning, etc) follow BSD conventions.  In
    particular, curly braces for the controlled blocks of <literal>if</>,
    <literal>while</>, <literal>switch</>, etc go on their own lines.
   </para>
-->
<para>
布局规则(花括弧定位等)遵循 BSD 传统。特别的，<literal>if</>、
<literal>while</>、<literal>switch</>等的控制块的大括号从它们自己的行开始。
</para>

   <!--
<para>
    Limit line lengths so that the code is readable in an 80-column window.
    (This doesn't mean that you must never go past 80 columns.  For instance,
    breaking a long error message string in arbitrary places just to keep the
    code within 80 columns is probably not a net gain in readability.)
   </para>
-->
<para>
限制行的长度，这样代码在80字段的窗口内可读。（这并不意味着你不能超过80个字段。
例如，在任意地方分解一个长的错误消息字符串，只是为了保持代码在80个字段内，
可能不是为了可读性。）
</para>

   <!--
<para>
    Do not use C++ style comments (<literal>//</> comments).  Strict ANSI C
    compilers do not accept them.  For the same reason, do not use C++
    extensions such as declaring new variables mid-block.
   </para>
-->
<para>
不要使用C++风格的注释(<literal>//</> 注释)。严格的ANSI C编译器不接受它们。
相同的原因，不要使用C++扩展，比如在块中声明新的变量。
</para>

   
<para>
<!-- 
   The preferred style for multi-line comment blocks is
-->
多行注释块的首选风格是
<programlisting>
/*
 * comment text begins here
 * and continues here
 */
</programlisting>
<!--
     Note that comment blocks that begin in column 1 will be preserved as-is
    by <application>pgindent</>, but it will re-flow indented comment blocks
    as though they were plain text.  If you want to preserve the line breaks
    in an indented block, add dashes like this:
-->
请注意，在第一列开始的注释块将被<application>pgindent</>按原样保存，
但是它将回流注释块缩进，就像它们是纯文本。如果你想要在缩进块中保留换行，
像这样添加破折号：
<programlisting>
    /*----------
     * comment text begins here
     * and continues here
     *----------
     */
</programlisting>
   </para>

   <!--
<para>
    While submitted patches do not absolutely have to follow these formatting
    rules, it's a good idea to do so.  Your code will get run through
    <application>pgindent</> before the next release, so there's no point in
    making it look nice under some other set of formatting conventions.
    A good rule of thumb for patches is <quote>make the new code look like
    the existing code around it</>.
   </para>
-->
<para>
虽然提交的补丁并不需要完全遵循这些格式化规则，最好还是这么做。
你的代码将会在下一个版本之前被<application>pgindent</>处理，
虽然这样做不会让它看起来比其它的格式化习惯更好看。
一个补丁的好的经验法则是<quote>让新的代码看起来像是被已有的代码包围</>。
</para>

   <!--
<para>
    The <filename>src/tools</filename> directory contains sample settings
    files that can be used with the <productname>emacs</productname>,
    <productname>xemacs</productname> or <productname>vim</productname>
    editors to help ensure that they format code according to these
    conventions.
   </para>
-->
<para>
<filename>src/tools</filename>目录包含了适用于<productname>emacs</productname>
的示范配置文件，<productname>xemacs</productname>或<productname>vim</productname>
用户也必须确保其格式代码也符合上述规范。
</para>

   <!--
<para>
    The text browsing tools <application>more</application> and
    <application>less</application> can be invoked as:
<programlisting>
more -x4
less -x4
</programlisting>
    to make them show tabs appropriately.
   </para>
-->
<para>
文本浏览工具<application>more</application>和<application>less</application>
可以用下面命令调用：
<programlisting>
more -x4
less -x4
</programlisting>
这样就可以让他们正确显示制表符。
</para>
  </sect1>

  <sect1 id="error-message-reporting">
   <!--
   <title>Reporting Errors Within the Server</title>
   -->
   <title>报告服务器里的错误</title>

   <indexterm>
    <primary>ereport</primary>
   </indexterm>
   <indexterm>
    <primary>elog</primary>
   </indexterm>

   <!--
<para>
    Error, warning, and log messages generated within the server code
    should be created using <function>ereport</>, or its older cousin
    <function>elog</>.  The use of this function is complex enough to
    require some explanation.
   </para>
-->
<para>
在服务器代码里生成的错误、警告以及日志信息应该用<function>ereport</>
或者它的兄弟<function>elog</>创建。这个函数的使用已经复杂得需要做些解释了。
</para>

   <!--
<para>
    There are two required elements for every message: a severity level
    (ranging from <literal>DEBUG</> to <literal>PANIC</>) and a primary
    message text.  In addition there are optional elements, the most
    common of which is an error identifier code that follows the SQL spec's
    SQLSTATE conventions.
    <function>ereport</> itself is just a shell function, that exists
    mainly for the syntactic convenience of making message generation
    look like a function call in the C source code.  The only parameter
    accepted directly by <function>ereport</> is the severity level.
    The primary message text and any optional message elements are
    generated by calling auxiliary functions, such as <function>errmsg</>,
    within the <function>ereport</> call.
   </para>
-->
<para>
每条消息都有两个必须的要素：一个严重级别(范围从<literal>DEBUG</>到
<literal>PANIC</>)和一个主要消息文本。除此之外还有可选的元素，
最常见的就是一个遵循 SQL 标准的 SQLSTATE 习惯的错误标识码。
<function>ereport</>本身只是一个壳函数，
它的存在主要是为了便于让消息生成看起来像 C 代码里的函数调用。
<function>ereport</>直接接受的唯一参数是严重级别。
主消息文本和任何附加消息元素都是通过在<function>ereport</>
调用里调用辅助函数(比如<function>errmsg</>)生成的。
</para>

   <!--
<para>
    A typical call to <function>ereport</> might look like this:
<programlisting>
ereport(ERROR,
        (errcode(ERRCODE_DIVISION_BY_ZERO),
         errmsg("division by zero")));
</programlisting>
    This specifies error severity level <literal>ERROR</> (a run-of-the-mill
    error).  The <function>errcode</> call specifies the SQLSTATE error code
    using a macro defined in <filename>src/include/utils/errcodes.h</>.  The
    <function>errmsg</> call provides the primary message text.  Notice the
    extra set of parentheses surrounding the auxiliary function calls &mdash;
    these are annoying but syntactically necessary.
   </para>
-->
<para>
典型的调用<function>ereport</>的方式看起来可能像下面这样：
<programlisting>
ereport(ERROR,
        (errcode(ERRCODE_DIVISION_BY_ZERO),
         errmsg("division by zero")));
</programlisting>
这样就声明了错误严重级别<literal>ERROR</>(一个普通错误)。
<function>errcode</>调用指定一个在<filename>src/include/utils/errcodes.h</>
里面使用宏定义的SQLSTATE错误代码。<function>errmsg</>调用提供主要的消息文本。
请注意包围在辅助函数调用周围的额外的圆括弧&mdash;这么做虽然烦人，
但是语法上是必须的。
</para>
  
<para>
<!--
    Here is a more complex example:
-->
然后是一个更复杂的例子：
<programlisting>
ereport(ERROR,
        (errcode(ERRCODE_AMBIGUOUS_FUNCTION),
         errmsg("function %s is not unique",
                func_signature_string(funcname, nargs,
                                      NIL, actual_arg_types)),
         errhint("Unable to choose a best candidate function. "
                 "You might need to add explicit typecasts.")));
</programlisting>
<!-- 
    This illustrates the use of format codes to embed run-time values into
    a message text.  Also, an optional <quote>hint</> message is provided. 
-->
这个例子演示了使用格式化代码把运行时数值嵌入一个消息文本的用法。
同样，还提供了一个可选的<quote>暗示</>信息。
   </para>

<!-- 
   <para>
    If the severity level is <literal>ERROR</> or higher,
    <function>ereport</> aborts the execution of the user-defined
    function and does not return to the caller. If the severity level is
    lower than <literal>ERROR</>, <function>ereport</> returns normally.
   </para>
-->
<para>
如果严重性级别是<literal>ERROR</>或更高，那么<function>ereport</>
退出用户定义函数的执行并且不返回给调用者。
如果严重性级别低于<literal>ERROR</>，那么<function>ereport</>正常返回。
</para>

<para>
<!-- 
    The available auxiliary routines for <function>ereport</> are:
-->
<function>ereport</>可用的附属过程有：
  <itemizedlist>
   <listitem>
<!--
    <para>
     <function>errcode(sqlerrcode)</function> specifies the SQLSTATE error identifier
     code for the condition.  If this routine is not called, the error
     identifier defaults to
     <literal>ERRCODE_INTERNAL_ERROR</> when the error severity level is
     <literal>ERROR</> or higher, <literal>ERRCODE_WARNING</> when the
     error level is <literal>WARNING</>, otherwise (for <literal>NOTICE</>
     and below) <literal>ERRCODE_SUCCESSFUL_COMPLETION</>.
     While these defaults are often convenient, always think whether they
     are appropriate before omitting the <function>errcode()</> call.
    </para>
-->
<para>
<function>errcode(sqlerrcode)</function>为该条件声明 SQLSTATE 错误标识符代码。
如果没有调用这个过程，并且错误严重级别是<literal>ERROR</>或更高，
那么错误标识符缺省是<literal>ERRCODE_INTERNAL_ERROR</>，
如果错误严重级别是<literal>WARNING</>则为<literal>ERRCODE_WARNING</>，
否则(用于<literal>NOTICE</>或者更低级别)为<literal>ERRCODE_SUCCESSFUL_COMPLETION</>。
虽然这些缺省都很方便，但是最好还是在省略<function>errcode()</>调用之前三思。
</para>
   </listitem>
   <listitem>
    
<para>
<!-- 
     <function>errmsg(const char *msg, ...)</function> specifies the primary error
     message text, and possibly run-time values to insert into it.  Insertions
     are specified by <function>sprintf</>-style format codes.  In addition to
     the standard format codes accepted by <function>sprintf</>, the format
     code <literal>%m</> can be used to insert the error message returned
     by <function>strerror</> for the current value of <literal>errno</>.
-->
<function>errmsg(const char *msg, ...)</function>声明主错误消息文本，
以及可能的插入其中的运行时数值。插入是使用<function>sprintf</>
风格的格式代码插入的。除了<function>sprintf</>接受的标准格式代码，
还接受<literal>%m</>用于插入<function>strerror</>为当前<literal>errno</>
值返回的错误消息。
     <footnote>
<!--
      <para>
       That is, the value that was current when the <function>ereport</> call
       was reached; changes of <literal>errno</> within the auxiliary reporting
       routines will not affect it.  That would not be true if you were to
       write <literal>strerror(errno)</> explicitly in <function>errmsg</>'s
       parameter list; accordingly, do not do so.
      </para>
-->
<para>
也就是说，在到达<function>ereport</>调用的时候当前的数值；
在附属报告过程里对<literal>errno</>的修改将不会影响他。但是如果你在
<function>errmsg</>的参数列表里明确地写<literal>strerror(errno)</>，
这一点就不能保证了，因此，请不要这么做。
</para>
     </footnote>
<!-- 
     <literal>%m</> does not require any
     corresponding entry in the parameter list for <function>errmsg</>.
     Note that the message string will be run through <function>gettext</>
     for possible localization before format codes are processed. 
-->
<literal>%m</>并不要求在<function>errmsg</>的参数列表里有任何对应的项目。
请注意这个消息字符串在格式代码得到处理之前将不会通过<function>gettext</>
运行获取合适的本地化。
    </para>
   </listitem>
   <listitem>
    <!--
<para>
     <function>errmsg_internal(const char *msg, ...)</function> is the same as
     <function>errmsg</>, except that the message string will not be
     translated nor included in the internationalization message dictionary.
     This should be used for <quote>cannot happen</> cases that are probably
     not worth expending translation effort on.
    </para>
-->
<para>
<function>errmsg_internal(const char *msg, ...)</function>和<function>errmsg</>
一样，只是消息字符串将不会包含在国际化消息字典里。这个函数应该用于
<quote>不可能发生</>的情况，也就是不值得展开进行翻译的场合。
</para>
   </listitem>
   <listitem>
    <!--
<para>
     <function>errmsg_plural(const char *fmt_singular, const char *fmt_plural,
     unsigned long n, ...)</function> is like <function>errmsg</>, but with
     support for various plural forms of the message.
     <replaceable>fmt_singular</> is the English singular format,
     <replaceable>fmt_plural</> is the English plural format,
     <replaceable>n</> is the integer value that determines which plural
     form is needed, and the remaining arguments are formatted according
     to the selected format string.  For more information see
     <xref linkend="nls-guidelines">.
    </para>
-->
<para>
<function>errmsg_plural(const char *fmt_singular, const char *fmt_plural, 
unsigned long n, ...)</function>就像是<function>errmsg</>，
但是支持消息的各种复数形式。<replaceable>fmt_singular</>是英语单数形式，
<replaceable>fmt_plural</>是英语复数形式，<replaceable>n</>
是决定使用哪个复数形式的整数值，剩余的参数根据选择的格式字符串进行格式化。
更多信息请查看<xref linkend="nls-guidelines">。
</para>
   </listitem>
   <listitem>
    <!--
<para>
     <function>errdetail(const char *msg, ...)</function> supplies an optional
     <quote>detail</> message; this is to be used when there is additional
     information that seems inappropriate to put in the primary message.
     The message string is processed in just the same way as for
     <function>errmsg</>.
    </para>
-->
<para>
<function>errdetail(const char *msg, ...)</function>提供一个可选的<quote>详细</>信息；
在存在额外的信息，并且很适合放在主消息里面的时候使用这个函数。
消息字符串处理的方法和<function>errmsg</>完全一样。
</para>
   </listitem>
   <listitem>
    <!--
<para>
     <function>errdetail_internal(const char *msg, ...)</function> is the same
     as <function>errdetail</>, except that the message string will not be
     translated nor included in the internationalization message dictionary.
     This should be used for detail messages that are not worth expending
     translation effort on, for instance because they are too technical to be
     useful to most users.
    </para>
-->
<para>
<function>errdetail_internal(const char *msg, ...)</function>和<function>errdetail</>一样，
只是消息字符串将不会包含在国际化消息字典里。这个函数应该用于不值得展开进行翻译的详细消息，
比如，因为它们太技术了以至于对大多数用户来说无用。
</para>
   </listitem>
   <listitem>
    <!--
<para>
     <function>errdetail_plural(const char *fmt_singular, const char *fmt_plural,
     unsigned long n, ...)</function> is like <function>errdetail</>, but with
     support for various plural forms of the message.
     For more information see <xref linkend="nls-guidelines">.
    </para>
-->
<para>
<function>errdetail_plural(const char *fmt_singular, const char *fmt_plural, 
unsigned long n, ...)</function>类似于<function>errdetail</>，
但是支持消息的各种复数形式。更多信息请查阅<xref linkend="nls-guidelines">。
</para>
   </listitem>
   <listitem>
    <!--
<para>
     <function>errdetail_log(const char *msg, ...)</function> is the same as
     <function>errdetail</> except that this string goes only to the server
     log, never to the client.  If both <function>errdetail</> (or one of
     its equivalents above) and
     <function>errdetail_log</> are used then one string goes to the client
     and the other to the log.  This is useful for error details that are
     too security-sensitive or too bulky to include in the report
     sent to the client.
    </para>
-->
<para>
<function>errdetail_log(const char *msg, ...)</function>和
<function>errdetail</> 一样，除了这个字符串只到服务器日志，从不到客户端。
如果<function>errdetail</>（或它的以上相同的其中之一）和<function>errdetail_log</>
都使用了，那么一个字符串到客户端，另一个到服务器日志。
这对于过于安全敏感或太大而不能包含进发送到客户端的报告中的错误细节来说是有用的。
</para>
   </listitem>

   <listitem>
<!--
    <para>
     <function>errdetail_log_plural(const char *fmt_singuar, const char
     *fmt_plural, unsigned long n, ...)</function> is like
     <function>errdetail_log</>, but with support for various plural forms of
     the message.
     For more information see <xref linkend="nls-guidelines">.
    </para>
-->
<para>
     <function>errdetail_log_plural(const char *fmt_singuar, const char
     *fmt_plural, unsigned long n, ...)</function>类似于
     <function>errdetail_log</>，但是支持该消息的各种复数形式。
     更多信息请查阅<xref linkend="nls-guidelines">。
</para>
   </listitem>

   <listitem>
    <!--
<para>
     <function>errhint(const char *msg, ...)</function> supplies an optional
     <quote>hint</> message; this is to be used when offering suggestions
     about how to fix the problem, as opposed to factual details about
     what went wrong.
     The message string is processed in just the same way as for
     <function>errmsg</>.
    </para>
-->
<para>
<function>errhint(const char *msg, ...)</function>提供一个可选的<quote>暗示</>消息；
这个函数用于提供如何修补问题的建议，而不是提供错误的事实。
消息字符串处理的方式和<function>errmsg</>一样。
</para>
   </listitem>
   <listitem>
    <!--
<para>
     <function>errcontext(const char *msg, ...)</function> is not normally called
     directly from an <function>ereport</> message site; rather it is used
     in <literal>error_context_stack</> callback functions to provide
     information about the context in which an error occurred, such as the
     current location in a PL function.
     The message string is processed in just the same way as for
     <function>errmsg</>.  Unlike the other auxiliary functions, this can
     be called more than once per <function>ereport</> call; the successive
     strings thus supplied are concatenated with separating newlines.
    </para>
-->
<para>
<function>errcontext(const char *msg, ...)</function>通常不会直接从<function>ereport</>
消息点里直接调用；而是用在<literal>error_context_stack</>
回调函数里提供有关错误发生的环境的信息，比如，当前的位置是在一个 PL 函数里等等。
消息字符串的处理和<function>errmsg</>完全一样。和其它辅助函数不同，
这个函数在一次<function>ereport</>调用里可以调用多次；
随后的调用生成的字符串将带着各自的换行符连接在原来的字符串上。
</para>
   </listitem>
   <listitem>
    <!--
<para>
     <function>errposition(int cursorpos)</function> specifies the textual location
     of an error within a query string.  Currently it is only useful for
     errors detected in the lexical and syntactic analysis phases of
     query processing.
    </para>
-->
<para>
<function>errposition(int cursorpos)</function>声明一个错误在查询字符串里的文本位置。
目前它只是在报告查询处理过程中的词法和语法分析阶段检测到的错误有用。
</para>
   </listitem>
   <listitem>
    <!--
<para>
     <function>errtable(Relation rel)</function> specifies a relation whose
     name and schema name should be included as auxiliary fields in the error
     report.
    </para>
-->
<para>
<function>errtable(Relation rel)</function>指定一个关系，
关系名和模式名应该作为辅助字段包含在错误报告内。
</para>
   </listitem>
   <listitem>
    <!--
<para>
     <function>errtablecol(Relation rel, int attnum)</function> specifies
     a column whose name, table name, and schema name should be included as
     auxiliary fields in the error report.
    </para>
-->
<para>
<function>errtablecol(Relation rel, int attnum)</function>指定一个字段，
该字段的名字、表名和模式名应该作为辅助字段包含在错误报告中。
</para>
   </listitem>
   <listitem>
    <!--
<para>
     <function>errtableconstraint(Relation rel, const char *conname)</function>
     specifies a table constraint whose name, table name, and schema name
     should be included as auxiliary fields in the error report.  Indexes
     should be considered to be constraints for this purpose, whether or
     not they have an associated <structname>pg_constraint</> entry.  Be
     careful to pass the underlying heap relation, not the index itself, as
     <literal>rel</>.
    </para>
-->
<para>
<function>errtableconstraint(Relation rel, const char *conname)</function>
指定一个表约束，该表约束的名字、表名和模式名应该作为辅助字段包含在错误报告中。
不管它们是否有一个相关的<structname>pg_constraint</>项，索引都应该被认为是约束。
小心地传递底层堆关系，不只是索引本身，作为<literal>rel</>。
</para>
   </listitem>
   <listitem>
    <!--
<para>
     <function>errdatatype(Oid datatypeOid)</function> specifies a data
     type whose name and schema name should be included as auxiliary fields
     in the error report.
    </para>
-->
<para>
<function>errdatatype(Oid datatypeOid)</function>指定一个数据类型，
它的名字和模式名应该作为辅助字段包含在错误报告中。
</para>
   </listitem>
   <listitem>
    <!--
<para>
     <function>errdomainconstraint(Oid datatypeOid, const char *conname)</function>
     specifies a domain constraint whose name, domain name, and schema name
     should be included as auxiliary fields in the error report.
    </para>
-->
<para>
<function>errdomainconstraint(Oid datatypeOid, const char *conname)</function>
指定一个域约束，该域约束的名字、域名和模式名应该作为附属字段包含在错误报告中。
</para>
   </listitem>
   <listitem>
    <!--
<para>
     <function>errcode_for_file_access()</> is a convenience function that
     selects an appropriate SQLSTATE error identifier for a failure in a
     file-access-related system call.  It uses the saved
     <literal>errno</> to determine which error code to generate.
     Usually this should be used in combination with <literal>%m</> in the
     primary error message text.
    </para>
-->
<para>
<function>errcode_for_file_access()</>是一个便利函数，
它可以为一个文件访问类的系统调用选择一个合适的 SQLSTATE 错误标识符。
它利用保存下来的<literal>errno</>判断生成哪个错误代码。
通常它应该和主错误消息文本里的<literal>%m</>结合使用。
</para>
   </listitem>
   <listitem>
    <!--
<para>
     <function>errcode_for_socket_access()</> is a convenience function that
     selects an appropriate SQLSTATE error identifier for a failure in a
     socket-related system call.
    </para>
-->
<para>
<function>errcode_for_socket_access()</>是一个便利函数，
它可以为一个套接字相关的系统调用选择一个合适的 SQLSTATE 错误标识符。
</para>
   </listitem>
   <listitem>
    <!--
<para>
     <function>errhidestmt(bool hide_stmt)</function> can be called to specify
     suppression of the <literal>STATEMENT:</> portion of a message in the
     postmaster log.  Generally this is appropriate if the message text
     includes the current statement already.
    </para>
-->
<para>
<function>errhidestmt(bool hide_stmt)</function>可以用来在主日志中指定消息的
<literal>STATEMENT:</>部分的消除。如果消息文本早已包括当前语句，
那么这通常是合适的。
</para>
   </listitem>
  </itemizedlist>
   </para>

   <note>
    <!--
<para>
     At most one of the functions <function>errtable</>,
     <function>errtablecol</>, <function>errtableconstraint</>,
     <function>errdatatype</>, or <function>errdomainconstraint</> should
     be used in an <function>ereport</> call.  These functions exist to
     allow applications to extract the name of a database object associated
     with the error condition without having to examine the
     potentially-localized error message text.
     These functions should be used in error reports for which it's likely
     that applications would wish to have automatic error handling.  As of
     <productname>PostgreSQL</> 9.3, complete coverage exists only for
     errors in SQLSTATE class 23 (integrity constraint violation), but this
     is likely to be expanded in future.
    </para>
-->
<para>
<function>errtable</>、<function>errtablecol</>、<function>errtableconstraint</>、
<function>errdatatype</>或<function>errdomainconstraint</>
中最多只有一个函数应该用在一个<function>ereport</>调用中。
这些函数的存在允许应用提取与没有检测潜在本地化错误消息文本的错误条件相关的数据库对象的名字。
这些函数应该用在应用希望自动错误处理的错误报告中。自<productname>PostgreSQL</> 9.3起，
完全覆盖只是为了SQLSTATE class 23中的错误而存在（违反完整约束），
但是有可能会在未来扩展。
</para>
   </note>

<para>
<!-- 
    There is an older function <function>elog</> that is still heavily used.
    An <function>elog</> call: 
-->
还有一个老一些的<function>elog</>函数，仍然在频繁使用。一个<function>elog</>调用：
<programlisting>
elog(level, "format string", ...);
</programlisting>
    <!-- 
is exactly equivalent to: 
-->
完全等效于：
<programlisting>
ereport(level, (errmsg_internal("format string", ...)));
</programlisting>
<!-- 
    Notice that the SQLSTATE error code is always defaulted, and the message
    string is not subject to translation.
    Therefore, <function>elog</> should be used only for internal errors and
    low-level debug logging.  Any message that is likely to be of interest to
    ordinary users should go through <function>ereport</>.  Nonetheless,
    there are enough internal <quote>cannot happen</> error checks in the
    system that <function>elog</> is still widely used; it is preferred for
    those messages for its notational simplicity. 
-->
请注意 SQLSTATE 错误代码总是缺省的，并且消息字符串并没有翻译。因此，
<function>elog</>应该只用于内部错误以及低层的调试日志。
任何普通用户感兴趣的消息都应该通过<function>ereport</>生成。当然，
还有大量内部的<quote>不可能发生</>的错误检查使用<function>elog</>；
因为这些信息最好还是表示得简单些好。
   </para>

   <!--
<para>
    Advice about writing good error messages can be found in
    <xref linkend="error-style-guide">.
   </para>
-->
<para>
书写好的错误消息的建议可以在<xref linkend="error-style-guide">找到。
</para>
  </sect1>

  <sect1 id="error-style-guide">
   <!--
   <title>Error Message Style Guide</title>
   -->
   <title>错误消息风格指导</title>

   <!--
<para>
    This style guide is offered in the hope of maintaining a consistent,
    user-friendly style throughout all the messages generated by
    <productname>PostgreSQL</>.
   </para>
-->
<para>
这份风格向导的目的是希望能把所有<productname>PostgreSQL</>
生成的消息维护一个一致的，用户友好的风格。
</para>

  <simplesect>
   <!--
   <title>What Goes Where</title>
   -->
   <title>何去何从</title>

   <!--
<para>
    The primary message should be short, factual, and avoid reference to
    implementation details such as specific function names.
    <quote>Short</quote> means <quote>should fit on one line under normal
    conditions</quote>.  Use a detail message if needed to keep the primary
    message short, or if you feel a need to mention implementation details
    such as the particular system call that failed. Both primary and detail
    messages should be factual.  Use a hint message for suggestions about what
    to do to fix the problem, especially if the suggestion might not always be
    applicable.
   </para>
-->
<para>
主信息应该简短，基于事实，并且避免引用类似特定函数名等这样的实现细节。
<quote>简短</quote>意味着<quote>在正常情况下应该能放在一行里</quote>。
如果需要保持主信息的简短，或者如果你觉得需要提到失败的特定系统调用之类的实现细节，
可以使用一个详细信息。主信息和详细信息都应该是基于事实的。
使用一个提示消息给出一个修补问题的提示，特别是在提出的建议可能并不总是有效的情况下。
</para>

<para>
<!-- 
    For example, instead of:
-->
比如，可以不这么写：
<programlisting>
IpcMemoryCreate: shmget(key=%d, size=%u, 0%o) failed: %m
(plus a long addendum that is basically a hint)
</programlisting>
    <!-- write: -->
而是：
<programlisting>
Primary:    could not create shared memory segment: %m
Detail:     Failed syscall was shmget(key=%d, size=%u, 0%o).
Hint:       the addendum
</programlisting>
   </para>

   <!--
<para>
    Rationale: keeping the primary message short helps keep it to the point,
    and lets clients lay out screen space on the assumption that one line is
    enough for error messages.  Detail and hint messages can be relegated to a
    verbose mode, or perhaps a pop-up error-details window.  Also, details and
    hints would normally be suppressed from the server log to save
    space. Reference to implementation details is best avoided since users
    don't know the details anyway.
   </para>
-->
<para>
基本原理：保持主消息的简短可以使它的内容有效，
并且让客户端的屏幕空间布局可以做出给错误消息保留一行就足够的假设。
而详细和提示消息可以转移到一个冗余模式里，或者使一个弹出的错误细节的窗口。
同样，详细和提示消息通常都会在服务器日志里消除，以节约空间。
对实现细节的引用最好避免，因为毕竟用户不知道细节。
</para>

  </simplesect>

  <simplesect>
   <!--
   <title>Formatting</title>
   -->
   <title>格式</title>

   <!--
<para>
    Don't put any specific assumptions about formatting into the message
    texts.  Expect clients and the server log to wrap lines to fit their own
    needs.  In long messages, newline characters (\n) can be used to indicate
    suggested paragraph breaks.  Don't end a message with a newline.  Don't
    use tabs or other formatting characters.  (In error context displays,
    newlines are automatically added to separate levels of context such as
    function calls.)
   </para>
-->
<para>
不要在消息文本里放任何有关格式化的特定的假设。
除非是客户端或者服务器日志为了符合自己需要回卷了长行。在长信息里，
新行字符(\n)可以用于分段建议。不要用新行结束一条消息。
不要使用 tab 或者其它格式化字符。在错误环境下的显示里，
系统会自动给独立级别的环境，比如，函数调用，增加新行。
</para>

   <!--
<para>
    Rationale: Messages are not necessarily displayed on terminal-type
    displays.  In GUI displays or browsers these formatting instructions are
    at best ignored.
   </para>
-->
<para>
基本原理：信息不一定非得在终端类型的显示器上显示。
在 GUI 显示或者在浏览器里，这些格式指示器最好被忽略。
</para>

  </simplesect>

  <simplesect>
   <!--
   <title>Quotation Marks</title>
   -->
   <title>引号</title>

   <!--
<para>
    English text should use double quotes when quoting is appropriate.
    Text in other languages should consistently use one kind of quotes that is
    consistent with publishing customs and computer output of other programs.
   </para>
-->
<para>
在需要的时候，英文文本应该使用双引号引起来。其它语言的文本应该一致地使用一种引号，
这种用法应该和出版习惯以及其它程序的计算输出一致。
</para>

   <!--
<para>
    Rationale: The choice of double quotes over single quotes is somewhat
    arbitrary, but tends to be the preferred use.  Some have suggested
    choosing the kind of quotes depending on the type of object according to
    SQL conventions (namely, strings single quoted, identifiers double
    quoted).  But this is a language-internal technical issue that many users
    aren't even familiar with, it won't scale to other kinds of quoted terms,
    it doesn't translate to other languages, and it's pretty pointless, too.
   </para>
-->
<para>
基本原理：选择双引号而不是单引号从某种角度来说是随机选择，但是应该是最优的选择。
有人建议过根据 SQL 传统，在不同对象类型上使用不同的引号(也就是说，
字符串单引号，标识符双引号)。但是这是一种语言内部的技巧，许多用户甚至都不熟悉，
并且也不能厌战到其它类型的引号场合，也不能翻译成其它语言，而且也没啥意义。
</para>

  </simplesect>

  <simplesect>
   <!-- 
   <title>Use of Quotes</title>
   -->
   <title>使用引号</title>

   <!--
<para>
    Use quotes always to delimit file names, user-supplied identifiers, and
    other variables that might contain words.  Do not use them to mark up
    variables that will not contain words (for example, operator names).
   </para>
-->
<para>
总是用引号分隔文件名，用户提供的标识符，以及其它可能包含字的变量。
不要用引号包含那些不会包含字的变量(比如，操作符)。
</para>

   <!--
<para>
    There are functions in the backend that will double-quote their own output
    at need (for example, <function>format_type_be()</function>).  Do not put
    additional quotes around the output of such functions.
   </para>
-->
<para>
在后端里有些函数会根据需要在他们的输出上加双引号
(比如 <function>format_type_be()</function>)。不要在这类函数的输出上加额外的引号。
</para>

   <!--
<para>
    Rationale: Objects can have names that create ambiguity when embedded in a
    message.  Be consistent about denoting where a plugged-in name starts and
    ends.  But don't clutter messages with unnecessary or duplicate quote
    marks.
   </para>
-->
<para>
基本原理：对象的名字嵌入到信息里面之后，可能造成歧义。
在一个插入的名字的起始和终止的位置保持一致。
但是不要在信息里混杂大量不必要的或者重复的引号。
</para>

  </simplesect>

  <simplesect>
   <!--
   <title>Grammar and Punctuation</title>
   -->
   <title>语法和标点</title>

   <!--
<para>
    The rules are different for primary error messages and for detail/hint
    messages:
   </para>
-->
<para>
对于主错误消息和详细/提示消息，规则不同：
</para>

   <!--
<para>
    Primary error messages: Do not capitalize the first letter.  Do not end a
    message with a period.  Do not even think about ending a message with an
    exclamation point.
   </para>
-->
<para>
主错误消息：首字母不要大写。不要用句号结束信息。绝对不要用叹号结束一条信息。
</para>

   <!--
<para>
    Detail and hint messages: Use complete sentences, and end each with
    a period.  Capitalize the first word of sentences.  Put two spaces after
    the period if another sentence follows (for English text; might be
    inappropriate in other languages).
   </para>
-->
<para>
详细和提示消息：使用完整的句子，并且用句号终止每个语句。句子首字母大写。
如有后面有另外一个句子，那么在句号后面放置两个空格（对于英文来说；
可能不适合其他语言）。
</para>

   <!--
<para>
    Error context strings: Do not capitalize the first letter and do
    not end the string with a period.  Context strings should normally
    not be complete sentences.
   </para>
-->
<para>
错误上下文字符串：不要大写首字母，不要用句号结束字符串。
上下文字符串应该通常不是完整的句子。
</para>

   <!--
<para>
    Rationale: Avoiding punctuation makes it easier for client applications to
    embed the message into a variety of grammatical contexts.  Often, primary
    messages are not grammatically complete sentences anyway.  (And if they're
    long enough to be more than one sentence, they should be split into
    primary and detail parts.)  However, detail and hint messages are longer
    and might need to include multiple sentences.  For consistency, they should
    follow complete-sentence style even when there's only one sentence.
   </para>
-->
<para>
基本原理：避免标点可以让客户端应用比较容易的把信息嵌入到各种语言环境中。并且，
主消息也经常不是完整的句子。并且，如果信息长得超过一个句子，
那么就应该把他们分裂成主信息和详细信息部分。不过，
详细和提示消息长得多并且可能需要包含多个句子。为了保持一致，
这些句子应该遵循完整句子得风格，即使他们只有一个句子。
</para>

  </simplesect>

  <simplesect>
   <!-- 
   <title>Upper Case vs. Lower Case</title>
   -->
   <title>大写字符与小写字符比较</title>

   <!--
<para>
    Use lower case for message wording, including the first letter of a
    primary error message.  Use upper case for SQL commands and key words if
    they appear in the message.
   </para>
-->
<para>
消息用语使用小写字符，包括主错误消息的首字母。
如果消息中出现 SQL 命令和关键字，用大写。
</para>

   <!--
<para>
    Rationale: It's easier to make everything look more consistent this
    way, since some messages are complete sentences and some not.
   </para>
-->
<para>
基本原理：这样很容易让所有东西看起来都一样，因为有些消息是完整的句子，有些不是。
</para>

  </simplesect>

  <simplesect>
   <!--
   <title>Avoid Passive Voice</title>
   -->
   <title>避免被动语气</title>

   <!--
<para>
    Use the active voice.  Use complete sentences when there is an acting
    subject (<quote>A could not do B</quote>).  Use telegram style without
    subject if the subject would be the program itself; do not use
    <quote>I</quote> for the program.
   </para>
-->
<para>
使用主动语气。如果有主语，那么就使用完整的句子(<quote>A不能做 B</quote>)。
如果主语是程序自己，那么就使用电报风格的语言；不要用<quote>我</quote>作为程序的主语。
</para>

   <!--
<para>
    Rationale: The program is not human.  Don't pretend otherwise.
   </para>
-->
<para>
基本原理：程序不是人。不要假装成其他的。
</para>

  </simplesect>

  <simplesect>
   <!--
   <title>Present vs. Past Tense</title>
   -->
   <title>现代时与过去时的比较</title>

   <!--
<para>
    Use past tense if an attempt to do something failed, but could perhaps
    succeed next time (perhaps after fixing some problem).  Use present tense
    if the failure is certainly permanent.
   </para>
-->
<para>
如果尝试某事失败，但可能下次尝试的时候成功(可能是修补了某些问题之后)，
那么使用过去时。如果错误肯定是永久的，那么用现代时。
</para>

<para>
<!-- 
    There is a nontrivial semantic difference between sentences of the form:
-->
下面的两个形式的句子之间有重要的语义差别：
<programlisting>
could not open file "%s": %m
</programlisting>
<!-- and: -->
和：
<programlisting>
cannot open file "%s"
</programlisting>
<!-- 
    The first one means that the attempt to open the file failed.  The
    message should give a reason, such as <quote>disk full</quote> or
    <quote>file doesn't exist</quote>.  The past tense is appropriate because
    next time the disk might not be full anymore or the file in question might
    exist. 
-->
第一个句子的意思是打开某个文件的企图失败。这个信息应该给出一个原因，
比如说<quote>磁盘满</quote>或者<quote>文件不存在</quote>之类的。
过去时的语气应该是合适的，因为下次磁盘可能不再是满的，或者有问题的文件存在了。
   </para>

   <!--
<para>
    The second form indicates that the functionality of opening the named file
    does not exist at all in the program, or that it's conceptually
    impossible.  The present tense is appropriate because the condition will
    persist indefinitely.
   </para>
-->
<para>
第二种形式表示打开指定文件的功能根本就不在程序里存在，或者是这么做概念上是错误的。
现代时语气是合适的，因为这个条件将无限期存在。
</para>

   <!--
<para>
    Rationale: Granted, the average user will not be able to draw great
    conclusions merely from the tense of the message, but since the language
    provides us with a grammar we should use it correctly.
   </para>
-->
<para>
基本原理：当然，普通用户将不会仅仅从信息的时态上得出大量的结论，
但是既然语言提供给语法，那么就应该正确使用。
</para>

  </simplesect>

  <simplesect>
   <!--
   <title>Type of the Object</title>
   -->
   <title>对象类型</title>

   <!--
<para>
    When citing the name of an object, state what kind of object it is.
   </para>
-->
<para>
在引用一个对象的名字的时候，说明它是什么类型的对象。
</para>

   <!--
<para>
    Rationale: Otherwise no one will know what <quote>foo.bar.baz</>
    refers to.
   </para>
-->
<para>
基本原理：否则，没人知道<quote>foo.bar.baz</>指的是什么。
</para>

  </simplesect>

  <simplesect>
   <!--
   <title>Brackets</title>
   -->
   <title>方括弧</title>

   <!--
<para>
    Square brackets are only to be used (1) in command synopses to denote
    optional arguments, or (2) to denote an array subscript.
   </para>
-->
<para>
方括弧只用(1)在命令概要里表示可选的参数，或者(2)表示一个数组下标。
</para>

   <!--
<para>
    Rationale: Anything else does not correspond to widely-known customary
    usage and will confuse people.
   </para>
-->
<para>
基本原理：任何其它的东西都不能对应这两种众所周知的习惯用法并且会让人混淆。
</para>

  </simplesect>

  <simplesect>
   <!--
   <title>Assembling Error Messages</title>
   -->
   <title>组装错误消息</title>

   <!--
<para>
   When a message includes text that is generated elsewhere, embed it in
   this style:
<programlisting>
could not open file %s: %m
</programlisting>
   </para>
-->
<para>
如果一个信息包含其它地方生成的文本，用下面的风格包含它：
<programlisting>
could not open file %s: %m
</programlisting>
</para>

   <!--
<para>
    Rationale: It would be difficult to account for all possible error codes
    to paste this into a single smooth sentence, so some sort of punctuation
    is needed.  Putting the embedded text in parentheses has also been
    suggested, but it's unnatural if the embedded text is likely to be the
    most important part of the message, as is often the case.
   </para>
-->
<para>
基本原理：很难估计所有可能放在这里的错误代码并且把它放在一个平滑的句子里，
所以需要某种方式的标点。也曾经建议把嵌入的文本放在圆括弧里，
但是如果嵌入文本是信息的最重要部分，那么就不太自然，而这种情况是很经常的。
</para>

  </simplesect>

  <simplesect>
   <!--
   <title>Reasons for Errors</title>
   -->
   <title>错误的原因</title>

   <!--
<para>
    Messages should always state the reason why an error occurred.
    For example:
<programlisting>
BAD:    could not open file %s
BETTER: could not open file %s (I/O failure)
</programlisting>
    If no reason is known you better fix the code.
   </para>
-->
<para>
消息应该总是说明为什么发生错误。比如：
<programlisting>
BAD:    could not open file %s
BETTER: could not open file %s (I/O failure)
</programlisting>
如果不知道原因，那么你最好修补代码。
</para>

  </simplesect>

  <simplesect>
   <!--
   <title>Function Names</title>
   -->
   <title>函数名</title>

   <!--
<para>
    Don't include the name of the reporting routine in the error text. We have
    other mechanisms for finding that out when needed, and for most users it's
    not helpful information.  If the error text doesn't make as much sense
    without the function name, reword it.
<programlisting>
BAD:    pg_atoi: error in "z": cannot parse "z"
BETTER: invalid input syntax for integer: "z"
</programlisting>
   </para>
-->
<para>
不要在错误消息里包含报告过程的名字。需要的时候，有别的机制找出这个函数，并且，
对于大多数用户，这个信息也没什么用。如果错误消息在缺少函数名的情况下没有什么意义，
那么重新措辞。
<programlisting>
BAD:    pg_atoi: error in "z": cannot parse "z"
BETTER: invalid input syntax for integer: "z"
</programlisting>
</para>

   <!--
<para>
    Avoid mentioning called function names, either; instead say what the code
    was trying to do:
<programlisting>
BAD:    open() failed: %m
BETTER: could not open file %s: %m
</programlisting>
    If it really seems necessary, mention the system call in the detail
    message.  (In some cases, providing the actual values passed to the
    system call might be appropriate information for the detail message.)
   </para>
-->
<para>
也避免提及被调用的函数名字；应该说代码试图做什么：
<programlisting>
BAD:    open() failed: %m
BETTER: could not open file %s: %m
</programlisting>
如果确实必要，在详细信息里提出系统调用。在某些场合下，
提供给系统调用的具体数值是适合放在详细信息里的。
</para>

   <!--
<para>
    Rationale: Users don't know what all those functions do.
   </para>
-->
<para>
基本原理：用户不知道这些函数都干些啥。
</para>

  </simplesect>

  <simplesect>
   <!--
   <title>Tricky Words to Avoid</title>
   -->
   <title>尽量避免的字眼</title>

  <formalpara>
   <!--
   <title>Unable</title>
   -->
    <title>Unable/不能</title>
   <!--
<para>
    <quote>Unable</quote> is nearly the passive voice.  Better use
    <quote>cannot</quote> or <quote>could not</quote>, as appropriate.
   </para>
-->
<para>
<quote>Unable/不能</quote> 几乎是被动语气。最好使用
<quote>cannot/无法</quote>或者<quote>could not</quote>。
</para>
  </formalpara>

  <formalpara>
    <!-- 
<title>Bad</title>
-->
<title>Bad/坏的</title>
   <!--
<para>
    Error messages like <quote>bad result</quote> are really hard to interpret
    intelligently.  It's better to write why the result is <quote>bad</quote>,
    e.g., <quote>invalid format</quote>.
   </para>
-->
<para>
 类似<quote>bad result/坏结果</quote>这样的错误消息真的是很难聪明地解释。
 最好写出为什么结果是<quote>bad/坏的</quote>，比如，<quote>invalid format/非法格式</quote>。
</para>
  </formalpara>

  <formalpara>
    <!--
<title>Illegal</title>
-->
<title>Illegal/非法</title>
   <!--
<para>
    <quote>Illegal</quote> stands for a violation of the law, the rest is
    <quote>invalid</quote>. Better yet, say why it's invalid.
   </para>
-->
<para>
<quote>Illegal/非法</quote>表示违反了法律，剩下的就是<quote>invalid/无效的</quote>。
但是最好还是说为什么无效。
</para>
  </formalpara>

  <formalpara>
    <!--
<title>Unknown</title> 
-->
<title>Unknown/未知</title>
   <!--
<para>
    Try to avoid <quote>unknown</quote>.  Consider <quote>error: unknown
    response</quote>.  If you don't know what the response is, how do you know
    it's erroneous? <quote>Unrecognized</quote> is often a better choice.
    Also, be sure to include the value being complained of.
<programlisting>
BAD:    unknown node type
BETTER: unrecognized node type: 42
</programlisting>
   </para>
-->
<para>
尽量避免使用<quote>unknown/未知</quote>。想想<quote>error: unknown response</quote>。
如果你不知道响应是什么，你怎么知道是错误?<quote>Unrecognized/无法识别的</quote>
通常是更好的选择。还有最好要包括被抱怨的数值。
<programlisting>
BAD:    unknown node type
BETTER: unrecognized node type: 42
</programlisting>
</para>
  </formalpara>

  <formalpara>
    <!--
<title>Find vs. Exists</title>
-->
<title>Find/找到 和 Exists/存在 比较</title>
   <!--
<para>
    If the program uses a nontrivial algorithm to locate a resource (e.g., a
    path search) and that algorithm fails, it is fair to say that the program
    couldn't <quote>find</quote> the resource.  If, on the other hand, the
    expected location of the resource is known but the program cannot access
    it there then say that the resource doesn't <quote>exist</quote>.  Using
    <quote>find</quote> in this case sounds weak and confuses the issue.
   </para>
-->
<para>
如果程序使用一个相当复杂的算法来定位一个资源(比如，一个路径搜索)，
并且算法失败了，那么说程序无法<quote>find/找到</quote>该资源是合理的。
但是，如果预期的资源位置是已知的但是程序无法在那里访问它，
那么说这个资源不<quote>exist/存在</quote>。
这种情况下用<quote>find/找到</quote>听起来语气比较弱并且会混淆事实。
</para>
  </formalpara>

  <formalpara>
    <!--
<title>May vs. Can vs. Might</title>
-->
<title>May 和 Can 和 Might 比较</title>
   <!--
<para>
    <quote>May</quote> suggests permission (e.g., "You may borrow my rake."),
    and has little use in documentation or error messages.
    <quote>Can</quote> suggests ability (e.g., "I can lift that log."),
    and <quote>might</quote> suggests possibility (e.g., "It might rain
    today.").  Using the proper word clarifies meaning and assists
    translation.
   </para>
-->
<para>
<quote>May</quote>暗示权限（如，"You may borrow my rake."），
在文档或错误消息中很少使用。<quote>Can</quote>暗示能力
（如，"I can lift that log."），<quote>might</quote>暗示可能性
（如，"It might rain today."）使用适当的单词澄清意义和帮助翻译。
</para>
  </formalpara>

  <formalpara>
    <!--
<title>Contractions</title>
-->
<title>缩写</title>
   <!--
<para>
    Avoid contractions, like <quote>can't</quote>;  use
    <quote>cannot</quote> instead.
   </para>
-->
<para>
避免缩写，像<quote>can't</quote>；使用<quote>cannot</quote>代替。
</para>
  </formalpara>

  </simplesect>

  <simplesect>
   <!--
   <title>Proper Spelling</title>
   -->
   <title>正确地拼写</title>

<para>
    <!-- 
Spell out words in full.  For instance, avoid:
-->
用单词的全拼。比如，避免下面这样的缩写：
  <itemizedlist>
   <listitem>
    <para>
     spec
    </para>
   </listitem>
   <listitem>
<para>
     stats
    </para>
   </listitem>
   <listitem>
<para>
     parens
    </para>
   </listitem>
   <listitem>
<para>
     auth
    </para>
   </listitem>
   <listitem>
<para>
     xact
    </para>
   </listitem>
  </itemizedlist>
   </para>

   <!--
<para>
    Rationale: This will improve consistency.
   </para>
-->
<para>
基本原理：这样将改善一致性。
</para>

  </simplesect>

  <simplesect>
   <!-- 
   <title>Localization</title>
   -->
   <title>本地化</title>

   <!--
<para>
    Keep in mind that error message texts need to be translated into other
    languages.  Follow the guidelines in <xref linkend="nls-guidelines">
    to avoid making life difficult for translators.
   </para>
-->
<para>
请记住，错误消息文本是需要翻译成其它语言的。遵循<xref linkend="nls-guidelines">
里面的指导以避免给翻译者造成太多麻烦。
</para>
  </simplesect>

  </sect1>

 </chapter>
