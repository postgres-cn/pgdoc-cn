<!-- doc/src/sgml/pgstattuple.sgml -->

<sect1 id="pgstattuple" xreflabel="pgstattuple">
<!--==========================orignal english content==========================
 <title>pgstattuple</title>
____________________________________________________________________________-->
 <title>pgstattuple</title>

<!--==========================orignal english content==========================
 <indexterm zone="pgstattuple">
  <primary>pgstattuple</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="pgstattuple">
  <primary>pgstattuple</primary>
 </indexterm>

<!--==========================orignal english content==========================
 <para>
  The <filename>pgstattuple</filename> module provides various functions to
  obtain tuple-level statistics.
 </para>
____________________________________________________________________________-->
 <para>
  <filename>pgstattuple</filename>模块提供多种函数来获得元组层的统计信息。
 </para>

<!--==========================orignal english content==========================
 <para>
  As these functions return detailed page-level information, only the superuser
  has EXECUTE privileges on them upon installation.  After the functions have
  been installed, users may issue <command>GRANT</command> commands to change
  the privileges on the functions to allow non-superusers to execute them. Members
  of the <literal>pg_stat_scan_tables</literal> role are granted access by default. See
  the description of the <xref linkend="sql-grant"> command for specifics.
 </para>
____________________________________________________________________________-->
 <para>
  由于这些函数返回详细的页面级信息，因此只有超级用户在安装时才具有EXECUTE特权。
  在安装函数之后，用户可以发出<command>GRANT</command>命令来更改函数的权限，
  以允许非超级用户执行它们。默认情况下，<literal>pg_stat_scan_tables</literal>
  角色的成员被授予访问权限。有关详细信息，请参阅<xref linkend="sql-grant">命令的描述。
 </para>

 <sect2>
<!--==========================orignal english content==========================
  <title>Functions</title>
____________________________________________________________________________-->
  <title>函数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
   <term>
     <indexterm>
      <primary>pgstattuple</primary>
     </indexterm>
     <function>pgstattuple(regclass) returns record</>
    </term>
____________________________________________________________________________-->
   <term>
     <function>pgstattuple(regclass) 返回 record</>
   <indexterm>
    <primary>pgstattuple</primary>
   </indexterm>    
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      <function>pgstattuple</function> returns a relation's physical length,
      percentage of <quote>dead</> tuples, and other info. This may help users
      to determine whether vacuum is necessary or not.  The argument is the
      target relation's name (optionally schema-qualified) or OID.
      For example:
<programlisting>
test=&gt; SELECT * FROM pgstattuple('pg_catalog.pg_proc');
-[ RECORD 1 ]-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-
table_len          | 458752
tuple_count        | 1470
tuple_len          | 438896
tuple_percent      | 95.67
dead_tuple_count   | 11
dead_tuple_len     | 3157
dead_tuple_percent | 0.69
free_space         | 8932
free_percent       | 1.95
</programlisting>
     The output columns are described in <xref linkend="pgstattuple-columns">.
    </para>
____________________________________________________________________________-->
     <para>
      <function>pgstattuple</function>返回一个关系的物理长度、<quote>死亡</>元组的百分比以及其他信息。这可以帮助用户决定是否需要清理。参数是目标关系的名称（可以有选择地用模式限定）或者 OID。例如：
<programlisting>
test=&gt; SELECT * FROM pgstattuple('pg_catalog.pg_proc');
-[ RECORD 1 ]------+-------
table_len          | 458752
tuple_count        | 1470
tuple_len          | 438896
tuple_percent      | 95.67
dead_tuple_count   | 11
dead_tuple_len     | 3157
dead_tuple_percent | 0.69
free_space         | 8932
free_percent       | 1.95
</programlisting>
     <xref linkend="pgstattuple-columns">中描述了输出列。
    </para>

    <table id="pgstattuple-columns">
<!--==========================orignal english content==========================
     <title><function>pgstattuple</function> Output Columns</title>
____________________________________________________________________________-->
     <title><function>pgstattuple</function> 输出列</title>
     <tgroup cols="3">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry>Column</entry>
        <entry>Type</entry>
        <entry>Description</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>列</entry>
        <entry>类型</entry>
        <entry>描述</entry>
       </row>
      </thead>

      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry><structfield>table_len</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>Physical relation length in bytes</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><structfield>table_len</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>物理关系长度，以字节计</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><structfield>tuple_count</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>Number of live tuples</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><structfield>tuple_count</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>存活元组的数量</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><structfield>tuple_len</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>Total length of live tuples in bytes</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><structfield>tuple_len</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>存活元组的总长度，以字节计</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><structfield>tuple_percent</structfield></entry>
        <entry><type>float8</type></entry>
        <entry>Percentage of live tuples</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><structfield>tuple_percent</structfield></entry>
        <entry><type>float8</type></entry>
        <entry>存活元组的百分比</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><structfield>dead_tuple_count</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>Number of dead tuples</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><structfield>dead_tuple_count</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>死亡元组的数量</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><structfield>dead_tuple_len</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>Total length of dead tuples in bytes</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><structfield>dead_tuple_len</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>死亡元组的总长度，以字节计</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><structfield>dead_tuple_percent</structfield></entry>
        <entry><type>float8</type></entry>
        <entry>Percentage of dead tuples</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><structfield>dead_tuple_percent</structfield></entry>
        <entry><type>float8</type></entry>
        <entry>死亡元组的百分比</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><structfield>free_space</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>Total free space in bytes</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><structfield>free_space</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>空闲空间总量，以字节计</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><structfield>free_percent</structfield></entry>
        <entry><type>float8</type></entry>
        <entry>Percentage of free space</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><structfield>free_percent</structfield></entry>
        <entry><type>float8</type></entry>
        <entry>空闲空间的百分比</entry>
       </row>

      </tbody>
     </tgroup>
    </table>

    <note>
<!--==========================orignal english content==========================
     <para>
      The <literal>table_len</literal> will always be greater than the sum
      of the <literal>tuple_len</literal>, <literal>dead_tuple_len</literal>
      and <literal>free_space</literal>. The difference is accounted for by
      fixed page overhead, the per-page table of pointers to tuples, and
      padding to ensure that tuples are correctly aligned.
     </para>
____________________________________________________________________________-->
     <para>
      <literal>table_len</literal>将总是比<literal>tuple_len</literal>、
	  <literal>dead_tuple_len</literal>和<literal>free_space</literal>的和要大。
	  不同之处在于固定的页面开销，每页指向元组的指针表和填充以确保元组正确对齐。
     </para>
    </note>

<!--==========================orignal english content==========================
    <para>
     <function>pgstattuple</function> acquires only a read lock on the
     relation. So the results do not reflect an instantaneous snapshot;
     concurrent updates will affect them.
    </para>
____________________________________________________________________________-->
    <para>
     <function>pgstattuple</function>只要求在关系上的一个读锁。因此结果不能反映一个即时快照，并发更新将影响结果。
    </para>

<!--==========================orignal english content==========================
    <para>
     <function>pgstattuple</function> judges a tuple is <quote>dead</> if
     <function>HeapTupleSatisfiesDirty</> returns false.
    </para>
____________________________________________________________________________-->
    <para>
     如果<function>HeapTupleSatisfiesDirty</>返回假，<function>pgstattuple</function>就判定一个元组是<quote>死亡的</>。
    </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term>
     <function>pgstattuple(text) returns record</>
    </term>
____________________________________________________________________________-->
    <term>
     <function>pgstattuple(text) 返回 record</>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      This is the same as <function>pgstattuple(regclass)</function>, except
      that the target relation is specified as TEXT. This function is kept
      because of backward-compatibility so far, and will be deprecated in
      some future release.
     </para>
____________________________________________________________________________-->
     <para>
      与<function>pgstattuple(regclass)</function>相同，只不过通过  TEXT 指定目标关系。这个函数只是为了向后兼容而保留，在未来的发布中将会被废除。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term>
    <indexterm>
     <primary>pgstatindex</primary>
    </indexterm>
     <function>pgstatindex(regclass) returns record</>
    </term>
____________________________________________________________________________-->
    <term>
    <indexterm>
     <primary>pgstatindex</primary>
    </indexterm>
     <function>pgstatindex(regclass) 返回 record</>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      <function>pgstatindex</function> returns a record showing information
      about a B-tree index.  For example:
<programlisting>
test=&gt; SELECT * FROM pgstatindex('pg_cast_oid_index');
-[ RECORD 1 ]-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;
version            | 2
tree_level         | 0
index_size         | 16384
root_block_no      | 1
internal_pages     | 0
leaf_pages         | 1
empty_pages        | 0
deleted_pages      | 0
avg_leaf_density   | 54.27
leaf_fragmentation | 0
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      <function>pgstatindex</function>返回一个记录显示有关一个 B-树索引的信息。例如：
<programlisting>
test=&gt; SELECT * FROM pgstatindex('pg_cast_oid_index');
-[ RECORD 1 ]------+------
version            | 2
tree_level         | 0
index_size         | 16384
root_block_no      | 1
internal_pages     | 0
leaf_pages         | 1
empty_pages        | 0
deleted_pages      | 0
avg_leaf_density   | 54.27
leaf_fragmentation | 0
</programlisting>
     </para>

<!--==========================orignal english content==========================
    <para>
     The output columns are:

    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Column</entry>
        <entry>Type</entry>
        <entry>Description</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><structfield>version</structfield></entry>
        <entry><type>integer</type></entry>
        <entry>B-tree version number</entry>
       </row>

       <row>
        <entry><structfield>tree_level</structfield></entry>
        <entry><type>integer</type></entry>
        <entry>Tree level of the root page</entry>
       </row>

       <row>
        <entry><structfield>index_size</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>Total index size in bytes</entry>
       </row>

       <row>
        <entry><structfield>root_block_no</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>Location of root page (zero if none)</entry>
       </row>

       <row>
        <entry><structfield>internal_pages</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>Number of <quote>internal</> (upper-level) pages</entry>
       </row>

       <row>
        <entry><structfield>leaf_pages</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>Number of leaf pages</entry>
       </row>

       <row>
        <entry><structfield>empty_pages</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>Number of empty pages</entry>
       </row>

       <row>
        <entry><structfield>deleted_pages</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>Number of deleted pages</entry>
       </row>

       <row>
        <entry><structfield>avg_leaf_density</structfield></entry>
        <entry><type>float8</type></entry>
        <entry>Average density of leaf pages</entry>
       </row>

       <row>
        <entry><structfield>leaf_fragmentation</structfield></entry>
        <entry><type>float8</type></entry>
        <entry>Leaf page fragmentation</entry>
       </row>

      </tbody>
     </tgroup>
    </informaltable>
    </para>
____________________________________________________________________________-->
    <para>
     输出列是：

    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>列</entry>
        <entry>类型</entry>
        <entry>描述</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><structfield>version</structfield></entry>
        <entry><type>integer</type></entry>
        <entry>B-树 版本号</entry>
       </row>

       <row>
        <entry><structfield>tree_level</structfield></entry>
        <entry><type>integer</type></entry>
        <entry>根页的树层次</entry>
       </row>

       <row>
        <entry><structfield>index_size</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>以字节计的索引总尺寸</entry>
       </row>

       <row>
        <entry><structfield>root_block_no</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>根页的位置（如果没有则为零）</entry>
       </row>

       <row>
        <entry><structfield>internal_pages</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry><quote>内部</>（上层）页面的数量</entry>
       </row>

       <row>
        <entry><structfield>leaf_pages</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>叶子页的数量</entry>
       </row>

       <row>
        <entry><structfield>empty_pages</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>空页的数量</entry>
       </row>

       <row>
        <entry><structfield>deleted_pages</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>删除页的数量</entry>
       </row>

       <row>
        <entry><structfield>avg_leaf_density</structfield></entry>
        <entry><type>float8</type></entry>
        <entry>叶子页的平均密度</entry>
       </row>

       <row>
        <entry><structfield>leaf_fragmentation</structfield></entry>
        <entry><type>float8</type></entry>
        <entry>叶子页碎片</entry>
       </row>

      </tbody>
     </tgroup>
    </informaltable>
    </para>

<!--==========================orignal english content==========================
    <para>
     The reported <literal>index_size</> will normally correspond to one more
     page than is accounted for by <literal>internal_pages + leaf_pages +
     empty_pages + deleted_pages</literal>, because it also includes the
     index's metapage.
    </para>
____________________________________________________________________________-->
    <para>
     报告的<literal>index_size</>通常对应于<literal>internal_pages + leaf_pages + empty_pages + deleted_pages</literal>加一，因为它还包括索引的元页。
    </para>
    
<!--==========================orignal english content==========================
    <para>
     As with <function>pgstattuple</>, the results are accumulated
     page-by-page, and should not be expected to represent an
     instantaneous snapshot of the whole index.
    </para>
____________________________________________________________________________-->
    <para>
     对于<function>pgstattuple</>，结果是一页一页累计的并且不要期望结果会表示整个索引的一个即时快照。
    </para>
    </listitem>
   </varlistentry>
   
   <varlistentry>
<!--==========================orignal english content==========================
   <term>
     <function>pgstatindex(text) returns record</>
    </term>
____________________________________________________________________________-->
   <term>
     <function>pgstatindex(text) returns record</>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      This is the same as <function>pgstatindex(regclass)</function>, except
      that the target index is specified as TEXT. This function is kept
      because of backward-compatibility so far, and will be deprecated in
      some future release.
     </para>
____________________________________________________________________________-->
     <para>
      与<function>pgstatindex(regclass)</function>相同，只不过通过  TEXT 指定目标索引。这个函数只是为了向后兼容而保留，在未来的某个发布中将会被废除。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term>
     <indexterm>
      <primary>pgstatginindex</primary>
     </indexterm>
     <function>pgstatginindex(regclass) returns record</>
    </term>
____________________________________________________________________________-->
    <term>
     <indexterm>
      <primary>pgstatginindex</primary>
     </indexterm>
     <function>pgstatginindex(regclass) 返回 record</>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      <function>pgstatginindex</function> returns a record showing information
      about a GIN index.  For example:
<programlisting>
test=&gt; SELECT * FROM pgstatginindex('test_gin_index');
-[ RECORD 1 ]-&minus;+-&minus;
version        | 1
pending_pages  | 0
pending_tuples | 0
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      <function>pgstatginindex</function>返回一个记录显示有关一个 GIN 索引的信息。例如：
<programlisting>
test=&gt; SELECT * FROM pgstatginindex('test_gin_index');
-[ RECORD 1 ]--+--
version        | 1
pending_pages  | 0
pending_tuples | 0
</programlisting>
     </para>

<!--==========================orignal english content==========================
    <para>
     The output columns are:

    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Column</entry>
        <entry>Type</entry>
        <entry>Description</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><structfield>version</structfield></entry>
        <entry><type>integer</type></entry>
        <entry>GIN version number</entry>
       </row>

       <row>
        <entry><structfield>pending_pages</structfield></entry>
        <entry><type>integer</type></entry>
        <entry>Number of pages in the pending list</entry>
       </row>

       <row>
        <entry><structfield>pending_tuples</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>Number of tuples in the pending list</entry>
       </row>

      </tbody>
     </tgroup>
    </informaltable>
    </para>
____________________________________________________________________________-->
    <para>
     输出列是：

    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>列</entry>
        <entry>类型</entry>
        <entry>描述</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><structfield>version</structfield></entry>
        <entry><type>integer</type></entry>
        <entry>GIN 版本号</entry>
       </row>

       <row>
        <entry><structfield>pending_pages</structfield></entry>
        <entry><type>integer</type></entry>
        <entry>待处理列表中的页面数</entry>
       </row>

       <row>
        <entry><structfield>pending_tuples</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>待处理列表中的元组数</entry>
       </row>

      </tbody>
     </tgroup>
    </informaltable>
    </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term>
     <indexterm>
      <primary>pgstathashindex</primary>
     </indexterm>
     <function>pgstathashindex(regclass) returns record</>
    </term>
____________________________________________________________________________-->
    <term>
     <indexterm>
      <primary>pgstathashindex</primary>
     </indexterm>
     <function>pgstathashindex(regclass) returns record</>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      <function>pgstathashindex</function> returns a record showing information
      about a HASH index.  For example:
<programlisting>
test=&gt; select * from pgstathashindex('con_hash_index');
-[ RECORD 1 ]-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
version        | 4
bucket_pages   | 33081
overflow_pages | 0
bitmap_pages   | 1
unused_pages   | 32455
live_items     | 10204006
dead_items     | 0
free_percent   | 61.8005949100872
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      <function>pgstathashindex</function>返回一个显示HASH索引信息的记录。例如：
<programlisting>
test=&gt; select * from pgstathashindex('con_hash_index');
-[ RECORD 1 ]--+-----------------
version        | 4
bucket_pages   | 33081
overflow_pages | 0
bitmap_pages   | 1
unused_pages   | 32455
live_items     | 10204006
dead_items     | 0
free_percent   | 61.8005949100872
</programlisting>
     </para>

<!--==========================orignal english content==========================
    <para>
     The output columns are:

    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Column</entry>
        <entry>Type</entry>
        <entry>Description</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><structfield>version</structfield></entry>
        <entry><type>integer</type></entry>
        <entry>HASH version number</entry>
       </row>

       <row>
        <entry><structfield>bucket_pages</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>Number of bucket pages</entry>
       </row>

       <row>
        <entry><structfield>overflow_pages</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>Number of overflow pages</entry>
       </row>

       <row>
        <entry><structfield>bitmap_pages</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>Number of bitmap pages</entry>
       </row>

       <row>
        <entry><structfield>unused_pages</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>Number of unused pages</entry>
       </row>

       <row>
        <entry><structfield>live_items</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>Number of live tuples</entry>
       </row>

       <row>
        <entry><structfield>dead_tuples</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>Number of dead tuples</entry>
       </row>

       <row>
        <entry><structfield>free_percent</structfield></entry>
        <entry><type>float</type></entry>
        <entry>Percentage of free space</entry>
       </row>

      </tbody>
     </tgroup>
    </informaltable>
    </para>
____________________________________________________________________________-->
    <para>
     输出字段是：

    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>字段</entry>
        <entry>类型</entry>
        <entry>描述</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><structfield>version</structfield></entry>
        <entry><type>integer</type></entry>
        <entry>HASH版本号</entry>
       </row>

       <row>
        <entry><structfield>bucket_pages</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>存储桶页面的数量</entry>
       </row>

       <row>
        <entry><structfield>overflow_pages</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>溢出页面的数量</entry>
       </row>

       <row>
        <entry><structfield>bitmap_pages</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>位图页数</entry>
       </row>

       <row>
        <entry><structfield>unused_pages</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>未使用页面的数量</entry>
       </row>

       <row>
        <entry><structfield>live_items</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>活元组的数量</entry>
       </row>

       <row>
        <entry><structfield>dead_tuples</structfield></entry>
        <entry><type>bigint</type></entry>
        <entry>死元组的数量</entry>
       </row>

       <row>
        <entry><structfield>free_percent</structfield></entry>
        <entry><type>float</type></entry>
        <entry>自由空间的百分比</entry>
       </row>

      </tbody>
     </tgroup>
    </informaltable>
    </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term>
     <indexterm>
      <primary>pg_relpages</primary>
     </indexterm>
     <function>pg_relpages(regclass) returns bigint</>
    </term>
____________________________________________________________________________-->
    <term>
     <indexterm>
      <primary>pg_relpages</primary>
     </indexterm>
     <function>pg_relpages(regclass) 返回 bigint</>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      <function>pg_relpages</function> returns the number of pages in the
      relation.
     </para>
____________________________________________________________________________-->
     <para>
      <function>pg_relpages</function>返回关系中的页面数。
     </para>
    </listitem>
   </varlistentry>
   
   <varlistentry>
<!--==========================orignal english content==========================
    <term>
     <function>pg_relpages(text) returns bigint</>
    </term>
____________________________________________________________________________-->
    <term>
     <function>pg_relpages(text) returns bigint</>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      This is the same as <function>pg_relpages(regclass)</function>, except
      that the target relation is specified as TEXT. This function is kept
      because of backward-compatibility so far, and will be deprecated in
      some future release.
     </para>
____________________________________________________________________________-->
     <para>
      与<function>pg_relpages(regclass)</function>相同，只不过用  TEXT 来 指定目标关系。这个函数只是为了向后兼容而保留，在未来的某个发布中将会被废除。
     </para>
    </listitem>
   </varlistentry>
   
   <varlistentry>
<!--==========================orignal english content==========================
    <term>
     <indexterm>
      <primary>pgstattuple_approx</primary>
     </indexterm>
     <function>pgstattuple_approx(regclass) returns record</>
    </term>
____________________________________________________________________________-->
    <term>
     <indexterm>
      <primary>pgstattuple_approx</primary>
     </indexterm>
     <function>pgstattuple_approx(regclass) returns record</>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      <function>pgstattuple_approx</function> is a faster alternative to
      <function>pgstattuple</function> that returns approximate results.
      The argument is the target relation's name or OID.
      For example:
<programlisting>
test=&gt; SELECT * FROM pgstattuple_approx('pg_catalog.pg_proc'::regclass);
-[ RECORD 1 ]-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-
table_len            | 573440
scanned_percent      | 2
approx_tuple_count   | 2740
approx_tuple_len     | 561210
approx_tuple_percent | 97.87
dead_tuple_count     | 0
dead_tuple_len       | 0
dead_tuple_percent   | 0
approx_free_space    | 11996
approx_free_percent  | 2.09
</programlisting>
      The output columns are described in <xref linkend="pgstatapprox-columns">.
     </para>
____________________________________________________________________________-->
     <para>
      <function>pgstattuple_approx</function>是<function>pgstattuple</function>的一个更加快速的替代品，它返回近似的结果。参数是目标关系的 OID 或者名称。例如：
<programlisting>
test=&gt; SELECT * FROM pgstattuple_approx('pg_catalog.pg_proc'::regclass);
-[ RECORD 1 ]--------+-------
table_len            | 573440
scanned_percent      | 2
approx_tuple_count   | 2740
approx_tuple_len     | 561210
approx_tuple_percent | 97.87
dead_tuple_count     | 0
dead_tuple_len       | 0
dead_tuple_percent   | 0
approx_free_space    | 11996
approx_free_percent  | 2.09
</programlisting>
      输出列在<xref linkend="pgstatapprox-columns">中描述。
     </para>

<!--==========================orignal english content==========================
     <para>
      Whereas <function>pgstattuple</function> always performs a
      full-table scan and returns an exact count of live and dead tuples
      (and their sizes) and free space, <function>pgstattuple_approx</function>
      tries to avoid the full-table scan and returns exact dead tuple
      statistics along with an approximation of the number and
      size of live tuples and free space.
     </para>
____________________________________________________________________________-->
     <para>
      鉴于<function>pgstattuple</function>总是执行全表扫描并且返回存活和死亡元组的准确计数、尺寸和空闲空间，<function>pgstattuple_approx</function>尝试避免全表扫描并且返回死亡元组的准确统计信息，以及存活元组和空闲空间的近似数量及尺寸。
     </para>

<!--==========================orignal english content==========================
     <para>
      It does this by skipping pages that have only visible tuples
      according to the visibility map (if a page has the corresponding VM
      bit set, then it is assumed to contain no dead tuples). For such
      pages, it derives the free space value from the free space map, and
      assumes that the rest of the space on the page is taken up by live
      tuples.
     </para>
____________________________________________________________________________-->
     <para>
      这个函数通过根据可见性映射跳过只包含可见元组的页面来实现这一目的（如果一个页面对应的 VM 位被设置，那么就说明它不含有死亡元组）。对于这样的额页面，它会从空闲空间映射中得到空闲空间值，并且假定该页面上的剩余空间由存活元组占据。
     </para>

<!--==========================orignal english content==========================
     <para>
      For pages that cannot be skipped, it scans each tuple, recording its
      presence and size in the appropriate counters, and adding up the
      free space on the page. At the end, it estimates the total number of
      live tuples based on the number of pages and tuples scanned (in the
      same way that VACUUM estimates pg_class.reltuples).
     </para>
____________________________________________________________________________-->
     <para>
      对于不能被跳过的页面，它会扫描每个元组，在合适的计数器中记录它的存在以及尺寸，并且统计该页面上的空闲空间。最后，它会基于已扫描的页面和元组数量来估计存活元组的总数（采用与 VACUUM 估计 pg_class.reltuples 时相同的方法）。
     </para>

     <table id="pgstatapprox-columns">
<!--==========================orignal english content==========================
      <title><function>pgstattuple_approx</function> Output Columns</title>
____________________________________________________________________________-->
      <title><function>pgstattuple_approx</function>输出列</title>
      <tgroup cols="3">
       <thead>
<!--==========================orignal english content==========================
        <row>
         <entry>Column</entry>
         <entry>Type</entry>
         <entry>Description</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>列</entry>
         <entry>类型</entry>
         <entry>描述</entry>
        </row>
       </thead>

       <tbody>
<!--==========================orignal english content==========================
        <row>
         <entry><structfield>table_len</structfield></entry>
         <entry><type>bigint</type></entry>
         <entry>Physical relation length in bytes (exact)</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><structfield>table_len</structfield></entry>
         <entry><type>bigint</type></entry>
         <entry>以字节计的物理关系长度（准确）</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><structfield>scanned_percent</structfield></entry>
         <entry><type>float8</type></entry>
         <entry>Percentage of table scanned</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><structfield>scanned_percent</structfield></entry>
         <entry><type>float8</type></entry>
         <entry>已扫描表的百分比</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><structfield>approx_tuple_count</structfield></entry>
         <entry><type>bigint</type></entry>
         <entry>Number of live tuples (estimated)</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><structfield>approx_tuple_count</structfield></entry>
         <entry><type>bigint</type></entry>
         <entry>存活元组的数量（估计）</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><structfield>approx_tuple_len</structfield></entry>
         <entry><type>bigint</type></entry>
         <entry>Total length of live tuples in bytes (estimated)</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><structfield>approx_tuple_len</structfield></entry>
         <entry><type>bigint</type></entry>
         <entry>以字节计的存活元组总长度（估计）</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><structfield>approx_tuple_percent</structfield></entry>
         <entry><type>float8</type></entry>
         <entry>Percentage of live tuples</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><structfield>approx_tuple_percent</structfield></entry>
         <entry><type>float8</type></entry>
         <entry>存活元组的百分比</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><structfield>dead_tuple_count</structfield></entry>
         <entry><type>bigint</type></entry>
         <entry>Number of dead tuples (exact)</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><structfield>dead_tuple_count</structfield></entry>
         <entry><type>bigint</type></entry>
         <entry>死亡元组的数量（准确）</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><structfield>dead_tuple_len</structfield></entry>
         <entry><type>bigint</type></entry>
         <entry>Total length of dead tuples in bytes (exact)</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><structfield>dead_tuple_len</structfield></entry>
         <entry><type>bigint</type></entry>
         <entry>以字节计的死亡元组总长度（准确）</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><structfield>dead_tuple_percent</structfield></entry>
         <entry><type>float8</type></entry>
         <entry>Percentage of dead tuples</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><structfield>dead_tuple_percent</structfield></entry>
         <entry><type>float8</type></entry>
         <entry>死亡元组的百分比</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><structfield>approx_free_space</structfield></entry>
         <entry><type>bigint</type></entry>
         <entry>Total free space in bytes (estimated)</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><structfield>approx_free_space</structfield></entry>
         <entry><type>bigint</type></entry>
         <entry>以字节计的总空闲空间（估计）</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><structfield>approx_free_percent</structfield></entry>
         <entry><type>float8</type></entry>
         <entry>Percentage of free space</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><structfield>approx_free_percent</structfield></entry>
         <entry><type>float8</type></entry>
         <entry>空闲空间的百分比</entry>
        </row>

       </tbody>
      </tgroup>
     </table>

<!--==========================orignal english content==========================
     <para>
      In the above output, the free space figures may not match the
      <function>pgstattuple</function> output exactly, because the free
      space map gives us an exact figure, but is not guaranteed to be
      accurate to the byte.
     </para>
____________________________________________________________________________-->
     <para>
      在上述的输出中，空闲空间数字可能不完全匹配<function>pgstattuple</function>的输出，这是因为空闲空间映射会给出一个准确的数字，但是这个数字不能保证是一个准确的字节数。
     </para>

    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

 <sect2>
<!--==========================orignal english content==========================
  <title>Authors</title>
____________________________________________________________________________-->
  <title>作者</title>

<!--==========================orignal english content==========================
  <para>
   Tatsuo Ishii, Satoshi Nagayasu and Abhijit Menon-Sen
  </para>
____________________________________________________________________________-->
  <para>
   Tatsuo Ishii, Satoshi Nagayasu 和 Abhijit Menon-Sen
  </para>
 </sect2>

</sect1>
