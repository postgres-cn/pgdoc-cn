<!-- doc/src/sgml/spi.sgml -->

<chapter id="spi">
 <!--
 <title>Server Programming Interface</title>
 -->
 <title>服务器编程接口</title>

 <indexterm zone="spi">
  <primary>SPI</primary>
 </indexterm>

 <!--
<para>
  The <firstterm>Server Programming Interface</firstterm>
  (<acronym>SPI</acronym>) gives writers of user-defined
  <acronym>C</acronym> functions the ability to run
  <acronym>SQL</acronym> commands inside their functions.
  <acronym>SPI</acronym> is a set of
  interface functions to simplify access to the parser, planner,
  and executor. <acronym>SPI</acronym> also does some
  memory management.
 </para>
-->
<para>
<firstterm>服务器编程接口</firstterm>(<acronym>SPI</acronym>)
给在用户定义的<acronym>C</acronym>函数里面运行<acronym>SQL</acronym>
查询的能力。<acronym>SQL</acronym>是一套接口函数，用于简化对分析器、
规划器和执行器的访问。<acronym>SQL</acronym>还进行一些内存管理的工作。
</para>

 <note>
  <!--
<para>
   The available procedural languages provide various means to
   execute SQL commands from procedures.  Most of these facilities are
   based on SPI, so this documentation might be of use for users
   of those languages as well.
  </para>
-->
<para>
过程语言的存在也提供了其它的一些在过程里执行 SQL 命令的方法。
这些语言中的大部分本身就是基于 SPI 的，
因此这份文档可能会对那些语言的用户同样有帮助。
</para>
 </note>

 <!--
<para>
  To avoid misunderstanding we'll use the term <quote>function</quote>
  when we speak of <acronym>SPI</acronym> interface functions and
  <quote>procedure</quote> for a user-defined C-function that is
  using <acronym>SPI</acronym>.
 </para>
-->
<para>
为了避免混淆，将使用术语<quote>函数</quote>(function)来代表
<acronym>SPI</acronym>接口函数，用<quote>过程</quote>(procedure)
代表用户用<acronym>SPI</acronym>定义的 C 函数。
</para>

 <!--
<para>
  Note that if a command invoked via SPI fails, then control will not be
  returned to your procedure.  Rather, the
  transaction or subtransaction in which your procedure executes will be
  rolled back.  (This might seem surprising given that the SPI functions mostly
  have documented error-return conventions.  Those conventions only apply
  for errors detected within the SPI functions themselves, however.)
  It is possible to recover control after an error by establishing your own
  subtransaction surrounding SPI calls that might fail.  This is not currently
  documented because the mechanisms required are still in flux.
 </para>
-->
<para>
注意，如果一条通过 SPI 调用的命令失败，那么控制不会返回到你的过程中。
取而代之的是，你的过程执行所在的事务或者子事务全部回滚。
这一点看起来可能很奇怪，因为大多数 SPI 函数的文档里都有错误返回习惯。
不过，那些习惯只适用于在 SPI 函数自己内部检测到的错误。
可以通过在你自己的可能失败的 SPI 调用周围建立一个子事务的方法来在错误之后恢复控制。
目前还没有写这方面的文档，因为所需要的机制仍然在变化。
</para>

 <!--
<para>
  <acronym>SPI</acronym> functions return a nonnegative result on
  success (either via a returned integer value or in the global
  variable <varname>SPI_result</varname>, as described below).  On
  error, a negative result or <symbol>NULL</symbol> will be returned.
 </para>
-->
<para>
如果执行成功了，<acronym>SPI</acronym>函数返回一个非负结果
(或者通过返回一个整数值或放在全局变量<varname>SPI_result</varname>里，
像下面描述的那样)。出错时，返回一个负数或<symbol>NULL</symbol>结果。
</para>

 <!--
<para>
  Source code files that use SPI must include the header file
  <filename>executor/spi.h</filename>.
 </para>
-->
<para>
使用 SPI 的源代码文件必须包含头文件<filename>executor/spi.h</filename>。
</para>


<sect1 id="spi-interface">
 <!--
 <title>Interface Functions</title>
 -->
 <title>接口函数</title>

 <refentry id="spi-spi-connect">
  <indexterm><primary>SPI_connect</primary></indexterm>
  <refmeta>
   <refentrytitle>SPI_connect</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>SPI_connect</refname>
   <!--
   <refpurpose>connect a procedure to the SPI manager</refpurpose>
   -->
   <refpurpose>把一个过程与 SPI 管理器连接起来</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
int SPI_connect(void)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_connect</function> opens a connection from a
   procedure invocation to the SPI manager.  You must call this
   function if you want to execute commands through SPI.  Some utility
   SPI functions can be called from unconnected procedures.
  </para>
-->
<para>
<function>SPI_connect</function>打开一个从过程调用到 SPI 管理器的连接。
如果你需要通过 SPI 执行命令，你就必需调用这个函数。
有些工具类 SPI 函数可以从未连接的过程中调用。
</para>

  <!--
<para>
   If your procedure is already connected,
   <function>SPI_connect</function> will return the error code
   <returnvalue>SPI_ERROR_CONNECT</returnvalue>.  This could happen if
   a procedure that has called <function>SPI_connect</function>
   directly calls another procedure that calls
   <function>SPI_connect</function>.  While recursive calls to the
   <acronym>SPI</acronym> manager are permitted when an SQL command
   called through SPI invokes another function that uses
   <acronym>SPI</acronym>, directly nested calls to
   <function>SPI_connect</function> and
   <function>SPI_finish</function> are forbidden.
   (But see <function>SPI_push</function> and <function>SPI_pop</function>.)
  </para>
-->
<para>
如果你的过程已经连接了，那么<function>SPI_connect</function>将返回一个
<returnvalue>SPI_ERROR_CONNECT</returnvalue>错误消息。
请注意如果一个过程已经调用了<function>SPI_connect</function>
然后它直接调用另外一个又会调用<function>SPI_connect</function>
的过程的时候也会发生这种问题。尽管以一个 SQL 命令里调用另外一个使用
<acronym>SPI</acronym>的函数的形式对<acronym>SPI</acronym>
管理器进行递归调用是允许的，但是直接的嵌套调用<function>SPI_connect</function>
和<function>SPI_finish</function>是不允许的(不过，可以看看
<function>SPI_push</function>和<function>SPI_pop</function>)。
</para>
 </refsect1>

 <refsect1>
  <!-- 
  <title>Return Value</title>
  -->
  <title>返回值</title>

  <variablelist>
   <varlistentry>
    <term><symbol>SPI_OK_CONNECT</symbol></term>
    <listitem>
     <!--
<para>
      on success
     </para>
-->
<para>
成功时
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><symbol>SPI_ERROR_CONNECT</symbol></term>
    <listitem>
     <!--
<para>
      on error
     </para>
-->
<para>
失败时
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-finish">
 <indexterm><primary>SPI_finish</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_finish</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_finish</refname>
  <!--
  <refpurpose>disconnect a procedure from the SPI manager</refpurpose>
  -->
  <refpurpose>把一个过程与 SPI 管理器断开</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
int SPI_finish(void)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_finish</function> closes an existing connection to
   the SPI manager.  You must call this function after completing the
   SPI operations needed during your procedure's current invocation.
   You do not need to worry about making this happen, however, if you
   abort the transaction via <literal>elog(ERROR)</literal>.  In that
   case SPI will clean itself up automatically.
  </para>
-->
<para>
<function>SPI_finish</function>关闭一个现有的到 SPI 管理器的连接。
在完成你的过程的当前调用所必须的 SPI 操作之后，你必须调用这个函数。
不过，如果你通过<literal>elog(ERROR)</literal>退出事务，
那么你就不需要担心这件事情。在这种情况下，SPI 将自动清理干净。
</para>

  <!--
<para>
   If <function>SPI_finish</function> is called without having a valid
   connection, it will return <symbol>SPI_ERROR_UNCONNECTED</symbol>.
   There is no fundamental problem with this; it means that the SPI
   manager has nothing to do.
  </para>
-->
<para>
如果<function>SPI_finish</function>是在当前没有有效连接的情况下被调用的，
你可能会得到一个<symbol>SPI_ERROR_UNCONNECTED</symbol>的返回。
这样做没有什么根本性问题，这意味着 SPI 管理器不做任何事情。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>

  <variablelist>
   <varlistentry>
    <term><symbol>SPI_OK_FINISH</symbol></term>
    <listitem>
     <!--
<para>
      if properly disconnected
     </para>
-->
<para>
如果正常断开
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
    <listitem>
     <!--
<para>
      if called from an unconnected procedure
     </para>
-->
<para>
如果从一个未连接的过程调用
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-push">
 <indexterm><primary>SPI_push</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_push</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_push</refname>
  <!--
  <refpurpose>push SPI stack to allow recursive SPI usage</refpurpose>
  -->
  <refpurpose> 对 SPI 堆栈进行压栈操作以允许递归的 SPI 使用</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
void SPI_push(void)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_push</function> should be called before executing another
   procedure that might itself wish to use SPI.
   After <function>SPI_push</function>, SPI is no longer in a
   <quote>connected</> state, and SPI function calls will be rejected unless
   a fresh <function>SPI_connect</function> is done.  This ensures a clean
   separation between your procedure's SPI state and that of another procedure
   you call.  After the other procedure returns, call
   <function>SPI_pop</function> to restore access to your own SPI state.
  </para>
-->
<para>
在执行另外一个可能也使用了 SPI 的过程之前，应该调用<function>SPI_push</function>。
之后，SPI 不再是<quote>已连接</>状态，除非再次进行<function>SPI_push</function>，
否则 SPI 函数调用将被拒绝。这样就保证了你的过程的 SPI
状态和另外一个你调用的过程的状态之间的干净的隔离。在另外一个过程返回后，
调用<function>SPI_pop</function>恢复对你自己的 SPI 状态的访问。
</para>

  <!--
<para>
   Note that <function>SPI_execute</function> and related functions
   automatically do the equivalent of <function>SPI_push</function> before
   passing control back to the SQL execution engine, so it is not necessary
   for you to worry about this when using those functions.
   Only when you are directly calling arbitrary code that might contain
   <function>SPI_connect</function> calls do you need to issue
   <function>SPI_push</function> and <function>SPI_pop</function>.
  </para>
-->
<para>
请注意<function>SPI_execute</function>和相关的函数在把控制交回 SQL 
执行引擎之前自动做与<function>SPI_push</function>相当的工作，
因此你在使用这些函数的时候不用担心这些。只有在你直接调用任意可能包含
<function>SPI_connect</function>调用的代码的时候，你才需要发出
<function>SPI_push</function>和<function>SPI_pop</function>。
</para>
 </refsect1>

</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-pop">
 <indexterm><primary>SPI_pop</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_pop</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_pop</refname>
  <!--
  <refpurpose>pop SPI stack to return from recursive SPI usage</refpurpose>
  -->
  <refpurpose>弹出 SPI 堆栈以从递归的 SPI 使用中返回</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
void SPI_pop(void)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_pop</function> pops the previous environment from the
   SPI call stack.  See <function>SPI_push</function>.
  </para>
-->
<para>
<function>SPI_pop</function>从 SPI 调用堆栈里弹出前面的环境。
参阅<function>SPI_push</function>。
</para>
 </refsect1>

</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-execute">
 <indexterm><primary>SPI_execute</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_execute</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_execute</refname>
  <!--
  <refpurpose>execute a command</refpurpose>
  -->
  <refpurpose>执行一条命令</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
int SPI_execute(const char * <parameter>command</parameter>, bool <parameter>read_only</parameter>, long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_execute</function> executes the specified SQL command
   for <parameter>count</parameter> rows.  If <parameter>read_only</parameter>
   is <literal>true</>, the command must be read-only, and execution overhead
   is somewhat reduced.
  </para>
-->
<para>
<function>SPI_execute</function>执行声明的 SQL 命令获取<parameter>count</parameter>
行。如果<parameter>read_only</parameter>为<literal>true</>，命令必须是只读的，
因此可以略微降低一些执行的开销。
</para>

  <!--
<para>
   This function can only be called from a connected procedure.
  </para>
-->
<para>
这个函数只能在已连接的过程中调用。
</para>

  <!--
<para>
   If <parameter>count</parameter> is zero then the command is executed
   for all rows that it applies to.  If <parameter>count</parameter>
   is greater than zero, then no more than <parameter>count</parameter> rows
   will be retrieved; execution stops when the count is reached, much like
   adding a <literal>LIMIT</literal> clause to the query. For example,
<programlisting>
SPI_execute("SELECT * FROM foo", true, 5);
</programlisting>
   will retrieve at most 5 rows from the table.  Note that such a limit
   is only effective when the command actually returns rows.  For example,
<programlisting>
SPI_execute("INSERT INTO foo SELECT * FROM bar", false, 5);
</programlisting>
   inserts all rows from <structname>bar</>, ignoring the
   <parameter>count</parameter> parameter.  However, with
<programlisting>
SPI_execute("INSERT INTO foo SELECT * FROM bar RETURNING *", false, 5);
</programlisting>
   at most 5 rows would be inserted, since execution would stop after the
   fifth <literal>RETURNING</> result row is retrieved.
  </para>
-->
<para>
如果<parameter>count</parameter>是零，则在命令适合的所有行上执行。
如果<parameter>count</parameter>大于 0 ，那么将不会超过
<parameter>count</parameter>行被检索；当达到计数时执行停止，
很像在查询中添加了一个<literal>LIMIT</literal>子句。比如，
<programlisting>
SPI_execute("SELECT * FROM foo", true, 5);
</programlisting>
将从表中最多检索5行。请注意，这样一个限制只在命令实际返回行时有效。例如，
<programlisting>
SPI_execute("INSERT INTO foo SELECT * FROM bar", false, 5);
</programlisting>
插入<structname>bar</>中的所有行，忽略<parameter>count</parameter>参数。
不过，
<programlisting>
SPI_execute("INSERT INTO foo SELECT * FROM bar RETURNING *", false, 5);
</programlisting>
将最多插入5行，因为在检索到第5个<literal>RETURNING</>结果行之后执行将停止。
</para>

  <!--
<para>
   You can pass multiple commands in one string;
   <function>SPI_execute</function> returns the
   result for the command executed last.  The <parameter>count</parameter>
   limit applies to each command separately (even though only the last
   result will actually be returned).  The limit is not applied to any
   hidden commands generated by rules.
  </para>
-->
<para>
你可以在一个字符串里传递多个命令。<function>SPI_execute</function>
返回最后执行的命令的结果。<parameter>count</parameter>
的限制独立地应用于每一个命令（即使实际只返回最后的结果）。
限制不会应用于规则生成的隐藏命令。
</para>

  <!--
<para>
   When <parameter>read_only</parameter> is <literal>false</>,
   <function>SPI_execute</function> increments the command
   counter and computes a new <firstterm>snapshot</> before executing each
   command in the string.  The snapshot does not actually change if the
   current transaction isolation level is <literal>SERIALIZABLE</> or <literal>REPEATABLE READ</>, but in
   <literal>READ COMMITTED</> mode the snapshot update allows each command to
   see the results of newly committed transactions from other sessions.
   This is essential for consistent behavior when the commands are modifying
   the database.
  </para>
-->
<para>
如果<parameter>read_only</parameter>是<literal>false</>，<function>SPI_execute</function>
递增命令计数器并且在字符串里执行每个命令之前计算一个新的<firstterm>快照</>。
如果当前事务的隔离级别是<literal>SERIALIZABLE</>或<literal>REPEATABLE READ</>，
这个快照实际上并不改变，但是在<literal>READ COMMITTED</>模式里，
这个快照更新允许每个命令看到其它会话的新提交的事务的结果。
这样实际上是为了修改数据库的命令有一致的行为。
</para>

  <!--
<para>
   When <parameter>read_only</parameter> is <literal>true</>,
   <function>SPI_execute</function> does not update either the snapshot
   or the command counter, and it allows only plain <command>SELECT</>
   commands to appear in the command string.  The commands are executed
   using the snapshot previously established for the surrounding query.
   This execution mode is somewhat faster than the read/write mode due
   to eliminating per-command overhead.  It also allows genuinely
   <firstterm>stable</> functions to be built: since successive executions
   will all use the same snapshot, there will be no change in the results.
  </para>
-->
<para>
如果<parameter>read_only</parameter>是<literal>true</>，<function>SPI_execute</function>
并不更新快照或者命令计数器，并且它只允许简单的<command>SELECT</>
命令出现在命令字符串里。这个命令使用为周围的查询建立起来的快照执行。
这个执行模式比读/写模式执行得略微块些，因为它消除了每个命令的一些开销。
并且它还允许制作真正的<firstterm>稳定</>函数：因为随后的执行都将使用同一个快照，
结果里不会有改变。
</para>

  <!--
<para>
   It is generally unwise to mix read-only and read-write commands within
   a single function using SPI; that could result in very confusing behavior,
   since the read-only queries would not see the results of any database
   updates done by the read-write queries.
  </para>
-->
<para>
通常，在同一个使用 SPI 的函数里混杂只读和读写命令是不明智的；
那样可能导致非常混乱的行为，因为只读的查询不能看到任何读写的查询做的数据库更新。
</para>

  <!--
<para>
   The actual number of rows for which the (last) command was executed
   is returned in the global variable <varname>SPI_processed</varname>.
   If the return value of the function is <symbol>SPI_OK_SELECT</symbol>,
   <symbol>SPI_OK_INSERT_RETURNING</symbol>,
   <symbol>SPI_OK_DELETE_RETURNING</symbol>, or
   <symbol>SPI_OK_UPDATE_RETURNING</symbol>,
   then you can use the
   global pointer <literal>SPITupleTable *SPI_tuptable</literal> to
   access the result rows.  Some utility commands (such as
   <command>EXPLAIN</>) also return row sets, and <literal>SPI_tuptable</>
   will contain the result in these cases too. Some utility commands
   (<command>COPY</>, <command>CREATE TABLE AS</>) don't return a row set, so
   <literal>SPI_tuptable</> is NULL, but they still return the number of
   rows processed in <varname>SPI_processed</>.
  </para>
-->
<para>
(最后)一条命令执行返回的结果的实际行数会放在全局的变量
<varname>SPI_processed</varname>里。如果函数的返回值是<symbol>SPI_OK_SELECT</symbol>、
<symbol>SPI_OK_INSERT_RETURNING</symbol>、<symbol>SPI_OK_DELETE_RETURNING</symbol>
或<symbol>SPI_OK_UPDATE_RETURNING</symbol>，那么你可以使用全局指针
<literal>SPITupleTable *SPI_tuptable</literal>访问结果行。一些实用命令
(比如<command>EXPLAIN</>)还返回行集合，并且<literal>SPI_tuptable</>
也将在这种情况下包含结果。一些实用命令（<command>COPY</>, <command>CREATE TABLE AS</>）
并不返回行集，所以<literal>SPI_tuptable</>为NULL，但是它们仍然返回
<varname>SPI_processed</>中处理了的行数。
</para>
  
<para>
<!--
   The structure <structname>SPITupleTable</structname> is defined
   thus:
-->
结构<structname>SPITupleTable</structname>是这样定义的：
<programlisting>
typedef struct
{
    MemoryContext tuptabcxt;    /* memory context of result table */
    uint32      alloced;        /* number of alloced vals */
    uint32      free;           /* number of free vals */
    TupleDesc   tupdesc;        /* row descriptor */
    HeapTuple  *vals;           /* rows */
} SPITupleTable;
</programlisting>
<!-- 
   <structfield>vals</> is an array of pointers to rows.  (The number
   of valid entries is given by <varname>SPI_processed</varname>.)
   <structfield>tupdesc</> is a row descriptor which you can pass to
   SPI functions dealing with rows.  <structfield>tuptabcxt</>,
   <structfield>alloced</>, and <structfield>free</> are internal
   fields not intended for use by SPI callers. 
-->
<structfield>vals</>是一个指向数据行的的指针数组(有效记录的数目由
<varname>SPI_processed</varname>给出)。<structfield>tupdesc</>是一个行描述符，
你可以传递给 SPI 函数处理这些数据行。<structfield>tuptabcxt</>、
<structfield>alloced</>和<structfield>free</>是 SPI 的内部字段，
并非给 SPI 调用者使用的。
  </para>

  <!--
<para>
   <function>SPI_finish</function> frees all
   <structname>SPITupleTable</>s allocated during the current
   procedure.  You can free a particular result table earlier, if you
   are done with it, by calling <function>SPI_freetuptable</function>.
  </para>
-->
<para>
<function>SPI_finish</function>释放所有在当前过程中分配的<structname>SPITupleTable</>。
如果你已经处理完特定的结果表，那么可以更早地释放它，方法是调用
<function>SPI_freetuptable</function>。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
     <!--
<para>
      string containing command to execute
     </para>
-->
<para>
包含要执行的命令的字符串
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
     <!--
<para><literal>true</> for read-only execution</para>
-->
<para>
<literal>true</>用于只读的执行
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
     <!--
<para>
      maximum number of rows to return,
      or <literal>0</> for no limit
     </para>
-->
<para>
返回的最大行数，或者没有限制时为<literal>0</>
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>
 
<para>
<!-- 
   If the execution of the command was successful then one of the
   following (nonnegative) values will be returned:
-->
如果命令执行成功，那么返回下列值之一(非负数)：
   <variablelist>
    <varlistentry>
     <term><symbol>SPI_OK_SELECT</symbol></term>
     <listitem>
<!--
      <para>
       if a <command>SELECT</command> (but not <command>SELECT
       INTO</>) was executed
      </para>
-->
<para>
如果执行了一个<command>SELECT</command>但不是<command>SELECT INTO</>
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_SELINTO</symbol></term>
     <listitem>
      <!--
<para>
       if a <command>SELECT INTO</command> was executed
      </para>
-->
<para>
如果执行了一条<command>SELECT INTO</command>
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_INSERT</symbol></term>
     <listitem>
      <!--
<para>
       if an <command>INSERT</command> was executed
      </para>
-->
<para>
如果执行了一条<command>INSERT</command>
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_DELETE</symbol></term>
     <listitem>
      <!--
<para>
       if a <command>DELETE</command> was executed
      </para>
-->
<para>
如果执行了一条<command>DELETE</command>
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_UPDATE</symbol></term>
     <listitem>
      <!--
<para>
       if an <command>UPDATE</command> was executed
      </para>
-->
<para>
如果执行了一条<command>UPDATE</command>
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_INSERT_RETURNING</symbol></term>
     <listitem>
      <!--
<para>
       if an <command>INSERT RETURNING</command> was executed
      </para>
-->
<para>
如果执行了一条<command>INSERT RETURNING</command>
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_DELETE_RETURNING</symbol></term>
     <listitem>
      <!--
<para>
       if a <command>DELETE RETURNING</command> was executed
      </para>
-->
<para>
如果执行了一条<command>DELETE RETURNING</command>
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_UPDATE_RETURNING</symbol></term>
     <listitem>
      <!--
<para>
       if an <command>UPDATE RETURNING</command> was executed
      </para>
-->
<para>
如果执行了一条<command>UPDATE RETURNING</command>
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_UTILITY</symbol></term>
     <listitem>
      <!--
<para>
       if a utility command (e.g., <command>CREATE TABLE</command>)
       was executed
      </para>
-->
<para>
如果执行了一条实用命令(比如<command>CREATE TABLE</command>)
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_REWRITTEN</symbol></term>
     <listitem>
      <!--
<para>
       if the command was rewritten into another kind of command (e.g.,
       <command>UPDATE</command> became an <command>INSERT</command>) by a <link linkend="rules">rule</link>.
      </para>
-->
<para>
如果该命令通过一个<link linkend="rules">规则</link>重新写入了另一个类型的命令
（比如，<command>UPDATE</command>变成一个<command>INSERT</command>）
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  
<para>
<!-- 
   On error, one of the following negative values is returned:
-->
发生错误时，返回下列负数值之一：
   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
<!--
      <para>
       if <parameter>command</parameter> is <symbol>NULL</symbol> or
       <parameter>count</parameter> is less than 0
      </para>
-->
<para>
如果<parameter>command</parameter>是<symbol>NULL</symbol>或
<parameter>count</parameter>小于 0
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_COPY</symbol></term>
     <listitem>
      <!--
<para>
       if <command>COPY TO stdout</> or <command>COPY FROM stdin</>
       was attempted
      </para>
-->
<para>
如果企图进行<command>COPY TO stdout</>或<command>COPY FROM stdin</>
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_TRANSACTION</symbol></term>
     <listitem>
      <!--
<para>
       if a transaction manipulation command was attempted
       (<command>BEGIN</>,
       <command>COMMIT</>,
       <command>ROLLBACK</>,
       <command>SAVEPOINT</>,
       <command>PREPARE TRANSACTION</>,
       <command>COMMIT PREPARED</>,
       <command>ROLLBACK PREPARED</>,
       or any variant thereof)
      </para>
-->
<para>
如果尝试事务操纵命令(<command>BEGIN</>,
       <command>COMMIT</>,
       <command>ROLLBACK</>,
       <command>SAVEPOINT</>,
       <command>PREPARE TRANSACTION</>,
       <command>COMMIT PREPARED</>,
       <command>ROLLBACK PREPARED</>,
       或它们的变种)
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_OPUNKNOWN</symbol></term>
     <listitem>
      <!--
<para>
       if the command type is unknown (shouldn't happen)
      </para>
-->
<para>
命令类型未知(不应该发生)
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
     <listitem>
      <!--
<para>
       if called from an unconnected procedure
      </para>
-->
<para>
如果从一个未连接的过程中调用
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>

 <refsect1>
  <!--
<title>Notes</title>
-->
<title>注意</title>

  <!--
<para>
   All SPI query-execution functions set both
   <varname>SPI_processed</varname> and
   <varname>SPI_tuptable</varname> (just the pointer, not the contents
   of the structure).  Save these two global variables into local
   procedure variables if you need to access the result table of
   <function>SPI_execute</function> or another query-execution function
   across later calls.
  </para>
-->
<para>
所有SPI查询执行函数设置了<varname>SPI_processed</varname>和<varname>SPI_tuptable</varname>
(只是一个指针，不是结构的内容)。如果你需要跨越后面的调用访问<function>SPI_execute</function>
或者另一个查询执行函数的结果表，那么需要把这两个全局变量保存到一个局部过程变量中。
</para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-exec">
 <indexterm><primary>SPI_exec</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_exec</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_exec</refname>
  <!--
  <refpurpose>execute a read/write command</refpurpose>
  -->
  <refpurpose>执行一个读/写命令</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
int SPI_exec(const char * <parameter>command</parameter>, long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_exec</function> is the same as
   <function>SPI_execute</function>, with the latter's
   <parameter>read_only</parameter> parameter always taken as
   <literal>false</>.
  </para>
-->
<para>
<function>SPI_exec</function>和<function>SPI_execute</function>一样，
只是相当于后者的<parameter>read_only</parameter>参数总是<literal>false</>。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
     <!--
<para>
      string containing command to execute
     </para>
-->
<para>
包含需要执行的命令的字符串
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
     <!--
<para>
      maximum number of rows to return,
      or <literal>0</> for no limit
     </para>
-->
<para>
返回的最大行数，或者没有限制时为<literal>0</>
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>

  <!--
<para>
   See <function>SPI_execute</function>.
  </para>
-->
<para>
参见<function>SPI_execute</function>。
</para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-execute-with-args">
 <indexterm><primary>SPI_execute_with_args</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_execute_with_args</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_execute_with_args</refname>
  <!--
  <refpurpose>execute a command with out-of-line parameters</refpurpose>
  -->
  <refpurpose>执行一个带有外联参数的命令</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
int SPI_execute_with_args(const char *<parameter>command</parameter>,
                          int <parameter>nargs</parameter>, Oid *<parameter>argtypes</parameter>,
                          Datum *<parameter>values</parameter>, const char *<parameter>nulls</parameter>,
                          bool <parameter>read_only</parameter>, long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_execute_with_args</function> executes a command that might
   include references to externally supplied parameters.  The command text
   refers to a parameter as <literal>$<replaceable>n</></literal>, and
   the call specifies data types and values for each such symbol.
   <parameter>read_only</parameter> and <parameter>count</parameter> have
   the same interpretation as in <function>SPI_execute</function>.
  </para>
-->
<para>
<function>SPI_execute_with_args</function>执行一个可能包含引用外部提供的参数的命令。
该命令文本作为<literal>$<replaceable>n</></literal>引用一个参数，
并且该调用为每个这样的符号指定数据类型和值。<parameter>read_only</parameter>和
<parameter>count</parameter>的解释和在<function>SPI_execute</function>中一样。
</para>

  <!--
<para>
   The main advantage of this routine compared to
   <function>SPI_execute</function> is that data values can be inserted
   into the command without tedious quoting/escaping, and thus with much
   less risk of SQL-injection attacks.
  </para>
-->
<para>
与<function>SPI_execute</function>比较，这个例程的主要优势是数据值可以插入命令，
而不用引用/转义，并且因此少了许多SQL注入攻击的危险。
</para>

  <!--
<para>
   Similar results can be achieved with <function>SPI_prepare</> followed by
   <function>SPI_execute_plan</function>; however, when using this function
   the query plan is always customized to the specific parameter values
   provided.
   For one-time query execution, this function should be preferred.
   If the same command is to be executed with many different parameters,
   either method might be faster, depending on the cost of re-planning
   versus the benefit of custom plans.
  </para>
-->
<para>
相似的结果可以用跟着<function>SPI_execute_plan</function>的<function>SPI_prepare</>
达到；不过，当使用这个函数时，该查询规划总是自定义为提供的特定的参数值。
对于一次性查询执行，这个函数应该优先执行。如果用许多不同的参数执行相同的命令，
哪种方法可能会更快，取决于重新规划的开销与自定义规划的好处的对比。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
     <!--
<para>
      command string
     </para>
-->
<para>
命令字符串
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>nargs</parameter></literal></term>
    <listitem>
     <!--
<para>
      number of input parameters (<literal>$1</>, <literal>$2</>, etc.)
     </para>
-->
<para>
输入参数的个数 (<literal>$1</>, <literal>$2</>, 等)
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Oid * <parameter>argtypes</parameter></literal></term>
    <listitem>
     <!--
<para>
      an array of length <parameter>nargs</parameter>, containing the
      <acronym>OID</acronym>s of the data types of the parameters
     </para>
-->
<para>
长度<parameter>nargs</parameter>的一个数组，包含参数的数据类型的<acronym>OID</acronym>
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Datum * <parameter>values</parameter></literal></term>
    <listitem>
     <!--
<para>
      an array of length <parameter>nargs</parameter>, containing the actual
      parameter values
     </para>
-->
<para>
长度<parameter>nargs</parameter>的一个数组，包含实际参数值
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
    <listitem>
     <!--
<para>
      an array of length <parameter>nargs</parameter>, describing which
      parameters are null
     </para>
-->
<para>
长度<parameter>nargs</parameter>的一个数组，描述哪个参数为空
</para>

     <!--
<para>
      If <parameter>nulls</parameter> is <symbol>NULL</symbol> then
      <function>SPI_execute_with_args</function> assumes that no parameters
      are null.  Otherwise, each entry of the <parameter>nulls</parameter>
      array should be <literal>'&nbsp;'</> if the corresponding parameter
      value is non-null, or <literal>'n'</> if the corresponding parameter
      value is null.  (In the latter case, the actual value in the
      corresponding <parameter>values</parameter> entry doesn't matter.)  Note
      that <parameter>nulls</parameter> is not a text string, just an array:
      it does not need a <literal>'\0'</> terminator.
     </para>
-->
<para>
如果<parameter>nulls</parameter>是<symbol>NULL</symbol>，那么<function>SPI_execute_with_args</function>
假设没有参数为空。否则，如果对应的参数值是非空的，那么<parameter>nulls</parameter>
数组的每一项都应该是<literal>'&nbsp;'</>，或者如果对应的参数值为空，那么
<parameter>nulls</parameter>数组的每一项都是<literal>'n'</>。
（在后面这种情况下，对应的<parameter>values</parameter>项中的实际值无关紧要。）
请注意，<parameter>nulls</parameter>不是文本字符串，只是一个数组：
它不需要<literal>'\0'</>终止符。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
     <!--
<para><literal>true</> for read-only execution</para>
-->
<para>
<literal>true</>用于只读的执行
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
     <!--
<para>
      maximum number of rows to return,
      or <literal>0</> for no limit
     </para>
-->
<para>
返回的最大行数，或者没有限制时为<literal>0</>
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>

  <!--
<para>
   The return value is the same as for <function>SPI_execute</function>.
  </para>
-->
<para>
返回值和<function>SPI_execute</function>相同。
</para>

  <!--
<para>
   <varname>SPI_processed</varname> and
   <varname>SPI_tuptable</varname> are set as in
   <function>SPI_execute</function> if successful.
  </para>
-->
<para>
如果成功，<varname>SPI_processed</varname>和<varname>SPI_tuptable</varname>
和在<function>SPI_execute</function>中一样设置。
</para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-prepare">
 <indexterm><primary>SPI_prepare</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_prepare</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_prepare</refname>
  <!-- 
  <refpurpose>prepare a statement, without executing it yet</refpurpose>
  -->
  <refpurpose>准备一个规划但不立即执行它</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
SPIPlanPtr SPI_prepare(const char * <parameter>command</parameter>, int <parameter>nargs</parameter>, Oid * <parameter>argtypes</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_prepare</function> creates and returns a prepared
   statement for the specified command, but doesn't execute the command.
   The prepared statement can later be executed repeatedly using
   <function>SPI_execute_plan</function>.
  </para>
-->
<para>
<function>SPI_prepare</function>为声明的命令创建和返回一个预备语句但是不执行查询。
该预备语句稍后可以使用<function>SPI_execute_plan</function>重复的执行。
</para>

  <!--
<para>
   When the same or a similar command is to be executed repeatedly, it
   is generally advantageous to perform parse analysis only once, and
   might furthermore be advantageous to re-use an execution plan for the
   command.
   <function>SPI_prepare</function> converts a command string into a
   prepared statement that encapsulates the results of parse analysis.
   The prepared statement also provides a place for caching an execution plan
   if it is found that generating a custom plan for each execution is not
   helpful.
  </para>
-->
<para>
如果相同或者类似的查询要多次重复执行，那么通常只进行一次解析分析应该是更好些，
并且此外可能有利于为该命令重复使用一个执行规划。<function>SPI_prepare</function>
把一个命令字符串转换成一个封装解析分析的结果的预备语句。
如果发现为每个执行生成一个自定义规划没什么帮助，
那么该预备语句也为缓存一个执行规划提供位置。
</para>

  <!--
<para>
   A prepared command can be generalized by writing parameters
   (<literal>$1</>, <literal>$2</>, etc.) in place of what would be
   constants in a normal command.  The actual values of the parameters
   are then specified when <function>SPI_execute_plan</function> is called.
   This allows the prepared command to be used over a wider range of
   situations than would be possible without parameters.
  </para>
-->
<para>
可以把预编写的查询通用化，方法是在那些普通查询里是常量的地方书写参数
(<literal>$1</>, <literal>$2</>等等)。参数的数值随后在调用<function>SPI_execute_plan</function>
的时候声明。这样就允许已准备的查询在远比没有参数时广泛得多的场合下使用。
</para>

  <!--
<para>
   The statement returned by <function>SPI_prepare</function> can be used
   only in the current invocation of the procedure, since
   <function>SPI_finish</function> frees memory allocated for such a
   statement.  But the statement can be saved for longer using the functions
   <function>SPI_keepplan</function> or <function>SPI_saveplan</function>.
  </para>
-->
<para>
<function>SPI_prepare</function>返回的语句只能在当前过程调用中使用，
因为<function>SPI_finish</function>释放为这样一个语句分配的内存。不过，
一个语句可以用函数<function>SPI_keepplan</function>或<function>SPI_saveplan</function>
保存更长的时间。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
     <!--
<para>
      command string
     </para>
-->
<para>
命令字符串
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>nargs</parameter></literal></term>
    <listitem>
     <!--
<para>
      number of input parameters (<literal>$1</>, <literal>$2</>, etc.)
     </para>
-->
<para>
输入参数的个数(<literal>$1</>, <literal>$2</>等等)
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Oid * <parameter>argtypes</parameter></literal></term>
    <listitem>
     <!--
<para>
      pointer to an array containing the <acronym>OID</acronym>s of
      the data types of the parameters
     </para>
-->
<para>
一个指针，指向包含参数数据类型的<acronym>OID</acronym>数组
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>

  <!--
<para>
   <function>SPI_prepare</function> returns a non-null pointer to an
   <type>SPIPlan</>, which is an opaque struct representing a prepared
   statement.  On error, <symbol>NULL</symbol> will be returned,
   and <varname>SPI_result</varname> will be set to one of the same
   error codes used by <function>SPI_execute</function>, except that
   it is set to <symbol>SPI_ERROR_ARGUMENT</symbol> if
   <parameter>command</parameter> is <symbol>NULL</symbol>, or if
   <parameter>nargs</> is less than 0, or if <parameter>nargs</> is
   greater than 0 and <parameter>argtypes</> is <symbol>NULL</symbol>.
  </para>
-->
<para>
<function>SPI_prepare</function>返回一个指向一个<type>SPIPlan</>的非空指针，
<type>SPIPlan</>是一个表示预备语句的不透明结构。错误时将返回<symbol>NULL</symbol>，
并且<varname>SPI_result</varname>将设置为和<function>SPI_execute</function>
使用的同样错误的错误代码，例外是在<parameter>command</parameter>是
<symbol>NULL</symbol>的时候，或者是<parameter>nargs</>小于 0 或者<parameter>nargs</>
大于 0 并且<parameter>argtypes</>是<symbol>NULL</symbol>的时候会被设置成
<symbol>SPI_ERROR_ARGUMENT</symbol>。
</para>
 </refsect1>

 <refsect1>
  <!--
<title>Notes</title>
-->
<title>注意</title>

  <!--
<para>
   If no parameters are defined, a generic plan will be created at the
   first use of <function>SPI_execute_plan</function>, and used for all
   subsequent executions as well.  If there are parameters, the first few uses
   of <function>SPI_execute_plan</function> will generate custom plans
   that are specific to the supplied parameter values.  After enough uses
   of the same prepared statement, <function>SPI_execute_plan</function> will
   build a generic plan, and if that is not too much more expensive than the
   custom plans, it will start using the generic plan instead of re-planning
   each time.  If this default behavior is unsuitable, you can alter it by
   passing the <literal>CURSOR_OPT_GENERIC_PLAN</> or
   <literal>CURSOR_OPT_CUSTOM_PLAN</> flag to
   <function>SPI_prepare_cursor</function>, to force use of generic or custom
   plans respectively.
  </para>
-->
<para>
如果没有定义参数，那么在第一次使用<function>SPI_execute_plan</function>
时将创建一个通用规划，并且也用于所有随后的执行。如果有参数，
前几次使用<function>SPI_execute_plan</function>将生成特定于提供的参数值的自定义规划。
相同的预备语句使用足够多次之后，<function>SPI_execute_plan</function>
将建立一个通用规划，并且如果该通用规划并不比自定义规划昂贵的多的话，
它将开始使用该通用规划而不是每次重新规划。如果这个缺省行为不合适，
你可以通过传递<literal>CURSOR_OPT_GENERIC_PLAN</>或<literal>CURSOR_OPT_CUSTOM_PLAN</>
标志到<function>SPI_prepare_cursor</function>来修改它，分别强制使用通用或自定义规划。
</para>

  <!--
<para>
   Although the main point of a prepared statement is to avoid repeated parse
   analysis and planning of the statement, <productname>PostgreSQL</> will
   force re-analysis and re-planning of the statement before using it
   whenever database objects used in the statement have undergone
   definitional (DDL) changes since the previous use of the prepared
   statement.  Also, if the value of <xref linkend="guc-search-path"> changes
   from one use to the next, the statement will be re-parsed using the new
   <varname>search_path</>.  (This latter behavior is new as of
   <productname>PostgreSQL</productname> 9.3.)  See <xref
   linkend="sql-prepare"> for more information about the behavior of prepared
   statements.
  </para>
-->
<para>
尽管预备语句的要点是为了避免重复的解析分析和规划语句，
但是在语句中使用的数据库对象自上次使用预备语句以来经历了明确的（DDL）
改变时，<productname>PostgreSQL</>将在使用它之前强制重新分析和重新规划语句。
另外，如果<xref linkend="guc-search-path">的值在下一次使用时发生了改变时，
该语句将使用新的<varname>search_path</>重新解析。（后者的行为是
<productname>PostgreSQL</productname> 9.3新增的。）参阅<xref linkend="sql-prepare">
获取更多关于预备语句的行为的信息。
</para>

  <!--
<para>
   This function should only be called from a connected procedure.
  </para>
-->
<para>
这个函数应该只从一个已连接的过程中调用。
</para>

  <!--
<para>
   <type>SPIPlanPtr</> is declared as a pointer to an opaque struct type in
   <filename>spi.h</>.  It is unwise to try to access its contents
   directly, as that makes your code much more likely to break in
   future revisions of <productname>PostgreSQL</productname>.
  </para>
-->
<para>
<type>SPIPlanPtr</>声明为一个指针，指向<filename>spi.h</>中的一个不透明的结构类型。
尝试直接访问它的内容是不明智的，因为那样会使得你的代码在未来的
<productname>PostgreSQL</productname>修订版本中更容易破裂。
</para>

  <!--
<para>
   The name <type>SPIPlanPtr</> is somewhat historical, since the data
   structure no longer necessarily contains an execution plan.
  </para>
-->
<para>
名字<type>SPIPlanPtr</>是历史用法，因为数据结构不再需要包含一个执行规划。
</para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-prepare-cursor">
 <indexterm><primary>SPI_prepare_cursor</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_prepare_cursor</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_prepare_cursor</refname>
  <!--
  <refpurpose>prepare a statement, without executing it yet</refpurpose>
  -->
  <refpurpose>准备一个语句但不立即执行它</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
SPIPlanPtr SPI_prepare_cursor(const char * <parameter>command</parameter>, int <parameter>nargs</parameter>,
                              Oid * <parameter>argtypes</parameter>, int <parameter>cursorOptions</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_prepare_cursor</function> is identical to
   <function>SPI_prepare</function>, except that it also allows specification
   of the planner's <quote>cursor options</> parameter.  This is a bit mask
   having the values shown in <filename>nodes/parsenodes.h</filename>
   for the <structfield>options</> field of <structname>DeclareCursorStmt</>.
   <function>SPI_prepare</function> always takes the cursor options as zero.
  </para>
-->
<para>
<function>SPI_prepare_cursor</function>和<function>SPI_prepare</function>相同，
除了它也允许说明规划器的<quote>游标选项</>参数。这是一个位掩码，
让<structname>DeclareCursorStmt</>的<structfield>options</>字段拥有
<filename>nodes/parsenodes.h</filename>中显示的值。<function>SPI_prepare</function>
总是将游标选项看做零。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
     <!--
<para>
      command string
     </para>
-->
<para>
命令字符串
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>nargs</parameter></literal></term>
    <listitem>
     <!--
<para>
      number of input parameters (<literal>$1</>, <literal>$2</>, etc.)
     </para>
-->
<para>
输入参数的个数(<literal>$1</>, <literal>$2</>等等)
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Oid * <parameter>argtypes</parameter></literal></term>
    <listitem>
     <!--
<para>
      pointer to an array containing the <acronym>OID</acronym>s of
      the data types of the parameters
     </para>
-->
<para>
一个指针，指向一个包含参数数据类型的<acronym>OID</acronym>的数组
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>cursorOptions</parameter></literal></term>
    <listitem>
     <!--
<para>
      integer bit mask of cursor options; zero produces default behavior
     </para>
-->
<para>
游标选项的整数位标记；零表示缺省行为
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>

  <!--
<para>
   <function>SPI_prepare_cursor</function> has the same return conventions as
   <function>SPI_prepare</function>.
  </para>
-->
<para>
<function>SPI_prepare_cursor</function>有和<function>SPI_prepare</function>
一样的返回约定。
</para>
 </refsect1>

 <refsect1>
  <!--
<title>Notes</title>
-->
<title>注意</title>

  <!--
<para>
   Useful bits to set in <parameter>cursorOptions</> include
   <symbol>CURSOR_OPT_SCROLL</symbol>,
   <symbol>CURSOR_OPT_NO_SCROLL</symbol>,
   <symbol>CURSOR_OPT_FAST_PLAN</symbol>,
   <symbol>CURSOR_OPT_GENERIC_PLAN</symbol>, and
   <symbol>CURSOR_OPT_CUSTOM_PLAN</symbol>.  Note in particular that
   <symbol>CURSOR_OPT_HOLD</symbol> is ignored.
  </para>
-->
<para>
<parameter>cursorOptions</>中的有效位包括<symbol>CURSOR_OPT_SCROLL</symbol>、
<symbol>CURSOR_OPT_NO_SCROLL</symbol>、<symbol>CURSOR_OPT_FAST_PLAN</symbol>、
<symbol>CURSOR_OPT_GENERIC_PLAN</symbol>和<symbol>CURSOR_OPT_CUSTOM_PLAN</symbol>。
特别要注意忽略了<symbol>CURSOR_OPT_HOLD</symbol>。
</para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-prepare-params">
 <indexterm><primary>SPI_prepare_params</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_prepare_params</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_prepare_params</refname>
  <!--
  <refpurpose>prepare a statement, without executing it yet</refpurpose>
  -->
  <refpurpose>准备一个语句但不立即执行它</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
SPIPlanPtr SPI_prepare_params(const char * <parameter>command</parameter>,
                              ParserSetupHook <parameter>parserSetup</parameter>,
                              void * <parameter>parserSetupArg</parameter>,
                              int <parameter>cursorOptions</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_prepare_params</function> creates and returns a prepared
   statement for the specified command, but doesn't execute the command.
   This function is equivalent to <function>SPI_prepare_cursor</function>,
   with the addition that the caller can specify parser hook functions
   to control the parsing of external parameter references.
  </para>
-->
<para>
<function>SPI_prepare_params</function>为指定的命令创建并返回一个预备语句，
但是不执行该命令。这个函数相当于<function>SPI_prepare_cursor</function>，
除了调用者可以指定解析器hook函数来控制外部参数引用的解析。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
     <!--
<para>
      command string
     </para>
-->
<para>
命令字符串
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ParserSetupHook <parameter>parserSetup</parameter></literal></term>
    <listitem>
     <!--
<para>
      Parser hook setup function
     </para>
-->
<para>
解析器hook设置功能
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>void * <parameter>parserSetupArg</parameter></literal></term>
    <listitem>
     <!--
<para>
      pass-through argument for <parameter>parserSetup</parameter>
     </para>
-->
<para>
为<parameter>parserSetup</parameter>传递参数
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>cursorOptions</parameter></literal></term>
    <listitem>
     <!--
<para>
      integer bit mask of cursor options; zero produces default behavior
     </para>
-->
<para>
游标选项的整型位标记；零表示缺省行为
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>

  <!--
<para>
   <function>SPI_prepare_params</function> has the same return conventions as
   <function>SPI_prepare</function>.
  </para>
-->
<para>
<function>SPI_prepare_params</function>有和<function>SPI_prepare</function>
一样的返回约定。
</para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-getargcount">
 <indexterm><primary>SPI_getargcount</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_getargcount</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_getargcount</refname>
  <!--
  <refpurpose>return the number of arguments needed by a statement
  prepared by <function>SPI_prepare</function></refpurpose>
  -->
  <refpurpose>返回一个<function>SPI_prepare</function>
  准备的已准备好语句需要的参数个数</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
int SPI_getargcount(SPIPlanPtr <parameter>plan</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_getargcount</function> returns the number of arguments needed
   to execute a statement prepared by <function>SPI_prepare</function>.
  </para>
-->
<para>
<function>SPI_getargcount</function>返回执行一个<function>SPI_prepare</function>
准备的已准备好语句需要的参数个数
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <!--
<para>
      prepared statement (returned by <function>SPI_prepare</function>)
     </para>
-->
<para>
预备语句（<function>SPI_prepare</function>返回的）
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>
  <!--
<para>
    The count of expected arguments for the <parameter>plan</parameter>.
    If the <parameter>plan</parameter> is <symbol>NULL</symbol> or invalid,
    <varname>SPI_result</varname> is set to <symbol>SPI_ERROR_ARGUMENT</symbol>
    and -1 is returned.
  </para>
-->
<para>
<parameter>plan</parameter>预期参数的个数。如果<parameter>plan</parameter>
是<symbol>NULL</symbol>或无效，<varname>SPI_result</varname>设置为
<symbol>SPI_ERROR_ARGUMENT</symbol>并返回-1.
</para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-getargtypeid">
 <indexterm><primary>SPI_getargtypeid</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_getargtypeid</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_getargtypeid</refname>
  <!--
  <refpurpose>return the data type OID for an argument of
  a statement prepared by <function>SPI_prepare</function></refpurpose>
  -->
  <refpurpose>返回<function>SPI_prepare</function>
  准备的已准备好语句的参数的数据类型OID</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
Oid SPI_getargtypeid(SPIPlanPtr <parameter>plan</parameter>, int <parameter>argIndex</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_getargtypeid</function> returns the OID representing the type
   for the <parameter>argIndex</parameter>'th argument of a statement prepared by
   <function>SPI_prepare</function>. First argument is at index zero.
  </para>
-->
<para>
<function>SPI_getargtypeid</function>返回<function>SPI_prepare</function>
准备的已准备好语句的第<parameter>argIndex</parameter>个参数的类型 ID ，
用 OID 表示。第一个参数的索引为零。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <!--
<para>
      prepared statement (returned by <function>SPI_prepare</function>)
     </para>
-->
<para>
预备语句（<function>SPI_prepare</function>返回的）
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>argIndex</parameter></literal></term>
    <listitem>
     <!--
<para>
      zero based index of the argument
     </para>
-->
<para>
以零为基的参数索引
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>
  <!--
<para>
    The type OID of the argument at the given index.
    If the <parameter>plan</parameter> is <symbol>NULL</symbol> or invalid,
    or <parameter>argIndex</parameter> is less than 0 or
    not less than the number of arguments declared for the
    <parameter>plan</parameter>,
    <varname>SPI_result</varname> is set to <symbol>SPI_ERROR_ARGUMENT</symbol>
    and <symbol>InvalidOid</symbol> is returned.
  </para>
-->
<para>
给出索引位置的参数的类型OID，如果<parameter>plan</parameter>为<symbol>NULL</symbol>
或无效，或<parameter>argIndex</parameter>小于 0 或者大于或等于为
<parameter>plan</parameter>声明的参数个数，则<varname>SPI_result</varname>
设置为<symbol>SPI_ERROR_ARGUMENT</symbol>并且返回<symbol>InvalidOid</symbol>。
</para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-is-cursor-plan">
 <indexterm><primary>SPI_is_cursor_plan</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_is_cursor_plan</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_is_cursor_plan</refname>
  <!--
  <refpurpose>return <symbol>true</symbol> if a statement
  prepared by <function>SPI_prepare</function> can be used with
  <function>SPI_cursor_open</function></refpurpose>
  -->
  <refpurpose>如果一个<function>SPI_prepare</function>准备的语句可以和
  <function>SPI_cursor_open</function>一起使用，则返回<symbol>true</symbol>
  </refpurpose> 
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
bool SPI_is_cursor_plan(SPIPlanPtr <parameter>plan</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_is_cursor_plan</function> returns <symbol>true</symbol>
   if a statement prepared by <function>SPI_prepare</function> can be passed
   as an argument to <function>SPI_cursor_open</function>, or
   <symbol>false</symbol> if that is not the case. The criteria are that the
   <parameter>plan</parameter> represents one single command and that this
   command returns tuples to the caller; for example, <command>SELECT</>
   is allowed unless it contains an <literal>INTO</> clause, and
   <command>UPDATE</> is allowed only if it contains a <literal>RETURNING</>
   clause.
  </para>
-->
<para>
如果一个<function>SPI_prepare</function>准备的语句可以作为参数传递给
<function>SPI_cursor_open</function>则<function>SPI_is_cursor_plan</function>
返回<symbol>true</symbol>，如果不是这样则返回<symbol>false</symbol>。
评判的标准是这个<parameter>plan</parameter>代表一个单个命令，
并且这个命令返回元组；例如一个包含<literal>INTO</>子句的<command>SELECT</>
或者包含<literal>RETURNING</>子句的<command>UPDATE</>。
</para>
 </refsect1>

 <refsect1>
  <!-- 
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <!--
<para>
      prepared statement (returned by <function>SPI_prepare</function>)
     </para>
-->
<para>
预备语句（<function>SPI_prepare</function>返回的）
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>
  <!--
<para>
    <symbol>true</symbol> or <symbol>false</symbol> to indicate if the
    <parameter>plan</parameter> can produce a cursor or not, with
    <varname>SPI_result</varname> set to zero.
    If it is not possible to determine the answer (for example,
    if the <parameter>plan</parameter> is <symbol>NULL</symbol> or invalid,
    or if called when not connected to SPI), then
    <varname>SPI_result</varname> is set to a suitable error code
    and <symbol>false</symbol> is returned.
  </para>
-->
<para>
表明该<parameter>plan</parameter>是否可以生成一个游标的<symbol>true</symbol>
或<symbol>false</symbol>，<varname>SPI_result</varname>设置为零。
如果不可能确定结果（例如，如果<parameter>plan</parameter>是<symbol>NULL</symbol>
或无效，或者如果在没有连接到SPI时调用），那么<varname>SPI_result</varname>
设置为合适的错误代码，并且返回<symbol>false</symbol>。
</para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-execute-plan">
 <indexterm><primary>SPI_execute_plan</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_execute_plan</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_execute_plan</refname>
  <!--
  <refpurpose>execute a statement prepared by <function>SPI_prepare</function></refpurpose>
  -->
  <refpurpose>执行一个<function>SPI_prepare</function>准备的语句</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
int SPI_execute_plan(SPIPlanPtr <parameter>plan</parameter>, Datum * <parameter>values</parameter>, const char * <parameter>nulls</parameter>,
                     bool <parameter>read_only</parameter>, long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_execute_plan</function> executes a statement prepared by
   <function>SPI_prepare</function> or one of its siblings.
   <parameter>read_only</parameter> and
   <parameter>count</parameter> have the same interpretation as in
   <function>SPI_execute</function>.
  </para>
-->
<para>
<function>SPI_execute_plan</function>执行一个<function>SPI_prepare</function>
或它的兄弟节点之一准备的语句。<parameter>read_only</parameter>和
<parameter>count</parameter>的含义和<function>SPI_execute</function>里面的相同。
</para>
 </refsect1>

 <refsect1>
  <!-- 
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <!--
<para>
      prepared statement (returned by <function>SPI_prepare</function>)
     </para>
-->
<para>
预备语句（<function>SPI_prepare</function>返回的）
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Datum * <parameter>values</parameter></literal></term>
    <listitem>
     <!--
<para>
      An array of actual parameter values.  Must have same length as the
      statement's number of arguments.
     </para>
-->
<para>
一个实际的参数值的数组。必须和语句的参数个数相同。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
    <listitem>
     <!--
<para>
      An array describing which parameters are null.  Must have same length as
      the statement's number of arguments.
     </para>
-->
<para>
一个描述哪个参数是空的数组。必须和语句的参数个数相同。
</para>

     <!--
<para>
      If <parameter>nulls</parameter> is <symbol>NULL</symbol> then
      <function>SPI_execute_plan</function> assumes that no parameters
      are null.  Otherwise, each entry of the <parameter>nulls</parameter>
      array should be <literal>'&nbsp;'</> if the corresponding parameter
      value is non-null, or <literal>'n'</> if the corresponding parameter
      value is null.  (In the latter case, the actual value in the
      corresponding <parameter>values</parameter> entry doesn't matter.)  Note
      that <parameter>nulls</parameter> is not a text string, just an array:
      it does not need a <literal>'\0'</> terminator.
     </para>
-->
<para>
如果<parameter>nulls</parameter>是<symbol>NULL</symbol>，那么<function>SPI_execute_plan</function>
假设没有参数为空。否则，如果对应的参数值是非空的，那么<parameter>nulls</parameter>
数组的每一项都应该是<literal>'&nbsp;'</>，或者如果对应的参数值为空，那么
<parameter>nulls</parameter>数组的每一项都是<literal>'n'</>。
（在后面这种情况下，对应的<parameter>values</parameter>项中的实际值无关紧要。）
请注意，<parameter>nulls</parameter>不是文本字符串，只是一个数组：
它不需要<literal>'\0'</>终止符。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
     <!--
<para><literal>true</> for read-only execution</para>
-->
<para>
<literal>true</>用于只读的执行
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
     <!--
<para>
      maximum number of rows to return,
      or <literal>0</> for no limit
     </para>
-->
<para>
返回的最大行数，或者没有限制时为<literal>0</>
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>

  
<para>
<!-- 
   The return value is the same as for <function>SPI_execute</function>,
   with the following additional possible error (negative) results:
-->
返回值和<function>SPI_execute</function>的一样，另外还有下面几个可能的错误(负值)结果：
   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
<!--
      <para>
       if <parameter>plan</parameter> is <symbol>NULL</symbol> or invalid,
       or <parameter>count</parameter> is less than 0
      </para>
-->
<para>
如果<parameter>plan</parameter>是<symbol>NULL</symbol>或者无效，
或者<parameter>count</parameter>小于 0
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_PARAM</symbol></term>
     <listitem>
      <!--
<para>
       if <parameter>values</parameter> is <symbol>NULL</symbol> and
       <parameter>plan</parameter> was prepared with some parameters
      </para>
-->
<para>
如果<parameter>values</parameter>是<symbol>NULL</symbol>并且
<parameter>plan</parameter>准备了一些参数
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <!--
<para>
   <varname>SPI_processed</varname> and
   <varname>SPI_tuptable</varname> are set as in
   <function>SPI_execute</function> if successful.
  </para>
-->
<para>
成功时，<varname>SPI_processed</varname>和<varname>SPI_tuptable</varname>
的设置和<function>SPI_execute</function>里一样。
</para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-execute-plan-with-paramlist">
 <indexterm><primary>SPI_execute_plan_with_paramlist</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_execute_plan_with_paramlist</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_execute_plan_with_paramlist</refname>
  <!--
  <refpurpose>execute a statement prepared by <function>SPI_prepare</function></refpurpose>
  -->
  <refpurpose>执行一个<function>SPI_prepare</function>准备的已准备好的语句</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
int SPI_execute_plan_with_paramlist(SPIPlanPtr <parameter>plan</parameter>,
                                    ParamListInfo <parameter>params</parameter>,
                                    bool <parameter>read_only</parameter>,
                                    long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_execute_plan_with_paramlist</function> executes a statement
   prepared by <function>SPI_prepare</function>.
   This function is equivalent to <function>SPI_execute_plan</function>
   except that information about the parameter values to be passed to the
   query is presented differently.  The <literal>ParamListInfo</>
   representation can be convenient for passing down values that are
   already available in that format.  It also supports use of dynamic
   parameter sets via hook functions specified in <literal>ParamListInfo</>.
  </para>
-->
<para>
<function>SPI_execute_plan_with_paramlist</function>执行一个<function>SPI_prepare</function>
准备的已准备好的语句。这个函数相当于<function>SPI_execute_plan</function>，
除了要传递给查询的有关参数值信息的表现不同。<literal>ParamListInfo</>
表示法可以方便的传递早已在该格式中可用的值。它也支持使用动态参数设置，
通过<literal>ParamListInfo</>中指定的hook函数。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <!--
<para>
      prepared statement (returned by <function>SPI_prepare</function>)
     </para>
-->
<para>
预备语句（<function>SPI_prepare</function>返回的）
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ParamListInfo <parameter>params</parameter></literal></term>
    <listitem>
     <!--
<para>
      data structure containing parameter types and values; NULL if none
     </para>
-->
<para>
包含参数类型和值的数据结构；如果没有则为NULL
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
     <!--
<para><literal>true</> for read-only execution</para>
-->
<para>
<literal>true</>用于只读的执行
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
     <!--
<para>
      maximum number of rows to return,
      or <literal>0</> for no limit
     </para>
-->
<para>
返回的最大行数，或者没有限制时为<literal>0</>
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
    <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>

  <!--
<para>
   The return value is the same as for <function>SPI_execute_plan</function>.
  </para>
-->
<para>
返回值和<function>SPI_execute_plan</function>的相同。
</para>

  <!--
<para>
   <varname>SPI_processed</varname> and
   <varname>SPI_tuptable</varname> are set as in
   <function>SPI_execute_plan</function> if successful.
  </para>
-->
<para>
如果成功，<varname>SPI_processed</varname>和<varname>SPI_tuptable</varname>
的设置和<function>SPI_execute_plan</function>里的相同。
</para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-execp">
 <indexterm><primary>SPI_execp</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_execp</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_execp</refname>
  <!--
  <refpurpose>execute a statement in read/write mode</refpurpose>
  -->
  <refpurpose>以读/写模式执行一个准备的查询规划</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
int SPI_execp(SPIPlanPtr <parameter>plan</parameter>, Datum * <parameter>values</parameter>, const char * <parameter>nulls</parameter>, long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_execp</function> is the same as
   <function>SPI_execute_plan</function>, with the latter's
   <parameter>read_only</parameter> parameter always taken as
   <literal>false</>.
  </para>
-->
<para>
<function>SPI_execp</function>和<function>SPI_execute_plan</function>一样，
只是后者的<parameter>read_only</parameter>参数总是为<literal>false</>。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <!--
<para>
      prepared statement (returned by <function>SPI_prepare</function>)
     </para>
-->
<para>
预备语句（<function>SPI_prepare</function>返回的）
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Datum * <parameter>values</parameter></literal></term>
    <listitem>
     <!--
<para>
      An array of actual parameter values.  Must have same length as the
      statement's number of arguments.
     </para>
-->
<para>
实际的参数值的数组，必须和语句的参数个数一样。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
    <listitem>
     <!--
<para>
      An array describing which parameters are null.  Must have same length as
      the statement's number of arguments.
     </para>
-->
<para>
一个描述哪个参数是空的数组。必须和参数的个数一样。
</para>

     <!--
<para>
      If <parameter>nulls</parameter> is <symbol>NULL</symbol> then
      <function>SPI_execp</function> assumes that no parameters
      are null.  Otherwise, each entry of the <parameter>nulls</parameter>
      array should be <literal>'&nbsp;'</> if the corresponding parameter
      value is non-null, or <literal>'n'</> if the corresponding parameter
      value is null.  (In the latter case, the actual value in the
      corresponding <parameter>values</parameter> entry doesn't matter.)  Note
      that <parameter>nulls</parameter> is not a text string, just an array:
      it does not need a <literal>'\0'</> terminator.
     </para>
-->
<para>
如果<parameter>nulls</parameter>是<symbol>NULL</symbol>，那么<function>SPI_execp</function>
假设没有参数为空。否则，如果对应的参数值是非空的，那么<parameter>nulls</parameter>
数组的每一项都应该是<literal>'&nbsp;'</>，或者如果对应的参数值为空，那么
<parameter>nulls</parameter>数组的每一项都是<literal>'n'</>。
（在后面这种情况下，对应的<parameter>values</parameter>项中的实际值无关紧要。）
请注意，<parameter>nulls</parameter>不是文本字符串，只是一个数组：
它不需要<literal>'\0'</>终止符。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
     <!--
<para>
      maximum number of rows to return,
      or <literal>0</> for no limit
     </para>
-->
<para>
返回的最大行数，或者没有限制时为<literal>0</>
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
    <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>

  <!--
<para>
   See <function>SPI_execute_plan</function>.
  </para>
-->
<para>
参阅<function>SPI_execute_plan</function>。
</para>

  <!--
<para>
   <varname>SPI_processed</varname> and
   <varname>SPI_tuptable</varname> are set as in
   <function>SPI_execute</function> if successful.
  </para>
-->
<para>
成功时，<varname>SPI_processed</varname>和<varname>SPI_tuptable</varname>
的设置和<function>SPI_execute</function>里一样。
</para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-open">
 <indexterm><primary>SPI_cursor_open</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_cursor_open</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_cursor_open</refname>
  <!--
  <refpurpose>set up a cursor using a statement created with <function>SPI_prepare</function></refpurpose>
  -->
  <refpurpose>用<function>SPI_prepare</function>创建的语句设置一个游标</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
Portal SPI_cursor_open(const char * <parameter>name</parameter>, SPIPlanPtr <parameter>plan</parameter>,
                       Datum * <parameter>values</parameter>, const char * <parameter>nulls</parameter>,
                       bool <parameter>read_only</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_cursor_open</function> sets up a cursor (internally,
   a portal) that will execute a statement prepared by
   <function>SPI_prepare</function>.  The parameters have the same
   meanings as the corresponding parameters to
   <function>SPI_execute_plan</function>.
  </para>
-->
<para>
<function>SPI_cursor_open</function>设置一个游标(内部叫入口)，
这个游标可以执行<function>SPI_prepare</function>准备的语句。
参数和对应的<function>SPI_execute_plan</function>参数具有相同的含义。
</para>

  <!--
<para>
   Using a cursor instead of executing the statement directly has two
   benefits.  First, the result rows can be retrieved a few at a time,
   avoiding memory overrun for queries that return many rows.  Second,
   a portal can outlive the current procedure (it can, in fact, live
   to the end of the current transaction).  Returning the portal name
   to the procedure's caller provides a way of returning a row set as
   result.
  </para>
-->
<para>
使用游标而不是直接执行语句有两个优点。首先，结果行可以每次检索一小部分，
避免那些返回大量数据行的查询造成的内存缺乏。第二，
一个入口可以在当前过程之外存活(实际上，它可以活到当前事务的结尾)。
给过程的调用者返回一个入口名是一种返回行结果集的方法。
</para>

  <!--
<para>
   The passed-in parameter data will be copied into the cursor's portal, so it
   can be freed while the cursor still exists.
  </para>
-->
<para>
传入参数数据将被拷贝到游标的入口，所以它在游标仍然存在时可以被释放。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>name</parameter></literal></term>
    <listitem>
     <!--
<para>
      name for portal, or <symbol>NULL</symbol> to let the system
      select a name
     </para>
-->
<para>
入口的名字，或者是用<symbol>NULL</symbol>让系统选择一个名字
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <!--
<para>
      prepared statement (returned by <function>SPI_prepare</function>)
     </para>
-->
<para>
预备语句（<function>SPI_prepare</function>返回的）
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Datum * <parameter>values</parameter></literal></term>
    <listitem>
     <!--
<para>
      An array of actual parameter values.  Must have same length as the
      statement's number of arguments.
     </para>
-->
<para>
一个实际参数值的数组。必须和语句的参数个数相等。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
    <listitem>
     <!--
<para>
      An array describing which parameters are null.  Must have same length as
      the statement's number of arguments.
     </para>
-->
<para>
一个描述哪些参数是 NULL 的数组。必须和语句的参数个数相等。
</para>

     <!--
<para>
      If <parameter>nulls</parameter> is <symbol>NULL</symbol> then
      <function>SPI_cursor_open</function> assumes that no parameters
      are null.  Otherwise, each entry of the <parameter>nulls</parameter>
      array should be <literal>'&nbsp;'</> if the corresponding parameter
      value is non-null, or <literal>'n'</> if the corresponding parameter
      value is null.  (In the latter case, the actual value in the
      corresponding <parameter>values</parameter> entry doesn't matter.)  Note
      that <parameter>nulls</parameter> is not a text string, just an array:
      it does not need a <literal>'\0'</> terminator.
     </para>
-->
<para>
如果<parameter>nulls</parameter>是<symbol>NULL</symbol>，那么<function>SPI_cursor_open</function>
假设没有参数为空。否则，如果对应的参数值是非空的，那么<parameter>nulls</parameter>
数组的每一项都应该是<literal>'&nbsp;'</>，或者如果对应的参数值为空，那么
<parameter>nulls</parameter>数组的每一项都是<literal>'n'</>。
（在后面这种情况下，对应的<parameter>values</parameter>项中的实际值无关紧要。）
请注意，<parameter>nulls</parameter>不是文本字符串，只是一个数组：
它不需要<literal>'\0'</>终止符。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
     <!--
<para><literal>true</> for read-only execution</para>
-->
<para>
<literal>true</>用于只读的执行
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
    <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>

  <!--
<para>
   Pointer to portal containing the cursor.  Note there is no error
   return convention; any error will be reported via <function>elog</>.
  </para>
-->
<para>
指向包含游标入口的指针。请注意，这里没有错误返回约定；
任何错误都将通过<function>elog</>报告。
</para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-open-with-args">
 <indexterm><primary>SPI_cursor_open_with_args</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_cursor_open_with_args</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_cursor_open_with_args</refname>
  <!--
  <refpurpose>set up a cursor using a query and parameters</refpurpose>
  -->
  <refpurpose>使用查询和参数设置一个游标</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
Portal SPI_cursor_open_with_args(const char *<parameter>name</parameter>,
                                 const char *<parameter>command</parameter>,
                                 int <parameter>nargs</parameter>, Oid *<parameter>argtypes</parameter>,
                                 Datum *<parameter>values</parameter>, const char *<parameter>nulls</parameter>,
                                 bool <parameter>read_only</parameter>, int <parameter>cursorOptions</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_cursor_open_with_args</function> sets up a cursor
   (internally, a portal) that will execute the specified query.
   Most of the parameters have the same meanings as the corresponding
   parameters to <function>SPI_prepare_cursor</function>
   and <function>SPI_cursor_open</function>.
  </para>
-->
<para>
<function>SPI_cursor_open_with_args</function>设置一个游标（内部的，一个入口），
该游标将执行指定的查询。大多数参数和<function>SPI_prepare_cursor</function>
和<function>SPI_cursor_open</function>的对应参数有相同的含义。
</para>

  <!--
<para>
   For one-time query execution, this function should be preferred
   over <function>SPI_prepare_cursor</function> followed by
   <function>SPI_cursor_open</function>.
   If the same command is to be executed with many different parameters,
   either method might be faster, depending on the cost of re-planning
   versus the benefit of custom plans.
  </para>
-->
<para>
对于一次性查询执行，跟着<function>SPI_cursor_open</function>的
<function>SPI_prepare_cursor</function>应该会偏爱这个函数。
如果相同的命令用不同的参数执行，哪种方法可能更快，
取决于重新规划的开销和自定义规划的益处的比较。
</para>

  <!--
<para>
   The passed-in parameter data will be copied into the cursor's portal, so it
   can be freed while the cursor still exists.
  </para>
-->
<para>
传入参数数据将被拷贝到游标的入口，所以它在游标仍然存在时可以被释放。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>name</parameter></literal></term>
    <listitem>
     <!--
<para>
      name for portal, or <symbol>NULL</symbol> to let the system
      select a name
     </para>
-->
<para>
入口的名字，或<symbol>NULL</symbol>让系统选择一个名字
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
     <!--
<para>
      command string
     </para>
-->
<para>
命令字符串
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>nargs</parameter></literal></term>
    <listitem>
     <!--
<para>
      number of input parameters (<literal>$1</>, <literal>$2</>, etc.)
     </para>
-->
<para>
输入参数的个数 (<literal>$1</>, <literal>$2</>等等)
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Oid * <parameter>argtypes</parameter></literal></term>
    <listitem>
     <!--
<para>
      an array of length <parameter>nargs</parameter>, containing the
      <acronym>OID</acronym>s of the data types of the parameters
     </para>
-->
<para>
长度<parameter>nargs</parameter>的一个数组，包括参数数据类型的<acronym>OID</acronym>
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Datum * <parameter>values</parameter></literal></term>
    <listitem>
     <!--
<para>
      an array of length <parameter>nargs</parameter>, containing the actual
      parameter values
     </para>
-->
<para>
长度<parameter>nargs</parameter>的一个数组，包括实际的参数值
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
    <listitem>
     <!--
<para>
      an array of length <parameter>nargs</parameter>, describing which
      parameters are null
     </para>
-->
<para>
长度<parameter>nargs</parameter>的一个数组，描述哪个参数为空
</para>

     <!--
<para>
      If <parameter>nulls</parameter> is <symbol>NULL</symbol> then
      <function>SPI_cursor_open_with_args</function> assumes that no parameters
      are null.  Otherwise, each entry of the <parameter>nulls</parameter>
      array should be <literal>'&nbsp;'</> if the corresponding parameter
      value is non-null, or <literal>'n'</> if the corresponding parameter
      value is null.  (In the latter case, the actual value in the
      corresponding <parameter>values</parameter> entry doesn't matter.)  Note
      that <parameter>nulls</parameter> is not a text string, just an array:
      it does not need a <literal>'\0'</> terminator.
     </para>
-->
<para>
如果<parameter>nulls</parameter>是<symbol>NULL</symbol>，那么<function>SPI_cursor_open_with_args</function>
假设没有参数为空。否则，如果对应的参数值是非空的，那么<parameter>nulls</parameter>
数组的每一项都应该是<literal>'&nbsp;'</>，或者如果对应的参数值为空，那么
<parameter>nulls</parameter>数组的每一项都是<literal>'n'</>。
（在后面这种情况下，对应的<parameter>values</parameter>项中的实际值无关紧要。）
请注意，<parameter>nulls</parameter>不是文本字符串，只是一个数组：
它不需要<literal>'\0'</>终止符。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
     <!--
<para><literal>true</> for read-only execution</para>
-->
<para>
<literal>true</>用于只读的执行
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>cursorOptions</parameter></literal></term>
    <listitem>
     <!--
<para>
      integer bit mask of cursor options; zero produces default behavior
     </para>
-->
<para>
游标选项的整型位标记；零表示缺省行为
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
    <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>

  <!--
<para>
   Pointer to portal containing the cursor.  Note there is no error
   return convention; any error will be reported via <function>elog</>.
  </para>
-->
<para>
指向包含游标入口的指针。请注意，这里没有错误返回约定；
任何错误都将通过<function>elog</>报告。
</para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-open-with-paramlist">
 <indexterm><primary>SPI_cursor_open_with_paramlist</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_cursor_open_with_paramlist</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_cursor_open_with_paramlist</refname>
  <!--
  <refpurpose>set up a cursor using parameters</refpurpose>
  -->
  <refpurpose>使用参数设置一个游标</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
Portal SPI_cursor_open_with_paramlist(const char *<parameter>name</parameter>,
                                      SPIPlanPtr <parameter>plan</parameter>,
                                      ParamListInfo <parameter>params</parameter>,
                                      bool <parameter>read_only</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_cursor_open_with_paramlist</function> sets up a cursor
   (internally, a portal) that will execute a statement prepared by
   <function>SPI_prepare</function>.
   This function is equivalent to <function>SPI_cursor_open</function>
   except that information about the parameter values to be passed to the
   query is presented differently.  The <literal>ParamListInfo</>
   representation can be convenient for passing down values that are
   already available in that format.  It also supports use of dynamic
   parameter sets via hook functions specified in <literal>ParamListInfo</>.
  </para>
-->
<para>
<function>SPI_cursor_open_with_paramlist</function>设置一个游标（内部的，一个入口），
该游标将执行一个<function>SPI_prepare</function>准备的已准备好的语句。
这个函数相当于<function>SPI_cursor_open</function>，
除了要传递给查询的有关参数值信息的表现不同。<literal>ParamListInfo</>
表示法可以方便的传递早已在该格式中可用的值。它也支持使用动态参数设置，
通过<literal>ParamListInfo</>中指定的hook函数。
</para>

  <!--
<para>
   The passed-in parameter data will be copied into the cursor's portal, so it
   can be freed while the cursor still exists.
  </para>
-->
<para>
传入参数数据将被拷贝到游标的入口，所以它在游标仍然存在时可以被释放。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>name</parameter></literal></term>
    <listitem>
     <!--
<para>
      name for portal, or <symbol>NULL</symbol> to let the system
      select a name
     </para>
-->
<para>
入口的名字，或者是<symbol>NULL</symbol>让系统选择一个名字
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <!--
<para>
      prepared statement (returned by <function>SPI_prepare</function>)
     </para>
-->
<para>
预备语句（<function>SPI_prepare</function>返回的）
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ParamListInfo <parameter>params</parameter></literal></term>
    <listitem>
     <!--
<para>
      data structure containing parameter types and values; NULL if none
     </para>
-->
<para>
包含参数类型和值的数据结构；如果没有则为NULL
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
     <!--
<para><literal>true</> for read-only execution</para>
-->
<para>
<literal>true</>用于只读的执行
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
    <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>

  <!--
<para>
   Pointer to portal containing the cursor.  Note there is no error
   return convention; any error will be reported via <function>elog</>.
  </para>
-->
<para>
指向包含游标入口的指针。请注意，这里没有错误返回约定；
任何错误都将通过<function>elog</>报告。
</para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-find">
 <indexterm><primary>SPI_cursor_find</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_cursor_find</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_cursor_find</refname>
  <!--
  <refpurpose>find an existing cursor by name</refpurpose>
  -->
  <refpurpose>用名字寻找并执行一个现存的游标</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
Portal SPI_cursor_find(const char * <parameter>name</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_cursor_find</function> finds an existing portal by
   name.  This is primarily useful to resolve a cursor name returned
   as text by some other function.
  </para>
-->
<para>
<function>SPI_cursor_find</function>通过名字寻找一个现存的入口。
主要用于解析一些其它函数返回的文本的游标名字。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>name</parameter></literal></term>
    <listitem>
     <!--
<para>
      name of the portal
     </para>
-->
<para>
入口的名字
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
    <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>

  <!--
<para>
   pointer to the portal with the specified name, or
   <symbol>NULL</symbol> if none was found
  </para>
-->
<para>
指向指定名称的入口的指针，如果没有找到就是<symbol>NULL</symbol>
</para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-fetch">
 <indexterm><primary>SPI_cursor_fetch</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_cursor_fetch</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_cursor_fetch</refname>
  <!--
  <refpurpose>fetch some rows from a cursor</refpurpose>
  -->
  <refpurpose>从一个游标里抓取一些行</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
void SPI_cursor_fetch(Portal <parameter>portal</parameter>, bool <parameter>forward</parameter>, long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_cursor_fetch</function> fetches some rows from a
   cursor.  This is equivalent to a subset of the SQL command
   <command>FETCH</> (see <function>SPI_scroll_cursor_fetch</function>
   for more functionality).
  </para>
-->
<para>
<function>SPI_cursor_fetch</function>从一个游标里抓取一些行。
这个函数等效于 SQL 命令<command>FETCH</>的一个子集（参阅
<function>SPI_scroll_cursor_fetch</function>获取更多功能性）。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>Portal <parameter>portal</parameter></literal></term>
    <listitem>
     <!--
<para>
      portal containing the cursor
     </para>
-->
<para>
包含游标的入口
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>forward</parameter></literal></term>
    <listitem>
     <!--
<para>
      true for fetch forward, false for fetch backward
     </para>
-->
<para>
向前抓取时为真，向后抓取时为假
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
     <!--
<para>
      maximum number of rows to fetch
     </para>
-->
<para>
要抓取的最大行数
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
    <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>

  <!--
<para>
   <varname>SPI_processed</varname> and
   <varname>SPI_tuptable</varname> are set as in
   <function>SPI_execute</function> if successful.
  </para>
-->
<para>
成功时，像<function>SPI_execute</function>那样设置
<varname>SPI_processed</varname>和<varname>SPI_tuptable</varname>
</para>
 </refsect1>

 <refsect1>
  <!--
<title>Notes</title>
-->
<title>注意</title>

  <!--
<para>
   Fetching backward may fail if the cursor's plan was not created
   with the <symbol>CURSOR_OPT_SCROLL</symbol> option.
  </para>
-->
<para>
如果游标的规划没有带有<symbol>CURSOR_OPT_SCROLL</symbol>选项创建，
那么向后抓取会失败。
</para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-move">
 <indexterm><primary>SPI_cursor_move</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_cursor_move</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_cursor_move</refname>
  <!--
  <refpurpose>move a cursor</refpurpose>
  -->
  <refpurpose>移动一个游标</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
void SPI_cursor_move(Portal <parameter>portal</parameter>, bool <parameter>forward</parameter>, long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_cursor_move</function> skips over some number of rows
   in a cursor.  This is equivalent to a subset of the SQL command
   <command>MOVE</> (see <function>SPI_scroll_cursor_move</function>
   for more functionality).
  </para>
-->
<para>
<function>SPI_cursor_move</function>忽略游标中的一些行。
这个函数等效于 SQL 命令<command>MOVE</>的一个子集（参阅
<function>SPI_scroll_cursor_move</function>获取更多功能性）。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>Portal <parameter>portal</parameter></literal></term>
    <listitem>
     <!--
<para>
      portal containing the cursor
     </para>
-->
<para>
包含游标的入口
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>forward</parameter></literal></term>
    <listitem>
     <!--
<para>
      true for move forward, false for move backward
     </para>
-->
<para>
向前移动时为真，向后移动时为假
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
     <!--
<para>
      maximum number of rows to move
     </para>
-->
<para>
移动的最大行数
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <!--
<title>Notes</title>
-->
<title>注意</title>

  <!--
<para>
   Moving backward may fail if the cursor's plan was not created
   with the <symbol>CURSOR_OPT_SCROLL</symbol> option.
  </para>
-->
<para>
如果游标的规划没有带有<symbol>CURSOR_OPT_SCROLL</symbol>选项创建，
那么向后移动会失败。
</para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-scroll-cursor-fetch">
 <indexterm><primary>SPI_scroll_cursor_fetch</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_scroll_cursor_fetch</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_scroll_cursor_fetch</refname>
  <!--
  <refpurpose>fetch some rows from a cursor</refpurpose>
  -->
  <refpurpose>从一个游标中抓取一些行</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
void SPI_scroll_cursor_fetch(Portal <parameter>portal</parameter>, FetchDirection <parameter>direction</parameter>,
                             long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_scroll_cursor_fetch</function> fetches some rows from a
   cursor.  This is equivalent to the SQL command <command>FETCH</>.
  </para>
-->
<para>
<function>SPI_scroll_cursor_fetch</function>从一个游标中抓取一些行。
这个函数等效于SQL命令的<command>FETCH</>。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>Portal <parameter>portal</parameter></literal></term>
    <listitem>
     <!--
<para>
      portal containing the cursor
     </para>
-->
<para>
包含游标的入口
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FetchDirection <parameter>direction</parameter></literal></term>
    <listitem>
     <!--
<para>
      one of <symbol>FETCH_FORWARD</symbol>,
      <symbol>FETCH_BACKWARD</symbol>,
      <symbol>FETCH_ABSOLUTE</symbol> or
      <symbol>FETCH_RELATIVE</symbol>
     </para>
-->
<para>
<symbol>FETCH_FORWARD</symbol>、<symbol>FETCH_BACKWARD</symbol>、
<symbol>FETCH_ABSOLUTE</symbol>或<symbol>FETCH_RELATIVE</symbol>之一
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
     <!--
<para>
      number of rows to fetch for
      <symbol>FETCH_FORWARD</symbol> or
      <symbol>FETCH_BACKWARD</symbol>; absolute row number to fetch for
      <symbol>FETCH_ABSOLUTE</symbol>; or relative row number to fetch for
      <symbol>FETCH_RELATIVE</symbol>
     </para>
-->
<para>
<symbol>FETCH_FORWARD</symbol>或<symbol>FETCH_BACKWARD</symbol>
抓取的最大行数；<symbol>FETCH_ABSOLUTE</symbol>抓取的绝对行数；
或<symbol>FETCH_RELATIVE</symbol>抓取的相对行数。
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
    <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>

  <!--
<para>
   <varname>SPI_processed</varname> and
   <varname>SPI_tuptable</varname> are set as in
   <function>SPI_execute</function> if successful.
  </para>
-->
<para>
如果成功，<varname>SPI_processed</varname>和<varname>SPI_tuptable</varname>
的设置和<function>SPI_execute</function>里一样。
</para>
 </refsect1>

 <refsect1>
  <!--
<title>Notes</title>
-->
<title>注意</title>

  <!--
<para>
   See the SQL <xref linkend="sql-fetch"> command
   for details of the interpretation of the
   <parameter>direction</parameter> and
   <parameter>count</parameter> parameters.
  </para>
-->
<para>
参阅SQL<xref linkend="sql-fetch">命令获取<parameter>direction</parameter>
和<parameter>count</parameter>参数的解释的详细信息。
</para>

  <!--
<para>
   Direction values other than <symbol>FETCH_FORWARD</symbol>
   may fail if the cursor's plan was not created
   with the <symbol>CURSOR_OPT_SCROLL</symbol> option.
  </para>
-->
<para>
如果游标的规划没有带有<symbol>CURSOR_OPT_SCROLL</symbol>选项创建，
那么方向值而不是<symbol>FETCH_FORWARD</symbol>会失败。
</para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-scroll-cursor-move">
 <indexterm><primary>SPI_scroll_cursor_move</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_scroll_cursor_move</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_scroll_cursor_move</refname>
  <!--
  <refpurpose>move a cursor</refpurpose>
  -->
  <refpurpose>移动一个游标</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
void SPI_scroll_cursor_move(Portal <parameter>portal</parameter>, FetchDirection <parameter>direction</parameter>,
                            long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_scroll_cursor_move</function> skips over some number of rows
   in a cursor.  This is equivalent to the SQL command
   <command>MOVE</>.
  </para>
-->
<para>
<function>SPI_scroll_cursor_move</function>忽略游标中的一些行数。
这个函数相当于SQL命令<command>MOVE</>。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>Portal <parameter>portal</parameter></literal></term>
    <listitem>
     <!--
<para>
      portal containing the cursor
     </para>
-->
<para>
包含游标的入口
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FetchDirection <parameter>direction</parameter></literal></term>
    <listitem>
     <!--
<para>
      one of <symbol>FETCH_FORWARD</symbol>,
      <symbol>FETCH_BACKWARD</symbol>,
      <symbol>FETCH_ABSOLUTE</symbol> or
      <symbol>FETCH_RELATIVE</symbol>
     </para>
-->
<para>
<symbol>FETCH_FORWARD</symbol>、<symbol>FETCH_BACKWARD</symbol>、
<symbol>FETCH_ABSOLUTE</symbol>或<symbol>FETCH_RELATIVE</symbol>之一
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
     <!--
<para>
      number of rows to move for
      <symbol>FETCH_FORWARD</symbol> or
      <symbol>FETCH_BACKWARD</symbol>; absolute row number to move to for
      <symbol>FETCH_ABSOLUTE</symbol>; or relative row number to move to for
      <symbol>FETCH_RELATIVE</symbol>
     </para>
-->
<para>
<symbol>FETCH_FORWARD</symbol>或<symbol>FETCH_BACKWARD</symbol>移动的行数；
<symbol>FETCH_ABSOLUTE</symbol>移动的绝对行数；或<symbol>FETCH_RELATIVE</symbol>
移动的相对行数
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
    <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>

  <!--
<para>
   <varname>SPI_processed</varname> is set as in
   <function>SPI_execute</function> if successful.
   <varname>SPI_tuptable</varname> is set to <symbol>NULL</>, since
   no rows are returned by this function.
  </para>
-->
<para>
如果成功，<varname>SPI_processed</varname>的设置和<function>SPI_execute</function>
里的一样。<varname>SPI_tuptable</varname>设置为<symbol>NULL</>，
因为这个函数没有返回行。
</para>
 </refsect1>

 <refsect1>
  <!--
<title>Notes</title>
-->
<title>注意</title>

  <!--
<para>
   See the SQL <xref linkend="sql-fetch"> command
   for details of the interpretation of the
   <parameter>direction</parameter> and
   <parameter>count</parameter> parameters.
  </para>
-->
<para>
参阅SQL <xref linkend="sql-fetch">命令获取<parameter>direction</parameter>
和<parameter>count</parameter>参数的解释的详细信息。
</para>

  <!--
<para>
   Direction values other than <symbol>FETCH_FORWARD</symbol>
   may fail if the cursor's plan was not created
   with the <symbol>CURSOR_OPT_SCROLL</symbol> option.
  </para>
-->
<para>
如果游标的规划没有使用<symbol>CURSOR_OPT_SCROLL</symbol>选项创建，
那么方向值而不是<symbol>FETCH_FORWARD</symbol>会失败。
</para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-close">
 <indexterm><primary>SPI_cursor_close</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_cursor_close</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_cursor_close</refname>
  <!--
  <refpurpose>close a cursor</refpurpose>
  -->
  <refpurpose>关闭一个游标</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
void SPI_cursor_close(Portal <parameter>portal</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_cursor_close</function> closes a previously created
   cursor and releases its portal storage.
  </para>
-->
<para>
<function>SPI_cursor_close</function>关闭一个前面创建的游标并且释放其入口存储。
</para>

  <!--
<para>
   All open cursors are closed automatically at the end of a
   transaction.  <function>SPI_cursor_close</function> need only be
   invoked if it is desirable to release resources sooner.
  </para>
-->
<para>
在事务结尾，所有打开的游标都自动关闭。只有在希望更早释放资源的时候才需要调用
<function>SPI_cursor_close</function>。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>Portal <parameter>portal</parameter></literal></term>
    <listitem>
     <!--
<para>
      portal containing the cursor
     </para>
-->
<para>
包含游标的入口
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-keepplan">
 <indexterm><primary>SPI_keepplan</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_keepplan</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_keepplan</refname>
  <!--
  <refpurpose>save a prepared statement</refpurpose>
  -->
  <refpurpose>保存一个预备语句</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
int SPI_keepplan(SPIPlanPtr <parameter>plan</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_keepplan</function> saves a passed statement (prepared by
   <function>SPI_prepare</function>) so that it will not be freed
   by <function>SPI_finish</function> nor by the transaction manager.
   This gives you the ability to reuse prepared statements in the subsequent
   invocations of your procedure in the current session.
  </para>
-->
<para>
<function>SPI_keepplan</function>保存一个已经传递了的语句（<function>SPI_prepare</function>
准备的），所以它将不会通过<function>SPI_finish</function>或者事务管理器释放。
这给了你在当前会话中你的过程的随后调用重新使用预备语句的能力。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <!--
<para>
      the prepared statement to be saved
     </para>
-->
<para>
要保存的预备语句
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
    <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>

  <!--
<para>
   0 on success;
   <symbol>SPI_ERROR_ARGUMENT</symbol> if <parameter>plan</parameter>
   is <symbol>NULL</symbol> or invalid
  </para>
-->
<para>
成功时为0；如果<parameter>plan</parameter>是<symbol>NULL</symbol>或者无效的，
那么是<symbol>SPI_ERROR_ARGUMENT</symbol>
</para>
 </refsect1>

 <refsect1>
  <!--
<title>Notes</title>
-->
<title>注意</title>

  <!--
<para>
   The passed-in statement is relocated to permanent storage by means
   of pointer adjustment (no data copying is required).  If you later
   wish to delete it, use <function>SPI_freeplan</function> on it.
  </para>
-->
<para>
通过指针调整，传入参数重定位到参数存储（不需要拷贝数据）。
如果你稍后想要删除它，在其上使用<function>SPI_freeplan</function>。
</para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-saveplan">
 <indexterm><primary>SPI_saveplan</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_saveplan</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_saveplan</refname>
  <!--
  <refpurpose>save a prepared statement</refpurpose>
  -->
  <refpurpose>保存一个预备语句</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
SPIPlanPtr SPI_saveplan(SPIPlanPtr <parameter>plan</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_saveplan</function> copies a passed statement (prepared by
   <function>SPI_prepare</function>) into memory that will not be freed
   by <function>SPI_finish</function> nor by the transaction manager,
   and returns a pointer to the copied statement.  This gives you the
   ability to reuse prepared statements in the subsequent invocations of
   your procedure in the current session.
  </para>
-->
<para>
<function>SPI_saveplan</function>在内存里保存一个传递进来的语句(用
<function>SPI_prepare</function>准备的)，它将不会被<function>SPI_finish</function>
和事务管理器释放，并且返回一个指向拷贝的语句的指针。
这样就给你在当前会话里的随后的调用中复用这个预备规划的能力。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <!--
<para>
      the prepared statement to be saved
     </para>
-->
<para>
要保存的预备语句
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
    <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>

  
<para>
<!-- 
   Pointer to the copied statement; or <symbol>NULL</symbol> if unsuccessful.
   On error, <varname>SPI_result</varname> is set thus:
-->
指向保存的规划的指针；如果不成功则为 NULL 。出错的时候，像下面这样设置 SPI_result ：
   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
<!--
      <para>
       if <parameter>plan</parameter> is <symbol>NULL</symbol> or invalid
      </para>
-->
<para>
如果<parameter>plan</parameter>是<symbol>NULL</symbol>或者无效的
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
     <listitem>
      <!--
<para>
       if called from an unconnected procedure
      </para>
-->
<para>
如果从一个未连接的过程中调用
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>

 <refsect1>
  <!--
<title>Notes</title>
-->
<title>注意</title>

  <!--
<para>
   The originally passed-in statement is not freed, so you might wish to do
   <function>SPI_freeplan</function> on it to avoid leaking memory
   until <function>SPI_finish</>.
  </para>
-->
<para>
原先传入的语句并没有释放，所以你可能希望在其上执行<function>SPI_freeplan</function>，
以避免内存泄露直到<function>SPI_finish</>。
</para>

  <!--
<para>
   In most cases, <function>SPI_keepplan</function> is preferred to this
   function, since it accomplishes largely the same result without needing
   to physically copy the prepared statement's data structures.
  </para>
-->
<para>
在大多数情况下，<function>SPI_keepplan</function>偏爱这个函数，
因为它基本上不需要物理上拷贝预备语句的数据结构就完成了相同的结果。
</para>
 </refsect1>
</refentry>

</sect1>

<sect1 id="spi-interface-support">
 <!--
 <title>Interface Support Functions</title>
 -->
 <title>接口支持函数</title>

 <!--
<para>
  The functions described here provide an interface for extracting
  information from result sets returned by <function>SPI_execute</> and
  other SPI functions.
 </para>
-->
<para>
这里描述的函数提供了从<function>SPI_execute</>返回的结果集以及其它
 SPI 接口函数中抽取信息的便利的接口。
</para>

 <!--
<para>
  All functions described in this section can be used by both
  connected and unconnected procedures.
 </para>
-->
<para>
所有本节描述的函数都可以用于已连接和未连接的过程。
</para>

<!-- *********************************************** -->

<refentry id="spi-spi-fname">
 <indexterm><primary>SPI_fname</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_fname</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_fname</refname>
  <!--
  <refpurpose>determine the column name for the specified column number</refpurpose>
  -->
  <refpurpose>从指定的字段编号判断字段名字</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
char * SPI_fname(TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_fname</function> returns a copy of the column name of the
   specified column.  (You can use <function>pfree</function> to
   release the copy of the name when you don't need it anymore.)
  </para>
-->
<para>
<function>SPI_fname</function>返回指定字段的字段名字。你可以在不在需要的时候用
<function>pfree</function>释放这个名字的副本占据的空间。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
     <!--
<para>
      input row description
     </para>
-->
<para>
输入行描述
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>colnumber</parameter></literal></term>
    <listitem>
     <!--
<para>
      column number (count starts at 1)
     </para>
-->
<para>
字段编号(从 1 开始)
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
    <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>

  <!--
<para>
   The column name; <symbol>NULL</symbol> if
   <parameter>colnumber</parameter> is out of range.
   <varname>SPI_result</varname> set to
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol> on error.
  </para>
-->
<para>
字段名；如果<parameter>colnumber</parameter>超出范围则返回<symbol>NULL</symbol>。
错误时，<varname>SPI_result</varname>设置为<symbol>SPI_ERROR_NOATTRIBUTE</symbol>。
</para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-fnumber">
 <indexterm><primary>SPI_fnumber</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_fnumber</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_fnumber</refname>
  <!--
  <refpurpose>determine the column number for the specified column name</refpurpose>
  -->
  <refpurpose>判断声明字段名的字段编号</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
int SPI_fnumber(TupleDesc <parameter>rowdesc</parameter>, const char * <parameter>colname</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_fnumber</function> returns the column number for the
   column with the specified name.
  </para>
-->
<para>
<function>SPI_fnumber</function>返回声明名字的字段的字段编号。
</para>

  <!--
<para>
   If <parameter>colname</parameter> refers to a system column (e.g.,
   <literal>oid</>) then the appropriate negative column number will
   be returned.  The caller should be careful to test the return value
   for exact equality to <symbol>SPI_ERROR_NOATTRIBUTE</symbol> to
   detect an error; testing the result for less than or equal to 0 is
   not correct unless system columns should be rejected.
  </para>
-->
<para>
如果<parameter>colname</parameter>引用的是一个系统字段(比如<literal>oid</>)，
那么将返回合适的负数字段编号。调用者应该仔细测试返回值是
<symbol>SPI_ERROR_NOATTRIBUTE</symbol>才能判断是一个错误；除非要拒绝系统字段，
否则，测试结果小于或者等于 0 是不正确的判断方法。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
     <!--
<para>
      input row description
     </para>
-->
<para>
输入行描述
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>colname</parameter></literal></term>
    <listitem>
     <!--
<para>
      column name
     </para>
-->
<para>
字段名
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
    <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>

  <!--
<para>
   Column number (count starts at 1), or
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol> if the named column was not
   found.
  </para>
-->
<para>
字段编号(从 1 开始记)，如果没有找到该名字的字段，
返回<symbol>SPI_ERROR_NOATTRIBUTE</symbol>
</para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-getvalue">
 <indexterm><primary>SPI_getvalue</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_getvalue</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_getvalue</refname>
  <!--
  <refpurpose>return the string value of the specified column</refpurpose>
  -->
  <refpurpose>返回声明字段的字符串值</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
char * SPI_getvalue(HeapTuple <parameter>row</parameter>, TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_getvalue</function> returns the string representation
   of the value of the specified column.
  </para>
-->
<para>
<function>SPI_getvalue</function>返回声明的字段的数值的字符串表现形式。
</para>

  <!--
<para>
   The result is returned in memory allocated using
   <function>palloc</function>.  (You can use
   <function>pfree</function> to release the memory when you don't
   need it anymore.)
  </para>
-->
<para>
结果是放在用<function>palloc</function>分配的内存里的。
在你不需要它之后，你可以使用<function>pfree</function>释放内存。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
     <!--
<para>
      input row to be examined
     </para>
-->
<para>
要检查的输入行
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
     <!--
<para>
      input row description
     </para>
-->
<para>
输入行描述
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>colnumber</parameter></literal></term>
    <listitem>
     <!--
<para>
      column number (count starts at 1)
     </para>
-->
<para>
字段编号(从 1 开始)
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
    <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>

  <!--
<para>
   Column value, or <symbol>NULL</symbol> if the column is null,
   <parameter>colnumber</parameter> is out of range
   (<varname>SPI_result</varname> is set to
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol>), or no output function is
   available (<varname>SPI_result</varname> is set to
   <symbol>SPI_ERROR_NOOUTFUNC</symbol>).
  </para>
-->
<para>
字段值，如果字段是空，或者<parameter>colnumber</parameter>超出范围
(<varname>SPI_result</varname>设置为<symbol>SPI_ERROR_NOATTRIBUTE</symbol>)，
或者没有可用的输出函数(<varname>SPI_result</varname>设置为
<symbol>SPI_ERROR_NOOUTFUNC</symbol>)的时候，返回<symbol>NULL</symbol>。
</para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-getbinval">
 <indexterm><primary>SPI_getbinval</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_getbinval</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_getbinval</refname>
  <!--
  <refpurpose>return the binary value of the specified column</refpurpose>
  -->
  <refpurpose>返回声明字段的二进制值</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
Datum SPI_getbinval(HeapTuple <parameter>row</parameter>, TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>,
                    bool * <parameter>isnull</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_getbinval</function> returns the value of the
   specified column in the internal form (as type <type>Datum</type>).
  </para>
-->
<para>
<function>SPI_getbinval</function>以数据的内部形式(像类型<type>Datum</type>)
返回声明字段的数值。
</para>

  <!--
<para>
   This function does not allocate new space for the datum.  In the
   case of a pass-by-reference data type, the return value will be a
   pointer into the passed row.
  </para>
-->
<para>
这个函数并不为数据分配新的空间。如果是传递引用，那么返回值将是指向传递的行的指针。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
     <!--
<para>
      input row to be examined
     </para>
-->
<para>
输入的要检查的行
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
     <!--
<para>
      input row description
     </para>
-->
<para>
输入行描述
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>colnumber</parameter></literal></term>
    <listitem>
     <!--
<para>
      column number (count starts at 1)
     </para>
-->
<para>
字段编号(从 1 开始记)
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool * <parameter>isnull</parameter></literal></term>
    <listitem>
     <!--
<para>
      flag for a null value in the column
     </para>
-->
<para>
字段里 NULL 的标志
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
    <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>

  <!--
<para>
   The binary value of the column is returned.  The variable pointed
   to by <parameter>isnull</parameter> is set to true if the column is
   null, else to false.
  </para>
-->
<para>
返回该字段的二进制值。如果字段为空，那么<parameter>isnull</parameter>
指向的变量设置为真，否则为假。
</para>

  <!--
<para>
   <varname>SPI_result</varname> is set to
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol> on error.
  </para>
-->
<para>
错误时，<varname>SPI_result</varname>设置为<symbol>SPI_ERROR_NOATTRIBUTE</symbol>。
</para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-gettype">
 <indexterm><primary>SPI_gettype</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_gettype</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_gettype</refname>
  <!--
  <refpurpose>return the data type name of the specified column</refpurpose>
  -->
  <refpurpose>返回声明字段的数据类型名</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
char * SPI_gettype(TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_gettype</function> returns a copy of the data type name of the
   specified column.  (You can use <function>pfree</function> to
   release the copy of the name when you don't need it anymore.)
  </para>
-->
<para>
<function>SPI_gettype</function>返回声明字段的数据类型名字的一份拷贝。
如果你不再需要它了，你可以使用<function>pfree</function>释放名字的拷贝。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
     <!--
<para>
      input row description
     </para>
-->
<para>
输入行描述
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>colnumber</parameter></literal></term>
    <listitem>
     <!--
<para>
      column number (count starts at 1)
     </para>
-->
<para>
字段编号(从 1 开始记)
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
    <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>

  <!--
<para>
   The data type name of the specified column, or
   <symbol>NULL</symbol> on error.  <varname>SPI_result</varname> is
   set to <symbol>SPI_ERROR_NOATTRIBUTE</symbol> on error.
  </para>
-->
<para>
声明的字段的数据类型名，如果错误，则为<symbol>NULL</symbol> 。
错误时，<varname>SPI_result</varname>设置为<symbol>SPI_ERROR_NOATTRIBUTE</symbol>。
</para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-gettypeid">
 <indexterm><primary>SPI_gettypeid</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_gettypeid</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_gettypeid</refname>
  <!--
  <refpurpose>return the data type <acronym>OID</acronym> of the specified column</refpurpose>
  -->
  <refpurpose>返回声明字段的数据类型<acronym>OID</acronym></refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
Oid SPI_gettypeid(TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_gettypeid</function> returns the
   <acronym>OID</acronym> of the data type of the specified column.
  </para>
-->
<para>
<function>SPI_gettypeid</function>返回声明字段的数据类型的<acronym>OID</acronym>。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
     <!--
<para>
      input row description
     </para>
-->
<para>
输入行描述
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>colnumber</parameter></literal></term>
    <listitem>
     <!--
<para>
      column number (count starts at 1)
     </para>
-->
<para>
字段编号(从 1 开始记)
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
    <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>

  <!--
<para>
   The <acronym>OID</acronym> of the data type of the specified column
   or <symbol>InvalidOid</symbol> on error.  On error,
   <varname>SPI_result</varname> is set to
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol>.
  </para>
-->
<para>
声明字段的数据类型的<acronym>OID</acronym>，或者错误时是<symbol>InvalidOid</symbol>。
在出错的时候，<varname>SPI_result</varname>设置为<symbol>SPI_ERROR_NOATTRIBUTE</symbol>。
</para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-getrelname">
 <indexterm><primary>SPI_getrelname</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_getrelname</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_getrelname</refname>
  <!-- 
  <refpurpose>return the name of the specified relation</refpurpose>
  -->
  <refpurpose>返回声明关系的名字</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
char * SPI_getrelname(Relation <parameter>rel</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_getrelname</function> returns a copy of the name of the
   specified relation.  (You can use <function>pfree</function> to
   release the copy of the name when you don't need it anymore.)
  </para>
-->
<para>
<function>SPI_getrelname</function>返回声明的关系的名字之一份拷贝。
如果你不再需要这个名字，可以用<function>pfree</function>释放这个拷贝。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>Relation <parameter>rel</parameter></literal></term>
    <listitem>
     <!--
<para>
      input relation
     </para>
-->
<para>
输入关系
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
    <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>

  <!--
<para>
   The name of the specified relation.
  </para>
-->
<para>
声明的关系的名字。
</para>
 </refsect1>
</refentry>

<refentry id="spi-spi-getnspname">
 <indexterm><primary>SPI_getnspname</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_getnspname</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_getnspname</refname>
  <!-- 
  <refpurpose>return the namespace of the specified relation</refpurpose>
  -->
  <refpurpose>返回声明关系的名字空间</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
char * SPI_getnspname(Relation <parameter>rel</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_getnspname</function> returns a copy of the name of
   the namespace that the specified <structname>Relation</structname>
   belongs to. This is equivalent to the relation's schema. You should
   <function>pfree</function> the return value of this function when
   you are finished with it.
  </para>
-->
<para>
<function>SPI_getnspname</function>返回一份声明的<structname>Relation</structname>
所属的名字空间的名字的拷贝。这个数值等于该关系的模式。在你使用完毕之后，
应该<function>pfree</function>这个函数的返回值。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>Relation <parameter>rel</parameter></literal></term>
    <listitem>
     <!--
<para>
      input relation
     </para>
-->
<para>
输入关系
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
    <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>

  <!--
<para>
   The name of the specified relation's namespace.
  </para>
-->
<para>
声明关系的名字空间的名字
</para>
 </refsect1>
</refentry>

 </sect1>

 <sect1 id="spi-memory">
  <!--
  <title>Memory Management</title>
  -->
  <title>内存管理</title>

  <!--
<para>
    <indexterm>
     <primary>memory context</primary>
     <secondary>in SPI</secondary>
    </indexterm>
   <productname>PostgreSQL</productname> allocates memory within
   <firstterm>memory contexts</firstterm>, which provide a convenient method of
   managing allocations made in many different places that need to
   live for differing amounts of time.  Destroying a context releases
   all the memory that was allocated in it.  Thus, it is not necessary
   to keep track of individual objects to avoid memory leaks; instead
   only a relatively small number of contexts have to be managed.
   <function>palloc</function> and related functions allocate memory
   from the <quote>current</> context.
  </para>
-->
<para>
    <indexterm>
     <primary>内存环境</primary>
     <secondary>在SPI中</secondary>
    </indexterm>
<productname>PostgreSQL</productname>在<firstterm>内存环境</firstterm>中分配内存，
它提供了在许多地方分配的，有着不同的生命期的许多内存块的一个方便的管理方法。
删除一个环境则释放所有在其内部分配的内存。因此，没必要跟踪独立的对象以避免内存泄漏；
而是只要管理少量的环境。<function>palloc</function>和相关的函数从<quote>当前</>
的环境中分配内存。
</para>

  <!--
<para>
   <function>SPI_connect</function> creates a new memory context and
   makes it current.  <function>SPI_finish</function> restores the
   previous current memory context and destroys the context created by
   <function>SPI_connect</function>.  These actions ensure that
   transient memory allocations made inside your procedure are
   reclaimed at procedure exit, avoiding memory leakage.
  </para>
-->
<para>
<function>SPI_connect</function>创建一个新的内存环境并且将其标记为当前的环境。
<function>SPI_finish</function>恢复前一个内存环境并且删除<function>SPI_connect</function>
创建的环境。这些动作确保在你的过程中分配的临时内存在过程结尾的时候都被回收，避免内存泄漏。
</para>

  <!--
<para>
   However, if your procedure needs to return an object in allocated
   memory (such as a value of a pass-by-reference data type), you
   cannot allocate that memory using <function>palloc</function>, at
   least not while you are connected to SPI.  If you try, the object
   will be deallocated by <function>SPI_finish</function>, and your
   procedure will not work reliably.  To solve this problem, use
   <function>SPI_palloc</function> to allocate memory for your return
   object.  <function>SPI_palloc</function> allocates memory in the
   <quote>upper executor context</quote>, that is, the memory context
   that was current when <function>SPI_connect</function> was called,
   which is precisely the right context for a value returned from your
   procedure.
  </para>
-->
<para>
不过，如果你的过程需要返回一个已分配的内存对象(比如一个传递引用的数据类型)，
那么你就不能用<function>palloc</function>分配返回的对象，
至少是不能在你已经和 SPI 连接上的时候。如果你试图这么做，
那么该对象将在<function>SPI_finish</function>的时候被释放，
因而你的过程就不能可靠地工作了!要解决这个问题，使用<function>SPI_palloc</function>
分配内存给你的返回对象。<function>SPI_palloc</function>从<quote>上层执行者环境</quote>
中分配空间，也就是调用<function>SPI_connect</function>时候的当前环境内存环境，
该环境是从你的过程返回数值的正确环境。
</para>

  <!--
<para>
   If <function>SPI_palloc</function> is called while the procedure is
   not connected to SPI, then it acts the same as a normal
   <function>palloc</function>.  Before a procedure connects to the
   SPI manager, the current memory context is the upper executor
   context, so all allocations made by the procedure via
   <function>palloc</function> or by SPI utility functions are made in
   this context.
  </para>
-->
<para>
如果还没有连接到 SPI 的时候调用它，<function>SPI_palloc</function>
的行为和简单的<function>palloc</function>一样。在一个过程和 SPI 管理器连接之前，
当前的内存环境是上层执行者环境，因此所有该过程使用<function>palloc</function>
或者 SPI 工具函数分配的空间都是在这个环境中分配的。
</para>

  <!--
<para>
   When <function>SPI_connect</function> is called, the private
   context of the procedure, which is created by
   <function>SPI_connect</function>, is made the current context.  All
   allocations made by <function>palloc</function>,
   <function>repalloc</function>, or SPI utility functions (except for
   <function>SPI_copytuple</function>,
   <function>SPI_returntuple</function>,
   <function>SPI_modifytuple</function>, and
   <function>SPI_palloc</function>) are made in this context.  When a
   procedure disconnects from the SPI manager (via
   <function>SPI_finish</function>) the current context is restored to
   the upper executor context, and all allocations made in the
   procedure memory context are freed and cannot be used any more.
  </para>
-->
<para>
在调用<function>SPI_connect</function>之后，当前环境是该过程私有的，
由<function>SPI_connect</function>制作的环境。所有通过<function>palloc</function>、
<function>repalloc</function>或者 SPI 工具函数(除了<function>SPI_copytuple</function>、
<function>SPI_returntuple</function>、<function>SPI_modifytuple</function>和
<function>SPI_palloc</function>)分配的内存都是在这个环境中分配的。
如果一个过程与 SPI 管理器断开(通过<function>SPI_finish</function>)，
那么当前环境恢复为上层执行器环境，
并且所有在该过程的内存环境中分配的内存都释放掉并且不能再次使用！
</para>

  <!--
<para>
   All functions described in this section can be used by both
   connected and unconnected procedures.  In an unconnected procedure,
   they act the same as the underlying ordinary server functions
   (<function>palloc</>, etc.).
  </para>
-->
<para>
所有在本节内描述的函数都可以在已连接的和未连接的过程中使用。
在未连接的过程中，他们的行为和下层的原始后端函数(<function>palloc</>等)相同。
</para>

<!-- *********************************************** -->

<refentry id="spi-spi-palloc">
 <indexterm><primary>SPI_palloc</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_palloc</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_palloc</refname>
  <!--
  <refpurpose>allocate memory in the upper executor context</refpurpose>
  -->
  <refpurpose>在上层执行器环境里分配内存</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
void * SPI_palloc(Size <parameter>size</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_palloc</function> allocates memory in the upper
   executor context.
  </para>
-->
<para>
<function>SPI_palloc</function>在上层执行者环境里分配内存。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>Size <parameter>size</parameter></literal></term>
    <listitem>
     <!--
<para>
      size in bytes of storage to allocate
     </para>
-->
<para>
要分配的存储空间的，以字节记
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
    <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>

  <!--
<para>
   pointer to new storage space of the specified size
  </para>
-->
<para>
指向声明尺寸的新空间的指针
</para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-realloc">
 <indexterm><primary>SPI_repalloc</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_repalloc</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_repalloc</refname>
  <!--
  <refpurpose>reallocate memory in the upper executor context</refpurpose>
  -->
  <refpurpose>在上层执行器环境里重新分配内存</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
void * SPI_repalloc(void * <parameter>pointer</parameter>, Size <parameter>size</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_repalloc</function> changes the size of a memory
   segment previously allocated using <function>SPI_palloc</function>.
  </para>
-->
<para>
<function>SPI_repalloc</function>改变一个前面用<function>SPI_palloc</function>
分配的内存段的大小。
</para>

  <!--
<para>
   This function is no longer different from plain
   <function>repalloc</function>.  It's kept just for backward
   compatibility of existing code.
  </para>
-->
<para>
这个函数现在和<function>repalloc</function>没什么区别。保留它只是为了向后兼容现有的代码。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>void * <parameter>pointer</parameter></literal></term>
    <listitem>
     <!--
<para>
      pointer to existing storage to change
     </para>
-->
<para>
一个指向现有存储的指针
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Size <parameter>size</parameter></literal></term>
    <listitem>
     <!--
<para>
      size in bytes of storage to allocate
     </para>
-->
<para>
分配的内存的大小，以字节记
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
    <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>

  <!--
<para>
   pointer to new storage space of specified size with the contents
   copied from the existing area
  </para>
-->
<para>
一个指向新存储空间的指针，大小为你声明的大小，并且从现有区域里拷贝了内存
</para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-pfree">
 <indexterm><primary>SPI_pfree</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_pfree</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_pfree</refname>
  <!--
  <refpurpose>free memory in the upper executor context</refpurpose>
  -->
  <refpurpose>在上层执行器环境里释放内存</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
void SPI_pfree(void * <parameter>pointer</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_pfree</function> frees memory previously allocated
   using <function>SPI_palloc</function> or
   <function>SPI_repalloc</function>.
  </para>
-->
<para>
<function>SPI_pfree</function>释放前面用<function>SPI_palloc</function>
或<function>SPI_repalloc</function>分配的内存。
</para>

  <!--
<para>
   This function is no longer different from plain
   <function>pfree</function>.  It's kept just for backward
   compatibility of existing code.
  </para>
-->
<para>
这个函数和<function>pfree</function>没什么不同。保留它主要是为了向下兼容现有代码。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>void * <parameter>pointer</parameter></literal></term>
    <listitem>
     <!--
<para>
      pointer to existing storage to free
     </para>
-->
<para>
一个指向要释放的现有内存的指针
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-copytuple">
 <indexterm><primary>SPI_copytuple</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_copytuple</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_copytuple</refname>
  <!--
  <refpurpose>make a copy of a row in the upper executor context</refpurpose>
  -->
  <refpurpose>在上层执行者环境里制作一个行的拷贝</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
HeapTuple SPI_copytuple(HeapTuple <parameter>row</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_copytuple</function> makes a copy of a row in the
   upper executor context.  This is normally used to return a modified
   row from a trigger.  In a function declared to return a composite
   type, use <function>SPI_returntuple</function> instead.
  </para>
-->
<para>
<function>SPI_copytuple</function>在上层执行者环境里制作一个行的拷贝。
这个函数通常用于从触发器里返回一个修改过的行。在声明为返回复合类型的函数里，
应该使用<function>SPI_returntuple</function>。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
     <!--
<para>
      row to be copied
     </para>
-->
<para>
要拷贝的行
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
    <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>

  <!--
<para>
   the copied row; <symbol>NULL</symbol> only if
   <parameter>tuple</parameter> is <symbol>NULL</symbol>
  </para>
-->
<para>
拷贝行；只有在<parameter>tuple</parameter>是<symbol>NULL</symbol>
的时候为<symbol>NULL</symbol>
</para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-returntuple">
 <indexterm><primary>SPI_returntuple</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_returntuple</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_returntuple</refname>
  <!--
  <refpurpose>prepare to return a tuple as a Datum</refpurpose>
  -->
  <refpurpose>准备把一个行当作 Datum 返回</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
HeapTupleHeader SPI_returntuple(HeapTuple <parameter>row</parameter>, TupleDesc <parameter>rowdesc</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_returntuple</function> makes a copy of a row in
   the upper executor context, returning it in the form of a row type <type>Datum</type>.
   The returned pointer need only be converted to <type>Datum</type> via <function>PointerGetDatum</function>
   before returning.
  </para>
-->
<para>
<function>SPI_returntuple</function>在上层执行者环境里制作一个行的拷贝，
并且把它以行类型<type>Datum</type>的形式返回。
所返回的指针在返回之前只需要用<function>PointerGetDatum</function>转换成<type>Datum</type>。
</para>

  <!--
<para>
   Note that this should be used for functions that are declared to return
   composite types.  It is not used for triggers; use
   <function>SPI_copytuple</> for returning a modified row in a trigger.
  </para>
-->
<para>
请注意这个函数应该只用于那些声明为返回复合类型的函数。它不用于触发器；
用<function>SPI_copytuple</>在触发器中返回一个修改过的行。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
     <!--
<para>
      row to be copied
     </para>
-->
<para>
将要被拷贝的行
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
     <!--
<para>
      descriptor for row (pass the same descriptor each time for most
      effective caching)
     </para>
-->
<para>
行的描述符(每次都传递同样的描述符可以获取最高缓冲效率)
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
    <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>

  <!--
<para>
   <type>HeapTupleHeader</type> pointing to copied row;
   <symbol>NULL</symbol> only if
   <parameter>row</parameter> or <parameter>rowdesc</parameter> is
   <symbol>NULL</symbol>
  </para>
-->
<para>
指向拷贝出来的行的<type>HeapTupleHeader</type>；只有在<parameter>row</parameter>
或<parameter>rowdesc</parameter>是<symbol>NULL</symbol>的时候才返回<symbol>NULL</symbol>
</para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-modifytuple">
 <indexterm><primary>SPI_modifytuple</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_modifytuple</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_modifytuple</refname>
  <!--
  <refpurpose>create a row by replacing selected fields of a given row</refpurpose>
  -->
  <refpurpose>通过替换一个给出行的选定的字段创建一行</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
HeapTuple SPI_modifytuple(Relation <parameter>rel</parameter>, HeapTuple <parameter>row</parameter>, int <parameter>ncols</parameter>,
                          int * <parameter>colnum</parameter>, Datum * <parameter>values</parameter>, const char * <parameter>nulls</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_modifytuple</function> creates a new row by
   substituting new values for selected columns, copying the original
   row's columns at other positions.  The input row is not modified.
  </para>
-->
<para>
<function>SPI_modifytuple</function>通过给选定的字段替换新值，
拷贝其它字段的原值的方法创建一个新行。不修改输入的行。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>Relation <parameter>rel</parameter></literal></term>
    <listitem>
     <!--
<para>
      Used only as the source of the row descriptor for the row.
      (Passing a relation rather than a row descriptor is a
      misfeature.)
     </para>
-->
<para>
只用于该行的行描述符的源(传递一个关系而不是一个行描述符是一个误特性)。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
     <!--
<para>
      row to be modified
     </para>
-->
<para>
要修改的行
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>ncols</parameter></literal></term>
    <listitem>
     <!--
<para>
      number of columns to be changed
     </para>
-->
<para>
要修改的字段数目
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int * <parameter>colnum</parameter></literal></term>
    <listitem>
     <!--
<para>
      an array of length <parameter>ncols</parameter>, containing the numbers
      of the columns that are to be changed (column numbers start at 1)
     </para>
-->
<para>
长度<parameter>ncols</parameter>的一个数组，包含要修改的字段的数目(字段编号从 1 开始记)
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Datum * <parameter>values</parameter></literal></term>
    <listitem>
     <!--
<para>
      an array of length <parameter>ncols</parameter>, containing the
      new values for the specified columns
     </para>
-->
<para>
长度<parameter>ncols</parameter>的一个数组，包含声明字段的新值
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
    <listitem>
     <!--
<para>
      an array of length <parameter>ncols</parameter>, describing which
      new values are null
     </para>
-->
<para>
长度<parameter>ncols</parameter>的一个数组，描述哪个新值是空
</para>

     <!--
<para>
      If <parameter>nulls</parameter> is <symbol>NULL</symbol> then
      <function>SPI_modifytuple</function> assumes that no new values
      are null.  Otherwise, each entry of the <parameter>nulls</parameter>
      array should be <literal>'&nbsp;'</> if the corresponding new value is
      non-null, or <literal>'n'</> if the corresponding new value is
      null.  (In the latter case, the actual value in the corresponding
      <parameter>values</parameter> entry doesn't matter.)  Note that
      <parameter>nulls</parameter> is not a text string, just an array: it
      does not need a <literal>'\0'</> terminator.
     </para>
-->
<para>
如果<parameter>nulls</parameter>是<symbol>NULL</symbol>，那么<function>SPI_modifytuple</function>
假设没有参数为空。否则，如果对应的参数值是非空的，那么<parameter>nulls</parameter>
数组的每一项都应该是<literal>'&nbsp;'</>，或者如果对应的参数值为空，那么
<parameter>nulls</parameter>数组的每一项都是<literal>'n'</>。
（在后面这种情况下，对应的<parameter>values</parameter>项中的实际值无关紧要。）
请注意，<parameter>nulls</parameter>不是文本字符串，只是一个数组：
它不需要<literal>'\0'</>终止符。
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
    <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>

  <!--
<para>
   new row with modifications, allocated in the upper executor
   context; <symbol>NULL</symbol> only if <parameter>row</parameter>
   is <symbol>NULL</symbol>
  </para>
-->
<para>
修改后的新行，在上层执行者环境里分配；只有在<parameter>row</parameter>
是<symbol>NULL</symbol>的时候为<symbol>NULL</symbol>
</para>

  
<para>
<!-- 
   On error, <varname>SPI_result</varname> is set as follows:
-->
错误时，<varname>SPI_result</varname>的设置如下：
   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
<!--
      <para>
       if <parameter>rel</> is <symbol>NULL</>, or if
       <parameter>row</> is <symbol>NULL</>, or if <parameter>ncols</>
       is less than or equal to 0, or if <parameter>colnum</> is
       <symbol>NULL</>, or if <parameter>values</> is <symbol>NULL</>.
      </para>
-->
<para>
如果<parameter>rel</>是<symbol>NULL</>，或者如果<parameter>row</>是<symbol>NULL</>，
或者如果<parameter>ncols</>小于或者等于 0 ，或者<parameter>colnum</>是<symbol>NULL</>，
或者如果<parameter>values</>是<symbol>NULL</>。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_NOATTRIBUTE</symbol></term>
     <listitem>
      <!--
<para>
       if <parameter>colnum</> contains an invalid column number (less
       than or equal to 0 or greater than the number of column in
       <parameter>row</>)
      </para>
-->
<para>
如果<parameter>colnum</>包含一个无效的字段编号(小于或者等于 0 或者大于
<parameter>row</>里的字段数)
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-freetuple">
 <indexterm><primary>SPI_freetuple</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_freetuple</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_freetuple</refname>
  <!--
  <refpurpose>free a row allocated in the upper executor context</refpurpose>
  -->
  <refpurpose>释放在上层执行者环境里分配的一行</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
void SPI_freetuple(HeapTuple <parameter>row</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_freetuple</function> frees a row previously allocated
   in the upper executor context.
  </para>
-->
<para>
<function>SPI_freetuple</function>释放一个前面在上层执行者环境里分配的行。
</para>

  <!--
<para>
   This function is no longer different from plain
   <function>heap_freetuple</function>.  It's kept just for backward
   compatibility of existing code.
  </para>
-->
<para>
这个函数和<function>heap_freetuple</function>没什么区别。保留它主要是为了向后兼容现有代码。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
     <!--
<para>
      row to free
     </para>
-->
<para>
要释放的行
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-freetupletable">
 <indexterm><primary>SPI_freetuptable</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_freetuptable</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_freetuptable</refname>
  <!--
  <refpurpose>free a row set created by <function>SPI_execute</> or a similar
  function</refpurpose>
  -->
  <refpurpose>释放一个由<function>SPI_execute</>或者类似的函数创建的行集</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
void SPI_freetuptable(SPITupleTable * <parameter>tuptable</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_freetuptable</function> frees a row set created by a
   prior SPI command execution function, such as
   <function>SPI_execute</>.  Therefore, this function is often called
   with the global variable <varname>SPI_tuptable</varname> as
   argument.
  </para>
-->
<para>
<function>SPI_freetuptable</function>释放一个由前面的 SPI 命令执行函数，
比如<function>SPI_execute</>创建的行集。因此，这个函数调用的时候通常用全局变量
<varname>SPI_tuptable</varname>作为参数。
</para>

  <!--
<para>
   This function is useful if a SPI procedure needs to execute
   multiple commands and does not want to keep the results of earlier
   commands around until it ends.  Note that any unfreed row sets will
   be freed anyway at <function>SPI_finish</>.
   Also, if a subtransaction is started and then aborted within execution
   of a SPI procedure, SPI automatically frees any row sets created while
   the subtransaction was running.
  </para>
-->
<para>
如果一个 SPI 过程需要执行多条命令并且不想把前面的命令的结果保存到其结尾的话，
那么这个函数就很有用。请注意任何没有释放的行集都会在<function>SPI_finish</>
的时候释放。另外，如果一个子事务开始并且然后在一个SPI过程的执行中退出，
那么SPI自动释放任何子事务运行时创建的行集。
</para>

  <!--
<para>
   Beginning in <productname>PostgreSQL</> 9.3,
   <function>SPI_freetuptable</function> contains guard logic to protect
   against duplicate deletion requests for the same row set.  In previous
   releases, duplicate deletions would lead to crashes.
  </para>
-->
<para>
在<productname>PostgreSQL</> 9.3中开始，<function>SPI_freetuptable</function>
包含保护逻辑防卫重复请求删除同一个行集。在以前的版本中，重复删除将会导致崩溃。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>SPITupleTable * <parameter>tuptable</parameter></literal></term>
    <listitem>
     <!--
<para>
      pointer to row set to free, or NULL to do nothing
     </para>
-->
<para>
一个指向要释放的行集的指针，或者什么也不做时为NULL
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-freeplan">
 <indexterm><primary>SPI_freeplan</primary></indexterm>
 <refmeta>
  <refentrytitle>SPI_freeplan</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_freeplan</refname>
  <!--
  <refpurpose>free a previously saved prepared statement</refpurpose>
  -->
  <refpurpose> 释放一个前面保存的预备语句</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
int SPI_freeplan(SPIPlanPtr <parameter>plan</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <function>SPI_freeplan</function> releases a prepared statement
   previously returned by <function>SPI_prepare</function> or saved by
   <function>SPI_keepplan</function> or <function>SPI_saveplan</function>.
  </para>
-->
<para>
<function>SPI_freeplan</function>释放一个以前由<function>SPI_prepare</function>
返回的或者是用<function>SPI_keepplan</function>或<function>SPI_saveplan</function>
保存的预备语句。
</para>
 </refsect1>

 <refsect1>
  <!--
  <title>Arguments</title>
  -->
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <!--
<para>
      pointer to statement to free
     </para>
-->
<para>
指向要释放的语句的指针
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
    <!--
  <title>Return Value</title>
  -->
  <title>返回值</title>

  <!--
<para>
   0 on success;
   <symbol>SPI_ERROR_ARGUMENT</symbol> if <parameter>plan</parameter>
   is <symbol>NULL</symbol> or invalid
  </para>
-->
<para>
成功时为0；如果<parameter>plan</parameter>是<symbol>NULL</symbol>或无效，
返回<symbol>SPI_ERROR_ARGUMENT</symbol>
</para>
 </refsect1>
</refentry>

 </sect1>

 <sect1 id="spi-visibility">
  <!--
  <title>Visibility of Data Changes</title>
  -->
  <title>数据改变的可视性</title>

  
<para>
<!-- 
   The following rules govern the visibility of data changes in
   functions that use SPI (or any other C function):
-->
下面规则决定使用 SPI(或者任何其它 C 函数)的函数里面的数据修改的可视性：
   <itemizedlist>
    <listitem>
<!--
     <para>
      During the execution of an SQL command, any data changes made by
      the command are invisible to the command itself.  For
      example, in:
<programlisting>
INSERT INTO a SELECT * FROM a;
</programlisting>
      the inserted rows are invisible to the <command>SELECT</command>
      part.
     </para>
-->
<para>
在一个 SQL 命令执行期间，任何这个命令做的数据改变都是命令本身所看不到的。
比如，在下面命令里：
<programlisting>
INSERT INTO a SELECT * FROM a;
</programlisting>
插入的行是<command>SELECT</command>部分看不到的。
</para>
    </listitem>

    <listitem>
     <!--
<para>
      Changes made by a command C are visible to all commands that are
      started after C, no matter whether they are started inside C
      (during the execution of C) or after C is done.
     </para>
-->
<para>
命令 C 做的修改可以被 C 之后开始的所有命令看到，不管他们是在 C 里面
(在执行 C 期间)还是在 C 完成后开始的。
</para>
    </listitem>

    <listitem>
     <!--
<para>
      Commands executed via SPI inside a function called by an SQL command
      (either an ordinary function or a trigger) follow one or the
      other of the above rules depending on the read/write flag passed
      to SPI.  Commands executed in read-only mode follow the first
      rule: they cannot see changes of the calling command.  Commands executed
      in read-write mode follow the second rule: they can see all changes made
      so far.
     </para>
-->
<para>
一个命令，如果是在一个 SQL 命令调用的函数(普通函数或者是触发器)里通过 SPI 执行的，
那么它遵循上面两个规则之一，具体哪个取决于传递给 SPI 的读/写标志。
以只读模式执行的命令遵循第一条规则：它们看不见调用它的命令做的修改。
以读写模式执行的规则遵循第二条规则：它们可以看到迄今为止所做的所有改变。
</para>
    </listitem>

    <listitem>
     <!--
<para>
      All standard procedural languages set the SPI read-write mode
      depending on the volatility attribute of the function.  Commands of
      <literal>STABLE</> and <literal>IMMUTABLE</> functions are done in
      read-only mode, while commands of <literal>VOLATILE</> functions are
      done in read-write mode.  While authors of C functions are able to
      violate this convention, it's unlikely to be a good idea to do so.
     </para>
-->
<para>
所有标准的过程语言都根据函数的易失性属性设置 SPI 读写模式。<literal>STABLE</>
和<literal>IMMUTABLE</>函数是以只读模式设置的，而<literal>VOLATILE</>
函数是以读写模式设置的。虽然其它 C 函数可以违反这个规定，但是这么做不是好事。
</para>
    </listitem>
   </itemizedlist>
  </para>

  <!--
<para>
   The next section contains an example that illustrates the
   application of these rules.
  </para>
-->
<para>
下一节里包含一些例子，演示了这些规则的应用。
</para>
 </sect1>

 <sect1 id="spi-examples">
  <!--
<title>Examples</title>
-->
<title>例子</title>

  <!--
<para>
   This section contains a very simple example of SPI usage. The
   procedure <function>execq</function> takes an SQL command as its
   first argument and a row count as its second, executes the command
   using <function>SPI_exec</function> and returns the number of rows
   that were processed by the command.  You can find more complex
   examples for SPI in the source tree in
   <filename>src/test/regress/regress.c</filename> and in the
   <xref linkend="contrib-spi"> module.
  </para>
-->
<para>
这是一个非常简单的 SPI 使用的例子。过程<function>execq</function>
在其第一个参数里接收一个 SQL 命令，第二个参数接收一个行计数，
用<function>SPI_exec</function>执行这个查询并且返回查询执行过的记录个数。
你可以在<filename>src/test/regress/regress.c</filename>中的源码树和
<xref linkend="contrib-spi">模块里找更复杂的例子。
</para>

<programlisting>
#include "postgres.h"

#include "executor/spi.h"
#include "utils/builtins.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

int execq(text *sql, int cnt);

int
execq(text *sql, int cnt)
{
    char *command;
    int ret;
    int proc;

    /* <!-- Convert given text object to a C string --> 把给出的 text 对象转换成 C 字符串*/
    command = text_to_cstring(sql);

    SPI_connect();

    ret = SPI_exec(command, cnt);

    proc = SPI_processed;
    /*
     <!-- * If some rows were fetched, print them via elog(INFO). --> 
 * 如果取出了一些行，通过 elog(INFO) 打印它们
     */
    if (ret &gt; 0 &amp;&amp; SPI_tuptable != NULL)
    {
        TupleDesc tupdesc = SPI_tuptable-&gt;tupdesc;
        SPITupleTable *tuptable = SPI_tuptable;
        char buf[8192];
        int i, j;

        for (j = 0; j &lt; proc; j++)
        {
            HeapTuple tuple = tuptable-&gt;vals[j];

            for (i = 1, buf[0] = 0; i &lt;= tupdesc-&gt;natts; i++)
                snprintf(buf + strlen (buf), sizeof(buf) - strlen(buf), " %s%s",
                        SPI_getvalue(tuple, tupdesc, i),
                        (i == tupdesc-&gt;natts) ? " " : " |");
            elog(INFO, "EXECQ: %s", buf);
        }
    }

    SPI_finish();
    pfree(command);

    return (proc);
}
</programlisting>

  <!--
<para>
   (This function uses call convention version 0, to make the example
   easier to understand.  In real applications you should use the new
   version 1 interface.)
  </para>
-->
<para>
这个函数使用了调用习惯版本0 ，为了是让例子更容易理解。在真实的应用里，
你应该使用新的版本1的接口。
</para>

  
<para>
<!--
   This is how you declare the function after having compiled it into
   a shared library (details are in <xref linkend="dfunc">.):
-->
下面是你在把函数编译成共享库之后声明它的方法（详情请看 <xref linkend="dfunc">）：
<programlisting>
CREATE FUNCTION execq(text, integer) RETURNS integer
    AS '<replaceable>filename</replaceable>'
    LANGUAGE C;
</programlisting>
  </para>
 
<para>
<!--
   Here is a sample session:
-->
下面是一个会话例子：
<programlisting>
=&gt; SELECT execq('CREATE TABLE a (x integer)', 0);
 execq
-------
     0
(1 row)

=&gt; INSERT INTO a VALUES (execq('INSERT INTO a VALUES (0)', 0));
INSERT 0 1
=&gt; SELECT execq('SELECT * FROM a', 0);
INFO:  EXECQ:  0    -- <!-- inserted by execq -->execq插入 0 行
INFO:  EXECQ:  1    -- <!-- returned by execq and inserted by upper INSERT -->execq 返回，被上层 INSERT 插入

 execq
-------
     2
(1 row)

=&gt; SELECT execq('INSERT INTO a SELECT x + 2 FROM a', 1);
 execq
-------
     1
(1 row)

=&gt; SELECT execq('SELECT * FROM a', 10);
INFO:  EXECQ:  0
INFO:  EXECQ:  1
INFO:  EXECQ:  2    -- 0 + 2,<!--  only one row inserted - as specified -->就像声明的那样只插入了一行

 execq
-------
     3              -- <!-- 10 is the max value only, 3 is the real number of rows -->10 只是最大值，3 是真实的行数
(1 row)

=&gt; DELETE FROM a;
DELETE 3
=&gt; INSERT INTO a VALUES (execq('SELECT * FROM a', 0) + 1);
INSERT 0 1
=&gt; SELECT * FROM a;
 x
---
 1                  -- <!-- no rows in a (0) + 1 --> 在 (0)+1 里面没有行
(1 row)

=&gt; INSERT INTO a VALUES (execq('SELECT * FROM a', 0) + 1);
INFO:  EXECQ:  1
INSERT 0 1
=&gt; SELECT * FROM a;
 x
---
 1
 2                  -- <!-- there was one row in a + 1 -->在 a+1 里面有一行
(2 rows)

-- <!-- This demonstrates the data changes visibility rule: -->下面示范了改变数据可视性的规则：

=&gt; INSERT INTO a SELECT execq('SELECT * FROM a', 0) * x FROM a;
INFO:  EXECQ:  1
INFO:  EXECQ:  2
INFO:  EXECQ:  1
INFO:  EXECQ:  2
INFO:  EXECQ:  2
INSERT 0 2
=&gt; SELECT * FROM a;
 x
---
 1
 2
 2                  -- <!-- 2 rows * 1 (x in first row) -->2行 * 1 (x 在第一行)
 6                  -- <!-- 3 rows (2 + 1 just inserted) * 2 (x in second row) -->3 行 (2 + 1 刚刚插入的) * 2 (第二行里的 x)
(4 rows)               ^^^^^^
                       <!-- rows visible to execq() in different invocations -->在不同的调用里 execq() 看到的东西不同
</programlisting>
  </para>
 </sect1>
</chapter>
