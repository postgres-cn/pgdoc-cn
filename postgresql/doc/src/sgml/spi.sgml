<!-- doc/src/sgml/spi.sgml -->

<chapter id="spi">
<!--==========================orignal english content==========================
 <title>Server Programming Interface</title>
____________________________________________________________________________-->
 <title>服务器编程接口</title>

<!--==========================orignal english content==========================
 <indexterm zone="spi">
  <primary>SPI</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="spi">
  <primary>SPI</primary>
 </indexterm>

<!--==========================orignal english content==========================
 <para>
  The <firstterm>Server Programming Interface</firstterm>
  (<acronym>SPI</acronym>) gives writers of user-defined
  <acronym>C</acronym> functions the ability to run
  <acronym>SQL</acronym> commands inside their functions.
  <acronym>SPI</acronym> is a set of
  interface functions to simplify access to the parser, planner,
  and executor. <acronym>SPI</acronym> also does some
  memory management.
 </para>
____________________________________________________________________________-->
 <para>
  <firstterm>服务器编程接口</firstterm>（<acronym>SPI</acronym>）给予用户定义<acronym>C</acronym>函数编写者在其函数内运行<acronym>SQL</acronym>命令的能力。<acronym>SPI</acronym>是一组接口函数，它们可以简化对解析器、规划器和执行器的访问。<acronym>SPI</acronym>也做一些内存管理。
 </para>

 <note>
<!--==========================orignal english content==========================
  <para>
   The available procedural languages provide various means to
   execute SQL commands from procedures.  Most of these facilities are
   based on SPI, so this documentation might be of use for users
   of those languages as well.
  </para>
____________________________________________________________________________-->
  <para>
   可用的过程语言提供了多种方法从过程中执行 SQL 命令。大部分这些设施都是基于 SPI 的，因此这个文档也对那些语言的用户有用。
  </para>
 </note>

<!--==========================orignal english content==========================
 <para>
  To avoid misunderstanding we'll use the term <quote>function</quote>
  when we speak of <acronym>SPI</acronym> interface functions and
  <quote>procedure</quote> for a user-defined C-function that is
  using <acronym>SPI</acronym>.
 </para>
____________________________________________________________________________-->
 <para>
  为了避免误解，我们在谈及<acronym>SPI</acronym>接口函数时使用术语<quote>函数</quote>，而谈及使用<acronym>SPI</acronym>的用户定义的 C 函数时使用术语<quote>过程</quote>。
 </para>

<!--==========================orignal english content==========================
 <para>
  Note that if a command invoked via SPI fails, then control will not be
  returned to your procedure.  Rather, the
  transaction or subtransaction in which your procedure executes will be
  rolled back.  (This might seem surprising given that the SPI functions mostly
  have documented error-return conventions.  Those conventions only apply
  for errors detected within the SPI functions themselves, however.)
  It is possible to recover control after an error by establishing your own
  subtransaction surrounding SPI calls that might fail.  This is not currently
  documented because the mechanisms required are still in flux.
 </para>
____________________________________________________________________________-->
 <para>
  注意如果一个通过 SPI 调用的命令失败，那么控制将会返回到你的过程中。当然啦，你的过程所在的事务或者子事务将被回滚（这可能看起来令人惊讶，因为据文档所说 SPI 函数大多数都有错误返回约定。但是那些约定只适用于在 SPI 函数本身内部检测到的错误）。通过在可能失败的 SPI 调用周围建立自己的子事务可以在错误之后恢复控制。当前文档中并未记载这些，因为所需的机制仍然在变化中。
 </para>

<!--==========================orignal english content==========================
 <para>
  <acronym>SPI</acronym> functions return a nonnegative result on
  success (either via a returned integer value or in the global
  variable <varname>SPI_result</varname>, as described below).  On
  error, a negative result or <symbol>NULL</symbol> will be returned.
 </para>
____________________________________________________________________________-->
 <para>
  <acronym>SPI</acronym>成功时返回一个非负结果（要么通过一个返回的整数值，要么如下所述放在全局变量<varname>SPI_result</varname>中）。错误时，将会返回一个负结果或者<symbol>NULL</symbol>。
 </para>

<!--==========================orignal english content==========================
 <para>
  Source code files that use SPI must include the header file
  <filename>executor/spi.h</filename>.
 </para>
____________________________________________________________________________-->
 <para>
  使用 SPI 的源代码文件必须包括头文件<filename>executor/spi.h</filename>。
 </para>


<sect1 id="spi-interface">
<!--==========================orignal english content==========================
 <title>Interface Functions</title>
____________________________________________________________________________-->
 <title>接口函数</title>

 <refentry id="spi-spi-connect">
<!--==========================orignal english content==========================
  <indexterm><primary>SPI_connect</primary></indexterm>
____________________________________________________________________________-->
  <indexterm><primary>SPI_connect</primary></indexterm>
  
<!--==========================orignal english content==========================
  <refmeta>
   <refentrytitle>SPI_connect</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>
____________________________________________________________________________-->
  <refmeta>
   <refentrytitle>SPI_connect</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

<!--==========================orignal english content==========================
  <refnamediv>
   <refname>SPI_connect</refname>
   <refpurpose>connect a procedure to the SPI manager</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
  <refnamediv>
   <refname>SPI_connect</refname>
   <refpurpose>连接一个过程到 SPI 管理器</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
int SPI_connect(void)
</synopsis>
____________________________________________________________________________-->
<synopsis>
int SPI_connect(void)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_connect</function> opens a connection from a
   procedure invocation to the SPI manager.  You must call this
   function if you want to execute commands through SPI.  Some utility
   SPI functions can be called from unconnected procedures.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_connect</function>从一个过程调用中打开一个到 SPI 管理器的连接。如果你想要通过 SPI 执行命令，你必须调用这个函数。有一些功能性 SPI 函数可以从未连接的过程中调用。
  </para>

 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><symbol>SPI_OK_CONNECT</symbol></term>
____________________________________________________________________________-->
    <term><symbol>SPI_OK_CONNECT</symbol></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      on success
     </para>
____________________________________________________________________________-->
     <para>
      成功时
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><symbol>SPI_ERROR_CONNECT</symbol></term>
____________________________________________________________________________-->
    <term><symbol>SPI_ERROR_CONNECT</symbol></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      on error
     </para>
____________________________________________________________________________-->
     <para>
      错误时
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-finish">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_finish</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_finish</primary></indexterm>
 
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_finish</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_finish</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_finish</refname>
  <refpurpose>disconnect a procedure from the SPI manager</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_finish</refname>
  <refpurpose>将一个过程从 SPI 管理器断开</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
int SPI_finish(void)
</synopsis>
____________________________________________________________________________-->
<synopsis>
int SPI_finish(void)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_finish</function> closes an existing connection to
   the SPI manager.  You must call this function after completing the
   SPI operations needed during your procedure's current invocation.
   You do not need to worry about making this happen, however, if you
   abort the transaction via <literal>elog(ERROR)</literal>.  In that
   case SPI will clean itself up automatically.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_finish</function>关闭一个到 SPI 管理器的现有连接。你必须在完成你的过程的当前调用中所需的 SPI 操作之后必须调用这个函数。不过，如果你通过<literal>elog(ERROR)</literal>中断了事务，你无须担心这个函数的调用。在那种情况下，SPI 将自己自动进行清理。
  </para>

 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><symbol>SPI_OK_FINISH</symbol></term>
____________________________________________________________________________-->
    <term><symbol>SPI_OK_FINISH</symbol></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      if properly disconnected
     </para>
____________________________________________________________________________-->
     <para>
      如果正确地断开连接
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
____________________________________________________________________________-->
    <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      if called from an unconnected procedure
     </para>
____________________________________________________________________________-->
     <para>
      如果从一个未连接的过程中调用
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-execute">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_execute</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_execute</primary></indexterm>
 
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_execute</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_execute</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_execute</refname>
  <refpurpose>execute a command</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_execute</refname>
  <refpurpose>执行一个命令</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
int SPI_execute(const char * <parameter>command</parameter>, bool <parameter>read_only</parameter>, long <parameter>count</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
int SPI_execute(const char * <parameter>command</parameter>, bool <parameter>read_only</parameter>, long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_execute</function> executes the specified SQL command
   for <parameter>count</parameter> rows.  If <parameter>read_only</parameter>
   is <literal>true</>, the command must be read-only, and execution overhead
   is somewhat reduced.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_execute</function>执行指定的 SQL 命令以获得<parameter>count</parameter>行。如果<parameter>read_only</parameter>为<literal>真</>，该命令必须是只读的，并且执行开销也会有所降低。
  </para>

<!--==========================orignal english content==========================
  <para>
   This function can only be called from a connected procedure.
  </para>
____________________________________________________________________________-->
  <para>
   只能从一个已连接的过程中调用这个函数。
  </para>

<!--==========================orignal english content==========================
  <para>
   If <parameter>count</parameter> is zero then the command is executed
   for all rows that it applies to.  If <parameter>count</parameter>
   is greater than zero, then no more than <parameter>count</parameter> rows
   will be retrieved; execution stops when the count is reached, much like
   adding a <literal>LIMIT</literal> clause to the query. For example,
<programlisting>
SPI_execute("SELECT * FROM foo", true, 5);
</programlisting>
   will retrieve at most 5 rows from the table.  Note that such a limit
   is only effective when the command actually returns rows.  For example,
<programlisting>
SPI_execute("INSERT INTO foo SELECT * FROM bar", false, 5);
</programlisting>
   inserts all rows from <structname>bar</>, ignoring the
   <parameter>count</parameter> parameter.  However, with
<programlisting>
SPI_execute("INSERT INTO foo SELECT * FROM bar RETURNING *", false, 5);
</programlisting>
   at most 5 rows would be inserted, since execution would stop after the
   fifth <literal>RETURNING</> result row is retrieved.
  </para>
____________________________________________________________________________-->
  <para>
   如果<parameter>count</parameter>为零，那么该命令会为其所适用的所有行执行。如果<parameter>count</parameter>大于零，那么会检索不超过<parameter>count</parameter>行，当到达该计数时执行会停止，这很像为查询增加一个<literal>LIMIT</literal>子句。例如：
<programlisting>
SPI_execute("SELECT * FROM foo", true, 5);
</programlisting>
   会从表中检索至多 5 行。注意这样一个限制只有当命令真正返回行时才有效。例如：
<programlisting>
SPI_execute("INSERT INTO foo SELECT * FROM bar", false, 5);
</programlisting>
   插入所有来自于<structname>bar</>的行，而忽略<parameter>count</parameter>参数。不过，通过
<programlisting>
SPI_execute("INSERT INTO foo SELECT * FROM bar RETURNING *", false, 5);
</programlisting>
   将插入至多 5 行，因为在第五个<literal>RETURNING</>结果行被检索到后执行就会停止。
  </para>

<!--==========================orignal english content==========================
  <para>
   You can pass multiple commands in one string;
   <function>SPI_execute</function> returns the
   result for the command executed last.  The <parameter>count</parameter>
   limit applies to each command separately (even though only the last
   result will actually be returned).  The limit is not applied to any
   hidden commands generated by rules.
  </para>
____________________________________________________________________________-->
  <para>
   你可以在一个字符串中传递多个命令，<function>SPI_execute</function>会返回最后一个被执行的命令的结果。
   <parameter>count</parameter>限制单独适用于每一个命令（即便只有最后一个结果会被实际返回）。该限制
   不适用于由规则产生的任何隐藏命令。
  </para>

<!--==========================orignal english content==========================
  <para>
   When <parameter>read_only</parameter> is <literal>false</>,
   <function>SPI_execute</function> increments the command
   counter and computes a new <firstterm>snapshot</> before executing each
   command in the string.  The snapshot does not actually change if the
   current transaction isolation level is <literal>SERIALIZABLE</> or <literal>REPEATABLE READ</>, but in
   <literal>READ COMMITTED</> mode the snapshot update allows each command to
   see the results of newly committed transactions from other sessions.
   This is essential for consistent behavior when the commands are modifying
   the database.
  </para>
____________________________________________________________________________-->
  <para>
   当<parameter>read_only</parameter>是<literal>false</>时，
   <function>SPI_execute</function>增加命令计数器并且在执行字符串中每一个命令之前
   计算一个新的<firstterm>snapshot</>。如果当前事务隔离级别是<literal>SERIALIZABLE</>或<literal>REPEATABLE READ</>，
   该快照并不会实际改变。但是在<literal>READ COMMITTED</>模式中，快照更新允许每个命令看到来自其他会话中新近已提交事务
   的结果。当命令正在修改数据库时，这对一致性行为非常重要。
  </para>

<!--==========================orignal english content==========================
  <para>
   When <parameter>read_only</parameter> is <literal>true</>,
   <function>SPI_execute</function> does not update either the snapshot
   or the command counter, and it allows only plain <command>SELECT</>
   commands to appear in the command string.  The commands are executed
   using the snapshot previously established for the surrounding query.
   This execution mode is somewhat faster than the read/write mode due
   to eliminating per-command overhead.  It also allows genuinely
   <firstterm>stable</> functions to be built: since successive executions
   will all use the same snapshot, there will be no change in the results.
  </para>
____________________________________________________________________________-->
  <para>
   当<parameter>read_only</parameter>是<literal>true</>时，
   <function>SPI_execute</function>不更新快照或者命令计数器，并且它只允许纯
   <command>SELECT</>命令出现在命令字符串中。这些命令被使用之前为周围查询
   建立的快照来执行。这种执行模式要比读/写模式更快，因为消除了每个命令跟新快照的开销。
   它也允许建立真正<firstterm>stable</>的函数：因为连续执行将会使用同一个快照，因此结果不会有改变。
  </para>

<!--==========================orignal english content==========================
  <para>
   It is generally unwise to mix read-only and read-write commands within
   a single function using SPI; that could result in very confusing behavior,
   since the read-only queries would not see the results of any database
   updates done by the read-write queries.
  </para>
____________________________________________________________________________-->
  <para>
   在一个使用 SPI 的单一函数中混合只读和读写命令通常是不明智的，
   这样可能会导致非常令人困惑的行为，因为只读查询将看不到任何
   由读写查询完成的数据库更新结果。
  </para>

<!--==========================orignal english content==========================
  <para>
   The actual number of rows for which the (last) command was executed
   is returned in the global variable <varname>SPI_processed</varname>.
   If the return value of the function is <symbol>SPI_OK_SELECT</symbol>,
   <symbol>SPI_OK_INSERT_RETURNING</symbol>,
   <symbol>SPI_OK_DELETE_RETURNING</symbol>, or
   <symbol>SPI_OK_UPDATE_RETURNING</symbol>,
   then you can use the
   global pointer <literal>SPITupleTable *SPI_tuptable</literal> to
   access the result rows.  Some utility commands (such as
   <command>EXPLAIN</>) also return row sets, and <literal>SPI_tuptable</>
   will contain the result in these cases too. Some utility commands
   (<command>COPY</>, <command>CREATE TABLE AS</>) don't return a row set, so
   <literal>SPI_tuptable</> is NULL, but they still return the number of
   rows processed in <varname>SPI_processed</>.
  </para>
____________________________________________________________________________-->
  <para>
   被执行的（最后一个）命令的实际行数使用全局变量<varname>SPI_processed</varname>返回。
   如果该函数的返回值是<symbol>SPI_OK_SELECT</symbol>、
   <symbol>SPI_OK_INSERT_RETURNING</symbol>、
   <symbol>SPI_OK_DELETE_RETURNING</symbol>或者
   <symbol>SPI_OK_UPDATE_RETURNING</symbol>，
   那么你可以使用全局指针<literal>SPITupleTable *SPI_tuptable</literal>来访问结果行。
   某些工具命令（例如<command>EXPLAIN</>）也返回行集合，并且在这些情况中<literal>SPI_tuptable</>
   也会包含该结果。某些工具命令（<command>COPY</>、<command>CREATE TABLE AS</>）不返回一个行集合，
   因此<literal>SPI_tuptable</>为 NULL，但是它们仍然会在<varname>SPI_processed</>中返回被处理的行数。
  </para>

<!--==========================orignal english content==========================
  <para>
   The structure <structname>SPITupleTable</structname> is defined
   thus:
<programlisting>
typedef struct
{
    MemoryContext tuptabcxt;    /* memory context of result table */
    uint64      alloced;        /* number of alloced vals */
    uint64      free;           /* number of free vals */
    TupleDesc   tupdesc;        /* row descriptor */
    HeapTuple  *vals;           /* rows */
} SPITupleTable;
</programlisting>
   <structfield>vals</> is an array of pointers to rows.  (The number
   of valid entries is given by <varname>SPI_processed</varname>.)
   <structfield>tupdesc</> is a row descriptor which you can pass to
   SPI functions dealing with rows.  <structfield>tuptabcxt</>,
   <structfield>alloced</>, and <structfield>free</> are internal
   fields not intended for use by SPI callers.
  </para>
____________________________________________________________________________-->
  <para>
   结构<structname>SPITupleTable</structname>被定义为：
<programlisting>
typedef struct
{
    MemoryContext tuptabcxt;    /* 结果表的内存上下文 */
    uint64      alloced;        /* 已分配值的数量 */
    uint64      free;           /* 空闲的数量 */
    TupleDesc   tupdesc;        /* 行描述符 */
    HeapTuple  *vals;           /* 行 */
} SPITupleTable;
</programlisting>
   <structfield>vals</>是一个行指针的数组（可用项的数量由<varname>SPI_processed</varname>给出）。
   <structfield>tupdesc</>是一个行描述符，你可以把它传递给 SPI 函数来处理行。<structfield>tuptabcxt</>、
   <structfield>alloced</>和<structfield>free</>是不准备给 SPI 调用者使用的内部域。
  </para>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_finish</function> frees all
   <structname>SPITupleTable</>s allocated during the current
   procedure.  You can free a particular result table earlier, if you
   are done with it, by calling <function>SPI_freetuptable</function>.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_finish</function>释放在当前过程中已分配的所有<structname>SPITupleTable</>。
   如果你已经用完了一个结果表，你可以通过调用<function>SPI_freetuptable</function>提早释放它。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>const char * <parameter>command</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      string containing command to execute
     </para>
____________________________________________________________________________-->
     <para>
      包含要执行命令的字符串
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>bool <parameter>read_only</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para><literal>true</> for read-only execution</para>
____________________________________________________________________________-->
     <para>对只读执行为<literal>true</></para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>long <parameter>count</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      maximum number of rows to return,
      or <literal>0</> for no limit
     </para>
____________________________________________________________________________-->
     <para>
      要返回的最大行数，或者用<literal>0</>表示没有限制
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

<!--==========================orignal english content==========================
  <para>
   If the execution of the command was successful then one of the
   following (nonnegative) values will be returned:

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_OK_SELECT</symbol></term>
     <listitem>
      <para>
       if a <command>SELECT</command> (but not <command>SELECT
       INTO</>) was executed
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_SELINTO</symbol></term>
     <listitem>
      <para>
       if a <command>SELECT INTO</command> was executed
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_INSERT</symbol></term>
     <listitem>
      <para>
       if an <command>INSERT</command> was executed
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_DELETE</symbol></term>
     <listitem>
      <para>
       if a <command>DELETE</command> was executed
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_UPDATE</symbol></term>
     <listitem>
      <para>
       if an <command>UPDATE</command> was executed
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_INSERT_RETURNING</symbol></term>
     <listitem>
      <para>
       if an <command>INSERT RETURNING</command> was executed
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_DELETE_RETURNING</symbol></term>
     <listitem>
      <para>
       if a <command>DELETE RETURNING</command> was executed
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_UPDATE_RETURNING</symbol></term>
     <listitem>
      <para>
       if an <command>UPDATE RETURNING</command> was executed
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_UTILITY</symbol></term>
     <listitem>
      <para>
       if a utility command (e.g., <command>CREATE TABLE</command>)
       was executed
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_REWRITTEN</symbol></term>
     <listitem>
      <para>
       if the command was rewritten into another kind of command (e.g.,
       <command>UPDATE</command> became an <command>INSERT</command>) by a <link linkend="rules">rule</link>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   如果命令的执行成功，那么将会返回下列（非负）值之一：

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_OK_SELECT</symbol></term>
     <listitem>
      <para>
       如果执行了一个<command>SELECT</command>（但不是<command>SELECT INTO</>）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_SELINTO</symbol></term>
     <listitem>
      <para>
       如果执行了一个<command>SELECT INTO</command>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_INSERT</symbol></term>
     <listitem>
      <para>
       如果执行了一个<command>INSERT</command>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_DELETE</symbol></term>
     <listitem>
      <para>
       如果执行了一个<command>DELETE</command>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_UPDATE</symbol></term>
     <listitem>
      <para>
       如果执行了一个<command>UPDATE</command>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_INSERT_RETURNING</symbol></term>
     <listitem>
      <para>
       如果执行了一个<command>INSERT RETURNING</command>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_DELETE_RETURNING</symbol></term>
     <listitem>
      <para>
       如果执行了一个<command>DELETE RETURNING</command>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_UPDATE_RETURNING</symbol></term>
     <listitem>
      <para>
       如果执行了一个<command>UPDATE RETURNING</command>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_UTILITY</symbol></term>
     <listitem>
      <para>
       如果执行了一个工具命令（例如<command>CREATE TABLE</command>）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_REWRITTEN</symbol></term>
     <listitem>
      <para>
       如果该命令被一个<link linkend="rules">规则</link>重写成了另一类命令（例如<command>UPDATE</command>变成了一个<command>INSERT</command>）
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

<!--==========================orignal english content==========================
  <para>
   On error, one of the following negative values is returned:

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
       if <parameter>command</parameter> is <symbol>NULL</symbol> or
       <parameter>count</parameter> is less than 0
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_COPY</symbol></term>
     <listitem>
      <para>
       if <command>COPY TO stdout</> or <command>COPY FROM stdin</>
       was attempted
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_TRANSACTION</symbol></term>
     <listitem>
      <para>
       if a transaction manipulation command was attempted
       (<command>BEGIN</>,
       <command>COMMIT</>,
       <command>ROLLBACK</>,
       <command>SAVEPOINT</>,
       <command>PREPARE TRANSACTION</>,
       <command>COMMIT PREPARED</>,
       <command>ROLLBACK PREPARED</>,
       or any variant thereof)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_OPUNKNOWN</symbol></term>
     <listitem>
      <para>
       if the command type is unknown (shouldn't happen)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
     <listitem>
      <para>
       if called from an unconnected procedure
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   发生错误时，将会返回下列负值之一：

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
       如果<parameter>command</parameter>为<symbol>NULL</symbol>或者<parameter>count</parameter>小于 0
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_COPY</symbol></term>
     <listitem>
      <para>
       如果尝试<command>COPY TO stdout</>或者<command>COPY FROM stdin</>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_TRANSACTION</symbol></term>
     <listitem>
      <para>
       如果尝试了一个事务操纵命令（
       <command>BEGIN</>、
       <command>COMMIT</>、
       <command>ROLLBACK</>、
       <command>SAVEPOINT</>、
       <command>PREPARE TRANSACTION</>、
       <command>COMMIT PREPARED</>、
       <command>ROLLBACK PREPARED</>或者其他变体）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_OPUNKNOWN</symbol></term>
     <listitem>
      <para>
       如果命令类型位置（不应该会发生）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
     <listitem>
      <para>
       如果调用过程未连接
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Notes</title>
____________________________________________________________________________-->
  <title>注解</title>

<!--==========================orignal english content==========================
  <para>
   All SPI query-execution functions set both
   <varname>SPI_processed</varname> and
   <varname>SPI_tuptable</varname> (just the pointer, not the contents
   of the structure).  Save these two global variables into local
   procedure variables if you need to access the result table of
   <function>SPI_execute</function> or another query-execution function
   across later calls.
  </para>
____________________________________________________________________________-->
  <para>
   所有 SPI 查询执行函数都会设置<varname>SPI_processed</varname>和<varname>SPI_tuptable</varname>（只是指针，
   而不是结构的内容）。如果你需要在以后访问<function>SPI_execute</function>或另一个查询执行函数的结果表，
   请将这两个全局变量保存到局部过程变量中。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-exec">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_exec</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_exec</primary></indexterm>
 
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_exec</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_exec</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_exec</refname>
  <refpurpose>execute a read/write command</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_exec</refname>
  <refpurpose>执行一个读/写命令</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
int SPI_exec(const char * <parameter>command</parameter>, long <parameter>count</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
int SPI_exec(const char * <parameter>command</parameter>, long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_exec</function> is the same as
   <function>SPI_execute</function>, with the latter's
   <parameter>read_only</parameter> parameter always taken as
   <literal>false</>.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_exec</function>和
   <function>SPI_execute</function>相同，但后者的
   <parameter>read_only</parameter>参数的值总是取
   <literal>false</>。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>const char * <parameter>command</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      string containing command to execute
     </para>
____________________________________________________________________________-->
     <para>
      包含要执行的命令的字符串
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>long <parameter>count</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      maximum number of rows to return,
      or <literal>0</> for no limit
     </para>
____________________________________________________________________________-->
     <para>
      要返回的最大行数，<literal>0</>表示没有限制
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

<!--==========================orignal english content==========================
  <para>
   See <function>SPI_execute</function>.
  </para>
____________________________________________________________________________-->
  <para>
   见<function>SPI_execute</function>。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-execute-with-args">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_execute_with_args</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_execute_with_args</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_execute_with_args</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_execute_with_args</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_execute_with_args</refname>
  <refpurpose>execute a command with out-of-line parameters</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_execute_with_args</refname>
  <refpurpose>用线外参数执行一个命令</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
int SPI_execute_with_args(const char *<parameter>command</parameter>,
                          int <parameter>nargs</parameter>, Oid *<parameter>argtypes</parameter>,
                          Datum *<parameter>values</parameter>, const char *<parameter>nulls</parameter>,
                          bool <parameter>read_only</parameter>, long <parameter>count</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
int SPI_execute_with_args(const char *<parameter>command</parameter>,
                          int <parameter>nargs</parameter>, Oid *<parameter>argtypes</parameter>,
                          Datum *<parameter>values</parameter>, const char *<parameter>nulls</parameter>,
                          bool <parameter>read_only</parameter>, long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_execute_with_args</function> executes a command that might
   include references to externally supplied parameters.  The command text
   refers to a parameter as <literal>$<replaceable>n</></literal>, and
   the call specifies data types and values for each such symbol.
   <parameter>read_only</parameter> and <parameter>count</parameter> have
   the same interpretation as in <function>SPI_execute</function>.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_execute_with_args</function>执行一个可能包括
   对外部提供的参数引用的命令。命令文本用
   <literal>$<replaceable>n</></literal>引用一个参数，并且调用
   会为每一个这种符号指定数据类型和值。
   <parameter>read_only</parameter>和
   <parameter>count</parameter>的解释与
   <function>SPI_execute</function>中相同。
  </para>

<!--==========================orignal english content==========================
  <para>
   The main advantage of this routine compared to
   <function>SPI_execute</function> is that data values can be inserted
   into the command without tedious quoting/escaping, and thus with much
   less risk of SQL-injection attacks.
  </para>
____________________________________________________________________________-->
  <para>
   相对于<function>SPI_execute</function>，这个例程的主要优
   点是数据值可以被插入到命令中而无需冗长的引用/转义，并且因此
   减少了 SQL 注入攻击的风险。
  </para>

<!--==========================orignal english content==========================
  <para>
   Similar results can be achieved with <function>SPI_prepare</> followed by
   <function>SPI_execute_plan</function>; however, when using this function
   the query plan is always customized to the specific parameter values
   provided.
   For one-time query execution, this function should be preferred.
   If the same command is to be executed with many different parameters,
   either method might be faster, depending on the cost of re-planning
   versus the benefit of custom plans.
  </para>
____________________________________________________________________________-->
  <para>
   可以通过在<function>SPI_prepare</>后面跟上
   <function>SPI_execute_plan</function>达到相似的结果。但是，
   使用这个函数时查询计划总是被定制成提供的指定参数值。对于一次
   性的查询执行，这个函数应该更好。如果同样的命令需要用很多不同
   的参数执行，两种方法都可能会更快，这取决于重新做规划的代价与
   定制计划带来的好处之间的对比。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>const char * <parameter>command</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      command string
     </para>
____________________________________________________________________________-->
     <para>
      命令字符串
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>int <parameter>nargs</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>int <parameter>nargs</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      number of input parameters (<literal>$1</>, <literal>$2</>, etc.)
     </para>
____________________________________________________________________________-->
     <para>
      输入参数的数量（<literal>$1</>、<literal>$2</>等等）。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>Oid * <parameter>argtypes</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>Oid * <parameter>argtypes</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      an array of length <parameter>nargs</parameter>, containing the
      <acronym>OID</acronym>s of the data types of the parameters
     </para>
____________________________________________________________________________-->
     <para>
      一个长度为<parameter>nargs</parameter>的数组，
      包含参数的数据类型的<acronym>OID</acronym>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>Datum * <parameter>values</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>Datum * <parameter>values</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      an array of length <parameter>nargs</parameter>, containing the actual
      parameter values
     </para>
____________________________________________________________________________-->
     <para>
      一个长度为<parameter>nargs</parameter>的数组，
      包含实际的参数值
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      an array of length <parameter>nargs</parameter>, describing which
      parameters are null
     </para>
____________________________________________________________________________-->
     <para>
      一个长度为<parameter>nargs</parameter>的数组，
      描述哪些参数为空值
     </para>

<!--==========================orignal english content==========================
     <para>
      If <parameter>nulls</parameter> is <symbol>NULL</symbol> then
      <function>SPI_execute_with_args</function> assumes that no parameters
      are null.  Otherwise, each entry of the <parameter>nulls</parameter>
      array should be <literal>'&nbsp;'</> if the corresponding parameter
      value is non-null, or <literal>'n'</> if the corresponding parameter
      value is null.  (In the latter case, the actual value in the
      corresponding <parameter>values</parameter> entry doesn't matter.)  Note
      that <parameter>nulls</parameter> is not a text string, just an array:
      it does not need a <literal>'\0'</> terminator.
     </para>
____________________________________________________________________________-->
     <para>
      如果<parameter>nulls</parameter>为<symbol>NULL</symbol>，
      那么<function>SPI_execute_with_args</function>会假设没有参数
      为空值。否则，如果对应的参数值为非空，
      <parameter>nulls</parameter>
      数组的每一个项都应该是<literal>'&nbsp;'</>；如果对应参数值为空，
      <parameter>nulls</parameter>数组的项应为<literal>'n'</>（在后
      面的情况中，对应的<parameter>values</parameter>项中的值没有
      关系）。注意<parameter>nulls</parameter>不是一个文本字符串，
      它只是一个数组：它不需要一个<literal>'\0'</>终止符。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>bool <parameter>read_only</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para><literal>true</> for read-only execution</para>
____________________________________________________________________________-->
     <para>对只读执行是<literal>true</></para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>long <parameter>count</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      maximum number of rows to return,
      or <literal>0</> for no limit
     </para>
____________________________________________________________________________-->
     <para>
      要返回的最大行数，<literal>0</>表示没有限制
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

<!--==========================orignal english content==========================
  <para>
   The return value is the same as for <function>SPI_execute</function>.
  </para>
____________________________________________________________________________-->
  <para>
   该返回值和<function>SPI_execute</function>一样。
  </para>

<!--==========================orignal english content==========================
  <para>
   <varname>SPI_processed</varname> and
   <varname>SPI_tuptable</varname> are set as in
   <function>SPI_execute</function> if successful.
  </para>
____________________________________________________________________________-->
  <para>
   如果成功<function>SPI_execute</function>会设置
   <varname>SPI_processed</varname>和
   <varname>SPI_tuptable</varname>。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-prepare">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_prepare</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_prepare</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_prepare</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_prepare</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_prepare</refname>
  <refpurpose>prepare a statement, without executing it yet</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_prepare</refname>
  <refpurpose>准备一个语句，但不执行它</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
SPIPlanPtr SPI_prepare(const char * <parameter>command</parameter>, int <parameter>nargs</parameter>, Oid * <parameter>argtypes</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
SPIPlanPtr SPI_prepare(const char * <parameter>command</parameter>, int <parameter>nargs</parameter>, Oid * <parameter>argtypes</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_prepare</function> creates and returns a prepared
   statement for the specified command, but doesn't execute the command.
   The prepared statement can later be executed repeatedly using
   <function>SPI_execute_plan</function>.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_prepare</function>为指定的命令创建并且返回一个
   预备语句，但是并不执行该命令。该预备语句会在稍后使用
   <function>SPI_execute_plan</function>重复执行。
  </para>

<!--==========================orignal english content==========================
  <para>
   When the same or a similar command is to be executed repeatedly, it
   is generally advantageous to perform parse analysis only once, and
   might furthermore be advantageous to re-use an execution plan for the
   command.
   <function>SPI_prepare</function> converts a command string into a
   prepared statement that encapsulates the results of parse analysis.
   The prepared statement also provides a place for caching an execution plan
   if it is found that generating a custom plan for each execution is not
   helpful.
  </para>
____________________________________________________________________________-->
  <para>
   当相同的或者相似的命令要被重复执行时，通常来说只执行一次解析分
   析是有利的，并且更有利的是重用该命令的执行计划。
   <function>SPI_prepare</function>把一个命令字符串转换成一个预
   备语句，它包装了解析分析的结果。如果发现为每一次执行都生成一个
   定制计划没有帮助，该预备语句也提供了一个地方缓存执行计划。
  </para>

<!--==========================orignal english content==========================
  <para>
   A prepared command can be generalized by writing parameters
   (<literal>$1</>, <literal>$2</>, etc.) in place of what would be
   constants in a normal command.  The actual values of the parameters
   are then specified when <function>SPI_execute_plan</function> is called.
   This allows the prepared command to be used over a wider range of
   situations than would be possible without parameters.
  </para>
____________________________________________________________________________-->
  <para>
   一个预备命令可以被一般化为在一个普通命令中应该出现常量的地方写
   上参数（<literal>$1</>、<literal>$2</>等等）。参数的实际值在
   <function>SPI_execute_plan</function>被调用时指定。这让该预备
   语句可以比没有参数的形式用户与更广泛的情况。
  </para>

<!--==========================orignal english content==========================
  <para>
   The statement returned by <function>SPI_prepare</function> can be used
   only in the current invocation of the procedure, since
   <function>SPI_finish</function> frees memory allocated for such a
   statement.  But the statement can be saved for longer using the functions
   <function>SPI_keepplan</function> or <function>SPI_saveplan</function>.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_prepare</function>返回的语句只能在当前过程调用
   中使用，因为<function>SPI_finish</function>会释放为这样一个语句
   分配的内存。但是可以使用函数<function>SPI_keepplan</function>
   或<function>SPI_saveplan</function>把该语句保存更久。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>const char * <parameter>command</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      command string
     </para>
____________________________________________________________________________-->
     <para>
      命令字符串
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>int <parameter>nargs</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>int <parameter>nargs</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      number of input parameters (<literal>$1</>, <literal>$2</>, etc.)
     </para>
____________________________________________________________________________-->
     <para>
      输入参数（<literal>$1</>、<literal>$2</>等等）的数量
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>Oid * <parameter>argtypes</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>Oid * <parameter>argtypes</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      pointer to an array containing the <acronym>OID</acronym>s of
      the data types of the parameters
     </para>
____________________________________________________________________________-->
     <para>
      一个数组指针，它指向的数组包含参数的数据类型的
      <acronym>OID</acronym>
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_prepare</function> returns a non-null pointer to an
   <type>SPIPlan</>, which is an opaque struct representing a prepared
   statement.  On error, <symbol>NULL</symbol> will be returned,
   and <varname>SPI_result</varname> will be set to one of the same
   error codes used by <function>SPI_execute</function>, except that
   it is set to <symbol>SPI_ERROR_ARGUMENT</symbol> if
   <parameter>command</parameter> is <symbol>NULL</symbol>, or if
   <parameter>nargs</> is less than 0, or if <parameter>nargs</> is
   greater than 0 and <parameter>argtypes</> is <symbol>NULL</symbol>.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_prepare</function>返回一个指向<type>SPIPlan</>
   的非空指针，它是一个表示一个预备语句的不透明结构。发生错误时，
   将会返回<symbol>NULL</symbol>，并且
   <varname>SPI_result</varname>将被设置为一个也被
   <function>SPI_execute</function>使用的错误码，不过当
   <parameter>command</parameter>为<symbol>NULL</symbol>、
   或者<parameter>nargs</>小于零、或者<parameter>nargs</>大于
   零但是<parameter>argtypes</>为<symbol>NULL</symbol>
   时它会被设置为<symbol>SPI_ERROR_ARGUMENT</symbol>。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Notes</title>
____________________________________________________________________________-->
  <title>注解</title>

<!--==========================orignal english content==========================
  <para>
   If no parameters are defined, a generic plan will be created at the
   first use of <function>SPI_execute_plan</function>, and used for all
   subsequent executions as well.  If there are parameters, the first few uses
   of <function>SPI_execute_plan</function> will generate custom plans
   that are specific to the supplied parameter values.  After enough uses
   of the same prepared statement, <function>SPI_execute_plan</function> will
   build a generic plan, and if that is not too much more expensive than the
   custom plans, it will start using the generic plan instead of re-planning
   each time.  If this default behavior is unsuitable, you can alter it by
   passing the <literal>CURSOR_OPT_GENERIC_PLAN</> or
   <literal>CURSOR_OPT_CUSTOM_PLAN</> flag to
   <function>SPI_prepare_cursor</function>, to force use of generic or custom
   plans respectively.
  </para>
____________________________________________________________________________-->
  <para>
   如果没有定义参数，在第一次使用<function>SPI_execute_plan</function>
   时将会创建一个一般的计划，并且把它用于所有的后续执行。如果有参数，
   <function>SPI_execute_plan</function>的前几次使用将根据提供的参数值
   产生定制计划。在使用同一个预备语句足够多次后，
   <function>SPI_execute_plan</function>将构建一个一般计划，并且如果它
   并不比定制计划昂贵太多， <function>SPI_execute_plan</function>将开始
   使用一般计划来取代每次都进行重新规划。如果这种默认的行为不合适，你可以
   通过传递<literal>CURSOR_OPT_GENERIC_PLAN</>或
   <literal>CURSOR_OPT_CUSTOM_PLAN</>标志给
   <function>SPI_prepare_cursor</function>，以分别强制使用一般或者定制
   计划。
  </para>

<!--==========================orignal english content==========================
  <para>
   Although the main point of a prepared statement is to avoid repeated parse
   analysis and planning of the statement, <productname>PostgreSQL</> will
   force re-analysis and re-planning of the statement before using it
   whenever database objects used in the statement have undergone
   definitional (DDL) changes since the previous use of the prepared
   statement.  Also, if the value of <xref linkend="guc-search-path"> changes
   from one use to the next, the statement will be re-parsed using the new
   <varname>search_path</>.  (This latter behavior is new as of
   <productname>PostgreSQL</productname> 9.3.)  See <xref
   linkend="sql-prepare"> for more information about the behavior of prepared
   statements.
  </para>
____________________________________________________________________________-->
  <para>
   尽管一个预备语句的要点是避免对语句的重复解析分析以及规划，只要语句中
   用到的数据库对象从上一次使用该预备语句以来经历过定义性（DDL）改变，
   <productname>PostgreSQL</>将会强制重新分析和重新规划该语句。还有，
   如果<xref linkend="guc-search-path">的值从一个改变成下一个，该语句将
   会使用新的<varname>search_path</>进行重新解析（后一种行为是从
   <productname>PostgreSQL</productname> 9.3 开始的新行为）。更多
   有关预备语句行为的信息请见<xref linkend="sql-prepare">。
  </para>

<!--==========================orignal english content==========================
  <para>
   This function should only be called from a connected procedure.
  </para>
____________________________________________________________________________-->
  <para>
   这个函数只能从一个已连接的过程调用。
  </para>

<!--==========================orignal english content==========================
  <para>
   <type>SPIPlanPtr</> is declared as a pointer to an opaque struct type in
   <filename>spi.h</>.  It is unwise to try to access its contents
   directly, as that makes your code much more likely to break in
   future revisions of <productname>PostgreSQL</productname>.
  </para>
____________________________________________________________________________-->
  <para>
   <type>SPIPlanPtr</>被声明为<filename>spi.h</>中的一种不透明结构类型
   的指针。尝试直接访问其内容是不明智的，因为那会让你的代码更有可能会在未
   来版本的<productname>PostgreSQL</productname>中崩溃。
  </para>

<!--==========================orignal english content==========================
  <para>
   The name <type>SPIPlanPtr</> is somewhat historical, since the data
   structure no longer necessarily contains an execution plan.
  </para>
____________________________________________________________________________-->
  <para>
   <type>SPIPlanPtr</>这个名字多少有点历史原因，因为该数据结构不再需要包
   含一个执行计划。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-prepare-cursor">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_prepare_cursor</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_prepare_cursor</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_prepare_cursor</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_prepare_cursor</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_prepare_cursor</refname>
  <refpurpose>prepare a statement, without executing it yet</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_prepare_cursor</refname>
  <refpurpose>预备一个语句，但是不执行它</refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
SPIPlanPtr SPI_prepare_cursor(const char * <parameter>command</parameter>, int <parameter>nargs</parameter>,
                              Oid * <parameter>argtypes</parameter>, int <parameter>cursorOptions</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
SPIPlanPtr SPI_prepare_cursor(const char * <parameter>command</parameter>, int <parameter>nargs</parameter>,
                              Oid * <parameter>argtypes</parameter>, int <parameter>cursorOptions</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_prepare_cursor</function> is identical to
   <function>SPI_prepare</function>, except that it also allows specification
   of the planner's <quote>cursor options</> parameter.  This is a bit mask
   having the values shown in <filename>nodes/parsenodes.h</filename>
   for the <structfield>options</> field of <structname>DeclareCursorStmt</>.
   <function>SPI_prepare</function> always takes the cursor options as zero.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_prepare_cursor</function>和
   <function>SPI_prepare</function>一样，不过它也允许说明规划器的
   <quote>游标选项</>参数。这是一个位掩码，它的值如
   <filename>nodes/parsenodes.h</filename>中
   <structname>DeclareCursorStmt</>的<structfield>options</>域所示。
   <function>SPI_prepare</function>总是把该游标选项取做零。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>const char * <parameter>command</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      command string
     </para>
____________________________________________________________________________-->
     <para>
      命令字符串
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>int <parameter>nargs</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>int <parameter>nargs</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      number of input parameters (<literal>$1</>, <literal>$2</>, etc.)
     </para>
____________________________________________________________________________-->
     <para>
      输入参数（<literal>$1</>、<literal>$2</>等等）的数量
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>Oid * <parameter>argtypes</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>Oid * <parameter>argtypes</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      pointer to an array containing the <acronym>OID</acronym>s of
      the data types of the parameters
     </para>
____________________________________________________________________________-->
     <para>
      一个数组指针，它指向的数组包含参数的数据类型的
      <acronym>OID</acronym>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>int <parameter>cursorOptions</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>int <parameter>cursorOptions</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      integer bit mask of cursor options; zero produces default behavior
     </para>
____________________________________________________________________________-->
     <para>
      整数形式的游标选项位掩码，零会导致默认行为
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_prepare_cursor</function> has the same return conventions as
   <function>SPI_prepare</function>.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_prepare_cursor</function>具有和
   <function>SPI_prepare</function>一样的返回习惯。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Notes</title>
____________________________________________________________________________-->
  <title>注解</title>

<!--==========================orignal english content==========================
  <para>
   Useful bits to set in <parameter>cursorOptions</> include
   <symbol>CURSOR_OPT_SCROLL</symbol>,
   <symbol>CURSOR_OPT_NO_SCROLL</symbol>,
   <symbol>CURSOR_OPT_FAST_PLAN</symbol>,
   <symbol>CURSOR_OPT_GENERIC_PLAN</symbol>, and
   <symbol>CURSOR_OPT_CUSTOM_PLAN</symbol>.  Note in particular that
   <symbol>CURSOR_OPT_HOLD</symbol> is ignored.
  </para>
____________________________________________________________________________-->
  <para>
   在<parameter>cursorOptions</>设置的有用的位包括
   <symbol>CURSOR_OPT_SCROLL</symbol>、
   <symbol>CURSOR_OPT_NO_SCROLL</symbol>、
   <symbol>CURSOR_OPT_FAST_PLAN</symbol>、
   <symbol>CURSOR_OPT_GENERIC_PLAN</symbol>以及
   <symbol>CURSOR_OPT_CUSTOM_PLAN</symbol>。
   注意<symbol>CURSOR_OPT_HOLD</symbol>被特别地忽略。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-prepare-params">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_prepare_params</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_prepare_params</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_prepare_params</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_prepare_params</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_prepare_params</refname>
  <refpurpose>prepare a statement, without executing it yet</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_prepare_params</refname>
  <refpurpose>预备一个语句，但是不执行它</refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
SPIPlanPtr SPI_prepare_params(const char * <parameter>command</parameter>,
                              ParserSetupHook <parameter>parserSetup</parameter>,
                              void * <parameter>parserSetupArg</parameter>,
                              int <parameter>cursorOptions</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
SPIPlanPtr SPI_prepare_params(const char * <parameter>command</parameter>,
                              ParserSetupHook <parameter>parserSetup</parameter>,
                              void * <parameter>parserSetupArg</parameter>,
                              int <parameter>cursorOptions</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_prepare_params</function> creates and returns a prepared
   statement for the specified command, but doesn't execute the command.
   This function is equivalent to <function>SPI_prepare_cursor</function>,
   with the addition that the caller can specify parser hook functions
   to control the parsing of external parameter references.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_prepare_params</function>为指定的命令创建并
   返回一个预备语句，但是不执行该命令。这个函数等效于
   <function>SPI_prepare_cursor</function>，此外调用者可以指定
   解析器钩子函数来控制外部参数引用的解析。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>const char * <parameter>command</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      command string
     </para>
____________________________________________________________________________-->
     <para>
      命令字符串
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>ParserSetupHook <parameter>parserSetup</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>ParserSetupHook <parameter>parserSetup</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Parser hook setup function
     </para>
____________________________________________________________________________-->
     <para>
      解析器钩子设置函数
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>void * <parameter>parserSetupArg</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>void * <parameter>parserSetupArg</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      pass-through argument for <parameter>parserSetup</parameter>
     </para>
____________________________________________________________________________-->
     <para>
      用于<parameter>parserSetup</parameter>的转嫁参数
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>int <parameter>cursorOptions</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>int <parameter>cursorOptions</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      integer bit mask of cursor options; zero produces default behavior
     </para>
____________________________________________________________________________-->
     <para>
      整数形式的游标选项位掩码，零会导致默认行为
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_prepare_params</function> has the same return conventions as
   <function>SPI_prepare</function>.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_prepare_params</function>具有和
   <function>SPI_prepare</function>相同的返回习惯。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-getargcount">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_getargcount</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_getargcount</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_getargcount</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_getargcount</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_getargcount</refname>
  <refpurpose>return the number of arguments needed by a statement
  prepared by <function>SPI_prepare</function></refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_getargcount</refname>
  <refpurpose>返回一个由<function>SPI_prepare</function>
  准备好的语句所需的参数数量</refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
int SPI_getargcount(SPIPlanPtr <parameter>plan</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
int SPI_getargcount(SPIPlanPtr <parameter>plan</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_getargcount</function> returns the number of arguments needed
   to execute a statement prepared by <function>SPI_prepare</function>.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_getargcount</function>返回执行一个由
   <function>SPI_prepare</function>准备好的语句所需的参数数量。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      prepared statement (returned by <function>SPI_prepare</function>)
     </para>
____________________________________________________________________________-->
     <para>
      预备语句（由<function>SPI_prepare</function>返回）
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>
<!--==========================orignal english content==========================
  <para>
    The count of expected arguments for the <parameter>plan</parameter>.
    If the <parameter>plan</parameter> is <symbol>NULL</symbol> or invalid,
    <varname>SPI_result</varname> is set to <symbol>SPI_ERROR_ARGUMENT</symbol>
    and -1 is returned.
  </para>
____________________________________________________________________________-->
  <para>
    <parameter>plan</parameter>所期望的参数计数。如果该
    <parameter>plan</parameter>为<symbol>NULL</symbol>或者无效，
    <varname>SPI_result</varname>会被设置为<symbol>SPI_ERROR_ARGUMENT</symbol>
    并且返回 -1。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-getargtypeid">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_getargtypeid</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_getargtypeid</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_getargtypeid</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_getargtypeid</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_getargtypeid</refname>
  <refpurpose>return the data type OID for an argument of
  a statement prepared by <function>SPI_prepare</function></refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_getargtypeid</refname>
  <refpurpose>为由<function>SPI_prepare</function>
  准备好的一个语句的一个参数返回其数据类型 OID</refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
Oid SPI_getargtypeid(SPIPlanPtr <parameter>plan</parameter>, int <parameter>argIndex</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
Oid SPI_getargtypeid(SPIPlanPtr <parameter>plan</parameter>, int <parameter>argIndex</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_getargtypeid</function> returns the OID representing the type
   for the <parameter>argIndex</parameter>'th argument of a statement prepared by
   <function>SPI_prepare</function>. First argument is at index zero.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_getargtypeid</function>返回由
   <function>SPI_prepare</function>准备好的一个语句的
   第<parameter>argIndex</parameter>个参数的类型的 OID。
   第一个参数的索引为零。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      prepared statement (returned by <function>SPI_prepare</function>)
     </para>
____________________________________________________________________________-->
     <para>
      预备语句（由<function>SPI_prepare</function>返回）
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>int <parameter>argIndex</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>int <parameter>argIndex</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      zero based index of the argument
     </para>
____________________________________________________________________________-->
     <para>
      参数的索引，从零开始
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>
<!--==========================orignal english content==========================
  <para>
    The type OID of the argument at the given index.
    If the <parameter>plan</parameter> is <symbol>NULL</symbol> or invalid,
    or <parameter>argIndex</parameter> is less than 0 or
    not less than the number of arguments declared for the
    <parameter>plan</parameter>,
    <varname>SPI_result</varname> is set to <symbol>SPI_ERROR_ARGUMENT</symbol>
    and <symbol>InvalidOid</symbol> is returned.
  </para>
____________________________________________________________________________-->
  <para>
    给定索引处的参数的类型 OID。如果该
    <parameter>plan</parameter>为<symbol>NULL</symbol>或者无效，
    或者<parameter>argIndex</parameter>小于零或者小于为
    <parameter>plan</parameter>声明的参数数量，
    <varname>SPI_result</varname>会被设置为
    <symbol>SPI_ERROR_ARGUMENT</symbol>并且将会返回
    <symbol>InvalidOid</symbol>。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-is-cursor-plan">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_is_cursor_plan</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_is_cursor_plan</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_is_cursor_plan</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_is_cursor_plan</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_is_cursor_plan</refname>
  <refpurpose>return <symbol>true</symbol> if a statement
  prepared by <function>SPI_prepare</function> can be used with
  <function>SPI_cursor_open</function></refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_is_cursor_plan</refname>
  <refpurpose>如果一个由<function>SPI_prepare</function>预备好
  的语句可以用于<function>SPI_cursor_open</function>则返回
  <symbol>true</symbol></refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
bool SPI_is_cursor_plan(SPIPlanPtr <parameter>plan</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
bool SPI_is_cursor_plan(SPIPlanPtr <parameter>plan</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_is_cursor_plan</function> returns <symbol>true</symbol>
   if a statement prepared by <function>SPI_prepare</function> can be passed
   as an argument to <function>SPI_cursor_open</function>, or
   <symbol>false</symbol> if that is not the case. The criteria are that the
   <parameter>plan</parameter> represents one single command and that this
   command returns tuples to the caller; for example, <command>SELECT</>
   is allowed unless it contains an <literal>INTO</> clause, and
   <command>UPDATE</> is allowed only if it contains a <literal>RETURNING</>
   clause.
  </para>
____________________________________________________________________________-->
  <para>
   如果一个由<function>SPI_prepare</function>预备好
   的语句可以被作为一个参数传递给<function>SPI_cursor_open</function>，
   <function>SPI_is_cursor_plan</function>会返回<symbol>true</symbol>。
   否则返回<symbol>false</symbol>。原则是该
   <parameter>plan</parameter>表示一个单一命令并且这个命令向其调用者
   返回元组。例如，只要不含<literal>INTO</>子句，<command>SELECT</>
   就被允许，而只有包含一个<literal>RETURNING</>子句时才允许
   <command>UPDATE</>。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      prepared statement (returned by <function>SPI_prepare</function>)
     </para>
____________________________________________________________________________-->
     <para>
      预备语句（由<function>SPI_prepare</function>返回）
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>
<!--==========================orignal english content==========================
  <para>
    <symbol>true</symbol> or <symbol>false</symbol> to indicate if the
    <parameter>plan</parameter> can produce a cursor or not, with
    <varname>SPI_result</varname> set to zero.
    If it is not possible to determine the answer (for example,
    if the <parameter>plan</parameter> is <symbol>NULL</symbol> or invalid,
    or if called when not connected to SPI), then
    <varname>SPI_result</varname> is set to a suitable error code
    and <symbol>false</symbol> is returned.
  </para>
____________________________________________________________________________-->
  <para>
    如果该<parameter>plan</parameter>能产生一个游标则返回
    <symbol>true</symbol>，否则返回<symbol>false</symbol>
    并且把<varname>SPI_result</varname>设置为零。如果不可能决定答案
    （例如，如果<parameter>plan</parameter>为
    <symbol>NULL</symbol>或无效，或者在没有连接到 SPI 时调用），
    那么<varname>SPI_result</varname>会被设置为一个合适的错误码
    并且返回<symbol>false</symbol>。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-execute-plan">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_execute_plan</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_execute_plan</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_execute_plan</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_execute_plan</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_execute_plan</refname>
  <refpurpose>execute a statement prepared by <function>SPI_prepare</function></refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_execute_plan</refname>
  <refpurpose>执行一个由<function>SPI_prepare</function>预备好的语句</refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
int SPI_execute_plan(SPIPlanPtr <parameter>plan</parameter>, Datum * <parameter>values</parameter>, const char * <parameter>nulls</parameter>,
                     bool <parameter>read_only</parameter>, long <parameter>count</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
int SPI_execute_plan(SPIPlanPtr <parameter>plan</parameter>, Datum * <parameter>values</parameter>, const char * <parameter>nulls</parameter>,
                     bool <parameter>read_only</parameter>, long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_execute_plan</function> executes a statement prepared by
   <function>SPI_prepare</function> or one of its siblings.
   <parameter>read_only</parameter> and
   <parameter>count</parameter> have the same interpretation as in
   <function>SPI_execute</function>.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_execute_plan</function>执行一个由
   <function>SPI_prepare</function>或其同类方法准备好的语句。
   <parameter>read_only</parameter>和 and
   <parameter>count</parameter>的解释和
   <function>SPI_execute</function>中相同。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      prepared statement (returned by <function>SPI_prepare</function>)
     </para>
____________________________________________________________________________-->
     <para>
      预备语句（由<function>SPI_prepare</function>返回）
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>Datum * <parameter>values</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>Datum * <parameter>values</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      An array of actual parameter values.  Must have same length as the
      statement's number of arguments.
     </para>
____________________________________________________________________________-->
     <para>
      一个实际参数值的数组。必须和语句的参数数量等长。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      An array describing which parameters are null.  Must have same length as
      the statement's number of arguments.
     </para>
____________________________________________________________________________-->
     <para>
      一个描述哪些参数为空值的数组。必须和语句的参数数量等长。
     </para>

<!--==========================orignal english content==========================
     <para>
      If <parameter>nulls</parameter> is <symbol>NULL</symbol> then
      <function>SPI_execute_plan</function> assumes that no parameters
      are null.  Otherwise, each entry of the <parameter>nulls</parameter>
      array should be <literal>'&nbsp;'</> if the corresponding parameter
      value is non-null, or <literal>'n'</> if the corresponding parameter
      value is null.  (In the latter case, the actual value in the
      corresponding <parameter>values</parameter> entry doesn't matter.)  Note
      that <parameter>nulls</parameter> is not a text string, just an array:
      it does not need a <literal>'\0'</> terminator.
     </para>
____________________________________________________________________________-->
     <para>
      如果<parameter>nulls</parameter>为<symbol>NULL</symbol>，
      那么<function>SPI_execute_plan</function>会假设没有参数
      为空值。否则，如果对应的参数值为非空，
      <parameter>nulls</parameter>
      数组的每一个项都应该是<literal>'&nbsp;'</>；如果对应参数值为空，
      <parameter>nulls</parameter>数组的项应为<literal>'n'</>（在后
      面的情况中，对应的<parameter>values</parameter>项中的值没有
      关系）。注意<parameter>nulls</parameter>不是一个文本字符串，
      它只是一个数组：它不需要一个<literal>'\0'</>终止符。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>bool <parameter>read_only</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para><literal>true</> for read-only execution</para>
____________________________________________________________________________-->
     <para><literal>true</>表示只读执行</para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>long <parameter>count</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      maximum number of rows to return,
      or <literal>0</> for no limit
     </para>
____________________________________________________________________________-->
     <para>
      要返回的行的最大数量，或者用<literal>0</>表示没有限制
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

<!--==========================orignal english content==========================
  <para>
   The return value is the same as for <function>SPI_execute</function>,
   with the following additional possible error (negative) results:

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
       if <parameter>plan</parameter> is <symbol>NULL</symbol> or invalid,
       or <parameter>count</parameter> is less than 0
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_PARAM</symbol></term>
     <listitem>
      <para>
       if <parameter>values</parameter> is <symbol>NULL</symbol> and
       <parameter>plan</parameter> was prepared with some parameters
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   返回值和<function>SPI_execute</function>相同，
   还有下列额外可能的错误（负值）结果：

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
       如果<parameter>plan</parameter>为<symbol>NULL</symbol>
       或者非法，或者<parameter>count</parameter>小于 0
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_PARAM</symbol></term>
     <listitem>
      <para>
       如果<parameter>values</parameter>为<symbol>NULL</symbol>但是
       <parameter>plan</parameter>被准备时用了一些参数
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

<!--==========================orignal english content==========================
  <para>
   <varname>SPI_processed</varname> and
   <varname>SPI_tuptable</varname> are set as in
   <function>SPI_execute</function> if successful.
  </para>
____________________________________________________________________________-->
  <para>
   成功时，就像在<function>SPI_execute</function>中会设置
   <varname>SPI_processed</varname>和
   <varname>SPI_tuptable</varname>。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-execute-plan-with-paramlist">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_execute_plan_with_paramlist</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_execute_plan_with_paramlist</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_execute_plan_with_paramlist</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_execute_plan_with_paramlist</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_execute_plan_with_paramlist</refname>
  <refpurpose>execute a statement prepared by <function>SPI_prepare</function></refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_execute_plan_with_paramlist</refname>
  <refpurpose>执行一个由<function>SPI_prepare</function>预备好的语句</refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
int SPI_execute_plan_with_paramlist(SPIPlanPtr <parameter>plan</parameter>,
                                    ParamListInfo <parameter>params</parameter>,
                                    bool <parameter>read_only</parameter>,
                                    long <parameter>count</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
int SPI_execute_plan_with_paramlist(SPIPlanPtr <parameter>plan</parameter>,
                                    ParamListInfo <parameter>params</parameter>,
                                    bool <parameter>read_only</parameter>,
                                    long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_execute_plan_with_paramlist</function> executes a statement
   prepared by <function>SPI_prepare</function>.
   This function is equivalent to <function>SPI_execute_plan</function>
   except that information about the parameter values to be passed to the
   query is presented differently.  The <literal>ParamListInfo</>
   representation can be convenient for passing down values that are
   already available in that format.  It also supports use of dynamic
   parameter sets via hook functions specified in <literal>ParamListInfo</>.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_execute_plan_with_paramlist</function>执行一个由
   <function>SPI_prepare</function>准备好的语句。这个函数与
   <function>SPI_execute_plan</function>等效，不过被传递给该查询
   的参数值的信息以不同的方式呈现。<literal>ParamListInfo</>表现形
   式更方便于把这种格式的值向下传递。它也支持通过
   <literal>ParamListInfo</>中指定的钩子函数动态设置参数。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      prepared statement (returned by <function>SPI_prepare</function>)
     </para>
____________________________________________________________________________-->
     <para>
      预备语句（由<function>SPI_prepare</function>返回）
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>ParamListInfo <parameter>params</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>ParamListInfo <parameter>params</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      data structure containing parameter types and values; NULL if none
     </para>
____________________________________________________________________________-->
     <para>
      包含参数类型和值的数据结构，如果没有则为 NULL
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>bool <parameter>read_only</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para><literal>true</> for read-only execution</para>
____________________________________________________________________________-->
     <para><literal>true</>表示只读执行</para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>long <parameter>count</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      maximum number of rows to return,
      or <literal>0</> for no limit
     </para>
____________________________________________________________________________-->
     <para>
    要返回的行的最大数量，或者用<literal>0</>表示没有限制
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

<!--==========================orignal english content==========================
  <para>
   The return value is the same as for <function>SPI_execute_plan</function>.
  </para>
____________________________________________________________________________-->
  <para>
   返回值和<function>SPI_execute_plan</function>相同。
  </para>

<!--==========================orignal english content==========================
  <para>
   <varname>SPI_processed</varname> and
   <varname>SPI_tuptable</varname> are set as in
   <function>SPI_execute_plan</function> if successful.
  </para>
____________________________________________________________________________-->
  <para>
   成功时，在<function>SPI_execute_plan</function>中会设置
   <varname>SPI_processed</varname>和
   <varname>SPI_tuptable</varname>。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-execp">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_execp</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_execp</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_execp</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_execp</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_execp</refname>
  <refpurpose>execute a statement in read/write mode</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_execp</refname>
  <refpurpose>以读/写模式执行一个语句</refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
int SPI_execp(SPIPlanPtr <parameter>plan</parameter>, Datum * <parameter>values</parameter>, const char * <parameter>nulls</parameter>, long <parameter>count</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
int SPI_execp(SPIPlanPtr <parameter>plan</parameter>, Datum * <parameter>values</parameter>, const char * <parameter>nulls</parameter>, long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_execp</function> is the same as
   <function>SPI_execute_plan</function>, with the latter's
   <parameter>read_only</parameter> parameter always taken as
   <literal>false</>.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_execp</function>与
   <function>SPI_execute_plan</function>相同，不过后者的
   <parameter>read_only</parameter>参数总是取<literal>false</>。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      prepared statement (returned by <function>SPI_prepare</function>)
     </para>
____________________________________________________________________________-->
     <para>
      预备语句（由<function>SPI_prepare</function>返回）
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>Datum * <parameter>values</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>Datum * <parameter>values</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      An array of actual parameter values.  Must have same length as the
      statement's number of arguments.
     </para>
____________________________________________________________________________-->
     <para>
      实际参数值的数组。长度必须等于该语句的参数数量。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      An array describing which parameters are null.  Must have same length as
      the statement's number of arguments.
     </para>
____________________________________________________________________________-->
     <para>
      描述哪些参数为空值的数据。长度必须等于该语句的参数数量。
     </para>

<!--==========================orignal english content==========================
     <para>
      If <parameter>nulls</parameter> is <symbol>NULL</symbol> then
      <function>SPI_execp</function> assumes that no parameters
      are null.  Otherwise, each entry of the <parameter>nulls</parameter>
      array should be <literal>'&nbsp;'</> if the corresponding parameter
      value is non-null, or <literal>'n'</> if the corresponding parameter
      value is null.  (In the latter case, the actual value in the
      corresponding <parameter>values</parameter> entry doesn't matter.)  Note
      that <parameter>nulls</parameter> is not a text string, just an array:
      it does not need a <literal>'\0'</> terminator.
     </para>
____________________________________________________________________________-->
     <para>
      如果<parameter>nulls</parameter>为<symbol>NULL</symbol>，
      那么<function>SPI_execp</function>会假设没有参数
      为空值。否则，如果对应的参数值为非空，
      <parameter>nulls</parameter>
      数组的每一个项都应该是<literal>'&nbsp;'</>；如果对应参数值为空，
      <parameter>nulls</parameter>数组的项应为<literal>'n'</>（在后
      面的情况中，对应的<parameter>values</parameter>项中的值没有
      关系）。注意<parameter>nulls</parameter>不是一个文本字符串，
      它只是一个数组：它不需要一个<literal>'\0'</>终止符。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>long <parameter>count</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      maximum number of rows to return,
      or <literal>0</> for no limit
     </para>
____________________________________________________________________________-->
     <para>
要返回的行的最大数量，或者用<literal>0</>表示没有限制
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

<!--==========================orignal english content==========================
  <para>
   See <function>SPI_execute_plan</function>.
  </para>
____________________________________________________________________________-->
  <para>
   见<function>SPI_execute_plan</function>。
  </para>

<!--==========================orignal english content==========================
  <para>
   <varname>SPI_processed</varname> and
   <varname>SPI_tuptable</varname> are set as in
   <function>SPI_execute</function> if successful.
  </para>
____________________________________________________________________________-->
  <para>
   成功时，就像在<function>SPI_execute</function>中会设置
   <varname>SPI_processed</varname>和
   <varname>SPI_tuptable</varname>。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-open">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_cursor_open</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_cursor_open</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_cursor_open</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_cursor_open</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_cursor_open</refname>
  <refpurpose>set up a cursor using a statement created with <function>SPI_prepare</function></refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_cursor_open</refname>
  <refpurpose>使用由<function>SPI_prepare</function>创建的
  语句建立一个游标</refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
Portal SPI_cursor_open(const char * <parameter>name</parameter>, SPIPlanPtr <parameter>plan</parameter>,
                       Datum * <parameter>values</parameter>, const char * <parameter>nulls</parameter>,
                       bool <parameter>read_only</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
Portal SPI_cursor_open(const char * <parameter>name</parameter>, SPIPlanPtr <parameter>plan</parameter>,
                       Datum * <parameter>values</parameter>, const char * <parameter>nulls</parameter>,
                       bool <parameter>read_only</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_cursor_open</function> sets up a cursor (internally,
   a portal) that will execute a statement prepared by
   <function>SPI_prepare</function>.  The parameters have the same
   meanings as the corresponding parameters to
   <function>SPI_execute_plan</function>.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_cursor_open</function>建立一个游标（在内部是一个
   portal），该游标将执行由<function>SPI_prepare</function>准备好
   的一个语句。参数具有和<function>SPI_execute_plan</function>的
   相应参数相同的含义。
  </para>

<!--==========================orignal english content==========================
  <para>
   Using a cursor instead of executing the statement directly has two
   benefits.  First, the result rows can be retrieved a few at a time,
   avoiding memory overrun for queries that return many rows.  Second,
   a portal can outlive the current procedure (it can, in fact, live
   to the end of the current transaction).  Returning the portal name
   to the procedure's caller provides a way of returning a row set as
   result.
  </para>
____________________________________________________________________________-->
  <para>
   使用一个游标而不是直接执行该语句有两个好处。首先，可以一次只取出
   一些结果行，避免为返回很多行的查询过度使用内存。其次，一个 portal
   可以比当前查询生存更长时间（事实上，它可以生存到当前事务结束）。
   把 portal 的名称返回给该过程的调用者提供了一种将一个行集合返回为结
   果的方法。
  </para>

<!--==========================orignal english content==========================
  <para>
   The passed-in parameter data will be copied into the cursor's portal, so it
   can be freed while the cursor still exists.
  </para>
____________________________________________________________________________-->
  <para>
   被传入的参数数据将被复制到游标的 portal 中，因此在该游标仍然存在时
   可以释放掉被传入的参数数据。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>const char * <parameter>name</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>const char * <parameter>name</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      name for portal, or <symbol>NULL</symbol> to let the system
      select a name
     </para>
____________________________________________________________________________-->
     <para>
      portal 的名字，或者设置成<symbol>NULL</symbol>
      让系统选择一个名称
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      prepared statement (returned by <function>SPI_prepare</function>)
     </para>
____________________________________________________________________________-->
     <para>
      预备语句（由<function>SPI_prepare</function>返回）
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>Datum * <parameter>values</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>Datum * <parameter>values</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      An array of actual parameter values.  Must have same length as the
      statement's number of arguments.
     </para>
____________________________________________________________________________-->
     <para>
      实际参数值的数组。长度必须等于该语句的参数数量。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      An array describing which parameters are null.  Must have same length as
      the statement's number of arguments.
     </para>
____________________________________________________________________________-->
     <para>
      描述哪些参数是空值的数据。长度必须等于该语句的参数数量。
     </para>

<!--==========================orignal english content==========================
     <para>
      If <parameter>nulls</parameter> is <symbol>NULL</symbol> then
      <function>SPI_cursor_open</function> assumes that no parameters
      are null.  Otherwise, each entry of the <parameter>nulls</parameter>
      array should be <literal>'&nbsp;'</> if the corresponding parameter
      value is non-null, or <literal>'n'</> if the corresponding parameter
      value is null.  (In the latter case, the actual value in the
      corresponding <parameter>values</parameter> entry doesn't matter.)  Note
      that <parameter>nulls</parameter> is not a text string, just an array:
      it does not need a <literal>'\0'</> terminator.
     </para>
____________________________________________________________________________-->
     <para>
      如果<parameter>nulls</parameter>为<symbol>NULL</symbol>，
      那么<function>SPI_cursor_open</function>会假设没有参数
      为空值。否则，如果对应的参数值为非空，
      <parameter>nulls</parameter>
      数组的每一个项都应该是<literal>'&nbsp;'</>；如果对应参数值为空，
      <parameter>nulls</parameter>数组的项应为<literal>'n'</>（在后
      面的情况中，对应的<parameter>values</parameter>项中的值没有
      关系）。注意<parameter>nulls</parameter>不是一个文本字符串，
      它只是一个数组：它不需要一个<literal>'\0'</>终止符。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>bool <parameter>read_only</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para><literal>true</> for read-only execution</para>
____________________________________________________________________________-->
     <para><literal>true</>表示只读执行</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

<!--==========================orignal english content==========================
  <para>
   Pointer to portal containing the cursor.  Note there is no error
   return convention; any error will be reported via <function>elog</>.
  </para>
____________________________________________________________________________-->
  <para>
   指向包含该游标的 portal 的指针。注意这里没有错误返回约定，
   任何错误都将通过<function>elog</>报告。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-open-with-args">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_cursor_open_with_args</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_cursor_open_with_args</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_cursor_open_with_args</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_cursor_open_with_args</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_cursor_open_with_args</refname>
  <refpurpose>set up a cursor using a query and parameters</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_cursor_open_with_args</refname>
  <refpurpose>使用一个查询和参数建立一个游标</refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
Portal SPI_cursor_open_with_args(const char *<parameter>name</parameter>,
                                 const char *<parameter>command</parameter>,
                                 int <parameter>nargs</parameter>, Oid *<parameter>argtypes</parameter>,
                                 Datum *<parameter>values</parameter>, const char *<parameter>nulls</parameter>,
                                 bool <parameter>read_only</parameter>, int <parameter>cursorOptions</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
Portal SPI_cursor_open_with_args(const char *<parameter>name</parameter>,
                                 const char *<parameter>command</parameter>,
                                 int <parameter>nargs</parameter>, Oid *<parameter>argtypes</parameter>,
                                 Datum *<parameter>values</parameter>, const char *<parameter>nulls</parameter>,
                                 bool <parameter>read_only</parameter>, int <parameter>cursorOptions</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_cursor_open_with_args</function> sets up a cursor
   (internally, a portal) that will execute the specified query.
   Most of the parameters have the same meanings as the corresponding
   parameters to <function>SPI_prepare_cursor</function>
   and <function>SPI_cursor_open</function>.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_cursor_open_with_args</function>建立一个将
   执行指定查询的游标（在内部是一个 portal）。大部分参数具有和
   <function>SPI_prepare_cursor</function>
   和<function>SPI_cursor_open</function>中相应参数相同的含
   义。
  </para>

<!--==========================orignal english content==========================
  <para>
   For one-time query execution, this function should be preferred
   over <function>SPI_prepare_cursor</function> followed by
   <function>SPI_cursor_open</function>.
   If the same command is to be executed with many different parameters,
   either method might be faster, depending on the cost of re-planning
   versus the benefit of custom plans.
  </para>
____________________________________________________________________________-->
  <para>
   对于一次性的查询执行，这个函数应该比
   <function>SPI_prepare_cursor</function>加上其后的
   <function>SPI_cursor_open</function>更好。如果相同的命令
   要被用很多不同的参数执行，哪种方法更快就要取决于重做计划的
   代价与定制计划带来的好处之间谁更有利。
  </para>

<!--==========================orignal english content==========================
  <para>
   The passed-in parameter data will be copied into the cursor's portal, so it
   can be freed while the cursor still exists.
  </para>
____________________________________________________________________________-->
  <para>
   被传入的参数数据将被复制到游标的 portal 中，因此在该游标仍然存在时
   可以释放掉被传入的参数数据。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>const char * <parameter>name</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>const char * <parameter>name</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      name for portal, or <symbol>NULL</symbol> to let the system
      select a name
     </para>
____________________________________________________________________________-->
     <para>
      portal 的名字，或者设置成<symbol>NULL</symbol>
      让系统选择一个名称
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>const char * <parameter>command</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      command string
     </para>
____________________________________________________________________________-->
     <para>
      命令字符串
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>int <parameter>nargs</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>int <parameter>nargs</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      number of input parameters (<literal>$1</>, <literal>$2</>, etc.)
     </para>
____________________________________________________________________________-->
     <para>
      输入参数的数量（<literal>$1</>、<literal>$2</>等等）
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>Oid * <parameter>argtypes</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>Oid * <parameter>argtypes</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      an array of length <parameter>nargs</parameter>, containing the
      <acronym>OID</acronym>s of the data types of the parameters
     </para>
____________________________________________________________________________-->
     <para>
      一个长度为<parameter>nargs</parameter>的数组，它包含参数的
      数据类型的<acronym>OID</acronym>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>Datum * <parameter>values</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>Datum * <parameter>values</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      an array of length <parameter>nargs</parameter>, containing the actual
      parameter values
     </para>
____________________________________________________________________________-->
     <para>
      一个长度为<parameter>nargs</parameter>的数组，它包含实际的参数值
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      an array of length <parameter>nargs</parameter>, describing which
      parameters are null
     </para>
____________________________________________________________________________-->
     <para>
      一个长度为<parameter>nargs</parameter>的数组，它描述哪些参数为空值
     </para>

<!--==========================orignal english content==========================
     <para>
      If <parameter>nulls</parameter> is <symbol>NULL</symbol> then
      <function>SPI_cursor_open_with_args</function> assumes that no parameters
      are null.  Otherwise, each entry of the <parameter>nulls</parameter>
      array should be <literal>'&nbsp;'</> if the corresponding parameter
      value is non-null, or <literal>'n'</> if the corresponding parameter
      value is null.  (In the latter case, the actual value in the
      corresponding <parameter>values</parameter> entry doesn't matter.)  Note
      that <parameter>nulls</parameter> is not a text string, just an array:
      it does not need a <literal>'\0'</> terminator.
     </para>
____________________________________________________________________________-->
     <para>
      如果<parameter>nulls</parameter>为<symbol>NULL</symbol>，
      那么<function>SPI_cursor_open_with_args</function>会假设没有参数
      为空值。否则，如果对应的参数值为非空，
      <parameter>nulls</parameter>
      数组的每一个项都应该是<literal>'&nbsp;'</>；如果对应参数值为空，
      <parameter>nulls</parameter>数组的项应为<literal>'n'</>（在后
      面的情况中，对应的<parameter>values</parameter>项中的值没有
      关系）。注意<parameter>nulls</parameter>不是一个文本字符串，
      它只是一个数组：它不需要一个<literal>'\0'</>终止符。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>bool <parameter>read_only</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para><literal>true</> for read-only execution</para>
____________________________________________________________________________-->
     <para><literal>true</>表示只读执行</para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>int <parameter>cursorOptions</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>int <parameter>cursorOptions</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      integer bit mask of cursor options; zero produces default behavior
     </para>
____________________________________________________________________________-->
     <para>
      游标选项的整数型位掩码，为零会产生默认行为
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

<!--==========================orignal english content==========================
  <para>
   Pointer to portal containing the cursor.  Note there is no error
   return convention; any error will be reported via <function>elog</>.
  </para>
____________________________________________________________________________-->
  <para>
   指向包含该游标的 portal 的指针。注意这里没有错误返回约定，
   任何错误都将通过<function>elog</>报告。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-open-with-paramlist">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_cursor_open_with_paramlist</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_cursor_open_with_paramlist</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_cursor_open_with_paramlist</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_cursor_open_with_paramlist</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_cursor_open_with_paramlist</refname>
  <refpurpose>set up a cursor using parameters</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_cursor_open_with_paramlist</refname>
  <refpurpose>使用参数建立一个游标</refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
Portal SPI_cursor_open_with_paramlist(const char *<parameter>name</parameter>,
                                      SPIPlanPtr <parameter>plan</parameter>,
                                      ParamListInfo <parameter>params</parameter>,
                                      bool <parameter>read_only</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
Portal SPI_cursor_open_with_paramlist(const char *<parameter>name</parameter>,
                                      SPIPlanPtr <parameter>plan</parameter>,
                                      ParamListInfo <parameter>params</parameter>,
                                      bool <parameter>read_only</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_cursor_open_with_paramlist</function> sets up a cursor
   (internally, a portal) that will execute a statement prepared by
   <function>SPI_prepare</function>.
   This function is equivalent to <function>SPI_cursor_open</function>
   except that information about the parameter values to be passed to the
   query is presented differently.  The <literal>ParamListInfo</>
   representation can be convenient for passing down values that are
   already available in that format.  It also supports use of dynamic
   parameter sets via hook functions specified in <literal>ParamListInfo</>.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_cursor_open_with_paramlist</function>建立一个
   游标（在内部是一个 portal），它将执行一个由
   <function>SPI_prepare</function>准备好的语句。这个函数等效于
   <function>SPI_cursor_open</function>，不过被传递给该查询
   的参数值的信息以不同的方式呈现。<literal>ParamListInfo</>表现形
   式更方便于把这种格式的值向下传递。它也支持通过
   <literal>ParamListInfo</>中指定的钩子函数动态设置参数。
  </para>

<!--==========================orignal english content==========================
  <para>
   The passed-in parameter data will be copied into the cursor's portal, so it
   can be freed while the cursor still exists.
  </para>
____________________________________________________________________________-->
  <para> 
  被传入的参数数据将被复制到游标的 portal 中，因此在该游标仍然存在时
   可以释放掉被传入的参数数据。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>const char * <parameter>name</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>const char * <parameter>name</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      name for portal, or <symbol>NULL</symbol> to let the system
      select a name
     </para>
____________________________________________________________________________-->
     <para>
      portal 的名字，或者设置成<symbol>NULL</symbol>
      让系统选择一个名称
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      prepared statement (returned by <function>SPI_prepare</function>)
     </para>
____________________________________________________________________________-->
     <para>
      预备语句（由<function>SPI_prepare</function>返回）
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>ParamListInfo <parameter>params</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>ParamListInfo <parameter>params</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      data structure containing parameter types and values; NULL if none
     </para>
____________________________________________________________________________-->
     <para>
      包含参数类型和值的数据结构，如果没有就为 NULL
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>bool <parameter>read_only</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para><literal>true</> for read-only execution</para>
____________________________________________________________________________-->
     <para><literal>true</>表示只读执行</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

<!--==========================orignal english content==========================
  <para>
   Pointer to portal containing the cursor.  Note there is no error
   return convention; any error will be reported via <function>elog</>.
  </para>
____________________________________________________________________________-->
  <para>
   指向包含该游标的 portal 的指针。注意这里没有错误返回约定，
   任何错误都将通过<function>elog</>报告。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-find">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_cursor_find</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_cursor_find</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_cursor_find</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_cursor_find</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_cursor_find</refname>
  <refpurpose>find an existing cursor by name</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_cursor_find</refname>
  <refpurpose>用名称查找一个现有的游标</refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
Portal SPI_cursor_find(const char * <parameter>name</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
Portal SPI_cursor_find(const char * <parameter>name</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_cursor_find</function> finds an existing portal by
   name.  This is primarily useful to resolve a cursor name returned
   as text by some other function.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_cursor_find</function>用名称查找一个现有的 portal。
   这主要被用于解析由其他某个函数返回的一个油表名称。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>const char * <parameter>name</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>const char * <parameter>name</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      name of the portal
     </para>
____________________________________________________________________________-->
     <para>
      该 portal 的名称
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

<!--==========================orignal english content==========================
  <para>
   pointer to the portal with the specified name, or
   <symbol>NULL</symbol> if none was found
  </para>
____________________________________________________________________________-->
  <para>
   带有指定名称的 portal 的指针，如果没有找到就是
   <symbol>NULL</symbol>
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-fetch">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_cursor_fetch</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_cursor_fetch</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_cursor_fetch</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_cursor_fetch</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_cursor_fetch</refname>
  <refpurpose>fetch some rows from a cursor</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_cursor_fetch</refname>
  <refpurpose>从一个游标取出一些行</refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
void SPI_cursor_fetch(Portal <parameter>portal</parameter>, bool <parameter>forward</parameter>, long <parameter>count</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
void SPI_cursor_fetch(Portal <parameter>portal</parameter>, bool <parameter>forward</parameter>, long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_cursor_fetch</function> fetches some rows from a
   cursor.  This is equivalent to a subset of the SQL command
   <command>FETCH</> (see <function>SPI_scroll_cursor_fetch</function>
   for more functionality).
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_cursor_fetch</function>从一个游标取得一些行。
   这等效于 SQL 命令<command>FETCH</>的一个子集（更多功能
   见<function>SPI_scroll_cursor_fetch</function>）。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>Portal <parameter>portal</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>Portal <parameter>portal</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      portal containing the cursor
     </para>
____________________________________________________________________________-->
     <para>
      包含该游标的 portal
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>bool <parameter>forward</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>bool <parameter>forward</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      true for fetch forward, false for fetch backward
     </para>
____________________________________________________________________________-->
     <para>
      为真表示向前获取，为假表示向后获取
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>long <parameter>count</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      maximum number of rows to fetch
     </para>
____________________________________________________________________________-->
     <para>
      要取得的最大行数
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

<!--==========================orignal english content==========================
  <para>
   <varname>SPI_processed</varname> and
   <varname>SPI_tuptable</varname> are set as in
   <function>SPI_execute</function> if successful.
  </para>
____________________________________________________________________________-->
  <para>
   成功时，就像在<function>SPI_execute</function>中会设置
   <varname>SPI_processed</varname>和
   <varname>SPI_tuptable</varname>。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Notes</title>
____________________________________________________________________________-->
  <title>注解</title>

<!--==========================orignal english content==========================
  <para>
   Fetching backward may fail if the cursor's plan was not created
   with the <symbol>CURSOR_OPT_SCROLL</symbol> option.
  </para>
____________________________________________________________________________-->
  <para>
   如果该游标的计划不是用<symbol>CURSOR_OPT_SCROLL</symbol>
   选项创建的，向后获取会失败。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-move">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_cursor_move</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_cursor_move</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_cursor_move</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_cursor_move</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_cursor_move</refname>
  <refpurpose>move a cursor</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_cursor_move</refname>
  <refpurpose>移动一个游标</refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
void SPI_cursor_move(Portal <parameter>portal</parameter>, bool <parameter>forward</parameter>, long <parameter>count</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
void SPI_cursor_move(Portal <parameter>portal</parameter>, bool <parameter>forward</parameter>, long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_cursor_move</function> skips over some number of rows
   in a cursor.  This is equivalent to a subset of the SQL command
   <command>MOVE</> (see <function>SPI_scroll_cursor_move</function>
   for more functionality).
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_cursor_move</function>跳过一个游标中的一些行。
   这等效于 SQL 命令<command>MOVE</>的一个子集（更多的功能
   请见<function>SPI_scroll_cursor_move</function>）。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>Portal <parameter>portal</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>Portal <parameter>portal</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      portal containing the cursor
     </para>
____________________________________________________________________________-->
     <para>
      包含该游标的 portal
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>bool <parameter>forward</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>bool <parameter>forward</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      true for move forward, false for move backward
     </para>
____________________________________________________________________________-->
     <para>
      为真表示前移，为假表示后移
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>long <parameter>count</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      maximum number of rows to move
     </para>
____________________________________________________________________________-->
     <para>
      要移动的最大行数
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Notes</title>
____________________________________________________________________________-->
  <title>注解</title>

<!--==========================orignal english content==========================
  <para>
   Moving backward may fail if the cursor's plan was not created
   with the <symbol>CURSOR_OPT_SCROLL</symbol> option.
  </para>
____________________________________________________________________________-->
  <para>
   如果该游标的计划不是用<symbol>CURSOR_OPT_SCROLL</symbol>
   选项创建的，向后移动会失败。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-scroll-cursor-fetch">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_scroll_cursor_fetch</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_scroll_cursor_fetch</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_scroll_cursor_fetch</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_scroll_cursor_fetch</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_scroll_cursor_fetch</refname>
  <refpurpose>fetch some rows from a cursor</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_scroll_cursor_fetch</refname>
  <refpurpose>从一个游标取出一些行</refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
void SPI_scroll_cursor_fetch(Portal <parameter>portal</parameter>, FetchDirection <parameter>direction</parameter>,
                             long <parameter>count</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
void SPI_scroll_cursor_fetch(Portal <parameter>portal</parameter>, FetchDirection <parameter>direction</parameter>,
                             long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_scroll_cursor_fetch</function> fetches some rows from a
   cursor.  This is equivalent to the SQL command <command>FETCH</>.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_scroll_cursor_fetch</function>从一个游标中取出一些行。
   这等效于 SQL 命令<command>FETCH</>。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>Portal <parameter>portal</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>Portal <parameter>portal</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      portal containing the cursor
     </para>
____________________________________________________________________________-->
     <para>
      包含该游标的 portal
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>FetchDirection <parameter>direction</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>FetchDirection <parameter>direction</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      one of <symbol>FETCH_FORWARD</symbol>,
      <symbol>FETCH_BACKWARD</symbol>,
      <symbol>FETCH_ABSOLUTE</symbol> or
      <symbol>FETCH_RELATIVE</symbol>
     </para>
____________________________________________________________________________-->
     <para>
      <symbol>FETCH_FORWARD</symbol>、
      <symbol>FETCH_BACKWARD</symbol>、
      <symbol>FETCH_ABSOLUTE</symbol>或者
      <symbol>FETCH_RELATIVE</symbol>之一
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>long <parameter>count</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      number of rows to fetch for
      <symbol>FETCH_FORWARD</symbol> or
      <symbol>FETCH_BACKWARD</symbol>; absolute row number to fetch for
      <symbol>FETCH_ABSOLUTE</symbol>; or relative row number to fetch for
      <symbol>FETCH_RELATIVE</symbol>
     </para>
____________________________________________________________________________-->
     <para>
      <symbol>FETCH_FORWARD</symbol>或
      <symbol>FETCH_BACKWARD</symbol>方式中要取出的行数；
      <symbol>FETCH_ABSOLUTE</symbol>方式中要取出的绝对行号；
      <symbol>FETCH_RELATIVE</symbol>方式中要取出的相对行号
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

<!--==========================orignal english content==========================
  <para>
   <varname>SPI_processed</varname> and
   <varname>SPI_tuptable</varname> are set as in
   <function>SPI_execute</function> if successful.
  </para>
____________________________________________________________________________-->
  <para>
   成功时，就像在<function>SPI_execute</function>中会设置
   <varname>SPI_processed</varname>和
   <varname>SPI_tuptable</varname>。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Notes</title>
____________________________________________________________________________-->
  <title>注解</title>

<!--==========================orignal english content==========================
  <para>
   See the SQL <xref linkend="sql-fetch"> command
   for details of the interpretation of the
   <parameter>direction</parameter> and
   <parameter>count</parameter> parameters.
  </para>
____________________________________________________________________________-->
  <para>
   参数<parameter>direction</parameter>和
   <parameter>count</parameter>的详细解释请见
   SQL <xref linkend="sql-fetch">命令。
  </para>

<!--==========================orignal english content==========================
  <para>
   Direction values other than <symbol>FETCH_FORWARD</symbol>
   may fail if the cursor's plan was not created
   with the <symbol>CURSOR_OPT_SCROLL</symbol> option.
  </para>
____________________________________________________________________________-->
  <para>
   如果该游标的计划不是用<symbol>CURSOR_OPT_SCROLL</symbol>
   选项创建的，除<symbol>FETCH_FORWARD</symbol>之外的方向值会
   失败。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-scroll-cursor-move">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_scroll_cursor_move</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_scroll_cursor_move</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_scroll_cursor_move</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_scroll_cursor_move</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_scroll_cursor_move</refname>
  <refpurpose>move a cursor</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_scroll_cursor_move</refname>
  <refpurpose>移动一个游标</refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
void SPI_scroll_cursor_move(Portal <parameter>portal</parameter>, FetchDirection <parameter>direction</parameter>,
                            long <parameter>count</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
void SPI_scroll_cursor_move(Portal <parameter>portal</parameter>, FetchDirection <parameter>direction</parameter>,
                            long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_scroll_cursor_move</function> skips over some number of rows
   in a cursor.  This is equivalent to the SQL command
   <command>MOVE</>.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_scroll_cursor_move</function>在一个游标中跳过
   一定数量的行。这等效于 SQL 命令<command>MOVE</>。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>Portal <parameter>portal</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>Portal <parameter>portal</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      portal containing the cursor
     </para>
____________________________________________________________________________-->
     <para>
      包含该游标的 portal
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>FetchDirection <parameter>direction</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>FetchDirection <parameter>direction</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      one of <symbol>FETCH_FORWARD</symbol>,
      <symbol>FETCH_BACKWARD</symbol>,
      <symbol>FETCH_ABSOLUTE</symbol> or
      <symbol>FETCH_RELATIVE</symbol>
     </para>
____________________________________________________________________________-->
     <para>
      <symbol>FETCH_FORWARD</symbol>、
      <symbol>FETCH_BACKWARD</symbol>、
      <symbol>FETCH_ABSOLUTE</symbol>或者
      <symbol>FETCH_RELATIVE</symbol>之一
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>long <parameter>count</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      number of rows to move for
      <symbol>FETCH_FORWARD</symbol> or
      <symbol>FETCH_BACKWARD</symbol>; absolute row number to move to for
      <symbol>FETCH_ABSOLUTE</symbol>; or relative row number to move to for
      <symbol>FETCH_RELATIVE</symbol>
     </para>
____________________________________________________________________________-->
     <para>
      <symbol>FETCH_FORWARD</symbol>或者
      <symbol>FETCH_BACKWARD</symbol>方式中要移动的行数；
      <symbol>FETCH_ABSOLUTE</symbol>方式中要移动到的绝对行号；
      <symbol>FETCH_RELATIVE</symbol>方式中要移动到的相对行号
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

<!--==========================orignal english content==========================
  <para>
   <varname>SPI_processed</varname> is set as in
   <function>SPI_execute</function> if successful.
   <varname>SPI_tuptable</varname> is set to <symbol>NULL</>, since
   no rows are returned by this function.
  </para>
____________________________________________________________________________-->
  <para>
   成功时，就像在<function>SPI_execute</function>中会设置
   <varname>SPI_processed</varname>。
   <varname>SPI_tuptable</varname>被设置为<symbol>NULL</>，
   因为这个函数不需要返回行。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Notes</title>
____________________________________________________________________________-->
  <title>注解</title>

<!--==========================orignal english content==========================
  <para>
   See the SQL <xref linkend="sql-fetch"> command
   for details of the interpretation of the
   <parameter>direction</parameter> and
   <parameter>count</parameter> parameters.
  </para>
____________________________________________________________________________-->
  <para>
   参数<parameter>direction</parameter>和
   <parameter>count</parameter>的详细解释请见
   SQL <xref linkend="sql-fetch">命令。
  </para>

<!--==========================orignal english content==========================
  <para>
   Direction values other than <symbol>FETCH_FORWARD</symbol>
   may fail if the cursor's plan was not created
   with the <symbol>CURSOR_OPT_SCROLL</symbol> option.
  </para>
____________________________________________________________________________-->
  <para>
   如果该游标的计划不是用<symbol>CURSOR_OPT_SCROLL</symbol>
   选项创建的，除<symbol>FETCH_FORWARD</symbol>之外的方向值会
   失败。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-close">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_cursor_close</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_cursor_close</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_cursor_close</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_cursor_close</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_cursor_close</refname>
  <refpurpose>close a cursor</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_cursor_close</refname>
  <refpurpose>关闭一个游标</refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
void SPI_cursor_close(Portal <parameter>portal</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
void SPI_cursor_close(Portal <parameter>portal</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_cursor_close</function> closes a previously created
   cursor and releases its portal storage.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_cursor_close</function>关闭一个之前创建的游标
   并且释放它的 portal 存储。
  </para>

<!--==========================orignal english content==========================
  <para>
   All open cursors are closed automatically at the end of a
   transaction.  <function>SPI_cursor_close</function> need only be
   invoked if it is desirable to release resources sooner.
  </para>
____________________________________________________________________________-->
  <para>
   所有打开的游标会在事务结束时自动被关闭。
   只有在希望尽快释放资源时，才需要调用
   <function>SPI_cursor_close</function>。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>Portal <parameter>portal</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>Portal <parameter>portal</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      portal containing the cursor
     </para>
____________________________________________________________________________-->
     <para>
      包含该游标的 portal
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-keepplan">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_keepplan</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_keepplan</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_keepplan</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_keepplan</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_keepplan</refname>
  <refpurpose>save a prepared statement</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_keepplan</refname>
  <refpurpose>保存一个预备语句</refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
int SPI_keepplan(SPIPlanPtr <parameter>plan</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
int SPI_keepplan(SPIPlanPtr <parameter>plan</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_keepplan</function> saves a passed statement (prepared by
   <function>SPI_prepare</function>) so that it will not be freed
   by <function>SPI_finish</function> nor by the transaction manager.
   This gives you the ability to reuse prepared statements in the subsequent
   invocations of your procedure in the current session.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_keepplan</function>保存一个被传入的语句（由
   <function>SPI_prepare</function>准备好），这样它将不会被
   <function>SPI_finish</function>或者事务管理器释放。这让你能够
   在当前会话的后续调用中重用预备语句。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      the prepared statement to be saved
     </para>
____________________________________________________________________________-->
     <para>
      要保存的预备语句
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

<!--==========================orignal english content==========================
  <para>
   0 on success;
   <symbol>SPI_ERROR_ARGUMENT</symbol> if <parameter>plan</parameter>
   is <symbol>NULL</symbol> or invalid
  </para>
____________________________________________________________________________-->
  <para>
   成功返回 0；如果<parameter>plan</parameter>为<symbol>NULL</symbol>
   或者无效则返回<symbol>SPI_ERROR_ARGUMENT</symbol>
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Notes</title>
____________________________________________________________________________-->
  <title>注解</title>

<!--==========================orignal english content==========================
  <para>
   The passed-in statement is relocated to permanent storage by means
   of pointer adjustment (no data copying is required).  If you later
   wish to delete it, use <function>SPI_freeplan</function> on it.
  </para>
____________________________________________________________________________-->
  <para>
   这个函数通过指针调整的方法（不需要数据复制）将被传入的语句重定位
   到永久存储中。如果你后来需要删除它，可以对它使用
   <function>SPI_freeplan</function>。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-saveplan">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_saveplan</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_saveplan</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_saveplan</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_saveplan</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_saveplan</refname>
  <refpurpose>save a prepared statement</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_saveplan</refname>
  <refpurpose>保存一个预备语句</refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
SPIPlanPtr SPI_saveplan(SPIPlanPtr <parameter>plan</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
SPIPlanPtr SPI_saveplan(SPIPlanPtr <parameter>plan</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_saveplan</function> copies a passed statement (prepared by
   <function>SPI_prepare</function>) into memory that will not be freed
   by <function>SPI_finish</function> nor by the transaction manager,
   and returns a pointer to the copied statement.  This gives you the
   ability to reuse prepared statements in the subsequent invocations of
   your procedure in the current session.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_saveplan</function>把一个被传入的语句（由
   <function>SPI_prepare</function>准备好）复制到不会被
   <function>SPI_finish</function>或者事务管理器释放的内存中。
   这让你能够在当前会话的后续调用中重用预备语句。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      the prepared statement to be saved
     </para>
____________________________________________________________________________-->
     <para>
      要保存的预备语句
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

<!--==========================orignal english content==========================
  <para>
   Pointer to the copied statement; or <symbol>NULL</symbol> if unsuccessful.
   On error, <varname>SPI_result</varname> is set thus:

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
       if <parameter>plan</parameter> is <symbol>NULL</symbol> or invalid
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
     <listitem>
      <para>
       if called from an unconnected procedure
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   要被复制的语句的指针；如果没有成功则返回<symbol>NULL</symbol>。
   错误时，<varname>SPI_result</varname>会被这样设置：

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
       如果<parameter>plan</parameter>为<symbol>NULL</symbol>或无效
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
     <listitem>
      <para>
       如果从一个未连接的过程调用
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Notes</title>
____________________________________________________________________________-->
  <title>注解</title>

<!--==========================orignal english content==========================
  <para>
   The originally passed-in statement is not freed, so you might wish to do
   <function>SPI_freeplan</function> on it to avoid leaking memory
   until <function>SPI_finish</>.
  </para>
____________________________________________________________________________-->
  <para>
   原始的被传入的语句不会被释放，因此你可能希望在其上执行
   <function>SPI_freeplan</function>以避免在
   <function>SPI_finish</>之前发生内存泄露。
  </para>

<!--==========================orignal english content==========================
  <para>
   In most cases, <function>SPI_keepplan</function> is preferred to this
   function, since it accomplishes largely the same result without needing
   to physically copy the prepared statement's data structures.
  </para>
____________________________________________________________________________-->
  <para>
   在大部分情况下，<function>SPI_keepplan</function>更适合于
   执行这种功能，因为它极大程度上达到了同样的结果而无需物理地
   复制该预备语句的数据结构。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-register-relation">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_register_relation</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_register_relation</primary></indexterm>

<!--==========================orignal english content==========================
 <indexterm>
  <primary>ephemeral named relation</primary>
  <secondary>registering with SPI</secondary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm>
  <primary>临时命名的关系</primary>
  <secondary>注册SPI</secondary>
 </indexterm>

<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_register_relation</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_register_relation</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_register_relation</refname>
  <refpurpose>make a ephemeral named relation available by name in SPI queries</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_register_relation</refname>
  <refpurpose>使得临时命名的关系在SPI查询中可以通过名称使用</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
int SPI_register_relation(EphemeralNamedRelation <parameter>enr</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
int SPI_register_relation(EphemeralNamedRelation <parameter>enr</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_register_relation</function> makes an ephemeral named
   relation, with associated information, available to queries planned and
   executed through the current SPI connection.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_register_relation</function>让临时命名的关系和相关信息可以用于
   通过当前SPI连接计划和执行的查询。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>EphemeralNamedRelation <parameter>enr</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>EphemeralNamedRelation <parameter>enr</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      the ephemeral named relation registry entry
     </para>
____________________________________________________________________________-->
     <para>
      临时命名关系注册表项
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

<!--==========================orignal english content==========================
  <para>
   If the execution of the command was successful then the following
   (nonnegative) value will be returned:

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_OK_REL_REGISTER</symbol></term>
     <listitem>
      <para>
       if the relation has been successfully registered by name
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   如果命令执行成功，则将返回以下（非负）值：

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_OK_REL_REGISTER</symbol></term>
     <listitem>
      <para>
       如果关系已经按名称成功注册
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

<!--==========================orignal english content==========================
  <para>
   On error, one of the following negative values is returned:

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
       if <parameter>enr</parameter> is <symbol>NULL</symbol> or its
       <varname>name</varname> field is <symbol>NULL</symbol>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
     <listitem>
      <para>
       if called from an unconnected procedure
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_REL_DUPLICATE</symbol></term>
     <listitem>
      <para>
       if the name specified in the <varname>name</varname> field of
       <parameter>enr</parameter> is already registered for this connection
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   出错时，将返回以下负值之一：

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
       如果 <parameter>enr</parameter> 是 <symbol>NULL</symbol>或者它的
       <varname>name</varname> 字段是 <symbol>NULL</symbol>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
     <listitem>
      <para>
       如果从未连接的程序中调用
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_REL_DUPLICATE</symbol></term>
     <listitem>
      <para>
       如果已经为此连接注册了<parameter>enr</parameter>的<varname>name</varname>字段中指定的名称
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-unregister-relation">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_unregister_relation</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_unregister_relation</primary></indexterm>

<!--==========================orignal english content==========================
 <indexterm>
  <primary>ephemeral named relation</primary>
  <secondary>unregistering from SPI</secondary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm>
  <primary>临时命名的关系</primary>
  <secondary>未注册SPI</secondary>
 </indexterm>

<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_unregister_relation</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_unregister_relation</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_unregister_relation</refname>
  <refpurpose>remove an ephemeral named relation from the registry</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_unregister_relation</refname>
  <refpurpose>从注册表中删除一个临时命名的关系</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
int SPI_unregister_relation(const char * <parameter>name</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
int SPI_unregister_relation(const char * <parameter>name</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_unregister_relation</function> removes an ephemeral named
   relation from the registry for the current connection.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_unregister_relation</function>
   从当前连接的注册表中删除一个临时的命名关系。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>const char * <parameter>name</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>const char * <parameter>name</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      the relation registry entry name
     </para>
____________________________________________________________________________-->
     <para>
      关系注册表项名称
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

<!--==========================orignal english content==========================
  <para>
   If the execution of the command was successful then the following
   (nonnegative) value will be returned:

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_OK_REL_UNREGISTER</symbol></term>
     <listitem>
      <para>
       if the tuplestore has been successfully removed from the registry
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   如果命令执行成功，则将返回以下（非负）值：

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_OK_REL_UNREGISTER</symbol></term>
     <listitem>
      <para>
       如果关系名称已成功从注册表中删除
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

<!--==========================orignal english content==========================
  <para>
   On error, one of the following negative values is returned:

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
       if <parameter>name</parameter> is <symbol>NULL</symbol>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
     <listitem>
      <para>
       if called from an unconnected procedure
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_REL_NOT_FOUND</symbol></term>
     <listitem>
      <para>
       if <parameter>name</parameter> is not found in the registry for the
       current connection
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   出错时，将返回以下负值之一：

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
       如果 <parameter>name</parameter> 是 <symbol>NULL</symbol>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
     <listitem>
      <para>
       如果从未连接的程序中调用
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_REL_NOT_FOUND</symbol></term>
     <listitem>
      <para>
       如果在注册表中找不到当前连接的<parameter>name</parameter>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-register-trigger-data">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_register_trigger_data</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_register_trigger_data</primary></indexterm>

<!--==========================orignal english content==========================
 <indexterm>
  <primary>ephemeral named relation</primary>
  <secondary>registering with SPI</secondary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm>
  <primary>临时命名的关系</primary>
  <secondary>注册SPI</secondary>
 </indexterm>

<!--==========================orignal english content==========================
 <indexterm>
  <primary>transition tables</primary>
  <secondary>implementation in PLs</secondary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm>
  <primary>转换表</primary>
  <secondary>在PL中实现</secondary>
 </indexterm>

<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_register_trigger_data</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_register_trigger_data</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_register_trigger_data</refname>
  <refpurpose>make ephemeral trigger data available in SPI queries</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_register_trigger_data</refname>
  <refpurpose>在SPI查询中提供临时触发器数据</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
int SPI_register_trigger_data(TriggerData *<parameter>tdata</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
int SPI_register_trigger_data(TriggerData *<parameter>tdata</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_register_trigger_data</function> makes any ephemeral
   relations captured by a trigger available to queries planned and executed
   through the current SPI connection.  Currently, this means the transition
   tables captured by an <literal>AFTER</literal> trigger defined with a
   <literal>REFERENCING OLD/NEW TABLE AS</literal> ... clause.  This function
   should be called by a PL trigger handler function after connecting.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_register_trigger_data</function>
   让触发器捕获的任何临时关系可以用于通过当前SPI连接计划和执行的查询。
   目前，这意味着由<literal>REFERENCING OLD/NEW TABLE AS</literal> ... 
   子句定义的<literal>AFTER</literal>触发器捕获的转换表。连接后应该由PL触发器处理函数调用该函数。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>TriggerData *<parameter>tdata</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>TriggerData *<parameter>tdata</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
       the <structname>TriggerData</structname> object passed to a trigger
       handler function as <literal>fcinfo->context</literal>
     </para>
____________________________________________________________________________-->
     <para>
       传递给触发器处理函数的<structname>TriggerData</structname>对象作为
	   <literal>fcinfo->context</literal>
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

<!--==========================orignal english content==========================
  <para>
   If the execution of the command was successful then the following
   (nonnegative) value will be returned:

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_OK_TD_REGISTER</symbol></term>
     <listitem>
      <para>
       if the captured trigger data (if any) has been successfully registered
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   如果命令执行成功，则将返回以下（非负）值：

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_OK_TD_REGISTER</symbol></term>
     <listitem>
      <para>
       如果捕获的触发数据（如果有）已成功注册
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

<!--==========================orignal english content==========================
  <para>
   On error, one of the following negative values is returned:

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
       if <parameter>tdata</parameter> is <symbol>NULL</symbol>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
     <listitem>
      <para>
       if called from an unconnected procedure
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_REL_DUPLICATE</symbol></term>
     <listitem>
      <para>
       if the name of any trigger data transient relation is already
       registered for this connection
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   出错时，将返回以下负值之一：

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
       如果 <parameter>tdata</parameter> 是<symbol>NULL</symbol>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
     <listitem>
      <para>
       如果从未连接的程序中调用
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_REL_DUPLICATE</symbol></term>
     <listitem>
      <para>
       如果任何触发器数据瞬态关系的名称已经为此连接注册
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

</sect1>

<sect1 id="spi-interface-support">
<!--==========================orignal english content==========================
 <title>Interface Support Functions</title>
____________________________________________________________________________-->
 <title>接口支持函数</title>

<!--==========================orignal english content==========================
 <para>
  The functions described here provide an interface for extracting
  information from result sets returned by <function>SPI_execute</> and
  other SPI functions.
 </para>
____________________________________________________________________________-->
 <para>
  这里描述的函数提供了一个接口从<function>SPI_execute</>
  及其他 SPI 函数返回的结果集中抽取信息。
 </para>

<!--==========================orignal english content==========================
 <para>
  All functions described in this section can be used by both
  connected and unconnected procedures.
 </para>
____________________________________________________________________________-->
 <para>
  这一小节中描述的所有函数都可以被用在已连接和未连接的过程中。
 </para>

<!-- *********************************************** -->

<refentry id="spi-spi-fname">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_fname</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_fname</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_fname</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_fname</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_fname</refname>
  <refpurpose>determine the column name for the specified column number</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_fname</refname>
  <refpurpose>为指定的列号确定列名</refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
char * SPI_fname(TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
char * SPI_fname(TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_fname</function> returns a copy of the column name of the
   specified column.  (You can use <function>pfree</function> to
   release the copy of the name when you don't need it anymore.)
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_fname</function>返回一个指定列的列名的拷贝（
   当你不再需要该列名拷贝后，可以使用<function>pfree</function>
   释放它）。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      input row description
     </para>
____________________________________________________________________________-->
     <para>
      输入行描述
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>int <parameter>colnumber</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>int <parameter>colnumber</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      column number (count starts at 1)
     </para>
____________________________________________________________________________-->
     <para>
      列号（从 1 开始计）
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

<!--==========================orignal english content==========================
  <para>
   The column name; <symbol>NULL</symbol> if
   <parameter>colnumber</parameter> is out of range.
   <varname>SPI_result</varname> set to
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol> on error.
  </para>
____________________________________________________________________________-->
  <para>
   列名；如果<parameter>colnumber</parameter>超出范围则返回
   <symbol>NULL</symbol>。出错时
   <varname>SPI_result</varname>会被设置成
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol>。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-fnumber">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_fnumber</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_fnumber</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_fnumber</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_fnumber</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_fnumber</refname>
  <refpurpose>determine the column number for the specified column name</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_fnumber</refname>
  <refpurpose>为一个指定的列名确定列号</refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
int SPI_fnumber(TupleDesc <parameter>rowdesc</parameter>, const char * <parameter>colname</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
int SPI_fnumber(TupleDesc <parameter>rowdesc</parameter>, const char * <parameter>colname</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_fnumber</function> returns the column number for the
   column with the specified name.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_fnumber</function>返回指定列名的列号。
  </para>

<!--==========================orignal english content==========================
  <para>
   If <parameter>colname</parameter> refers to a system column (e.g.,
   <literal>oid</>) then the appropriate negative column number will
   be returned.  The caller should be careful to test the return value
   for exact equality to <symbol>SPI_ERROR_NOATTRIBUTE</symbol> to
   detect an error; testing the result for less than or equal to 0 is
   not correct unless system columns should be rejected.
  </para>
____________________________________________________________________________-->
  <para>
   如果<parameter>colname</parameter>引用的是一个系统列（例如，
   <literal>oid</>），那么将返回对应的负值列号。调用者应该小心地测试
   返回值是不是正好为<symbol>SPI_ERROR_NOATTRIBUTE</symbol>
   来检测错误；除非系统列应该被拒绝，测试结果是否小于或者等于零这种
   方式是不正确的。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      input row description
     </para>
____________________________________________________________________________-->
     <para>
      输入行描述
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>const char * <parameter>colname</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>const char * <parameter>colname</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      column name
     </para>
____________________________________________________________________________-->
     <para>
      列名
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

<!--==========================orignal english content==========================
  <para>
   Column number (count starts at 1 for user-defined columns), or
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol> if the named column was not
   found.
  </para>
____________________________________________________________________________-->
  <para>
   列号（对于用户定义的列从 1 开始计数），如果没有找到所提到的列名则返回
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol>。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-getvalue">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_getvalue</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_getvalue</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_getvalue</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_getvalue</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_getvalue</refname>
  <refpurpose>return the string value of the specified column</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_getvalue</refname>
  <refpurpose>返回指定列的字符串值</refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
char * SPI_getvalue(HeapTuple <parameter>row</parameter>, TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
char * SPI_getvalue(HeapTuple <parameter>row</parameter>, TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_getvalue</function> returns the string representation
   of the value of the specified column.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_getvalue</function>返回指定列的值的字符串表示。
  </para>

<!--==========================orignal english content==========================
  <para>
   The result is returned in memory allocated using
   <function>palloc</function>.  (You can use
   <function>pfree</function> to release the memory when you don't
   need it anymore.)
  </para>
____________________________________________________________________________-->
  <para>
   结果在使用<function>palloc</function>分配的内存中返回（当你不再
   需要该结果时，你可以使用<function>pfree</function>释放该内存）。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      input row to be examined
     </para>
____________________________________________________________________________-->
     <para>
      要检查的输入行
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      input row description
     </para>
____________________________________________________________________________-->
     <para>
      输入行描述
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>int <parameter>colnumber</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>int <parameter>colnumber</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      column number (count starts at 1)
     </para>
____________________________________________________________________________-->
     <para>
      列号（从 1 开始计）
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

<!--==========================orignal english content==========================
  <para>
   Column value, or <symbol>NULL</symbol> if the column is null,
   <parameter>colnumber</parameter> is out of range
   (<varname>SPI_result</varname> is set to
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol>), or no output function is
   available (<varname>SPI_result</varname> is set to
   <symbol>SPI_ERROR_NOOUTFUNC</symbol>).
  </para>
____________________________________________________________________________-->
  <para>
   列值，如果列为空值、<parameter>colnumber</parameter>超出范围
   （<varname>SPI_result</varname>被设置为
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol>）或者没有输出函数
   可用（<varname>SPI_result</varname>被设置为
   <symbol>SPI_ERROR_NOOUTFUNC</symbol>）则返回
   <symbol>NULL</symbol>。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-getbinval">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_getbinval</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_getbinval</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_getbinval</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_getbinval</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_getbinval</refname>
  <refpurpose>return the binary value of the specified column</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_getbinval</refname>
  <refpurpose>返回指定列的二进制值</refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
Datum SPI_getbinval(HeapTuple <parameter>row</parameter>, TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>,
                    bool * <parameter>isnull</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
Datum SPI_getbinval(HeapTuple <parameter>row</parameter>, TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>,
                    bool * <parameter>isnull</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_getbinval</function> returns the value of the
   specified column in the internal form (as type <type>Datum</type>).
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_getbinval</function>以内部格
   式（以<type>Datum</type>类型）返回指定列的值。
  </para>

<!--==========================orignal english content==========================
  <para>
   This function does not allocate new space for the datum.  In the
   case of a pass-by-reference data type, the return value will be a
   pointer into the passed row.
  </para>
____________________________________________________________________________-->
  <para>
   这个函数不会为该 datum 分配新空间。在传引用数据类型的情况下，
   返回值将是一个被传递行的指针。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      input row to be examined
     </para>
____________________________________________________________________________-->
     <para>
      要检查的输入行
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      input row description
     </para>
____________________________________________________________________________-->
     <para>
      输入行描述
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>int <parameter>colnumber</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>int <parameter>colnumber</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      column number (count starts at 1)
     </para>
____________________________________________________________________________-->
     <para>
      列号（从 1 开始计）
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>bool * <parameter>isnull</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>bool * <parameter>isnull</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      flag for a null value in the column
     </para>
____________________________________________________________________________-->
     <para>
      列中是否为空值的标志
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

<!--==========================orignal english content==========================
  <para>
   The binary value of the column is returned.  The variable pointed
   to by <parameter>isnull</parameter> is set to true if the column is
   null, else to false.
  </para>
____________________________________________________________________________-->
  <para>
   该列的二进制值会被返回。如果该列为空值，由<parameter>isnull</parameter>
   指向的变量将被设置为真，否则会被设置为假。
  </para>

<!--==========================orignal english content==========================
  <para>
   <varname>SPI_result</varname> is set to
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol> on error.
  </para>
____________________________________________________________________________-->
  <para>
   错误时<varname>SPI_result</varname>会被设置成
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol>。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-gettype">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_gettype</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_gettype</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_gettype</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_gettype</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_gettype</refname>
  <refpurpose>return the data type name of the specified column</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_gettype</refname>
  <refpurpose>返回指定列的数据类型名称</refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
char * SPI_gettype(TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
char * SPI_gettype(TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_gettype</function> returns a copy of the data type name of the
   specified column.  (You can use <function>pfree</function> to
   release the copy of the name when you don't need it anymore.)
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_gettype</function>返回该指定列的数据类型名称
   的拷贝（当你不再需要该拷贝后，可以使用<function>pfree</function>
   释放它）。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      input row description
     </para>
____________________________________________________________________________-->
     <para>
      输入行描述
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>int <parameter>colnumber</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>int <parameter>colnumber</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      column number (count starts at 1)
     </para>
____________________________________________________________________________-->
     <para>
      列号（从 1 开始计）
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

<!--==========================orignal english content==========================
  <para>
   The data type name of the specified column, or
   <symbol>NULL</symbol> on error.  <varname>SPI_result</varname> is
   set to <symbol>SPI_ERROR_NOATTRIBUTE</symbol> on error.
  </para>
____________________________________________________________________________-->
  <para>
   指定列的数据类型名称，或者在错误时返回<symbol>NULL</symbol>。
   错误时<varname>SPI_result</varname>会被设置成
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol>。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-gettypeid">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_gettypeid</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_gettypeid</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_gettypeid</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_gettypeid</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_gettypeid</refname>
  <refpurpose>return the data type <acronym>OID</acronym> of the specified column</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_gettypeid</refname>
  <refpurpose>返回指定列的数据类型的<acronym>OID</acronym></refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
Oid SPI_gettypeid(TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
Oid SPI_gettypeid(TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_gettypeid</function> returns the
   <acronym>OID</acronym> of the data type of the specified column.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_gettypeid</function>返回该指定列的数据类型的
   <acronym>OID</acronym>。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      input row description
     </para>
____________________________________________________________________________-->
     <para>
      输入行描述
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>int <parameter>colnumber</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>int <parameter>colnumber</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      column number (count starts at 1)
     </para>
____________________________________________________________________________-->
     <para>
      列号（从 1 开始计）
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

<!--==========================orignal english content==========================
  <para>
   The <acronym>OID</acronym> of the data type of the specified column
   or <symbol>InvalidOid</symbol> on error.  On error,
   <varname>SPI_result</varname> is set to
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol>.
  </para>
____________________________________________________________________________-->
  <para>
   指定列的数据类型的<acronym>OID</acronym>，或者出错时返回
   <symbol>InvalidOid</symbol>。出错时，
   <varname>SPI_result</varname>会被设置成
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol>。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-getrelname">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_getrelname</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_getrelname</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_getrelname</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_getrelname</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_getrelname</refname>
  <refpurpose>return the name of the specified relation</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_getrelname</refname>
  <refpurpose>返回指定关系的名称</refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
char * SPI_getrelname(Relation <parameter>rel</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
char * SPI_getrelname(Relation <parameter>rel</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_getrelname</function> returns a copy of the name of the
   specified relation.  (You can use <function>pfree</function> to
   release the copy of the name when you don't need it anymore.)
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_getrelname</function>返回该指定关系的名称
   的拷贝（当你不再需要该拷贝后，可以使用<function>pfree</function>
   释放它）。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>Relation <parameter>rel</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>Relation <parameter>rel</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      input relation
     </para>
____________________________________________________________________________-->
     <para>
      输入关系
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

<!--==========================orignal english content==========================
  <para>
   The name of the specified relation.
  </para>
____________________________________________________________________________-->
  <para>
   指定关系的名称。
  </para>
 </refsect1>
</refentry>

<refentry id="spi-spi-getnspname">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_getnspname</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_getnspname</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_getnspname</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_getnspname</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_getnspname</refname>
  <refpurpose>return the namespace of the specified relation</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_getnspname</refname>
  <refpurpose>返回指定关系的名字空间</refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
char * SPI_getnspname(Relation <parameter>rel</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
char * SPI_getnspname(Relation <parameter>rel</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_getnspname</function> returns a copy of the name of
   the namespace that the specified <structname>Relation</structname>
   belongs to. This is equivalent to the relation's schema. You should
   <function>pfree</function> the return value of this function when
   you are finished with it.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_getnspname</function>返回指定
   <structname>关系</structname>所属的名字空间的名称拷贝。这等效
   于该关系的模式。当你用完这个函数的返回值后，应该调用
   <function>pfree</function>释放它。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>Relation <parameter>rel</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>Relation <parameter>rel</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      input relation
     </para>
____________________________________________________________________________-->
     <para>
      输入关系
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

<!--==========================orignal english content==========================
  <para>
   The name of the specified relation's namespace.
  </para>
____________________________________________________________________________-->
  <para>
   指定关系的名字空间的名称。
  </para>
 </refsect1>
</refentry>

 </sect1>

 <sect1 id="spi-memory">
<!--==========================orignal english content==========================
  <title>Memory Management</title>
____________________________________________________________________________-->
  <title>内存管理</title>

<!--==========================orignal english content==========================
  <para>
    <indexterm>
     <primary>memory context</primary>
     <secondary>in SPI</secondary>
    </indexterm>
   <productname>PostgreSQL</productname> allocates memory within
   <firstterm>memory contexts</firstterm>, which provide a convenient method of
   managing allocations made in many different places that need to
   live for differing amounts of time.  Destroying a context releases
   all the memory that was allocated in it.  Thus, it is not necessary
   to keep track of individual objects to avoid memory leaks; instead
   only a relatively small number of contexts have to be managed.
   <function>palloc</function> and related functions allocate memory
   from the <quote>current</> context.
  </para>
____________________________________________________________________________-->
  <para>
    <indexterm>
     <primary>memory context</primary>
     <secondary>in SPI</secondary>
    </indexterm>
   <productname>PostgreSQL</productname>
   在<firstterm>内存上下文</firstterm>中分配内存，内存上下文为管理
   在多个不同位置、具有不同生存时间需要的分配提供了一种便捷的方法。
   销毁一个上下文会释放所有在其中分配的内存。因此不必跟踪单个对象来
   避免内存泄露，而是只需要管理数量相对较少的上下文即可。
   <function>palloc</function>和相关的函数可以从<quote>当前</>
   上下文中分配内存。
  </para>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_connect</function> creates a new memory context and
   makes it current.  <function>SPI_finish</function> restores the
   previous current memory context and destroys the context created by
   <function>SPI_connect</function>.  These actions ensure that
   transient memory allocations made inside your procedure are
   reclaimed at procedure exit, avoiding memory leakage.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_connect</function>创建一个新的内存上下文并且让它
   成为当前上下文。<function>SPI_finish</function>恢复之前的当前上下
   文并且销毁由<function>SPI_connect</function>创建的内存上下文。
   这些动作确保在你的过程中的内存分配在过程退出时被回收，从而避免内存
   泄露。
  </para>

<!--==========================orignal english content==========================
  <para>
   However, if your procedure needs to return an object in allocated
   memory (such as a value of a pass-by-reference data type), you
   cannot allocate that memory using <function>palloc</function>, at
   least not while you are connected to SPI.  If you try, the object
   will be deallocated by <function>SPI_finish</function>, and your
   procedure will not work reliably.  To solve this problem, use
   <function>SPI_palloc</function> to allocate memory for your return
   object.  <function>SPI_palloc</function> allocates memory in the
   <quote>upper executor context</quote>, that is, the memory context
   that was current when <function>SPI_connect</function> was called,
   which is precisely the right context for a value returned from your
   procedure.  Several of the other utility procedures described in
   this section also return objects created in the upper executor context.
  </para>
____________________________________________________________________________-->
  <para>
   不过，如果你的过程需要返回一个在已分配内存中的对象（例如一个
   传引用数据类型的值），你不能使用<function>palloc</function>
   分配内存，或者说至少不能在连接到 SPI 时这样做。如果你试着这样
   做，该对象会被<function>SPI_finish</function>接触分配，那么
   你的过程将无法可靠地工作。要解决这个问题，应使用
   <function>SPI_palloc</function>来为要返回的对象分配内存。
   <function>SPI_palloc</function>会在
   <quote>上层执行器上下文</quote>中分配内存，也就是当
   <function>SPI_connect</function>被调用时的当前内存上下文，
   它才是从你的过程中返回的值最适合的上下文。
   本节中介绍的其他一些实用程序还会返回在上层执行程序上下文中创建的对象。
  </para>

<!--==========================orignal english content==========================
  <para>
   When <function>SPI_connect</function> is called, the private
   context of the procedure, which is created by
   <function>SPI_connect</function>, is made the current context.  All
   allocations made by <function>palloc</function>,
   <function>repalloc</function>, or SPI utility functions (except as
   described in this section) are made in this context.  When a
   procedure disconnects from the SPI manager (via
   <function>SPI_finish</function>) the current context is restored to
   the upper executor context, and all allocations made in the
   procedure memory context are freed and cannot be used any more.
  </para>
____________________________________________________________________________-->
  <para>
   当<function>SPI_connect</function>被调用时，这个过程的私有
   上下文（由<function>SPI_connect</function>）会被作为当前上
   下文。所有用<function>palloc</function>、
   <function>repalloc</function>或者 SPI 功能函数（除本节描述的之外）分配的内存都在这个上下文中。
   当一个过程从 SPI 管理器断开连接时（通过
   <function>SPI_finish</function>），当前上下文被恢复到上层的
   执行器上下文，并且在该过程的内存上下文中分配的内存都会被释放，
   之后再不能被使用。
  </para>

<!-- *********************************************** -->

<refentry id="spi-spi-palloc">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_palloc</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_palloc</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_palloc</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_palloc</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_palloc</refname>
  <refpurpose>allocate memory in the upper executor context</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_palloc</refname>
  <refpurpose>在上层执行器上下文中分配内存</refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
void * SPI_palloc(Size <parameter>size</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
void * SPI_palloc(Size <parameter>size</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_palloc</function> allocates memory in the upper
   executor context.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_palloc</function>在上层的执行器上下文中分配内存。
  </para>

<!--==========================orignal english content==========================
  <para>
   This function can only be used while connected to SPI.
   Otherwise, it throws an error.
  </para>
____________________________________________________________________________-->
  <para>
  该函数只能在连接到SPI时使用。否则，它会抛出一个错误。
  </para>
  </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>Size <parameter>size</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>Size <parameter>size</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      size in bytes of storage to allocate
     </para>
____________________________________________________________________________-->
     <para>
      要分配的存储空间大小（以字节计）
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

<!--==========================orignal english content==========================
  <para>
   pointer to new storage space of the specified size
  </para>
____________________________________________________________________________-->
  <para>
   指向具有指定大小的新存储空间的指针
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-realloc">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_repalloc</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_repalloc</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_repalloc</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_repalloc</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_repalloc</refname>
  <refpurpose>reallocate memory in the upper executor context</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_repalloc</refname>
  <refpurpose>在上层执行器上下文中重分配内存</refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
void * SPI_repalloc(void * <parameter>pointer</parameter>, Size <parameter>size</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
void * SPI_repalloc(void * <parameter>pointer</parameter>, Size <parameter>size</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_repalloc</function> changes the size of a memory
   segment previously allocated using <function>SPI_palloc</function>.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_repalloc</function>改变之前用<function>SPI_palloc</function>
   分配的内存段的大小。
  </para>

<!--==========================orignal english content==========================
  <para>
   This function is no longer different from plain
   <function>repalloc</function>.  It's kept just for backward
   compatibility of existing code.
  </para>
____________________________________________________________________________-->
  <para>
   这个函数不再和普通的<function>repalloc</function>相区别。
   保留它只是为了对现有代码保持向后兼容。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>void * <parameter>pointer</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>void * <parameter>pointer</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      pointer to existing storage to change
     </para>
____________________________________________________________________________-->
     <para>
      指向要改变的现有存储空间的指针
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>Size <parameter>size</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>Size <parameter>size</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      size in bytes of storage to allocate
     </para>
____________________________________________________________________________-->
     <para>
      要分配的存储空间大小（以字节计）
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

<!--==========================orignal english content==========================
  <para>
   pointer to new storage space of specified size with the contents
   copied from the existing area
  </para>
____________________________________________________________________________-->
  <para>
   指向具有指定大小的新存储空间的指针，现有区域的内容会被复制到其中
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-pfree">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_pfree</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_pfree</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_pfree</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_pfree</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_pfree</refname>
  <refpurpose>free memory in the upper executor context</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_pfree</refname>
  <refpurpose>在上层执行器上下文中释放内存</refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
void SPI_pfree(void * <parameter>pointer</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
void SPI_pfree(void * <parameter>pointer</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_pfree</function> frees memory previously allocated
   using <function>SPI_palloc</function> or
   <function>SPI_repalloc</function>.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_pfree</function>释放之前使用
   <function>SPI_palloc</function>或者
   <function>SPI_repalloc</function>分配的内存。
  </para>

<!--==========================orignal english content==========================
  <para>
   This function is no longer different from plain
   <function>pfree</function>.  It's kept just for backward
   compatibility of existing code.
  </para>
____________________________________________________________________________-->
  <para>
   这个函数不再和普通的<function>pfree</function>相区别。
   保留它只是为了对现有代码保持向后兼容。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>void * <parameter>pointer</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>void * <parameter>pointer</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      pointer to existing storage to free
     </para>
____________________________________________________________________________-->
     <para>
      指向要释放的现有存储空间的指针
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-copytuple">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_copytuple</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_copytuple</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_copytuple</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_copytuple</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_copytuple</refname>
  <refpurpose>make a copy of a row in the upper executor context</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_copytuple</refname>
  <refpurpose>在上层执行器上下文中创建一行的拷贝</refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
HeapTuple SPI_copytuple(HeapTuple <parameter>row</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
HeapTuple SPI_copytuple(HeapTuple <parameter>row</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_copytuple</function> makes a copy of a row in the
   upper executor context.  This is normally used to return a modified
   row from a trigger.  In a function declared to return a composite
   type, use <function>SPI_returntuple</function> instead.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_copytuple</function>在上层执行器上下文中为一行创建
   一份拷贝。这通常被用来从一个触发器中返回一个被修改的行。在一个被声
   明为返回组合类型的函数中，应使用
   <function>SPI_returntuple</function>。
  </para>

<!--==========================orignal english content==========================
  <para>
   This function can only be used while connected to SPI.
   Otherwise, it returns NULL and sets <varname>SPI_result</varname> to
   <symbol>SPI_ERROR_UNCONNECTED</symbol>.
  </para>
____________________________________________________________________________-->
  <para>
   该函数只能在连接到SPI时使用。否则，它会返回NULL并将<varname>SPI_result</varname>
   设置为<symbol>SPI_ERROR_UNCONNECTED</symbol>。
  </para>
  </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      row to be copied
     </para>
____________________________________________________________________________-->
     <para>
      要拷贝的行
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

<!--==========================orignal english content==========================
  <para>
   the copied row, or <symbol>NULL</symbol> on error
   (see <varname>SPI_result</varname> for an error indication)
  </para>
____________________________________________________________________________-->
  <para>
   被拷贝的行，或者错误时为<symbol>NULL</symbol>
   （参阅<varname>SPI_result</varname>获取错误指示）
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-returntuple">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_returntuple</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_returntuple</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_returntuple</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_returntuple</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_returntuple</refname>
  <refpurpose>prepare to return a tuple as a Datum</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_returntuple</refname>
  <refpurpose>准备把一个元组返回为一个 Datum</refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
HeapTupleHeader SPI_returntuple(HeapTuple <parameter>row</parameter>, TupleDesc <parameter>rowdesc</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
HeapTupleHeader SPI_returntuple(HeapTuple <parameter>row</parameter>, TupleDesc <parameter>rowdesc</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_returntuple</function> makes a copy of a row in
   the upper executor context, returning it in the form of a row type <type>Datum</type>.
   The returned pointer need only be converted to <type>Datum</type> via <function>PointerGetDatum</function>
   before returning.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_returntuple</function>为一个行在上层执行器上下文中
   创建一个拷贝，把它以一种行类型<type>Datum</type>的形式返回。被
   返回的指针只需要在返回前通过<function>PointerGetDatum</function>
   被转换成<type>Datum</type>。
  </para>

<!--==========================orignal english content==========================
  <para>
   This function can only be used while connected to SPI.
   Otherwise, it returns NULL and sets <varname>SPI_result</varname> to
   <symbol>SPI_ERROR_UNCONNECTED</symbol>.
  </para>
____________________________________________________________________________-->
  <para>
   该函数只能在连接到SPI时使用。否则，它会返回NULL并将<varname>SPI_result</varname>
   设置为<symbol>SPI_ERROR_UNCONNECTED</symbol>。
  </para>
<!--==========================orignal english content==========================
  <para>
   Note that this should be used for functions that are declared to return
   composite types.  It is not used for triggers; use
   <function>SPI_copytuple</> for returning a modified row in a trigger.
  </para>
____________________________________________________________________________-->
  <para>
   注意这应该被用于声明为要返回组合类型的函数。它不能用于触发器，在
   触发器中应使用<function>SPI_copytuple</>来返回一个被修改的行。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      row to be copied
     </para>
____________________________________________________________________________-->
     <para>
      要被拷贝的行
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      descriptor for row (pass the same descriptor each time for most
      effective caching)
     </para>
____________________________________________________________________________-->
     <para>
      行的描述符（对大部分有效的缓存，每次都传递相同的描述符）
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

<!--==========================orignal english content==========================
  <para>
   <type>HeapTupleHeader</type> pointing to copied row,
   or <symbol>NULL</symbol> on error
   (see <varname>SPI_result</varname> for an error indication)
  </para>
____________________________________________________________________________-->
  <para>
   <type>HeapTupleHeader</type>指向拷贝好的行，或者错误时为<symbol>NULL</symbol>
   （参阅<varname>SPI_result</varname>获取错误指示）
   时才返回
   <symbol>NULL</symbol>
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-modifytuple">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_modifytuple</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_modifytuple</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_modifytuple</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_modifytuple</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_modifytuple</refname>
  <refpurpose>create a row by replacing selected fields of a given row</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_modifytuple</refname>
  <refpurpose>通过替换一个给定行的选定域来创建一行</refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
HeapTuple SPI_modifytuple(Relation <parameter>rel</parameter>, HeapTuple <parameter>row</parameter>, int <parameter>ncols</parameter>,
                          int * <parameter>colnum</parameter>, Datum * <parameter>values</parameter>, const char * <parameter>nulls</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
HeapTuple SPI_modifytuple(Relation <parameter>rel</parameter>, HeapTuple <parameter>row</parameter>, int <parameter>ncols</parameter>,
                          int * <parameter>colnum</parameter>, Datum * <parameter>values</parameter>, const char * <parameter>nulls</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_modifytuple</function> creates a new row by
   substituting new values for selected columns, copying the original
   row's columns at other positions.  The input row is not modified.
   The new row is returned in the upper executor context.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_modifytuple</function>创建一个新行，其中选定的列
   用新值替代，其他列则从输入行中拷贝。输入行本身不被修改。
   新行在上层执行器上下文中返回。
  </para>

<!--==========================orignal english content==========================
  <para>
   This function can only be used while connected to SPI.
   Otherwise, it returns NULL and sets <varname>SPI_result</varname> to
   <symbol>SPI_ERROR_UNCONNECTED</symbol>.
  </para>
____________________________________________________________________________-->
  <para>
   该函数只能在连接到SPI时使用。否则，它会返回NULL并将<varname>SPI_result</varname>
   设置为<symbol>SPI_ERROR_UNCONNECTED</symbol>。
  </para>
  </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>Relation <parameter>rel</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>Relation <parameter>rel</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Used only as the source of the row descriptor for the row.
      (Passing a relation rather than a row descriptor is a
      misfeature.)
     </para>
____________________________________________________________________________-->
     <para>
      只被用作该行的行描述符的来源（传递一个关系而不是
      一个行描述符是一种令人头痛的设计）。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      row to be modified
     </para>
____________________________________________________________________________-->
     <para>
      要被修改的行
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>int <parameter>ncols</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>int <parameter>ncols</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      number of columns to be changed
     </para>
____________________________________________________________________________-->
     <para>
      要被修改的列数
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>int * <parameter>colnum</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>int * <parameter>colnum</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      an array of length <parameter>ncols</parameter>, containing the numbers
      of the columns that are to be changed (column numbers start at 1)
     </para>
____________________________________________________________________________-->
     <para>
      一个长度为<parameter>ncols</parameter>的数组，包含了要被修改的列号
      （列号从 1 开始）
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>Datum * <parameter>values</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>Datum * <parameter>values</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      an array of length <parameter>ncols</parameter>, containing the
      new values for the specified columns
     </para>
____________________________________________________________________________-->
     <para>
      一个长度为<parameter>ncols</parameter>的数组，包含了指定列的新值
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      an array of length <parameter>ncols</parameter>, describing which
      new values are null
     </para>
____________________________________________________________________________-->
     <para>
      一个长度为<parameter>ncols</parameter>的数组，描述哪些新值为空值
     </para>

<!--==========================orignal english content==========================
     <para>
      If <parameter>nulls</parameter> is <symbol>NULL</symbol> then
      <function>SPI_modifytuple</function> assumes that no new values
      are null.  Otherwise, each entry of the <parameter>nulls</parameter>
      array should be <literal>'&nbsp;'</> if the corresponding new value is
      non-null, or <literal>'n'</> if the corresponding new value is
      null.  (In the latter case, the actual value in the corresponding
      <parameter>values</parameter> entry doesn't matter.)  Note that
      <parameter>nulls</parameter> is not a text string, just an array: it
      does not need a <literal>'\0'</> terminator.
     </para>
____________________________________________________________________________-->
     <para>
      如果<parameter>nulls</parameter>为<symbol>NULL</symbol>，那么
      <function>SPI_modifytuple</function>假定没有新值为空值。否则，
      如果对应的新值为非空，<parameter>nulls</parameter>数组的每一项都应
      该是<literal>'&nbsp;'</>，而如果对应的新值为空值则为<literal>'n'</>（在
      后一种情况中，对应的<parameter>values</parameter>项中的新值无关紧
      要）。注意<parameter>nulls</parameter>不是一个文本字符串，只是一个
      数组：它不需要一个<literal>'\0'</>终止符。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

<!--==========================orignal english content==========================
  <para>
   new row with modifications, allocated in the upper executor
   context, or <symbol>NULL</symbol> on error
   (see <varname>SPI_result</varname> for an error indication)
  </para>
____________________________________________________________________________-->
  <para>
   应用了修改的新行，在上层执行器上下文中分配，或者错误时为
   <symbol>NULL</symbol>（参阅<varname>SPI_result</varname>获取错误指示）
  </para>

<!--==========================orignal english content==========================
  <para>
   On error, <varname>SPI_result</varname> is set as follows:
   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
       if <parameter>rel</> is <symbol>NULL</>, or if
       <parameter>row</> is <symbol>NULL</>, or if <parameter>ncols</>
       is less than or equal to 0, or if <parameter>colnum</> is
       <symbol>NULL</>, or if <parameter>values</> is <symbol>NULL</>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_NOATTRIBUTE</symbol></term>
     <listitem>
      <para>
       if <parameter>colnum</> contains an invalid column number (less
       than or equal to 0 or greater than the number of columns in
       <parameter>row</>)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
     <listitem>
      <para>
       if SPI is not active
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   出错时，<varname>SPI_result</varname>被设置如下：
   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
       如果<parameter>rel</>为<symbol>NULL</>，或者
       <parameter>row</>为<symbol>NULL</>，或者<parameter>ncols</>
       小于等于 0，或者<parameter>colnum</>为<symbol>NULL</>，
       或者<parameter>values</>为<symbol>NULL</>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_NOATTRIBUTE</symbol></term>
     <listitem>
      <para>
       如果<parameter>colnum</>包含一个无效的列号（小于等于 0 或者大于
       <parameter>row</>中的列数）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
     <listitem>
      <para>
       如果SPI未激活
      </para>
     </listitem>
    </varlistentry>
	</variablelist>
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-freetuple">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_freetuple</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_freetuple</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_freetuple</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_freetuple</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_freetuple</refname>
  <refpurpose>free a row allocated in the upper executor context</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_freetuple</refname>
  <refpurpose>释放一个在上层执行器上下文中分配的行</refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
void SPI_freetuple(HeapTuple <parameter>row</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
void SPI_freetuple(HeapTuple <parameter>row</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_freetuple</function> frees a row previously allocated
   in the upper executor context.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_freetuple</function>释放之前在上层执行器上下文中
   分配的一个行。
  </para>

<!--==========================orignal english content==========================
  <para>
   This function is no longer different from plain
   <function>heap_freetuple</function>.  It's kept just for backward
   compatibility of existing code.
  </para>
____________________________________________________________________________-->
  <para>
   这个函数不再和普通的<function>heap_freetuple</function>相区别。
   保留它只是为了对现有代码保持向后兼容。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      row to free
     </para>
____________________________________________________________________________-->
     <para>
      要释放的行
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-freetupletable">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_freetuptable</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_freetuptable</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_freetuptable</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_freetuptable</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_freetuptable</refname>
  <refpurpose>free a row set created by <function>SPI_execute</> or a similar
  function</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_freetuptable</refname>
  <refpurpose>释放一个由<function>SPI_execute</>
  或者类似函数创建的行集合</refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
void SPI_freetuptable(SPITupleTable * <parameter>tuptable</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
void SPI_freetuptable(SPITupleTable * <parameter>tuptable</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_freetuptable</function> frees a row set created by a
   prior SPI command execution function, such as
   <function>SPI_execute</>.  Therefore, this function is often called
   with the global variable <varname>SPI_tuptable</varname> as
   argument.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_freetuptable</function>释放一个由之前的 SPI 命令
   执行函数（例如<function>SPI_execute</>）创建的行集合。因此，
   调用这个函数时，常常使用<varname>SPI_tuptable</varname>作为
   参数。
  </para>

<!--==========================orignal english content==========================
  <para>
   This function is useful if a SPI procedure needs to execute
   multiple commands and does not want to keep the results of earlier
   commands around until it ends.  Note that any unfreed row sets will
   be freed anyway at <function>SPI_finish</>.
   Also, if a subtransaction is started and then aborted within execution
   of a SPI procedure, SPI automatically frees any row sets created while
   the subtransaction was running.
  </para>
____________________________________________________________________________-->
  <para>
   如果一个 SPI 过程需要执行多个命令并且不想保留早期命令的结果，这个
   函数就有用了。注意，<function>SPI_finish</>会释放任何还未释放的
   行集合。还有，如果在一个 SPI 过程的执行中开始了一个子事务并且后来
   被中止，SPI 会自动释放该子事务运行期间创建的任何行集合。
  </para>

<!--==========================orignal english content==========================
  <para>
   Beginning in <productname>PostgreSQL</> 9.3,
   <function>SPI_freetuptable</function> contains guard logic to protect
   against duplicate deletion requests for the same row set.  In previous
   releases, duplicate deletions would lead to crashes.
  </para>
____________________________________________________________________________-->
  <para>
   从<productname>PostgreSQL</> 9.3 开始，
   <function>SPI_freetuptable</function>包含了保护逻辑以避免对于同
   一行集的重复删除请求。在以前的发布中，重复的删除将会导致崩溃。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>SPITupleTable * <parameter>tuptable</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>SPITupleTable * <parameter>tuptable</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      pointer to row set to free, or NULL to do nothing
     </para>
____________________________________________________________________________-->
     <para>
      要释放的行集的指针，NULL 表示什么也不做
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-freeplan">
<!--==========================orignal english content==========================
 <indexterm><primary>SPI_freeplan</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>SPI_freeplan</primary></indexterm>
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>SPI_freeplan</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>SPI_freeplan</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>SPI_freeplan</refname>
  <refpurpose>free a previously saved prepared statement</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>SPI_freeplan</refname>
  <refpurpose>释放一个之前保存的预备语句</refpurpose>
 </refnamediv>


 
 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
int SPI_freeplan(SPIPlanPtr <parameter>plan</parameter>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
int SPI_freeplan(SPIPlanPtr <parameter>plan</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <function>SPI_freeplan</function> releases a prepared statement
   previously returned by <function>SPI_prepare</function> or saved by
   <function>SPI_keepplan</function> or <function>SPI_saveplan</function>.
  </para>
____________________________________________________________________________-->
  <para>
   <function>SPI_freeplan</function>释放一个之前由
   <function>SPI_prepare</function>返回的或者由
   <function>SPI_keepplan</function>、<function>SPI_saveplan</function>
   保存的预备语句。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Arguments</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
____________________________________________________________________________-->
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      pointer to statement to free
     </para>
____________________________________________________________________________-->
     <para>
      要释放的语句的指针
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Return Value</title>
____________________________________________________________________________-->
  <title>返回值</title>

<!--==========================orignal english content==========================
  <para>
   0 on success;
   <symbol>SPI_ERROR_ARGUMENT</symbol> if <parameter>plan</parameter>
   is <symbol>NULL</symbol> or invalid
  </para>
____________________________________________________________________________-->
  <para>
   成功返回 0；如果<parameter>plan</parameter>为
   <symbol>NULL</symbol>或无效则返回
   <symbol>SPI_ERROR_ARGUMENT</symbol>
  </para>
 </refsect1>
</refentry>

 </sect1>

 <sect1 id="spi-visibility">
<!--==========================orignal english content==========================
  <title>Visibility of Data Changes</title>
____________________________________________________________________________-->
  <title>数据改变的可见性</title>

<!--==========================orignal english content==========================
  <para>
   The following rules govern the visibility of data changes in
   functions that use SPI (or any other C function):

   <itemizedlist>
    <listitem>
     <para>
      During the execution of an SQL command, any data changes made by
      the command are invisible to the command itself.  For
      example, in:
<programlisting>
INSERT INTO a SELECT * FROM a;
</programlisting>
      the inserted rows are invisible to the <command>SELECT</command>
      part.
     </para>
    </listitem>

    <listitem>
     <para>
      Changes made by a command C are visible to all commands that are
      started after C, no matter whether they are started inside C
      (during the execution of C) or after C is done.
     </para>
    </listitem>

    <listitem>
     <para>
      Commands executed via SPI inside a function called by an SQL command
      (either an ordinary function or a trigger) follow one or the
      other of the above rules depending on the read/write flag passed
      to SPI.  Commands executed in read-only mode follow the first
      rule: they cannot see changes of the calling command.  Commands executed
      in read-write mode follow the second rule: they can see all changes made
      so far.
     </para>
    </listitem>

    <listitem>
     <para>
      All standard procedural languages set the SPI read-write mode
      depending on the volatility attribute of the function.  Commands of
      <literal>STABLE</> and <literal>IMMUTABLE</> functions are done in
      read-only mode, while commands of <literal>VOLATILE</> functions are
      done in read-write mode.  While authors of C functions are able to
      violate this convention, it's unlikely to be a good idea to do so.
     </para>
    </listitem>
   </itemizedlist>
  </para>
____________________________________________________________________________-->
  <para>
   下列规则主导了使用 SPI 的函数（或者任何其他 C 函数）中数据改变
   的可见性：

   <itemizedlist>
    <listitem>
     <para>
      在一个 SQL 命令的执行期间，该命令所作的任何数据更改对该命令本身
      是不可见的。例如，在
<programlisting>
INSERT INTO a SELECT * FROM a;
</programlisting>
      中，被插入的行对<command>SELECT</command>部分不可见。
     </para>
    </listitem>

    <listitem>
     <para>
      一个命令 C 所作的更改对所有在 C 之后开始的命令可见，不管它们是否
      在 C 之中（在 C 的执行期间）开始还是在 C 完成之后开始。
     </para>
    </listitem>

    <listitem>
     <para>
      在一个 SQL 命令（或者一个普通函数或者触发器）调用的函数内通过
      SPI 执行的命令遵循以上哪条规则取决于传递给 SPI 的读/写标志。以
      只读模式执行的命令遵循第一条规则：它们不能看到调用它们的命令的
      改变。在读写模式中执行的命令遵循第二条规则：它们能看见目前为止
      所有的改变。
     </para>
    </listitem>

    <listitem>
     <para>
      所有的标准过程语言会基于函数的易变性属性设置 SPI 读写模式。
      <literal>STABLE</>和<literal>IMMUTABLE</>函数的命令会以
      只读模式完成，而<literal>VOLATILE</>函数的命令会以读写模式
      完成。虽然 C 函数的作者可以违反这种习惯，但是最好不要那样做。
     </para>
    </listitem>
   </itemizedlist>
  </para>

<!--==========================orignal english content==========================
  <para>
   The next section contains an example that illustrates the
   application of these rules.
  </para>
____________________________________________________________________________-->
  <para>
   下一节包含一个关于这些规则应用的例子：
  </para>
 </sect1>

 <sect1 id="spi-examples">
<!--==========================orignal english content==========================
  <title>Examples</title>
____________________________________________________________________________-->
  <title>例子</title>

<!--==========================orignal english content==========================
  <para>
   This section contains a very simple example of SPI usage. The
   procedure <function>execq</function> takes an SQL command as its
   first argument and a row count as its second, executes the command
   using <function>SPI_exec</function> and returns the number of rows
   that were processed by the command.  You can find more complex
   examples for SPI in the source tree in
   <filename>src/test/regress/regress.c</filename> and in the
   <xref linkend="contrib-spi"> module.
  </para>
____________________________________________________________________________-->
  <para>
   这一节包含了 SPI 用法的一个非常简单的例子。过程
   <function>execq</function>用一个 SQL 命令作为其第一个参数
   并且用一个行计数作为第二个参数，使用
   <function>SPI_exec</function>执行该命令并且返回被该该命令
   处理过的行的数量。你可以在源代码树的
   <filename>src/test/regress/regress.c</filename>和
   <xref linkend="contrib-spi">模块中找到 SPI 的更复杂的例子。
  </para>

<!--==========================orignal english content==========================
<programlisting>
#include "postgres.h"

#include "executor/spi.h"
#include "utils/builtins.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

int64 execq(text *sql, int cnt);

int64
execq(text *sql, int cnt)
{
    char *command;
    int ret;
    uint64 proc;

    /* Convert given text object to a C string */
    command = text_to_cstring(sql);

    SPI_connect();

    ret = SPI_exec(command, cnt);

    proc = SPI_processed;
    /*
     * If some rows were fetched, print them via elog(INFO).
     */
    if (ret &gt; 0 &amp;&amp; SPI_tuptable != NULL)
    {
        TupleDesc tupdesc = SPI_tuptable-&gt;tupdesc;
        SPITupleTable *tuptable = SPI_tuptable;
        char buf[8192];
        uint64 j;

        for (j = 0; j &lt; proc; j++)
        {
            HeapTuple tuple = tuptable-&gt;vals[j];
            int i;

            for (i = 1, buf[0] = 0; i &lt;= tupdesc-&gt;natts; i++)
                snprintf(buf + strlen (buf), sizeof(buf) - strlen(buf), " %s%s",
                        SPI_getvalue(tuple, tupdesc, i),
                        (i == tupdesc-&gt;natts) ? " " : " |");
            elog(INFO, "EXECQ: %s", buf);
        }
    }

    SPI_finish();
    pfree(command);

    return (proc);
}
</programlisting>
____________________________________________________________________________-->
<programlisting>
#include "postgres.h"

#include "executor/spi.h"
#include "utils/builtins.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

int64 execq(text *sql, int cnt);

int64
execq(text *sql, int cnt)
{
    char *command;
    int ret;
    uint64 proc;

    /* 把给定的文本对象转换成一个 C 字符串 */
    command = text_to_cstring(sql);

    SPI_connect();

    ret = SPI_exec(command, cnt);

    proc = SPI_processed;
    /*
     * 如果取出了一些行，通过 elog(INFO) 打印它们。
     */
    if (ret &gt; 0 &amp;&amp; SPI_tuptable != NULL)
    {
        TupleDesc tupdesc = SPI_tuptable-&gt;tupdesc;
        SPITupleTable *tuptable = SPI_tuptable;
        char buf[8192];
        uint64 j;

        for (j = 0; j &lt; proc; j++)
        {
            HeapTuple tuple = tuptable-&gt;vals[j];
            int i;
            for (i = 1, buf[0] = 0; i &lt;= tupdesc-&gt;natts; i++)
                snprintf(buf + strlen (buf), sizeof(buf) - strlen(buf), " %s%s",
                        SPI_getvalue(tuple, tupdesc, i),
                        (i == tupdesc-&gt;natts) ? " " : " |");
            elog(INFO, "EXECQ: %s", buf);
        }
    }

    SPI_finish();
    pfree(command);

    return (proc);
}
</programlisting>

<!--==========================orignal english content==========================
  <para>
   (This function uses call convention version 0, to make the example
   easier to understand.  In real applications you should use the new
   version 1 interface.)
  </para>
____________________________________________________________________________-->
  <para>
   （为了便于理解，这个函数使用了调用习惯版本 0。在实际的应用中，
   你应该使用新的版本 1 接口）。
  </para>

<!--==========================orignal english content==========================
  <para>
   This is how you declare the function after having compiled it into
   a shared library (details are in <xref linkend="dfunc">.):

<programlisting>
CREATE FUNCTION execq(text, integer) RETURNS int8
    AS '<replaceable>filename</replaceable>'
    LANGUAGE C STRICT;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   在把该函数编译到一个共享库中（详见<xref linkend="dfunc">）之
   后，这样声明该函数：

<programlisting>
CREATE FUNCTION execq(text, integer) RETURNS int8
    AS '<replaceable>filename</replaceable>'
    LANGUAGE C STRICT;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Here is a sample session:

<programlisting>
=&gt; SELECT execq('CREATE TABLE a (x integer)', 0);
 execq
-&minus;-&minus;-&minus;-
     0
(1 row)

=&gt; INSERT INTO a VALUES (execq('INSERT INTO a VALUES (0)', 0));
INSERT 0 1
=&gt; SELECT execq('SELECT * FROM a', 0);
INFO:  EXECQ:  0    -&minus; inserted by execq
INFO:  EXECQ:  1    -&minus; returned by execq and inserted by upper INSERT

 execq
-&minus;-&minus;-&minus;-
     2
(1 row)

=&gt; SELECT execq('INSERT INTO a SELECT x + 2 FROM a', 1);
 execq
-&minus;-&minus;-&minus;-
     1
(1 row)

=&gt; SELECT execq('SELECT * FROM a', 10);
INFO:  EXECQ:  0
INFO:  EXECQ:  1
INFO:  EXECQ:  2    -&minus; 0 + 2, only one row inserted - as specified

 execq
-&minus;-&minus;-&minus;-
     3              -&minus; 10 is the max value only, 3 is the real number of rows
(1 row)

=&gt; DELETE FROM a;
DELETE 3
=&gt; INSERT INTO a VALUES (execq('SELECT * FROM a', 0) + 1);
INSERT 0 1
=&gt; SELECT * FROM a;
 x
-&minus;-
 1                  -&minus; no rows in a (0) + 1
(1 row)

=&gt; INSERT INTO a VALUES (execq('SELECT * FROM a', 0) + 1);
INFO:  EXECQ:  1
INSERT 0 1
=&gt; SELECT * FROM a;
 x
-&minus;-
 1
 2                  -&minus; there was one row in a + 1
(2 rows)

-&minus; This demonstrates the data changes visibility rule:

=&gt; INSERT INTO a SELECT execq('SELECT * FROM a', 0) * x FROM a;
INFO:  EXECQ:  1
INFO:  EXECQ:  2
INFO:  EXECQ:  1
INFO:  EXECQ:  2
INFO:  EXECQ:  2
INSERT 0 2
=&gt; SELECT * FROM a;
 x
-&minus;-
 1
 2
 2                  -&minus; 2 rows * 1 (x in first row)
 6                  -&minus; 3 rows (2 + 1 just inserted) * 2 (x in second row)
(4 rows)               ^^^^^^
                       rows visible to execq() in different invocations
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   下面是一个会话实例：

<programlisting>
=&gt; SELECT execq('CREATE TABLE a (x integer)', 0);
 execq
-------
     0
(1 row)

=&gt; INSERT INTO a VALUES (execq('INSERT INTO a VALUES (0)', 0));
INSERT 0 1
=&gt; SELECT execq('SELECT * FROM a', 0);
INFO:  EXECQ:  0    -- inserted by execq
INFO:  EXECQ:  1    -- returned by execq and inserted by upper INSERT

 execq
-------
     2
(1 row)

=&gt; SELECT execq('INSERT INTO a SELECT x + 2 FROM a', 1);
 execq
-------
     1
(1 row)

=&gt; SELECT execq('SELECT * FROM a', 10);
INFO:  EXECQ:  0
INFO:  EXECQ:  1
INFO:  EXECQ:  2    -- 0 + 2，按照所指定的，只有一行被插入

 execq
-------
     3              -- 10 只是最大值，3 是实际的行数
(1 row)

=&gt; DELETE FROM a;
DELETE 3
=&gt; INSERT INTO a VALUES (execq('SELECT * FROM a', 0) + 1);
INSERT 0 1
=&gt; SELECT * FROM a;
 x
---
 1                  -- 没有行在 a (0) + 1
(1 row)

=&gt; INSERT INTO a VALUES (execq('SELECT * FROM a', 0) + 1);
INFO:  EXECQ:  1
INSERT 0 1
=&gt; SELECT * FROM a;
 x
---
 1
 2                  -- 有一行在 in a + 1
(2 rows)

-- 这证明了数据改变可见性规则：

=&gt; INSERT INTO a SELECT execq('SELECT * FROM a', 0) * x FROM a;
INFO:  EXECQ:  1
INFO:  EXECQ:  2
INFO:  EXECQ:  1
INFO:  EXECQ:  2
INFO:  EXECQ:  2
INSERT 0 2
=&gt; SELECT * FROM a;
 x
---
 1
 2
 2                  -- 2 行 * 1 （第一行中的 x）
 6                  -- 3 rows (2 + 1 被插入) * 2 （第二行中的 x）
(4 rows)               ^^^^^^
                       不同调用中 execq() 的行可见性
</programlisting>
  </para>
 </sect1>
</chapter>
