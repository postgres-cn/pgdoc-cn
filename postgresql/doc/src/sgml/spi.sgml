<!-- doc/src/sgml/spi.sgml -->

<chapter id="spi">
 <title>服务器编程接口</title>

 <indexterm zone="spi">
  <primary>SPI</primary>
 </indexterm>

 <para>
  <firstterm>服务器编程接口</firstterm>（<acronym>SPI</acronym>）给予用户定义<acronym>C</acronym>函数编写者在其函数内运行<acronym>SQL</acronym>命令的能力。<acronym>SPI</acronym>是一组接口函数，它们可以简化对解析器、规划器和执行器的访问。<acronym>SPI</acronym>也做一些内存管理。
 </para>

 <note>
  <para>
   可用的过程语言提供了多种方法从过程中执行 SQL 命令。大部分这些设施都是基于 SPI 的，因此这个文档也对那些语言的用户有用。
  </para>
 </note>

 <para>
  为了避免误解，我们在谈及<acronym>SPI</acronym>接口函数时使用术语<quote>函数</quote>，而谈及使用<acronym>SPI</acronym>的用户定义的 C 函数时使用术语<quote>过程</quote>。
 </para>

 <para>
  注意如果一个通过 SPI 调用的命令失败，那么控制将会返回到你的过程中。当然啦，你的过程所在的事务或者子事务将被回滚（这可能看起来令人惊讶，因为据文档所说 SPI 函数大多数都有错误返回约定。但是那些约定只适用于在 SPI 函数本身内部检测到的错误）。通过在可能失败的 SPI 调用周围建立自己的子事务可以在错误之后恢复控制。当前文档中并未记载这些，因为所需的机制仍然在变化中。
 </para>

 <para>
  <acronym>SPI</acronym>成功时返回一个非负结果（要么通过一个返回的整数值，要么如下所述放在全局变量<varname>SPI_result</varname>中）。错误时，将会返回一个负结果或者<symbol>NULL</symbol>。
 </para>

 <para>
  使用 SPI 的源代码文件必须包括头文件<filename>executor/spi.h</filename>。
 </para>


<sect1 id="spi-interface">
 <title>接口函数</title>

 <refentry id="spi-spi-connect">
  <indexterm><primary>SPI_connect</primary></indexterm>
  
  <refmeta>
   <refentrytitle>SPI_connect</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>SPI_connect</refname>
   <refpurpose>连接一个过程到 SPI 管理器</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
int SPI_connect(void)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_connect</function>从一个过程调用中打开一个到 SPI 管理器的连接。如果你想要通过 SPI 执行命令，你必须调用这个函数。有一些功能性 SPI 函数可以从未连接的过程中调用。
  </para>

  <para>
   如果你的过程已经连接，<function>SPI_connect</function>将返回错误代码<returnvalue>SPI_ERROR_CONNECT</returnvalue>。这可能发生在一个已经直接调用过<function>SPI_connect</function>的过程中调用另一个调用<function>SPI_connect</function>的过程时。虽然当一个通过 SPI 调用的 SQL 命令调用另一个使用<acronym>SPI</acronym>的函数时允许对<acronym>SPI</acronym>管理器的递归调用，但对<function>SPI_connect</function>和<function>SPI_finish</function>的直接嵌套调用是被禁止的（但是可以看看<function>SPI_push</function> 和<function>SPI_pop</function>）。
  </para>
 </refsect1>

 <refsect1>
  <title>返回值</title>

  <variablelist>
   <varlistentry>
    <term><symbol>SPI_OK_CONNECT</symbol></term>
    <listitem>
     <para>
      成功时
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><symbol>SPI_ERROR_CONNECT</symbol></term>
    <listitem>
     <para>
      错误时
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-finish">
 <indexterm><primary>SPI_finish</primary></indexterm>
 
 <refmeta>
  <refentrytitle>SPI_finish</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_finish</refname>
  <refpurpose>将一个过程从 SPI 管理器断开</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
int SPI_finish(void)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_finish</function>关闭一个到 SPI 管理器的现有连接。你必须在完成你的过程的当前调用中所需的 SPI 操作之后必须调用这个函数。不过，如果你通过<literal>elog(ERROR)</literal>中断了事务，你无须担心这个函数的调用。在那种情况下，SPI 将自己自动进行清理。
  </para>

  <para>
   如果调用<function>SPI_finish</function>时没有一个可用的连接，它将返回<symbol>SPI_ERROR_UNCONNECTED</symbol>。这没有根本性的问题，它表示 SPI 管理器无事可做。
  </para>
 </refsect1>

 <refsect1>
  <title>返回值</title>

  <variablelist>
   <varlistentry>
    <term><symbol>SPI_OK_FINISH</symbol></term>
    <listitem>
     <para>
      如果正确地断开连接
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
    <listitem>
     <para>
      如果从一个未连接的过程中调用
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-push">
 <indexterm><primary>SPI_push</primary></indexterm>

<refmeta>
  <refentrytitle>SPI_push</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_push</refname>
  <refpurpose>下推 SPI 栈以允许递归的 SPI 使用</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
void SPI_push(void)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   在执行另一个可能本身也想用 SPI 的过程之前，应该调用<function>SPI_push</function>。在<function>SPI_push</function>之后，SPI 就不再处于一种<quote>已连接</>状态，并且除非完成一次新的<function>SPI_connect</function>否则 SPI 函数调用将被拒绝。这保证了在过程的 SPI 状态和另一个你调用的过程之间的完全隔离。在其他过程返回后，调用<function>SPI_pop</function>以恢复对你自己的 SPI 状态的访问。
  </para>

  <para>
   注意<function>SPI_execute</function>和相关函数在将控制交回给 SQL 执行引擎之前会自动做<function>SPI_push</function>的等效物，因此在使用那些函数时你无须担心这个问题。只有当你直接调用任何可能包含<function>SPI_connect</function>调用的代码时，你才真正需要发出<function>SPI_push</function>和<function>SPI_pop</function>。
  </para>
 </refsect1>

</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-pop">
 <indexterm><primary>SPI_pop</primary></indexterm>
 
 <refmeta>
  <refentrytitle>SPI_pop</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_pop</refname>
  <refpurpose>从 SPI 栈弹出以从递归的 SPI 使用中返回</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
void SPI_pop(void)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_pop</function>从 SPI 调用栈中弹出之前的环境。参见<function>SPI_push</function>。
  </para>
 </refsect1>

</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-execute">
 <indexterm><primary>SPI_execute</primary></indexterm>
 
 <refmeta>
  <refentrytitle>SPI_execute</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_execute</refname>
  <refpurpose>执行一个命令</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
int SPI_execute(const char * <parameter>command</parameter>, bool <parameter>read_only</parameter>, long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_execute</function>执行指定的 SQL 命令以获得<parameter>count</parameter>行。如果<parameter>read_only</parameter>为<literal>真</>，该命令必须是只读的，并且执行开销也会有所降低。
  </para>

  <para>
   只能从一个已连接的过程中调用这个函数。
  </para>

  <para>
   如果<parameter>count</parameter>为零，那么该命令会为其所适用的所有行执行。如果<parameter>count</parameter>大于零，那么会检索不超过<parameter>count</parameter>行，当到达该计数时执行会停止，这很像为查询增加一个<literal>LIMIT</literal>子句。例如：
<programlisting>
SPI_execute("SELECT * FROM foo", true, 5);
</programlisting>
   会从表中检索至多 5 行。注意这样一个限制只有当命令真正返回行时才有效。例如：
<programlisting>
SPI_execute("INSERT INTO foo SELECT * FROM bar", false, 5);
</programlisting>
   插入所有来自于<structname>bar</>的行，而忽略<parameter>count</parameter>参数。不过，通过
<programlisting>
SPI_execute("INSERT INTO foo SELECT * FROM bar RETURNING *", false, 5);
</programlisting>
   将插入至多 5 行，因为在第五个<literal>RETURNING</>结果行被检索到后执行就会停止。
  </para>

  <para>
   你可以在一个字符串中传递多个命令，<function>SPI_execute</function>会返回最后一个被执行的命令的结果。
   <parameter>count</parameter>限制单独适用于每一个命令（即便只有最后一个结果会被实际返回）。该限制
   不适用于由规则产生的任何隐藏命令。
  </para>

  <para>
   当<parameter>read_only</parameter>是<literal>false</>时，
   <function>SPI_execute</function>增加命令计数器并且在执行字符串中每一个命令之前
   计算一个新的<firstterm>snapshot</>。如果当前事务隔离级别是<literal>SERIALIZABLE</>或<literal>REPEATABLE READ</>，
   该快照并不会实际改变。但是在<literal>READ COMMITTED</>模式中，快照更新允许每个命令看到来自其他会话中新近已提交事务
   的结果。当命令正在修改数据库时，这对一致性行为非常重要。
  </para>

  <para>
   当<parameter>read_only</parameter>是<literal>true</>时，
   <function>SPI_execute</function>不更新快照或者命令计数器，并且它只允许纯
   <command>SELECT</>命令出现在命令字符串中。这些命令被使用之前为周围查询
   建立的快照来执行。这种执行模式要比读/写模式更快，因为消除了每个命令跟新快照的开销。
   它也允许建立真正<firstterm>stable</>的函数：因为连续执行将会使用同一个快照，因此结果不会有改变。
  </para>

  <para>
   在一个使用 SPI 的单一函数中混合只读和读写命令通常是不明智的，
   这样可能会导致非常令人困惑的行为，因为只读查询将看不到任何
   由读写查询完成的数据库更新结果。
  </para>

  <para>
   被执行的（最后一个）命令的实际行数使用全局变量<varname>SPI_processed</varname>返回。
   如果该函数的返回值是<symbol>SPI_OK_SELECT</symbol>、
   <symbol>SPI_OK_INSERT_RETURNING</symbol>、
   <symbol>SPI_OK_DELETE_RETURNING</symbol>或者
   <symbol>SPI_OK_UPDATE_RETURNING</symbol>，
   那么你可以使用全局指针<literal>SPITupleTable *SPI_tuptable</literal>来访问结果行。
   某些工具命令（例如<command>EXPLAIN</>）也返回行集合，并且在这些情况中<literal>SPI_tuptable</>
   也会包含该结果。某些工具命令（<command>COPY</>、<command>CREATE TABLE AS</>）不返回一个行集合，
   因此<literal>SPI_tuptable</>为 NULL，但是它们仍然会在<varname>SPI_processed</>中返回被处理的行数。
  </para>

  <para>
   结构<structname>SPITupleTable</structname>被定义为：
<programlisting>
typedef struct
{
    MemoryContext tuptabcxt;    /* 结果表的内存上下文 */
    uint32      alloced;        /* 已分配值的数量 */
    uint32      free;           /* 空限值的数量 */
    TupleDesc   tupdesc;        /* 行描述符 */
    HeapTuple  *vals;           /* 行 */
} SPITupleTable;
</programlisting>
   <structfield>vals</>是一个行指针的数组（可用项的数量由<varname>SPI_processed</varname>给出）。
   <structfield>tupdesc</>是一个行描述符，你可以把它传递给 SPI 函数来处理行。<structfield>tuptabcxt</>、
   <structfield>alloced</>和<structfield>free</>是不准备给 SPI 调用者使用的内部域。
  </para>

  <para>
   <function>SPI_finish</function>释放在当前过程中已分配的所有<structname>SPITupleTable</>。
   如果你已经用完了一个结果表，你可以通过调用<function>SPI_freetuptable</function>提早释放它。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
     <para>
      包含要执行命令的字符串
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
     <para>对只读执行为<literal>true</></para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
     <para>
      要返回的最大行数，或者用<literal>0</>表示没有限制
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>返回值</title>

  <para>
   如果命令的执行成功，那么将会返回下列（非负）值之一：

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_OK_SELECT</symbol></term>
     <listitem>
      <para>
       如果执行了一个<command>SELECT</command>（但不是<command>SELECT INTO</>）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_SELINTO</symbol></term>
     <listitem>
      <para>
       如果执行了一个<command>SELECT INTO</command>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_INSERT</symbol></term>
     <listitem>
      <para>
       如果执行了一个<command>INSERT</command>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_DELETE</symbol></term>
     <listitem>
      <para>
       如果执行了一个<command>DELETE</command>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_UPDATE</symbol></term>
     <listitem>
      <para>
       如果执行了一个<command>UPDATE</command>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_INSERT_RETURNING</symbol></term>
     <listitem>
      <para>
       如果执行了一个<command>INSERT RETURNING</command>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_DELETE_RETURNING</symbol></term>
     <listitem>
      <para>
       如果执行了一个<command>DELETE RETURNING</command>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_UPDATE_RETURNING</symbol></term>
     <listitem>
      <para>
       如果执行了一个<command>UPDATE RETURNING</command>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_UTILITY</symbol></term>
     <listitem>
      <para>
       如果执行了一个工具命令（例如<command>CREATE TABLE</command>）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_REWRITTEN</symbol></term>
     <listitem>
      <para>
       如果该命令被一个<link linkend="rules">规则</link>重写成了另一类命令（例如<command>UPDATE</command>变成了一个<command>INSERT</command>）
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   发生错误时，将会返回下列负值之一：

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
       如果<parameter>command</parameter>为<symbol>NULL</symbol>或者<parameter>count</parameter>小于 0
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_COPY</symbol></term>
     <listitem>
      <para>
       如果尝试<command>COPY TO stdout</>或者<command>COPY FROM stdin</>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_TRANSACTION</symbol></term>
     <listitem>
      <para>
       如果尝试了一个事务操纵命令（
       <command>BEGIN</>、
       <command>COMMIT</>、
       <command>ROLLBACK</>、
       <command>SAVEPOINT</>、
       <command>PREPARE TRANSACTION</>、
       <command>COMMIT PREPARED</>、
       <command>ROLLBACK PREPARED</>或者其他变体）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_OPUNKNOWN</symbol></term>
     <listitem>
      <para>
       如果命令类型位置（不应该会发生）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
     <listitem>
      <para>
       如果调用过程未连接
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>

 <refsect1>
  <title>注解</title>

  <para>
   所有 SPI 查询执行函数都会设置<varname>SPI_processed</varname>和<varname>SPI_tuptable</varname>（只是指针，
   而不是结构的内容）。如果你需要在以后访问<function>SPI_execute</function>或另一个查询执行函数的结果表，
   请将这两个全局变量保存到局部过程变量中。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-exec">
 <indexterm><primary>SPI_exec</primary></indexterm>
 
 <refmeta>
  <refentrytitle>SPI_exec</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_exec</refname>
  <refpurpose>执行一个读/写命令</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
int SPI_exec(const char * <parameter>command</parameter>, long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_exec</function>和
   <function>SPI_execute</function>相同，但后者的
   <parameter>read_only</parameter>参数的值总是取
   <literal>false</>。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
     <para>
      包含要执行的命令的字符串
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
     <para>
      要返回的最大行数，<literal>0</>表示没有限制
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>返回值</title>

  <para>
   见<function>SPI_execute</function>。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-execute-with-args">
 <refmeta>
  <refentrytitle>SPI_execute_with_args</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_execute_with_args</refname>
  <refpurpose>用线外参数执行一个命令</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_execute_with_args</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
int SPI_execute_with_args(const char *<parameter>command</parameter>,
                          int <parameter>nargs</parameter>, Oid *<parameter>argtypes</parameter>,
                          Datum *<parameter>values</parameter>, const char *<parameter>nulls</parameter>,
                          bool <parameter>read_only</parameter>, long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_execute_with_args</function>执行一个可能包括
   对外部提供的参数引用的命令。命令文本用
   <literal>$<replaceable>n</></literal>引用一个参数，并且调用
   会为每一个这种符号指定数据类型和值。
   <parameter>read_only</parameter>和
   <parameter>count</parameter>的解释与
   <function>SPI_execute</function>中相同。
  </para>

  <para>
   相对于<function>SPI_execute</function>，这个例程的主要优
   点是数据值可以被插入到命令中而无需冗长的引用/转义，并且因此
   减少了 SQL 注入攻击的风险。
  </para>

  <para>
   可以通过在<function>SPI_prepare</>后面跟上
   <function>SPI_execute_plan</function>达到相似的结果。但是，
   使用这个函数时查询计划总是被定制成提供的指定参数值。对于一次
   性的查询执行，这个函数应该更好。如果同样的命令需要用很多不同
   的参数执行，两种方法都可能会更快，这取决于重新做规划的代价与
   定制计划带来的好处之间的对比。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
     <para>
      命令字符串
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>nargs</parameter></literal></term>
    <listitem>
     <para>
      输入参数的数量（<literal>$1</>、<literal>$2</>等等）。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Oid * <parameter>argtypes</parameter></literal></term>
    <listitem>
     <para>
      一个长度为<parameter>nargs</parameter>的数组，
      包含参数的数据类型的<acronym>OID</acronym>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Datum * <parameter>values</parameter></literal></term>
    <listitem>
     <para>
      一个长度为<parameter>nargs</parameter>的数组，
      包含实际的参数值
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
    <listitem>
     <para>
      一个长度为<parameter>nargs</parameter>的数组，
      描述哪些参数为空值
     </para>

     <para>
      如果<parameter>nulls</parameter>为<symbol>NULL</symbol>，
      那么<function>SPI_execute_with_args</function>会假设没有参数
      为空值。否则，如果对应的参数值为非空，
      <parameter>nulls</parameter>
      数组的每一个项都应该是<literal>'&nbsp;'</>；如果对应参数值为空，
      <parameter>nulls</parameter>数组的项应为<literal>'n'</>（在后
      面的情况中，对应的<parameter>values</parameter>项中的值没有
      关系）。注意<parameter>nulls</parameter>不是一个文本字符串，
      它只是一个数组：它不需要一个<literal>'\0'</>终止符。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
     <para>对只读执行是<literal>true</></para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
     <para>
      要返回的最大行数，<literal>0</>表示没有限制
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>返回值</title>

  <para>
   该返回值和<function>SPI_execute</function>一样。
  </para>

  <para>
   如果成功<function>SPI_execute</function>会设置
   <varname>SPI_processed</varname>和
   <varname>SPI_tuptable</varname>。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-prepare">
 <refmeta>
  <refentrytitle>SPI_prepare</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_prepare</refname>
  <refpurpose>准备一个语句，但不执行它</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_prepare</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
SPIPlanPtr SPI_prepare(const char * <parameter>command</parameter>, int <parameter>nargs</parameter>, Oid * <parameter>argtypes</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_prepare</function>为指定的命令创建并且返回一个
   预备语句，但是并不执行该命令。该预备语句会在稍后使用
   <function>SPI_execute_plan</function>重复执行。
  </para>

  <para>
   当相同的或者相似的命令要被重复执行时，通常来说只执行一次解析分
   析是有利的，并且更有利的是重用该命令的执行计划。
   <function>SPI_prepare</function>把一个命令字符串转换成一个预
   备语句，它包装了解析分析的结果。如果发现为每一次执行都生成一个
   定制计划没有帮助，该预备语句也提供了一个地方缓存执行计划。
  </para>

  <para>
   一个预备命令可以被一般化为在一个普通命令中应该出现常量的地方写
   上参数（<literal>$1</>、<literal>$2</>等等）。参数的实际值在
   <function>SPI_execute_plan</function>被调用时指定。这让该预备
   语句可以比没有参数的形式用户与更广泛的情况。
  </para>

  <para>
   <function>SPI_prepare</function>返回的语句只能在当前过程调用
   中使用，因为<function>SPI_finish</function>会释放为这样一个语句
   分配的内存。但是可以使用函数<function>SPI_keepplan</function>
   或<function>SPI_saveplan</function>把该语句保存更久。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
     <para>
      命令字符串
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>nargs</parameter></literal></term>
    <listitem>
     <para>
      输入参数（<literal>$1</>、<literal>$2</>等等）的数量
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Oid * <parameter>argtypes</parameter></literal></term>
    <listitem>
     <para>
      一个数组指针，它指向的数组包含参数的数据类型的
      <acronym>OID</acronym>
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>返回值</title>

  <para>
   <function>SPI_prepare</function>返回一个指向<type>SPIPlan</>
   的非空指针，它是一个表示一个预备语句的不透明结构。发生错误时，
   将会返回<symbol>NULL</symbol>，并且
   <varname>SPI_result</varname>将被设置为一个也被
   <function>SPI_execute</function>使用的错误码，不过当
   <parameter>command</parameter>为<symbol>NULL</symbol>、
   或者<parameter>nargs</>小于零、或者<parameter>nargs</>大于
   零但是<parameter>argtypes</>为<symbol>NULL</symbol>
   时它会被设置为<symbol>SPI_ERROR_ARGUMENT</symbol>。
  </para>
 </refsect1>

 <refsect1>
  <title>注解</title>

  <para>
   如果没有定义参数，在第一次使用<function>SPI_execute_plan</function>
   时将会创建一个一般的计划，并且把它用于所有的后续执行。如果有参数，
   <function>SPI_execute_plan</function>的前几次使用将根据提供的参数值
   产生定制计划。在使用同一个预备语句足够多次后，
   <function>SPI_execute_plan</function>将构建一个一般计划，并且如果它
   并不比定制计划昂贵太多， <function>SPI_execute_plan</function>将开始
   使用一般计划来取代每次都进行重新规划。如果这种默认的行为不合适，你可以
   通过传递<literal>CURSOR_OPT_GENERIC_PLAN</>或
   <literal>CURSOR_OPT_CUSTOM_PLAN</>标志给
   <function>SPI_prepare_cursor</function>，以分别强制使用一般或者定制
   计划。
  </para>

  <para>
   尽管一个预备语句的要点是避免对语句的重复解析分析以及规划，只要语句中
   用到的数据库对象从上一次使用该预备语句以来经历过定义性（DDL）改变，
   <productname>PostgreSQL</>将会强制重新分析和重新规划该语句。还有，
   如果<xref linkend="guc-search-path">的值从一个改变成下一个，该语句将
   会使用新的<varname>search_path</>进行重新解析（后一种行为是从
   <productname>PostgreSQL</productname> 9.3 开始的新行为）。更多
   有关预备语句行为的信息请见<xref linkend="sql-prepare">。
  </para>

  <para>
   这个函数只能从一个已连接的过程调用。
  </para>

  <para>
   <type>SPIPlanPtr</>被声明为<filename>spi.h</>中的一种不透明结构类型
   的指针。尝试直接访问其内容是不明智的，因为那会让你的代码更有可能会在未
   来版本的<productname>PostgreSQL</productname>中崩溃。
  </para>

  <para>
   <type>SPIPlanPtr</>这个名字多少有点历史原因，因为该数据结构不再需要包
   含一个执行计划。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-prepare-cursor">
 <refmeta>
  <refentrytitle>SPI_prepare_cursor</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_prepare_cursor</refname>
  <refpurpose>预备一个语句，但是不执行它</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_prepare_cursor</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
SPIPlanPtr SPI_prepare_cursor(const char * <parameter>command</parameter>, int <parameter>nargs</parameter>,
                              Oid * <parameter>argtypes</parameter>, int <parameter>cursorOptions</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_prepare_cursor</function>和
   <function>SPI_prepare</function>一样，不过它也允许说明规划器的
   <quote>游标选项</>参数。这是一个位掩码，它的值如
   <filename>nodes/parsenodes.h</filename>中
   <structname>DeclareCursorStmt</>的<structfield>options</>域所示。
   <function>SPI_prepare</function>总是把该游标选项取做零。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
     <para>
      命令字符串
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>nargs</parameter></literal></term>
    <listitem>
     <para>
      输入参数（<literal>$1</>、<literal>$2</>等等）的数量
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Oid * <parameter>argtypes</parameter></literal></term>
    <listitem>
     <para>
      一个数组指针，它指向的数组包含参数的数据类型的
      <acronym>OID</acronym>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>cursorOptions</parameter></literal></term>
    <listitem>
     <para>
      整数形式的游标选项位掩码，零会导致默认行为
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>返回值</title>

  <para>
   <function>SPI_prepare_cursor</function>具有和
   <function>SPI_prepare</function>一样的返回习惯。
  </para>
 </refsect1>

 <refsect1>
  <title>注解</title>

  <para>
   在<parameter>cursorOptions</>设置的有用的位包括
   <symbol>CURSOR_OPT_SCROLL</symbol>、
   <symbol>CURSOR_OPT_NO_SCROLL</symbol>、
   <symbol>CURSOR_OPT_FAST_PLAN</symbol>、
   <symbol>CURSOR_OPT_GENERIC_PLAN</symbol>以及
   <symbol>CURSOR_OPT_CUSTOM_PLAN</symbol>。
   注意<symbol>CURSOR_OPT_HOLD</symbol>被特别地忽略。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-prepare-params">
 <refmeta>
  <refentrytitle>SPI_prepare_params</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_prepare_params</refname>
  <refpurpose>预备一个语句，但是不执行它</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_prepare_params</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
SPIPlanPtr SPI_prepare_params(const char * <parameter>command</parameter>,
                              ParserSetupHook <parameter>parserSetup</parameter>,
                              void * <parameter>parserSetupArg</parameter>,
                              int <parameter>cursorOptions</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_prepare_params</function>为指定的命令创建并
   返回一个预备语句，但是不执行该命令。这个函数等效于
   <function>SPI_prepare_cursor</function>，此外调用者可以指定
   解析器钩子函数来控制外部参数引用的解析。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
     <para>
      命令字符串
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ParserSetupHook <parameter>parserSetup</parameter></literal></term>
    <listitem>
     <para>
      解析器钩子设置函数
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>void * <parameter>parserSetupArg</parameter></literal></term>
    <listitem>
     <para>
      用于<parameter>parserSetup</parameter>的转嫁参数
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>cursorOptions</parameter></literal></term>
    <listitem>
     <para>
      整数形式的游标选项位掩码，零会导致默认行为
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>返回值</title>

  <para>
   <function>SPI_prepare_params</function>具有和
   <function>SPI_prepare</function>相同的返回习惯。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-getargcount">
 <refmeta>
  <refentrytitle>SPI_getargcount</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_getargcount</refname>
  <refpurpose>返回一个由<function>SPI_prepare</function>
  准备好的语句所需的参数数量</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_getargcount</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
int SPI_getargcount(SPIPlanPtr <parameter>plan</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_getargcount</function>返回执行一个由
   <function>SPI_prepare</function>准备好的语句所需的参数数量。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <para>
      预备语句（由<function>SPI_prepare</function>返回）
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>返回值</title>
  <para>
    <parameter>plan</parameter>所期望的参数计数。如果该
    <parameter>plan</parameter>为<symbol>NULL</symbol>或者无效，
    <varname>SPI_result</varname>会被设置为<symbol>SPI_ERROR_ARGUMENT</symbol>
    并且返回 -1。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-getargtypeid">
 <refmeta>
  <refentrytitle>SPI_getargtypeid</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_getargtypeid</refname>
  <refpurpose>为由<function>SPI_prepare</function>
  准备好的一个语句的一个参数返回其数据类型 OID</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_getargtypeid</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
Oid SPI_getargtypeid(SPIPlanPtr <parameter>plan</parameter>, int <parameter>argIndex</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_getargtypeid</function>返回由
   <function>SPI_prepare</function>准备好的一个语句的
   第<parameter>argIndex</parameter>个参数的类型的 OID。
   第一个参数的索引为零。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <para>
      预备语句（由<function>SPI_prepare</function>返回）
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>argIndex</parameter></literal></term>
    <listitem>
     <para>
      参数的索引，从零开始
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>返回值</title>
  <para>
    给定索引处的参数的类型 OID。如果该
    <parameter>plan</parameter>为<symbol>NULL</symbol>或者无效，
    或者<parameter>argIndex</parameter>小于零或者小于为
    <parameter>plan</parameter>声明的参数数量，
    <varname>SPI_result</varname>会被设置为
    <symbol>SPI_ERROR_ARGUMENT</symbol>并且将会返回
    <symbol>InvalidOid</symbol>。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-is-cursor-plan">
 <refmeta>
  <refentrytitle>SPI_is_cursor_plan</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_is_cursor_plan</refname>
  <refpurpose>如果一个由<function>SPI_prepare</function>预备好
  的语句可以用于<function>SPI_cursor_open</function>则返回
  <symbol>true</symbol></refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_is_cursor_plan</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
bool SPI_is_cursor_plan(SPIPlanPtr <parameter>plan</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   如果一个由<function>SPI_prepare</function>预备好
   的语句可以被作为一个参数传递给<function>SPI_cursor_open</function>，
   <function>SPI_is_cursor_plan</function>会返回<symbol>true</symbol>。
   否则返回<symbol>false</symbol>。原则是该
   <parameter>plan</parameter>表示一个单一命令并且这个命令向其调用者
   返回元组。例如，只要不含<literal>INTO</>子句，<command>SELECT</>
   就被允许，而只有包含一个<literal>RETURNING</>子句时才允许
   <command>UPDATE</>。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <para>
      预备语句（由<function>SPI_prepare</function>返回）
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>返回值</title>
  <para>
    如果该<parameter>plan</parameter>能产生一个游标则返回
    <symbol>true</symbol>，否则返回<symbol>false</symbol>
    并且把<varname>SPI_result</varname>设置为零。如果不可能决定答案
    （例如，如果<parameter>plan</parameter>为
    <symbol>NULL</symbol>或无效，或者在没有连接到 SPI 时调用），
    那么<varname>SPI_result</varname>会被设置为一个合适的错误码
    并且返回<symbol>false</symbol>。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-execute-plan">
 <refmeta>
  <refentrytitle>SPI_execute_plan</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_execute_plan</refname>
  <refpurpose>执行一个由<function>SPI_prepare</function>预备好的语句</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_execute_plan</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
int SPI_execute_plan(SPIPlanPtr <parameter>plan</parameter>, Datum * <parameter>values</parameter>, const char * <parameter>nulls</parameter>,
                     bool <parameter>read_only</parameter>, long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_execute_plan</function>执行一个由
   <function>SPI_prepare</function>或其同类方法准备好的语句。
   <parameter>read_only</parameter>和 and
   <parameter>count</parameter>的解释和
   <function>SPI_execute</function>中相同。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <para>
      预备语句（由<function>SPI_prepare</function>返回）
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Datum * <parameter>values</parameter></literal></term>
    <listitem>
     <para>
      一个实际参数值的数组。必须和语句的参数数量等长。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
    <listitem>
     <para>
      一个描述哪些参数为空值的数组。必须和语句的参数数量等长。
     </para>

     <para>
      如果<parameter>nulls</parameter>为<symbol>NULL</symbol>，
      那么<function>SPI_execute_plan</function>会假设没有参数
      为空值。否则，如果对应的参数值为非空，
      <parameter>nulls</parameter>
      数组的每一个项都应该是<literal>'&nbsp;'</>；如果对应参数值为空，
      <parameter>nulls</parameter>数组的项应为<literal>'n'</>（在后
      面的情况中，对应的<parameter>values</parameter>项中的值没有
      关系）。注意<parameter>nulls</parameter>不是一个文本字符串，
      它只是一个数组：它不需要一个<literal>'\0'</>终止符。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
     <para><literal>true</>表示只读执行</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
     <para>
      要返回的行的最大数量，或者用<literal>0</>表示没有限制
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>返回值</title>

  <para>
   返回值和<function>SPI_execute</function>相同，
   还有下列额外可能的错误（负值）结果：

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
       如果<parameter>plan</parameter>为<symbol>NULL</symbol>
       或者非法，或者<parameter>count</parameter>小于 0
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_PARAM</symbol></term>
     <listitem>
      <para>
       如果<parameter>values</parameter>为<symbol>NULL</symbol>但是
       <parameter>plan</parameter>被准备时用了一些参数
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   成功时，就像在<function>SPI_execute</function>中会设置
   <varname>SPI_processed</varname>和
   <varname>SPI_tuptable</varname>。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-execute-plan-with-paramlist">
 <refmeta>
  <refentrytitle>SPI_execute_plan_with_paramlist</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_execute_plan_with_paramlist</refname>
  <refpurpose>执行一个由<function>SPI_prepare</function>预备好的语句</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_execute_plan_with_paramlist</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
int SPI_execute_plan_with_paramlist(SPIPlanPtr <parameter>plan</parameter>,
                                    ParamListInfo <parameter>params</parameter>,
                                    bool <parameter>read_only</parameter>,
                                    long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_execute_plan_with_paramlist</function>执行一个由
   <function>SPI_prepare</function>准备好的语句。这个函数与
   <function>SPI_execute_plan</function>等效，不过被传递给该查询
   的参数值的信息以不同的方式呈现。<literal>ParamListInfo</>表现形
   式更方便于把这种格式的值向下传递。它也支持通过
   <literal>ParamListInfo</>中指定的钩子函数动态设置参数。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <para>
      预备语句（由<function>SPI_prepare</function>返回）
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ParamListInfo <parameter>params</parameter></literal></term>
    <listitem>
     <para>
      包含参数类型和值的数据结构，如果没有则为 NULL
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
     <para><literal>true</>表示只读执行</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
     <para>
    要返回的行的最大数量，或者用<literal>0</>表示没有限制
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>返回值</title>

  <para>
   返回值和<function>SPI_execute_plan</function>相同。
  </para>

  <para>
   成功时，在<function>SPI_execute_plan</function>中会设置
   <varname>SPI_processed</varname>和
   <varname>SPI_tuptable</varname>。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-execp">
 <refmeta>
  <refentrytitle>SPI_execp</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_execp</refname>
  <refpurpose>以读/写模式执行一个语句</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_execp</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
int SPI_execp(SPIPlanPtr <parameter>plan</parameter>, Datum * <parameter>values</parameter>, const char * <parameter>nulls</parameter>, long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_execp</function>与
   <function>SPI_execute_plan</function>相同，不过后者的
   <parameter>read_only</parameter>参数总是取<literal>false</>。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <para>
      预备语句（由<function>SPI_prepare</function>返回）
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Datum * <parameter>values</parameter></literal></term>
    <listitem>
     <para>
      实际参数值的数组。长度必须等于该语句的参数数量。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
    <listitem>
     <para>
      描述哪些参数为空值的数据。长度必须等于该语句的参数数量。
     </para>

     <para>
      如果<parameter>nulls</parameter>为<symbol>NULL</symbol>，
      那么<function>SPI_execp</function>会假设没有参数
      为空值。否则，如果对应的参数值为非空，
      <parameter>nulls</parameter>
      数组的每一个项都应该是<literal>'&nbsp;'</>；如果对应参数值为空，
      <parameter>nulls</parameter>数组的项应为<literal>'n'</>（在后
      面的情况中，对应的<parameter>values</parameter>项中的值没有
      关系）。注意<parameter>nulls</parameter>不是一个文本字符串，
      它只是一个数组：它不需要一个<literal>'\0'</>终止符。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
     <para>
要返回的行的最大数量，或者用<literal>0</>表示没有限制
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>返回值</title>

  <para>
   见<function>SPI_execute_plan</function>。
  </para>

  <para>
   成功时，就像在<function>SPI_execute</function>中会设置
   <varname>SPI_processed</varname>和
   <varname>SPI_tuptable</varname>。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-open">
 <refmeta>
  <refentrytitle>SPI_cursor_open</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_cursor_open</refname>
  <refpurpose>使用由<function>SPI_prepare</function>创建的
  语句建立一个游标</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_cursor_open</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
Portal SPI_cursor_open(const char * <parameter>name</parameter>, SPIPlanPtr <parameter>plan</parameter>,
                       Datum * <parameter>values</parameter>, const char * <parameter>nulls</parameter>,
                       bool <parameter>read_only</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_cursor_open</function>建立一个游标（在内部是一个
   portal），该游标将执行由<function>SPI_prepare</function>准备好
   的一个语句。参数具有和<function>SPI_execute_plan</function>的
   相应参数相同的含义。
  </para>

  <para>
   使用一个游标而不是直接执行该语句有两个好处。首先，可以一次只取出
   一些结果行，避免为返回很多行的查询过度使用内存。其次，一个 portal
   可以比当前查询生存更长时间（事实上，它可以生存到当前事务结束）。
   把 portal 的名称返回给该过程的调用者提供了一种将一个行集合返回为结
   果的方法。
  </para>

  <para>
   被传入的参数数据将被复制到游标的 portal 中，因此在该游标仍然存在时
   可以释放掉被传入的参数数据。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>name</parameter></literal></term>
    <listitem>
     <para>
      portal 的名字，或者设置成<symbol>NULL</symbol>
      让系统选择一个名称
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <para>
      预备语句（由<function>SPI_prepare</function>返回）
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Datum * <parameter>values</parameter></literal></term>
    <listitem>
     <para>
      实际参数值的数组。长度必须等于该语句的参数数量。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
    <listitem>
     <para>
      描述哪些参数是空值的数据。长度必须等于该语句的参数数量。
     </para>

     <para>
      如果<parameter>nulls</parameter>为<symbol>NULL</symbol>，
      那么<function>SPI_cursor_open</function>会假设没有参数
      为空值。否则，如果对应的参数值为非空，
      <parameter>nulls</parameter>
      数组的每一个项都应该是<literal>'&nbsp;'</>；如果对应参数值为空，
      <parameter>nulls</parameter>数组的项应为<literal>'n'</>（在后
      面的情况中，对应的<parameter>values</parameter>项中的值没有
      关系）。注意<parameter>nulls</parameter>不是一个文本字符串，
      它只是一个数组：它不需要一个<literal>'\0'</>终止符。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
     <para><literal>true</>表示只读执行</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>返回值</title>

  <para>
   指向包含该游标的 portal 的指针。注意这里没有错误返回约定，
   任何错误都将通过<function>elog</>报告。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-open-with-args">
 <refmeta>
  <refentrytitle>SPI_cursor_open_with_args</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_cursor_open_with_args</refname>
  <refpurpose>使用一个查询和参数建立一个游标</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_cursor_open_with_args</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
Portal SPI_cursor_open_with_args(const char *<parameter>name</parameter>,
                                 const char *<parameter>command</parameter>,
                                 int <parameter>nargs</parameter>, Oid *<parameter>argtypes</parameter>,
                                 Datum *<parameter>values</parameter>, const char *<parameter>nulls</parameter>,
                                 bool <parameter>read_only</parameter>, int <parameter>cursorOptions</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_cursor_open_with_args</function>建立一个将
   执行指定查询的游标（在内部是一个 portal）。大部分参数具有和
   <function>SPI_prepare_cursor</function>
   和<function>SPI_cursor_open</function>中相应参数相同的含
   义。
  </para>

  <para>
   对于一次性的查询执行，这个函数应该比
   <function>SPI_prepare_cursor</function>加上其后的
   <function>SPI_cursor_open</function>更好。如果相同的命令
   要被用很多不同的参数执行，哪种方法更快就要取决于重做计划的
   代价与定制计划带来的好处之间谁更有利。
  </para>

  <para>
   被传入的参数数据将被复制到游标的 portal 中，因此在该游标仍然存在时
   可以释放掉被传入的参数数据。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>name</parameter></literal></term>
    <listitem>
     <para>
      portal 的名字，或者设置成<symbol>NULL</symbol>
      让系统选择一个名称
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
     <para>
      命令字符串
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>nargs</parameter></literal></term>
    <listitem>
     <para>
      输入参数的数量（<literal>$1</>、<literal>$2</>等等）
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Oid * <parameter>argtypes</parameter></literal></term>
    <listitem>
     <para>
      一个长度为<parameter>nargs</parameter>的数组，它包含参数的
      数据类型的<acronym>OID</acronym>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Datum * <parameter>values</parameter></literal></term>
    <listitem>
     <para>
      一个长度为<parameter>nargs</parameter>的数组，它包含实际的参数值
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
    <listitem>
     <para>
      一个长度为<parameter>nargs</parameter>的数组，它描述哪些参数为空值
     </para>

     <para>
      如果<parameter>nulls</parameter>为<symbol>NULL</symbol>，
      那么<function>SPI_cursor_open_with_args</function>会假设没有参数
      为空值。否则，如果对应的参数值为非空，
      <parameter>nulls</parameter>
      数组的每一个项都应该是<literal>'&nbsp;'</>；如果对应参数值为空，
      <parameter>nulls</parameter>数组的项应为<literal>'n'</>（在后
      面的情况中，对应的<parameter>values</parameter>项中的值没有
      关系）。注意<parameter>nulls</parameter>不是一个文本字符串，
      它只是一个数组：它不需要一个<literal>'\0'</>终止符。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
     <para><literal>true</>表示只读执行</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>cursorOptions</parameter></literal></term>
    <listitem>
     <para>
      游标选项的整数型位掩码，为零会产生默认行为
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>返回值</title>

  <para>
   指向包含该游标的 portal 的指针。注意这里没有错误返回约定，
   任何错误都将通过<function>elog</>报告。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-open-with-paramlist">
 <refmeta>
  <refentrytitle>SPI_cursor_open_with_paramlist</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_cursor_open_with_paramlist</refname>
  <refpurpose>使用参数建立一个游标</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_cursor_open_with_paramlist</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
Portal SPI_cursor_open_with_paramlist(const char *<parameter>name</parameter>,
                                      SPIPlanPtr <parameter>plan</parameter>,
                                      ParamListInfo <parameter>params</parameter>,
                                      bool <parameter>read_only</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_cursor_open_with_paramlist</function>建立一个
   游标（在内部是一个 portal），它将执行一个由
   <function>SPI_prepare</function>准备好的语句。这个函数等效于
   <function>SPI_cursor_open</function>，不过被传递给该查询
   的参数值的信息以不同的方式呈现。<literal>ParamListInfo</>表现形
   式更方便于把这种格式的值向下传递。它也支持通过
   <literal>ParamListInfo</>中指定的钩子函数动态设置参数。
  </para>

  <para> 
  被传入的参数数据将被复制到游标的 portal 中，因此在该游标仍然存在时
   可以释放掉被传入的参数数据。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>name</parameter></literal></term>
    <listitem>
     <para>
      portal 的名字，或者设置成<symbol>NULL</symbol>
      让系统选择一个名称
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <para>
      预备语句（由<function>SPI_prepare</function>返回）
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ParamListInfo <parameter>params</parameter></literal></term>
    <listitem>
     <para>
      包含参数类型和值的数据结构，如果没有就为 NULL
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
     <para><literal>true</>表示只读执行</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>返回值</title>

  <para>
   指向包含该游标的 portal 的指针。注意这里没有错误返回约定，
   任何错误都将通过<function>elog</>报告。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-find">
 <refmeta>
  <refentrytitle>SPI_cursor_find</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_cursor_find</refname>
  <refpurpose>用名称查找一个现有的游标</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_cursor_find</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
Portal SPI_cursor_find(const char * <parameter>name</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_cursor_find</function>用名称查找一个现有的 portal。
   这主要被用于解析由其他某个函数返回的一个油表名称。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>name</parameter></literal></term>
    <listitem>
     <para>
      该 portal 的名称
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>返回值</title>

  <para>
   带有指定名称的 portal 的指针，如果没有找到就是
   <symbol>NULL</symbol>
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-fetch">
 <refmeta>
  <refentrytitle>SPI_cursor_fetch</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_cursor_fetch</refname>
  <refpurpose>从一个游标取出一些行</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_cursor_fetch</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
void SPI_cursor_fetch(Portal <parameter>portal</parameter>, bool <parameter>forward</parameter>, long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_cursor_fetch</function>从一个游标取得一些行。
   这等效于 SQL 命令<command>FETCH</>的一个子集（更多功能
   见<function>SPI_scroll_cursor_fetch</function>）。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>Portal <parameter>portal</parameter></literal></term>
    <listitem>
     <para>
      包含该游标的 portal
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>forward</parameter></literal></term>
    <listitem>
     <para>
      为真表示向前获取，为假表示向后获取
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
     <para>
      要取得的最大行数
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>返回值</title>

  <para>
   成功时，就像在<function>SPI_execute</function>中会设置
   <varname>SPI_processed</varname>和
   <varname>SPI_tuptable</varname>。
  </para>
 </refsect1>

 <refsect1>
  <title>注解</title>

  <para>
   如果该游标的计划不是用<symbol>CURSOR_OPT_SCROLL</symbol>
   选项创建的，向后获取会失败。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-move">
 <refmeta>
  <refentrytitle>SPI_cursor_move</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_cursor_move</refname>
  <refpurpose>移动一个游标</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_cursor_move</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
void SPI_cursor_move(Portal <parameter>portal</parameter>, bool <parameter>forward</parameter>, long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_cursor_move</function>跳过一个游标中的一些行。
   这等效于 SQL 命令<command>MOVE</>的一个子集（更多的功能
   请见<function>SPI_scroll_cursor_move</function>）。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>Portal <parameter>portal</parameter></literal></term>
    <listitem>
     <para>
      包含该游标的 portal
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>forward</parameter></literal></term>
    <listitem>
     <para>
      为真表示前移，为假表示后移
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
     <para>
      要移动的最大行数
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>注解</title>

  <para>
   如果该游标的计划不是用<symbol>CURSOR_OPT_SCROLL</symbol>
   选项创建的，向后移动会失败。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-scroll-cursor-fetch">
 <refmeta>
  <refentrytitle>SPI_scroll_cursor_fetch</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_scroll_cursor_fetch</refname>
  <refpurpose>从一个游标取出一些行</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_scroll_cursor_fetch</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
void SPI_scroll_cursor_fetch(Portal <parameter>portal</parameter>, FetchDirection <parameter>direction</parameter>,
                             long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_scroll_cursor_fetch</function>从一个游标中取出一些行。
   这等效于 SQL 命令<command>FETCH</>。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>Portal <parameter>portal</parameter></literal></term>
    <listitem>
     <para>
      包含该游标的 portal
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FetchDirection <parameter>direction</parameter></literal></term>
    <listitem>
     <para>
      <symbol>FETCH_FORWARD</symbol>、
      <symbol>FETCH_BACKWARD</symbol>、
      <symbol>FETCH_ABSOLUTE</symbol>或者
      <symbol>FETCH_RELATIVE</symbol>之一
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
     <para>
      <symbol>FETCH_FORWARD</symbol>或
      <symbol>FETCH_BACKWARD</symbol>方式中要取出的行数；
      <symbol>FETCH_ABSOLUTE</symbol>方式中要取出的绝对行号；
      <symbol>FETCH_RELATIVE</symbol>方式中要取出的相对行号
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>返回值</title>

  <para>
   成功时，就像在<function>SPI_execute</function>中会设置
   <varname>SPI_processed</varname>和
   <varname>SPI_tuptable</varname>。
  </para>
 </refsect1>

 <refsect1>
  <title>注解</title>

  <para>
   参数<parameter>direction</parameter>和
   <parameter>count</parameter>的详细解释请见
   SQL <xref linkend="sql-fetch">命令。
  </para>

  <para>
   如果该游标的计划不是用<symbol>CURSOR_OPT_SCROLL</symbol>
   选项创建的，除<symbol>FETCH_FORWARD</symbol>之外的方向值会
   失败。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-scroll-cursor-move">
 <refmeta>
  <refentrytitle>SPI_scroll_cursor_move</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_scroll_cursor_move</refname>
  <refpurpose>移动一个游标</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_scroll_cursor_move</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
void SPI_scroll_cursor_move(Portal <parameter>portal</parameter>, FetchDirection <parameter>direction</parameter>,
                            long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_scroll_cursor_move</function>在一个游标中跳过
   一定数量的行。这等效于 SQL 命令<command>MOVE</>。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>Portal <parameter>portal</parameter></literal></term>
    <listitem>
     <para>
      包含该游标的 portal
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FetchDirection <parameter>direction</parameter></literal></term>
    <listitem>
     <para>
      <symbol>FETCH_FORWARD</symbol>、
      <symbol>FETCH_BACKWARD</symbol>、
      <symbol>FETCH_ABSOLUTE</symbol>或者
      <symbol>FETCH_RELATIVE</symbol>之一
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
     <para>
      <symbol>FETCH_FORWARD</symbol>或者
      <symbol>FETCH_BACKWARD</symbol>方式中要移动的行数；
      <symbol>FETCH_ABSOLUTE</symbol>方式中要移动到的绝对行号；
      <symbol>FETCH_RELATIVE</symbol>方式中要移动到的相对行号
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>返回值</title>

  <para>
   成功时，就像在<function>SPI_execute</function>中会设置
   <varname>SPI_processed</varname>。
   <varname>SPI_tuptable</varname>被设置为<symbol>NULL</>，
   因为这个函数不需要返回行。
  </para>
 </refsect1>

 <refsect1>
  <title>注解</title>

  <para>
   参数<parameter>direction</parameter>和
   <parameter>count</parameter>的详细解释请见
   SQL <xref linkend="sql-fetch">命令。
  </para>

  <para>
   如果该游标的计划不是用<symbol>CURSOR_OPT_SCROLL</symbol>
   选项创建的，除<symbol>FETCH_FORWARD</symbol>之外的方向值会
   失败。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-close">
 <refmeta>
  <refentrytitle>SPI_cursor_close</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_cursor_close</refname>
  <refpurpose>关闭一个游标</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_cursor_close</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
void SPI_cursor_close(Portal <parameter>portal</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_cursor_close</function>关闭一个之前创建的游标
   并且释放它的 portal 存储。
  </para>

  <para>
   所有打开的游标会在事务结束时自动被关闭。
   只有在希望尽快释放资源时，才需要调用
   <function>SPI_cursor_close</function>。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>Portal <parameter>portal</parameter></literal></term>
    <listitem>
     <para>
      包含该游标的 portal
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-keepplan">
 <refmeta>
  <refentrytitle>SPI_keepplan</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_keepplan</refname>
  <refpurpose>保存一个预备语句</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_keepplan</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
int SPI_keepplan(SPIPlanPtr <parameter>plan</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_keepplan</function>保存一个被传入的语句（由
   <function>SPI_prepare</function>准备好），这样它将不会被
   <function>SPI_finish</function>或者事务管理器释放。这让你能够
   在当前会话的后续调用中重用预备语句。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <para>
      要保存的预备语句
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>返回值</title>

  <para>
   成功返回 0；如果<parameter>plan</parameter>为<symbol>NULL</symbol>
   或者无效则返回<symbol>SPI_ERROR_ARGUMENT</symbol>
  </para>
 </refsect1>

 <refsect1>
  <title>注解</title>

  <para>
   这个函数通过指针调整的方法（不需要数据复制）将被传入的语句重定位
   到永久存储中。如果你后来需要删除它，可以对它使用
   <function>SPI_freeplan</function>。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-saveplan">
 <refmeta>
  <refentrytitle>SPI_saveplan</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_saveplan</refname>
  <refpurpose>保存一个预备语句</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_saveplan</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
SPIPlanPtr SPI_saveplan(SPIPlanPtr <parameter>plan</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_saveplan</function>把一个被传入的语句（由
   <function>SPI_prepare</function>准备好）复制到不会被
   <function>SPI_finish</function>或者事务管理器释放的内存中。
   这让你能够在当前会话的后续调用中重用预备语句。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <para>
      要保存的预备语句
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>返回值</title>

  <para>
   要被复制的语句的指针；如果没有成功则返回<symbol>NULL</symbol>。
   错误时，<varname>SPI_result</varname>会被这样设置：

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
       如果<parameter>plan</parameter>为<symbol>NULL</symbol>或无效
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
     <listitem>
      <para>
       如果从一个未连接的过程调用
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>

 <refsect1>
  <title>注解</title>

  <para>
   原始的被传入的语句不会被释放，因此你可能希望在其上执行
   <function>SPI_freeplan</function>以避免在
   <function>SPI_finish</>之前发生内存泄露。
  </para>

  <para>
   在大部分情况下，<function>SPI_keepplan</function>更适合于
   执行这种功能，因为它极大程度上达到了同样的结果而无需物理地
   复制该预备语句的数据结构。
  </para>
 </refsect1>
</refentry>

</sect1>

<sect1 id="spi-interface-support">
 <title>接口支持函数</title>

 <para>
  这里描述的函数提供了一个接口从<function>SPI_execute</>
  及其他 SPI 函数返回的结果集中抽取信息。
 </para>

 <para>
  这一小节中描述的所有函数都可以被用在已连接和未连接的过程中。
 </para>

<!-- *********************************************** -->

<refentry id="spi-spi-fname">
 <refmeta>
  <refentrytitle>SPI_fname</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_fname</refname>
  <refpurpose>为指定的列号确定列名</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_fname</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
char * SPI_fname(TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_fname</function>返回一个指定列的列名的拷贝（
   当你不再需要该列名拷贝后，可以使用<function>pfree</function>
   释放它）。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
     <para>
      输入行描述
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>colnumber</parameter></literal></term>
    <listitem>
     <para>
      列号（从 1 开始计）
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>返回值</title>

  <para>
   列名；如果<parameter>colnumber</parameter>超出范围则返回
   <symbol>NULL</symbol>。出错时
   <varname>SPI_result</varname>会被设置成
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol>。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-fnumber">
 <refmeta>
  <refentrytitle>SPI_fnumber</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_fnumber</refname>
  <refpurpose>为一个指定的列名确定列号</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_fnumber</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
int SPI_fnumber(TupleDesc <parameter>rowdesc</parameter>, const char * <parameter>colname</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_fnumber</function>返回指定列名的列号。
  </para>

  <para>
   如果<parameter>colname</parameter>引用的是一个系统列（例如，
   <literal>oid</>），那么将返回对应的负值列号。调用者应该小心地测试
   返回值是不是正好为<symbol>SPI_ERROR_NOATTRIBUTE</symbol>
   来检测错误；除非系统列应该被拒绝，测试结果是否小于或者等于零这种
   方式是不正确的。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
     <para>
      输入行描述
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>colname</parameter></literal></term>
    <listitem>
     <para>
      列名
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>返回值</title>

  <para>
   列号（从 1 开始计），如果没有找到所提到的列名则返回
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol>。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-getvalue">
 <refmeta>
  <refentrytitle>SPI_getvalue</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_getvalue</refname>
  <refpurpose>返回指定列的字符串值</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_getvalue</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
char * SPI_getvalue(HeapTuple <parameter>row</parameter>, TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_getvalue</function>返回指定列的值的字符串表示。
  </para>

  <para>
   结果在使用<function>palloc</function>分配的内存中返回（当你不再
   需要该结果时，你可以使用<function>pfree</function>释放该内存）。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
     <para>
      要检查的输入行
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
     <para>
      输入行描述
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>colnumber</parameter></literal></term>
    <listitem>
     <para>
      列号（从 1 开始计）
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>返回值</title>

  <para>
   列值，如果列为空值、<parameter>colnumber</parameter>超出范围
   （<varname>SPI_result</varname>被设置为
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol>）或者没有输出函数
   可用（<varname>SPI_result</varname>被设置为
   <symbol>SPI_ERROR_NOOUTFUNC</symbol>）则返回
   <symbol>NULL</symbol>。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-getbinval">
 <refmeta>
  <refentrytitle>SPI_getbinval</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_getbinval</refname>
  <refpurpose>返回指定列的二进制值</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_getbinval</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
Datum SPI_getbinval(HeapTuple <parameter>row</parameter>, TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>,
                    bool * <parameter>isnull</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_getbinval</function>以内部格
   式（以<type>Datum</type>类型）返回指定列的值。
  </para>

  <para>
   这个函数不会为该 datum 分配新空间。在传引用数据类型的情况下，
   返回值将是一个被传递行的指针。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
     <para>
      要检查的输入行
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
     <para>
      输入行描述
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>colnumber</parameter></literal></term>
    <listitem>
     <para>
      列号（从 1 开始计）
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool * <parameter>isnull</parameter></literal></term>
    <listitem>
     <para>
      列中是否为空值的标志
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>返回值</title>

  <para>
   该列的二进制值会被返回。如果该列为空值，由<parameter>isnull</parameter>
   指向的变量将被设置为真，否则会被设置为假。
  </para>

  <para>
   错误时<varname>SPI_result</varname>会被设置成
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol>。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-gettype">
 <refmeta>
  <refentrytitle>SPI_gettype</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_gettype</refname>
  <refpurpose>返回指定列的数据类型名称</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_gettype</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
char * SPI_gettype(TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_gettype</function>返回该指定列的数据类型名称
   的拷贝（当你不再需要该拷贝后，可以使用<function>pfree</function>
   释放它）。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
     <para>
      输入行描述
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>colnumber</parameter></literal></term>
    <listitem>
     <para>
      列号（从 1 开始计）
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>返回值</title>

  <para>
   指定列的数据类型名称，或者在错误时返回<symbol>NULL</symbol>。
   错误时<varname>SPI_result</varname>会被设置成
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol>。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-gettypeid">
 <refmeta>
  <refentrytitle>SPI_gettypeid</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_gettypeid</refname>
  <refpurpose>返回指定列的数据类型的<acronym>OID</acronym></refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_gettypeid</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
Oid SPI_gettypeid(TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_gettypeid</function>返回该指定列的数据类型的
   <acronym>OID</acronym>。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
     <para>
      输入行描述
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>colnumber</parameter></literal></term>
    <listitem>
     <para>
      列号（从 1 开始计）
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>返回值</title>

  <para>
   指定列的数据类型的<acronym>OID</acronym>，或者出错时返回
   <symbol>InvalidOid</symbol>。出错时，
   <varname>SPI_result</varname>会被设置成
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol>。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-getrelname">
 <refmeta>
  <refentrytitle>SPI_getrelname</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_getrelname</refname>
  <refpurpose>返回指定关系的名称</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_getrelname</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
char * SPI_getrelname(Relation <parameter>rel</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_getrelname</function>返回该指定关系的名称
   的拷贝（当你不再需要该拷贝后，可以使用<function>pfree</function>
   释放它）。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>Relation <parameter>rel</parameter></literal></term>
    <listitem>
     <para>
      输入关系
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>返回值</title>

  <para>
   指定关系的名称。
  </para>
 </refsect1>
</refentry>

<refentry id="spi-spi-getnspname">
 <refmeta>
  <refentrytitle>SPI_getnspname</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_getnspname</refname>
  <refpurpose>返回指定关系的名字空间</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_getnspname</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
char * SPI_getnspname(Relation <parameter>rel</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_getnspname</function>返回指定
   <structname>关系</structname>所属的名字空间的名称拷贝。这等效
   于该关系的模式。当你用完这个函数的返回值后，应该调用
   <function>pfree</function>释放它。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>Relation <parameter>rel</parameter></literal></term>
    <listitem>
     <para>
      输入关系
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>返回值</title>

  <para>
   指定关系的名字空间的名称。
  </para>
 </refsect1>
</refentry>

 </sect1>

 <sect1 id="spi-memory">
  <title>内存管理</title>

  <para>
    <indexterm>
     <primary>memory context</primary>
     <secondary>in SPI</secondary>
    </indexterm>
   <productname>PostgreSQL</productname>
   在<firstterm>内存上下文</firstterm>中分配内存，内存上下文为管理
   在多个不同位置、具有不同生存时间需要的分配提供了一种便捷的方法。
   销毁一个上下文会释放所有在其中分配的内存。因此不必跟踪单个对象来
   避免内存泄露，而是只需要管理数量相对较少的上下文即可。
   <function>palloc</function>和相关的函数可以从<quote>当前</>
   上下文中分配内存。
  </para>

  <para>
   <function>SPI_connect</function>创建一个新的内存上下文并且让它
   成为当前上下文。<function>SPI_finish</function>恢复之前的当前上下
   文并且销毁由<function>SPI_connect</function>创建的内存上下文。
   这些动作确保在你的过程中的内存分配在过程退出时被回收，从而避免内存
   泄露。
  </para>

  <para>
   不过，如果你的过程需要返回一个在已分配内存中的对象（例如一个
   传引用数据类型的值），你不能使用<function>palloc</function>
   分配内存，或者说至少不能在连接到 SPI 时这样做。如果你试着这样
   做，该对象会被<function>SPI_finish</function>接触分配，那么
   你的过程将无法可靠地工作。要解决这个问题，应使用
   <function>SPI_palloc</function>来为要返回的对象分配内存。
   <function>SPI_palloc</function>会在
   <quote>上层执行器上下文</quote>中分配内存，也就是当
   <function>SPI_connect</function>被调用时的当前内存上下文，
   它才是从你的过程中返回的值最适合的上下文。
  </para>

  <para>
   如果在过程还没有连接到 SPI 时调用<function>SPI_palloc</function>，
   那么它的效用就和普通的<function>palloc</function>相同。在一个
   过程连接到 SPI 管理器之前，当前的内存上下文就是上层的执行器上下
   文，所以所有由该过程通过<function>palloc</function>或者 SPI 
   功能函数分配的内存都在这个上下文中。
  </para>

  <para>
   当<function>SPI_connect</function>被调用时，这个过程的私有
   上下文（由<function>SPI_connect</function>）会被作为当前上
   下文。所有用<function>palloc</function>、
   <function>repalloc</function>或者 SPI 功能函数（除了
   <function>SPI_copytuple</function>、
   <function>SPI_returntuple</function>、
   <function>SPI_modifytuple</function>和
   <function>SPI_palloc</function>）分配的内存都在这个上下文中。
   当一个过程从 SPI 管理器断开连接时（通过
   <function>SPI_finish</function>），当前上下文被恢复到上层的
   执行器上下文，并且在该过程的内存上下文中分配的内存都会被释放，
   之后再不能被使用。
  </para>

  <para>
   这一节中描述的所有函数都可以在已连接和未连接的过程中使用。在
   一个未连接的过程中，它们的行为和底层的普通服务器函数（
   <function>palloc</>等）相同。
  </para>

<!-- *********************************************** -->

<refentry id="spi-spi-palloc">
 <refmeta>
  <refentrytitle>SPI_palloc</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_palloc</refname>
  <refpurpose>在上层执行器上下文中分配内存</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_palloc</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
void * SPI_palloc(Size <parameter>size</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_palloc</function>在上层的执行器上下文中分配内存。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>Size <parameter>size</parameter></literal></term>
    <listitem>
     <para>
      要分配的存储空间大小（以字节计）
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>返回值</title>

  <para>
   指向具有指定大小的新存储空间的指针
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-realloc">
 <refmeta>
  <refentrytitle>SPI_repalloc</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_repalloc</refname>
  <refpurpose>在上层执行器上下文中重分配内存</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_repalloc</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
void * SPI_repalloc(void * <parameter>pointer</parameter>, Size <parameter>size</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_repalloc</function>改变之前用<function>SPI_palloc</function>
   分配的内存段的大小。
  </para>

  <para>
   这个函数不再和普通的<function>repalloc</function>相区别。
   保留它只是为了对现有代码保持向后兼容。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>void * <parameter>pointer</parameter></literal></term>
    <listitem>
     <para>
      指向要改变的现有存储空间的指针
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Size <parameter>size</parameter></literal></term>
    <listitem>
     <para>
      要分配的存储空间大小（以字节计）
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>返回值</title>

  <para>
   指向具有指定大小的新存储空间的指针，现有区域的内容会被复制到其中
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-pfree">
 <refmeta>
  <refentrytitle>SPI_pfree</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_pfree</refname>
  <refpurpose>在上层执行器上下文中释放内存</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_pfree</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
void SPI_pfree(void * <parameter>pointer</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_pfree</function>释放之前使用
   <function>SPI_palloc</function>或者
   <function>SPI_repalloc</function>分配的内存。
  </para>

  <para>
   这个函数不再和普通的<function>pfree</function>相区别。
   保留它只是为了对现有代码保持向后兼容。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>void * <parameter>pointer</parameter></literal></term>
    <listitem>
     <para>
      指向要释放的现有存储空间的指针
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-copytuple">
 <refmeta>
  <refentrytitle>SPI_copytuple</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_copytuple</refname>
  <refpurpose>在上层执行器上下文中创建一行的拷贝</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_copytuple</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
HeapTuple SPI_copytuple(HeapTuple <parameter>row</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_copytuple</function>在上层执行器上下文中为一行创建
   一份拷贝。这通常被用来从一个触发器中返回一个被修改的行。在一个被声
   明为返回组合类型的函数中，应使用
   <function>SPI_returntuple</function>。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
     <para>
      要拷贝的行
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>返回值</title>

  <para>
   被拷贝的行，只有在<parameter>tuple</parameter>为
   <symbol>NULL</symbol>时才返回<symbol>NULL</symbol>。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-returntuple">
 <refmeta>
  <refentrytitle>SPI_returntuple</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_returntuple</refname>
  <refpurpose>准备把一个元组返回为一个 Datum</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_returntuple</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
HeapTupleHeader SPI_returntuple(HeapTuple <parameter>row</parameter>, TupleDesc <parameter>rowdesc</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_returntuple</function>为一个行在上层执行器上下文中
   创建一个拷贝，把它以一种行类型<type>Datum</type>的形式返回。被
   返回的指针只需要在返回前通过<function>PointerGetDatum</function>
   被转换成<type>Datum</type>。
  </para>

  <para>
   注意这应该被用于声明为要返回组合类型的函数。它不能用于触发器，在
   触发器中应使用<function>SPI_copytuple</>来返回一个被修改的行。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
     <para>
      要被拷贝的行
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
     <para>
      行的描述符（对大部分有效的缓存，每次都传递相同的描述符）
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>返回值</title>

  <para>
   <type>HeapTupleHeader</type>指向拷贝好的行；只有在
   <parameter>row</parameter>或者
   <parameter>rowdesc</parameter> 为<symbol>NULL</symbol>
   时才返回
   <symbol>NULL</symbol>
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-modifytuple">
 <refmeta>
  <refentrytitle>SPI_modifytuple</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_modifytuple</refname>
  <refpurpose>通过替换一个给定行的选定域来创建一行</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_modifytuple</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
HeapTuple SPI_modifytuple(Relation <parameter>rel</parameter>, HeapTuple <parameter>row</parameter>, int <parameter>ncols</parameter>,
                          int * <parameter>colnum</parameter>, Datum * <parameter>values</parameter>, const char * <parameter>nulls</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_modifytuple</function>创建一个新行，其中选定的列
   用新值替代，其他列则从输入行中拷贝。输入行本身不被修改。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>Relation <parameter>rel</parameter></literal></term>
    <listitem>
     <para>
      只被用作该行的行描述符的来源（传递一个关系而不是
      一个行描述符是一种令人头痛的设计）。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
     <para>
      要被修改的行
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>ncols</parameter></literal></term>
    <listitem>
     <para>
      要被修改的列数
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int * <parameter>colnum</parameter></literal></term>
    <listitem>
     <para>
      一个长度为<parameter>ncols</parameter>的数组，包含了要被修改的列号
      （列号从 1 开始）
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Datum * <parameter>values</parameter></literal></term>
    <listitem>
     <para>
      一个长度为<parameter>ncols</parameter>的数组，包含了指定列的新值
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
    <listitem>
     <para>
      一个长度为<parameter>ncols</parameter>的数组，描述哪些新值为空值
     </para>

     <para>
      如果<parameter>nulls</parameter>为<symbol>NULL</symbol>，那么
      <function>SPI_modifytuple</function>假定没有新值为空值。否则，
      如果对应的新值为非空，<parameter>nulls</parameter>数组的每一项都应
      该是<literal>'&nbsp;'</>，而如果对应的新值为空值则为<literal>'n'</>（在
      后一种情况中，对应的<parameter>values</parameter>项中的新值无关紧
      要）。注意<parameter>nulls</parameter>不是一个文本字符串，只是一个
      数组：它不需要一个<literal>'\0'</>终止符。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>返回值</title>

  <para>
   应用了修改的新行，在上层执行器上下文中分配，只有当
   <parameter>row</parameter>为<symbol>NULL</symbol>时才返回
   <symbol>NULL</symbol>
  </para>

  <para>
   出错时，<varname>SPI_result</varname>被设置如下：
   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
       如果<parameter>rel</>为<symbol>NULL</>，或者
       <parameter>row</>为<symbol>NULL</>，或者<parameter>ncols</>
       小于等于 0，或者<parameter>colnum</>为<symbol>NULL</>，
       或者<parameter>values</>为<symbol>NULL</>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_NOATTRIBUTE</symbol></term>
     <listitem>
      <para>
       如果<parameter>colnum</>包含一个无效的列号（小于等于 0 或者大于
       <parameter>row</>中的列数）。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-freetuple">
 <refmeta>
  <refentrytitle>SPI_freetuple</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_freetuple</refname>
  <refpurpose>释放一个在上层执行器上下文中分配的行</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_freetuple</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
void SPI_freetuple(HeapTuple <parameter>row</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_freetuple</function>释放之前在上层执行器上下文中
   分配的一个行。
  </para>

  <para>
   这个函数不再和普通的<function>heap_freetuple</function>相区别。
   保留它只是为了对现有代码保持向后兼容。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
     <para>
      要释放的行
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-freetupletable">
 <refmeta>
  <refentrytitle>SPI_freetuptable</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_freetuptable</refname>
  <refpurpose>释放一个由<function>SPI_execute</>
  或者类似函数创建的行集合</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_freetuptable</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
void SPI_freetuptable(SPITupleTable * <parameter>tuptable</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_freetuptable</function>释放一个由之前的 SPI 命令
   执行函数（例如<function>SPI_execute</>）创建的行集合。因此，
   调用这个函数时，常常使用<varname>SPI_tuptable</varname>作为
   参数。
  </para>

  <para>
   如果一个 SPI 过程需要执行多个命令并且不想保留早期命令的结果，这个
   函数就有用了。注意，<function>SPI_finish</>会释放任何还未释放的
   行集合。还有，如果在一个 SPI 过程的执行中开始了一个子事务并且后来
   被中止，SPI 会自动释放该子事务运行期间创建的任何行集合。
  </para>

  <para>
   从<productname>PostgreSQL</> 9.3 开始，
   <function>SPI_freetuptable</function>包含了保护逻辑以避免对于同
   一行集的重复删除请求。在以前的发布中，重复的删除将会导致崩溃。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>SPITupleTable * <parameter>tuptable</parameter></literal></term>
    <listitem>
     <para>
      要释放的行集的指针，NULL 表示什么也不做
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-freeplan">
 <refmeta>
  <refentrytitle>SPI_freeplan</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_freeplan</refname>
  <refpurpose>释放一个之前保存的预备语句</refpurpose>
 </refnamediv>

 <indexterm><primary>SPI_freeplan</primary></indexterm>

 <refsynopsisdiv>
<synopsis>
int SPI_freeplan(SPIPlanPtr <parameter>plan</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <function>SPI_freeplan</function>释放一个之前由
   <function>SPI_prepare</function>返回的或者由
   <function>SPI_keepplan</function>、<function>SPI_saveplan</function>
   保存的预备语句。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <para>
      要释放的语句的指针
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>返回值</title>

  <para>
   成功返回 0；如果<parameter>plan</parameter>为
   <symbol>NULL</symbol>或无效则返回
   <symbol>SPI_ERROR_ARGUMENT</symbol>
  </para>
 </refsect1>
</refentry>

 </sect1>

 <sect1 id="spi-visibility">
  <title>数据改变的可见性</title>

  <para>
   下列规则主导了使用 SPI 的函数（或者任何其他 C 函数）中数据改变
   的可见性：

   <itemizedlist>
    <listitem>
     <para>
      在一个 SQL 命令的执行期间，该命令所作的任何数据更改对该命令本身
      是不可见的。例如，在
<programlisting>
INSERT INTO a SELECT * FROM a;
</programlisting>
      中，被插入的行对<command>SELECT</command>部分不可见。
     </para>
    </listitem>

    <listitem>
     <para>
      一个命令 C 所作的更改对所有在 C 之后开始的命令可见，不管它们是否
      在 C 之中（在 C 的执行期间）开始还是在 C 完成之后开始。
     </para>
    </listitem>

    <listitem>
     <para>
      在一个 SQL 命令（或者一个普通函数或者触发器）调用的函数内通过
      SPI 执行的命令遵循以上哪条规则取决于传递给 SPI 的读/写标志。以
      只读模式执行的命令遵循第一条规则：它们不能看到调用它们的命令的
      改变。在读写模式中执行的命令遵循第二条规则：它们能看见目前为止
      所有的改变。
     </para>
    </listitem>

    <listitem>
     <para>
      所有的标准过程语言会基于函数的易变性属性设置 SPI 读写模式。
      <literal>STABLE</>和<literal>IMMUTABLE</>函数的命令会以
      只读模式完成，而<literal>VOLATILE</>函数的命令会以读写模式
      完成。虽然 C 函数的作者可以违反这种习惯，但是最好不要那样做。
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   下一节包含一个关于这些规则应用的例子：
  </para>
 </sect1>

 <sect1 id="spi-examples">
  <title>例子</title>

  <para>
   这一节包含了 SPI 用法的一个非常简单的例子。过程
   <function>execq</function>用一个 SQL 命令作为其第一个参数
   并且用一个行计数作为第二个参数，使用
   <function>SPI_exec</function>执行该命令并且返回被该该命令
   处理过的行的数量。你可以在源代码树的
   <filename>src/test/regress/regress.c</filename>和
   <xref linkend="contrib-spi">模块中找到 SPI 的更复杂的例子。
  </para>

<programlisting>
#include "postgres.h"

#include "executor/spi.h"
#include "utils/builtins.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

int execq(text *sql, int cnt);

int
execq(text *sql, int cnt)
{
    char *command;
    int ret;
    int proc;

    /* 把给定的文本对象转换成一个 C 字符串 */
    command = text_to_cstring(sql);

    SPI_connect();

    ret = SPI_exec(command, cnt);

    proc = SPI_processed;
    /*
     * 如果取出了一些行，通过 elog(INFO) 打印它们。
     */
    if (ret &gt; 0 &amp;&amp; SPI_tuptable != NULL)
    {
        TupleDesc tupdesc = SPI_tuptable-&gt;tupdesc;
        SPITupleTable *tuptable = SPI_tuptable;
        char buf[8192];
        int i, j;

        for (j = 0; j &lt; proc; j++)
        {
            HeapTuple tuple = tuptable-&gt;vals[j];

            for (i = 1, buf[0] = 0; i &lt;= tupdesc-&gt;natts; i++)
                snprintf(buf + strlen (buf), sizeof(buf) - strlen(buf), " %s%s",
                        SPI_getvalue(tuple, tupdesc, i),
                        (i == tupdesc-&gt;natts) ? " " : " |");
            elog(INFO, "EXECQ: %s", buf);
        }
    }

    SPI_finish();
    pfree(command);

    return (proc);
}
</programlisting>

  <para>
   （为了便于理解，这个函数使用了调用习惯版本 0。在实际的应用中，
   你应该使用新的版本 1 接口）。
  </para>

  <para>
   在把该函数编译到一个共享库中（详见<xref linkend="dfunc">）之
   后，这样声明该函数：

<programlisting>
CREATE FUNCTION execq(text, integer) RETURNS integer
    AS '<replaceable>filename</replaceable>'
    LANGUAGE C;
</programlisting>
  </para>

  <para>
   下面是一个会话实例：

<programlisting>
=&gt; SELECT execq('CREATE TABLE a (x integer)', 0);
 execq
-------
     0
(1 row)

=&gt; INSERT INTO a VALUES (execq('INSERT INTO a VALUES (0)', 0));
INSERT 0 1
=&gt; SELECT execq('SELECT * FROM a', 0);
INFO:  EXECQ:  0    -- inserted by execq
INFO:  EXECQ:  1    -- returned by execq and inserted by upper INSERT

 execq
-------
     2
(1 row)

=&gt; SELECT execq('INSERT INTO a SELECT x + 2 FROM a', 1);
 execq
-------
     1
(1 row)

=&gt; SELECT execq('SELECT * FROM a', 10);
INFO:  EXECQ:  0
INFO:  EXECQ:  1
INFO:  EXECQ:  2    -- 0 + 2，按照所指定的，只有一行被插入

 execq
-------
     3              -- 10 只是最大值，3 是实际的行数
(1 row)

=&gt; DELETE FROM a;
DELETE 3
=&gt; INSERT INTO a VALUES (execq('SELECT * FROM a', 0) + 1);
INSERT 0 1
=&gt; SELECT * FROM a;
 x
---
 1                  -- 没有行在 a (0) + 1
(1 row)

=&gt; INSERT INTO a VALUES (execq('SELECT * FROM a', 0) + 1);
INFO:  EXECQ:  1
INSERT 0 1
=&gt; SELECT * FROM a;
 x
---
 1
 2                  -- 有一行在 in a + 1
(2 rows)

-- 这证明了数据改变可见性规则：

=&gt; INSERT INTO a SELECT execq('SELECT * FROM a', 0) * x FROM a;
INFO:  EXECQ:  1
INFO:  EXECQ:  2
INFO:  EXECQ:  1
INFO:  EXECQ:  2
INFO:  EXECQ:  2
INSERT 0 2
=&gt; SELECT * FROM a;
 x
---
 1
 2
 2                  -- 2 行 * 1 （第一行中的 x）
 6                  -- 3 rows (2 + 1 被插入) * 2 （第二行中的 x）
(4 rows)               ^^^^^^
                       不同调用中 execq() 的行可见性
</programlisting>
  </para>
 </sect1>
</chapter>
