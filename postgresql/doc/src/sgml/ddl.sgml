<!-- doc/src/sgml/ddl.sgml -->

<chapter id="ddl">
 <title>数据定义</title>

 <para>
  本章包含了如何创建用来保存数据的数据库结构。在一个关系型数据库中，原始数据被存储在表中，因此本章的主要工作就是解释如何创建和修改表，以及哪些特性可以控制何种数据会被存储在表中。接着，我们讨论表如何被组织成模式，以及如何将权限分配给表。最后，我们将将简短地介绍其他一些影响数据存储的特性，例如继承、视图、函数和触发器。
 </para>

 <sect1 id="ddl-basics">
  <title>表基础</title>

  <indexterm zone="ddl-basics">
   <primary>table</primary>
  </indexterm>

  <indexterm>
   <primary>row</primary>
  </indexterm>

  <indexterm>
   <primary>column</primary>
  </indexterm>

  <para>
   关系型数据库中的一个表非常像纸上的一张表：它由行和列组成。列的数量和顺序是固定的，并且每一列拥有一个名字。行的数目是变化的，它反映了在一个给定时刻表中存储的数据量。SQL并不保证表中行的顺序。当一个表被读取时，表中的行将以非特定顺序出现，除非明确地指定需要排序。这些将在<xref linkend="queries">介绍。此外，SQL不会为行分配唯一的标识符，因此在一个表中可能会存在一些完全相同的行。这是SQL之下的数学模型导致的结果，但并不是所期望的。稍后在本章中我们将看到如何处理这种问题。
  </para>

  <para>
   每一列都有一个数据类型。数据类型约束着一组可以分配给列的可能值，并且它为列中存储的数据赋予了语义，这样它可以用于计算。例如，一个被声明为数字类型的列将不会接受任何文本串，而存储在这样一列中的数据可以用来进行数学计算。反过来，一个被声明为字符串类型的列将接受几乎任何一种的数据，它可以进行如字符串连接的操作但不允许进行数学计算。
  </para>

  <para>
   <productname>PostgreSQL</productname>包括了相当多的内建数据类型，可以适用于很多应用。用户也可以定义他们自己的数据类型。大部分内建数据类型有着显而易见的名称和语义，所以我们将它们的详细解释放在<xref linkend="datatype">中。一些常用的数据类型是：用于整数的<type>integer</type>；可以用于分数的<type>numeric</type>；用于字符串的<type>text</type>，用于日期的<type>date</type>，用于一天内时间的<type>time</type>以及可以同时包含日期和时间的<type>timestamp</type>。
  </para>

  <indexterm>
   <primary>table</primary>
   <secondary>creating</secondary>
  </indexterm>

  <para>
   要创建一个表，我们要用到<xref linkend="sql-createtable">命令。在这个命令中 我们需要为新表至少指定一个名字、列的名字及数据类型。例如：
<programlisting>
CREATE TABLE my_first_table (
    first_column text,
    second_column integer
);
</programlisting>
   这将创建一个名为<literal>my_first_table</literal>的表，它拥有两个列。第一个列名为<literal>first_column</literal>且数据类型为<type>text</type>；第二个列名为<literal>second_column</literal>且数据类型为<type>integer</type>。表和列的名字遵循<xref linkend="sql-syntax-identifiers">中解释的标识符语法。类型名称通常也是标识符，但是也有些例外。注意列的列表由逗号分隔并被圆括号包围。
  </para>

  <para>
   当然，前面的例子是非常不自然的。通常，我们为表和列赋予的名称都会表明它们存储着什么类别的数据。因此让我们再看一个更现实的例子：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric
);
</programlisting>
   （<type>numeric</type>类型能够存储小数部分，典型的例子是金额。）
  </para>

  <tip>
   <para>
    当我们创建很多相关的表时，最好为表和列选择一致的命名模式。例如，一种选择是用单数或复数名词作为表名，每一种都受到一些理论家支持。
   </para>
  </tip>

  <para>
   一个表能够拥有的列的数据是有限的，根据列的类型，这个限制介于250和1600之间。但是，极少会定义一个接近这个限制的表，即便有也是一个值的商榷的设计。
  </para>

  <indexterm>
   <primary>table</primary>
   <secondary>removing</secondary>
  </indexterm>

  <para>
   如果我们不再需要一个表，我们可以通过使用<xref
   linkend="sql-droptable">命令来移除它。例如：
<programlisting>
DROP TABLE my_first_table;
DROP TABLE products;
</programlisting>
   尝试移除一个不存在的表会引起错误。然而，在SQL脚本中在创建每个表之前无条件地尝试移除它的做法是很常见的，即使发生错误也会忽略之，因此这样的脚本可以在表存在和不存在时都工作得很好（如果你喜欢，可以使用<literal>DROP TABLE IF EXISTS</>变体来防止出现错误消息，但这并非标准SQL）。
  </para>

  <para>
   如果我们需要修改一个已经存在的表，请参考本章稍后的<xref
   linkend="ddl-alter">。
  </para>

  <para>
   利用到目前为止所讨论的工具，我们可以创建一个全功能的表。本章的后续部分将集中于为表定义增加特性来保证数据完整性、安全性或方便。如果你希望现在就去填充你的表，你可以跳过这些直接去<xref linkend="dml">。
  </para>
 </sect1>

 <sect1 id="ddl-default">
  <title>默认值</title>

  <indexterm zone="ddl-default">
   <primary>default value</primary>
  </indexterm>

  <para>
   一个列可以被分配一个默认值。当一个新行被创建且没有为某些列指定值时，这些列将会被它们相应的默认值填充。一个数据操纵命令也可以显式地要求一个列被置为它的默认值，而不需要知道这个值到底是什么（数据操纵命令详见<xref linkend="dml">）。
  </para>

  <para>
   <indexterm><primary>null value</primary><secondary>default value</secondary></indexterm>
   如果没有显式指定默认值，则默认值是空值。这是合理的，因为空值表示未知数据。
  </para>

  <para>
   在一个表定义中，默认值被列在列的数据类型之后。例如：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric <emphasis>DEFAULT 9.99</emphasis>
);
</programlisting>
  </para>

  <para>
   默认值可以是一个表达式，它将在任何需要插入默认值的时候被实时计算（<emphasis>不</emphasis>是表创建时）。一个常见的例子是为一个<type>timestamp</type>列指定默认值为<literal>CURRENT_TIMESTAMP</>，这样它将得到行被插入时的时间。另一个常见的例子是为每一行生成一个<quote>序列号</> 。这在<productname>PostgreSQL</productname>可以按照如下方式实现：
<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>DEFAULT nextval('products_product_no_seq')</emphasis>,
    ...
);
</programlisting>
   这里<literal>nextval()</>函数从一个<firstterm>序列对象</firstterm><xref linkend="functions-sequence">）。还有一种特别的速写：
<programlisting>
CREATE TABLE products (
    product_no <emphasis>SERIAL</emphasis>,
    ...
);
</programlisting>
   <literal>SERIAL</>速写将在<xref
   linkend="datatype-serial">进一步讨论。
  </para>
 </sect1>

 <sect1 id="ddl-constraints">
  <title>约束</title>

  <indexterm zone="ddl-constraints">
   <primary>constraint</primary>
  </indexterm>

  <para>
   数据类型是一种限制能够存储在表中数据类别的方法。但是对于很多应用来说，它们提供的约束太粗糙。例如，一个包含产品价格的列应该只接受正值。但是没有任何一种标准数据类型只接受正值。另一个问题是我们可能需要根据其他列或行来约束一个列中的数据。例如，在一个包含产品信息的表中，对于每个产品编号应该只有一行。
  </para>

  <para>
   到目前为止，SQL允许我们在列和表上定义约束。约束让我们能够根据我们的愿望来控制表中的数据。如果一个用户试图在一个列中保存违反一个约束的数据，一个错误会被抛出。即便是这个值来自于默认值定义，这个规则也同样适用。
  </para>

  <sect2 id="ddl-constraints-check-constraints">
   <title>检查约束</title>

   <indexterm>
    <primary>check constraint</primary>
   </indexterm>

   <indexterm>
    <primary>constraint</primary>
    <secondary>check</secondary>
   </indexterm>

   <para>
    一个检查约束是最普通的约束类型。它允许我们指定一个特定列中的值必须要满足一个布尔表达式。例如，为了要求正值的产品价格，我们可以使用：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric <emphasis>CHECK (price &gt; 0)</emphasis>
);
</programlisting>
   </para>

   <para>
    如你所见，约束定义就和默认值定义一样跟在数据类型之后。默认值和约束之间的顺序没有影响。一个检查约束有关键字<literal>CHECK</literal>以及其后的包围在圆括号中的表达式组成。检查约束表达式应该涉及到被约束的列，否则该约束也没什么实际意义。
   </para>

   <indexterm>
    <primary>constraint</primary>
    <secondary>name</secondary>
   </indexterm>

   <para>
    我们也可以给与约束一个独立的名称。这会使得错误消息更为清晰，同时也允许我们在需要更改约束时能引用它。语法为：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric <emphasis>CONSTRAINT positive_price</emphasis> CHECK (price &gt; 0)
);
</programlisting>
    要指定一个命名的约束，请在约束名称标识符前使用关键词<literal>CONSTRAINT</literal>，然后把约束定义放在标识符之后（如果没有以这种方式指定一个约束名称，系统将会为我们选择一个）。
   </para>

   <para>
    一个检查约束也可以引用多个列。例如我们存储一个普通价格和一个打折后的价格，而我们希望保证打折后的价格低于普通价格：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price &gt; 0),
    discounted_price numeric CHECK (discounted_price &gt; 0),
    <emphasis>CHECK (price &gt; discounted_price)</emphasis>
);
</programlisting>
   </para>

   <para>
    前两个约束看起来很相似。第三个则使用了一种新语法。它并没有依附在一个特定的列，而是作为一个独立的项出现在逗号分隔的列列表中。列定义和这种约束定义可以以混合的顺序出现在列表中。
   </para>

   <para>
    我们将前两个约束称为列约束，而第三个约束为表约束，因为它独立于任何一个列定义。列约束也可以写成表约束，但反过来不行，因为一个列约束只能引用它所依附的那一个列（<productname>PostgreSQL</productname>并不强制要求这个规则，但是如果我们希望表定义能够在其他数据库系统中工作，那就应该遵循它）。上述例子也可以写成：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0),
    CHECK (price &gt; discounted_price)
);
</programlisting>
    甚至是：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0 AND price &gt; discounted_price)
);
</programlisting>
    这只是口味的问题。
   </para>

   <para>
    表约束也可以用列约束相同的方法来指定名称：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0),
    <emphasis>CONSTRAINT valid_discount</> CHECK (price &gt; discounted_price)
);
</programlisting>
   </para>

   <indexterm>
    <primary>null value</primary>
    <secondary sortas="check constraints">with check constraints</secondary>
   </indexterm>

   <para>
    需要注意的是，一个检查约束在其检查表达式值为真或空值时被满足。因为当任何操作数为空时大部分表达式将计算为空值，所以它们不会阻止被约束列中的控制。为了保证一个列不包含控制，可以使用下一节中的非空约束。
   </para>
  </sect2>

  <sect2>
   <title>非空约束</title>

   <indexterm>
    <primary>not-null constraint</primary>
   </indexterm>

   <indexterm>
    <primary>constraint</primary>
    <secondary>NOT NULL</secondary>
   </indexterm>

   <para>
    一个非空约束仅仅指定一个列中不会有空值。语法例子：
<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>NOT NULL</emphasis>,
    name text <emphasis>NOT NULL</emphasis>,
    price numeric
);
</programlisting>
   </para>

   <para>
    一个非空约束总是被写成一个列约束。一个非空约束等价于创建一个检查约束<literal>CHECK (<replaceable>column_name</replaceable>
    IS NOT NULL)</literal>，但在<productname>PostgreSQL</productname>中创建一个显式的非空约束更高效。这种方式创建的非空约束的缺点是我们无法为它给予一个显式的名称。
   </para>

   <para>
    当然，一个列可以有多于一个的约束，只需要将这些约束一个接一个写出：
<programlisting>
CREATE TABLE products (
    product_no integer NOT NULL,
    name text NOT NULL,
    price numeric NOT NULL CHECK (price &gt; 0)
);
</programlisting>
    约束的顺序没有关系，因为并不需要决定约束被检查的顺序。
   </para>

   <para>
    <literal>NOT NULL</literal>约束有一个相反的情况：<literal>NULL</literal>约束。这并不意味着该列必须为空，进而肯定是无用的。相反，它仅仅选择了列可能为空的默认行为。SQL标准中并不存在<literal>NULL</literal>约束，因此它不能被用于可移植的应用中（<productname>PostgreSQL</productname>中加入它是为了和某些其他数据库系统兼容）。但是某些用户喜欢它，因为它使得在一个脚本文件中可以很容易的进行约束切换。例如，初始时我们可以：
<programlisting>
CREATE TABLE products (
    product_no integer NULL,
    name text NULL,
    price numeric NULL
);
</programlisting>
    然后可以在需要的地方插入<literal>NOT</literal>关键词。
   </para>

   <tip>
    <para>
     在大部分数据库中多数列应该被标记为非空。
    </para>
   </tip>
  </sect2>

  <sect2 id="ddl-constraints-unique-constraints">
   <title>唯一约束</title>

   <indexterm>
    <primary>unique constraint</primary>
   </indexterm>

   <indexterm>
    <primary>constraint</primary>
    <secondary>unique</secondary>
   </indexterm>

   <para>
    唯一约束保证表中所有行在一列中或者一组列中保存的数据是唯一的。写成一个列约束的语法是：
<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>UNIQUE</emphasis>,
    name text,
    price numeric
);
</programlisting>
    写成一个表约束的语法是：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    <emphasis>UNIQUE (product_no)</emphasis>
);
</programlisting>
   </para>

   <para>
    为一组列定义一个唯一约束，将它看做使用逗号分隔列名的表约束：
<programlisting>
CREATE TABLE example (
    a integer,
    b integer,
    c integer,
    <emphasis>UNIQUE (a, c)</emphasis>
);
</programlisting>
    这指定这些列的组合值在整个表的范围内是唯一的，但其中任意一列的值并不需要是（一般也不是）唯一的。
   </para>

   <para>
    我们可以通常的方式为一个唯一索引命名：
<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>CONSTRAINT must_be_different</emphasis> UNIQUE,
    name text,
    price numeric
);
</programlisting>
   </para>

   <para>
    增加一个唯一约束会在约束中的列或列组上自动创建一个唯一B-tree索引。
    在某些行上的唯一约束不能看做唯一约束，但是可能通过创建一个唯一<link linkend="indexes-partial">部分索引</link>执行这个约束。
   </para>

   <indexterm>
    <primary>null value</primary>
    <secondary sortas="unique constraints">with unique constraints</secondary>
   </indexterm>

   <para>
    通常，当表中有超过一行在约束所包括列上的值相同时，将会违反唯一约束。但是在这种比较中，两个空值被认为是不同的。这意味着即便存在一个唯一约束，也可以存储多个在至少一个被约束列中包含空值的行。这种行为符合SQL标准，但我们听说一些其他SQL数据库可能不遵循这个规则。所以在开发需要可移植的应用时应注意这一点。
   </para>
  </sect2>

  <sect2 id="ddl-constraints-primary-keys">
   <title>主键</title>

   <indexterm>
    <primary>primary key</primary>
   </indexterm>

   <indexterm>
    <primary>constraint</primary>
    <secondary>primary key</secondary>
   </indexterm>

   <para>
    主键约束表示列，或者列组，可以作为表中行唯一标识符使用。需要该值是
    唯一的而且非空。因此，下面的两个表定义接受相同的数据：
<programlisting>
CREATE TABLE products (
    product_no integer UNIQUE NOT NULL,
    name text,
    price numeric
);
</programlisting>

<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>PRIMARY KEY</emphasis>,
    name text,
    price numeric
);
</programlisting>
   </para>

   <para>
    主键也可以包含多于一个列，其语法和唯一约束相似：
<programlisting>
CREATE TABLE example (
    a integer,
    b integer,
    c integer,
    <emphasis>PRIMARY KEY (a, c)</emphasis>
);
</programlisting>
   </para> 

   <para>
     添加主键将在主键列出的列上或者列组中自动创建唯一B树索引，
     并且强制列被标记为<literal>非空</>。
   </para>

   <para>
    一个表最多只能有一个主键（可以有任意数量的唯一和非空约束，它们可以达到和逐渐一样的功能，但只能有一个被标识为主键）。关系数据库理论要求每一个表都要有一个主键。但<productname>PostgreSQL</productname>中并未强制要求这一点，但是最好能够遵循它。
   </para>
   
    <para>
    主键对于建立文档的目的和客户端应用都有用。
    例如，一个允许修改行值的GUI应用可能需要知道一个表的主键，
    这样它才能唯一地区分行。在数据库系统中有各种方法，如果已声明，
    则使用主键；例如，主键定义了用于外键参照表的缺省目标列(s)。
   </para>
  </sect2>

  <sect2 id="ddl-constraints-fk">
   <title>外键</title>

   <indexterm>
    <primary>foreign key</primary>
   </indexterm>

   <indexterm>
    <primary>constraint</primary>
    <secondary>foreign key</secondary>
   </indexterm>

   <indexterm>
    <primary>referential integrity</primary>
   </indexterm>

   <para>
    一个外键约束指定一列（或一组列）中的值必须匹配出现在另一个表中某些行的值。我们说这维持了两个关联表之间的<firstterm>引用完整性</firstterm>。
   </para>

   <para>
    例如我们有一个使用过多次的产品表：
<programlisting>
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);
</programlisting>
    让我们假设我们还有一个存储这些产品订单的表。我们希望保证订单表中只包含真正存在的产品的订单。因此我们在订单表中定义一个引用产品表的外键约束：
<programlisting>
CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer <emphasis>REFERENCES products (product_no)</emphasis>,
    quantity integer
);
</programlisting>
    现在就不可能创建包含不存在于产品表中的<structfield>product_no</structfield>值（非空）的订单。
   </para>

   <para>
    我们说在这种情况下，订单表是<firstterm>引用</firstterm>表而产品表是<firstterm>被引用</firstterm>表。相应地，也有引用和被引用列的说法。
   </para>

   <para>
    我们也可以把上述命令简写为：
<programlisting>
CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer <emphasis>REFERENCES products</emphasis>,
    quantity integer
);
</programlisting>
    因为如果缺少列的列表，则被引用表的主键将被用作被引用列。
   </para>

   <para>
    一个外键也可以约束和引用一组列。照例，它需要被写成表约束的形式。下面是一个例子：
<programlisting>
CREATE TABLE t1 (
  a integer PRIMARY KEY,
  b integer,
  c integer,
  <emphasis>FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)</emphasis>
);
</programlisting>
    当然，被约束列的数量和类型应该匹配被引用列的数量和类型。
   </para>

   <para>
    按照前面的方式，我们可以为一个外键约束命名。
   </para>

   <para>
    一个表可以有超过一个的外键约束。这被用于实现表之间的多对多关系。例如我们有关于产品和订单的表，但我们现在希望一个订单能包含多种产品（这在上面的结构中是不允许的）。我们可以使用这种表结构：
<programlisting>
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);

CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    shipping_address text,
    ...
);

CREATE TABLE order_items (
    product_no integer REFERENCES products,
    order_id integer REFERENCES orders,
    quantity integer,
    PRIMARY KEY (product_no, order_id)
);
</programlisting>
    注意在最后一个表中主键和外键之间有重叠。
   </para>

   <indexterm>
    <primary>CASCADE</primary>
    <secondary>foreign key action</secondary>
   </indexterm>

   <indexterm>
    <primary>RESTRICT</primary>
    <secondary>foreign key action</secondary>
   </indexterm>

   <para>
    我们知道外键不允许创建与任何产品都不相关的订单。但如果一个产品在一个引用它的订单创建之后被移除会发生什么？SQL允许我们处理这种情况。直观上，我们有几种选项：
    <itemizedlist spacing="compact">
     <listitem><para>不允许删除一个被引用的产品</para></listitem>
     <listitem><para>同时也删除引用产品的订单</para></listitem>
     <listitem><para>其他？</para></listitem>
    </itemizedlist>
   </para>

   <para>
    为了说明这些，让我们在上面的多对多关系例子中实现下面的策略：当某人希望移除一个仍然被一个订单引用（通过<literal>order_items</literal>）的产品时 ，我们组织它。如果某人移除一个订单，订单项也同时被移除：
<programlisting>
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);

CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    shipping_address text,
    ...
);

CREATE TABLE order_items (
    product_no integer REFERENCES products <emphasis>ON DELETE RESTRICT</emphasis>,
    order_id integer REFERENCES orders <emphasis>ON DELETE CASCADE</emphasis>,
    quantity integer,
    PRIMARY KEY (product_no, order_id)
);
</programlisting>
   </para>

   <para>
    限制删除或者级联删除是两种最常见的选项。<literal>RESTRICT</literal>阻止删除一个被引用的行。<literal>NO ACTION</literal>表示在约束被检察时如果有任何引用行存在，则会抛出一个错误，这是我们没有指定任何东西时的默认行为（这两种选择的本质不同在于<literal>NO ACTION</literal>允许检查被推迟到事务的最后，而<literal>RESTRICT</literal>则不会）。<literal>CASCADE</>指定当一个被引用行被删除后，引用它的行也应该被自动删除。还有其他两种选项：<literal>SET NULL</literal>和<literal>SET DEFAULT</literal>。这些将导致在被引用行被删除后，引用行中的引用列被置为空值或它们的默认值。注意这些并不会是我们免于遵守任何约束。例如，如果一个动作指定了<literal>SET DEFAULT</literal>，但是默认值不满足外键约束，操作将会失败。
   </para>

   <para>
    与<literal>ON DELETE</literal>相似，同样有<literal>ON UPDATE</literal>可以用在一个被引用列被修改（更新）的情况，可选的动作相同。在这种情况下，<literal>CASCADE</>意味着被引用列的更新值应该被复制到引用行中。
   </para>

   <para>
    正常情况下，如果一个引用行的任意一个引用列都为空，则它不需要满足外键约束。如果在外键定义中加入了<literal>MATCH FULL</>，一个引用行只有在它的所有引用列为空时才不需要满足外键约束（因此空和非空值的混合肯定会导致<literal>MATCH FULL</>约束失败）。如果不希望引用行能够避开外键约束，将引用行声明为<literal>NOT NULL</>。
   </para>

   <para>
    一个外键所引用的列必须是一个主键或者被唯一约束所限制。这意味着被引用列总是拥有一个索引（位于主键或唯一约束之下的索引），因此在其上进行的一个引用行是否匹配的检查将会很高效。由于从被引用表中<command>DELETE</command>一行或者<command>UPDATE</command>一个被引用列将要求对引用表进行扫描以得到匹配旧值的行，在引用列上建立合适的索引也会大有益处。由于这种做法并不是必须的，而且创建索引也有很多种选择，所以外键约束的定义并不会自动在引用列上创建索引。
   </para>

   <para>
    更多关于更新和删除数据的信息请见<xref
    linkend="dml">。外键约束的语法描述请参考<xref linkend="sql-createtable">。
   </para>
  </sect2>

  <sect2 id="ddl-constraints-exclusion">
   <title>排他约束</title>

   <indexterm>
    <primary>exclusion constraint</primary>
   </indexterm>

   <indexterm>
    <primary>constraint</primary>
    <secondary>exclusion</secondary>
   </indexterm>

   <para>
    排他约束保证如果将任何两行的指定列或表达式使用指定操作符进行比较，至少其中一个操作符比较将会返回否或空值。语法是：
<programlisting>
CREATE TABLE circles (
    c circle,
    EXCLUDE USING gist (c WITH &amp;&amp;)
);
</programlisting>
   </para>

   <para>
    详见<link linkend="SQL-CREATETABLE-EXCLUDE"><command>CREATE
    TABLE ... CONSTRAINT ... EXCLUDE</></link>。
   </para>

   <para>
    增加一个排他约束将在约束声明所指定的类型上自动创建索引。
   </para>
  </sect2>
 </sect1>

 <sect1 id="ddl-system-columns">
  <title>系统列</title>

  <para>
   每一个表都拥有一些由系统隐式定义的<firstterm>系统列</>。因此，这些列的名字不能像用户定义的列一样使用（注意这种限制与名称是否为关键词没有关系，即便用引号限定一个名称也无法绕过这种限制）。 事实上用户不需要关心这些列，只需要知道它们存在即可。
  </para>

  <indexterm>
   <primary>column</primary>
   <secondary>system column</secondary>
  </indexterm>

  <variablelist>
   <varlistentry>
    <term><structfield>oid</></term>
    <listitem>
     <para>
      <indexterm>
       <primary>OID</primary>
       <secondary>column</secondary>
      </indexterm>
      一行的对象标识符（对象ID）。该列只有在表使用<literal>WITH OIDS</literal>创建时或者<xref linkend="guc-default-with-oids">配置变量被设置时才存在。该列的类型为<type>oid</type>（与列名一致），该类型详见<xref linkend="datatype-oid">。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><structfield>tableoid</></term>
    <listitem>
     <indexterm>
      <primary>tableoid</primary>
     </indexterm>

     <para>
      包含这一行的表的OID。该列是特别为从继承层次（见<xref linkend="ddl-inherit">）中选择的查询而准备，因为如果没有它将很难知道一行来自于哪个表。<structfield>tableoid</structfield>可以与<structname>pg_class</structname>的<structfield>oid</structfield>列进行连接来获得表的名称。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><structfield>xmin</></term>
    <listitem>
     <indexterm>
      <primary>xmin</primary>
     </indexterm>

     <para>
      插入该行版本的事务身份（事务ID）。一个行版本是一个行的一个特别版本，对一个逻辑行的每一次更新都将创建一个新的行版本。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><structfield>cmin</></term>
    <listitem>
     <indexterm>
      <primary>cmin</primary>
     </indexterm>

     <para>
      插入事务中的命令标识符（从0开始）。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><structfield>xmax</></term>
    <listitem>
     <indexterm>
      <primary>xmax</primary>
     </indexterm>

     <para>
      删除事务的身份（事务ID），对于未删除的行版本为0。对于一个可见的行版本，该列值也可能为非零。这通常表示删除事务还没有提交，或者一个删除尝试被回滚。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><structfield>cmax</></term>
    <listitem>
     <indexterm>
      <primary>cmax</primary>
     </indexterm>

     <para>
      删除事务中的命令标识符，或者为0。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><structfield>ctid</></term>
    <listitem>
     <indexterm>
      <primary>ctid</primary>
     </indexterm>

     <para>
      行版本在其表中的物理位置。注意尽管<structfield>ctid</structfield>可以被用来非常快速地定位行版本，但是一个行的<structfield>ctid</structfield>会在被更新或者被<command>VACUUM FULL</>移动时改变。因此，<structfield>ctid</structfield>不能作为一个长期行标识符。OID或者最好是一个用户定义的序列号才应该被用来标识逻辑行。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

   <para>
    OID是32位量，它从一个服务于整个集簇的计数器分配而来。在一个大型的或者历时长久的数据库中，该计数器有可能会出现绕回。因此，不要总是假设OID是唯一的，除非你采取了措施来保证。如果需要在一个表中标识行，推荐使用一个序列生成器。然而，OID也可以被使用，但是是要采取一些额外的预防措施：

    <itemizedlist>
     <listitem>
      <para>
       如果要将OID用来标识行，应该在OID列上创建一个唯一约束。当这样一个唯一约束（或唯一索引）存在时，系统会注意不生成匹配现有行的OID（当然，这只有在表的航数目少于2<superscript>32</>（40亿）时才成立。并且在实践中表的尺寸最好远比这个值小，否则将会牺牲性能）。
      </para>
     </listitem>
     <listitem>
      <para>
       绝不要认为OID在表之间也是唯一的，使用<structfield>tableoid</>和行OID的组合来作为数据库范围内的标识符。
      </para>
     </listitem>
     <listitem>
      <para>
       当然，问题中的表都必须是用<literal>WITH OIDS</literal>创建。在<productname>PostgreSQL</productname> 8.1中，<literal>WITHOUT OIDS</>是默认形式。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    事务标识符也是32位量。在一个历时长久的数据库中事务ID同样会绕回。但如果采取适当的维护过程，这不会是一个致命的问题，详见<xref linkend="maintenance">。但是，长期（超过10亿个事务）依赖事务ID的唯一性是不明智的。
   </para>

   <para>
    命令标识符也是32位量。这对一个事务中包含的<acronym>SQL</acronym>命令设置了一个硬极限：
    2<superscript>32</>（40亿）。在实践中，该限制并不是问题 &mdash; 注意该限制只是针对<acronym>SQL</acronym>命令的数目而不是被处理的行数。同样，只有真正
    修改了数据库内容的命令才会消耗一个命令标识符。
   </para>
 </sect1>

 <sect1 id="ddl-alter">
  <title>修改表</title>

  <indexterm zone="ddl-alter">
   <primary>table</primary>
   <secondary>modifying</secondary>
  </indexterm>

  <para>
   当我们已经创建了一个表并意识到犯了一个错误或者应用需求发生改变时，我们可以移除表并重新创建它。但如果表中已经被填充数据或者被其他数据库对象引用（例如有一个外键约束），这种做法就显得很不方便。因此，<productname>PostgreSQL</productname>提供了一族命令来对已有的表进行修改。注意这和修改表中所包含的数据是不同的，这里要做的是对表的定义或者说结构进行修改。
  </para>

  <para>
   利用这些命令，我们可以：
   <itemizedlist spacing="compact">
    <listitem>
     <para>增加列</para>
    </listitem>
    <listitem>
     <para>移除列</para>
    </listitem>
    <listitem>
     <para>增加约束</para>
    </listitem>
    <listitem>
     <para>移除约束</para>
    </listitem>
    <listitem>
     <para>修改默认值</para>
    </listitem>
    <listitem>
     <para>修改列数据类型</para>
    </listitem>
    <listitem>
     <para>重命名列</para>
    </listitem>
    <listitem>
     <para>重命名表</para>
    </listitem>
   </itemizedlist>

   所有这些动作都由<xref linkend="sql-altertable">命令执行，其参考页面中包含更详细的信息。
  </para>

  <sect2 id="ddl-alter-adding-a-column">
   <title>增加列</title>

   <indexterm>
    <primary>column</primary>
    <secondary>adding</secondary>
   </indexterm>

   <para>
    要增加一个列，可以使用这样的命令：
<programlisting>
ALTER TABLE products ADD COLUMN description text;
</programlisting>
    新列将被默认值所填充（如果没有指定<literal>DEFAULT</>子句，则会填充空值）。
   </para>

   <para>
    也可以同时为列定义约束，语法：
<programlisting>
ALTER TABLE products ADD COLUMN description text CHECK (description &lt;&gt; '');
</programlisting>
    事实上<command>CREATE TABLE</>中关于一列的描述都可以应用在这里。记住不管怎样，默认值必须满足给定的约束，否则<literal>ADD</>将会失败。也可以先将新列正确地填充好，然后再增加约束（见后文）。
   </para>

  <tip>
   <para>
    增加一个带默认值的列需要更新表中的每一行（来存储新列值）。然而，如果不指定默认值，<productname>PostgreSQL</productname>可以避免物理更新。因此如果我们准备向列中填充的值大多是非默认值，最好是增加列的时候不指定默认值，增加列后用<command>UPDATE</>填充正确的数据并且增加所需要的默认值约束。   </para>
  </tip>
  </sect2>

  <sect2 id="ddl-alter-removing-a-column">
   <title>移除列</title>

   <indexterm>
    <primary>column</primary>
    <secondary>removing</secondary>
   </indexterm>

   <para>
    为了移除一个列，使用如下的命令：
<programlisting>
ALTER TABLE products DROP COLUMN description;
</programlisting>
    列中的数据将会消失。涉及到该列的表约束也会被移除。然而，如果该列被另一个表的外键所引用，<productname>PostgreSQL</productname>不会安静地移除该约束。我们可以通过增加<literal>CASCADE</>来授权移除任何依赖于被删除列的所有东西：
<programlisting>
ALTER TABLE products DROP COLUMN description CASCADE;
</programlisting>
    关于这个操作背后的一般性机制请见<xref linkend="ddl-depend">。
   </para>
  </sect2>

  <sect2 id="ddl-alter-adding-a-constraint">
   <title>增加约束</title>

   <indexterm>
    <primary>constraint</primary>
    <secondary>adding</secondary>
   </indexterm>

   <para>
    为了增加一个约束，可以使用表约束的语法，例如：
<programlisting>
ALTER TABLE products ADD CHECK (name &lt;&gt; '');
ALTER TABLE products ADD CONSTRAINT some_name UNIQUE (product_no);
ALTER TABLE products ADD FOREIGN KEY (product_group_id) REFERENCES product_groups;
</programlisting>
    要增加一个不能写成表约束的非空约束，可使用语法：
<programlisting>
ALTER TABLE products ALTER COLUMN product_no SET NOT NULL;
</programlisting>
   </para>

   <para>
    该约束会立即被检查，所以表中的数据必须在约束被增加之前就已经符合约束。
   </para>
  </sect2>

  <sect2 id="ddl-alter-removing-a-constraint">
   <title>移除约束</title>

   <indexterm>
    <primary>constraint</primary>
    <secondary>removing</secondary>
   </indexterm>

   <para>
    为了移除一个约束首先需要知道它的名称。如果在创建时已经给它指定了名称，那么事情就变得很容易。否则约束的名称是由系统生成的，我们必须先找出这个名称。<application>psql</application>的命令<literal>\d
    <replaceable>表名</replaceable></literal>将会对此有所帮助，其他接口也会提供方法来查看表的细节。因此命令是：
<programlisting>
ALTER TABLE products DROP CONSTRAINT some_name;
</programlisting>
    （如果处理的是自动生成的约束名称，如<literal>$2</>，别忘了用双引号使它变成一个合法的标识符。）
   </para>

   <para>
    和移除一个列相似，如果需要移除一个被某些别的东西依赖的约束，也需要加上<literal>CASCADE</>。一个例子是一个外键约束依赖于被引用列上的一个唯一或者主键约束。
   </para>

   <para>
    这对除了非空约束之外的所有约束类型都一样有效。为了移除一个非空约束可以用：
<programlisting>
ALTER TABLE products ALTER COLUMN product_no DROP NOT NULL;
</programlisting>
    （回忆一下，非空约束是没有名称的，所以不能用第一种方式。）
   </para>
  </sect2>

  <sect2>
   <title>更改列的默认值</title>

   <indexterm>
    <primary>default value</primary>
    <secondary>changing</secondary>
   </indexterm>

   <para>
    要为一个列设置一个新默认值，使用命令：
<programlisting>
ALTER TABLE products ALTER COLUMN price SET DEFAULT 7.77;
</programlisting>
    注意这不会影响任何表中已经存在的行，它只是为未来的<command>INSERT</>命令改变了默认值。
   </para>

   <para>
    要移除任何默认值，使用：
<programlisting>
ALTER TABLE products ALTER COLUMN price DROP DEFAULT;
</programlisting>
    这等同于将默认值设置为空值。相应的，试图删除一个未被定义的默认值并不会引发错误，因为默认值已经被隐式地设置为空值。
   </para>
  </sect2>

  <sect2>
   <title>修改列的数据类型</title>

   <indexterm>
    <primary>column data type</primary>
    <secondary>changing</secondary>
   </indexterm>

   <para>
    为了将一个列转换为一种不同的数据类型，使用如下命令：
<programlisting>
ALTER TABLE products ALTER COLUMN price TYPE numeric(10,2);
</programlisting>
    只有当列中的每一个项都能通过一个隐式造型转换为新的类型时该操作才能成功。如果需要一种更复杂的转换，应该加上一个<literal>USING</>子句来指定应该如何把旧值转换为新值。
   </para>

   <para>
    <productname>PostgreSQL</>将尝试把列的默认值转换为新类型，其他涉及到该列的任何约束也是一样。但是这些转换可能失败或者产生奇特的结果。因此最好在修改类型之前先删除该列上所有的约束，然后在修改完类型后重新加上相应修改过的约束。
   </para>
  </sect2>

  <sect2>
   <title>重命名列</title>

   <indexterm>
    <primary>column</primary>
    <secondary>renaming</secondary>
   </indexterm>

   <para>
    要重命名一个列：
<programlisting>
ALTER TABLE products RENAME COLUMN product_no TO product_number;
</programlisting>
   </para>
  </sect2>

  <sect2>
   <title>重命名表</title>

   <indexterm>
    <primary>table</primary>
    <secondary>renaming</secondary>
   </indexterm>

   <para>
    要重命名一个表：
<programlisting>
ALTER TABLE products RENAME TO items;
</programlisting>
   </para>
  </sect2>
 </sect1>

 <sect1 id="ddl-priv">
  <title>权限</title>

  <indexterm zone="ddl-priv">
   <primary>privilege</primary>
  </indexterm>

  <indexterm>
   <primary>permission</primary>
   <see>privilege</see>
  </indexterm>

  <indexterm zone="ddl-priv">
   <primary>owner</primary>
  </indexterm>

  <indexterm zone="ddl-priv">
   <primary>GRANT</primary>
  </indexterm>

  <indexterm zone="ddl-priv">
   <primary>REVOKE</primary>
  </indexterm>

  <para>
   一旦一个对象被创建，它会被分配一个所有者。所有者通常是执行创建语句的角色。对于大部分类型的对象，初始状态下只有所有者（或者超级用户）能够对该对象做任何事情。为了允许其他角色使用它，必须分配<firstterm>权限</firstterm>。
  </para>

  <para>
   有多种不同的权限：<literal>SELECT</>、<literal>INSERT</>、<literal>UPDATE</>、<literal>DELETE</>、<literal>TRUNCATE</>、<literal>REFERENCES</>、<literal>TRIGGER</>、<literal>CREATE</>、<literal>CONNECT</>、<literal>TEMPORARY</>、<literal>EXECUTE</>以及<literal>USAGE</>。可以应用于一个特定对象的权限随着对象的类型（表、函数等）而不同。<productname>PostgreSQL</productname>所支持的不同类型的完整权限信息请参考<xref linkend="sql-grant">。下面的章节将简单介绍如何使用这些权限。
  </para>

  <para>
   修改或销毁一个对象的权力通常是只有所有者才有的权限。
  </para>

  <para>
   一个对象可以通过该对象类型相应的<command>ALTER</command>命令来重新分配所有者，例如<xref linkend="sql-altertable">。超级用户总是可以做到这点，普通角色只有同时是对象的当前所有者（或者是拥有角色的一个成员）以及新拥有角色的一个成员时才能做同样的事。
  </para>

  <para>
   要分配权限，可以使用<command>GRANT</command>命令。例如，如果<literal>joe</literal>是一个已有用户，而<literal>accounts</literal>是一个已有表，更新该表的权限可以按如下方式授权：
<programlisting>
GRANT UPDATE ON accounts TO joe;
</programlisting>
   用<literal>ALL</literal>取代特定权限会把与对象类型相关的所有权限全部授权。
  </para>

  <para>
   一个特殊的名为<literal>PUBLIC</literal>的<quote>用户</quote>可以用来向系统中的每一个用户授予一个权限。同时，在数据库中有很多用户时可以设置<quote>组</>角色来帮助管理权限。详见<xref linkend="user-manag">。
  </para>

  <para>
   为了撤销一个权限，使用<command>REVOKE</command>命令：
<programlisting>
REVOKE ALL ON accounts FROM PUBLIC;
</programlisting>
   对象拥有者的特殊权限（即执行<command>DROP</>、<command>GRANT</>、<command>REVOKE</>等的权力）总是隐式地属于拥有者，并且不能被授予或撤销。但是对象拥有者可以选择撤销他自己的普通权限，例如把一个表变得对他自己和其他人只读。
  </para>

  <para>
   一般情况下，只有对象拥有者（或者超级用户）可以授予或撤销一个对象上的权限。但是可以在授予权限时使用<quote>with grant option</>来允许接收人将权限转授给其他人。如果后来授予选项被撤销，则所有从接收人那里获得的权限（直接或者通过授权链获得）都将被撤销。更多详情请见<xref linkend="sql-grant">和<xref linkend="sql-revoke">参考页。
  </para>
 </sect1>

<sect1 id="ddl-rowsecurity">
  <title>行安全策略</title>

  <indexterm zone="ddl-rowsecurity">
   <primary>行级安全</primary>
  </indexterm>

  <indexterm zone="ddl-rowsecurity">
   <primary>策略</primary>
  </indexterm>

  <para> 
   除了SQL标准通过<xref linkend="sql-grant"><link linkend="ddl-priv">权限系统</link>可用之外，
   表可以有<firstterm>行安全策略</>，每个用户基础上，
   限制通过正常查询或者插入，更新，或者数据修改命令删除的返回行。
   该功能看做<firstterm>行级安全</>。缺省情况下，表没有任何策略，
   因此如果用户按照SQL权限系统有对表的访问权限，在它内的所有行同样
   可以用于查询或者更新。 
  </para>

  <para>
   当表上（使用<link linkend="sql-altertable">ALTER TABLE ... ENABLE ROW LEVEL
   SECURITY</>）启用行安全时， 
   通过行安全策略允许正常访问表进行选择行或者修改行。（然而，表的所有者通常
   不受限于行安全策略。）如果没有策略存在于表中，使用缺省拒绝策略，意味着
   没有行可见或者被修改。适用整个表的操作，
   比如<command>TRUNCATE</>和<literal>REFERENCES</>不受行安全限制。
  </para>

  <para>
   行安全策略特定于命令，或者角色，或者两者。指定策略适用于<literal>ALL</literal>
   命令，或者<literal>SELECT</>，<literal>INSERT</>，<literal>UPDATE</>，
   或者<literal>DELETE</>。分配多个角色给特定策略，适用正常角色从属关系和继承规则。
  </para>

  <para>
   指定哪些行按政策可见或者可修改，表达式是必需的，它返回一个布尔结果。
   表达式将对先于任何条件或者来自用户查询的任何函数之前的每一行进行评估。
（这个规则的唯一例外是<literal>leakproof</literal>函数，它保证不泄露信息；该优化器
可能选择行安全检查前应用这个函数。）不处理那些表达式不返回<literal>true</>的行。
可以指定单独的表达式，用以提供对可见的行和允许进行修改的行的独立控制。
策略表达式作为查询部分运行，并具有用户运行查询权限，
尽管安全定义函数可用于访问对主叫用户不可见的数据。
  </para>

  <para>
   当访问表的时候，超级用户以及具有<literal>BYPASSRLS</>属性的角色总是避开
   行安全系统。表的所有者通常也绕过行安全，尽管表所有者可以选择从属于具有
   <link linkend="sql-altertable">ALTER TABLE ... FORCE ROW LEVEL SECURITY</>的行安全。
  </para>

  <para>
   启用和禁用行安全，以及增加表策略，总是表所有者的特权。
  </para>

  <para>
   使用<xref linkend="sql-createpolicy">命令创建策略，
   使用<xref linkend="sql-alterpolicy">命令修改策略，
   使用<xref linkend="sql-droppolicy">命令删除策略。
   为了启用和禁用特定表的行安全性，使用<xref linkend="sql-altertable">命令。
  </para>

  <para>
   Each policy has a name and multiple policies can be defined for a
   table.  As policies are table-specific, each policy for a table must
   have a unique name.  Different tables may have policies with the
   same name.
   每个策略都有一个名字并且可以为表定义多个策略。
   由于策略是表特定的，每一个表策略必须有唯一的名称。
   不同的表可能有相同名称的策略。
  </para>

  <para>
   当多个策略应用于特定查询时，使用<literal>OR</literal>结合，
   因此如果任何策略允许的话，
   行是可访问的。这类似于特定角色是所有角色成员权限的规则。
  </para>

  <para>
   作为一个简单的例子，这里是如何创建关于
<literal>account</>关系允许<literal>managers</>角色成员访问行的策略，
并且只有他们账户里面的行：
  </para>

<programlisting>
CREATE TABLE accounts (manager text, company text, contact_email text);

ALTER TABLE accounts ENABLE ROW LEVEL SECURITY;

CREATE POLICY account_managers ON accounts TO managers
    USING (manager = current_user);
</programlisting>

  <para>
   如果不指定任何角色，或者使用特定用户名<literal>PUBLIC</literal>，
   那么策略应用于系统上的所有用户。允许所有用户访问<literal>用户</>
   表中的行，可以使用简单策略： 
  </para>

<programlisting>
CREATE POLICY user_policy ON users
    USING (user = current_user);
</programlisting>

  <para>
   相比较那些可见行为添加到表中行使用不同策略，可以使用<literal>WITH CHECK</>子句。
   这个策略允许所有用户查看<literal>users</>表中的所有行，但是仅仅修改自己：
  </para>

<programlisting>
CREATE POLICY user_policy ON users
    USING (true)
    WITH CHECK (user = current_user);
</programlisting>

  <para>
   使用<command>ALTER TABLE</>命令禁用行安全性。
   禁用行安全性不移除在表上定义的任何策略；他们只是忽略。
   然后表上所有的行是可见的并且可修改的，属于标准的SQL权限系统。
  </para>

  <para>
   下面是一个在生产环境中如何使用这个功能的例子。表<literal>passwd</>模拟
   Unix密码文件：
  </para>

<programlisting>
-- 简单密码文件基本例子
CREATE TABLE passwd (
  username              text UNIQUE NOT NULL,
  pwhash                text,
  uid                   int  PRIMARY KEY,
  gid                   int  NOT NULL,
  real_name             text NOT NULL,
  home_phone            text,
  extra_info            text,
  home_dir              text NOT NULL,
  shell                 text NOT NULL
);

CREATE ROLE admin;  -- Administrator
CREATE ROLE bob;    -- Normal user
CREATE ROLE alice;  -- Normal user

-- 填充表
INSERT INTO passwd VALUES
  ('admin','xxx',0,0,'Admin','111-222-3333',null,'/root','/bin/dash');
INSERT INTO passwd VALUES
  ('bob','xxx',1,1,'Bob','123-456-7890',null,'/home/bob','/bin/zsh');
INSERT INTO passwd VALUES
  ('alice','xxx',2,1,'Alice','098-765-4321',null,'/home/alice','/bin/zsh');

-- 一定启用表上行级安全性
ALTER TABLE passwd ENABLE ROW LEVEL SECURITY;

-- 创建策略
-- 管理员可以查看所有行并且添加行
CREATE POLICY admin_all ON passwd TO admin USING (true) WITH CHECK (true);
-- 普通用户可以查看所有行
CREATE POLICY all_view ON passwd FOR SELECT USING (true);
-- 普通用户可以更新自己的记录，但是限制普通用户设置哪个脚本
CREATE POLICY user_mod ON passwd FOR UPDATE
  USING (current_user = username)
  WITH CHECK (
    current_user = username AND
    shell IN ('/bin/bash','/bin/sh','/bin/dash','/bin/zsh','/bin/tcsh')
  );

-- 允许管理所有普通权限
GRANT SELECT, INSERT, UPDATE, DELETE ON passwd TO admin;
-- 用户只在public列上获取select访问
GRANT SELECT
  (username, uid, gid, real_name, home_phone, extra_info, home_dir, shell)
  ON passwd TO public;
-- 允许用户更新某些列
GRANT UPDATE
  (pwhash, real_name, home_phone, extra_info, shell)
  ON passwd TO public;
</programlisting>

  <para>
   正如任何安全设置，重要的是要测试，并确保该系统的行为如预期。
   使用上面的例子，这演示了权限系统正常工作。
  </para>

<programlisting>
-- 管理员可以查看所有行和字段
postgres=&gt; set role admin;
SET
postgres=&gt; table passwd;
 username | pwhash | uid | gid | real_name |  home_phone  | extra_info | home_dir    |   shell
----------+--------+-----+-----+-----------+--------------+------------+-------------+-----------
 admin    | xxx    |   0 |   0 | Admin     | 111-222-3333 |            | /root       | /bin/dash
 bob      | xxx    |   1 |   1 | Bob       | 123-456-7890 |            | /home/bob   | /bin/zsh
 alice    | xxx    |   2 |   1 | Alice     | 098-765-4321 |            | /home/alice | /bin/zsh
(3 rows)

-- 测试Alice能做什么
postgres=&gt; set role alice;
SET
postgres=&gt; table passwd;
ERROR:  permission denied for relation passwd
postgres=&gt; select username,real_name,home_phone,extra_info,home_dir,shell from passwd;
 username | real_name |  home_phone  | extra_info | home_dir    |   shell
----------+-----------+--------------+------------+-------------+-----------
 admin    | Admin     | 111-222-3333 |            | /root       | /bin/dash
 bob      | Bob       | 123-456-7890 |            | /home/bob   | /bin/zsh
 alice    | Alice     | 098-765-4321 |            | /home/alice | /bin/zsh
(3 rows)

postgres=&gt; update passwd set username = 'joe';
ERROR:  permission denied for relation passwd
-- Alice可以修改她的real_name，但是没有其他人
postgres=&gt; update passwd set real_name = 'Alice Doe';
UPDATE 1
postgres=&gt; update passwd set real_name = 'John Doe' where username = 'admin';
UPDATE 0
postgres=&gt; update passwd set shell = '/bin/xx';
ERROR:  new row violates WITH CHECK OPTION for "passwd"
postgres=&gt; delete from passwd;
ERROR:  permission denied for relation passwd
postgres=&gt; insert into passwd (username) values ('xxx');
ERROR:  permission denied for relation passwd
-- Alice can change her own password; RLS silently prevents updating other rows
postgres=&gt; update passwd set pwhash = 'abc';
UPDATE 1
</programlisting>

  <para>
   引用完整性检查，比如唯一或者主键约束和外键引用，总是绕开行安全性确保
   维持数据完整性。当开发模式时必须小心，
   并且行级策略通过引用完整性检查避开<quote>隐蔽通道</>泄露信息。 
  </para>

  <para>
   在某些情况下重要的是要确保行安全不被应用。
   例如，当备份时，它可能是灾难性的，如果行安全默默地导致从备份中省略了一些行。
   在这种情况下,你可以设置<xref linkend="guc-row-security">配置参数为
   <literal>off</>。这本身不绕开行安全；如果任何
   查询的结果可以过滤策略，那么它会抛出一个错误。错误的原因可以调查并且修复。
  </para>

  <para>
   在上面的例子中，策略表达式只考虑当前被访问或者被更新行中的值。
   这是最简单和表现最好的情况下；如果可能，最好设计行安全应用程序以这种方式工作。
   如果有必要咨询其它行或其它表采取策略决定，可以通过策略表达式中使用子-<command>SELECT</>,
   或包含<command>SELECT</>的函数完成。
   然而要注意这样的访问可以创建竞态条件，如果不小心可能造成信息泄漏。
   作为一个例子，考虑下面的表设计：
  </para>

<programlisting>
-- 权限组定义
CREATE TABLE groups (group_id int PRIMARY KEY,
                     group_name text NOT NULL);

INSERT INTO groups VALUES
  (1, 'low'),
  (2, 'medium'),
  (5, 'high');

GRANT ALL ON groups TO alice;  -- alice is the administrator
GRANT SELECT ON groups TO public;

-- 用户的权限级别定义
CREATE TABLE users (user_name text PRIMARY KEY,
                    group_id int NOT NULL REFERENCES groups);

INSERT INTO users VALUES
  ('alice', 5),
  ('bob', 2),
  ('mallory', 2);

GRANT ALL ON users TO alice;
GRANT SELECT ON users TO public;

-- 保持受保护信息的表
CREATE TABLE information (info text,
                          group_id int NOT NULL REFERENCES groups);

INSERT INTO information VALUES
  ('barely secret', 1),
  ('slightly secret', 2),
  ('very secret', 5);

ALTER TABLE information ENABLE ROW LEVEL SECURITY;

-- 行对于安全group_id大于或者等于行的group_id的用户是可见的/可更新的
CREATE POLICY fp_s ON information FOR SELECT
  USING (group_id &lt;= (SELECT group_id FROM users WHERE user_name = current_user));
CREATE POLICY fp_u ON information FOR UPDATE
  USING (group_id &lt;= (SELECT group_id FROM users WHERE user_name = current_user));

-- 我们只依赖RLS保护信息表
GRANT ALL ON information TO public;
</programlisting>

  <para>
   现在假设<literal>alice</>想要改变<quote>秘密</>信息，
   但是决定<literal>mallory</>不信任行的新内容，因此：
  </para>

<programlisting>
BEGIN;
UPDATE users SET group_id = 1 WHERE user_name = 'mallory';
UPDATE information SET info = 'secret from mallory' WHERE group_id = 2;
COMMIT;
</programlisting>

  <para>
   看起来安全；在<literal>mallory</>中可以<quote>从mallory查看秘密</>字符串。
   然而，这有个竞态条件。如果<literal>mallory</>是同时执行的，即
<programlisting>
SELECT * FROM information WHERE group_id = 2 FOR UPDATE;
</programlisting>
   并且事务是<literal>READ COMMITTED</>模式，对于她有可能看到<quote>来自mallory的秘密</>。
   如果她的事务在<literal>alice</>之后到达<structname>information</>行，则会发生。
   他阻塞等待<literal>alice</>事务提交，
   那么获取由于<literal>FOR UPDATE</>子句更新的行内容。然而，它确实<emphasis>没有</>
   从<structname>users</>为隐含的<command>SELECT</>抓取更新行，
   因为子-<command>SELECT</>没有<literal>FOR UPDATE</>；相反<structname>users</>行读取查询开始时采取的快照。
   因此，策略表达式测试<literal>mallory</>权限级别的旧值，并且允许她查看更新的行。
  </para>

  <para>
   有几种方法可以解决这个问题。一个简单的答案是在子<command>SELECT</>行安全策略中使用
<literal>SELECT ... FOR SHARE</>。然而，这需要授予引用表（这里<structname>users</>）的
受影响用户<literal>UPDATE</>权限，这可能是不可取的。
（但是可以应用另一个行安全策略以防止它们实际上行使这一
特权；或子<command>SELECT</>可以嵌入到一个安全
定义函数中。）同时，行共享锁在引用表上大并发使用可能会造成性能问题，
尤其是如果更新它是频繁的。
如果引用表更新不频繁，另一个解决方案是当更新时在引用表上采取排它锁。
所以没有并发事务会检查旧的行值。
或者提交引用表的更新之后，并在修改依赖于新安全方法之前只是等待所有并发事务结束。 
  </para>

  <para>
   更多详细信息参阅 <xref linkend="sql-createpolicy">和<xref linkend="sql-altertable">。
  </para>

 </sect1> 
 
 <sect1 id="ddl-schemas">
  <title>模式</title>

  <indexterm zone="ddl-schemas">
   <primary>schema</primary>
  </indexterm>

  <para>
   一个<productname>PostgreSQL</productname>数据库集簇中包含一个或更多命名的数据库。用户和用户组被整个集簇共享，但没有其他数据在数据库之间共享。任何给定客户端连接只能访问在连接中指定的数据库中的数据。
  </para>

  <note>
   <para>
    一个集簇的用户并不必拥有访问集簇中每一个数据库的权限。用户名的共享意味着不可能在同一个集簇中出现重名的不同用户，例如两个数据库中都有叫<literal>joe</>的用户。但系统可以被配置为只允许<literal>joe</>访问某些数据库。
   </para>
  </note>

  <para>
   一个数据库包含一个或多个命名<firstterm>模式</>，模式中包含着表。模式还包含其他类型的命名对象，包括数据类型、函数和操作符。相同的对象名称可以被用于不同的模式中二不会出现冲突，例如<literal>schema1</>和<literal>myschema</>都可以包含名为<literal>mytable</>的表。和数据库不同，模式并不是被严格地隔离：一个用户可以访问他所连接的数据库中的所有模式内的对象，只要他有足够的权限。
  </para>

  <para>
   下面是一些使用模式的原因：

   <itemizedlist>
    <listitem>
     <para>
      允许多个用户使用一个数据库并且不会互相干扰。
     </para>
    </listitem>

    <listitem>
     <para>
      将数据库对象组织成逻辑组以便更容易管理。
     </para>
    </listitem>

    <listitem>
     <para>
      第三方应用的对象可以放在独立的模式中，这样它们就不会与其他对象的名称发生冲突。     </para>
    </listitem>
   </itemizedlist>

   模式类似于操作系统层的目录，但是模式不能嵌套。
  </para>

  <sect2 id="ddl-schemas-create">
   <title>创建模式</title>

   <indexterm zone="ddl-schemas-create">
    <primary>schema</primary>
    <secondary>creating</secondary>
   </indexterm>

   <para>
    要创建一个模式，可使用<xref linkend="sql-createschema">命令，并且给出选择的模式名称。例如：
<programlisting>
CREATE SCHEMA myschema;
</programlisting>
   </para>

   <indexterm>
    <primary>qualified name</primary>
   </indexterm>

   <indexterm>
    <primary>name</primary>
    <secondary>qualified</secondary>
   </indexterm>

   <para>
    在一个模式中创建或访问对象，需要使用由模式名和表名构成的<firstterm>限定名</>，模式名和表名之间以点号分隔：
<synopsis>
<replaceable>模式</><literal>.</><replaceable>表</>
</synopsis>
    在任何需要一个表名的地方都可以这样用，包括表修改命令和后续章节要讨论的数据访问命令（为了简洁我们在这里只谈到表，但是这种方式对其他类型的命名对象同样有效，例如类型和函数）。
   </para>

   <para>
    事实上，还有更加通用的语法：
<synopsis>
<replaceable>数据库</><literal>.</><replaceable>模式</><literal>.</><replaceable>表</>
</synopsis>
    也可以使用，但是目前它只是在<foreignphrase>形式上</>与SQL标准兼容。如果我们写一个数据库名称，它必须是我们正在连接的数据库。
   </para>

   <para>
    因此，如果要在一个新模式中创建一个表，可用：
<programlisting>
CREATE TABLE myschema.mytable (
 ...
);
</programlisting>
   </para>

   <indexterm>
    <primary>schema</primary>
    <secondary>removing</secondary>
   </indexterm>

   <para>
    要删除一个为空的模式（其中的所有对象已经被删除），可用：
<programlisting>
DROP SCHEMA myschema;
</programlisting>
    要删除一个模式以及其中包含的所有对象，可用：
<programlisting>
DROP SCHEMA myschema CASCADE;
</programlisting>
    有关于此的更一般的机制请参见<xref linkend="ddl-depend">。
   </para>

   <para>
    我们常常希望创建一个由其他人所拥有的模式（因为这是将用户动作限制在良定义的名字空间中的方法之一）。其语法是：
<programlisting>
CREATE SCHEMA <replaceable>schemaname</replaceable> AUTHORIZATION <replaceable>username</replaceable>;
</programlisting>
    我们甚至可以省略模式名称，在此种情况下模式名称将会使用用户名，参见<xref linkend="ddl-schemas-patterns">。
   </para>

   <para>
    以<literal>pg_</>开头的模式名被保留用于系统目的，所以不能被用户所创建。
   </para>
  </sect2>

  <sect2 id="ddl-schemas-public">
   <title>公共模式</title>

   <indexterm zone="ddl-schemas-public">
    <primary>schema</primary>
    <secondary>public</secondary>
   </indexterm>

   <para>
    在前面的小节中，我们创建的表都没有指定任何模式名称。默认情况下这些表（以及其他对象）会自动的被放入一个名为<quote>public</quote>的模式中。任何新数据库都包含这样一个模式。因此，下面的命令是等效的：
<programlisting>
CREATE TABLE products ( ... );
</programlisting>
    以及：
<programlisting>
CREATE TABLE public.products ( ... );
</programlisting>
   </para>
  </sect2>

  <sect2 id="ddl-schemas-path">
   <title>模式搜索路径</title>

   <indexterm>
    <primary>search path</primary>
   </indexterm>

   <indexterm>
    <primary>unqualified name</primary>
   </indexterm>

   <indexterm>
    <primary>name</primary>
    <secondary>unqualified</secondary>
   </indexterm>

   <para>
    限定名写起来很冗长，通常最好不要把一个特定模式名拉到应用中。因此，表名通常被使用<firstterm>非限定名</>来引用，它只由表名构成。系统将沿着一条<firstterm>搜索路径</>来决定该名称指的是哪个表，搜索路径是一个进行查看的模式列表。 搜索路径中第一个匹配的表将被认为是所需要的。如果在搜索路径中没有任何匹配，即使在数据库的其他模式中存在匹配的表名也将会报告一个错误。
   </para>

   <indexterm>
    <primary>schema</primary>
    <secondary>current</secondary>
   </indexterm>

   <para>
    搜索路径中的第一个模式被称为当前模式。除了是第一个被搜索的模式外，如果<command>CREATE TABLE</>命令没有指定模式名，它将是新创建表所在的模式。
   </para>

   <indexterm>
    <primary><varname>search_path</varname>配置参数</primary>
   </indexterm>

   <para>
    要显示当前搜索路径，使用下面的命令：
<programlisting>
SHOW search_path;
</programlisting>
    在默认设置下这将返回：
<screen>
 search_path
--------------
 "$user",public
</screen>
    第一个元素说明一个和当前用户同名的模式会被搜索。如果不存在这个模式，该项将被忽略。第二个元素指向我们已经见过的公共模式。
   </para>

   <para>
    搜索路径中的第一个模式是创建新对象的默认存储位置。这就是默认情况下对象会被创建在公共模式中的原因。当对象在任何其他没有模式限定的环境中被引用（表修改、数据修改或查询命令）时，搜索路径将被遍历直到一个匹配对象被找到。因此，在默认配置中，任何非限定访问将只能指向公共模式。
   </para>

   <para>
    要把新模式放在搜索路径中，我们可以使用：
<programlisting>
SET search_path TO myschema,public;
</programlisting>
    （我们在这里省略了<literal>$user</literal>，因为我们并不立即需要它）。然后我们可以该表而无需使用模式限定：
<programlisting>
DROP TABLE mytable;
</programlisting>
    同样，由于<literal>myschema</literal>是路径中的第一个元素，新对象会被默认创建在其中。
   </para>

   <para>
    我们也可以这样写：
<programlisting>
SET search_path TO myschema;
</programlisting>
    这样我们在没有显式限定时再也不必去访问公共模式了。公共模式没有什么特别之处，它只是默认存在而已，它也可以被删除。
   </para>

   <para>
    其他操作模式搜索路径的方法请见<xref linkend="functions-info">。
   </para>

   <para>
    搜索路径对于数据类型名称、函数名称和操作符名称的作用与表名一样。数据类型和函数名称可以使用和表名完全相同的限定方式。如果我们需要在一个表达式中写一个限定的操作符名称，我们必须写成一种特殊的形式：
<synopsis>
<literal>OPERATOR(</><replaceable>schema</><literal>.</><replaceable>operator</><literal>)</>
</synopsis>
    这是为了避免句法歧义。例如：
<programlisting>
SELECT 3 OPERATOR(pg_catalog.+) 4;
</programlisting>
    实际上我们通常都会依赖于搜索路径来查找操作符，因此没有必要去写如此“丑陋”的东西。
   </para>
  </sect2>

  <sect2 id="ddl-schemas-priv">
   <title>模式和权限</title>

   <indexterm zone="ddl-schemas-priv">
    <primary>privilege</primary>
    <secondary sortas="schemas">for schemas</secondary>
   </indexterm>

   <para>
    默认情况下，用户不能访问不属于他们的模式中的任何对象。要允许这种行为，模式的拥有者必须在该模式上授予<literal>USAGE</literal>权限。为了允许用户使用模式中的对象，可能还需要根据对象授予额外的权限。
   </para>

   <para>
    一个用户也可以被允许在其他某人的模式中创建对象。要允许这种行为，模式上的<literal>CREATE</literal>权限必须被授予。注意在默认情况下，所有人都拥有在<literal>public</literal>模式上的<literal>CREATE</literal>和<literal>USAGE</literal>权限。这使得用户能够连接到一个给定数据库并在它的<literal>public</literal>模式中创建对象。如果不希望允许这样，可以撤销该权限：
<programlisting>
REVOKE CREATE ON SCHEMA public FROM PUBLIC;
</programlisting>
    （第一个<quote>public</quote>是模式，第二个<quote>public</quote>指的是 <quote>每一个用户</quote>。第一种是一个标识符，第二种是一个关键词，所以两者的大小写不同。请回想<xref linkend="sql-syntax-identifiers">中的指导方针。）
   </para>
  </sect2>

  <sect2 id="ddl-schemas-catalog">
   <title>系统目录模式</title>

   <indexterm zone="ddl-schemas-catalog">
    <primary>system catalog</primary>
    <secondary>schema</secondary>
   </indexterm>

   <para>
    除<literal>public</>和用户创建的模式之外，每一个数据库还包括一个<literal>pg_catalog</>模式，它包含了系统表和所有内建的数据类型、函数以及操作符。<literal>pg_catalog</>总是搜索路径的一个有效部分。如果没有在路径中显式地包括该模式，它将在路径中的模式<emphasis>之前</>被搜索。这保证了内建的名称总是能被找到。然而，如果我们希望用用户定义的名称重载内建的名称，可以显式的将<literal>pg_catalog</>放在搜索路径的末尾。
   </para>

   <para>
    由于系统表名称以<literal>pg_</>开头，最好还是避免使用这样的名称，以避免和未来新版本中
    可能出现的系统表名发生冲突。系统表将继续采用以<literal>pg_</>开头的方式，这样它们不会
    与非限制的用户表名称冲突。
   </para>
  </sect2>

  <sect2 id="ddl-schemas-patterns">
   <title>惯用法</title>

   <para>
    模式可以被用来以多种方式组织我们的数据。在默认配置下，一些常见的用法是：
    <itemizedlist>
     <listitem>
      <para>
       如果我们不创建任何模式则所有用户会隐式地访问公共模式。这就像根本不存在模式一样。当数据库中只有一个用户或者少量合作用户时，推荐使用这种配置。这种配置使得我们很容易从没有模式的环境中转换过来。
      </para>
     </listitem>

     <listitem>
      <para>
       我们可以为每一个用户创建与它同名的模式。回想一下，默认的搜索路径以<literal>$user</literal>开始，它将会被解析成用户名。因此，如果每一个用户有一个独立的模式，它们将会默认访问自己的模式。
      </para>

      <para>
       如果我们使用这种配置，则我们可能也希望撤销到公共模式的访问（或者把它也一起删除），这样用户被真正地限制在他们自己的模式中。
      </para>
     </listitem>

     <listitem>
      <para>
       要安装共享的应用（任何人都可以用的表、由第三方提供的附加函数等），将它们放在独立的模式中。记住要授予适当的权限以允许其他用户访问它们。然后用户就可以使用带模式名的限定名称来引用这些附加对象，或者他们可以把附加模式放入到他们的搜索路径中。
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </sect2>

  <sect2 id="ddl-schemas-portability">
   <title>可移植性</title>

   <para>
    在SQL标准中，在由不同用户拥有的同一个模式中的对象是不存在的。此外，某些实现不允许创建与拥有者名称不同名的模式。事实上，在那些仅实现了标准中基本模式支持的数据库中，模式和用户的概念是等同的。因此，很多用户认为限定名称实际上是由<literal><replaceable>username</>.<replaceable>tablename</></literal>组成的。如果我们为每一个用户都创建了一个模式，<productname>PostgreSQL</productname>实际也是这样认为的。
   </para>

   <para>
    同样，在SQL标准中也没有<literal>public</>模式的概念。为了最大限度的与标准一致，我们不应使用（甚至是删除）<literal>public</>模式。
   </para>

   <para>
    当然，某些SQL数据库系统可能根本没有实现模式，或者提供允许跨数据库访问的名字空间。如果需要使用这样一些系统，最好不要使用模式。
   </para>
  </sect2>
 </sect1>

 <sect1 id="ddl-inherit">
  <title>继承</title>

  <indexterm>
   <primary>inheritance</primary>
  </indexterm>

  <indexterm>
   <primary>table</primary>
   <secondary>inheritance</secondary>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname>实现了表继承，这对数据库设计者来说是一种有用的工具（SQL:1999及其后的版本定义了一种类型继承特性，但和这里介绍的继承有很大的不同）。
  </para>

  <para>
   让我们从一个例子开始：假设我们要为城市建立一个数据模型。每一个州有很多城市，但是只有一个首府。我们希望能够快速地检索任何特定州的首府城市。这可以通过创建两个表来实现：一个用于州首府，另一个用于不是首府的城市。然而，当我们想要查看一个城市的数据（不管它是不是一个首府）时会发生什么？继承特性将有助于解决这个问题。我们可以将<structname>capitals</structname>表定义为继承自<structname>cities</structname>表：

<programlisting>
CREATE TABLE cities (
    name            text,
    population      float,
    altitude        int     -- in feet
);

CREATE TABLE capitals (
    state           char(2)
) INHERITS (cities);
</programlisting>

   在这种情况下，<structname>capitals</>表<firstterm>继承</>了它的父表<structname>cities</>的所有列。州首府还有一个额外的列<structfield>state</>用来表示它所属的州。
  </para>

  <para>
   在<productname>PostgreSQL</productname>中，一个表可以从0个或者多个其他表继承，而对一个表的查询则可以引用一个表的所有行或者该表的所有行加上它所有的后代表。默认情况是后一种行为。例如，下面的查询将查找所有海拔高于500尺的城市的名称，包括州首府：

<programlisting>
SELECT name, altitude
    FROM cities
    WHERE altitude &gt; 500;
</programlisting>

   对于来自<productname>PostgreSQL</productname>教程（见<xref linkend="tutorial-sql-intro">）的例子数据，它将返回：

<programlisting>
   name    | altitude
-----------+----------
 Las Vegas |     2174
 Mariposa  |     1953
 Madison   |      845
</programlisting>
  </para>

  <para>
   在另一方面，下面的查询将找到海拔超过500尺且不是州首府的所有城市：

<programlisting>
SELECT name, altitude
    FROM ONLY cities
    WHERE altitude &gt; 500;

   name    | altitude
-----------+----------
 Las Vegas |     2174
 Mariposa  |     1953
</programlisting>
  </para>

  <para>
   这里的<literal>ONLY</literal>关键词指示查询只被应用于<structname>cities</structname>上，而其他在继承层次中位于<structname>cities</structname>之下的其他表都不会被该查询涉及。很多我们已经讨论过的命令（如<command>SELECT</command>、<command>UPDATE</command>和<command>DELETE</command>）都支持<literal>ONLY</literal>关键词。
  </para>

  <para>
   我们也可以在表名后写上一个<literal>*</>来显式地将后代表包括在查询范围内：

<programlisting>
SELECT name, altitude
    FROM cities*
    WHERE altitude &gt; 500;
</programlisting>

   <literal>*</>并不是必须的，因为它对应的行为是默认的（除非改变<xref linkend="guc-sql-inheritance">配置选项的设置）。但是书写<literal>*</>有助于强调会有附加表被搜索。
  </para>

  <para>
   在某些情况下，我们可能希望知道一个特定行来自于哪个表。每个表中的系统列<structfield>tableoid</structfield>可以告诉我们行来自于哪个表：

<programlisting>
SELECT c.tableoid, c.name, c.altitude
FROM cities c
WHERE c.altitude &gt; 500;
</programlisting>

   将会返回：

<programlisting>
 tableoid |   name    | altitude
----------+-----------+----------
   139793 | Las Vegas |     2174
   139793 | Mariposa  |     1953
   139798 | Madison   |      845
</programlisting>

   （如果重新生成这个结果，可能会得到不同的OID数字。）通过与<structname>pg_class</>进行连接可以看到实际的表名：

<programlisting>
SELECT p.relname, c.name, c.altitude
FROM cities c, pg_class p
WHERE c.altitude &gt; 500 AND c.tableoid = p.oid;
</programlisting>

   将会返回：

<programlisting>
 relname  |   name    | altitude
----------+-----------+----------
 cities   | Las Vegas |     2174
 cities   | Mariposa  |     1953
 capitals | Madison   |      845
</programlisting>
  </para>

<para>
   另一种方法是使用<type>regclass</>伪类型获得相同效果，这将象征性地输出表OID：
<programlisting>
SELECT c.tableoid::regclass, c.name, c.altitude
FROM cities c
WHERE c.altitude &gt; 500;
</programlisting>
  </para>  
  
  <para>
   继承不会自动地将来自<command>INSERT</command>或<command>COPY</command>命令的数据传播到继承层次中的其他表中。在我们的例子中，下面的<command>INSERT</command>语句将会失败：
<programlisting>
INSERT INTO cities (name, population, altitude, state)
VALUES ('Albany', NULL, NULL, 'NY');
</programlisting>
   我们也许希望数据能被以某种方式被引入到<structname>capitals</structname>表中，但是这不会发生：<command>INSERT</command>总是向指定的表中插入。在某些情况下，可以通过使用一个规则（见<xref linkend="rules">）来将插入动作重定向。但是这对上面的情况并没有帮助，因为<structname>cities</>表根本就不包含<structfield>state</>列，因而这个命令将在触发规则之前就被拒绝。
  </para>

  <para>
   父表上的所有检查约束和非空约束都将自动被它的后代所继承。其他类型的约束（唯一、主键和外键约束）则不会被继承。
  </para>

  <para>
   一个表可以从超过一个的父表继承，在这种情况下它拥有父表们所定义的列的并集。任何定义在子表上的列也会被加入到其中。如果在这个集合中出现重名列，那么这些列将被<quote>合并</>，这样在子表中只会有一个这样的列。重名列能被合并的前提是这些列必须具有相同的数据类型，否则会导致错误。合并后的列将会从被合并的列中复制所有的检查约束，并且如果其中一个被合并的列上有非空约束，合并后的列也会被标记为非空。
  </para>

  <para>
   表继承通常是在子表被创建时建立，使用<xref linkend="sql-createtable">语句的<literal>INHERITS</>子句。一个已经被创建的表也可以另外一种方式增加一个新的父亲关系，使用<xref linkend="sql-altertable">的<literal>INHERIT</literal>变体。要这样做，新的子表必须已经包括和父表相同名称和数据类型的列。子表还必须包括和父表相同的检查约束和检查表达式。相似地，一个继承链接也可以使用<command>ALTER TABLE</>的 <literal>NO INHERIT</literal>变体从一个子表中移除。动态增加和移除继承链接可以用于实现表划分（见<xref linkend="ddl-partitioning">）。
  </para>

  <para>
   一种创建一个未来将被用做子女的新表的方法是在<command>CREATE
   TABLE</command>中使用<literal>LIKE</literal>子句。这将创建一个和源表具有相同列的新表。如果源表上定义有任何<literal>CHECK</literal>约束，<literal>LIKE</literal>的<literal>INCLUDING CONSTRAINTS</literal>选项可以用来让新的子表也包含和父表相同的约束。
  </para>

  <para>
   当有任何一个子表存在时，父表不能被删除。当子表的列或者检查约束继承于父表时，它们也不能被删除或修改。如果希望移除一个表和它的所有后代，一种简单的方法是使用<literal>CASCADE</literal>选项删除父表。
  </para>

  <para>
   <xref linkend="sql-altertable">将会把列的数据定义或检查约束上的任何变化沿着继承层次向下传播。同样，删除被其他表依赖的列只能使用<literal>CASCADE</literal>选项。<command>ALTER TABLE</command>对于重名列的合并和拒绝遵循与<command>CREATE TABLE</command>同样的规则。
  </para>

  <para>
   请注意表访问权限的处理方式。查询一个父表将自动地访问子表中的数据而不需要进一步的访问权限检查。这体现了子表的数据（也）在父表里存在。但是，访问子表并不是自动被允许的且可能需要进一步被授予权限。
  </para>
  
  <para>
   外表（参见<xref linkend="ddl-foreign-data">）也可以作为继承层次结构的一部分，
   无论是作为父表或者子表，正如普通表一样。
   如果外表是继承层次结构的一部分，那么任何外表不支持的操作在整个层次结构中也不被支持。
  </para>
  
 <sect2 id="ddl-inherit-caveats">
  <title>警告</title>

  <para>
   注意并非所有的SQL命令都能工作在继承层次上。用于数据查询、数据修改或模式修改（例如<literal>SELECT</literal>、<literal>UPDATE</literal>、<literal>DELETE</literal>、大部分<literal>ALTER TABLE</literal>的变体，但<literal>INSERT</literal>或<literal>ALTER TABLE ... RENAME</literal>不在此列）的命令会默认将子表包含在内并且支持<literal>ONLY</literal>记号来排除子表。负责数据库维护和调整的命令（如<literal>REINDEX</literal>、<literal>VACUUM</literal>）只工作在独立的、物理的表上并且不支持在继承层次上的递归。每个命令相应的行为请参见它们的参考页（<xref linkend="sql-commands">）。
  </para>

  <para>
   继承特性的一个严肃的限制是索引（包括唯一约束）和外键约束值应用在单个表上而非它们的继承子女。在外键约束的引用端和被引用端都是这样。因此，按照上面的例子：

   <itemizedlist>
    <listitem>
     <para>
      如果我们声明<structname>cities</>.<structfield>name</>为<literal>UNIQUE</>或者<literal>PRIMARY KEY</>，这将不会阻止<structname>capitals</>表中拥有和<structname>cities</>中城市同名的行。而且这些重复的行将会默认显示在<structname>cities</>的查询中。事实上，<structname>capitals</>在默认情况下是根本不能拥有唯一约束的，并且因此能够包含多个同名的行。我们可以为<structname>capitals</>增加一个唯一约束，但这无法阻止相对于<structname>cities</>的重复。
     </para>
    </listitem>

    <listitem>
     <para>
      相似地，如果我们指定<structname>cities</>.<structfield>name</> <literal>REFERENCES</>某个其他表，该约束不会自动地传播到<structname>capitals</>。在此种情况下，我们可以变通地在<structname>capitals</>上手工创建一个相同的<literal>REFERENCES</>约束。
     </para>
    </listitem>

    <listitem>
     <para>
      指定另一个表的列<literal>REFERENCES cities(name)</>将允许其他表包含城市名称，但不会包含首府名称。这对于这个例子不是一个好的变通方案。
     </para>
    </listitem>
   </itemizedlist>

   这些不足可能还将存在于某些未来的发布中，但是同时在决定继承是否对我们的应用有用时需要相当小心。
  </para>

   </sect2>
  </sect1>

  <sect1 id="ddl-partitioning">
   <title>划分</title>

   <indexterm>
    <primary>partitioning</primary>
   </indexterm>

   <indexterm>
    <primary>table</primary>
    <secondary>partitioning</secondary>
   </indexterm>

   <para>
    <productname>PostgreSQL</productname>支持基本的表划分。本小节介绍为何以及怎样把划分实现为数据库设计的一部分。
   </para>

   <sect2 id="ddl-partitioning-overview">
     <title>概述</title>

   <para>
    划分指的是将逻辑上的一个大表分成一些小的物理上的片。划分有很多益处：
   <itemizedlist>
    <listitem>
     <para>
      在某些情况下查询性能能够显著提升，特别是当那些访问压力大的行在一个分区或者少数几个分区时。划分可以取代索引的主导列、减小索引尺寸以及使索引中访问压力大的部分更有可能被放在内存中。
     </para>
    </listitem>

    <listitem>
     <para>
      当查询或更新访问一个分区的大部分行时，可以通过该分区上的一个顺序扫描来取代分散到整个表上的索引和随机访问，这样可以改善性能。
     </para>
    </listitem>

    <listitem>
     <para>
      如果需求计划使用划分设计，可以通过增加或移除分区来完成批量载入和删除。<command>ALTER TABLE NO INHERIT</>和<command>DROP TABLE</>都远快于一个批量操作。这些命令也完全避免了由批量<command>DELETE</>造成的<command>VACUUM</command>负载。
     </para>
    </listitem>

    <listitem>
     <para>
      很少使用的数据可以被迁移到便宜且较慢的存储介质上。
     </para>
    </listitem>
   </itemizedlist>

    当一个表非常大时，划分所带来的好处是非常值得的。一个表何种情况下会从划分获益取决于应用，一个经验法则是当表的尺寸超过了数据库服务器物理内存时，划分会为表带来好处。
   </para>

   <para>
    目前，<productname>PostgreSQL</productname>支持通过表继承来进行划分。每一个分区被创建为父表的一个子表。父表本身通常是空的，它的存在仅仅为了表示整个数据集。在尝试建立划分之前，应该先熟悉继承（参见<xref linkend="ddl-inherit">）。
   </para>

   <para>
    在<productname>PostgreSQL</productname>中可以实现下列形式的划分：

    <variablelist>
     <varlistentry>
      <term>范围划分</term>

      <listitem>
       <para>
        表被根据一个关键列或一组列划分为<quote>范围</quote>，不同的分区的范围之间没有重叠。例如，我们可以根据日期范围划分，或者根据特定业务对象的标识符划分。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>列表划分</term>

      <listitem>
       <para>
        通过显式地列出每一个分区中出现的键值来划分表。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
   </sect2>

   <sect2 id="ddl-partitioning-implementation">
     <title>实现划分</title>

    <para>
     要建立一个划分的表，可以这样做：
     <orderedlist spacing="compact">
      <listitem>
       <para>
        创建<quote>主</quote>表，所有的分区都将继承它。
       </para>
       <para>
        这个表将不会包含任何数据。不要在这个表上定义任何检查约束，除非准备将它们应用到所有分区。同样也不需要定义任何索引或者唯一约束。
       </para>
      </listitem>

      <listitem>
       <para>
        创建一些继承于主表的<quote>子</quote>表。通常，这些表不会在从主表继承的列集中增加任何列。
       </para>

       <para>
        我们将这些子表认为是分区，尽管它们在各方面来看普通的<productname>PostgreSQL</>表
        (或者可能外表)。
       </para>
      </listitem>

      <listitem>
       <para>
        为分区表增加表约束以定义每个分区中允许的键值。
       </para>

       <para>
        典型的例子是：
<programlisting>
CHECK ( x = 1 )
CHECK ( county IN ( 'Oxfordshire', 'Buckinghamshire', 'Warwickshire' ))
CHECK ( outletID &gt;= 100 AND outletID &lt; 200 )
</programlisting>
        要确保这些约束能够保证在不同分区所允许的键值之间不存在重叠。设置范围约束时一种常见的错误是：
<programlisting>
CHECK ( outletID BETWEEN 100 AND 200 )
CHECK ( outletID BETWEEN 200 AND 300 )
</programlisting>
        这是错误的，因为键值200并没有被清楚地分配到某一个分区。
       </para>

       <para>
        注意在语法上范围划分和列表划分没有区别，这些术语只是为了描述方便而存在。
       </para>
      </listitem>

      <listitem>
       <para>
        对于每一个分区，在关键列上创建一个索引，并创建其他我们所需要的索引（关键索引并不是严格必要的，但是在大部分情况下它都是有用的。如果我们希望键值是唯一的，则我们还要为每一个分区创建一个唯一或者主键约束。）。
       </para>
      </listitem>

      <listitem>
       <para>
        还可以有选择地定义一个触发器或者规则将在主表上的数据插入重定向到合适的分区上。
       </para>
      </listitem>

      <listitem>
       <para>
        确保在<filename>postgresql.conf</>中<xref linkend="guc-constraint-exclusion">配置参数没有被禁用。如果它被禁用，查询将不会被按照期望的方式优化。
       </para>
      </listitem>

     </orderedlist>
    </para>

    <para>
     例如，假设我们正在为一个大型的冰淇淋公司构建一个数据库。该公司测量每天在每一个区域的最高气温以及冰淇淋销售。在概念上，我们想要一个这样的表：

<programlisting>
CREATE TABLE measurement (
    city_id         int not null,
    logdate         date not null,
    peaktemp        int,
    unitsales       int
);
</programlisting>

     由于该表的主要用途是为管理层提供在线报告，我们知道大部分查询将只会访问上周、上月或者上季度的数据。为了减少需要保存的旧数据的量，我们决定只保留最近3年的数据。在每一个月的开始，我们将删除最老的一个月的数据。
    </para>

    <para>
     在这种情况下，我们可以使用划分来帮助我们满足对于测量表的所有不同需求。按照上面所勾勒的步骤，划分可以这样来建立：
    </para>

    <para>
     <orderedlist spacing="compact">
      <listitem>
       <para>
        主表是<structname>measurement</>表，完全按照以上的方式声明。
       </para>
      </listitem>

      <listitem>
       <para>
        下一步我们为每一个活动月创建一个分区：

<programlisting>
CREATE TABLE measurement_y2006m02 ( ) INHERITS (measurement);
CREATE TABLE measurement_y2006m03 ( ) INHERITS (measurement);
...
CREATE TABLE measurement_y2007m11 ( ) INHERITS (measurement);
CREATE TABLE measurement_y2007m12 ( ) INHERITS (measurement);
CREATE TABLE measurement_y2008m01 ( ) INHERITS (measurement);
</programlisting>

        每一个分区自身都是完整的表，但是它们的定义都是从<structname>measurement</>表继承而来。
       </para>

       <para>
        这解决了我们的一个问题：删除旧数据。每个月，我们所需要做的是在最旧的子表上执行一个<command>DROP TABLE</command>命令并为新一个月的数据创建一个新的子表。
       </para>
      </listitem>

      <listitem>
       <para>
        我们必须提供不重叠的表约束。和前面简单地创建分区表不同，实际的表创建脚本应该是：

<programlisting>
CREATE TABLE measurement_y2006m02 (
    CHECK ( logdate &gt;= DATE '2006-02-01' AND logdate &lt; DATE '2006-03-01' )
) INHERITS (measurement);
CREATE TABLE measurement_y2006m03 (
    CHECK ( logdate &gt;= DATE '2006-03-01' AND logdate &lt; DATE '2006-04-01' )
) INHERITS (measurement);
...
CREATE TABLE measurement_y2007m11 (
    CHECK ( logdate &gt;= DATE '2007-11-01' AND logdate &lt; DATE '2007-12-01' )
) INHERITS (measurement);
CREATE TABLE measurement_y2007m12 (
    CHECK ( logdate &gt;= DATE '2007-12-01' AND logdate &lt; DATE '2008-01-01' )
) INHERITS (measurement);
CREATE TABLE measurement_y2008m01 (
    CHECK ( logdate &gt;= DATE '2008-01-01' AND logdate &lt; DATE '2008-02-01' )
) INHERITS (measurement);
</programlisting>
       </para>
      </listitem>

      <listitem>
       <para>
        我们可能在关键列上也需要索引：

<programlisting>
CREATE INDEX measurement_y2006m02_logdate ON measurement_y2006m02 (logdate);
CREATE INDEX measurement_y2006m03_logdate ON measurement_y2006m03 (logdate);
...
CREATE INDEX measurement_y2007m11_logdate ON measurement_y2007m11 (logdate);
CREATE INDEX measurement_y2007m12_logdate ON measurement_y2007m12 (logdate);
CREATE INDEX measurement_y2008m01_logdate ON measurement_y2008m01 (logdate);
</programlisting>

        在这里我们选择不增加更多的索引。
       </para>
      </listitem>

      <listitem>
       <para>
        我们希望我们的应用能够使用<literal>INSERT INTO measurement ...</>并且数据将被重定向到合适的分区表。我们可以通过为主表附加一个合适的触发器函数来实现这一点。如果数据将只被增加到最后一个分区，我们可以使用一个非常简单的触发器函数：

<programlisting>
CREATE OR REPLACE FUNCTION measurement_insert_trigger()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO measurement_y2008m01 VALUES (NEW.*);
    RETURN NULL;
END;
$$
LANGUAGE plpgsql;
</programlisting>

        完成函数创建后，我们创建一个调用该触发器函数的触发器：

<programlisting>
CREATE TRIGGER insert_measurement_trigger
    BEFORE INSERT ON measurement
    FOR EACH ROW EXECUTE PROCEDURE measurement_insert_trigger();
</programlisting>

        我们必须在每个月重新定义触发器函数，这样它才会总是指向当前分区。而触发器的定义则不需要被更新。
       </para>

       <para>
        我们也可能希望插入数据时服务器会自动地定位应该加入数据的分区。我们可以通过一个更复杂的触发器函数来实现之，例如：

<programlisting>
CREATE OR REPLACE FUNCTION measurement_insert_trigger()
RETURNS TRIGGER AS $$
BEGIN
    IF ( NEW.logdate &gt;= DATE '2006-02-01' AND
         NEW.logdate &lt; DATE '2006-03-01' ) THEN
        INSERT INTO measurement_y2006m02 VALUES (NEW.*);
    ELSIF ( NEW.logdate &gt;= DATE '2006-03-01' AND
            NEW.logdate &lt; DATE '2006-04-01' ) THEN
        INSERT INTO measurement_y2006m03 VALUES (NEW.*);
    ...
    ELSIF ( NEW.logdate &gt;= DATE '2008-01-01' AND
            NEW.logdate &lt; DATE '2008-02-01' ) THEN
        INSERT INTO measurement_y2008m01 VALUES (NEW.*);
    ELSE
        RAISE EXCEPTION 'Date out of range.  Fix the measurement_insert_trigger() function!';
    END IF;
    RETURN NULL;
END;
$$
LANGUAGE plpgsql;
</programlisting>

        触发器的定义和以前一样。注意每一个<literal>IF</literal>测试必须准确地匹配它的分区的<literal>CHECK</literal>约束。
       </para>

       <para>
        当该函数比单月形式更加复杂时，并不需要频繁地更新它，因为可以在需要的时候提前加入分支。
       </para>

       <note>
        <para>
         在实践中，如果大部分插入都会进入最新的分区，最好先检查它。为了简洁，我们为触发器的检查采用了和本例中其他部分一致的顺序。
        </para>
       </note>
      </listitem>
     </orderedlist>
    </para>

    <para>
     如我们所见，一个复杂的划分模式可能需要大量的DDL。在上面的例子中，我们需要每月创建一个新分区，所以最好能够编写一个脚本自动地生成所需的DDL。
    </para>

   </sect2>

   <sect2 id="ddl-partitioning-managing-partitions">
   <title>管理分区</title>

   <para>
     通常当初始定义的表倾向于动态变化时，一组分区会被创建。删除旧的分区并周期性地为新数据增加新分区是很常见的。划分的一个最重要的优点是可以通过操纵分区结构来使得这种痛苦的任务几乎是自发地完成，而不需要去物理地移除大量的数据。
   </para>

   <para>
     移除旧数据的最简单的选项是直接删除不再需要的分区：
<programlisting>
DROP TABLE measurement_y2006m02;
</programlisting>
     这可以非常快地删除百万级别的记录，因为它不需要逐一地删除记录。
   </para>

   <para>
     另一个经常使用的选项是将分区从被划分的表中移除，但是把它作为一个独立的表保留下来：
<programlisting>
ALTER TABLE measurement_y2006m02 NO INHERIT measurement;
</programlisting>
     这允许在数据被删除前执行更进一步的操作。例如，这是一个很有用的时机通过<command>COPY</>、<application>pg_dump</>或类似的工具来备份数据。这也是进行数据聚集、执行其他数据操作或运行报表的好时机。
   </para>

   <para>
     相似地我们也可以增加新分区来处理新数据。我们可以在被划分的表中创建一个新的空分区：

<programlisting>
CREATE TABLE measurement_y2008m02 (
    CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' )
) INHERITS (measurement);
</programlisting>

     作为一种选择方案，有时创建一个在分区结构之外的新表更方便，并且在以后才将它作为一个合适的分区。这使得数据可以在出现于被划分表中之前被载入、检查和转换：

<programlisting>
CREATE TABLE measurement_y2008m02
  (LIKE measurement INCLUDING DEFAULTS INCLUDING CONSTRAINTS);
ALTER TABLE measurement_y2008m02 ADD CONSTRAINT y2008m02
   CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' );
\copy measurement_y2008m02 from 'measurement_y2008m02'
-- 可能做一些其他数据准备工作
ALTER TABLE measurement_y2008m02 INHERIT measurement;
</programlisting>
    </para>
   </sect2>

   <sect2 id="ddl-partitioning-constraint-exclusion">
   <title>划分和约束排除</title>

   <indexterm>
    <primary>constraint exclusion</primary>
   </indexterm>

   <para>
    <firstterm>约束排除</>是一种查询优化技术，它可以为按照以上方式定义的被划分表提高性能。例如：

<programlisting>
SET constraint_exclusion = on;
SELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01';
</programlisting>

    如果没有约束排除，上述查询将扫描<structname>measurement</>表的每一个分区。在启用约束排除后，规划器将检查每一个分区的约束来确定该分区需不需要被扫描，因为分区中可能不包含满足查询<literal>WHERE</>子句的行。如果规划器能够证实这一点，则它将会把该分区排除在查询计划之外。
   </para>

   <para>
    可以使用<command>EXPLAIN</>命令来显示开启了<varname>constraint_exclusion</>的计划和没有开启该选项的计划之间的区别。一个典型的未优化的计划是：

<programlisting>
SET constraint_exclusion = off;
EXPLAIN SELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01';

                                          QUERY PLAN
-----------------------------------------------------------------------------------------------
 Aggregate  (cost=158.66..158.68 rows=1 width=0)
   -&gt;  Append  (cost=0.00..151.88 rows=2715 width=0)
         -&gt;  Seq Scan on measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2006m02 measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2006m03 measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
...
         -&gt;  Seq Scan on measurement_y2007m12 measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2008m01 measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
</programlisting>

    其中的某些或者全部分区将会使用索引扫描而不是全表顺序扫描，但是关键在于根本不需要扫描旧分区来回答这个查询。当我们开启约束排除后，对于同一个查询我们会得到一个更加廉价的计划：

<programlisting>
SET constraint_exclusion = on;
EXPLAIN SELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01';
                                          QUERY PLAN
-----------------------------------------------------------------------------------------------
 Aggregate  (cost=63.47..63.48 rows=1 width=0)
   -&gt;  Append  (cost=0.00..60.75 rows=1086 width=0)
         -&gt;  Seq Scan on measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2008m01 measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
</programlisting>
   </para>

   <para>
    注意约束排除只由<literal>CHECK</>约束驱动，而非索引的存在。因此，没有必要在关键列上定义索引。是否在给定分区上定义索引取决于我们希望查询经常扫描表的大部分还是小部分。在后一种情况中索引将会发挥作用。
   </para>

   <para>
    <xref linkend="guc-constraint-exclusion">的默认（也是推荐）设置实际上既不是<literal>on</>也不是<literal>off</>，而是一个被称为<literal>partition</>的中间设置，这使得该技术只被应用于将要在被分区表上工作的查询。设置<literal>on</>将使得规划器在所有的查询中检查<literal>CHECK</>约束，即使简单查询不会从中受益。
   </para>

   </sect2>

   <sect2 id="ddl-partitioning-alternatives">
   <title>可选划分方法</title>

    <para>
     另一种将插入重定向到合适的分区表的方法是在主表上建立规则而不是触发器，例如：

<programlisting>
CREATE RULE measurement_insert_y2006m02 AS
ON INSERT TO measurement WHERE
    ( logdate &gt;= DATE '2006-02-01' AND logdate &lt; DATE '2006-03-01' )
DO INSTEAD
    INSERT INTO measurement_y2006m02 VALUES (NEW.*);
...
CREATE RULE measurement_insert_y2008m01 AS
ON INSERT TO measurement WHERE
    ( logdate &gt;= DATE '2008-01-01' AND logdate &lt; DATE '2008-02-01' )
DO INSTEAD
    INSERT INTO measurement_y2008m01 VALUES (NEW.*);
</programlisting>

     一个规则比一个触发器具有明显更高的负荷，但是该负荷是由每个查询承担而不是每一个行，因此这种方法可能对于批量插入的情况有益。但是，在大部分情况下触发器方法能提供更好的性能。
    </para>

    <para>
     注意<command>COPY</>会忽略规则。如果希望使用<command>COPY</>来插入数据，我们将希望将数据复制到正确的分区表而不是主表。<command>COPY</>会引发触发器，因此如果使用触发器方法就可以正常地使用它。
    </para>

    <para>
     规则方法的另一个缺点是如果一组规则没有覆盖被插入的数据，则该数据将被插入到主表中而不会发出任何错误。
    </para>

    <para>
     划分也可以使用一个<literal>UNION ALL</literal>视图来组织。例如：

<programlisting>
CREATE VIEW measurement AS
          SELECT * FROM measurement_y2006m02
UNION ALL SELECT * FROM measurement_y2006m03
...
UNION ALL SELECT * FROM measurement_y2007m11
UNION ALL SELECT * FROM measurement_y2007m12
UNION ALL SELECT * FROM measurement_y2008m01;
</programlisting>

     但是，如果要增加或者删除单独的分区，就需要重新地创建视图。在实践中，相对于使用继承，这种方法很少被推荐。
    </para>

   </sect2>

   <sect2 id="ddl-partitioning-caveats">
   <title>警告</title>

   <para>
    下面的警告适用于被划分表：
   <itemizedlist>
    <listitem>
     <para>
      没有自动的方法来验证所有的<literal>CHECK</literal>约束是互斥的。创建代码来生成分区并创建或修改相关对象比手工写命令要更安全。
     </para>
    </listitem>

    <listitem>
     <para>
      这里展示的模式都假设分区的关键列从不改变，或者是其改变不足以导致它被移到另一个分区。一个尝试将行移到另一个分区的<command>UPDATE</>会失败，因为<literal>CHECK</>约束的存在。如果我们需要处理这类情况，我们可以在分区表上放置合适的更新触发器，但是它会使得结构的管理更加复杂。
     </para>
    </listitem>

    <listitem>
     <para>
      如果我们在使用手工的<command>VACUUM</command>或<command>ANALYZE</command>命令，别忘了需要在每一个分区上都运行一次。以下的命令：
<programlisting>
ANALYZE measurement;
</programlisting>
      只会处理主表。
     </para>
    </listitem>
    
    <listitem>
     <para>
      具有<literal>ON CONFLICT</>子句的<command>INSERT</command>语句不太可能像预期那样工作，
      正如特定目标关系中而非子关系的独特侵权情况下采取<literal>ON CONFLICT</>操作。
     </para>
    </listitem>

   </itemizedlist>
   </para>

   <para>
    下面的警告适用于约束排除：

   <itemizedlist>
    <listitem>
     <para>
      只有在查询的<literal>WHERE</>子句包含常量（或者外部提供的参数）时，约束排除才会起效。例如，一个与非不变函数（例如<function>CURRENT_TIMESTAMP</function>）的比较不能被优化，因为规划器不知道该函数的值在运行时会落到哪个分区内。
     </para>
    </listitem>

    <listitem>
     <para>
      保持划分约束简单，否则规划器可能没有办法验证无需访问的分区。按前面的例子所示，为列表划分使用简单相等条件或者为范围划分使用简单范围测试。一个好的经验法则是划分约束应该只包含使用B-tree可索引操作符的比较，比较的双方应该是划分列和常量。
     </para>
    </listitem>

    <listitem>
     <para>
      在约束排除期间，主表所有的分区上的所有约束都会被检查，所以大量的分区将会显著地增加查询规划时间。使用这些技术的划分在大约最多100个分区的情况下工作得很好，但是不要尝试使用成千个分区。
     </para>
    </listitem>

   </itemizedlist>
   </para>
  </sect2>
 </sect1>

 <sect1 id="ddl-foreign-data">
  <title>外部数据</title>

   <indexterm>
    <primary>foreign data</primary>
   </indexterm>
   <indexterm>
    <primary>foreign table</primary>
   </indexterm>
   <indexterm>
    <primary>user mapping</primary>
   </indexterm>

   <para>
    <productname>PostgreSQL</productname>实现了部分的SQL/MED规定，允许我们使用普通SQL查询来访问位于PostgreSQL之外的数据。这种数据被称为<firstterm>外部数据</>（注意这种用法不要和外键混淆，后者是数据库中的一种约束）。
   </para>

   <para>
    外部数据可以在一个<firstterm>外部数据包装器</firstterm>的帮助下被访问。一个外部数据包装器是一个库，它可以与一个外部数据源通讯，并隐藏连接到数据源和从它获取数据的细节。在<filename>contrib</>模块中有一些外部数据包装器，参见<xref linkend="contrib">。其他类型的外部数据包装器可以在第三方产品中找到。如果这些现有的外部数据包装器都不能满足你的需要，可以自己编写一个，参见<xref linkend="fdwhandler">。
   </para>

   <para>
    要访问外部数据，我们需要建立一个<firstterm>外部服务器</>对象，它根据它所支持的外部数据包装器所使用的一组选项定义了如何连接到一个特定的外部数据源。接着我们需要创建一个或多个<firstterm>外部表</firstterm>，它们定义了外部数据的结构。一个外部表可以在查询中像一个普通表一样地使用，但是在PostgreSQL服务器中外部表没有存储数据。不管使用什么外部数据包装器，<productname>PostgreSQL</productname>会要求外部数据包装器从外部数据源获取数据，或者在更新命令的情况下传送数据到外部数据源。
   </para>

   <para>
    访问远程数据可能需要在外部数据源的授权。这些信息通过一个<firstterm>用户映射</>提供，它基于当前的<productname>PostgreSQL</productname>角色提供了附加的数据例如用户名和密码。
   </para>

   <para>
    更多信息请见
    <xref linkend="sql-createforeigndatawrapper">，
    <xref linkend="sql-createserver">，<xref linkend="sql-createusermapping">，
    <xref linkend="sql-createforeigntable">以及<xref linkend="sql-importforeignschema">。
   </para>
 </sect1>

 <sect1 id="ddl-others">
  <title>其他数据库对象</title>

  <para>
   表是一个关系型数据库结构中的核心对象，因为它们承载了我们的数据。但是它们并不是数据库中的唯一一种对象。有很多其他种类的对象可以被创建来使得数据的使用和刮泥更加方便或高效。在本章中不会讨论它们，但是我们在会给出一个列表：
  </para>

  <itemizedlist>
   <listitem>
    <para>
     视图
    </para>
   </listitem>

   <listitem>
    <para>
     函数和操作符
    </para>
   </listitem>

   <listitem>
    <para>
     数据类型和域
    </para>
   </listitem>

   <listitem>
    <para>
     触发器和重写规则
    </para>
   </listitem>
  </itemizedlist>

  <para>
   这些主题的详细信息请见<xref linkend="server-programming">。
  </para>
 </sect1>

 <sect1 id="ddl-depend">
  <title>依赖跟踪</title>

  <indexterm zone="ddl-depend">
   <primary>CASCADE</primary>
   <secondary sortas="DROP">with DROP</secondary>
  </indexterm>

  <indexterm zone="ddl-depend">
   <primary>RESTRICT</primary>
   <secondary sortas="DROP">with DROP</secondary>
  </indexterm>

  <para>
   当我们创建一个涉及到很多具有外键约束、视图、触发器、函数等的表的复杂数据库结构时，我们隐式地创建了一张对象之间的依赖关系网。例如，具有一个外键约束的表依赖于它所引用的表。
  </para>

  <para>
   为了保证整个数据库结构的完整性，<productname>PostgreSQL</productname>确保我们无法删除仍然被其他对象依赖的对象。例如，尝试删除<xref linkend="ddl-constraints-fk">中的产品表会导致一个如下的错误消息，因为有订单表依赖于产品表：
<screen>
DROP TABLE products;

NOTICE:  constraint orders_product_no_fkey on table orders depends on table products
ERROR:  cannot drop table products because other objects depend on it
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
</screen>
   该错误消息包含了一个有用的提示：如果我们不想一个一个去删除所有的依赖对象，我们可以执行：
<screen>
DROP TABLE products CASCADE;
</screen>
   这样所有的依赖对象将被移除。在这种情况下，订单表不会被移除，但是它的外键约束会被移除（如果希望检查<command>DROP ... CASCADE</>会干什么，运行不带<literal>CASCADE</>的<command>DROP</>并阅读<literal>NOTICE</>消息）。
  </para>

  <para>
   All drop commands in <productname>PostgreSQL</productname>中的所有删除命令都支持<literal>CASCADE</literal>。当然，其本质的区别随着对象的类型而不同。我们也可以用<literal>RESTRICT</literal>代替<literal>CASCADE</literal>来获得默认行为，它将阻止删除被其他对象依赖的对象。
  </para>

  <note>
   <para>
    根据SQL标准，指定<literal>RESTRICT</literal>或<literal>CASCADE</literal>是被要求的。但没有哪个数据库系统真正强制了这个规则，但是不同的系统中两种默认行为都是可能的。
   </para>
  </note>

  <note>
   <para>
    早于版本7.3之前的<productname>PostgreSQL</productname>中的外键约束依赖和序数列依赖在升级过程中<emphasis>不</emphasis>会被维护或创建。其他类型的依赖会在一个早于7.3的数据库的升级过程中自动被创建。
   </para>
  </note>
 </sect1>

</chapter>
