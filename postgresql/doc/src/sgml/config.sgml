<!-- doc/src/sgml/config.sgml -->

<chapter id="runtime-config">
<!--==========================orignal english content==========================
  <title>Server Configuration</title>
____________________________________________________________________________-->
  <title>服务器配置</title>
<!--==========================orignal english content==========================
  <indexterm>
   <primary>configuration</primary>
   <secondary>of the server</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>配置</primary>
   <secondary>of the server</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   There are many configuration parameters that affect the behavior of
   the database system. In the first section of this chapter we
   describe how to interact with configuration parameters. The subsequent sections
   discuss each parameter in detail.
  </para>
____________________________________________________________________________-->
  <para>
   有很多配置参数可以影响数据库系统的行为。本章的第一节中我们将描述一下如何与配置参数交互。
   后续的小节将详细地讨论每一个参数。
  </para>

  <sect1 id="config-setting">
<!--==========================orignal english content==========================
   <title>Setting Parameters</title>
____________________________________________________________________________-->
   <title>设置参数</title>

   <sect2 id="config-setting-names-values">
<!--==========================orignal english content==========================
    <title>Parameter Names and Values</title>
____________________________________________________________________________-->
    <title>参数名称和值</title>
<!--==========================orignal english content==========================
    <para>
     All parameter names are case-insensitive. Every parameter takes a
     value of one of five types: boolean, string, integer, floating point,
     or enumerated (enum).  The type determines the syntax for setting the
     parameter:
    </para>
____________________________________________________________________________-->
    <para>
     所有参数名都是大小写不敏感的。每个参数都可以接受五种类型之一的值： 布尔、字符串、整数、
     浮点数或枚举。该类型决定了设置该参数的语法：
    </para>

    <itemizedlist>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       <emphasis>Boolean:</emphasis>
       Values can be written as
       <literal>on</literal>,
       <literal>off</literal>,
       <literal>true</literal>,
       <literal>false</literal>,
       <literal>yes</literal>,
       <literal>no</literal>,
       <literal>1</literal>,
       <literal>0</literal>
       (all case-insensitive) or any unambiguous prefix of one of these.
      </para>
____________________________________________________________________________-->
      <para>
       <emphasis>布尔:</emphasis>
       值可以被写成
       <literal>on</literal>,
       <literal>off</literal>,
       <literal>true</literal>,
       <literal>false</literal>,
       <literal>yes</literal>,
       <literal>no</literal>,
       <literal>1</literal>,
       <literal>0</literal>
       （都是大小写不敏感的）或者这些值的任何无歧义前缀。
      </para>
     </listitem>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       <emphasis>String:</emphasis>
       In general, enclose the value in single quotes, doubling any single
       quotes within the value.  Quotes can usually be omitted if the value
       is a simple number or identifier, however.
       (Values that match an SQL keyword require quoting in some contexts.)
      </para>
____________________________________________________________________________-->
      <para>
       <emphasis>字符串:</emphasis>
       通常值被包括在单引号内，值内部的任何单引号都需要被双写。不过，如果值是一个简单数字或者
       标识符，引号通常可以被省略。
       (与 SQL 关键字匹配的值需要在某些上下文中引用。)	  
      </para>
     </listitem>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       <emphasis>Numeric (integer and floating point):</emphasis>
       Numeric parameters can be specified in the customary integer and
       floating-point formats; fractional values are rounded to the nearest
       integer if the parameter is of integer type.  Integer parameters
       additionally accept hexadecimal input (beginning
       with <literal>0x</literal>) and octal input (beginning
       with <literal>0</literal>), but these formats cannot have a fraction.
       Do not use thousands separators.
       Quotes are not required, except for hexadecimal input.
      </para>
____________________________________________________________________________-->
      <para>
       <emphasis>数字（整数和浮点）:</emphasis>
       数字参数可以规定为惯用的整数和浮点格式；如果参数为整数类型，则小数值四舍五入到最接近的整数。
       证书参数还接受十六进制输入(以<literal>0x</literal>开头)和十进制输入(以<literal>0</literal>开头)，但是这些格式不能有小数。
       不能使用千位分隔符。引号是不是必需的，除了十六进制输入。  
      </para>
     </listitem>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       <emphasis>Numeric with Unit:</emphasis>
       Some numeric parameters have an implicit unit, because they describe
       quantities of memory or time. The unit might be bytes, kilobytes, blocks
       (typically eight kilobytes), milliseconds, seconds, or minutes.
       An unadorned numeric value for one of these settings will use the
       setting's default unit, which can be learned from
       <structname>pg_settings</structname>.<structfield>unit</structfield>.
       For convenience, settings can be given with a unit specified explicitly,
       for example <literal>'120 ms'</literal> for a time value, and they will be
       converted to whatever the parameter's actual unit is.  Note that the
       value must be written as a string (with quotes) to use this feature.
       The unit name is case-sensitive, and there can be whitespace between
       the numeric value and the unit.

       <itemizedlist>
        <listitem>
         <para>
          Valid memory units are <literal>B</literal> (bytes),
          <literal>kB</literal> (kilobytes),
          <literal>MB</literal> (megabytes), <literal>GB</literal>
          (gigabytes), and <literal>TB</literal> (terabytes).
          The multiplier for memory units is 1024, not 1000.
         </para>
        </listitem>

        <listitem>
         <para>
          Valid time units are
          <literal>us</literal> (microseconds),
          <literal>ms</literal> (milliseconds),
          <literal>s</literal> (seconds), <literal>min</literal> (minutes),
          <literal>h</literal> (hours), and <literal>d</literal> (days).
         </para>
        </listitem>
       </itemizedlist>

       If a fractional value is specified with a unit, it will be rounded
       to a multiple of the next smaller unit if there is one.
       For example, <literal>30.1 GB</literal> will be converted
       to <literal>30822 MB</literal> not <literal>32319628902 B</literal>.
       If the parameter is of integer type, a final rounding to integer
       occurs after any unit conversion.
      </para>
____________________________________________________________________________-->
      <para>
       <emphasis>带单位的数字:</emphasis>
       一些数字参数具有隐含单位，因为它们描述内存或时间量。单位可能是字节、千字节、块（通常是 8KB）、 毫秒、秒或分钟。这些设置之一的一个未修饰的数字值将使用该设置的默认单位，默认单位可以通
       过引用<structname>pg_settings</structname>.<structfield>unit</structfield>来找到。为了方便，也可以
       显式地指定一个不同的单位，例如时间值可以是<literal>'120 ms'</literal>，并且它们将被转换到参数的实际单位。要使用这个特性，注意值必须被写成一个字符
       串（带有引号）。单位名称是大小写敏感的，并且在数字值和单位之间可以有空白。

       <itemizedlist>
        <listitem>
         <para>
          可用的内存单位是<literal>B</literal>（字节）、<literal>kB</literal>（千字节）、<literal>MB</literal>（兆字节）和<literal>GB</literal>（吉字节）。内存单位的乘数是 1024 而不是 1000。
         </para>
        </listitem>

        <listitem>
         <para>
          可用的时间单位是
          <literal>us</literal> (微秒),
          <literal>ms</literal> (毫秒),
          <literal>s</literal>（秒）、<literal>min</literal>（分钟）、
          <literal>h</literal>（小时）和<literal>d</literal>（天）。
         </para>
        </listitem>
       </itemizedlist>

       如果一个单位指定了小数值，如果有下一个较小的单元，它将四舍五入为下一个较小单位的倍数。
       例如，<literal>30.1 GB</literal>将被转换为<literal>30822 MB</literal>而不是<literal>32319628902 B</literal>。
       如果参数为整数类型，则在进行任何单位转换之后，最后四舍五入到整数。
      </para>
     </listitem>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       <emphasis>Enumerated:</emphasis>
       Enumerated-type parameters are written in the same way as string
       parameters, but are restricted to have one of a limited set of
       values.  The values allowable for such a parameter can be found from
       <structname>pg_settings</structname>.<structfield>enumvals</structfield>.
       Enum parameter values are case-insensitive.
      </para>
____________________________________________________________________________-->
      <para>
       <emphasis>枚举:</emphasis>
       枚举类型的参数以与字符串参数相同的方式指定，但被限制到一组有限的值。 这样一个参数可用的值可以在<structname>pg_settings</structname>.<structfield>enumvals</structfield>
       中找到。枚举参数值是大小写无关的。
      </para>
     </listitem>
    </itemizedlist>
   </sect2>

   <sect2 id="config-setting-configuration-file">
<!--==========================orignal english content==========================
    <title>Parameter Interaction via the Configuration File</title>
____________________________________________________________________________-->
    <title>通过配置文件影响参数</title>
<!--==========================orignal english content==========================
    <para>
     The most fundamental way to set these parameters is to edit the file
     <filename>postgresql.conf</filename><indexterm><primary>postgresql.conf</primary></indexterm>,
     which is normally kept in the data directory.  A default copy is
     installed when the database cluster directory is initialized.
     An example of what this file might look like is:
<programlisting>
# This is a comment
log_connections = yes
log_destination = 'syslog'
search_path = '"$user", public'
shared_buffers = 128MB
</programlisting>
     One parameter is specified per line. The equal sign between name and
     value is optional. Whitespace is insignificant (except within a quoted
     parameter value) and blank lines are
     ignored. Hash marks (<literal>#</literal>) designate the remainder
     of the line as a comment.  Parameter values that are not simple
     identifiers or numbers must be single-quoted.  To embed a single
     quote in a parameter value, write either two quotes (preferred)
     or backslash-quote.
     If the file contains multiple entries for the same parameter,
     all but the last one are ignored.
    </para>
____________________________________________________________________________-->
    <para>
     设置这些参数最基本的方法是编辑<filename>postgresql.conf</filename><indexterm><primary>postgresql.conf</primary></indexterm>文件， 它通常被保存在数据目录中（当数据库集簇目录被初始化时，一个默认的拷贝将会被安装在那里）。一个该文件的例子看起来是：
<programlisting>
# This is a comment
log_connections = yes
log_destination = 'syslog'
search_path = '"$user", public'
shared_buffers = 128MB
</programlisting>
     每一行指定一个参数。名称和值之间的等号是可选的。空白是无意义的（除了在一个引号引用的参数值内）并且空行被忽略。井号（<literal>#</literal>）指示该行的剩余部分是一个注释。非简单标识符或者数字的参数值必须用单引号包围。要在参数值里嵌入单引号， 要么写两个单引号（首选）或者在引号前放反斜线。
     如果文件包含相同参数的多个条目，则忽略除最后一个之外的所有条目。
    </para>

<!--==========================orignal english content==========================
    <para>
     Parameters set in this way provide default values for the cluster.
     The settings seen by active sessions will be these values unless they
     are overridden.  The following sections describe ways in which the
     administrator or user can override these defaults.
    </para>
____________________________________________________________________________-->
    <para>
     以这种方式设定的参数为集簇提供了默认值。除非这些设置被覆盖，活动会话看到的就是这些设置。
     下面的小节描述了管理员或用户覆盖这些默认值的方法。
    </para>

<!--==========================orignal english content==========================
    <para>
     <indexterm>
      <primary>SIGHUP</primary>
     </indexterm>
     The configuration file is reread whenever the main server process
     receives a <systemitem>SIGHUP</systemitem> signal; this signal is most easily
     sent by running <literal>pg_ctl reload</literal> from the command line or by
     calling the SQL function <function>pg_reload_conf()</function>. The main
     server process also propagates this signal to all currently running
     server processes, so that existing sessions also adopt the new values
     (this will happen after they complete any currently-executing client
     command).  Alternatively, you can
     send the signal to a single server process directly.  Some parameters
     can only be set at server start; any changes to their entries in the
     configuration file will be ignored until the server is restarted.
     Invalid parameter settings in the configuration file are likewise
     ignored (but logged) during <systemitem>SIGHUP</systemitem> processing.
    </para>
____________________________________________________________________________-->
    <para>
     <indexterm>
      <primary>SIGHUP</primary>
     </indexterm>
     主服务器进程每次收到<systemitem>SIGHUP</systemitem>信号（最简单的方法是从命令行运行<literal>pg_ctl reload</literal>或调用 SQL 函数<function>pg_reload_conf()</function>来发送这个信号）后都会重新读取这个配置
     文件。主服务器进程还会把这个信号传播给所有正在运行的服务器进程，这样现有的会话也能采用新
     值（要等待它们完成当前正在执行的客户端命令之后才会发生）。另外，你可以直接向一个单一服务
     器进程发送该信号。有些参数只能在服务器启动时设置，在配置文件中对这些条目的修改将被忽略，
     直到下次服务器重启。配置文件中的非法参数设置也会在<systemitem>SIGHUP</systemitem>处理过程中被
     忽略（但是会记录日志）。
    </para>

<!--==========================orignal english content==========================
    <para>
     In addition to <filename>postgresql.conf</filename>,
     a <productname>PostgreSQL</productname> data directory contains a file
     <filename>postgresql.auto.conf</filename><indexterm><primary>postgresql.auto.conf</primary></indexterm>,
     which has the same format as <filename>postgresql.conf</filename> but
     is intended to be edited automatically, not manually.  This file holds
     settings provided through the <link linkend="sql-altersystem"><command>ALTER SYSTEM</command></link> command.
     This file is read whenever <filename>postgresql.conf</filename> is,
     and its settings take effect in the same way.  Settings
     in <filename>postgresql.auto.conf</filename> override those
     in <filename>postgresql.conf</filename>.
    </para>
____________________________________________________________________________-->
    <para>
     除<filename>postgresql.conf</filename>之外，<productname>PostgreSQL</productname>
     数据目录还包含一个文件<filename>postgresql.auto.conf</filename><indexterm><primary>postgresql.auto.conf</primary></indexterm>，
     它具有和<filename>postgresql.conf</filename>相同的格式但是原自动编辑，而不是手工编辑。
     这个文件保存了通过<link linkend="sql-altersystem"><command>ALTER SYSTEM</command></link>命令提供的设置。
     每当<filename>postgresql.conf</filename>被读取时这个文件会被自动读取，并且它的设置会以同样的方式生效。
     <filename>postgresql.auto.conf</filename>中的设置会覆盖<filename>postgresql.conf</filename>中的设置。
    </para>

<!--==========================orignal english content==========================
    <para>
     External tools may also
     modify <filename>postgresql.auto.conf</filename>.  It is not
     recommended to do this while the server is running, since a
     concurrent <command>ALTER SYSTEM</command> command could overwrite
     such changes.  Such tools might simply append new settings to the end,
     or they might choose to remove duplicate settings and/or comments
     (as <command>ALTER SYSTEM</command> will).
    </para>
____________________________________________________________________________-->
    <para>
     外部工具也可以修改 <filename>postgresql.auto.conf</filename>.
     不建议在服务器运行时执行此操作，因为并发的 <command>ALTER SYSTEM</command> 可能会覆盖这些更改。
     这些工具可能只是简单地在末尾附加新的设置，或者它们可能删除重复的设置和/或注释(就像 <command>ALTER SYSTEM</command> )。
    </para>

<!--==========================orignal english content==========================
    <para>
     The system view
     <link linkend="view-pg-file-settings"><structname>pg_file_settings</structname></link>
     can be helpful for pre-testing changes to the configuration files, or for
     diagnosing problems if a <systemitem>SIGHUP</systemitem> signal did not have the
     desired effects.
    </para>
____________________________________________________________________________-->
    <para>
     系统视图<link linkend="view-pg-file-settings"><structname>pg_file_settings</structname></link>
     可以有助于对配置文件中的更改进行提前测试，或者在<systemitem>SIGHUP</systemitem>
     信号没有达到预期效果时用来诊断问题。
    </para>
   </sect2>

   <sect2 id="config-setting-sql-command-interaction">
<!--==========================orignal english content==========================
    <title>Parameter Interaction via SQL</title>
____________________________________________________________________________-->
    <title>通过SQL影响参数</title>
<!--==========================orignal english content==========================
     <para>
      <productname>PostgreSQL</productname> provides three SQL
      commands to establish configuration defaults.
      The already-mentioned <command>ALTER SYSTEM</command> command
      provides an SQL-accessible means of changing global defaults; it is
      functionally equivalent to editing <filename>postgresql.conf</filename>.
      In addition, there are two commands that allow setting of defaults
      on a per-database or per-role basis:
     </para>
____________________________________________________________________________-->
     <para>
      <productname>PostgreSQL</productname>提供了三个SQL命令来建立配置默认值。
      已经提到过的<command>ALTER SYSTEM</command>命令提供了一种改变全局默认值的从SQL可
      访问的方法；它在功效上等效于编辑<filename>postgresql.conf</filename>。此外，还有两个命令
      可以针对每个数据库或者每个角色设置默认值：
     </para>

     <itemizedlist>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       The <link linkend="sql-alterdatabase"><command>ALTER DATABASE</command></link> command allows global
       settings to be overridden on a per-database basis.
      </para>
____________________________________________________________________________-->
      <para>
       <link linkend="sql-alterdatabase"><command>ALTER DATABASE</command></link>命令允许针对一个数据库覆盖其全局设置。
      </para>
     </listitem>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       The <link linkend="sql-alterrole"><command>ALTER ROLE</command></link> command allows both global and
       per-database settings to be overridden with user-specific values.
      </para>
____________________________________________________________________________-->
      <para>
       <link linkend="sql-alterrole"><command>ALTER ROLE</command></link>命令允许用用户指定的值来覆盖全局设置和数据库设置。
      </para>
     </listitem>
    </itemizedlist>

<!--==========================orignal english content==========================
     <para>
      Values set with <command>ALTER DATABASE</command> and <command>ALTER ROLE</command>
      are applied only when starting a fresh database session.  They
      override values obtained from the configuration files or server
      command line, and constitute defaults for the rest of the session.
      Note that some settings cannot be changed after server start, and
      so cannot be set with these commands (or the ones listed below).
    </para>
____________________________________________________________________________-->
     <para>
      只有当开始一个新的数据库会话时，用<command>ALTER DATABASE</command>和
      <command>ALTER ROLE</command>设置的值才会被应用。它们会覆盖从配置文件或服务器命令行
      获得的值，并且作为该会话后续的默认值。注意某些设置在服务器启动后不能被更改，并且因此
      不能被这些命令（或者下文列举的命令）设置。
    </para>

<!--==========================orignal english content==========================
     <para>
      Once a client is connected to the database, <productname>PostgreSQL</productname>
      provides two additional SQL commands (and equivalent functions) to
      interact with session-local configuration settings:
    </para>
____________________________________________________________________________-->
     <para>
      一旦一个客户端连接到数据库，<productname>PostgreSQL</productname>会提供两个额外的SQL命令（
      以及等效的函数）用以影响会话本地的配置设置：
    </para>

    <itemizedlist>
     <listitem>
<!--==========================orignal english content==========================
     <para>
      The <link linkend="sql-show"><command>SHOW</command></link> command allows inspection of the
      current value of any parameter.  The corresponding SQL function is
      <function>current_setting(setting_name text)</function>
      (see <xref linkend="functions-admin-set"/>).
     </para>
____________________________________________________________________________-->
     <para>
      <link linkend="sql-show"><command>SHOW</command></link>命令允许察看任何参数的当前值。对应的SQL函数是
      <function>current_setting(setting_name text)</function> (参见 <xref linkend="functions-admin-set"/>)。
     </para>
     </listitem>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       The <link linkend="sql-set"><command>SET</command></link> command allows modification of the
       current value of those parameters that can be set locally to a
       session; it has no effect on other sessions.
       The corresponding SQL function is
       <function>set_config(setting_name, new_value, is_local)</function>
       (see <xref linkend="functions-admin-set"/>).
      </para>
____________________________________________________________________________-->
      <para>
       <link linkend="sql-set"><command>SET</command></link>命令允许修改对于一个会话可以本地设置的参数的当前值，它对其他会话没有影响。
       对应的SQL函数是 <function>set_config(setting_name, new_value, is_local)</function> (参见 <xref linkend="functions-admin-set"/>)。
      </para>
     </listitem>
    </itemizedlist>

<!--==========================orignal english content==========================
    <para>
     In addition, the system view <link
     linkend="view-pg-settings"><structname>pg_settings</structname></link> can be
     used to view and change session-local values:
    </para>
____________________________________________________________________________-->
    <para>
     此外，系统视图<link
     linkend="view-pg-settings"><structname>pg_settings</structname></link>可以被用来查看和改变
     会话本地的值：
    </para>

    <itemizedlist>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       Querying this view is similar to using <command>SHOW ALL</command> but
       provides more detail.  It is also more flexible, since it's possible
       to specify filter conditions or join against other relations.
      </para>
____________________________________________________________________________-->
      <para>
       查询这个视图与使用<command>SHOW ALL</command>相似，但是可以提供更多细节。它也更加灵活，
       因为可以为它指定过滤条件或者把它与其他关系进行连接。
      </para>
     </listitem>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       Using <command>UPDATE</command> on this view, specifically
       updating the <structname>setting</structname> column, is the equivalent
       of issuing <command>SET</command> commands.  For example, the equivalent of
<programlisting>
SET configuration_parameter TO DEFAULT;
</programlisting>
       is:
<programlisting>
UPDATE pg_settings SET setting = reset_val WHERE name = 'configuration_parameter';
</programlisting>
      </para>
____________________________________________________________________________-->
      <para>
       在这个视图上使用<command>UPDATE</command>并且指定更新<structname>setting</structname>
       列，其效果等同于发出<command>SET</command>命令。例如，下面的命令
<programlisting>
SET configuration_parameter TO DEFAULT;
</programlisting>
       等效于：
<programlisting>
UPDATE pg_settings SET setting = reset_val WHERE name = 'configuration_parameter';
</programlisting>
      </para>
     </listitem>
    </itemizedlist>

   </sect2>

   <sect2>
<!--==========================orignal english content==========================
    <title>Parameter Interaction via the Shell</title>
____________________________________________________________________________-->
    <title>通过 Shell 影响参数</title>
<!--==========================orignal english content==========================
     <para>
      In addition to setting global defaults or attaching
      overrides at the database or role level, you can pass settings to
      <productname>PostgreSQL</productname> via shell facilities.
      Both the server and <application>libpq</application> client library
      accept parameter values via the shell.
     </para>
____________________________________________________________________________-->
     <para>
      除了在数据库或者角色层面上设置全局默认值或者进行覆盖，你还可以通过 shell 工具把设置
      传递给<productname>PostgreSQL</productname>。服务器和<application>libpq</application>
      客户端库都能通过 shell 接受参数值。
     </para>

     <itemizedlist>
      <listitem>
<!--==========================orignal english content==========================
      <para>
       During server startup, parameter settings can be
       passed to the <command>postgres</command> command via the
       <option>-c</option> command-line parameter.  For example,
<programlisting>
postgres -c log_connections=yes -c log_destination='syslog'
</programlisting>
       Settings provided in this way override those set via
       <filename>postgresql.conf</filename> or <command>ALTER SYSTEM</command>,
       so they cannot be changed globally without restarting the server.
     </para>
____________________________________________________________________________-->
      <para>
       在服务器启动期间，可以通过<option>-c</option>命令行参数把参数设置传递给
       <command>postgres</command>命令。例如：
<programlisting>
postgres -c log_connections=yes -c log_destination='syslog'
</programlisting>
       这种方式提供的设置会覆盖通过<filename>postgresql.conf</filename>或者
       <command>ALTER SYSTEM</command>提供的设置，因此除了重启服务器之外无法从全局上改变它们。
     </para>
    </listitem>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      When starting a client session via <application>libpq</application>,
      parameter settings can be
      specified using the <envar>PGOPTIONS</envar> environment variable.
      Settings established in this way constitute defaults for the life
      of the session, but do not affect other sessions.
      For historical reasons, the format of <envar>PGOPTIONS</envar> is
      similar to that used when launching the <command>postgres</command>
      command; specifically, the <option>-c</option> flag must be specified.
      For example,
<programlisting>
env PGOPTIONS="-c geqo=off -c statement_timeout=5min" psql
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      当通过<application>libpq</application>启动一个客户端会话时，可以使用<envar>PGOPTIONS</envar>
      环境变量指定参数设置。这种方式建立的设置构成了会话生存期间的默认值，但是不会影响
      其他的会话。由于历史原因，<envar>PGOPTIONS</envar>的格式和启动
      <command>postgres</command>命令时用到的相似，特别是<option>-c</option>标志必须被指定。
      例如：
<programlisting>
env PGOPTIONS="-c geqo=off -c statement_timeout=5min" psql
</programlisting>
     </para>

<!--==========================orignal english content==========================
     <para>
      Other clients and libraries might provide their own mechanisms,
      via the shell or otherwise, that allow the user to alter session
      settings without direct use of SQL commands.
     </para>
____________________________________________________________________________-->
     <para>
      通过 shell 或者其他方式，其他客户端和库可能提供它们自己的机制，以便允许用户在不直接
      使用SQL命令的前提下修改会话设置。
     </para>
    </listitem>
   </itemizedlist>

   </sect2>

   <sect2 id="config-includes">
<!--==========================orignal english content==========================
    <title>Managing Configuration File Contents</title>
____________________________________________________________________________-->
    <title>管理配置文件内容</title>
<!--==========================orignal english content==========================
     <para>
      <productname>PostgreSQL</productname> provides several features for breaking
      down complex <filename>postgresql.conf</filename> files into sub-files.
      These features are especially useful when managing multiple servers
      with related, but not identical, configurations.
     </para>
____________________________________________________________________________-->
     <para>
      <productname>PostgreSQL</productname>提供了一些特性用于把复杂的
      <filename>postgresql.conf</filename>文件分解成子文件。在管理多个具有相关但不完全相同
      配置的服务器时，这些特性特别有用。
     </para>

<!--==========================orignal english content==========================
     <para>
      <indexterm>
       <primary><literal>include</literal></primary>
       <secondary>in configuration file</secondary>
      </indexterm>
      In addition to individual parameter settings,
      the <filename>postgresql.conf</filename> file can contain <firstterm>include
      directives</firstterm>, which specify another file to read and process as if
      it were inserted into the configuration file at this point.  This
      feature allows a configuration file to be divided into physically
      separate parts.  Include directives simply look like:
<programlisting>
include 'filename'
</programlisting>
      If the file name is not an absolute path, it is taken as relative to
      the directory containing the referencing configuration file.
      Inclusions can be nested.
     </para>
____________________________________________________________________________-->
     <para>
      <indexterm>
       <primary><literal>include</literal></primary>
       <secondary>in configuration file</secondary>
      </indexterm>
      除了单个参数设置，<filename>postgresql.conf</filename>文件可以包含<firstterm>包括指令</firstterm>，它指定要读入和处理的另一个文件，就好像该文件被插入到配置文件的这个点。这个特性允许一个配置文件被划分成物理上独立的部分。包括指令看起来像：
<programlisting>
include 'filename'
</programlisting>
      如果文件名不是一个绝对路径，它将作为包含引用配置文件的目录的相对位置。包括可以被嵌套。
     </para>

<!--==========================orignal english content==========================
     <para>
      <indexterm>
       <primary><literal>include_if_exists</literal></primary>
       <secondary>in configuration file</secondary>
      </indexterm>
      There is also an <literal>include_if_exists</literal> directive, which acts
      the same as the <literal>include</literal> directive, except
      when the referenced file does not exist or cannot be read.  A regular
      <literal>include</literal> will consider this an error condition, but
      <literal>include_if_exists</literal> merely logs a message and continues
      processing the referencing configuration file.
     </para>
____________________________________________________________________________-->
     <para>
      <indexterm>
       <primary><literal>include_if_exists</literal></primary>
       <secondary>in configuration file</secondary>
      </indexterm>
      也有一个<literal>include_if_exists</literal>指令，它的作用和<literal>include</literal>指令一样，不过当被引用的文件不存在或者无法被读取时其行为不同。一个通常的<literal>include</literal>将认为这是一个错误情况，而<literal>include_if_exists</literal>仅仅记录一个消息并且继续处理引用配置文件。
     </para>

<!--==========================orignal english content==========================
     <para>
      <indexterm>
       <primary><literal>include_dir</literal></primary>
       <secondary>in configuration file</secondary>
      </indexterm>
      The <filename>postgresql.conf</filename> file can also contain
      <literal>include_dir</literal> directives, which specify an entire
      directory of configuration files to include.  These look like
<programlisting>
include_dir 'directory'
</programlisting>
      Non-absolute directory names are taken as relative to the directory
      containing the referencing configuration file.  Within the specified
      directory, only non-directory files whose names end with the
      suffix <literal>.conf</literal> will be included.  File names that
      start with the <literal>.</literal> character are also ignored, to
      prevent mistakes since such files are hidden on some platforms.  Multiple
      files within an include directory are processed in file name order
      (according to C locale rules, i.e., numbers before letters, and
      uppercase letters before lowercase ones).
     </para>
____________________________________________________________________________-->
     <para>
      <indexterm>
       <primary><literal>include_dir</literal></primary>
       <secondary>in configuration file</secondary>
      </indexterm>
        <filename>postgresql.conf</filename>文件也可以包含<literal>include_dir</literal>指令，它指定要被包含的配置文件的一整个目录。它的用法类似：
 <programlisting>
 include_dir 'directory'
 </programlisting>
        非绝对目录名被当做包含引用配置文件的目录的相对路径。在该指定目录中，只有以后缀名
        <literal>.conf</literal>结尾的非目录文件才会被包括。以<literal>.</literal>
        字符开头的文件名也会被忽略，因为在某些平台上它们是隐藏文件。一个包括目录中的多个文件
        被以文件名顺序处理（根据 C 区域规则排序，即数字在字母之前并且大写字母在小写字母
        之前）。
     </para>

<!--==========================orignal english content==========================
     <para>
      Include files or directories can be used to logically separate portions
      of the database configuration, rather than having a single large
      <filename>postgresql.conf</filename> file.  Consider a company that has two
      database servers, each with a different amount of memory.  There are
      likely elements of the configuration both will share, for things such
      as logging.  But memory-related parameters on the server will vary
      between the two.  And there might be server specific customizations,
      too.  One way to manage this situation is to break the custom
      configuration changes for your site into three files.  You could add
      this to the end of your <filename>postgresql.conf</filename> file to include
      them:
<programlisting>
include 'shared.conf'
include 'memory.conf'
include 'server.conf'
</programlisting>
      All systems would have the same <filename>shared.conf</filename>.  Each
      server with a particular amount of memory could share the
      same <filename>memory.conf</filename>; you might have one for all servers
      with 8GB of RAM, another for those having 16GB.  And
      finally <filename>server.conf</filename> could have truly server-specific
      configuration information in it.
     </para>
____________________________________________________________________________-->
     <para>
      包括文件或目录可以被用来在逻辑上分隔数据库配置的各个部分，而不是用一个很大的<filename>postgresql.conf</filename>文件。
      考虑一个有两台数据库服务器的公司，每一个都有不同的内存量。
      很可能配置的元素都会被共享，例如用于日志的参数。但是两者关于内存的参数将会不同。
      并且还可能会有服务器相关的自定义。
      一种管理这类情况的方法是将你的站点的自定义配置修改分成三个文件。
      你可以把下面的内容加入到你的<filename>postgresql.conf</filename>文件末尾来包括它们：
<programlisting>
include 'shared.conf'
include 'memory.conf'
include 'server.conf'
</programlisting>
      所有的系统将会有相同的<filename>shared.conf</filename>。
      每个有特定内存量的服务器可以共享相同的<filename>memory.conf</filename>。
      你可能对所有 8GB 内存的服务器有一个，而对那些 16GB 内存的服务器有另一个。
      并且最后<filename>server.conf</filename>可以装有真正服务器相关的配置信息。
     </para>

<!--==========================orignal english content==========================
     <para>
      Another possibility is to create a configuration file directory and
      put this information into files there. For example, a <filename>conf.d</filename>
      directory could be referenced at the end of <filename>postgresql.conf</filename>:
<programlisting>
include_dir 'conf.d'
</programlisting>
      Then you could name the files in the <filename>conf.d</filename> directory
      like this:
<programlisting>
00shared.conf
01memory.conf
02server.conf
</programlisting>
       This naming convention establishes a clear order in which these
       files will be loaded.  This is important because only the last
       setting encountered for a particular parameter while the server is
       reading configuration files will be used.  In this example,
       something set in <filename>conf.d/02server.conf</filename> would override a
       value set in <filename>conf.d/01memory.conf</filename>.
     </para>
____________________________________________________________________________-->
     <para>
      另一中可能性是创建一个配置文件目录并把这个信息放到其中的文件里。
      例如，一个<filename>conf.d</filename>目录可以在<filename>postgresql.conf</filename>的末尾被引用：
<programlisting>
include_dir 'conf.d'
</programlisting>
      然后你可以这样命名<filename>conf.d</filename>目录中的文件：
<programlisting>
00shared.conf
01memory.conf
02server.conf
</programlisting>
      这种命名习惯建立了这些文件将被载入的清晰顺序。这是很重要的，因为在服务器读取配置
      文件时，对于一个特定的参数只有最后碰到的一个设置才会被使用。在这个例子中，
      <filename>conf.d/02server.conf</filename>设置的东西将会覆盖在
      <filename>conf.d/01memory.conf</filename>中相同参数的值。
     </para>

<!--==========================orignal english content==========================
     <para>
      You might instead use this approach to naming the files
      descriptively:
<programlisting>
00shared.conf
01memory-8GB.conf
02server-foo.conf
</programlisting>
      This sort of arrangement gives a unique name for each configuration file
      variation.  This can help eliminate ambiguity when several servers have
      their configurations all stored in one place, such as in a version
      control repository.  (Storing database configuration files under version
      control is another good practice to consider.)
     </para>
____________________________________________________________________________-->
     <para>
       你还可以使用这种配置目录方法，在命名文件时更有描述性：
<programlisting>
00shared.conf
01memory-8GB.conf
02server-foo.conf
</programlisting>
       这种形式的安排为每个配置文件变体给定了一个唯一的名称。当多个服务器把它们的配置全部存储在一个位置（例如在一个版本控制仓库中）时，这可以帮助消除歧义（在版本控制下存储数据库配置文件是另一个值得考虑的好方法）。
     </para>
    </sect2>
   </sect1>

   <sect1 id="runtime-config-file-locations">
<!--==========================orignal english content==========================
    <title>File Locations</title>
____________________________________________________________________________-->
    <title>文件位置</title>
<!--==========================orignal english content==========================
     <para>
      In addition to the <filename>postgresql.conf</filename> file
      already mentioned, <productname>PostgreSQL</productname> uses
      two other manually-edited configuration files, which control
      client authentication (their use is discussed in <xref
      linkend="client-authentication"/>).  By default, all three
      configuration files are stored in the database cluster's data
      directory.  The parameters described in this section allow the
      configuration files to be placed elsewhere.  (Doing so can ease
      administration.  In particular it is often easier to ensure that
      the configuration files are properly backed-up when they are
      kept separate.)
     </para>
____________________________________________________________________________-->
     <para>
      除了已经提到过的<filename>postgresql.conf</filename>文件之外，<productname>PostgreSQL</productname>还使用另外两个手工编辑的配置文件，它们控制客户端认证（其使用在<xref linkend="client-authentication"/>中讨论）。默认情况下，所有三个配置文件都存放在数据库集簇的数据目录中。 本节描述的参数允许配置文件放在别的地方（这么做可以简化管理，特别是如果配置文件被独立放置，可以很容易保证它得到恰当的备份）。
     </para>

     <variablelist>
     <varlistentry id="guc-data-directory" xreflabel="data_directory">
<!--==========================orignal english content==========================
      <term><varname>data_directory</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>data_directory</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>data_directory</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>data_directory</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
         Specifies the directory to use for data storage.
         This parameter can only be set at server start.
       </para>
____________________________________________________________________________-->
       <para>
         指定用于数据存储的目录。这个选项只能在服务器启动时设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-config-file" xreflabel="config_file">
<!--==========================orignal english content==========================
      <term><varname>config_file</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>config_file</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>config_file</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>config_file</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
         Specifies the main server configuration file
         (customarily called <filename>postgresql.conf</filename>).
         This parameter can only be set on the <command>postgres</command> command line.
       </para>
____________________________________________________________________________-->
       <para>
         指定主服务器配置文件（通常叫<filename>postgresql.conf</filename>）。这个参数只能在<command>postgres</command>命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-hba-file" xreflabel="hba_file">
<!--==========================orignal english content==========================
      <term><varname>hba_file</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>hba_file</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>hba_file</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>hba_file</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
         Specifies the configuration file for host-based authentication
         (customarily called <filename>pg_hba.conf</filename>).
         This parameter can only be set at server start.
       </para>
____________________________________________________________________________-->
       <para>
         指定基于主机认证配置文件（通常叫<filename>pg_hba.conf</filename>）。这个参数只能在服务器启动的时候设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ident-file" xreflabel="ident_file">
<!--==========================orignal english content==========================
      <term><varname>ident_file</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>ident_file</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>ident_file</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>ident_file</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
         Specifies the configuration file for user name mapping
         (customarily called <filename>pg_ident.conf</filename>).
         This parameter can only be set at server start.
         See also <xref linkend="auth-username-maps"/>.
       </para>
____________________________________________________________________________-->
       <para>
         指定用于用户名称映射的配置文件（通常叫<filename>pg_ident.conf</filename>）。这个参数只能在服务器启动的时候设置。另见<xref linkend="auth-username-maps"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-external-pid-file" xreflabel="external_pid_file">
<!--==========================orignal english content==========================
      <term><varname>external_pid_file</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>external_pid_file</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>external_pid_file</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>external_pid_file</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the name of an additional process-ID (PID) file that the
        server should create for use by server administration programs.
        This parameter can only be set at server start.
       </para>
____________________________________________________________________________-->
       <para>
        指定可被服务器创建的用于管理程序的额外进程 ID（PID）文件。这个参数只能在服务器启动的时候设置。
       </para>
      </listitem>
     </varlistentry>
     </variablelist>

<!--==========================orignal english content==========================
     <para>
      In a default installation, none of the above parameters are set
      explicitly.  Instead, the
      data directory is specified by the <option>-D</option> command-line
      option or the <envar>PGDATA</envar> environment variable, and the
      configuration files are all found within the data directory.
     </para>
____________________________________________________________________________-->
     <para>
      在默认安装中不会显式设置以上参数。相反，命令行参数<option>-D</option>或者环境变量<envar>PGDATA</envar>指定数据目录，并且上述配置文件都能在数据目录中找到。
     </para>

<!--==========================orignal english content==========================
     <para>
      If you wish to keep the configuration files elsewhere than the
      data directory, the <command>postgres</command> <option>-D</option>
      command-line option or <envar>PGDATA</envar> environment variable
      must point to the directory containing the configuration files,
      and the <varname>data_directory</varname> parameter must be set in
      <filename>postgresql.conf</filename> (or on the command line) to show
      where the data directory is actually located.  Notice that
      <varname>data_directory</varname> overrides <option>-D</option> and
      <envar>PGDATA</envar> for the location
      of the data directory, but not for the location of the configuration
      files.
     </para>
____________________________________________________________________________-->
     <para>
      如果你想把配置文件放在别的地方而不是数据目录中，那么<command>postgres</command> <option>-D</option>命令行选项或者环境变量<envar>PGDATA</envar>必须指向包含配置文件的目录，并且<filename>postgresql.conf</filename>中（或者命令行上）的<varname>data_directory</varname>参数必须显示数据目录实际存放的地方。请注意，<varname>data_directory</varname>将覆盖<option>-D</option>和<envar>PGDATA</envar>指定的数据目录位置，但是不覆盖配置文件的位置。
     </para>

<!--==========================orignal english content==========================
     <para>
      If you wish, you can specify the configuration file names and locations
      individually using the parameters <varname>config_file</varname>,
      <varname>hba_file</varname> and/or <varname>ident_file</varname>.
      <varname>config_file</varname> can only be specified on the
      <command>postgres</command> command line, but the others can be
      set within the main configuration file.  If all three parameters plus
      <varname>data_directory</varname> are explicitly set, then it is not necessary
      to specify <option>-D</option> or <envar>PGDATA</envar>.
     </para>
____________________________________________________________________________-->
     <para>
      如果你愿意，可以使用选项<varname>config_file</varname>、<varname>hba_file</varname>和/或<varname>ident_file</varname>单独指定配置文件名称和位置。<varname>config_file</varname>只能在<command>postgres</command>命令行上指定，但是其他文件可以在主配置文件中设置。如果所有三个参数外加<varname>data_directory</varname>被显式地设置，则不必指定<option>-D</option>或<envar>PGDATA</envar>。
     </para>

<!--==========================orignal english content==========================
     <para>
      When setting any of these parameters, a relative path will be interpreted
      with respect to the directory in which <command>postgres</command>
      is started.
     </para>
____________________________________________________________________________-->
     <para>
      在设置任何这些参数时，相对路径将被解释为相对于<command>postgres</command>启动路径的路径。
     </para>
   </sect1>

   <sect1 id="runtime-config-connection">
<!--==========================orignal english content==========================
    <title>Connections and Authentication</title>
____________________________________________________________________________-->
    <title>连接和认证</title>

    <sect2 id="runtime-config-connection-settings">
<!--==========================orignal english content==========================
     <title>Connection Settings</title>
____________________________________________________________________________-->
     <title>连接设置</title>

     <variablelist>

     <varlistentry id="guc-listen-addresses" xreflabel="listen_addresses">
<!--==========================orignal english content==========================
      <term><varname>listen_addresses</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>listen_addresses</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>listen_addresses</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>listen_addresses</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
         Specifies the TCP/IP address(es) on which the server is
         to listen for connections from client applications.
         The value takes the form of a comma-separated list of host names
         and/or numeric IP addresses.  The special entry <literal>*</literal>
         corresponds to all available IP interfaces.  The entry
         <literal>0.0.0.0</literal> allows listening for all IPv4 addresses and
         <literal>::</literal> allows listening for all IPv6 addresses.
         If the list is empty, the server does not listen on any IP interface
         at all, in which case only Unix-domain sockets can be used to connect
         to it.
         The default value is <systemitem class="systemname">localhost</systemitem>,
         which allows only local TCP/IP <quote>loopback</quote> connections to be
         made.  While client authentication (<xref
         linkend="client-authentication"/>) allows fine-grained control
         over who can access the server, <varname>listen_addresses</varname>
         controls which interfaces accept connection attempts, which
         can help prevent repeated malicious connection requests on
         insecure network interfaces.  This parameter can only be set
         at server start.
       </para>
____________________________________________________________________________-->
       <para>
         指定服务器在哪些 TCP/IP 地址上监听客户端连接。值的形式是一个逗号分隔的主机名和/或数字 IP 地址列表。特殊项<literal>*</literal>对应所有可用 IP 接口。项<literal>0.0.0.0</literal>允许监听所有 IPv4 地址并且<literal>::</literal>允许监听所有 IPv6 地址。如果列表为空，服务器将根本不会监听任何 IP 接口，在这种情况中只能使用 Unix 域套接字来连接它。默认值是<systemitem class="systemname">localhost</systemitem>，它只允许建立本地 TCP/IP <quote>环回</quote>连接。虽然客户端认证（<xref linkend="client-authentication"/>）允许细粒度地控制谁能访问服务器，<varname>listen_addresses</varname>控制哪些接口接受连接尝试，这能帮助在不安全网络接口上阻止重复的恶意连接请求。这个参数只能在服务器启动时设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-port" xreflabel="port">
<!--==========================orignal english content==========================
      <term><varname>port</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>port</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>port</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>port</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The TCP port the server listens on; 5432 by default.  Note that the
        same port number is used for all IP addresses the server listens on.
        This parameter can only be set at server start.
       </para>
____________________________________________________________________________-->
       <para>
        服务器监听的 TCP 端口；默认是 5432 。请注意服务器会同一个端口号监听所有的 IP 地址。这个参数只能在服务器启动时设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-connections" xreflabel="max_connections">
<!--==========================orignal english content==========================
      <term><varname>max_connections</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_connections</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>max_connections</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_connections</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Determines the maximum number of concurrent connections to the
        database server. The default is typically 100 connections, but
        might be less if your kernel settings will not support it (as
        determined during <application>initdb</application>).  This parameter can
        only be set at server start.
       </para>
____________________________________________________________________________-->
       <para>
        决定数据库的最大并发连接数。默认值通常是 100 个连接，但是如果内核设置不支持（<application>initdb</application>时决定），可能会比这个 数少。这个参数只能在服务器启动时设置。
       </para>

<!--==========================orignal english content==========================
       <para>
        When running a standby server, you must set this parameter to the
        same or higher value than on the primary server. Otherwise, queries
        will not be allowed in the standby server.
       </para>
____________________________________________________________________________-->
       <para>
        当运行一个后备服务器时，你必须设置这个参数等于或大于主服务器上的参数。
        否则，后备服务器上可能无法允许查询。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-superuser-reserved-connections"
     xreflabel="superuser_reserved_connections">
<!--==========================orignal english content==========================
      <term><varname>superuser_reserved_connections</varname>
      (<type>integer</type>)
      <indexterm>
       <primary><varname>superuser_reserved_connections</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>superuser_reserved_connections</varname>
      (<type>integer</type>)
      <indexterm>
       <primary><varname>superuser_reserved_connections</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Determines the number of connection <quote>slots</quote> that
        are reserved for connections by <productname>PostgreSQL</productname>
        superusers.  At most <xref linkend="guc-max-connections"/>
        connections can ever be active simultaneously.  Whenever the
        number of active concurrent connections is at least
        <varname>max_connections</varname> minus
        <varname>superuser_reserved_connections</varname>, new
        connections will be accepted only for superusers, and no
        new replication connections will be accepted.
       </para>
____________________________________________________________________________-->
       <para>
        决定为<productname>PostgreSQL</productname>超级用户连接而保留的连接<quote>槽</quote>数。 同时活跃的并发连接最多<xref linkend="guc-max-connections"/>个。任何时候，活跃的并发连接数最多为<varname>max_connections</varname>减去 <varname>superuser_reserved_connections</varname>，新连接就只能由超级用户发起了，并且不会有新的复制连接被接受。
       </para>

<!--==========================orignal english content==========================
       <para>
        The default value is three connections. The value must be less
        than <varname>max_connections</varname>.
        This parameter can only be set at server start.
       </para>
____________________________________________________________________________-->
       <para>
        默认值是 3 连接 。这个值必须小于<varname>max_connections</varname>。 这个参数只能在服务器启动时设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-unix-socket-directories" xreflabel="unix_socket_directories">
<!--==========================orignal english content==========================
      <term><varname>unix_socket_directories</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>unix_socket_directories</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>unix_socket_directories</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>unix_socket_directories</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the directory of the Unix-domain socket(s) on which the
        server is to listen for connections from client applications.
        Multiple sockets can be created by listing multiple directories
        separated by commas.  Whitespace between entries is
        ignored; surround a directory name with double quotes if you need
        to include whitespace or commas in the name.
        An empty value
        specifies not listening on any Unix-domain sockets, in which case
        only TCP/IP sockets can be used to connect to the server.
       </para>
____________________________________________________________________________-->
       <para>
        指定服务器用于监听来自客户端应用的连接的 Unix 域套接字目录。通过列出用逗号分隔的多个目录可以建立多个套接字。
        项之间的空白被忽略，如果你需要在名字中包括空白或逗号，在目录名周围放上双引号。
        一个空值指定在任何 Unix 域套接字上都不监听，在这种情况中只能使用 TCP/IP 套接字来连接到服务器。
       </para>

<!--==========================orignal english content==========================
       <para>
        A value that starts with <literal>@</literal> specifies that a
        Unix-domain socket in the abstract namespace should be created
        (currently supported on Linux and Windows).  In that case, this value
        does not specify a <quote>directory</quote> but a prefix from which
        the actual socket name is computed in the same manner as for the
        file-system namespace.  While the abstract socket name prefix can be
        chosen freely, since it is not a file-system location, the convention
        is to nonetheless use file-system-like values such as
        <literal>@/tmp</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        以<literal>@</literal>开头的值指定将要在抽象命名空间中创建Unix-domain套接字(当前在Linux和Windows上支持)。
        在这种情况下，该值不指定<quote>directory</quote>，而是指定一个前缀，实际的套接字名称以与文件系统名称空间相同的方式从该前缀计算。
        虽然抽象套接字名称前缀可以自由选择，由于它不是一个文件系统位置，但惯例上仍然使用类似文件系统的值，例如<literal>@/tmp</literal>。
       </para>

<!--==========================orignal english content==========================
       <para>
        The default value is normally
        <filename>/tmp</filename>, but that can be changed at build time.
        On Windows, the default is empty, which means no Unix-domain socket is
        created by default.
        This parameter can only be set at server start.
       </para>
____________________________________________________________________________-->
       <para>
        默认值通常是<filename>/tmp</filename>，但是在编译时可以被改变。
        在windows上，默认值为空，意味着默认不建立UNIX-域嵌套。这个参数只能在服务器启动时设置。
       </para>

<!--==========================orignal english content==========================
       <para>
        In addition to the socket file itself, which is named
        <literal>.s.PGSQL.<replaceable>nnnn</replaceable></literal> where
        <replaceable>nnnn</replaceable> is the server's port number, an ordinary file
        named <literal>.s.PGSQL.<replaceable>nnnn</replaceable>.lock</literal> will be
        created in each of the <varname>unix_socket_directories</varname> directories.
        Neither file should ever be removed manually.
        For sockets in the abstract namespace, no lock file is created.
       </para>
____________________________________________________________________________-->
       <para>
        除了套接字文件本身（名为<literal>.s.PGSQL.<replaceable>nnnn</replaceable></literal>，其中<replaceable>nnnn</replaceable>是服务器的端口号），一个名为<literal>.s.PGSQL.<replaceable>nnnn</replaceable>.lock</literal>的普通文件会在每一个<varname>unix_socket_directories</varname>目录中被创建。
        任何一个都不应该被手工移除。
        对于抽象命名空间，没有锁文件被建立。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-unix-socket-group" xreflabel="unix_socket_group">
<!--==========================orignal english content==========================
      <term><varname>unix_socket_group</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>unix_socket_group</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>unix_socket_group</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>unix_socket_group</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the owning group of the Unix-domain socket(s).  (The owning
        user of the sockets is always the user that starts the
        server.)  In combination with the parameter
        <varname>unix_socket_permissions</varname> this can be used as
        an additional access control mechanism for Unix-domain connections.
        By default this is the empty string, which uses the default
        group of the server user.  This parameter can only be set at
        server start.
       </para>
____________________________________________________________________________-->
       <para>
        设置 Unix 域套接字的所属组（套接字的所属用户总是启动服务器的用户）。可以与选项<varname>unix_socket_permissions</varname>一起用于对 Unix域连接进行访问控制。默认是一个空字符串，表示服务器用户的默认组。这个参数只能在服务器启动时设置。
       </para>

<!--==========================orignal english content==========================
       <para>
        This parameter is not supported on Windows.  Any setting will be
        ignored.  Also, sockets in the abstract namespace have no file owner,
        so this setting is also ignored in that case.
       </para>
____________________________________________________________________________-->
       <para>
        Windows 上不支持这个参数。
        所有设置会被忽略。
        同样，抽象命名空间中的套接字没有文件属主，所以在这种情况下，这个设置也会被忽略。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-unix-socket-permissions" xreflabel="unix_socket_permissions">
<!--==========================orignal english content==========================
      <term><varname>unix_socket_permissions</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>unix_socket_permissions</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>unix_socket_permissions</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>unix_socket_permissions</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the access permissions of the Unix-domain socket(s).  Unix-domain
        sockets use the usual Unix file system permission set.
        The parameter value is expected to be a numeric mode
        specified in the format accepted by the
        <function>chmod</function> and <function>umask</function>
        system calls.  (To use the customary octal format the number
        must start with a <literal>0</literal> (zero).)
       </para>
____________________________________________________________________________-->
       <para>
        设置 Unix 域套接字的访问权限。Unix 域套接字使用普通的 Unix 文件系统权限集。这个参数值应该是数字的形式，也就是系统调用<function>chmod</function>和<function>umask</function>接受的 形式（如果使用自定义的八进制格式，数字必须以一个<literal>0</literal>（零）开头）。
       </para>

<!--==========================orignal english content==========================
       <para>
        The default permissions are <literal>0777</literal>, meaning
        anyone can connect. Reasonable alternatives are
        <literal>0770</literal> (only user and group, see also
        <varname>unix_socket_group</varname>) and <literal>0700</literal>
        (only user). (Note that for a Unix-domain socket, only write
        permission matters, so there is no point in setting or revoking
        read or execute permissions.)
       </para>
____________________________________________________________________________-->
       <para>
        默认的权限是<literal>0777</literal>，意思是任何人都可以连接。合理的候选是<literal>0770</literal>（只有用户和同组的人可以访问， 又见<varname>unix_socket_group</varname>）和<literal>0700</literal>（只有用户自己可以访问）（请注意，对于 Unix 域套接字，只有写权限有麻烦，因此没有对读取和执行权限的设置和收回）。
       </para>

<!--==========================orignal english content==========================
       <para>
        This access control mechanism is independent of the one
        described in <xref linkend="client-authentication"/>.
       </para>
____________________________________________________________________________-->
       <para>
        这个访问控制机制与<xref linkend="client-authentication"/>中的用户认证没有关系。
       </para>

<!--==========================orignal english content==========================
       <para>
        This parameter can only be set at server start.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数只能在服务器启动时设置。
       </para>

<!--==========================orignal english content==========================
       <para>
        This parameter is irrelevant on systems, notably Solaris as of Solaris
        10, that ignore socket permissions entirely.  There, one can achieve a
        similar effect by pointing <varname>unix_socket_directories</varname> to a
        directory having search permission limited to the desired audience.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数与完全忽略套接字权限的系统无关，尤其是自版本10以上的Solaris。
        在那些系统上，可以通过把<varname>unix_socket_directories</varname>指向一个把搜索权限
        限制给指定用户的目录来实现相似的效果。
       </para>

<!--==========================orignal english content==========================
       <para>
        Sockets in the abstract namespace have no file permissions, so this
        setting is also ignored in that case.
       </para>
____________________________________________________________________________-->
       <para>
        抽象命名空间中的套接字没有文件权限，所以这种情况下这个设置也会被忽略。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-bonjour" xreflabel="bonjour">
<!--==========================orignal english content==========================
      <term><varname>bonjour</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>bonjour</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>bonjour</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>bonjour</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Enables advertising the server's existence via
        <productname>Bonjour</productname>.  The default is off.
        This parameter can only be set at server start.
       </para>
____________________________________________________________________________-->
       <para>
        通过<productname>Bonjour</productname>广告服务器的存在。默认值是关闭。
        这个参数只能在服务器启动时设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-bonjour-name" xreflabel="bonjour_name">
<!--==========================orignal english content==========================
      <term><varname>bonjour_name</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>bonjour_name</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>bonjour_name</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>bonjour_name</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the <productname>Bonjour</productname> service
        name.  The computer name is used if this parameter is set to the
        empty string <literal>''</literal> (which is the default).  This parameter is
        ignored if the server was not compiled with
        <productname>Bonjour</productname> support.
        This parameter can only be set at server start.
       </para>
____________________________________________________________________________-->
       <para>
        指定<productname>Bonjour</productname>服务名称。空字符串<literal>''</literal>（默认值）表示使用计算机名。 如果编译时没有打开<productname>Bonjour</productname>支持那么将忽略这个参数。这个参数只能在服务器启动时设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-tcp-keepalives-idle" xreflabel="tcp_keepalives_idle">
<!--==========================orignal english content==========================
      <term><varname>tcp_keepalives_idle</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>tcp_keepalives_idle</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>tcp_keepalives_idle</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>tcp_keepalives_idle</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the amount of time with no network activity after which
        the operating system should send a TCP keepalive message to the client.
        If this value is specified without units, it is taken as seconds.
        A value of 0 (the default) selects the operating system's default.
        This parameter is supported only on systems that support
        <symbol>TCP_KEEPIDLE</symbol> or an equivalent socket option, and on
        Windows; on other systems, it must be zero.
        In sessions connected via a Unix-domain socket, this parameter is
        ignored and always reads as zero.
       </para>
____________________________________________________________________________-->
       <para>
        规定在操作系统向客户端发送一个TCP keepalive消息后无网络活动的时间总量。
        如果指定值时没有单位，则以秒为单位。值0(默认值)表示选择操作系统默认值。
        指定不活动多少秒之后通过 TCP 向客户端发送一个 keepalive 消息。 0 值表示使用默认值。
        这个参数只有在支持<symbol>TCP_KEEPIDLE</symbol>或等效套接字选项的系统或 Windows 上才可以使用。在其他系统上，它必须为零。在通过 Unix 域套接字连接的会话中，这个参数被忽略并且总是读作零。
       </para>
       <note>
<!--==========================orignal english content==========================
        <para>
         On Windows, setting a value of 0 will set this parameter to 2 hours,
         since Windows does not provide a way to read the system default value.
        </para>
____________________________________________________________________________-->
        <para>
         在 Windows 上，设定值为0将设置这个参数为 2 小时，因为 Windows 不支持读取系统默认值。
        </para>
       </note>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-tcp-keepalives-interval" xreflabel="tcp_keepalives_interval">
<!--==========================orignal english content==========================
      <term><varname>tcp_keepalives_interval</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>tcp_keepalives_interval</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>tcp_keepalives_interval</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>tcp_keepalives_interval</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the amount of time after which a TCP keepalive message
        that has not been acknowledged by the client should be retransmitted.
        If this value is specified without units, it is taken as seconds.
        A value of 0 (the default) selects the operating system's default.
        This parameter is supported only on systems that support
        <symbol>TCP_KEEPINTVL</symbol> or an equivalent socket option, and on
        Windows; on other systems, it must be zero.
        In sessions connected via a Unix-domain socket, this parameter is
        ignored and always reads as zero.
       </para>
____________________________________________________________________________-->
       <para>
        规定未被客户端确认收到的TCP keepalive消息应重新传输的时间长度。
        如果指定值时没有单位，则以秒为单位。值0(默认值)表示选择操作系统默认值。
		这个参数只有在支持<symbol>TCP_KEEPINTVL</symbol>或等效套接字选项的系统或 Windows 上才可以使用。在其他系统上，必须为零。在通过 Unix域套接字连接的会话中，这个参数被忽略并总被读作零。
       </para>
       <note>
<!--==========================orignal english content==========================
        <para>
         On Windows, setting a value of 0 will set this parameter to 1 second,
         since Windows does not provide a way to read the system default value.
        </para>
____________________________________________________________________________-->
        <para>
         在 Windows 上，设定值为0将设置这个参数为 1 秒，因为 Windows 不支持读取系统默认值。
        </para>
       </note>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-tcp-keepalives-count" xreflabel="tcp_keepalives_count">
<!--==========================orignal english content==========================
      <term><varname>tcp_keepalives_count</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>tcp_keepalives_count</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>tcp_keepalives_count</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>tcp_keepalives_count</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the number of TCP keepalive messages that can be lost before
        the server's connection to the client is considered dead.
        A value of 0 (the default) selects the operating system's default.
        This parameter is supported only on systems that support
        <symbol>TCP_KEEPCNT</symbol> or an equivalent socket option;
        on other systems, it must be zero.
        In sessions connected via a Unix-domain socket, this parameter is
        ignored and always reads as zero.
       </para>
____________________________________________________________________________-->
       <para>
        指定服务器到客户端的连接被认为中断之前可以丢失的TCP keepalive消息的数量。值0(默认值)表示选择操作系统默认值。
        这个参数只有在支持<symbol>TCP_KEEPCNT</symbol>或等效套接字选项的系统上才可以使用。在其他系统上，必须为零。在通过 Unix 域套接字连接的会话中，这个参数被忽略并总被读作零。
       </para>
       <note>
<!--==========================orignal english content==========================
        <para>
         This parameter is not supported on Windows, and must be zero.
        </para>
____________________________________________________________________________-->
        <para>
         Windows 不支持该参数，且必须为零。
        </para>
       </note>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-tcp-user-timeout" xreflabel="tcp_user_timeout">
<!--==========================orignal english content==========================
      <term><varname>tcp_user_timeout</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>tcp_user_timeout</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>tcp_user_timeout</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>tcp_user_timeout</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the amount of time that transmitted data may
        remain unacknowledged before the TCP connection is forcibly closed.
        If this value is specified without units, it is taken as milliseconds.
        A value of 0 (the default) selects the operating system's default.
        This parameter is supported only on systems that support
        <symbol>TCP_USER_TIMEOUT</symbol>; on other systems, it must be zero.
        In sessions connected via a Unix-domain socket, this parameter is
        ignored and always reads as zero.
       </para>
____________________________________________________________________________-->
       <para>
        指定传输的数据在TCP连接被强制关闭之前可以保持未确认状态的时间量。
        如果指定值时没有单位，则以毫秒为单位。值0(默认值)表示选择操作系统默认值。
        这个参数只有在支持<symbol>TCP_USER_TIMEOUT</symbol>的系统上才被支持；在其他系统上，它必须为零。
        在通过Unix-domain 套接字连接的会话中，此参数将被忽略并且始终读取为零。
       </para>
       <note>
<!--==========================orignal english content==========================
        <para>
         This parameter is not supported on Windows, and must be zero.
        </para>
____________________________________________________________________________-->
        <para>
         在Windows上不支持该参数，并且必须为零。
        </para>
       </note>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-client-connection-check-interval" xreflabel="client_connection_check_interval">
<!--==========================orignal english content==========================
      <term><varname>client_connection_check_interval</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>client_connection_check_interval</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>client_connection_check_interval</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>client_connection_check_interval</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the time interval between optional checks that the client is still
        connected, while running queries.  The check is performed by polling
        the socket, and allows long running queries to be aborted sooner if
        the kernel reports that the connection is closed.
       </para>
____________________________________________________________________________-->
       <para>
        在运行查询时，设置检查客户端是否保持连接的可选检查的时间间隔。
        这个检查通过轮询套接字来执行，并且在内核报告该连接关闭时，允许长时间运行的查询可以尽快中止。
       </para>
<!--==========================orignal english content==========================
       <para>
        This option is currently available only on systems that support the
        non-standard <symbol>POLLRDHUP</symbol> extension to the
        <symbol>poll</symbol> system call, including Linux.
       </para>
____________________________________________________________________________-->
       <para>
        这个选项当前仅在支持非标的<symbol>POLLRDHUP</symbol>扩展到<symbol>poll</symbol>系统调用的系统上有效，包括Linux.
       </para>
<!--==========================orignal english content==========================
       <para>
        If the value is specified without units, it is taken as milliseconds.
        The default value is <literal>0</literal>, which disables connection
        checks.  Without connection checks, the server will detect the loss of
        the connection only at the next interaction with the socket, when it
        waits for, receives or sends data.
       </para>
____________________________________________________________________________-->
       <para>
        如果指定的值没有单位，则以毫秒为单位。
        默认值为<literal>0</literal>，代表禁用连接检查。
        没有连接检查，服务器将只在与套接字的下一次交互时检测连接的丢失，当它等待、接收或发送数据时。
       </para>
<!--==========================orignal english content==========================
       <para>
        For the kernel itself to detect lost TCP connections reliably and within
        a known timeframe in all scenarios including network failure, it may
        also be necessary to adjust the TCP keepalive settings of the operating
        system, or the <xref linkend="guc-tcp-keepalives-idle"/>,
        <xref linkend="guc-tcp-keepalives-interval"/> and
        <xref linkend="guc-tcp-keepalives-count"/> settings of
        <productname>PostgreSQL</productname>.
       </para>
____________________________________________________________________________-->
       <para>
        为了让内核本身能够在包括网络故障在内的所有场景中，在已知的时间范围内可靠地检测丢失的TCP连接，它可能还需要调整操作系统的TCP保持连接设置，
        或者<productname>PostgreSQL</productname>的<xref linkend="guc-tcp-keepalives-idle"/>,  <xref linkend="guc-tcp-keepalives-interval"/> 和 <xref linkend="guc-tcp-keepalives-count"/> 设置。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
     </sect2>

     <sect2 id="runtime-config-connection-authentication">
<!--==========================orignal english content==========================
     <title>Authentication</title>
____________________________________________________________________________-->
     <title>安全和认证</title>

     <variablelist>
     <varlistentry id="guc-authentication-timeout" xreflabel="authentication_timeout">
<!--==========================orignal english content==========================
      <term><varname>authentication_timeout</varname> (<type>integer</type>)
      <indexterm><primary>timeout</primary><secondary>client authentication</secondary></indexterm>
      <indexterm><primary>client authentication</primary><secondary>timeout during</secondary></indexterm>
      <indexterm>
       <primary><varname>authentication_timeout</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>authentication_timeout</varname> (<type>integer</type>)
      <indexterm><primary>timeout</primary><secondary>client authentication</secondary></indexterm>
      <indexterm><primary>client authentication</primary><secondary>timeout during</secondary></indexterm>
      <indexterm>
       <primary><varname>authentication_timeout</varname>配置参数</primary>
      </indexterm>
      </term>

      <listitem>
<!--==========================orignal english content==========================
       <para>
        Maximum amount of time allowed to complete client authentication. If a
        would-be client has not completed the authentication protocol in
        this much time, the server closes the connection. This prevents
        hung clients from occupying a connection indefinitely.
        If this value is specified without units, it is taken as seconds.
        The default is one minute (<literal>1m</literal>).
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        允许完成客户端认证的最长时间。如果一个客户端没有在这段时间里完成认证协议，服务器将关闭连接。
        这样就避免了出问题的客户端无限制地占有一个连接。如果指定值时没有单位，则以秒为单位。
        默认值是 1分钟（<literal>1m</literal>）。这个参数只能在服务器命令行上或者在<filename>postgresql.conf</filename>文件中设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-password-encryption" xreflabel="password_encryption">
<!--==========================orignal english content==========================
      <term><varname>password_encryption</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>password_encryption</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>password_encryption</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>password_encryption</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        When a password is specified in <xref linkend="sql-createrole"/> or
        <xref linkend="sql-alterrole"/>, this parameter determines the
        algorithm to use to encrypt the password.  Possible values are
        <literal>scram-sha-256</literal>, which will encrypt the password with
        SCRAM-SHA-256, and <literal>md5</literal>, which stores the password
        as an MD5 hash.  The default is <literal>scram-sha-256</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        当在<xref linkend="sql-createrole"/>或者<xref linkend="sql-alterrole"/>中指定了口令时，这个参数决定用于加密该口令的算法。
        可能的值是 <literal>scram-sha-256</literal>, 可以用SCRAM-SHA-256, 和 <literal>md5</literal>加密密码，以MD5 哈希的方式存储密码。 
        默认为 <literal>scram-sha-256</literal>。
       </para>

<!--==========================orignal english content==========================
       <para>
        Note that older clients might lack support for the SCRAM authentication
        mechanism, and hence not work with passwords encrypted with
        SCRAM-SHA-256.  See <xref linkend="auth-password"/> for more details.
       </para>
____________________________________________________________________________-->
       <para>
        注意老的客户端可能缺少对SCRAM认证机制的支持，因此无法使用用SCRAM-SHA-256加密的口令。详情请参考<xref linkend="auth-password"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-krb-server-keyfile" xreflabel="krb_server_keyfile">
<!--==========================orignal english content==========================
      <term><varname>krb_server_keyfile</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>krb_server_keyfile</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>krb_server_keyfile</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>krb_server_keyfile</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the location of the server's Kerberos key file.  The default is
        <filename>FILE:/usr/local/pgsql/etc/krb5.keytab</filename>
        (where the directory part is whatever was specified
        as <varname>sysconfdir</varname> at build time; use
        <literal>pg_config -&minus;sysconfdir</literal> to determine that).
        If this parameter is set to an empty string, it is ignored and a
        system-dependent default is used.
        This parameter can only be set in the
        <filename>postgresql.conf</filename> file or on the server command line.
        See <xref linkend="gssapi-auth"/> for more information.
       </para>
____________________________________________________________________________-->
       <para>
        设置服务器的Kerberos密钥文件的位置。
        默认为<filename>FILE:/usr/local/pgsql/etc/krb5.keytab</filename>（其中目录部分是在构建时由<varname>sysconfdir</varname>指定的；用<literal>pg_config --sysconfdir</literal>来决定）。
        如果这个参数被设为空字符串，它将被忽略，并且系统依赖的默认值被应用。
        这个参数只能在<filename>postgresql.conf</filename>文件中或者服务器命令行上设置。
        详情请参考<xref linkend="gssapi-auth"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-krb-caseins-users" xreflabel="krb_caseins_users">
<!--==========================orignal english content==========================
      <term><varname>krb_caseins_users</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>krb_caseins_users</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>krb_caseins_users</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>krb_caseins_users</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets whether GSSAPI user names should be treated
        case-insensitively.
        The default is <literal>off</literal> (case sensitive). This parameter can only be
        set in the <filename>postgresql.conf</filename> file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        设置是否应该以大小写不敏感的方式对待GSSAPI用户名。默认值是<literal>off</literal>（大小写敏感）。这个参数只能在<filename>postgresql.conf</filename>文件中或者服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-db-user-namespace" xreflabel="db_user_namespace">
<!--==========================orignal english content==========================
      <term><varname>db_user_namespace</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>db_user_namespace</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>db_user_namespace</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>db_user_namespace</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        This parameter enables per-database user names.  It is off by default.
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数启用针对每个数据库的用户名。这个参数默认是关掉的。这个参数只能在<filename>postgresql.conf</filename>文件中或者服务器命令行上设置。
       </para>

<!--==========================orignal english content==========================
       <para>
        If this is on, you should create users as <replaceable>username@dbname</replaceable>.
        When <replaceable>username</replaceable> is passed by a connecting client,
        <literal>@</literal> and the database name are appended to the user
        name and that database-specific user name is looked up by the
        server. Note that when you create users with names containing
        <literal>@</literal> within the SQL environment, you will need to
        quote the user name.
       </para>
____________________________________________________________________________-->
       <para>
        如果这个参数为打开，应该把用户创建成<replaceable>username@dbname</replaceable>的形式。当一个连接客户端传来<replaceable>username</replaceable>时，<literal>@</literal>和数据库名会被追加到用户名并且服务器会查找这个与数据库相关的用户名。注意在SQL环境中用含有<literal>@</literal>的名称创建用户时，需要把用户名放在引号内。
       </para>

<!--==========================orignal english content==========================
       <para>
        With this parameter enabled, you can still create ordinary global
        users.  Simply append <literal>@</literal> when specifying the user
        name in the client, e.g., <literal>joe@</literal>.  The <literal>@</literal>
        will be stripped off before the user name is looked up by the
        server.
       </para>
____________________________________________________________________________-->
       <para>
        在这个参数被启用时，仍然可以创建平常的全局用户。而在客户端中指定这种用户时只需要简单地追加<literal>@</literal>，例如<literal>joe@</literal>。在服务器查找该用户名之前，<literal>@</literal>会被剥离掉。
       </para>

<!--==========================orignal english content==========================
       <para>
        <varname>db_user_namespace</varname> causes the client's and
        server's user name representation to differ.
        Authentication checks are always done with the server's user name
        so authentication methods must be configured for the
        server's user name, not the client's.  Because
        <literal>md5</literal> uses the user name as salt on both the
        client and server, <literal>md5</literal> cannot be used with
        <varname>db_user_namespace</varname>.
       </para>
____________________________________________________________________________-->
       <para>
        <varname>db_user_namespace</varname>会导致客户端和服务器的用户名表达形式不同。认证检查总是会以服务器的用户名表达形式来完成，因此认证方法必须针对服务器用户名而不是客户端用户名来配置。由于<literal>md5</literal>方法在客户端和服务器两端都使用用户名作为salt，<literal>md5</literal>不能与<varname>db_user_namespace</varname>同时使用。
       </para>

       <note>
<!--==========================orignal english content==========================
        <para>
         This feature is intended as a temporary measure until a
         complete solution is found.  At that time, this option will
         be removed.
        </para>
____________________________________________________________________________-->
        <para>
         这种特性的目的是在找到完整的解决方案之前提供一种临时的措施。在找到完整解决方案时，这个选项将被去除。
        </para>
       </note>
      </listitem>
     </varlistentry>
     </variablelist>
     </sect2>

     <sect2 id="runtime-config-connection-ssl">
<!--==========================orignal english content==========================
     <title>SSL</title>
____________________________________________________________________________-->
     <title>SSL</title>

<!--==========================orignal english content==========================
     <para>
      See <xref linkend="ssl-tcp"/> for more information about setting up SSL.
     </para>
____________________________________________________________________________-->
     <para>
      有关设置SSL的更多信息请参考<xref linkend="ssl-tcp"/>。
     </para>

     <variablelist>
     <varlistentry id="guc-ssl" xreflabel="ssl">
<!--==========================orignal english content==========================
      <term><varname>ssl</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>ssl</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>ssl</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>ssl</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Enables <acronym>SSL</acronym> connections.
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
        The default is <literal>off</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        启用<acronym>SSL</acronym>连接。这个参数只能在<filename>postgresql.conf</filename>文件中或者服务器命令行上设置。默认值是<literal>off</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ssl-ca-file" xreflabel="ssl_ca_file">
<!--==========================orignal english content==========================
      <term><varname>ssl_ca_file</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>ssl_ca_file</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>ssl_ca_file</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>ssl_ca_file</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the name of the file containing the SSL server certificate
        authority (CA).
        Relative paths are relative to the data directory.
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
        The default is empty, meaning no CA file is loaded,
        and client certificate verification is not performed.
       </para>
____________________________________________________________________________-->
       <para>
        指定包含 SSL 服务器证书颁发机构（CA）的文件名。相对路径是相对于数据目录的。这个参数只能在<filename>postgresql.conf</filename>文件中或者服务器命令行上设置。默认值为空，表示没有载入CA文件，并且客户端证书验证没有被执行。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ssl-cert-file" xreflabel="ssl_cert_file">
<!--==========================orignal english content==========================
      <term><varname>ssl_cert_file</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>ssl_cert_file</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>ssl_cert_file</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>ssl_cert_file</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the name of the file containing the SSL server certificate.
        Relative paths are relative to the data directory.
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
        The default is <filename>server.crt</filename>.
       </para>
____________________________________________________________________________-->
       <para>
        指定包含 SSL 服务器证书的文件名。相对路径是相对于数据目录的。这个参数只能在<filename>postgresql.conf</filename>文件中或者服务器命令行上设置。默认值是<filename>server.crt</filename>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ssl-crl-file" xreflabel="ssl_crl_file">
<!--==========================orignal english content==========================
      <term><varname>ssl_crl_file</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>ssl_crl_file</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>ssl_crl_file</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>ssl_crl_file</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the name of the file containing the SSL server certificate
        revocation list (CRL).
        Relative paths are relative to the data directory.
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
        The default is empty, meaning no CRL file is loaded (unless
        <xref linkend="guc-ssl-crl-dir"/> is set).
       </para>
____________________________________________________________________________-->
       <para>
        指定包含 SSL 服务器证书撤销列表（CRL）的文件名。其中的相对路径是相对于数据目录的。
        这个参数只能在<filename>postgresql.conf</filename>文件中或者服务器命令行上设置。
        默认值是空，表示没有载入CRL文件(除非设定了 <xref linkend="guc-ssl-crl-dir"/> is set)。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ssl-crl-dir" xreflabel="ssl_crl_dir">
<!--==========================orignal english content==========================
      <term><varname>ssl_crl_dir</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>ssl_crl_dir</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>ssl_crl_dir</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>ssl_crl_dir</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the name of the directory containing the SSL server
        certificate revocation list (CRL).  Relative paths are relative to the
        data directory.  This parameter can only be set in
        the <filename>postgresql.conf</filename> file or on the server command
        line.  The default is empty, meaning no CRLs are used (unless
        <xref linkend="guc-ssl-crl-file"/> is set).
       </para>
____________________________________________________________________________-->
       <para>
        指定包含SSD服务器证书吊销列表(CRL)的目录的名称。
        相对路径与数据目录相关。
        这个参数只能在<filename>postgresql.conf</filename>文件中设置或者通过服务器命令行。
        默认值为空，意味着没有使用CRLs(除非设定了<xref linkend="guc-ssl-crl-file"/>)。
       </para>

<!--==========================orignal english content==========================
       <para>
        The directory needs to be prepared with the
        <productname>OpenSSL</productname> command
        <literal>openssl rehash</literal> or <literal>c_rehash</literal>.  See
        its documentation for details.
       </para>
____________________________________________________________________________-->
       <para>
        这个目录需要用<productname>OpenSSL</productname> 命令 <literal>openssl rehash</literal> 或 <literal>c_rehash</literal>来准备。
        详请参阅相应文档
       </para>

<!--==========================orignal english content==========================
       <para>
        When using this setting, CRLs in the specified directory are loaded
        on-demand at connection time.  New CRLs can be added to the directory
        and will be used immediately.  This is unlike <xref
        linkend="guc-ssl-crl-file"/>, which causes the CRL in the file to be
        loaded at server start time or when the configuration is reloaded.
        Both settings can be used together.
       </para>
____________________________________________________________________________-->
       <para>
        当使用此设置时，在连接时会按需加载指定目录下的CRLs。
        新的CRLs可以添加到该目录中，并可以立即使用。
        这与<xref linkend="guc-ssl-crl-file"/>不同，那个会导致文件中的CRL在服务器启动时间或重新加载配置时加载。
        两个设置可以一起使用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ssl-key-file" xreflabel="ssl_key_file">
<!--==========================orignal english content==========================
      <term><varname>ssl_key_file</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>ssl_key_file</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>ssl_key_file</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>ssl_key_file</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the name of the file containing the SSL server private key.
        Relative paths are relative to the data directory.
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
        The default is <filename>server.key</filename>.
       </para>
____________________________________________________________________________-->
       <para>
        指定包含 SSL 服务器私钥的文件名。相对路径是相对于数据目录。这个参数只能在<filename>postgresql.conf</filename>文件中或者服务器命令行上设置。默认值是<filename>server.key</filename>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ssl-ciphers" xreflabel="ssl_ciphers">
<!--==========================orignal english content==========================
      <term><varname>ssl_ciphers</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>ssl_ciphers</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>ssl_ciphers</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>ssl_ciphers</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies a list of <acronym>SSL</acronym> cipher suites that are
        allowed to be used by SSL connections.  See the
        <citerefentry><refentrytitle>ciphers</refentrytitle></citerefentry>
        manual page in the <productname>OpenSSL</productname> package for the
        syntax of this setting and a list of supported values.  Only
        connections using TLS version 1.2 and lower are affected.  There is
        currently no setting that controls the cipher choices used by TLS
        version 1.3 connections.  The default value is
        <literal>HIGH:MEDIUM:+3DES:!aNULL</literal>.  The default is usually a
        reasonable choice unless you have specific security requirements.
       </para>
____________________________________________________________________________-->
       <para>
        指定一个允许用于SSL连接的<acronym>SSL</acronym>密码套件列表。
        这个设置的语法和所支持的值列表可以参见<productname>OpenSSL</productname>包中的<citerefentry><refentrytitle>ciphers</refentrytitle></citerefentry>手册页。
        仅在使用 TLS 版本 1.2 及更低版本的连接才受影响。目前没有控制 TLS 版本 1.3 连接使用的密码选择的设置。 
        默认值是<literal>HIGH:MEDIUM:+3DES:!aNULL</literal>。默认值通常是一种合理的选择，除非用户有特定的安全性需求。
       </para>

<!--==========================orignal english content==========================
       <para>
        This parameter can only be set in the
        <filename>postgresql.conf</filename> file or on the server command
        line.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数只能在<filename>postgresql.conf</filename>文件中或者服务器命令行上设置。
       </para>

<!--==========================orignal english content==========================
       <para>
        Explanation of the default value:
        <variablelist>
         <varlistentry>
          <term><literal>HIGH</literal></term>
          <listitem>
           <para>
            Cipher suites that use ciphers from <literal>HIGH</literal> group (e.g.,
            AES, Camellia, 3DES)
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>MEDIUM</literal></term>
          <listitem>
           <para>
            Cipher suites that use ciphers from <literal>MEDIUM</literal> group
            (e.g., RC4, SEED)
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>+3DES</literal></term>
          <listitem>
           <para>
            The <productname>OpenSSL</productname> default order for
            <literal>HIGH</literal> is problematic because it orders 3DES
            higher than AES128.  This is wrong because 3DES offers less
            security than AES128, and it is also much slower.
            <literal>+3DES</literal> reorders it after all other
            <literal>HIGH</literal> and <literal>MEDIUM</literal> ciphers.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>!aNULL</literal></term>
          <listitem>
           <para>
            Disables anonymous cipher suites that do no authentication.  Such
            cipher suites are vulnerable to <acronym>MITM</acronym> attacks and
            therefore should not be used.
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>
____________________________________________________________________________-->
       <para>
        默认值的解释：
        <variablelist>
         <varlistentry>
          <term><literal>HIGH</literal></term>
          <listitem>
           <para>
            使用来自<literal>HIGH</literal>组的密码的密码组（例如 AES, Camellia, 3DES）
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>MEDIUM</literal></term>
          <listitem>
           <para>
            使用来自<literal>MEDIUM</literal>组的密码的密码组（例如 RC4, SEED）
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>+3DES</literal></term>
          <listitem>
           <para>
            <productname>OpenSSL</productname> 对<literal>HIGH</literal>的默认排序是有问题的，因为它认为 3DES 比AES128 更高。
            这是错误的，因为 3DES 提供的安全性比 AES128 低，并且它也更加慢。
            <literal>+3DES</literal>把它重新排序在所有其他<literal>HIGH</literal>和 <literal>MEDIUM</literal>密码之后。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>!aNULL</literal></term>
          <listitem>
           <para>
            禁用不做认证的匿名密码组。这类密码组容易收到<acronym>MITM</acronym>攻击，因此不应被使用。
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>

<!--==========================orignal english content==========================
       <para>
        Available cipher suite details will vary across
        <productname>OpenSSL</productname> versions.  Use the command
        <literal>openssl ciphers -v 'HIGH:MEDIUM:+3DES:!aNULL'</literal> to
        see actual details for the currently installed
        <productname>OpenSSL</productname> version.  Note that this list is
        filtered at run time based on the server key type.
       </para>
____________________________________________________________________________-->
       <para>
        可用的密码组细节可能会随着<productname>OpenSSL</productname> 版本变化。
        可使用命令 <literal>openssl ciphers -v 'HIGH:MEDIUM:+3DES:!aNULL'</literal>来查看当前安装的<productname>OpenSSL</productname>版本的实际细节。
        注意这个列表是根据服务器密钥类型在运行时过滤过的。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ssl-prefer-server-ciphers" xreflabel="ssl_prefer_server_ciphers">
<!--==========================orignal english content==========================
      <term><varname>ssl_prefer_server_ciphers</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>ssl_prefer_server_ciphers</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>ssl_prefer_server_ciphers</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>ssl_prefer_server_ciphers</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies whether to use the server's SSL cipher preferences, rather
        than the client's.
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
        The default is <literal>on</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        指定是否使用服务器的 SSL 密码首选项，而不是用客户端的。这个参数只能在<filename>postgresql.conf</filename>文件中或者服务器命令行上设置。
        默认值是 <literal>on</literal>。
       </para>

<!--==========================orignal english content==========================
       <para>
        Older PostgreSQL versions do not have this setting and always use the
        client's preferences.  This setting is mainly for backward
        compatibility with those versions.  Using the server's preferences is
        usually better because it is more likely that the server is appropriately
        configured.
       </para>
____________________________________________________________________________-->
       <para>
        老的PostgreSQL版本没有这个设置并且总是使用客户端的首选项。这个设置主要用于与那些版本
        的向后兼容性。使用服务器的首选项通常会更好，因为服务器更可能会被合适地配置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ssl-ecdh-curve" xreflabel="ssl_ecdh_curve">
<!--==========================orignal english content==========================
      <term><varname>ssl_ecdh_curve</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>ssl_ecdh_curve</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>ssl_ecdh_curve</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>ssl_ecdh_curve</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the name of the curve to use in <acronym>ECDH</acronym> key
        exchange.  It needs to be supported by all clients that connect.
        It does not need to be the same curve used by the server's Elliptic
        Curve key.
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
        The default is <literal>prime256v1</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        指定用在<acronym>ECDH</acronym>密钥交换中的曲线名称。它需要被所有连接的客户端支持。
        它不需要与服务器椭圆曲线密钥使用的曲线相同。这个参数只能在<filename>postgresql.conf</filename>文件中或者服务器命令行上设置。默认值是<literal>prime256v1</literal>。
       </para>

<!--==========================orignal english content==========================
       <para>
        <productname>OpenSSL</productname> names for the most common curves
        are:
        <literal>prime256v1</literal> (NIST P-256),
        <literal>secp384r1</literal> (NIST P-384),
        <literal>secp521r1</literal> (NIST P-521).
        The full list of available curves can be shown with the command
        <command>openssl ecparam -list_curves</command>.  Not all of them
        are usable in <acronym>TLS</acronym> though.
       </para>
____________________________________________________________________________-->
       <para>
        <productname>OpenSSL</productname>最常见的曲线名称是：
        <literal>prime256v1</literal> (NIST P-256)、
        <literal>secp384r1</literal> (NIST P-384)、
        <literal>secp521r1</literal> (NIST P-521)。
        <command>openssl ecparam -list_curves</command>命令可以显示可用曲线的完整列表。
        不过并不是所有的都在<acronym>TLS</acronym>中可用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ssl-min-protocol-version" xreflabel="ssl_min_protocol_version">
<!--==========================orignal english content==========================
      <term><varname>ssl_min_protocol_version</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>ssl_min_protocol_version</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>ssl_min_protocol_version</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>ssl_min_protocol_version</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the minimum SSL/TLS protocol version to use.  Valid values are
        currently: <literal>TLSv1</literal>, <literal>TLSv1.1</literal>,
        <literal>TLSv1.2</literal>, <literal>TLSv1.3</literal>.  Older
        versions of the <productname>OpenSSL</productname> library do not
        support all values; an error will be raised if an unsupported setting
        is chosen.  Protocol versions before TLS 1.0, namely SSL version 2 and
        3, are always disabled.
       </para>
____________________________________________________________________________-->
       <para>
        设置要使用的最小SSL/TLS协议版本。当前的可用版本包括： <literal>TLSv1</literal>, <literal>TLSv1.1</literal>, <literal>TLSv1.2</literal>, <literal>TLSv1.3</literal>.
        旧版本的 <productname>OpenSSL</productname> 库不支持所有值;如果选择了不支持的设置将会引发错误。
        TLS 1.0之前的协议版本，也就是SSL 版本 2 and 3，总是禁用的。
       </para>

<!--==========================orignal english content==========================
       <para>
        The default is <literal>TLSv1.2</literal>, which satisfies industry
        best practices as of this writing.
       </para>
____________________________________________________________________________-->
       <para>
        默认为<literal>TLSv1.2</literal>, 在本文撰写时的行业最佳实践。
       </para>

<!--==========================orignal english content==========================
       <para>
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数只能在<filename>postgresql.conf</filename>文件中或通过服务器命令行进行设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ssl-max-protocol-version" xreflabel="ssl_max_protocol_version">
<!--==========================orignal english content==========================
      <term><varname>ssl_max_protocol_version</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>ssl_max_protocol_version</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>ssl_max_protocol_version</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>ssl_max_protocol_version</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the maximum SSL/TLS protocol version to use.  Valid values are as
        for <xref linkend="guc-ssl-min-protocol-version"/>, with addition of
        an empty string, which allows any protocol version.  The default is to
        allow any version.  Setting the maximum protocol version is mainly
        useful for testing or if some component has issues working with a
        newer protocol.
       </para>
____________________________________________________________________________-->
       <para>
        设定要使用的最大SSL/TLS协议版本。
        有效的版本为 <xref linkend="guc-ssl-min-protocol-version"/>, 添加一个空字符串，允许任何协议版本。
        默认为允许任何版本。设置最大协议版本主要用于测试，或者某个组件在与较新的协议配合工作时出现了问题。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ssl-dh-params-file" xreflabel="ssl_dh_params_file">
<!--==========================orignal english content==========================
      <term><varname>ssl_dh_params_file</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>ssl_dh_params_file</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>ssl_dh_params_file</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>ssl_dh_params_file</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the name of the file containing Diffie-Hellman parameters
        used for so-called ephemeral DH family of SSL ciphers. The default is
        empty, in which case compiled-in default DH parameters used. Using
        custom DH parameters reduces the exposure if an attacker manages to
        crack the well-known compiled-in DH parameters. You can create your own
        DH parameters file with the command
        <command>openssl dhparam -out dhparams.pem 2048</command>.
       </para>
____________________________________________________________________________-->
       <para>
        指定含有用于SSL密码的所谓临时DH家族的Diffie-Hellman参数的文件名。默认值为空，这种情况下将使用内置的默认DH参数。使用自定义的DH参数可以降低攻击者破解众所周知的内置DH参数的风险。可以用命令<command>openssl dhparam -out dhparams.pem 2048</command>创建自己的DH参数文件。
       </para>

<!--==========================orignal english content==========================
       <para>
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数只能在 <filename>postgresql.conf</filename>文件中或服务器命令行上进行设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ssl-passphrase-command" xreflabel="ssl_passphrase_command">
<!--==========================orignal english content==========================
      <term><varname>ssl_passphrase_command</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>ssl_passphrase_command</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>ssl_passphrase_command</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>ssl_passphrase_command</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets an external command to be invoked when a passphrase for
        decrypting an SSL file such as a private key needs to be obtained.  By
        default, this parameter is empty, which means the built-in prompting
        mechanism is used.
       </para>
____________________________________________________________________________-->
       <para>
        设置当需要一个密码（例如一个私钥）来解密SSL文件时会调用的一个外部命令。默认情况下，这个参数为空，表示使用内建的提示机制。
       </para>

<!--==========================orignal english content==========================
       <para>
        The command must print the passphrase to the standard output and exit
        with code 0.  In the parameter value, <literal>%p</literal> is
        replaced by a prompt string.  (Write <literal>%%</literal> for a
        literal <literal>%</literal>.)  Note that the prompt string will
        probably contain whitespace, so be sure to quote adequately.  A single
        newline is stripped from the end of the output if present.
       </para>
____________________________________________________________________________-->
       <para>
        该命令必须将密码打印到标准输出并且以代码0退出。在该参数值中，<literal>%p</literal>被替换为一个提示字符串（要得到文字<literal>%</literal>，应该写成<literal>%%</literal>）。注意该提示字符串将可能含有空格，因此要确保加上适当的引号。如果输出的末尾有单一的新行，它会被剥离掉。
       </para>

<!--==========================orignal english content==========================
       <para>
        The command does not actually have to prompt the user for a
        passphrase.  It can read it from a file, obtain it from a keychain
        facility, or similar.  It is up to the user to make sure the chosen
        mechanism is adequately secure.
       </para>
____________________________________________________________________________-->
       <para>
        该命令实际上并不一定要提示用户输入一个密码。它可以从文件中读取密码、从钥匙链得到密码等等。确保选中的机制足够安全是用户的责任。
       </para>

<!--==========================orignal english content==========================
       <para>
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数只能在 <filename>postgresql.conf</filename>文件中或服务器命令行上进行设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ssl-passphrase-command-supports-reload" xreflabel="ssl_passphrase_command_supports_reload">
<!--==========================orignal english content==========================
      <term><varname>ssl_passphrase_command_supports_reload</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>ssl_passphrase_command_supports_reload</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>ssl_passphrase_command_supports_reload</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>ssl_passphrase_command_supports_reload</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        This parameter determines whether the passphrase command set by
        <varname>ssl_passphrase_command</varname> will also be called during a
        configuration reload if a key file needs a passphrase.  If this
        parameter is off (the default), then
        <varname>ssl_passphrase_command</varname> will be ignored during a
        reload and the SSL configuration will not be reloaded if a passphrase
        is needed.  That setting is appropriate for a command that requires a
        TTY for prompting, which might not be available when the server is
        running.  Setting this parameter to on might be appropriate if the
        passphrase is obtained from a file, for example.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数决定在配置重载期间如果一个密钥文件需要口令时，是否也调用<varname>ssl_passphrase_command</varname>设置的密码命令。
        如果这个参数为off（默认），那么在重载期间将忽略<varname>ssl_passphrase_command</varname>，如果在此期间需要密码则SSL配置将不会被重载。
        对于要求一个TTY（当服务器正在运行时可能是不可用的）来进行提示的命令，这种设置是合适的。
        例如，如果密码是从一个文件中得到的，将这个参数设置为on可能是合适的。
       </para>

<!--==========================orignal english content==========================
       <para>
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数只能在<filename>postgresql.conf</filename>文件中或者服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    </sect2>
   </sect1>

   <sect1 id="runtime-config-resource">
<!--==========================orignal english content==========================
    <title>Resource Consumption</title>
____________________________________________________________________________-->
    <title>资源消耗</title>

    <sect2 id="runtime-config-resource-memory">
<!--==========================orignal english content==========================
     <title>Memory</title>
____________________________________________________________________________-->
     <title>内存</title>

     <variablelist>
     <varlistentry id="guc-shared-buffers" xreflabel="shared_buffers">
<!--==========================orignal english content==========================
      <term><varname>shared_buffers</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>shared_buffers</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>shared_buffers</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>shared_buffers</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the amount of memory the database server uses for shared
        memory buffers.  The default is typically 128 megabytes
        (<literal>128MB</literal>), but might be less if your kernel settings will
        not support it (as determined during <application>initdb</application>).
        This setting must be at least 128 kilobytes.  However,
        settings significantly higher than the minimum are usually needed
        for good performance.
        If this value is specified without units, it is taken as blocks,
        that is <symbol>BLCKSZ</symbol> bytes, typically 8kB.
        (Non-default values of <symbol>BLCKSZ</symbol> change the minimum
        value.)
        This parameter can only be set at server start.
       </para>
____________________________________________________________________________-->
       <para>
        设置数据库服务器将使用的共享内存缓冲区量。默认通常是 128 兆字节（<literal>128MB</literal>），但是如果你的内核设置不支持（在<application>initdb</application>时决定），那么可以会更少。
        这个设置必须至少为 128 千字节。不过为了更好的性能，通常会使用明显高于最小值的设置。
        如果指定值时没有单位，则以块为单位，即<symbol>BLCKSZ</symbol>字节，通常为8kB.(<symbol>BLCKSZ</symbol> 的非默认值改变最小值。)
        此参数只能在服务器启动时设置。
       </para>

<!--==========================orignal english content==========================
       <para>
        If you have a dedicated database server with 1GB or more of RAM, a
        reasonable starting value for <varname>shared_buffers</varname> is 25%
        of the memory in your system.  There are some workloads where even
        larger settings for <varname>shared_buffers</varname> are effective, but
        because <productname>PostgreSQL</productname> also relies on the
        operating system cache, it is unlikely that an allocation of more than
        40% of RAM to <varname>shared_buffers</varname> will work better than a
        smaller amount.  Larger settings for <varname>shared_buffers</varname>
        usually require a corresponding increase in
        <varname>max_wal_size</varname>, in order to spread out the
        process of writing large quantities of new or changed data over a
        longer period of time.
       </para>
____________________________________________________________________________-->
       <para>
        如果有一个专用的 1GB 或更多内存的数据库服务器，一个合理的<varname>shared_buffers</varname>开始值是系统内存的 25%。即使更大的<varname>shared_buffers</varname>有效，也会造成一些工作负载， 但因为<productname>PostgreSQL</productname>同样依赖操作系统的高速缓冲区，将<varname>shared_buffers</varname>设置为超过 40% 的RAM不太可能比一个小点值工作得更好。为了能把对写大量新的或改变的数据的处理分布在一个较长的时间段内，<varname>shared_buffers</varname>更大的设置通常要求对<varname>max_wal_size</varname>也做相应增加。
       </para>

<!--==========================orignal english content==========================
       <para>
        On systems with less than 1GB of RAM, a smaller percentage of RAM is
        appropriate, so as to leave adequate space for the operating system.
       </para>
____________________________________________________________________________-->
       <para>
        如果系统内存小于 1GB，一个较小的 RAM 百分数是合适的，这样可以为操作系统留下足够的空间。
       </para>

      </listitem>
     </varlistentry>

     <varlistentry id="guc-huge-pages" xreflabel="huge_pages">
<!--==========================orignal english content==========================
      <term><varname>huge_pages</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>huge_pages</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>huge_pages</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>huge_pages</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Controls whether huge pages are requested for the main shared memory
        area. Valid values are <literal>try</literal> (the default),
        <literal>on</literal>, and <literal>off</literal>.  With
        <varname>huge_pages</varname> set to <literal>try</literal>, the
        server will try to request huge pages, but fall back to the default if
        that fails. With <literal>on</literal>, failure to request huge pages
        will prevent the server from starting up. With <literal>off</literal>,
        huge pages will not be requested.
       </para>
____________________________________________________________________________-->
       <para>
        控制是否为主共享内存区域请求巨型页。有效值是<literal>try</literal>（默认）、<literal>on</literal>以及<literal>off</literal>。如果<varname>huge_pages</varname>被设置为<literal>try</literal>，则服务器将尝试请求巨型页，但是如果失败会退回到默认的方式。如果为<literal>on</literal>，请求巨型页失败将使得服务器无法启动。如果为<literal>off</literal>，则不会请求巨型页。
       </para>

<!--==========================orignal english content==========================
       <para>
        At present, this setting is supported only on Linux and Windows. The
        setting is ignored on other systems when set to
        <literal>try</literal>.  On Linux, it is only supported when
        <varname>shared_memory_type</varname> is set to <literal>mmap</literal>
        (the default).
       </para>
____________________________________________________________________________-->
       <para>
        当前，只有Linux和Windows上支持这个设置。在其他系统上这个参数被设置为<literal>try</literal>时，它会被忽略。
        在Linux中，它只在<varname>shared_memory_type</varname>设置为<literal>mmap</literal>（默认）的时候被支持。
       </para>

<!--==========================orignal english content==========================
       <para>
        The use of huge pages results in smaller page tables and less CPU time
        spent on memory management, increasing performance. For more details about
        using huge pages on Linux, see <xref linkend="linux-huge-pages"/>.
       </para>
____________________________________________________________________________-->
       <para>
        巨型页面的使用会导致更小的页面表以及花费在内存管理上的 CPU 时间更少，从而提高性能。更多有关Linux上使用巨型页面的细节请见<xref linkend="linux-huge-pages"/>。
       </para>

<!--==========================orignal english content==========================
       <para>
        Huge pages are known as large pages on Windows.  To use them, you need to
        assign the user right <quote>Lock pages in memory</quote> to the Windows user account
        that runs <productname>PostgreSQL</productname>.
        You can use Windows Group Policy tool (gpedit.msc) to assign the user right
        <quote>Lock pages in memory</quote>.
        To start the database server on the command prompt as a standalone process,
        not as a Windows service, the command prompt must be run as an administrator or
        User Access Control (UAC) must be disabled. When the UAC is enabled, the normal
        command prompt revokes the user right <quote>Lock pages in memory</quote> when started.
       </para>
____________________________________________________________________________-->
       <para>
        巨型页在Windows上被称为大页面。
        要使用大页面，需要为运行<productname>PostgreSQL</productname>的Windows用户账号分配<quote>Lock pages in memory</quote>的用户权限。
        可以使用Windows的组策略工具（gpedit.msc）来分配用户权限<quote>Lock pages in memory</quote>。
        为了在命令窗口以单进程（而不是Windows服务）的方式启动数据库服务器，命令窗口必须以管理员身份运行或者禁用用户访问控制（UAC）。
        当UAC被启用时，普通的命令窗口会在启动时收回用户权限<quote>Lock pages in memory</quote>。
       </para>

<!--==========================orignal english content==========================
       <para>
        Note that this setting only affects the main shared memory area.
        Operating systems such as Linux, FreeBSD, and Illumos can also use
        huge pages (also known as <quote>super</quote> pages or
        <quote>large</quote> pages) automatically for normal memory
        allocation, without an explicit request from
        <productname>PostgreSQL</productname>. On Linux, this is called
        <quote>transparent huge pages</quote><indexterm><primary>transparent
        huge pages</primary></indexterm> (THP). That feature has been known to
        cause performance degradation with
        <productname>PostgreSQL</productname> for some users on some Linux
        versions, so its use is currently discouraged (unlike explicit use of
        <varname>huge_pages</varname>).
       </para>
____________________________________________________________________________-->
       <para>
        注意这种设置仅影响主共享内存区域。Linux、FreeBSD以及Illumos之类的操作系统也能为普通内存分配自动使用巨型页（也被称为<quote>超级</quote>页或者<quote>大</quote>页面），而不需要来自<productname>PostgreSQL</productname>的显式请求。在Linux上，这被称为<quote>transparent huge pages</quote><indexterm><primary>transparent huge pages</primary></indexterm>（THP，透明巨型页）。已知这种特性对某些Linux版本上的某些用户会导致<productname>PostgreSQL</productname>的性能退化，因此当前并不鼓励使用它（与<varname>huge_pages</varname>的显式使用不同）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-huge-page-size" xreflabel="huge_page_size">
<!--==========================orignal english content==========================
      <term><varname>huge_page_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>huge_page_size</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>huge_page_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>huge_page_size</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Controls the size of huge pages, when they are enabled with
        <xref linkend="guc-huge-pages"/>.
        The default is zero (<literal>0</literal>).
        When set to <literal>0</literal>, the default huge page size on the
        system will be used. This parameter can only be set at server start.
       </para>
____________________________________________________________________________-->
       <para>
        控制巨型页的大小，当他们通过<xref linkend="guc-huge-pages"/>时。
        默认为零 (<literal>0</literal>)。
        当设置为<literal>0</literal>时，将使用系统默认的巨型页大小。
        这个参数只能在服务器启动时设置。
       </para>
<!--==========================orignal english content==========================
       <para>
        Some commonly available page sizes on modern 64 bit server architectures include:
        <literal>2MB</literal> and <literal>1GB</literal> (Intel and AMD), <literal>16MB</literal> and
        <literal>16GB</literal> (IBM POWER), and <literal>64kB</literal>, <literal>2MB</literal>,
        <literal>32MB</literal> and <literal>1GB</literal> (ARM). For more information
        about usage and support, see <xref linkend="linux-huge-pages"/>.
       </para>
____________________________________________________________________________-->
       <para>
        一些现代64位服务器体系结构上常用的有效页尺寸包括：
        <literal>2MB</literal> 和 <literal>1GB</literal> (Intel and AMD), 
        <literal>16MB</literal> 和 <literal>16GB</literal> (IBM POWER), 
        还有 <literal>64kB</literal>, <literal>2MB</literal>,<literal>32MB</literal> 和 <literal>1GB</literal> (ARM). 
        关于使用和支持的更多信息，参见<xref linkend="linux-huge-pages"/>。
       </para>
<!--==========================orignal english content==========================
       <para>
        Non-default settings are currently supported only on Linux.
       </para>
____________________________________________________________________________-->
       <para>
        非默认设置当前仅在Linux上支持。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-temp-buffers" xreflabel="temp_buffers">
<!--==========================orignal english content==========================
      <term><varname>temp_buffers</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>temp_buffers</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>temp_buffers</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>temp_buffers</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the maximum amount of memory used for temporary buffers within
        each database session.  These are session-local buffers used only
        for access to temporary tables.
        If this value is specified without units, it is taken as blocks,
        that is <symbol>BLCKSZ</symbol> bytes, typically 8kB.
        The default is eight megabytes (<literal>8MB</literal>).
        (If <symbol>BLCKSZ</symbol> is not 8kB, the default value scales
        proportionally to it.)
        This setting can be changed within individual
        sessions, but only before the first use of temporary tables
        within the session; subsequent attempts to change the value will
        have no effect on that session.
       </para>
____________________________________________________________________________-->
       <para>
        为每个数据库会话设置用于临时缓冲区的最大内存.这些是仅用于访问临时表的会话本地缓冲。
        如果指定值时没有单位，则以块为单位，即<symbol>BLCKSZ</symbol>字节，通常为8kB。
        默认为8兆字节 (<literal>8MB</literal>)。(如果<symbol>BLCKSZ</symbol>不是8kB,则默认值按比例缩放。)
        这个设置可以在独立的会话内部被改变，但是只有在会话第一次使用临时表之前才能改变； 在会话中随后企图改变该值是无效的。
       </para>

<!--==========================orignal english content==========================
       <para>
        A session will allocate temporary buffers as needed up to the limit
        given by <varname>temp_buffers</varname>.  The cost of setting a large
        value in sessions that do not actually need many temporary
        buffers is only a buffer descriptor, or about 64 bytes, per
        increment in <varname>temp_buffers</varname>.  However if a buffer is
        actually used an additional 8192 bytes will be consumed for it
        (or in general, <symbol>BLCKSZ</symbol> bytes).
       </para>
____________________________________________________________________________-->
       <para>
        一个会话将按照<varname>temp_buffers</varname>给出的限制根据需要分配临时缓冲区。如果在一个并不需要大量临时缓冲区的会话里设置一个大的数值， 其开销只是一个缓冲区描述符，或者说<varname>temp_buffers</varname>每增加一则增加大概 64 字节。不过，如果一个缓冲区被实际使用，那么它就会额外消耗 8192 字节（或者<symbol>BLCKSZ</symbol>字节）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-prepared-transactions" xreflabel="max_prepared_transactions">
<!--==========================orignal english content==========================
      <term><varname>max_prepared_transactions</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_prepared_transactions</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>max_prepared_transactions</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_prepared_transactions</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the maximum number of transactions that can be in the
        <quote>prepared</quote> state simultaneously (see <xref
        linkend="sql-prepare-transaction"/>).
        Setting this parameter to zero (which is the default)
        disables the prepared-transaction feature.
        This parameter can only be set at server start.
       </para>
____________________________________________________________________________-->
       <para>
        设置可以同时处于<quote>prepared</quote>状态的事务的最大数目（见<xref linkend="sql-prepare-transaction"/>）。把这个参数设置 为零（这是默认设置）将禁用预备事务特性。这个参数只能在服务器启动时设置。
       </para>

<!--==========================orignal english content==========================
       <para>
        If you are not planning to use prepared transactions, this parameter
        should be set to zero to prevent accidental creation of prepared
        transactions.  If you are using prepared transactions, you will
        probably want <varname>max_prepared_transactions</varname> to be at
        least as large as <xref linkend="guc-max-connections"/>, so that every
        session can have a prepared transaction pending.
       </para>
____________________________________________________________________________-->
       <para>
        如果你不打算使用预备事务，可以把这个参数设置为零来防止意外创建预备事务。如果你正在使用预备事务，你将希望把<varname>max_prepared_transactions</varname>至少设置为<xref linkend="guc-max-connections"/>一样大，因此每一个会话可以有一个预备事务待处理。
       </para>

<!--==========================orignal english content==========================
       <para>
        When running a standby server, you must set this parameter to the
        same or higher value than on the primary server. Otherwise, queries
        will not be allowed in the standby server.
       </para>
____________________________________________________________________________-->
       <para>
        当运行一个后备服务器时，这个参数必须至少与主服务器上的一样大。否则，后备服务器上将不会执行查询。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-work-mem" xreflabel="work_mem">
<!--==========================orignal english content==========================
      <term><varname>work_mem</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>work_mem</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>work_mem</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>work_mem</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the base maximum amount of memory to be used by a query operation
        (such as a sort or hash table) before writing to temporary disk files.
        If this value is specified without units, it is taken as kilobytes.
        The default value is four megabytes (<literal>4MB</literal>).
        Note that for a complex query, several sort or hash operations might be
        running in parallel; each operation will generally be allowed
        to use as much memory as this value specifies before it starts
        to write data into temporary files.  Also, several running
        sessions could be doing such operations concurrently.
        Therefore, the total memory used could be many times the value
        of <varname>work_mem</varname>; it is necessary to keep this
        fact in mind when choosing the value.  Sort operations are used
        for <literal>ORDER BY</literal>, <literal>DISTINCT</literal>,
        and merge joins.
        Hash tables are used in hash joins, hash-based aggregation, result
        cache nodes and hash-based processing of <literal>IN</literal>
        subqueries.
       </para>
____________________________________________________________________________-->
       <para>
        设置在写入临时磁盘文件之前查询操作(例如排序或哈希表)可使用的基础最大内存容量。
        如果指定值时没有单位，则以千字节为单位。默认值是4兆字节 (<literal>4MB</literal>)。
        注意对于一个复杂查询， 可能会并行运行好几个排序或者哈希操作；每个操作通常都会被允许使用这个参数指定的内存量，然后才会开始写数据到临时文件。
        同样，几个正在运行的会话可能并发进行这样的操作。因此被使用的总内存可能是<varname>work_mem</varname>值的好几倍，在选择这个值时一定要记住这一点。
        <literal>ORDER BY</literal>、<literal>DISTINCT</literal>和归并连接都要用到排序操作。
        哈希连接、基于哈希的聚集，结果缓存节点以及基于哈希的<literal>IN</literal>子查询处理中都要用到哈希表。
       </para>

<!--==========================orignal english content==========================
       <para>
        Hash-based operations are generally more sensitive to memory
        availability than equivalent sort-based operations.  The
        memory available for hash tables is computed by multiplying
        <varname>work_mem</varname> by
        <varname>hash_mem_multiplier</varname>.  This makes it
        possible for hash-based operations to use an amount of memory
        that exceeds the usual <varname>work_mem</varname> base
        amount.
       </para>
____________________________________________________________________________-->
       <para>
        与等效的基于排序的操作相比，基于哈希的操作通常对内存可用性更敏感。 
        可用于哈希表的内存通过将<varname>work_mem</varname>乘<varname>hash_mem_multiplier</varname>来计算。 
        这使得基于哈希的操作可以使用超出通常<varname>work_mem</varname>基本量的内存。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-hash-mem-multiplier" xreflabel="hash_mem_multiplier">
<!--==========================orignal english content==========================
      <term><varname>hash_mem_multiplier</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>hash_mem_multiplier</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>hash_mem_multiplier</varname> (<type>浮点</type>)
      <indexterm>
       <primary><varname>hash_mem_multiplier</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Used to compute the maximum amount of memory that hash-based
        operations can use.  The final limit is determined by
        multiplying <varname>work_mem</varname> by
        <varname>hash_mem_multiplier</varname>.  The default value is
        1.0, which makes hash-based operations subject to the same
        simple <varname>work_mem</varname> maximum as sort-based
        operations.
       </para>
____________________________________________________________________________-->
       <para>
        用于计算基于哈希的操作可以使用的最大内存量。
        最终限制通过将<varname>work_mem</varname>乘以<varname>hash_mem_multiplier</varname>来决定。
        默认值为 1.0，这使得基于hash的操作与基于排序的操作一样，都取决于简单的<varname>work_mem</varname>最大值。。
       </para>
<!--==========================orignal english content==========================
       <para>
        Consider increasing <varname>hash_mem_multiplier</varname> in
        environments where spilling by query operations is a regular
        occurrence, especially when simply increasing
        <varname>work_mem</varname> results in memory pressure (memory
        pressure typically takes the form of intermittent out of
        memory errors).  A setting of 1.5 or 2.0 may be effective with
        mixed workloads.  Higher settings in the range of 2.0 - 8.0 or
        more may be effective in environments where
        <varname>work_mem</varname> has already been increased to 40MB
        or more.
       </para>
____________________________________________________________________________-->
       <para>
        考虑在经常发生溢出的环境中增加<varname>hash_mem_multiplier</varname>，尤其是在简单增加 <varname>work_mem</varname> 会导致内存压力（内存压力通常以间歇性的内存退出错误的形式出现）。 
        设置为 1.5 或 2.0 对混合工作负载有效。在 2.0 - 8.0 或更多范围内的较高设置在已<varname>work_mem</varname>已经达到40MB 或更多的环境中可能有效。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-maintenance-work-mem" xreflabel="maintenance_work_mem">
<!--==========================orignal english content==========================
      <term><varname>maintenance_work_mem</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>maintenance_work_mem</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>maintenance_work_mem</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>maintenance_work_mem</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the maximum amount of memory to be used by maintenance
        operations, such as <command>VACUUM</command>, <command>CREATE
        INDEX</command>, and <command>ALTER TABLE ADD FOREIGN KEY</command>.
        If this value is specified without units, it is taken as kilobytes.
        It defaults
        to 64 megabytes (<literal>64MB</literal>).  Since only one of these
        operations can be executed at a time by a database session, and
        an installation normally doesn't have many of them running
        concurrently, it's safe to set this value significantly larger
        than <varname>work_mem</varname>.  Larger settings might improve
        performance for vacuuming and for restoring database dumps.
       </para>
____________________________________________________________________________-->
       <para>
        指定在维护性操作（例如<command>VACUUM</command>、<command>CREATE INDEX</command>和<command>ALTER TABLE ADD FOREIGN KEY</command>）中使用的 最大的内存量。
        如果指定值时没有单位，则以千字节为单位，其默认值是 64 兆字节（<literal>64MB</literal>）。因为在一个数据库会话中，一个时刻只有一个这样的操作可以被执行，并且一个数据库安装通常不会有太多这样的操作并发执行， 把这个数值设置得比<varname>work_mem</varname>大很多是安全的。 更大的设置可以改进清理和恢复数据库转储的性能。
       </para>

<!--==========================orignal english content==========================
       <para>
        Note that when autovacuum runs, up to
        <xref linkend="guc-autovacuum-max-workers"/> times this memory
        may be allocated, so be careful not to set the default value
        too high.  It may be useful to control for this by separately
        setting <xref linkend="guc-autovacuum-work-mem"/>.
       </para>
____________________________________________________________________________-->
       <para>
        注意当自动清理运行时，可能会分配最多达这个内存的<xref linkend="guc-autovacuum-max-workers"/>倍，因此要小心不要把该默认值设置得太高。
        通过独立地设置<xref linkend="guc-autovacuum-work-mem"/>可能会对控制这种情况
        有所帮助。
       </para>
<!--==========================orignal english content==========================
       <para>
        Note that for the collection of dead tuple identifiers,
        <command>VACUUM</command> is only able to utilize up to a maximum of
        <literal>1GB</literal> of memory.
       </para>
____________________________________________________________________________-->
       <para>
        注意，对于死亡元组标识的集合，<command>VACUUM</command>最多只能使用<literal>1GB</literal>的内存。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-autovacuum-work-mem" xreflabel="autovacuum_work_mem">
<!--==========================orignal english content==========================
      <term><varname>autovacuum_work_mem</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>autovacuum_work_mem</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>autovacuum_work_mem</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>autovacuum_work_mem</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the maximum amount of memory to be used by each
        autovacuum worker process.
        If this value is specified without units, it is taken as kilobytes.
        It defaults to -1, indicating that
        the value of <xref linkend="guc-maintenance-work-mem"/> should
        be used instead.  The setting has no effect on the behavior of
        <command>VACUUM</command> when run in other contexts.
        This parameter can only be set in the
        <filename>postgresql.conf</filename> file or on the server command
        line.
       </para>
____________________________________________________________________________-->
       <para>
        指定每个自动清理工作者进程能使用的最大内存量。
        如果指定值时没有单位，则以千字节为单位。
        其默认值为 -1，表示转而使用 <xref linkend="guc-maintenance-work-mem"/>的值。
        当运行在其他上下文环境中时，这个设置对<command>VACUUM</command>的行为没有影响。
        这个参数只能在<filename>postgresql.conf</filename>中或者服务器命令行上设置。
       </para>
<!--==========================orignal english content==========================
       <para>
        For the collection of dead tuple identifiers, autovacuum is only able
        to utilize up to a maximum of <literal>1GB</literal> of memory, so
        setting <varname>autovacuum_work_mem</varname> to a value higher than
        that has no effect on the number of dead tuples that autovacuum can
        collect while scanning a table.
       </para>
____________________________________________________________________________-->
       <para>
        对于死亡元组标识的集合，autovacuum最大只能使用<literal>1GB</literal>内存，所以设置<varname>autovacuum_work_mem</varname>到一个更高的值，对于autovacuum在扫描表时所能收集的死亡元组数量是无效的。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-logical-decoding-work-mem" xreflabel="logical_decoding_work_mem">
<!--==========================orignal english content==========================
      <term><varname>logical_decoding_work_mem</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>logical_decoding_work_mem</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>logical_decoding_work_mem</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>logical_decoding_work_mem</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the maximum amount of memory to be used by logical decoding,
        before some of the decoded changes are written to local disk. This
        limits the amount of memory used by logical streaming replication
        connections. It defaults to 64 megabytes (<literal>64MB</literal>).
        Since each replication connection only uses a single buffer of this size,
        and an installation normally doesn't have many such connections
        concurrently (as limited by <varname>max_wal_senders</varname>), it's
        safe to set this value significantly higher than <varname>work_mem</varname>,
        reducing the amount of decoded changes written to disk.
       </para>
____________________________________________________________________________-->
       <para>
        指定逻辑解码要使用的最大内存量，在将某些解码的更改写入本地磁盘之前。
        这将限制逻辑流复制连接使用的内存量。它默认为 64 兆字节（<literal>64MB</literal>）。
        由于每个复制连接仅使用此大小的单个缓冲区，并且安装通常不会同时具有多个此类连接（受 <varname>max_wal_senders</varname> 的限制），因此将此值设置得明显高于 <varname>work_mem</varname>是安全的，从而减少写入磁盘的解码更改数量。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-stack-depth" xreflabel="max_stack_depth">
<!--==========================orignal english content==========================
      <term><varname>max_stack_depth</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_stack_depth</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>max_stack_depth</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_stack_depth</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the maximum safe depth of the server's execution stack.
        The ideal setting for this parameter is the actual stack size limit
        enforced by the kernel (as set by <literal>ulimit -s</literal> or local
        equivalent), less a safety margin of a megabyte or so.  The safety
        margin is needed because the stack depth is not checked in every
        routine in the server, but only in key potentially-recursive routines.
        If this value is specified without units, it is taken as kilobytes.
        The default setting is two megabytes (<literal>2MB</literal>), which
        is conservatively small and unlikely to risk crashes.  However,
        it might be too small to allow execution of complex functions.
        Only superusers can change this setting.
       </para>
____________________________________________________________________________-->
       <para>
        指定服务器的执行堆栈的最大安全深度。这个参数的理想设置是由内核强制的实际栈尺寸限制（<literal>ulimit -s</literal>所设置的或者本地等价物），减去大约一兆字节的安全边缘。
        需要这个安全边缘是因为在服务器中并非所有例程都检查栈深度，只是在关键的可能递规的例程中才进行检查。如果指定值时没有单位，则以千字节为单位。默认设置是两兆字节（<literal>2MB</literal>），这个值相对比较小并且不可能导致崩溃。但是，这个值可能太小了，以至于无法执行复杂的函数。只有超级用户可以修改这个设置。
       </para>

<!--==========================orignal english content==========================
       <para>
        Setting <varname>max_stack_depth</varname> higher than
        the actual kernel limit will mean that a runaway recursive function
        can crash an individual backend process.  On platforms where
        <productname>PostgreSQL</productname> can determine the kernel limit,
        the server will not allow this variable to be set to an unsafe
        value.  However, not all platforms provide the information,
        so caution is recommended in selecting a value.
       </para>
____________________________________________________________________________-->
       <para>
        把<varname>max_stack_depth</varname>参数设置得高于实际的内核限制将意味着一个失控的递归函数可能会导致一个独立的后端进程崩溃。 在<productname>PostgreSQL</productname>能够检测内核限制的平台上， 服务器将不允许把这个参数设置为一个不安全的值。不过，并非所有平台都能提供该信息，所以我们还是建议你在选择值时要小心。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-shared-memory-type" xreflabel="shared_memory_type">
<!--==========================orignal english content==========================
      <term><varname>shared_memory_type</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>shared_memory_type</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>shared_memory_type</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>shared_memory_type</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the shared memory implementation that the server
        should use for the main shared memory region that holds
        <productname>PostgreSQL</productname>'s shared buffers and other
        shared data.  Possible values are <literal>mmap</literal> (for
        anonymous shared memory allocated using <function>mmap</function>),
        <literal>sysv</literal> (for System V shared memory allocated via
        <function>shmget</function>) and <literal>windows</literal> (for Windows
        shared memory).  Not all values are supported on all platforms; the
        first supported option is the default for that platform.  The use of
        the <literal>sysv</literal> option, which is not the default on any
        platform, is generally discouraged because it typically requires
        non-default kernel settings to allow for large allocations (see <xref
        linkend="sysvipc"/>).
       </para>
____________________________________________________________________________-->
       <para>
        指定服务器应用于主共享内存区域的共享内存实现，包括 <productname>PostgreSQL</productname> 的共享缓冲区和其他共享数据。
        可能的值为 <literal>mmap</literal> (对使用 <function>mmap</function> 分配的匿名共享内存)，<literal>sysv</literal> (通过 <function>shmget</function> 分配的系统V 共享内存)，和<literal>windows</literal> (Windows共享内存)。
        并非在所有平台上都支持全部值;第一个被支持的选项是该平台的默认选项。
        <literal>sysv</literal> 选项不是任何平台的默认选项，通常不建议使用，因为它通常需要非默认的内核设置来允许大量的地址分配(参见 <xref linkend="sysvipc"/>)。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-dynamic-shared-memory-type" xreflabel="dynamic_shared_memory_type">
<!--==========================orignal english content==========================
      <term><varname>dynamic_shared_memory_type</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>dynamic_shared_memory_type</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>dynamic_shared_memory_type</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>dynamic_shared_memory_type</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the dynamic shared memory implementation that the server
        should use.  Possible values are <literal>posix</literal> (for POSIX shared
        memory allocated using <literal>shm_open</literal>), <literal>sysv</literal>
        (for System V shared memory allocated via <literal>shmget</literal>),
        <literal>windows</literal> (for Windows shared memory),
        and <literal>mmap</literal> (to simulate shared memory using
        memory-mapped files stored in the data directory).
        Not all values are supported on all platforms; the first supported
        option is the default for that platform.  The use of the
        <literal>mmap</literal> option, which is not the default on any platform,
        is generally discouraged because the operating system may write
        modified pages back to disk repeatedly, increasing system I/O load;
        however, it may be useful for debugging, when the
        <literal>pg_dynshmem</literal> directory is stored on a RAM disk, or when
        other shared memory facilities are not available.
       </para>
____________________________________________________________________________-->
       <para>
        指定服务器应该使用的动态共享内存实现。可能的值是<literal>posix</literal>（用于使用
        <literal>shm_open</literal>分配的 POSIX 共享内存）、<literal>sysv</literal>
        （用于通过<literal>shmget</literal>分配的 System V 共享内存）、
        <literal>windows</literal>（用于 Windows 共享内存）、和<literal>mmap</literal>
        （使用存储在数据目录中的内存映射文件模拟共享内存）。并非所有平台上都支持所有值，平台上第一个支持的选项就是其默认值。
        在任何平台上<literal>mmap</literal>选项都不是默认值，通常不鼓励使用它，因为操作系统会
        反复地把修改过的页面写回到磁盘上，从而增加了系统的I/O负载。不过当
        <literal>pg_dynshmem</literal>目录被存储在一个 RAM 盘时或者没有其他共享内存功能可用时，
        它还是有用的。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-min-dynamic-shared-memory" xreflabel="min_dynamic_shared_memory">
<!--==========================orignal english content==========================
      <term><varname>min_dynamic_shared_memory</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>min_dynamic_shared_memory</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>min_dynamic_shared_memory</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>min_dynamic_shared_memory</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the amount of memory that should be allocated at server
        startup for use by parallel queries.  When this memory region is
        insufficient or exhausted by concurrent queries, new parallel queries
        try to allocate extra shared memory temporarily from the operating
        system using the method configured with
        <varname>dynamic_shared_memory_type</varname>, which may be slower due
        to memory management overheads.  Memory that is allocated at startup
        with <varname>min_dynamic_shared_memory</varname> is affected by
        the <varname>huge_pages</varname> setting on operating systems where
        that is supported, and may be more likely to benefit from larger pages
        on operating systems where that is managed automatically.
        The default value is <literal>0</literal> (none). This parameter can
        only be set at server start.
       </para>
____________________________________________________________________________-->
       <para>
        指定在服务器启动时将要分配给并行查询使用的内存容量。
        当此内存区域不够用或被并发查询耗尽时，新的并行查询尝试使用<varname>dynamic_shared_memory_type</varname>配置的方法从操作系统临时分配额外的共享内存，由于内存管理开销该方法可能慢一些。
        在启动时由<varname>min_dynamic_shared_memory</varname>分配的内存受到操作系统上所支持的<varname>huge_pages</varname>设置的影响，并且在自动管理的操作系统上更可能从较大的页面中受益。
        默认值是<literal>0</literal>(无)。
        该参数只能在服务器启动时设置。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
     </sect2>

     <sect2 id="runtime-config-resource-disk">
<!--==========================orignal english content==========================
     <title>Disk</title>
____________________________________________________________________________-->
     <title>磁盘</title>

     <variablelist>
     <varlistentry id="guc-temp-file-limit" xreflabel="temp_file_limit">
<!--==========================orignal english content==========================
      <term><varname>temp_file_limit</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>temp_file_limit</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>temp_file_limit</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>temp_file_limit</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the maximum amount of disk space that a process can use
        for temporary files, such as sort and hash temporary files, or the
        storage file for a held cursor.  A transaction attempting to exceed
        this limit will be canceled.
        If this value is specified without units, it is taken as kilobytes.
        <literal>-1</literal> (the default) means no limit.
        Only superusers can change this setting.
       </para>
____________________________________________________________________________-->
       <para>
        指定一个进程能用于临时文件（如排序和哈希临时文件，或者用于保持游标的存储文件）的最大磁盘空间量。一个试图超过这个限制的事务将被取消。
        如果指定值时没有单位，则以千字节为单位。<literal>-1</literal>（默认值）意味着没有限制。只有超级用户能够修改这个设置。
       </para>

<!--==========================orignal english content==========================
       <para>
        This setting constrains the total space used at any instant by all
        temporary files used by a given <productname>PostgreSQL</productname> process.
        It should be noted that disk space used for explicit temporary
        tables, as opposed to temporary files used behind-the-scenes in query
        execution, does <emphasis>not</emphasis> count against this limit.
       </para>
____________________________________________________________________________-->
       <para>
        这个设置约束着一个给定<productname>PostgreSQL</productname>进程在任何瞬间所使用的所有临时文件的总空间。应该注意的是，与在查询执行中在幕后使用的临时文件相反，显式临时表所用的磁盘空间<emphasis>不</emphasis>被这个设置所限制。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
     </sect2>

     <sect2 id="runtime-config-resource-kernel">
<!--==========================orignal english content==========================
     <title>Kernel Resource Usage</title>
____________________________________________________________________________-->
     <title>内核资源使用</title>

     <variablelist>
     <varlistentry id="guc-max-files-per-process" xreflabel="max_files_per_process">
<!--==========================orignal english content==========================
      <term><varname>max_files_per_process</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_files_per_process</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>max_files_per_process</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_files_per_process</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the maximum number of simultaneously open files allowed to each
        server subprocess. The default is one thousand files. If the kernel is enforcing
        a safe per-process limit, you don't need to worry about this setting.
        But on some platforms (notably, most BSD systems), the kernel will
        allow individual processes to open many more files than the system
        can actually support if many processes all try to open
        that many files. If you find yourself seeing <quote>Too many open
        files</quote> failures, try reducing this setting.
        This parameter can only be set at server start.
       </para>
____________________________________________________________________________-->
       <para>
        设置每个服务器子进程允许同时打开的最大文件数目。默认是 1000 个文件。如果内核强制一个安全的针对每个进程的限制，那么你不用操心这个设置。但是在 一些平台上（特别是大多数 BSD 系统），如果很多进程都尝试打开很多文件，内核将允许独立进程打开比个系统真正可以支持的数目大得多得文件数。如果你发现自己看到了<quote>Too many open files</quote>这样的失败，可尝试减小这个设置。这个参数只能在服务器启动时设置。
       </para>
      </listitem>
     </varlistentry>
     </variablelist>
    </sect2>

    <sect2 id="runtime-config-resource-vacuum-cost">
<!--==========================orignal english content==========================
     <title>Cost-based Vacuum Delay</title>
____________________________________________________________________________-->
     <title>基于代价的清理延迟</title>
<!--==========================orignal english content==========================
     <para>
      During the execution of <xref linkend="sql-vacuum"/>
      and <xref linkend="sql-analyze"/>
      commands, the system maintains an
      internal counter that keeps track of the estimated cost of the
      various I/O operations that are performed.  When the accumulated
      cost reaches a limit (specified by
      <varname>vacuum_cost_limit</varname>), the process performing
      the operation will sleep for a short period of time, as specified by
      <varname>vacuum_cost_delay</varname>. Then it will reset the
      counter and continue execution.
     </para>
____________________________________________________________________________-->
     <para>
      在<xref linkend="sql-vacuum"/>和<xref linkend="sql-analyze"/>命令的执行过程中，系统维持着一个内部计数器来跟踪各种被执行的I/O操作的估算开销。当累计的代价达到一个限制（由<varname>vacuum_cost_limit</varname>指定），执行这些操作的进程将按照<varname>vacuum_cost_delay</varname>所指定的休眠一小段时间。然后它将重置计数器并继续执行。
     </para>

<!--==========================orignal english content==========================
     <para>
      The intent of this feature is to allow administrators to reduce
      the I/O impact of these commands on concurrent database
      activity. There are many situations where it is not
      important that maintenance commands like
      <command>VACUUM</command> and <command>ANALYZE</command> finish
      quickly; however, it is usually very important that these
      commands do not significantly interfere with the ability of the
      system to perform other database operations. Cost-based vacuum
      delay provides a way for administrators to achieve this.
     </para>
____________________________________________________________________________-->
     <para>
      这个特性的出发点是允许管理员降低这些命令对并发的数据库活动产生的I/O影响。在很多情况下，<command>VACUUM</command>和<command>ANALYZE</command>等维护命令能否快速完成并不重要，而非常重要的是这些命令不会对系统执行其他数据库操作的能力产生显著的影响。基于代价的清理延迟提供了一种方式让管理员能够保证这一点。
     </para>

<!--==========================orignal english content==========================
     <para>
      This feature is disabled by default for manually issued
      <command>VACUUM</command> commands. To enable it, set the
      <varname>vacuum_cost_delay</varname> variable to a nonzero
      value.
     </para>
____________________________________________________________________________-->
     <para>
      对于手动发出的<command>VACUUM</command>命令，该特性默认被禁用。要启用它，只要把<varname>vacuum_cost_delay</varname>变量设为一个非零值。
     </para>

     <variablelist>
      <varlistentry id="guc-vacuum-cost-delay" xreflabel="vacuum_cost_delay">
<!--==========================orignal english content==========================
       <term><varname>vacuum_cost_delay</varname> (<type>floating point</type>)
       <indexterm>
        <primary><varname>vacuum_cost_delay</varname> configuration parameter</primary>
       </indexterm>
       </term>
____________________________________________________________________________-->
       <term><varname>vacuum_cost_delay</varname> (<type>floating point</type>)
       <indexterm>
        <primary><varname>vacuum_cost_delay</varname>配置参数</primary>
       </indexterm>
       </term>
       <listitem>
<!--==========================orignal english content==========================
        <para>
         The amount of time that the process will sleep
         when the cost limit has been exceeded.
         If this value is specified without units, it is taken as milliseconds.
         The default value is zero, which disables the cost-based vacuum
         delay feature.  Positive values enable cost-based vacuuming.
        </para>
____________________________________________________________________________-->
        <para>
         当超出开销限制时进程将要休眠的时间量。如果指定值时没有单位，则以毫秒为单位。
         其默认值为0，这将禁用基于代价的清理延迟特性。正值将启用基于代价的清理。
        </para>

<!--==========================orignal english content==========================
        <para>
         When using cost-based vacuuming, appropriate values for
         <varname>vacuum_cost_delay</varname> are usually quite small, perhaps
         less than 1 millisecond.  While <varname>vacuum_cost_delay</varname>
         can be set to fractional-millisecond values, such delays may not be
         measured accurately on older platforms.  On such platforms,
         increasing <command>VACUUM</command>'s throttled resource consumption
         above what you get at 1ms will require changing the other vacuum cost
         parameters.  You should, nonetheless,
         keep <varname>vacuum_cost_delay</varname> as small as your platform
         will consistently measure; large delays are not helpful.
        </para>
____________________________________________________________________________-->
        <para>
         在使用基于代价的清理时，<varname>vacuum_cost_delay</varname>的合适值通常很小，也许是小于1毫秒。
         虽然<varname>vacuum_cost_delay</varname>可以被设置为毫秒级别的值，但是在较老的平台上可能无法准确地测量这种延迟。
         在这样的平台上，增加 <command>VACUUM</command>的节流资源消耗在1ms以上，需要改变其他的清理开销参数。
         尽管如此，你应该保持 <varname>vacuum_cost_delay</varname> 在平台能持续测量的情况下尽可能小；大延迟没有帮助。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-vacuum-cost-page-hit" xreflabel="vacuum_cost_page_hit">
<!--==========================orignal english content==========================
       <term><varname>vacuum_cost_page_hit</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>vacuum_cost_page_hit</varname> configuration parameter</primary>
       </indexterm>
       </term>
____________________________________________________________________________-->
       <term><varname>vacuum_cost_page_hit</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>vacuum_cost_page_hit</varname>配置参数</primary>
       </indexterm>
       </term>
       <listitem>
<!--==========================orignal english content==========================
        <para>
         The estimated cost for vacuuming a buffer found in the shared buffer
         cache. It represents the cost to lock the buffer pool, lookup
         the shared hash table and scan the content of the page. The
         default value is one.
        </para>
____________________________________________________________________________-->
        <para>
         清理一个在共享缓存中找到的缓冲区的估计代价。它表示锁住缓冲池、查找共享哈希表和扫描页内容的代价。默认值为1。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-vacuum-cost-page-miss" xreflabel="vacuum_cost_page_miss">
<!--==========================orignal english content==========================
       <term><varname>vacuum_cost_page_miss</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>vacuum_cost_page_miss</varname> configuration parameter</primary>
       </indexterm>
       </term>
____________________________________________________________________________-->
       <term><varname>vacuum_cost_page_miss</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>vacuum_cost_page_miss</varname>配置参数</primary>
       </indexterm>
       </term>
       <listitem>
<!--==========================orignal english content==========================
        <para>
         The estimated cost for vacuuming a buffer that has to be read from
         disk.  This represents the effort to lock the buffer pool,
         lookup the shared hash table, read the desired block in from
         the disk and scan its content. The default value is 2.
        </para>
____________________________________________________________________________-->
        <para>
         清理一个必须从磁盘上读取的缓冲区的代价。
         它表示锁住缓冲池、查找共享哈希表、从磁盘读取需要的块以及扫描其内容的代价。
         默认值为2。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-vacuum-cost-page-dirty" xreflabel="vacuum_cost_page_dirty">
<!--==========================orignal english content==========================
       <term><varname>vacuum_cost_page_dirty</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>vacuum_cost_page_dirty</varname> configuration parameter</primary>
       </indexterm>
       </term>
____________________________________________________________________________-->
       <term><varname>vacuum_cost_page_dirty</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>vacuum_cost_page_dirty</varname>配置参数</primary>
       </indexterm>
       </term>
       <listitem>
<!--==========================orignal english content==========================
        <para>
         The estimated cost charged when vacuum modifies a block that was
         previously clean. It represents the extra I/O required to
         flush the dirty block out to disk again. The default value is
         20.
        </para>
____________________________________________________________________________-->
        <para>
         当清理修改一个之前干净的块时需要花费的估计代价。它表示再次把脏块刷出到磁盘所需要的额外I/O。默认值为20。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-vacuum-cost-limit" xreflabel="vacuum_cost_limit">
<!--==========================orignal english content==========================
       <term><varname>vacuum_cost_limit</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>vacuum_cost_limit</varname> configuration parameter</primary>
       </indexterm>
       </term>
____________________________________________________________________________-->
       <term><varname>vacuum_cost_limit</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>vacuum_cost_limit</varname>配置参数</primary>
       </indexterm>
       </term>
       <listitem>
<!--==========================orignal english content==========================
        <para>
         The accumulated cost that will cause the vacuuming process to sleep.
         The default value is 200.
        </para>
____________________________________________________________________________-->
        <para>
         将导致清理进程休眠的累计代价。默认值为200。
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     <note>
<!--==========================orignal english content==========================
      <para>
       There are certain operations that hold critical locks and should
       therefore complete as quickly as possible.  Cost-based vacuum
       delays do not occur during such operations.  Therefore it is
       possible that the cost accumulates far higher than the specified
       limit.  To avoid uselessly long delays in such cases, the actual
       delay is calculated as <varname>vacuum_cost_delay</varname> *
       <varname>accumulated_balance</varname> /
       <varname>vacuum_cost_limit</varname> with a maximum of
       <varname>vacuum_cost_delay</varname> * 4.
      </para>
____________________________________________________________________________-->
      <para>
       有些操作会保持关键性的锁，这样可以尽快完成。基于代价的清理延迟在这类操作期间不会发生。因此有可能代价会累计至大大超过指定的限制。为了防止在这种情况下的无意义的长时间延迟，实际延迟的计算方式是<varname>vacuum_cost_delay</varname> *
       <varname>accumulated_balance</varname> /
       <varname>vacuum_cost_limit</varname>，且最大值是<varname>vacuum_cost_delay</varname> * 4。
      </para>
     </note>
    </sect2>

    <sect2 id="runtime-config-resource-background-writer">
<!--==========================orignal english content==========================
     <title>Background Writer</title>
____________________________________________________________________________-->
     <title>后台写入器</title>
<!--==========================orignal english content==========================
     <para>
      There is a separate server
      process called the <firstterm>background writer</firstterm>, whose function
      is to issue writes of <quote>dirty</quote> (new or modified) shared
      buffers.  When the number of clean shared buffers appears to be
      insufficient, the background writer writes some dirty buffers to the
      file system and marks them as clean.  This reduces the likelihood
      that server processes handling user queries will be unable to find
      clean buffers and have to write dirty buffers themselves.
      However, the background writer does cause a net overall
      increase in I/O load, because while a repeatedly-dirtied page might
      otherwise be written only once per checkpoint interval, the
      background writer might write it several times as it is dirtied
      in the same interval.  The parameters discussed in this subsection
      can be used to tune the behavior for local needs.
     </para>
____________________________________________________________________________-->
     <para>
      有一个独立的服务器进程，叫做<firstterm>后台写入器</firstterm>，它的功能就是发出写<quote>脏</quote>（新的或修改过的）共享缓冲区的命令。
      当干净的共享缓存数量出现不足时，后台写入器写入一些脏缓存到文件系统，并标记为干净。
      不过，后台写入器确实会增加 I/O 的总负荷，因为虽然在每个检查点间隔中一个重复弄脏的页面可能只会写出一次，但在同一个间隔中后台写入器可能会把它写出好几次。
      在这一小节讨论的参数可以被用于调节本地需求的行为。
     </para>

     <variablelist>
      <varlistentry id="guc-bgwriter-delay" xreflabel="bgwriter_delay">
<!--==========================orignal english content==========================
       <term><varname>bgwriter_delay</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>bgwriter_delay</varname> configuration parameter</primary>
       </indexterm>
       </term>
____________________________________________________________________________-->
       <term><varname>bgwriter_delay</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>bgwriter_delay</varname>配置参数</primary>
       </indexterm>
       </term>
       <listitem>
<!--==========================orignal english content==========================
        <para>
         Specifies the delay between activity rounds for the
         background writer.  In each round the writer issues writes
         for some number of dirty buffers (controllable by the
         following parameters).  It then sleeps for
         the length of <varname>bgwriter_delay</varname>, and repeats.
         When there are no dirty buffers in the
         buffer pool, though, it goes into a longer sleep regardless of
         <varname>bgwriter_delay</varname>.
         If this value is specified without units, it is taken as milliseconds.
         The default value is 200
         milliseconds (<literal>200ms</literal>). Note that on many systems, the
         effective resolution of sleep delays is 10 milliseconds; setting
         <varname>bgwriter_delay</varname> to a value that is not a multiple of 10
         might have the same results as setting it to the next higher multiple
         of 10.  This parameter can only be set in the
         <filename>postgresql.conf</filename> file or on the server command line.
        </para>
____________________________________________________________________________-->
        <para>
         指定后台写入器活动轮次之间的延迟。在每个轮次中，写入器都会为一定数量的脏缓冲区发出写操作（可以用下面的参数控制）。
         然后它就休眠 <varname>bgwriter_delay</varname>的时长， 然后重复动作。当缓冲池中没有脏缓冲区时，不管 <varname>bgwriter_delay</varname>，它都会进入更长的休眠。如果指定值时没有单位，则以毫秒为单位。默认值是 200 毫秒（<literal>200ms</literal>）。
         注意在许多系统上，休眠延迟的有效解析度是 10 毫秒；因此，为<varname>bgwriter_delay</varname>设置一个 不是 10 的倍数的值与把它设置为下一个更高的 10 的倍数是一样的效果。这个选项只能在服务器命令行上或者在<filename>postgresql.conf</filename>文件中设置。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-bgwriter-lru-maxpages" xreflabel="bgwriter_lru_maxpages">
<!--==========================orignal english content==========================
       <term><varname>bgwriter_lru_maxpages</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>bgwriter_lru_maxpages</varname> configuration parameter</primary>
       </indexterm>
       </term>
____________________________________________________________________________-->
       <term><varname>bgwriter_lru_maxpages</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>bgwriter_lru_maxpages</varname>配置参数</primary>
       </indexterm>
       </term>
       <listitem>
<!--==========================orignal english content==========================
        <para>
         In each round, no more than this many buffers will be written
         by the background writer.  Setting this to zero disables
         background writing.  (Note that checkpoints, which are managed by
         a separate, dedicated auxiliary process, are unaffected.)
         The default value is 100 buffers.
         This parameter can only be set in the <filename>postgresql.conf</filename>
         file or on the server command line.
        </para>
____________________________________________________________________________-->
        <para>
         在每个轮次中，不超过这么多个缓冲区将被后台写入器写出。把这个参数设置为零可禁用后台写出（注意被一个独立、专用辅助进程管理的检查点不受影响）。默认值是 100 个缓冲区。这个参数只能在<filename>postgresql.conf</filename>文件中或在服务器命令行上设置。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-bgwriter-lru-multiplier" xreflabel="bgwriter_lru_multiplier">
<!--==========================orignal english content==========================
       <term><varname>bgwriter_lru_multiplier</varname> (<type>floating point</type>)
       <indexterm>
        <primary><varname>bgwriter_lru_multiplier</varname> configuration parameter</primary>
       </indexterm>
       </term>
____________________________________________________________________________-->
       <term><varname>bgwriter_lru_multiplier</varname> (<type>floating point</type>)
       <indexterm>
        <primary><varname>bgwriter_lru_multiplier</varname>配置参数</primary>
       </indexterm>
       </term>
       <listitem>
<!--==========================orignal english content==========================
        <para>
         The number of dirty buffers written in each round is based on the
         number of new buffers that have been needed by server processes
         during recent rounds.  The average recent need is multiplied by
         <varname>bgwriter_lru_multiplier</varname> to arrive at an estimate of the
         number of buffers that will be needed during the next round.  Dirty
         buffers are written until there are that many clean, reusable buffers
         available.  (However, no more than <varname>bgwriter_lru_maxpages</varname>
         buffers will be written per round.)
         Thus, a setting of 1.0 represents a <quote>just in time</quote> policy
         of writing exactly the number of buffers predicted to be needed.
         Larger values provide some cushion against spikes in demand,
         while smaller values intentionally leave writes to be done by
         server processes.
         The default is 2.0.
         This parameter can only be set in the <filename>postgresql.conf</filename>
         file or on the server command line.
        </para>
____________________________________________________________________________-->
        <para>
         每一轮次要写的脏缓冲区的数目基于最近几个轮次中服务器进程需要的新缓冲区的数目。 最近所需的平均值乘以<varname>bgwriter_lru_multiplier</varname>可以估算下一轮次中将会需要的缓冲区数目。脏缓冲区将被写出直到有很多干净可重用的缓冲区（然而，每一轮次中写出的缓冲区数不超过<varname>bgwriter_lru_maxpages</varname>）。 因此，设置为 1.0 表示一种<quote>刚刚好的</quote>策略，这种策略会写出正好符合预测值的数目的缓冲区。 更大大的值可以为需求高峰提供某种缓冲，而更小的值则需要服务进程来处理一些写出操作。默认值是 2.0。这个参数只能在<filename>postgresql.conf</filename>文件中或在服务器命令行上设置。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-bgwriter-flush-after" xreflabel="bgwriter_flush_after">
<!--==========================orignal english content==========================
       <term><varname>bgwriter_flush_after</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>bgwriter_flush_after</varname> configuration parameter</primary>
       </indexterm>
       </term>
____________________________________________________________________________-->
       <term><varname>bgwriter_flush_after</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>bgwriter_flush_after</varname> 配置参数</primary>
       </indexterm>
       </term>
       <listitem>
<!--==========================orignal english content==========================
        <para>
         Whenever more than this amount of data has
         been written by the background writer, attempt to force the OS to issue these
         writes to the underlying storage.  Doing so will limit the amount of
         dirty data in the kernel's page cache, reducing the likelihood of
         stalls when an <function>fsync</function> is issued at the end of a checkpoint, or when
         the OS writes data back in larger batches in the background.  Often
         that will result in greatly reduced transaction latency, but there
         also are some cases, especially with workloads that are bigger than
         <xref linkend="guc-shared-buffers"/>, but smaller than the OS's page
         cache, where performance might degrade.  This setting may have no
         effect on some platforms.
         If this value is specified without units, it is taken as blocks,
         that is <symbol>BLCKSZ</symbol> bytes, typically 8kB.
         The valid range is between
         <literal>0</literal>, which disables forced writeback, and
         <literal>2MB</literal>.  The default is <literal>512kB</literal> on Linux,
         <literal>0</literal> elsewhere.  (If <symbol>BLCKSZ</symbol> is not 8kB,
         the default and maximum values scale proportionally to it.)
         This parameter can only be set in the <filename>postgresql.conf</filename>
         file or on the server command line.
        </para>
____________________________________________________________________________-->
        <para>
         只要后台写入的数据超过这个数量，尝试强制 OS 把这些写发送到底层存储上。这样做将限制内核页缓存中脏数据的量，降低了在检查点末尾发出一个 fsync 时或者 OS 在后台大批量写回数据时卡住的可能性。
		 那常常会导致大幅度压缩的事务延迟，但是也有一些情况（特别是负载超过<xref linkend="guc-shared-buffers"/>但小于 OS 页面高速缓存）的性能会降低。这种设置可能会在某些平台上没有效果。
         如果指定值时没有单位，则以块为单位，即为<symbol>BLCKSZ</symbol> 字节，通常为8kB.合法的范围在<literal>0</literal>（禁用受控写回）和<literal>2MB</literal>之间。Linux 上的默认值是<literal>512kB</literal>，其他平台上是<literal>0</literal>（如果<symbol>BLCKSZ</symbol>不是8kB，则默认值和最大值会按比例缩放至这个值）。这个参数只能在<filename>postgresql.conf</filename>文件中或者服务器命令行上设置。
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

<!--==========================orignal english content==========================
     <para>
      Smaller values of <varname>bgwriter_lru_maxpages</varname> and
      <varname>bgwriter_lru_multiplier</varname> reduce the extra I/O load
      caused by the background writer, but make it more likely that server
      processes will have to issue writes for themselves, delaying interactive
      queries.
     </para>
____________________________________________________________________________-->
     <para>
      较小的<varname>bgwriter_lru_maxpages</varname>和<varname>bgwriter_lru_multiplier</varname>可以降低由后台写入器造成的额外 I/O 开销。但更可能的是，服务器进程将必须自己发出写入操作，这会延迟交互式查询。
     </para>
    </sect2>

    <sect2 id="runtime-config-resource-async-behavior">
<!--==========================orignal english content==========================
     <title>Asynchronous Behavior</title>
____________________________________________________________________________-->
     <title>异步行为</title>

     <variablelist>
      <varlistentry id="guc-backend-flush-after" xreflabel="backend_flush_after">
<!--==========================orignal english content==========================
       <term><varname>backend_flush_after</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>backend_flush_after</varname> configuration parameter</primary>
       </indexterm>
       </term>
____________________________________________________________________________-->
       <term><varname>backend_flush_after</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>backend_flush_after</varname> 配置参数</primary>
       </indexterm>
       </term>
       <listitem>
<!--==========================orignal english content==========================
        <para>
         Whenever more than this amount of data has
         been written by a single backend, attempt to force the OS to issue
         these writes to the underlying storage.  Doing so will limit the
         amount of dirty data in the kernel's page cache, reducing the
         likelihood of stalls when an <function>fsync</function> is issued at the end of a
         checkpoint, or when the OS writes data back in larger batches in the
         background.  Often that will result in greatly reduced transaction
         latency, but there also are some cases, especially with workloads
         that are bigger than <xref linkend="guc-shared-buffers"/>, but smaller
         than the OS's page cache, where performance might degrade.  This
         setting may have no effect on some platforms.
         If this value is specified without units, it is taken as blocks,
         that is <symbol>BLCKSZ</symbol> bytes, typically 8kB.
         The valid range is
         between <literal>0</literal>, which disables forced writeback,
         and <literal>2MB</literal>.  The default is <literal>0</literal>, i.e., no
         forced writeback.  (If <symbol>BLCKSZ</symbol> is not 8kB,
         the maximum value scales proportionally to it.)
        </para>
____________________________________________________________________________-->
        <para>
         当单个后端写入数据的量超过这个数量时，尝试强制操作系统发送这些写入到底层存储。
         这样做将限制内核的页面缓存中的脏数据量，降低在检查点末尾发出<function>fsync</function>时暂停的可能性，或者当操作系统在后台大批量的写回数据时。
         通常的结果会大大减少事务延迟，但也有一些情况，特别是当工作负载大于<xref linkend="guc-shared-buffers"/>，但小于操作系统的页面缓存时，性能可能会下降。
         此设置在某些平台上可能无效。
         如果指定此值时没有单位，则将其作为块，即<symbol>BLCKSZ</symbol>字节，通常为8kB。
         有效范围在<literal>0</literal>，禁止强制回写，和<literal>2MB</literal>之间。
         默认值是<literal>0</literal>，即没有强制回写。
         (如果<symbol>BLCKSZ</symbol>不是8kB，则最大值按其比例缩放。)
        </para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-effective-io-concurrency" xreflabel="effective_io_concurrency">
<!--==========================orignal english content==========================
       <term><varname>effective_io_concurrency</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>effective_io_concurrency</varname> configuration parameter</primary>
       </indexterm>
       </term>
____________________________________________________________________________-->
       <term><varname>effective_io_concurrency</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>effective_io_concurrency</varname>配置参数</primary>
       </indexterm>
       </term>
       <listitem>
<!--==========================orignal english content==========================
        <para>
         Sets the number of concurrent disk I/O operations that
         <productname>PostgreSQL</productname> expects can be executed
         simultaneously.  Raising this value will increase the number of I/O
         operations that any individual <productname>PostgreSQL</productname> session
         attempts to initiate in parallel.  The allowed range is 1 to 1000,
         or zero to disable issuance of asynchronous I/O requests. Currently,
         this setting only affects bitmap heap scans.
        </para>
____________________________________________________________________________-->
        <para>
         设置<productname>PostgreSQL</productname>可以同时被执行的并发磁盘 I/O 操作的数量。调高这个值，可以增加任何单个<productname>PostgreSQL</productname>会话试图并行发起的 I/O 操作的数目。 允许的范围是 1 到 1000，或 0 表示禁用异步 I/O 请求。当前这个设置仅影响位图堆扫描。
        </para>

<!--==========================orignal english content==========================
        <para>
         For magnetic drives, a good starting point for this setting is the
         number of separate
         drives comprising a RAID 0 stripe or RAID 1 mirror being used for the
         database.  (For RAID 5 the parity drive should not be counted.)
         However, if the database is often busy with multiple queries issued in
         concurrent sessions, lower values may be sufficient to keep the disk
         array busy.  A value higher than needed to keep the disks busy will
         only result in extra CPU overhead.
         SSDs and other memory-based storage can often process many
         concurrent requests, so the best value might be in the hundreds.
        </para>
____________________________________________________________________________-->
        <para>
         对于磁盘驱动器，这个设置的一个很好的出发点是组成一个被用于该数据库的 RAID 0 条带或 RAID 1 镜像的独立驱动器数量（对 RAID 5 而言，校验驱动器不计入）。但是， 如果数据库经常忙于在并发会话中发出的多个查询，较低的值可能足以使磁盘阵列繁忙。比保持磁盘繁忙所需的值更高的值只会造成额外的 CPU 开销。SSD 以及其他基于内存的存储常常能处理很多并发请求，因此它们的最佳值可能是数百。
        </para>

<!--==========================orignal english content==========================
        <para>
         Asynchronous I/O depends on an effective <function>posix_fadvise</function>
         function, which some operating systems lack.  If the function is not
         present then setting this parameter to anything but zero will result
         in an error.  On some operating systems (e.g., Solaris), the function
         is present but does not actually do anything.
        </para>
____________________________________________________________________________-->
        <para>
         异步 I/O 依赖于一个有效的<function>posix_fadvise</function>函数（一些操作系统可能没有）。 如果不存在这个函数，将这个参数设置为除 0 之外的任何东西将导致错误。在一些操作系统上（如Solaris）虽然提供了这个函数，但它不会做任何事情。
        </para>

<!--==========================orignal english content==========================
        <para>
         The default is 1 on supported systems, otherwise 0.  This value can
         be overridden for tables in a particular tablespace by setting the
         tablespace parameter of the same name (see
         <xref linkend="sql-altertablespace"/>).
        </para>
____________________________________________________________________________-->
        <para>
         在支持的系统上默认值为 1，否则为 0。对于一个特定表空间中的表，可以通过设定该表空间的同名参数（见<xref linkend="sql-altertablespace"/>）可以覆盖这个值。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-maintenance-io-concurrency" xreflabel="maintenance_io_concurrency">
<!--==========================orignal english content==========================
       <term><varname>maintenance_io_concurrency</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>maintenance_io_concurrency</varname> configuration parameter</primary>
       </indexterm>
       </term>
____________________________________________________________________________-->
       <term><varname>maintenance_io_concurrency</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>maintenance_io_concurrency</varname> 配置参数</primary>
       </indexterm>
       </term>
       <listitem>
<!--==========================orignal english content==========================
        <para>
         Similar to <varname>effective_io_concurrency</varname>, but used
         for maintenance work that is done on behalf of many client sessions.
        </para>
____________________________________________________________________________-->
        <para>
         与<varname>effective_io_concurrency</varname>相似，但用于支持许多客户端会话完成的维护工作。
        </para>
<!--==========================orignal english content==========================
        <para>
         The default is 10 on supported systems, otherwise 0.  This value can
         be overridden for tables in a particular tablespace by setting the
         tablespace parameter of the same name (see
         <xref linkend="sql-altertablespace"/>).
        </para>
____________________________________________________________________________-->
        <para>
         在支持的系统上的默认值为 10，否则为 0。 
         对于特定表空间中的表，这个值可以被覆盖，通过设置同名的表空间参数（参见 <xref linkend="sql-altertablespace"/>）。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-max-worker-processes" xreflabel="max_worker_processes">
<!--==========================orignal english content==========================
       <term><varname>max_worker_processes</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>max_worker_processes</varname> configuration parameter</primary>
       </indexterm>
       </term>
____________________________________________________________________________-->
       <term><varname>max_worker_processes</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>max_worker_processes</varname>配置参数</primary>
       </indexterm>
       </term>
       <listitem>
<!--==========================orignal english content==========================
        <para>
         Sets the maximum number of background processes that the system
         can support.  This parameter can only be set at server start.  The
         default is 8.
        </para>
____________________________________________________________________________-->
        <para>
         设置系统能够支持的后台进程的最大数量。这个参数只能在服务器启动时设置。默认值为 8。
        </para>

<!--==========================orignal english content==========================
        <para>
         When running a standby server, you must set this parameter to the
         same or higher value than on the master server. Otherwise, queries
         will not be allowed in the standby server.
        </para>
____________________________________________________________________________-->
        <para>
         在运行一个后备服务器时，你必须把这个参数设置为等于或者高于主控服务器上的值。
         否则，后备服务器上可能不会允许查询。
        </para>

<!--==========================orignal english content==========================
        <para>
         When changing this value, consider also adjusting
         <xref linkend="guc-max-parallel-workers"/>,
         <xref linkend="guc-max-parallel-maintenance-workers"/>, and
         <xref linkend="guc-max-parallel-workers-per-gather"/>.
        </para>
____________________________________________________________________________-->
        <para>
         在更改这个值时，考虑也对<xref linkend="guc-max-parallel-workers"/>、<xref linkend="guc-max-parallel-maintenance-workers"/>以及<xref linkend="guc-max-parallel-workers-per-gather"/>进行调整。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-max-parallel-workers-per-gather" xreflabel="max_parallel_workers_per_gather">
<!--==========================orignal english content==========================
       <term><varname>max_parallel_workers_per_gather</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>max_parallel_workers_per_gather</varname> configuration parameter</primary>
       </indexterm>
       </term>
____________________________________________________________________________-->
       <term><varname>max_parallel_workers_per_gather</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>max_parallel_workers_per_gather</varname> 配置参数</primary>
       </indexterm>
       </term>
       <listitem>
<!--==========================orignal english content==========================
        <para>
         Sets the maximum number of workers that can be started by a single
         <literal>Gather</literal> or <literal>Gather Merge</literal> node.
         Parallel workers are taken from the pool of processes established by
         <xref linkend="guc-max-worker-processes"/>, limited by
         <xref linkend="guc-max-parallel-workers"/>.  Note that the requested
         number of workers may not actually be available at run time.  If this
         occurs, the plan will run with fewer workers than expected, which may
         be inefficient.  The default value is 2.  Setting this value to 0
         disables parallel query execution.
        </para>
____________________________________________________________________________-->
        <para>
         设置单个<literal>Gather</literal>或者<literal>Gather Merge</literal>节点能够开始的工作者的最大数量。并行工作者会从<xref linkend="guc-max-worker-processes"/>建立的进程池中取得，数量由<xref linkend="guc-max-parallel-workers"/>限制。注意所要求的工作者数量在运行时可能实际无法被满足。如果这种事情发生，该计划将会以比预期更少的工作者运行，这可能会不太高效。默认值是2。把这个值设置为0将会禁用并行查询执行。
        </para>

<!--==========================orignal english content==========================
        <para>
         Note that parallel queries may consume very substantially more
         resources than non-parallel queries, because each worker process is
         a completely separate process which has roughly the same impact on the
         system as an additional user session.  This should be taken into
         account when choosing a value for this setting, as well as when
         configuring other settings that control resource utilization, such
         as <xref linkend="guc-work-mem"/>.  Resource limits such as
         <varname>work_mem</varname> are applied individually to each worker,
         which means the total utilization may be much higher across all
         processes than it would normally be for any single process.
         For example, a parallel query using 4 workers may use up to 5 times
         as much CPU time, memory, I/O bandwidth, and so forth as a query which
         uses no workers at all.
        </para>
____________________________________________________________________________-->
        <para>
         注意并行查询可能消耗比非并行查询更多的资源，因为每一个工作者进程时一个完全独立的进程，它对系统产生的影响大致和一个额外的用户会话相同。在为这个设置选择值时，以及配置其他控制资源利用的设置（例如<xref linkend="guc-work-mem"/>）时，应该把这个因素考虑在内。<varname>work_mem</varname>之类的资源限制会被独立地应用于每一个工作者，这意味着所有进程的总资源利用可能会比单个进程时高得多。例如，一个使用 4 个工作者的并行查询使用的 CPU 时间、内存、I/O 带宽可能是不使用工作者时的 5 倍之多。
        </para>

<!--==========================orignal english content==========================
        <para>
         For more information on parallel query, see
         <xref linkend="parallel-query"/>.
        </para>
____________________________________________________________________________-->
        <para>
         并行查询的更多信息请见<xref linkend="parallel-query"/>。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-max-parallel-maintenance-workers" xreflabel="max_parallel_maintenance_workers">
<!--==========================orignal english content==========================
       <term><varname>max_parallel_maintenance_workers</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>max_parallel_maintenance_workers</varname> configuration parameter</primary>
       </indexterm>
       </term>
____________________________________________________________________________-->
       <term><varname>max_parallel_maintenance_workers</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>max_parallel_maintenance_workers</varname>配置参数</primary>
       </indexterm>
       </term>
       <listitem>
<!--==========================orignal english content==========================
        <para>
         Sets the maximum number of parallel workers that can be
         started by a single utility command.  Currently, the parallel
         utility commands that support the use of parallel workers are
         <command>CREATE INDEX</command> only when building a B-tree index,
         and <command>VACUUM</command> without <literal>FULL</literal>
         option.  Parallel workers are taken from the pool of processes
         established by <xref linkend="guc-max-worker-processes"/>, limited
         by <xref linkend="guc-max-parallel-workers"/>.  Note that the requested
         number of workers may not actually be available at run time.
         If this occurs, the utility operation will run with fewer
         workers than expected.  The default value is 2.  Setting this
         value to 0 disables the use of parallel workers by utility
         commands.
        </para>
____________________________________________________________________________-->
        <para>
         设置单一工具性命令能够启动的并行工作者的最大数目。
         当前，支持使用并行工作者的工具性命令是<command>CREATE INDEX</command>，并且只有在构建B-树索引时才能并行，并且 <command>VACUUM</command> 没有 <literal>FULL</literal>选项。
         并行工作者从由<xref linkend="guc-max-worker-processes"/>创建的进程池中取出，数量由<xref linkend="guc-max-parallel-workers"/>控制。
         注意实际在运行时所请求数量的工作者可能不可用。如果发生这种情况，工具性操作将使用比预期数量少的工作者运行。默认值为2。将这个值设置为0可以禁用工具性命令对并行工作者的使用。
        </para>

<!--==========================orignal english content==========================
        <para>
         Note that parallel utility commands should not consume
         substantially more memory than equivalent non-parallel
         operations.  This strategy differs from that of parallel
         query, where resource limits generally apply per worker
         process.  Parallel utility commands treat the resource limit
         <varname>maintenance_work_mem</varname> as a limit to be applied to
         the entire utility command, regardless of the number of
         parallel worker processes.  However, parallel utility
         commands may still consume substantially more CPU resources
         and I/O bandwidth.
        </para>
____________________________________________________________________________-->
        <para>
         注意并行工具性命令不应该消耗比同等数量非并行操作更多的内存。这种策略与并行查询不同，并行查询的资源限制通常是应用在每个工作者进程上。并行工具性命令把资源限制<varname>maintenance_work_mem</varname>当作对整个工具性命令的限制，而不管其中用到了多少个并行工作者进程。不过，并行工具性命令实际上可能仍会消耗更多的CPU资源和I/O带宽。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-max-parallel-workers" xreflabel="max_parallel_workers">
<!--==========================orignal english content==========================
       <term><varname>max_parallel_workers</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>max_parallel_workers</varname> configuration parameter</primary>
       </indexterm>
       </term>
____________________________________________________________________________-->
       <term><varname>max_parallel_workers</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>max_parallel_workers</varname>配置参数</primary>
       </indexterm>
       </term>
       <listitem>
<!--==========================orignal english content==========================
        <para>
         Sets the maximum number of workers that the system can support for
         parallel operations.  The default value is 8.  When increasing or
         decreasing this value, consider also adjusting
         <xref linkend="guc-max-parallel-maintenance-workers"/> and
         <xref linkend="guc-max-parallel-workers-per-gather"/>.
         Also, note that a setting for this value which is higher than
         <xref linkend="guc-max-worker-processes"/> will have no effect,
         since parallel workers are taken from the pool of worker processes
         established by that setting.
        </para>
____________________________________________________________________________-->
        <para>
         设置系统为并行操作所支持的工作者的最大数量。默认值为8。
         在增加或者减小这个值时，也要考虑对<xref linkend="guc-max-parallel-maintenance-workers"/>以及<xref linkend="guc-max-parallel-workers-per-gather"/>进行调整。
         此外，要注意将这个值设置得大于<xref linkend="guc-max-worker-processes"/>将不会产生效果，因为并行工作者进程都是从<xref linkend="guc-max-worker-processes"/>所建立的工作者进程池中取出来的。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-parallel-leader-participation" xreflabel="parallel_leader_participation">
<!--==========================orignal english content==========================
       <term>
       <varname>parallel_leader_participation</varname> (<type>boolean</type>)
       <indexterm>
        <primary><varname>parallel_leader_participation</varname> configuration parameter</primary>
       </indexterm>
       </term>
____________________________________________________________________________-->
       <term>
       <varname>parallel_leader_participation</varname> (<type>boolean</type>)
       <indexterm>
        <primary><varname>parallel_leader_participation</varname> 配置参数</primary>
       </indexterm>
       </term>
       <listitem>
<!--==========================orignal english content==========================
        <para>
         Allows the leader process to execute the query plan under
         <literal>Gather</literal> and <literal>Gather Merge</literal> nodes
         instead of waiting for worker processes.  The default is
         <literal>on</literal>.  Setting this value to <literal>off</literal>
         reduces the likelihood that workers will become blocked because the
         leader is not reading tuples fast enough, but requires the leader
         process to wait for worker processes to start up before the first
         tuples can be produced.  The degree to which the leader can help or
         hinder performance depends on the plan type, number of workers and
         query duration.
        </para>
____________________________________________________________________________-->
        <para>
         允许leader进程在<literal>Gather</literal> 和 <literal>Gather Merge</literal>节点下执行查询计划，而不是等待worker进程。
         默认值是<literal>on</literal>。
         设置该值为<literal>off</literal>可以降低workers因为leader读取元组的速度不够快而被阻塞的可能性，但在第一个元组生成之前需要leader进程等待worker进程启动。
         leader能帮助或阻碍性能的程度取决于计划类型，workers的数量和查询持续时间。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-old-snapshot-threshold" xreflabel="old_snapshot_threshold">
<!--==========================orignal english content==========================
       <term><varname>old_snapshot_threshold</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>old_snapshot_threshold</varname> configuration parameter</primary>
       </indexterm>
       </term>
____________________________________________________________________________-->
       <term><varname>old_snapshot_threshold</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>old_snapshot_threshold</varname> 配置参数</primary>
       </indexterm>
       </term>
       <listitem>
<!--==========================orignal english content==========================
        <para>
         Sets the minimum amount of time that a query snapshot can be used
         without risk of a <quote>snapshot too old</quote> error occurring
         when using the snapshot.  Data that has been dead for longer than
         this threshold is allowed to be vacuumed away.  This can help
         prevent bloat in the face of snapshots which remain in use for a
         long time.  To prevent incorrect results due to cleanup of data which
         would otherwise be visible to the snapshot, an error is generated
         when the snapshot is older than this threshold and the snapshot is
         used to read a page which has been modified since the snapshot was
         built.
        </para>
____________________________________________________________________________-->
        <para>
         设置在使用快照时，一个快照可以被使用而没有发生<quote>snapshot too old</quote> 错误的风险的最小时间。超过此阈值时间的死数据将允许被清除。 
         这可以有助于阻止长时间使用的快照造成的快照膨胀。为了阻止由于本来对该快照可见的数据被清理导致的不正确结果，当快照比这个阈值更旧并且该快照被用来读取一个该快照建立以来被修改过的页面时，将会产生一个错误。
        </para>

<!--==========================orignal english content==========================
        <para>
         If this value is specified without units, it is taken as minutes.
         A value of <literal>-1</literal> (the default) disables this feature,
         effectively setting the snapshot age limit to infinity.
         This parameter can only be set at server start.
        </para>
____________________________________________________________________________-->
        <para>
         如果指定值时没有单位，则以分钟为单位。
         值 <literal>-1</literal> (默认值) 禁用此功能,实际上将快照的时限设置为无穷大。
         这个参数只能在服务器启动时设置。
        </para>

<!--==========================orignal english content==========================
        <para>
         Useful values for production work probably range from a small number
         of hours to a few days.  Small values (such as <literal>0</literal> or
         <literal>1min</literal>) are only allowed because they may sometimes be
         useful for testing.  While a setting as high as <literal>60d</literal> is
         allowed, please note that in many workloads extreme bloat or
         transaction ID wraparound may occur in much shorter time frames.
        </para>
____________________________________________________________________________-->
        <para>
         对于生产工作有用的值的范围可能从几个小时到几天不等。只允许小的值（例如<literal>0</literal>或者<literal>1min</literal>）是因为它们有时可能对测试有用。
         虽然允许高达<literal>60d</literal>的设置，但是请注意很多负载情况下，很短的时间帧里就可能发生极大的膨胀或者事务 ID 回卷。
        </para>

<!--==========================orignal english content==========================
        <para>
         When this feature is enabled, freed space at the end of a relation
         cannot be released to the operating system, since that could remove
         information needed to detect the <quote>snapshot too old</quote>
         condition.  All space allocated to a relation remains associated with
         that relation for reuse only within that relation unless explicitly
         freed (for example, with <command>VACUUM FULL</command>).
        </para>
____________________________________________________________________________-->
        <para>
         当这个特性被启用时，关系末尾的被清出的空间不能被释放给操作系统，因为那可能会移除用于检测<quote>snapshot too old</quote>情况所需的信息。所有分配给关系的空间还将与该关系关联在一起便于重用，除非它们被显式地释放（例如，用<command>VACUUM FULL</command>）。
        </para>

<!--==========================orignal english content==========================
        <para>
         This setting does not attempt to guarantee that an error will be
         generated under any particular circumstances.  In fact, if the
         correct results can be generated from (for example) a cursor which
         has materialized a result set, no error will be generated even if the
         underlying rows in the referenced table have been vacuumed away.
         Some tables cannot safely be vacuumed early, and so will not be
         affected by this setting, such as system catalogs.  For such tables
         this setting will neither reduce bloat nor create a possibility
         of a <quote>snapshot too old</quote> error on scanning.
        </para>
____________________________________________________________________________-->
        <para>
         这个设置不会尝试保证在任何特殊情况下都会生成错误。事实上，如果（例如）可以从一个已经物化了一个结果集的游标中生成正确的结果，即便被引用表中的底层行已经被清理掉也不会生成错误。某些表不能被过早地安全清除，并且因此将不受这个设置的影响，例如系统目录。对于这些表，这个设置将不能降低膨胀，也不能降低在扫描时产生<quote>snapshot too old</quote>错误的可能性。
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </sect2>
   </sect1>

   <sect1 id="runtime-config-wal">
<!--==========================orignal english content==========================
    <title>Write Ahead Log</title>
____________________________________________________________________________-->
    <title>预写式日志</title>
<!--==========================orignal english content==========================
   <para>
    For additional information on tuning these settings,
    see <xref linkend="wal-configuration"/>.
   </para>
____________________________________________________________________________-->
   <para>
    参阅<xref linkend="wal-configuration"/>获取调节这些设置的额外信息。
   </para>

    <sect2 id="runtime-config-wal-settings">
<!--==========================orignal english content==========================
     <title>Settings</title>
____________________________________________________________________________-->
     <title>设置</title>
     <variablelist>

     <varlistentry id="guc-wal-level" xreflabel="wal_level">
<!--==========================orignal english content==========================
      <term><varname>wal_level</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>wal_level</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>wal_level</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>wal_level</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        <varname>wal_level</varname> determines how much information is written to
        the WAL. The default value is <literal>replica</literal>, which writes enough
        data to support WAL archiving and replication, including running
        read-only queries on a standby server. <literal>minimal</literal> removes all
        logging except the information required to recover from a crash or
        immediate shutdown.  Finally,
        <literal>logical</literal> adds information necessary to support logical
        decoding.  Each level includes the information logged at all lower
        levels.  This parameter can only be set at server start.
       </para>
____________________________________________________________________________-->
       <para>
        <varname>wal_level</varname>决定多少信息写入到 WAL 中。默认值是<literal>replica</literal>，它会写入足够的数据以支持WAL归档和复制，包括在后备服务器上运行只读查询。<literal>minimal</literal>会去掉除从崩溃或者立即关机中进行恢复所需的信息之外的所有记录。最后，<literal>logical</literal>会增加支持逻辑解码所需的信息。每个层次包括所有更低层次记录的信息。这个参数只能在服务器启动时设置。
       </para>

<!--==========================orignal english content==========================
       <para>
        In <literal>minimal</literal> level, no information is logged for
        permanent relations for the remainder of a transaction that creates or
        rewrites them.  This can make operations much faster (see
        <xref linkend="populate-pitr"/>).  Operations that initiate this
        optimization include:
        <simplelist>
         <member><command>ALTER ... SET TABLESPACE</command></member>
         <member><command>CLUSTER</command></member>
         <member><command>CREATE TABLE</command></member>
         <member><command>REFRESH MATERIALIZED VIEW</command>
         (without <option>CONCURRENTLY</option>)</member>
         <member><command>REINDEX</command></member>
         <member><command>TRUNCATE</command></member>
        </simplelist>
        But minimal WAL does not contain enough information to reconstruct the
        data from a base backup and the WAL logs, so <literal>replica</literal> or
        higher must be used to enable WAL archiving
        (<xref linkend="guc-archive-mode"/>) and streaming replication.
        Note that changing <varname>wal_level</varname> to
        <literal>minimal</literal> makes any base backups taken before
        unavailable for archive recovery and standby server, which may
        lead to data loss.
       </para>
____________________________________________________________________________-->
       <para>
        在<literal>minimal</literal>级别中，对于创建或重写永久关系的事务的其余部分，不会记录任何信息。
        这可以使那些操作更快（参见<xref linkend="populate-pitr"/>）。初始化这种优化的操作包括：
        <simplelist>
         <member><command>ALTER ... SET TABLESPACE</command></member>
         <member><command>CLUSTER</command></member>
         <member><command>CREATE TABLE</command></member>
         <member><command>REFRESH MATERIALIZED VIEW</command>
         (without <option>CONCURRENTLY</option>)</member>
         <member><command>REINDEX</command></member>
         <member><command>TRUNCATE</command></member>
        </simplelist>
        但最少的 WAL 不会包括足够的信息来从基础备份和 WAL 日志中重建数据，因此，要启用 WAL 归档（<xref linkend="guc-archive-mode"/>）和流复制，必须使用<literal>replica</literal>或更高级别。
        注意改变<varname>wal_level</varname>为<literal>minimal</literal>导致归档恢复和备用服务器之前的基本备份失效，也可能会导致数据丢失。
       </para>

<!--==========================orignal english content==========================
       <para>
        In <literal>logical</literal> level, the same information is logged as
        with <literal>replica</literal>, plus information needed to allow
        extracting logical change sets from the WAL. Using a level of
        <literal>logical</literal> will increase the WAL volume, particularly if many
        tables are configured for <literal>REPLICA IDENTITY FULL</literal> and
        many <command>UPDATE</command> and <command>DELETE</command> statements are
        executed.
       </para>
____________________________________________________________________________-->
       <para>
        在<literal>logical</literal>层，与<literal>replica</literal>相同的信息会被记录，外加上
        允许从 WAL 抽取逻辑修改集所需的信息。使用级别
        <literal>logical</literal>将增加 WAL 容量，特别是如果为了<literal>REPLICA IDENTITY FULL</literal>配置了很多表并且执行了很多<command>UPDATE</command>和<command>DELETE</command>
        语句时。
       </para>

<!--==========================orignal english content==========================
       <para>
        In releases prior to 9.6, this parameter also allowed the
        values <literal>archive</literal> and <literal>hot_standby</literal>.
        These are still accepted but mapped to <literal>replica</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        在 9.6 之前的版本中，这个参数也允许值<literal>archive</literal>和<literal>hot_standby</literal>。现在仍然接受这些值，但是它们会被映射到<literal>replica</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-fsync" xreflabel="fsync">
<!--==========================orignal english content==========================
      <term><varname>fsync</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>fsync</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>fsync</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>fsync</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        If this parameter is on, the <productname>PostgreSQL</productname> server
        will try to make sure that updates are physically written to
        disk, by issuing <function>fsync()</function> system calls or various
        equivalent methods (see <xref linkend="guc-wal-sync-method"/>).
        This ensures that the database cluster can recover to a
        consistent state after an operating system or hardware crash.
       </para>
____________________________________________________________________________-->
       <para>
        如果打开这个参数，<productname>PostgreSQL</productname>服务器将尝试确保更新被物理地写入到磁盘，做法是发出<function>fsync()</function>系统调用或者使用多种等价的方法（见<xref linkend="guc-wal-sync-method"/>）。这保证了数据库集簇在一次操作系统或者硬件崩溃后能恢复到一个一致的状态。
       </para>

<!--==========================orignal english content==========================
       <para>
        While turning off <varname>fsync</varname> is often a performance
        benefit, this can result in unrecoverable data corruption in
        the event of a power failure or system crash.  Thus it
        is only advisable to turn off <varname>fsync</varname> if
        you can easily recreate your entire database from external
        data.
       </para>
____________________________________________________________________________-->
       <para>
        虽然关闭<varname>fsync</varname>常常可以得到性能上的收益，但当发生断电或系统崩溃时可能造成不可恢复的数据损坏。因此，只有在能很容易地从外部数据中重建整个数据库时才建议关闭<varname>fsync</varname>。
       </para>

<!--==========================orignal english content==========================
       <para>
        Examples of safe circumstances for turning off
        <varname>fsync</varname> include the initial loading of a new
        database cluster from a backup file, using a database cluster
        for processing a batch of data after which the database
        will be thrown away and recreated,
        or for a read-only database clone which
        gets recreated frequently and is not used for failover.  High
        quality hardware alone is not a sufficient justification for
        turning off <varname>fsync</varname>.
       </para>
____________________________________________________________________________-->
       <para>
        能安全关闭<varname>fsync</varname>的环境的例子包括从一个备份文件中初始加载一个新数据库集簇、使用一个数据库集簇来在数据库被删掉并重建之后处理一批数据，或者一个被经常重建并却不用于失效备援的只读数据库克隆。单独的高质量硬件不足以成为关闭<varname>fsync</varname>的理由。
       </para>

<!--==========================orignal english content==========================
       <para>
        For reliable recovery when changing <varname>fsync</varname>
        off to on, it is necessary to force all modified buffers in the
        kernel to durable storage.  This can be done while the cluster
        is shutdown or while <varname>fsync</varname> is on by running <command>initdb
        -&minus;sync-only</command>, running <command>sync</command>, unmounting the
        file system, or rebooting the server.
       </para>
____________________________________________________________________________-->
       <para>
        当把<varname>fsync</varname>从关闭改成打开时，为了可靠的恢复，需要强制在内核中的所有被修改的缓冲区进入持久化存储。这可以在多个时机来完成：在集簇被关闭时或在 fsync 因为运行<command>initdb --sync-only</command>而打开时、运行<command>sync</command>时、卸载文件系统时或者重启服务器时。
       </para>

<!--==========================orignal english content==========================
       <para>
        In many situations, turning off <xref linkend="guc-synchronous-commit"/>
        for noncritical transactions can provide much of the potential
        performance benefit of turning off <varname>fsync</varname>, without
        the attendant risks of data corruption.
       </para>
____________________________________________________________________________-->
       <para>
        在很多情况下，为不重要的事务关闭<xref linkend="guc-synchronous-commit"/>可以提供很多关闭<varname>fsync</varname>的潜在性能收益，并不会有的同时， 关闭fsync可以提供很多潜在的性能优势，而不会有伴随着的数据损坏风险。
       </para>

<!--==========================orignal english content==========================
       <para>
        <varname>fsync</varname> can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
        If you turn this parameter off, also consider turning off
        <xref linkend="guc-full-page-writes"/>.
       </para>
____________________________________________________________________________-->
       <para>
        <varname>fsync</varname>只能在<filename>postgresql.conf</filename>文件中或在服务器命令行上设置。如果你关闭这个参数，请也考虑关闭<xref linkend="guc-full-page-writes"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-synchronous-commit" xreflabel="synchronous_commit">
<!--==========================orignal english content==========================
      <term><varname>synchronous_commit</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>synchronous_commit</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>synchronous_commit</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>synchronous_commit</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>

<!--==========================orignal english content==========================
       <para>
        Specifies how much WAL processing must complete before
        the database server returns a <quote>success</quote>
        indication to the client.  Valid values are
        <literal>remote_apply</literal>, <literal>on</literal>
        (the default), <literal>remote_write</literal>,
        <literal>local</literal>, and <literal>off</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        指定数据库服务器返回<quote>success</quote>指示给客户端之前，必须要完成多少WAL处理。
        合法的值为<literal>remote_apply</literal>, <literal>on</literal>(默认值), <literal>remote_write</literal>,<literal>local</literal>, 和 <literal>off</literal>。
       </para>

<!--==========================orignal english content==========================
       <para>
        If <varname>synchronous_standby_names</varname> is empty,
        the only meaningful settings are <literal>on</literal> and
        <literal>off</literal>;  <literal>remote_apply</literal>,
        <literal>remote_write</literal> and <literal>local</literal>
        all provide the same local synchronization level
        as <literal>on</literal>.  The local behavior of all
        non-<literal>off</literal> modes is to wait for local flush of WAL
        to disk.  In <literal>off</literal> mode, there is no waiting,
        so there can be a delay between when success is reported to the
        client and when the transaction is later guaranteed to be safe
        against a server crash.  (The maximum
        delay is three times <xref linkend="guc-wal-writer-delay"/>.)  Unlike
        <xref linkend="guc-fsync"/>, setting this parameter to <literal>off</literal>
        does not create any risk of database inconsistency: an operating
        system or database crash might
        result in some recent allegedly-committed transactions being lost, but
        the database state will be just the same as if those transactions had
        been aborted cleanly.  So, turning <varname>synchronous_commit</varname> off
        can be a useful alternative when performance is more important than
        exact certainty about the durability of a transaction.  For more
        discussion see <xref linkend="wal-async-commit"/>.
       </para>
____________________________________________________________________________-->
       <para>
        如果<varname>synchronous_standby_names</varname>为空，则唯一有意义的设置为<literal>on</literal> 和 <literal>off</literal> ；
        <literal>remote_apply</literal>，<literal>remote_write</literal> 和 <literal>local</literal>都提供与<literal>on</literal>相同的本地同步级别。 
        所有非<literal>off</literal>模式的本地行为都是等待WAL的本地刷新到磁盘。 
        在 <literal>off</literal>模式，无需等待，因此在向客户端报告成功和以后保证事务安全防止服务器崩溃之间可能会出现延迟。
        当设置为<literal>off</literal>时，在向客户端报告成功和真正保证事务不会被服务器崩溃威胁之间会有延迟（最大的延迟是<xref linkend="guc-wal-writer-delay"/>的三倍）。
        不同于<xref linkend="guc-fsync"/>，将这个参数设置为<literal>off</literal>不会产生数据库不一致性的风险：一个操作系统或数据库崩溃可能会造成一些最近据说已提交的事务丢失，但数据库状态是一致的，就像这些事务已经被干净地中止。
        因此，当性能比完全确保事务的持久性更重要时，关闭<varname>synchronous_commit</varname>可以作为一个有效的代替手段。更多讨论见<xref linkend="wal-async-commit"/>。
       </para>

<!--==========================orignal english content==========================
       <para>
        If <xref linkend="guc-synchronous-standby-names"/> is non-empty,
        <varname>synchronous_commit</varname> also controls whether
        transaction commits will wait for their WAL records to be
        processed on the standby server(s).
       </para>
____________________________________________________________________________-->
       <para>
        如果<xref linkend="guc-synchronous-standby-names"/>为非空，<varname>synchronous_commit</varname>也控制是否事务提交将等待它们的 WAL 记录在后备服务器上被处理。
       </para>

<!--==========================orignal english content==========================
       <para>
        When set to <literal>remote_apply</literal>, commits will wait
        until replies from the current synchronous standby(s) indicate they
        have received the commit record of the transaction and applied
        it, so that it has become visible to queries on the standby(s),
        and also written to durable storage on the standbys.  This will
        cause much larger commit delays than previous settings since
        it waits for WAL replay.  When set to <literal>on</literal>,
        commits wait until replies
        from the current synchronous standby(s) indicate they have received
        the commit record of the transaction and flushed it to durable storage.  This
        ensures the transaction will not be lost unless both the primary and
        all synchronous standbys suffer corruption of their database storage.
        When set to <literal>remote_write</literal>, commits will wait until replies
        from the current synchronous standby(s) indicate they have
        received the commit record of the transaction and written it to
        their file systems. This setting ensures data preservation if a standby instance of
        <productname>PostgreSQL</productname> crashes, but not if the standby
        suffers an operating-system-level crash because the data has not
        necessarily reached durable storage on the standby.
        The setting <literal>local</literal> causes commits to wait for
        local flush to disk, but not for replication.  This is usually not
        desirable when synchronous replication is in use, but is provided for
        completeness.
       </para>
____________________________________________________________________________-->
       <para>
        当设置为 <literal>remote_apply</literal> 时，提交将等待，直到来自当前同步备用服务器的答复显示他们已收到事务的提交记录并应用了它，以便它变得对备用服务器上的查询可见，并写入备用服务器上的持久存储。 
        这将导致比以前的设置更大的提交延迟，因为它等待 WAL 重放(replay)。 
        当设置为<literal>on</literal>时，提交将等待，直到来自于当前同步的后备服务器的回复显示它们已经收到了事务的提交记录并将其刷入了磁盘。
        这保证事务将不会被丢失，除非主服务器和所有同步后备都遭受到了数据库存储损坏的问题。
        当这个参数被设置为<literal>remote_write</literal>时，提交将等待，直到来自当前的同步后备的回复指示它们已经收到了该事务的提交记录并且已经把该记录写到它们的文件系统，这种设置保证数据得以保存，在<productname>PostgreSQL</productname>的后备服务器实例崩溃时，但是不能保证后备服务器遭受操作系统级别崩溃时数据能被保持，因为数据不一定必须要在后备机上达到持久存储。
        设置<literal>local</literal>会导致提交等待本地刷写到磁盘，而不是复制。在使用同步复制时这通常是不可取的，但是为了完整性提供了这个选项。
       </para>

<!--==========================orignal english content==========================
       <para>
        This parameter can be changed at any time; the behavior for any
        one transaction is determined by the setting in effect when it
        commits.  It is therefore possible, and useful, to have some
        transactions commit synchronously and others asynchronously.
        For example, to make a single multistatement transaction commit
        asynchronously when the default is the opposite, issue <command>SET
        LOCAL synchronous_commit TO OFF</command> within the transaction.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数可以随时被修改；任何一个事务的行为由其提交时生效的设置决定。因此，可以同步提交一些事务，同时异步提交其他事务。例如，当默认是相反时，实现一个单一多语句事务的异步提交，在事务中发出<command>SET LOCAL synchronous_commit TO OFF</command>。
       </para>

<!--==========================orignal english content==========================
       <para>
        <xref linkend="synchronous-commit-matrix"/> summarizes the
        capabilities of the <varname>synchronous_commit</varname> settings.
       </para>
____________________________________________________________________________-->
       <para>
        <xref linkend="synchronous-commit-matrix"/> 概括了 <varname>synchronous_commit</varname> 设置的能力.
       </para>

       <table id="synchronous-commit-matrix">
<!--==========================orignal english content==========================
        <title>synchronous_commit Modes</title>
____________________________________________________________________________-->
        <title>synchronous_commit Modes</title>
        <tgroup cols="5">
         <colspec colname="col1" colwidth="1.5*"/>
         <colspec colname="col2" colwidth="1*"/>
         <colspec colname="col3" colwidth="1*"/>
         <colspec colname="col4" colwidth="1*"/>
         <colspec colname="col5" colwidth="1*"/>
         <thead>
<!--==========================orignal english content==========================
          <row>
           <entry>synchronous_commit setting</entry>
           <entry>local durable commit</entry>
           <entry>standby durable commit after PG crash</entry>
           <entry>standby durable commit after OS crash</entry>
           <entry>standby query consistency</entry>
          </row>
____________________________________________________________________________-->
          <row>
           <entry>synchronous_commit setting</entry>
           <entry>local durable commit</entry>
           <entry>standby durable commit after PG crash</entry>
           <entry>standby durable commit after OS crash</entry>
           <entry>standby query consistency</entry>
          </row>
         </thead>

         <tbody>

<!--==========================orignal english content==========================
          <row>
           <entry>remote_apply</entry>
           <entry align="center">&bull;</entry>
           <entry align="center">&bull;</entry>
           <entry align="center">&bull;</entry>
           <entry align="center">&bull;</entry>
          </row>
____________________________________________________________________________-->
          <row>
           <entry>remote_apply</entry>
           <entry align="center">&bull;</entry>
           <entry align="center">&bull;</entry>
           <entry align="center">&bull;</entry>
           <entry align="center">&bull;</entry>
          </row>

<!--==========================orignal english content==========================
          <row>
           <entry>on</entry>
           <entry align="center">&bull;</entry>
           <entry align="center">&bull;</entry>
           <entry align="center">&bull;</entry>
           <entry align="center"></entry>
          </row>
____________________________________________________________________________-->
          <row>
           <entry>on</entry>
           <entry align="center">&bull;</entry>
           <entry align="center">&bull;</entry>
           <entry align="center">&bull;</entry>
           <entry align="center"></entry>
          </row>

<!--==========================orignal english content==========================
          <row>
           <entry>remote_write</entry>
           <entry align="center">&bull;</entry>
           <entry align="center">&bull;</entry>
           <entry align="center"></entry>
           <entry align="center"></entry>
          </row>
____________________________________________________________________________-->
          <row>
           <entry>remote_write</entry>
           <entry align="center">&bull;</entry>
           <entry align="center">&bull;</entry>
           <entry align="center"></entry>
           <entry align="center"></entry>
          </row>

<!--==========================orignal english content==========================
          <row>
           <entry>local</entry>
           <entry align="center">&bull;</entry>
           <entry align="center"></entry>
           <entry align="center"></entry>
           <entry align="center"></entry>
          </row>
____________________________________________________________________________-->
          <row>
           <entry>local</entry>
           <entry align="center">&bull;</entry>
           <entry align="center"></entry>
           <entry align="center"></entry>
           <entry align="center"></entry>
          </row>

<!--==========================orignal english content==========================
          <row>
           <entry>off</entry>
           <entry align="center"></entry>
           <entry align="center"></entry>
           <entry align="center"></entry>
           <entry align="center"></entry>
          </row>
____________________________________________________________________________-->
          <row>
           <entry>off</entry>
           <entry align="center"></entry>
           <entry align="center"></entry>
           <entry align="center"></entry>
           <entry align="center"></entry>
          </row>

         </tbody>
        </tgroup>
       </table>

      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-sync-method" xreflabel="wal_sync_method">
<!--==========================orignal english content==========================
      <term><varname>wal_sync_method</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>wal_sync_method</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>wal_sync_method</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>wal_sync_method</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Method used for forcing WAL updates out to disk.
        If <varname>fsync</varname> is off then this setting is irrelevant,
        since WAL file updates will not be forced out at all.
        Possible values are:
       </para>
____________________________________________________________________________-->
       <para>
        用来向强制 WAL 更新到磁盘的方法。如果<varname>fsync</varname>是关闭的，那么这个设置就不相关，因为 WAL 文件更新将根本不会被强制。可能的值是：
       </para>
       <itemizedlist>
        <listitem>
<!--==========================orignal english content==========================
        <para>
         <literal>open_datasync</literal> (write WAL files with <function>open()</function> option <symbol>O_DSYNC</symbol>)
        </para>
____________________________________________________________________________-->
        <para>
         <literal>open_datasync</literal>（用<function>open()</function>选项<symbol>O_DSYNC</symbol>写 WAL 文件）
        </para>
        </listitem>
        <listitem>
<!--==========================orignal english content==========================
        <para>
         <literal>fdatasync</literal> (call <function>fdatasync()</function> at each commit)
        </para>
____________________________________________________________________________-->
        <para>
         <literal>fdatasync</literal>（在每次提交时调用<function>fdatasync()</function>）
        </para>
        </listitem>
        <listitem>
<!--==========================orignal english content==========================
        <para>
         <literal>fsync</literal> (call <function>fsync()</function> at each commit)
        </para>
____________________________________________________________________________-->
        <para>
         <literal>fsync</literal>（在每次提交时调用<function>fsync()</function>）
        </para>
        </listitem>
        <listitem>
<!--==========================orignal english content==========================
        <para>
         <literal>fsync_writethrough</literal> (call <function>fsync()</function> at each commit, forcing write-through of any disk write cache)
        </para>
____________________________________________________________________________-->
        <para>
         <literal>fsync_writethrough</literal>（在每次提交时调用<function>fsync()</function>，强制任何磁盘写高速缓存的直通写）
        </para>
        </listitem>
        <listitem>
<!--==========================orignal english content==========================
        <para>
         <literal>open_sync</literal> (write WAL files with <function>open()</function> option <symbol>O_SYNC</symbol>)
        </para>
____________________________________________________________________________-->
        <para>
         <literal>open_sync</literal>（用<function>open()</function>选项<symbol>O_SYNC</symbol>写 WAL 文件）
        </para>
        </listitem>
       </itemizedlist>
<!--==========================orignal english content==========================
       <para>
        The <literal>open_</literal>* options also use <literal>O_DIRECT</literal> if available.
        Not all of these choices are available on all platforms.
        The default is the first method in the above list that is supported
        by the platform, except that <literal>fdatasync</literal> is the default on
        Linux and FreeBSD.  The default is not necessarily ideal; it might be
        necessary to change this setting or other aspects of your system
        configuration in order to create a crash-safe configuration or
        achieve optimal performance.
        These aspects are discussed in <xref linkend="wal-reliability"/>.
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        <literal>open_</literal>* 选项也可以使用<literal>O_DIRECT</literal>（如果可用）。
        不是在所有平台上都能使用所有这些选择。
        默认值是列表中第一个被平台支持的那个， 不过<literal>fdatasync</literal>是 Linux和FreeBSD中的默认值。
        默认值不一定是最理想的；有可能需要修改这个设置或系统配置的其他方面来创建一个崩溃-安全的配置，或达到最佳性能。
        这些方面在<xref linkend="wal-reliability"/>中讨论。
        这个参数只能在<filename>postgresql.conf</filename>文件中或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-full-page-writes" xreflabel="full_page_writes">
<!--==========================orignal english content==========================
      <term><varname>full_page_writes</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>full_page_writes</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>full_page_writes</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>full_page_writes</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        When this parameter is on, the <productname>PostgreSQL</productname> server
        writes the entire content of each disk page to WAL during the
        first modification of that page after a checkpoint.
        This is needed because
        a page write that is in process during an operating system crash might
        be only partially completed, leading to an on-disk page
        that contains a mix of old and new data.  The row-level change data
        normally stored in WAL will not be enough to completely restore
        such a page during post-crash recovery.  Storing the full page image
        guarantees that the page can be correctly restored, but at the price
        of increasing the amount of data that must be written to WAL.
        (Because WAL replay always starts from a checkpoint, it is sufficient
        to do this during the first change of each page after a checkpoint.
        Therefore, one way to reduce the cost of full-page writes is to
        increase the checkpoint interval parameters.)
       </para>
____________________________________________________________________________-->
       <para>
        当这个参数为打开时，<productname>PostgreSQL</productname>服务器在一个检查点之后的页面的第一次修改期间将每个页面的全部内容写到  WAL 中。这么做是因为在操作系统崩溃期间正在处理的一次页写入可能只有部分完成，从而导致在一个磁盘页面中混合有新旧数据。在崩溃后的恢复期间，通常存储在 WAL 中的行级改变数据不足以完全恢复这样一个页面。存储完整的页面映像可以保证页面被正确存储，但代价是增加了必须被写入 WAL 的数据量（因为 WAL 重放总是从一个检查点开始，所以在检查点后每个页面的第一次改变时这样做就够了。因此，一种减小全页面写开销的方法是增加检查点间隔参数值）。
       </para>

<!--==========================orignal english content==========================
       <para>
        Turning this parameter off speeds normal operation, but
        might lead to either unrecoverable data corruption, or silent
        data corruption, after a system failure. The risks are similar to turning off
        <varname>fsync</varname>, though smaller, and it should be turned off
        only based on the same circumstances recommended for that parameter.
       </para>
____________________________________________________________________________-->
       <para>
        把这个参数关闭会加快正常操作，但是在系统失败后可能导致不可恢复的数据损坏，或者静默的数据损坏。其风险类似于关闭<varname>fsync</varname>， 但是风险较小。并且只有在可关闭<varname>fsync</varname>的情况下才应该关闭它。
       </para>

<!--==========================orignal english content==========================
       <para>
        Turning off this parameter does not affect use of
        WAL archiving for point-in-time recovery (PITR)
        (see <xref linkend="continuous-archiving"/>).
       </para>
____________________________________________________________________________-->
       <para>
        关闭这个选项并不影响用于时间点恢复（PITR）的 WAL 归档使用（见<xref linkend="continuous-archiving"/>）。
       </para>

<!--==========================orignal english content==========================
       <para>
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
        The default is <literal>on</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数只能在<filename>postgresql.conf</filename>文件中或在服务器命令行上设置。默认值是<literal>on</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-log-hints" xreflabel="wal_log_hints">
<!--==========================orignal english content==========================
      <term><varname>wal_log_hints</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>wal_log_hints</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>wal_log_hints</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>wal_log_hints</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        When this parameter is <literal>on</literal>, the <productname>PostgreSQL</productname>
        server writes the entire content of each disk page to WAL during the
        first modification of that page after a checkpoint, even for
        non-critical modifications of so-called hint bits.
       </para>
____________________________________________________________________________-->
       <para>
        当这个参数为<literal>on</literal>时，<productname>PostgreSQL</productname>服务器一个检查点之后页面被第一次修改期间把该磁盘页面的整个内容都写入 WAL，即使对所谓的提示位做非关键修改也会这样做。
       </para>

<!--==========================orignal english content==========================
       <para>
        If data checksums are enabled, hint bit updates are always WAL-logged
        and this setting is ignored. You can use this setting to test how much
        extra WAL-logging would occur if your database had data checksums
        enabled.
       </para>
____________________________________________________________________________-->
       <para>
        如果启用了数据校验和，提示位更新总是会被 WAL 记录并且这个设置会被忽略。你可以使用这个
        设置测试如果你的数据库启用了数据校验和，会有多少额外的 WAL 记录发生。
       </para>

<!--==========================orignal english content==========================
       <para>
        This parameter can only be set at server start. The default value is <literal>off</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数只能在服务器启动时设置。默认值是<literal>off</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-compression" xreflabel="wal_compression">
<!--==========================orignal english content==========================
      <term><varname>wal_compression</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>wal_compression</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>wal_compression</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>wal_compression</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        When this parameter is <literal>on</literal>, the <productname>PostgreSQL</productname>
        server compresses full page images written to WAL when
        <xref linkend="guc-full-page-writes"/> is on or during a base backup.
        A compressed page image will be decompressed during WAL replay.
        The default value is <literal>off</literal>.
        Only superusers can change this setting.
       </para>
____________________________________________________________________________-->
       <para>
        当这个参数为<literal>on</literal>时，如果<xref linkend="guc-full-page-writes"/>
        为打开或者处于基础备份期间，<productname>PostgreSQL</productname>服务器
        会压缩写入到 WAL 中的完整页面镜像。压缩页面镜像将在 WAL 重放时
        被解压。默认值为<literal>off</literal>。只有超级用户可以更改这个设置。
       </para>

<!--==========================orignal english content==========================
       <para>
        Turning this parameter on can reduce the WAL volume without
        increasing the risk of unrecoverable data corruption,
        but at the cost of some extra CPU spent on the compression during
        WAL logging and on the decompression during WAL replay.
       </para>
____________________________________________________________________________-->
       <para>
        打开这个参数可以减小 WAL 所占的空间且无需承受不可恢复的数据损坏风险，
        但是代价是需要额外的 CPU 开销以便在 WAL 记录期间进行压缩以及在 WAL 
        重放时解压。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-init-zero" xreflabel="wal_init_zero">
<!--==========================orignal english content==========================
      <term><varname>wal_init_zero</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>wal_init_zero</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>wal_init_zero</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>wal_init_zero</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        If set to <literal>on</literal> (the default), this option causes new
        WAL files to be filled with zeroes.  On some file systems, this ensures
        that space is allocated before we need to write WAL records.  However,
        <firstterm>Copy-On-Write</firstterm> (COW) file systems may not benefit
        from this technique, so the option is given to skip the unnecessary
        work.  If set to <literal>off</literal>, only the final byte is written
        when the file is created so that it has the expected size.
       </para>
____________________________________________________________________________-->
       <para>
        如果设置为<literal>on</literal>（默认值），此选项会导致新的 WAL 文件被零填充。 
        在某些文件系统上，这可确保在我们需要写入 WAL 记录之前分配空间。 
        但是，<firstterm>Copy-On-Write</firstterm>（COW）文件系统可能不会从此技术中受益，因此可以选择跳过不必要的工作。 
        如果设置为<literal>off</literal>，则在创建文件时仅写入最终字节，以便其具有预期大小。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-recycle" xreflabel="wal_recycle">
<!--==========================orignal english content==========================
      <term><varname>wal_recycle</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>wal_recycle</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>wal_recycle</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>wal_recycle</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        If set to <literal>on</literal> (the default), this option causes WAL
        files to be recycled by renaming them, avoiding the need to create new
        ones.  On COW file systems, it may be faster to create new ones, so the
        option is given to disable this behavior.
       </para>
____________________________________________________________________________-->
       <para>
        如果设置为 <literal>on</literal> （默认值），此选项通过重命名来回收 WAL 文件，从而避免创建新文件。 
        在 COW 文件系统上，创建新文件系统可能更快，因此提供了禁用此行为的选项。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-buffers" xreflabel="wal_buffers">
<!--==========================orignal english content==========================
      <term><varname>wal_buffers</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>wal_buffers</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>wal_buffers</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>wal_buffers</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The amount of shared memory used for WAL data that has not yet been
        written to disk.  The default setting of -1 selects a size equal to
        1/32nd (about 3%) of <xref linkend="guc-shared-buffers"/>, but not less
        than <literal>64kB</literal> nor more than the size of one WAL
        segment, typically <literal>16MB</literal>.  This value can be set
        manually if the automatic choice is too large or too small,
        but any positive value less than <literal>32kB</literal> will be
        treated as <literal>32kB</literal>.
        If this value is specified without units, it is taken as WAL blocks,
        that is <symbol>XLOG_BLCKSZ</symbol> bytes, typically 8kB.
        This parameter can only be set at server start.
       </para>
____________________________________________________________________________-->
       <para>
        用于还未写入磁盘的 WAL 数据的共享内存量。默认值 -1 选择等于<xref linkend="guc-shared-buffers"/>的 1/32 的尺寸（大约3%），但是不小于<literal>64kB</literal>也不大于 WAL 段的尺寸（通常为）。如果自动的选择太大或太小可以手工设置该值，但是任何小于<literal>32kB</literal>的正值都将被当作<literal>32kB</literal>。
        如果指定值时没有单位，则以WAL块作为单位，即为 <symbol>XLOG_BLCKSZ</symbol> 字节，通常为8kB。这个参数只能在服务器启动时设置。
       </para>

<!--==========================orignal english content==========================
       <para>
        The contents of the WAL buffers are written out to disk at every
        transaction commit, so extremely large values are unlikely to
        provide a significant benefit.  However, setting this value to at
        least a few megabytes can improve write performance on a busy
        server where many clients are committing at once.  The auto-tuning
        selected by the default setting of -1 should give reasonable
        results in most cases.
       </para>
____________________________________________________________________________-->
       <para>
        在每次事务提交时，WAL 缓冲区的内容被写出到磁盘，因此极大的值不可能提供显著的收益。不过，把这个值设置为几个兆字节可以在一个繁忙的服务器（其中很多客户端会在同一时间提交）上提高写性能。由默认设置 -1 选择的自动调节将在大部分情况下得到合理的结果。
       </para>

      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-writer-delay" xreflabel="wal_writer_delay">
<!--==========================orignal english content==========================
      <term><varname>wal_writer_delay</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>wal_writer_delay</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>wal_writer_delay</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>wal_writer_delay</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
      <para>
        Specifies how often the WAL writer flushes WAL, in time terms.
        After flushing WAL the writer sleeps for the length of time given
        by <varname>wal_writer_delay</varname>, unless woken up sooner
        by an asynchronously committing transaction. If the last flush
        happened less than <varname>wal_writer_delay</varname> ago and less
        than <varname>wal_writer_flush_after</varname> worth of WAL has been
        produced since, then WAL is only written to the operating system, not
        flushed to disk.
        If this value is specified without units, it is taken as milliseconds.
        The default value is 200 milliseconds (<literal>200ms</literal>).  Note that
        on many systems, the effective resolution of sleep delays is 10
        milliseconds; setting <varname>wal_writer_delay</varname> to a value that is
        not a multiple of 10 might have the same results as setting it to the
        next higher multiple of 10. This parameter can only be set in the
        <filename>postgresql.conf</filename> file or on the server command line.
       </para>
____________________________________________________________________________-->
      <para>
        指定 WAL 写入器刷写 WAL 的频繁程度，以时间为单位。
        在刷写WAL之后，写入器将根据<varname>wal_writer_delay</varname>所给出的时间长度进行睡眠，除非被一个异步提交的事务提前唤醒。
        如果最近的刷写发生在 <varname>wal_writer_delay</varname> 之前，并且小于 <varname>wal_writer_flush_after</varname> WAL的值产生之后，那么WAL只会被写入操作系统，而不会被刷写到磁盘。
        如果指定值时没有单位，则以毫秒作为单位。
		默认值是 200 毫秒（<literal>200ms</literal>）。注意在很多系统上，有效的睡眠延迟粒度是 10 毫秒，把<varname>wal_writer_delay</varname>设置为一个不是 10 的倍数的值，其效果和把它设置为大于该值的下一个 10 的倍数产生的效果相同。这个参数只能在<filename>postgresql.conf</filename>文件中或者服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-writer-flush-after" xreflabel="wal_writer_flush_after">
<!--==========================orignal english content==========================
      <term><varname>wal_writer_flush_after</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>wal_writer_flush_after</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>wal_writer_flush_after</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>wal_writer_flush_after</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
      <para>
        Specifies how often the WAL writer flushes WAL, in volume terms.
        If the last flush happened less
        than <varname>wal_writer_delay</varname> ago and less
        than <varname>wal_writer_flush_after</varname> worth of WAL has been
        produced since, then WAL is only written to the operating system, not
        flushed to disk.  If <varname>wal_writer_flush_after</varname> is set
        to <literal>0</literal> then WAL data is always flushed immediately.
        If this value is specified without units, it is taken as WAL blocks,
        that is <symbol>XLOG_BLCKSZ</symbol> bytes, typically 8kB.
        The default is <literal>1MB</literal>.
        This parameter can only be set in the
        <filename>postgresql.conf</filename> file or on the server command line.
       </para>
____________________________________________________________________________-->
      <para>
        指定 WAL 写入器刷写 WAL 的频繁程度，以卷为单位。
        如果最近的刷写发生在 <varname>wal_writer_delay</varname> 之前，并且小于 <varname>wal_writer_flush_after</varname> WAL的值产生之后，那么WAL只会被写入操作系统，而不会被刷写到磁盘。
        如果<varname>wal_writer_flush_after</varname>被设置为<literal>0</literal>，则WAL数据总是会被立即刷写。
        如果指定值时没有单位，则以WAL块作为单位，即为<symbol>XLOG_BLCKSZ</symbol>字节，通常为8kB。
        默认是<literal>1MB</literal>。这个参数只能在<filename>postgresql.conf</filename>文件中或者服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-skip-threshold" xreflabel="wal_skip_threshold">
<!--==========================orignal english content==========================
      <term><varname>wal_skip_threshold</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>wal_skip_threshold</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>wal_skip_threshold</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>wal_skip_threshold</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        When <varname>wal_level</varname> is <literal>minimal</literal> and a
        transaction commits after creating or rewriting a permanent relation,
        this setting determines how to persist the new data.  If the data is
        smaller than this setting, write it to the WAL log; otherwise, use an
        fsync of affected files.  Depending on the properties of your storage,
        raising or lowering this value might help if such commits are slowing
        concurrent transactions.  If this value is specified without units, it
        is taken as kilobytes.  The default is two megabytes
        (<literal>2MB</literal>).
       </para>
____________________________________________________________________________-->
       <para>
        当<varname>wal_level</varname>为<literal>minimal</literal>，并且在创建或重写永久关系之后提交事务时，此设置将确定如何保留新数据。 
        如果数据小于此设置，将其写入 WAL 日志;否则，使用受影响文件的 fsync。 
        根据存储的属性，如果此类提交减慢了并发事务，提高或降低此值可能会有所帮助。 
        如果指定此值时没有单位，则视为千字节。默认为两兆字节（<literal>2MB</literal>）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-commit-delay" xreflabel="commit_delay">
<!--==========================orignal english content==========================
      <term><varname>commit_delay</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>commit_delay</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>commit_delay</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>commit_delay</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Setting <varname>commit_delay</varname> adds a time delay
        before a WAL flush is initiated.  This can improve
        group commit throughput by allowing a larger number of transactions
        to commit via a single WAL flush, if system load is high enough
        that additional transactions become ready to commit within the
        given interval.  However, it also increases latency by up to the
        <varname>commit_delay</varname> for each WAL
        flush.  Because the delay is just wasted if no other transactions
        become ready to commit, a delay is only performed if at least
        <varname>commit_siblings</varname> other transactions are active
        when a flush is about to be initiated.  Also, no delays are
        performed if <varname>fsync</varname> is disabled.
        If this value is specified without units, it is taken as microseconds.
        The default <varname>commit_delay</varname> is zero (no delay).
        Only superusers can change this setting.
       </para>
____________________________________________________________________________-->
       <para>
        在一次 WAL 刷写被发起之前，<varname>commit_delay</varname>增加一个时间延迟。
        如果系统负载足够高，使得在一个给定间隔内有额外的事务准备好提交，那么通过允许更多事务通过一个单次 WAL 刷写来提交能够提高组提交的吞吐量。
        但是，它也把每次 WAL 刷写的潜伏期增加到了最多<varname>commit_delay</varname>。
        因为如果没有其他事务准备好提交，就会浪费一次延迟，只有在当一次刷写将要被发起时有至少<varname>commit_siblings</varname>个其他活动事务时，才会执行一次延迟。
        另外，如果<varname>fsync</varname>被禁用，则将不会执行任何延迟。
        如果指定值时没有单位，则以微秒作为单位。
        默认的<varname>commit_delay</varname>是零（无延迟）。只有超级用户才能修改这个设置。
       </para>

<!--==========================orignal english content==========================
       <para>
        In <productname>PostgreSQL</productname> releases prior to 9.3,
        <varname>commit_delay</varname> behaved differently and was much
        less effective: it affected only commits, rather than all WAL flushes,
        and waited for the entire configured delay even if the WAL flush
        was completed sooner.  Beginning in <productname>PostgreSQL</productname> 9.3,
        the first process that becomes ready to flush waits for the configured
        interval, while subsequent processes wait only until the leader
        completes the flush operation.
       </para>
____________________________________________________________________________-->
       <para>
        在<productname>PostgreSQL</productname>的 9.3 发布之前，<varname>commit_delay</varname>的行为不同并且效果更差：它只影响提交，而不是所有 WAL 刷写，并且即使在 WAL 刷写马上就要完成时也会等待一整个配置的延迟。从<productname>PostgreSQL</productname> 9.3 中开始，第一个准备好刷写的进程会等待配置的间隔，而后续的进程只等到领先者完成刷写操作。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-commit-siblings" xreflabel="commit_siblings">
<!--==========================orignal english content==========================
      <term><varname>commit_siblings</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>commit_siblings</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>commit_siblings</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>commit_siblings</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Minimum number of concurrent open transactions to require
        before performing the <varname>commit_delay</varname> delay. A larger
        value makes it more probable that at least one other
        transaction will become ready to commit during the delay
        interval. The default is five transactions.
       </para>
____________________________________________________________________________-->
       <para>
        在执行<varname>commit_delay</varname>延迟时，要求的并发活动事务的最小数目。大一些的值会导致在延迟间隔期间更可能有至少另外一个事务准备好提交。默认值是五个事务。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
     </sect2>
     <sect2 id="runtime-config-wal-checkpoints">
<!--==========================orignal english content==========================
     <title>Checkpoints</title>
____________________________________________________________________________-->
     <title>检查点</title>

    <variablelist>
     <varlistentry id="guc-checkpoint-timeout" xreflabel="checkpoint_timeout">
<!--==========================orignal english content==========================
      <term><varname>checkpoint_timeout</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>checkpoint_timeout</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>checkpoint_timeout</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>checkpoint_timeout</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Maximum time between automatic WAL checkpoints.
        If this value is specified without units, it is taken as seconds.
        The valid range is between 30 seconds and one day.
        The default is five minutes (<literal>5min</literal>).
        Increasing this parameter can increase the amount of time needed
        for crash recovery.
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        自动 WAL 检查点之间的最长时间。如果指定值时没有单位，则以秒为单位。
        合理的范围在 30 秒到 1 天之间。默认是 5 分钟（<literal>5min</literal>）。增加这个参数的值会增加崩溃恢复所需的时间。这个参数只能在<filename>postgresql.conf</filename>文件中或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-checkpoint-completion-target" xreflabel="checkpoint_completion_target">
<!--==========================orignal english content==========================
      <term><varname>checkpoint_completion_target</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>checkpoint_completion_target</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>checkpoint_completion_target</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>checkpoint_completion_target</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the target of checkpoint completion, as a fraction of
        total time between checkpoints. The default is 0.9, which spreads the
        checkpoint across almost all of the available interval, providing fairly
        consistent I/O load while also leaving some time for checkpoint
        completion overhead.  Reducing this parameter is not recommended because
        it causes the checkpoint to complete faster.  This results in a higher
        rate of I/O during the checkpoint followed by a period of less I/O between
        the checkpoint completion and the next scheduled checkpoint.  This
        parameter can only be set in the <filename>postgresql.conf</filename> file
        or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        指定检查点完成的目标，作为检查点之间总时间的一部分。
        默认是 0.9，这将把检查点分布在几乎所有可用的时间间隔上，提供公平一致的I/O负载，同时也为检查点完成开销留下了一些时间。
        减少此参数是不被推荐的，因为这会导致检查点完成得更快。
        这个造成处于在检查点和下一个计划检查点之间较少IO之后的检查点会有更高的IO比例。
        这个参数只能在<filename>postgresql.conf</filename>文件中或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-checkpoint-flush-after" xreflabel="checkpoint_flush_after">
<!--==========================orignal english content==========================
      <term><varname>checkpoint_flush_after</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>checkpoint_flush_after</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>checkpoint_flush_after</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>checkpoint_flush_after</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Whenever more than this amount of data has been
        written while performing a checkpoint, attempt to force the
        OS to issue these writes to the underlying storage.  Doing so will
        limit the amount of dirty data in the kernel's page cache, reducing
        the likelihood of stalls when an <function>fsync</function> is issued at the end of the
        checkpoint, or when the OS writes data back in larger batches in the
        background.  Often that will result in greatly reduced transaction
        latency, but there also are some cases, especially with workloads
        that are bigger than <xref linkend="guc-shared-buffers"/>, but smaller
        than the OS's page cache, where performance might degrade.  This
        setting may have no effect on some platforms.
        If this value is specified without units, it is taken as blocks,
        that is <symbol>BLCKSZ</symbol> bytes, typically 8kB.
        The valid range is
        between <literal>0</literal>, which disables forced writeback,
        and <literal>2MB</literal>.  The default is <literal>256kB</literal> on
        Linux, <literal>0</literal> elsewhere.  (If <symbol>BLCKSZ</symbol> is not
        8kB, the default and maximum values scale proportionally to it.)
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        当执行检查点时写入的数据量超过此数量时，就尝试强制 OS 把这些写发送到底层存储。
        这样做将会限制内核页面高速缓存中的脏数据数量，降低在检查点末尾发出<function>fsync</function>或者 OS 在后台大批量写回数据时被卡住的可能性。
        那常常会导致大幅度压缩的事务延迟，但是也有一些情况（特别是负载超过<xref linkend="guc-shared-buffers"/>但小于 OS 页面高速缓存）的性能会降低。
        这种设置可能会在某些平台上没有效果。
        如果指定值时没有单位，则以块为单位，即为<symbol>BLCKSZ</symbol> 字节，通常为8kB。
        合法的范围在<literal>0</literal>（禁用强制写回）和<literal>2MB</literal>之间。Linux 上的默认值是<literal>256kB</literal>，其他平台上是<literal>0</literal>（如果<symbol>BLCKSZ</symbol>不是8kB，则默认值和最大值会按比例缩放到它）。这个参数只能在<filename>postgresql.conf</filename>文件中或者服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-checkpoint-warning" xreflabel="checkpoint_warning">
<!--==========================orignal english content==========================
      <term><varname>checkpoint_warning</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>checkpoint_warning</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>checkpoint_warning</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>checkpoint_warning</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Write a message to the server log if checkpoints caused by
        the filling of WAL segment files happen closer together
        than this amount of time (which suggests that
        <varname>max_wal_size</varname> ought to be raised).
        If this value is specified without units, it is taken as seconds.
        The default is 30 seconds (<literal>30s</literal>).
        Zero disables the warning.
        No warnings will be generated if <varname>checkpoint_timeout</varname>
        is less than <varname>checkpoint_warning</varname>.
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        如果由于填充WAL段文件导致的检查点之间的间隔低于这个参数表示的时间量，那么就向服务器日志写一个消息（它建议增加<varname>max_wal_size</varname>的值）。
        如果指定值时没有单位，则以秒为单位。默认值是 30 秒（<literal>30s</literal>）。零则关闭警告。如果<varname>checkpoint_timeout</varname>低于<varname>checkpoint_warning</varname>，则不会有警告产生。这个参数只能在<filename>postgresql.conf</filename>文件中或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-wal-size" xreflabel="max_wal_size">
<!--==========================orignal english content==========================
      <term><varname>max_wal_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_wal_size</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>max_wal_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_wal_size</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Maximum size to let the WAL grow during automatic
        checkpoints. This is a soft limit; WAL size can exceed
        <varname>max_wal_size</varname> under special circumstances, such as
        heavy load, a failing <varname>archive_command</varname>, or a high
        <varname>wal_keep_size</varname> setting.
        If this value is specified without units, it is taken as megabytes.
        The default is 1 GB.
        Increasing this parameter can increase the amount of time needed for
        crash recovery.
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        在自动 WAL 检查点之间允许 WAL 增长到的最大尺寸。这是一个软限制，在特殊的情况下 WAL 尺寸可能会超过<varname>max_wal_size</varname>，
        例如在重度负荷下、<varname>archive_command</varname>失败或者高的 <varname>wal_keep_size</varname>设置。
        如果指定值时没有单位，则以兆字节为单位。默认为 1 GB。增加这个参数可能导致崩溃恢复所需的时间。
        这个参数只能在<filename>postgresql.conf</filename> 或者服务器命令行中设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-min-wal-size" xreflabel="min_wal_size">
<!--==========================orignal english content==========================
      <term><varname>min_wal_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>min_wal_size</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>min_wal_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>min_wal_size</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        As long as WAL disk usage stays below this setting, old WAL files are
        always recycled for future use at a checkpoint, rather than removed.
        This can be used to ensure that enough WAL space is reserved to
        handle spikes in WAL usage, for example when running large batch
        jobs.
        If this value is specified without units, it is taken as megabytes.
        The default is 80 MB.
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        只要 WAL 磁盘用量保持在这个设置之下，在检查点时旧的 WAL 文件总是
        被回收以便未来使用，而不是直接被删除。这可以被用来确保有足够的
        WAL 空间被保留来应付 WAL 使用的高峰，例如运行大型的批处理任务。
        如果指定值时没有单位，则以兆字节为单位。默认是 80 MB。这个参数只能在<filename>postgresql.conf</filename>
        或者服务器命令行中设置。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
     </sect2>
     <sect2 id="runtime-config-wal-archiving">
<!--==========================orignal english content==========================
     <title>Archiving</title>
____________________________________________________________________________-->
     <title>归档</title>

    <variablelist>
     <varlistentry id="guc-archive-mode" xreflabel="archive_mode">
<!--==========================orignal english content==========================
      <term><varname>archive_mode</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>archive_mode</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>archive_mode</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>archive_mode</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        When <varname>archive_mode</varname> is enabled, completed WAL segments
        are sent to archive storage by setting
        <xref linkend="guc-archive-command"/>. In addition to <literal>off</literal>,
        to disable, there are two modes: <literal>on</literal>, and
        <literal>always</literal>. During normal operation, there is no
        difference between the two modes, but when set to <literal>always</literal>
        the WAL archiver is enabled also during archive recovery or standby
        mode. In <literal>always</literal> mode, all files restored from the archive
        or streamed with streaming replication will be archived (again). See
        <xref linkend="continuous-archiving-in-standby"/> for details.
       </para>
____________________________________________________________________________-->
       <para>
        当启用<varname>archive_mode</varname>时，可以通过设置
        <xref linkend="guc-archive-command"/>命令将完成的 WAL 段发送到
        归档存储。除用于禁用的<literal>off</literal>之外，还有两种模式：
        <literal>on</literal>和<literal>always</literal>。在普通操作期间，这两种模式之间
        没有区别，但是当设置为<literal>always</literal>时，WAL 归档器在归档恢复
        或者后备模式下也会被启用。在<literal>always</literal>模式下，所有从归档恢复
        的或者用流复制传来的文件将被（再次）归档。详见
        <xref linkend="continuous-archiving-in-standby"/>。
       </para>

<!--==========================orignal english content==========================
       <para>
        <varname>archive_mode</varname> and <varname>archive_command</varname> are
        separate variables so that <varname>archive_command</varname> can be
        changed without leaving archiving mode.
        This parameter can only be set at server start.
        <varname>archive_mode</varname> cannot be enabled when
        <varname>wal_level</varname> is set to <literal>minimal</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        <varname>archive_mode</varname>和<varname>archive_command</varname>是独立的变量，这样可以在不影响归档模式的前提下修改<varname>archive_command</varname>。这个参数只能在服务器启动时设置。当<varname>wal_level</varname>被设置为<literal>minimal</literal>时，<varname>archive_mode</varname>不能被启用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-archive-command" xreflabel="archive_command">
<!--==========================orignal english content==========================
      <term><varname>archive_command</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>archive_command</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>archive_command</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>archive_command</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The local shell command to execute to archive a completed WAL file
        segment.  Any <literal>%p</literal> in the string is
        replaced by the path name of the file to archive, and any
        <literal>%f</literal> is replaced by only the file name.
        (The path name is relative to the working directory of the server,
        i.e., the cluster's data directory.)
        Use <literal>%%</literal> to embed an actual <literal>%</literal> character in the
        command.  It is important for the command to return a zero
        exit status only if it succeeds. For more information see
        <xref linkend="backup-archiving-wal"/>.
       </para>
____________________________________________________________________________-->
       <para>
        本地 shell 命令被执行来归档一个完成的 WAL 文件段。字符串中的任何<literal>%p</literal>被替换成要被归档的文件的路径名， 而<literal>%f</literal>只被文件名替换（路径名是相对于服务器的工作目录， 即集簇的数据目录）。如果要在命令里嵌入一个真正的<literal>%</literal>字符，可以使用<literal>%%</literal>。有一点很重要，该命令只在成功时返回一个零作为退出状态。更多信息请见<xref linkend="backup-archiving-wal"/>。
       </para>

<!--==========================orignal english content==========================
       <para>
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.  It is ignored unless
        <varname>archive_mode</varname> was enabled at server start.
        If <varname>archive_command</varname> is an empty string (the default) while
        <varname>archive_mode</varname> is enabled, WAL archiving is temporarily
        disabled, but the server continues to accumulate WAL segment files in
        the expectation that a command will soon be provided.  Setting
        <varname>archive_command</varname> to a command that does nothing but
        return true, e.g., <literal>/bin/true</literal> (<literal>REM</literal> on
        Windows), effectively disables
        archiving, but also breaks the chain of WAL files needed for
        archive recovery, so it should only be used in unusual circumstances.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数只能在<filename>postgresql.conf</filename>文件中或在服务器命令行上设置。除非服务器启动时启用了<varname>archive_mode</varname>，否则它会被忽略。如果<varname>archive_mode</varname>被启用时，<varname>archive_command</varname>是一个空字符串（默认），WAL 归档会被临时禁用，但服务器仍会继续累计 WAL 段文件，期待着一个命令被提供。将<varname>archive_command</varname>设置为一个只返回真但不做任何事的命令（例如<literal>/bin/true</literal>或 Windows 上的<literal>REM</literal>）实际上会禁用归档，也会打破归档恢复所需的 WAL 文件链，因此只有在极少数情况下才能用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-archive-timeout" xreflabel="archive_timeout">
<!--==========================orignal english content==========================
      <term><varname>archive_timeout</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>archive_timeout</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>archive_timeout</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>archive_timeout</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The <xref linkend="guc-archive-command"/> is only invoked for
        completed WAL segments. Hence, if your server generates little WAL
        traffic (or has slack periods where it does so), there could be a
        long delay between the completion of a transaction and its safe
        recording in archive storage.  To limit how old unarchived
        data can be, you can set <varname>archive_timeout</varname> to force the
        server to switch to a new WAL segment file periodically.  When this
        parameter is greater than zero, the server will switch to a new
        segment file whenever this amount of time has elapsed since the last
        segment file switch, and there has been any database activity,
        including a single checkpoint (checkpoints are skipped if there is
        no database activity).  Note that archived files that are closed
        early due to a forced switch are still the same length as completely
        full files.  Therefore, it is unwise to use a very short
        <varname>archive_timeout</varname> &mdash; it will bloat your archive
        storage.  <varname>archive_timeout</varname> settings of a minute or so are
        usually reasonable.  You should consider using streaming replication,
        instead of archiving, if you want data to be copied off the primary
        server more quickly than that.
        If this value is specified without units, it is taken as seconds.
        This parameter can only be set in the
        <filename>postgresql.conf</filename> file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        <xref linkend="guc-archive-command"/>仅在已完成的 WAL 段上调用。因此，如果你的服务器只产生很少的 WAL 流量（或产生流量的周期很长），那么在事务完成和它被安全地记录到归档存储之间将有一个很长的延迟。为了限制未归档数据存在的时间，你可以设置<varname>archive_timeout</varname>来强制服务器来周期性地切换到一个新的 WAL 段文件。
        当这个参数被设置为大于零时，只要从上次段文件切换后过了参数所设置的时间量，并且已经有过任何数据库活动（包括一个单一检查点），服务器将切换到一个新的段文件（如果没有数据库活动则会跳过检查点）。
        注意，由于强制切换而提早关闭的被归档文件仍然与完整的归档文件长度相同。因此，使用非常短的<varname>archive_timeout</varname>是不明智的 &mdash; 它将占用巨大的归档存储。一分钟左右的<varname>archive_timeout</varname>设置通常比较合理。如果你希望数据能被更快地从主服务器上复制下来，你应该考虑使用流复制而不是归档。如果指定值时没有单位，则以秒为单位。这个参数只能在<filename>postgresql.conf</filename>文件中或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect2>

  <sect2 id="runtime-config-wal-archive-recovery">
<!--==========================orignal english content==========================
    <title>Archive Recovery</title>
____________________________________________________________________________-->
    <title>归档恢复</title>
<!--==========================orignal english content==========================
    <indexterm>
     <primary>configuration</primary>
     <secondary>of recovery</secondary>
     <tertiary>of a standby server</tertiary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>configuration</primary>
     <secondary>of recovery</secondary>
     <tertiary>of a standby server</tertiary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     This section describes the settings that apply only for the duration of
     the recovery.  They must be reset for any subsequent recovery you wish to
     perform.
    </para>
____________________________________________________________________________-->
    <para>
     本节描述了仅在恢复期间适用的设置。如果您希望执行任何后续恢复，则必须重置它们。
    </para>

<!--==========================orignal english content==========================
    <para>
     <quote>Recovery</quote> covers using the server as a standby or for
     executing a targeted recovery.  Typically, standby mode would be used to
     provide high availability and/or read scalability, whereas a targeted
     recovery is used to recover from data loss.
    </para>
____________________________________________________________________________-->
    <para>
     <quote>Recovery</quote> 涵盖使用服务器作为备用服务器或用于执行目标恢复。
     通常情况，备用模式用于提供高可用性和/或读可扩展性，而目标恢复用于从数据丢失中恢复。
    </para>

<!--==========================orignal english content==========================
    <para>
     To start the server in standby mode, create a file called
     <filename>standby.signal</filename><indexterm><primary>standby.signal</primary></indexterm>
     in the data directory.  The server will enter recovery and will not stop
     recovery when the end of archived WAL is reached, but will keep trying to
     continue recovery by connecting to the sending server as specified by the
     <varname>primary_conninfo</varname> setting and/or by fetching new WAL
     segments using <varname>restore_command</varname>.  For this mode, the
     parameters from this section and <xref
     linkend="runtime-config-replication-standby"/> are of interest.
     Parameters from <xref linkend="runtime-config-wal-recovery-target"/> will
     also be applied but are typically not useful in this mode.
    </para>
____________________________________________________________________________-->
    <para>
     若要在备用模式下启动服务器，在数据目录中建立名为<filename>standby.signal</filename><indexterm><primary>standby.signal</primary></indexterm>的文件。
     服务器将会进入恢复状态并且在到达归档WAL末尾时不会停止恢复，但将保持尝试继续恢复，通过连接到<varname>primary_conninfo</varname>设置指定的发送服务器和/或用<varname>restore_command</varname>获取新的WAL分段。
     对于这种模式，来自本节的参数和<xref linkend="runtime-config-replication-standby"/> 是值得关注的。
     <xref linkend="runtime-config-wal-recovery-target"/> 中的参数也会被应用，但通常在这种模式下没用。
    </para>

<!--==========================orignal english content==========================
    <para>
     To start the server in targeted recovery mode, create a file called
     <filename>recovery.signal</filename><indexterm><primary>recovery.signal</primary></indexterm>
     in the data directory.  If both <filename>standby.signal</filename> and
     <filename>recovery.signal</filename> files are created, standby mode
     takes precedence.  Targeted recovery mode ends when the archived WAL is
     fully replayed, or when <varname>recovery_target</varname> is reached.
     In this mode, the parameters from both this section and <xref
     linkend="runtime-config-wal-recovery-target"/> will be used.
    </para>
____________________________________________________________________________-->
    <para>
     要启动服务器为目标恢复模式，需在数据目录中建立名为<filename>recovery.signal</filename><indexterm><primary>recovery.signal</primary></indexterm>的文件。
     如果同时创建了<filename>standby.signal</filename> 和 <filename>recovery.signal</filename> 文件，则优先使用备用模式。
     目标恢复模式在归档的WAL全部回放或到达<varname>recovery_target</varname>时结束。
     在这种模式下，将使用来自本节和 <xref linkend="runtime-config-wal-recovery-target"/> 的参数。
    </para>

    <variablelist>
     <varlistentry id="guc-restore-command" xreflabel="restore_command">
<!--==========================orignal english content==========================
      <term><varname>restore_command</varname> (<type>string</type>)
      <indexterm>
        <primary><varname>restore_command</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>restore_command</varname> (<type>string</type>)
      <indexterm>
        <primary><varname>restore_command</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The local shell command to execute to retrieve an archived segment of
        the WAL file series. This parameter is required for archive recovery,
        but optional for streaming replication.
        Any <literal>%f</literal> in the string is
        replaced by the name of the file to retrieve from the archive,
        and any <literal>%p</literal> is replaced by the copy destination path name
        on the server.
        (The path name is relative to the current working directory,
        i.e., the cluster's data directory.)
        Any <literal>%r</literal> is replaced by the name of the file containing the
        last valid restart point. That is the earliest file that must be kept
        to allow a restore to be restartable, so this information can be used
        to truncate the archive to just the minimum required to support
        restarting from the current restore. <literal>%r</literal> is typically only
        used by warm-standby configurations
        (see <xref linkend="warm-standby"/>).
        Write <literal>%%</literal> to embed an actual <literal>%</literal> character.
       </para>
____________________________________________________________________________-->
       <para>
        用于获取 WAL 文件系列的一个已归档段的本地 shell 命令。这个参数是归档恢复所必需的，但是对于流复制是可选的。
        在该字符串中的任何<literal>%f</literal>会被替换为从归档中获得的文件的名字，并且任何<literal>%p</literal>会被在服务器上的复制目标路径名替换（该路径名是相对于当前工作目录的，即集簇的数据目录）。
        任何<literal>%r</literal>会被包含上一个可用重启点的文件的名字所替换。
        在那些必须被保留用于使得一次恢复变成可重启的文件中，这个文件是其中最早的一个，因此这个信息可以被用来把归档截断为支持从当前恢复重启所需的最小值。
        <literal>%r</literal>通常只被温备配置（见<xref linkend="warm-standby"/>）所使用。要嵌入一个真正的<literal>%</literal>字符，需要写成<literal>%%</literal>。
       </para>

<!--==========================orignal english content==========================
       <para>
        It is important for the command to return a zero exit status
        only if it succeeds.  The command <emphasis>will</emphasis> be asked for file
        names that are not present in the archive; it must return nonzero
        when so asked.  Examples:
<programlisting>
restore_command = 'cp /mnt/server/archivedir/%f "%p"'
restore_command = 'copy "C:\\server\\archivedir\\%f" "%p"'  # Windows
</programlisting>
        An exception is that if the command was terminated by a signal (other
        than <systemitem>SIGTERM</systemitem>, which is used as part of a
        database server shutdown) or an error by the shell (such as command
        not found), then recovery will abort and the server will not start up.
       </para>
____________________________________________________________________________-->
       <para>
        很重要的一点是，该命令只有在成功时才返回一个为零的退出状态。
        该命令<emphasis>将</emphasis>会被询问不存在于归档中的文件名，当这样被询问时它必须返回非零。例子：
<programlisting>
restore_command = 'cp /mnt/server/archivedir/%f "%p"'
restore_command = 'copy "C:\\server\\archivedir\\%f" "%p"'  # Windows
</programlisting>
        一个例外是如果该命令被一个信号（不是<systemitem>SIGTERM</systemitem>，它是数据库服务器关闭的一部分）或者一个 shell 错误（例如命令未找到）终止，则恢复将会中止并且服务器将不会启动。
       </para>

<!--==========================orignal english content==========================
       <para>
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数只能在<filename>postgresql.conf</filename>文件中或通过服务器命令行进行设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-archive-cleanup-command" xreflabel="archive_cleanup_command">
<!--==========================orignal english content==========================
      <term><varname>archive_cleanup_command</varname> (<type>string</type>)
      <indexterm>
        <primary><varname>archive_cleanup_command</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>archive_cleanup_command</varname> (<type>string</type>)
      <indexterm>
        <primary><varname>archive_cleanup_command</varname> 配置参数 </primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        This optional parameter specifies a shell command that will be executed
        at every restartpoint.  The purpose of
        <varname>archive_cleanup_command</varname> is to provide a mechanism for
        cleaning up old archived WAL files that are no longer needed by the
        standby server.
        Any <literal>%r</literal> is replaced by the name of the file containing the
        last valid restart point.
        That is the earliest file that must be <emphasis>kept</emphasis> to allow a
        restore to be restartable, and so all files earlier than <literal>%r</literal>
        may be safely removed.
        This information can be used to truncate the archive to just the
        minimum required to support restart from the current restore.
        The <xref linkend="pgarchivecleanup"/> module
        is often used in <varname>archive_cleanup_command</varname> for
        single-standby configurations, for example:
<programlisting>archive_cleanup_command = 'pg_archivecleanup /mnt/server/archivedir %r'</programlisting>
        Note however that if multiple standby servers are restoring from the
        same archive directory, you will need to ensure that you do not delete
        WAL files until they are no longer needed by any of the servers.
        <varname>archive_cleanup_command</varname> would typically be used in a
        warm-standby configuration (see <xref linkend="warm-standby"/>).
        Write <literal>%%</literal> to embed an actual <literal>%</literal> character in the
        command.
       </para>
____________________________________________________________________________-->
       <para>
        这个可选参数指定了一个 shell 命令，它将在每一个重启点被执行。
        <varname>archive_cleanup_command</varname>的目的是提供一种清除不再被后备服务器需要的旧的已归档 WAL 文件的机制。
        任何<literal>%r</literal>会被替换为包含最后一个可用重启点的文件的名称。
        那是使一次恢复变成可重启的所必须被<emphasis>保留</emphasis>的最早的文件，并且因此比<literal>%r</literal>更早的所有文件可以被安全地移除。
        这个信息可以被用来把归档截断为支持从当前恢复重启所需的最小值。
        对于单一后备配置，<xref linkend="pgarchivecleanup"/>模块常常被用在<varname>archive_cleanup_command</varname>中，例如：
<programlisting>archive_cleanup_command = 'pg_archivecleanup /mnt/server/archivedir %r'</programlisting>
        但是注意，如果多个后备服务器正在从同一个归档目录中恢复，你将需要保证只有当任意服务器都不再需要 WAL 文件时才会删除它们。
        <varname>archive_cleanup_command</varname>通常被用于一种温后备配置（见<xref linkend="warm-standby"/>）中。
        要在该命令中嵌入一个真正的<literal>%</literal>字符，需要写成<literal>%%</literal>。
       </para>

<!--==========================orignal english content==========================
       <para>
        If the command returns a nonzero exit status then a warning log
        message will be written.  An exception is that if the command was
        terminated by a signal or an error by the shell (such as command not
        found), a fatal error will be raised.
       </para>
____________________________________________________________________________-->
       <para>
        如果该命令返回一个非零退出状态，则将会写出一个警告日志消息。
        一个例外是如果该命令被一个信号或者一个 shell 错误（例如命令未找到）终止，则会抛出一个致命错误。
       </para>

<!--==========================orignal english content==========================
       <para>
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数只能在 <filename>postgresql.conf</filename> 文件中设置或通过服务器命令行的方式。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-recovery-end-command" xreflabel="recovery_end_command">
<!--==========================orignal english content==========================
      <term><varname>recovery_end_command</varname> (<type>string</type>)
      <indexterm>
        <primary><varname>recovery_end_command</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>recovery_end_command</varname> (<type>string</type>)
      <indexterm>
        <primary><varname>recovery_end_command</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        This parameter specifies a shell command that will be executed once only
        at the end of recovery. This parameter is optional. The purpose of the
        <varname>recovery_end_command</varname> is to provide a mechanism for cleanup
        following replication or recovery.
        Any <literal>%r</literal> is replaced by the name of the file containing the
        last valid restart point, like in <xref linkend="guc-archive-cleanup-command"/>.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数指定了一个将只在恢复末尾被执行一次的 shell 命令。这个参数是可选的。
        <varname>recovery_end_command</varname>的目的是为复制或恢复之后的清除提供一种机制。
        与<xref linkend="guc-archive-cleanup-command"/>中相似，任何<literal>%r</literal>会被替换为包含最后一个可用重启点的文件的名称。
       </para>

<!--==========================orignal english content==========================
       <para>
        If the command returns a nonzero exit status then a warning log
        message will be written and the database will proceed to start up
        anyway.  An exception is that if the command was terminated by a
        signal or an error by the shell (such as command not found), the
        database will not proceed with startup.
       </para>
____________________________________________________________________________-->
       <para>
        如果该命令返回一个非零退出状态，则一个警告日志消息将被写出并且不管怎样该数据库将继续启动。
        一个例外是如果该命令被一个信号或者 shell 错误（例如命令未找到）中止，该数据库将不会继续启动。
       </para>

<!--==========================orignal english content==========================
       <para>
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数只能在 <filename>postgresql.conf</filename> 文件中设置或通过服务器命令行的方式。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>

  </sect2>

  <sect2 id="runtime-config-wal-recovery-target">
<!--==========================orignal english content==========================
    <title>Recovery Target</title>
____________________________________________________________________________-->
    <title>恢复目标</title>
<!--==========================orignal english content==========================
     <para>
      By default, recovery will recover to the end of the WAL log. The
      following parameters can be used to specify an earlier stopping point.
      At most one of <varname>recovery_target</varname>,
      <varname>recovery_target_lsn</varname>, <varname>recovery_target_name</varname>,
      <varname>recovery_target_time</varname>, or <varname>recovery_target_xid</varname>
      can be used; if more than one of these is specified in the configuration
      file, an error will be raised.
      These parameters can only be set at server start.
     </para>
____________________________________________________________________________-->
     <para>
      默认情况下，恢复将会一直恢复到 WAL 日志的末尾。下面的参数可以被用来指定一个更早的停止点。
      在<varname>recovery_target</varname>、<varname>recovery_target_lsn</varname>、<varname>recovery_target_name</varname>、<varname>recovery_target_time</varname>和<varname>recovery_target_xid</varname>中，
      最多只能使用一个，如果在配置文件中使用了多个，将会产生一个错误。这个参数只能在服务器启动时设置。	  
     </para>

     <variablelist>
     <varlistentry id="guc-recovery-target" xreflabel="recovery_target">
<!--==========================orignal english content==========================
      <term><varname>recovery_target</varname><literal> = 'immediate'</literal>
      <indexterm>
        <primary><varname>recovery_target</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>recovery_target</varname><literal> = 'immediate'</literal>
      <indexterm>
        <primary><varname>recovery_target</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        This parameter specifies that recovery should end as soon as a
        consistent state is reached, i.e., as early as possible. When restoring
        from an online backup, this means the point where taking the backup
        ended.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数指定恢复应该在达到一个一致状态后尽快结束，即尽早结束。在从一个在线备份中恢复时，这意味着备份结束的那个点。
       </para>

<!--==========================orignal english content==========================
       <para>
        Technically, this is a string parameter, but <literal>'immediate'</literal>
        is currently the only allowed value.
       </para>
____________________________________________________________________________-->
       <para>
        在技术上，这是一个字符串参数，但是<literal>'immediate'</literal>是目前唯一允许的值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-recovery-target-name" xreflabel="recovery_target_name">
<!--==========================orignal english content==========================
      <term><varname>recovery_target_name</varname> (<type>string</type>)
      <indexterm>
        <primary><varname>recovery_target_name</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>recovery_target_name</varname> (<type>string</type>)
      <indexterm>
        <primary><varname>recovery_target_name</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        This parameter specifies the named restore point (created with
        <function>pg_create_restore_point()</function>) to which recovery will proceed.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数指定（<function>pg_create_restore_point()</function>所创建）的已命名的恢复点，恢复将进入该恢复点。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-recovery-target-time" xreflabel="recovery_target_time">
<!--==========================orignal english content==========================
      <term><varname>recovery_target_time</varname> (<type>timestamp</type>)
      <indexterm>
        <primary><varname>recovery_target_time</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>recovery_target_time</varname> (<type>timestamp</type>)
      <indexterm>
        <primary><varname>recovery_target_time</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        This parameter specifies the time stamp up to which recovery
        will proceed.
        The precise stopping point is also influenced by
        <xref linkend="guc-recovery-target-inclusive"/>.
       </para>
____________________________________________________________________________-->
       <para>
        此参数指定恢复将执行的时间戳。精确的停止点还受到<xref linkend="guc-recovery-target-inclusive"/>得影响。
       </para>

<!--==========================orignal english content==========================
       <para>
        The value of this parameter is a time stamp in the same format
        accepted by the <type>timestamp with time zone</type> data type,
        except that you cannot use a time zone abbreviation (unless the
        <xref linkend="guc-timezone-abbreviations"/> variable has been set
        earlier in the configuration file).  Preferred style is to use a
        numeric offset from UTC, or you can write a full time zone name,
        e.g., <literal>Europe/Helsinki</literal> not <literal>EEST</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        此参数的值是一个被<type>timestamp with time zone</type>数据类型接受的相同格式的时间戳，只不过你不能使用时区缩写（除非<xref linkend="guc-timezone-abbreviations"/>变量在配置文件中已提前设置）。 
        首选样式是使用 UTC 的数字偏移量，或者你可以写一个完整时区名称，例如 <literal>Europe/Helsinki</literal> 而不是 <literal>EEST</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-recovery-target-xid" xreflabel="recovery_target_xid">
<!--==========================orignal english content==========================
      <term><varname>recovery_target_xid</varname> (<type>string</type>)
      <indexterm>
        <primary><varname>recovery_target_xid</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>recovery_target_xid</varname> (<type>string</type>)
      <indexterm>
        <primary><varname>recovery_target_xid</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        This parameter specifies the transaction ID up to which recovery
        will proceed. Keep in mind
        that while transaction IDs are assigned sequentially at transaction
        start, transactions can complete in a different numeric order.
        The transactions that will be recovered are those that committed
        before (and optionally including) the specified one.
        The precise stopping point is also influenced by
        <xref linkend="guc-recovery-target-inclusive"/>.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数指定恢复将进入的事务 ID。记住虽然事务 ID 是在事务开始时顺序分配的，但是事务可能以不同的数字顺序完成。
        那些在指定事务之前（也可以包括该事务）提交的事务将被恢复。精确的停止点也受到<xref linkend="guc-recovery-target-inclusive"/>的影响。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-recovery-target-lsn" xreflabel="recovery_target_lsn">
<!--==========================orignal english content==========================
      <term><varname>recovery_target_lsn</varname> (<type>pg_lsn</type>)
      <indexterm>
        <primary><varname>recovery_target_lsn</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>recovery_target_lsn</varname> (<type>pg_lsn</type>)
      <indexterm>
        <primary><varname>recovery_target_lsn</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        This parameter specifies the LSN of the write-ahead log location up
        to which recovery will proceed. The precise stopping point is also
        influenced by <xref linkend="guc-recovery-target-inclusive"/>. This
        parameter is parsed using the system data type
        <link linkend="datatype-pg-lsn"><type>pg_lsn</type></link>.
       </para>
____________________________________________________________________________-->
       <para>
        此参数指定恢复将继续进行的预写日志位置的LSN。精确的停靠点也受 <xref linkend="guc-recovery-target-inclusive"/>的影响。
        使用系统数据类型<link linkend="datatype-pg-lsn"><type>pg_lsn</type></link>解析此参数。
       </para>
      </listitem>
     </varlistentry>
     </variablelist>

<!--==========================orignal english content==========================
     <para>
       The following options further specify the recovery target, and affect
       what happens when the target is reached:
     </para>
____________________________________________________________________________-->
     <para>
       下列选项进一步指定恢复目标，并且影响到达目标时会发生什么：
     </para>

     <variablelist>
     <varlistentry id="guc-recovery-target-inclusive"
                   xreflabel="recovery_target_inclusive">
<!--==========================orignal english content==========================
      <term><varname>recovery_target_inclusive</varname> (<type>boolean</type>)
      <indexterm>
        <primary><varname>recovery_target_inclusive</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>recovery_target_inclusive</varname> (<type>boolean</type>)
      <indexterm>
        <primary><varname>recovery_target_inclusive</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies whether to stop just after the specified recovery target
        (<literal>on</literal>), or just before the recovery target
        (<literal>off</literal>).
        Applies when <xref linkend="guc-recovery-target-lsn"/>,
        <xref linkend="guc-recovery-target-time"/>, or
        <xref linkend="guc-recovery-target-xid"/> is specified.
        This setting controls whether transactions
        having exactly the target WAL location (LSN), commit time, or transaction ID, respectively, will
        be included in the recovery.  Default is <literal>on</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        指定我们是否仅在指定的恢复目标之后停止（<literal>on</literal>），或者仅在恢复目标之前停止（<literal>off</literal>）。
        适用于<xref linkend="guc-recovery-target-lsn"/>、<xref linkend="guc-recovery-target-time"/>或者<xref linkend="guc-recovery-target-xid"/>被指定的情况。
        这个设置分别控制事务是否有准确的目标WAL位置(LSN)、提交时间或事务ID将被包括在该恢复中。默认值为<literal>on</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-recovery-target-timeline"
                   xreflabel="recovery_target_timeline">
<!--==========================orignal english content==========================
      <term><varname>recovery_target_timeline</varname> (<type>string</type>)
      <indexterm>
        <primary><varname>recovery_target_timeline</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>recovery_target_timeline</varname> (<type>string</type>)
      <indexterm>
        <primary><varname>recovery_target_timeline</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies recovering into a particular timeline.  The value can be a
        numeric timeline ID or a special value.  The value
        <literal>current</literal> recovers along the same timeline that was
        current when the base backup was taken.  The
        value <literal>latest</literal> recovers
        to the latest timeline found in the archive, which is useful in
        a standby server.  <literal>latest</literal> is the default.
       </para>
____________________________________________________________________________-->
       <para>
        指定恢复到一个特定的时间线中。该值可以是数字时间线 ID 或特殊值。
        值<literal>current</literal>沿着与执行基本备份时相同的时间线恢复。
        值<literal>latest</literal>将恢复到归档中能找到的最新的时间线，这在一个备用服务器中有用。<literal>latest</literal>是默认的。
       </para>

<!--==========================orignal english content==========================
       <para>
        You usually only need to set this parameter
        in complex re-recovery situations, where you need to return to
        a state that itself was reached after a point-in-time recovery.
        See <xref linkend="backup-timelines"/> for discussion.
       </para>
____________________________________________________________________________-->
       <para>
        你通常只需要在复杂的重恢复情况下设置这个参数，在这种情况下你需要返回到一个状态，该状态本身是在一次时间点恢复之后到达的。
        相关讨论见<xref linkend="backup-timelines"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-recovery-target-action"
                   xreflabel="recovery_target_action">
<!--==========================orignal english content==========================
      <term><varname>recovery_target_action</varname> (<type>enum</type>)
      <indexterm>
        <primary><varname>recovery_target_action</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>recovery_target_action</varname> (<type>enum</type>)
      <indexterm>
        <primary><varname>recovery_target_action</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies what action the server should take once the recovery target is
        reached. The default is <literal>pause</literal>, which means recovery will
        be paused. <literal>promote</literal> means the recovery process will finish
        and the server will start to accept connections.
        Finally <literal>shutdown</literal> will stop the server after reaching the
        recovery target.
       </para>
____________________________________________________________________________-->
       <para>
        指定在达到恢复目标时服务器应该立刻采取的动作。默认动作是<literal>pause</literal>，这表示恢复将会被暂停。
        <literal>promote</literal>表示恢复处理将会结束并且服务器将开始接受连接。
        最后，<literal>shutdown</literal>将在达到恢复目标之后停止服务器。
       </para>

<!--==========================orignal english content==========================
       <para>
        The intended use of the <literal>pause</literal> setting is to allow queries
        to be executed against the database to check if this recovery target
        is the most desirable point for recovery.
        The paused state can be resumed by
        using <function>pg_wal_replay_resume()</function> (see
        <xref linkend="functions-recovery-control-table"/>), which then
        causes recovery to end. If this recovery target is not the
        desired stopping point, then shut down the server, change the
        recovery target settings to a later target and restart to
        continue recovery.
       </para>
____________________________________________________________________________-->
       <para>
        使用<literal>pause</literal>设置的目的是：如果这个恢复目标就是恢复最想要的位置，就允许对数据库执行查询。
        暂停的状态可以使用<function>pg_wal_replay_resume()</function>（见<xref linkend="functions-recovery-control-table"/>）继续，这会让恢复终结。
        如果这个恢复目标不是想要的停止点，那么关闭服务器，将恢复目标设置改为一个稍后的目标并且重启以继续恢复。
       </para>

<!--==========================orignal english content==========================
       <para>
        The <literal>shutdown</literal> setting is useful to have the instance ready
        at the exact replay point desired.  The instance will still be able to
        replay more WAL records (and in fact will have to replay WAL records
        since the last checkpoint next time it is started).
       </para>
____________________________________________________________________________-->
       <para>
        要让实例在想要的重放点那里准备好，<literal>shutdown</literal>设置可以派上用场。
        该实例将仍能重放更多 WAL 记录（并且事实上将不得不重放从下一次它被启动后最后一个检查点以来的 WAL 记录）。
       </para>

<!--==========================orignal english content==========================
       <para>
        Note that because <filename>recovery.signal</filename> will not be
        removed when <varname>recovery_target_action</varname> is set to <literal>shutdown</literal>,
        any subsequent start will end with immediate shutdown unless the
        configuration is changed or the <filename>recovery.signal</filename>
        file is removed manually.
       </para>
____________________________________________________________________________-->
       <para>
        注意由于在<varname>recovery_target_action</varname>被设置为<literal>shutdown</literal>时，<filename>recovery.signal</filename>将不会被移除，
        任何后续的启动都将会以立刻关闭为终结，除非该配置被改变或者<filename>recovery.signal</filename>文件被手工移除。
       </para>

<!--==========================orignal english content==========================
       <para>
        This setting has no effect if no recovery target is set.
        If <xref linkend="guc-hot-standby"/> is not enabled, a setting of
        <literal>pause</literal> will act the same as <literal>shutdown</literal>.
        If the recovery target is reached while a promotion is ongoing,
        a setting of <literal>pause</literal> will act the same as
        <literal>promote</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        如果没有设置恢复目标，这个设置没有效果。
        如果没有启用<xref linkend="guc-hot-standby"/>，<literal>pause</literal>设置的动作将和<literal>shutdown</literal>一样。
        如果在升级期间达到恢复目标，<literal>pause</literal> 的设置将与 <literal>promote</literal>的行为相同。
       </para>
<!--==========================orignal english content==========================
       <para>
        In any case, if a recovery target is configured but the archive
        recovery ends before the target is reached, the server will shut down
        with a fatal error.
       </para>
____________________________________________________________________________-->
       <para>
        在任何情况下，如果已配置了恢复目标，但归档恢复在达到目标之前结束，则服务器将关闭，并出现致命错误。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </sect2>

   </sect1>

   <sect1 id="runtime-config-replication">
<!--==========================orignal english content==========================
    <title>Replication</title>
____________________________________________________________________________-->
    <title>复制</title>
<!--==========================orignal english content==========================
    <para>
     These settings control the behavior of the built-in
     <firstterm>streaming replication</firstterm> feature (see
     <xref linkend="streaming-replication"/>).  Servers will be either a
     primary or a standby server.  Primaries can send data, while standbys
     are always receivers of replicated data.  When cascading replication
     (see <xref linkend="cascading-replication"/>) is used, standby servers
     can also be senders, as well as receivers.
     Parameters are mainly for sending and standby servers, though some
     parameters have meaning only on the primary server.  Settings may vary
     across the cluster without problems if that is required.
    </para>
____________________________________________________________________________-->
    <para>
     这些设置控制内建<firstterm>流复制</firstterm>特性（见<xref linkend="streaming-replication"/>）的行为。服务器将可以是主控服务器或后备服务器。主控机能发送数据，而后备机总是被复制数据的接收者。当使用级联复制（见<xref linkend="cascading-replication"/>）时，后备服务器也可以是发送者，同时也是接收者。这些参数主要用于发送服务器和后备服务器，尽管某些只在主服务器上有意义。如果有必要，设置可以在集群中变化而不出问题。
    </para>

    <sect2 id="runtime-config-replication-sender">
<!--==========================orignal english content==========================
     <title>Sending Servers</title>
____________________________________________________________________________-->
     <title>发送服务器</title>
<!--==========================orignal english content==========================
     <para>
      These parameters can be set on any server that is
      to send replication data to one or more standby servers.
      The primary is always a sending server, so these parameters must
      always be set on the primary.
      The role and meaning of these parameters does not change after a
      standby becomes the primary.
     </para>
____________________________________________________________________________-->
     <para>
      这些参数可以在任何发送复制数据给一个或多个后备服务器的服务器上设置。主控机总是一个发送服务器，因此这些参数总是要在主控机上设置。这些参数的角色和含义不会在一个后备机变成主控机后改变。
     </para>

     <variablelist>
      <varlistentry id="guc-max-wal-senders" xreflabel="max_wal_senders">
<!--==========================orignal english content==========================
       <term><varname>max_wal_senders</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>max_wal_senders</varname> configuration parameter</primary>
       </indexterm>
       </term>
____________________________________________________________________________-->
       <term><varname>max_wal_senders</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>max_wal_senders</varname>配置参数</primary>
       </indexterm>
       </term>
       <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the maximum number of concurrent connections from standby
        servers or streaming base backup clients (i.e., the maximum number of
        simultaneously running WAL sender processes). The default is
        <literal>10</literal>.  The value <literal>0</literal> means
        replication is disabled.  Abrupt disconnection of a streaming client might
        leave an orphaned connection slot behind until a timeout is reached,
        so this parameter should be set slightly higher than the maximum
        number of expected clients so disconnected clients can immediately
        reconnect.  This parameter can only be set at server start.  Also,
        <varname>wal_level</varname> must be set to
        <literal>replica</literal> or higher to allow connections from standby
        servers.
       </para>
____________________________________________________________________________-->
       <para>
        指定来自后备服务器或流式基础备份客户端的并发连接的最大数量（即同时运行 WAL 发送进程的最大数）。
        默认值是<literal>10</literal>。值<literal>0</literal>意味着禁用复制。
        突然的流客户端断开连接可能留下一个孤立连接槽（知道达到超时），因此这个参数应该设置得略高于最大客户端连接数，这样断开连接的客户端可以立刻重新连接。
        这个参数只能在服务器启动时被设置。此外，<varname>wal_level</varname>必须设置为<literal>replica</literal>或更高级别以允许来自后备服务器的连接。
       </para>

<!--==========================orignal english content==========================
       <para>
         When running a standby server, you must set this parameter to the
         same or higher value than on the primary server. Otherwise, queries
         will not be allowed in the standby server.
        </para>
____________________________________________________________________________-->
       <para>
         当运行备用服务器时，你必须将此参数设置为与主服务器上相同的或更高的值。否则，备用服务器中将不允许查询。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-max-replication-slots" xreflabel="max_replication_slots">
<!--==========================orignal english content==========================
       <term><varname>max_replication_slots</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>max_replication_slots</varname> configuration parameter</primary>
       </indexterm>
       </term>
____________________________________________________________________________-->
       <term><varname>max_replication_slots</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>max_replication_slots</varname>配置参数</primary>
       </indexterm>
       </term>
       <listitem>
<!--==========================orignal english content==========================
        <para>
         Specifies the maximum number of replication slots
         (see <xref linkend="streaming-replication-slots"/>) that the server
         can support. The default is 10.  This parameter can only be set at
         server start.
         Setting it to a lower value than the number of currently
         existing replication slots will prevent the server from starting.
         Also, <varname>wal_level</varname> must be set
         to <literal>replica</literal> or higher to allow replication slots to
         be used.
        </para>
____________________________________________________________________________-->
        <para>
         指定服务器可以支持的复制槽（见<xref linkend="streaming-replication-slots"/>）
         最大数量。默认值为10。这个参数只能在服务器启动时设置。将它设置为一个比当前已有复制槽要少的值会阻碍服务器启动。此外，要允许使用复制槽，
         <varname>wal_level</varname>必须被设置为<literal>replica</literal>或
         更高。
        </para>

<!--==========================orignal english content==========================
        <para>
         On the subscriber side, specifies how many replication origins (see
         <xref linkend="replication-origins"/>) can be tracked simultaneously,
         effectively limiting how many logical replication subscriptions can
         be created on the server. Setting it to a lower value than the current
         number of tracked replication origins (reflected in
         <link linkend="view-pg-replication-origin-status">pg_replication_origin_status</link>,
         not <link linkend="catalog-pg-replication-origin">pg_replication_origin</link>)
         will prevent the server from starting.
        </para>
____________________________________________________________________________-->
        <para>
         在订阅端，指定多少复制源头 (参见 <xref linkend="replication-origins"/>) 可以被同时跟踪，有效的限制了服务器上可以建立多少逻辑复制订阅。
         设置它到一个低与当前跟踪复制源(体现在<link linkend="view-pg-replication-origin-status">pg_replication_origin_status</link>,不是 <link linkend="catalog-pg-replication-origin">pg_replication_origin</link>)的值将阻止服务器启动。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-wal-keep-size" xreflabel="wal_keep_size">
<!--==========================orignal english content==========================
       <term><varname>wal_keep_size</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>wal_keep_size</varname> configuration parameter</primary>
       </indexterm>
       </term>
____________________________________________________________________________-->
       <term><varname>wal_keep_size</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>wal_keep_size</varname> 配置参数</primary>
       </indexterm>
       </term>
       <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the minimum size of past log file segments kept in the
        <filename>pg_wal</filename>
        directory, in case a standby server needs to fetch them for streaming
        replication. If a standby
        server connected to the sending server falls behind by more than
        <varname>wal_keep_size</varname> megabytes, the sending server might
        remove a WAL segment still needed by the standby, in which case the
        replication connection will be terminated.  Downstream connections
        will also eventually fail as a result.  (However, the standby
        server can recover by fetching the segment from archive, if WAL
        archiving is in use.)
       </para>
____________________________________________________________________________-->
       <para>
        指定在后备服务器需要为流复制获取日志段文件的情况下，<filename>pg_wal</filename>目录下所能保留的过去日志文件段的最小尺寸。
        如果一个连接到发送服务器的后备服务器落后了超过<varname>wal_keep_size</varname>兆字节，发送服务器可以移除一个后备机仍然需要的 WAL 段，在这种情况下复制连接将被中断。
        最终结果是下行连接也将最终失败（不过，如果在使用 WAL 归档，后备服务器可以通过从归档获取段来恢复）。
       </para>

<!--==========================orignal english content==========================
       <para>
        This sets only the minimum size of segments retained in
        <filename>pg_wal</filename>; the system might need to retain more segments
        for WAL archival or to recover from a checkpoint. If
        <varname>wal_keep_size</varname> is zero (the default), the system
        doesn't keep any extra segments for standby purposes, so the number
        of old WAL segments available to standby servers is a function of
        the location of the previous checkpoint and status of WAL
        archiving.
        If this value is specified without units, it is taken as megabytes.
        This parameter can only be set in the
        <filename>postgresql.conf</filename> file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        只设置<filename>pg_wal</filename>中保留的文件段的最小尺寸；系统可能需要为 WAL 归档或从一个检查点恢复保留更多段。
        如果<varname>wal_keep_size</varname>为零（默认值）， 更多的空间来 存放WAL归档或从一个检查点恢复。
        如果wal_keep_segments是零（缺省）， 系统不会为后备目的保留任何多余的段，因此后备服务器可用的旧 WAL 段的数量是一个上个检查点位置和 WAL 归档状态的函数。
        如果此值被指定时没有单位，则视为兆字节。这个参数只能在<filename>postgresql.conf</filename>文件中或在服务器命令行上设置。
       </para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-max-slot-wal-keep-size" xreflabel="max_slot_wal_keep_size">
<!--==========================orignal english content==========================
       <term><varname>max_slot_wal_keep_size</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>max_slot_wal_keep_size</varname> configuration parameter</primary>
       </indexterm>
       </term>
____________________________________________________________________________-->
       <term><varname>max_slot_wal_keep_size</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>max_slot_wal_keep_size</varname> 配置参数</primary>
       </indexterm>
       </term>
       <listitem>
<!--==========================orignal english content==========================
       <para>
        Specify the maximum size of WAL files
        that <link linkend="streaming-replication-slots">replication
        slots</link> are allowed to retain in the <filename>pg_wal</filename>
        directory at checkpoint time.
        If <varname>max_slot_wal_keep_size</varname> is -1 (the default),
        replication slots may retain an unlimited amount of WAL files.  Otherwise, if
        restart_lsn of a replication slot falls behind the current LSN by more
        than the given size, the standby using the slot may no longer be able
        to continue replication due to removal of required WAL files. You
        can see the WAL availability of replication slots
        in <link linkend="view-pg-replication-slots">pg_replication_slots</link>.
       </para>
____________________________________________________________________________-->
       <para>
        指定<link linkend="streaming-replication-slots">replication slots</link> 所允许的在检查点时保留在 <filename>pg_wal</filename> 目录中的 WAL 文件的最大尺寸。
        如果<varname>max_slot_wal_keep_size</varname> 为 -1（默认值），复制槽可能会保留无限数量的 WAL 文件。 
        否则，如果复制槽的restart_lsn比当前LSN滞后超过给定的大小，由于删除了所需的WAL文件，使用插槽的备用服务器可能无法继续复制。
        你可以在<link linkend="view-pg-replication-slots">pg_replication_slots</link>中查看复制槽有效的WAL。
       </para>
       </listitem>
      </varlistentry>

     <varlistentry id="guc-wal-sender-timeout" xreflabel="wal_sender_timeout">
<!--==========================orignal english content==========================
      <term><varname>wal_sender_timeout</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>wal_sender_timeout</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>wal_sender_timeout</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>wal_sender_timeout</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Terminate replication connections that are inactive for longer
        than this amount of time. This is useful for
        the sending server to detect a standby crash or network outage.
        If this value is specified without units, it is taken as milliseconds.
        The default value is 60 seconds.
        A value of zero disables the timeout mechanism.
       </para>
____________________________________________________________________________-->
       <para>
        中断那些停止活动超过这个时间量的复制连接。这对发送服务器检测一个费用服务器崩溃或网络中断有用。
        如果指定值时没有单位，则以毫秒为单位。默认值是 60 秒。值0将禁用超时机制。
       </para>

<!--==========================orignal english content==========================
       <para>
        With a cluster distributed across multiple geographic
        locations, using different values per location brings more flexibility
        in the cluster management. A smaller value is useful for faster
        failure detection with a standby having a low-latency network
        connection, and a larger value helps in judging better the health
        of a standby if located on a remote location, with a high-latency
        network connection.
       </para>
____________________________________________________________________________-->
       <para>
        对于跨越多个地理位置分布的集群，每个位置使用不同的值可以为集群管理带来更大的灵活性。
        对于具有低延迟网络连接的备用服务器，较小的值有助于更快的故障检测;
        对于位于远端位置的具有高延迟网络连接的备用服务器，较大的值有助于更好地判断备用服务器的健康状况。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-track-commit-timestamp" xreflabel="track_commit_timestamp">
<!--==========================orignal english content==========================
      <term><varname>track_commit_timestamp</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>track_commit_timestamp</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>track_commit_timestamp</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>track_commit_timestamp</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Record commit time of transactions. This parameter
        can only be set in <filename>postgresql.conf</filename> file or on the server
        command line. The default value is <literal>off</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        记录事务的提交时间。这个参数只能在<filename>postgresql.conf</filename>
        文件中或在服务器命令行上设置。默认值是<literal>off</literal>。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect2>

    <sect2 id="runtime-config-replication-primary">
<!--==========================orignal english content==========================
     <title>Primary Server</title>
____________________________________________________________________________-->
     <title>主服务器</title>
<!--==========================orignal english content==========================
     <para>
      These parameters can be set on the primary server that is
      to send replication data to one or more standby servers.
      Note that in addition to these parameters,
      <xref linkend="guc-wal-level"/> must be set appropriately on the primary
      server, and optionally WAL archiving can be enabled as
      well (see <xref linkend="runtime-config-wal-archiving"/>).
      The values of these parameters on standby servers are irrelevant,
      although you may wish to set them there in preparation for the
      possibility of a standby becoming the primary.
     </para>
____________________________________________________________________________-->
     <para>
      这些参数可以在发送复制数据给一个或多个后备服务器的主控/主要服务器上设置。注意除了这些参数之外，在主控服务器上必须设置合适的<xref linkend="guc-wal-level"/>，并且也启用可选的 WAL 归档（见<xref linkend="runtime-config-wal-archiving"/>）。这些参数值与后备服务器无关，尽管你可能希望为了准备好一个后备机转变成主控机来设置这些参数。
     </para>

    <variablelist>

     <varlistentry id="guc-synchronous-standby-names" xreflabel="synchronous_standby_names">
<!--==========================orignal english content==========================
      <term><varname>synchronous_standby_names</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>synchronous_standby_names</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>synchronous_standby_names</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>synchronous_standby_names</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies a list of standby servers that can support
        <firstterm>synchronous replication</firstterm>, as described in
        <xref linkend="synchronous-replication"/>.
        There will be one or more active synchronous standbys;
        transactions waiting for commit will be allowed to proceed after
        these standby servers confirm receipt of their data.
        The synchronous standbys will be those whose names appear
        in this list, and
        that are both currently connected and streaming data in real-time
        (as shown by a state of <literal>streaming</literal> in the
        <link linkend="monitoring-pg-stat-replication-view">
        <structname>pg_stat_replication</structname></link> view).
        Specifying more than one synchronous standby can allow for very high
        availability and protection against data loss.
       </para>
____________________________________________________________________________-->
       <para>
        如<xref linkend="synchronous-replication"/>所述，这个参数指定一个支持<firstterm>同步复制</firstterm>的后备服务器的列表。
        可能会有一个或者多个活动的同步后备服务器，在这些后备服务器确认收到它们的数据之后，等待提交的事务将被允许继续下去。
        同步后备服务器是那些名字出现在这个列表前面，并且当前已连接并且正在实时流传输数据（如<link linkend="monitoring-pg-stat-replication-view"><structname>pg_stat_replication</structname></link>视图中<literal>streaming</literal>的状态所示）的服务器。
        指定多于一台同步后备可以得到非常高的可用性并且能防止数据丢失。
       </para>

<!--==========================orignal english content==========================
       <para>
        The name of a standby server for this purpose is the
        <varname>application_name</varname> setting of the standby, as set in the
        standby's connection information.  In case of a physical replication
        standby, this should be set in the <varname>primary_conninfo</varname>
        setting; the default is the setting of <xref linkend="guc-cluster-name"/>
        if set, else <literal>walreceiver</literal>.
        For logical replication, this can be set in the connection
        information of the subscription, and it defaults to the
        subscription name.  For other replication stream consumers,
        consult their documentation.
       </para>
____________________________________________________________________________-->
       <para>
        用于这一目的的后备服务器的名称是其<varname>application_name</varname>设置，它在后备服务器的连接信息中设置。
        在物理复制后备的情况下，这应该被设置在<varname>primary_conninfo</varname>设置中，如果设置了，默认是<xref linkend="guc-cluster-name"/>的设置，否则为 <literal>walreceiver</literal>。
        对于逻辑复制，可以在订阅的连接信息中设置。对于其他复制流消费者，请参考其文档。
       </para>

<!--==========================orignal english content==========================
       <para>
        This parameter specifies a list of standby servers using
        either of the following syntaxes:
<synopsis>
[FIRST] <replaceable class="parameter">num_sync</replaceable> ( <replaceable class="parameter">standby_name</replaceable> [, ...] )
ANY <replaceable class="parameter">num_sync</replaceable> ( <replaceable class="parameter">standby_name</replaceable> [, ...] )
<replaceable class="parameter">standby_name</replaceable> [, ...]
</synopsis>
        where <replaceable class="parameter">num_sync</replaceable> is
        the number of synchronous standbys that transactions need to
        wait for replies from,
        and <replaceable class="parameter">standby_name</replaceable>
        is the name of a standby server.
        <literal>FIRST</literal> and <literal>ANY</literal> specify the method to choose
        synchronous standbys from the listed servers.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数使用下面的语法之一来指定一个后备服务器列表：
<synopsis>
[FIRST] <replaceable class="parameter">num_sync</replaceable> ( <replaceable class="parameter">standby_name</replaceable> [, ...] )
ANY <replaceable class="parameter">num_sync</replaceable> ( <replaceable class="parameter">standby_name</replaceable> [, ...] )
<replaceable class="parameter">standby_name</replaceable> [, ...]
</synopsis>
        其中<replaceable class="parameter">num_sync</replaceable>是事务需要等待其回复的同步后备服务器的数量，<replaceable class="parameter">standby_name</replaceable>是一个后备服务器的名称。<literal>FIRST</literal>以及<literal>ANY</literal>指定从所列服务器中选取同步后备的方法。
        </para>

<!--==========================orignal english content==========================
       <para>
        The keyword <literal>FIRST</literal>, coupled with
        <replaceable class="parameter">num_sync</replaceable>, specifies a
        priority-based synchronous replication and makes transaction commits
        wait until their WAL records are replicated to
        <replaceable class="parameter">num_sync</replaceable> synchronous
        standbys chosen based on their priorities. For example, a setting of
        <literal>FIRST 3 (s1, s2, s3, s4)</literal> will cause each commit to wait for
        replies from three higher-priority standbys chosen from standby servers
        <literal>s1</literal>, <literal>s2</literal>, <literal>s3</literal> and <literal>s4</literal>.
        The standbys whose names appear earlier in the list are given higher
        priority and will be considered as synchronous. Other standby servers
        appearing later in this list represent potential synchronous standbys.
        If any of the current synchronous standbys disconnects for whatever
        reason, it will be replaced immediately with the next-highest-priority
        standby. The keyword <literal>FIRST</literal> is optional.
       </para>
____________________________________________________________________________-->
       <para>
        关键词<literal>FIRST</literal>加上<replaceable class="parameter">num_sync</replaceable>指定一种基于优先的同步复制，并且会让事务提交等待，直到它们的WAL记录被复制到基于优先级选择的<replaceable class="parameter">num_sync</replaceable>台同步后备上为止。例如，设置<literal>FIRST 3 (s1, s2, s3, s4)</literal>将导致每次提交都等待来自三台较高优先级的后备机的答复，这三台后备机将从后备服务器<literal>s1</literal>、<literal>s2</literal>、<literal>s3</literal>以及<literal>s4</literal>中选出。在该列表中出现较早的后备服务器将被给予较高的优先级，并且将被考虑为同步后备。列表中出现的其他后备服务器表示潜在的同步后备。如果当前的任何同步后备因为某种原因断开连接，它将立刻被下一个最高优先级的后备服务器替代。关键词<literal>FIRST</literal>是可选的。
       </para>

<!--==========================orignal english content==========================
       <para>
        The keyword <literal>ANY</literal>, coupled with
        <replaceable class="parameter">num_sync</replaceable>, specifies a
        quorum-based synchronous replication and makes transaction commits
        wait until their WAL records are replicated to <emphasis>at least</emphasis>
        <replaceable class="parameter">num_sync</replaceable> listed standbys.
        For example, a setting of <literal>ANY 3 (s1, s2, s3, s4)</literal> will cause
        each commit to proceed as soon as at least any three standbys of
        <literal>s1</literal>, <literal>s2</literal>, <literal>s3</literal> and <literal>s4</literal>
        reply.
       </para>
____________________________________________________________________________-->
       <para>
        关键词<literal>ANY</literal>加上<replaceable class="parameter">num_sync</replaceable>指定一种基于规定数量的同步复制，并且会让事务提交等待，直到它们的WAL记录被复制到所列出后备服务器中的<emphasis>至少</emphasis><replaceable class="parameter">num_sync</replaceable>台上为止。例如，设置<literal>ANY 3 (s1, s2, s3, s4)</literal>将导致每次提交会在收到<literal>s1</literal>、<literal>s2</literal>、<literal>s3</literal>以及<literal>s4</literal>中任意三台后备服务器的回答后立刻继续下去。
       </para>

<!--==========================orignal english content==========================
       <para>
        <literal>FIRST</literal> and <literal>ANY</literal> are case-insensitive. If these
        keywords are used as the name of a standby server,
        its <replaceable class="parameter">standby_name</replaceable> must
        be double-quoted.
       </para>
____________________________________________________________________________-->
       <para>
        <literal>FIRST</literal>和<literal>ANY</literal>是大小写不敏感的。如果这些关键词被用作后备服务器的名字，其<replaceable class="parameter">standby_name</replaceable>必须被放在双引号内。
       </para>

<!--==========================orignal english content==========================
       <para>
        The third syntax was used before <productname>PostgreSQL</productname>
        version 9.6 and is still supported. It's the same as the first syntax
        with <literal>FIRST</literal> and
        <replaceable class="parameter">num_sync</replaceable> equal to 1.
        For example, <literal>FIRST 1 (s1, s2)</literal> and <literal>s1, s2</literal> have
        the same meaning: either <literal>s1</literal> or <literal>s2</literal> is chosen
        as a synchronous standby.
       </para>
____________________________________________________________________________-->
       <para>
        <productname>PostgreSQL</productname>版本 9.6 之前使用过第三种语法，目前也仍然支持。它和<literal>FIRST</literal>和<replaceable class="parameter">num_sync</replaceable>等于1的第一种语法相同。例如，<literal>FIRST 1 (s1, s2)</literal>和<literal>s1, s2</literal>具有相同的含义：<literal>s1</literal>或者<literal>s2</literal>会被选中作为同步后备服务器。
       </para>

<!--==========================orignal english content==========================
       <para>
        The special entry <literal>*</literal> matches any standby name.
       </para>
____________________________________________________________________________-->
       <para>
        特殊项<literal>*</literal>匹配任意后备名称。
       </para>

<!--==========================orignal english content==========================
       <para>
        There is no mechanism to enforce uniqueness of standby names.  In case
        of duplicates one of the matching standbys will be considered as
        higher priority, though exactly which one is indeterminate.
       </para>
____________________________________________________________________________-->
       <para>
        没有机制强制后备服务器名称的唯一性。在出现重复的情况下，匹配的后备之一将被认为是较高优先级，不过无法弄清到底是哪一个。
       </para>
       <note>
<!--==========================orignal english content==========================
        <para>
         Each <replaceable class="parameter">standby_name</replaceable>
         should have the form of a valid SQL identifier, unless it
         is <literal>*</literal>.  You can use double-quoting if necessary.  But note
         that <replaceable class="parameter">standby_name</replaceable>s are
         compared to standby application names case-insensitively, whether
         double-quoted or not.
        </para>
____________________________________________________________________________-->
        <para>
         每一个<replaceable class="parameter">standby_name</replaceable>都应该具有合法 SQL 标识符的形式，除非它是<literal>*</literal>。如果必要你可以使用双引号。但是注意在比较<replaceable class="parameter">standby_name</replaceable>和后备机应用程序名称时是大小写不敏感的（不管有没有双引号）。
        </para>
       </note>
<!--==========================orignal english content==========================
       <para>
        If no synchronous standby names are specified here, then synchronous
        replication is not enabled and transaction commits will not wait for
        replication.  This is the default configuration.  Even when
        synchronous replication is enabled, individual transactions can be
        configured not to wait for replication by setting the
        <xref linkend="guc-synchronous-commit"/> parameter to
        <literal>local</literal> or <literal>off</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        如果这里没有指定同步后备机名称，那么同步复制不能被启用并且事务提交将不会等待复制。这是默认的配置。即便当同步复制被启用时，个体事务也可以被配置为不等待复制，做法是将<xref linkend="guc-synchronous-commit"/>参数设置为<literal>local</literal>或<literal>off</literal>。
       </para>

<!--==========================orignal english content==========================
       <para>
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数只能在<filename>postgresql.conf</filename>文件中或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-vacuum-defer-cleanup-age" xreflabel="vacuum_defer_cleanup_age">
<!--==========================orignal english content==========================
      <term><varname>vacuum_defer_cleanup_age</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>vacuum_defer_cleanup_age</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>vacuum_defer_cleanup_age</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>vacuum_defer_cleanup_age</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the number of transactions by which <command>VACUUM</command> and
        <acronym>HOT</acronym> updates will defer cleanup of dead row versions. The
        default is zero transactions, meaning that dead row versions can be
        removed as soon as possible, that is, as soon as they are no longer
        visible to any open transaction.  You may wish to set this to a
        non-zero value on a primary server that is supporting hot standby
        servers, as described in <xref linkend="hot-standby"/>.  This allows
        more time for queries on the standby to complete without incurring
        conflicts due to early cleanup of rows.  However, since the value
        is measured in terms of number of write transactions occurring on the
        primary server, it is difficult to predict just how much additional
        grace time will be made available to standby queries.
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        指定<command>VACUUM</command>和<acronym>HOT</acronym>更新在清除死亡行版本之前，应该推迟多久（以事务数量计）。默认值是零个事务，表示死亡行版本将被尽可能快地清除，即当它们不再对任何打开的事务可见时尽快清除。在一个支持热后备服务器的主服务器上，你可能希望把这个参数设置为一个非零值，如<xref linkend="hot-standby"/>中所述。这允许后备机上的查询有更多时间来完成而不会由于先前的行清除产生冲突。但是，由于该值是用在主服务器上发生的写事务的数目衡量的，很难预测对后备机查询可用的附加时间到底是多少。这个参数只能在<filename>postgresql.conf</filename>文件中或在服务器命令行上设置。
       </para>

<!--==========================orignal english content==========================
       <para>
        You should also consider setting <varname>hot_standby_feedback</varname>
        on standby server(s) as an alternative to using this parameter.
       </para>
____________________________________________________________________________-->
       <para>
        你也可以考虑设置后备服务器上的<varname>hot_standby_feedback</varname>作为使用这个参数的一种替代方案。
       </para>

<!--==========================orignal english content==========================
       <para>
        This does not prevent cleanup of dead rows which have reached the age
        specified by <varname>old_snapshot_threshold</varname>.
       </para>
____________________________________________________________________________-->
       <para>
        这无法阻止已经达到<varname>old_snapshot_threshold</varname>所指定年龄的死亡行被清除。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect2>

    <sect2 id="runtime-config-replication-standby">
<!--==========================orignal english content==========================
     <title>Standby Servers</title>
____________________________________________________________________________-->
     <title>后备服务器</title>
<!--==========================orignal english content==========================
     <para>
      These settings control the behavior of a
      <link linkend="standby-server-operation">standby server</link>
      that is
      to receive replication data.  Their values on the primary server
      are irrelevant.
     </para>
____________________________________________________________________________-->
     <para>
      这些设置控制一个<link linkend="standby-server-operation">standby server</link>接收复制数据的行为。
      它们在主服务器的值是无关的。
     </para>

    <variablelist>

       <varlistentry id="guc-primary-conninfo" xreflabel="primary_conninfo">
<!--==========================orignal english content==========================
        <term><varname>primary_conninfo</varname> (<type>string</type>)
        <indexterm>
          <primary><varname>primary_conninfo</varname> configuration parameter</primary>
        </indexterm>
        </term>
____________________________________________________________________________-->
        <term><varname>primary_conninfo</varname> (<type>string</type>)
        <indexterm>
          <primary><varname>primary_conninfo</varname> 配置参数</primary>
        </indexterm>
        </term>
        <listitem>
<!--==========================orignal english content==========================
         <para>
          Specifies a connection string to be used for the standby server
          to connect with a sending server. This string is in the format
          described in <xref linkend="libpq-connstring"/>. If any option is
          unspecified in this string, then the corresponding environment
          variable (see <xref linkend="libpq-envars"/>) is checked. If the
          environment variable is not set either, then
          defaults are used.
         </para>
____________________________________________________________________________-->
         <para>
          指定备用服务器用来连接发送服务器的连接字符串。这个字符串的格式在<xref linkend="libpq-connstring"/>中描述。
          如果在这个字符串中有任何选项未被指定，那么将检查相应的环境变量（见<xref linkend="libpq-envars"/>）。
          如果环境变量也没有被设置，则使用默认值。
         </para>

<!--==========================orignal english content==========================
         <para>
          The connection string should specify the host name (or address)
          of the sending server, as well as the port number if it is not
          the same as the standby server's default.
          Also specify a user name corresponding to a suitably-privileged role
          on the sending server (see
          <xref linkend="streaming-replication-authentication"/>).
          A password needs to be provided too, if the sender demands password
          authentication.  It can be provided in the
          <varname>primary_conninfo</varname> string, or in a separate
          <filename>~/.pgpass</filename> file on the standby server (use
          <literal>replication</literal> as the database name).
          Do not specify a database name in the
          <varname>primary_conninfo</varname> string.
         </para>
____________________________________________________________________________-->
         <para>
          连接字符串应当指定发送服务器的主机名（或地址），以及端口号（如果它和备用服务器的默认端口不同）。
          还要指定对应于发送服务器上合适权限角色的用户名（见<xref linkend="streaming-replication-authentication"/>）。
          如果发送服务器要求口令认证，还需要提供一个口令。它可以在<varname>primary_conninfo</varname>字符串中提供，或者在后备服务器（使用<literal>replication</literal>作为数据库名）的一个单独<filename>~/.pgpass</filename>文件中提供。
          不要在<varname>primary_conninfo</varname>字符串中指定一个数据库名。
         </para>

<!--==========================orignal english content==========================
         <para>
          This parameter can only be set in the <filename>postgresql.conf</filename>
          file or on the server command line.
          If this parameter is changed while the WAL receiver process is
          running, that process is signaled to shut down and expected to
          restart with the new setting (except if <varname>primary_conninfo</varname>
          is an empty string).
          This setting has no effect if the server is not in standby mode.
         </para>
____________________________________________________________________________-->
         <para>
          这个参数只能在 <filename>postgresql.conf</filename>文件或服务器命令行上设置。
          如果在 WAL 接收器进程运行时更改此参数，则该进程将发出关机信号，并预期使用新设置重新启动（除非<varname>primary_conninfo</varname>为空字符串）。
          如果服务器没有处于备用模式，则此设置无效。
         </para>
        </listitem>
       </varlistentry>
       <varlistentry id="guc-primary-slot-name" xreflabel="primary_slot_name">
<!--==========================orignal english content==========================
        <term><varname>primary_slot_name</varname> (<type>string</type>)
        <indexterm>
          <primary><varname>primary_slot_name</varname> configuration parameter</primary>
        </indexterm>
        </term>
____________________________________________________________________________-->
        <term><varname>primary_slot_name</varname> (<type>string</type>)
        <indexterm>
          <primary><varname>primary_slot_name</varname> 配置参数</primary>
        </indexterm>
        </term>
        <listitem>
<!--==========================orignal english content==========================
         <para>
          Optionally specifies an existing replication slot to be used when
          connecting to the sending server via streaming replication to control
          resource removal on the upstream node
          (see <xref linkend="streaming-replication-slots"/>).
          This parameter can only be set in the <filename>postgresql.conf</filename>
          file or on the server command line.
          If this parameter is changed while the WAL receiver process is running,
          that process is signaled to shut down and expected to restart with the
          new setting.
          This setting has no effect if <varname>primary_conninfo</varname> is not
          set or the server is not in standby mode.
         </para>
____________________________________________________________________________-->
         <para>
          有选择地指定通过流复制连接到发送服务器时使用一个现有的复制槽来控制上游节点上的资源移除（见<xref linkend="streaming-replication-slots"/>）。
          这个参数只能在 <filename>postgresql.conf</filename>文件或服务器命令行上设置。
          如果在 WAL 接收器进程运行时更改此参数，则该进程将发出关机信号，并预期使用新设置重新启动（除非<varname>primary_conninfo</varname>为空字符串）。
          如果没有设置<varname>primary_conninfo</varname>或服务器没有处于备用模式，则此设置无效。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry id="guc-promote-trigger-file" xreflabel="promote_trigger_file">
<!--==========================orignal english content==========================
        <term><varname>promote_trigger_file</varname> (<type>string</type>)
        <indexterm>
          <primary><varname>promote_trigger_file</varname> configuration parameter</primary>
        </indexterm>
        </term>
____________________________________________________________________________-->
        <term><varname>promote_trigger_file</varname> (<type>string</type>)
        <indexterm>
          <primary><varname>promote_trigger_file</varname> 配置参数</primary>
        </indexterm>
        </term>
        <listitem>
<!--==========================orignal english content==========================
         <para>
          Specifies a trigger file whose presence ends recovery in the
          standby.  Even if this value is not set, you can still promote
          the standby using <command>pg_ctl promote</command> or calling
          <function>pg_promote()</function>.
          This parameter can only be set in the <filename>postgresql.conf</filename>
          file or on the server command line.
         </para>
____________________________________________________________________________-->
         <para>
          指定一个触发器文件，该文件的存在会结束后备机中的恢复。即使这个值没有被设置，你也能够使用<command>pg_ctl promote</command>或调用<function>pg_promote()</function>.来提升后备机。
          这个参数只能在<filename>postgresql.conf</filename>文件中或在服务器命令行上设置。
         </para>
        </listitem>
       </varlistentry>

     <varlistentry id="guc-hot-standby" xreflabel="hot_standby">
<!--==========================orignal english content==========================
      <term><varname>hot_standby</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>hot_standby</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>hot_standby</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>hot_standby</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies whether or not you can connect and run queries during
        recovery, as described in <xref linkend="hot-standby"/>.
        The default value is <literal>on</literal>.
        This parameter can only be set at server start. It only has effect
        during archive recovery or in standby mode.
       </para>
____________________________________________________________________________-->
       <para>
        指定在恢复期间，你是否能够连接并运行查询，如<xref linkend="hot-standby"/>中所述。默认值是<literal>on</literal>。这个参数只能在服务器启动时设置。它只在归档恢复期间或后备机模式下才有效。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-standby-archive-delay" xreflabel="max_standby_archive_delay">
<!--==========================orignal english content==========================
      <term><varname>max_standby_archive_delay</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_standby_archive_delay</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>max_standby_archive_delay</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_standby_archive_delay</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        When Hot Standby is active, this parameter determines how long the
        standby server should wait before canceling standby queries that
        conflict with about-to-be-applied WAL entries, as described in
        <xref linkend="hot-standby-conflict"/>.
        <varname>max_standby_archive_delay</varname> applies when WAL data is
        being read from WAL archive (and is therefore not current).
        If this value is specified without units, it is taken as milliseconds.
        The default is 30 seconds.
        A value of -1 allows the standby to wait forever for conflicting
        queries to complete.
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        当热后备机处于活动状态时，这个参数决定取消那些与即将应用的 WAL 项冲突的后备机查询之前，后备服务器应该等待多久，如<xref linkend="hot-standby-conflict"/>中所述。
        当 WAL 数据被从 WAL 归档（并且因此不是当前的 WAL）时，<varname>max_standby_archive_delay</varname>可以应用。
        如果指定值时没有单位，则以毫秒为单位。默认值是 30 秒。值 -1 允许后备机一直等到冲突查询结束。
        这个参数只能在<filename>postgresql.conf</filename>文件中或在服务器命令行上设置。
       </para>

<!--==========================orignal english content==========================
       <para>
        Note that <varname>max_standby_archive_delay</varname> is not the same as the
        maximum length of time a query can run before cancellation; rather it
        is the maximum total time allowed to apply any one WAL segment's data.
        Thus, if one query has resulted in significant delay earlier in the
        WAL segment, subsequent conflicting queries will have much less grace
        time.
       </para>
____________________________________________________________________________-->
       <para>
        注意，<varname>max_standby_archive_delay</varname>与取消之前一个查询能够运行的最长时间不同；它表示应用任何一个 WAL 段数据能够被允许的最长总时间。因此，如果一个查询早于 WAL 段导致了显著的延迟，后续冲突查询将只有更少的时间。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-standby-streaming-delay" xreflabel="max_standby_streaming_delay">
<!--==========================orignal english content==========================
      <term><varname>max_standby_streaming_delay</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_standby_streaming_delay</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>max_standby_streaming_delay</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_standby_streaming_delay</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        When Hot Standby is active, this parameter determines how long the
        standby server should wait before canceling standby queries that
        conflict with about-to-be-applied WAL entries, as described in
        <xref linkend="hot-standby-conflict"/>.
        <varname>max_standby_streaming_delay</varname> applies when WAL data is
        being received via streaming replication.
        If this value is specified without units, it is taken as milliseconds.
        The default is 30 seconds.
        A value of -1 allows the standby to wait forever for conflicting
        queries to complete.
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        当热后备机处于活动状态时，这个参数决定取消那些与即将应用的 WAL 项冲突的后备机查询之前，后备服务器应该等待多久，如<xref linkend="hot-standby-conflict"/>中所述。
        当 WAL 数据正在通过流复制被接收时，<varname>max_standby_streaming_delay</varname>可以应用。
        如果指定值时没有单位，则以毫秒为单位。默认值是 30 秒。值 -1 允许后备机一直等到冲突查询结束。
        这个参数只能在<filename>postgresql.conf</filename>文件中或在服务器命令行上设置。
       </para>

<!--==========================orignal english content==========================
       <para>
        Note that <varname>max_standby_streaming_delay</varname> is not the same as
        the maximum length of time a query can run before cancellation; rather
        it is the maximum total time allowed to apply WAL data once it has
        been received from the primary server.  Thus, if one query has
        resulted in significant delay, subsequent conflicting queries will
        have much less grace time until the standby server has caught up
        again.
       </para>
____________________________________________________________________________-->
       <para>
        注意，<varname>max_standby_streaming_delay</varname>与取消之前一个查询能够运行的最长时间不同；它表示在从主服务器接收到 WAL 数据并立刻应用它能够被允许的最长总时间。因此，如果一个查询导致了显著的延迟，后续冲突查询将只有更少的时间，直到后备服务器再次赶上进度。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-receiver-create-temp-slot" xreflabel="wal_receiver_create_temp_slot">
<!--==========================orignal english content==========================
      <term><varname>wal_receiver_create_temp_slot</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>wal_receiver_create_temp_slot</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>wal_receiver_create_temp_slot</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>wal_receiver_create_temp_slot</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies whether the WAL receiver process should create a temporary replication
        slot on the remote instance when no permanent replication slot to use
        has been configured (using <xref linkend="guc-primary-slot-name"/>).
        The default is off.  This parameter can only be set in the
        <filename>postgresql.conf</filename> file or on the server command line.
        If this parameter is changed while the WAL receiver process is running,
        that process is signaled to shut down and expected to restart with
        the new setting.
       </para>
____________________________________________________________________________-->
       <para>
        指定在未配置永久复制槽时，WAL 接收器进程是否应在远程实例上创建临时复制槽（使用 <xref linkend="guc-primary-slot-name"/>）。
        默认为"关闭"。 此参数只能在<filename>postgresql.conf</filename>文件或服务器命令行中设置。
        如果在 WAL 接收器进程运行时更改此参数，则该进程将发出关机的信号，并预期使用新设置重新启动。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-receiver-status-interval" xreflabel="wal_receiver_status_interval">
<!--==========================orignal english content==========================
      <term><varname>wal_receiver_status_interval</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>wal_receiver_status_interval</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>wal_receiver_status_interval</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>wal_receiver_status_interval</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
      <para>
       Specifies the minimum frequency for the WAL receiver
       process on the standby to send information about replication progress
       to the primary or upstream standby, where it can be seen using the
       <link linkend="monitoring-pg-stat-replication-view">
       <structname>pg_stat_replication</structname></link>
       view.  The standby will report
       the last write-ahead log location it has written, the last position it
       has flushed to disk, and the last position it has applied.
       This parameter's value is the maximum amount of time between reports.
       Updates are sent each time the write or flush positions change, or as
       often as specified by this parameter if set to a non-zero value.
       There are additional cases where updates are sent while ignoring this
       parameter; for example, when processing of the existing WAL completes
       or when <varname>synchronous_commit</varname> is set to
       <literal>remote_apply</literal>.
       Thus, the apply position may lag slightly behind the true position.
       If this value is specified without units, it is taken as seconds.
       The default value is 10 seconds. This parameter can only be set in
       the <filename>postgresql.conf</filename> file or on the server
       command line.
      </para>
____________________________________________________________________________-->
      <para>
       指定在后备机上的 WAL 接收者进程向主服务器或上游后备机发送有关复制进度的信息的最小频度，它可以使用<link linkend="monitoring-pg-stat-replication-view"><structname>pg_stat_replication</structname></link>视图看到。
       后备机将报告它已经写入的上一个预写式日志位置、它已经刷到磁盘的上一个位置以及它已经应用的最后一个位置。
       这个参数的值是报告之间的最大时间量。
       每次写入或刷出位置改变时会发送状态更新，或者按这个参数的指定的频度发送，如果设置为非零值。 
       在其他情况下发送更新时忽略此参数；例如，当现有的WAL处理完成或当<varname>synchronous_commit</varname>设置为<literal>remote_apply</literal>时。
       因此，应用位置可能比真实位置略微滞后。
       如果指定值时没有单位，则以秒为单位。
       默认值是 10 秒。
       这个参数只能在<filename>postgresql.conf</filename>文件中或在服务器命令行上设置。
      </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-hot-standby-feedback" xreflabel="hot_standby_feedback">
<!--==========================orignal english content==========================
      <term><varname>hot_standby_feedback</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>hot_standby_feedback</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>hot_standby_feedback</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>hot_standby_feedback</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies whether or not a hot standby will send feedback to the primary
        or upstream standby
        about queries currently executing on the standby. This parameter can
        be used to eliminate query cancels caused by cleanup records, but
        can cause database bloat on the primary for some workloads.
        Feedback messages will not be sent more frequently than once per
        <varname>wal_receiver_status_interval</varname>. The default value is
        <literal>off</literal>. This parameter can only be set in the
        <filename>postgresql.conf</filename> file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        指定一个热后备机是否将会向主服务器或上游后备机发送有关于后备机上当前正被执行的查询的反馈。这个参数可以被用来排除由于记录清除导致的查询取消，但是可能导致在主服务器上用于某些负载的数据库膨胀。反馈消息的发送频度不会高于每个<varname>wal_receiver_status_interval</varname>周期发送一次。默认值是<literal>off</literal>。这个参数只能在<filename>postgresql.conf</filename>文件中或在服务器命令行上设置。
       </para>

<!--==========================orignal english content==========================
       <para>
        If cascaded replication is in use the feedback is passed upstream
        until it eventually reaches the primary.  Standbys make no other use
        of feedback they receive other than to pass upstream.
       </para>
____________________________________________________________________________-->
       <para>
        如果使用级联复制，反馈将被向上游传递直到它最后到达主服务器。后备机在接收到反馈之后除了传递给上游不会做任何其他操作。
       </para>

<!--==========================orignal english content==========================
       <para>
        This setting does not override the behavior of
        <varname>old_snapshot_threshold</varname> on the primary; a snapshot on the
        standby which exceeds the primary's age threshold can become invalid,
        resulting in cancellation of transactions on the standby.  This is
        because <varname>old_snapshot_threshold</varname> is intended to provide an
        absolute limit on the time which dead rows can contribute to bloat,
        which would otherwise be violated because of the configuration of a
        standby.
       </para>
____________________________________________________________________________-->
       <para>
        这个设置不会覆盖主服务器上的<varname>old_snapshot_threshold</varname>的行为，后备服务器上一个超过了主服务器年龄阈值的快照可能会变得不可用，导致后备服务器上事务的取消。这是因为<varname>old_snapshot_threshold</varname>是为了对死亡行能够存在的时间给出一个绝对限制，不然就会因为一个后备服务器的配置而被违背。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-receiver-timeout" xreflabel="wal_receiver_timeout">
<!--==========================orignal english content==========================
      <term><varname>wal_receiver_timeout</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>wal_receiver_timeout</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>wal_receiver_timeout</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>wal_receiver_timeout</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Terminate replication connections that are inactive for longer
        than this amount of time. This is useful for
        the receiving standby server to detect a primary node crash or network
        outage.
        If this value is specified without units, it is taken as milliseconds.
        The default value is 60 seconds.
        A value of zero disables the timeout mechanism.
        This parameter can only be set in
        the <filename>postgresql.conf</filename> file or on the server
        command line.
       </para>
____________________________________________________________________________-->
       <para>
        中止处于非活动状态超过这个时间量的复制链接。这对于正在接收的后备服务器检测主服务器崩溃或网络断开有用。
        如果指定值时没有单位，则以毫秒为单位。默认值是 60 秒。
        这个参数只能在<filename>postgresql.conf</filename>文件中或者服务器命令行中设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-retrieve-retry-interval" xreflabel="wal_retrieve_retry_interval">
<!--==========================orignal english content==========================
      <term><varname>wal_retrieve_retry_interval</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>wal_retrieve_retry_interval</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>wal_retrieve_retry_interval</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>wal_retrieve_retry_interval</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies how long the standby server should wait when WAL data is not
        available from any sources (streaming replication,
        local <filename>pg_wal</filename> or WAL archive) before trying
        again to retrieve WAL data.
        If this value is specified without units, it is taken as milliseconds.
        The default value is 5 seconds.
        This parameter can only be set in
        the <filename>postgresql.conf</filename> file or on the server
        command line.
       </para>
____________________________________________________________________________-->
       <para>
        指定当从任何来源（流复制、本地<filename>pg_wal</filename>或者 WAL 归档）都得不到 WAL 数据时，后备服务器应该等待多久才去重新尝试获取 WAL 数据。
        如果指定值时没有单位，则以毫秒为单位。默认值是 5 秒。
        这个参数只能在<filename>postgresql.conf</filename>文件或者服务器命令行中设置。
       </para>

<!--==========================orignal english content==========================
       <para>
        This parameter is useful in configurations where a node in recovery
        needs to control the amount of time to wait for new WAL data to be
        available. For example, in archive recovery, it is possible to
        make the recovery more responsive in the detection of a new WAL
        log file by reducing the value of this parameter. On a system with
        low WAL activity, increasing it reduces the amount of requests necessary
        to access WAL archives, something useful for example in cloud
        environments where the amount of times an infrastructure is accessed
        is taken into account.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数对恢复中的节点需要为新 WAL 数据可用等待多少时间的配置有用。
        例如，在归档恢复中，通过减小这个参数的值可以让恢复更积极地检测新的
        WAL 日志文件。在一个 WAL 活动较低的系统上，增加这个参数的值可以减
        少访问 WAL 归档所必需的请求数量，这对于例如云环境是有用的，在其中
        对于基础设施的访问时间也是被考虑的。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-recovery-min-apply-delay" xreflabel="recovery_min_apply_delay">
<!--==========================orignal english content==========================
      <term><varname>recovery_min_apply_delay</varname> (<type>integer</type>)
      <indexterm>
        <primary><varname>recovery_min_apply_delay</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>recovery_min_apply_delay</varname> (<type>integer</type>)
      <indexterm>
        <primary><varname>recovery_min_apply_delay</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        By default, a standby server restores WAL records from the
        sending server as soon as possible. It may be useful to have a time-delayed
        copy of the data, offering opportunities to correct data loss errors.
        This parameter allows you to delay recovery by a specified amount
        of time.  For example, if
        you set this parameter to <literal>5min</literal>, the standby will
        replay each transaction commit only when the system time on the standby
        is at least five minutes past the commit time reported by the primary.
        If this value is specified without units, it is taken as milliseconds.
        The default is zero, adding no delay.
       </para>
____________________________________________________________________________-->
       <para>
        默认情况下，后备服务器会尽快恢复来自于发送服务器的 WAL 记录。有一份数据的延时拷贝是有用的，它能提供机会纠正数据丢失错误。
        这个参数允许你将恢复延迟一段指定的时间量。
        例如，如果你设置这个参数为<literal>5min</literal>，对于一个事务提交，只有当后备机上的系统时钟超过主服务器报告的提交时间至少 5分钟时，后备机才会重放该事务。
        如果指定值时没有单位，则以毫秒为单位。默认为0，不增加延迟。
       </para>

<!--==========================orignal english content==========================
       <para>
        It is possible that the replication delay between servers exceeds the
        value of this parameter, in which case no delay is added.
        Note that the delay is calculated between the WAL time stamp as written
        on primary and the current time on the standby. Delays in transfer
        because of network lag or cascading replication configurations
        may reduce the actual wait time significantly. If the system
        clocks on primary and standby are not synchronized, this may lead to
        recovery applying records earlier than expected; but that is not a
        major issue because useful settings of this parameter are much larger
        than typical time deviations between servers.
       </para>
____________________________________________________________________________-->
       <para>
        有可能服务器之间的复制延迟会超过这个参数的值，在这种情况下则不会增加延迟。
        注意延迟是根据主服务器上写 WAL 的时间戳以及后备机上的当前时间来计算。
        由于网络延迟或者级联复制配置导致的传输延迟可能会显著地减少实际等待时间。
        如果主服务器和后备机上的系统时钟不同步，这会导致恢复比预期的更早应用记录。
        但这不是一个主要问题，因为这个参数有用的设置比服务器之间的典型事件偏差要大得多。
       </para>

<!--==========================orignal english content==========================
       <para>
        The delay occurs only on WAL records for transaction commits.
        Other records are replayed as quickly as possible, which
        is not a problem because MVCC visibility rules ensure their effects
        are not visible until the corresponding commit record is applied.
       </para>
____________________________________________________________________________-->
       <para>
        只有在事务提交的 WAL 记录上才会发生延迟。其他记录还是会被尽可能快地重放，这不会成为问题，因为 MVCC 可见性规则确保了在对应的提交记录被应用之前它们的效果不会被看到。
       </para>

<!--==========================orignal english content==========================
       <para>
        The delay occurs once the database in recovery has reached a consistent
        state, until the standby is promoted or triggered. After that the standby
        will end recovery without further waiting.
       </para>
____________________________________________________________________________-->
       <para>
        一旦恢复中的数据库已经达到一致状态，延迟就会产生，直到后备机被提升或者触发。在那之后，后备机将会结束恢复并且不再等待。
       </para>

<!--==========================orignal english content==========================
       <para>
        This parameter is intended for use with streaming replication deployments;
        however, if the parameter is specified it will be honored in all cases
        except crash recovery.

        <varname>hot_standby_feedback</varname> will be delayed by use of this feature
        which could lead to bloat on the primary; use both together with care.

        <warning>
         <para>
          Synchronous replication is affected by this setting when <varname>synchronous_commit</varname>
          is set to <literal>remote_apply</literal>; every <literal>COMMIT</literal>
          will need to wait to be applied.
         </para>
        </warning>
       </para>
____________________________________________________________________________-->
       <para>
        这个参数的目的是和流复制部署一起使用，但是，如果指定了该参数，除了崩溃恢复之外所有的情况下都会遵守它。
        使用这个特性也会让<varname>hot_standby_feedback</varname>被延迟，这可能导致主服务器的膨胀，两者一起使用时要小心。
        
        <warning>
         <para>
          当<varname>synchronous_commit</varname>被设置为<literal>remote_apply</literal>时，同步复制会受到这个设置的影响，每一个<literal>COMMIT</literal>都需要等待被应用。
         </para>
        </warning>
       </para>

<!--==========================orignal english content==========================
       <para>
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数只能在<filename>postgresql.conf</filename>文件中或在服务器命令行中设置。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect2>

    <sect2 id="runtime-config-replication-subscriber">
<!--==========================orignal english content==========================
     <title>Subscribers</title>
____________________________________________________________________________-->
     <title>订阅者</title>

<!--==========================orignal english content==========================
     <para>
      These settings control the behavior of a logical replication subscriber.
      Their values on the publisher are irrelevant.
     </para>
____________________________________________________________________________-->
     <para>
      这些设置控制逻辑复制订阅者的行为。它们在发布者上的值与此无关。
     </para>

<!--==========================orignal english content==========================
     <para>
      Note that <varname>wal_receiver_timeout</varname>,
      <varname>wal_receiver_status_interval</varname> and
      <varname>wal_retrieve_retry_interval</varname> configuration parameters
      affect the logical replication workers as well.
     </para>
____________________________________________________________________________-->
     <para>
      注意，配置参数<varname>wal_receiver_timeout</varname>、<varname>wal_receiver_status_interval</varname>以及<varname>wal_retrieve_retry_interval</varname>也影响逻辑复制工作者。
     </para>

     <variablelist>

     <varlistentry id="guc-max-logical-replication-workers" xreflabel="max_logical_replication_workers">
<!--==========================orignal english content==========================
      <term><varname>max_logical_replication_workers</varname> (<type>int</type>)
      <indexterm>
       <primary><varname>max_logical_replication_workers</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>max_logical_replication_workers</varname> (<type>int</type>)
      <indexterm>
       <primary><varname>max_logical_replication_workers</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies maximum number of logical replication workers. This includes
        both apply workers and table synchronization workers.
       </para>
____________________________________________________________________________-->
       <para>
        指定逻辑复制工作者的最大数目。这同时包括应用工作者和表同步工作者。
       </para>

<!--==========================orignal english content==========================
       <para>
        Logical replication workers are taken from the pool defined by
        <varname>max_worker_processes</varname>.
       </para>
____________________________________________________________________________-->
       <para>
        逻辑复制工作者是从<varname>max_worker_processes</varname>定义的池中取出的。
       </para>

<!--==========================orignal english content==========================
       <para>
        The default value is 4. This parameter can only be set at server
        start.
       </para>
____________________________________________________________________________-->
       <para>
        默认值是4。
        这个参数只能在服务器启动时被设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-sync-workers-per-subscription" xreflabel="max_sync_workers_per_subscription">
<!--==========================orignal english content==========================
      <term><varname>max_sync_workers_per_subscription</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_sync_workers_per_subscription</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>max_sync_workers_per_subscription</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_sync_workers_per_subscription</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Maximum number of synchronization workers per subscription. This
        parameter controls the amount of parallelism of the initial data copy
        during the subscription initialization or when new tables are added.
       </para>
____________________________________________________________________________-->
       <para>
        每个订阅的同步工作者的最大数目。这个参数控制订阅初始化期间或者新表增加时的初始数据拷贝的并行度。
       </para>

<!--==========================orignal english content==========================
       <para>
        Currently, there can be only one synchronization worker per table.
       </para>
____________________________________________________________________________-->
       <para>
        当前，每个表只能有一个同步工作者。
       </para>

<!--==========================orignal english content==========================
       <para>
        The synchronization workers are taken from the pool defined by
        <varname>max_logical_replication_workers</varname>.
       </para>
____________________________________________________________________________-->
       <para>
        同步工作者是从<varname>max_logical_replication_workers</varname>定义的池中取出的。
       </para>

<!--==========================orignal english content==========================
       <para>
        The default value is 2. This parameter can only be set in the
        <filename>postgresql.conf</filename> file or on the server command
        line.
       </para>
____________________________________________________________________________-->
       <para>
        默认值为2。
        这个参数只能在<filename>postgresql.conf</filename>文件中或服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect2>

   </sect1>

   <sect1 id="runtime-config-query">
<!--==========================orignal english content==========================
    <title>Query Planning</title>
____________________________________________________________________________-->
    <title>查询规划</title>

    <sect2 id="runtime-config-query-enable">
<!--==========================orignal english content==========================
     <title>Planner Method Configuration</title>
____________________________________________________________________________-->
     <title>规划器方法配制</title>

<!--==========================orignal english content==========================
      <para>
       These configuration parameters provide a crude method of
       influencing the query plans chosen by the query optimizer. If
       the default plan chosen by the optimizer for a particular query
       is not optimal, a <emphasis>temporary</emphasis> solution is to use one
       of these configuration parameters to force the optimizer to
       choose a different plan.
       Better ways to improve the quality of the
       plans chosen by the optimizer include adjusting the planner cost
       constants (see <xref linkend="runtime-config-query-constants"/>),
       running <link linkend="sql-analyze"><command>ANALYZE</command></link> manually, increasing
       the value of the <xref
       linkend="guc-default-statistics-target"/> configuration parameter,
       and increasing the amount of statistics collected for
       specific columns using <command>ALTER TABLE SET
       STATISTICS</command>.
      </para>
____________________________________________________________________________-->
      <para>
       这些配置参数提供了影响查询优化器选择查询规划的原始方法。
       如果优化器 为特定的查询选择的缺省规划并不是最优，那么我们就可以通过使用这些 配置参数强制优化器选择一个更好的规划来temporary解决这个问题。
       不过，永久地关闭这些设置几乎从不是个好主意。
       更好的改善优化器 选择规划的方法包括调节Section 18.6.2、 更频繁运行ANALYZE、增大配置参数 default_statistics_target的值、使用 ALTER TABLE SET STATISTICS为某个字段增加收集的统计信息。
       这些配置参数影响查询优化器选择查询计划的暴力方法。
       如果优化器为一个特定查询选择的默认计划不是最优的，一种<emphasis>临时</emphasis>解决方案是使用这些配置参数之一来强制优化器选择一个不同的计划。
       提高优化器选择的计划质量的更好的方式包括调整规划器的代价常数（见<xref linkend="runtime-config-query-constants"/>）、手工运行<link linkend="sql-analyze"><command>ANALYZE</command></link> 、增加<xref  linkend="guc-default-statistics-target"/>配置参数的值以及使用<command>ALTER TABLE SET STATISTICS</command>增加为特定列收集的统计信息量。
      </para>

     <variablelist>
     <varlistentry id="guc-enable-async-append" xreflabel="enable_async_append">
<!--==========================orignal english content==========================
      <term><varname>enable_async_append</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_async_append</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>enable_async_append</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_async_append</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Enables or disables the query planner's use of async-aware
        append plan types. The default is <literal>on</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        激活或禁用查询计划的关于异步感知附加计划类型的使用。
        默认为<literal>on</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-bitmapscan" xreflabel="enable_bitmapscan">
<!--==========================orignal english content==========================
      <term><varname>enable_bitmapscan</varname> (<type>boolean</type>)
      <indexterm>
       <primary>bitmap scan</primary>
      </indexterm>
      <indexterm>
       <primary><varname>enable_bitmapscan</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>enable_bitmapscan</varname> (<type>boolean</type>)
      <indexterm>
       <primary>bitmap scan</primary>
      </indexterm>
      <indexterm>
       <primary><varname>enable_bitmapscan</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Enables or disables the query planner's use of bitmap-scan plan
        types. The default is <literal>on</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        允许或禁止查询规划器使用位图扫描计划类型。默认值是<literal>on</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-gathermerge" xreflabel="enable_gathermerge">
<!--==========================orignal english content==========================
      <term><varname>enable_gathermerge</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_gathermerge</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>enable_gathermerge</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_gathermerge</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Enables or disables the query planner's use of gather
        merge plan types. The default is <literal>on</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        启用或者禁用查询规划器对收集归并计划类型的使用。默认值是<literal>on</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-hashagg" xreflabel="enable_hashagg">
<!--==========================orignal english content==========================
      <term><varname>enable_hashagg</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_hashagg</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>enable_hashagg</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_hashagg</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Enables or disables the query planner's use of hashed
        aggregation plan types. The default is <literal>on</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        允许或禁用查询规划器使用哈希聚集计划类型。默认值是<literal>on</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-hashjoin" xreflabel="enable_hashjoin">
<!--==========================orignal english content==========================
      <term><varname>enable_hashjoin</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_hashjoin</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>enable_hashjoin</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_hashjoin</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Enables or disables the query planner's use of hash-join plan
        types. The default is <literal>on</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        允许或禁止查询规划器使用哈希连接计划类型。默认值是<literal>on</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-incremental-sort" xreflabel="enable_incremental_sort">
<!--==========================orignal english content==========================
      <term><varname>enable_incremental_sort</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_incremental_sort</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>enable_incremental_sort</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_incremental_sort</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Enables or disables the query planner's use of incremental sort steps.
        The default is <literal>on</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        启用或禁用查询规划器对增量排序步骤的使用。默认为<literal>on</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-indexscan" xreflabel="enable_indexscan">
<!--==========================orignal english content==========================
      <term><varname>enable_indexscan</varname> (<type>boolean</type>)
      <indexterm>
       <primary>index scan</primary>
      </indexterm>
      <indexterm>
       <primary><varname>enable_indexscan</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>enable_indexscan</varname> (<type>boolean</type>)
      <indexterm>
       <primary>index scan</primary>
      </indexterm>
      <indexterm>
       <primary><varname>enable_indexscan</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Enables or disables the query planner's use of index-scan plan
        types. The default is <literal>on</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        允许或禁止查询规划器使用索引扫描计划类型。默认值是<literal>on</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-indexonlyscan" xreflabel="enable_indexonlyscan">
<!--==========================orignal english content==========================
      <term><varname>enable_indexonlyscan</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_indexonlyscan</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>enable_indexonlyscan</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_indexonlyscan</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Enables or disables the query planner's use of index-only-scan plan
        types (see <xref linkend="indexes-index-only-scans"/>).
        The default is <literal>on</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        允许或禁止查询规划器使用只用索引扫描计划类型（见<xref linkend="indexes-index-only-scans"/>）。默认值是<literal>on</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-material" xreflabel="enable_material">
<!--==========================orignal english content==========================
      <term><varname>enable_material</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_material</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>enable_material</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_material</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Enables or disables the query planner's use of materialization.
        It is impossible to suppress materialization entirely,
        but turning this variable off prevents the planner from inserting
        materialize nodes except in cases where it is required for correctness.
        The default is <literal>on</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        允许或者禁止查询规划器使用物化。它不可能完全禁用物化，但是关闭这个变量将阻止规划器插入物化节点，除非为了保证正确性。默认值是<literal>on</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-memoize" xreflabel="enable_memoize">
<!--==========================orignal english content==========================
      <term><varname>enable_memoize</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_memoize</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>enable_memoize</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_memoize</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Enables or disables the query planner's use of memoize plans for
        caching results from parameterized scans inside nested-loop joins.
        This plan type allows scans to the underlying plans to be skipped when
        the results for the current parameters are already in the cache.  Less
        commonly looked up results may be evicted from the cache when more
        space is required for new entries. The default is
        <literal>on</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        启用或禁用查询计划器对memoize计划的使用，以便缓存在嵌套循环连接中参数化扫描的结果。
        在当前参数的结果已经在缓存中时，此计划类型允许跳过对底层计划的扫描。
        当新条目需要更多空间时，不太常用的查询结果可能会从缓存中去除。
        默认值是<literal>on</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-mergejoin" xreflabel="enable_mergejoin">
<!--==========================orignal english content==========================
      <term><varname>enable_mergejoin</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_mergejoin</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>enable_mergejoin</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_mergejoin</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Enables or disables the query planner's use of merge-join plan
        types. The default is <literal>on</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        允许或禁止查询规划器使用归并连接计划类型。默认值是<literal>on</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-nestloop" xreflabel="enable_nestloop">
<!--==========================orignal english content==========================
      <term><varname>enable_nestloop</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_nestloop</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>enable_nestloop</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_nestloop</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Enables or disables the query planner's use of nested-loop join
        plans. It is impossible to suppress nested-loop joins entirely,
        but turning this variable off discourages the planner from using
        one if there are other methods available. The default is
        <literal>on</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        允许或禁止查询规划器使用嵌套循环连接计划。它不可能完全禁止嵌套循环连接，但是关闭这个变量将使得规划器尽可能优先使用其他方法。默认值是<literal>on</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-parallel-append" xreflabel="enable_parallel_append">
<!--==========================orignal english content==========================
      <term><varname>enable_parallel_append</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_parallel_append</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>enable_parallel_append</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_parallel_append</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Enables or disables the query planner's use of parallel-aware
        append plan types. The default is <literal>on</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        允许或禁止查询规划器使用并行追加计划类型。默认值是<literal>on</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-parallel-hash" xreflabel="enable_parallel_hash">
<!--==========================orignal english content==========================
      <term><varname>enable_parallel_hash</varname> (<type>boolean</type>)
       <indexterm>
        <primary><varname>enable_parallel_hash</varname> configuration parameter</primary>
       </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>enable_parallel_hash</varname> (<type>boolean</type>)
       <indexterm>
        <primary><varname>enable_parallel_hash</varname>配置参数</primary>
       </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Enables or disables the query planner's use of hash-join plan
        types with parallel hash. Has no effect if hash-join plans are not
        also enabled. The default is <literal>on</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        允许或禁止查询规划器对并行哈希使用哈希连接计划类型。如果哈希连接计划也没有启用，这个参数没有效果。默认值是<literal>on</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-partition-pruning" xreflabel="enable_partition_pruning">
<!--==========================orignal english content==========================
      <term><varname>enable_partition_pruning</varname> (<type>boolean</type>)
       <indexterm>
        <primary><varname>enable_partition_pruning</varname> configuration parameter</primary>
       </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>enable_partition_pruning</varname> (<type>boolean</type>)
       <indexterm>
        <primary><varname>enable_partition_pruning</varname>配置参数</primary>
       </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Enables or disables the query planner's ability to eliminate a
        partitioned table's partitions from query plans.  This also controls
        the planner's ability to generate query plans which allow the query
        executor to remove (ignore) partitions during query execution.  The
        default is <literal>on</literal>.
        See <xref linkend="ddl-partition-pruning"/> for details.
       </para>
____________________________________________________________________________-->
       <para>
        允许或者禁止查询规划器从查询计划中消除一个分区表的分区。这也控制着规划器产生允许执行器在查询执行期间移除（忽略）分区的查询计划的能力。默认值是<literal>on</literal>。详情请参考<xref linkend="ddl-partition-pruning"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-partitionwise-join" xreflabel="enable_partitionwise_join">
<!--==========================orignal english content==========================
      <term><varname>enable_partitionwise_join</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_partitionwise_join</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>enable_partitionwise_join</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_partitionwise_join</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Enables or disables the query planner's use of partitionwise join,
        which allows a join between partitioned tables to be performed by
        joining the matching partitions.  Partitionwise join currently applies
        only when the join conditions include all the partition keys, which
        must be of the same data type and have one-to-one matching sets of
        child partitions.  Because partitionwise join planning can use
        significantly more CPU time and memory during planning, the default is
        <literal>off</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        允许或者禁止查询规划器使用面向分区的连接，这使得分区表之间的连接以连接匹配的分区的方式来执行。
        面向分区的连接当前只适用于连接条件包括所有分区键的情况，连接条件必须是相同的数据类型并且子分区集合要1对1匹配。
        由于面向分区的连接规划在规划期间会使用可观的CPU时间和内存，所以默认值为<literal>off</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-partitionwise-aggregate" xreflabel="enable_partitionwise_aggregate">
<!--==========================orignal english content==========================
      <term><varname>enable_partitionwise_aggregate</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_partitionwise_aggregate</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>enable_partitionwise_aggregate</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_partitionwise_aggregate</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Enables or disables the query planner's use of partitionwise grouping
        or aggregation, which allows grouping or aggregation on a partitioned
        tables performed separately for each partition.  If the <literal>GROUP
        BY</literal> clause does not include the partition keys, only partial
        aggregation can be performed on a per-partition basis, and
        finalization must be performed later.  Because partitionwise grouping
        or aggregation can use significantly more CPU time and memory during
        planning, the default is <literal>off</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        允许或者禁止查询规划器使用面向分区的分组或聚集，这使得在分区表上的分组或聚集可以在每个分区上分别执行。如果<literal>GROUP BY</literal>子句不包括分区键，只有部分聚集能够以基于每个分区的方式执行，并且finalization必须最后执行。由于面向分区的分组或聚集在规划期间会使用可观的CPU时间和内存，所以默认值为<literal>off</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-seqscan" xreflabel="enable_seqscan">
<!--==========================orignal english content==========================
      <term><varname>enable_seqscan</varname> (<type>boolean</type>)
      <indexterm>
       <primary>sequential scan</primary>
      </indexterm>
      <indexterm>
       <primary><varname>enable_seqscan</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>enable_seqscan</varname> (<type>boolean</type>)
      <indexterm>
       <primary>sequential scan</primary>
      </indexterm>
      <indexterm>
       <primary><varname>enable_seqscan</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Enables or disables the query planner's use of sequential scan
        plan types. It is impossible to suppress sequential scans
        entirely, but turning this variable off discourages the planner
        from using one if there are other methods available. The
        default is <literal>on</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        允许或禁止查询规划器使用顺序扫描计划类型。它不可能完全禁止顺序扫描，但是关闭这个变量将使得规划器尽可能优先使用其他方法。默认值是<literal>on</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-sort" xreflabel="enable_sort">
<!--==========================orignal english content==========================
      <term><varname>enable_sort</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_sort</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>enable_sort</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_sort</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Enables or disables the query planner's use of explicit sort
        steps. It is impossible to suppress explicit sorts entirely,
        but turning this variable off discourages the planner from
        using one if there are other methods available. The default
        is <literal>on</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        允许或禁止查询规划器使用显式排序步骤。它不可能完全禁止显式排序，但是关闭这个变量将使得规划器尽可能优先使用其他方法。默认值是<literal>on</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-tidscan" xreflabel="enable_tidscan">
<!--==========================orignal english content==========================
      <term><varname>enable_tidscan</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_tidscan</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>enable_tidscan</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_tidscan</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Enables or disables the query planner's use of <acronym>TID</acronym>
        scan plan types. The default is <literal>on</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        允许或禁止查询规划器使用<acronym>TID</acronym>扫描计划类型。默认值是<literal>on</literal>。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
     </sect2>
     <sect2 id="runtime-config-query-constants">
<!--==========================orignal english content==========================
     <title>Planner Cost Constants</title>
____________________________________________________________________________-->
     <title>规划器代价常量</title>
<!--==========================orignal english content==========================
    <para>
     The <firstterm>cost</firstterm> variables described in this section are measured
     on an arbitrary scale.  Only their relative values matter, hence
     scaling them all up or down by the same factor will result in no change
     in the planner's choices.  By default, these cost variables are based on
     the cost of sequential page fetches; that is,
     <varname>seq_page_cost</varname> is conventionally set to <literal>1.0</literal>
     and the other cost variables are set with reference to that.  But
     you can use a different scale if you prefer, such as actual execution
     times in milliseconds on a particular machine.
    </para>
____________________________________________________________________________-->
    <para>
     这一节中描述的<firstterm>代价</firstterm>变量可以按照任意尺度衡量。我们只关心它们的相对值，将它们以相同的因子缩放不会影响规划器的选择。默认情况下，这些代价变量是基于顺序页面获取的代价的，即<varname>seq_page_cost</varname>被设置为<literal>1.0</literal>并且其他代价变量都参考它来设置。不过你可以使用你喜欢的不同尺度，例如在一个特定机器上的真实执行时间。
    </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     Unfortunately, there is no well-defined method for determining ideal
     values for the cost variables.  They are best treated as averages over
     the entire mix of queries that a particular installation will receive.  This
     means that changing them on the basis of just a few experiments is very
     risky.
    </para>
____________________________________________________________________________-->
    <para>
     不幸的是，没有一种良定义的方法来决定代价变量的理想值。它们最好被作为一个特定安装将接收到的查询的平均值来对待。这意味着基于少量的实验来改变它们是有风险的。
    </para>
   </note>

     <variablelist>

     <varlistentry id="guc-seq-page-cost" xreflabel="seq_page_cost">
<!--==========================orignal english content==========================
      <term><varname>seq_page_cost</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>seq_page_cost</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>seq_page_cost</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>seq_page_cost</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the planner's estimate of the cost of a disk page fetch
        that is part of a series of sequential fetches.  The default is 1.0.
        This value can be overridden for tables and indexes in a particular
        tablespace by setting the tablespace parameter of the same name
        (see <xref linkend="sql-altertablespace"/>).
       </para>
____________________________________________________________________________-->
       <para>
        设置规划器计算一次顺序磁盘页面抓取的开销。默认值是1.0。 通过设置同名的表空间参数，这个值可以重写为一个特定的表空间。 参阅ALTER TABLESPACE。
        设置规划器对一系列顺序磁盘页面获取中的一次的代价估计。默认值是 1.0。通过把表和索引放在一个特殊的表空间（要设置该表空间的同名参数）中可以覆盖这个值（见<xref linkend="sql-altertablespace"/>）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-random-page-cost" xreflabel="random_page_cost">
<!--==========================orignal english content==========================
      <term><varname>random_page_cost</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>random_page_cost</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>random_page_cost</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>random_page_cost</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the planner's estimate of the cost of a
        non-sequentially-fetched disk page.  The default is 4.0.
        This value can be overridden for tables and indexes in a particular
        tablespace by setting the tablespace parameter of the same name
        (see <xref linkend="sql-altertablespace"/>).
       </para>
____________________________________________________________________________-->
       <para>
        设置规划器对一次非顺序获取磁盘页面的代价估计。默认值是 4.0。通过把表和索引放在一个特殊的表空间（要设置该表空间的同名参数）中可以覆盖这个值（见<xref linkend="sql-altertablespace"/>）。
       </para>

<!--==========================orignal english content==========================
       <para>
        Reducing this value relative to <varname>seq_page_cost</varname>
        will cause the system to prefer index scans; raising it will
        make index scans look relatively more expensive.  You can raise
        or lower both values together to change the importance of disk I/O
        costs relative to CPU costs, which are described by the following
        parameters.
       </para>
____________________________________________________________________________-->
       <para>
        减少这个值（相对于<varname>seq_page_cost</varname>）将导致系统更倾向于索引扫描；提高它将让索引扫描看起来相对更昂贵。你可以一起提高或降低两个值来改变磁盘 I/O 代价相对于 CPU 代价的重要性，后者由下列参数描述。
       </para>

<!--==========================orignal english content==========================
       <para>
        Random access to mechanical disk storage is normally much more expensive
        than four times sequential access.  However, a lower default is used
        (4.0) because the majority of random accesses to disk, such as indexed
        reads, are assumed to be in cache.  The default value can be thought of
        as modeling random access as 40 times slower than sequential, while
        expecting 90% of random reads to be cached.
       </para>
____________________________________________________________________________-->
       <para>
        对磁盘存储的随机访问通常比顺序访问要贵不止四倍。但是，由于对磁盘的大部分随机访问（例如被索引的读取）都被假定在高速缓冲中进行，所以使用了一个较低的默认值（4.0）。默认值可以被想成把随机访问建模为比顺序访问慢 40 倍，而期望 90% 的随机读取会被缓存。
       </para>

<!--==========================orignal english content==========================
       <para>
        If you believe a 90% cache rate is an incorrect assumption
        for your workload, you can increase random_page_cost to better
        reflect the true cost of random storage reads. Correspondingly,
        if your data is likely to be completely in cache, such as when
        the database is smaller than the total server memory, decreasing
        random_page_cost can be appropriate.  Storage that has a low random
        read cost relative to sequential, e.g., solid-state drives, might
        also be better modeled with a lower value for random_page_cost,
        e.g., <literal>1.1</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        如果你相信 90% 的缓冲率对你的负载是一个不正确的假设，你可以增加 random_page_cost 来更好的反映随机存储读取的真正代价。
        相应地，如果你的数据可以完全放在高速缓存中（例如当数据库小于服务器总内存时），降低 random_page_cost 可能是合适的。
        为具有很低的随机读取代价的存储（例如固态驱动器）采用较低的 random_page_cost 值可能更好，例如<literal>1.1</literal>。
       </para>

       <tip>
<!--==========================orignal english content==========================
        <para>
         Although the system will let you set <varname>random_page_cost</varname> to
         less than <varname>seq_page_cost</varname>, it is not physically sensible
         to do so.  However, setting them equal makes sense if the database
         is entirely cached in RAM, since in that case there is no penalty
         for touching pages out of sequence.  Also, in a heavily-cached
         database you should lower both values relative to the CPU parameters,
         since the cost of fetching a page already in RAM is much smaller
         than it would normally be.
        </para>
____________________________________________________________________________-->
        <para>
         虽然允许你将random_page_cost设置的比 seq_page_cost小，但是物理上的实际情况并不受此影响。 然而当所有数据库都位于内存中时，两者设置为相等是非常合理的，因为 在此情况下，乱序抓取并不比顺序抓取开销更大。同样，在缓冲率很高的 数据库上，你应当相对于 CPU 开销同时降低这两个值，因为获取内存中 的页比通常情况下的开销小许多。
         尽管系统可以是你把<varname>random_page_cost</varname>设置得小于<varname>seq_page_cost</varname>，但是实际上没有意义。不过，如果数据库被整个缓存在 RAM 中，将它们设置为相等是有意义的，因为在那种情况中不按顺序访问页面是没有惩罚值的。同样，在一个高度缓存化的数据库中，你应该相对于 CPU 参数降低这两个值，因为获取一个已经在 RAM 中的页面的代价要远小于通常情况下的代价。
        </para>
       </tip>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-cpu-tuple-cost" xreflabel="cpu_tuple_cost">
<!--==========================orignal english content==========================
      <term><varname>cpu_tuple_cost</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>cpu_tuple_cost</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>cpu_tuple_cost</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>cpu_tuple_cost</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the planner's estimate of the cost of processing
        each row during a query.
        The default is 0.01.
       </para>
____________________________________________________________________________-->
       <para>
        设置规划器对一次查询中处理每一行的代价估计。默认值是 0.01。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-cpu-index-tuple-cost" xreflabel="cpu_index_tuple_cost">
<!--==========================orignal english content==========================
      <term><varname>cpu_index_tuple_cost</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>cpu_index_tuple_cost</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>cpu_index_tuple_cost</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>cpu_index_tuple_cost</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the planner's estimate of the cost of processing
        each index entry during an index scan.
        The default is 0.005.
       </para>
____________________________________________________________________________-->
       <para>
        设置规划器对一次索引扫描中处理每一个索引项的代价估计。默认值是 0.005。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-cpu-operator-cost" xreflabel="cpu_operator_cost">
<!--==========================orignal english content==========================
      <term><varname>cpu_operator_cost</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>cpu_operator_cost</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>cpu_operator_cost</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>cpu_operator_cost</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the planner's estimate of the cost of processing each
        operator or function executed during a query.
        The default is 0.0025.
       </para>
____________________________________________________________________________-->
       <para>
        设置规划器对于一次查询中处理每个操作符或函数的代价估计。默认值是 0.0025。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-parallel-setup-cost" xreflabel="parallel_setup_cost">
<!--==========================orignal english content==========================
      <term><varname>parallel_setup_cost</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>parallel_setup_cost</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>parallel_setup_cost</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>parallel_setup_cost</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the planner's estimate of the cost of launching parallel worker
        processes.
        The default is 1000.
       </para>
____________________________________________________________________________-->
       <para>
        设置规划器对启动并行工作者进程的代价估计。默认是 1000。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-parallel-tuple-cost" xreflabel="parallel_tuple_cost">
<!--==========================orignal english content==========================
      <term><varname>parallel_tuple_cost</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>parallel_tuple_cost</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>parallel_tuple_cost</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>parallel_tuple_cost</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the planner's estimate of the cost of transferring one tuple
        from a parallel worker process to another process.
        The default is 0.1.
       </para>
____________________________________________________________________________-->
       <para>
        设置规划器对于从一个并行工作者进程传递一个元组给另一个进程的代价估计。默认是 0.1。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-min-parallel-table-scan-size" xreflabel="min_parallel_table_scan_size">
<!--==========================orignal english content==========================
      <term><varname>min_parallel_table_scan_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>min_parallel_table_scan_size</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>min_parallel_table_scan_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>min_parallel_table_scan_size</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the minimum amount of table data that must be scanned in order
        for a parallel scan to be considered.  For a parallel sequential scan,
        the amount of table data scanned is always equal to the size of the
        table, but when indexes are used the amount of table data
        scanned will normally be less.
        If this value is specified without units, it is taken as blocks,
        that is <symbol>BLCKSZ</symbol> bytes, typically 8kB.
        The default is 8 megabytes (<literal>8MB</literal>).
       </para>
____________________________________________________________________________-->
       <para>
        为必须扫描的表数据量设置一个最小值，扫描的表数据量超过这一个值才会考虑使用并行扫描。
        对于并行顺序扫描，被扫描的表数据量总是等于表的尺寸，但是在使用索引时，被扫描的表数据量通常会更小。
        如果指定值时没有单位，则以块为单位，即<symbol>BLCKSZ</symbol>字节，通常为8kB。默认值是8兆字节（<literal>8MB</literal>）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-min-parallel-index-scan-size" xreflabel="min_parallel_index_scan_size">
<!--==========================orignal english content==========================
      <term><varname>min_parallel_index_scan_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>min_parallel_index_scan_size</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>min_parallel_index_scan_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>min_parallel_index_scan_size</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the minimum amount of index data that must be scanned in order
        for a parallel scan to be considered.  Note that a parallel index scan
        typically won't touch the entire index; it is the number of pages
        which the planner believes will actually be touched by the scan which
        is relevant.  This parameter is also used to decide whether a
        particular index can participate in a parallel vacuum.  See
        <xref linkend="sql-vacuum"/>.
        If this value is specified without units, it is taken as blocks,
        that is <symbol>BLCKSZ</symbol> bytes, typically 8kB.
        The default is 512 kilobytes (<literal>512kB</literal>).
       </para>
____________________________________________________________________________-->
       <para>
        为必须扫描的索引数据量设置一个最小值，扫描的索引数据量超过这一个值时才会考虑使用并行扫描。
        注意并行索引扫描通常并不会触及整个索引，它是规划器认为该扫描会实际用到的相关页面的数量。
        这个参数还用于决定特定的索引是否参与并行vacuum。参见<xref linkend="sql-vacuum"/>。
        如果指定值时没有单位，则以块为单位，即<symbol>BLCKSZ</symbol>字节，通常为8kB。默认值是512千字节（<literal>512kB</literal>）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-effective-cache-size" xreflabel="effective_cache_size">
<!--==========================orignal english content==========================
      <term><varname>effective_cache_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>effective_cache_size</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>effective_cache_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>effective_cache_size</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the planner's assumption about the effective size of the
        disk cache that is available to a single query.  This is
        factored into estimates of the cost of using an index; a
        higher value makes it more likely index scans will be used, a
        lower value makes it more likely sequential scans will be
        used. When setting this parameter you should consider both
        <productname>PostgreSQL</productname>'s shared buffers and the
        portion of the kernel's disk cache that will be used for
        <productname>PostgreSQL</productname> data files, though some
        data might exist in both places. Also, take
        into account the expected number of concurrent queries on different
        tables, since they will have to share the available
        space.  This parameter has no effect on the size of shared
        memory allocated by <productname>PostgreSQL</productname>, nor
        does it reserve kernel disk cache; it is used only for estimation
        purposes.  The system also does not assume data remains in
        the disk cache between queries.
        If this value is specified without units, it is taken as blocks,
        that is <symbol>BLCKSZ</symbol> bytes, typically 8kB.
        The default is 4 gigabytes (<literal>4GB</literal>).
        (If <symbol>BLCKSZ</symbol> is not 8kB, the default value scales
        proportionally to it.)
       </para>
____________________________________________________________________________-->
       <para>
        设置规划器对一个单一查询可用的有效磁盘缓冲区尺寸的假设。
        这个参数会被考虑在使用一个索引的代价估计中，更高的数值会使得索引扫描更可能被使用，更低的数值会使得顺序扫描更可能被使用。
        在设置这个参数时，你还应该考虑<productname>PostgreSQL</productname>的共享缓冲区以及将被用于<productname>PostgreSQL</productname>数据文件的内核磁盘缓冲区，尽管有些数据可能在两个地方都存在。
        另外，还要考虑预计在不同表上的并发查询数目，因为它们必须共享可用的空间。
        这个参数对<productname>PostgreSQL</productname>分配的共享内存尺寸没有影响，它也不会保留内核磁盘缓冲，它只用于估计的目的。系统也不会假设在查询之间数据会保留在磁盘缓冲中。
        如果指定值时没有单位，则以块为单位，即<symbol>BLCKSZ</symbol>字节，通常为8kB。
        默认值是 4吉字节（<literal>4GB</literal>）。(如果<symbol>BLCKSZ</symbol>不是8kB，默认值会按比例缩放它。)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-jit-above-cost" xreflabel="jit_above_cost">
<!--==========================orignal english content==========================
      <term><varname>jit_above_cost</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>jit_above_cost</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>jit_above_cost</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>jit_above_cost</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the query cost above which JIT compilation is activated, if
        enabled (see <xref linkend="jit"/>).
        Performing <acronym>JIT</acronym> costs planning time but can
        accelerate query execution.
        Setting this to <literal>-1</literal> disables JIT compilation.
        The default is <literal>100000</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        设置激活JIT编译的查询代价，如果查询代价超过这个值就会激活JIT编译（如果启用了JIT，见<xref linkend="jit"/>）。执行<acronym>JIT</acronym>会消耗一些规划时间，但是能够加速查询执行。将这个值设置为<literal>-1</literal>会禁用JIT编译。默认值是<literal>100000</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-jit-inline-above-cost" xreflabel="jit_inline_above_cost">
<!--==========================orignal english content==========================
      <term><varname>jit_inline_above_cost</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>jit_inline_above_cost</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>jit_inline_above_cost</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>jit_inline_above_cost</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the query cost above which JIT compilation attempts to inline
        functions and operators.  Inlining adds planning time, but can
        improve execution speed.  It is not meaningful to set this to less
        than <varname>jit_above_cost</varname>.
        Setting this to <literal>-1</literal> disables inlining.
        The default is <literal>500000</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        设置JIT编译尝试内联函数和操作符的查询代价阈值，如果查询代价超过这个值，JIT编译就会尝试内联。内联会增加规划时间，但是可以提高执行速度。将这个参数设置成小于<varname>jit_above_cost</varname>是没有意义的。将这个参数设置为<literal>-1</literal>会禁用内联。默认值是<literal>500000</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-jit-optimize-above-cost" xreflabel="jit_optimize_above_cost">
<!--==========================orignal english content==========================
      <term><varname>jit_optimize_above_cost</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>jit_optimize_above_cost</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>jit_optimize_above_cost</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>jit_optimize_above_cost</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the query cost above which JIT compilation applies expensive
        optimizations.  Such optimization adds planning time, but can improve
        execution speed.  It is not meaningful to set this to less
        than <varname>jit_above_cost</varname>, and it is unlikely to be
        beneficial to set it to more
        than <varname>jit_inline_above_cost</varname>.
        Setting this to <literal>-1</literal> disables expensive optimizations.
        The default is <literal>500000</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        设置JIT编译应用优化的查询代价阈值，如果查询代价超过这个值，JIT编译就会应用开销较大的优化。这类优化会增加规划时间，但是更能够改进执行速度。将这个参数设置成小于<varname>jit_above_cost</varname>是没有意义的，并且将它设置成大于<varname>jit_inline_above_cost</varname>也未必有益。将这个参数设置为<literal>-1</literal>会禁用开销较大的优化。默认值是<literal>500000</literal>。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>

    </sect2>
     <sect2 id="runtime-config-query-geqo">
<!--==========================orignal english content==========================
     <title>Genetic Query Optimizer</title>
____________________________________________________________________________-->
     <title>遗传查询优化</title>
<!--==========================orignal english content==========================
     <para>
      The genetic query optimizer (GEQO) is an algorithm that does query
      planning using heuristic searching.  This reduces planning time for
      complex queries (those joining many relations), at the cost of producing
      plans that are sometimes inferior to those found by the normal
      exhaustive-search algorithm.
      For more information see <xref linkend="geqo"/>.
     </para>
____________________________________________________________________________-->
     <para>
      GEQO是一个使用探索式搜索来执行查询规划的算法。它可以降低负载查询的规划时间。 同时，GEQO的检索是随机的，因此它的规划可能会不可确定。 更多信息参阅Chapter 50。
      遗传查询规划器（GEQO）是一种使用启发式搜索来进行查询规划的算法。它可以降低对于复杂查询（连接很多表的查询）的规划时间，但是代价是它产生的计划有时候要差于使用穷举搜索算法找到的计划。详见<xref linkend="geqo"/>。
     </para>

     <variablelist>

     <varlistentry id="guc-geqo" xreflabel="geqo">
<!--==========================orignal english content==========================
      <term><varname>geqo</varname> (<type>boolean</type>)
      <indexterm>
       <primary>genetic query optimization</primary>
      </indexterm>
      <indexterm>
       <primary>GEQO</primary>
       <see>genetic query optimization</see>
      </indexterm>
      <indexterm>
       <primary><varname>geqo</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>geqo</varname> (<type>boolean</type>)
      <indexterm>
       <primary>遗传查询优化</primary>
      </indexterm>
      <indexterm>
       <primary>GEQO</primary>
       <see>遗传查询优化</see>
      </indexterm>
      <indexterm>
       <primary><varname>geqo</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Enables or disables genetic query optimization.
        This is on by default.  It is usually best not to turn it off in
        production; the <varname>geqo_threshold</varname> variable provides
        more granular control of GEQO.
       </para>
____________________________________________________________________________-->
       <para>
        允许或禁止遗传查询优化。默认是启用。在生产环境中通常最好不要关闭它。<varname>geqo_threshold</varname>变量提供了对 GEQO 更细粒度的空值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-geqo-threshold" xreflabel="geqo_threshold">
<!--==========================orignal english content==========================
      <term><varname>geqo_threshold</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>geqo_threshold</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>geqo_threshold</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>geqo_threshold</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Use genetic query optimization to plan queries with at least
        this many <literal>FROM</literal> items involved. (Note that a
        <literal>FULL OUTER JOIN</literal> construct counts as only one <literal>FROM</literal>
        item.) The default is 12. For simpler queries it is usually best
        to use the regular, exhaustive-search planner, but for queries with
        many tables the exhaustive search takes too long, often
        longer than the penalty of executing a suboptimal plan.  Thus,
        a threshold on the size of the query is a convenient way to manage
        use of GEQO.
       </para>
____________________________________________________________________________-->
       <para>
        只有当涉及的<literal>FROM</literal>项数量至少有这么多个的时候，才使用遗传查询优化（注意一个<literal>FULL OUTER JOIN</literal>只被计为一个<literal>FROM</literal>项）。默认值是 12。对于更简单的查询，通常会使用普通的穷举搜索规划器，但是对于有很多表的查询穷举搜索会花很长时间，通常比执行一个次优的计划带来的惩罚值还要长。因此，在查询尺寸上的一个阈值是管理 GEQO 使用的一种方便的方法。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-geqo-effort" xreflabel="geqo_effort">
<!--==========================orignal english content==========================
      <term><varname>geqo_effort</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>geqo_effort</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>geqo_effort</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>geqo_effort</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Controls the trade-off between planning time and query plan
        quality in GEQO. This variable must be an integer in the
        range from 1 to 10. The default value is five. Larger values
        increase the time spent doing query planning, but also
        increase the likelihood that an efficient query plan will be
        chosen.
       </para>
____________________________________________________________________________-->
       <para>
        控制 GEQO 里规划时间和查询规划的有效性之间的平衡。这个变量必须是 一个范围从 1 到 10 的整数。缺省值是 5 。大的数值增加花在进行查询 规划上面的时间，但是也很可能会提高选中更有效的查询规划的几率。
        控制 GEQO 中规划时间和查询计划质量之间的折中。这个变量必须是位于 1 到 10 之间的一个整数。默认值是 5。更大的值会增加花在查询规划上的时间，但是同时也增加了选择一个高效查询计划的可能性。
       </para>

<!--==========================orignal english content==========================
       <para>
        <varname>geqo_effort</varname> doesn't actually do anything
        directly; it is only used to compute the default values for
        the other variables that influence GEQO behavior (described
        below). If you prefer, you can set the other parameters by
        hand instead.
       </para>
____________________________________________________________________________-->
       <para>
        <varname>geqo_effort</varname>实际并不直接做任何事情；它只是被用来计算其他影响 GEQO 行为的变量（如下所述）的默认值。如果你愿意，你可以手工设置其他参数。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-geqo-pool-size" xreflabel="geqo_pool_size">
<!--==========================orignal english content==========================
      <term><varname>geqo_pool_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>geqo_pool_size</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>geqo_pool_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>geqo_pool_size</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Controls the pool size used by GEQO, that is the
        number of individuals in the genetic population.  It must be
        at least two, and useful values are typically 100 to 1000.  If
        it is set to zero (the default setting) then a suitable
        value is chosen based on <varname>geqo_effort</varname> and
        the number of tables in the query.
       </para>
____________________________________________________________________________-->
       <para>
        控制 GEQO 使用的池尺寸，它就是遗传种群中的个体数目。它必须至少为 2，且有用的值通常在 100 到 1000 之间。如果它被设置为零（默认设置）则会基于<varname>geqo_effort</varname>和查询中表的数量选择一个合适的值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-geqo-generations" xreflabel="geqo_generations">
<!--==========================orignal english content==========================
      <term><varname>geqo_generations</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>geqo_generations</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>geqo_generations</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>geqo_generations</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Controls the number of generations used by GEQO, that is
        the number of iterations of the algorithm.  It must
        be at least one, and useful values are in the same range as
        the pool size.  If it is set to zero (the default setting)
        then a suitable value is chosen based on
        <varname>geqo_pool_size</varname>.
       </para>
____________________________________________________________________________-->
       <para>
        控制 GEQO 使用的子代数目。子代的意思是算法的迭代次数。它必须至少 是 1 ，有用的值范围和池大小相同。如果设置为零(缺省)，那么将基于 geqo_pool_size选取合适的值。
        控制 GEQO 使用的代数，也是算法的迭代次数。它必须至少为 1，并且有用值的范围和池尺寸相同。如果它被设置为零（默认设置）则会基于<varname>geqo_pool_size</varname>选择一个合适的值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-geqo-selection-bias" xreflabel="geqo_selection_bias">
<!--==========================orignal english content==========================
      <term><varname>geqo_selection_bias</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>geqo_selection_bias</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>geqo_selection_bias</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>geqo_selection_bias</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Controls the selection bias used by GEQO. The selection bias
        is the selective pressure within the population. Values can be
        from 1.50 to 2.00; the latter is the default.
       </para>
____________________________________________________________________________-->
       <para>
        控制 GEQO 使用的选择偏好。选择偏好是种群中的选择压力。值可以是 1.5 到 2.0 之间，后者是默认值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-geqo-seed" xreflabel="geqo_seed">
<!--==========================orignal english content==========================
      <term><varname>geqo_seed</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>geqo_seed</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>geqo_seed</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>geqo_seed</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Controls the initial value of the random number generator used
        by GEQO to select random paths through the join order search space.
        The value can range from zero (the default) to one.  Varying the
        value changes the set of join paths explored, and may result in a
        better or worse best path being found.
       </para>
____________________________________________________________________________-->
       <para>
        控制 GEQO 使用的随机数生成器的初始值，随机数生成器用于在连接顺序搜索空间中选择随机路径。该值可以从 0 （默认值）到 1。变化该值会改变被探索的连接路径集合，并且可能导致找到一个更好或更差的路径。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect2>
     <sect2 id="runtime-config-query-other">
<!--==========================orignal english content==========================
     <title>Other Planner Options</title>
____________________________________________________________________________-->
     <title>其他规划器选项</title>

     <variablelist>

     <varlistentry id="guc-default-statistics-target" xreflabel="default_statistics_target">
<!--==========================orignal english content==========================
      <term><varname>default_statistics_target</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>default_statistics_target</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>default_statistics_target</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>default_statistics_target</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the default statistics target for table columns without
        a column-specific target set via <command>ALTER TABLE
        SET STATISTICS</command>.  Larger values increase the time needed to
        do <command>ANALYZE</command>, but might improve the quality of the
        planner's estimates. The default is 100. For more information
        on the use of statistics by the <productname>PostgreSQL</productname>
        query planner, refer to <xref linkend="planner-stats"/>.
       </para>
____________________________________________________________________________-->
       <para>
        为没有通过<command>ALTER TABLE SET STATISTICS</command>设置列相关目标的表列设置默认统计目标。更大的值增加了需要做<command>ANALYZE</command>的时间，但是可能会改善规划器的估计质量。默认值是 100。有关<productname>PostgreSQL</productname>查询规划器使用的统计信息的更多内容， 请参考<xref linkend="planner-stats"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-constraint-exclusion" xreflabel="constraint_exclusion">
<!--==========================orignal english content==========================
      <term><varname>constraint_exclusion</varname> (<type>enum</type>)
      <indexterm>
       <primary>constraint exclusion</primary>
      </indexterm>
      <indexterm>
       <primary><varname>constraint_exclusion</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>constraint_exclusion</varname> (<type>enum</type>)
      <indexterm>
       <primary>constraint exclusion</primary>
      </indexterm>
      <indexterm>
       <primary><varname>constraint_exclusion</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Controls the query planner's use of table constraints to
        optimize queries.
        The allowed values of <varname>constraint_exclusion</varname> are
        <literal>on</literal> (examine constraints for all tables),
        <literal>off</literal> (never examine constraints), and
        <literal>partition</literal> (examine constraints only for inheritance
        child tables and <literal>UNION ALL</literal> subqueries).
        <literal>partition</literal> is the default setting.
        It is often used with traditional inheritance trees to improve
        performance.
      </para>
____________________________________________________________________________-->
       <para>
        控制查询规划器对表约束的使用，以优化查询。
        <varname>constraint_exclusion</varname>的允许值是<literal>on</literal>（对所有表检查约束）、<literal>off</literal>（从不检查约束）和<literal>partition</literal>（只对继承的子表和<literal>UNION ALL</literal>子查询检查约束）。
        <literal>partition</literal>是默认设置。它通常与传统的继承树一起使用来提高性能。
      </para>

<!--==========================orignal english content==========================
       <para>
        When this parameter allows it for a particular table, the planner
        compares query conditions with the table's <literal>CHECK</literal>
        constraints, and omits scanning tables for which the conditions
        contradict the constraints.  For example:

<programlisting>
CREATE TABLE parent(key integer, ...);
CREATE TABLE child1000(check (key between 1000 and 1999)) INHERITS(parent);
CREATE TABLE child2000(check (key between 2000 and 2999)) INHERITS(parent);
...
SELECT * FROM parent WHERE key = 2400;
</programlisting>

        With constraint exclusion enabled, this <command>SELECT</command>
        will not scan <structname>child1000</structname> at all, improving performance.
       </para>
____________________________________________________________________________-->
       <para>
        当对一个特定表允许这个参数，规划器比较查询条件和表的<literal>CHECK</literal>约束，并且忽略那些条件违反约束的表扫描。例如：

<programlisting>
CREATE TABLE parent(key integer, ...);
CREATE TABLE child1000(check (key between 1000 and 1999)) INHERITS(parent);
CREATE TABLE child2000(check (key between 2000 and 2999)) INHERITS(parent);
...
SELECT * FROM parent WHERE key = 2400;
</programlisting>

        在启用约束排除时，这个<command>SELECT</command>将完全不会扫描<structname>child1000</structname>，从而提高性能。
       </para>

<!--==========================orignal english content==========================
       <para>
        Currently, constraint exclusion is enabled by default
        only for cases that are often used to implement table partitioning via
        inheritance trees.  Turning it on for all tables imposes extra
        planning overhead that is quite noticeable on simple queries, and most
        often will yield no benefit for simple queries.  If you have no
        tables that are partitioned using traditional inheritance, you might
        prefer to turn it off entirely.  (Note that the equivalent feature for
        partitioned tables is controlled by a separate parameter,
        <xref linkend="guc-enable-partition-pruning"/>.)
       </para>
____________________________________________________________________________-->
       <para>
        目前，约束排除只在通过继承树实现表分区的情况中被默认启用。为所有表启用它会增加额外的规划开销，特别是在简单查询上并且不会产生任何好处。
        如果没有用传统继承树分区的表时，最好是完全关闭它。(注意分区表的等效特性是由单独的参数控制的，<xref linkend="guc-enable-partition-pruning"/>.)
       </para>

<!--==========================orignal english content==========================
       <para>
        Refer to <xref linkend="ddl-partitioning-constraint-exclusion"/> for
        more information on using constraint exclusion to implement
        partitioning.
       </para>
____________________________________________________________________________-->
       <para>
        更多关于使用约束排除实现分区的信息请参阅<xref linkend="ddl-partitioning-constraint-exclusion"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-cursor-tuple-fraction" xreflabel="cursor_tuple_fraction">
<!--==========================orignal english content==========================
      <term><varname>cursor_tuple_fraction</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>cursor_tuple_fraction</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>cursor_tuple_fraction</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>cursor_tuple_fraction</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the planner's estimate of the fraction of a cursor's rows that
        will be retrieved.  The default is 0.1.  Smaller values of this
        setting bias the planner towards using <quote>fast start</quote> plans
        for cursors, which will retrieve the first few rows quickly while
        perhaps taking a long time to fetch all rows.  Larger values
        put more emphasis on the total estimated time.  At the maximum
        setting of 1.0, cursors are planned exactly like regular queries,
        considering only the total estimated time and not how soon the
        first rows might be delivered.
       </para>
____________________________________________________________________________-->
       <para>
        设置规划器对将被检索的一个游标的行的比例的估计。默认值是 0.1。更小的值使得规划器偏向为游标使用<quote>快速开始</quote>计划，它将很快地检索前几行但是可能需要很长时间来获取所有行。更大的值强调总的估计时间。最大设置为 1.0，游标将和普通查询完全一样地被规划，只考虑总估计时间并且不考虑前几行会被多快地返回。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-from-collapse-limit" xreflabel="from_collapse_limit">
<!--==========================orignal english content==========================
      <term><varname>from_collapse_limit</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>from_collapse_limit</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>from_collapse_limit</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>from_collapse_limit</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The planner will merge sub-queries into upper queries if the
        resulting <literal>FROM</literal> list would have no more than
        this many items.  Smaller values reduce planning time but might
        yield inferior query plans.  The default is eight.
        For more information see <xref linkend="explicit-joins"/>.
       </para>
____________________________________________________________________________-->
       <para>
        如果生成的<literal>FROM</literal>列表不超过这么多项，规划器将把子查询融合到上层查询。较小的值可以减少规划时间，但是可能 会生成较差的查询计划。默认值是 8。详见<xref linkend="explicit-joins"/>。
       </para>

<!--==========================orignal english content==========================
       <para>
        Setting this value to <xref linkend="guc-geqo-threshold"/> or more
        may trigger use of the GEQO planner, resulting in non-optimal
        plans.  See <xref linkend="runtime-config-query-geqo"/>.
       </para>
____________________________________________________________________________-->
       <para>
        将这个值设置为<xref linkend="guc-geqo-threshold"/>或更大，可能触发使用 GEQO 规划器，从而产生非最优计划。见<xref linkend="runtime-config-query-geqo"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-jit" xreflabel="jit">
<!--==========================orignal english content==========================
      <term><varname>jit</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>jit</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>jit</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>jit</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Determines whether <acronym>JIT</acronym> compilation may be used by
        <productname>PostgreSQL</productname>, if available (see <xref
        linkend="jit"/>).
        The default is <literal>on</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        决定如果可用（见<xref linkend="jit"/>），<productname>PostgreSQL</productname>是否可以使用<acronym>JIT</acronym>编译。默认值是<literal>on</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-join-collapse-limit" xreflabel="join_collapse_limit">
<!--==========================orignal english content==========================
      <term><varname>join_collapse_limit</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>join_collapse_limit</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>join_collapse_limit</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>join_collapse_limit</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The planner will rewrite explicit <literal>JOIN</literal>
        constructs (except <literal>FULL JOIN</literal>s) into lists of
        <literal>FROM</literal> items whenever a list of no more than this many items
        would result.  Smaller values reduce planning time but might
        yield inferior query plans.
       </para>
____________________________________________________________________________-->
       <para>
        如果得出的列表中不超过这么多项，那么规划器将把显式<literal>JOIN</literal>（除了<literal>FULL JOIN</literal>）结构重写到 <literal>FROM</literal>项列表中。较小的值可减少规划时间，但是可能会生成差些的查询计划。
       </para>

<!--==========================orignal english content==========================
       <para>
        By default, this variable is set the same as
        <varname>from_collapse_limit</varname>, which is appropriate
        for most uses. Setting it to 1 prevents any reordering of
        explicit <literal>JOIN</literal>s. Thus, the explicit join order
        specified in the query will be the actual order in which the
        relations are joined. Because the query planner does not always choose
        the optimal join order, advanced users can elect to
        temporarily set this variable to 1, and then specify the join
        order they desire explicitly.
        For more information see <xref linkend="explicit-joins"/>.
       </para>
____________________________________________________________________________-->
       <para>
        默认情况下，这个变量被设置成和<varname>from_collapse_limit</varname>相同， 这样适合大多数使用。把它设置为 1 可避免任何显式<literal>JOIN</literal>的重排序。因此查询中指定的显式连接顺序就是关系被连接的实际顺序。因为查询规划器并不是总能 选取最优的连接顺序，高级用户可以选择暂时把这个变量设置为 1，然后显式地指定他们想要的连接顺序。更多信息请见<xref linkend="explicit-joins"/>。
       </para>

<!--==========================orignal english content==========================
       <para>
        Setting this value to <xref linkend="guc-geqo-threshold"/> or more
        may trigger use of the GEQO planner, resulting in non-optimal
        plans.  See <xref linkend="runtime-config-query-geqo"/>.
       </para>
____________________________________________________________________________-->
       <para>
        将这个值设置为<xref linkend="guc-geqo-threshold"/>或更大，可能触发使用 GEQO 规划器，从而产生非最优计划。见<xref linkend="runtime-config-query-geqo"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-plan-cache_mode" xreflabel="plan_cache_mode">
<!--==========================orignal english content==========================
      <term><varname>plan_cache_mode</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>plan_cache_mode</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>plan_cache_mode</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>plan_cache_mode</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Prepared statements (either explicitly prepared or implicitly
        generated, for example by PL/pgSQL) can be executed using custom or
        generic plans.  Custom plans are made afresh for each execution
        using its specific set of parameter values, while generic plans do
        not rely on the parameter values and can be re-used across
        executions.  Thus, use of a generic plan saves planning time, but if
        the ideal plan depends strongly on the parameter values then a
        generic plan may be inefficient.  The choice between these options
        is normally made automatically, but it can be overridden
        with <varname>plan_cache_mode</varname>.
        The allowed values are <literal>auto</literal> (the default),
        <literal>force_custom_plan</literal> and
        <literal>force_generic_plan</literal>.
        This setting is considered when a cached plan is to be executed,
        not when it is prepared.
        For more information see <xref linkend="sql-prepare"/>.
       </para>
____________________________________________________________________________-->
       <para>
        准备语句（显式准备或隐式生成的，例如 PL/pgSQL）可以使用自定义或通用计划执行。 
        使用其特定的参数值集为每个执行重新生成自定义计划，而通用计划不依赖于参数值，并且可以在执行中重复使用。 
        因此，使用通用计划可以节省计划时间，但如果理想计划严重依赖参数值，则通用计划可能效率低下。
        这些选项之间的选择通常是自动进行的，但可以通过<varname>plan_cache_mode</varname>覆盖它。
        允许的值为 <literal>auto</literal> (默认的),<literal>force_custom_plan</literal> 和 <literal>force_generic_plan</literal>。
        这个设置是在执行缓存计划时考虑，而不是在准备计划时考虑。
        更多信息请参阅 <xref linkend="sql-prepare"/>.
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect2>
   </sect1>

   <sect1 id="runtime-config-logging">
<!--==========================orignal english content==========================
    <title>Error Reporting and Logging</title>
____________________________________________________________________________-->
    <title>错误报告和日志</title>
<!--==========================orignal english content==========================
    <indexterm zone="runtime-config-logging">
     <primary>server log</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm zone="runtime-config-logging">
     <primary>服务器日志</primary>
    </indexterm>

    <sect2 id="runtime-config-logging-where">
<!--==========================orignal english content==========================
     <title>Where to Log</title>
____________________________________________________________________________-->
     <title>在哪里做日志</title>
<!--==========================orignal english content==========================
     <indexterm zone="runtime-config-logging-where">
      <primary>where to log</primary>
     </indexterm>
____________________________________________________________________________-->
     <indexterm zone="runtime-config-logging-where">
      <primary>where to log</primary>
     </indexterm>

<!--==========================orignal english content==========================
     <indexterm>
       <primary>current_logfiles</primary>
       <secondary>and the log_destination configuration parameter</secondary>
     </indexterm>
____________________________________________________________________________-->
     <indexterm>
       <primary>current_logfiles</primary>
       <secondary>and the log_destination configuration parameter</secondary>
     </indexterm>

     <variablelist>

     <varlistentry id="guc-log-destination" xreflabel="log_destination">
<!--==========================orignal english content==========================
      <term><varname>log_destination</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>log_destination</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>log_destination</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>log_destination</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        <productname>PostgreSQL</productname> supports several methods
         for logging server messages, including
         <systemitem>stderr</systemitem>, <systemitem>csvlog</systemitem> and
         <systemitem>syslog</systemitem>. On Windows,
         <systemitem>eventlog</systemitem> is also supported. Set this
         parameter to a list of desired log destinations separated by
         commas. The default is to log to <systemitem>stderr</systemitem>
         only.
         This parameter can only be set in the <filename>postgresql.conf</filename>
         file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        <productname>PostgreSQL</productname>支持多种方法来记录服务器消息，包括<systemitem>stderr</systemitem>、<systemitem>csvlog</systemitem>和<systemitem>syslog</systemitem>。在 Windows 上还支持<systemitem>eventlog</systemitem>。设置这个参数为一个由想要的日志目的地的列表，之间用逗号分隔。默认值是只记录到<systemitem>stderr</systemitem>。这个参数只能在<filename>postgresql.conf</filename>文件中或在服务器命令行上设置。
       </para>
<!--==========================orignal english content==========================
       <para>
        If <systemitem>csvlog</systemitem> is included in <varname>log_destination</varname>,
        log entries are output in <quote>comma separated
        value</quote> (<acronym>CSV</acronym>) format, which is convenient for
        loading logs into programs.
        See <xref linkend="runtime-config-logging-csvlog"/> for details.
        <xref linkend="guc-logging-collector"/> must be enabled to generate
        CSV-format log output.
       </para>
____________________________________________________________________________-->
       <para>
        如果<systemitem>csvlog</systemitem>被包括在<varname>log_destination</varname>中，日志项会以<quote>逗号分隔值</quote> （<acronym>CSV</acronym>）格式被输出，这样可以很方便地把日志载入到程序中。详见<xref linkend="runtime-config-logging-csvlog"/>。要产生 CSV 格式的日志输出，必须启用<xref linkend="guc-logging-collector"/>。
       </para>
<!--==========================orignal english content==========================
       <para>
        When either <systemitem>stderr</systemitem> or
        <systemitem>csvlog</systemitem> are included, the file
        <filename>current_logfiles</filename> is created to record the location
        of the log file(s) currently in use by the logging collector and the
        associated logging destination. This provides a convenient way to
        find the logs currently in use by the instance. Here is an example of
        this file's content:
<programlisting>
stderr log/postgresql.log
csvlog log/postgresql.csv
</programlisting>

        <filename>current_logfiles</filename> is recreated when a new log file
        is created as an effect of rotation, and
        when <varname>log_destination</varname> is reloaded.  It is removed when
        neither <systemitem>stderr</systemitem>
        nor <systemitem>csvlog</systemitem> are included
        in <varname>log_destination</varname>, and when the logging collector is
        disabled.
       </para>
____________________________________________________________________________-->
       <para>
        当包括有<systemitem>stderr</systemitem>或<systemitem>csvlog</systemitem>时，会创建文件<filename>current_logfiles</filename>来记录当前正在被日志收集器使用的日志文件的位置以及相关的日志目的地。这提供了一种查找实例当前使用的日志的便利手段。这里是该文件内容的一个例子：
<programlisting>
stderr log/postgresql.log
csvlog log/postgresql.csv
</programlisting>

        当由于轮转效应创建一个新的日志文件时以及<varname>log_destination</varname>被重载时，<filename>current_logfiles</filename>文件会被重建。当<varname>log_destination</varname>中不包括<systemitem>stderr</systemitem>和<systemitem>csvlog</systemitem>时以及当日志收集器被禁用时，这个文件会被删除。
       </para>

       <note>
<!--==========================orignal english content==========================
        <para>
         On most Unix systems, you will need to alter the configuration of
         your system's <application>syslog</application> daemon in order
         to make use of the <systemitem>syslog</systemitem> option for
         <varname>log_destination</varname>.  <productname>PostgreSQL</productname>
         can log to <application>syslog</application> facilities
         <literal>LOCAL0</literal> through <literal>LOCAL7</literal> (see <xref
         linkend="guc-syslog-facility"/>), but the default
         <application>syslog</application> configuration on most platforms
         will discard all such messages.  You will need to add something like:
<programlisting>
local0.*    /var/log/postgresql
</programlisting>
         to the  <application>syslog</application> daemon's configuration file
         to make it work.
        </para>
____________________________________________________________________________-->
        <para>
         在大多数 Unix 系统上，你将需要修改系统的<application>syslog</application>守护进程的配置来使用<varname>log_destination</varname>的<systemitem>syslog</systemitem>选项。<productname>PostgreSQL</productname>可以在<application>syslog</application>设备<literal>LOCAL0</literal>到<literal>LOCAL7</literal>中记录（见<xref linkend="guc-syslog-facility"/>），但是大部分平台上的默认<application>syslog</application>配置会丢弃所有这种消息。你将需要增加这样的内容：
<programlisting>
local0.*    /var/log/postgresql
</programlisting>
         到<application>syslog</application>守护进程的配置文件来让它工作。
        </para>
<!--==========================orignal english content==========================
        <para>
         On Windows, when you use the <literal>eventlog</literal>
         option for <varname>log_destination</varname>, you should
         register an event source and its library with the operating
         system so that the Windows Event Viewer can display event
         log messages cleanly.
         See <xref linkend="event-log-registration"/> for details.
        </para>
____________________________________________________________________________-->
        <para>
         在 Windows 上，当你使用<varname>log_destination</varname>的<literal>eventlog</literal>选项时，你应该在操作系统中注册一个事件源极其库，这样 Windows 事件查看器能够清楚地显示事件日志消息。详见<xref linkend="event-log-registration"/>。
        </para>
       </note>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-logging-collector" xreflabel="logging_collector">
<!--==========================orignal english content==========================
      <term><varname>logging_collector</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>logging_collector</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>logging_collector</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>logging_collector</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
         This parameter enables the <firstterm>logging collector</firstterm>, which
         is a background process that captures log messages
         sent to <systemitem>stderr</systemitem> and redirects them into log files.
         This approach is often more useful than
         logging to <application>syslog</application>, since some types of messages
         might not appear in <application>syslog</application> output.  (One common
         example is dynamic-linker failure messages; another is error messages
         produced by scripts such as <varname>archive_command</varname>.)
         This parameter can only be set at server start.
       </para>
____________________________________________________________________________-->
       <para>
         这个参数启用<firstterm>日志收集器</firstterm>，它是一个捕捉被发送到<systemitem>stderr</systemitem>的日志消息的后台进程，并且它会将这些消息重定向到日志文件中。这种方法比记录到<application>syslog</application>通常更有用，因为某些类型的消息不会在<application>syslog</application>输出中出现（一个常见的例子是动态链接器错误消息；另一个例子是由<varname>archive_command</varname>等脚本产生的错误消息）。这个参数只能在服务器启动时设置。
       </para>

       <note>
<!--==========================orignal english content==========================
        <para>
         It is possible to log to <systemitem>stderr</systemitem> without using the
         logging collector; the log messages will just go to wherever the
         server's <systemitem>stderr</systemitem> is directed.  However, that method is
         only suitable for low log volumes, since it provides no convenient
         way to rotate log files.  Also, on some platforms not using the
         logging collector can result in lost or garbled log output, because
         multiple processes writing concurrently to the same log file can
         overwrite each other's output.
        </para>
____________________________________________________________________________-->
        <para>
         也可以不使用日志收集器而把日志记录到<systemitem>stderr</systemitem>，日志消息将只会去到服务器的<systemitem>stderr</systemitem>被定向到的位置。不过，那种方法只适合于低日志量，因为它没有提供方法来轮转日志文件。还有，在某些不使用日志收集器的平台上可能会导致丢失或者混淆日志输出，因为多个进程并发写入同一个日志文件时会覆盖彼此的输出。
        </para>
       </note>

       <note>
<!--==========================orignal english content==========================
        <para>
          The logging collector is designed to never lose messages.  This means
          that in case of extremely high load, server processes could be
          blocked while trying to send additional log messages when the
          collector has fallen behind.  In contrast, <application>syslog</application>
          prefers to drop messages if it cannot write them, which means it
          may fail to log some messages in such cases but it will not block
          the rest of the system.
        </para>
____________________________________________________________________________-->
        <para>
          日志收集器被设计成从来不会丢失消息。这意味着在极高的负载下，如果服务器进程试图在收集器已经落后时发送更多的日志消息，那么它会被阻塞。相反，<application>syslog</application>倾向于在无法写入消息时丢掉消息，这意味着在这样的情况下它可能会无法记录某些消息，但是它不会阻塞系统的其他部分。
        </para>
       </note>

      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-directory" xreflabel="log_directory">
<!--==========================orignal english content==========================
      <term><varname>log_directory</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>log_directory</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>log_directory</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>log_directory</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        When <varname>logging_collector</varname> is enabled,
        this parameter determines the directory in which log files will be created.
        It can be specified as an absolute path, or relative to the
        cluster data directory.
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
        The default is <literal>log</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        当<varname>logging_collector</varname>被启用时，这个参数决定日志文件将被在哪个目录下创建。它可以被指定为一个绝对路径，也可以被指定为一个相对于集簇数据目录的相对路径。这个参数只能在<filename>postgresql.conf</filename>文件中或在服务器命令行上设置。
        默认是<literal>log</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-filename" xreflabel="log_filename">
<!--==========================orignal english content==========================
      <term><varname>log_filename</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>log_filename</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>log_filename</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>log_filename</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        When <varname>logging_collector</varname> is enabled,
        this parameter sets the file names of the created log files.  The value
        is treated as a <function>strftime</function> pattern,
        so <literal>%</literal>-escapes can be used to specify time-varying
        file names.  (Note that if there are
        any time-zone-dependent <literal>%</literal>-escapes, the computation
        is done in the zone specified
        by <xref linkend="guc-log-timezone"/>.)
        The supported <literal>%</literal>-escapes are similar to those
        listed in the Open Group's <ulink
        url="https://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html">strftime
        </ulink> specification.
        Note that the system's <function>strftime</function> is not used
        directly, so platform-specific (nonstandard) extensions do not work.
        The default is <literal>postgresql-%Y-%m-%d_%H%M%S.log</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        当<varname>logging_collector</varname>被启用时，这个参数设置被创建的日志文件的文件名。
        该值被视为一种<function>strftime</function>模式，因此<literal>%</literal>转义可以被用来指定根据时间变化的文件名（注意如果有任何时区独立的<literal>%</literal>转义，计算将在由<xref linkend="guc-log-timezone"/>指定的时区中完成）。
        被支持的<literal>%</literal>转义和开放组织的<ulink url="https://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html">strftime</ulink>说明中列举的类似。
        注意系统的<function>strftime</function>不会被直接使用，因此平台相关（非标准）的扩展无法工作。
        默认是<literal>postgresql-%Y-%m-%d_%H%M%S.log</literal>。
       </para>
<!--==========================orignal english content==========================
       <para>
        If you specify a file name without escapes, you should plan to
        use a log rotation utility to avoid eventually filling the
        entire disk.  In releases prior to 8.4, if
        no <literal>%</literal> escapes were
        present, <productname>PostgreSQL</productname> would append
        the epoch of the new log file's creation time, but this is no
        longer the case.
       </para>
____________________________________________________________________________-->
       <para>
        如果你不使用转义来指定一个文件名，你应该计划使用一个日志轮转工具来避免最终填满整个磁盘。在 8.4 发行之前，如果不存在<literal>%</literal>转义，<productname>PostgreSQL</productname>将追加新日志文件创建时间的纪元，但是现在已经不再这样做了。
       </para>
<!--==========================orignal english content==========================
       <para>
        If CSV-format output is enabled in <varname>log_destination</varname>,
        <literal>.csv</literal> will be appended to the timestamped
        log file name to create the file name for CSV-format output.
        (If <varname>log_filename</varname> ends in <literal>.log</literal>, the suffix is
        replaced instead.)
       </para>
____________________________________________________________________________-->
       <para>
        如果在<varname>log_destination</varname>中启用了 CSV 格式输出，<literal>.csv</literal>将会被追加到时间戳日志文件名中来创建 CSV 格式输出（如果<varname>log_filename</varname>以<literal>.log</literal>结尾，该后缀会被替换）。
       </para>
<!--==========================orignal english content==========================
       <para>
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数只能在<filename>postgresql.conf</filename>文件中或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-file-mode" xreflabel="log_file_mode">
<!--==========================orignal english content==========================
      <term><varname>log_file_mode</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>log_file_mode</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>log_file_mode</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>log_file_mode</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        On Unix systems this parameter sets the permissions for log files
        when <varname>logging_collector</varname> is enabled. (On Microsoft
        Windows this parameter is ignored.)
        The parameter value is expected to be a numeric mode
        specified in the format accepted by the
        <function>chmod</function> and <function>umask</function>
        system calls.  (To use the customary octal format the number
        must start with a <literal>0</literal> (zero).)
       </para>
____________________________________________________________________________-->
       <para>
        在 Unix 系统上，当<varname>logging_collector</varname>被启用时，这个参数设置日志文件的权限（在微软 Windows 上这个参数将被忽略）。这个参数值应当是一个数字形式的模式，它可以被<function>chmod</function>和<function>umask</function>系统调用接受（要使用通常的十进制格式，该数字必须以一个<literal>0</literal>（零）开始）。
       </para>
<!--==========================orignal english content==========================
       <para>
        The default permissions are <literal>0600</literal>, meaning only the
        server owner can read or write the log files.  The other commonly
        useful setting is <literal>0640</literal>, allowing members of the owner's
        group to read the files.  Note however that to make use of such a
        setting, you'll need to alter <xref linkend="guc-log-directory"/> to
        store the files somewhere outside the cluster data directory.  In
        any case, it's unwise to make the log files world-readable, since
        they might contain sensitive data.
       </para>
____________________________________________________________________________-->
       <para>
        默认的权限是<literal>0600</literal>，表示只有服务器拥有者才能读取或写入日志文件。其他常用的设置是<literal>0640</literal>，它允许拥有者的组成员读取文件。不过要注意你需要修改<xref linkend="guc-log-directory"/>为将文件存储在集簇数据目录之外的某个位置，才能利用这个设置。在任何情况下，让日志文件变成任何人都可读是不明智的，因为日志文件中可能包含敏感数据。
       </para>
<!--==========================orignal english content==========================
       <para>
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数只能在<filename>postgresql.conf</filename>文件中或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-rotation-age" xreflabel="log_rotation_age">
<!--==========================orignal english content==========================
      <term><varname>log_rotation_age</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>log_rotation_age</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>log_rotation_age</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>log_rotation_age</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        When <varname>logging_collector</varname> is enabled,
        this parameter determines the maximum amount of time to use an
        individual log file, after which a new log file will be created.
        If this value is specified without units, it is taken as minutes.
        The default is 24 hours.
        Set to zero to disable time-based creation of new log files.
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        当<varname>logging_collector</varname>被启用时，这个参数决定使用一个单个日志文件的最大时间量，之后将创立一个新的日志文件。
        如果指定值时没有单位，则以分钟为单位。默认为24小时。
        将这个参数设置为零将禁用基于时间的新日志文件创建。这个参数只能在<filename>postgresql.conf</filename>文件中或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-rotation-size" xreflabel="log_rotation_size">
<!--==========================orignal english content==========================
      <term><varname>log_rotation_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>log_rotation_size</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>log_rotation_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>log_rotation_size</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        When <varname>logging_collector</varname> is enabled,
        this parameter determines the maximum size of an individual log file.
        After this amount of data has been emitted into a log file,
        a new log file will be created.
        If this value is specified without units, it is taken as kilobytes.
        The default is 10 megabytes.
        Set to zero to disable size-based creation of new log files.
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        当<varname>logging_collector</varname>被启用时，这个参数决定一个个体日志文件的最大尺寸。
        当这些数据量被发送到一个日志文件后，将创建一个新的日志文件。
        如果指定值的时候没有单位，则以千字节为单位。默认值是10兆字节。设置为零时将禁用基于大小创建新的日志文件。
        这个参数只能在<filename>postgresql.conf</filename>文件中或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-truncate-on-rotation" xreflabel="log_truncate_on_rotation">
<!--==========================orignal english content==========================
      <term><varname>log_truncate_on_rotation</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_truncate_on_rotation</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>log_truncate_on_rotation</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_truncate_on_rotation</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        When <varname>logging_collector</varname> is enabled,
        this parameter will cause <productname>PostgreSQL</productname> to truncate (overwrite),
        rather than append to, any existing log file of the same name.
        However, truncation will occur only when a new file is being opened
        due to time-based rotation, not during server startup or size-based
        rotation.  When off, pre-existing files will be appended to in
        all cases.  For example, using this setting in combination with
        a <varname>log_filename</varname> like <literal>postgresql-%H.log</literal>
        would result in generating twenty-four hourly log files and then
        cyclically overwriting them.
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        当<varname>logging_collector</varname>被启用时，这个参数将导致<productname>PostgreSQL</productname>截断（覆盖而不是追加）任何已有的同名日志文件。不过，截断只在一个新文件由于基于时间的轮转被打开时发生，在服务器启动或基于尺寸的轮转时不会发生。如果被关闭，在所有情况下以前存在的文件将被追加。例如，使用这个设置和一个类似<literal>postgresql-%H.log</literal>的<varname>log_filename</varname>将导致产生 24 个每小时的日志文件，并且循环地覆盖它们。这个参数只能在<filename>postgresql.conf</filename>文件中或在服务器命令行上设置。
       </para>
<!--==========================orignal english content==========================
       <para>
        Example:  To keep 7 days of logs, one log file per day named
        <literal>server_log.Mon</literal>, <literal>server_log.Tue</literal>,
        etc, and automatically overwrite last week's log with this week's log,
        set <varname>log_filename</varname> to <literal>server_log.%a</literal>,
        <varname>log_truncate_on_rotation</varname> to <literal>on</literal>, and
        <varname>log_rotation_age</varname> to <literal>1440</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        例子：要保留 7 天的日志，每天的一个日志文件被命令为<literal>server_log.Mon</literal>、<literal>server_log.Tue</literal>等等，并且自动用本周的日志覆盖上一周的日志。可以这样做：将<varname>log_filename</varname>设置为<literal>server_log.%a</literal>、将<varname>log_truncate_on_rotation</varname>设置为<literal>on</literal>并且将<varname>log_rotation_age</varname>设置为<literal>1440</literal>。
       </para>
<!--==========================orignal english content==========================
       <para>
        Example: To keep 24 hours of logs, one log file per hour, but
        also rotate sooner if the log file size exceeds 1GB, set
        <varname>log_filename</varname> to <literal>server_log.%H%M</literal>,
        <varname>log_truncate_on_rotation</varname> to <literal>on</literal>,
        <varname>log_rotation_age</varname> to <literal>60</literal>, and
        <varname>log_rotation_size</varname> to <literal>1000000</literal>.
        Including <literal>%M</literal> in <varname>log_filename</varname> allows
        any size-driven rotations that might occur to select a file name
        different from the hour's initial file name.
       </para>
____________________________________________________________________________-->
       <para>
        例子：要保留 24 小时的日志，每个小时一个日志文件，但是在日志文件尺寸超过 1GB 时轮转。可以这样做：将<varname>log_filename</varname>设置为<literal>server_log.%H%M</literal>、
        将<varname>log_truncate_on_rotation</varname>设置为<literal>on</literal>、
        将<varname>log_rotation_age</varname>设置为<literal>60</literal>并且
        将<varname>log_rotation_size</varname>设置为<literal>1000000</literal>。
        在<varname>log_filename</varname>中包括<literal>%M</literal>允许发生任何尺寸驱动的轮转来选择一个不同于每个小时的初始文件名的新文件名。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-syslog-facility" xreflabel="syslog_facility">
<!--==========================orignal english content==========================
      <term><varname>syslog_facility</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>syslog_facility</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>syslog_facility</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>syslog_facility</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        When logging to <application>syslog</application> is enabled, this parameter
        determines the <application>syslog</application>
        <quote>facility</quote> to be used.  You can choose
        from <literal>LOCAL0</literal>, <literal>LOCAL1</literal>,
        <literal>LOCAL2</literal>, <literal>LOCAL3</literal>, <literal>LOCAL4</literal>,
        <literal>LOCAL5</literal>, <literal>LOCAL6</literal>, <literal>LOCAL7</literal>;
        the default is <literal>LOCAL0</literal>. See also the
        documentation of your system's
        <application>syslog</application> daemon.
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        当启用了向<application>syslog</application>记录时，这个参数决定要使用的<application>syslog</application><quote>设备</quote>。你可以在<literal>LOCAL0</literal>、<literal>LOCAL1</literal>、<literal>LOCAL2</literal>、<literal>LOCAL3</literal>、<literal>LOCAL4</literal>、
        <literal>LOCAL5</literal>、<literal>LOCAL6</literal>、<literal>LOCAL7</literal>中选择，默认值是<literal>LOCAL0</literal>。还请参阅系统的<application>syslog</application>守护进程的文档。这个参数只能在<filename>postgresql.conf</filename>文件中或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-syslog-ident" xreflabel="syslog_ident">
<!--==========================orignal english content==========================
      <term><varname>syslog_ident</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>syslog_ident</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>syslog_ident</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>syslog_ident</varname>配置参数</primary>
      </indexterm>
      </term>
       <listitem>
<!--==========================orignal english content==========================
        <para>
         When logging to <application>syslog</application> is enabled, this parameter
         determines the program name used to identify
         <productname>PostgreSQL</productname> messages in
         <application>syslog</application> logs. The default is
         <literal>postgres</literal>.
         This parameter can only be set in the <filename>postgresql.conf</filename>
         file or on the server command line.
        </para>
____________________________________________________________________________-->
        <para>
         当启用了向<application>syslog</application>记录时，这个参数决定用来标识<application>syslog</application>中的<productname>PostgreSQL</productname>消息的程序名。默认值是<literal>postgres</literal>。这个参数只能在<filename>postgresql.conf</filename>文件中或在服务器命令行上设置。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-syslog-sequence-numbers" xreflabel="syslog_sequence_numbers">
<!--==========================orignal english content==========================
       <term><varname>syslog_sequence_numbers</varname> (<type>boolean</type>)
        <indexterm>
         <primary><varname>syslog_sequence_numbers</varname> configuration parameter</primary>
        </indexterm>
       </term>
____________________________________________________________________________-->
       <term><varname>syslog_sequence_numbers</varname> (<type>boolean</type>)
        <indexterm>
         <primary><varname>syslog_sequence_numbers</varname> 配置参数</primary>
        </indexterm>
       </term>

       <listitem>
<!--==========================orignal english content==========================
        <para>
         When logging to <application>syslog</application> and this is on (the
         default), then each message will be prefixed by an increasing
         sequence number (such as <literal>[2]</literal>).  This circumvents
         the <quote>-&minus;- last message repeated N times -&minus;-</quote> suppression
         that many syslog implementations perform by default.  In more modern
         syslog implementations, repeated message suppression can be configured
         (for example, <literal>$RepeatedMsgReduction</literal>
         in <productname>rsyslog</productname>), so this might not be
         necessary.  Also, you could turn this off if you actually want to
         suppress repeated messages.
        </para>
____________________________________________________________________________-->
        <para>
         当日志被记录到<application>syslog</application>并且这个设置为 on （默认）时，每一个消息会被加上一个增长的序号作为前缀（例如<literal>[2]</literal>）。这种行为避开了很多 syslog 实现默认采用的<quote>--- 上一个消息重复 N 次 ---</quote>形式。在现代 syslog 实现中，抑制重复消息是可以配置的（例如<productname>rsyslog</productname>中的<literal>$RepeatedMsgReduction</literal>），因此这个参数可能不是必需的。此外，如果你真的想抑制重复消息，你可以把这个参数设置为 off。
        </para>

<!--==========================orignal english content==========================
        <para>
         This parameter can only be set in the <filename>postgresql.conf</filename>
         file or on the server command line.
        </para>
____________________________________________________________________________-->
        <para>
         这个参数只能在<filename>postgresql.conf</filename>文件或者服务器命令行上设置。
        </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-syslog-split-messages" xreflabel="syslog_split_messages">
<!--==========================orignal english content==========================
      <term><varname>syslog_split_messages</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>syslog_split_messages</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>syslog_split_messages</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>syslog_split_messages</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        When logging to <application>syslog</application> is enabled, this parameter
        determines how messages are delivered to syslog.  When on (the
        default), messages are split by lines, and long lines are split so
        that they will fit into 1024 bytes, which is a typical size limit for
        traditional syslog implementations.  When off, PostgreSQL server log
        messages are delivered to the syslog service as is, and it is up to
        the syslog service to cope with the potentially bulky messages.
       </para>
____________________________________________________________________________-->
       <para>
        当启用把日志记录到<application>syslog</application>时，这个参数决定消息如何送达 syslog。当设置为 on（默认）时，消息会被分成行，并且长的行也会被划分以便能够放到 1024 字节中，这是传统 syslog 实现一种典型的尺寸限制。当设置为 off 时，PostgreSQL 服务器日志消息会被原样送达 syslog 服务，而处理可能的大体量消息的任务由 syslog 服务负责。
       </para>

<!--==========================orignal english content==========================
       <para>
        If syslog is ultimately logging to a text file, then the effect will
        be the same either way, and it is best to leave the setting on, since
        most syslog implementations either cannot handle large messages or
        would need to be specially configured to handle them.  But if syslog
        is ultimately writing into some other medium, it might be necessary or
        more useful to keep messages logically together.
       </para>
____________________________________________________________________________-->
       <para>
        如果 syslog 最终被记录到一个文本文件中，那么两种设置的效果是一样的，但最好设置为 on，因为大部分 syslog 实现要么不能处理大型消息，要么需要做特殊的配置以处理大型消息。但是如果 syslog 最终写入到某种其他媒介，有必要让消息保持逻辑上的整体性（也更加有用）。
       </para>

<!--==========================orignal english content==========================
       <para>
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数只能在<filename>postgresql.conf</filename>文件或者服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-event-source" xreflabel="event_source">
<!--==========================orignal english content==========================
      <term><varname>event_source</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>event_source</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>event_source</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>event_source</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        When logging to <application>event log</application> is enabled, this parameter
        determines the program name used to identify
        <productname>PostgreSQL</productname> messages in
        the log. The default is <literal>PostgreSQL</literal>.
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        当启用了向<application>事件日志</application>记录时，这个参数决定用来标识日志中<productname>PostgreSQL</productname>消息的程序名。默认值是<literal>PostgreSQL</literal>。这个参数只能在<filename>postgresql.conf</filename>文件中或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

      </variablelist>
    </sect2>
     <sect2 id="runtime-config-logging-when">
<!--==========================orignal english content==========================
     <title>When to Log</title>
____________________________________________________________________________-->
     <title>什么时候记录日志</title>

     <variablelist>

     <varlistentry id="guc-log-min-messages" xreflabel="log_min_messages">
<!--==========================orignal english content==========================
      <term><varname>log_min_messages</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>log_min_messages</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>log_min_messages</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>log_min_messages</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Controls which <link linkend="runtime-config-severity-levels">message
        levels</link> are written to the server log.
        Valid values are <literal>DEBUG5</literal>, <literal>DEBUG4</literal>,
        <literal>DEBUG3</literal>, <literal>DEBUG2</literal>, <literal>DEBUG1</literal>,
        <literal>INFO</literal>, <literal>NOTICE</literal>, <literal>WARNING</literal>,
        <literal>ERROR</literal>, <literal>LOG</literal>, <literal>FATAL</literal>, and
        <literal>PANIC</literal>.  Each level includes all the levels that
        follow it.  The later the level, the fewer messages are sent
        to the log.  The default is <literal>WARNING</literal>.  Note that
        <literal>LOG</literal> has a different rank here than in
        <xref linkend="guc-client-min-messages"/>.
        Only superusers can change this setting.
       </para>
____________________________________________________________________________-->
       <para>
        控制哪些<link linkend="runtime-config-severity-levels">消息级别</link>
        被写入到服务器日志。有效值是<literal>DEBUG5</literal>、<literal>DEBUG4</literal>、
        <literal>DEBUG3</literal>、<literal>DEBUG2</literal>、<literal>DEBUG1</literal>、
        <literal>INFO</literal>、<literal>NOTICE</literal>、<literal>WARNING</literal>、
        <literal>ERROR</literal>、<literal>LOG</literal>、<literal>FATAL</literal>和
        <literal>PANIC</literal>。每个级别都包括以后的所有级别。级别越靠后，被发送的消息越少。默认值是<literal>WARNING</literal>。注意<literal>LOG</literal>在这里有与<xref linkend="guc-client-min-messages"/>中不同的排名。只有超级用户可以改变这个设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-min-error-statement" xreflabel="log_min_error_statement">
<!--==========================orignal english content==========================
      <term><varname>log_min_error_statement</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>log_min_error_statement</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>log_min_error_statement</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>log_min_error_statement</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Controls which SQL statements that cause an error
        condition are recorded in the server log.  The current
        SQL statement is included in the log entry for any message of
        the specified
        <link linkend="runtime-config-severity-levels">severity</link>
        or higher.
        Valid values are <literal>DEBUG5</literal>,
        <literal>DEBUG4</literal>, <literal>DEBUG3</literal>,
        <literal>DEBUG2</literal>, <literal>DEBUG1</literal>,
        <literal>INFO</literal>, <literal>NOTICE</literal>,
        <literal>WARNING</literal>, <literal>ERROR</literal>,
        <literal>LOG</literal>,
        <literal>FATAL</literal>, and <literal>PANIC</literal>.
        The default is <literal>ERROR</literal>, which means statements
        causing errors, log messages, fatal errors, or panics will be logged.
        To effectively turn off logging of failing statements,
        set this parameter to <literal>PANIC</literal>.
        Only superusers can change this setting.
       </para>
____________________________________________________________________________-->
       <para>
        控制哪些导致一个错误情况的 SQL 语句被记录在服务器日志中。任何指定
        <link linkend="runtime-config-severity-levels">严重级别</link>
        或更高级别的消息的当前 SQL 语句将被包括在日志项中。有效值是<literal>DEBUG5</literal>、
        <literal>DEBUG4</literal>、<literal>DEBUG3</literal>、
        <literal>DEBUG2</literal>、<literal>DEBUG1</literal>、
        <literal>INFO</literal>、<literal>NOTICE</literal>、
        <literal>WARNING</literal>、<literal>ERROR</literal>、
        <literal>LOG</literal>、
        <literal>FATAL</literal>和<literal>PANIC</literal>。默认值是<literal>ERROR</literal>，它表示导致错误、日志消息、致命错误或恐慌错误的语句将被记录在日志中。要有效地关闭记录失败语句，将这个参数设置为<literal>PANIC</literal>。只有超级用户可以改变这个设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-min-duration-statement" xreflabel="log_min_duration_statement">
<!--==========================orignal english content==========================
      <term><varname>log_min_duration_statement</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>log_min_duration_statement</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>log_min_duration_statement</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>log_min_duration_statement</varname>配置参数</primary>
      </indexterm>
      </term>
       <listitem>
<!--==========================orignal english content==========================
        <para>
         Causes the duration of each completed statement to be logged
         if the statement ran for at least the specified amount of time.
         For example, if you set it to <literal>250ms</literal>
         then all SQL statements that run 250ms or longer will be
         logged.  Enabling this parameter can be helpful in tracking down
         unoptimized queries in your applications.
         If this value is specified without units, it is taken as milliseconds.
         Setting this to zero prints all statement durations.
         <literal>-1</literal> (the default) disables logging statement
         durations. Only superusers can change this setting.
        </para>
____________________________________________________________________________-->
        <para>
         如果语句运行至少指定的时间量，将导致记录每一个这种完成的语句的持续时间。
         例如，如果你设置它为<literal>250ms</literal>，那么所有运行 250ms 或更久的 SQL 语句将被记录。
         启用这个参数可以有助于追踪应用中未优化的查询。如果指定值时没有单位，则以毫秒为单位。将这个参数设置为零将打印所有语句的执行时间。
         设置为 <literal>-1</literal>（默认值）将停止记录语句持续时间。只有超级用户可以改变这个设置。
        </para>

<!--==========================orignal english content==========================
        <para>
         This overrides <xref linkend="guc-log-min-duration-sample"/>,
         meaning that queries with duration exceeding this setting are not
         subject to sampling and are always logged.
        </para>
____________________________________________________________________________-->
        <para>
         这会覆盖<xref linkend="guc-log-min-duration-sample"/>，意味着持续时间超过此设置的查询不进行抽样，并且始终被记录。
        </para>

<!--==========================orignal english content==========================
        <para>
         For clients using extended query protocol, durations of the Parse,
         Bind, and Execute steps are logged independently.
        </para>
____________________________________________________________________________-->
        <para>
         对于使用扩展查询协议的客户端，解析、绑定和执行步骤的持续时间将被独立记录。
        </para>

       <note>
<!--==========================orignal english content==========================
        <para>
         When using this option together with
         <xref linkend="guc-log-statement"/>,
         the text of statements that are logged because of
         <varname>log_statement</varname> will not be repeated in the
         duration log message.
         If you are not using <application>syslog</application>, it is recommended
         that you log the PID or session ID using
         <xref linkend="guc-log-line-prefix"/>
         so that you can link the statement message to the later
         duration message using the process ID or session ID.
        </para>
____________________________________________________________________________-->
        <para>
         当把这个选项和<xref linkend="guc-log-statement"/>一起使用时，已经被<varname>log_statement</varname>记录的语句文本不会在持续时间日志消息中重复。如果你没有使用<application>syslog</application>，我们推荐你使用<xref linkend="guc-log-line-prefix"/>记录 PID 或会话 ID，这样你可以使用进程 ID 或会话 ID 把语句消息链接到后来的持续时间消息。
        </para>
       </note>
       </listitem>
      </varlistentry>

     <varlistentry id="guc-log-min-duration-sample" xreflabel="log_min_duration_sample">
<!--==========================orignal english content==========================
      <term><varname>log_min_duration_sample</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>log_min_duration_sample</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>log_min_duration_sample</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>log_min_duration_sample</varname> 配置参数</primary>
      </indexterm>
      </term>
       <listitem>
<!--==========================orignal english content==========================
        <para>
         Allows sampling the duration of completed statements that ran for
         at least the specified amount of time.  This produces the same
         kind of log entries as
         <xref linkend="guc-log-min-duration-statement"/>, but only for a
         subset of the executed statements, with sample rate controlled by
         <xref linkend="guc-log-statement-sample-rate"/>.
         For example, if you set it to <literal>100ms</literal> then all
         SQL statements that run 100ms or longer will be considered for
         sampling.  Enabling this parameter can be helpful when the
         traffic is too high to log all queries.
         If this value is specified without units, it is taken as milliseconds.
         Setting this to zero samples all statement durations.
         <literal>-1</literal> (the default) disables sampling statement
         durations. Only superusers can change this setting.
        </para>
____________________________________________________________________________-->
        <para>
         允许对最少运行了指定时间的已完成语句的持续时间进行抽样。
         这将生成与<xref linkend="guc-log-min-duration-statement"/> 相同的日志条目，但仅适用于已执行语句的子集，采样率由 <xref linkend="guc-log-statement-sample-rate"/> 控制。
         例如，如果将它设置为 <literal>100ms</literal>则所有运行 100ms 或更长的 SQL 语句都将被采样。 
         当流量过高而无法记录所有查询时，启用此参数会很有帮助。如果指定此值时没有单位，则以毫秒为单位。
         设置为零将采样所有语句持续时间。<literal>-1</literal>（默认值）禁用采样语句持续时间。只有超级用户可以更改此设置。
        </para>

<!--==========================orignal english content==========================
        <para>
         This setting has lower priority
         than <varname>log_min_duration_statement</varname>, meaning that
         statements with durations
         exceeding <varname>log_min_duration_statement</varname> are not
         subject to sampling and are always logged.
        </para>
____________________________________________________________________________-->
        <para>
         此设置的优先级低于 <varname>log_min_duration_statement</varname>，意味着持续时间超过 <varname>log_min_duration_statement</varname> 的语句不被采样，并且始终被记录。
        </para>

<!--==========================orignal english content==========================
        <para>
         Other notes for <varname>log_min_duration_statement</varname>
         apply also to this setting.
        </para>
____________________________________________________________________________-->
        <para>
         <varname>log_min_duration_statement</varname>的其他注释也适用于此设置。
        </para>
       </listitem>
     </varlistentry>

     <varlistentry id="guc-log-statement-sample-rate" xreflabel="log_statement_sample_rate">
<!--==========================orignal english content==========================
      <term><varname>log_statement_sample_rate</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>log_statement_sample_rate</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>log_statement_sample_rate</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>log_statement_sample_rate</varname> 配置参数</primary>
      </indexterm>
      </term>
       <listitem>
<!--==========================orignal english content==========================
        <para>
         Determines the fraction of statements with duration exceeding
         <xref linkend="guc-log-min-duration-sample"/> that will be logged.
         Sampling is stochastic, for example <literal>0.5</literal> means
         there is statistically one chance in two that any given statement
         will be logged.
         The default is <literal>1.0</literal>, meaning to log all sampled
         statements.
         Setting this to zero disables sampled statement-duration logging,
         the same as setting
         <varname>log_min_duration_sample</varname> to
         <literal>-1</literal>.
         Only superusers can change this setting.
        </para>
____________________________________________________________________________-->
        <para>
         确定持续时间超过 <xref linkend="guc-log-min-duration-sample"/>的语句的部分。
         采样是随机的，例如<literal>0.5</literal>意味着从统计学上讲，任何给定语句都有1/2的概率将被记录。
         默认值为 <literal>1.0</literal>，意味着要记录所有采样语句。
         设置为零将禁用采样语句持续时间日志，与将<varname>log_min_duration_sample</varname>设为 <literal>-1</literal> 相同。
         只有超级用户可以更改此设置。
        </para>
       </listitem>
     </varlistentry>

     <varlistentry id="guc-log-transaction-sample-rate" xreflabel="log_transaction_sample_rate">
<!--==========================orignal english content==========================
      <term><varname>log_transaction_sample_rate</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>log_transaction_sample_rate</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>log_transaction_sample_rate</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>log_transaction_sample_rate</varname> 配置参数</primary>
      </indexterm>
      </term>
       <listitem>
<!--==========================orignal english content==========================
        <para>
         Sets the fraction of transactions whose statements are all logged,
         in addition to statements logged for other reasons.  It applies to
         each new transaction regardless of its statements' durations.
         Sampling is stochastic, for example <literal>0.1</literal> means
         there is statistically one chance in ten that any given transaction
         will be logged.
         <varname>log_transaction_sample_rate</varname> can be helpful to
         construct a sample of transactions.
         The default is <literal>0</literal>, meaning not to log
         statements from any additional transactions.  Setting this
         to <literal>1</literal> logs all statements of all transactions.
         Only superusers can change this setting.
        </para>
____________________________________________________________________________-->
        <para>
         设置所有语句都被记录的交易的部分，以及由于其他原因而记录的语句。它适用于每个新事务，而不考虑其语句的持续时间。
         采样是随机的，例如 <literal>0.1</literal>意味着从统计学上讲，任何给定事务都有十分之一的机会将被记录。
         <varname>log_transaction_sample_rate</varname> 有助于构建一个事务示例.
         默认值为 <literal>0</literal>，表示不记录任何额外事务的语句。
         设置这个为<literal>1</literal>将记录所有交易的所有语句。只有超级用户可以更改此设置。
        </para>

       <note>
<!--==========================orignal english content==========================
        <para>
         Like all statement-logging options, this option can add significant
         overhead.
        </para>
____________________________________________________________________________-->
        <para>
         就像所有的语句-日志选项一样，这个选项可能会增加大量开销。
        </para>
       </note>
       </listitem>
     </varlistentry>

     </variablelist>

<!--==========================orignal english content==========================
    <para>
     <xref linkend="runtime-config-severity-levels"/> explains the message
     severity levels used by <productname>PostgreSQL</productname>.  If logging output
     is sent to <systemitem>syslog</systemitem> or Windows'
     <systemitem>eventlog</systemitem>, the severity levels are translated
     as shown in the table.
    </para>
____________________________________________________________________________-->
    <para>
     <xref linkend="runtime-config-severity-levels"/>解释了<productname>PostgreSQL</productname>所使用的消息严重级别。如果日志输出被发送到<systemitem>syslog</systemitem>或 Windows 的<systemitem>eventlog</systemitem>，严重级别会按照表中所示进行转换。
    </para>

    <table id="runtime-config-severity-levels">
<!--==========================orignal english content==========================
     <title>Message Severity Levels</title>
____________________________________________________________________________-->
     <title>消息严重级别</title>
     <tgroup cols="4">
      <colspec colname="col1" colwidth="1*"/>
      <colspec colname="col2" colwidth="2*"/>
      <colspec colname="col3" colwidth="1*"/>
      <colspec colname="col4" colwidth="1*"/>
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry>Severity</entry>
        <entry>Usage</entry>
        <entry><systemitem>syslog</systemitem></entry>
        <entry><systemitem>eventlog</systemitem></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>严重性</entry>
        <entry>用法</entry>
        <entry><systemitem>syslog</systemitem></entry>
        <entry><systemitem>eventlog</systemitem></entry>
       </row>
      </thead>

      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>DEBUG1 .. DEBUG5</literal></entry>
        <entry>Provides successively-more-detailed information for use by
         developers.</entry>
        <entry><literal>DEBUG</literal></entry>
        <entry><literal>INFORMATION</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>DEBUG1 .. DEBUG5</literal></entry>
        <entry>为开发者提供连续的更详细的信息。</entry>
        <entry><literal>DEBUG</literal></entry>
        <entry><literal>INFORMATION</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><literal>INFO</literal></entry>
        <entry>Provides information implicitly requested by the user,
         e.g., output from <command>VACUUM VERBOSE</command>.</entry>
        <entry><literal>INFO</literal></entry>
        <entry><literal>INFORMATION</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>INFO</literal></entry>
        <entry>提供用户隐式要求的信息，例如来自<command>VACUUM VERBOSE</command>的输出。</entry>
        <entry><literal>INFO</literal></entry>
        <entry><literal>INFORMATION</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><literal>NOTICE</literal></entry>
        <entry>Provides information that might be helpful to users, e.g.,
         notice of truncation of long identifiers.</entry>
        <entry><literal>NOTICE</literal></entry>
        <entry><literal>INFORMATION</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>NOTICE</literal></entry>
        <entry>提供可能对用户有用的信息，例如长标识符截断提示。</entry>
        <entry><literal>NOTICE</literal></entry>
        <entry><literal>INFORMATION</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><literal>WARNING</literal></entry>
        <entry>Provides warnings of likely problems, e.g., <command>COMMIT</command>
         outside a transaction block.</entry>
        <entry><literal>NOTICE</literal></entry>
        <entry><literal>WARNING</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>WARNING</literal></entry>
        <entry>提供可能出现的问题的警告，例如在一个事务块外<command>COMMIT</command>。</entry>
        <entry><literal>NOTICE</literal></entry>
        <entry><literal>WARNING</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><literal>ERROR</literal></entry>
        <entry>Reports an error that caused the current command to
         abort.</entry>
        <entry><literal>WARNING</literal></entry>
        <entry><literal>ERROR</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>ERROR</literal></entry>
        <entry>报告一个导致当前命令中断的错误。</entry>
        <entry><literal>WARNING</literal></entry>
        <entry><literal>ERROR</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><literal>LOG</literal></entry>
        <entry>Reports information of interest to administrators, e.g.,
         checkpoint activity.</entry>
        <entry><literal>INFO</literal></entry>
        <entry><literal>INFORMATION</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>LOG</literal></entry>
        <entry>报告管理员可能感兴趣的信息，例如检查点活动。</entry>
        <entry><literal>INFO</literal></entry>
        <entry><literal>INFORMATION</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><literal>FATAL</literal></entry>
        <entry>Reports an error that caused the current session to
         abort.</entry>
        <entry><literal>ERR</literal></entry>
        <entry><literal>ERROR</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>FATAL</literal></entry>
        <entry>报告一个导致当前会话中断的错误。</entry>
        <entry><literal>ERR</literal></entry>
        <entry><literal>ERROR</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><literal>PANIC</literal></entry>
        <entry>Reports an error that caused all database sessions to abort.</entry>
        <entry><literal>CRIT</literal></entry>
        <entry><literal>ERROR</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>PANIC</literal></entry>
        <entry>报告一个导致所有数据库会话中断的错误。</entry>
        <entry><literal>CRIT</literal></entry>
        <entry><literal>ERROR</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    </sect2>
     <sect2 id="runtime-config-logging-what">
<!--==========================orignal english content==========================
     <title>What to Log</title>
____________________________________________________________________________-->
     <title>记录什么到日志</title>

     <variablelist>

     <varlistentry id="guc-application-name" xreflabel="application_name">
<!--==========================orignal english content==========================
      <term><varname>application_name</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>application_name</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>application_name</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>application_name</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The <varname>application_name</varname> can be any string of less than
        <symbol>NAMEDATALEN</symbol> characters (64 characters in a standard build).
        It is typically set by an application upon connection to the server.
        The name will be displayed in the <structname>pg_stat_activity</structname> view
        and included in CSV log entries.  It can also be included in regular
        log entries via the <xref linkend="guc-log-line-prefix"/> parameter.
        Only printable ASCII characters may be used in the
        <varname>application_name</varname> value. Other characters will be
        replaced with question marks (<literal>?</literal>).
       </para>
____________________________________________________________________________-->
       <para>
        <varname>application_name</varname>可以是任意小于<symbol>NAMEDATALEN</symbol>个字符（标准编译中是 64 个字符）的字符串。这通常由一个应用通过到服务器的连接设置。该名称将被显示在<structname>pg_stat_activity</structname>视图中并被包括在 CSV 日志项中。它也会被通过<xref linkend="guc-log-line-prefix"/>包括在普通日志项中。只有可打印 ASCII 字符能被使用在<varname>application_name</varname>之中。其他字符将被替换为问号（<literal>?</literal>）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><varname>debug_print_parse</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>debug_print_parse</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>debug_print_parse</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>debug_print_parse</varname>配置参数</primary>
      </indexterm>
      </term>
<!--==========================orignal english content==========================
      <term><varname>debug_print_rewritten</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>debug_print_rewritten</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>debug_print_rewritten</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>debug_print_rewritten</varname>配置参数</primary>
      </indexterm>
      </term>
<!--==========================orignal english content==========================
      <term><varname>debug_print_plan</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>debug_print_plan</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>debug_print_plan</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>debug_print_plan</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        These parameters enable various debugging output to be emitted.
        When set, they print the resulting parse tree, the query rewriter
        output, or the execution plan for each executed query.
        These messages are emitted at <literal>LOG</literal> message level, so by
        default they will appear in the server log but will not be sent to the
        client.  You can change that by adjusting
        <xref linkend="guc-client-min-messages"/> and/or
        <xref linkend="guc-log-min-messages"/>.
        These parameters are off by default.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数启用发出各种调试输出。当设置时，会打印生成的解析树， 查询重写输出，或执行的每个查询的执行计划。这些信息是在LOG 信息级别发出，因此默认的，它们会出现在服务器日志中，但不会发送给客户端。 可以通过 client_min_messages和/或log_min_messages 来设置。这些参数缺省是off。
        这些参数将会让多种调试输出被发出。当被设置时，它们为每一个被执行的查询打印结果分析树、查询重写器输出或执行计划。这些消息在<literal>LOG</literal>消息级别上被发出，因此默认情况下它们将出现在服务器日志中但不会被发送到客户端。你可以通过调整<xref linkend="guc-client-min-messages"/>和/或<xref linkend="guc-log-min-messages"/>来改变这种情况。这些参数默认是关闭的。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><varname>debug_pretty_print</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>debug_pretty_print</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>debug_pretty_print</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>debug_pretty_print</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        When set, <varname>debug_pretty_print</varname> indents the messages
        produced by <varname>debug_print_parse</varname>,
        <varname>debug_print_rewritten</varname>, or
        <varname>debug_print_plan</varname>.  This results in more readable
        but much longer output than the <quote>compact</quote> format used when
        it is off.  It is on by default.
       </para>
____________________________________________________________________________-->
       <para>
        当被设置时，<varname>debug_pretty_print</varname>会缩进由<varname>debug_print_parse</varname>、
        <varname>debug_print_rewritten</varname>或
        <varname>debug_print_plan</varname>产生的输出。这将导致比关闭参数时使用的<quote>紧凑</quote>模式可读性更强但是更长的输出。它默认是打开的。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-autovacuum-min-duration" xreflabel="log_autovacuum_min_duration">
<!--==========================orignal english content==========================
      <term><varname>log_autovacuum_min_duration</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>log_autovacuum_min_duration</varname></primary>
       <secondary>configuration parameter</secondary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>log_autovacuum_min_duration</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>log_autovacuum_min_duration</varname></primary>
       <secondary>配置参数</secondary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Causes each action executed by autovacuum to be logged if it ran for at
        least the specified amount of time.  Setting this to zero logs
        all autovacuum actions. <literal>-1</literal> (the default) disables
        logging autovacuum actions.
        If this value is specified without units, it is taken as milliseconds.
        For example, if you set this to
        <literal>250ms</literal> then all automatic vacuums and analyzes that run
        250ms or longer will be logged.  In addition, when this parameter is
        set to any value other than <literal>-1</literal>, a message will be
        logged if an autovacuum action is skipped due to a conflicting lock or a
        concurrently dropped relation.  Enabling this parameter can be helpful
        in tracking autovacuum activity.  This parameter can only be set in
        the <filename>postgresql.conf</filename> file or on the server command line;
        but the setting can be overridden for individual tables by
        changing table storage parameters.
       </para>
____________________________________________________________________________-->
       <para>
        如果autovacuum执行的每个操作至少运行了指定的时间，该操作会被记录。
        设置这个为零记录所有autovacuum操作。
        <literal>-1</literal>(默认的)禁用日志记录autovacuum操作。
        如果指定此值时不带单位，则以毫秒为单位。
        例如，如果将其设置为<literal>250ms</literal>，那么所有运行250毫秒或更长时间的自动vacuums和分析都将被记录。
        此外，当此参数设置为<literal>-1</literal>以外的任何值时，如果由于锁冲突或并发删除关系而跳过autovacuum操作，则会记录一条消息。
        启用此参数有助于跟踪autovacuum活动。
        该参数只能在<filename>postgresql.conf</filename>文件或在服务器命令行中设置;但是可以通过更改表存储参数来覆盖单独表的设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-checkpoints" xreflabel="log_checkpoints">
<!--==========================orignal english content==========================
      <term><varname>log_checkpoints</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_checkpoints</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>log_checkpoints</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_checkpoints</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Causes checkpoints and restartpoints to be logged in the server log.
        Some statistics are included in the log messages, including the number
        of buffers written and the time spent writing them.
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line. The default is off.
       </para>
____________________________________________________________________________-->
       <para>
        导致检查点和重启点被记录在服务器日志中。一些统计信息也被包括在日志消息中，包括写入缓冲区的数据和写它们所花的时间。这个参数只能在<filename>postgresql.conf</filename>文件中或在服务器命令行上设置。默认值是关闭。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-connections" xreflabel="log_connections">
<!--==========================orignal english content==========================
      <term><varname>log_connections</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_connections</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>log_connections</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_connections</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Causes each attempted connection to the server to be logged,
        as well as successful completion of both client authentication (if
        necessary) and authorization.
        Only superusers can change this parameter at session start,
        and it cannot be changed at all within a session.
        The default is <literal>off</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        导致每一次尝试对服务器的连接被记录，客户端认证(如需要)和认证的成功完成也会被记录。
        只有超级用户能在会话开始时更改这个参数，在会话中它不能被更改。默认
        为<literal>off</literal>。
       </para>

       <note>
<!--==========================orignal english content==========================
        <para>
         Some client programs, like <application>psql</application>, attempt
         to connect twice while determining if a password is required, so
         duplicate <quote>connection received</quote> messages do not
         necessarily indicate a problem.
        </para>
____________________________________________________________________________-->
        <para>
         某些客户端程序（例如<application>psql</application>）在要求密码时会尝试连接两次，因此重复的<quote>收到连接</quote>消息并不一定表示一个错误。
        </para>
       </note>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-disconnections" xreflabel="log_disconnections">
<!--==========================orignal english content==========================
      <term><varname>log_disconnections</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_disconnections</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>log_disconnections</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_disconnections</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Causes session terminations to be logged.  The log output
        provides information similar to <varname>log_connections</varname>,
        plus the duration of the session.
        Only superusers can change this parameter at session start,
        and it cannot be changed at all within a session.
        The default is <literal>off</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        导致会话终止被记录。日志输出提供的信息类似于
        <varname>log_connections</varname>，不过还外加会话的持续时间。
        只有超级用户能在会话开始时更改这个参数，在会话中它不能被更改。默认
        为<literal>off</literal>。
       </para>
      </listitem>
     </varlistentry>


     <varlistentry id="guc-log-duration" xreflabel="log_duration">
<!--==========================orignal english content==========================
      <term><varname>log_duration</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_duration</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>log_duration</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_duration</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Causes the duration of every completed statement to be logged.
        The default is <literal>off</literal>.
        Only superusers can change this setting.
       </para>
____________________________________________________________________________-->
       <para>
        导致每一个完成的语句的持续时间被记录。默认值是<literal>off</literal>。只有超级用户可以改变这个设置。
       </para>

<!--==========================orignal english content==========================
       <para>
        For clients using extended query protocol, durations of the Parse,
        Bind, and Execute steps are logged independently.
       </para>
____________________________________________________________________________-->
       <para>
        对于使用扩展查询协议的客户端，解析、绑定和执行步骤的持续时间将被独立记录。
       </para>

       <note>
<!--==========================orignal english content==========================
        <para>
         The difference between enabling <varname>log_duration</varname> and setting
         <xref linkend="guc-log-min-duration-statement"/> to zero is that
         exceeding <varname>log_min_duration_statement</varname> forces the text of
         the query to be logged, but this option doesn't.  Thus, if
         <varname>log_duration</varname> is <literal>on</literal> and
         <varname>log_min_duration_statement</varname> has a positive value, all
         durations are logged but the query text is included only for
         statements exceeding the threshold.  This behavior can be useful for
         gathering statistics in high-load installations.
        </para>
____________________________________________________________________________-->
        <para>
         启用<varname>log_duration</varname>和设置<xref linkend="guc-log-min-duration-statement"/>为零之间的区别是，超过<varname>log_min_duration_statement</varname>强制查询的文本被记录，但这个选项不会。因此，如果<varname>log_duration</varname>为<literal>on</literal>并且<varname>log_min_duration_statement</varname>为正值，所有持续时间都将被记录，但是只有超过阈值的语句才会被记录查询文本。这种行为有助于在高负载安装中收集统计信息。
        </para>
       </note>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-error-verbosity" xreflabel="log_error_verbosity">
<!--==========================orignal english content==========================
      <term><varname>log_error_verbosity</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>log_error_verbosity</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>log_error_verbosity</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>log_error_verbosity</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Controls the amount of detail written in the server log for each
        message that is logged.  Valid values are <literal>TERSE</literal>,
        <literal>DEFAULT</literal>, and <literal>VERBOSE</literal>, each adding more
        fields to displayed messages.  <literal>TERSE</literal> excludes
        the logging of <literal>DETAIL</literal>, <literal>HINT</literal>,
        <literal>QUERY</literal>, and <literal>CONTEXT</literal> error information.
        <literal>VERBOSE</literal> output includes the <symbol>SQLSTATE</symbol> error
        code (see also <xref linkend="errcodes-appendix"/>) and the source code file name, function name,
        and line number that generated the error.
        Only superusers can change this setting.
       </para>
____________________________________________________________________________-->
       <para>
        控制为每一个被记录的消息要写入到服务器日志的细节量。有效值是<literal>TERSE</literal>、<literal>DEFAULT</literal>和<literal>VERBOSE</literal>，每一个都为显示的消息增加更多域。<literal>TERSE</literal>排除记录<literal>DETAIL</literal>、<literal>HINT</literal>、<literal>QUERY</literal>和<literal>CONTEXT</literal>错误信息。<literal>VERBOSE</literal>输出包括<symbol>SQLSTATE</symbol>错误码（见<xref linkend="errcodes-appendix"/>）以及产生错误的源代码文件名、函数名和行号。只有超级用户能够更改这个设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-hostname" xreflabel="log_hostname">
<!--==========================orignal english content==========================
      <term><varname>log_hostname</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_hostname</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>log_hostname</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_hostname</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        By default, connection log messages only show the IP address of the
        connecting host. Turning this parameter on causes logging of the
        host name as well.  Note that depending on your host name resolution
        setup this might impose a non-negligible performance penalty.
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        默认情况下，连接日志消息只显示连接主机的 IP 地址。打开这个参数将导致也记录主机名。注意根据你的主机名解析设置，这可能会导致很微小的性能损失。这个参数只能在<filename>postgresql.conf</filename>文件中或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-line-prefix" xreflabel="log_line_prefix">
<!--==========================orignal english content==========================
      <term><varname>log_line_prefix</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>log_line_prefix</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>log_line_prefix</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>log_line_prefix</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
         This is a <function>printf</function>-style string that is output at the
         beginning of each log line.
         <literal>%</literal> characters begin <quote>escape sequences</quote>
         that are replaced with status information as outlined below.
         Unrecognized escapes are ignored. Other
         characters are copied straight to the log line. Some escapes are
         only recognized by session processes, and will be treated as empty by
         background processes such as the main server process. Status
         information may be aligned either left or right by specifying a
         numeric literal after the % and before the option. A negative
         value will cause the status information to be padded on the
         right with spaces to give it a minimum width, whereas a positive
         value will pad on the left. Padding can be useful to aid human
         readability in log files.
       </para>
____________________________________________________________________________-->
       <para>
         这是一个<function>printf</function>风格的字符串，它在每个日志行的开头输出。
         <literal>%</literal>字符开始<quote>转义序列</quote>，它将被按照下文描述的替换成状态信息。
         未识别的转义被忽略。其他字符被直接复制到日志行。某些转义只被会话进程识别并且被主服务器进程等后台进程当作空。
         通过指定一个在%之后和该选项之前的数字可以让状态信息左对齐或右对齐。
         负值将导致在右边用空格填充状态信息已达到最小宽度，而正值则在左边填充。填充对于日志文件的人类可读性大有帮助。
       </para>

<!--==========================orignal english content==========================
       <para>
         This parameter can only be set in the <filename>postgresql.conf</filename>
         file or on the server command line. The default is
         <literal>'%m [%p] '</literal> which logs a time stamp and the process ID.
       </para>
____________________________________________________________________________-->
       <para>
         这个参数只能在<filename>postgresql.conf</filename>文件中或在服务器命令行上设置。默认值是<literal>'%m [%p] '</literal>，它记录时间戳和进程ID。
       </para>

         <informaltable>
          <tgroup cols="3">
           <thead>
<!--==========================orignal english content==========================
            <row>
             <entry>Escape</entry>
             <entry>Effect</entry>
             <entry>Session only</entry>
             </row>
____________________________________________________________________________-->
            <row>
             <entry>转义</entry>
             <entry>效果</entry>
             <entry>只限会话</entry>
             </row>
            </thead>
           <tbody>
<!--==========================orignal english content==========================
            <row>
             <entry><literal>%a</literal></entry>
             <entry>Application name</entry>
             <entry>yes</entry>
            </row>
____________________________________________________________________________-->
            <row>
             <entry><literal>%a</literal></entry>
             <entry>应用名</entry>
             <entry>是</entry>
            </row>
<!--==========================orignal english content==========================
            <row>
             <entry><literal>%u</literal></entry>
             <entry>User name</entry>
             <entry>yes</entry>
            </row>
____________________________________________________________________________-->
            <row>
             <entry><literal>%u</literal></entry>
             <entry>用户名</entry>
             <entry>是</entry>
            </row>
<!--==========================orignal english content==========================
            <row>
             <entry><literal>%d</literal></entry>
             <entry>Database name</entry>
             <entry>yes</entry>
            </row>
____________________________________________________________________________-->
            <row>
             <entry><literal>%d</literal></entry>
             <entry>数据库名</entry>
             <entry>是</entry>
            </row>
<!--==========================orignal english content==========================
            <row>
             <entry><literal>%r</literal></entry>
             <entry>Remote host name or IP address, and remote port</entry>
             <entry>yes</entry>
            </row>
____________________________________________________________________________-->
            <row>
             <entry><literal>%r</literal></entry>
             <entry>远程主机名或 IP 地址，以及远程端口</entry>
             <entry>是</entry>
            </row>
<!--==========================orignal english content==========================
            <row>
             <entry><literal>%h</literal></entry>
             <entry>Remote host name or IP address</entry>
             <entry>yes</entry>
            </row>
____________________________________________________________________________-->
            <row>
             <entry><literal>%h</literal></entry>
             <entry>远程主机名或 IP 地址</entry>
             <entry>是</entry>
            </row>
<!--==========================orignal english content==========================
            <row>
             <entry><literal>%b</literal></entry>
             <entry>Backend type</entry>
             <entry>no</entry>
            </row>
____________________________________________________________________________-->
            <row>
             <entry><literal>%b</literal></entry>
             <entry>后端类型</entry>
             <entry>否</entry>
            </row>
<!--==========================orignal english content==========================
            <row>
             <entry><literal>%p</literal></entry>
             <entry>Process ID</entry>
             <entry>no</entry>
            </row>
____________________________________________________________________________-->
            <row>
             <entry><literal>%p</literal></entry>
             <entry>进程 ID</entry>
             <entry>否</entry>
            </row>
<!--==========================orignal english content==========================
            <row>
             <entry><literal>%P</literal></entry>
             <entry>Process ID of the parallel group leader, if this process
              is a parallel query worker</entry>
             <entry>no</entry>
            </row>
____________________________________________________________________________-->
            <row>
             <entry><literal>%P</literal></entry>
             <entry>并行组leader的进程ID，如果该进程是一个并行查询worker</entry>
             <entry>no</entry>
            </row>
<!--==========================orignal english content==========================
            <row>
             <entry><literal>%t</literal></entry>
             <entry>Time stamp without milliseconds</entry>
             <entry>no</entry>
            </row>
____________________________________________________________________________-->
            <row>
             <entry><literal>%t</literal></entry>
             <entry>无毫秒的时间戳</entry>
             <entry>否</entry>
            </row>
<!--==========================orignal english content==========================
            <row>
             <entry><literal>%m</literal></entry>
             <entry>Time stamp with milliseconds</entry>
             <entry>no</entry>
            </row>
____________________________________________________________________________-->
            <row>
             <entry><literal>%m</literal></entry>
             <entry>带毫秒的时间戳</entry>
             <entry>否</entry>
            </row>
<!--==========================orignal english content==========================
            <row>
             <entry><literal>%n</literal></entry>
             <entry>Time stamp with milliseconds (as a Unix epoch)</entry>
             <entry>no</entry>
            </row>
____________________________________________________________________________-->
            <row>
             <entry><literal>%n</literal></entry>
             <entry>带毫秒的时间戳（作为 Unix 时代）</entry>
             <entry>no</entry>
            </row>
<!--==========================orignal english content==========================
            <row>
             <entry><literal>%i</literal></entry>
             <entry>Command tag: type of session's current command</entry>
             <entry>yes</entry>
            </row>
____________________________________________________________________________-->
            <row>
             <entry><literal>%i</literal></entry>
             <entry>命令标签：会话当前命令的类型</entry>
             <entry>是</entry>
            </row>
<!--==========================orignal english content==========================
            <row>
             <entry><literal>%e</literal></entry>
             <entry>SQLSTATE error code</entry>
             <entry>no</entry>
            </row>
____________________________________________________________________________-->
            <row>
             <entry><literal>%e</literal></entry>
             <entry>SQLSTATE 错误代码</entry>
             <entry>否</entry>
            </row>
<!--==========================orignal english content==========================
            <row>
             <entry><literal>%c</literal></entry>
             <entry>Session ID: see below</entry>
             <entry>no</entry>
            </row>
____________________________________________________________________________-->
            <row>
             <entry><literal>%c</literal></entry>
             <entry>会话 ID：见下文</entry>
             <entry>否</entry>
            </row>
<!--==========================orignal english content==========================
            <row>
             <entry><literal>%l</literal></entry>
             <entry>Number of the log line for each session or process, starting at 1</entry>
             <entry>no</entry>
            </row>
____________________________________________________________________________-->
            <row>
             <entry><literal>%l</literal></entry>
             <entry>对每个会话或进程的日志行号，从 1 开始</entry>
             <entry>否</entry>
            </row>
<!--==========================orignal english content==========================
            <row>
             <entry><literal>%s</literal></entry>
             <entry>Process start time stamp</entry>
             <entry>no</entry>
            </row>
____________________________________________________________________________-->
            <row>
             <entry><literal>%s</literal></entry>
             <entry>进程开始的时间戳</entry>
             <entry>否</entry>
            </row>
<!--==========================orignal english content==========================
            <row>
             <entry><literal>%v</literal></entry>
             <entry>Virtual transaction ID (backendID/localXID)</entry>
             <entry>no</entry>
            </row>
____________________________________________________________________________-->
            <row>
             <entry><literal>%v</literal></entry>
             <entry>虚拟事务 ID (backendID/localXID)</entry>
             <entry>否</entry>
            </row>
<!--==========================orignal english content==========================
            <row>
             <entry><literal>%x</literal></entry>
             <entry>Transaction ID (0 if none is assigned)</entry>
             <entry>no</entry>
            </row>
____________________________________________________________________________-->
            <row>
             <entry><literal>%x</literal></entry>
             <entry>事务 ID （如果未分配则为 0）</entry>
             <entry>否</entry>
            </row>
<!--==========================orignal english content==========================
            <row>
             <entry><literal>%q</literal></entry>
             <entry>Produces no output, but tells non-session
             processes to stop at this point in the string; ignored by
             session processes</entry>
             <entry>no</entry>
            </row>
____________________________________________________________________________-->
            <row>
             <entry><literal>%q</literal></entry>
             <entry>不产生输出，但是告诉非会话进程在字符串的这一点停止；会话进程忽略</entry>
             <entry>否</entry>
            </row>
<!--==========================orignal english content==========================
            <row>
             <entry><literal>%Q</literal></entry>
             <entry>Query identifier of the current query.  Query
             identifiers are not computed by default, so this field
             will be zero unless <xref linkend="guc-compute-query-id"/>
             parameter is enabled or a third-party module that computes
             query identifiers is configured.</entry>
             <entry>yes</entry>
            </row>
____________________________________________________________________________-->
            <row>
             <entry><literal>%Q</literal></entry>
             <entry>当前查询的查询标识符。
             查询标识符默认是不计算的，所以这个部分将是零，除非<xref linkend="guc-compute-query-id"/> 参数被激活或者配置了计算查询标识符的第三方模块</entry>
             <entry>yes</entry>
            </row>
<!--==========================orignal english content==========================
            <row>
             <entry><literal>%%</literal></entry>
             <entry>Literal <literal>%</literal></entry>
             <entry>no</entry>
            </row>
____________________________________________________________________________-->
            <row>
             <entry><literal>%%</literal></entry>
             <entry>纯文字 <literal>%</literal></entry>
             <entry>否</entry>
            </row>
           </tbody>
          </tgroup>
         </informaltable>

<!--==========================orignal english content==========================
         <para>
          The backend type corresponds to the column
          <structfield>backend_type</structfield> in the view
          <link linkend="monitoring-pg-stat-activity-view">
          <structname>pg_stat_activity</structname></link>,
          but additional types can appear
          in the log that don't show in that view.
         </para>
____________________________________________________________________________-->
         <para>
          后端类型对应视图<link linkend="monitoring-pg-stat-activity-view"> <structname>pg_stat_activity</structname></link>中的<structfield>backend_type</structfield>列。
          但是其他类型可能会出现在日志中而不显示在该视图中。
         </para>

<!--==========================orignal english content==========================
         <para>
         The <literal>%c</literal> escape prints a quasi-unique session identifier,
         consisting of two 4-byte hexadecimal numbers (without leading zeros)
         separated by a dot.  The numbers are the process start time and the
         process ID, so <literal>%c</literal> can also be used as a space saving way
         of printing those items.  For example, to generate the session
         identifier from <literal>pg_stat_activity</literal>, use this query:
<programlisting>
SELECT to_hex(trunc(EXTRACT(EPOCH FROM backend_start))::integer) || '.' ||
       to_hex(pid)
FROM pg_stat_activity;
</programlisting>

       </para>
____________________________________________________________________________-->
         <para>
         <literal>%c</literal>转义打印一个准唯一的会话标识符，它由两个 4 字节的十六进制数（不带先导零）组成，以点号分隔。
         这些数字是进程启动时间和进程 ID，因此<literal>%c</literal>也可以被用作保存打印这些项的方式的空间。
         例如，要从<literal>pg_stat_activity</literal>生成会话标识符，使用这个查询：
<programlisting>
SELECT to_hex(trunc(EXTRACT(EPOCH FROM backend_start))::integer) || '.' ||
       to_hex(pid)
FROM pg_stat_activity;
</programlisting>

       </para>

       <tip>
<!--==========================orignal english content==========================
        <para>
         If you set a nonempty value for <varname>log_line_prefix</varname>,
         you should usually make its last character be a space, to provide
         visual separation from the rest of the log line.  A punctuation
         character can be used too.
        </para>
____________________________________________________________________________-->
        <para>
         如果你为<varname>log_line_prefix</varname>设置了非空值，你通常应该让它的最后一个字符为空格，这样用以提供和日志行的剩余部分的视觉区别。也可以使用标点符号。
        </para>
       </tip>

       <tip>
<!--==========================orignal english content==========================
        <para>
         <application>Syslog</application> produces its own
         time stamp and process ID information, so you probably do not want to
         include those escapes if you are logging to <application>syslog</application>.
        </para>
____________________________________________________________________________-->
        <para>
         <application>Syslog</application>产生自己的时间戳和进程 ID 信息，因此如果你记录到<application>syslog</application>你可能不希望包括哪些转义。
        </para>
       </tip>

       <tip>
<!--==========================orignal english content==========================
        <para>
         The <literal>%q</literal> escape is useful when including information that is
         only available in session (backend) context like user or database
         name.  For example:
<programlisting>
log_line_prefix = '%m [%p] %q%u@%d/%a '
</programlisting>
        </para>
____________________________________________________________________________-->
        <para>
         在包括仅在会话（后端）上下文中可用的信息（如用户名或者数据库名）时，<literal>%q</literal>转义很有用。例如：
<programlisting>
log_line_prefix = '%m [%p] %q%u@%d/%a '
</programlisting>
        </para>
       </tip>

       <note>
<!--==========================orignal english content==========================
        <para>
         The <literal>%Q</literal> escape always reports a zero identifier
         for lines output by <xref linkend="guc-log-statement"/> because
         <varname>log_statement</varname> generates output before an
         identifier can be calculated, including invalid statements for
         which an identifier cannot be calculated.
        </para>
____________________________________________________________________________-->
        <para>
         对于<xref linkend="guc-log-statement"/>输出的行，<literal>%Q</literal> 总是报告零标识符，
		 因为<varname>log_statement</varname>在标识符能被计算之前生成输出，包括无效标识符不能计算的无效语句。
        </para>
       </note>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-lock-waits" xreflabel="log_lock_waits">
<!--==========================orignal english content==========================
      <term><varname>log_lock_waits</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_lock_waits</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>log_lock_waits</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_lock_waits</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Controls whether a log message is produced when a session waits
        longer than <xref linkend="guc-deadlock-timeout"/> to acquire a
        lock.  This is useful in determining if lock waits are causing
        poor performance.  The default is <literal>off</literal>.
        Only superusers can change this setting.
       </para>
____________________________________________________________________________-->
       <para>
        控制当一个会话为获得一个锁等到超过<xref linkend="guc-deadlock-timeout"/>时，是否要产生一个日志消息。这有助于决定是否所等待造成了性能低下。默认值是<literal>off</literal>。只有超级用户可以更改这个设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-recovery-conflict-waits" xreflabel="log_recovery_conflict_waits">
<!--==========================orignal english content==========================
      <term><varname>log_recovery_conflict_waits</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_recovery_conflict_waits</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>log_recovery_conflict_waits</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_recovery_conflict_waits</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Controls whether a log message is produced when the startup process
        waits longer than <varname>deadlock_timeout</varname>
        for recovery conflicts.  This is useful in determining if recovery
        conflicts prevent the recovery from applying WAL.
       </para>
____________________________________________________________________________-->
       <para>
        控制启动过程等待时间超过针对恢复冲突的<varname>deadlock_timeout</varname>的时候是否产生日志消息。
        这对于决定恢复冲突是否会阻止恢复应用WAL有所帮助。
       </para>

<!--==========================orignal english content==========================
       <para>
        The default is <literal>off</literal>.  This parameter can only be set
        in the <filename>postgresql.conf</filename> file or on the server
        command line.
       </para>
____________________________________________________________________________-->
       <para>
        默认为<literal>off</literal>。
        这个参数只能在<filename>postgresql.conf</filename>文件中或服务器命令行中设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-parameter-max-length" xreflabel="log_parameter_max_length">
<!--==========================orignal english content==========================
      <term><varname>log_parameter_max_length</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>log_parameter_max_length</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>log_parameter_max_length</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>log_parameter_max_length</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        If greater than zero, each bind parameter value logged with a
        non-error statement-logging message is trimmed to this many bytes.
        Zero disables logging of bind parameters for non-error statement logs.
        <literal>-1</literal> (the default) allows bind parameters to be
        logged in full.
        If this value is specified without units, it is taken as bytes.
        Only superusers can change this setting.
       </para>
____________________________________________________________________________-->
       <para>
        如果大于零，则使用非错误语句日志消息记录的每个绑定参数值都被裁剪为这么多字节。
        零禁用非错误语句日志的绑定参数日志。<literal>-1</literal>（默认值）允许绑定参数被完整登录。
        如果指定此值时没有单位，则将其作为字节。只有超级用户可以更改此设置。
       </para>

<!--==========================orignal english content==========================
       <para>
        This setting only affects log messages printed as a result of
        <xref linkend="guc-log-statement"/>,
        <xref linkend="guc-log-duration"/>, and related settings.  Non-zero
        values of this setting add some overhead, particularly if parameters
        are sent in binary form, since then conversion to text is required.
       </para>
____________________________________________________________________________-->
       <para>
        此设置仅影响作为结果打印的日志消息<xref linkend="guc-log-statement"/>,<xref linkend="guc-log-duration"/>, 和相关的设置。
        该设置的非零值会增加一些开销，特别是当参数以二进制形式发送时，因为需要转换为文本。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-parameter-max-length-on-error" xreflabel="log_parameter_max_length_on_error">
<!--==========================orignal english content==========================
      <term><varname>log_parameter_max_length_on_error</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>log_parameter_max_length_on_error</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>log_parameter_max_length_on_error</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>log_parameter_max_length_on_error</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        If greater than zero, each bind parameter value reported in error
        messages is trimmed to this many bytes.
        Zero (the default) disables including bind parameters in error
        messages.
        <literal>-1</literal> allows bind parameters to be printed in full.
        If this value is specified without units, it is taken as bytes.
       </para>
____________________________________________________________________________-->
       <para>
        如果大于零，则错误消息中报告的每个绑定参数值都将裁剪为这么多字节。
        零(默认值)禁止在错误消息中包含绑定参数。<literal>-1</literal>允许打印完整绑定参数。
        如果指定此值时没有单位，则将其作为字节。
       </para>

<!--==========================orignal english content==========================
       <para>
        Non-zero values of this setting add overhead, as
        <productname>PostgreSQL</productname> will need to store textual
        representations of parameter values in memory at the start of each
        statement, whether or not an error eventually occurs.  The overhead
        is greater when bind parameters are sent in binary form than when
        they are sent as text, since the former case requires data
        conversion while the latter only requires copying the string.
       </para>
____________________________________________________________________________-->
       <para>
        该设置的非零值会增加开销，由于<productname>PostgreSQL</productname>需要在每条语句的开始处将参数值的文本表示存储在内存中，无论最终是否会发生错误。
        当绑定参数以二进制形式发送时，开销比以文本形式发送时更大，因为前者需要数据转换，而后者只需要复制字符串。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-statement" xreflabel="log_statement">
<!--==========================orignal english content==========================
      <term><varname>log_statement</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>log_statement</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>log_statement</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>log_statement</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Controls which SQL statements are logged. Valid values are
        <literal>none</literal> (off), <literal>ddl</literal>, <literal>mod</literal>, and
        <literal>all</literal> (all statements). <literal>ddl</literal> logs all data definition
        statements, such as <command>CREATE</command>, <command>ALTER</command>, and
        <command>DROP</command> statements. <literal>mod</literal> logs all
        <literal>ddl</literal> statements, plus data-modifying statements
        such as <command>INSERT</command>,
        <command>UPDATE</command>, <command>DELETE</command>, <command>TRUNCATE</command>,
        and <command>COPY FROM</command>.
        <command>PREPARE</command>, <command>EXECUTE</command>, and
        <command>EXPLAIN ANALYZE</command> statements are also logged if their
        contained command is of an appropriate type.  For clients using
        extended query protocol, logging occurs when an Execute message
        is received, and values of the Bind parameters are included
        (with any embedded single-quote marks doubled).
       </para>
____________________________________________________________________________-->
       <para>
        控制哪些 SQL 语句被记录。有效值是
        <literal>none</literal> (off)、<literal>ddl</literal>、<literal>mod</literal>和
        <literal>all</literal>（所有语句）。<literal>ddl</literal>记录所有数据定义语句，例如<command>CREATE</command>、<command>ALTER</command>和
        <command>DROP</command>语句。<literal>mod</literal>记录所有<literal>ddl</literal>语句，外加数据修改语句例如<command>INSERT</command>,
        <command>UPDATE</command>、<command>DELETE</command>、<command>TRUNCATE</command>,
        和<command>COPY FROM</command>。
        如果<command>PREPARE</command>、<command>EXECUTE</command>和
        <command>EXPLAIN ANALYZE</command>包含合适类型的命令，它们也会被记录。对于使用扩展查询协议的客户端，当收到一个执行消息时会产生日志并且会包括绑定参数的值（任何内嵌的单引号会被双写）。
       </para>

<!--==========================orignal english content==========================
       <para>
        The default is <literal>none</literal>. Only superusers can change this
        setting.
       </para>
____________________________________________________________________________-->
       <para>
        默认值是<literal>none</literal>。只有超级用户可以改变这个设置。
       </para>

       <note>
<!--==========================orignal english content==========================
        <para>
         Statements that contain simple syntax errors are not logged
         even by the <varname>log_statement</varname> = <literal>all</literal> setting,
         because the log message is emitted only after basic parsing has
         been done to determine the statement type.  In the case of extended
         query protocol, this setting likewise does not log statements that
         fail before the Execute phase (i.e., during parse analysis or
         planning).  Set <varname>log_min_error_statement</varname> to
         <literal>ERROR</literal> (or lower) to log such statements.
        </para>
____________________________________________________________________________-->
        <para>
         即使使用<varname>log_statement</varname> = <literal>all</literal>设置，包含简单语法错误的语句也不会被记录。这是因为只有在完成基本语法解析并确定了语句类型之后才会发出日志消息。在扩展查询协议的情况下，在执行阶段之前（即在解析分析或规划期间）出错的语句也不会被记录。将<varname>log_min_error_statement</varname>设置为<literal>ERROR</literal>（或更低）来记录这种语句。
        </para>
       </note>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-replication-commands" xreflabel="log_replication_commands">
<!--==========================orignal english content==========================
      <term><varname>log_replication_commands</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_replication_commands</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>log_replication_commands</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_replication_commands</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Causes each replication command to be logged in the server log.
        See <xref linkend="protocol-replication"/> for more information about
        replication command. The default value is <literal>off</literal>.
        Only superusers can change this setting.
       </para>
____________________________________________________________________________-->
       <para>
        导致每一个复制命令都被记录在服务器日志中。关于复制命令的详细信息请见
        <xref linkend="protocol-replication"/>。默认值是<literal>off</literal>。只有
        超级用户可以更改这个设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-temp-files" xreflabel="log_temp_files">
<!--==========================orignal english content==========================
      <term><varname>log_temp_files</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>log_temp_files</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>log_temp_files</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>log_temp_files</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Controls logging of temporary file names and sizes.
        Temporary files can be
        created for sorts, hashes, and temporary query results.
        If enabled by this setting, a log entry is emitted for each
        temporary file when it is deleted.
        A value of zero logs all temporary file information, while positive
        values log only files whose size is greater than or equal to
        the specified amount of data.
        If this value is specified without units, it is taken as kilobytes.
        The default setting is -1, which disables such logging.
        Only superusers can change this setting.
       </para>
____________________________________________________________________________-->
       <para>
        控制记录临时文件名和尺寸。临时文件可以被创建用来排序、哈希和存储临时查询结果。
        如果启用这个设置，当每一个临时文件被删除时都会产生一个日志项。
        一个零值记录所有临时文件信息，而正值只记录尺寸大于或等于指定数据量的文件。如果指定值时没有单位，则以千字节为单位。默认设置为 -1，它禁用这种记录。只有超级用户可以更改这个设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-timezone" xreflabel="log_timezone">
<!--==========================orignal english content==========================
      <term><varname>log_timezone</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>log_timezone</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>log_timezone</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>log_timezone</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the time zone used for timestamps written in the server log.
        Unlike <xref linkend="guc-timezone"/>, this value is cluster-wide,
        so that all sessions will report timestamps consistently.
        The built-in default is <literal>GMT</literal>, but that is typically
        overridden in <filename>postgresql.conf</filename>; <application>initdb</application>
        will install a setting there corresponding to its system environment.
        See <xref linkend="datatype-timezones"/> for more information.
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        设置在服务器日志中写入的时间戳的时区。和<xref linkend="guc-timezone"/>不同，这个值是集簇范围的，因此所有会话将报告一致的时间戳。内建默认值是<literal>GMT</literal>，但是通常会被在<filename>postgresql.conf</filename>中覆盖。<application>initdb</application>将安装一个对应于其系统环境的设置。详见<xref linkend="datatype-timezones"/>。这个参数只能在<filename>postgresql.conf</filename>文件中或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect2>
     <sect2 id="runtime-config-logging-csvlog">
<!--==========================orignal english content==========================
     <title>Using CSV-Format Log Output</title>
____________________________________________________________________________-->
     <title>使用 CSV 格式的日志输出</title>
<!--==========================orignal english content==========================
       <para>
        Including <literal>csvlog</literal> in the <varname>log_destination</varname> list
        provides a convenient way to import log files into a database table.
        This option emits log lines in comma-separated-values
        (<acronym>CSV</acronym>) format,
        with these columns:
        time stamp with milliseconds,
        user name,
        database name,
        process ID,
        client host:port number,
        session ID,
        per-session line number,
        command tag,
        session start time,
        virtual transaction ID,
        regular transaction ID,
        error severity,
        SQLSTATE code,
        error message,
        error message detail,
        hint,
        internal query that led to the error (if any),
        character count of the error position therein,
        error context,
        user query that led to the error (if any and enabled by
        <varname>log_min_error_statement</varname>),
        character count of the error position therein,
        location of the error in the PostgreSQL source code
        (if <varname>log_error_verbosity</varname> is set to <literal>verbose</literal>),
        application name, backend type, process ID of parallel group leader,
        and query id.
        Here is a sample table definition for storing CSV-format log output:

<programlisting>
CREATE TABLE postgres_log
(
  log_time timestamp(3) with time zone,
  user_name text,
  database_name text,
  process_id integer,
  connection_from text,
  session_id text,
  session_line_num bigint,
  command_tag text,
  session_start_time timestamp with time zone,
  virtual_transaction_id text,
  transaction_id bigint,
  error_severity text,
  sql_state_code text,
  message text,
  detail text,
  hint text,
  internal_query text,
  internal_query_pos integer,
  context text,
  query text,
  query_pos integer,
  location text,
  application_name text,
  backend_type text,
  leader_pid integer,
  query_id bigint,
  PRIMARY KEY (session_id, session_line_num)
);
</programlisting>
       </para>
____________________________________________________________________________-->
       <para>
        在<varname>log_destination</varname>列表中包括<literal>csvlog</literal>提供了一种便捷方式将日志文件导入到一个数据库表。这个选项发出逗号分隔值（<acronym>CSV</acronym>）格式的日志行，包括这些列：
        带毫秒的时间戳、
        用户名、
        数据库名、
        进程 ID、
        客户端主机:端口号、
        会话 ID、
        每个会话的行号、
        命令标签、
        会话开始时间、
        虚拟事务 ID、
        普通事务 ID、
        错误严重性、
        SQLSTATE 代码、
        错误消息、
        错误消息详情、
        提示、
        导致错误的内部查询（如果有）、
        错误位置所在的字符计数、
        错误上下文、
        导致错误的用户查询（如果有且被<varname>log_min_error_statement</varname>启用）、
        错误位置所在的字符计数、
        在 PostgreSQL 源代码中错误的位置（如果<varname>log_error_verbosity</varname>被设置为<literal>verbose</literal>）以及应用名，后端类型，并行组leader的进程ID和查询ID。
        下面是一个定义用来存储 CSV 格式日志输出的样表：

<programlisting>
CREATE TABLE postgres_log
(
  log_time timestamp(3) with time zone,
  user_name text,
  database_name text,
  process_id integer,
  connection_from text,
  session_id text,
  session_line_num bigint,
  command_tag text,
  session_start_time timestamp with time zone,
  virtual_transaction_id text,
  transaction_id bigint,
  error_severity text,
  sql_state_code text,
  message text,
  detail text,
  hint text,
  internal_query text,
  internal_query_pos integer,
  context text,
  query text,
  query_pos integer,
  location text,
  application_name text,
  backend_type text,
  leader_pid integer,
  query_id bigint,
  PRIMARY KEY (session_id, session_line_num)
);
</programlisting>
        It is also possible to access the file as a foreign table, using
        the supplied <xref linkend="file-fdw"/> module.
       </para>

<!--==========================orignal english content==========================
       <para>
        To import a log file into this table, use the <command>COPY FROM</command>
        command:

<programlisting>
COPY postgres_log FROM '/full/path/to/logfile.csv' WITH csv;
</programlisting>
        It is also possible to access the file as a foreign table, using
        the supplied <xref linkend="file-fdw"/> module.
       </para>
____________________________________________________________________________-->
       <para>
        使用<command>COPY FROM</command>命令将一个日志文件导入到这个表中：

<programlisting>
COPY postgres_log FROM '/full/path/to/logfile.csv' WITH csv;
</programlisting>
		也可以作为外部表访问该文件，使用提供的 <xref linkend="file-fdw"/> 模块。
       </para>

<!--==========================orignal english content==========================
       <para>
       There are a few things you need to do to simplify importing CSV log
       files:

       <orderedlist>
         <listitem>
           <para>
            Set <varname>log_filename</varname> and
            <varname>log_rotation_age</varname> to provide a consistent,
            predictable naming scheme for your log files.  This lets you
            predict what the file name will be and know when an individual log
            file is complete and therefore ready to be imported.
         </para>
        </listitem>

        <listitem>
           <para>
            Set <varname>log_rotation_size</varname> to 0 to disable
            size-based log rotation, as it makes the log file name difficult
            to predict.
           </para>
        </listitem>

        <listitem>
          <para>
           Set <varname>log_truncate_on_rotation</varname> to <literal>on</literal> so
           that old log data isn't mixed with the new in the same file.
          </para>
        </listitem>

        <listitem>
          <para>
           The table definition above includes a primary key specification.
           This is useful to protect against accidentally importing the same
           information twice.  The <command>COPY</command> command commits all of the
           data it imports at one time, so any error will cause the entire
           import to fail.  If you import a partial log file and later import
           the file again when it is complete, the primary key violation will
           cause the import to fail.  Wait until the log is complete and
           closed before importing.  This procedure will also protect against
           accidentally importing a partial line that hasn't been completely
           written, which would also cause <command>COPY</command> to fail.
          </para>
        </listitem>
        </orderedlist>
      </para>
____________________________________________________________________________-->
       <para>
       你可以做一些事情来简化导入 CSV 日志文件：

       <orderedlist>
         <listitem>
           <para>
            设置<varname>log_filename</varname>和<varname>log_rotation_age</varname>为你的日志文件提供一种一致的、可预测的命名空间。这让你预测文件名会是怎样以及知道什么时候一个个体日志文件完成并且因此准备好被导入。
         </para>
        </listitem>

        <listitem>
           <para>
            将<varname>log_rotation_size</varname>设置为 0 来禁用基于尺寸的日志轮转，因为它使得日志文件名难以预测。
           </para>
        </listitem>

        <listitem>
          <para>
           将<varname>log_truncate_on_rotation</varname>设置为<literal>on</literal>，这样在同一个文件中旧日志数据不会与新数据混杂。
          </para>
        </listitem>

        <listitem>
          <para>
           上述表定义包括一个主键声明。这有助于避免意外地两次导入相同的信息。<command>COPY</command>命令一次提交所有它导入的数据，因此任何错误将导致整个导入失败。如果你导入一个部分完成的日志文件并且稍后当它完全完成后再次导入，主键违背将导致导入失败。请等到日志完成且被关闭之后再导入。这个过程也可以避免意外地导入部分完成的行，这种行也将导致<command>COPY</command>失败。
          </para>
        </listitem>
        </orderedlist>
      </para>
    </sect2>

   <sect2>
<!--==========================orignal english content==========================
    <title>Process Title</title>
____________________________________________________________________________-->
    <title>进程标题</title>
<!--==========================orignal english content==========================
    <para>
     These settings control how process titles of server processes are
     modified.  Process titles are typically viewed using programs like
     <application>ps</application> or, on Windows, <application>Process Explorer</application>.
     See <xref linkend="monitoring-ps"/> for details.
    </para>
____________________________________________________________________________-->
    <para>
     这些设置控制服务器进程的进程标题如何被修改。进程标题通常可以用<application>ps</application>或者 Windows 上的<application>进程浏览器</application>等程序来查看。详见<xref linkend="monitoring-ps"/>。
    </para>

    <variablelist>
     <varlistentry id="guc-cluster-name" xreflabel="cluster_name">
<!--==========================orignal english content==========================
      <term><varname>cluster_name</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>cluster_name</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>cluster_name</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>cluster_name</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets a name that identifies this database cluster (instance) for
        various purposes.  The cluster name appears in the process title for
        all server processes in this cluster.  Moreover, it is the default
        application name for a standby connection (see <xref
        linkend="guc-synchronous-standby-names"/>.)
       </para>
____________________________________________________________________________-->
       <para>
        为不同目的设置标识这个数据库集群(实例)的名称。此集群名称出现在该集群中所有服务器进程的进程标题中。
        此外，它还是备用连接的默认应用名称。(参见 <xref linkend="guc-synchronous-standby-names"/>.)
       </para>

<!--==========================orignal english content==========================
       <para>
        The name can be any string of less
        than <symbol>NAMEDATALEN</symbol> characters (64 characters in a standard
        build). Only printable ASCII characters may be used in the
        <varname>cluster_name</varname> value. Other characters will be
        replaced with question marks (<literal>?</literal>).  No name is shown
        if this parameter is set to the empty string <literal>''</literal> (which is
        the default). This parameter can only be set at server start.
       </para>
____________________________________________________________________________-->
       <para>
        这个名称可以是任何长度不超过<symbol>NAMEDATALEN</symbol>个字符（在标准编译中是 64字符）的任何字符串。只有可打印的 ASCII 字符能被用在<varname>cluster_name</varname>值中。其他字符将被替换为问号（<literal>?</literal>）。如果这个参数被设置为空字符串<literal>''</literal>（也是默认值），将不会显示名称。这个参数只能在服务器启动时设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-update-process-title" xreflabel="update_process_title">
<!--==========================orignal english content==========================
      <term><varname>update_process_title</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>update_process_title</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>update_process_title</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>update_process_title</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Enables updating of the process title every time a new SQL command
        is received by the server.
        This setting defaults to <literal>on</literal> on most platforms, but it
        defaults to <literal>off</literal> on Windows due to that platform's larger
        overhead for updating the process title.
        Only superusers can change this setting.
       </para>
____________________________________________________________________________-->
       <para>
        启用进程标题更新，每次服务器接收到一个新的 SQL 命令时都更新进程标题。在大部分平台上这个设置默认为<literal>on</literal>，但是由于 Windows 上更新进程标题的开销更大，所以在 Windows 这个设置默认为<literal>off</literal>。只有超级用户能更改这个设置。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect2>
  </sect1>

   <sect1 id="runtime-config-statistics">
<!--==========================orignal english content==========================
    <title>Run-time Statistics</title>
____________________________________________________________________________-->
    <title>运行时统计数据</title>

    <sect2 id="runtime-config-statistics-collector">
<!--==========================orignal english content==========================
     <title>Query and Index Statistics Collector</title>
____________________________________________________________________________-->
     <title>查询和索引统计收集器</title>
<!--==========================orignal english content==========================
     <para>
      These parameters control server-wide statistics collection features.
      When statistics collection is enabled, the data that is produced can be
      accessed via the <structname>pg_stat</structname> and
      <structname>pg_statio</structname> family of system views.
      Refer to <xref linkend="monitoring"/> for more information.
     </para>
____________________________________________________________________________-->
     <para>
      这些参数控制服务器范围的统计数据收集特性。当统计收集被启用时，被产生的数据可以通过<structname>pg_stat</structname>和<structname>pg_statio</structname>系统视图族访问。详见<xref linkend="monitoring"/>。
     </para>

     <variablelist>

     <varlistentry id="guc-track-activities" xreflabel="track_activities">
<!--==========================orignal english content==========================
      <term><varname>track_activities</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>track_activities</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>track_activities</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>track_activities</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Enables the collection of information on the currently
        executing command of each session, along with its identifier and the
        time when that command began execution. This parameter is on by
        default. Note that even when enabled, this information is not
        visible to all users, only to superusers and the user owning
        the session being reported on, so it should not represent a
        security risk.
        Only superusers can change this setting.
       </para>
____________________________________________________________________________-->
       <para>
        启用对每个会话的当前执行命令的信息收集，还有它的标识符和命令开始执行的时间。
        这个参数默认为打开。注意即使被启用，这些信息也不是对所有用户可见，只有超级用户和拥有报告信息的会话的用户可见，因此它不会表现为一个安全风险。
        只有超级用户可以更改这个设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-track-activity-query-size" xreflabel="track_activity_query_size">
<!--==========================orignal english content==========================
      <term><varname>track_activity_query_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>track_activity_query_size</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>track_activity_query_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>track_activity_query_size</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
       Specifies the amount of memory reserved to store the text of the
       currently executing command for each active session, for the
       <structname>pg_stat_activity</structname>.<structfield>query</structfield> field.
       If this value is specified without units, it is taken as bytes.
       The default value is 1024 bytes.
       This parameter can only be set at server start.
       </para>
____________________________________________________________________________-->
       <para>
       为每个活动会话指定存储当前执行命令的文本所保留的内存量，它们被用于<structname>pg_stat_activity</structname>.<structfield>query</structfield>域。
       如果指定值时没有单位，则以字节为单位。默认值是 1024字节。这个参数只能在服务器启动时被设置。  
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-track-counts" xreflabel="track_counts">
<!--==========================orignal english content==========================
      <term><varname>track_counts</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>track_counts</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>track_counts</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>track_counts</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Enables collection of statistics on database activity.
        This parameter is on by default, because the autovacuum
        daemon needs the collected information.
        Only superusers can change this setting.
       </para>
____________________________________________________________________________-->
       <para>
        启用在数据库活动上的统计收集。这个参数默认为打开，因为自动清理守护进程需要被收集的信息。只有超级用户可以更改这个设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-track-io-timing" xreflabel="track_io_timing">
<!--==========================orignal english content==========================
      <term><varname>track_io_timing</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>track_io_timing</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>track_io_timing</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>track_io_timing</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Enables timing of database I/O calls.  This parameter is off by
        default, as it will repeatedly query the operating system for
        the current time, which may cause significant overhead on some
        platforms.  You can use the <xref linkend="pgtesttiming"/> tool to
        measure the overhead of timing on your system.
        I/O timing information is
        displayed in <link linkend="monitoring-pg-stat-database-view">
        <structname>pg_stat_database</structname></link>, in the output of
        <xref linkend="sql-explain"/> when the <literal>BUFFERS</literal> option
        is used, by autovacuum for auto-vacuums and auto-analyzes, when
        <xref linkend="guc-log-autovacuum-min-duration"/> is set and by
        <xref linkend="pgstatstatements"/>.  Only superusers can change this
        setting.
       </para>
____________________________________________________________________________-->
       <para>
        启用对系统 I/O 调用的计时。这个参数默认为关闭，因为它将重复地向操作系统查询当前时间，这会在某些平台上导致显著的负荷。
        你可以使用<xref linkend="pgtesttiming"/>工具来度量你的系统中计时的开销。
        I/O 计时信息被显示在<link linkend="monitoring-pg-stat-database-view"> <structname>pg_stat_database</structname></link>中，
        当<literal>BUFFERS</literal>选项被使用时的<xref linkend="sql-explain"/>输出中，通过autovacuum对auto-vacuums 和 auto-analyzes，当 <xref linkend="guc-log-autovacuum-min-duration"/> 被<xref linkend="pgstatstatements"/>设置时。
        只有超级用户可以更改这个设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-track-wal-io-timing" xreflabel="track_wal_io_timing">
<!--==========================orignal english content==========================
      <term><varname>track_wal_io_timing</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>track_wal_io_timing</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>track_wal_io_timing</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>track_wal_io_timing</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Enables timing of WAL I/O calls. This parameter is off by default,
        as it will repeatedly query the operating system for the current time,
        which may cause significant overhead on some platforms.
        You can use the <application>pg_test_timing</application> tool to
        measure the overhead of timing on your system.
        I/O timing information is
        displayed in <link linkend="monitoring-pg-stat-wal-view">
        <structname>pg_stat_wal</structname></link>.  Only superusers can
        change this setting.
       </para>
____________________________________________________________________________-->
       <para>
        激活WAL I/O调用的计时。
        该参数默认为关闭，因为它将重复查询操作系统当前时间，这可能在某些平台上造成显著的开销。
        您可以使用<application>pg_test_timing</application>工具来评估系统上的定时开销。
        I/O计时信息在<link linkend="monitoring-pg-stat-wal-view"><structname>pg_stat_wal</structname></link>.中显示。
        只有超级用户才能改变此设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-track-functions" xreflabel="track_functions">
<!--==========================orignal english content==========================
      <term><varname>track_functions</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>track_functions</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>track_functions</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>track_functions</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Enables tracking of function call counts and time used. Specify
        <literal>pl</literal> to track only procedural-language functions,
        <literal>all</literal> to also track SQL and C language functions.
        The default is <literal>none</literal>, which disables function
        statistics tracking.  Only superusers can change this setting.
       </para>
____________________________________________________________________________-->
       <para>
        启用跟踪函数调用计数和用时。指定<literal>pl</literal>只跟踪过程语言函数，指定<literal>all</literal>还会跟踪 SQL 和 C 语言函数。默认值是<literal>none</literal>，它禁用函数统计跟踪。只有超级用户可以更改这个设置。
       </para>

       <note>
<!--==========================orignal english content==========================
        <para>
         SQL-language functions that are simple enough to be <quote>inlined</quote>
         into the calling query will not be tracked, regardless of this
         setting.
        </para>
____________________________________________________________________________-->
        <para>
         简单到足以被<quote>内联</quote>到调用查询中的 SQL 语言函数不会被跟踪， 而不管这个设置。
        </para>
       </note>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-stats-temp-directory" xreflabel="stats_temp_directory">
<!--==========================orignal english content==========================
      <term><varname>stats_temp_directory</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>stats_temp_directory</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>stats_temp_directory</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>stats_temp_directory</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the directory to store temporary statistics data in. This can be
        a path relative to the data directory or an absolute path. The default
        is <filename>pg_stat_tmp</filename>. Pointing this at a RAM-based
        file system will decrease physical I/O requirements and can lead to
        improved performance.
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        设置存储临时统计数据的目录。这可以是一个相对于数据目录的路径或一个绝对路径。默认值是<filename>pg_stat_tmp</filename>。在一个基于 RAM 的文件系统上指明这个参数将降低物理 I/O 需求，并且提高性能。这个参数只能在<filename>postgresql.conf</filename>文件中或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect2>

    <sect2 id="runtime-config-statistics-monitor">
<!--==========================orignal english content==========================
     <title>Statistics Monitoring</title>
____________________________________________________________________________-->
     <title>统计监控</title>
     <variablelist>

     <varlistentry id="guc-compute-query-id" xreflabel="compute_query_id">
<!--==========================orignal english content==========================
      <term><varname>compute_query_id</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>compute_query_id</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>compute_query_id</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>compute_query_id</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Enables in-core computation of a query identifier.
        Query identifiers can be displayed in the <link
        linkend="monitoring-pg-stat-activity-view"><structname>pg_stat_activity</structname></link>
        view, using <command>EXPLAIN</command>, or emitted in the log if
        configured via the <xref linkend="guc-log-line-prefix"/> parameter.
        The <xref linkend="pgstatstatements"/> extension also requires a query
        identifier to be computed.  Note that an external module can
        alternatively be used if the in-core query identifier computation
        method is not acceptable.  In this case, in-core computation
        must be always disabled.
        Valid values are <literal>off</literal> (always disabled),
        <literal>on</literal> (always enabled) and <literal>auto</literal>,
        which lets modules such as <xref linkend="pgstatstatements"/>
        automatically enable it.
        The default is <literal>auto</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        启用查询标识符的内核中计算。
        查询标识符可以显示在<link linkend="monitoring-pg-stat-activity-view"><structname>pg_stat_activity</structname></link>视图中，使用<command>EXPLAIN</command>，或者在日志中发出，如果通过<xref linkend="guc-log-line-prefix"/>参数配置，。
        <xref linkend="pgstatstatements"/>扩展还需要一个查询标识符以计算。
        注意，如果内核中查询标识符计算方法不可接受，也可以使用外部模块。
        在这种情况下，必须始终禁用核内计算。
        有效的值为<literal>off</literal>(总是禁用)，<literal>on</literal>(总是启用)和<literal>auto</literal>，这让像<xref linkend="pgstatstatements"/>的模块自动启用它。
        默认为<literal>auto</literal>。
       </para>
       <note>
<!--==========================orignal english content==========================
        <para>
         To ensure that only one query identifier is calculated and
         displayed, extensions that calculate query identifiers should
         throw an error if a query identifier has already been computed.
        </para>
____________________________________________________________________________-->
        <para>
         确认只有一个查询标识符被计算和显示，如果一个查询标识符已经被计算，扩展计算标识符将抛出一个错误。
        </para>
       </note>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><varname>log_statement_stats</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_statement_stats</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>log_statement_stats</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_statement_stats</varname>配置参数</primary>
      </indexterm>
      </term>
<!--==========================orignal english content==========================
      <term><varname>log_parser_stats</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_parser_stats</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>log_parser_stats</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_parser_stats</varname>配置参数</primary>
      </indexterm>
      </term>
<!--==========================orignal english content==========================
      <term><varname>log_planner_stats</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_planner_stats</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>log_planner_stats</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_planner_stats</varname>配置参数</primary>
      </indexterm>
      </term>
<!--==========================orignal english content==========================
      <term><varname>log_executor_stats</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_executor_stats</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>log_executor_stats</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_executor_stats</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        For each query, output performance statistics of the respective
        module to the server log. This is a crude profiling
        instrument, similar to the Unix <function>getrusage()</function> operating
        system facility.  <varname>log_statement_stats</varname> reports total
        statement statistics, while the others report per-module statistics.
        <varname>log_statement_stats</varname> cannot be enabled together with
        any of the per-module options.  All of these options are disabled by
        default.   Only superusers can change these settings.
       </para>
____________________________________________________________________________-->
       <para>
        对每个查询，向服务器日志里输出相应模块的性能统计。这是一种粗糙的分析工具。类似于 Unix 的<function>getrusage()</function>系统功能。<varname>log_statement_stats</varname>报告总的语句统计，而其它的报告针每个模块的统计。<varname>log_statement_stats</varname>不能和 其它任何针对每个模块统计的选项一起启用。所有这些选项都是默认禁用的。只有超级用户可以更改这个设置。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>

    </sect2>
   </sect1>

   <sect1 id="runtime-config-autovacuum">
<!--==========================orignal english content==========================
    <title>Automatic Vacuuming</title>
____________________________________________________________________________-->
    <title>自动清理</title>
<!--==========================orignal english content==========================
    <indexterm>
     <primary>autovacuum</primary>
     <secondary>configuration parameters</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>自动清理</primary>
     <secondary>配置参数</secondary>
    </indexterm>

<!--==========================orignal english content==========================
     <para>
      These settings control the behavior of the <firstterm>autovacuum</firstterm>
      feature.  Refer to <xref linkend="autovacuum"/> for more information.
      Note that many of these settings can be overridden on a per-table
      basis; see <xref linkend="sql-createtable-storage-parameters"/>.
     </para>
____________________________________________________________________________-->
     <para>
      这些设置控制<firstterm>autovacuum</firstterm>特性的行为。详情请参考
      <xref linkend="autovacuum"/>。注意很多这些设置可以被针对每个表
      的设置所覆盖，参见<xref linkend="sql-createtable-storage-parameters"/>。
     </para>

    <variablelist>

     <varlistentry id="guc-autovacuum" xreflabel="autovacuum">
<!--==========================orignal english content==========================
      <term><varname>autovacuum</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>autovacuum</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>autovacuum</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>autovacuum</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Controls whether the server should run the
        autovacuum launcher daemon.  This is on by default; however,
        <xref linkend="guc-track-counts"/> must also be enabled for
        autovacuum to work.
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line; however, autovacuuming can be
        disabled for individual tables by changing table storage parameters.
       </para>
____________________________________________________________________________-->
       <para>
        控制服务器是否运行自动清理启动器后台进程。默认为开启，
        不过要自动清理正常工作还需要启用<xref linkend="guc-track-counts"/>。
        该参数只能在<filename>postgresql.conf</filename>文件或服务器命令行中设置，
        不过，通过更改表存储参数可以为表禁用自动清理。
       </para>

<!--==========================orignal english content==========================
       <para>
        Note that even when this parameter is disabled, the system
        will launch autovacuum processes if necessary to
        prevent transaction ID wraparound.  See <xref
        linkend="vacuum-for-wraparound"/> for more information.
       </para>
____________________________________________________________________________-->
       <para>
        注意即使该参数被禁用，系统也会在需要防止事务ID回卷时发起清理进程。详情请见<xref linkend="vacuum-for-wraparound"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-autovacuum-max-workers" xreflabel="autovacuum_max_workers">
<!--==========================orignal english content==========================
      <term><varname>autovacuum_max_workers</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>autovacuum_max_workers</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>autovacuum_max_workers</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>autovacuum_max_workers</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the maximum number of autovacuum processes (other than the
        autovacuum launcher) that may be running at any one time.  The default
        is three.  This parameter can only be set at server start.
       </para>
____________________________________________________________________________-->
       <para>
        指定能同时运行的自动清理进程（除了自动清理启动器之外）的最大数量。默认值为3。该参数只能在服务器启动时设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-autovacuum-naptime" xreflabel="autovacuum_naptime">
<!--==========================orignal english content==========================
      <term><varname>autovacuum_naptime</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>autovacuum_naptime</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>autovacuum_naptime</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>autovacuum_naptime</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the minimum delay between autovacuum runs on any given
        database.  In each round the daemon examines the
        database and issues <command>VACUUM</command> and <command>ANALYZE</command> commands
        as needed for tables in that database.
        If this value is specified without units, it is taken as seconds.
        The default is one minute (<literal>1min</literal>).
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        指定自动清理在任意给定数据库上运行的最小延迟。在每一轮中后台进程检查数据库并根据需要为数据库中的表发出<command>VACUUM</command>和<command>ANALYZE</command>命令。
        如果指定值时没有单位，则以秒为单位。默认值为1分钟（<literal>1min</literal>）。该参数只能在<filename>postgresql.conf</filename>文件或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-autovacuum-vacuum-threshold" xreflabel="autovacuum_vacuum_threshold">
<!--==========================orignal english content==========================
      <term><varname>autovacuum_vacuum_threshold</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>autovacuum_vacuum_threshold</varname></primary>
       <secondary>configuration parameter</secondary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>autovacuum_vacuum_threshold</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>autovacuum_vacuum_threshold</varname></primary>
       <secondary>配置参数</secondary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the minimum number of updated or deleted tuples needed
        to trigger a <command>VACUUM</command> in any one table.
        The default is 50 tuples.
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line;
        but the setting can be overridden for individual tables by
        changing table storage parameters.
       </para>
____________________________________________________________________________-->
       <para>
        指定能在一个表上触发<command>VACUUM</command>的被更新或被删除元组的最小数量。默认值为50个元组。该参数只能在<filename>postgresql.conf</filename>文件或在服务器命令中设置。但是对个别表可以通过修改表存储参数来覆盖该设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-autovacuum-vacuum-insert-threshold" xreflabel="autovacuum_vacuum_insert_threshold">
<!--==========================orignal english content==========================
      <term><varname>autovacuum_vacuum_insert_threshold</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>autovacuum_vacuum_insert_threshold</varname></primary>
       <secondary>configuration parameter</secondary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>autovacuum_vacuum_insert_threshold</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>autovacuum_vacuum_insert_threshold</varname></primary>
       <secondary>配置参数</secondary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the number of inserted tuples needed to trigger a
        <command>VACUUM</command> in any one table.
        The default is 1000 tuples.  If -1 is specified, autovacuum will not
        trigger a <command>VACUUM</command> operation on any tables based on
        the number of inserts.
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line;
        but the setting can be overridden for individual tables by
        changing table storage parameters.
       </para>
____________________________________________________________________________-->
       <para>
        指定在任何一个表中触发 <command>VACUUM</command>所需要插入的元组数。默认值为 1000 个元组。 
        如果指定了 -1，则autovacuum不会根据插入数量在任何表上触发 <command>VACUUM</command>操作。
        此参数只能在<filename>postgresql.conf</filename>文件或服务器命令行中设置;但可以通过更改表存储参数来覆盖单个表的设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-autovacuum-analyze-threshold" xreflabel="autovacuum_analyze_threshold">
<!--==========================orignal english content==========================
      <term><varname>autovacuum_analyze_threshold</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>autovacuum_analyze_threshold</varname></primary>
       <secondary>configuration parameter</secondary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>autovacuum_analyze_threshold</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>autovacuum_analyze_threshold</varname></primary>
       <secondary>配置参数</secondary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the minimum number of inserted, updated or deleted tuples
        needed to trigger an <command>ANALYZE</command> in any one table.
        The default is 50 tuples.
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line;
        but the setting can be overridden for individual tables by
        changing table storage parameters.
       </para>
____________________________________________________________________________-->
       <para>
        指定能在一个表上触发<command>ANALYZE</command>的被插入、被更新或被删除元组的最小数量。默认值为50个元组。该参数只能在<filename>postgresql.conf</filename>文件或在服务器命令中设置。但是对个别表可以通过修改表存储参数来覆盖该设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-autovacuum-vacuum-scale-factor" xreflabel="autovacuum_vacuum_scale_factor">
<!--==========================orignal english content==========================
      <term><varname>autovacuum_vacuum_scale_factor</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>autovacuum_vacuum_scale_factor</varname></primary>
       <secondary>configuration parameter</secondary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>autovacuum_vacuum_scale_factor</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>autovacuum_vacuum_scale_factor</varname></primary>
       <secondary>配置参数</secondary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies a fraction of the table size to add to
        <varname>autovacuum_vacuum_threshold</varname>
        when deciding whether to trigger a <command>VACUUM</command>.
        The default is 0.2 (20% of table size).
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line;
        but the setting can be overridden for individual tables by
        changing table storage parameters.
       </para>
____________________________________________________________________________-->
       <para>
        指定一个表尺寸的分数，在决定是否触发<command>VACUUM</command>时将它加到<varname>autovacuum_vacuum_threshold</varname>上。默认值为0.2（表尺寸的20%）。该参数只能在<filename>postgresql.conf</filename>文件或在服务器命令中设置。但是对个别表可以通过修改表存储参数来覆盖该设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-autovacuum-vacuum-insert-scale-factor" xreflabel="autovacuum_vacuum_insert_scale_factor">
<!--==========================orignal english content==========================
      <term><varname>autovacuum_vacuum_insert_scale_factor</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>autovacuum_vacuum_insert_scale_factor</varname></primary>
       <secondary>configuration parameter</secondary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>autovacuum_vacuum_insert_scale_factor</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>autovacuum_vacuum_insert_scale_factor</varname></primary>
       <secondary>配置参数</secondary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies a fraction of the table size to add to
        <varname>autovacuum_vacuum_insert_threshold</varname>
        when deciding whether to trigger a <command>VACUUM</command>.
        The default is 0.2 (20% of table size).
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line;
        but the setting can be overridden for individual tables by
        changing table storage parameters.
       </para>
____________________________________________________________________________-->
       <para>
        指定一个要添加到<varname>autovacuum_vacuum_insert_threshold</varname> 中的表的大小的比例，在决定是否触发<command>VACUUM</command>时。
        默认值为 0.2（表大小的 20%）。此参数只能在<filename>postgresql.conf</filename>文件或服务器命令行中设置;但可以通过更改表存储参数来覆盖单个表的设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-autovacuum-analyze-scale-factor" xreflabel="autovacuum_analyze_scale_factor">
<!--==========================orignal english content==========================
      <term><varname>autovacuum_analyze_scale_factor</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>autovacuum_analyze_scale_factor</varname></primary>
       <secondary>configuration parameter</secondary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>autovacuum_analyze_scale_factor</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>autovacuum_analyze_scale_factor</varname></primary>
       <secondary>配置参数</secondary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies a fraction of the table size to add to
        <varname>autovacuum_analyze_threshold</varname>
        when deciding whether to trigger an <command>ANALYZE</command>.
        The default is 0.1 (10% of table size).
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line;
        but the setting can be overridden for individual tables by
        changing table storage parameters.
       </para>
____________________________________________________________________________-->
       <para>
        指定一个表尺寸的分数，在决定是否触发<command>ANALYZE</command>时将它加到<varname>autovacuum_analyze_threshold</varname>上。默认值为0.1（表尺寸的10%）。该参数只能在<filename>postgresql.conf</filename>文件或在服务器命令中设置。但是对个别表可以通过修改表存储参数来覆盖该设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-autovacuum-freeze-max-age" xreflabel="autovacuum_freeze_max_age">
<!--==========================orignal english content==========================
      <term><varname>autovacuum_freeze_max_age</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>autovacuum_freeze_max_age</varname></primary>
       <secondary>configuration parameter</secondary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>autovacuum_freeze_max_age</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>autovacuum_freeze_max_age</varname></primary>
       <secondary>配置参数</secondary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the maximum age (in transactions) that a table's
        <structname>pg_class</structname>.<structfield>relfrozenxid</structfield> field can
        attain before a <command>VACUUM</command> operation is forced
        to prevent transaction ID wraparound within the table.
        Note that the system will launch autovacuum processes to
        prevent wraparound even when autovacuum is otherwise disabled.
       </para>
____________________________________________________________________________-->
       <para>
        指定在一个<command>VACUUM</command>操作被强制执行来防止表中事务ID回卷之前，一个表的<structname>pg_class</structname>.<structfield>relfrozenxid</structfield>域能保持的最大年龄（事务的）。注意即便自动清理被禁用，系统也将发起自动清理进程来阻止回卷。
       </para>

<!--==========================orignal english content==========================
       <para>
        Vacuum also allows removal of old files from the
        <filename>pg_xact</filename> subdirectory, which is why the default
        is a relatively low 200 million transactions.
        This parameter can only be set at server start, but the setting
        can be reduced for individual tables by
        changing table storage parameters.
        For more information see <xref linkend="vacuum-for-wraparound"/>.
       </para>
____________________________________________________________________________-->
       <para>
        清理也允许从<filename>pg_xact</filename>子目录中移除旧文件，这也是为什么默认值被设置为较低的2亿事务。该参数只能在服务器启动时设置，但是对于个别表可以通过修改表存储参数来降低该设置。详见<xref linkend="vacuum-for-wraparound"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-autovacuum-multixact-freeze-max-age" xreflabel="autovacuum_multixact_freeze_max_age">
<!--==========================orignal english content==========================
      <term><varname>autovacuum_multixact_freeze_max_age</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>autovacuum_multixact_freeze_max_age</varname></primary>
       <secondary>configuration parameter</secondary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>autovacuum_multixact_freeze_max_age</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>autovacuum_multixact_freeze_max_age</varname></primary>
       <secondary>配置参数</secondary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the maximum age (in multixacts) that a table's
        <structname>pg_class</structname>.<structfield>relminmxid</structfield> field can
        attain before a <command>VACUUM</command> operation is forced to
        prevent multixact ID wraparound within the table.
        Note that the system will launch autovacuum processes to
        prevent wraparound even when autovacuum is otherwise disabled.
       </para>
____________________________________________________________________________-->
       <para>
        指定在一个<command>VACUUM</command>操作被强制执行来防止表中多事务ID回卷之前，一个表的<structname>pg_class</structname>.<structfield>relminmxid</structfield>域能保持的最大年龄（多事务的）。注意即便自动清理被禁用，系统也将发起自动清理进程来阻止回卷。
       </para>

<!--==========================orignal english content==========================
       <para>
        Vacuuming multixacts also allows removal of old files from the
        <filename>pg_multixact/members</filename> and <filename>pg_multixact/offsets</filename>
        subdirectories, which is why the default is a relatively low
        400 million multixacts.
        This parameter can only be set at server start, but the setting can
        be reduced for individual tables by changing table storage parameters.
        For more information see <xref linkend="vacuum-for-multixact-wraparound"/>.
       </para>
____________________________________________________________________________-->
       <para>
        清理多事务也允许从<filename>pg_multixact/members</filename>和<filename>pg_multixact/offsets</filename>子目录中移除旧文件，这也是为什么默认值被设置为较低的4亿事务。该参数只能在服务器启动时设置，但是对于个别表可以通过修改表存储参数来降低该设置。详见<xref linkend="vacuum-for-multixact-wraparound"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-autovacuum-vacuum-cost-delay" xreflabel="autovacuum_vacuum_cost_delay">
<!--==========================orignal english content==========================
      <term><varname>autovacuum_vacuum_cost_delay</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>autovacuum_vacuum_cost_delay</varname></primary>
       <secondary>configuration parameter</secondary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>autovacuum_vacuum_cost_delay</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>autovacuum_vacuum_cost_delay</varname></primary>
       <secondary>配置参数</secondary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the cost delay value that will be used in automatic
        <command>VACUUM</command> operations.  If -1 is specified, the regular
        <xref linkend="guc-vacuum-cost-delay"/> value will be used.
        If this value is specified without units, it is taken as milliseconds.
        The default value is 2 milliseconds.
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line;
        but the setting can be overridden for individual tables by
        changing table storage parameters.
       </para>
____________________________________________________________________________-->
       <para>
        指定用于自动<command>VACUUM</command>操作中的代价延迟值。如果指定-1，则使用<xref linkend="guc-vacuum-cost-delay"/>值。
        如果指定值时没有单位，则以毫秒为单位。默认值为2毫秒。该参数只能在<filename>postgresql.conf</filename>文件或在服务器命令中设置。但是对个别表可以通过修改表存储参数来覆盖该设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-autovacuum-vacuum-cost-limit" xreflabel="autovacuum_vacuum_cost_limit">
<!--==========================orignal english content==========================
      <term><varname>autovacuum_vacuum_cost_limit</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>autovacuum_vacuum_cost_limit</varname></primary>
       <secondary>configuration parameter</secondary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>autovacuum_vacuum_cost_limit</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>autovacuum_vacuum_cost_limit</varname></primary>
       <secondary>配置参数</secondary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the cost limit value that will be used in automatic
        <command>VACUUM</command> operations.  If -1 is specified (which is the
        default), the regular
        <xref linkend="guc-vacuum-cost-limit"/> value will be used.  Note that
        the value is distributed proportionally among the running autovacuum
        workers, if there is more than one, so that the sum of the limits for
        each worker does not exceed the value of this variable.
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line;
        but the setting can be overridden for individual tables by
        changing table storage parameters.
       </para>
____________________________________________________________________________-->
       <para>
        指定用于自动<command>VACUUM</command>操作中的代价限制值。如果指定-1（默认值），则使用<xref linkend="guc-vacuum-cost-limit"/>值。注意该值被按比例地分配到运行中的自动清理工作者上（如果有多个），因此每一个工作者的限制值之和不会超过这个变量中的值。该参数只能在<filename>postgresql.conf</filename>文件或在服务器命令中设置。但是对个别表可以通过修改表存储参数来覆盖该设置。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </sect1>

   <sect1 id="runtime-config-client">
<!--==========================orignal english content==========================
    <title>Client Connection Defaults</title>
____________________________________________________________________________-->
    <title>客户端连接默认值</title>

    <sect2 id="runtime-config-client-statement">
<!--==========================orignal english content==========================
     <title>Statement Behavior</title>
____________________________________________________________________________-->
     <title>语句行为</title>
     <variablelist>

     <varlistentry id="guc-client-min-messages" xreflabel="client_min_messages">
<!--==========================orignal english content==========================
      <term><varname>client_min_messages</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>client_min_messages</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>client_min_messages</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>client_min_messages</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Controls which
        <link linkend="runtime-config-severity-levels">message levels</link>
        are sent to the client.
        Valid values are <literal>DEBUG5</literal>,
        <literal>DEBUG4</literal>, <literal>DEBUG3</literal>, <literal>DEBUG2</literal>,
        <literal>DEBUG1</literal>, <literal>LOG</literal>, <literal>NOTICE</literal>,
        <literal>WARNING</literal>, and <literal>ERROR</literal>.
        Each level includes all the levels that follow it.  The later the level,
        the fewer messages are sent.  The default is
        <literal>NOTICE</literal>.  Note that <literal>LOG</literal> has a different
        rank here than in <xref linkend="guc-log-min-messages"/>.
       </para>
____________________________________________________________________________-->
       <para>
        控制被发送给客户端的<link linkend="runtime-config-severity-levels">消息级别</link>。有效值是<literal>DEBUG5</literal>、
        <literal>DEBUG4</literal>、<literal>DEBUG3</literal>、<literal>DEBUG2</literal>、
        <literal>DEBUG1</literal>、<literal>LOG</literal>、<literal>NOTICE</literal>、
        <literal>WARNING</literal>、<literal>ERROR</literal>。
        每个级别都包括其后的所有级别。级别越靠后，被发送的消息越少。默认值是<literal>NOTICE</literal>。
        注意<literal>LOG</literal>在这里有与<xref linkend="guc-log-min-messages"/>中不同的排名。
       </para>

<!--==========================orignal english content==========================
       <para>
        <literal>INFO</literal> level messages are always sent to the client.
       </para>
____________________________________________________________________________-->
       <para>
        <literal>INFO</literal> 级别的消息总是被发送到客户端。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-search-path" xreflabel="search_path">
<!--==========================orignal english content==========================
      <term><varname>search_path</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>search_path</varname> configuration parameter</primary>
      </indexterm>
      <indexterm><primary>path</primary><secondary>for schemas</secondary></indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>search_path</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>search_path</varname>配置参数</primary>
      </indexterm>
      <indexterm><primary>path</primary><secondary>for schemas</secondary></indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        This variable specifies the order in which schemas are searched
        when an object (table, data type, function, etc.) is referenced by a
        simple name with no schema specified.  When there are objects of
        identical names in different schemas, the one found first
        in the search path is used.  An object that is not in any of the
        schemas in the search path can only be referenced by specifying
        its containing schema with a qualified (dotted) name.
       </para>
____________________________________________________________________________-->
       <para>
        这个变量指定当一个对象（表、数据类型、函数等）被用一个无模式限定的简单名称引用时，用于进行搜索该对象的模式顺序。当在不同模式中有同名对象时，将使用第一个在搜索路径中被找到的对象。一个不属于搜索路径中任何一个模式的对象只能通过用限定名（带点号）指定包含它的模式来引用。
       </para>

<!--==========================orignal english content==========================
       <para>
        The value for <varname>search_path</varname> must be a comma-separated
        list of schema names.  Any name that is not an existing schema, or is
        a schema for which the user does not have <literal>USAGE</literal>
        permission, is silently ignored.
       </para>
____________________________________________________________________________-->
       <para>
        <varname>search_path</varname>的值必需是一个逗号分隔的模式名列表。任何不是一个已有模式的名称，或者是一个用户不具有<literal>USAGE</literal>权限的模式，将被安静地忽略。
       </para>

<!--==========================orignal english content==========================
       <para>
        If one of the list items is the special name
        <literal>$user</literal>, then the schema having the name returned by
        <function>CURRENT_USER</function> is substituted, if there is such a schema
        and the user has <literal>USAGE</literal> permission for it.
        (If not, <literal>$user</literal> is ignored.)
       </para>
____________________________________________________________________________-->
       <para>
        如果列表项之一是特殊名<literal>$user</literal>，则具有<function>SESSION_USER</function>返回的名字的模式将取代它（如果有这样一个模式并且该用户有该模式的<literal>USAGE</literal>权限；如果没有，<literal>$user</literal>会被忽略）。
       </para>

<!--==========================orignal english content==========================
       <para>
        The system catalog schema, <literal>pg_catalog</literal>, is always
        searched, whether it is mentioned in the path or not.  If it is
        mentioned in the path then it will be searched in the specified
        order.  If <literal>pg_catalog</literal> is not in the path then it will
        be searched <emphasis>before</emphasis> searching any of the path items.
       </para>
____________________________________________________________________________-->
       <para>
        系统目录模式<literal>pg_catalog</literal>总是被搜索，不管它是否在搜索路径中被提及。如果它在路径中被提及，那么它将被按照路径指定的顺序搜索。如果<literal>pg_catalog</literal>不在路径中，则它将在任何路径项<emphasis>之前</emphasis>被搜索。
       </para>

       <!-- 为了进一步细化，funcname('foo')不使用临时模式，即使它考虑到了typname='funcname'。
            本段引用了宽松意义的函数名, "pg_proc.proname or func_name grammar production". -->
<!--==========================orignal english content==========================
       <para>
        Likewise, the current session's temporary-table schema,
        <literal>pg_temp_<replaceable>nnn</replaceable></literal>, is always searched if it
        exists.  It can be explicitly listed in the path by using the
        alias <literal>pg_temp</literal><indexterm><primary>pg_temp</primary></indexterm>.  If it is not listed in the path then
        it is searched first (even before <literal>pg_catalog</literal>).  However,
        the temporary schema is only searched for relation (table, view,
        sequence, etc) and data type names.  It is never searched for
        function or operator names.
       </para>
____________________________________________________________________________-->
       <para>
        同样，当前会话的临时表模式<literal>pg_temp_<replaceable>nnn</replaceable></literal>也总是被搜索（如果存在）。它可以在路径中通过使用别名<literal>pg_temp</literal><indexterm><primary>pg_temp</primary></indexterm>显式列出。如果在路径中没有列出，那么会首先对它进行搜索（甚至是在<literal>pg_catalog</literal>之前）。然而，临时模式只被用来搜索关系（表、视图、序列等）和数据类型名。它从不用于搜索函数或操作符名。
       </para>

<!--==========================orignal english content==========================
       <para>
        When objects are created without specifying a particular target
        schema, they will be placed in the first valid schema named in
        <varname>search_path</varname>.  An error is reported if the search
        path is empty.
       </para>
____________________________________________________________________________-->
       <para>
        当对象创建时没有指定一个特定目标模式，它们将被放置在<varname>search_path</varname>中第一个合法模式中。如果搜索路径为空将报告一个错误。
       </para>

<!--==========================orignal english content==========================
       <para>
        The default value for this parameter is
        <literal>"$user", public</literal>.
        This setting supports shared use of a database (where no users
        have private schemas, and all share use of <literal>public</literal>),
        private per-user schemas, and combinations of these.  Other
        effects can be obtained by altering the default search path
        setting, either globally or per-user.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数的缺省值是<literal>"$user", public</literal>。这种设置支持一个数据库（其中没有用户拥有私有模式，并且所有人共享使用<literal>public</literal>）、每个用户私有模式及其组合的共享使用。其它效果可以通过全局或者针对每个用户修改默认搜索路径设置获得。
       </para>

<!--==========================orignal english content==========================
       <para>
        For more information on schema handling, see
        <xref linkend="ddl-schemas"/>.  In particular, the default
        configuration is suitable only when the database has a single user or
        a few mutually-trusting users.
       </para>
____________________________________________________________________________-->
       <para>
        更多有关方案处理的信息，请参考<xref linkend="ddl-schemas"/>。特别地，只有当数据库只有一个用户或者有少数的相互信任的用户时，默认配置是合适的。
       </para>

<!--==========================orignal english content==========================
       <para>
        The current effective value of the search path can be examined
        via the <acronym>SQL</acronym> function
        <function>current_schemas</function>
        (see <xref linkend="functions-info"/>).
        This is not quite the same as
        examining the value of <varname>search_path</varname>, since
        <function>current_schemas</function> shows how the items
        appearing in <varname>search_path</varname> were resolved.
       </para>
____________________________________________________________________________-->
       <para>
        搜索路径的当前有效值可以通过<acronym>SQL</acronym>函数<function>current_schemas</function>检查（见<xref linkend="functions-info"/>）。它和检查<varname>search_path</varname>的值不太一样，因为<function>current_schemas</function>显示出现在<varname>search_path</varname>中的项如何被解析。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-row-security" xreflabel="row_security">
<!--==========================orignal english content==========================
      <term><varname>row_security</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>row_security</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>row_security</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>row_security</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        This variable controls whether to raise an error in lieu of applying a
        row security policy.  When set to <literal>on</literal>, policies apply
        normally.  When set to <literal>off</literal>, queries fail which would
        otherwise apply at least one policy.  The default is <literal>on</literal>.
        Change to <literal>off</literal> where limited row visibility could cause
        incorrect results; for example, <application>pg_dump</application> makes that
        change by default.  This variable has no effect on roles which bypass
        every row security policy, to wit, superusers and roles with
        the <literal>BYPASSRLS</literal> attribute.
       </para>
____________________________________________________________________________-->
       <para>
        这个变量控制是否以抛出一个错误来代替应用一条行安全性策略。在设置为<literal>on</literal>时，策略正常应用。在设置为<literal>off</literal>时，只要有至少一条策略被应用则查询就会失败。默认为<literal>on</literal>。受限的行可见性会导致不正确的结果时，可将其改成<literal>off</literal>。例如，<application>pg_dump</application>默认会做这种更改。这个变量对能绕过每一条行安全性策略的角色（即超级用户和具有<literal>BYPASSRLS</literal>）属性的角色没有效果。
       </para>

<!--==========================orignal english content==========================
       <para>
        For more information on row security policies,
        see <xref linkend="sql-createpolicy"/>.
       </para>
____________________________________________________________________________-->
       <para>
        更多关于行安全性策略的信息请见<xref linkend="sql-createpolicy"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-default-table-access-method" xreflabel="default_table_access_method">
<!--==========================orignal english content==========================
      <term><varname>default_table_access_method</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>default_table_access_method</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>default_table_access_method</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>default_table_access_method</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        This parameter specifies the default table access method to use when
        creating tables or materialized views if the <command>CREATE</command>
        command does not explicitly specify an access method, or when
        <command>SELECT ... INTO</command> is used, which does not allow to
        specify a table access method. The default is <literal>heap</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        如果 <command>CREATE</command>命令没有显式指定访问方法，则此参数指定在创建表或物化视图时使用的默认表访问方法，
        或者在使用<command>SELECT ... INTO</command> 时，不允许指定表访问方法。默认为<literal>heap</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-default-tablespace" xreflabel="default_tablespace">
<!--==========================orignal english content==========================
      <term><varname>default_tablespace</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>default_tablespace</varname> configuration parameter</primary>
      </indexterm>
      <indexterm><primary>tablespace</primary><secondary>default</secondary></indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>default_tablespace</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>default_tablespace</varname>配置参数</primary>
      </indexterm>
      <indexterm><primary>tablespace</primary><secondary>default</secondary></indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        This variable specifies the default tablespace in which to create
        objects (tables and indexes) when a <command>CREATE</command> command does
        not explicitly specify a tablespace.
       </para>
____________________________________________________________________________-->
       <para>
        这个变量指定当一个<command>CREATE</command>命令没有显式指定一个表空间时，创建对象（表和索引）的默认表空间。
       </para>

<!--==========================orignal english content==========================
       <para>
        The value is either the name of a tablespace, or an empty string
        to specify using the default tablespace of the current database.
        If the value does not match the name of any existing tablespace,
        <productname>PostgreSQL</productname> will automatically use the default
        tablespace of the current database.  If a nondefault tablespace
        is specified, the user must have <literal>CREATE</literal> privilege
        for it, or creation attempts will fail.
       </para>
____________________________________________________________________________-->
       <para>
        该值要么是一个表空间的名字，要么是一个指定使用当前数据库默认表空间的空字符串。如果该值和任何现有表空间的名字都不匹配，<productname>PostgreSQL</productname>将自动使用当前数据库的默认表空间。如果指定了一个非默认的表空间，用户必须对它有<literal>CREATE</literal>权限，否则创建企图将失败。
       </para>

<!--==========================orignal english content==========================
       <para>
        This variable is not used for temporary tables; for them,
        <xref linkend="guc-temp-tablespaces"/> is consulted instead.
       </para>
____________________________________________________________________________-->
       <para>
        这个变量不被用于临时表，对临时表会使用<xref linkend="guc-temp-tablespaces"/>。
       </para>

<!--==========================orignal english content==========================
       <para>
        This variable is also not used when creating databases.
        By default, a new database inherits its tablespace setting from
        the template database it is copied from.
       </para>
____________________________________________________________________________-->
       <para>
        当创建数据库时也会使用这个变量。默认情况下，一个新数据库会从它的模板数据库继承其表空间设置。
       </para>

<!--==========================orignal english content==========================
       <para>
        If this parameter is set to a value other than the empty string
        when a partitioned table is created, the partitioned table's
        tablespace will be set to that value, which will be used as
        the default tablespace for partitions created in the future,
        even if <varname>default_tablespace</varname> has changed since then.
       </para>
____________________________________________________________________________-->
       <para>
        当一个分区表建立时如果这个参数被设置为空字符串以外的值，分区表的表空间将被设置为该值，将被用做未来建立分区的默认表空间，
        即使<varname>default_tablespace</varname>已经改变。
       </para>

<!--==========================orignal english content==========================
       <para>
        For more information on tablespaces,
        see <xref linkend="manage-ag-tablespaces"/>.
       </para>
____________________________________________________________________________-->
       <para>
        有关表空间的更多的信息，请见<xref linkend="manage-ag-tablespaces"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-default-toast-compression" xreflabel="default_toast_compression">
<!--==========================orignal english content==========================
      <term><varname>default_toast_compression</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>default_toast_compression</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>default_toast_compression</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>default_toast_compression</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        This variable sets the default
        <link linkend="storage-toast">TOAST</link>
        compression method for values of compressible columns.
        (This can be overridden for individual columns by setting
        the <literal>COMPRESSION</literal> column option in
        <command>CREATE TABLE</command> or
        <command>ALTER TABLE</command>.)
        The supported compression methods are <literal>pglz</literal> and
        (if <productname>PostgreSQL</productname> was compiled with
        <option>-&minus;with-lz4</option>) <literal>lz4</literal>.
        The default is <literal>pglz</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        这个变量设置针对可压缩列的值的默认的<link linkend="storage-toast">TOAST</link>压缩方法。
        （这个可以通过设置<literal>COMPRESSION</literal>列选项跨越不同的列，通过<command>CREATE TABLE</command> 或 <command>ALTER TABLE</command>）
        支持的压法方法有<literal>pglz</literal> 和(如果<productname>PostgreSQL</productname> 编译时包括 <option>--with-lz4</option>) <literal>lz4</literal>.
        默认为 <literal>pglz</literal>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-temp-tablespaces" xreflabel="temp_tablespaces">
<!--==========================orignal english content==========================
      <term><varname>temp_tablespaces</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>temp_tablespaces</varname> configuration parameter</primary>
      </indexterm>
      <indexterm><primary>tablespace</primary><secondary>temporary</secondary></indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>temp_tablespaces</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>temp_tablespaces</varname>配置参数</primary>
      </indexterm>
      <indexterm><primary>tablespace</primary><secondary>temporary</secondary></indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        This variable specifies tablespaces in which to create temporary
        objects (temp tables and indexes on temp tables) when a
        <command>CREATE</command> command does not explicitly specify a tablespace.
        Temporary files for purposes such as sorting large data sets
        are also created in these tablespaces.
       </para>
____________________________________________________________________________-->
       <para>
        这个变量指定当一个<command>CREATE</command>命令没有显式指定一个表空间时，创建临时对象（临时表和临时表上的索引）的默认表空间。用于排序大型数据集的临时文件也被创建在这些表空间中。
       </para>

<!--==========================orignal english content==========================
       <para>
        The value is a list of names of tablespaces.  When there is more than
        one name in the list, <productname>PostgreSQL</productname> chooses a random
        member of the list each time a temporary object is to be created;
        except that within a transaction, successively created temporary
        objects are placed in successive tablespaces from the list.
        If the selected element of the list is an empty string,
        <productname>PostgreSQL</productname> will automatically use the default
        tablespace of the current database instead.
       </para>
____________________________________________________________________________-->
       <para>
        该值是一个表空间名字的列表。当列表中有多于一个名称时，每次一个临时对象被创建时<productname>PostgreSQL</productname>随机选择列表中的一个成员。例外是在一个事务中，连续创建的临时对象被放置在里表中的连续表空间中。如果列表被选中元素是一个空字符串，<productname>PostgreSQL</productname>将自动使用当前数据库的默认表空间。
       </para>

<!--==========================orignal english content==========================
       <para>
        When <varname>temp_tablespaces</varname> is set interactively, specifying a
        nonexistent tablespace is an error, as is specifying a tablespace for
        which the user does not have <literal>CREATE</literal> privilege.  However,
        when using a previously set value, nonexistent tablespaces are
        ignored, as are tablespaces for which the user lacks
        <literal>CREATE</literal> privilege.  In particular, this rule applies when
        using a value set in <filename>postgresql.conf</filename>.
       </para>
____________________________________________________________________________-->
       <para>
        当<varname>temp_tablespaces</varname>被交互式地设置时，指定一个不存在的表空间是一种错误，类似于为用户指定一个不具有<literal>CREATE</literal>权限的表空间。不过，当使用一个之前设置的值时，不存在的表空间会被忽略，就像用户缺少<literal>CREATE</literal>权限的表空间一样。特殊地，使用一个在<filename>postgresql.conf</filename>中设置的值时，这条规则起效。
       </para>

<!--==========================orignal english content==========================
       <para>
        The default value is an empty string, which results in all temporary
        objects being created in the default tablespace of the current
        database.
       </para>
____________________________________________________________________________-->
       <para>
        默认值是一个空字符串，它使得所有临时对象被创建在当前数据库的默认表空间中。
       </para>

<!--==========================orignal english content==========================
       <para>
        See also <xref linkend="guc-default-tablespace"/>.
       </para>
____________________________________________________________________________-->
       <para>
        参阅<xref linkend="guc-default-tablespace"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-check-function-bodies" xreflabel="check_function_bodies">
<!--==========================orignal english content==========================
      <term><varname>check_function_bodies</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>check_function_bodies</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>check_function_bodies</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>check_function_bodies</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        This parameter is normally on. When set to <literal>off</literal>, it
        disables validation of the routine body string during <xref
        linkend="sql-createfunction"/> and <xref
        linkend="sql-createprocedure"/>.  Disabling validation avoids side
        effects of the validation process, in particular preventing false
        positives due to problems such as forward references.
        Set this parameter
        to <literal>off</literal> before loading functions on behalf of other
        users; <application>pg_dump</application> does so automatically.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数通常为打开。
        当设置为<literal>off</literal>时，它禁用<xref linkend="sql-createfunction"/>和<xref linkend="sql-createprocedure"/>期间对例程体字符串的验证。
        禁用验证避免了验证处理的副作用，特别避免了如向前引用导致的伪肯定。
        在代表其他用户载入函数之前设置这个参数为<literal>off</literal>；<application>pg_dump</application>会自动这样做。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-default-transaction-isolation" xreflabel="default_transaction_isolation">
<!--==========================orignal english content==========================
      <term><varname>default_transaction_isolation</varname> (<type>enum</type>)
      <indexterm>
       <primary>transaction isolation level</primary>
       <secondary>setting default</secondary>
      </indexterm>
      <indexterm>
       <primary><varname>default_transaction_isolation</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>default_transaction_isolation</varname> (<type>enum</type>)
      <indexterm>
       <primary>transaction isolation level</primary>
       <secondary>setting default</secondary>
      </indexterm>
      <indexterm>
       <primary><varname>default_transaction_isolation</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Each SQL transaction has an isolation level, which can be
        either <quote>read uncommitted</quote>, <quote>read
        committed</quote>, <quote>repeatable read</quote>, or
        <quote>serializable</quote>.  This parameter controls the
        default isolation level of each new transaction. The default
        is <quote>read committed</quote>.
       </para>
____________________________________________________________________________-->
       <para>
        每个 SQL 事务都有一个隔离级别，可以是<quote>读未提交</quote>、<quote>读已提交</quote>、<quote>可重复读</quote>或者<quote>可序列化</quote>。这个参数控制每个新事务的默认隔离级别。默认是<quote>读已提交</quote>。
       </para>

<!--==========================orignal english content==========================
       <para>
        Consult <xref linkend="mvcc"/> and <xref
        linkend="sql-set-transaction"/> for more information.
       </para>
____________________________________________________________________________-->
       <para>
        更多信息请参阅<xref linkend="mvcc"/>和<xref linkend="sql-set-transaction"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-default-transaction-read-only" xreflabel="default_transaction_read_only">
<!--==========================orignal english content==========================
      <term><varname>default_transaction_read_only</varname> (<type>boolean</type>)
      <indexterm>
       <primary>read-only transaction</primary>
       <secondary>setting default</secondary>
      </indexterm>
      <indexterm>
       <primary><varname>default_transaction_read_only</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>default_transaction_read_only</varname> (<type>boolean</type>)
      <indexterm>
       <primary>read-only transaction</primary>
       <secondary>setting default</secondary>
      </indexterm>
      <indexterm>
       <primary><varname>default_transaction_read_only</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        A read-only SQL transaction cannot alter non-temporary tables.
        This parameter controls the default read-only status of each new
        transaction. The default is <literal>off</literal> (read/write).
       </para>
____________________________________________________________________________-->
       <para>
        一个只读的 SQL 事务不能修改非临时表。这个参数控制每个新事务的默认只读状态 。默认是<literal>off</literal>（读/写）。
       </para>

<!--==========================orignal english content==========================
       <para>
        Consult <xref linkend="sql-set-transaction"/> for more information.
       </para>
____________________________________________________________________________-->
       <para>
        更多信息请参考<xref linkend="sql-set-transaction"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-default-transaction-deferrable" xreflabel="default_transaction_deferrable">
<!--==========================orignal english content==========================
      <term><varname>default_transaction_deferrable</varname> (<type>boolean</type>)
      <indexterm>
       <primary>deferrable transaction</primary>
       <secondary>setting default</secondary>
      </indexterm>
      <indexterm>
       <primary><varname>default_transaction_deferrable</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>default_transaction_deferrable</varname> (<type>boolean</type>)
      <indexterm>
       <primary>deferrable transaction</primary>
       <secondary>setting default</secondary>
      </indexterm>
      <indexterm>
       <primary><varname>default_transaction_deferrable</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        When running at the <literal>serializable</literal> isolation level,
        a deferrable read-only SQL transaction may be delayed before
        it is allowed to proceed.  However, once it begins executing
        it does not incur any of the overhead required to ensure
        serializability; so serialization code will have no reason to
        force it to abort because of concurrent updates, making this
        option suitable for long-running read-only transactions.
        </para>
____________________________________________________________________________-->
       <para>
        当运行在<literal>可序列化</literal>隔离级别时，一个可延迟只读 SQL 事务可以在它被允许继续之前延迟一段时间。但是，一旦它开始执行就不会产生任何用来保证可序列化性的负荷；因此序列化代码将没有任何理由因为并发更新而强制它中断，使得这个选项适合于长时间运行的只读事务。
        </para>

<!--==========================orignal english content==========================
        <para>
        This parameter controls the default deferrable status of each
        new transaction.  It currently has no effect on read-write
        transactions or those operating at isolation levels lower
        than <literal>serializable</literal>. The default is <literal>off</literal>.
       </para>
____________________________________________________________________________-->
        <para>
        这个参数控制每个新事务的默认可延迟状态。目前它对读写事务或者那些操作在低于<literal>可序列化</literal>隔离级别上的事务无效。默认值是<literal>off</literal>。
       </para>

<!--==========================orignal english content==========================
       <para>
        Consult <xref linkend="sql-set-transaction"/> for more information.
       </para>
____________________________________________________________________________-->
       <para>
        详情请参阅<xref linkend="sql-set-transaction"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-transaction-read-only" xreflabel="transaction_read_only">
<!--==========================orignal english content==========================
      <term><varname>transaction_read_only</varname> (<type>boolean</type>)
      <indexterm>
       <primary>read-only transaction</primary>
      </indexterm>
      <indexterm>
       <primary><varname>transaction_read_only</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>transaction_read_only</varname> (<type>boolean</type>)
      <indexterm>
       <primary>read-only transaction</primary>
      </indexterm>
      <indexterm>
       <primary><varname>transaction_read_only</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        This parameter reflects the current transaction's read-only status.
        At the beginning of each transaction, it is set to the current value
        of <xref linkend="guc-default-transaction-read-only"/>.
        Any subsequent attempt to change it is equivalent to a <xref
        linkend="sql-set-transaction"/> command.
       </para>
____________________________________________________________________________-->
       <para>
        此参数反映当前事务的只读状态。
        在每个事务的开始，它被设置为<xref linkend="guc-default-transaction-read-only"/>的当前值。
        任何后续尝试更改它的都等同于<xref linkend="sql-set-transaction"/>命令。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-transaction-deferrable" xreflabel="transaction_deferrable">
<!--==========================orignal english content==========================
      <term><varname>transaction_deferrable</varname> (<type>boolean</type>)
      <indexterm>
       <primary>deferrable transaction</primary>
      </indexterm>
      <indexterm>
       <primary><varname>transaction_deferrable</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>transaction_deferrable</varname> (<type>boolean</type>)
      <indexterm>
       <primary>deferrable transaction</primary>
      </indexterm>
      <indexterm>
       <primary><varname>transaction_deferrable</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        This parameter reflects the current transaction's deferrability status.
        At the beginning of each transaction, it is set to the current value
        of <xref linkend="guc-default-transaction-deferrable"/>.
        Any subsequent attempt to change it is equivalent to a <xref
        linkend="sql-set-transaction"/> command.
       </para>
____________________________________________________________________________-->
       <para>
        此参数反映当前事务的可延迟性状态。
        在每个事务的开始，它被设置为<xref linkend="guc-default-transaction-deferrable"/>的当前值。
        任何后续尝试更改它的都等同于<xref linkend="sql-set-transaction"/>命令。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-session-replication-role" xreflabel="session_replication_role">
<!--==========================orignal english content==========================
      <term><varname>session_replication_role</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>session_replication_role</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>session_replication_role</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>session_replication_role</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Controls firing of replication-related triggers and rules for the
        current session.  Setting this variable requires
        superuser privilege and results in discarding any previously cached
        query plans.  Possible values are <literal>origin</literal> (the default),
        <literal>replica</literal> and <literal>local</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        为当前会话控制复制相关的触发器和规则的触发。需要超级用户权限才能设置这个变量，并且会导致丢弃任何之前缓存下来的查询计划。可能的值有<literal>origin</literal>（默认）、<literal>replica</literal>和<literal>local</literal>。
       </para>

<!--==========================orignal english content==========================
       <para>
        The intended use of this setting is that logical replication systems
        set it to <literal>replica</literal> when they are applying replicated
        changes.  The effect of that will be that triggers and rules (that
        have not been altered from their default configuration) will not fire
        on the replica.  See the <link linkend="sql-altertable"><command>ALTER TABLE</command></link> clauses
        <literal>ENABLE TRIGGER</literal> and <literal>ENABLE RULE</literal>
        for more information.
       </para>
____________________________________________________________________________-->
       <para>
        这个设置的预期用途是由逻辑复制系统在应用所复制的更改时将它设置为<literal>replica</literal>。
		其效果将是触发器和规则（没有对其默认配置做修改）在复制机上将不会被触发。
		更多信息请参考<link linkend="sql-altertable"><command>ALTER TABLE</command></link>的子句<literal>ENABLE TRIGGER</literal>以及<literal>ENABLE RULE</literal>。
       </para>

<!--==========================orignal english content==========================
       <para>
        PostgreSQL treats the settings <literal>origin</literal> and
        <literal>local</literal> the same internally.  Third-party replication
        systems may use these two values for their internal purposes, for
        example using <literal>local</literal> to designate a session whose
        changes should not be replicated.
       </para>
____________________________________________________________________________-->
       <para>
        PostgreSQL在内部会把设置<literal>origin</literal>和<literal>local</literal>同样对待。第三方复制系统可能会把这两个值用于其内部目的，例如把<literal>local</literal>用来标出一个不应复制其更改的会话。
       </para>

<!--==========================orignal english content==========================
       <para>
        Since foreign keys are implemented as triggers, setting this parameter
        to <literal>replica</literal> also disables all foreign key checks,
        which can leave data in an inconsistent state if improperly used.
       </para>
____________________________________________________________________________-->
       <para>
        因为外键被实现为触发器，将这个参数设置为<literal>replica</literal>还会禁用所有的外键检查，如果使用不当可能会让数据处于一种不一致的状态。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-statement-timeout" xreflabel="statement_timeout">
<!--==========================orignal english content==========================
      <term><varname>statement_timeout</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>statement_timeout</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>statement_timeout</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>statement_timeout</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Abort any statement that takes more than the specified amount of time.
        If <varname>log_min_error_statement</varname> is set
        to <literal>ERROR</literal> or lower, the statement that timed out
        will also be logged.
        If this value is specified without units, it is taken as milliseconds.
        A value of zero (the default) disables the timeout.
       </para>
____________________________________________________________________________-->
       <para>
        中止任何使用了超过指定时间量的语句。
        如果<varname>log_min_error_statement</varname>被设置为<literal>ERROR</literal>或更低，语句如果超时也会被记录。
        如果指定值时没有单位，则以毫秒为单位。一个零值（默认）将禁用超时。
       </para>

<!--==========================orignal english content==========================
       <para>
        The timeout is measured from the time a command arrives at the
        server until it is completed by the server.  If multiple SQL
        statements appear in a single simple-Query message, the timeout
        is applied to each statement separately.
        (<productname>PostgreSQL</productname> versions before 13 usually
        treated the timeout as applying to the whole query string.)
        In extended query protocol, the timeout starts running when any
        query-related message (Parse, Bind, Execute, Describe) arrives, and
        it is canceled by completion of an Execute or Sync message.
       </para>
____________________________________________________________________________-->
       <para>
        超时从命令到达服务器的时间开始计算，一直到它被服务器完成为止。
        如果单个简单查询消息中出现多个 SQL 语句，超时将分别应用于每个语句。（<productname>PostgreSQL</productname> 13 之前的版本通常将超时应用于整个查询字符串。
        在扩展查询协议中，当任何与查询相关的消息(解析、绑定、执行、描述)到达时，超时就开始运行，并且可以通过执行完成或同步消息来取消超时。
       </para>

<!--==========================orignal english content==========================
       <para>
        Setting <varname>statement_timeout</varname> in
        <filename>postgresql.conf</filename> is not recommended because it would
        affect all sessions.
       </para>
____________________________________________________________________________-->
       <para>
        我们不推荐在<filename>postgresql.conf</filename>中设置<varname>statement_timeout</varname>，因为它会影响所有会话。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-lock-timeout" xreflabel="lock_timeout">
<!--==========================orignal english content==========================
      <term><varname>lock_timeout</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>lock_timeout</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>lock_timeout</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>lock_timeout</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Abort any statement that waits longer than the specified amount of
        time while attempting to acquire a lock on a table, index,
        row, or other database object.  The time limit applies separately to
        each lock acquisition attempt.  The limit applies both to explicit
        locking requests (such as <command>LOCK TABLE</command>, or <command>SELECT
        FOR UPDATE</command> without <literal>NOWAIT</literal>) and to implicitly-acquired
        locks.
        If this value is specified without units, it is taken as milliseconds.
        A value of zero (the default) disables the timeout.
       </para>
____________________________________________________________________________-->
       <para>
        如果任何语句在试图获取表、索引、行或其他数据库对象上的锁时等到超过指定的时间量，该语句将被中止。
        该时间限制独立地应用于每一次锁获取尝试。该限制会应用到显式锁定请求（如<command>LOCK TABLE</command>或不带<literal>NOWAIT</literal>的<command>SELECT FOR UPDATE</command>）和隐式获得的锁。
        如果指定值时没有单位，则以毫秒为单位。一个零值（默认）将禁用超时。
       </para>

<!--==========================orignal english content==========================
       <para>
        Unlike <varname>statement_timeout</varname>, this timeout can only occur
        while waiting for locks.  Note that if <varname>statement_timeout</varname>
        is nonzero, it is rather pointless to set <varname>lock_timeout</varname> to
        the same or larger value, since the statement timeout would always
        trigger first.  If <varname>log_min_error_statement</varname> is set to
        <literal>ERROR</literal> or lower, the statement that timed out will be
        logged.
       </para>
____________________________________________________________________________-->
       <para>
        与<varname>statement_timeout</varname>不同，这个超时只在等待锁时发生。注意如果<varname>statement_timeout</varname>为非零，设置<varname>lock_timeout</varname>为相同或更大的值没有意义，因为事务超时将总是第一个被触发。
        如果<varname>log_min_error_statement</varname> 被设置为<literal>ERROR</literal> 或更低，超时的语句将被记录。
       </para>

<!--==========================orignal english content==========================
       <para>
        Setting <varname>lock_timeout</varname> in
        <filename>postgresql.conf</filename> is not recommended because it would
        affect all sessions.
       </para>
____________________________________________________________________________-->
       <para>
        我们不推荐在<filename>postgresql.conf</filename>中设置<varname>lock_timeout</varname>，因为它会影响所有会话。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-idle-in-transaction-session-timeout" xreflabel="idle_in_transaction_session_timeout">
<!--==========================orignal english content==========================
      <term><varname>idle_in_transaction_session_timeout</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>idle_in_transaction_session_timeout</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>idle_in_transaction_session_timeout</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>idle_in_transaction_session_timeout</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Terminate any session that has been idle (that is, waiting for a
        client query) within an open transaction for longer than the
        specified amount of time.
        If this value is specified without units, it is taken as milliseconds.
        A value of zero (the default) disables the timeout.
       </para>
____________________________________________________________________________-->
       <para>
        终止任何已经闲置(这是指，等待客户端查询)超过这个参数所指定时间量的打开事务的会话。
        如果这个值指定时没有单位，它被设为毫秒。
        零值(默认)禁用超时。
       </para>

<!--==========================orignal english content==========================
       <para>
        This option can be used to ensure that idle sessions do not hold
        locks for an unreasonable amount of time.  Even when no significant
        locks are held, an open transaction prevents vacuuming away
        recently-dead tuples that may be visible only to this transaction;
        so remaining idle for a long time can contribute to table bloat.
        See <xref linkend="routine-vacuuming"/> for more details.
       </para>
____________________________________________________________________________-->
       <para>
        此选项可以用于确保空闲会话不会在不合理的时间内持有锁。
        即使没有持有重要的锁的时候，打开的事务也会防止清理最近死亡的可能只对这个事务可见的元组;所以长时间保持空闲会导致表膨胀。
        详见<xref linkend="routine-vacuuming"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-idle-session-timeout" xreflabel="idle_session_timeout">
<!--==========================orignal english content==========================
      <term><varname>idle_session_timeout</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>idle_session_timeout</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>idle_session_timeout</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>idle_session_timeout</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Terminate any session that has been idle (that is, waiting for a
        client query), but not within an open transaction, for longer than
        the specified amount of time.
        If this value is specified without units, it is taken as milliseconds.
        A value of zero (the default) disables the timeout.
       </para>
____________________________________________________________________________-->
       <para>
        终止任何空闲的会话(也就是，等待客户端查询)，但不在打开的事务中，且超过指定的时间量。
        如果指定值时不带单位，其单位采用毫秒。
        零值时(默认)禁用超时。
       </para>

<!--==========================orignal english content==========================
       <para>
        Unlike the case with an open transaction, an idle session without a
        transaction imposes no large costs on the server, so there is less
        need to enable this timeout
        than <varname>idle_in_transaction_session_timeout</varname>.
       </para>
____________________________________________________________________________-->
       <para>
        不像打开事务的情况，没有事务的空闲会话不会给服务器带来很大的开销，因此启用此超时的需要比<varname>idle_in_transaction_session_timeout</varname>更少。
       </para>

<!--==========================orignal english content==========================
       <para>
        Be wary of enforcing this timeout on connections made through
        connection-pooling software or other middleware, as such a layer
        may not react well to unexpected connection closure.  It may be
        helpful to enable this timeout only for interactive sessions,
        perhaps by applying it only to particular users.
       </para>
____________________________________________________________________________-->
       <para>
        注意不要对通过连接池软件或其他中间件建立的连接强制执行此超时，因为这样的层可能不会很好地响应意外的连接关闭。
        只对交互会话启用此超时可能是帮助的，也许只对特定用户应用它。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-vacuum-freeze-table-age" xreflabel="vacuum_freeze_table_age">
<!--==========================orignal english content==========================
      <term><varname>vacuum_freeze_table_age</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>vacuum_freeze_table_age</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>vacuum_freeze_table_age</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>vacuum_freeze_table_age</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        <command>VACUUM</command> performs an aggressive scan if the table's
        <structname>pg_class</structname>.<structfield>relfrozenxid</structfield> field has reached
        the age specified by this setting.  An aggressive scan differs from
        a regular <command>VACUUM</command> in that it visits every page that might
        contain unfrozen XIDs or MXIDs, not just those that might contain dead
        tuples.  The default is 150 million transactions.  Although users can
        set this value anywhere from zero to two billion, <command>VACUUM</command>
        will silently limit the effective value to 95% of
        <xref linkend="guc-autovacuum-freeze-max-age"/>, so that a
        periodic manual <command>VACUUM</command> has a chance to run before an
        anti-wraparound autovacuum is launched for the table. For more
        information see
        <xref linkend="vacuum-for-wraparound"/>.
       </para>
____________________________________________________________________________-->
       <para>
        当表的<structname>pg_class</structname>.<structfield>relfrozenxid</structfield>域达到该设置指定的年龄时，<command>VACUUM</command>会执行一次激进的扫描。激进的扫描与常规<command>VACUUM</command>的不同在于它会访问每一个可能包含未冻结 XID 或者 MXID 的页面，而不只是那些可能包含死亡元组的页面。默认值是 1.5 亿个事务。尽管用户可以把这个值设置为从 0 到 20 亿，<command>VACUUM</command>会悄悄地将有效值设置为<xref linkend="guc-autovacuum-freeze-max-age"/>值的95%，因此在表上启动一次反回卷自动清理之前有机会进行一次定期手动<command>VACUUM</command>。更多信息请见<xref linkend="vacuum-for-wraparound"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-vacuum-freeze-min-age" xreflabel="vacuum_freeze_min_age">
<!--==========================orignal english content==========================
      <term><varname>vacuum_freeze_min_age</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>vacuum_freeze_min_age</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>vacuum_freeze_min_age</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>vacuum_freeze_min_age</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the cutoff age (in transactions) that <command>VACUUM</command>
        should use to decide whether to freeze row versions
        while scanning a table.
        The default is 50 million transactions.  Although
        users can set this value anywhere from zero to one billion,
        <command>VACUUM</command> will silently limit the effective value to half
        the value of <xref linkend="guc-autovacuum-freeze-max-age"/>, so
        that there is not an unreasonably short time between forced
        autovacuums.  For more information see <xref
        linkend="vacuum-for-wraparound"/>.
       </para>
____________________________________________________________________________-->
       <para>
        指定<command>VACUUM</command>在扫描表时用来决定是否冻结行版本的切断年龄（以事务计）。默认值是 5 千万个事务。尽管用户可以将这个值设置为从 0 到 10 亿，<command>VACUUM</command>会悄悄地将有效值设置为<xref linkend="guc-autovacuum-freeze-max-age"/>值的一半，这样在强制执行的自动清理之间不会有过短的时间间隔。更多信息请见<xref linkend="vacuum-for-wraparound"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-vacuum-failsafe-age" xreflabel="vacuum_failsafe_age">
<!--==========================orignal english content==========================
      <term><varname>vacuum_failsafe_age</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>vacuum_failsafe_age</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>vacuum_failsafe_age</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>vacuum_failsafe_age</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the maximum age (in transactions) that a table's
        <structname>pg_class</structname>.<structfield>relfrozenxid</structfield>
        field can attain before <command>VACUUM</command> takes
        extraordinary measures to avoid system-wide transaction ID
        wraparound failure.  This is <command>VACUUM</command>'s
        strategy of last resort.  The failsafe typically triggers
        when an autovacuum to prevent transaction ID wraparound has
        already been running for some time, though it's possible for
        the failsafe to trigger during any <command>VACUUM</command>.
       </para>
____________________________________________________________________________-->
       <para>
        指定表的<structname>pg_class</structname>.<structfield>relfrozenxid</structfield>字段在<command>VACUUM</command>采取特别措施以避免系统级事务ID封装失败之前的最大年龄(在事务中)。
        这是<command>VACUUM</command>最后手段的策略。
        失效保护通常在防止事务ID换行的autovacuum已经运行了一段时间时触发，不过失效保护也有可能在任何<command>VACUUM</command>期间触发。
       </para>
<!--==========================orignal english content==========================
       <para>
        When the failsafe is triggered, any cost-based delay that is
        in effect will no longer be applied, and further non-essential
        maintenance tasks (such as index vacuuming) are bypassed.
       </para>
____________________________________________________________________________-->
       <para>
        当失效保护被触发时，任何有效的基于成本的延迟都将不再被应用，并且进一步的非必要的维护任务(例如索引vacuuming)被绕过。
       </para>
<!--==========================orignal english content==========================
       <para>
        The default is 1.6 billion transactions.  Although users can
        set this value anywhere from zero to 2.1 billion,
        <command>VACUUM</command> will silently adjust the effective
        value to no less than 105% of <xref
         linkend="guc-autovacuum-freeze-max-age"/>.
       </para>
____________________________________________________________________________-->
       <para>
        默认为16亿事务。
        虽然用户可以把这个值设置为零到21亿之间的任何地方。
        <command>VACUUM</command>将静默调整有效值到不小于<xref linkend="guc-autovacuum-freeze-max-age"/>的105%。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-vacuum-multixact-freeze-table-age" xreflabel="vacuum_multixact_freeze_table_age">
<!--==========================orignal english content==========================
      <term><varname>vacuum_multixact_freeze_table_age</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>vacuum_multixact_freeze_table_age</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>vacuum_multixact_freeze_table_age</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>vacuum_multixact_freeze_table_age</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        <command>VACUUM</command> performs an aggressive scan if the table's
        <structname>pg_class</structname>.<structfield>relminmxid</structfield> field has reached
        the age specified by this setting.  An aggressive scan differs from
        a regular <command>VACUUM</command> in that it visits every page that might
        contain unfrozen XIDs or MXIDs, not just those that might contain dead
        tuples.  The default is 150 million multixacts.
        Although users can set this value anywhere from zero to two billion,
        <command>VACUUM</command> will silently limit the effective value to 95% of
        <xref linkend="guc-autovacuum-multixact-freeze-max-age"/>, so that a
        periodic manual <command>VACUUM</command> has a chance to run before an
        anti-wraparound is launched for the table.
        For more information see <xref linkend="vacuum-for-multixact-wraparound"/>.
       </para>
____________________________________________________________________________-->
       <para>
        如果表的<structname>pg_class</structname>.<structfield>relminmxid</structfield>域超过了这个设置指定的年龄，<command>VACUUM</command>会执行一次激进的扫描。激进的扫描与常规<command>VACUUM</command>的区别在于它会访问每一个可能包含未冻结 XID 或者 MXID 的页面，而不是只扫描那些可能包含死亡元组的页面。默认值是 1.5 亿个组合事务。尽管用户可以把这个值设置为从 0 到 20 亿，<command>VACUUM</command>会悄悄地将有效值设置为<xref linkend="guc-autovacuum-multixact-freeze-max-age"/>值的95%，因此在表上启动一次反回卷自动清理之前有机会进行一次定期手动<command>VACUUM</command>。更多信息请见<xref linkend="vacuum-for-multixact-wraparound"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-vacuum-multixact-freeze-min-age" xreflabel="vacuum_multixact_freeze_min_age">
<!--==========================orignal english content==========================
      <term><varname>vacuum_multixact_freeze_min_age</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>vacuum_multixact_freeze_min_age</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>vacuum_multixact_freeze_min_age</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>vacuum_multixact_freeze_min_age</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the cutoff age (in multixacts) that <command>VACUUM</command>
        should use to decide whether to replace multixact IDs with a newer
        transaction ID or multixact ID while scanning a table.  The default
        is 5 million multixacts.
        Although users can set this value anywhere from zero to one billion,
        <command>VACUUM</command> will silently limit the effective value to half
        the value of <xref linkend="guc-autovacuum-multixact-freeze-max-age"/>,
        so that there is not an unreasonably short time between forced
        autovacuums.
        For more information see <xref linkend="vacuum-for-multixact-wraparound"/>.
       </para>
____________________________________________________________________________-->
       <para>
        指定<command>VACUUM</command>在扫描表时用来决定是否把组合事务 ID 替换为一个更新的事务 ID 或组合事务 ID 的切断年龄（以组合事务计）。默认值是 5 千万个组合事务。尽管用户可以将这个值设置为从 0 到 10 亿，<command>VACUUM</command>会悄悄地将有效值设置为<xref linkend="guc-autovacuum-multixact-freeze-max-age"/>值的一半，这样在强制执行的自动清理之间不会有过短的时间间隔。更多信息请见<xref linkend="vacuum-for-multixact-wraparound"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-vacuum-multixact-failsafe-age" xreflabel="vacuum_multixact_failsafe_age">
<!--==========================orignal english content==========================
      <term><varname>vacuum_multixact_failsafe_age</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>vacuum_multixact_failsafe_age</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>vacuum_multixact_failsafe_age</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>vacuum_multixact_failsafe_age</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies the maximum age (in multixacts) that a table's
        <structname>pg_class</structname>.<structfield>relminmxid</structfield>
        field can attain before <command>VACUUM</command> takes
        extraordinary measures to avoid system-wide multixact ID
        wraparound failure.  This is <command>VACUUM</command>'s
        strategy of last resort.  The failsafe typically triggers when
        an autovacuum to prevent transaction ID wraparound has already
        been running for some time, though it's possible for the
        failsafe to trigger during any <command>VACUUM</command>.
       </para>
____________________________________________________________________________-->
       <para>
        指定最大寿命(in multixacts)，以便表的<structname>pg_class</structname>.<structfield>relminmxid</structfield>字段可以在<command>VACUUM</command>采取特别措施之前获得，以避免系统范围的multixact ID 回卷失败。
        这是<command>VACUUM</command>的最后手段的策略。
        失效保护通常在防止事务ID回卷的autovacuum已经运行了一段时间时触发，不过失效保护也有可能在任何<command>VACUUM</command>期间被触发。
       </para>
<!--==========================orignal english content==========================
       <para>
        When the failsafe is triggered, any cost-based delay that is
        in effect will no longer be applied, and further non-essential
        maintenance tasks (such as index vacuuming) are bypassed.
       </para>
____________________________________________________________________________-->
       <para>
        当失效保护被触发时，任何进行中的基于成本的延迟将不再应用，而且非必要的维护任务(如索引vacuuming)会被旁路。
       </para>
<!--==========================orignal english content==========================
       <para>
        The default is 1.6 billion multixacts.  Although users can set
        this value anywhere from zero to 2.1 billion,
        <command>VACUUM</command> will silently adjust the effective
        value to no less than 105% of <xref
         linkend="guc-autovacuum-multixact-freeze-max-age"/>.
       </para>
____________________________________________________________________________-->
       <para>
        默认为16亿multixacts。
        但是用户可以设置这个值为零至21亿之间的任意值。
        <command>VACUUM</command>将静默调整有效值到不小于<xref linkend="guc-autovacuum-multixact-freeze-max-age"/>的105%。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-bytea-output" xreflabel="bytea_output">
<!--==========================orignal english content==========================
      <term><varname>bytea_output</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>bytea_output</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>bytea_output</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>bytea_output</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the output format for values of type <type>bytea</type>.
        Valid values are <literal>hex</literal> (the default)
        and <literal>escape</literal> (the traditional PostgreSQL
        format).  See <xref linkend="datatype-binary"/> for more
        information.  The <type>bytea</type> type always
        accepts both formats on input, regardless of this setting.
       </para>
____________________________________________________________________________-->
       <para>
        设置<type>bytea</type>类型值的输出格式。有效值是<literal>hex</literal>（默认）和 <literal>escape</literal>（传统的 PostgreSQL 格式）。详见<xref linkend="datatype-binary"/>。不管这个设置的值如何，<type>bytea</type>类型总是接受这两种格式的输入。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-xmlbinary" xreflabel="xmlbinary">
<!--==========================orignal english content==========================
      <term><varname>xmlbinary</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>xmlbinary</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>xmlbinary</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>xmlbinary</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets how binary values are to be encoded in XML.  This applies
        for example when <type>bytea</type> values are converted to
        XML by the functions <function>xmlelement</function> or
        <function>xmlforest</function>.  Possible values are
        <literal>base64</literal> and <literal>hex</literal>, which
        are both defined in the XML Schema standard.  The default is
        <literal>base64</literal>.  For further information about
        XML-related functions, see <xref linkend="functions-xml"/>.
       </para>
____________________________________________________________________________-->
       <para>
        设置二进制值如何被编码为 XML。例如，这适用于通过<function>xmlelement</function>函数或<function>xmlforest</function>函数将<type>bytea</type>值转换到 XML 值。可能的值有<literal>base64</literal>和<literal>hex</literal>，它们都是用 XML 模式标准定义的。默认值是<literal>base64</literal>。更多关于 XML 相关函数的信息可参阅<xref linkend="functions-xml"/>。
       </para>

<!--==========================orignal english content==========================
       <para>
        The actual choice here is mostly a matter of taste,
        constrained only by possible restrictions in client
        applications.  Both methods support all possible values,
        although the hex encoding will be somewhat larger than the
        base64 encoding.
       </para>
____________________________________________________________________________-->
       <para>
        这里的实际选择都是根据爱好做出的，只受客户端应用中可能存在的限制的约束。两种方法都支持所有可能的值，尽管十六进制编码将比 base64 编码更大。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-xmloption" xreflabel="xmloption">
<!--==========================orignal english content==========================
      <term><varname>xmloption</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>xmloption</varname> configuration parameter</primary>
      </indexterm>
      <indexterm>
       <primary><varname>SET XML OPTION</varname></primary>
      </indexterm>
      <indexterm>
       <primary>XML option</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>xmloption</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>xmloption</varname>配置参数</primary>
      </indexterm>
      <indexterm>
       <primary><varname>SET XML OPTION</varname></primary>
      </indexterm>
      <indexterm>
       <primary>XML option</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets whether <literal>DOCUMENT</literal> or
        <literal>CONTENT</literal> is implicit when converting between
        XML and character string values.  See <xref
        linkend="datatype-xml"/> for a description of this.  Valid
        values are <literal>DOCUMENT</literal> and
        <literal>CONTENT</literal>.  The default is
        <literal>CONTENT</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        当在XML和字符串值之间进行转换时，无论设置DOCUMENT或 CONTENT都是隐式的。可参阅Section 8.13。 有效值是DOCUMENT和CONTENT。 缺省值是CONTENT。当在 XML 和字符串值之间进行转换时，设置<literal>DOCUMENT</literal>或<literal>CONTENT</literal>都是隐式的。详见<xref linkend="datatype-xml"/>。有效值是<literal>DOCUMENT</literal>和<literal>CONTENT</literal>。默认值是<literal>CONTENT</literal>。
       </para>

<!--==========================orignal english content==========================
       <para>
        According to the SQL standard, the command to set this option is
<synopsis>
SET XML OPTION { DOCUMENT | CONTENT };
</synopsis>
        This syntax is also available in PostgreSQL.
       </para>
____________________________________________________________________________-->
       <para>
        根据 SQL 标准，设置这个选项的命令是：
<synopsis>
SET XML OPTION { DOCUMENT | CONTENT };
</synopsis>
        这种语法在 PostgreSQL 也可用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-gin-pending-list-limit" xreflabel="gin_pending_list_limit">
<!--==========================orignal english content==========================
      <term><varname>gin_pending_list_limit</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>gin_pending_list_limit</varname></primary>
       <secondary>configuration parameter</secondary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>gin_pending_list_limit</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>gin_pending_list_limit</varname></primary>
       <secondary>配置参数</secondary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the maximum size of a GIN index's pending list, which is used
        when <literal>fastupdate</literal> is enabled. If the list grows
        larger than this maximum size, it is cleaned up by moving
        the entries in it to the index's main GIN data structure in bulk.
        If this value is specified without units, it is taken as kilobytes.
        The default is four megabytes (<literal>4MB</literal>). This setting
        can be overridden for individual GIN indexes by changing
        index storage parameters.
         See <xref linkend="gin-fast-update"/> and <xref linkend="gin-tips"/>
         for more information.
       </para>
____________________________________________________________________________-->
       <para>
        设置<literal>fastupdate</literal>被启用时可以使用的 GIN索引的待处理列表的最大尺寸。
        如果该列表增长到超过这个最大尺寸，会通过批量将其中的项移入索引的主 GIN 数据结构来清理列表。
        如果指定值时没有单位，则以千字节为单位。默认值是四兆字节（<literal>4MB</literal>）。
        可以通过更改索引的存储参数来为个别 GIN 索引覆盖这个设置。更多信息请见<xref linkend="gin-fast-update"/>和<xref linkend="gin-tips"/>。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect2>
     <sect2 id="runtime-config-client-format">
<!--==========================orignal english content==========================
     <title>Locale and Formatting</title>
____________________________________________________________________________-->
     <title>区域和格式化</title>

     <variablelist>

     <varlistentry id="guc-datestyle" xreflabel="DateStyle">
<!--==========================orignal english content==========================
      <term><varname>DateStyle</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>DateStyle</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>DateStyle</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>DateStyle</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the display format for date and time values, as well as the
        rules for interpreting ambiguous date input values. For
        historical reasons, this variable contains two independent
        components: the output format specification (<literal>ISO</literal>,
        <literal>Postgres</literal>, <literal>SQL</literal>, or <literal>German</literal>)
        and the input/output specification for year/month/day ordering
        (<literal>DMY</literal>, <literal>MDY</literal>, or <literal>YMD</literal>). These
        can be set separately or together. The keywords <literal>Euro</literal>
        and <literal>European</literal> are synonyms for <literal>DMY</literal>; the
        keywords <literal>US</literal>, <literal>NonEuro</literal>, and
        <literal>NonEuropean</literal> are synonyms for <literal>MDY</literal>. See
        <xref linkend="datatype-datetime"/> for more information. The
        built-in default is <literal>ISO, MDY</literal>, but
        <application>initdb</application> will initialize the
        configuration file with a setting that corresponds to the
        behavior of the chosen <varname>lc_time</varname> locale.
       </para>
____________________________________________________________________________-->
       <para>
        设置日期和时间值的显示格式，以及解释有歧义的日期输入值的规则。由于历史原因， 这个变量包含两个独立的部分：输出格式声明（<literal>ISO</literal>、<literal>Postgres</literal>、<literal>SQL</literal>或<literal>German</literal>）、 输入/输出的年/月/日顺序（<literal>DMY</literal>、<literal>MDY</literal>或<literal>YMD</literal>）。这些可以被独立设置或者一起设置。关键字<literal>Euro</literal>和<literal>European</literal>是<literal>DMY</literal>的同义词；关键字<literal>US</literal>、<literal>NonEuro</literal>和<literal>NonEuropean</literal>是<literal>MDY</literal>的同义词。详见<xref linkend="datatype-datetime"/>。内建默认值是<literal>ISO, MDY</literal>，但是<application>initdb</application>将用对应于选中的<varname>lc_time</varname>区域行为的设置初始化配置文件。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-intervalstyle" xreflabel="IntervalStyle">
<!--==========================orignal english content==========================
      <term><varname>IntervalStyle</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>IntervalStyle</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>IntervalStyle</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>IntervalStyle</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the display format for interval values.
        The value <literal>sql_standard</literal> will produce
        output matching <acronym>SQL</acronym> standard interval literals.
        The value <literal>postgres</literal> (which is the default) will produce
        output matching <productname>PostgreSQL</productname> releases prior to 8.4
        when the <xref linkend="guc-datestyle"/>
        parameter was set to <literal>ISO</literal>.
        The value <literal>postgres_verbose</literal> will produce output
        matching <productname>PostgreSQL</productname> releases prior to 8.4
        when the <varname>DateStyle</varname>
        parameter was set to non-<literal>ISO</literal> output.
        The value <literal>iso_8601</literal> will produce output matching the time
        interval <quote>format with designators</quote> defined in section
        4.4.3.2 of ISO 8601.
       </para>
____________________________________________________________________________-->
       <para>
        设置间隔值的显示格式。值<literal>sql_standard</literal>将产生匹配 SQL 标准间隔文本的输出。当<xref linkend="guc-datestyle"/>参数被设置为<literal>ISO</literal>时，值<literal>postgres</literal>（默认）将产生匹配<productname>PostgreSQL</productname>发行 8.4 之前的输出。当<varname>DateStyle</varname>参数被设置为非<literal>ISO</literal>输出时，值<literal>postgres_verbose</literal>会产生匹配<productname>PostgreSQL</productname>发行 8.4 之前的输出。值<literal>iso_8601</literal>会产生匹配在 ISO 8601 的 4.4.3.2 节中定义的<quote>带标志符格式</quote>的时间间隔的输出。
       </para>

<!--==========================orignal english content==========================
       <para>
        The <varname>IntervalStyle</varname> parameter also affects the
        interpretation of ambiguous interval input.  See
        <xref linkend="datatype-interval-input"/> for more information.
       </para>
____________________________________________________________________________-->
       <para>
        <varname>IntervalStyle</varname>参数也可以影响对有歧义的间隔输入的解释。详见<xref linkend="datatype-interval-input"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-timezone" xreflabel="TimeZone">
<!--==========================orignal english content==========================
      <term><varname>TimeZone</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>TimeZone</varname> configuration parameter</primary>
      </indexterm>
      <indexterm><primary>time zone</primary></indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>TimeZone</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>TimeZone</varname>配置参数</primary>
      </indexterm>
      <indexterm><primary>time zone</primary></indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the time zone for displaying and interpreting time stamps.
        The built-in default is <literal>GMT</literal>, but that is typically
        overridden in <filename>postgresql.conf</filename>; <application>initdb</application>
        will install a setting there corresponding to its system environment.
        See <xref linkend="datatype-timezones"/> for more information.
       </para>
____________________________________________________________________________-->
       <para>
        设置用于显示和解释时间戳的时区。内建默认值是<literal>GMT</literal>，但是它通常会在<filename>postgresql.conf</filename>中被覆盖；<application>initdb</application>将安装一个对应于其系统环境的设置。详见<xref linkend="datatype-timezones"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-timezone-abbreviations" xreflabel="timezone_abbreviations">
<!--==========================orignal english content==========================
      <term><varname>timezone_abbreviations</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>timezone_abbreviations</varname> configuration parameter</primary>
      </indexterm>
      <indexterm><primary>time zone names</primary></indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>timezone_abbreviations</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>timezone_abbreviations</varname>配置参数</primary>
      </indexterm>
      <indexterm><primary>time zone names</primary></indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the collection of time zone abbreviations that will be accepted
        by the server for datetime input.  The default is <literal>'Default'</literal>,
        which is a collection that works in most of the world; there are
        also <literal>'Australia'</literal> and <literal>'India'</literal>,
        and other collections can be defined for a particular installation.
        See <xref linkend="datetime-config-files"/> for more information.
       </para>
____________________________________________________________________________-->
       <para>
        设置服务器接受的日期时间输入中使用的时区缩写集合。默认值为<literal>'Default'</literal>， 这个集合在全世界大多数地方都能工作。也还有<literal>'Australia'</literal>和<literal>'India'</literal>，以及可能为一种特定安装定义的其他集合。详见<xref linkend="datetime-config-files"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-extra-float-digits" xreflabel="extra_float_digits">
<!--==========================orignal english content==========================
      <term><varname>extra_float_digits</varname> (<type>integer</type>)
      <indexterm>
       <primary>significant digits</primary>
      </indexterm>
      <indexterm>
       <primary>floating-point</primary>
       <secondary>display</secondary>
      </indexterm>
      <indexterm>
       <primary><varname>extra_float_digits</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>extra_float_digits</varname> (<type>integer</type>)
      <indexterm>
       <primary>significant digits</primary>
      </indexterm>
      <indexterm>
       <primary>floating-point</primary>
       <secondary>display</secondary>
      </indexterm>
      <indexterm>
       <primary><varname>extra_float_digits</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        This parameter adjusts the number of digits used for textual output of
        floating-point values, including <type>float4</type>, <type>float8</type>,
        and geometric data types.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数调整用于文本输出浮点值的位数，包括<type>float4</type>，<type>float8</type>以及几何数据类型。
       </para>

<!--==========================orignal english content==========================
       <para>
        If the value is 1 (the default) or above, float values are output in
        shortest-precise format; see <xref linkend="datatype-float"/>. The
        actual number of digits generated depends only on the value being
        output, not on the value of this parameter. At most 17 digits are
        required for <type>float8</type> values, and 9 for <type>float4</type>
        values. This format is both fast and precise, preserving the original
        binary float value exactly when correctly read. For historical
        compatibility, values up to 3 are permitted.
       </para>
____________________________________________________________________________-->
       <para>
        如果值为1(默认值)或更高，浮点值被输出为最短-精度格式；参见<xref linkend="datatype-float"/>。
        实际生成的位数只取决于输出的值，而不取决于此参数的值。
        <type> float8</type> 值最多需要 17 位数字，<type>float4</type>值最多需要9位数字。
        这种格式既快速又精确，在正确读取时精确地保留了原始的二进制浮点值。为了历史兼容性，允许的值最大为3。
       </para>

<!--==========================orignal english content==========================
       <para>
        If the value is zero or negative, then the output is rounded to a
        given decimal precision. The precision used is the standard number of
        digits for the type (<literal>FLT_DIG</literal>
        or <literal>DBL_DIG</literal> as appropriate) reduced according to the
        value of this parameter. (For example, specifying -1 will cause
        <type>float4</type> values to be output rounded to 5 significant
        digits, and <type>float8</type> values
        rounded to 14 digits.) This format is slower and does not preserve all
        the bits of the binary float value, but may be more human-readable.
       </para>
____________________________________________________________________________-->
       <para>
        如果值为零或负，则输出四舍五入为给定的十进制精度。
        使用的精度是根据此参数的值减小的类型（(<literal>FLT_DIG</literal>或<literal>DBL_DIG</literal>，视情况而定）的标准位数。
        （例如，指定 -1 将导致<type>float4</type> 值输出四舍五入为 5 位有效数字，而<type>float8</type>值四舍五入为 14 位。）
        此格式较慢，不会保留二进制浮点值的所有位，但可能令人更易于阅读。
       </para>

       <note>
<!--==========================orignal english content==========================
        <para>
         The meaning of this parameter, and its default value, changed
         in <productname>PostgreSQL</productname> 12;
         see <xref linkend="datatype-float"/> for further discussion.
        </para>
____________________________________________________________________________-->
        <para>
         此参数的含义，以及其默认值，在 <productname>PostgreSQL</productname> 12 中发生了变化;
         参见 <xref linkend="datatype-float"/> 以便进一步讨论。
        </para>
       </note>

      </listitem>
     </varlistentry>

     <varlistentry id="guc-client-encoding" xreflabel="client_encoding">
<!--==========================orignal english content==========================
      <term><varname>client_encoding</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>client_encoding</varname> configuration parameter</primary>
      </indexterm>
      <indexterm><primary>character set</primary></indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>client_encoding</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>client_encoding</varname>配置参数</primary>
      </indexterm>
      <indexterm><primary>character set</primary></indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the client-side encoding (character set).
        The default is to use the database encoding.
        The character sets supported by the <productname>PostgreSQL</productname>
        server are described in <xref linkend="multibyte-charset-supported"/>.
       </para>
____________________________________________________________________________-->
       <para>
        设置客户端编码（字符集）。默认使用数据库编码。<productname>PostgreSQL</productname>服务器所支持的字符集在<xref linkend="multibyte-charset-supported"/>中描述。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-lc-messages" xreflabel="lc_messages">
<!--==========================orignal english content==========================
      <term><varname>lc_messages</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>lc_messages</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>lc_messages</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>lc_messages</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the language in which messages are displayed.  Acceptable
        values are system-dependent; see <xref linkend="locale"/> for
        more information.  If this variable is set to the empty string
        (which is the default) then the value is inherited from the
        execution environment of the server in a system-dependent way.
       </para>
____________________________________________________________________________-->
       <para>
        设置消息显示的语言。可接受的值是系统相关的；详见<xref linkend="locale"/>。如果这个变量被设置为空字符串（默认），那么该值将以一种系统相关的方式从服务器的执行环境中继承。
       </para>

<!--==========================orignal english content==========================
       <para>
        On some systems, this locale category does not exist.  Setting
        this variable will still work, but there will be no effect.
        Also, there is a chance that no translated messages for the
        desired language exist.  In that case you will continue to see
        the English messages.
       </para>
____________________________________________________________________________-->
       <para>
        在一些系统上，这个区域分类并不存在。仍然可以设置这个变量，只是不会有任何效果。同样，所期望语言的翻译消息也可能不存在。在这种情况下，你将仍然继续看到英文消息。
       </para>

<!--==========================orignal english content==========================
       <para>
        Only superusers can change this setting, because it affects the
        messages sent to the server log as well as to the client, and
        an improper value might obscure the readability of the server
        logs.
       </para>
____________________________________________________________________________-->
       <para>
        只有超级用户可以改变这个设置。因为它同时影响发送到服务器日志和客户端的消息。一个不正确的值可能会降低服务器日志的可读性。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-lc-monetary" xreflabel="lc_monetary">
<!--==========================orignal english content==========================
      <term><varname>lc_monetary</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>lc_monetary</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>lc_monetary</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>lc_monetary</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the locale to use for formatting monetary amounts, for
        example with the <function>to_char</function> family of
        functions.  Acceptable values are system-dependent; see <xref
        linkend="locale"/> for more information.  If this variable is
        set to the empty string (which is the default) then the value
        is inherited from the execution environment of the server in a
        system-dependent way.
       </para>
____________________________________________________________________________-->
       <para>
        设置用于格式化货币量的区域，例如用<function>to_char</function>函数族。可接受的值是系统相关的；详见<xref linkend="locale"/>。如果这个变量被设置为空字符串（默认），那么该值将以一种系统相关的方式从服务器的执行环境中继承。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-lc-numeric" xreflabel="lc_numeric">
<!--==========================orignal english content==========================
      <term><varname>lc_numeric</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>lc_numeric</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>lc_numeric</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>lc_numeric</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the locale to use for formatting numbers, for example
        with the <function>to_char</function> family of
        functions. Acceptable values are system-dependent; see <xref
        linkend="locale"/> for more information.  If this variable is
        set to the empty string (which is the default) then the value
        is inherited from the execution environment of the server in a
        system-dependent way.
       </para>
____________________________________________________________________________-->
       <para>
        设置用于格式化数字的区域，例如用<function>to_char</function>函数族。可接受的值是系统相关的；详见<xref linkend="locale"/>。如果这个变量被设置为空字符串（默认），那么该值将以一种系统相关的方式从服务器的执行环境中继承。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-lc-time" xreflabel="lc_time">
<!--==========================orignal english content==========================
      <term><varname>lc_time</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>lc_time</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>lc_time</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>lc_time</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Sets the locale to use for formatting dates and times, for example
        with the <function>to_char</function> family of
        functions. Acceptable values are system-dependent; see <xref
        linkend="locale"/> for more information.  If this variable is
        set to the empty string (which is the default) then the value
        is inherited from the execution environment of the server in a
        system-dependent way.
       </para>
____________________________________________________________________________-->
       <para>
        设置用于格式化日期和时间的区域，例如用<function>to_char</function>函数族。可接受的值是系统相关的；详见<xref linkend="locale"/>。如果这个变量被设置为空字符串（默认），那么该值将以一种系统相关的方式从服务器的执行环境中继承。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-default-text-search-config" xreflabel="default_text_search_config">
<!--==========================orignal english content==========================
      <term><varname>default_text_search_config</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>default_text_search_config</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>default_text_search_config</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>default_text_search_config</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Selects the text search configuration that is used by those variants
        of the text search functions that do not have an explicit argument
        specifying the configuration.
        See <xref linkend="textsearch"/> for further information.
        The built-in default is <literal>pg_catalog.simple</literal>, but
        <application>initdb</application> will initialize the
        configuration file with a setting that corresponds to the
        chosen <varname>lc_ctype</varname> locale, if a configuration
        matching that locale can be identified.
       </para>
____________________________________________________________________________-->
       <para>
        选择被那些没有显式参数指定配置的文本搜索函数变体使用的文本搜索配置。详见<xref linkend="textsearch"/>。内建默认值是<literal>pg_catalog.simple</literal>，但是如果能够标识一个匹配区域的配置，<application>initdb</application>将用对应于选中的<varname>lc_ctype</varname>区域的设置初始化配置文件。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>

    </sect2>

    <sect2 id="runtime-config-client-preload">
<!--==========================orignal english content==========================
     <title>Shared Library Preloading</title>
____________________________________________________________________________-->
     <title>共享库预载入</title>
<!--==========================orignal english content==========================
     <para>
      Several settings are available for preloading shared libraries into the
      server, in order to load additional functionality or achieve performance
      benefits.  For example, a setting of
      <literal>'$libdir/mylib'</literal> would cause
      <literal>mylib.so</literal> (or on some platforms,
      <literal>mylib.sl</literal>) to be preloaded from the installation's standard
      library directory.  The differences between the settings are when they
      take effect and what privileges are required to change them.
     </para>
____________________________________________________________________________-->
     <para>
      为了载入附加的功能或者达到提高性能的目的，可用多个设置来预先载入共享库到服务器中。
      例如<literal>'$libdir/mylib'</literal>设置可能会导致<literal>mylib.so</literal>（或者某些平台上的<literal>mylib.sl</literal>）从安装的标准库目录被预装载。这些设置之间的区别在于生效的时间以及改变它们所需的特权。
     </para>

<!--==========================orignal english content==========================
     <para>
      <productname>PostgreSQL</productname> procedural language libraries can
      be preloaded in this way, typically by using the
      syntax <literal>'$libdir/plXXX'</literal> where
      <literal>XXX</literal> is <literal>pgsql</literal>, <literal>perl</literal>,
      <literal>tcl</literal>, or <literal>python</literal>.
     </para>
____________________________________________________________________________-->
     <para>
      可以用这个方法预装载<productname>PostgreSQL</productname>的过程语言库，通常是使用<literal>'$libdir/plXXX'</literal>语法，其中的<literal>XXX</literal>是<literal>pgsql</literal>、<literal>perl</literal>、<literal>tcl</literal>或<literal>python</literal>。
     </para>

<!--==========================orignal english content==========================
     <para>
      Only shared libraries specifically intended to be used with PostgreSQL
      can be loaded this way.  Every PostgreSQL-supported library has
      a <quote>magic block</quote> that is checked to guarantee compatibility.  For
      this reason, non-PostgreSQL libraries cannot be loaded in this way.  You
      might be able to use operating-system facilities such
      as <envar>LD_PRELOAD</envar> for that.
     </para>
____________________________________________________________________________-->
     <para>
      只有特别为与PostgreSQL一起使用设计的共享库才能以这种方式载入。每一个PostgreSQL支持
      的库都有一个<quote>魔法块</quote>，它会被检查以保证兼容性。由于这个原因，非PostgreSQL无法
      以这种方式被载入。你可能可以使用操作系统的工具（如<envar>LD_PRELOAD</envar>）载入它。
     </para>

<!--==========================orignal english content==========================
     <para>
      In general, refer to the documentation of a specific module for the
      recommended way to load that module.
     </para>
____________________________________________________________________________-->
     <para>
      总之，请参考特定模块的文档来用推荐的方法载入它。
     </para>

     <variablelist>
     <varlistentry id="guc-local-preload-libraries" xreflabel="local_preload_libraries">
<!--==========================orignal english content==========================
      <term><varname>local_preload_libraries</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>local_preload_libraries</varname> configuration parameter</primary>
      </indexterm>
      <indexterm>
       <primary><filename>$libdir/plugins</filename></primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>local_preload_libraries</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>local_preload_libraries</varname>配置参数</primary>
      </indexterm>
      <indexterm>
       <primary><filename>$libdir/plugins</filename></primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        This variable specifies one or more shared libraries that are to be
        preloaded at connection start.
        It contains a comma-separated list of library names, where each name
        is interpreted as for the <link linkend="sql-load"><command>LOAD</command></link> command.
        Whitespace between entries is ignored; surround a library name with
        double quotes if you need to include whitespace or commas in the name.
        The parameter value only takes effect at the start of the connection.
        Subsequent changes have no effect.  If a specified library is not
        found, the connection attempt will fail.
       </para>
____________________________________________________________________________-->
       <para>
        这个变量指定一个或者多个要在连接开始时预载入的共享库。
        它包含一个由逗号分隔的库名列表，其中每个名称都会按<link linkend="sql-load"><command>LOAD</command></link>命令的方式解析。
        项之间的空格会被忽略，如果需要在库名中包含空格或者逗号，请把库名放在双引号内。
        这个参数值只在连接开始时生效。后续的更改不会有任何效果。
        如果一个指定的库没有找到，连接尝试将会失败。
       </para>

<!--==========================orignal english content==========================
       <para>
        This option can be set by any user.  Because of that, the libraries
        that can be loaded are restricted to those appearing in the
        <filename>plugins</filename> subdirectory of the installation's
        standard library directory.  (It is the database administrator's
        responsibility to ensure that only <quote>safe</quote> libraries
        are installed there.)  Entries in <varname>local_preload_libraries</varname>
        can specify this directory explicitly, for example
        <literal>$libdir/plugins/mylib</literal>, or just specify
        the library name &mdash; <literal>mylib</literal> would have
        the same effect as <literal>$libdir/plugins/mylib</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        任何用户都能设置这个选项。正因为如此，能被这样载入的库被严格限制为出现于安装的标准库
        目录中<filename>plugins</filename>子目录下的共享库（保证只有<quote>安全的</quote>库被安装到
        这里是数据库管理员的责任）。<varname>local_preload_libraries</varname>中的项可以显式
        指定这个目录，例如<literal>$libdir/plugins/mylib</literal>，或者只是指定库的
        名称 &mdash; <literal>mylib</literal> 和
        <literal>$libdir/plugins/mylib</literal>的效果是相同的。
       </para>

<!--==========================orignal english content==========================
       <para>
        The intent of this feature is to allow unprivileged users to load
        debugging or performance-measurement libraries into specific sessions
        without requiring an explicit <command>LOAD</command> command.  To that end,
        it would be typical to set this parameter using
        the <envar>PGOPTIONS</envar> environment variable on the client or by
        using
        <command>ALTER ROLE SET</command>.
       </para>
____________________________________________________________________________-->
       <para>
        这个特性的目的是允许非特权用户在特定的会话中载入正在调试的或者性能度量库，
        而无需一个显式的<command>LOAD</command>命令。为了这个目的，通常通过使用客
        户端的<envar>PGOPTIONS</envar>环境变量或者
        <command>ALTER ROLE SET</command>来设置这个参数。
       </para>

<!--==========================orignal english content==========================
       <para>
        However, unless a module is specifically designed to be used in this way by
        non-superusers, this is usually not the right setting to use.  Look
        at <xref linkend="guc-session-preload-libraries"/> instead.
       </para>
____________________________________________________________________________-->
       <para>
        不过，除非一个模块被特别设计成由非超级用户以这种方式使用，通常不推荐使用这个设置。应该看看
        <xref linkend="guc-session-preload-libraries"/>。
       </para>
      </listitem>
     </varlistentry>


     <varlistentry id="guc-session-preload-libraries" xreflabel="session_preload_libraries">
<!--==========================orignal english content==========================
      <term><varname>session_preload_libraries</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>session_preload_libraries</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>session_preload_libraries</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>session_preload_libraries</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        This variable specifies one or more shared libraries that are to be
        preloaded at connection start.
        It contains a comma-separated list of library names, where each name
        is interpreted as for the <link linkend="sql-load"><command>LOAD</command></link> command.
        Whitespace between entries is ignored; surround a library name with
        double quotes if you need to include whitespace or commas in the name.
        The parameter value only takes effect at the start of the connection.
        Subsequent changes have no effect.  If a specified library is not
        found, the connection attempt will fail.
        Only superusers can change this setting.
       </para>
____________________________________________________________________________-->
       <para>
        这个变量指定一个或者多个要在连接开始时预载入的共享库。
        只有超级用户更够更改这个设置。
        它包含一个由逗号分隔的库名列表，其中每个名称都会按<link linkend="sql-load"><command>LOAD</command></link>命令的方式解析。
        项之间的空格会被忽略，如果需要在库名中包含空格或者逗号，请把库名放在双引号内。这个参数只在连接开始时起效。
        后续的改变没有效果。如果指定的库没有找到，连接尝试将会失败。
        只有超级用户能够更改这个设置。
       </para>

<!--==========================orignal english content==========================
       <para>
        The intent of this feature is to allow debugging or
        performance-measurement libraries to be loaded into specific sessions
        without an explicit
        <command>LOAD</command> command being given.  For
        example, <xref linkend="auto-explain"/> could be enabled for all
        sessions under a given user name by setting this parameter
        with <command>ALTER ROLE SET</command>.  Also, this parameter can be changed
        without restarting the server (but changes only take effect when a new
        session is started), so it is easier to add new modules this way, even
        if they should apply to all sessions.
       </para>
____________________________________________________________________________-->
       <para>
        这个特性的意图是允许在特定会话中载入调试用的或者测量性能的库，而不需要显式的给出一个
        <command>LOAD</command>命令。例如，通过用<command>ALTER ROLE SET</command>设置这个参数可以
        为一个给定用户名下的所有会话启用<xref linkend="auto-explain"/>。还有，无需重启
        服务器就能更改这个参数（但是只有新会话启动时才会生效），这样可以以这种方式更容易地增
        加新模块，即便它们会应用到所有会话。
       </para>

<!--==========================orignal english content==========================
       <para>
        Unlike <xref linkend="guc-shared-preload-libraries"/>, there is no large
        performance advantage to loading a library at session start rather than
        when it is first used.  There is some advantage, however, when
        connection pooling is used.
       </para>
____________________________________________________________________________-->
       <para>
        和<xref linkend="guc-shared-preload-libraries"/>不同，相对于在库被第一次使用
        时载入它，在会话开始时载入库并没有什么性能优势。不过，当使用连接池时这样做还是有一些
        优势。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-shared-preload-libraries" xreflabel="shared_preload_libraries">
<!--==========================orignal english content==========================
      <term><varname>shared_preload_libraries</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>shared_preload_libraries</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>shared_preload_libraries</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>shared_preload_libraries</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        This variable specifies one or more shared libraries to be preloaded at
        server start.
        It contains a comma-separated list of library names, where each name
        is interpreted as for the <link linkend="sql-load"><command>LOAD</command></link> command.
        Whitespace between entries is ignored; surround a library name with
        double quotes if you need to include whitespace or commas in the name.
        This parameter can only be set at server start.  If a specified
        library is not found, the server will fail to start.
       </para>
____________________________________________________________________________-->
       <para>
        这个变量指定一个或者多个要在服务器启动时预载入的共享库。
        它包含一个由逗号分隔的库名列表，其中每个名称都会按<link linkend="sql-load"><command>LOAD</command></link>命令的方式解析。
        项之间的空格会被忽略，如果需要在库名中包含空格或者逗号，请把库名放在双引号内。
        这个参数只能在服务器启动时设置。
        如果指定的库没有找到，服务器将无法启动。
       </para>

<!--==========================orignal english content==========================
       <para>
        Some libraries need to perform certain operations that can only take
        place at postmaster start, such as allocating shared memory, reserving
        light-weight locks, or starting background workers.  Those libraries
        must be loaded at server start through this parameter.  See the
        documentation of each library for details.
       </para>
____________________________________________________________________________-->
       <para>
        有些库需要执行只能在postmaster启动时发生的特定操作，例如分配共享内存、保留轻量级锁
        或者启动后台工作者。这些库必须通过这个参数在服务器启动时载入。每个库的详情请见文档。
       </para>

<!--==========================orignal english content==========================
       <para>
        Other libraries can also be preloaded.  By preloading a shared library,
        the library startup time is avoided when the library is first used.
        However, the time to start each new server process might increase
        slightly, even if that process never uses the library.  So this
        parameter is recommended only for libraries that will be used in most
        sessions.  Also, changing this parameter requires a server restart, so
        this is not the right setting to use for short-term debugging tasks,
        say.  Use <xref linkend="guc-session-preload-libraries"/> for that
        instead.
       </para>
____________________________________________________________________________-->
       <para>
        其他库也能被预载入。通过预载入一个共享库，当该库被第一次使用时就可以避免库的启动时间。
        不过，启动每个新服务器进程的时间可能会略有增加，即使该进程从不使用该库。因此，推荐只
        把这个参数用于那些要在大多数会话中使用的库上。还有，改变这个参数要求重启服务器，因此
        对于短期的调试任务来说这不是好的选择，应该转用
        <xref linkend="guc-session-preload-libraries"/>。
       </para>

      <note>
<!--==========================orignal english content==========================
       <para>
        On Windows hosts, preloading a library at server start will not reduce
        the time required to start each new server process; each server process
        will re-load all preload libraries.  However, <varname>shared_preload_libraries
        </varname> is still useful on Windows hosts for libraries that need to
        perform operations at postmaster start time.
       </para>
____________________________________________________________________________-->
       <para>
        在 Windows 主机上，在服务器启动时预载入一个库并不会减少启动每个新服务器进程所需的
        时间；每一个服务器进程将会重新载入预载入的库。不过，对于那些要在postmaster启动时
        执行操作的库来说，Windows 主机上的
        <varname>shared_preload_libraries</varname>任然有用。
       </para>
      </note>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-jit-provider" xreflabel="jit_provider">
<!--==========================orignal english content==========================
      <term><varname>jit_provider</varname> (<type>string</type>)
       <indexterm>
        <primary><varname>jit_provider</varname> configuration parameter</primary>
       </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>jit_provider</varname> (<type>string</type>)
       <indexterm>
        <primary><varname>jit_provider</varname>配置参数</primary>
       </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        This variable is the name of the JIT provider library to be used
        (see <xref linkend="jit-pluggable"/>).
        The default is <literal>llvmjit</literal>.
        This parameter can only be set at server start.
       </para>
____________________________________________________________________________-->
       <para>
        这个变量是要被使用的JIT提供者库的名称（见<xref linkend="jit-pluggable"/>）。默认是<literal>llvmjit</literal>。这个参数只能在服务器启动时设置。
       </para>

<!--==========================orignal english content==========================
       <para>
        If set to a non-existent library, <acronym>JIT</acronym> will not be
        available, but no error will be raised. This allows JIT support to be
        installed separately from the main
        <productname>PostgreSQL</productname> package.
       </para>
____________________________________________________________________________-->
       <para>
        如果这个变量被设置为一个不存在的库，<acronym>JIT</acronym>将不可用，但是也不会发生错误。这种特性允许在主<productname>PostgreSQL</productname>包之外单独安装JIT支持。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect2>

     <sect2 id="runtime-config-client-other">
<!--==========================orignal english content==========================
     <title>Other Defaults</title>
____________________________________________________________________________-->
     <title>其他默认值</title>

     <variablelist>

     <varlistentry id="guc-dynamic-library-path" xreflabel="dynamic_library_path">
<!--==========================orignal english content==========================
      <term><varname>dynamic_library_path</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>dynamic_library_path</varname> configuration parameter</primary>
      </indexterm>
      <indexterm><primary>dynamic loading</primary></indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>dynamic_library_path</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>dynamic_library_path</varname>配置参数</primary>
      </indexterm>
      <indexterm><primary>dynamic loading</primary></indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        If a dynamically loadable module needs to be opened and the
        file name specified in the <command>CREATE FUNCTION</command> or
        <command>LOAD</command> command
        does not have a directory component (i.e., the
        name does not contain a slash), the system will search this
        path for the required file.
       </para>
____________________________________________________________________________-->
       <para>
        如果需要打开一个可以动态装载的模块并且在<command>CREATE FUNCTION</command>或<command>LOAD</command>命令中指定的文件名没有目录部分（即名字中不包含斜线），那么系统将搜索这个路径以查找所需的文件。
       </para>

<!--==========================orignal english content==========================
       <para>
        The value for <varname>dynamic_library_path</varname> must be a
        list of absolute directory paths separated by colons (or semi-colons
        on Windows).  If a list element starts
        with the special string <literal>$libdir</literal>, the
        compiled-in <productname>PostgreSQL</productname> package
        library directory is substituted for <literal>$libdir</literal>; this
        is where the modules provided by the standard
        <productname>PostgreSQL</productname> distribution are installed.
        (Use <literal>pg_config -&minus;pkglibdir</literal> to find out the name of
        this directory.) For example:
<programlisting>
dynamic_library_path = '/usr/local/lib/postgresql:/home/my_project/lib:$libdir'
</programlisting>
        or, in a Windows environment:
<programlisting>
dynamic_library_path = 'C:\tools\postgresql;H:\my_project\lib;$libdir'
</programlisting>
       </para>
____________________________________________________________________________-->
       <para>
        <varname>dynamic_library_path</varname>的值必须是一个冒号分隔（或者在 Windows 上以分号分隔）的绝对目录路径的列表。如果一个列表元素以特殊字符串开始，<literal>$libdir</literal>会被替换为<productname>PostgreSQL</productname>包中已编译好的库目录。这里是<productname>PostgreSQL</productname>发布提供的模块被安装的位置（使用<literal>pg_config --pkglibdir</literal>来找到这个目录的名字）。例如：
<programlisting>
dynamic_library_path = '/usr/local/lib/postgresql:/home/my_project/lib:$libdir'
</programlisting>
        或者在 Windows 环境中：
<programlisting>
dynamic_library_path = 'C:\tools\postgresql;H:\my_project\lib;$libdir'
</programlisting>
       </para>

<!--==========================orignal english content==========================
       <para>
        The default value for this parameter is
        <literal>'$libdir'</literal>. If the value is set to an empty
        string, the automatic path search is turned off.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数的默认值是<literal>'$libdir'</literal>。如果该值被设置为一个空字符串，则关闭自动路径搜索。
       </para>

<!--==========================orignal english content==========================
       <para>
        This parameter can be changed at run time by superusers, but a
        setting done that way will only persist until the end of the
        client connection, so this method should be reserved for
        development purposes. The recommended way to set this parameter
        is in the <filename>postgresql.conf</filename> configuration
        file.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数可以在运行时由超级用户修改，但是这样修改的设置只能保持到这个客户端连接的结尾，因此这个方法应该保留给开发目的。 我们建议在<filename>postgresql.conf</filename>配置文件中设置这个参数。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-gin-fuzzy-search-limit" xreflabel="gin_fuzzy_search_limit">
<!--==========================orignal english content==========================
      <term><varname>gin_fuzzy_search_limit</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>gin_fuzzy_search_limit</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>gin_fuzzy_search_limit</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>gin_fuzzy_search_limit</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Soft upper limit of the size of the set returned by GIN index scans. For more
        information see <xref linkend="gin-tips"/>.
       </para>
____________________________________________________________________________-->
       <para>
        GIN 索引返回的集合尺寸的软上限。详见<xref linkend="gin-tips"/>。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect2>
   </sect1>

   <sect1 id="runtime-config-locks">
<!--==========================orignal english content==========================
    <title>Lock Management</title>
____________________________________________________________________________-->
    <title>锁管理</title>

     <variablelist>

     <varlistentry id="guc-deadlock-timeout" xreflabel="deadlock_timeout">
<!--==========================orignal english content==========================
      <term><varname>deadlock_timeout</varname> (<type>integer</type>)
      <indexterm>
       <primary>deadlock</primary>
       <secondary>timeout during</secondary>
      </indexterm>
      <indexterm>
       <primary>timeout</primary>
       <secondary>deadlock</secondary>
      </indexterm>
      <indexterm>
       <primary><varname>deadlock_timeout</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>deadlock_timeout</varname> (<type>integer</type>)
      <indexterm>
       <primary>deadlock</primary>
       <secondary>timeout during</secondary>
      </indexterm>
      <indexterm>
       <primary>timeout</primary>
       <secondary>deadlock</secondary>
      </indexterm>
      <indexterm>
       <primary><varname>deadlock_timeout</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        This is the amount of time to wait on a lock
        before checking to see if there is a deadlock condition. The
        check for deadlock is relatively expensive, so the server doesn't run
        it every time it waits for a lock. We optimistically assume
        that deadlocks are not common in production applications and
        just wait on the lock for a while before checking for a
        deadlock. Increasing this value reduces the amount of time
        wasted in needless deadlock checks, but slows down reporting of
        real deadlock errors.
        If this value is specified without units, it is taken as milliseconds.
        The default is one second (<literal>1s</literal>),
        which is probably about the smallest value you would want in
        practice. On a heavily loaded server you might want to raise it.
        Ideally the setting should exceed your typical transaction time,
        so as to improve the odds that a lock will be released before
        the waiter decides to check for deadlock.  Only superusers can change
        this setting.
       </para>
____________________________________________________________________________-->
       <para>
        这是进行死锁检测之前在一个锁上等待的时间量。死锁检测相对昂贵，因此服务器不会在每次等待锁时都运行这个它。
        我们乐观地假设在生产应用中死锁是不常出现的，并且只在开始检测死锁之前等待一会儿。增加这个值就减少了浪费在无用的死锁检测上的时间，但是减慢了报告真正死锁错误的速度。
        如果指定值时没有单位，则以毫秒为单位。默认是 1 秒（<literal>1s</literal>），这可能是实际中你想要的最小值。
        在一个高负载的服务器上，你可能需要增大它。这个值的理想设置应该超过你通常的事务时间，这样就可以减少在锁释放之前就开始死锁检查的机会。只有超级用户可以更改这个设置。
       </para>

<!--==========================orignal english content==========================
       <para>
        When <xref linkend="guc-log-lock-waits"/> is set,
        this parameter also determines the amount of time to wait before
        a log message is issued about the lock wait.  If you are trying
        to investigate locking delays you might want to set a shorter than
        normal <varname>deadlock_timeout</varname>.
       </para>
____________________________________________________________________________-->
       <para>
        当<xref linkend="guc-log-lock-waits"/>被设置时，这个参数还可以决定发出关于锁等待的日志之前等待的时间量。如果你想调查锁延迟，你可能希望设置一个比正常的<varname>deadlock_timeout</varname>小的值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-locks-per-transaction" xreflabel="max_locks_per_transaction">
<!--==========================orignal english content==========================
      <term><varname>max_locks_per_transaction</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_locks_per_transaction</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>max_locks_per_transaction</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_locks_per_transaction</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The shared lock table tracks locks on
        <varname>max_locks_per_transaction</varname> * (<xref
        linkend="guc-max-connections"/> + <xref
        linkend="guc-max-prepared-transactions"/>) objects (e.g.,  tables);
        hence, no more than this many distinct objects can be locked at
        any one time.  This parameter controls the average number of object
        locks allocated for each transaction;  individual transactions
        can lock more objects as long as the locks of all transactions
        fit in the lock table.  This is <emphasis>not</emphasis> the number of
        rows that can be locked; that value is unlimited.  The default,
        64, has historically proven sufficient, but you might need to
        raise this value if you have queries that touch many different
        tables in a single transaction, e.g., query of a parent table with
        many children.  This parameter can only be set at server start.
       </para>
____________________________________________________________________________-->
       <para>
        共享锁表跟踪在<varname>max_locks_per_transaction</varname> * (<xref
        linkend="guc-max-connections"/> + <xref
        linkend="guc-max-prepared-transactions"/>) 个对象（如表）上的锁。因此，在任何一个时刻，只有不超过这么多个可区分对象能够被锁住。这个参数控制为每个事务分配的对象锁的平均数量。个体事务可以锁住更多对象，数量可以和锁表中能容纳的所有事务的锁一样多。这<emphasis>不</emphasis>是能被锁住的行数，那个值是没有限制的。默认值 64 已经被历史证明是足够的，但是如果你有需要在一个事务中使用很多不同表的查询（例如查询一个有很多子表的父表），你可能需要提高这个值。这个参数只能在服务器启动时设置。
       </para>

<!--==========================orignal english content==========================
       <para>
        When running a standby server, you must set this parameter to the
        same or higher value than on the primary server. Otherwise, queries
        will not be allowed in the standby server.
       </para>
____________________________________________________________________________-->
       <para>
        当运行一个后备服务器时，你必须设置这个参数为大于等于主服务器上的值。
        否则，后备服务器上将不允许查询。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-pred-locks-per-transaction" xreflabel="max_pred_locks_per_transaction">
<!--==========================orignal english content==========================
      <term><varname>max_pred_locks_per_transaction</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_pred_locks_per_transaction</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>max_pred_locks_per_transaction</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_pred_locks_per_transaction</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The shared predicate lock table tracks locks on
        <varname>max_pred_locks_per_transaction</varname> * (<xref
        linkend="guc-max-connections"/> + <xref
        linkend="guc-max-prepared-transactions"/>) objects (e.g., tables);
        hence, no more than this many distinct objects can be locked at
        any one time.  This parameter controls the average number of object
        locks allocated for each transaction;  individual transactions
        can lock more objects as long as the locks of all transactions
        fit in the lock table.  This is <emphasis>not</emphasis> the number of
        rows that can be locked; that value is unlimited.  The default,
        64, has generally been sufficient in testing, but you might need to
        raise this value if you have clients that touch many different
        tables in a single serializable transaction. This parameter can
        only be set at server start.
       </para>
____________________________________________________________________________-->
       <para>
        共享谓词锁表跟踪在<varname>max_pred_locks_per_transaction</varname> * (<xref
        linkend="guc-max-connections"/> + <xref
        linkend="guc-max-prepared-transactions"/>) 个对象（如表）上的锁。因此，在任何一个时刻，只有不超过这么多个可区分对象能够被锁住。这个参数控制为每个事务分配的对象锁的平均数量。个体事务可以锁住更多对象，数量可以和锁表中能容纳的所有事务的锁一样多。这<emphasis>不</emphasis>是能被锁住的行数，那个值是没有限制的。默认值 64 已经在测试中被证明通常是足够的，但是如果你有需要在一个可序列化事务中使用很多不同表的查询（例如查询一个有很多子表的父表），你可能需要提高这个值。这个参数只能在服务器启动时设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-pred-locks-per-relation" xreflabel="max_pred_locks_per_relation">
<!--==========================orignal english content==========================
      <term><varname>max_pred_locks_per_relation</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_pred_locks_per_relation</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>max_pred_locks_per_relation</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_pred_locks_per_relation</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        This controls how many pages or tuples of a single relation can be
        predicate-locked before the lock is promoted to covering the whole
        relation.  Values greater than or equal to zero mean an absolute
        limit, while negative values
        mean <xref linkend="guc-max-pred-locks-per-transaction"/> divided by
        the absolute value of this setting.  The default is -2, which keeps
        the behavior from previous versions of <productname>PostgreSQL</productname>.
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数控制在谓词锁被提升为覆盖整个关系之前，该谓词锁能够在单个关系上锁住多少页面或元组。大于等于零的值表示一种绝对限制，而负值表示用<xref linkend="guc-max-pred-locks-per-transaction"/>除以这个设置的绝对值。默认值为-2，它将保持以往版本的<productname>PostgreSQL</productname>中的行为。这个参数只能在<filename>postgresql.conf</filename>文件中或者服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-pred-locks-per-page" xreflabel="max_pred_locks_per_page">
<!--==========================orignal english content==========================
      <term><varname>max_pred_locks_per_page</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_pred_locks_per_page</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>max_pred_locks_per_page</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_pred_locks_per_page</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        This controls how many rows on a single page can be predicate-locked
        before the lock is promoted to covering the whole page.  The default
        is 2.  This parameter can only be set in
        the <filename>postgresql.conf</filename> file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数控制在谓词锁被提升为覆盖整个页面之前，该谓词锁能在单一页面上锁住多少行。默认值是2。这个参数只能在<filename>postgresql.conf</filename>文件中或者服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
   </sect1>

   <sect1 id="runtime-config-compatible">
<!--==========================orignal english content==========================
    <title>Version and Platform Compatibility</title>
____________________________________________________________________________-->
    <title>版本和平台兼容性</title>

    <sect2 id="runtime-config-compatible-version">
<!--==========================orignal english content==========================
     <title>Previous PostgreSQL Versions</title>
____________________________________________________________________________-->
     <title>以前的 PostgreSQL 版本</title>

     <variablelist>

     <varlistentry id="guc-array-nulls" xreflabel="array_nulls">
<!--==========================orignal english content==========================
      <term><varname>array_nulls</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>array_nulls</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>array_nulls</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>array_nulls</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        This controls whether the array input parser recognizes
        unquoted <literal>NULL</literal> as specifying a null array element.
        By default, this is <literal>on</literal>, allowing array values containing
        null values to be entered.  However, <productname>PostgreSQL</productname> versions
        before 8.2 did not support null values in arrays, and therefore would
        treat <literal>NULL</literal> as specifying a normal array element with
        the string value <quote>NULL</quote>.  For backward compatibility with
        applications that require the old behavior, this variable can be
        turned <literal>off</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数控制数组输入解析器是否把未用引号的<literal>NULL</literal>识别为一个空数组元素。默认为<literal>on</literal>，允许输入包含空值的数组值。但是<productname>PostgreSQL</productname> 8.2 之前的版本不支持数组中的空值，并且因此将把<literal>NULL</literal>当作指定一个值为字符串<quote>NULL</quote>的正常数组元素。对于那些要求旧行为的应用的向后兼容性，这个变量可以被设置为<literal>off</literal>。
       </para>

<!--==========================orignal english content==========================
       <para>
        Note that it is possible to create array values containing null values
        even when this variable is <literal>off</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        注意即使这个变量为<literal>off</literal>也能够创建包含空值的数组值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-backslash-quote" xreflabel="backslash_quote">
<!--==========================orignal english content==========================
      <term><varname>backslash_quote</varname> (<type>enum</type>)
      <indexterm><primary>strings</primary><secondary>backslash quotes</secondary></indexterm>
      <indexterm>
       <primary><varname>backslash_quote</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>backslash_quote</varname> (<type>enum</type>)
      <indexterm><primary>strings</primary><secondary>backslash quotes</secondary></indexterm>
      <indexterm>
       <primary><varname>backslash_quote</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        This controls whether a quote mark can be represented by
        <literal>\'</literal> in a string literal.  The preferred, SQL-standard way
        to represent a quote mark is by doubling it (<literal>''</literal>) but
        <productname>PostgreSQL</productname> has historically also accepted
        <literal>\'</literal>. However, use of <literal>\'</literal> creates security risks
        because in some client character set encodings, there are multibyte
        characters in which the last byte is numerically equivalent to ASCII
        <literal>\</literal>.  If client-side code does escaping incorrectly then an
        SQL-injection attack is possible.  This risk can be prevented by
        making the server reject queries in which a quote mark appears to be
        escaped by a backslash.
        The allowed values of <varname>backslash_quote</varname> are
        <literal>on</literal> (allow <literal>\'</literal> always),
        <literal>off</literal> (reject always), and
        <literal>safe_encoding</literal> (allow only if client encoding does not
        allow ASCII <literal>\</literal> within a multibyte character).
        <literal>safe_encoding</literal> is the default setting.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数控制字符串文本中的单引号是否能够用<literal>\'</literal>来表示。首选的 SQL 标准的方法是将其双写（<literal>''</literal>），但是<productname>PostgreSQL</productname>在历史上也接受<literal>\'</literal>。不过使用<literal>\'</literal>容易导致安全风险，因为在某些客户端字符集编码中，有多字节字符的最后一个字节在数值上等价于 ASCII 的<literal>\'</literal>。如果客户端代码没有做到正确转义，那么将会导致 SQL 注入攻击。如果服务器拒绝看起来带有被反斜线转义的单引号的查询，那么就可以避免这种风险。<varname>backslash_quote</varname>的可用值是<literal>on</literal>（总是允许<literal>\'</literal>）、<literal>off</literal>（总是拒绝）以及<literal>safe_encoding</literal>（只有客户端编码不允许在多字节字符中存在 ASCII <literal>\</literal>时允许）。<literal>safe_encoding</literal>是默认设置。
       </para>

<!--==========================orignal english content==========================
       <para>
        Note that in a standard-conforming string literal, <literal>\</literal> just
        means <literal>\</literal> anyway.  This parameter only affects the handling of
        non-standard-conforming literals, including
        escape string syntax (<literal>E'...'</literal>).
       </para>
____________________________________________________________________________-->
       <para>
        注意在符合标准的字符串文本中，<literal>\</literal>就表示<literal>\</literal>。这个参数只影响不符合标准的文本的处理，包括转义字符串语法（<literal>E'...'</literal>）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-escape-string-warning" xreflabel="escape_string_warning">
<!--==========================orignal english content==========================
      <term><varname>escape_string_warning</varname> (<type>boolean</type>)
      <indexterm><primary>strings</primary><secondary>escape warning</secondary></indexterm>
      <indexterm>
       <primary><varname>escape_string_warning</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>escape_string_warning</varname> (<type>boolean</type>)
      <indexterm><primary>strings</primary><secondary>escape warning</secondary></indexterm>
      <indexterm>
       <primary><varname>escape_string_warning</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        When on, a warning is issued if a backslash (<literal>\</literal>)
        appears in an ordinary string literal (<literal>'...'</literal>
        syntax) and <varname>standard_conforming_strings</varname> is off.
        The default is <literal>on</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        打开时，如果在普通字符串文本中（<literal>'...'</literal>语法）出现了 一个反斜线（<literal>\</literal>）并且<varname>standard_conforming_strings</varname>为关闭，那么就会发出一个警告。默认值是<literal>on</literal>。
       </para>

<!--==========================orignal english content==========================
       <para>
        Applications that wish to use backslash as escape should be
        modified to use escape string syntax (<literal>E'...'</literal>),
        because the default behavior of ordinary strings is now to treat
        backslash as an ordinary character, per SQL standard.  This variable
        can be enabled to help locate code that needs to be changed.
       </para>
____________________________________________________________________________-->
       <para>
        希望使用反斜线作为转义符的应用应该被修改来使用转义字符串语法（<literal>E'...'</literal>），因为在 SQL 标准中普通字符串的默认行为是将反斜线视作一个普通字符。这个变量可以被启用来帮助定位需要被更改的代码。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-lo-compat-privileges" xreflabel="lo_compat_privileges">
<!--==========================orignal english content==========================
      <term><varname>lo_compat_privileges</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>lo_compat_privileges</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>lo_compat_privileges</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>lo_compat_privileges</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        In <productname>PostgreSQL</productname> releases prior to 9.0, large objects
        did not have access privileges and were, therefore, always readable
        and writable by all users.  Setting this variable to <literal>on</literal>
        disables the new privilege checks, for compatibility with prior
        releases.  The default is <literal>off</literal>.
        Only superusers can change this setting.
       </para>
____________________________________________________________________________-->
       <para>
        在<productname>PostgreSQL</productname> 9.0 之前，大对象不具有访问特权并且因此总是所有用户可读可写的。为了和以前的版本兼容，把这个变量设置为<literal>on</literal>可以禁用这种新的特权检查。默认是<literal>off</literal>。只有超级用户可以更改这个设置。
       </para>

<!--==========================orignal english content==========================
       <para>
        Setting this variable does not disable all security checks related to
        large objects &mdash; only those for which the default behavior has
        changed in <productname>PostgreSQL</productname> 9.0.
       </para>
____________________________________________________________________________-->
       <para>
        设置这个参数不会禁用所有与大对象相关的安全检查 &mdash; 除了那些在<productname>PostgreSQL</productname> 9.0中已经修改了的默认行为。
       </para>
      </listitem>
     </varlistentry>

    <varlistentry id="guc-quote-all-identifiers" xreflabel="quote-all-identifiers">
<!--==========================orignal english content==========================
      <term><varname>quote_all_identifiers</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>quote_all_identifiers</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>quote_all_identifiers</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>quote_all_identifiers</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        When the database generates SQL, force all identifiers to be quoted,
        even if they are not (currently) keywords.  This will affect the
        output of <command>EXPLAIN</command> as well as the results of functions
        like <function>pg_get_viewdef</function>.  See also the
        <option>-&minus;quote-all-identifiers</option> option of
        <xref linkend="app-pgdump"/> and <xref linkend="app-pg-dumpall"/>.
       </para>
____________________________________________________________________________-->
       <para>
        当数据库产生 SQL 时，强制所有标识符被引号包围，即使它们（当前）不是关键字。这将影响<command>EXPLAIN</command>的输出以及<function>pg_get_viewdef</function>等函数的结果。另请参阅<xref linkend="app-pgdump"/>和<xref linkend="app-pg-dumpall"/>的<option>--quote-all-identifiers</option>选项。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-standard-conforming-strings" xreflabel="standard_conforming_strings">
<!--==========================orignal english content==========================
      <term><varname>standard_conforming_strings</varname> (<type>boolean</type>)
      <indexterm><primary>strings</primary><secondary>standard conforming</secondary></indexterm>
      <indexterm>
       <primary><varname>standard_conforming_strings</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>standard_conforming_strings</varname> (<type>boolean</type>)
      <indexterm><primary>strings</primary><secondary>standard conforming</secondary></indexterm>
      <indexterm>
       <primary><varname>standard_conforming_strings</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        This controls whether ordinary string literals
        (<literal>'...'</literal>) treat backslashes literally, as specified in
        the SQL standard.
        Beginning in <productname>PostgreSQL</productname> 9.1, the default is
        <literal>on</literal> (prior releases defaulted to <literal>off</literal>).
        Applications can check this
        parameter to determine how string literals will be processed.
        The presence of this parameter can also be taken as an indication
        that the escape string syntax (<literal>E'...'</literal>) is supported.
        Escape string syntax (<xref linkend="sql-syntax-strings-escape"/>)
        should be used if an application desires
        backslashes to be treated as escape characters.
       </para>
____________________________________________________________________________-->
       <para>
        控制普通字符串文本（<literal>'...'</literal>）是否按照 SQL 标准把反斜线当普通文本。从<productname>PostgreSQL</productname> 9.1 开始，默认值为<literal>on</literal>（之前的发行中默认值为<literal>off</literal>）。应用可以检查这个参数来判断字符串文本如何被处理。这个参数的存在也可以被当做转义字符串语法（<literal>E'...'</literal>）被支持的标志。如果一个应用希望反斜线被当做转义字符，应该使用转义字符串语法（<xref linkend="sql-syntax-strings-escape"/>）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-synchronize-seqscans" xreflabel="synchronize_seqscans">
<!--==========================orignal english content==========================
      <term><varname>synchronize_seqscans</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>synchronize_seqscans</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>synchronize_seqscans</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>synchronize_seqscans</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        This allows sequential scans of large tables to synchronize with each
        other, so that concurrent scans read the same block at about the
        same time and hence share the I/O workload.  When this is enabled,
        a scan might start in the middle of the table and then <quote>wrap
        around</quote> the end to cover all rows, so as to synchronize with the
        activity of scans already in progress.  This can result in
        unpredictable changes in the row ordering returned by queries that
        have no <literal>ORDER BY</literal> clause.  Setting this parameter to
        <literal>off</literal> ensures the pre-8.3 behavior in which a sequential
        scan always starts from the beginning of the table.  The default
        is <literal>on</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        它允许对大型表的顺序扫描与其他扫描同步，因此并发扫描可以在几乎相同的时刻读取相同的块，这样可以分担 I/O 负载。当启用这个参数时，一个扫描可能会从表的中间开始并且之后<quote>绕回</quote>到开头以覆盖所有的行，这样可以与已在进行中的扫描活动同步。对于没有<literal>ORDER BY</literal>子句的查询来，这样的扫描会在返回行的顺序中造成不可预料的改变。将这个参数设置为<literal>off</literal>以保证 8.3 之前的行为（顺序扫描总是从表的起始处开始）。默认值是<literal>on</literal>。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect2>

    <sect2 id="runtime-config-compatible-clients">
<!--==========================orignal english content==========================
     <title>Platform and Client Compatibility</title>
____________________________________________________________________________-->
     <title>平台和客户端兼容性</title>
     <variablelist>

     <varlistentry id="guc-transform-null-equals" xreflabel="transform_null_equals">
<!--==========================orignal english content==========================
      <term><varname>transform_null_equals</varname> (<type>boolean</type>)
      <indexterm><primary>IS NULL</primary></indexterm>
      <indexterm>
       <primary><varname>transform_null_equals</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>transform_null_equals</varname> (<type>boolean</type>)
      <indexterm><primary>IS NULL</primary></indexterm>
      <indexterm>
       <primary><varname>transform_null_equals</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        When on, expressions of the form <literal><replaceable>expr</replaceable> =
        NULL</literal> (or <literal>NULL =
        <replaceable>expr</replaceable></literal>) are treated as
        <literal><replaceable>expr</replaceable> IS NULL</literal>, that is, they
        return true if <replaceable>expr</replaceable> evaluates to the null value,
        and false otherwise. The correct SQL-spec-compliant behavior of
        <literal><replaceable>expr</replaceable> = NULL</literal> is to always
        return null (unknown). Therefore this parameter defaults to
        <literal>off</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        当打开时，形为<literal><replaceable>expr</replaceable> = NULL</literal>（或<literal>NULL =  <replaceable>expr</replaceable></literal>）的表达式将被当做<literal><replaceable>expr</replaceable> IS NULL</literal>， 也就是说，如果<replaceable>expr</replaceable>得出空值值则返回真，否则返回假。正确的 SQL 标准兼容的<literal><replaceable>expr</replaceable> = NULL</literal>行为总是返回空（未知）。因此这个参数默认为<literal>off</literal>。
       </para>

<!--==========================orignal english content==========================
       <para>
        However, filtered forms in <productname>Microsoft
        Access</productname> generate queries that appear to use
        <literal><replaceable>expr</replaceable> = NULL</literal> to test for
        null values, so if you use that interface to access the database you
        might want to turn this option on.  Since expressions of the
        form <literal><replaceable>expr</replaceable> = NULL</literal> always
        return the null value (using the SQL standard interpretation), they are not
        very useful and do not appear often in normal applications so
        this option does little harm in practice.  But new users are
        frequently confused about the semantics of expressions
        involving null values, so this option is off by default.
       </para>
____________________________________________________________________________-->
       <para>
        不过，在<productname>Microsoft Access</productname>里的过滤表单生成的查询似乎使用<literal><replaceable>expr</replaceable> = NULL</literal>来测试空值，因此，如果你使用这个接口访问数据库，你可能想把这个选项打开。因为<literal><replaceable>expr</replaceable> = NULL</literal>形式的表达式总是返回空值（使用 SQL 标准解释）。它们不是非常有用并且在普通应用中也不常见，在应用中也不常见，因此这个选项实际上没有什么危害。但是新用户常常对涉及 空值的表达式的语义上感到困惑，因此这个选项默认为关闭。
       </para>

<!--==========================orignal english content==========================
       <para>
        Note that this option only affects the exact form <literal>= NULL</literal>,
        not other comparison operators or other expressions
        that are computationally equivalent to some expression
        involving the equals operator (such as <literal>IN</literal>).
        Thus, this option is not a general fix for bad programming.
       </para>
____________________________________________________________________________-->
       <para>
        请注意这个选项只影响<literal>= NULL</literal>形式，而不影响其它比较操作符或者其它与一些涉及等值操作符的表达式在计算上等效的其他表达式（例如<literal>IN</literal>）。因此，这个选项不是劣质程序的一般修复。
       </para>

<!--==========================orignal english content==========================
       <para>
        Refer to <xref linkend="functions-comparison"/> for related information.
       </para>
____________________________________________________________________________-->
       <para>
        相关信息请见<xref linkend="functions-comparison"/>。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect2>
   </sect1>

   <sect1 id="runtime-config-error-handling">
<!--==========================orignal english content==========================
    <title>Error Handling</title>
____________________________________________________________________________-->
    <title>错误处理</title>

    <variablelist>

     <varlistentry id="guc-exit-on-error" xreflabel="exit_on_error">
<!--==========================orignal english content==========================
      <term><varname>exit_on_error</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>exit_on_error</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>exit_on_error</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>exit_on_error</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        If on, any error will terminate the current session.  By default,
        this is set to off, so that only FATAL errors will terminate the
        session.
       </para>
____________________________________________________________________________-->
       <para>
        如果为开(on)，任何错误将中止当前会话。默认情况下，这个值被设置为关(off)，这样只有 FATAL 错误（致命）将中止会话。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-restart-after-crash" xreflabel="restart_after_crash">
<!--==========================orignal english content==========================
      <term><varname>restart_after_crash</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>restart_after_crash</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>restart_after_crash</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>restart_after_crash</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        When set to on, which is the default, <productname>PostgreSQL</productname>
        will automatically reinitialize after a backend crash.  Leaving this
        value set to on is normally the best way to maximize the availability
        of the database.  However, in some circumstances, such as when
        <productname>PostgreSQL</productname> is being invoked by clusterware, it may be
        useful to disable the restart so that the clusterware can gain
        control and take any actions it deems appropriate.
       </para>
____________________________________________________________________________-->
       <para>
        当被设置为开(on)，<productname>PostgreSQL</productname>将在一次后端崩溃后自动重新初始化。
        让这个值设置为开(on)通常是将数据库可用性最大化的最佳方法。但是在某些环境中，例如<productname>PostgreSQL</productname>被集群软件调用时，禁用重启可能很有用，这样集群软件可以得到控制并且采取它认为适当的行动。
       </para>

<!--==========================orignal english content==========================
       <para>
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数只能在<filename>postgresql.conf</filename>文件中或服务器命令行中设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-data-sync-retry" xreflabel="data_sync_retry">
<!--==========================orignal english content==========================
      <term><varname>data_sync_retry</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>data_sync_retry</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>data_sync_retry</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>data_sync_retry</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        When set to off, which is the default, <productname>PostgreSQL</productname>
        will raise a PANIC-level error on failure to flush modified data files
        to the file system.  This causes the database server to crash.  This
        parameter can only be set at server start.
       </para>
____________________________________________________________________________-->
       <para>
        如果设置为关（off），<productname>PostgreSQL</productname>在将修改的数据文件刷新到文件系统失败时，将引发PANIC级错误。
        这样会导致数据库服务器崩溃。这个参数只能在服务器启动时被设置。
       </para>

<!--==========================orignal english content==========================
       <para>
        On some operating systems, the status of data in the kernel's page
        cache is unknown after a write-back failure.  In some cases it might
        have been entirely forgotten, making it unsafe to retry; the second
        attempt may be reported as successful, when in fact the data has been
        lost.  In these circumstances, the only way to avoid data loss is to
        recover from the WAL after any failure is reported, preferably
        after investigating the root cause of the failure and replacing any
        faulty hardware.
       </para>
____________________________________________________________________________-->
       <para>
        在某些操作系统上，回写失败后，内核页面缓存中的数据状态未知。 在某些情况下，它可能已被完全遗忘，因此重试不安全；第二次尝试可能报告为成功，而事实上数据已丢失。在此类情形下，避免数据丢失的唯一方法是在报告任何故障后从WAL中恢复，最好是在调查了故障的根本原因并更换了任何有故障的硬件之后。
       </para>

<!--==========================orignal english content==========================
       <para>
        If set to on, <productname>PostgreSQL</productname> will instead
        report an error but continue to run so that the data flushing
        operation can be retried in a later checkpoint.  Only set it to on
        after investigating the operating system's treatment of buffered data
        in case of write-back failure.
       </para>
____________________________________________________________________________-->
       <para>
        如果设置为开(on)，<productname>PostgreSQL</productname>将报告错误，但会继续运行，以便可以在以后的检查点中重试数据刷新操作。
        仅在调查操作系统假如回写失败时对缓冲数据的处理方式的情况下，才将其设置为开(on)。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-recovery-init-sync-method" xreflabel="recovery_init_sync_method">
<!--==========================orignal english content==========================
      <term><varname>recovery_init_sync_method</varname> (<type>enum</type>)
       <indexterm>
        <primary><varname>recovery_init_sync_method</varname> configuration parameter</primary>
       </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>recovery_init_sync_method</varname> (<type>enum</type>)
       <indexterm>
        <primary><varname>recovery_init_sync_method</varname> 配置参数</primary>
       </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        When set to <literal>fsync</literal>, which is the default,
        <productname>PostgreSQL</productname> will recursively open and
        synchronize all files in the data directory before crash recovery
        begins.  The search for files will follow symbolic links for the WAL
        directory and each configured tablespace (but not any other symbolic
        links).  This is intended to make sure that all WAL and data files are
        durably stored on disk before replaying changes.  This applies whenever
        starting a database cluster that did not shut down cleanly, including
        copies created with <application>pg_basebackup</application>.
       </para>
____________________________________________________________________________-->
       <para>
        当设置为<literal>fsync</literal>，也就是默认值，<productname>PostgreSQL</productname>将在崩溃恢复开始之前递归地打开并同步数据目录中的所有文件。
        对文件的搜索将遵循WAL目录和每个配置表空间的符号链接(而不是任何其它符号链接)。
        这是为了确保在重现更改之前，所有WAL和数据文件都持久地存储在硬盘上。
        这适用于在启动没有完全关闭的数据库集群时，包括由<application>pg_basebackup</application>创建的副本。
       </para>
<!--==========================orignal english content==========================
       <para>
        On Linux, <literal>syncfs</literal> may be used instead, to ask the
        operating system to synchronize the whole file systems that contain the
        data directory, the WAL files and each tablespace (but not any other
        file systems that may be reachable through symbolic links).  This may
        be a lot faster than the <literal>fsync</literal> setting, because it
        doesn't need to open each file one by one.  On the other hand, it may
        be slower if a file system is shared by other applications that
        modify a lot of files, since those files will also be written to disk.
        Furthermore, on versions of Linux before 5.8, I/O errors encountered
        while writing data to disk may not be reported to
        <productname>PostgreSQL</productname>, and relevant error messages may
        appear only in kernel logs.
       </para>
____________________________________________________________________________-->
       <para>
        在Linux上，可以用<literal>syncfs</literal>代替，请求操作系统来同步包含数据目录的整个文件系统，WAL文件和每个表空间(但不是通过符号链接可访问到的任何其他文件系统)。
        这可能比<literal>fsync</literal>设置快得多，因为它不需要逐个打开每个文件。
        另一方面，如果一个文件系统是被其他需要修改大量文件的应用程序共享的，它可能会慢一些，因为这些文件也将写入硬盘。
        此外，在5.8之前的Linux版本中，向磁盘写入数据时遇到的I/O错误可能不会报告给<productname>PostgreSQL</productname>，相关的错误消息可能只出现在内核日志中。
       </para>
<!--==========================orignal english content==========================
       <para>
        This parameter can only be set in the
        <filename>postgresql.conf</filename> file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数只能在<filename>postgresql.conf</filename>文件中或者服务器命令行中设置。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>

   </sect1>

   <sect1 id="runtime-config-preset">
<!--==========================orignal english content==========================
    <title>Preset Options</title>
____________________________________________________________________________-->
    <title>预置选项</title>
<!--==========================orignal english content==========================
    <para>
     The following <quote>parameters</quote> are read-only.
     As such, they have been excluded from the sample
     <filename>postgresql.conf</filename> file.  These options report
     various aspects of <productname>PostgreSQL</productname> behavior
     that might be of interest to certain applications, particularly
     administrative front-ends.
     Most of them are determined when <productname>PostgreSQL</productname>
     is compiled or when it is installed.
    </para>
____________________________________________________________________________-->
    <para>
     下列<quote>参数</quote>是只读的。
     同样，它们被排除在<filename>postgresql.conf</filename>文件例子之外。
     这些选项报告特定应用可能感兴趣的多种<productname>PostgreSQL</productname>行为，特别是管理前端相关的行为。
     所有这些都是在<productname>PostgreSQL</productname>被编译或者它被安装时决定的。
    </para>

    <variablelist>

     <varlistentry id="guc-block-size" xreflabel="block_size">
<!--==========================orignal english content==========================
      <term><varname>block_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>block_size</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>block_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>block_size</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Reports the size of a disk block.  It is determined by the value
        of <literal>BLCKSZ</literal> when building the server. The default
        value is 8192 bytes.  The meaning of some configuration
        variables (such as <xref linkend="guc-shared-buffers"/>) is
        influenced by <varname>block_size</varname>. See <xref
        linkend="runtime-config-resource"/> for information.
       </para>
____________________________________________________________________________-->
       <para>
        报告一个磁盘块的大小。它由编译服务器时<literal>BLCKSZ</literal>的值确定。默认值是 8192 字节。有些配置变量的含义（例如<xref linkend="guc-shared-buffers"/>）会被<varname>block_size</varname>影响。详见<xref linkend="runtime-config-resource"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-data-checksums" xreflabel="data_checksums">
<!--==========================orignal english content==========================
      <term><varname>data_checksums</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>data_checksums</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>data_checksums</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>data_checksums</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Reports whether data checksums are enabled for this cluster.
        See <xref linkend="app-initdb-data-checksums"/> for more information.
       </para>
____________________________________________________________________________-->
       <para>
        报告对这个集簇是否启用了数据校验码。详见<xref linkend="app-initdb-data-checksums"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-data-directory-mode" xreflabel="data_directory_mode">
<!--==========================orignal english content==========================
      <term><varname>data_directory_mode</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>data_directory_mode</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>data_directory_mode</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>data_directory_mode</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        On Unix systems this parameter reports the permissions the data
        directory (defined by <xref linkend="guc-data-directory"/>)
        had at server startup.
        (On Microsoft Windows this parameter will always display
        <literal>0700</literal>.) See
        <xref linkend="app-initdb-allow-group-access"/> for more information.
       </para>
____________________________________________________________________________-->
       <para>
        在Unix系统上，这个参数报告启动时的数据目录(由<xref linkend="guc-data-directory"/>定义)的权限。
        （在Microsoft Windows上这个参数将总是显示<literal>0700</literal>。）
        更多信息请参考<xref linkend="app-initdb-allow-group-access"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-debug-assertions" xreflabel="debug_assertions">
<!--==========================orignal english content==========================
      <term><varname>debug_assertions</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>debug_assertions</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>debug_assertions</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>debug_assertions</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Reports whether <productname>PostgreSQL</productname> has been built
        with assertions enabled. That is the case if the
        macro <symbol>USE_ASSERT_CHECKING</symbol> is defined
        when <productname>PostgreSQL</productname> is built (accomplished
        e.g., by the <command>configure</command> option
        <option>-&minus;enable-cassert</option>). By
        default <productname>PostgreSQL</productname> is built without
        assertions.
       </para>
____________________________________________________________________________-->
       <para>
        报告编译<productname>PostgreSQL</productname>时是否启用了断言。
        如果<productname>PostgreSQL</productname>被编译时定义了宏
        <symbol>USE_ASSERT_CHECKING</symbol> is defined
        when <productname>PostgreSQL</productname>（例如通过
        <command>configure</command>选项
        <option>--enable-cassert</option>定义），那么会报告已启用。默认情况下
        <productname>PostgreSQL</productname>编译时没有用断言。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-integer-datetimes" xreflabel="integer_datetimes">
<!--==========================orignal english content==========================
      <term><varname>integer_datetimes</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>integer_datetimes</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>integer_datetimes</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>integer_datetimes</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Reports whether <productname>PostgreSQL</productname> was built with support for
        64-bit-integer dates and times.  As of <productname>PostgreSQL</productname> 10,
        this is always <literal>on</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        报告<productname>PostgreSQL</productname>是否在编译时打开了 64 位整数日期和时间。从<productname>PostgreSQL</productname> 10起，这个值总是<literal>on</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-in-hot-standby" xreflabel="in_hot_standby">
<!--==========================orignal english content==========================
      <term><varname>in_hot_standby</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>in_hot_standby</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>in_hot_standby</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>in_hot_standby</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Reports whether the server is currently in hot standby mode.  When
        this is <literal>on</literal>, all transactions are forced to be
        read-only.  Within a session, this can change only if the server is
        promoted to be primary.  See <xref linkend="hot-standby"/> for more
        information.
       </para>
____________________________________________________________________________-->
       <para>
        报告服务器当前是否处于热备模式。
        当这个是<literal>on</literal>的时候，所有的事务强制为只读。
        在会话中，这个只能在服务器提升为主服务器的时候变更。
        更多信息参见<xref linkend="hot-standby"/>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-lc-collate" xreflabel="lc_collate">
<!--==========================orignal english content==========================
      <term><varname>lc_collate</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>lc_collate</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>lc_collate</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>lc_collate</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Reports the locale in which sorting of textual data is done.
        See <xref linkend="locale"/> for more information.
        This value is determined when a database is created.
       </para>
____________________________________________________________________________-->
       <para>
        报告文本数据排序使用的区域。详见<xref linkend="locale"/>。该值是在数据库被创建时确定的。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-lc-ctype" xreflabel="lc_ctype">
<!--==========================orignal english content==========================
      <term><varname>lc_ctype</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>lc_ctype</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>lc_ctype</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>lc_ctype</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Reports the locale that determines character classifications.
        See <xref linkend="locale"/> for more information.
        This value is determined when a database is created.
        Ordinarily this will be the same as <varname>lc_collate</varname>,
        but for special applications it might be set differently.
       </para>
____________________________________________________________________________-->
       <para>
        报告决定字符分类的区域。详见<xref linkend="locale"/>。该值是在数据库被创建时决定的。通常它和<varname>lc_collate</varname>一样，但是可以为特殊应用设置成不同的值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-function-args" xreflabel="max_function_args">
<!--==========================orignal english content==========================
      <term><varname>max_function_args</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_function_args</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>max_function_args</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_function_args</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Reports the maximum number of function arguments. It is determined by
        the value of <literal>FUNC_MAX_ARGS</literal> when building the server. The
        default value is 100 arguments.
       </para>
____________________________________________________________________________-->
       <para>
        报告函数参数的最大数量。它由编译服务器时的<literal>FUNC_MAX_ARGS</literal>值决定的。默认值是 100 个参数。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-identifier-length" xreflabel="max_identifier_length">
<!--==========================orignal english content==========================
      <term><varname>max_identifier_length</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_identifier_length</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>max_identifier_length</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_identifier_length</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Reports the maximum identifier length. It is determined as one
        less than the value of <literal>NAMEDATALEN</literal> when building
        the server. The default value of <literal>NAMEDATALEN</literal> is
        64; therefore the default
        <varname>max_identifier_length</varname> is 63 bytes, which
        can be less than 63 characters when using multibyte encodings.
       </para>
____________________________________________________________________________-->
       <para>
        报告标识符的最大长度。它由编译服务器时的<literal>NAMEDATALEN</literal>值减一决定。<literal>NAMEDATALEN</literal>的默认值是 64 ；因此<varname>max_identifier_length</varname>的默认值是 63，但是在使用多字节编码时可以少于 63 个字符。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-index-keys" xreflabel="max_index_keys">
<!--==========================orignal english content==========================
      <term><varname>max_index_keys</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_index_keys</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>max_index_keys</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_index_keys</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Reports the maximum number of index keys. It is determined by
        the value of <literal>INDEX_MAX_KEYS</literal> when building the server. The
        default value is 32 keys.
       </para>
____________________________________________________________________________-->
       <para>
        报告索引键的最大数目。它由编译服务器时的<literal>INDEX_MAX_KEYS</literal>值决定。默认值是 32 个键。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-segment-size" xreflabel="segment_size">
<!--==========================orignal english content==========================
      <term><varname>segment_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>segment_size</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>segment_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>segment_size</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Reports the number of blocks (pages) that can be stored within a file
        segment.  It is determined by the value of <literal>RELSEG_SIZE</literal>
        when building the server.  The maximum size of a segment file in bytes
        is equal to <varname>segment_size</varname> multiplied by
        <varname>block_size</varname>; by default this is 1GB.
       </para>
____________________________________________________________________________-->
       <para>
        报告一个文件段中可以存储的块（页）的数量。由编译服务器时的<literal>RELSEG_SIZE</literal>值决定。一个段文件的最大尺寸（以字节计）等于<varname>segment_size</varname>乘以<varname>block_size</varname>，默认是 1GB。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-server-encoding" xreflabel="server_encoding">
<!--==========================orignal english content==========================
      <term><varname>server_encoding</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>server_encoding</varname> configuration parameter</primary>
      </indexterm>
      <indexterm><primary>character set</primary></indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>server_encoding</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>server_encoding</varname>配置参数</primary>
      </indexterm>
      <indexterm><primary>character set</primary></indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Reports the database encoding (character set).
        It is determined when the database is created.  Ordinarily,
        clients need only be concerned with the value of <xref
        linkend="guc-client-encoding"/>.
       </para>
____________________________________________________________________________-->
       <para>
        报告数据库的编码（字符集）。这是在数据库被创建时决定的。通常，客户端只需要关心<xref linkend="guc-client-encoding"/>的值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-server-version" xreflabel="server_version">
<!--==========================orignal english content==========================
      <term><varname>server_version</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>server_version</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>server_version</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>server_version</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Reports the version number of the server. It is determined by the
        value of <literal>PG_VERSION</literal> when building the server.
       </para>
____________________________________________________________________________-->
       <para>
        报告服务器版本数值。它是由编译服务器时的<literal>PG_VERSION</literal>值决定的。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-server-version-num" xreflabel="server_version_num">
<!--==========================orignal english content==========================
      <term><varname>server_version_num</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>server_version_num</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>server_version_num</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>server_version_num</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Reports the version number of the server as an integer. It is determined
        by the value of <literal>PG_VERSION_NUM</literal> when building the server.
       </para>
____________________________________________________________________________-->
       <para>
        报告服务器版本数值的整数值。它是由编译服务器时的<literal>PG_VERSION_NUM</literal>值决定的。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ssl-library" xreflabel="ssl_library">
<!--==========================orignal english content==========================
      <term><varname>ssl_library</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>ssl_library</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>ssl_library</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>ssl_library</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Reports the name of the SSL library that this
        <productname>PostgreSQL</productname> server was built with (even if
        SSL is not currently configured or in use on this instance), for
        example <literal>OpenSSL</literal>, or an empty string if none.
       </para>
____________________________________________________________________________-->
       <para>
        报告此<productname>PostgreSQL</productname>服务器已构建的 SSL 库的名称（即使此实例当前未配置或使用 SSL），
        例如<literal>OpenSSL</literal>，或一个空字符串(如果没有)。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-block-size" xreflabel="wal_block_size">
<!--==========================orignal english content==========================
      <term><varname>wal_block_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>wal_block_size</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>wal_block_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>wal_block_size</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Reports the size of a WAL disk block.  It is determined by the value
        of <literal>XLOG_BLCKSZ</literal> when building the server. The default value
        is 8192 bytes.
       </para>
____________________________________________________________________________-->
       <para>
        报告一个 WAL 磁盘块的尺寸。由编译服务器时的<literal>XLOG_BLCKSZ</literal>值决定。默认是 8192 字节。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-segment-size" xreflabel="wal_segment_size">
<!--==========================orignal english content==========================
      <term><varname>wal_segment_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>wal_segment_size</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>wal_segment_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>wal_segment_size</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Reports the size of write ahead log segments.  The default value is
        16MB. See <xref linkend="wal-configuration"/> for more information.
       </para>
____________________________________________________________________________-->
       <para>
        报告 WAL 段文件的大小。默认是 16MB。详见<xref linkend="wal-configuration"/>。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </sect1>

   <sect1 id="runtime-config-custom">
<!--==========================orignal english content==========================
    <title>Customized Options</title>
____________________________________________________________________________-->
    <title>自定义选项</title>
<!--==========================orignal english content==========================
    <para>
     This feature was designed to allow parameters not normally known to
     <productname>PostgreSQL</productname> to be added by add-on modules
     (such as procedural languages).  This allows extension modules to be
     configured in the standard ways.
    </para>
____________________________________________________________________________-->
    <para>
     这个特性被设计用来由附加模块向<productname>PostgreSQL</productname>添加通常不为系统知道的参数（例如过程语言）。这允许使用标准方法配制扩展模块。
    </para>

<!--==========================orignal english content==========================
    <para>
     Custom options have two-part names: an extension name, then a dot, then
     the parameter name proper, much like qualified names in SQL.  An example
     is <literal>plpgsql.variable_conflict</literal>.
    </para>
____________________________________________________________________________-->
    <para>
     自定义选项有两部分名称：一个扩展名，然后是一个句点，再然后是正确的参数名，就像 SQL 中的合格名称。一个例子是<literal>plpgsql.variable_conflict</literal>。
    </para>

<!--==========================orignal english content==========================
    <para>
     Because custom options may need to be set in processes that have not
     loaded the relevant extension module, <productname>PostgreSQL</productname>
     will accept a setting for any two-part parameter name.  Such variables
     are treated as placeholders and have no function until the module that
     defines them is loaded. When an extension module is loaded, it will add
     its variable definitions, convert any placeholder values according to
     those definitions, and issue warnings for any unrecognized placeholders
     that begin with its extension name.
    </para>
____________________________________________________________________________-->
    <para>
     因为自定义选项可能需要在没有载入相关扩展模块的进程中设置，<productname>PostgreSQL</productname>将接收任意两部分参数名的设置。这种变量被认为是占位符并且在定义它们的模块被载入之前不会有实际功能。当一个扩展模块被载入，它将加入它的变量定义、根据那些定义转换任何占位符值并且对以其扩展名开始的任意未识别占位符发出警告。
    </para>
   </sect1>

   <sect1 id="runtime-config-developer">
<!--==========================orignal english content==========================
    <title>Developer Options</title>
____________________________________________________________________________-->
    <title>开发者选项</title>
<!--==========================orignal english content==========================
    <para>
     The following parameters are intended for developer testing, and
     should never be used on a production database.  However, some of
     them can be used to assist with the recovery of severely damaged
     databases.  As such, they have been excluded from the sample
     <filename>postgresql.conf</filename> file.  Note that many of these
     parameters require special source compilation flags to work at all.
    </para>
____________________________________________________________________________-->
    <para>
     下面的参数目的是用在开发测试上， 并且永远不能用于生产数据库。
     但是，它们中的一些能够用于帮助恢复严重损坏的数据库。
     同样，它们被从例子<filename>postgresql.conf</filename>文件中排除。
     请注意许多这些参数要求特殊的源代码编译标志才能工作。
    </para>

    <variablelist>
     <varlistentry id="guc-allow-system-table-mods" xreflabel="allow_system_table_mods">
<!--==========================orignal english content==========================
      <term><varname>allow_system_table_mods</varname> (<type>boolean</type>)
      <indexterm>
        <primary><varname>allow_system_table_mods</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>allow_system_table_mods</varname> (<type>boolean</type>)
      <indexterm>
        <primary><varname>allow_system_table_mods</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Allows modification of the structure of system tables as well as
        certain other risky actions on system tables.  This is otherwise not
        allowed even for superusers.  Ill-advised use of this setting can
        cause irretrievable data loss or seriously corrupt the database
        system.  Only superusers can change this setting.
       </para>
____________________________________________________________________________-->
       <para>
        允许对系统表结构的修改，以及对系统表的某些其他危险操作。这是不允许的，即使是对超级用户。
        不理智地使用此设置可能导致无法恢复的数据丢失或严重损坏数据库系统。只有超级用户才能更改此设置
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-backtrace-functions" xreflabel="backtrace_functions">
<!--==========================orignal english content==========================
      <term><varname>backtrace_functions</varname> (<type>string</type>)
      <indexterm>
        <primary><varname>backtrace_functions</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>backtrace_functions</varname> (<type>string</type>)
      <indexterm>
        <primary><varname>backtrace_functions</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        This parameter contains a comma-separated list of C function names.
        If an error is raised and the name of the internal C function where
        the error happens matches a value in the list, then a backtrace is
        written to the server log together with the error message.  This can
        be used to debug specific areas of the source code.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数包含一个以逗号分隔的C函数名称列表。
        如果出现错误，并且发生错误的内部C函数的名称与列表中的值相匹配，那么将向服务器日志中写入一个回溯跟踪信息和错误消息。
        这可以用来调试源代码的特定区域。
       </para>

<!--==========================orignal english content==========================
       <para>
        Backtrace support is not available on all platforms, and the quality
        of the backtraces depends on compilation options.
       </para>
____________________________________________________________________________-->
       <para>
        回溯支持并非在所有平台上都可以使用，并且回溯的质量取决于编译选项。
       </para>

<!--==========================orignal english content==========================
       <para>
        This parameter can only be set by superusers.
       </para>
____________________________________________________________________________-->
       <para>
        该参数只能由超级用户设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-debug-discard-caches" xreflabel="debug_discard_caches">
<!--==========================orignal english content==========================
      <term><varname>debug_discard_caches</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>debug_discard_caches</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>debug_discard_caches</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>debug_discard_caches</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        When set to <literal>1</literal>, each system catalog cache entry is
        invalidated at the first possible opportunity, whether or not
        anything that would render it invalid really occurred.  Caching of
        system catalogs is effectively disabled as a result, so the server
        will run extremely slowly.  Higher values run the cache invalidation
        recursively, which is even slower and only useful for testing
        the caching logic itself.  The default value of <literal>0</literal>
        selects normal catalog caching behavior.
       </para>
____________________________________________________________________________-->
       <para>
        当设置为<literal>1</literal>时，每个系统目录缓存条目在第一个可能的机会时失效，不管任何使之无效的事情是否真的发生。
        作为结果，系统目录的缓存被有效地禁用，因此服务器将运行得非常缓慢。
        较高的值递归地运行缓存失效，这样会更慢，而且只用于测试缓存逻辑自身。
        默认值<literal>0</literal>选择正常的目录缓存行为。
       </para>

<!--==========================orignal english content==========================
       <para>
        This parameter can be very helpful when trying to trigger
        hard-to-reproduce bugs involving concurrent catalog changes, but it
        is otherwise rarely needed.  See the source code files
        <filename>inval.c</filename> and
        <filename>pg_config_manual.h</filename> for details.
       </para>
____________________________________________________________________________-->
       <para>
        当试图触发涉及并发目录更改的难以复现的错误时，此参数非常有用，但除此之外它不太被需要。
        详请参见源码文件<filename>inval.c</filename> 和 <filename>pg_config_manual.h</filename>。
       </para>

<!--==========================orignal english content==========================
       <para>
        This parameter is supported when
        <symbol>DISCARD_CACHES_ENABLED</symbol> was defined at compile time
        (which happens automatically when using the
        <application>configure</application> option
        <option>-&minus;enable-cassert</option>).  In production builds, its value
        will always be <literal>0</literal> and attempts to set it to another
        value will raise an error.
       </para>
____________________________________________________________________________-->
       <para>
        当 <symbol>DISCARD_CACHES_ENABLED</symbol>在编译时定义时，可支持此参数(当使用<application>configure</application> option <option>--enable-cassert</option>时自动发生)。
        在生产建设中，它的值总是<literal>0</literal>，并且试图将它设置为另一个值将引发错误。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-force-parallel-mode" xreflabel="force_parallel_mode">
<!--==========================orignal english content==========================
      <term><varname>force_parallel_mode</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>force_parallel_mode</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>force_parallel_mode</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>force_parallel_mode</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Allows the use of parallel queries for testing purposes even in cases
        where no performance benefit is expected.
        The allowed values of <varname>force_parallel_mode</varname> are
        <literal>off</literal> (use parallel mode only when it is expected to improve
        performance), <literal>on</literal> (force parallel query for all queries
        for which it is thought to be safe), and <literal>regress</literal> (like
        <literal>on</literal>, but with additional behavior changes as explained
        below).
       </para>
____________________________________________________________________________-->
       <para>
        允许应用并行查询作为测试目的，即使在没有预期性能好处的情况下。
        <varname>force_parallel_mode</varname> 的允许值为<literal>off</literal>(仅在期望提高性能时使用并行模式)，
        <literal>on</literal>(对被认为是安全的所有查询强制并行查询)，
        以及<literal>regress</literal>   (类似<literal>on</literal>，但是有额外的行为变化在下面说明)。
       </para>

<!--==========================orignal english content==========================
       <para>
        More specifically, setting this value to <literal>on</literal> will add
        a <literal>Gather</literal> node to the top of any query plan for which this
        appears to be safe, so that the query runs inside of a parallel worker.
        Even when a parallel worker is not available or cannot be used,
        operations such as starting a subtransaction that would be prohibited
        in a parallel query context will be prohibited unless the planner
        believes that this will cause the query to fail.  If failures or
        unexpected results occur when this option is set, some functions used
        by the query may need to be marked <literal>PARALLEL UNSAFE</literal>
        (or, possibly, <literal>PARALLEL RESTRICTED</literal>).
       </para>
____________________________________________________________________________-->
       <para>
        更具体地说，将该值设置为<literal>on</literal>的将在看起来安全的任何查询计划的顶部添加一个<literal>Gather</literal> 节点，以便查询在并行worker内部运行。
        即使当并行worker不可用或不能使用时，例如启动子事务之类的操作将被禁止，在并行查询上下文中将被禁止，除非规划器认为这会导致查询失败。
        如果设置此选项时发生失败或意外结果，查询使用的一些函数可能需要被标记为<literal>PARALLEL UNSAFE</literal>(或者，可能是<literal>PARALLEL RESTRICTED</literal>)。
       </para>

<!--==========================orignal english content==========================
       <para>
        Setting this value to <literal>regress</literal> has all of the same effects
        as setting it to <literal>on</literal> plus some additional effects that are
        intended to facilitate automated regression testing.  Normally,
        messages from a parallel worker include a context line indicating that,
        but a setting of <literal>regress</literal> suppresses this line so that the
        output is the same as in non-parallel execution.  Also,
        the <literal>Gather</literal> nodes added to plans by this setting are hidden
        in <literal>EXPLAIN</literal> output so that the output matches what
        would be obtained if this setting were turned <literal>off</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        设置该值为<literal>regress</literal>与设置为<literal>on</literal> 具有相同的所有效果，加上一些附加效果，为了便于自动回归测试。
        通常，来自并行worker的消息包含一个上下文行表示之，
        但是<literal>regress</literal>的设置会抑制这一行，因此输出与非并行执行时相同。
        此外，通过此设置隐藏在<literal>EXPLAIN</literal>输出中，<literal>Gather</literal>节点添加到计划，以便输出匹配如果将此设置<literal>off</literal>将获得的结果。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ignore-system-indexes" xreflabel="ignore_system_indexes">
<!--==========================orignal english content==========================
      <term><varname>ignore_system_indexes</varname> (<type>boolean</type>)
      <indexterm>
        <primary><varname>ignore_system_indexes</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>ignore_system_indexes</varname> (<type>boolean</type>)
      <indexterm>
        <primary><varname>ignore_system_indexes</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Ignore system indexes when reading system tables (but still
        update the indexes when modifying the tables).  This is useful
        when recovering from damaged system indexes.
        This parameter cannot be changed after session start.
       </para>
____________________________________________________________________________-->
       <para>
        读取系统表时忽略系统索引（但是修改系统表时依然同时更新索引）。这在从被破坏的系统索引中恢复数据的时有用。这个参数在会话开始之后不能被更改。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-post-auth-delay" xreflabel="post_auth_delay">
<!--==========================orignal english content==========================
      <term><varname>post_auth_delay</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>post_auth_delay</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>post_auth_delay</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>post_auth_delay</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The amount of time to delay when a new
        server process is started, after it conducts the
        authentication procedure.  This is intended to give developers an
        opportunity to attach to the server process with a debugger.
        If this value is specified without units, it is taken as seconds.
        A value of zero (the default) disables the delay.
        This parameter cannot be changed after session start.
       </para>
____________________________________________________________________________-->
       <para>
        执行身份验证过程后启动新服务器进程时延迟的时间量。这是为了给开发者们一个机会在一个服务器进程上附加一个调试器。
        如果指定值时没有单位，则以秒为单位。0值(默认值)禁用延迟。这个参数在会话开始之后不能被更改。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-pre-auth-delay" xreflabel="pre_auth_delay">
<!--==========================orignal english content==========================
      <term><varname>pre_auth_delay</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>pre_auth_delay</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>pre_auth_delay</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>pre_auth_delay</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The amount of time to delay just after a
        new server process is forked, before it conducts the
        authentication procedure.  This is intended to give developers an
        opportunity to attach to the server process with a debugger to
        trace down misbehavior in authentication.
        If this value is specified without units, it is taken as seconds.
        A value of zero (the default) disables the delay.
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        在新服务器进程分叉后，在进行身份验证过程之前，延迟的时间量。这是为了给开发者们一个机会在一个服务器进程上附加一个调试器来跟踪认证过程中的不当行为。
        如果指定值时没有单位，则以秒为单位。0值(默认值)禁用延迟。这个参数只能在<filename>postgresql.conf</filename>文件中或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-trace-notify" xreflabel="trace_notify">
<!--==========================orignal english content==========================
      <term><varname>trace_notify</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>trace_notify</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>trace_notify</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>trace_notify</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Generates a great amount of debugging output for the
        <command>LISTEN</command> and <command>NOTIFY</command>
        commands.  <xref linkend="guc-client-min-messages"/> or
        <xref linkend="guc-log-min-messages"/> must be
        <literal>DEBUG1</literal> or lower to send this output to the
        client or server logs, respectively.
       </para>
____________________________________________________________________________-->
       <para>
        为<command>LISTEN</command>和<command>NOTIFY</command>命令生成大量调试输出。<xref linkend="guc-client-min-messages"/>和<xref linkend="guc-log-min-messages"/>必须是<literal>DEBUG1</literal>或者更低才能把这种输出分别发送到客户端或者服务器日志。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-trace-recovery-messages" xreflabel="trace_recovery_messages">
<!--==========================orignal english content==========================
      <term><varname>trace_recovery_messages</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>trace_recovery_messages</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>trace_recovery_messages</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>trace_recovery_messages</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Enables logging of recovery-related debugging output that otherwise
        would not be logged. This parameter allows the user to override the
        normal setting of <xref linkend="guc-log-min-messages"/>, but only for
        specific messages. This is intended for use in debugging Hot Standby.
        Valid values are <literal>DEBUG5</literal>, <literal>DEBUG4</literal>,
        <literal>DEBUG3</literal>, <literal>DEBUG2</literal>, <literal>DEBUG1</literal>, and
        <literal>LOG</literal>.  The default, <literal>LOG</literal>, does not affect
        logging decisions at all.  The other values cause recovery-related
        debug messages of that priority or higher to be logged as though they
        had <literal>LOG</literal> priority; for common settings of
        <varname>log_min_messages</varname> this results in unconditionally sending
        them to the server log.
        This parameter can only be set in the <filename>postgresql.conf</filename>
        file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        启用记录与恢复有关的调试输出，否则无法记录。这个参数允许用户覆盖<xref linkend="guc-log-min-messages"/>的正常设置，但只用于指定的消息。这个参数的目的是用来调试热后备。有效值包括<literal>DEBUG5</literal>、<literal>DEBUG4</literal>、<literal>DEBUG3</literal>、<literal>DEBUG2</literal>、<literal>DEBUG1</literal>和<literal>LOG</literal>。默认值<literal>LOG</literal>完全不会影响日志决定。其他值会记录相关级别或更高级别的与恢复相关的调试消息，就好像它们具有<literal>LOG</literal>优先级一样；对于<varname>log_min_messages</varname>的通用设置，这会无条件的将消息发送给服务器日志。这个参数只能在<filename>postgresql.conf</filename>文件中或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-trace-sort" xreflabel="trace_sort">
<!--==========================orignal english content==========================
      <term><varname>trace_sort</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>trace_sort</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>trace_sort</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>trace_sort</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        If on, emit information about resource usage during sort operations.
        This parameter is only available if the <symbol>TRACE_SORT</symbol> macro
        was defined when <productname>PostgreSQL</productname> was compiled.
        (However, <symbol>TRACE_SORT</symbol> is currently defined by default.)
       </para>
____________________________________________________________________________-->
       <para>
        如果打开，发出在排序操作中的资源使用的相关信息。只有在编译<productname>PostgreSQL</productname>时定义了<symbol>TRACE_SORT</symbol>宏， 这个参数才可用（不过，当前在默认情况下就定义了<symbol>TRACE_SORT</symbol>）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><varname>trace_locks</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>trace_locks</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>trace_locks</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>trace_locks</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        If on, emit information about lock usage.  Information dumped
        includes the type of lock operation, the type of lock and the unique
        identifier of the object being locked or unlocked.  Also included
        are bit masks for the lock types already granted on this object as
        well as for the lock types awaited on this object.  For each lock
        type a count of the number of granted locks and waiting locks is
        also dumped as well as the totals.  An example of the log file output
        is shown here:
<screen>
LOG:  LockAcquire: new: lock(0xb7acd844) id(24688,24696,0,0,0,1)
      grantMask(0) req(0,0,0,0,0,0,0)=0 grant(0,0,0,0,0,0,0)=0
      wait(0) type(AccessShareLock)
LOG:  GrantLock: lock(0xb7acd844) id(24688,24696,0,0,0,1)
      grantMask(2) req(1,0,0,0,0,0,0)=1 grant(1,0,0,0,0,0,0)=1
      wait(0) type(AccessShareLock)
LOG:  UnGrantLock: updated: lock(0xb7acd844) id(24688,24696,0,0,0,1)
      grantMask(0) req(0,0,0,0,0,0,0)=0 grant(0,0,0,0,0,0,0)=0
      wait(0) type(AccessShareLock)
LOG:  CleanUpLock: deleting: lock(0xb7acd844) id(24688,24696,0,0,0,1)
      grantMask(0) req(0,0,0,0,0,0,0)=0 grant(0,0,0,0,0,0,0)=0
      wait(0) type(INVALID)
</screen>
        Details of the structure being dumped may be found in
        <filename>src/include/storage/lock.h</filename>.
       </para>
____________________________________________________________________________-->
       <para>
        如果开启，发出锁使用情况的信息。被转储信息中包括锁操作的类型、锁的类型和 被锁或被解锁对象的唯一标识符。同样包括的还有已经授予这个对象的锁类型的位掩码和 等待这个对象的锁类型的位掩码。对每一种锁类型，已授权锁和等待锁的计数也会被一起转储。一个日志文件输出的例子如下：
<screen>
LOG:  LockAcquire: new: lock(0xb7acd844) id(24688,24696,0,0,0,1)
      grantMask(0) req(0,0,0,0,0,0,0)=0 grant(0,0,0,0,0,0,0)=0
      wait(0) type(AccessShareLock)
LOG:  GrantLock: lock(0xb7acd844) id(24688,24696,0,0,0,1)
      grantMask(2) req(1,0,0,0,0,0,0)=1 grant(1,0,0,0,0,0,0)=1
      wait(0) type(AccessShareLock)
LOG:  UnGrantLock: updated: lock(0xb7acd844) id(24688,24696,0,0,0,1)
      grantMask(0) req(0,0,0,0,0,0,0)=0 grant(0,0,0,0,0,0,0)=0
      wait(0) type(AccessShareLock)
LOG:  CleanUpLock: deleting: lock(0xb7acd844) id(24688,24696,0,0,0,1)
      grantMask(0) req(0,0,0,0,0,0,0)=0 grant(0,0,0,0,0,0,0)=0
      wait(0) type(INVALID)
</screen>
        被转储结构的详细信息可以在<filename>src/include/storage/lock.h</filename>中找到。
       </para>

<!--==========================orignal english content==========================
       <para>
        This parameter is only available if the <symbol>LOCK_DEBUG</symbol>
        macro was defined when <productname>PostgreSQL</productname> was
        compiled.
       </para>
____________________________________________________________________________-->
       <para>
        只有在编译<productname>PostgreSQL</productname>时定义了<symbol>LOCK_DEBUG</symbol>宏， 这个参数才可用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><varname>trace_lwlocks</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>trace_lwlocks</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>trace_lwlocks</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>trace_lwlocks</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        If on, emit information about lightweight lock usage.  Lightweight
        locks are intended primarily to provide mutual exclusion of access
        to shared-memory data structures.
       </para>
____________________________________________________________________________-->
       <para>
        如果开启，发出轻量级锁的使用信息。轻量级锁主要是为了提供对共享内存数据结构的互斥访问。
       </para>

<!--==========================orignal english content==========================
       <para>
        This parameter is only available if the <symbol>LOCK_DEBUG</symbol>
        macro was defined when <productname>PostgreSQL</productname> was
        compiled.
       </para>
____________________________________________________________________________-->
       <para>
        只有在编译<productname>PostgreSQL</productname>时定义了<symbol>LOCK_DEBUG</symbol>宏， 这个参数才可用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><varname>trace_userlocks</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>trace_userlocks</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>trace_userlocks</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>trace_userlocks</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        If on, emit information about user lock usage.  Output is the same
        as for <symbol>trace_locks</symbol>, only for advisory locks.
       </para>
____________________________________________________________________________-->
       <para>
        如果开启，发出关于用户锁使用的信息。与<symbol>trace_locks</symbol>的输出一样，但只用于咨询锁。
       </para>

<!--==========================orignal english content==========================
       <para>
        This parameter is only available if the <symbol>LOCK_DEBUG</symbol>
        macro was defined when <productname>PostgreSQL</productname> was
        compiled.
       </para>
____________________________________________________________________________-->
       <para>
        只有在编译<productname>PostgreSQL</productname>时定义了<symbol>LOCK_DEBUG</symbol>宏， 这个参数才可用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><varname>trace_lock_oidmin</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>trace_lock_oidmin</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>trace_lock_oidmin</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>trace_lock_oidmin</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        If set, do not trace locks for tables below this OID (used to avoid
        output on system tables).
       </para>
____________________________________________________________________________-->
       <para>
        如果设置，不会跟踪小于这个 OID 的锁（用于避免在系统表上的输出）。
       </para>

<!--==========================orignal english content==========================
       <para>
        This parameter is only available if the <symbol>LOCK_DEBUG</symbol>
        macro was defined when <productname>PostgreSQL</productname> was
        compiled.
       </para>
____________________________________________________________________________-->
       <para>
        只有在编译<productname>PostgreSQL</productname>时定义了<symbol>LOCK_DEBUG</symbol>宏， 这个参数才可用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><varname>trace_lock_table</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>trace_lock_table</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>trace_lock_table</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>trace_lock_table</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Unconditionally trace locks on this table (OID).
       </para>
____________________________________________________________________________-->
       <para>
        无条件地跟踪此表（OID）上的锁。
       </para>

<!--==========================orignal english content==========================
       <para>
        This parameter is only available if the <symbol>LOCK_DEBUG</symbol>
        macro was defined when <productname>PostgreSQL</productname> was
        compiled.
       </para>
____________________________________________________________________________-->
       <para>
        只有在编译<productname>PostgreSQL</productname>时定义了<symbol>LOCK_DEBUG</symbol>宏， 这个参数才可用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><varname>debug_deadlocks</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>debug_deadlocks</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>debug_deadlocks</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>debug_deadlocks</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        If set, dumps information about all current locks when a
        deadlock timeout occurs.
       </para>
____________________________________________________________________________-->
       <para>
        如果设置，当死锁超时发生时，转储所有当前锁的信息。
       </para>

<!--==========================orignal english content==========================
       <para>
        This parameter is only available if the <symbol>LOCK_DEBUG</symbol>
        macro was defined when <productname>PostgreSQL</productname> was
        compiled.
       </para>
____________________________________________________________________________-->
       <para>
        只有在编译<productname>PostgreSQL</productname>时定义了<symbol>LOCK_DEBUG</symbol>宏， 这个参数才可用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><varname>log_btree_build_stats</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_btree_build_stats</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>log_btree_build_stats</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_btree_build_stats</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        If set, logs system resource usage statistics (memory and CPU) on
        various B-tree operations.
       </para>
____________________________________________________________________________-->
       <para>
        如果设置，会记录 B 树操作上的系统资源使用情况统计（内存和 CPU）。
       </para>

<!--==========================orignal english content==========================
       <para>
        This parameter is only available if the <symbol>BTREE_BUILD_STATS</symbol>
        macro was defined when <productname>PostgreSQL</productname> was
        compiled.
       </para>
____________________________________________________________________________-->
       <para>
        只有在编译<productname>PostgreSQL</productname>时定义了<symbol>BTREE_BUILD_STATS</symbol>宏， 这个参数才可用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-consistency-checking" xreflabel="wal_consistency_checking">
<!--==========================orignal english content==========================
      <term><varname>wal_consistency_checking</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>wal_consistency_checking</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>wal_consistency_checking</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>wal_consistency_checking</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        This parameter is intended to be used to check for bugs in the WAL
        redo routines.  When enabled, full-page images of any buffers modified
        in conjunction with the WAL record are added to the record.
        If the record is subsequently replayed, the system will first apply
        each record and then test whether the buffers modified by the record
        match the stored images.  In certain cases (such as hint bits), minor
        variations are acceptable, and will be ignored.  Any unexpected
        differences will result in a fatal error, terminating recovery.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数被设计用来检查WAL重做例程中的缺陷。当这个参数被启用时，被修改的任何缓冲区的全页映像及其WAL记录都被加入到记录中。如果该记录后来被重放，系统将首先应用每个记录然后测试该记录修改的缓冲区是否符合存储的映像。在某些情况下（例如提示位），小的变动是可以接受的，并且会被忽略。任何预期之外的差别都将导致致命错误，最后中止恢复。
       </para>

<!--==========================orignal english content==========================
       <para>
        The default value of this setting is the empty string, which disables
        the feature.  It can be set to <literal>all</literal> to check all
        records, or to a comma-separated list of resource managers to check
        only records originating from those resource managers.  Currently,
        the supported resource managers are <literal>heap</literal>,
        <literal>heap2</literal>, <literal>btree</literal>, <literal>hash</literal>,
        <literal>gin</literal>, <literal>gist</literal>, <literal>sequence</literal>,
        <literal>spgist</literal>, <literal>brin</literal>, and <literal>generic</literal>. Only
        superusers can change this setting.
       </para>
____________________________________________________________________________-->
       <para>
        这个设置的默认值是空字符串，它将禁用这一特性。它可以被设置为<literal>all</literal>以检查所有记录，或者被设置为一个逗号分隔的资源管理器列表用以检查那些资源管理器产生的记录。当前，支持的资源管理器是<literal>heap</literal>、<literal>heap2</literal>、<literal>btree</literal>、<literal>hash</literal>、<literal>gin</literal>、<literal>gist</literal>、<literal>sequence</literal>、<literal>spgist</literal>、<literal>brin</literal>以及<literal>generic</literal>。只有超级用户可以更改这一设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-debug" xreflabel="wal_debug">
<!--==========================orignal english content==========================
      <term><varname>wal_debug</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>wal_debug</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>wal_debug</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>wal_debug</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        If on, emit WAL-related debugging output. This parameter is
        only available if the <symbol>WAL_DEBUG</symbol> macro was
        defined when <productname>PostgreSQL</productname> was
        compiled.
       </para>
____________________________________________________________________________-->
       <para>
        如果被打开，WAL 相关的调试输出将被发出。只有在编译<productname>PostgreSQL</productname>时定义了<symbol>WAL_DEBUG</symbol>宏的情况下，这个参数才可用。
       </para>
      </listitem>
     </varlistentry>

    <varlistentry id="guc-ignore-checksum-failure" xreflabel="ignore_checksum_failure">
<!--==========================orignal english content==========================
      <term><varname>ignore_checksum_failure</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>ignore_checksum_failure</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>ignore_checksum_failure</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>ignore_checksum_failure</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Only has effect if <xref linkend="app-initdb-data-checksums"/> are enabled.
       </para>
____________________________________________________________________________-->
       <para>
        只有当<xref linkend="app-initdb-data-checksums"/>被启用时才有效。
       </para>

<!--==========================orignal english content==========================
       <para>
        Detection of a checksum failure during a read normally causes
        <productname>PostgreSQL</productname> to report an error, aborting the current
        transaction.  Setting <varname>ignore_checksum_failure</varname> to on causes
        the system to ignore the failure (but still report a warning), and
        continue processing.  This behavior may <emphasis>cause crashes, propagate
        or hide corruption, or other serious problems</emphasis>.  However, it may allow
        you to get past the error and retrieve undamaged tuples that might still be
        present in the table if the block header is still sane. If the header is
        corrupt an error will be reported even if this option is enabled. The
        default setting is <literal>off</literal>, and it can only be changed by a superuser.
       </para>
____________________________________________________________________________-->
       <para>
        在读取过程中检测到一次校验码失败通常会导致<productname>PostgreSQL</productname>报告一个错误。设置<varname>ignore_checksum_failure</varname>为打开会导致系统忽略失败（但是仍然报告一个警告），并且继续执行。这种行为可能<emphasis>导致崩溃、传播或隐藏损坏或者其他严重的问题</emphasis>。但是，它允许你绕过错误并且在块头部仍然健全的情况下从表中检索未损坏的元组。如果头部被损坏，即便这个选项被启用系统也将报告一个错误。默认设置是<literal>off</literal>，并且只能被超级用户改变。
       </para>
      </listitem>
     </varlistentry>

    <varlistentry id="guc-zero-damaged-pages" xreflabel="zero_damaged_pages">
<!--==========================orignal english content==========================
      <term><varname>zero_damaged_pages</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>zero_damaged_pages</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>zero_damaged_pages</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>zero_damaged_pages</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Detection of a damaged page header normally causes
        <productname>PostgreSQL</productname> to report an error, aborting the current
        transaction.  Setting <varname>zero_damaged_pages</varname> to on causes
        the system to instead report a warning, zero out the damaged
        page in memory, and continue processing.  This behavior <emphasis>will destroy data</emphasis>,
        namely all the rows on the damaged page.  However, it does allow you to get
        past the error and retrieve rows from any undamaged pages that might
        be present in the table.  It is useful for recovering data if
        corruption has occurred due to a hardware or software error.  You should
        generally not set this on until you have given up hope of recovering
        data from the damaged pages of a table.  Zeroed-out pages are not
        forced to disk so it is recommended to recreate the table or
        the index before turning this parameter off again.  The
        default setting is <literal>off</literal>, and it can only be changed
        by a superuser.
       </para>
____________________________________________________________________________-->
       <para>
        检测到一个损坏的页面头部通常会导致<productname>PostgreSQL</productname>报告一个错误，并且中止当前事务。把<varname>zero_damaged_pages</varname>设置为打开会让系统报告一个警告、把损坏的页面填充零，然后继续处理。这种行为会<emphasis>毁掉数据</emphasis>，即被损坏页面上的所有行。但是它允许你绕开错误并且从可能存在表中的任何未损坏页面中检索行。如果由于一次硬件或软件错误而发生毁坏，这种方法可用于恢复数据。通常你不应该把它设置为打开，除非你已经彻底放弃从表的损坏页面中恢复数据。被填充零的页面不会被强制到磁盘上，因此我们推荐在再次关闭这个参数之前先重建表或索引。默认的设置是<literal>off</literal>，并且只有超级用户可以改变它。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ignore-invalid-pages" xreflabel="ignore_invalid_pages">
<!--==========================orignal english content==========================
      <term><varname>ignore_invalid_pages</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>ignore_invalid_pages</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>ignore_invalid_pages</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>ignore_invalid_pages</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        If set to <literal>off</literal> (the default), detection of
        WAL records having references to invalid pages during
        recovery causes <productname>PostgreSQL</productname> to
        raise a PANIC-level error, aborting the recovery. Setting
        <varname>ignore_invalid_pages</varname> to <literal>on</literal>
        causes the system to ignore invalid page references in WAL records
        (but still report a warning), and continue the recovery.
        This behavior may <emphasis>cause crashes, data loss,
        propagate or hide corruption, or other serious problems</emphasis>.
        However, it may allow you to get past the PANIC-level error,
        to finish the recovery, and to cause the server to start up.
        The parameter can only be set at server start. It only has effect
        during recovery or in standby mode.
       </para>
____________________________________________________________________________-->
       <para>
        如果设置为 <literal>off</literal>（默认值），则在恢复期间检测到引用无效页面的 WAL 记录会导致 <productname>PostgreSQL</productname> 引发 PANIC 级别错误，中止恢复。
        将<varname>ignore_invalid_pages</varname>设置为<literal>on</literal>会导致系统忽略 WAL 记录中的无效页面引用（但仍报告警告），并继续恢复。
        此行为可能会<emphasis>导致崩溃、数据丢失、传播或隐藏腐败，或其他严重问题</emphasis>。
        但是，它可能允许你通过 PANIC 级错误，完成恢复，并启动服务器。
        参数只能在服务器启动时设置。它仅在恢复期间或待机模式下生效。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-jit-debugging-support" xreflabel="jit_debugging_support">
<!--==========================orignal english content==========================
      <term><varname>jit_debugging_support</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>jit_debugging_support</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>jit_debugging_support</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>jit_debugging_support</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        If LLVM has the required functionality, register generated functions
        with <productname>GDB</productname>.  This makes debugging easier.
        The default setting is <literal>off</literal>.
        This parameter can only be set at server start.
       </para>
____________________________________________________________________________-->
       <para>
        如果LLVM有所需要的功能，用<productname>GDB</productname>注册所生成的函数。这会让调试更加容易。默认设置是<literal>off</literal>。这个参数只能在服务器启动时设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-jit-dump-bitcode" xreflabel="jit_dump_bitcode">
<!--==========================orignal english content==========================
      <term><varname>jit_dump_bitcode</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>jit_dump_bitcode</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>jit_dump_bitcode</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>jit_dump_bitcode</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Writes the generated <productname>LLVM</productname> IR out to the
        file system, inside <xref linkend="guc-data-directory"/>. This is only
        useful for working on the internals of the JIT implementation.
        The default setting is <literal>off</literal>.
        This parameter can only be changed by a superuser.
       </para>
____________________________________________________________________________-->
       <para>
        把生成的<productname>LLVM</productname> IR写出到文件系统，写到<xref linkend="guc-data-directory"/>中。只有在做JIT内部实现工作时，这个参数才能派上用场。默认设置是<literal>off</literal>。这个参数只能由超级用户修改。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-jit-expressions" xreflabel="jit_expressions">
<!--==========================orignal english content==========================
      <term><varname>jit_expressions</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>jit_expressions</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>jit_expressions</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>jit_expressions</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Determines whether expressions are JIT compiled, when JIT compilation
        is activated (see <xref linkend="jit-decision"/>).  The default is
        <literal>on</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        当JIT编译被激活时（见<xref linkend="jit-decision"/>），确定表达式是否用JIT编译。默认值是<literal>on</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-jit-profiling-support" xreflabel="jit_profiling_support">
<!--==========================orignal english content==========================
      <term><varname>jit_profiling_support</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>jit_profiling_support</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>jit_profiling_support</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>jit_profiling_support</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        If LLVM has the required functionality, emit the data needed to allow
        <productname>perf</productname> to profile functions generated by JIT.
        This writes out files to <filename>~/.debug/jit/</filename>; the
        user is responsible for performing cleanup when desired.
        The default setting is <literal>off</literal>.
        This parameter can only be set at server start.
       </para>
____________________________________________________________________________-->
       <para>
        如果LLVM有所需的功能，发出需要的数据以允许<productname>perf</productname>对JIT生成的函数画像。
        这会写出文件到<filename>~/.debug/jit/</filename>中，如果需要，由用户负责对其执行清除。
        默认设置是<literal>off</literal>。
        这个参数只能在服务器启动时设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-jit-tuple-deforming" xreflabel="jit_tuple_deforming">
<!--==========================orignal english content==========================
      <term><varname>jit_tuple_deforming</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>jit_tuple_deforming</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>jit_tuple_deforming</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>jit_tuple_deforming</varname>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Determines whether tuple deforming is JIT compiled, when JIT
        compilation is activated (see <xref linkend="jit-decision"/>).
        The default is <literal>on</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        当JIT编译被激活时（见<xref linkend="jit-decision"/>），确定元组拆解是否被JIT编译。默认值是<literal>on</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-remove-temp-files-after-crash" xreflabel="remove_temp_files_after_crash">
<!--==========================orignal english content==========================
      <term><varname>remove_temp_files_after_crash</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>remove_temp_files_after_crash</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term><varname>remove_temp_files_after_crash</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>remove_temp_files_after_crash</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        When set to <literal>on</literal>, which is the default,
        <productname>PostgreSQL</productname> will automatically remove
        temporary files after a backend crash. If disabled, the files will be
        retained and may be used for debugging, for example. Repeated crashes
        may however result in accumulation of useless files. This parameter
        can only be set in the <filename>postgresql.conf</filename> file or on
        the server command line.
       </para>
____________________________________________________________________________-->
       <para>
        当设置为<literal>on</literal>时，这是默认值，<productname>PostgreSQL</productname>将在后端崩溃后自动删除临时文件。
        如果禁用，文件将被保留，并且也许可用于调试，例如。
        重复的崩溃可能会导致无用文件的积累。
        该参数只能在<filename>postgresql.conf</filename>文件中或服务器命令行中设置。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
  </sect1>
  <sect1 id="runtime-config-short">
<!--==========================orignal english content==========================
   <title>Short Options</title>
____________________________________________________________________________-->
   <title>短选项</title>
<!--==========================orignal english content==========================
   <para>
    For convenience there are also single letter command-line option
    switches available for some parameters.  They are described in
    <xref linkend="runtime-config-short-table"/>.  Some of these
    options exist for historical reasons, and their presence as a
    single-letter option does not necessarily indicate an endorsement
    to use the option heavily.
   </para>
____________________________________________________________________________-->
   <para>
    为了方便起见，系统中还为一些参数提供了单字母的命令行选项开关。它们在<xref linkend="runtime-config-short-table"/>中描述。其中一些选项是由于历史原因而存在，并且它们作为一个单字母选项存在并不表示它们会被大量使用。
   </para>

    <table id="runtime-config-short-table">
<!--==========================orignal english content==========================
     <title>Short Option Key</title>
____________________________________________________________________________-->
     <title>短选项键</title>
     <tgroup cols="2">
      <colspec colname="col1" colwidth="1*"/>
      <colspec colname="col2" colwidth="2*"/>
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry>Short Option</entry>
        <entry>Equivalent</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>短选项</entry>
        <entry>等效于</entry>
       </row>
      </thead>

      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry><option>-B <replaceable>x</replaceable></option></entry>
        <entry><literal>shared_buffers = <replaceable>x</replaceable></literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><option>-B <replaceable>x</replaceable></option></entry>
        <entry><literal>shared_buffers = <replaceable>x</replaceable></literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><option>-d <replaceable>x</replaceable></option></entry>
        <entry><literal>log_min_messages = DEBUG<replaceable>x</replaceable></literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><option>-d <replaceable>x</replaceable></option></entry>
        <entry><literal>log_min_messages = DEBUG<replaceable>x</replaceable></literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><option>-e</option></entry>
        <entry><literal>datestyle = euro</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><option>-e</option></entry>
        <entry><literal>datestyle = euro</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry>
          <option>-fb</option>, <option>-fh</option>, <option>-fi</option>,
          <option>-fm</option>, <option>-fn</option>, <option>-fo</option>,
          <option>-fs</option>, <option>-ft</option>
         </entry>
         <entry>
          <literal>enable_bitmapscan = off</literal>,
          <literal>enable_hashjoin = off</literal>,
          <literal>enable_indexscan = off</literal>,
          <literal>enable_mergejoin = off</literal>,
          <literal>enable_nestloop = off</literal>,
          <literal>enable_indexonlyscan = off</literal>,
          <literal>enable_seqscan = off</literal>,
          <literal>enable_tidscan = off</literal>
         </entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>
          <option>-fb</option>, <option>-fh</option>, <option>-fi</option>,
          <option>-fm</option>, <option>-fn</option>, <option>-fo</option>,
          <option>-fs</option>, <option>-ft</option>
         </entry>
         <entry>
          <literal>enable_bitmapscan = off</literal>,
          <literal>enable_hashjoin = off</literal>,
          <literal>enable_indexscan = off</literal>,
          <literal>enable_mergejoin = off</literal>,
          <literal>enable_nestloop = off</literal>,
          <literal>enable_indexonlyscan = off</literal>,
          <literal>enable_seqscan = off</literal>,
          <literal>enable_tidscan = off</literal>
         </entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><option>-F</option></entry>
        <entry><literal>fsync = off</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><option>-F</option></entry>
        <entry><literal>fsync = off</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><option>-h <replaceable>x</replaceable></option></entry>
        <entry><literal>listen_addresses = <replaceable>x</replaceable></literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><option>-h <replaceable>x</replaceable></option></entry>
        <entry><literal>listen_addresses = <replaceable>x</replaceable></literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><option>-i</option></entry>
        <entry><literal>listen_addresses = '*'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><option>-i</option></entry>
        <entry><literal>listen_addresses = '*'</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><option>-k <replaceable>x</replaceable></option></entry>
        <entry><literal>unix_socket_directories = <replaceable>x</replaceable></literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><option>-k <replaceable>x</replaceable></option></entry>
        <entry><literal>unix_socket_directories = <replaceable>x</replaceable></literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><option>-l</option></entry>
        <entry><literal>ssl = on</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><option>-l</option></entry>
        <entry><literal>ssl = on</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><option>-N <replaceable>x</replaceable></option></entry>
        <entry><literal>max_connections = <replaceable>x</replaceable></literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><option>-N <replaceable>x</replaceable></option></entry>
        <entry><literal>max_connections = <replaceable>x</replaceable></literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><option>-O</option></entry>
        <entry><literal>allow_system_table_mods = on</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><option>-O</option></entry>
        <entry><literal>allow_system_table_mods = on</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><option>-p <replaceable>x</replaceable></option></entry>
        <entry><literal>port = <replaceable>x</replaceable></literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><option>-p <replaceable>x</replaceable></option></entry>
        <entry><literal>port = <replaceable>x</replaceable></literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><option>-P</option></entry>
        <entry><literal>ignore_system_indexes = on</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><option>-P</option></entry>
        <entry><literal>ignore_system_indexes = on</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><option>-s</option></entry>
        <entry><literal>log_statement_stats = on</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><option>-s</option></entry>
        <entry><literal>log_statement_stats = on</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><option>-S <replaceable>x</replaceable></option></entry>
        <entry><literal>work_mem = <replaceable>x</replaceable></literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><option>-S <replaceable>x</replaceable></option></entry>
        <entry><literal>work_mem = <replaceable>x</replaceable></literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><option>-tpa</option>, <option>-tpl</option>, <option>-te</option></entry>
        <entry><literal>log_parser_stats = on</literal>,
        <literal>log_planner_stats = on</literal>,
        <literal>log_executor_stats = on</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><option>-tpa</option>, <option>-tpl</option>, <option>-te</option></entry>
        <entry><literal>log_parser_stats = on</literal>,
        <literal>log_planner_stats = on</literal>,
        <literal>log_executor_stats = on</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><option>-W <replaceable>x</replaceable></option></entry>
        <entry><literal>post_auth_delay = <replaceable>x</replaceable></literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><option>-W <replaceable>x</replaceable></option></entry>
        <entry><literal>post_auth_delay = <replaceable>x</replaceable></literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  </sect1>
</chapter>
