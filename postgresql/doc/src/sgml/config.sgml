<!-- doc/src/sgml/config.sgml -->

<chapter id="runtime-config">
  <title>服务器配置</title>

  <indexterm>
   <primary>配置</primary>
   <secondary>of the server</secondary>
  </indexterm>

  <para>
   有很多配置参数可以影响数据库系统的行为。本章的第一节中我们将描述一下如何与配置参数交互。
   后续的小节将详细地讨论每一个参数。
  </para>

  <sect1 id="config-setting">
   <title>设置参数</title>

   <sect2 id="config-setting-names-values">
    <title>参数名称和值</title>

    <para>
     所有参数名都是大小写不敏感的。每个参数都可以接受五种类型之一的值： 布尔、字符串、整数、
     浮点数或枚举。该类型决定了设置该参数的语法：
    </para>

    <itemizedlist>
     <listitem>
      <para>
       <emphasis>布尔:</emphasis>
       值可以被写成
       <literal>on</literal>,
       <literal>off</literal>,
       <literal>true</literal>,
       <literal>false</literal>,
       <literal>yes</literal>,
       <literal>no</literal>,
       <literal>1</literal>,
       <literal>0</literal>
       （都是大小写不敏感的）或者这些值的任何无歧义前缀。
      </para>
     </listitem>

     <listitem>
      <para>
       <emphasis>字符串:</emphasis>
       通常值被包括在单引号内，值内部的任何单引号都需要被双写。不过，如果值是一个简单数字或者
       标识符，引号通常可以被省略。
      </para>
     </listitem>

     <listitem>
      <para>
       <emphasis>数字（整数和浮点）:</emphasis>
       只对浮点参数允许一个小数点。不要使用千位分隔符。不要求引号。
      </para>
     </listitem>

     <listitem>
      <para>
       <emphasis>带单位的数字:</emphasis>
       一些数字参数具有隐含单位，因为它们描述内存或时间量。单位可能是千字节、块（通常是 8KB）、 毫秒、秒或分钟。这些设置之一的一个未修饰的数字值将使用该设置的默认单位，默认单位可以通
       过引用<structname>pg_settings</>.<structfield>unit</>来找到。为了方便，也可以
       显式地指定一个不同的单位，例如时间值可以是<literal>'120 ms'</>，并且它们将被转换到参数的实际单位。要使用这个特性，注意值必须被写成一个字符
       串（带有引号）。单位名称是大小写敏感的，并且在数字值和单位之间可以有空白。

       <itemizedlist>
        <listitem>
         <para>
          可用的内存单位是<literal>kB</literal>（千字节）、<literal>MB</literal>（兆字节）和<literal>GB</literal>（吉字节）。内存单位的乘数是 1024 而不是 1000。
         </para>
        </listitem>

        <listitem>
         <para>
          可用的时间单位是<literal>ms</literal>（毫秒）、<literal>s</literal>（秒）、<literal>min</literal>（分钟）、 <literal>h</literal>（小时）和<literal>d</literal>（天）。
         </para>
        </listitem>
       </itemizedlist>
      </para>
     </listitem>

     <listitem>
      <para>
       <emphasis>枚举:</emphasis>
       枚举类型的参数以与字符串参数相同的方式指定，但被限制到一组有限的值。 这样一个参数可用的值可以在<structname>pg_settings</>.<structfield>enumvals</>
       中找到。枚举参数值是大小写无关的。
      </para>
     </listitem>
    </itemizedlist>
   </sect2>

   <sect2 id="config-setting-configuration-file">
    <title>通过配置文件影响参数</title>

    <para>
     设置这些参数最基本的方法是编辑<filename>postgresql.conf</><indexterm><primary>postgresql.conf</></>文件， 它通常被保存在数据目录中（当数据库集簇目录被初始化时，一个默认的拷贝将会被安装在那里）。一个该文件的例子看起来是：
<programlisting>
# This is a comment
log_connections = yes
log_destination = 'syslog'
search_path = '"$user", public'
shared_buffers = 128MB
</programlisting>
     每一行指定一个参数。名称和值之间的等号是可选的。空白是无意义的（除了在一个引号引用的参数值内）并且空行被忽略。井号（<literal>#</literal>）指示该行的剩余部分是一个注释。非简单标识符或者数字的参数值必须用单引号包围。要在参数值里嵌入单引号， 要么写两个单引号（首选）或者在引号前放反斜线。
    </para>

    <para>
     以这种方式设定的参数为集簇提供了默认值。除非这些设置被覆盖，活动会话看到的就是这些设置。
     下面的小节描述了管理员或用户覆盖这些默认值的方法。
    </para>

    <para>
     <indexterm>
      <primary>SIGHUP</primary>
     </indexterm>
     主服务器进程每次收到<systemitem>SIGHUP</>信号（最简单的方法是从命令行运行<literal>pg_ctl reload</>或调用 SQL 函数<function>pg_reload_conf()</function>来发送这个信号）后都会重新读取这个配置
     文件。主服务器进程还会把这个信号传播给所有正在运行的服务器进程，这样现有的会话也能采用新
     值（要等待它们完成当前正在执行的客户端命令之后才会发生）。另外，你可以直接向一个单一服务
     器进程发送该信号。有些参数只能在服务器启动时设置，在配置文件中对这些条目的修改将被忽略，
     直到下次服务器重启。配置文件中的非法参数设置也会在<systemitem>SIGHUP</>处理过程中被
     忽略（但是会记录日志）。
    </para>

    <para>
     除<filename>postgresql.conf</>之外，<productname>PostgreSQL</productname>
     数据目录还包含一个文件
     <filename>postgresql.auto.conf</><indexterm><primary>postgresql.auto.conf</></>，它具有和<filename>postgresql.conf</>相同的格式但是不应该被手工编辑。这个
     文件保存了通过<xref linkend="SQL-ALTERSYSTEM">命令提供的设置。每当<filename>postgresql.conf</>被读
     取时这个文件会被自动读取，并且它的设置会以同样的方式生效。
     <filename>postgresql.auto.conf</>中的设置会覆盖<filename>postgresql.conf</>
     中的设置。
    </para>
    
    <para>
     如果<systemitem>SIGHUP</>信号没有产生预期效果，
     那么系统表<link linkend="view-pg-file-settings"><structname>pg_file_settings</structname></link>
     有助于对配置文件的预测试更改，或者诊断问题。
    </para>
    
   </sect2>

   <sect2 id="config-setting-sql-command-interaction">
    <title>通过SQL影响参数</title>

     <para>
      <productname>PostgreSQL</productname>提供了三个SQL命令来建立配置默认值。
      已经提到过的<xref linkend="SQL-ALTERSYSTEM">命令提供了一种改变全局默认值的从SQL可
      访问的方法；它在功效上等效于编辑<filename>postgresql.conf</>。此外，还有两个命令
      可以针对每个数据库或者每个角色设置默认值：
     </para>

     <itemizedlist>
     <listitem>
      <para>
       <xref linkend="sql-alterdatabase">命令允许针对一个数据库覆盖其全局设置。
      </para>
     </listitem>

     <listitem>
      <para>
       <xref linkend="sql-alterrole">命令允许用用户指定的值来覆盖全局设置和数据库设置。
      </para>
     </listitem>
    </itemizedlist>

     <para>
      只有当开始一个新的数据库会话时，用<command>ALTER DATABASE</>和
      <command>ALTER ROLE</>设置的值才会被应用。它们会覆盖从配置文件或服务器命令行
      获得的值，并且作为该会话后续的默认值。注意某些设置在服务器启动后不能被更改，并且因此
      不能被这些命令（或者下文列举的命令）设置。
    </para>

     <para>
      一旦一个客户端连接到数据库，<productname>PostgreSQL</>会提供两个额外的SQL命令（
      以及等效的函数）用以影响会话本地的配置设置：
    </para>

    <itemizedlist>
     <listitem>
     <para>
      <xref linkend="SQL-SHOW">命令允许察看所有参数的当前值。对应的函数是
      <function>current_setting(setting_name text)</function>。
     </para>
     </listitem>

     <listitem>
      <para>
       <xref linkend="SQL-SET">命令允许修改对于一个会话可以本地设置的参数的当前值，
       它对其他会话没有影响。对应的函数是
       <function>set_config(setting_name, new_value, is_local)</function>。
      </para>
     </listitem>
    </itemizedlist>

    <para>
     此外，系统视图<link
     linkend="view-pg-settings"><structname>pg_settings</></>可以被用来查看和改变
     会话本地的值：
    </para>

    <itemizedlist>
     <listitem>
      <para>
       查询这个视图与使用<command>SHOW ALL</>相似，但是可以提供更多细节。它也更加灵活，
       因为可以为它指定过滤条件或者把它与其他关系进行连接。
      </para>
     </listitem>

     <listitem>
      <para>
       在这个视图上使用<xref linkend="SQL-UPDATE">并且指定更新<structname>setting</>
       列，其效果等同于发出<command>SET</>命令。例如，下面的命令
<programlisting>
SET configuration_parameter TO DEFAULT;
</programlisting>
       等效于：
<programlisting>
UPDATE pg_settings SET setting = reset_val WHERE name = 'configuration_parameter';
</programlisting>
      </para>
     </listitem>
    </itemizedlist>
   </sect2>

   <sect2>
    <title>通过 Shell 影响参数</title>

     <para>
      除了在数据库或者角色层面上设置全局默认值或者进行覆盖，你还可以通过 shell 工具把设置
      传递给<productname>PostgreSQL</productname>。服务器和<application>libpq</>
      客户端库都能通过 shell 接受参数值。
     </para>

     <itemizedlist>
      <listitem>
      <para>
       在服务器启动期间，可以通过<option>-c</>命令行参数把参数设置传递给
       <command>postgres</command>命令。例如：
<programlisting>
postgres -c log_connections=yes -c log_destination='syslog'
</programlisting>
       这种方式提供的设置会覆盖通过<filename>postgresql.conf</>或者
       <command>ALTER SYSTEM</>提供的设置，因此除了重启服务器之外无法从全局上改变它们。
     </para>
    </listitem>

    <listitem>
     <para>
      当通过<application>libpq</>启动一个客户端会话时，可以使用<envar>PGOPTIONS</envar>
      环境变量指定参数设置。这种方式建立的设置构成了会话生存期间的默认值，但是不会影响
      其他的会话。由于历史原因，<envar>PGOPTIONS</envar>的格式和启动
      <command>postgres</command>命令时用到的相似，特别是<option>-c</>标志必须被指定。
      例如：
<programlisting>
env PGOPTIONS="-c geqo=off -c statement_timeout=5min" psql
</programlisting>
     </para>

     <para>
      通过 shell 或者其他方式，其他客户端和库可能提供它们自己的机制，以便允许用户在不直接
      使用SQL命令的前提下修改会话设置。
     </para>
    </listitem>
   </itemizedlist>

   </sect2>

   <sect2 id="config-includes">
    <title>管理配置文件内容</title>

     <para>
      <productname>PostgreSQL</>提供了一些特性用于把复杂的
      <filename>postgresql.conf</>文件分解成子文件。在管理多个具有相关但不完全相同
      配置的服务器时，这些特性特别有用。
     </para>

     <para>
      <indexterm>
       <primary><literal>include</></primary>
       <secondary>in configuration file</secondary>
       </indexterm>
         除了单个参数设置，<filename>postgresql.conf</>文件可以包含<firstterm>包括指令</>，它指定要读入和处理的另一个文件，就好像该文件被插入到配置文件的这个点。这个特性允许一个配置文件被划分成物理上独立的部分。包括指令看起来像：
<programlisting>
include 'filename'
</programlisting>
         如果文件名不是一个绝对路径，它将作为包含引用配置文件的目录的相对位置。包括可以被嵌套。
     </para>

     <para>
      <indexterm>
       <primary><literal>include_if_exists</></primary>
       <secondary>in configuration file</secondary>
      </indexterm>
         也有一个<literal>include_if_exists</>指令，它的作用和<literal>include</>指令一样，不过当被引用的文件不存在或者无法被读取时其行为不同。一个通常的<literal>include</>将认为这是一个错误情况，而<literal>include_if_exists</>仅仅记录一个消息并且继续处理引用配置文件。
     </para>

     <para>
      <indexterm>
       <primary><literal>include_dir</></primary>
       <secondary>in configuration file</secondary>
      </indexterm>
        <filename>postgresql.conf</>文件也可以包含<literal>include_dir</literal>指令，它指定要被包含的配置文件的一整个目录。它的用法类似：
 <programlisting>
 include_dir 'directory'
 </programlisting>
        非绝对目录名被当做包含引用配置文件的目录的相对路径。在该指定目录中，只有以后缀名
        <literal>.conf</literal>结尾的非目录文件才会被包括。以<literal>.</literal>
        字符开头的文件名也会被忽略，因为在某些平台上它们是隐藏文件。一个包括目录中的多个文件
        被以文件名顺序处理（根据 C 区域规则排序，即数字在字母之前并且大写字母在小写字母
        之前）。
     </para>

     <para>
       包括文件或目录可以被用来在逻辑上分隔数据库配置的各个部分，而不是用一个很大的<filename>postgresql.conf</>文件。考虑一个有两台数据库服务器的公司，每一个都有不同的内存量。很可能配置的元素都会被共享，例如用于日志的参数。但是两者关于内存的参数将会不同。并且还可能会有服务器相关的自定义。一种管理这类情况的方法是将你的站点的自定义配置修改分成三个文件。你可以把下面的内容加入到你的<filename>postgresql.conf</>文件末尾来包括它们：
 <programlisting>
 include 'shared.conf'
 include 'memory.conf'
 include 'server.conf'
 </programlisting>
       所有的系统将会有相同的<filename>shared.conf</>。每个有特定内存量的服务器可以共享相同的<filename>memory.conf</>。你可能对所有 8GB 内存的服务器有一个，而对那些 16GB 内存的服务器有另一个。并且最后<filename>server.conf</>可以装有真正服务器相关的配置信息。
     </para>

     <para>
       另一中可能性是创建一个配置文件目录并把这个信息放到其中的文件里。例如，一个<filename>conf.d</>目录可以在<filename>postgresql.conf</>的末尾被引用：
 <programlisting>
 include_dir 'conf.d'
 </programlisting>
       然后你可以这样命名<filename>conf.d</>目录中的文件：
 <programlisting>
 00shared.conf
 01memory.conf
 02server.conf
 </programlisting>
       这种命名习惯建立了这些文件将被载入的清晰顺序。这是很重要的，因为在服务器读取配置
       文件时，对于一个特定的参数只有最后碰到的一个设置才会被使用。在这个例子中，
       <filename>conf.d/02server.conf</>设置的东西将会覆盖在
       <filename>conf.d/01memory.conf</>中相同参数的值。
     </para>

     <para>
       你还可以使用这种配置目录方法，在命名文件时更有描述性：
 <programlisting>
 00shared.conf
 01memory-8GB.conf
 02server-foo.conf
 </programlisting>
       这种形式的安排为每个配置文件变体给定了一个唯一的名称。当多个服务器把它们的配置全部存储在一个位置（例如在一个版本控制仓库中）时，这可以帮助消除歧义（在版本控制下存储数据库配置文件是另一个值得考虑的好方法）。
     </para>
    </sect2>
   </sect1>

   <sect1 id="runtime-config-file-locations">
    <title>文件位置</title>

     <para>
      除了已经提到过的<filename>postgresql.conf</filename>文件之外，<productname>PostgreSQL</productname>还使用另外两个手工编辑的配置文件，它们控制客户端认证（其使用在<xref linkend="client-authentication">中讨论）。默认情况下，所有三个配置文件都存放在数据库集簇的数据目录中。 本节描述的参数允许配置文件放在别的地方（这么做可以简化管理，特别是如果配置文件被独立放置，可以很容易保证它得到恰当的备份）。
     </para>

     <variablelist>
     <varlistentry id="guc-data-directory" xreflabel="data_directory">
      <term><varname>data_directory</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>data_directory</>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
       <para>
         指定用于数据存储的目录。这个选项只能在服务器启动时设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-config-file" xreflabel="config_file">
      <term><varname>config_file</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>config_file</>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
       <para>
         指定主服务器配置文件（通常叫<filename>postgresql.conf</>）。这个参数只能在<command>postgres</command>命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-hba-file" xreflabel="hba_file">
      <term><varname>hba_file</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>hba_file</>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
       <para>
         指定基于主机认证配置文件（通常叫<filename>pg_hba.conf</>）。 这个参数只能在服务器启动的时候设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ident-file" xreflabel="ident_file">
      <term><varname>ident_file</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>ident_file</>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
       <para>
         指定用于<xref linkend="auth-username-maps">用户名称映射的配置文件（通常叫<filename>pg_ident.conf</>）。这个参数只能在服务器启动的时候设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-external-pid-file" xreflabel="external_pid_file">
      <term><varname>external_pid_file</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>external_pid_file</>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
       <para>
        指定可被服务器创建的用于管理程序的额外进程 ID（PID）文件。这个参数只能在服务器启动的时候设置。
       </para>
      </listitem>
     </varlistentry>
     </variablelist>

     <para>
      在默认安装中不会显式设置以上参数。相反，命令行参数<option>-D</option>或者环境变量<envar>PGDATA</envar>指定数据目录，并且上述配置文件都能在数据目录中找到。
     </para>

     <para>
      如果你想把配置文件放在别的地方而不是数据目录中，那么<command>postgres</command> <option>-D</option>命令行选项或者环境变量<envar>PGDATA</envar>必须指向包含配置文件的目录，并且<filename>postgresql.conf</filename>中（或者命令行上）的<varname>data_directory</>参数必须显示数据目录实际存放的地方。请注意，<varname>data_directory</>将覆盖<option>-D</option>和<envar>PGDATA</envar>指定的数据目录位置，但是不覆盖配置文件的位置。
     </para>

     <para>
      如果你愿意，可以使用选项<varname>config_file</>、<varname>hba_file</>和/或<varname>ident_file</>单独指定配置文件名称和位置。<varname>config_file</>只能在<command>postgres</command>命令行上指定，但是其他文件可以在主配置文件中设置。如果所有三个参数外加<varname>data_directory</>被显式地设置，则不必指定<option>-D</option>或<envar>PGDATA</envar>。
     </para>

     <para>
      在设置任何这些参数时，相对路径将被解释为相对于<command>postgres</command>启动路径的路径。
     </para>
   </sect1>

   <sect1 id="runtime-config-connection">
    <title>连接和认证</title>

    <sect2 id="runtime-config-connection-settings">
     <title>连接设置</title>

     <variablelist>

     <varlistentry id="guc-listen-addresses" xreflabel="listen_addresses">
      <term><varname>listen_addresses</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>listen_addresses</>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
       <para>
         指定服务器在哪些 TCP/IP 地址上监听客户端连接。值的形式是一个逗号分隔的主机名和/或数字 IP 地址列表。特殊项<literal>*</>对应所有可用 IP 接口。项<literal>0.0.0.0</>允许监听所有 IPv4 地址并且<literal>::</>允许监听所有 IPv6 地址。如果列表为空，服务器将根本不会监听任何 IP 接口，在这种情况中只能使用 Unix 域套接字来连接它。默认值是<systemitem class="systemname">localhost</>，它只允许建立本地 TCP/IP <quote>环回</>连接。虽然客户端认证（<xref linkend="client-authentication">）允许细粒度地控制谁能访问服务器，<varname>listen_addresses</varname>控制哪些接口接受连接尝试，这能帮助在不安全网络接口上阻止重复的恶意连接请求。这个参数只能在服务器启动时设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-port" xreflabel="port">
      <term><varname>port</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>port</>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
       <para>
        服务器监听的 TCP 端口；默认是 5432 。请注意服务器会同一个端口号监听所有的 IP 地址。这个参数只能在服务器启动时设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-connections" xreflabel="max_connections">
      <term><varname>max_connections</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_connections</>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
       <para>
        决定数据库的最大并发连接数。默认值通常是 100 个连接，但是如果内核设置不支持（<application>initdb</>时决定），可能会比这个 数少。这个参数只能在服务器启动时设置。
       </para>

       <para>
        当运行一个后备服务器时，你必须设置这个参数等于或大于主服务器上的参数。否则，后备服务器上可能无法允许查询。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-superuser-reserved-connections"
     xreflabel="superuser_reserved_connections">
      <term><varname>superuser_reserved_connections</varname>
      (<type>integer</type>)
      <indexterm>
       <primary><varname>superuser_reserved_connections</>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
       <para>
        决定为<productname>PostgreSQL</>超级用户连接而保留的连接<quote>槽</quote>数。 同时活跃的并发连接最多<xref linkend="guc-max-connections">个。任何时候，活跃的并发连接数最多为<varname>max_connections</>减去 <varname>superuser_reserved_connections</varname>，新连接就只能由超级用户发起了，并且不会有新的复制连接被接受。
       </para>

       <para>
        默认值是 3 。这个值必须小于<varname>max_connections</varname>的值。 这个参数只能在服务器启动时设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-unix-socket-directories" xreflabel="unix_socket_directories">
      <term><varname>unix_socket_directories</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>unix_socket_directories</>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
       <para>
        指定服务器用于监听来自客户端应用的连接的 Unix 域套接字目录。通过列出用逗号分隔的多个目录可以建立多个套接字。项之间的空白被忽略，如果你需要在名字中包括空白或逗号，在目录名周围放上双引号。一个空值指定在任何 Unix 域套接字上都不监听，在这种情况中只能使用 TCP/IP 套接字来连接到服务器。默认值通常是<filename>/tmp</filename>，但是在编译时可以被改变。这个参数只能在服务器启动时设置。
       </para>

       <para>
        除了套接字文件本身（名为<literal>.s.PGSQL.<replaceable>nnnn</></literal>，其中<replaceable>nnnn</>是服务器的端口号），一个名为<literal>.s.PGSQL.<replaceable>nnnn</>.lock</literal>的普通文件会在每一个<varname>unix_socket_directories</>目录中被创建。任何一个都不应该被手工移除。
       </para>

       <para>
        Windows下没有 Unix 域套接字，因此这个参数与 Windows 无关。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-unix-socket-group" xreflabel="unix_socket_group">
      <term><varname>unix_socket_group</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>unix_socket_group</>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
       <para>
        设置 Unix 域套接字的所属组（套接字的所属用户总是启动服务器的用户）。可以与选项<varname>unix_socket_permissions</varname>一起用于对 Unix域连接进行访问控制。默认是一个空字符串，表示服务器用户的默认组。这个参数只能在服务器启动时设置。
       </para>

       <para>
        Windows 下没有 Unix 域套接字，因此这个参数与 Windows 无关。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-unix-socket-permissions" xreflabel="unix_socket_permissions">
      <term><varname>unix_socket_permissions</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>unix_socket_permissions</>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
       <para>
        设置 Unix 域套接字的访问权限。Unix 域套接字使用普通的 Unix 文件系统权限集。这个参数值应该是数字的形式，也就是系统调用<function>chmod</function>和<function>umask</function>接受的 形式（如果使用自定义的八进制格式，数字必须以一个<literal>0</literal>（零）开头）。
       </para>

       <para>
        默认的权限是<literal>0777</literal>，意思是任何人都可以连接。合理的候选是<literal>0770</literal>（只有用户和同组的人可以访问， 又见<varname>unix_socket_group</varname>）和<literal>0700</literal>（只有用户自己可以访问）（请注意，对于 Unix 域套接字，只有写权限有麻烦，因此没有对读取和执行权限的设置和收回）。
       </para>

       <para>
        这个访问控制机制与<xref linkend="client-authentication">中的用户认证没有关系。
       </para>

       <para>
        这个参数只能在服务器启动时设置。
       </para>

       <para>
        这个参数与完全忽略套接字权限的系统无关，尤其是自版本10以上的Solaris。
        在那些系统上，可以通过把<varname>unix_socket_directories</>指向一个把搜索权限
        限制给指定用户的目录来实现相似的效果。
        因为 Windows 下没有 Unix 域套接字，因此这个参数也与 Windows 无关。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-bonjour" xreflabel="bonjour">
      <term><varname>bonjour</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>bonjour</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        通过<productname>Bonjour</productname>广告服务器的存在。默认值是关闭。
        这个参数只能在服务器启动时设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-bonjour-name" xreflabel="bonjour_name">
      <term><varname>bonjour_name</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>bonjour_name</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        指定<productname>Bonjour</productname>服务名称。空字符串<literal>''</>（默认值）表示使用计算机名。 如果编译时没有打开<productname>Bonjour</productname>支持那么将忽略这个参数。这个参数只能在服务器启动时设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-tcp-keepalives-idle" xreflabel="tcp_keepalives_idle">
      <term><varname>tcp_keepalives_idle</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>tcp_keepalives_idle</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        指定不活动多少秒之后通过 TCP 向客户端发送一个 keepalive 消息。 0 值表示使用默认值。这个参数只有在支持<symbol>TCP_KEEPIDLE</>或<symbol>TCP_KEEPALIVE</>符号的系统或 Windows 上才可以使用。在其他系统上，它必须为零。在通过 Unix 域套接字连接的会话中，这个参数被忽略并且总是读作零。
       </para>
       <note>
        <para>
         在 Windows 上，值若为 0，系统会将该参数设置为 2 小时，因为 Windows 不支持读取系统默认值。
        </para>
       </note>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-tcp-keepalives-interval" xreflabel="tcp_keepalives_interval">
      <term><varname>tcp_keepalives_interval</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>tcp_keepalives_interval</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        指定在多少秒之后重发一个还没有被客户端告知已收到的 TCP keepalive 消息。0 值表示使用系统默认值。这个参数只有在支持<symbol>TCP_KEEPINTVL</>符号的系统或 Windows 上才可以使用。在其他系统上，必须为零。在通过 Unix域套接字连接的会话中，这个参数被忽略并总被读作零。
       </para>
       <note>
        <para>
         在 Windows 上，值若为 0，系统会将该参数设置为 1 秒，因为 Windows 不支持读取系统默认值。
        </para>
       </note>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-tcp-keepalives-count" xreflabel="tcp_keepalives_count">
      <term><varname>tcp_keepalives_count</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>tcp_keepalives_count</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        指定与客户端的服务器连接被认为死掉之前允许丢失的 TCP keepalive 数量。0 值表示使用系统默认值。这个参数只有在支持<symbol>TCP_KEEPCNT</>符号的系统上才可以使用。在其他系统上，必须为零。在通过 Unix 域套接字连接的会话中，这个参数被忽略并总被读作零。
       </para>
       <note>
        <para>
         Windows 不支持该参数，且必须为零。
        </para>
       </note>
      </listitem>
     </varlistentry>

     </variablelist>
     </sect2>
     <sect2 id="runtime-config-connection-security">
     <title>安全和认证</title>

     <variablelist>
     <varlistentry id="guc-authentication-timeout" xreflabel="authentication_timeout">
      <term><varname>authentication_timeout</varname> (<type>integer</type>)
      <indexterm><primary>timeout</><secondary>client authentication</></indexterm>
      <indexterm><primary>client authentication</><secondary>timeout during</></indexterm>
      <indexterm>
       <primary><varname>authentication_timeout</>配置参数</primary>
      </indexterm></term>

      <listitem>
       <para>
        完成客户端认证的最长时间，以秒计。如果一个客户端没有在这段时间里完成 认证协议，服务器将关闭连接。这样就避免了出问题的客户端无限制地占有一个连接。默认值是 1分钟（<literal>1m</>）。这个参数只能在服务器命令行上或者在<filename>postgresql.conf</>文件中设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ssl" xreflabel="ssl">
      <term><varname>ssl</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>ssl</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        启用<acronym>SSL</>连接。请在使用这个参数之前阅读<xref linkend="ssl-tcp">。默认是<literal>off</>。 这个选项只能在服务器启动时设置。<acronym>SSL</>通信只能和 TCP/IP 连接一起使用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ssl-ca-file" xreflabel="ssl_ca_file">
      <term><varname>ssl_ca_file</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>ssl_ca_file</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        指定包含 SSL 服务器证书颁发机构（CA）的文件名。默认值为空，表示不载入 CA 文件，并且不执行客户端证书验证（在之前的 PostgreSQL 发布中，这个文件的名字被硬编码成<filename>root.crt</filename>）。相对路径是相对于数据目录。这个参数只能在服务器启动时设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ssl-cert-file" xreflabel="ssl_cert_file">
      <term><varname>ssl_cert_file</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>ssl_cert_file</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        指定包含 SSL 服务器证书的文件名。默认值是<filename>server.crt</filename>。相对路径是相对于数据目录的。这个参数只能在服务器启动时设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ssl-crl-file" xreflabel="ssl_crl_file">
      <term><varname>ssl_crl_file</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>ssl_crl_file</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        指定包含 SSL 服务器证书撤销列表（CRL）的文件名。默认值为空，意味着不载入 CRL 文件（在之前的 PostgreSQL 发布中，这个文件的名称被硬编码为<filename>root.crl</filename>）。相对路径是相对于数据目录。这个参数只能在服务器启动时设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ssl-key-file" xreflabel="ssl_key_file">
      <term><varname>ssl_key_file</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>ssl_key_file</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        指定包含 SSL 服务器私钥的文件名。默认值为<filename>server.key</filename>。  相对路径是相对于数据目录。这个参数只能在服务器启动时设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ssl-ciphers" xreflabel="ssl_ciphers">
      <term><varname>ssl_ciphers</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>ssl_ciphers</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        指定一个<acronym>SSL</>密码列表，用于安全连接。这个设置的语法和所支持的值列表可以
        参见<application>OpenSSL</>包中的
        <citerefentry><refentrytitle>ciphers</></citerefentry>手册页。默认值是
        <literal>HIGH:MEDIUM:+3DES:!aNULL</>。它通常是合理的，除非你有特别的安全性需求。
       </para>

       <para>
        默认值的解释：
        <variablelist>
         <varlistentry>
          <term><literal>HIGH</literal></term>
          <listitem>
           <para>
            使用来自<literal>HIGH</>组的密码的密码组（例如 AES, Camellia, 3DES）
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>MEDIUM</literal></term>
          <listitem>
           <para>
            使用来自<literal>MEDIUM</>组的密码的密码组（例如 RC4, SEED）
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>+3DES</literal></term>
          <listitem>
           <para>
            OpenSSL 对<literal>HIGH</>的默认排序是有问题的，因为它认为 3DES 比
            AES128 更高。这是错误的，因为 3DES 提供的安全性比 AES128 低，并且它也更加慢。
            <literal>+3DES</>把它重新排序在所有其他<literal>HIGH</>和
            <literal>MEDIUM</>密码之后。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>!aNULL</literal></term>
          <listitem>
           <para>
            禁用不做认证的匿名密码组。这类密码组容易收到中间人攻击，因此不应被使用。
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>

       <para>
        可用的密码组细节可能会随着 OpenSSL 版本变化。可使用命令
        <literal>openssl ciphers -v 'HIGH:MEDIUM:+3DES:!aNULL'</literal>来查看
        当前安装的<application>OpenSSL</>版本的实际细节。注意这个列表是根据服务器密钥类型
        在运行时过滤过的。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ssl-prefer-server-ciphers" xreflabel="ssl_prefer_server_ciphers">
      <term><varname>ssl_prefer_server_ciphers</varname> (<type>bool</type>)
      <indexterm>
       <primary><varname>ssl_prefer_server_ciphers</>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
       <para>
        指定是否使用服务器的 SSL 密码首选项，而不是用客户端的。默认为真。
       </para>

       <para>
        老的PostgreSQL版本没有这个设置并且总是使用客户端的首选项。这个设置主要用于与那些版本
        的向后兼容性。使用服务器的首选项通常会更好，因为服务器更可能会被合适地配置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ssl-ecdh-curve" xreflabel="ssl_ecdh_curve">
      <term><varname>ssl_ecdh_curve</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>ssl_ecdh_curve</>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
       <para>
        指定用在<acronym>ECDH</>密钥交换中的曲线名称。它需要被所有连接的客户端支持。
        它不需要与服务器椭圆曲线密钥使用的曲线相同。默认值是<literal>prime256v1</>。
       </para>

       <para>
        OpenSSL 命名了最常见的曲线：
        <literal>prime256v1</> (NIST P-256)、
        <literal>secp384r1</> (NIST P-384)、
        <literal>secp521r1</> (NIST P-521)。
       </para>

       <para>
        <command>openssl ecparam -list_curves</command>命令可以显示可用曲线的完
        整列表。不过并不是所有的都在<acronym>TLS</>中可用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-password-encryption" xreflabel="password_encryption">
      <term><varname>password_encryption</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>password_encryption</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        当在<xref linkend="sql-createuser">或<xref linkend="sql-alterrole">中指定了一个密码，而没有写<literal>ENCRYPTED</>或<literal>UNENCRYPTED</>时，这个参数决定是否密码会被加密。默认值是<literal>on</>（加密密码）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-krb-server-keyfile" xreflabel="krb_server_keyfile">
      <term><varname>krb_server_keyfile</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>krb_server_keyfile</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        设置 Kerberos 服务器密钥文件的位置。详见<xref linkend="gssapi-auth">。这个参数只能在 <filename>postgresql.conf</>文件中或服务器命令行上进行设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-krb-caseins-users" xreflabel="krb_caseins_users">
      <term><varname>krb_caseins_users</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>krb_caseins_users</varname>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        设置 Kerberos 和 GSSAPI 用户名是否应区分大小写。默认是<literal>off</>（区分大小写）。这个参数只能在 <filename>postgresql.conf</>文件中或服务器命令行上进行设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-db-user-namespace" xreflabel="db_user_namespace">
      <term><varname>db_user_namespace</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>db_user_namespace</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        允许针对每个数据库的用户名。默认是关闭的。这个参数只能在 <filename>postgresql.conf</>文件中或服务器命令行上进行设置。
       </para>

       <para>
        如果打开这个参数，你应该以<literal>username@dbname</>的方式创建用户。 当一个<literal>username</>被连接着的客户端传递时，<literal>@</>和数据库名被增加到用户名中并且那个数据库相关的用户名会被服务器查找。注意，当你在 SQL 环境里创建包含<literal>@</>的用户名时， 你需要用引号包围用户名。
       </para>

       <para>
        打开这个参数之后，你还是能够创建普通的全局用户。只要在客户端指定用户名时附加一个<literal>@</>，例如<literal>joe@</>。 在服务器查找这个用户名之前，这个<literal>@</>会被剥除。
       </para>

       <para>
        <varname>db_user_namespace</>导致客户端和服务器的用户名表示变得不同。 认证检查总是使用服务器用户名来完成，因此认证方法必须为服务器的用户名配置，而不是客户端的用户名。因为在客户端和服务器上<literal>md5</>都使用用户名作为盐粒，<literal>md5</>不能和<varname>db_user_namespace</>一起使用。
       </para>

       <note>
        <para>
         这个特性只是一种临时方法，直到找到一个完全的解决方案。那个时候， 这个选项将被删除。
        </para>
       </note>
      </listitem>
     </varlistentry>

    </variablelist>
    </sect2>
   </sect1>

   <sect1 id="runtime-config-resource">
    <title>资源消耗</title>

    <sect2 id="runtime-config-resource-memory">
     <title>内存</title>

     <variablelist>
     <varlistentry id="guc-shared-buffers" xreflabel="shared_buffers">
      <term><varname>shared_buffers</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>shared_buffers</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        设置数据库服务器将使用的共享内存缓冲区量。默认通常是 128 兆字节（<literal>128MB</>），但是如果你的内核设置不支持（在<application>initdb</>时决定），那么可以会更少。这个设置必须至少为 128 千字节（<symbol>BLCKSZ</symbol>的非默认值将改变最小值）。不过为了更好的性能，通常会使用明显高于最小值的设置。
       </para>

       <para>
        如果有一个专用的 1GB 或更多内存的数据库服务器，
        一个合理的<varname>shared_buffers</varname>开始值是系统内存的 25%。
        即使很大的<varname>shared_buffers</varname>有效，
        也会造成一些工作负载， 
        但因为<productname>PostgreSQL</productname>同样依赖操作系统的高速缓冲区，
        将<varname>shared_buffers</varname>设置为超过 40% 
        的RAM不太可能比一个小点值工作得更好。
        为了能把对写大量新的或改变的数据的处理分布在一个较长的时间段内，
        <varname>shared_buffers</varname>更大的
        设置通常要求对<varname>max_wal_size</varname>也做相应增加。
       </para>

       <para>
        如果系统内存小于 1GB，一个较小的 RAM 百分数是合适的，这样可以为操作系统留下足够的空间。 同时，在 Windows 上，<varname>shared_buffers</varname>设置得较大也不一定有效。你会发现保持相对低的设置并且更多使用操作系统高速缓存会得到更好的结果。Windows 上可用的<varname>shared_buffers</varname>值通常是从 64MB 到 512 MB。
       </para>

      </listitem>
     </varlistentry>

     <varlistentry id="guc-huge-pages" xreflabel="huge_pages">
      <term><varname>huge_pages</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>huge_pages</>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
       <para>
        启用/禁用巨型内存页面的使用。可用的值是
        <literal>try</literal>（默认）、<literal>on</literal>、
        和<literal>off</literal>。
       </para>

       <para>
        当前，只有 Linux 上支持这个特性。在其他系统上这个参数被设置为
        <literal>try</literal>时，它会被忽略。
       </para>

       <para>
        巨型页面的使用会导致更小的页面表以及花费在内存管理上的 CPU 时间更少，从而提高性能。
        详见<xref linkend="linux-huge-pages">。
       </para>

       <para>
        当<varname>huge_pages</varname>被设置为<literal>try</literal>时，服务器将
        尝试使用巨型页面，如果失败则会转回去使用正常的分配。如果设置为
        <literal>on</literal>，使用巨型页面失败会阻止服务器启动。如果设置为
        <literal>off</literal>，则不会使用巨型页面。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-temp-buffers" xreflabel="temp_buffers">
      <term><varname>temp_buffers</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>temp_buffers</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        设置每个数据库会话使用的临时缓冲区的最大数目。这些都是会话的本地缓冲区，只用于访问临时表。默认是 8 兆字节（<literal>8MB</>）。这个设置可以在独立的会话内部被改变，但是只有在会话第一次使用临时表之前才能改变； 在会话中随后企图改变该值是无效的。
       </para>

       <para>
        一个会话将按照<varname>temp_buffers</>给出的限制根据需要分配临时缓冲区。如果在一个并不需要大量临时缓冲区的会话里设置一个大的数值， 其开销只是一个缓冲区描述符，或者说<varname>temp_buffers</>每增加一则增加大概 64 字节。不过，如果一个缓冲区被实际使用，那么它就会额外消耗 8192 字节（或者<symbol>BLCKSZ</symbol>字节）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-prepared-transactions" xreflabel="max_prepared_transactions">
      <term><varname>max_prepared_transactions</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_prepared_transactions</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        设置可以同时处于<quote>prepared</>状态的事务的最大数目（见<xref linkend="sql-prepare-transaction">）。把这个参数设置 为零（这是默认设置）将禁用预备事务特性。这个参数只能在服务器启动时设置。
       </para>

       <para>
        如果你不打算使用预备事务，可以把这个参数设置为零来防止意外创建预备事务。如果你正在使用预备事务，你将希望把<varname>max_prepared_transactions</varname>至少设置为<xref linkend="guc-max-connections">一样大，因此每一个会话可以有一个预备事务待处理。
       </para>

       <para>
        当运行一个后备服务器时，这个参数必须至少与主服务器上的一样大。否则，后备服务器上将不会执行查询。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-work-mem" xreflabel="work_mem">
      <term><varname>work_mem</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>work_mem</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        指定在写到临时磁盘文件之前被内部排序操作和哈希表使用的内存量。该值默认为四兆字节（<literal>4MB</>）。注意对于一个复杂查询， 可能会并行运行好几个排序或者哈希操作；每个操作都会被允许使用这个参数指定的内存量，然后才会开始写数据到临时文件。同样，几个正在运行的会话可能并发进行这样的操作。因此被使用的总内存可能是<varname>work_mem</varname>值的好几倍，在选择这个值时一定要记住这一点。<literal>ORDER BY</>、<literal>DISTINCT</>和归并连接都要用到排序操作。哈希连接、基于哈希的聚集以及基于哈希的<literal>IN</>子查询处理中都要用到哈希表。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-maintenance-work-mem" xreflabel="maintenance_work_mem">
      <term><varname>maintenance_work_mem</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>maintenance_work_mem</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        指定在维护性操作（例如<command>VACUUM</command>、<command>CREATE INDEX</>和<command>ALTER TABLE ADD FOREIGN KEY</>）中使用的 最大的内存量。其默认值是 64 兆字节（<literal>64MB</>）。因为在一个数据库会话中，一个时刻只有一个这样的操作可以被执行，并且一个数据库安装通常不会有太多这样的操作并发执行， 把这个数值设置得比<varname>work_mem</varname>大很多是安全的。 更大的设置可以改进清理和恢复数据库转储的性能。
       </para>
       <para>
        注意当自动清理运行时，可能会分配这个内存的<xref linkend="guc-autovacuum-max-workers">倍，因此要小心不要把该默认值设置得太高。
       </para>
       <para>
        注意当自动清理运行时，可能会分配最多达这个内存的<xref linkend="guc-autovacuum-max-workers">倍，因此要小心不要把该默认值设置得太高。
        通过独立地设置<xref linkend="guc-autovacuum-work-mem">可能会对控制这种情况
        有所帮助。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-autovacuum-work-mem" xreflabel="autovacuum_work_mem">
      <term><varname>autovacuum_work_mem</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>autovacuum_work_mem</>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
       <para>
        指定每个自动清理工作者进程能使用的最大内存量。其默认值为 -1，表示转而使用
        <xref linkend="guc-maintenance-work-mem">的值。当运行在其他上下文环境中时，
        这个设置对<command>VACUUM</command>的行为没有影响。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-stack-depth" xreflabel="max_stack_depth">
      <term><varname>max_stack_depth</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_stack_depth</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        指定服务器的执行堆栈的最大安全深度。这个参数的理想设置是由内核强制的实际栈尺寸限制（<literal>ulimit -s</>所设置的或者本地等价物），减去大约一兆字节的安全边缘。需要这个安全边缘是因为在服务器中并非所有例程都检查栈深度，只是在关键的可能递规的例程（例如表达式计算）中才进行检查。默认设置是两兆字节（<literal>2MB</>），这个值相对比较小并且不可能导致崩溃。但是，这个值可能太小了，以至于无法执行复杂的函数。只有超级用户可以修改这个设置。
       </para>

       <para>
        把<varname>max_stack_depth</>参数设置得高于实际的内核限制将意味着一个失控的递归函数可能会导致一个独立的后端进程崩溃。 在<productname>PostgreSQL</productname>能够检测内核限制的平台上， 服务器将不允许把这个参数设置为一个不安全的值。不过，并非所有平台都能提供该信息，所以我们还是建议你在选择值时要小心。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-dynamic-shared-memory-type" xreflabel="dynamic_shared_memory_type">
      <term><varname>dynamic_shared_memory_type</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>dynamic_shared_memory_type</>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
       <para>
        指定服务器应该使用的动态共享内存实现。可能的值是<literal>posix</>（用于使用
        <literal>shm_open</>分配的 POSIX 共享内存）、<literal>sysv</literal>
        （用于通过<literal>shmget</>分配的 System V 共享内存）、
        <literal>windows</>（用于 Windows 共享内存）、<literal>mmap</>
        （使用存储在数据目录中的内存映射文件模拟共享内存）以及<literal>none</>（禁用
        这个特性）。并非所有平台上都支持所有值，平台上第一个支持的选项就是其默认值。
        在任何平台上<literal>mmap</>选项都不是默认值，通常不鼓励使用它，因为操作系统会
        反复地把修改过的页面写回到磁盘上，从而增加了系统的I/O负载。不过当
        <literal>pg_dynshmem</>目录被存储在一个 RAM 盘时或者没有其他共享内存功能可用时，
        它还是有用的。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
     </sect2>

     <sect2 id="runtime-config-resource-disk">
     <title>磁盘</title>

     <variablelist>
     <varlistentry id="guc-temp-file-limit" xreflabel="temp_file_limit">
      <term><varname>temp_file_limit</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>temp_file_limit</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        指定一个会话能用于临时文件（如排序和哈希临时文件，或者用于保持游标的存储文件）的最大磁盘空间量。一个试图超过这个限制的事务将被取消。这个值以千字节计，并且<literal>-1</>（默认值）意味着没有限制。只有超级用户能够修改这个设置。
       </para>
       <para>
        这个设置约束着一个给定<productname>PostgreSQL</>会话在任何瞬间所使用的所有临时文件的总空间。应该注意的是，与在查询执行中在幕后使用的临时文件相反，显式临时表所用的磁盘空间<emphasis>不</emphasis>被这个设置所限制。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
     </sect2>

     <sect2 id="runtime-config-resource-kernel">
     <title>内核资源使用</title>

     <variablelist>
     <varlistentry id="guc-max-files-per-process" xreflabel="max_files_per_process">
      <term><varname>max_files_per_process</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_files_per_process</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        设置每个服务器子进程允许同时打开的最大文件数目。默认是 1000 个文件。如果内核强制一个安全的针对每个进程的限制，那么你不用操心这个设置。但是在 一些平台上（特别是大多数 BSD 系统），如果很多进程都尝试打开很多文件，内核将允许独立进程打开比个系统真正可以支持的数目大得多得文件数。如果你发现自己看到了<quote>Too many open files</>这样的失败，可尝试减小这个设置。这个参数只能在服务器启动时设置。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect2>

    <sect2 id="runtime-config-resource-vacuum-cost">
     <title>基于代价的清理延迟</title>

     <para>
      在<xref linkend="sql-vacuum">和<xref linkend="sql-analyze">命令的执行过程中，系统维持着一个内部计数器来跟踪各种被执行的I/O操作的估算开销。当累计的代价达到一个限制（由<varname>vacuum_cost_limit</varname>指定），执行这些操作的进程将按照<varname>vacuum_cost_delay</varname>所指定的休眠一小段时间。然后它将重置计数器并继续执行。
     </para>

     <para>
      这个特性的出发点是允许管理员降低这些命令对并发的数据库活动产生的I/O影响。在很多情况下，<command>VACUUM</command>和<command>ANALYZE</command>等维护命令能否快速完成并不重要，而非常重要的是这些命令不会对系统执行其他数据库操作的能力产生显著的影响。基于代价的清理延迟提供了一种方式让管理员能够保证这一点。
     </para>

     <para>
      对于手动发出的<command>VACUUM</command>命令，该特性默认被禁用。要启用它，只要把<varname>vacuum_cost_delay</varname>变量设为一个非零值。
     </para>

     <variablelist>
      <varlistentry id="guc-vacuum-cost-delay" xreflabel="vacuum_cost_delay">
       <term><varname>vacuum_cost_delay</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>vacuum_cost_delay</>配置参数</primary>
       </indexterm></term>
       <listitem>
        <para>
         进程超过代价限制后将休眠的时间长度，以毫秒计。其默认值为0，这将禁用基于代价的清理延迟特性。正值将启用基于代价的清理。注意在很多系统上，实际的休眠延迟单位是10毫秒，将<varname>vacuum_cost_delay</varname>设置成不为10的倍数的值和将它设置为比该值大的10的倍数的效果相同。
        </para>

        <para>
         在使用基于代价的清理时，<varname>vacuum_cost_delay</>的合适值通常很小，也许是10或20毫秒。调整清理时资源消耗最好的方法是调整其他清理代价参数。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-vacuum-cost-page-hit" xreflabel="vacuum_cost_page_hit">
       <term><varname>vacuum_cost_page_hit</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>vacuum_cost_page_hit</>配置参数</primary>
       </indexterm></term>
       <listitem>
        <para>
         清理一个在共享缓存中找到的缓冲区的估计代价。它表示锁住缓冲池、查找共享哈希表和扫描页内容的代价。默认值为1。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-vacuum-cost-page-miss" xreflabel="vacuum_cost_page_miss">
       <term><varname>vacuum_cost_page_miss</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>vacuum_cost_page_miss</>配置参数</primary>
       </indexterm></term>
       <listitem>
        <para>
         清理一个必须从磁盘上读取的缓冲区的代价。它表示锁住缓冲池、查找共享哈希表、从磁盘读取需要的块以及扫描其内容的代价。默认值为10。        </para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-vacuum-cost-page-dirty" xreflabel="vacuum_cost_page_dirty">
       <term><varname>vacuum_cost_page_dirty</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>vacuum_cost_page_dirty</>配置参数</primary>
       </indexterm></term>
       <listitem>
        <para>
         当清理修改一个之前干净的块时需要花费的估计代价。它表示再次把脏块刷出到磁盘所需要的额外I/O。默认值为20。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-vacuum-cost-limit" xreflabel="vacuum_cost_limit">
       <term><varname>vacuum_cost_limit</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>vacuum_cost_limit</>配置参数</primary>
       </indexterm></term>
       <listitem>
        <para>
         将导致清理进程休眠的累计代价。默认值为200。
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     <note>
      <para>
       有些操作会保持关键性的锁，这样可以尽快完成。基于代价的清理延迟在这类操作期间不会发生。因此有可能代价会累计至大大超过指定的限制。为了防止在这种情况下的无意义的长时间延迟，实际延迟的计算方式是<varname>vacuum_cost_delay</varname> *
       <varname>accumulated_balance</varname> /
       <varname>vacuum_cost_limit</varname>，且最大值是<varname>vacuum_cost_delay</varname> * 4。
      </para>
     </note>
    </sect2>

    <sect2 id="runtime-config-resource-background-writer">
     <title>后台写入器</title>

     <para>
      有一个独立的服务器进程，叫做<firstterm>后台写入器</>，它的功能就是发出写<quote>脏</>（新的或修改过的）共享缓冲区的命令。它写出共享缓冲区，这样让处理用户查询的服务器进程很少或者永不等待写动作的发生。不过，后台写入器确实会增加 I/O 的总负荷，因为虽然在每个检查点间隔中一个重复弄脏的页面可能只会写出一次，但在同一个间隔中后台写入器可能会把它写出好几次。在这一小节讨论的参数可以被用于调节本地需求的行为。
     </para>

     <variablelist>
      <varlistentry id="guc-bgwriter-delay" xreflabel="bgwriter_delay">
       <term><varname>bgwriter_delay</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>bgwriter_delay</>配置参数</primary>
       </indexterm></term>
       <listitem>
        <para>
         指定后台写入器活动轮次之间的延迟。在每个轮次中，写入器都会为一定数量的脏缓冲区发出写操作（可以用下面的参数控制）。然后它就休眠 <varname>bgwriter_delay</>毫秒， 然后重复动作。默认值是 200 毫秒（<literal>200ms</>）。注意在许多系统上，休眠延迟的有效解析度是 10 毫秒；因此，为<varname>bgwriter_delay</>设置一个 不是 10 的倍数的值与把它设置为下一个更高的 10 的倍数是一样的效果。这个选项只能在服务器命令行上或者在<filename>postgresql.conf</>文件中设置。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-bgwriter-lru-maxpages" xreflabel="bgwriter_lru_maxpages">
       <term><varname>bgwriter_lru_maxpages</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>bgwriter_lru_maxpages</>配置参数</primary>
       </indexterm></term>
       <listitem>
        <para>
         在每个轮次中，不超过这么多个缓冲区将被后台写入器写出。把这个参数设置为零可禁用后台写出（注意被一个独立、专用辅助进程管理的检查点不受影响）。默认值是 100 个缓冲区。这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-bgwriter-lru-multiplier" xreflabel="bgwriter_lru_multiplier">
       <term><varname>bgwriter_lru_multiplier</varname> (<type>floating point</type>)
       <indexterm>
        <primary><varname>bgwriter_lru_multiplier</>配置参数</primary>
       </indexterm></term>
       <listitem>
        <para>
         每一轮次要写的脏缓冲区的数目基于最近几个轮次中服务器进程需要的新缓冲区的数目。 最近所需的平均值乘以<varname>bgwriter_lru_multiplier</>可以估算下一轮次中将会需要的缓冲区数目。脏缓冲区将被写出直到有很多干净可重用的缓冲区（然而，每一轮次中写出的缓冲区数不超过<varname>bgwriter_lru_maxpages</>）。 因此，设置为 1.0 表示一种<quote>刚刚好的</>策略，这种策略会写出正好符合预测值的数目的缓冲区。 更大大的值可以为需求高峰提供某种缓冲，而更小的值则需要服务进程来处理一些写出操作。默认值是 2.0。这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     <para>
      较小的<varname>bgwriter_lru_maxpages</varname>和<varname>bgwriter_lru_multiplier</varname>可以降低由后台写入器造成的额外 I/O 开销。但更可能的是，服务器进程将必须自己发出写入操作，这会延迟交互式查询。
     </para>
    </sect2>

    <sect2 id="runtime-config-resource-async-behavior">
     <title>异步行为</title>

     <variablelist>
      <varlistentry id="guc-effective-io-concurrency" xreflabel="effective_io_concurrency">
       <term><varname>effective_io_concurrency</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>effective_io_concurrency</>配置参数</primary>
       </indexterm></term>
       <listitem>
        <para>
         设置<productname>PostgreSQL</>可以同时被执行的并发磁盘 I/O 操作的数量。调高这个值，可以增加任何单个<productname>PostgreSQL</>会话试图并行发起的 I/O 操作的数目。 允许的范围是 1 到 1000，或 0 表示禁用异步 I/O 请求。当前这个设置仅影响位图堆扫描。
        </para>

        <para>
         这个设置的一个很好的出发点是组成一个被用于该数据库的 RAID 0 条带或 RAID 1 镜像的独立驱动器数量（对 RAID 5 而言，校验驱动器不计入）。但是， 如果数据库经常忙于在并发会话中发出的多个查询，较低的值可能足以使磁盘阵列繁忙。比保持磁盘繁忙所需的值更高的值只会造成额外的 CPU 开销。
        </para>

        <para>
         对更特殊的系统（如，基于内存的存储或受限于总线带宽的RAID阵列）来说，正确的值可能是可用的 I/O 路径数。需要一些实验来找出最佳值。
        </para>

        <para>
         异步 I/O 依赖于一个有效的<function>posix_fadvise</>函数（一些操作系统可能没有）。 如果不存在这个函数，将这个参数设置为除 0 之外的任何东西将导致错误。在一些操作系统上（如Solaris）虽然提供了这个函数，但它不会做任何事情。
        </para>
        
        <para>
         支持的系统上缺省为1，否则为0。
        </para>
          
       </listitem>
      </varlistentry>

      <varlistentry id="guc-max-worker-processes" xreflabel="max_worker_processes">
       <term><varname>max_worker_processes</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>max_worker_processes</>配置参数</primary>
       </indexterm>
       </term>
       <listitem>
        <para>
         设置系统能够支持的后台进程的最大数量。这个参数只能在服务器启动时设置。
        </para>

        <para>
         在运行一个后备服务器时，你必须把这个参数设置为等于或者高于主控服务器上的值。否则，
         后备服务器上可能不会允许查询。
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </sect2>
   </sect1>

   <sect1 id="runtime-config-wal">
    <title>预写式日志</title>

   <para>
    参阅<xref linkend="wal-configuration">获取调节这些设置的额外信息。
   </para>

    <sect2 id="runtime-config-wal-settings">
     <title>设置</title>
     <variablelist>

     <varlistentry id="guc-wal-level" xreflabel="wal_level">
      <term><varname>wal_level</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>wal_level</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        <varname>wal_level</>决定多少信息写入到 WAL 中。默认值是<literal>minimal</>， 只写入从崩溃或立即关机恢复所需要的信息。<literal>archive</>添加 WAL 归档所需要的日志。 <literal>hot_standby</>则进一步增加在一个后备服务器上运行只读查询所需的信息。
        最后，<literal>logical</>会增加支持逻辑解码所需的信息。每个层次包括所有更低层次
        记录的信息。这个参数只能在服务器启动时设置。
       </para>
       <para>
        在<literal>minimal</>级别中，某些批量操作的 WAL 日志可以被安全地跳过，这可以使那些操作更快（见<xref linkend="populate-pitr">）。这种优化可以应用的操作包括：
        <simplelist>
         <member><command>CREATE TABLE AS</></member>
         <member><command>CREATE INDEX</></member>
         <member><command>CLUSTER</></member>
         <member><command>COPY</>到在同一个事务中被创建或截断的表中</member>
        </simplelist>
        但最少的 WAL 不会包括足够的信息来从基础备份和 WAL 日志中重建数据，因此，要启用 WAL 归档（<xref linkend="guc-archive-mode">）和流复制，必须使用<literal>archive</>或更高级别。
       </para>
       <para>
        在<literal>hot_standby</>级别，日志记录的信息和<literal>archive</>相同，外加从 WAL 重建运行事务状态所需的信息。为了在一个后备服务器上启用只读查询，主服务器上的<varname>wal_level</>必须设置为<literal>hot_standby</>或更高级别， 并且后备服务器上必须启用<xref linkend="guc-hot-standby">。这是因为使用<literal>hot_standby</>和<literal>archive</>级别在性能方面存在微小的差异，因此如果任何生产影响很显著，那么欢迎反馈。
       </para>
       <para>
        在<literal>logical</>层，与<literal>hot_standby</>相同的信息会被记录，外加上
        允许从 WAL 抽取逻辑修改集所需的信息。使用级别
        <literal>logical</>将增加 WAL 容量，特别是如果为了<literal>REPLICA IDENTITY FULL</literal>配置了很多表并且执行了很多<command>UPDATE</>和<command>DELETE</>
        语句时。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-fsync" xreflabel="fsync">
      <term><varname>fsync</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>fsync</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        如果打开这个参数，<productname>PostgreSQL</>服务器将尝试确保更新被物理地写入到磁盘，做法是发出<function>fsync()</>系统调用或者使用多种等价的方法（见<xref linkend="guc-wal-sync-method">）。这保证了数据库集簇在一次操作系统或者硬件崩溃后能恢复到一个一致的状态。
       </para>

       <para>
        虽然关闭<varname>fsync</varname>常常可以得到性能上的收益，但当发生断电或系统崩溃时可能造成不可恢复的数据损坏。因此，只有在能很容易地从外部数据中重建整个数据库时才建议关闭<varname>fsync</varname>。
       </para>

       <para>
        能安全关闭<varname>fsync</varname>的环境的例子包括从一个备份文件中初始加载一个新数据库集簇、使用一个数据库集簇来在数据库被删掉并重建之后处理一批数据，或者一个被经常重建并却不用于失效备援的只读数据库克隆。单独的高质量硬件不足以成为关闭<varname>fsync</varname>的理由。
       </para>

       <para>
        当把<varname>fsync</varname>从关闭改成打开时，为了可靠的恢复，需要强制在内核中的所有被修改的缓冲区进入持久化存储。这可以在多个时机来完成：在集簇被关闭时或在 fsync 因为运行<command>initdb --sync-only</command>而打开时、运行<command>sync</>时、卸载文件系统时或者重启服务器时。
       </para>

       <para>
        在很多情况下，为不重要的事务关闭<xref linkend="guc-synchronous-commit">可以提供很多关闭<varname>fsync</varname>的潜在性能收益，并不会有的同时， 关闭fsync可以提供很多潜在的性能优势，而不会有伴随着的数据损坏风险。
       </para>

       <para>
        <varname>fsync</varname>只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。如果你关闭这个参数，请也考虑关闭<xref linkend="guc-full-page-writes">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-synchronous-commit" xreflabel="synchronous_commit">
      <term><varname>synchronous_commit</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>synchronous_commit</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        指定在命令返回<quote>success</>指示给客户端之前，一个事务是否需要等待 WAL 记录被写入磁盘。合法的值是<literal>on</>、<literal>remote_write</>、<literal>local</>和<literal>off</>。默认的并且安全的设置是<literal>on</>。当设置为<literal>off</>时，在向客户端报告成功和真正保证事务不会被服务器崩溃威胁之间会有延迟（最大的延迟是<xref linkend="guc-wal-writer-delay">的三倍）。不同于<xref linkend="guc-fsync">，将这个参数设置为<literal>off</>不会产生数据库不一致性的风险：一个操作系统或数据库崩溃可能会造成一些最近据说已提交的事务丢失，但数据库状态是一致的，就像这些事务已经被干净地中止。因此，当性能比完全确保事务的持久性更重要时，关闭<varname>synchronous_commit</>可以作为一个有效的代替手段。更多讨论见<xref linkend="wal-async-commit">。
       </para>
       <para>
        如果<xref linkend="guc-synchronous-standby-names">被设置，这个参数也控制事务提交是否将等待事务的 WAL 记录被复制到后备服务器上。当这个参数被设置为<literal>on</>时，直到来自于当前同步的后备服务器的一个回复指示该后备服务器已经收到了事务的提交记录并将其刷入了磁盘，主服务器上的事务才会提交。这保证事务将不会被丢失，除非主服务器和后备服务器都遭受到了数据库存储损坏的问题。当这个参数被设置为<literal>remote_write</>时，提交将等待，直到来自当前同步的后备服务器的一个回复指示该服务器已经收到了该事务的提交记录并且已经把该记录写出到后备服务器的操作系统，但是该数据并不一定到达了后备服务器上的稳定存储。这种设置足以保证数据在后备服务器的<productname>PostgreSQL</>实例崩溃时得以保存，但是不能保证后备服务器遭受操作系统级别崩溃时数据能被保持。
       </para>
       <para>
        当使用同步复制时，它将对等待本地刷写磁盘和 WAL 记录复制很敏感，或者对允许事务异步提交很敏感。不过，设置<literal>local</>可以用于希望等待本地刷写磁盘但不等待同步复制的事务。如果没有设置<varname>synchronous_standby_names</>，设置<literal>on</>、<literal>remote_write</>和<literal>local</>都提供了同样的同步级别：事务提交只等待本地刷写磁盘。
       </para>
       <para>
        这个参数可以随时被修改；任何一个事务的行为由其提交时生效的设置决定。因此，可以同步提交一些事务，同时异步提交其他事务。例如，当默认是相反时，实现一个单一多语句事务的异步提交，在事务中发出<command>SET LOCAL synchronous_commit TO OFF</>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-sync-method" xreflabel="wal_sync_method">
      <term><varname>wal_sync_method</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>wal_sync_method</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        用来向强制 WAL 更新到磁盘的方法。如果<varname>fsync</varname>是关闭的，那么这个设置就不相关，因为 WAL 文件更新将根本不会被强制。可能的值是：
       </para>
       <itemizedlist>
        <listitem>
        <para>
         <literal>open_datasync</>（用<function>open()</>选项<symbol>O_DSYNC</>写 WAL 文件）
        </para>
        </listitem>
        <listitem>
        <para>
         <literal>fdatasync</>（在每次提交时调用<function>fdatasync()</>）
        </para>
        </listitem>
        <listitem>
        <para>
         <literal>fsync</>（在每次提交时调用<function>fsync()</>）
        </para>
        </listitem>
        <listitem>
        <para>
         <literal>fsync_writethrough</>（在每次提交时调用<function>fsync()</>，强制任何磁盘写高速缓存的直通写）
        </para>
        </listitem>
        <listitem>
        <para>
         <literal>open_sync</>（用<function>open()</>选项<symbol>O_SYNC</>写 WAL 文件）
        </para>
        </listitem>
       </itemizedlist>
       <para>
        <literal>open_</>* 选项也可以使用<literal>O_DIRECT</>（如果可用）。不是在所有平台上都能使用所有这些选择。默认值是列表中第一个被平台支持的那个， 不过<literal>fdatasync</>是 Linux 中的默认值。默认值不一定是最理想的；有可能需要修改这个设置或系统配置的其他方面来创建一个崩溃-安全的配置，或达到最佳性能。这些方面在<xref linkend="wal-reliability">中讨论。这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-full-page-writes" xreflabel="full_page_writes">
      <term><varname>full_page_writes</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>full_page_writes</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        当这个参数为打开时，<productname>PostgreSQL</>服务器在一个检查点之后的页面的第一次修改期间将每个页面的全部内容写到  WAL 中。这么做是因为在操作系统崩溃期间正在处理的一次页写入可能只有部分完成，从而导致在一个磁盘页面中混合有新旧数据。在崩溃后的恢复期间，通常存储在 WAL 中的行级改变数据不足以完全恢复这样一个页面。存储完整的页面映像可以保证页面被正确存储，但代价是增加了必须被写入 WAL 的数据量（因为 WAL 重放总是从一个检查点开始，所以在检查点后每个页面的第一次改变时这样做就够了。因此，一种减小全页面写开销的方法是增加检查点间隔参数值）。
       </para>

       <para>
        把这个参数关闭会加快正常操作，但是在系统失败后可能导致不可恢复的数据损坏，或者静默的数据损坏。其风险类似于关闭<varname>fsync</varname>， 但是风险较小。并且只有在可关闭<varname>fsync</varname>的情况下才应该关闭它。
       </para>

       <para>
        关闭这个选项并不影响用于时间点恢复（PITR）的 WAL 归档使用（见<xref linkend="continuous-archiving">）。
       </para>

       <para>
        这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。默认值是<literal>on</>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-log-hints" xreflabel="wal_log_hints">
      <term><varname>wal_log_hints</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>wal_log_hints</>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
       <para>
        当这个参数为<literal>on</>时，<productname>PostgreSQL</>服务器一个检查点之后页面被第一次修改期间把该磁盘页面的整个内容都写入 WAL，即使对所谓的提示位做非关键修改也会这样做。
       </para>

       <para>
        如果启用了数据校验和，提示位更新总是会被 WAL 记录并且这个设置会被忽略。你可以使用这个
        设置测试如果你的数据库启用了数据校验和，会有多少额外的 WAL 记录发生。
       </para>

       <para>
        这个参数只能在服务器启动时设置。默认值是<literal>off</>。
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry id="guc-wal-compression" xreflabel="wal_compression">
      <term><varname>wal_compression</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>wal_compression</>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
       <para>
        当这个参数为<literal>on</>，
        <xref linkend="guc-full-page-writes">为on，或者基础备份中，
        <productname>PostgreSQL</>服务器压缩完整页面图片到WAL中。
        在WAL回放中解压压缩的页面图片。缺省值为<literal>off</>。
        只有超级用户可以修改这个设置。 
       </para>

       <para>
       开启这个参数可以减少WAL量而不增加不可恢复数据丢失的风险，
       但是增加了WAL日志压缩以及WAL回放解压过程中一些额外CPU成本开销。
       </para>
      </listitem>
     </varlistentry>
     

     <varlistentry id="guc-wal-buffers" xreflabel="wal_buffers">
      <term><varname>wal_buffers</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>wal_buffers</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        用于还未写入磁盘的 WAL 数据的共享内存量。默认值 -1 选择等于<xref linkend="guc-shared-buffers">的 1/32 的尺寸（大约3%），但是不小于<literal>64kB</literal>也不大于 WAL 段的尺寸（通常为）。如果自动的选择太大或太小可以手工设置该值，但是任何小于<literal>32kB</literal>的正值都将被当作<literal>32kB</literal>。这个参数只能在服务器启动时设置。
       </para>

       <para>
        在每次事务提交时，WAL 缓冲区的内容被写出到磁盘，因此极大的值不可能提供显著的收益。不过，把这个值设置为几个兆字节可以在一个繁忙的服务器（其中很多客户端会在同一时间提交）上提高写性能。由默认设置 -1 选择的自动调节将在大部分情况下得到合理的结果。
       </para>

      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-writer-delay" xreflabel="wal_writer_delay">
      <term><varname>wal_writer_delay</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>wal_writer_delay</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        指定 WAL 写入器的活动轮次之间的延迟。在每个轮次中写入器会将 WAL 刷到磁盘。之后，休眠<varname>wal_writer_delay</>毫秒，然后重复。默认值是 200 毫秒（<literal>200ms</>）。需要注意的是，在许多系统上，有效的休眠延迟解析度是 10 毫秒；将<varname>wal_writer_delay</>设置为不是 10 的倍数将得到把它设置为下一个 10 的倍数同样的效果。这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-commit-delay" xreflabel="commit_delay">
      <term><varname>commit_delay</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>commit_delay</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        在一次 WAL 刷写被发起之前，<varname>commit_delay</varname>增加一个时间延迟，以微妙计。如果系统负载足够高，使得在一个给定间隔内有额外的事务准备好提交，那么通过允许更多事务通过一个单次 WAL 刷写来提交能够提高组提交的吞吐量。但是，它也把每次 WAL 刷写的潜伏期增加到了最多<varname>commit_delay</varname>微秒。因为如果没有其他事务准备好提交，就会浪费一次延迟，只有在当一次刷写将要被发起时有至少<varname>commit_siblings</varname>个其他活动事务时，才会执行一次延迟。另外，如果<varname>fsync</varname>被禁用，则将不会执行任何延迟。默认的<varname>commit_delay</>是零（无延迟）。只有超级用户才能修改这个设置。
       </para>
       <para>
        在<productname>PostgreSQL</>的 9.3 发布之前，<varname>commit_delay</varname>的行为不同并且效果更差：它只影响提交，而不是所有 WAL 刷写，并且即使在 WAL 刷写马上就要完成时也会等待一整个配置的延迟。从<productname>PostgreSQL</> 9.3 中开始，第一个准备好刷写的进程会等待配置的间隔，而后续的进程只等到领先者完成刷写操作。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-commit-siblings" xreflabel="commit_siblings">
      <term><varname>commit_siblings</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>commit_siblings</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        在执行<varname>commit_delay</>延迟时，要求的并发活动事务的最小数目。大一些的值会导致在延迟间隔期间更可能有至少另外一个事务准备好提交。默认值是五个事务。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
     </sect2>
     <sect2 id="runtime-config-wal-checkpoints">
     <title>检查点</title>
     
     <varlistentry id="guc-checkpoint-timeout" xreflabel="checkpoint_timeout">
      <term><varname>checkpoint_timeout</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>checkpoint_timeout</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        自动 WAL 检查点之间的最长时间，以秒计。
        有效值在30秒和1小时之间。
        默认是 5 分钟（<literal>5min</>）。
        增加这个参数的值会增加崩溃恢复所需的时间。
        这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-checkpoint-completion-target" xreflabel="checkpoint_completion_target">
      <term><varname>checkpoint_completion_target</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>checkpoint_completion_target</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        指定检查点完成的目标，作为检查点之间总时间的一部分。默认是 0.5。

        这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-checkpoint-warning" xreflabel="checkpoint_warning">
      <term><varname>checkpoint_warning</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>checkpoint_warning</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        如果由于填充检查点段文件导致的检查点之间的间隔低于这个参数表示的秒数，那么就向服务器日志写一个消息（它建议增加<varname>max_wal_size</>的值）。默认值是 30 秒（<literal>30s</>）。零则关闭警告。如果<varname>checkpoint_timeout</varname>低于<varname>checkpoint_warning</varname>，则不会有警告产生。这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-wal-size" xreflabel="max_wal_size">
      <term><varname>max_wal_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_wal_size</>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
       <para>
        在自动WAL检查点使得WAL增长到最大尺寸。这是软限制；特殊情况下WAL大小可以超过
        <varname>max_wal_size</>，如重负载下，错误<varname>archive_command</>，或者
        较大<varname>wal_keep_segments</>的设置。缺省是1GB。
        增加这个参数会延长崩溃恢复所需要的时间。
        这个参数只能在<filename>postgresql.conf</>文件或者服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-min-wal-size" xreflabel="min_wal_size">
      <term><varname>min_wal_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>min_wal_size</>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
       <para>
        只要WAL磁盘使用率低于这个设置，旧的WAL文件总数被回收，以供将来检查点使用。而不是删除。
        这可以用来确保预留足够的WAL空间处理WAL使用中的峰值，比如当运行大批量工作时。
        缺省是80MB。这个参数只能在<filename>postgresql.conf</>文件或者
        服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     
     
     </variablelist>
     </sect2>
     <sect2 id="runtime-config-wal-archiving">
     <title>归档</title>

    <variablelist>
     <varlistentry id="guc-archive-mode" xreflabel="archive_mode">
      <term><varname>archive_mode</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>archive_mode</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        当启用<varname>archive_mode</>时，
        可以通过设置<xref linkend="guc-archive-command">命令将完成的 
        WAL段发送到归档存储。
        除了<literal>off</>，要禁用两种模式<literal>on</>和
        <literal>always</>。在正常操作过程中，两种模式没有区别，但是
        当设置为<literal>always</>时，归档恢复或者待机模式中激活WAL归档。
        在<literal>always</>模式中，
        从归档中恢复所有文件或者再次归档使用流复制传输的文件。
        参阅<xref linkend="continuous-archiving-in-standby">获取详情。
       
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-archive-command" xreflabel="archive_command">
      <term><varname>archive_command</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>archive_command</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        本地 shell 命令被执行来归档一个完成的 WAL 文件段。字符串中的任何<literal>%p</>被替换成要被归档的文件的路径名， 而<literal>%f</>只被文件名替换（路径名是相对于服务器的工作目录， 即集簇的数据目录）。如果要在命令里嵌入一个真正的<literal>%</>字符，可以使用<literal>%%</>。有一点很重要，该命令只在成功时返回一个零作为退出状态。更多信息请见<xref linkend="backup-archiving-wal">。
       </para>
       <para>
        这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。除非服务器启动时启用了<varname>archive_mode</>，否则它会被忽略。如果<varname>archive_mode</>被启用时，<varname>archive_command</>是一个空字符串（默认），WAL 归档会被临时禁用，但服务器仍会继续累计 WAL 段文件，期待着一个命令被提供。将<varname>archive_command</>设置为一个只返回真但不做任何事的命令（例如<literal>/bin/true</>或 Windows 上的<literal>REM</>）实际上会禁用归档，也会打破归档恢复所需的 WAL 文件链，因此只有在极少数情况下才能用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-archive-timeout" xreflabel="archive_timeout">
      <term><varname>archive_timeout</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>archive_timeout</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        <xref linkend="guc-archive-command">仅在已完成的 WAL 段上调用。因此，如果你的服务器只产生很少的 WAL 流量（或产生流量的周期很长），那么在事务完成和它被安全地记录到归档存储之间将有一个很长的延迟。为了限制未归档数据存在的时间，你可以设置<varname>archive_timeout</>来强制服务器来周期性地切换到一个新的 WAL 段文件。当这个参数被设置为大于零时，只要从上次段文件切换后过了参数所设置的那么多秒并且已经有过任何数据库活动（包括一个单一检查点），服务器将切换到一个新的段文件（增加<varname>checkpoint_timeout</>将减少在一个空闲系统中不必要的检查点）。注意，由于强制切换而提早关闭的被归档文件仍然与完整的归档文件长度相同。因此，使用非常短的<varname>archive_timeout</>是不明智的 &mdash; 它将占用巨大的归档存储。一分钟左右的<varname>archive_timeout</>设置通常比较合理。如果你希望数据能被更快地从主服务器上复制下来，你应该考虑使用流复制而不是归档。这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect2>

   </sect1>

   <sect1 id="runtime-config-replication">
    <title>复制</title>

    <para>
     这些设置控制内建<firstterm>流复制</>特性（见<xref linkend="streaming-replication">）的行为。服务器将可以是主控服务器或后备服务器。主控机能发送数据，而后备机总是被复制数据的接收者。当使用级联复制（见<xref linkend="cascading-replication">）时，后备服务器也可以是发送者，同时也是接收者。这些参数主要用于发送服务器和后备服务器，尽管某些只在主服务器上有意义。如果有必要，设置可以在集群中变化而不出问题。
    </para>

    <sect2 id="runtime-config-replication-sender">
     <title>发送服务器</title>

     <para>
      这些参数可以在任何发送复制数据给一个或多个后备服务器的服务器上设置。主控机总是一个发送服务器，因此这些参数总是要在主控机上设置。这些参数的角色和含义不会在一个后备机变成主控机后改变。
     </para>

     <variablelist>
      <varlistentry id="guc-max-wal-senders" xreflabel="max_wal_senders">
       <term><varname>max_wal_senders</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>max_wal_senders</>配置参数</primary>
       </indexterm></term>
       <listitem>
       <para>
        指定来自后备服务器或流式基础备份客户端的并发连接的最大数量（即同时运行 WAL 发送进程
        的最大数）。默认值是零，它意味着禁用复制。WAL 发送进程被计算在连接总数内，因此该参数
        不能被设置为高于<xref linkend="guc-max-connections">的值。突然的流客户端断开
        连接可能导致一个孤立连接槽（知道达到超时），因此这个参数应该设置得略高于最大客户端
        连接数，这样断开连接的客户端可以立刻重新连接。这个参数只能在服务器启动时被设置。
        <varname>wal_level</>必须设置为<literal>archive</>或更高级别以允许来自后备服
        务器的连接。
       </para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-max-replication-slots" xreflabel="max_replication_slots">
       <term><varname>max_replication_slots</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>max_replication_slots</>配置参数</primary>
       </indexterm>
       </term>
       <listitem>
        <para>
         指定服务器可以支持的复制槽（见<xref linkend="streaming-replication-slots">）
         最大数量。默认值为零。这个参数只能在服务器启动时设置。要允许使用复制槽，
         <varname>wal_level</varname>必须被设置为<literal>archive</literal>或
         更高。把它的值设置为低于现有复制槽的数量会阻止服务器启动。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-wal-keep-segments" xreflabel="wal_keep_segments">
       <term><varname>wal_keep_segments</varname> (<type>integer</type>)
       <indexterm>
        <primary><varname>wal_keep_segments</>配置参数</primary>
       </indexterm></term>
       <listitem>
       <para>
        指定在后备服务器需要为流复制获取日志段文件的情况下，<filename>pg_xlog</>目录下所能保留的过去日志文件段的最小数目。每个段通常是 16 兆字节。如果一个连接到发送服务器的后备服务器落后了超过<varname>wal_keep_segments</>个段，发送服务器可以移除一个后备机仍然需要的 WAL 段，在这种情况下复制连接将被中断。最终结果是下行连接也将最终失败（不过，如果在使用 WAL 归档，后备服务器可以通过从归档获取段来恢复）。
       </para>

       <para>
        只设置<filename>pg_xlog</>中保留的文件段的最小数目；系统可能需要为 WAL 归档或从一个检查点恢复保留更多段。如果<varname>wal_keep_segments</>为零（默认值）， 更多的空间来 存放WAL归档或从一个检查点恢复。如果wal_keep_segments是零（缺省）， 系统不会为后备目的保留任何多余的段，因此后备服务器可用的旧 WAL 段的数量是一个上个检查点位置和 WAL 归档状态的函数。这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。
       </para>
       </listitem>
      </varlistentry>

     <varlistentry id="guc-wal-sender-timeout" xreflabel="wal_sender_timeout">
      <term><varname>wal_sender_timeout</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>wal_sender_timeout</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        中断那些停止活动超过指定毫秒数的复制连接。这对发送服务器检测一个后备机崩溃或网络中断有用。零值将禁用该超时机制。这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。默认值是 60 秒。
       </para>
      </listitem>
     </varlistentry>

     
     <varlistentry id="guc-track-commit-timestamp" xreflabel="track_commit_timestamp">
      <term><varname>track_commit_timestamp</varname> (<type>bool</type>)
      <indexterm>
       <primary><varname>track_commit_timestamp</>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
       <para>
        记录事务提交时间。这个参数只能在<filename>postgresql.conf</>文件
        或者服务器命令行上设置。缺省值是<literal>off</literal>。
       </para>
      </listitem>
     </varlistentry>
     
     </variablelist>
    </sect2>

    <sect2 id="runtime-config-replication-master">
     <title>主服务器</title>

     <para>
      这些参数可以在发送复制数据给一个或多个后备服务器的主控/主要服务器上设置。注意除了这些参数之外，在主控服务器上必须设置合适的<xref linkend="guc-wal-level">，并且也启用可选的 WAL 归档（见<xref linkend="runtime-config-wal-archiving">）。这些参数值与后备服务器无关，尽管你可能希望为了准备好一个后备机转变成主控机来设置这些参数。
     </para>

    <variablelist>

     <varlistentry id="guc-synchronous-standby-names" xreflabel="synchronous_standby_names">
      <term><varname>synchronous_standby_names</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>synchronous_standby_names</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        指定一个由逗号分隔的后备机名称列表，这些后备机能够支持<firstterm>同步复制</>，如<xref linkend="synchronous-replication">中所述。在任何一个时刻，只能有最多一个活动的同步后备机；等待提交的事务只有在后备服务器确认收到了它们的数据之后才被允许继续。该同步备份机将是这个列表中第一个被提到的后备机，它当前已连接并且实时获取流数据（在<link linkend="monitoring-stats-views-table"><literal>pg_stat_replication</></link>视图中以<literal>streaming</literal>状态显示）。出现在这个列表后面的其他后备服务器表示潜在的同步后备机。如果当前的同步后备机由于某种原因断开连接，它将立刻被下一个优先级最高的后备机替换。指定多于一个后备机名称可以允许很高的可用性。
       </para>
       <para>
        用于此目的的一个后备服务器的名称是后备服务器的<varname>application_name</>设置，
        正如在后备机的 WAL 接收进程的<varname>primary_conninfo</>中所设置的。
        现在没有机制可以强制唯一性。在重名的情况下，匹配的后备机之一将被选中为同步后备机，
        但是究竟是哪一个被选中是无法判断的。特殊项<literal>*</>可匹配任意
        <varname>application_name</>，包括<literal>walreceiver</>的默认应用名称。
       </para>
       <para>
        如果这里没有指定同步后备机名称，那么同步复制不能被启用并且事务提交将不会等待复制。这是默认的配置。即便当同步复制被启用时，个体事务也可以被配置为不等待复制，做法是将<xref linkend="guc-synchronous-commit">参数设置为<literal>local</>或<literal>off</>。
       </para>
       <para>
        这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-vacuum-defer-cleanup-age" xreflabel="vacuum_defer_cleanup_age">
      <term><varname>vacuum_defer_cleanup_age</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>vacuum_defer_cleanup_age</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
                指定<command>VACUUM</>和<acronym>HOT</>更新在清除死亡行版本之前，应该推迟多久（以事务数量计）。默认值是零个事务，表示死亡行版本将被尽可能快地清除，即当它们不再对任何打开的事务可见时尽快清除。在一个支持热后备服务器的主服务器上，你可能希望把这个参数设置为一个非零值，如<xref linkend="hot-standby">中所述。这允许后备机上的查询有更多时间来完成而不会由于先前的行清除产生冲突。但是，由于该值是用在主服务器上发生的写事务的数目衡量的，很难预测对后备机查询可用的附加时间到底是多少。这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。
       </para>
       <para>
        你也可以考虑设置后备服务器上的<varname>hot_standby_feedback</>作为使用这个参数的一种替代方案。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect2>

    <sect2 id="runtime-config-replication-standby">
     <title>后备服务器</title>

     <para>
      这些设置空值接收复制数据的一个后备服务器的行为。它们的值与主服务器无关。
     </para>

    <variablelist>

     <varlistentry id="guc-hot-standby" xreflabel="hot_standby">
      <term><varname>hot_standby</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>hot_standby</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        指定在恢复期间，你是否能够连接并运行查询，如<xref linkend="hot-standby">中所述。默认值是<literal>off</literal>。这个参数只能在服务器启动时设置。它只在归档恢复期间或后备机模式下才有效。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-standby-archive-delay" xreflabel="max_standby_archive_delay">
      <term><varname>max_standby_archive_delay</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_standby_archive_delay</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        当热后备机处于活动状态时，这个参数决定取消那些与即将应用的 WAL 项冲突的后备机查询之前，后备服务器应该等待多久，如<xref linkend="hot-standby-conflict">中所述。当 WAL 数据被从 WAL 归档（并且因此不是当前的 WAL）时，<varname>max_standby_archive_delay</>可以应用。默认值是 30 秒。如果没有指定，衡量单位是毫秒。值 -1 允许后备机一直等到冲突查询结束。这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。
       </para>
       <para>
        注意，<varname>max_standby_archive_delay</>与取消之前一个查询能够运行的最长时间不同；它表示应用任何一个 WAL 段数据能够被允许的最长总时间。因此，如果一个查询早于 WAL 段导致了显著的延迟，后续冲突查询将只有更少的时间。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-standby-streaming-delay" xreflabel="max_standby_streaming_delay">
      <term><varname>max_standby_streaming_delay</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_standby_streaming_delay</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        当热后备机处于活动状态时，这个参数决定取消那些与即将应用的 WAL 项冲突的后备机查询之前，后备服务器应该等待多久，如<xref linkend="hot-standby-conflict">中所述。当 WAL 数据正在通过流复制被接收时，<varname>max_standby_streaming_delay</>可以应用。默认值是 30 秒。如果没有指定，衡量单位是毫秒。值 -1 允许后备机一直等到冲突查询结束。这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。
       </para>
       <para>
        注意，<varname>max_standby_streaming_delay</>与取消之前一个查询能够运行的最长时间不同；它表示在从主服务器接收到 WAL 数据并立刻应用它能够被允许的最长总时间。因此，如果一个查询导致了显著的延迟，后续冲突查询将只有更少的时间，直到后备服务器再次赶上进度。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-receiver-status-interval" xreflabel="wal_receiver_status_interval">
      <term><varname>wal_receiver_status_interval</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>wal_receiver_status_interval</>配置参数</primary>
      </indexterm></term>
      <listitem>
      <para>
       指定在后备机上的 WAL 接收者进程向主服务器或上游后备机发送有关复制进度的信息的最小频度，它可以使用<link linkend="monitoring-stats-views-table"><literal>pg_stat_replication</></link>视图看到。后备机将报告它已经写入的上一个事务日志位置、它已经刷到磁盘的上一个位置以及它已经应用的最后一个位置。这个参数的值是报告之间的最大间隔，以秒计。每次写入或刷出位置改变时会发送状态更新，或者至少按这个参数的指定的频度发送。因此，应用位置可能比真实位置略微滞后。将这个参数设置为零将完全禁用状态更新。这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。默认值是 10 秒。
      </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-hot-standby-feedback" xreflabel="hot_standby">
      <term><varname>hot_standby_feedback</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>hot_standby_feedback</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        指定一个热后备机是否将会向主服务器或上游后备机发送有关于后备机上当前正被执行的查询的反馈。这个参数可以被用来排除由于记录清除导致的查询取消，但是可能导致在主服务器上用于某些负载的数据库膨胀。反馈消息的发送频度不会高于每个<varname>wal_receiver_status_interval</>周期发送一次。默认值是<literal>off</literal>。这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。
       </para>
       <para>
        如果使用级联复制，反馈将被向上游传递直到它最后到达主服务器。后备机在接收到反馈之后除了传递给上游不会做任何其他操作。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-receiver-timeout" xreflabel="wal_receiver_timeout">
      <term><varname>wal_receiver_timeout</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>wal_receiver_timeout</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        中止处于非活动状态超过指定毫秒数的复制链接。这对于正在接收的后备服务器检测主服务器崩溃或网络断开有用。值零会禁用超时机制。这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。默认值是 60 秒。
       </para>
      </listitem>
     </varlistentry>

    <varlistentry id="guc-wal-retrieve-retry-interval" xreflabel="wal_retrieve_retry_interval">
      <term><varname>wal_retrieve_retry_interval</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>wal_retrieve_retry_interval</>配置参数</primary>
      </indexterm>
      </term>
      <listitem>  
       <para>
        指定等待服务器应等待多长时间时，
        当重试检索WAL数据之前来自任何源
        （流复制，本地<filename>pg_xlog</>或者WAL归档）的WAL数据不可用。
        此参数只能在<filename>postgresql.conf</>文件或服务器命令行设置。
        缺省值是5秒。如果没有指定，单位是毫秒。
       </para>
       <para>
        此参数有助于配置恢复节点控制等待新的WAL数据可用的时间数。
        例如，在归档恢复中，通过减少此参数的值检测一个新的WAL日志文件中使得恢复更加敏感，
        这种做法是有可能的。在一个低WAL活动系统中，增加它减少了必要的访问WAL归档的需求量，
        一些有用例子在云环境中访问基础设施的时间量要考虑在内。
       </para>
      </listitem>
     </varlistentry> 
     
     </variablelist>
    </sect2>
   </sect1>

   <sect1 id="runtime-config-query">
    <title>查询规划</title>

    <sect2 id="runtime-config-query-enable">
     <title>规划器方法配制</title>

      <para>
       这些配置参数提供了影响查询优化器选择查询规划的原始方法。如果优化器 为特定的查询选择的缺省规划并不是最优，那么我们就可以通过使用这些 配置参数强制优化器选择一个更好的规划来temporary解决这个 问题。不过，永久地关闭这些设置几乎从不是个好主意。更好的改善优化器 选择规划的方法包括调节Section 18.6.2、 更频繁运行ANALYZE、增大配置参数 default_statistics_target的值、使用 ALTER TABLE SET STATISTICS为某个字段增加收集的 统计信息。
       这些配置参数影响查询优化器选择查询计划的暴力方法。如果优化器为一个特定查询选择的默认计划不是最优的，一种<emphasis>临时</>解决方案是使用这些配置参数之一来强制优化器选择一个不同的计划。提高优化器选择的计划质量的更好的方式包括调整规划器的代价常数（见<xref linkend="runtime-config-query-constants">）、手工运行<xref linkend="sql-analyze">、增加<xref  linkend="guc-default-statistics-target">配置参数的值以及使用<command>ALTER TABLE SET STATISTICS</command>增加为特定列收集的统计信息量。
      </para>

     <variablelist>
     <varlistentry id="guc-enable-bitmapscan" xreflabel="enable_bitmapscan">
      <term><varname>enable_bitmapscan</varname> (<type>boolean</type>)
      <indexterm>
       <primary>bitmap scan</primary>
      </indexterm>
      <indexterm>
       <primary><varname>enable_bitmapscan</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        允许或禁止查询规划器使用位图扫描计划类型。默认值是<literal>on</>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-hashagg" xreflabel="enable_hashagg">
      <term><varname>enable_hashagg</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_hashagg</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        允许或禁用查询规划器使用哈希聚集计划类型。默认值是<literal>on</>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-hashjoin" xreflabel="enable_hashjoin">
      <term><varname>enable_hashjoin</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_hashjoin</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        允许或禁止查询规划器使用哈希连接计划类型。默认值是<literal>on</>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-indexscan" xreflabel="enable_indexscan">
      <term><varname>enable_indexscan</varname> (<type>boolean</type>)
      <indexterm>
       <primary>index scan</primary>
      </indexterm>
      <indexterm>
       <primary><varname>enable_indexscan</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        允许或禁止查询规划器使用索引扫描计划类型。默认值是<literal>on</>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-indexonlyscan" xreflabel="enable_indexonlyscan">
      <term><varname>enable_indexonlyscan</varname> (<type>boolean</type>)
      <indexterm>
       <primary>index-only scan</primary>
      </indexterm>
      <indexterm>
       <primary><varname>enable_indexonlyscan</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        允许或禁止查询规划器使用只用索引扫描计划类型。默认值是<literal>on</>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-material" xreflabel="enable_material">
      <term><varname>enable_material</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_material</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        允许或者禁止查询规划器使用物化。它不可能完全禁用物化，但是关闭这个变量将阻止规划器插入物化节点，除非为了保证正确性。默认值是<literal>on</>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-mergejoin" xreflabel="enable_mergejoin">
      <term><varname>enable_mergejoin</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_mergejoin</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        允许或禁止查询规划器使用归并连接计划类型。默认值是<literal>on</>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-nestloop" xreflabel="enable_nestloop">
      <term><varname>enable_nestloop</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_nestloop</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        允许或禁止查询规划器使用嵌套循环连接计划。它不可能完全禁止嵌套循环连接，但是关闭这个变量将使得规划器尽可能优先使用其他方法。默认值是<literal>on</>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-seqscan" xreflabel="enable_seqscan">
      <term><varname>enable_seqscan</varname> (<type>boolean</type>)
      <indexterm>
       <primary>sequential scan</primary>
      </indexterm>
      <indexterm>
       <primary><varname>enable_seqscan</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        允许或禁止查询规划器使用顺序扫描计划类型。它不可能完全禁止顺序扫描，但是关闭这个变量将使得规划器尽可能优先使用其他方法。默认值是<literal>on</>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-sort" xreflabel="enable_sort">
      <term><varname>enable_sort</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_sort</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        允许或禁止查询规划器使用显式排序步骤。它不可能完全禁止显式排序，但是关闭这个变量将使得规划器尽可能优先使用其他方法。默认值是<literal>on</>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-tidscan" xreflabel="enable_tidscan">
      <term><varname>enable_tidscan</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>enable_tidscan</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        允许或禁止查询规划器使用<acronym>TID</>扫描计划类型。默认值是<literal>on</>。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
     </sect2>
     <sect2 id="runtime-config-query-constants">
     <title>规划器代价常量</title>

    <para>
     本节中描述的cost可以按照任意标准度量。我们只关心其相对值， 因此以相同的系数缩放它们将不会对规划器产生任何影响。默认情况下，它们 以抓取顺序页的开销作为基准单位。也就是说将seq_page_cost 设为 1.0 ，同时其它开销参数对照它来设置。当然你也可以使用其它基准， 例如以毫秒计的实际执行时间。
     这一节中描述的<firstterm>代价</>变量可以按照任意尺度衡量。我们只关心它们的相对值，将它们以相同的因子缩放不会影响规划器的选择。默认情况下，这些代价变量是基于顺序页面获取的代价的，即<varname>seq_page_cost</>被设置为<literal>1.0</>并且其他代价变量都参考它来设置。不过你可以使用你喜欢的不同尺度，例如在一个特定机器上的真实执行时间。
    </para>

   <note>
    <para>
     不幸的是，没有一种良定义的方法来决定代价变量的理想值。它们最好被作为一个特定安装将接收到的查询的平均值来对待。这意味着基于少量的实验来改变它们是有风险的。
    </para>
   </note>

     <variablelist>

     <varlistentry id="guc-seq-page-cost" xreflabel="seq_page_cost">
      <term><varname>seq_page_cost</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>seq_page_cost</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        设置规划器计算一次顺序磁盘页面抓取的开销。默认值是1.0。 通过设置同名的表空间参数，这个值可以重写为一个特定的表空间。 参阅ALTER TABLESPACE。
        设置规划器对一系列顺序磁盘页面获取中的一次的代价估计。默认值是 1.0。通过把表和索引放在一个特殊的表空间（要设置该表空间的同名参数）中可以覆盖这个值（见<xref linkend="sql-altertablespace">）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-random-page-cost" xreflabel="random_page_cost">
      <term><varname>random_page_cost</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>random_page_cost</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        设置规划器对一次非顺序获取磁盘页面的代价估计。默认值是 4.0。通过把表和索引放在一个特殊的表空间（要设置该表空间的同名参数）中可以覆盖这个值（见<xref linkend="sql-altertablespace">）。
       </para>

       <para>
        减少这个值（相对于<varname>seq_page_cost</>）将导致系统更倾向于索引扫描；提高它将让索引扫描看起来相对更昂贵。你可以一起提高或降低两个值来改变磁盘 I/O 代价相对于 CPU 代价的重要性，后者由下列参数描述。
       </para>

       <para>
        对磁盘存储的随机访问通常比顺序访问要贵不止四倍。但是，由于对磁盘的大部分随机访问（例如被索引的读取）都被假定在高速缓冲中进行，所以使用了一个较低的默认值（4.0）。默认值可以被想成把随机访问建模为比顺序访问慢 40 倍，而期望 90% 的随机读取会被缓存。
       </para>

       <para>
        如果你相信 90% 的缓冲率对你的负载是一个不正确的假设，你可以增加 random_page_cost 来更好的反映随机存储读取的真正代价。相应地，如果你的数据可以完全放在高速缓存中（例如当数据库小于服务器总内存时），降低 random_page_cost 可能是合适的。为具有很低的随机读取代价的存储（例如固态驱动器）采用较低的 random_page_cost 值可能更好。
       </para>

       <tip>
        <para>
         虽然允许你将random_page_cost设置的比 seq_page_cost小，但是物理上的实际情况并不受此影响。 然而当所有数据库都位于内存中时，两者设置为相等是非常合理的，因为 在此情况下，乱序抓取并不比顺序抓取开销更大。同样，在缓冲率很高的 数据库上，你应当相对于 CPU 开销同时降低这两个值，因为获取内存中 的页比通常情况下的开销小许多。
         尽管系统可以是你把<varname>random_page_cost</>设置得小于<varname>seq_page_cost</>，但是实际上没有意义。不过，如果数据库被整个缓存在 RAM 中，将它们设置为相等是有意义的，因为在那种情况中不按顺序访问页面是没有惩罚值的。同样，在一个高度缓存化的数据库中，你应该相对于 CPU 参数降低这两个值，因为获取一个已经在 RAM 中的页面的代价要远小于通常情况下的代价。
        </para>
       </tip>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-cpu-tuple-cost" xreflabel="cpu_tuple_cost">
      <term><varname>cpu_tuple_cost</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>cpu_tuple_cost</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        设置规划器对一次查询中处理每一行的代价估计。默认值是 0.01。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-cpu-index-tuple-cost" xreflabel="cpu_index_tuple_cost">
      <term><varname>cpu_index_tuple_cost</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>cpu_index_tuple_cost</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        设置规划器对一次索引扫描中处理每一个索引项的代价估计。默认值是 0.005。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-cpu-operator-cost" xreflabel="cpu_operator_cost">
      <term><varname>cpu_operator_cost</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>cpu_operator_cost</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        设置规划器对于一次查询中处理每个操作符或函数的代价估计。默认值是 0.0025。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-effective-cache-size" xreflabel="effective_cache_size">
      <term><varname>effective_cache_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>effective_cache_size</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        设置规划器对一个单一查询可用的有效磁盘缓冲区尺寸的假设。这个参数会被考虑在使用一个索引的代价估计中，更高的数值会使得索引扫描更可能被使用，更低的数值会使得顺序扫描更可能被使用。在设置这个参数时，你还应该考虑<productname>PostgreSQL</productname>的共享缓冲区以及将被用于<productname>PostgreSQL</productname>数据文件的内核磁盘缓冲区。另外，还要考虑预计在不同表上的并发查询数目，因为它们必须共享可用的空间。这个参数对<productname>PostgreSQL</productname>分配的共享内存尺寸没有影响，它也不会保留内核磁盘缓冲，它只用于估计的目的。系统也不会假设在查询之间数据会保留在磁盘缓冲中。默认值是 4吉字节（<literal>4GB</>）。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>

    </sect2>
     <sect2 id="runtime-config-query-geqo">
     <title>遗传查询优化</title>

     <para>
      GEQO是一个使用探索式搜索来执行查询规划的算法。它可以降低负载查询的规划时间。 同时，GEQO的检索是随机的，因此它的规划可能会不可确定。 更多信息参阅Chapter 50。
      遗传查询规划器（GEQO）是一种使用启发式搜索来进行查询规划的算法。它可以降低对于复杂查询（连接很多表的查询）的规划时间，但是代价是它产生的计划有时候要差于使用穷举搜索算法找到的计划。详见<xref linkend="geqo">。
     </para>

     <variablelist>

     <varlistentry id="guc-geqo" xreflabel="geqo">
      <term><varname>geqo</varname> (<type>boolean</type>)
      <indexterm>
       <primary>遗传查询优化</primary>
      </indexterm>
      <indexterm>
       <primary>GEQO</primary>
       <see>遗传查询优化</see>
      </indexterm>
      <indexterm>
       <primary><varname>geqo</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        允许或禁止遗传查询优化。默认是启用。在生产环境中通常最好不要关闭它。<varname>geqo_threshold</varname>变量提供了对 GEQO 更细粒度的空值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-geqo-threshold" xreflabel="geqo_threshold">
      <term><varname>geqo_threshold</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>geqo_threshold</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        只有当涉及的<literal>FROM</>项数量至少有这么多个的时候，才使用遗传查询优化（注意一个<literal>FULL OUTER JOIN</>只被计为一个<literal>FROM</>项）。默认值是 12。对于更简单的查询，通常会使用普通的穷举搜索规划器，但是对于有很多表的查询穷举搜索会花很长时间，通常比执行一个次优的计划带来的惩罚值还要长。因此，在查询尺寸上的一个阈值是管理 GEQO 使用的一种方便的方法。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-geqo-effort" xreflabel="geqo_effort">
      <term><varname>geqo_effort</varname>
      (<type>integer</type>)
      <indexterm>
       <primary><varname>geqo_effort</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        控制 GEQO 里规划时间和查询规划的有效性之间的平衡。这个变量必须是 一个范围从 1 到 10 的整数。缺省值是 5 。大的数值增加花在进行查询 规划上面的时间，但是也很可能会提高选中更有效的查询规划的几率。
        控制 GEQO 中规划时间和查询计划质量之间的折中。这个变量必须是位于 1 到 10 之间的一个整数。默认值是 5。更大的值会增加花在查询规划上的时间，但是同时也增加了选择一个高效查询计划的可能性。
       </para>

       <para>
        <varname>geqo_effort</varname>实际并不直接做任何事情；它只是被用来计算其他影响 GEQO 行为的变量（如下所述）的默认值。如果你愿意，你可以手工设置其他参数。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-geqo-pool-size" xreflabel="geqo_pool_size">
      <term><varname>geqo_pool_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>geqo_pool_size</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        控制 GEQO 使用的池尺寸，它就是遗传种群中的个体数目。它必须至少为 2，且有用的值通常在 100 到 1000 之间。如果它被设置为零（默认设置）则会基于<varname>geqo_effort</varname>和查询中表的数量选择一个合适的值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-geqo-generations" xreflabel="geqo_generations">
      <term><varname>geqo_generations</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>geqo_generations</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        控制 GEQO 使用的子代数目。子代的意思是算法的迭代次数。它必须至少 是 1 ，有用的值范围和池大小相同。如果设置为零(缺省)，那么将基于 geqo_pool_size选取合适的值。
        控制 GEQO 使用的代数，也是算法的迭代次数。它必须至少为 1，并且有用值的范围和池尺寸相同。如果它被设置为零（默认设置）则会基于<varname>geqo_pool_size</varname>选择一个合适的值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-geqo-selection-bias" xreflabel="geqo_selection_bias">
      <term><varname>geqo_selection_bias</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>geqo_selection_bias</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        控制 GEQO 使用的选择偏好。选择偏好是种群中的选择压力。值可以是 1.5 到 2.0 之间，后者是默认值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-geqo-seed" xreflabel="geqo_seed">
      <term><varname>geqo_seed</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>geqo_seed</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        控制 GEQO 使用的随机数生成器的初始值，随机数生成器用于在连接顺序搜索空间中选择随机路径。该值可以从 0 （默认值）到 1。变化该值会改变被探索的连接路径集合，并且可能导致找到一个更好或更差的路径。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect2>
     <sect2 id="runtime-config-query-other">
     <title>其他规划器选项</title>

     <variablelist>

     <varlistentry id="guc-default-statistics-target" xreflabel="default_statistics_target">
      <term><varname>default_statistics_target</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>default_statistics_target</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        为没有通过<command>ALTER TABLE SET STATISTICS</>设置列相关目标的表列设置默认统计目标。更大的值增加了需要做<command>ANALYZE</>的时间，但是可能会改善规划器的估计质量。默认值是 100。有关<productname>PostgreSQL</>查询规划器使用的统计信息的更多内容， 请参考<xref linkend="planner-stats">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-constraint-exclusion" xreflabel="constraint_exclusion">
      <term><varname>constraint_exclusion</varname> (<type>enum</type>)
      <indexterm>
       <primary>constraint exclusion</primary>
      </indexterm>
      <indexterm>
       <primary><varname>constraint_exclusion</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        <varname>constraint_exclusion</>的允许值是<literal>on</>（对所有表检查约束）、<literal>off</>（从不检查约束）和<literal>partition</>（只对继承的子表和<literal>UNION ALL</>子查询检查约束）。<literal>partition</>是默认设置。它通常被用于继承和分区表来提高性能。
      </para>

       <para>
        当对一个特定表允许这个参数，规划器比较查询条件和表的<literal>CHECK</>约束，并且忽略那些条件违反约束的表扫描。例如：

<programlisting>
CREATE TABLE parent(key integer, ...);
CREATE TABLE child1000(check (key between 1000 and 1999)) INHERITS(parent);
CREATE TABLE child2000(check (key between 2000 and 2999)) INHERITS(parent);
...
SELECT * FROM parent WHERE key = 2400;
</programlisting>

        在启用约束排除时，这个<command>SELECT</>将完全不会扫描<structname>child1000</>，从而提高性能。
       </para>

       <para>
        目前，约束排除只在用来实现表分区的情况中被默认启用。为所有表启用它会增加额外的规划开销，特别是在简单查询上并且不会产生任何好处。如果没有分区表时，最好是完全关闭它。
       </para>

       <para>
        更多关于使用约束排除和分区的信息请参阅<xref linkend="ddl-partitioning-constraint-exclusion">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-cursor-tuple-fraction" xreflabel="cursor_tuple_fraction">
      <term><varname>cursor_tuple_fraction</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>cursor_tuple_fraction</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        设置规划器对将被检索的一个游标的行的比例的估计。默认值是 0.1。更小的值使得规划器偏向为游标使用<quote>快速开始</>计划，它将很快地检索前几行但是可能需要很长时间来获取所有行。更大的值强调总的估计时间。最大设置为 1.0，游标将和普通查询完全一样地被规划，只考虑总估计时间并且不考虑前几行会被多快地返回。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-from-collapse-limit" xreflabel="from_collapse_limit">
      <term><varname>from_collapse_limit</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>from_collapse_limit</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        如果生成的<literal>FROM</literal>列表不超过这么多项，规划器将把子查询融合到上层查询。较小的值可以减少规划时间，但是可能 会生成较差的查询计划。默认值是 8。详见<xref linkend="explicit-joins">。
       </para>

       <para>
        将这个值设置为<xref linkend="guc-geqo-threshold">或更大，可能触发使用 GEQO 规划器，从而产生非最优计划。见<xref linkend="runtime-config-query-geqo">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-join-collapse-limit" xreflabel="join_collapse_limit">
      <term><varname>join_collapse_limit</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>join_collapse_limit</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        如果得出的列表中不超过这么多项，那么规划器将把显式<literal>JOIN</>（除了<literal>FULL JOIN</>）结构重写到 <literal>FROM</>项列表中。较小的值可减少规划时间，但是可能会生成差些的查询计划。
       </para>

       <para>
        默认情况下，这个变量被设置成和<varname>from_collapse_limit</varname>相同， 这样适合大多数使用。把它设置为 1 可避免任何显式<literal>JOIN</>的重排序。因此查询中指定的显式连接顺序就是关系被连接的实际顺序。因为查询规划器并不是总能 选取最优的连接顺序，高级用户可以选择暂时把这个变量设置为 1，然后显式地指定他们想要的连接顺序。更多信息请见<xref linkend="explicit-joins">。
       </para>

       <para>
        将这个值设置为<xref linkend="guc-geqo-threshold">或更大，可能触发使用 GEQO 规划器，从而产生非最优计划。见<xref linkend="runtime-config-query-geqo">。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect2>
   </sect1>

   <sect1 id="runtime-config-logging">
    <title>错误报告和日志</title>

    <indexterm zone="runtime-config-logging">
     <primary>服务器日志</primary>
    </indexterm>

    <sect2 id="runtime-config-logging-where">
     <title>在哪里做日志</title>

     <indexterm zone="runtime-config-logging-where">
      <primary>where to log</primary>
     </indexterm>

     <variablelist>

     <varlistentry id="guc-log-destination" xreflabel="log_destination">
      <term><varname>log_destination</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>log_destination</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        <productname>PostgreSQL</productname>支持多种方法来记录服务器消息，包括<systemitem>stderr</systemitem>、<systemitem>csvlog</systemitem>和<systemitem>syslog</systemitem>。在 Windows 上还支持<systemitem>eventlog</systemitem>。设置这个参数为一个由想要的日志目的地的列表，之间用逗号分隔。默认值是只记录到<systemitem>stderr</systemitem>。这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。
       </para>
       <para>
        如果<systemitem>csvlog</>被包括在<varname>log_destination</>中，日志项会以<quote>逗号分隔值</> （<acronym>CSV</>）格式被输出，这样可以很方便地把日志载入到程序中。详见<xref linkend="runtime-config-logging-csvlog">。要产生 CSV 格式的日志输出，必须启用<xref linkend="guc-logging-collector">。
       </para>

       <note>
        <para>
         在大多数 Unix 系统上，你将需要修改系统的<application>syslog</application>守护进程的配置来使用<varname>log_destination</>的<systemitem>syslog</systemitem>选项。<productname>PostgreSQL</productname>可以在<application>syslog</application>设备<literal>LOCAL0</>到<literal>LOCAL7</>中记录（见<xref linkend="guc-syslog-facility">），但是大部分平台上的默认<application>syslog</application>配置会丢弃所有这种消息。你将需要增加这样的内容：
<programlisting>
local0.*    /var/log/postgresql
</programlisting>
         到<application>syslog</application>守护进程的配置文件来让它工作。
        </para>
        <para>
         在 Windows 上，当你使用<varname>log_destination</>的<literal>eventlog</literal>选项时，你应该在操作系统中注册一个事件源极其库，这样 Windows 事件查看器能够清楚地显示事件日志消息。详见<xref linkend="event-log-registration">。
        </para>
       </note>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-logging-collector" xreflabel="logging_collector">
      <term><varname>logging_collector</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>logging_collector</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
         这个参数启用<firstterm>日志收集器</>，它是一个捕捉被发送到<systemitem>stderr</>的日志消息的后台进程，并且它会将这些消息重定向到日志文件中。这种方法比记录到<application>syslog</>通常更有用，因为某些类型的消息不会在<application>syslog</>输出中出现（一个常见的例子是动态链接器错误消息；另一个例子是由<varname>archive_command</>等脚本产生的错误消息）。这个参数只能在服务器启动时设置。
       </para>

       <note>
        <para>
         也可以不使用日志收集器而把日志记录到<systemitem>stderr</>，日志消息将只会去到服务器的<systemitem>stderr</>被定向到的位置。不过，那种方法只适合于低日志量，因为它没有提供方法来轮转日志文件。还有，在某些不使用日志收集器的平台上可能会导致丢失或者混淆日志输出，因为多个进程并发写入同一个日志文件时会覆盖彼此的输出。
        </para>
       </note>

       <note>
        <para>
          日志收集器被设计成从来不会丢失消息。这意味着在极高的负载下，如果服务器进程试图在收集器已经落后时发送更多的日志消息，那么它会被阻塞。相反，<application>syslog</>倾向于在无法写入消息时丢掉消息，这意味着在这样的情况下它可能会无法记录某些消息，但是它不会阻塞系统的其他部分。
        </para>
       </note>

      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-directory" xreflabel="log_directory">
      <term><varname>log_directory</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>log_directory</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        当<varname>logging_collector</>被启用时，这个参数决定日志文件将被在哪个目录下创建。它可以被指定为一个绝对路径，也可以被指定为一个相对于集簇数据目录的相对路径。这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。
        默认是<literal>pg_log</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-filename" xreflabel="log_filename">
      <term><varname>log_filename</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>log_filename</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        当<varname>logging_collector</varname>被启用时，这个参数设置被创建的日志文件的文件名。该值被视为一种<function>strftime</function>模式，因此<literal>%</literal>转义可以被用来指定根据时间变化的文件名（注意如果有任何时区独立的<literal>%</literal>转义，计算将在由<xref linkend="guc-log-timezone">指定的时区中完成）。被支持的<literal>%</literal>转义和开放组织的<ulink url="http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html">strftime</ulink>说明中列举的类似。
        注意系统的<function>strftime</function>不会被直接使用，因此平台相关（非标准）的扩展无法工作。
        默认是<literal>postgresql-%Y-%m-%d_%H%M%S.log</literal>。
       </para>
       <para>
        如果你不使用转义来指定一个文件名，你应该计划使用一个日志轮转工具来避免最终填满整个磁盘。在 8.4 发行之前，如果不存在<literal>%</literal>转义，<productname>PostgreSQL</productname>将追加新日志文件创建时间的纪元，但是现在已经不再这样做了。
       </para>
       <para>
        如果在<varname>log_destination</>中启用了 CSV 格式输出，<literal>.csv</>将会被追加到时间戳日志文件名中来创建 CSV 格式输出（如果<varname>log_filename</>以<literal>.log</>结尾，该后缀会被替换）。
       </para>
       <para>
        这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-file-mode" xreflabel="log_file_mode">
      <term><varname>log_file_mode</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>log_file_mode</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        在 Unix 系统上，当<varname>logging_collector</varname>被启用时，这个参数设置日志文件的权限（在微软 Windows 上这个参数将被忽略）。这个参数值应当是一个数字形式的模式，它可以被<function>chmod</function>和<function>umask</function>系统调用接受（要使用通常的十进制格式，该数字必须以一个<literal>0</literal>（零）开始）。
       </para>
       <para>
        默认的权限是<literal>0600</>，表示只有服务器拥有者才能读取或写入日志文件。其他常用的设置是<literal>0640</>，它允许拥有者的组成员读取文件。不过要注意你需要修改<xref linkend="guc-log-directory">为将文件存储在集簇数据目录之外的某个位置，才能利用这个设置。在任何情况下，让日志文件变成任何人都可读是不明智的，因为日志文件中可能包含敏感数据。
       </para>
       <para>
        这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-rotation-age" xreflabel="log_rotation_age">
      <term><varname>log_rotation_age</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>log_rotation_age</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        当<varname>logging_collector</varname>被启用时，这个参数决定一个个体日志文件的最长生命期。当这些分钟过去后，一个新的日志文件将被创建。将这个参数设置为零将禁用基于时间的新日志文件创建。这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-rotation-size" xreflabel="log_rotation_size">
      <term><varname>log_rotation_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>log_rotation_size</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        当<varname>logging_collector</varname>被启用时，这个参数决定一个个体日志文件的最大尺寸。当这么多千字节被发送到一个日志文件后，将创建一个新的日志文件。将这个参数设置为零将禁用基于尺寸的新日志文件创建。这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-truncate-on-rotation" xreflabel="log_truncate_on_rotation">
      <term><varname>log_truncate_on_rotation</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_truncate_on_rotation</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        当<varname>logging_collector</varname>被启用时，这个参数将导致<productname>PostgreSQL</productname>截断（覆盖而不是追加）任何已有的同名日志文件。不过，截断只在一个新文件由于基于时间的轮转被打开时发生，在服务器启动或基于尺寸的轮转时不会发生。如果被关闭，在所有情况下以前存在的文件将被追加。例如，使用这个设置和一个类似<literal>postgresql-%H.log</literal>的<varname>log_filename</varname>将导致产生 24 个每小时的日志文件，并且循环地覆盖它们。这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。
       </para>
       <para>
        例子：要保留 7 天的日志，每天的一个日志文件被命令为<literal>server_log.Mon</literal>、<literal>server_log.Tue</literal>等等，并且自动用本周的日志覆盖上一周的日志。可以这样做：将<varname>log_filename</varname>设置为<literal>server_log.%a</literal>、将<varname>log_truncate_on_rotation</varname>设置为<literal>on</literal>并且将<varname>log_rotation_age</varname>设置为<literal>1440</literal>。
       </para>
       <para>
        例子：要保留 24 小时的日志，每个小时一个日志文件，但是在日志文件尺寸超过 1GB 时轮转。可以这样做：将<varname>log_filename</varname>设置为<literal>server_log.%H%M</literal>、
        将<varname>log_truncate_on_rotation</varname>设置为<literal>on</literal>、
        将<varname>log_rotation_age</varname>设置为<literal>60</literal>并且
        将<varname>log_rotation_size</varname>设置为<literal>1000000</literal>。
        Including <literal>%M</> in 在<varname>log_filename</varname>中包括<literal>%M</>允许发生任何尺寸驱动的轮转来选择一个不同于每个小时的初始文件名的新文件名。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-syslog-facility" xreflabel="syslog_facility">
      <term><varname>syslog_facility</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>syslog_facility</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        当启用了向<application>syslog</>记录时，这个参数决定要使用的<application>syslog</application><quote>设备</quote>。你可以在<literal>LOCAL0</>、<literal>LOCAL1</>、<literal>LOCAL2</>、<literal>LOCAL3</>、<literal>LOCAL4</>、
        <literal>LOCAL5</>、<literal>LOCAL6</>、<literal>LOCAL7</>中选择，默认值是<literal>LOCAL0</>。还请参阅系统的<application>syslog</application>守护进程的文档。这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-syslog-ident" xreflabel="syslog_ident">
      <term><varname>syslog_ident</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>syslog_ident</>配置参数</primary>
      </indexterm></term>
       <listitem>
        <para>
         当启用了向<application>syslog</>记录时，这个参数决定用来标识<application>syslog</application>中的<productname>PostgreSQL</productname>消息的程序名。默认值是<literal>postgres</literal>。这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。
        </para>
       </listitem>
      </varlistentry>

     <varlistentry id="guc-event-source" xreflabel="event_source">
      <term><varname>event_source</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>event_source</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        当启用了向<application>事件日志</>记录时，这个参数决定用来标识日志中<productname>PostgreSQL</productname>消息的程序名。默认值是<literal>PostgreSQL</literal>。这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

      </variablelist>
    </sect2>
     <sect2 id="runtime-config-logging-when">
     <title>什么时候记录日志</title>

     <variablelist>

     <varlistentry id="guc-client-min-messages" xreflabel="client_min_messages">
      <term><varname>client_min_messages</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>client_min_messages</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        控制被发送给客户端的消息级别。有效值是<literal>DEBUG5</>、
        <literal>DEBUG4</>、<literal>DEBUG3</>、<literal>DEBUG2</>、
        <literal>DEBUG1</>、<literal>LOG</>、<literal>NOTICE</>、
        <literal>WARNING</>、<literal>ERROR</>、<literal>FATAL</>和<literal>PANIC</>。每个级别都包括其后的所有级别。级别越靠后，被发送的消息越少。默认值是<literal>NOTICE</>。注意<literal>LOG</>在这里有与<varname>log_min_messages</>中不同的排名。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-min-messages" xreflabel="log_min_messages">
      <term><varname>log_min_messages</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>log_min_messages</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        控制哪些消息级别被写入到服务器日志。有效值是<literal>DEBUG5</>、<literal>DEBUG4</>、
        <literal>DEBUG3</>、<literal>DEBUG2</>、<literal>DEBUG1</>、
        <literal>INFO</>、<literal>NOTICE</>、<literal>WARNING</>、
        <literal>ERROR</>、<literal>LOG</>、<literal>FATAL</>和
        <literal>PANIC</>。每个级别都包括以后的所有级别。级别越靠后，被发送的消息越少。默认值是<literal>WARNING</>。注意<literal>LOG</>在这里有与<varname>log_min_messages</>中不同的排名。只有超级用户可以改变这个设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-min-error-statement" xreflabel="log_min_error_statement">
      <term><varname>log_min_error_statement</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>log_min_error_statement</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        控制哪些导致一个错误情况的 SQL 语句被记录在服务器日志中。任何指定严重级别或更高级别的消息的当前 SQL 语句将被包括在日志项中。有效值是<literal>DEBUG5</literal>、
        <literal>DEBUG4</literal>、<literal>DEBUG3</literal>、
        <literal>DEBUG2</literal>、<literal>DEBUG1</literal>、
        <literal>INFO</literal>、<literal>NOTICE</literal>、
        <literal>WARNING</literal>、<literal>ERROR</literal>、
        <literal>LOG</literal>、
        <literal>FATAL</literal>和<literal>PANIC</literal>。默认值是<literal>ERROR</literal>，它表示导致错误、日志消息、致命错误或恐慌错误的语句将被记录在日志中。要有效地关闭记录失败语句，将这个参数设置为<literal>PANIC</literal>。只有超级用户可以改变这个设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-min-duration-statement" xreflabel="log_min_duration_statement">
      <term><varname>log_min_duration_statement</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>log_min_duration_statement</>配置参数</primary>
      </indexterm></term>
       <listitem>
        <para>
         如果语句运行至少指定的毫秒数，将导致记录每一个这种完成的语句的持续时间。将这个参数设置为零将打印所有语句的执行时间。设置为 -1 （默认值）将停止记录语句持续时间。例如，如果你设置它为<literal>250ms</literal>，那么所有运行 250ms 或更久的 SQL 语句将被记录。启用这个参数可以有助于追踪应用中未优化的查询。只有超级用户可以改变这个设置。
        </para>

        <para>
         对于使用扩展查询协议的客户端，解析、绑定和执行步骤的持续时间将被独立记录。
        </para>

       <note>
        <para>
         当把这个选项和<xref linkend="guc-log-statement">一起使用时，已经被<varname>log_statement</>记录的语句文本不会在持续时间日志消息中重复。如果你没有使用<application>syslog</>，我们推荐你使用<xref linkend="guc-log-line-prefix">记录 PID 或会话 ID，这样你可以使用进程 ID 或会话 ID 把语句消息链接到后来的持续时间消息。
        </para>
       </note>
       </listitem>
      </varlistentry>

     </variablelist>

    <para>
     <xref linkend="runtime-config-severity-levels">解释了<productname>PostgreSQL</>所使用的消息严重级别。如果日志输出被发送到<systemitem>syslog</systemitem>或 Windows 的<systemitem>eventlog</systemitem>，严重级别会按照表中所示进行转换。
    </para>

    <table id="runtime-config-severity-levels">
     <title>消息严重级别</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>严重性</entry>
        <entry>用法</entry>
        <entry><systemitem>syslog</></entry>
        <entry><systemitem>eventlog</></entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>DEBUG1..DEBUG5</></entry>
        <entry>为开发者提供连续的更详细的信息。</entry>
        <entry><literal>DEBUG</></entry>
        <entry><literal>INFORMATION</></entry>
       </row>

       <row>
        <entry><literal>INFO</></entry>
        <entry>提供用户隐式要求的信息，例如来自<command>VACUUM VERBOSE</>的输出。</entry>
        <entry><literal>INFO</></entry>
        <entry><literal>INFORMATION</></entry>
       </row>

       <row>
        <entry><literal>NOTICE</></entry>
        <entry>提供可能对用户有用的信息，例如长标识符截断提示。</entry>
        <entry><literal>NOTICE</></entry>
        <entry><literal>INFORMATION</></entry>
       </row>

       <row>
        <entry><literal>WARNING</></entry>
        <entry>提供可能出现的问题的警告，例如在一个事务块外<command>COMMIT</>。</entry>
        <entry><literal>NOTICE</></entry>
        <entry><literal>WARNING</></entry>
       </row>

       <row>
        <entry><literal>ERROR</></entry>
        <entry>报告一个导致当前命令中断的错误。</entry>
        <entry><literal>WARNING</></entry>
        <entry><literal>ERROR</></entry>
       </row>

       <row>
        <entry><literal>LOG</></entry>
        <entry>报告管理员可能感兴趣的信息，例如检查点活动。</entry>
        <entry><literal>INFO</></entry>
        <entry><literal>INFORMATION</></entry>
       </row>

       <row>
        <entry><literal>FATAL</></entry>
        <entry>报告一个导致当前会话中断的错误。</entry>
        <entry><literal>ERR</></entry>
        <entry><literal>ERROR</></entry>
       </row>

       <row>
        <entry><literal>PANIC</></entry>
        <entry>报告一个导致所有数据库会话中断的错误。</entry>
        <entry><literal>CRIT</></entry>
        <entry><literal>ERROR</></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    </sect2>
     <sect2 id="runtime-config-logging-what">
     <title>记录什么到日志</title>

     <variablelist>

     <varlistentry id="guc-application-name" xreflabel="application_name">
      <term><varname>application_name</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>application_name</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        application_name可以是任意的小于NAMEDATALEN字字符 （标准编译是64字符）的字符串。它通常由一个连接服务器后的的应用程序设置。 名字会记录在pg_stat_activity和CSV日志条目中。 也可以通过log_line_prefix参数，包含在规律的日志条目中。 只有可打印的ASCII字符可以被用于application_name。 其他字符会被问号(?)替换。
        <varname>application_name</varname>可以是任意小于<symbol>NAMEDATALEN</>个字符（标准编译中是 64 个字符）的字符串。这通常由一个应用通过到服务器的连接设置。该名称将被显示在<structname>pg_stat_activity</>视图中并被包括在 CSV 日志项中。它也会被通过<xref linkend="guc-log-line-prefix">包括在普通日志项中。只有可打印 ASCII 字符能被使用在<varname>application_name</varname>之中。其他字符将被替换为问号（<literal>?</literal>）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>debug_print_parse</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>debug_print_parse</>配置参数</primary>
      </indexterm>
      </term>
      <term><varname>debug_print_rewritten</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>debug_print_rewritten</>配置参数</primary>
      </indexterm>
      </term>
      <term><varname>debug_print_plan</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>debug_print_plan</>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
       <para>
        这个参数启用发出各种调试输出。当设置时，会打印生成的解析树， 查询重写输出，或执行的每个查询的执行计划。这些信息是在LOG 信息级别发出，因此默认的，它们会出现在服务器日志中，但不会发送给客户端。 可以通过 client_min_messages和/或log_min_messages 来设置。这些参数缺省是off。
        这些参数将会让多种调试输出被发出。当被设置时，它们为每一个被执行的查询打印结果分析树、查询重写器输出或执行计划。这些消息在<literal>LOG</>消息级别上被发出，因此默认情况下它们将出现在服务器日志中但不会被发送到客户端。你可以通过调整<xref linkend="guc-client-min-messages">和/或<xref linkend="guc-log-min-messages">来改变这种情况。这些参数默认是关闭的。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>debug_pretty_print</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>debug_pretty_print</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        当被设置时，<varname>debug_pretty_print</varname>会缩进由<varname>debug_print_parse</varname>、
        <varname>debug_print_rewritten</varname>或
        <varname>debug_print_plan</varname>产生的输出。这将导致比关闭参数时使用的<quote>紧凑</>模式可读性更强但是更长的输出。它默认是打开的。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-checkpoints" xreflabel="log_checkpoints">
      <term><varname>log_checkpoints</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_checkpoints</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        导致检查点和重启点被记录在服务器日志中。一些统计信息也被包括在日志消息中，包括写入缓冲区的数据和写它们所花的时间。这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。默认值是关闭。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-connections" xreflabel="log_connections">
      <term><varname>log_connections</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_connections</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        导致每一次尝试对服务器的连接被记录，客户端认证的成功完成也会被记录。
        只有超级用户在会话开启时可以改变这个参数，并且在所有会话中不能改变。
        缺省是<literal>off</>。
       </para>

       <note>
        <para>
          某些客户端程序（例如<application>psql</>）在要求密码时会尝试连接两次，因此重复的<quote>收到连接</>消息并不一定表示一个错误。
        </para>
       </note>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-disconnections" xreflabel="log_disconnections">
      <term><varname>log_disconnections</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_disconnections</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        记录会话终止原因。日志输出提供信息类似于<varname>log_connections</varname>，
        以及会话持续时间。只有超级用户在会话开启时可以改变这个参数，
        并且在所有会话中不能改变。缺省是<literal>off</>。
       </para>
      </listitem>
     </varlistentry>


     <varlistentry id="guc-log-duration" xreflabel="log_duration">
      <term><varname>log_duration</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_duration</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        导致每一个完成的语句的持续时间被记录。默认值是<literal>off</>。只有超级用户可以改变这个设置。
       </para>

       <para>
        对于使用扩展查询协议的客户端，解析、绑定和执行步骤的持续时间将被独立记录。
       </para>

       <note>
        <para>
         设置这个选项和设置<xref linkend="guc-log-min-duration-statement">为零之间的区别是，超过<varname>log_min_duration_statement</>强制查询的文本被记录，但这个选项不会。因此，如果<varname>log_duration</>为<literal>on</>并且<varname>log_min_duration_statement</>为正值，所有持续时间都将被记录，但是只有超过阈值的语句才会被记录查询文本。这种行为有助于在高负载安装中收集统计信息。
        </para>
       </note>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-error-verbosity" xreflabel="log_error_verbosity">
      <term><varname>log_error_verbosity</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>log_error_verbosity</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        控制为每一个被记录的消息要写入到服务器日志的细节量。有效值是<literal>TERSE</>、<literal>DEFAULT</>和<literal>VERBOSE</>，每一个都为显示的消息增加更多域。<literal>TERSE</>排除记录<literal>DETAIL</>、<literal>HINT</>、<literal>QUERY</>和<literal>CONTEXT</>错误信息。<literal>VERBOSE</>输出包括<symbol>SQLSTATE</>错误码（见<xref linkend="errcodes-appendix">）以及产生错误的源代码文件名、函数名和行号。只有超级用户能够更改这个设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-hostname" xreflabel="log_hostname">
      <term><varname>log_hostname</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_hostname</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        默认情况下，连接日志消息只显示连接主机的 IP 地址。打开这个参数将导致也记录主机名。注意根据你的主机名解析设置，这可能会导致很微小的性能损失。这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-line-prefix" xreflabel="log_line_prefix">
      <term><varname>log_line_prefix</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>log_line_prefix</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
         这是一个<function>printf</>风格的字符串，它在每个日志行的开头输出。<literal>%</>字符开始<quote>转义序列</>，它将被按照下文描述的替换成状态信息。未识别的转义被忽略。其他字符被直接复制到日志行。某些转义只被会话进程识别并且被主服务器进程等后台进程当作空。通过指定一个在%之后和该选项之前的数字可以让状态信息左对齐或右对齐。
         负值将导致在右边用空格填充状态信息已达到最小宽度，而正值则在左边填充。填充对于日志文
         件的人类可读性大有帮助。这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。默认值是一个空字符串。

         <informaltable>
          <tgroup cols="3">
           <thead>
            <row>
             <entry>转义</entry>
             <entry>效果</entry>
             <entry>只限会话</entry>
             </row>
            </thead>
           <tbody>
            <row>
             <entry><literal>%a</literal></entry>
             <entry>应用名</entry>
             <entry>是</entry>
            </row>
            <row>
             <entry><literal>%u</literal></entry>
             <entry>用户名</entry>
             <entry>是</entry>
            </row>
            <row>
             <entry><literal>%d</literal></entry>
             <entry>数据库名</entry>
             <entry>是</entry>
            </row>
            <row>
             <entry><literal>%r</literal></entry>
             <entry>远程主机名或 IP 地址，以及远程端口</entry>
             <entry>是</entry>
            </row>
            <row>
             <entry><literal>%h</literal></entry>
             <entry>远程主机名或 IP 地址</entry>
             <entry>是</entry>
            </row>
            <row>
             <entry><literal>%p</literal></entry>
             <entry>进程 ID</entry>
             <entry>否</entry>
            </row>
            <row>
             <entry><literal>%t</literal></entry>
             <entry>无毫秒的时间戳</entry>
             <entry>否</entry>
            </row>
            <row>
             <entry><literal>%m</literal></entry>
             <entry>带毫秒的时间戳</entry>
             <entry>否</entry>
            </row>
            <row>
             <entry><literal>%i</literal></entry>
             <entry>命令标签：会话当前命令的类型</entry>
             <entry>是</entry>
            </row>
            <row>
             <entry><literal>%e</literal></entry>
             <entry>SQLSTATE 错误代码</entry>
             <entry>否</entry>
            </row>
            <row>
             <entry><literal>%c</literal></entry>
             <entry>会话 ID：见下文</entry>
             <entry>否</entry>
            </row>
            <row>
             <entry><literal>%l</literal></entry>
             <entry>对每个会话或进程的日志行号，从 1 开始</entry>
             <entry>否</entry>
            </row>
            <row>
             <entry><literal>%s</literal></entry>
             <entry>进程开始的时间戳</entry>
             <entry>否</entry>
            </row>
            <row>
             <entry><literal>%v</literal></entry>
             <entry>虚拟事务 ID (backendID/localXID)</entry>
             <entry>否</entry>
            </row>
            <row>
             <entry><literal>%x</literal></entry>
             <entry>事务 ID （如果未分配则为 0）</entry>
             <entry>否</entry>
            </row>
            <row>
             <entry><literal>%q</literal></entry>
             <entry>不产生输出，但是告诉非会话进程在字符串的这一点停止；会话进程忽略</entry>
             <entry>否</entry>
            </row>
            <row>
             <entry><literal>%%</literal></entry>
             <entry>纯文字 <literal>%</></entry>
             <entry>否</entry>
            </row>
           </tbody>
          </tgroup>
         </informaltable>

         <literal>%c</>转义打印一个准唯一的会话标识符，它由两个 4 字节的十六进制数（不带先导零）组成，以点号分隔。这些数字是进程启动时间和进程 ID，因此<literal>%c</>也可以被用作保存打印这些项的方式的空间。例如，要从<literal>pg_stat_activity</>生成会话标识符，使用这个查询：
<programlisting>
SELECT to_hex(trunc(EXTRACT(EPOCH FROM backend_start))::integer) || '.' ||
       to_hex(pid)
FROM pg_stat_activity;
</programlisting>

       </para>

       <tip>
        <para>
         如果你为<varname>log_line_prefix</>设置了非空值，你通常应该让它的最后一个字符为空格，这样用以提供和日志行的剩余部分的视觉区别。也可以使用标点符号。
        </para>
       </tip>

       <tip>
        <para>
         <application>Syslog</>产生自己的时间戳和进程 ID 信息，因此如果你记录到<application>syslog</>你可能不希望包括哪些转义。
        </para>
       </tip>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-lock-waits" xreflabel="log_lock_waits">
      <term><varname>log_lock_waits</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_lock_waits</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        控制当一个会话为获得一个锁等到超过<xref linkend="guc-deadlock-timeout">时，是否要产生一个日志消息。这有助于决定是否所等待造成了性能低下。默认值是<literal>off</>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-statement" xreflabel="log_statement">
      <term><varname>log_statement</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>log_statement</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        控制哪些 SQL 语句被记录。有效值是
        <literal>none</> (off)、<literal>ddl</>、<literal>mod</>和
        <literal>all</>（所有语句）。<literal>ddl</>记录所有数据定义语句，例如<command>CREATE</>、<command>ALTER</>和
        <command>DROP</>语句。<literal>mod</>记录所有<literal>ddl</>语句，外加数据修改语句例如<command>INSERT</>,
        <command>UPDATE</>、<command>DELETE</>、<command>TRUNCATE</>,
        和<command>COPY FROM</>。
        如果<command>PREPARE</>、<command>EXECUTE</>和
        <command>EXPLAIN ANALYZE</>包含合适类型的命令，它们也会被记录。对于使用扩展查询协议的客户端，当收到一个执行消息时会产生日志并且会包括绑定参数的值（任何内嵌的单引号会被双写）。
       </para>

       <para>
        默认值是<literal>none</>。只有超级用户可以改变这个设置。
       </para>

       <note>
        <para>
         即使设置了log_statement=all，包含 简单语法错误的语句也不会被记录。因为仅在完成基本的语法分析并 确定了语句类型之后才记录日志。在使用扩展查询协议的情况下，在 执行阶段之前(语法分析或规划阶段)同样不会记录。将 log_min_error_statement设为ERROR 或更低才能记录这些语句。
         即使使用<varname>log_statement</> = <literal>all</>设置，包含简单语法错误的语句也不会被记录。这是因为只有在完成基本语法解析并确定了语句类型之后才会发出日志消息。在扩展查询协议的情况下，在执行阶段之前（即在解析分析或规划期间）出错的语句也不会被记录。将<varname>log_min_error_statement</>设置为<literal>ERROR</>（或更低）来记录这种语句。
        </para>
       </note>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-replication-commands" xreflabel="log_replication_commands">
      <term><varname>log_replication_commands</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_replication_commands</>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
       <para>
        导致每个复制命令记录在服务器日志中。
        参阅<xref linkend="protocol-replication">获取更多复制命令的详细信息。
        缺省值是<literal>off</>。只有超级用户可以修改这个设置。
       </para>
      </listitem>
     </varlistentry>
      
     <varlistentry id="guc-log-temp-files" xreflabel="log_temp_files">
      <term><varname>log_temp_files</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>log_temp_files</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        控制记录临时文件名和尺寸。临时文件可以被创建用来排序、哈希和存储临时查询结果。当每一个临时文件被删除时都会制作一个日志项。一个零值记录所有临时文件信息，而正值只记录尺寸大于或等于指定千字节数的文件。默认设置为 -1，它禁用这种记录。只有超级用户可以更改这个设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-timezone" xreflabel="log_timezone">
      <term><varname>log_timezone</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>log_timezone</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        设置在服务器日志中写入的时间戳的时区。和<xref linkend="guc-timezone">不同，这个值是集簇范围的，因此所有会话将报告一致的时间戳。内建默认值是<literal>GMT</>，但是通常会被在<filename>postgresql.conf</>中覆盖。<application>initdb</>将安装一个对应于其系统环境的设置。详见<xref linkend="datatype-timezones">。这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect2>
     <sect2 id="runtime-config-logging-csvlog">
     <title>使用 CSV 格式的日志输出</title>

       <para>
        包括在log_destination中的csvlog，提供了一个 便捷的方式向数据库中导入日志文件。这个选项以CSV格式发出日志行， 带有这些列： 以毫秒为单位的时间戳，用户名，数据库名，进程ID，客户端主机：端口号， 会话ID，每个会话的行号，命令标签，会话开始时间，虚拟事务ID，日常事务ID， 错误严重性，SQLSTATE代码，错误信息，错误信息的详细信息，建议， 导致错误的内部查询（如果存在），其中的错误位置的字符统计， 错误范围，导致错误的用户查询（如果存在，并且启用log_min_error_statement）， 其中的错误位置的字符统计，PostgreSQL源代码中报错的位置（如果 log_error_verbosity设置为verbose）和应用程序名。 下面是一个用于存储CSV格式日志暑促的简单表定义：
        在<varname>log_destination</>列表中包括<literal>csvlog</>提供了一种便捷方式将日志文件导入到一个数据库表。这个选项发出逗号分隔值（<acronym>CSV</>）格式的日志行，包括这些列：
        带毫秒的时间戳、
        用户名、
        数据库名、
        进程 ID、
        客户端主机:端口号、
        会话 ID、
        每个会话的行号、
        命令标签、
        会话开始时间、
        虚拟事务 ID、
        普通事务 ID、
        错误严重性、
        SQLSTATE 代码、
        错误消息、
        错误消息详情、
        提示、
        导致错误的内部查询（如果有）、
        错误位置所在的字符计数、
        错误上下文、
        导致错误的用户查询（如果有且被<varname>log_min_error_statement</>启用）、
        错误位置所在的字符计数、
        在 PostgreSQL 源代码中错误的位置（如果<varname>log_error_verbosity</>被设置为<literal>verbose</>）以及应用名。
        下面是一个定义用来存储 CSV 格式日志输出的样表：

<programlisting>
CREATE TABLE postgres_log
(
  log_time timestamp(3) with time zone,
  user_name text,
  database_name text,
  process_id integer,
  connection_from text,
  session_id text,
  session_line_num bigint,
  command_tag text,
  session_start_time timestamp with time zone,
  virtual_transaction_id text,
  transaction_id bigint,
  error_severity text,
  sql_state_code text,
  message text,
  detail text,
  hint text,
  internal_query text,
  internal_query_pos integer,
  context text,
  query text,
  query_pos integer,
  location text,
  application_name text,
  PRIMARY KEY (session_id, session_line_num)
);
</programlisting>
       </para>

       <para>
        使用<command>COPY FROM</>命令将一个日志文件导入到这个表中：

<programlisting>
COPY postgres_log FROM '/full/path/to/logfile.csv' WITH csv;
</programlisting>
       </para>

       <para>
       你可以做一些事情来简化导入 CSV 日志文件：

       <orderedlist>
         <listitem>
           <para>
            设置<varname>log_filename</varname>和<varname>log_rotation_age</>为你的日志文件提供一种一致的、可预测的命名空间。这让你预测文件名会是怎样以及知道什么时候一个个体日志文件完成并且因此准备好被导入。
         </para>
        </listitem>

        <listitem>
           <para>
           将<varname>log_rotation_size</varname>设置为 0 来禁用基于尺寸的日志轮转，因为它使得日志文件名难以预测。
           </para>
        </listitem>

        <listitem>
          <para>
           将<varname>log_truncate_on_rotation</varname>设置为<literal>on</>，这样在同一个文件中旧日志数据不会与新数据混杂。
          </para>
        </listitem>

        <listitem>
          <para>
           上述表定义包括一个主键声明。这有助于避免意外地两次导入相同的信息。<command>COPY</>命令一次提交所有它导入的数据，因此任何错误将导致整个导入失败。如果你导入一个部分完成的日志文件并且稍后当它完全完成后再次导入，主键违背将导致导入失败。请等到日志完成且被关闭之后再导入。这个过程也可以避免意外地导入部分完成的行，这种行也将导致<command>COPY</>失败。
          </para>
        </listitem>
        </orderedlist>
      </para>

    </sect2>
    
    <sect2>
    <title>进程标题</title>

    <para>
     这些设置控制进程标题如<command>ps</command>是如何被修改的。
     参阅<xref linkend="monitoring-ps">获取详情。
    </para>

    <variablelist>
     <varlistentry id="guc-cluster-name" xreflabel="cluster_name">
      <term><varname>cluster_name</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>cluster_name</>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
       <para>
        设置出现在集群中的所有进程标题中的集群名称。
        名称可以是任何小于<symbol>NAMEDATALEN</>字符（标准64字符）的字符串。
        只有可输出的ASCII字符可以用在<varname>cluster_name</varname>值中。
        其他字符将用问号替换(<literal>?</literal>)。
        如果此参数设置为空字符串<literal>''</>（即为缺省值），不显示名字。
        此参数只能在服务器启动时设置。
       </para>
       <para>
        通常使用程序查看进程标题，如
        <application>ps</>或者Windows上的<application>进程管理器</>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-update-process-title" xreflabel="update_process_title">
      <term><varname>update_process_title</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>update_process_title</>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
       <para> 
        启用更新进程标题的特性，这个特性在每次服务器接收到一个新SQL命令时都会更新进程的标题。
       进程标题通常通过<command>ps</>命令来查看，
       或者在Windows中用<application>进程管理器</>查看。
       只有超级用户可以更改这个设置。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect2>
   </sect1>

   <sect1 id="runtime-config-statistics">
    <title>运行时统计数据</title>

    <sect2 id="runtime-config-statistics-collector">
     <title>查询和索引统计收集器</title>

     <para>
      这些参数控制服务器范围的统计数据收集特性。当统计收集被启用时，被产生的数据可以通过<structname>pg_stat</structname>和<structname>pg_statio</structname>系统视图族访问。详见<xref linkend="monitoring">。
     </para>

     <variablelist>

     <varlistentry id="guc-track-activities" xreflabel="track_activities">
      <term><varname>track_activities</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>track_activities</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        启用对每个会话的当前执行命令的信息收集，还有命令开始执行的时间。这个参数默认为打开。注意即使被启用，这些信息也不是对所有用户可见，只有超级用户和拥有报告信息的会话的用户可见，因此它不会表现为一个安全风险。只有超级用户可以更改这个设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-track-activity-query-size" xreflabel="track_activity_query_size">
      <term><varname>track_activity_query_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>track_activity_query_size</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
       声明保留的字节数，以跟踪每个活动会话的当前执行命令，对 pg_stat_activity.current_query段。 缺省值是1024。这个参数只能在服务器启动时设置。
       指定跟踪每个活动会话当前执行命令所保留的字节数，它们被用于<structname>pg_stat_activity</>.<structfield>query</>域。默认值是 1024。这个参数只能在服务器启动时被设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-track-counts" xreflabel="track_counts">
      <term><varname>track_counts</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>track_counts</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        启用在数据库活动上的统计收集。这个参数默认为打开，因为自动清理守护进程需要被收集的信息。只有超级用户可以更改这个设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-track-io-timing" xreflabel="track_io_timing">
      <term><varname>track_io_timing</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>track_io_timing</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        启用对系统 I/O 调用的计时。这个参数默认为关闭，因为它将重复地向操作系统查询当前时间，这会在某些平台上导致显著的负荷。你可以使用<xref linkend="pgtesttiming">工具来度量你的系统中计时的开销。I/O 计时信息被显示在<xref linkend="pg-stat-database-view">中、当<literal>BUFFERS</>选项被使用时的<xref linkend="sql-explain">输出中以及<xref linkend="pgstatstatements">中。只有超级用户可以更改这个设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-track-functions" xreflabel="track_functions">
      <term><varname>track_functions</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>track_functions</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        启用跟踪函数调用计数和用时。指定<literal>pl</literal>只跟踪过程语言函数，指定<literal>all</literal>还会跟踪 SQL 和 C 语言函数。默认值是<literal>none</literal>，它禁用函数统计跟踪。只有超级用户可以更改这个设置。
       </para>

       <note>
        <para>
         简单到足以被<quote>内联</>到调用查询中的 SQL 语言函数不会被跟踪， 而不管这个设置。
        </para>
       </note>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-stats-temp-directory" xreflabel="stats_temp_directory">
      <term><varname>stats_temp_directory</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>stats_temp_directory</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        设置存储临时统计数据的目录。这可以是一个相对于数据目录的路径或一个绝对路径。默认值是<filename>pg_stat_tmp</filename>。在一个基于 RAM 的文件系统上指明这个参数将降低物理 I/O 需求，并且提高性能。这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect2>

    <sect2 id="runtime-config-statistics-monitor">
     <title>统计监控</title>
     <variablelist>

     <varlistentry>
      <term><varname>log_statement_stats</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_statement_stats</>配置参数</primary>
      </indexterm>
      </term>
      <term><varname>log_parser_stats</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_parser_stats</>配置参数</primary>
      </indexterm>
      </term>
      <term><varname>log_planner_stats</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_planner_stats</>配置参数</primary>
      </indexterm>
      </term>
      <term><varname>log_executor_stats</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_executor_stats</>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
       <para>
        对每个查询，向服务器日志里输出相应模块的性能统计。这是一种粗糙的分析工具。类似于 Unix 的<function>getrusage()</>系统功能。<varname>log_statement_stats</varname>报告总的语句统计，而其它的报告针每个模块的统计。<varname>log_statement_stats</varname>不能和 其它任何针对每个模块统计的选项一起启用。所有这些选项都是默认禁用的。只有超级用户可以更改这个设置。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>

    </sect2>
   </sect1>

   <sect1 id="runtime-config-autovacuum">
    <title>自动清理</title>

    <indexterm>
     <primary>自动清理</primary>
     <secondary>配置参数</secondary>
    </indexterm>

     <para>
      这些设置控制<firstterm>自动清理</>特性的行为。
      详情请见<xref linkend="autovacuum">。请注意在每个表基础上可以重写这些设置；
      参阅<xref linkend="sql-createtable-storage-parameters"
      endterm="sql-createtable-storage-parameters-title">。
     </para>

    <variablelist>

     <varlistentry id="guc-autovacuum" xreflabel="autovacuum">
      <term><varname>autovacuum</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>autovacuum</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        控制服务器是否运行自动清理启动器后台进程。默认为开启，不过要自动清理正常工作还需要启用<xref linkend="guc-track-counts">。该参数只能在<filename>postgresql.conf</>文件或服务器命令行中设置。
        然而，为单表通过修改表存储参数可以禁用自动清理。
       </para>
       <para>
        注意即使该参数被禁用，系统也会在需要防止事务ID回卷时发起清理进程。详情请见<xref linkend="vacuum-for-wraparound">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-autovacuum-min-duration" xreflabel="log_autovacuum_min_duration">
      <term><varname>log_autovacuum_min_duration</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>log_autovacuum_min_duration</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        如果自动清理运行至少该值所指定的毫秒数，被自动清理执行的每一个动作都会被日志记录。将该参数设置为0会记录所有的自动清理动作。-1（默认值）将禁用对自动清理动作的记录。例如，如果你将它设置为<literal>250ms</literal>，则所有运行250ms或更长时间的自动清理和分析将被记录。此外，当该参数被设置为除<literal>-1</literal>外的任何值时，如果一个自动清理动作由于存在一个锁冲突而被跳过，将会为此记录一个消息。开启这个参数对于追踪自动清理活动非常有用。该设置只能在<filename>postgresql.conf</>文件或者服务器命令行上设置。
        但是可以通过为单表修改表存储参数重写这个设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-autovacuum-max-workers" xreflabel="autovacuum_max_workers">
      <term><varname>autovacuum_max_workers</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>autovacuum_max_workers</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        指定能同时运行的自动清理进程（除了自动清理启动器之外）的最大数量。默认值为3。该参数只能在服务器启动时设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-autovacuum-naptime" xreflabel="autovacuum_naptime">
      <term><varname>autovacuum_naptime</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>autovacuum_naptime</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        指定自动清理在任意给定数据库上运行的最小延迟。在每一轮中后台进程检查数据库并根据需要为数据库中的表发出<command>VACUUM</>和<command>ANALYZE</>命令。延迟以秒计，且默认值为1分钟（<literal>1min</>）。该参数只能在<filename>postgresql.conf</>文件或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-autovacuum-vacuum-threshold" xreflabel="autovacuum_vacuum_threshold">
      <term><varname>autovacuum_vacuum_threshold</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>autovacuum_vacuum_threshold</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        指定能在一个表上触发<command>VACUUM</>的被插入、被更新或被删除元组的最小数量。默认值为50个元组。该参数只能在<filename>postgresql.conf</>文件或在服务器命令中设置。对个别表可以通过修改存储参数来覆盖该设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-autovacuum-analyze-threshold" xreflabel="autovacuum_analyze_threshold">
      <term><varname>autovacuum_analyze_threshold</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>autovacuum_analyze_threshold</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        指定能在一个表上触发<command>ANALYZE</>的被插入、被更新或被删除元组的最小数量。默认值为50个元组。该参数只能在<filename>postgresql.conf</>文件或在服务器命令中设置。对个别表可以通过修改存储参数来覆盖该设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-autovacuum-vacuum-scale-factor" xreflabel="autovacuum_vacuum_scale_factor">
      <term><varname>autovacuum_vacuum_scale_factor</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>autovacuum_vacuum_scale_factor</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        指定一个表尺寸的分数，在决定是否触发<command>VACUUM</>时将它加到<varname>autovacuum_vacuum_threshold</varname>上。默认值为0.2（表尺寸的20%）。该参数只能在<filename>postgresql.conf</>文件或在服务器命令中设置。对个别表可以通过修改存储参数来覆盖该设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-autovacuum-analyze-scale-factor" xreflabel="autovacuum_analyze_scale_factor">
      <term><varname>autovacuum_analyze_scale_factor</varname> (<type>floating point</type>)
      <indexterm>
       <primary><varname>autovacuum_analyze_scale_factor</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        指定一个表尺寸的分数，在决定是否触发<command>ANALYZE</>时将它加到<varname>autovacuum_analyze_threshold</varname>上。默认值为0.2（表尺寸的20%）。该参数只能在<filename>postgresql.conf</>文件或在服务器命令中设置。对个别表可以通过修改存储参数来覆盖该设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-autovacuum-freeze-max-age" xreflabel="autovacuum_freeze_max_age">
      <term><varname>autovacuum_freeze_max_age</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>autovacuum_freeze_max_age</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        指定在一个<command>VACUUM</>操作被强制执行来防止表中事务ID回卷之前，一个表的<structname>pg_class</>.<structfield>relfrozenxid</>域能保持的最大年龄（事务的）。注意即便自动清理被禁用，系统也将发起自动清理进程来阻止回卷。
       </para>

       <para>
        清理也允许从<filename>pg_clog</>子目录中移除旧文件，这也是为什么默认值被设置为较低的200万事务。该参数只能在服务器启动时设置，但是对于个别表可以通过修改存储参数来降低该设置。详见<xref linkend="vacuum-for-wraparound">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-autovacuum-multixact-freeze-max-age" xreflabel="autovacuum_multixact_freeze_max_age">
      <term><varname>autovacuum_multixact_freeze_max_age</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>autovacuum_multixact_freeze_max_age</varname>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        指定在一个<command>VACUUM</>操作被强制执行来防止表中多事务ID回卷之前，一个表的<structname>pg_class</>.<structfield>relminmxid</>域能保持的最大年龄（多事务的）。注意即便自动清理被禁用，系统也将发起自动清理进程来阻止回卷。
       </para>

       <para>
        清理多事务也允许从<filename>pg_multixact/members</>和<filename>pg_multixact/offsets</>子目录中移除旧文件，这也是为什么默认值被设置为较低的400万多事务。该参数只能在服务器启动时设置，但是对于个别表可以通过修改存储参数来降低该设置。详见<xref linkend="vacuum-for-multixact-wraparound">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-autovacuum-vacuum-cost-delay" xreflabel="autovacuum_vacuum_cost_delay">
      <term><varname>autovacuum_vacuum_cost_delay</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>autovacuum_vacuum_cost_delay</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        指定用于自动<command>VACUUM</>操作中的代价延迟值。如果指定-1（默认值），则使用<xref linkend="guc-vacuum-cost-delay">值。默认值为20毫秒。该参数只能在<filename>postgresql.conf</>文件或在服务器命令中设置。对个别表可以通过修改存储参数来覆盖该设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-autovacuum-vacuum-cost-limit" xreflabel="autovacuum_vacuum_cost_limit">
      <term><varname>autovacuum_vacuum_cost_limit</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>autovacuum_vacuum_cost_limit</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        指定用于自动<command>VACUUM</>操作中的代价限制值。如果指定-1（默认值），则使用<xref linkend="guc-vacuum-cost-limit">值。注意该值被按比例地分配到运行中的自动清理工作者上（如果有多个），因此每一个工作者的限制值之和绝不会超过这个变量中的限制值。该参数只能在<filename>postgresql.conf</>文件或在服务器命令中设置。对个别表可以通过修改存储参数来覆盖该设置。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </sect1>

   <sect1 id="runtime-config-client">
    <title>客户端连接默认值</title>

    <sect2 id="runtime-config-client-statement">
     <title>语句行为</title>
     <variablelist>

     <varlistentry id="guc-search-path" xreflabel="search_path">
      <term><varname>search_path</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>search_path</>配置参数</primary>
      </indexterm>
      <indexterm><primary>path</><secondary>for schemas</></></term>
      <listitem>
       <para>
        这个变量指定当一个对象（表、数据类型、函数等）被用一个无模式限定的简单名称引用时，用于进行搜索该对象的模式顺序。当在不同模式中有同名对象时，将使用第一个在搜索路径中被找到的对象。一个不属于搜索路径中任何一个模式的对象只能通过用限定名（带点号）指定包含它的模式来引用。
       </para>

       <para>
        <varname>search_path</varname>的值必需是一个逗号分隔的模式名列表。任何不是一个已有模式的名称，或者是一个用户不具有<literal>USAGE</>权限的模式，将被安静地忽略。
       </para>

       <para>
        如果列表项之一是特殊名<literal>$user</literal>，则具有<function>SESSION_USER</>返回的名字的模式将取代它（如果有这样一个模式并且该用户有该模式的<literal>USAGE</>权限；如果没有，<literal>$user</literal>会被忽略）。
       </para>

       <para>
        系统目录模式<literal>pg_catalog</>总是被搜索，不管它是否在搜索路径中被提及。如果它在路径中被提及，那么它将被按照路径指定的顺序搜索。如果<literal>pg_catalog</>不在路径中，则它将在任何路径项<emphasis>之前</>被搜索。
       </para>

       <para>
        同样，当前会话的临时表模式<literal>pg_temp_<replaceable>nnn</></>也总是被搜索（如果存在）。它可以在路径中通过使用别名<literal>pg_temp</><indexterm><primary>pg_temp</></>显式列出。如果在路径中没有列出，那么会首先对它进行搜索（甚至是在<literal>pg_catalog</>之前）。然而，临时模式只被用来搜索关系（表、视图、序列等）和数据类型名。它从不用于搜索函数或操作符名。
       </para>

       <para>
        当对象创建时没有指定一个特定目标模式，它们将被放置在<varname>search_path</varname>中第一个合法模式中。如果搜索路径为空将报告一个错误。
       </para>

       <para>
        这个参数的缺省值是<literal>"$user", public</literal>。这种设置支持一个数据库（其中没有用户拥有私有模式，并且所有人共享使用<literal>public</>）   、每个用户私有模式及其组合的共享使用。其它效果可以通过全局或者针对每个用户修改默认搜索路径设置获得。
       </para>

       <para>
        搜索路径的当前有效值可以通过<acronym>SQL</acronym>函数<function>current_schemas</>检查（见<xref linkend="functions-info">）。它和检查<varname>search_path</varname>的值不太一样，因为<function>current_schemas</>显示出现在<varname>search_path</varname>中的项如何被解析。
       </para>

       <para>
        更多关于模式处理的信息，请见<xref linkend="ddl-schemas">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-row-security" xreflabel="row_security">
      <term><varname>row_security</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>row_security</>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
       <para>
        此变量控制是否提高错误以代替应用行安全策略。
        当设置为<literal>on</>时，策略往往适用。
        当设置为<literal>off</>时，查询失败，这将应用至少一个策略。
        默认为<literal>on</>。
        在有限的行可见性引起不正确的结果的位置更改为<literal>off</>。
        例如，<application>pg_dump</>使用缺省更改。
        这个变量不影响避开每行安全策略的角色，
        即超级用户和具有<literal>BYPASSRLS</>属性的角色。
       </para>

       <para>
        关于行安全策略的更多信息，参阅<xref linkend="SQL-CREATEPOLICY">。
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry id="guc-default-tablespace" xreflabel="default_tablespace">
      <term><varname>default_tablespace</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>default_tablespace</>配置参数</primary>
      </indexterm>
      <indexterm><primary>tablespace</><secondary>default</></></term>
      <listitem>
       <para>
        这个变量指定当一个<command>CREATE</>命令没有显式指定一个表空间时，创建对象（表和索引）的默认表空间。
       </para>

       <para>
        该值要么是一个表空间的名字，要么是一个指定使用当前数据库默认表空间的空字符串。如果该值和任何现有表空间的名字都不匹配，<productname>PostgreSQL</>将自动使用当前数据库的默认表空间。如果指定了一个非默认的表空间，用户必须对它有<literal>CREATE</>权限，否则创建企图将失败。
       </para>

       <para>
        这个变量不被用于临时表，对临时表会使用<xref linkend="guc-temp-tablespaces">。
       </para>

       <para>
        当创建数据库时也会使用这个变量。默认情况下，一个新数据库会从它的模板数据库继承其表空间设置。
       </para>

       <para>
        有关表空间的更多的信息，请见<xref linkend="manage-ag-tablespaces">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-temp-tablespaces" xreflabel="temp_tablespaces">
      <term><varname>temp_tablespaces</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>temp_tablespaces</>配置参数</primary>
      </indexterm>
      <indexterm><primary>tablespace</><secondary>temporary</></></term>
      <listitem>
       <para>
        这个变量指定当一个<command>CREATE</>命令没有显式指定一个表空间时，创建临时对象（临时表和临时表上的索引）的默认表空间。用于排序大型数据集的临时文件也被创建在这些表空间中。
       </para>

       <para>
        该值是一个表空间名字的列表。当列表中有多于一个名称时，每次一个临时对象被创建时<productname>PostgreSQL</>随机选择列表中的一个成员。例外是在一个事务中，连续创建的临时对象被放置在里表中的连续表空间中。如果列表被选中元素是一个空字符串，<productname>PostgreSQL</>将自动使用当前数据库的默认表空间。
       </para>

       <para>
        当<varname>temp_tablespaces</>被交互式地设置时，指定一个不存在的表空间是一种错误，类似于为用户指定一个不具有<literal>CREATE</>权限的表空间。不过，当使用一个之前设置的值时，不存在的表空间会被忽略，就像用户缺少<literal>CREATE</>权限的表空间一样。特殊地，使用一个在<filename>postgresql.conf</>中设置的值时，这条规则起效。
       </para>

       <para>
        默认值是一个空字符串，它使得所有临时对象被创建在当前数据库的默认表空间中。
       </para>

       <para>
        参阅<xref linkend="guc-default-tablespace">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-check-function-bodies" xreflabel="check_function_bodies">
      <term><varname>check_function_bodies</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>check_function_bodies</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        这个参数通常为打开 。当设置为<literal>off</>时，它禁用<xref linkend="sql-createfunction">期间对函数体字符串的验证。禁用验证避免了验证处理的副作用并且避免了如向前引用导致的伪肯定。在代表其他用户载入函数之前设置这个参数为<literal>off</>；<application>pg_dump</>会自动这样做。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-default-transaction-isolation" xreflabel="default_transaction_isolation">
      <term><varname>default_transaction_isolation</varname> (<type>enum</type>)
      <indexterm>
       <primary>transaction isolation level</primary>
       <secondary>setting default</secondary>
      </indexterm>
      <indexterm>
       <primary><varname>default_transaction_isolation</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        每个 SQL 事务都有一个隔离级别，可以是<quote>读未提交</quote>、<quote>读已提交</quote>、<quote>可重复读</quote>或者<quote>可序列化</quote>。这个参数控制每个新事务的默认隔离级别。默认是<quote>读已提交</quote>。
       </para>

       <para>
        更多信息请参阅<xref linkend="mvcc">和<xref linkend="sql-set-transaction">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-default-transaction-read-only" xreflabel="default_transaction_read_only">
      <term><varname>default_transaction_read_only</varname> (<type>boolean</type>)
      <indexterm>
       <primary>read-only transaction</primary>
       <secondary>setting default</secondary>
      </indexterm>
      <indexterm>
       <primary><varname>default_transaction_read_only</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        一个只读的 SQL 事务不能修改非临时表。这个参数控制每个新事务的默认只读状态 。默认是<literal>off</>（读/写）。
       </para>

       <para>
        更多信息请参考<xref linkend="sql-set-transaction">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-default-transaction-deferrable" xreflabel="default_transaction_deferrable">
      <term><varname>default_transaction_deferrable</varname> (<type>boolean</type>)
      <indexterm>
       <primary>deferrable transaction</primary>
       <secondary>setting default</secondary>
      </indexterm>
      <indexterm>
       <primary><varname>default_transaction_deferrable</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        当运行在<literal>可序列化</>隔离级别时，一个可延迟只读 SQL 事务可以在它被允许继续之前延迟一段时间。但是，一旦它开始执行就不会产生任何用来保证可序列化性的负荷；因此序列化代码将没有任何理由因为并发更新而强制它中断，使得这个选项适合于长时间运行的只读事务。
        </para>

        <para>
        这个参数控制每个新事务的默认可延迟状态。目前它对读写事务或者那些操作在低于<literal>可序列化</>隔离级别上的事务无效。默认值是<literal>off</>。
       </para>

       <para>
        详情请参阅<xref linkend="sql-set-transaction">。
       </para>
      </listitem>
     </varlistentry>


     <varlistentry id="guc-session-replication-role" xreflabel="session_replication_role">
      <term><varname>session_replication_role</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>session_replication_role</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        为当前会话控制复制相关的触发器和规则的触发。需要超级用户权限才能设置这个变量，并且会导致丢弃任何之前缓存下来的查询计划。可能的值有<literal>origin</>（默认）、<literal>replica</>和<literal>local</>。详见<xref linkend="sql-altertable">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-statement-timeout" xreflabel="statement_timeout">
      <term><varname>statement_timeout</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>statement_timeout</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        中止任何使用了超过指定毫秒数的语句，从命令到达服务器开始计时。如果<varname>log_min_error_statement</>被设置为<literal>ERROR</>或更低，语句如果超时也会被记录。一个零值（默认）将关闭这个参数。
       </para>

       <para>
        我们不推荐在<filename>postgresql.conf</>中设置<varname>statement_timeout</>，因为它会影响所有会话。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-lock-timeout" xreflabel="lock_timeout">
      <term><varname>lock_timeout</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>lock_timeout</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        如果任何语句在试图获取表、索引、行或其他数据库对象上的锁时等到超过指定的毫秒数，该语句将被中止。该时间限制独立地应用于每一次锁获取尝试。该限制会应用到显式锁定请求（如<command>LOCK TABLE</>或不带<literal>NOWAIT</>的<command>SELECT FOR UPDATE</> without <literal>NOWAIT</>）和隐式获得的锁。如果<varname>log_min_error_statement</>被设置为<literal>ERROR</>或更低，超时的语句会被记录。一个零值（默认）将关闭这个参数。
       </para>

       <para>
        与<varname>statement_timeout</>不同，这个超时只在等待锁时发生。注意如果<varname>statement_timeout</>为非零，设置<varname>lock_timeout</>为相同或更大的值没有意义，因为事务超时将总是第一个被触发。
       </para>

       <para>
        我们不推荐在<filename>postgresql.conf</>中设置<varname>lock_timeout</>，因为它会影响所有会话。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-vacuum-freeze-table-age" xreflabel="vacuum_freeze_table_age">
      <term><varname>vacuum_freeze_table_age</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>vacuum_freeze_table_age</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        当表的<structname>pg_class</>.<structfield>relfrozenxid</>域达到该设置指定的年龄时，<command>VACUUM</>会执行一次全表扫描。默认值是 1.5 亿个事务。尽管用户可以把这个值设置为从 0 到 20 亿，<command>VACUUM</>会悄悄地将有效值设置为<xref linkend="guc-autovacuum-freeze-max-age">值的95%，因此在表上启动一次反回卷自动清理之前有机会进行一次定期手动<command>VACUUM</>。更多信息请见<xref linkend="vacuum-for-wraparound">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-vacuum-freeze-min-age" xreflabel="vacuum_freeze_min_age">
      <term><varname>vacuum_freeze_min_age</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>vacuum_freeze_min_age</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        指定<command>VACUUM</>在扫描表时用来决定是否冻结行版本的切断年龄（以事务计）。默认值是 5 千万个事务。尽管用户可以将这个值设置为从 0 到 10 亿，<command>VACUUM</>会悄悄地将有效值设置为<xref linkend="guc-autovacuum-freeze-max-age">值的一半，这样在强制执行的自动清理之间不会有过短的时间间隔。更多信息请见<xref linkend="vacuum-for-wraparound">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-vacuum-multixact-freeze-table-age" xreflabel="vacuum_multixact_freeze_table_age">
      <term><varname>vacuum_multixact_freeze_table_age</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>vacuum_multixact_freeze_table_age</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        如果表的<structname>pg_class</>.<structfield>relminmxid</>域超过了这个设置指定的年龄，<command>VACUUM</>会执行一次全表扫描。默认值是 1.5 亿个组合事务。尽管用户可以把这个值设置为从 0 到 20 亿，<command>VACUUM</>会悄悄地将有效值设置为<xref linkend="guc-autovacuum-multixact-freeze-max-age">值的95%，因此在表上启动一次反回卷自动清理之前有机会进行一次定期手动<command>VACUUM</>。更多信息请见<xref linkend="vacuum-for-multixact-wraparound">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-vacuum-multixact-freeze-min-age" xreflabel="vacuum_multixact_freeze_min_age">
      <term><varname>vacuum_multixact_freeze_min_age</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>vacuum_multixact_freeze_min_age</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        指定<command>VACUUM</>在扫描表时用来决定是否把组合事务 ID 替换为一个更新的事务 ID 或组合事务 ID 的切断年龄（以组合事务计）。默认值是 5 千万个组合事务。尽管用户可以将这个值设置为从 0 到 10 亿，<command>VACUUM</>会悄悄地将有效值设置为<xref linkend="guc-autovacuum-multixact-freeze-max-age">值的一半，这样在强制执行的自动清理之间不会有过短的时间间隔。更多信息请见<xref linkend="vacuum-for-multixact-wraparound">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-bytea-output" xreflabel="bytea_output">
      <term><varname>bytea_output</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>bytea_output</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        设置<type>bytea</type>类型值的输出格式。有效值是<literal>hex</literal>（默认）和 <literal>escape</literal>（传统的 PostgreSQL 格式）。详见<xref linkend="datatype-binary">。不管这个设置的值如何，<type>bytea</type>类型总是接受这两种格式的输入。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-xmlbinary" xreflabel="xmlbinary">
      <term><varname>xmlbinary</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>xmlbinary</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        设置二进制值如何被编码为 XML。例如，这适用于通过<function>xmlelement</function>函数或<function>xmlforest</function>函数将<type>bytea</type>值转换到 XML 值。可能的值有<literal>base64</literal>和<literal>hex</literal>，它们都是用 XML 模式标准定义的。默认值是<literal>base64</literal>。更多关于 XML 相关函数的信息可参阅<xref linkend="functions-xml">。
       </para>

       <para>
        这里的实际选择都是根据爱好做出的，只受客户端应用中可能存在的限制的约束。两种方法都支持所有可能的值，尽管十六进制编码将比 base64 编码更大。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-xmloption" xreflabel="xmloption">
      <term><varname>xmloption</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>xmloption</>配置参数</primary>
      </indexterm>
      <indexterm>
       <primary><varname>SET XML OPTION</></primary>
      </indexterm>
      <indexterm>
       <primary>XML option</primary>
      </indexterm></term>
      <listitem>
       <para>
        当在XML和字符串值之间进行转换时，无论设置DOCUMENT或 CONTENT都是隐式的。可参阅Section 8.13。 有效值是DOCUMENT和CONTENT。 缺省值是CONTENT。
        当在 XML 和字符串值之间进行转换时，设置<literal>DOCUMENT</literal>或<literal>CONTENT</literal>都是隐式的。详见<xref linkend="datatype-xml">。有效值是<literal>DOCUMENT</literal>和<literal>CONTENT</literal>。默认值是<literal>CONTENT</literal>。
       </para>

       <para>
        根据 SQL 标准，设置这个选项的命令是：
<synopsis>
SET XML OPTION { DOCUMENT | CONTENT };
</synopsis>
        这种语法在 PostgreSQL 也可用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-gin-pending-list-limit" xreflabel="gin_pending_list_limit">
      <term><varname>gin_pending_list_limit</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>gin_pending_list_limit</>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
       <para>
         当启用<literal>fastupdate</>时，设置正在使用的GIN挂起列表的最大尺寸。
         如果列表增长大于这个最大尺寸，
         通过移动块存储的主要的GIN数据结构项进行清理。
         默认值为四字节(<literal>4MB</>)。
         为单个GIN索引改变索引存储参数来重写此设置。
         参阅<xref linkend="gin-fast-update">和<xref linkend="gin-tips">
         获取更多信息。
       </para>
      </listitem>
     </varlistentry>
     
     </variablelist>
    </sect2>
     <sect2 id="runtime-config-client-format">
     <title>区域和格式化</title>

     <variablelist>

     <varlistentry id="guc-datestyle" xreflabel="DateStyle">
      <term><varname>DateStyle</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>DateStyle</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        设置日期和时间值的显示格式，以及解释有歧义的日期输入值的规则。由于历史原因， 这个变量包含两个独立的部分：输出格式声明（<literal>ISO</>、<literal>Postgres</>、<literal>SQL</>或<literal>German</>）、 输入/输出的年/月/日顺序（<literal>DMY</>、<literal>MDY</>或<literal>YMD</>）。这些可以被独立设置或者一起设置。关键字<literal>Euro</>和<literal>European</>是<literal>DMY</>的同义词；关键字<literal>US</>、<literal>NonEuro</>和<literal>NonEuropean</>是<literal>MDY</>的同义词。详见<xref linkend="datatype-datetime">。内建默认值是<literal>ISO, MDY</>，但是<application>initdb</application>将用对应于选中的<varname>lc_time</varname>区域行为的设置初始化配置文件。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-intervalstyle" xreflabel="IntervalStyle">
      <term><varname>IntervalStyle</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>IntervalStyle</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        设置间隔值的显示格式。值<literal>sql_standard</>将产生匹配 SQL 标准间隔文本的输出。当<xref linkend="guc-datestyle">参数被设置为<literal>ISO</>时，值<literal>postgres</>（默认）将产生匹配<productname>PostgreSQL</>发行 8.4 之前的输出。当<varname>DateStyle</>参数被设置为非<literal>ISO</>输出时，值<literal>postgres_verbose</>会产生匹配<productname>PostgreSQL</>发行 8.4 之前的输出。值<literal>iso_8601</>会产生匹配在 ISO 8601 的 4.4.3.2 节中定义的<quote>带标志符格式</>的时间间隔的输出。
       </para>
       <para>
        <varname>IntervalStyle</>参数也可以影响对有歧义的间隔输入的解释。详见<xref linkend="datatype-interval-input">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-timezone" xreflabel="TimeZone">
      <term><varname>TimeZone</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>TimeZone</>配置参数</primary>
      </indexterm>
      <indexterm><primary>time zone</></></term>
      <listitem>
       <para>
        设置用于显示和解释时间戳的时区。内建默认值是<literal>GMT</>，但是它通常会在<filename>postgresql.conf</>中被覆盖；<application>initdb</>将安装一个对应于其系统环境的设置。详见<xref linkend="datatype-timezones">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-timezone-abbreviations" xreflabel="timezone_abbreviations">
      <term><varname>timezone_abbreviations</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>timezone_abbreviations</>配置参数</primary>
      </indexterm>
      <indexterm><primary>time zone names</></></term>
      <listitem>
       <para>
        设置服务器接受的日期时间输入中使用的时区缩写集合。默认值为<literal>'Default'</>， 这个集合在全世界大多数地方都能工作。也还有<literal>'Australia'</literal>和<literal>'India'</literal>，以及可能为一种特定安装定义的其他集合。详见<xref linkend="datetime-config-files">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-extra-float-digits" xreflabel="extra_float_digits">
      <term><varname>extra_float_digits</varname> (<type>integer</type>)
      <indexterm>
       <primary>significant digits</primary>
      </indexterm>
      <indexterm>
       <primary>floating-point</primary>
       <secondary>display</secondary>
      </indexterm>
      <indexterm>
       <primary><varname>extra_float_digits</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        这个参数为浮点值调整显示的位数，包括<type>float4</>、<type>float8</>以及几何数据类型。参数值被加在标准的位数（<literal>FLT_DIG</>或<literal>DBL_DIG</>，视情况而定）上。该值最高可以被设置为 3 来包括部分有效位；这特别有助于转储需要被准确恢复的否点数据。或者它可以被设置为负值来消除不需要的位。另请参见<xref linkend="datatype-float">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-client-encoding" xreflabel="client_encoding">
      <term><varname>client_encoding</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>client_encoding</>配置参数</primary>
      </indexterm>
      <indexterm><primary>character set</></></term>
      <listitem>
       <para>
        设置客户端编码（字符集）。默认使用数据库编码。<productname>PostgreSQL</productname>服务器所支持的字符集在<xref linkend="multibyte-charset-supported">中描述。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-lc-messages" xreflabel="lc_messages">
      <term><varname>lc_messages</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>lc_messages</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        设置消息显示的语言。可接受的值是系统相关的；详见<xref linkend="locale">。如果这个变量被设置为空字符串（默认），那么该值将以一种系统相关的方式从服务器的执行环境中继承。
       </para>

       <para>
        在一些系统上，这个区域分类并不存在。仍然可以设置这个变量，只是不会有任何效果。同样，所期望语言的翻译消息也可能不存在。在这种情况下，你将仍然继续看到英文消息。
       </para>

       <para>
        只有超级用户可以改变这个设置。因为它同时影响发送到服务器日志和客户端的消息。一个不正确的值可能会降低服务器日志的可读性。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-lc-monetary" xreflabel="lc_monetary">
      <term><varname>lc_monetary</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>lc_monetary</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        设置用于格式化货币量的区域，例如用<function>to_char</function>函数族。可接受的值是系统相关的；详见<xref linkend="locale">。如果这个变量被设置为空字符串（默认），那么该值将以一种系统相关的方式从服务器的执行环境中继承。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-lc-numeric" xreflabel="lc_numeric">
      <term><varname>lc_numeric</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>lc_numeric</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        设置用于格式化数字的区域，例如用<function>to_char</function>函数族。可接受的值是系统相关的；详见<xref linkend="locale">。如果这个变量被设置为空字符串（默认），那么该值将以一种系统相关的方式从服务器的执行环境中继承。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-lc-time" xreflabel="lc_time">
      <term><varname>lc_time</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>lc_time</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        设置用于格式化日期和时间的区域，例如用<function>to_char</function>函数族。可接受的值是系统相关的；详见<xref linkend="locale">。如果这个变量被设置为空字符串（默认），那么该值将以一种系统相关的方式从服务器的执行环境中继承。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-default-text-search-config" xreflabel="default_text_search_config">
      <term><varname>default_text_search_config</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>default_text_search_config</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        选择被那些没有显式参数指定配置的文本搜索函数变体使用的文本搜索配置。详见<xref linkend="textsearch">。内建默认值是<literal>pg_catalog.simple</>，但是如果能够标识一个匹配区域的配置，<application>initdb</application>将用对应于选中的<varname>lc_ctype</varname>区域的设置初始化配置文件。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>

    </sect2>

     <sect2 id="runtime-config-client-preload">
     <title>共享库预载入</title>

     <para>
      为了载入附加的功能或者达到提高性能的目的，可用多个设置来预先载入共享库到服务器中。
      例如<literal>'$libdir/mylib'</literal>设置可能会导致<literal>mylib.so</>（或者某些平台上的<literal>mylib.sl</>）从安装的标准库目录被预装载。这些设置之间的区别在于生效的时间以及改变它们所需的特权。
     </para>

     <para>
      可以用这个方法预装载<productname>PostgreSQL</productname>的过程语言库，通常是使用<literal>'$libdir/plXXX'</literal>语法，其中的<literal>XXX</literal>是<literal>pgsql</>、<literal>perl</>、<literal>tcl</>或<literal>python</>。
     </para>

     <para>
      对于每个参数，如果要载入多于一个库，用逗号分隔它们的名称。除非被双引号包围，所有的库名
      称会被转换成小写形式。
     </para>

     <para>
      只有特别为与PostgreSQL一起使用设计的共享库才能以这种方式载入。每一个PostgreSQL支持
      的库都有一个<quote>魔法块</>，它会被检查以保证兼容性。由于这个原因，非PostgreSQL无法
      以这种方式被载入。你可能可以使用操作系统的工具（如<envar>LD_PRELOAD</envar>）载入它。
     </para>

     <para>
      总之，请参考特定模块的文档来用推荐的方法载入它。
     </para>

     <variablelist>
     <varlistentry id="guc-local-preload-libraries" xreflabel="local_preload_libraries">
      <term><varname>local_preload_libraries</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>local_preload_libraries</>配置参数</primary>
      </indexterm>
      <indexterm>
       <primary><filename>$libdir/plugins</></primary>
      </indexterm>
      </term>
      <listitem>
       <para>
        这个变量指定一个或者多个要在连接开始时预载入的共享库。
        这个参数在连接启动时起作用，对后续更改没有影响。
        如果指定的库没有找到，连接尝试将会失败。    
       </para>

       <para>
        任何用户都能设置这个选项。正因为如此，能被这样载入的库被严格限制为出现于安装的标准库
        目录中<filename>plugins</>子目录下的共享库（保证只有<quote>安全的</>库被安装到
        这里是数据库管理员的责任）。<varname>local_preload_libraries</>中的项可以显式
        指定这个目录，例如<literal>$libdir/plugins/mylib</literal>，或者只是指定库的
        名称 &mdash; <literal>mylib</literal> 和
        <literal>$libdir/plugins/mylib</literal>的效果是相同的。
       </para>

       <para>
        这个功能的目的是允许非特权用户加载调试或性能测量库到特定会话，
        而不需要显式的<command>LOAD</>命令。
        为达到此目的，典型的使用<envar>PGOPTIONS</envar>环境变量或使用<command>ALTER ROLE SET</>设置这个参数。
       </para>
       
       <para>
        除非一个模块被特别设计成由非超级用户以这种方式使用，通常不推荐使用这个设置。应该看看
        <xref linkend="guc-session-preload-libraries">。
       </para>
      </listitem>
     </varlistentry>


     <varlistentry id="guc-session-preload-libraries" xreflabel="session_preload_libraries">
      <term><varname>session_preload_libraries</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>session_preload_libraries</>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
       <para>
        这个变量指定一个或者多个要在连接开始时预载入的共享库。只有超级用户更够更改这个设置。
        这个参数只在连接开始时起效。后续的改变没有效果。如果指定的库没有找到，连接尝试将会失败。
       </para>

       <para>
        这个特性的意图是允许在特定会话中载入调试用的或者测量性能的库，而不需要显式的给出一个
        <command>LOAD</>命令。例如，通过用<command>ALTER ROLE SET</>设置这个参数可以
        为一个给定用户名下的所有会话启用<xref linkend="auto-explain">。还有，无需重启
        服务器就能更改这个参数（但是只有新会话启动时才会生效），这样可以以这种方式更容易地增
        加新模块，即便它们会应用到所有会话。
       </para>

       <para>
        和<xref linkend="guc-shared-preload-libraries">不同，相对于在库被第一次使用
        时载入它，在会话开始时载入库并没有什么性能优势。不过，当使用连接池时这样做还是有一些
        优势。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-shared-preload-libraries" xreflabel="shared_preload_libraries">
      <term><varname>shared_preload_libraries</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>shared_preload_libraries</>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
       <para>
        这个变量指定一个或者多个要在服务器启动时预载入的共享库。这个参数只能在服务器启动时设置。
        如果指定的库没有找到，服务器将无法启动。
       </para>

       <para>
        有些库需要执行只能在postmaster启动时发生的特定操作，例如分配共享内存、保留轻量级锁
        或者启动后台工作者。这些库必须通过这个参数在服务器启动时载入。每个库的详情请见文档。
       </para>

       <para>
        其他库也能被预载入。通过预载入一个共享库，当该库被第一次使用时就可以避免库的启动时间。
        不过，启动每个新服务器进程的时间可能会略有增加，即使该进程从不使用该库。因此，推荐只
        把这个参数用于那些要在大多数会话中使用的库上。还有，改变这个参数要求重启服务器，因此
        对于短期的调试任务来说这不是好的选择，应该转用
        <xref linkend="guc-session-preload-libraries">。
       </para>

      <note>
       <para>
        在 Windows 主机上，在服务器启动时预载入一个库并不会减少启动每个新服务器进程所需的
        时间；每一个服务器进程将会重新载入预载入的库。不过，对于那些要在postmaster启动时
        执行操作的库来说，Windows 主机上的
        <varname>shared_preload_libraries</varname>任然有用。
       </para>
      </note>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect2>

     <sect2 id="runtime-config-client-other">
     <title>其他默认值</title>

     <variablelist>

     <varlistentry id="guc-dynamic-library-path" xreflabel="dynamic_library_path">
      <term><varname>dynamic_library_path</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>dynamic_library_path</>配置参数</primary>
      </indexterm>
      <indexterm><primary>dynamic loading</></></term>
      <listitem>
       <para>
        如果需要打开一个可以动态装载的模块并且在<command>CREATE FUNCTION</command>或<command>LOAD</command>命令中指定的文件名没有目录部分（即名字中不包含斜线），那么系统将搜索这个路径以查找所需的文件。
       </para>

       <para>
        <varname>dynamic_library_path</varname>的值必须是一个冒号分隔（或者在 Windows 上以分号分隔）的绝对目录路径的列表。如果一个列表元素以特殊字符串开始，<literal>$libdir</literal>会被替换为<productname>PostgreSQL</productname>包中已编译好的库目录。这里是<productname>PostgreSQL</productname>发布提供的模块被安装的位置（使用<literal>pg_config --pkglibdir</literal>来找到这个目录的名字）。例如：
<programlisting>
dynamic_library_path = '/usr/local/lib/postgresql:/home/my_project/lib:$libdir'
</programlisting>
        或者在 Windows 环境中：
<programlisting>
dynamic_library_path = 'C:\tools\postgresql;H:\my_project\lib;$libdir'
</programlisting>
       </para>

       <para>
        这个参数的默认值是<literal>'$libdir'</literal>。如果该值被设置为一个空字符串，则关闭自动路径搜索。
       </para>

       <para>
        这个参数可以在运行时由超级用户修改，但是这样修改的设置只能保持到这个客户端连接的结尾，因此这个方法应该保留给开发目的。 我们建议在<filename>postgresql.conf</filename>配置文件中设置这个参数。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-gin-fuzzy-search-limit" xreflabel="gin_fuzzy_search_limit">
      <term><varname>gin_fuzzy_search_limit</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>gin_fuzzy_search_limit</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        GIN 索引返回的集合尺寸的软上限。详见<xref linkend="gin-tips">。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect2>
   </sect1>

   <sect1 id="runtime-config-locks">
    <title>锁管理</title>

     <variablelist>

     <varlistentry id="guc-deadlock-timeout" xreflabel="deadlock_timeout">
      <term><varname>deadlock_timeout</varname> (<type>integer</type>)
      <indexterm>
       <primary>deadlock</primary>
       <secondary>timeout during</secondary>
      </indexterm>
      <indexterm>
       <primary>timeout</primary>
       <secondary>deadlock</secondary>
      </indexterm>
      <indexterm>
       <primary><varname>deadlock_timeout</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        这是进行死锁检测之前在一个锁上等待的总时间（以毫秒计）。死锁检测相对昂贵，因此服务器不会在每次等待锁时都运行这个它。我们乐观地假设在生产应用中死锁是不常出现的，并且只在开始检测死锁之前等待一会儿。增加这个值就减少了浪费在无用的死锁检测上的时间，但是减慢了报告真正死锁错误的速度。默认是 1 秒（<literal>1s</>），这可能是实际中你想要的最小值。在一个高负载的服务器上，你可能需要增大它。这个值的理想设置应该超过你通常的事务时间，这样就可以减少在锁释放之前就开始死锁检查的机会。只有超级用户可以更改这个设置。
       </para>

       <para>
        当<xref linkend="guc-log-lock-waits">被设置时，这个参数还可以决定发出关于锁等待的日志之前等待的时长。如果你想调查锁延迟，你可能希望设置一个比正常的<varname>deadlock_timeout</varname>小的值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-locks-per-transaction" xreflabel="max_locks_per_transaction">
      <term><varname>max_locks_per_transaction</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_locks_per_transaction</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        共享锁表跟踪在<varname>max_locks_per_transaction</varname> * (<xref
        linkend="guc-max-connections"> + <xref
        linkend="guc-max-prepared-transactions">) 个对象（如表）上的锁。因此，在任何一个时刻，只有不超过这么多个可区分对象能够被锁住。这个参数控制为每个事务分配的对象锁的平均数量。个体事务可以锁住更多对象，数量可以和锁表中能容纳的所有事务的锁一样多。这<emphasis>not</>是能被锁住的行数，那个值是没有限制的。默认值 64 已经被历史证明是足够的，但是如果你有需要在一个事务中使用很多不同表的查询（例如查询一个有很多子表的父表），你可能需要提高这个值。这个参数只能在服务器启动时设置。
       </para>

       <para>
        当运行一个后备服务器时，你必须设置这个参数为大于等于主服务器上的值。否则，后备服务器上将不允许查询。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-pred-locks-per-transaction" xreflabel="max_pred_locks_per_transaction">
      <term><varname>max_pred_locks_per_transaction</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_pred_locks_per_transaction</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        共享谓词锁表跟踪在<varname>max_pred_locks_per_transaction</varname> * (<xref
        linkend="guc-max-connections"> + <xref
        linkend="guc-max-prepared-transactions">) 个对象（如表）上的锁。因此，在任何一个时刻，只有不超过这么多个可区分对象能够被锁住。这个参数控制为每个事务分配的对象锁的平均数量。个体事务可以锁住更多对象，数量可以和锁表中能容纳的所有事务的锁一样多。这<emphasis>not</>是能被锁住的行数，那个值是没有限制的。默认值 64 已经在测试中被证明通常是足够的，但是如果你有需要在一个可序列化事务中使用很多不同表的查询（例如查询一个有很多子表的父表），你可能需要提高这个值。这个参数只能在服务器启动时设置。
       </para>

      </listitem>
     </varlistentry>

     </variablelist>
   </sect1>

   <sect1 id="runtime-config-compatible">
    <title>版本和平台兼容性</title>

    <sect2 id="runtime-config-compatible-version">
     <title>以前的 PostgreSQL 版本</title>

     <variablelist>

     <varlistentry id="guc-array-nulls" xreflabel="array_nulls">
      <term><varname>array_nulls</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>array_nulls</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        这个参数控制数组输入解析器是否把未用引号的<literal>NULL</>识别为一个空数组元素。默认为<literal>on</>，允许输入包含空值的数组值。但是<productname>PostgreSQL</> 8.2 之前的版本不支持数组中的空值，并且因此将把<literal>NULL</>当作指定一个值为字符串<quote>NULL</>的正常数组元素。对于那些要求旧行为的应用的向后兼容性，这个变量可以被设置为<literal>off</>。
       </para>

       <para>
        注意即使这个变量为<literal>off</>也能够创建包含空值的数组值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-backslash-quote" xreflabel="backslash_quote">
      <term><varname>backslash_quote</varname> (<type>enum</type>)
      <indexterm><primary>strings</><secondary>backslash quotes</></>
      <indexterm>
       <primary><varname>backslash_quote</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        这个参数控制字符串文本中的单引号是否能够用<literal>\'</>来表示。首选的 SQL 标准的方法是将其双写（<literal>''</>），但是<productname>PostgreSQL</>在历史上也接受<literal>\'</>。不过使用<literal>\'</>容易导致安全风险，因为在某些客户端字符集编码中，有多字节字符的最后一个字节在数值上等价于 ASCII 的<literal>\'</>。如果客户端代码没有做到正确转义，那么将会导致 SQL 注入攻击。如果服务器拒绝看起来带有被反斜线转义的单引号的查询，那么就可以避免这种风险。<varname>backslash_quote</>的可用值是<literal>on</>（总是允许<literal>\'</>）、<literal>off</>（总是拒绝）以及<literal>safe_encoding</>（只有客户端编码不允许在多字节字符中存在 ASCII <literal>\</>时允许）。<literal>safe_encoding</>是默认设置。
       </para>

       <para>
        注意在符合标准的字符串文本中，<literal>\</>就表示<literal>\</>。这个参数只影响不符合标准的文本的处理，包括转义字符串语法（<literal>E'...'</>）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-default-with-oids" xreflabel="default_with_oids">
      <term><varname>default_with_oids</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>default_with_oids</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        这个参数控制<command>CREATE TABLE</command>和<command>CREATE TABLE AS</command>在既没有指定<literal>WITH OIDS</literal>也没有指定<literal>WITHOUT OIDS</literal>的情况下，是否在新创建的表中包含 OID 列。它还决定被<command>SELECT INTO</command>创建的表里面是否包含 OID 。这个参数在默认情况下为<literal>off</>。在<productname>PostgreSQL</> 8.0 及更早的版本中，它默认为<literal>on</>。
       </para>

       <para>
        我们反对在用户表中使用 OID ，因此大多数安装应该禁用这个变量。需要为一个特殊表使用 OID 的应用应该在创建表的时候指定<literal>WITH OIDS</literal>。为了兼容不遵循这一行为的老旧应用，这个变量可以被启用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-escape-string-warning" xreflabel="escape_string_warning">
      <term><varname>escape_string_warning</varname> (<type>boolean</type>)
      <indexterm><primary>strings</><secondary>escape warning</></>
      <indexterm>
       <primary><varname>escape_string_warning</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        打开时，如果在普通字符串文本中（<literal>'...'</>语法）出现了 一个反斜线（<literal>\</>）并且<varname>standard_conforming_strings</varname>为关闭，那么就会发出一个警告。默认值是<literal>on</>。
       </para>
       <para>
        希望使用反斜线作为转义符的应用应该被修改来使用转义字符串语法（<literal>E'...'</>），因为在 SQL 标准中普通字符串的默认行为是将反斜线视作一个普通字符。这个变量可以被启用来帮助定位需要被更改的代码。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-lo-compat-privileges" xreflabel="lo_compat_privileges">
      <term><varname>lo_compat_privileges</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>lo_compat_privileges</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        在9.0之前的版本中，大对象没有连接权限，并且对所有用户哦都市可读可写的。 将这个变量设置为on，从而禁用新的权限检查，以与以前的版本兼容。 默认是off。In <productname>PostgreSQL</> releases prior to 9.0, large objects
        did not have access privileges and were, therefore, always readable
        and writable by all users.  Setting this variable to <literal>on</>
        disables the new privilege checks, for compatibility with prior
        releases.  The default is <literal>off</>.
        只有超级用户可以更改这个设置。
       </para>
       <para>
        设置这个参数不会禁用所有与大对象相关的安全检查 &mdash; 除了那些在<productname>PostgreSQL</> 9.0中已经修改了的默认行为。例如，<literal>lo_import()</literal>和<literal>lo_export()</literal>需要超级用户权限而不管这个设置。
       </para>
      </listitem>
     </varlistentry>
         
     <varlistentry id="guc-operator-precedence-warning" xreflabel="operator_precedence_warning">
      <term><varname>operator_precedence_warning</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>operator_precedence_warning</>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
       <para>
        当开启时，解析器为了可能修改的任何结构发出警告，
        意味着<productname>PostgreSQL</> 9.4操作符优先级中作为修改结果。     
        对审计应用程序是非常有用的，
        看看是否优先更改会打断任何东西；
        但它并不意味着在生成过程中保持开启，
        因为它会对一些完全有效的，符合标准的SQL代码发出警告。
        缺省<literal>off</>。
       </para>

       <para>
           参阅<xref linkend="sql-precedence">获取更多信息。
       </para>
      </listitem>
     </varlistentry>

    <varlistentry id="guc-quote-all-identifiers" xreflabel="quote-all-identifiers">
      <term><varname>quote_all_identifiers</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>quote_all_identifiers</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        当数据库产生 SQL 时，强制所有标识符被引号包围，即使它们（当前）不是关键字。这将影响<command>EXPLAIN</>的输出以及<function>pg_get_viewdef</>等函数的结果。另请参阅<xref linkend="app-pgdump">和<xref linkend="app-pg-dumpall">的<option>--quote-all-identifiers</option>选项。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-sql-inheritance" xreflabel="sql_inheritance">
      <term><varname>sql_inheritance</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>sql_inheritance</>配置参数</primary>
      </indexterm>
      <indexterm><primary>inheritance</></></term>
      <listitem>
       <para>
        这个设置控制未修饰的表引用是否被视作要包括继承的子表。默认值是<literal>on</>，它表示包括子表（因此，默认假定一个<literal>*</>后缀）。如果被设置为<literal>off</>，不包括子表（因此，假设一个<literal>ONLY</literal>前缀）。SQL 标准要求子表被包括在内，因此<literal>off</>设置不是说明兼容的，但是被提供用来满足对<productname>PostgreSQL</>版本 7.1 之前的兼容性。详见<xref linkend="ddl-inherit">。
       </para>

       <para>
        我们已经废弃了关闭<varname>sql_inheritance</>，因为那个行为已经被发现容易产生错误并且与 SQL 标准矛盾。本手册中其他地方讨论继承行为时通常假设它被设置为<literal>on</>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-standard-conforming-strings" xreflabel="standard_conforming_strings">
      <term><varname>standard_conforming_strings</varname> (<type>boolean</type>)
      <indexterm><primary>strings</><secondary>standard conforming</></>
      <indexterm>
       <primary><varname>standard_conforming_strings</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        控制普通字符串文本（<literal>'...'</>）是否按照 SQL 标准把反斜线当普通文本。从<productname>PostgreSQL</productname> 9.1 开始，默认值为<literal>on</>（之前的发行中默认值为<literal>off</>）。应用可以检查这个参数来判断字符串文本如何被处理。这个参数的存在也可以被当做转义字符串语法（<literal>E'...'</>）被支持的标志。如果一个应用希望反斜线被当做转义字符，应该使用转义字符串语法（<xref linkend="sql-syntax-strings-escape">）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-synchronize-seqscans" xreflabel="synchronize_seqscans">
      <term><varname>synchronize_seqscans</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>synchronize_seqscans</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        它允许对大型表的顺序扫描与其他扫描同步，因此并发扫描可以在几乎相同的时刻读取相同的块，这样可以分担 I/O 负载。当启用这个参数时，一个扫描可能会从表的中间开始并且之后<quote>绕回</>到开头以覆盖所有的行，这样可以与已在进行中的扫描活动同步。对于没有<literal>ORDER BY</>子句的查询来，这样的扫描会在返回行的顺序中造成不可预料的改变。将这个参数设置为<literal>off</>以保证 8.3 之前的行为（顺序扫描总是从表的起始处开始）。默认值是<literal>on</>。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect2>

    <sect2 id="runtime-config-compatible-clients">
     <title>平台和客户端兼容性</title>
     <variablelist>

     <varlistentry id="guc-transform-null-equals" xreflabel="transform_null_equals">
      <term><varname>transform_null_equals</varname> (<type>boolean</type>)
      <indexterm><primary>IS NULL</></>
      <indexterm>
       <primary><varname>transform_null_equals</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        当打开时，形为<literal><replaceable>expr</> = NULL</literal>（或<literal>NULL =  <replaceable>expr</></literal>）的表达式将被当做<literal><replaceable>expr</> IS NULL</literal>， 也就是说，如果<replaceable>expr</>得出空值值则返回真，否则返回假。正确的 SQL 标准兼容的<literal><replaceable>expr</> = NULL</literal>行为总是返回空（未知）。因此这个参数默认为<literal>off</>。
       </para>

       <para>
        不过，在<productname>Microsoft Access</productname>里的过滤表单生成的查询似乎使用<literal><replaceable>expr</> = NULL</literal>来测试空值，因此，如果你使用这个接口访问数据库，你可能想把这个选项打开。因为<literal><replaceable>expr</> = NULL</literal>形式的表达式总是返回空值（使用 SQL 标准解释）。它们不是非常有用并且在普通应用中也不常见，在应用中也不常见，因此这个选项实际上没有什么危害。但是新用户常常对涉及 空值的表达式的语义上感到困惑，因此这个选项默认为关闭。
       </para>

       <para>
        请注意这个选项只影响<literal>= NULL</>形式，而不影响其它比较操作符或者其它与一些涉及等值操作符的表达式在计算上等效的其他表达式（例如<literal>IN</literal>）。因此，这个选项不是劣质程序的一般修复。
       </para>

       <para>
        相关信息请见<xref linkend="functions-comparison">。
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect2>
   </sect1>

   <sect1 id="runtime-config-error-handling">
    <title>错误处理</title>

    <variablelist>

     <varlistentry id="guc-exit-on-error" xreflabel="exit_on_error">
      <term><varname>exit_on_error</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>exit_on_error</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        如果为真，任何错误将中止当前会话。默认情况下，这个值被设置为假，这样只有 FATAL 错误（致命）将中止会话。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-restart-after-crash" xreflabel="restart_after_crash">
      <term><varname>restart_after_crash</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>restart_after_crash</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        当被设置为真（默认值）时，<productname>PostgreSQL</>将在一次后端崩溃后自动重新初始化。让这个值设置为真通常是将数据库可用性最大化的最佳方法。但是在某些环境中，例如<productname>PostgreSQL</>被集群软件调用时，禁用重启可能很有用，这样集群软件可以得到控制并且采取它认为适当的行动。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>

   </sect1>

   <sect1 id="runtime-config-preset">
    <title>预置选项</title>

    <para>
     下列<quote>参数</>是只读的，它们是在编译或安装<productname>PostgreSQL</productname>时决定的。同样，它们被排除在<filename>postgresql.conf</>文件例子之外。这些选项报告特定应用可能感兴趣的多种<productname>PostgreSQL</productname>行为，特别是管理前端相关的行为。
    </para>

    <variablelist>

     <varlistentry id="guc-block-size" xreflabel="block_size">
      <term><varname>block_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>block_size</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        报告一个磁盘块的大小。它由编译服务器时<literal>BLCKSZ</>的值确定。默认值是 8192 字节。有些配置变量的含义（例如<xref linkend="guc-shared-buffers">）会被<varname>block_size</varname>影响。详见<xref linkend="runtime-config-resource">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-data-checksums" xreflabel="data_checksums">
      <term><varname>data_checksums</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>data_checksums</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        报告对这个集簇是否启用了数据校验码。详见<xref linkend="app-initdb-data-checksums">。
       </para>
      </listitem>
     </varlistentry>
      
     <varlistentry id="guc-debug-assertions" xreflabel="debug_assertions">
      <term><varname>debug_assertions</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>debug_assertions</>配置参数</primary>
      </indexterm>
      </term>
      <listitem>
       <para>
        报告是否启用断言编译<productname>PostgreSQL</productname>。
       当构建<productname>PostgreSQL</productname>时（比如通过<command>configure</command>选项
        <option>--enable-cassert</option>完成），
        如果是这样的话，定义宏<symbol>USE_ASSERT_CHECKING</symbol>。
        缺省情况下编译没有断言的<productname>PostgreSQL</productname>。        
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-integer-datetimes" xreflabel="integer_datetimes">
      <term><varname>integer_datetimes</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>integer_datetimes</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        报告<productname>PostgreSQL</>是否在编译时打开了 64 位整数日期和时间。这可以在编译<productname>PostgreSQL</>时通过使用<literal>--disable-integer-datetimes</>配置来禁用。默认值是<literal>on</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-lc-collate" xreflabel="lc_collate">
      <term><varname>lc_collate</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>lc_collate</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        报告文本数据排序使用的区域。详见<xref linkend="locale">。该值是在数据库被创建时确定的。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-lc-ctype" xreflabel="lc_ctype">
      <term><varname>lc_ctype</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>lc_ctype</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        报告决定字符分类的区域。详见<xref linkend="locale">。该值是在数据库被创建时决定的。通常它和<varname>lc_collate</varname>一样，但是可以为特殊应用设置成不同的值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-function-args" xreflabel="max_function_args">
      <term><varname>max_function_args</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_function_args</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        报告函数参数的最大数量。它由编译服务器时的<literal>FUNC_MAX_ARGS</>值决定的。默认值是 100 个参数。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-identifier-length" xreflabel="max_identifier_length">
      <term><varname>max_identifier_length</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_identifier_length</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        报告标识符的最大长度。它由编译服务器时的<literal>NAMEDATALEN</>值减一决定。<literal>NAMEDATALEN</>的默认值是 64 ；因此<varname>max_identifier_length</varname>的默认值是 63，但是在使用多字节编码时可以少于 63 个字符。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-index-keys" xreflabel="max_index_keys">
      <term><varname>max_index_keys</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>max_index_keys</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        报告索引键的最大数目。它由编译服务器时的<literal>INDEX_MAX_KEYS</>值决定。默认值是 32 个键。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-segment-size" xreflabel="segment_size">
      <term><varname>segment_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>segment_size</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        报告一个文件段中可以存储的块（页）的数量。由编译服务器时的<literal>RELSEG_SIZE</>值决定。一个段文件的最大尺寸（以字节计）等于<varname>segment_size</>乘以<varname>block_size</>， 默认是 1GB。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-server-encoding" xreflabel="server_encoding">
      <term><varname>server_encoding</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>server_encoding</>配置参数</primary>
      </indexterm>
      <indexterm><primary>character set</></></term>
      <listitem>
       <para>
        报告数据库的编码（字符集）。这是在数据库被创建时决定的。通常，客户端只需要关心<xref linkend="guc-client-encoding">的值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-server-version" xreflabel="server_version">
      <term><varname>server_version</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>server_version</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        报告服务器版本数值。它是由编译服务器时的<literal>PG_VERSION</>值决定的。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-server-version-num" xreflabel="server_version_num">
      <term><varname>server_version_num</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>server_version_num</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        报告服务器版本数值的整数值。它是由编译服务器时的<literal>PG_VERSION_NUM</>值决定的。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-block-size" xreflabel="wal_block_size">
      <term><varname>wal_block_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>wal_block_size</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        报告一个 WAL 磁盘块的尺寸。由编译服务器时的<literal>XLOG_BLCKSZ</>值决定。默认是 8192 字节。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-segment-size" xreflabel="wal_segment_size">
      <term><varname>wal_segment_size</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>wal_segment_size</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        报告 WAL 段文件中的块（页）数。WAL 段文件的总尺寸（以字节计）等于 <varname>wal_segment_size</>乘以<varname>wal_block_size</>，默认是 16MB。详见<xref linkend="wal-configuration">。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </sect1>

   <sect1 id="runtime-config-custom">
    <title>自定义选项</title>

    <para>
     这个特性被设计用来由附加模块向<productname>PostgreSQL</productname>添加通常不为系统知道的参数（例如过程语言）。这允许使用标准方法配制扩展模块。
    </para>

    <para>
     自定义选项有两部分名称：一个扩展名，然后是一个句点，再然后是正确的参数名，就像 SQL 中的合格名称。一个例子是<literal>plpgsql.variable_conflict</>。
    </para>

    <para>
     因为自定义选项可能需要在没有载入相关扩展模块的进程中设置，<productname>PostgreSQL</>将接收任意两部分参数名的设置。这种变量被认为是占位符并且在定义它们的模块被载入之前不会有实际功能。当一个扩展模块被载入，它将加入它的变量定义、根据那些定义转换任何占位符值并且对以其扩展名开始的任意未识别占位符发出警告。
    </para>
   </sect1>

   <sect1 id="runtime-config-developer">
    <title>开发者选项</title>

    <para>
     下面的参数目的是用在<productname>PostgreSQL</productname>源代码上， 并且在某些情况下可以帮助恢复严重损坏了的数据库。在一个生产数据库中没有理由使用它们。同样，它们被从例子<filename>postgresql.conf</>文件中排除。请注意许多这些参数要求特殊的源代码编译标志才能工作。
    </para>

    <variablelist>
     <varlistentry id="guc-allow-system-table-mods" xreflabel="allow_system_table_mods">
      <term><varname>allow_system_table_mods</varname> (<type>boolean</type>)
      <indexterm>
        <primary><varname>allow_system_table_mods</varname>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        允许对系统表结构的修改。它可以被<command>initdb</command>使用。这个参数只能在服务器启动时设置。
       </para>
      </listitem>
     </varlistentry>


     <varlistentry id="guc-ignore-system-indexes" xreflabel="ignore_system_indexes">
      <term><varname>ignore_system_indexes</varname> (<type>boolean</type>)
      <indexterm>
        <primary><varname>ignore_system_indexes</varname>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        读取系统表时忽略系统索引（但是修改系统表时依然同时更新索引）。这在从被破坏的系统索引中恢复数据的时有用。这个参数在会话开始之后不能被更改。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-post-auth-delay" xreflabel="post_auth_delay">
      <term><varname>post_auth_delay</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>post_auth_delay</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        如果为非零，那么在一个新的服务器进程派生出来之后并且在它开始认证过程之前，就会发生这么多秒的延迟。这是为了给开发者们一个机会在一个服务器进程上附加一个调试器。这个参数在会话开始之后不能被更改。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-pre-auth-delay" xreflabel="pre_auth_delay">
      <term><varname>pre_auth_delay</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>pre_auth_delay</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        如果为非零，那么在一个新的服务器进程派生出来之后并且在它开始认证过程之前，就会发生这么多秒的延迟。这是为了给开发者们一个机会在一个服务器进程上附加一个调试器来跟踪认证过程中的不当行为。这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-trace-notify" xreflabel="trace_notify">
      <term><varname>trace_notify</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>trace_notify</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        为<command>LISTEN</command>和<command>NOTIFY</command>命令生成大量调试输出。<xref linkend="guc-client-min-messages">和<xref linkend="guc-log-min-messages">必须是<literal>DEBUG1</literal>或者更低才能把这种输出分别发送到客户端或者服务器日志。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-trace-recovery-messages" xreflabel="trace_recovery_messages">
      <term><varname>trace_recovery_messages</varname> (<type>enum</type>)
      <indexterm>
       <primary><varname>trace_recovery_messages</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        启用记录与恢复有关的调试输出，否则无法记录。这个参数允许用户覆盖<xref linkend="guc-log-min-messages">的正常设置，但只用于指定的消息。这个参数的目的是用来调试热后备。有效值包括<literal>DEBUG5</>、<literal>DEBUG4</>、<literal>DEBUG3</>、<literal>DEBUG2</>、<literal>DEBUG1</>和<literal>LOG</>。默认值<literal>LOG</>完全不会影响日志决定。其他值会记录相关级别或更高级别的与恢复相关的调试消息，就好像它们具有<literal>LOG</>优先级一样；对于<varname>log_min_messages</>的通用设置，这会无条件的将消息发送给服务器日志。这个参数只能在<filename>postgresql.conf</>文件中或在服务器命令行上设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-trace-sort" xreflabel="trace_sort">
      <term><varname>trace_sort</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>trace_sort</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        如果打开，发出在排序操作中的资源使用的相关信息。只有在编译<productname>PostgreSQL</productname>时定义了<symbol>TRACE_SORT</symbol>宏， 这个参数才可用（不过，当前在默认情况下就定义了<symbol>TRACE_SORT</symbol>）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>trace_locks</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>trace_locks</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        如果开启，发出锁使用情况的信息。被转储信息中包括锁操作的类型、锁的类型和 被锁或被解锁对象的唯一标识符。同样包括的还有已经授予这个对象的锁类型的位掩码和 等待这个对象的锁类型的位掩码。对每一种锁类型，已授权锁和等待锁的计数也会被一起转储。一个日志文件输出的例子如下：
<screen>
LOG:  LockAcquire: new: lock(0xb7acd844) id(24688,24696,0,0,0,1)
      grantMask(0) req(0,0,0,0,0,0,0)=0 grant(0,0,0,0,0,0,0)=0
      wait(0) type(AccessShareLock)
LOG:  GrantLock: lock(0xb7acd844) id(24688,24696,0,0,0,1)
      grantMask(2) req(1,0,0,0,0,0,0)=1 grant(1,0,0,0,0,0,0)=1
      wait(0) type(AccessShareLock)
LOG:  UnGrantLock: updated: lock(0xb7acd844) id(24688,24696,0,0,0,1)
      grantMask(0) req(0,0,0,0,0,0,0)=0 grant(0,0,0,0,0,0,0)=0
      wait(0) type(AccessShareLock)
LOG:  CleanUpLock: deleting: lock(0xb7acd844) id(24688,24696,0,0,0,1)
      grantMask(0) req(0,0,0,0,0,0,0)=0 grant(0,0,0,0,0,0,0)=0
      wait(0) type(INVALID)
</screen>
        被转储结构的详细信息可以在<filename>src/include/storage/lock.h</filename>中找到。
       </para>
       <para>
        只有在编译<productname>PostgreSQL</productname>时定义了<symbol>LOCK_DEBUG</symbol>宏， 这个参数才可用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>trace_lwlocks</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>trace_lwlocks</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        如果开启，发出轻量级锁的使用信息。轻量级锁主要是为了提供对共享内存数据结构的互斥访问。
       </para>
       <para>
        只有在编译<productname>PostgreSQL</productname>时定义了<symbol>LOCK_DEBUG</symbol>宏， 这个参数才可用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>trace_userlocks</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>trace_userlocks</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        如果开启，发出关于用户锁使用的信息。与<symbol>trace_locks</symbol>的输出一样，但只用于咨询锁。
       </para>
       <para>
        只有在编译<productname>PostgreSQL</productname>时定义了<symbol>LOCK_DEBUG</symbol>宏， 这个参数才可用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>trace_lock_oidmin</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>trace_lock_oidmin</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        如果设置，不会跟踪小于这个 OID 的锁（用于避免在系统表上的输出）。
       </para>
       <para>
        只有在编译<productname>PostgreSQL</productname>时定义了<symbol>LOCK_DEBUG</symbol>宏， 这个参数才可用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>trace_lock_table</varname> (<type>integer</type>)
      <indexterm>
       <primary><varname>trace_lock_table</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        无条件地跟踪此表（OID）上的锁。
       </para>
       <para>
        只有在编译<productname>PostgreSQL</productname>时定义了<symbol>LOCK_DEBUG</symbol>宏， 这个参数才可用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>debug_deadlocks</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>debug_deadlocks</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        如果设置，当死锁超时发生时，转储所有当前锁的信息。
       </para>
       <para>
        只有在编译<productname>PostgreSQL</productname>时定义了<symbol>LOCK_DEBUG</symbol>宏， 这个参数才可用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>log_btree_build_stats</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>log_btree_build_stats</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        如果设置，会记录 B 树操作上的系统资源使用情况统计（内存和 CPU）。
       </para>
       <para>
        只有在编译<productname>PostgreSQL</productname>时定义了<symbol>BTREE_BUILD_STATS</symbol>宏， 这个参数才可用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-debug" xreflabel="wal_debug">
      <term><varname>wal_debug</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>wal_debug</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        如果被打开，WAL 相关的调试输出将被发出。只有在编译<productname>PostgreSQL</productname>时定义了<symbol>WAL_DEBUG</symbol>宏的情况下，这个参数才可用。
       </para>
      </listitem>
     </varlistentry>

    <varlistentry id="guc-ignore-checksum-failure" xreflabel="ignore_checksum_failure">
      <term><varname>ignore_checksum_failure</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>ignore_checksum_failure</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        只有当<xref linkend="app-initdb-data-checksums">被启用时才有效。
       </para>
       <para>
        在读取过程中检测到一次校验码失败通常会导致<productname>PostgreSQL</>报告一个错误。设置<varname>ignore_checksum_failure</>为打开会导致系统忽略失败（但是仍然报告一个警告），并且继续执行。这种行为可能<emphasis>导致崩溃、传播或隐藏损坏或者其他严重的问题</>。但是，它允许你绕过错误并且在块头部仍然健全的情况下从表中检索未损坏的元组。如果头部被损坏，即便这个选项被启用系统也将报告一个错误。默认设置是<literal>off</>，并且只能被超级用户改变。
       </para>
      </listitem>
     </varlistentry>

    <varlistentry id="guc-zero-damaged-pages" xreflabel="zero_damaged_pages">
      <term><varname>zero_damaged_pages</varname> (<type>boolean</type>)
      <indexterm>
       <primary><varname>zero_damaged_pages</>配置参数</primary>
      </indexterm></term>
      <listitem>
       <para>
        检测到一个损坏的页面头部通常会导致<productname>PostgreSQL</>报告一个错误，并且中止当前事务。把<varname>zero_damaged_pages</>设置为打开会让系统报告一个警告、把损坏的页面填充零，然后继续处理。这种行为会<emphasis>毁掉数据</>，即被损坏页面上的所有行。但是它允许你绕开错误并且从可能存在表中的任何未损坏页面中检索行。如果由于一次硬件或软件错误而发生毁坏，这种方法可用于恢复数据。通常你不应该把它设置为打开，除非你已经彻底放弃从表的损坏页面中恢复数据。被填充零的页面不会被强制到磁盘上，因此我们推荐在再次关闭这个参数之前先重建表或索引。默认的设置是<literal>off</>，并且只有超级用户可以改变它。
       </para>
      </listitem>
     </varlistentry>
   </variablelist>
  </sect1>
  <sect1 id="runtime-config-short">
   <title>短选项</title>

   <para>
    为了方便起见，系统中还为一些参数提供了单字母的命令行选项开关。它们在<xref linkend="runtime-config-short-table">中描述。其中一些选项是由于历史原因而存在，并且它们作为一个单字母选项存在并不表示它们会被大量使用。
   </para>

    <table id="runtime-config-short-table">
     <title>短选项键</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>短选项</entry>
        <entry>等效于</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><option>-B <replaceable>x</replaceable></option></entry>
        <entry><literal>shared_buffers = <replaceable>x</replaceable></></entry>
       </row>
       <row>
        <entry><option>-d <replaceable>x</replaceable></option></entry>
        <entry><literal>log_min_messages = DEBUG<replaceable>x</replaceable></></entry>
       </row>
       <row>
        <entry><option>-e</option></entry>
        <entry><literal>datestyle = euro</></entry>
       </row>
       <row>
        <entry>
          <option>-fb</option>, <option>-fh</option>, <option>-fi</option>,
          <option>-fm</option>, <option>-fn</option>, <option>-fo</option>,
          <option>-fs</option>, <option>-ft</option>
         </entry>
         <entry>
          <literal>enable_bitmapscan = off</>,
          <literal>enable_hashjoin = off</>,
          <literal>enable_indexscan = off</>,
          <literal>enable_mergejoin = off</>,
          <literal>enable_nestloop = off</>,
          <literal>enable_indexonlyscan = off</>,
          <literal>enable_seqscan = off</>,
          <literal>enable_tidscan = off</>
         </entry>
       </row>
       <row>
        <entry><option>-F</option></entry>
        <entry><literal>fsync = off</></entry>
       </row>
       <row>
        <entry><option>-h <replaceable>x</replaceable></option></entry>
        <entry><literal>listen_addresses = <replaceable>x</replaceable></></entry>
       </row>
       <row>
        <entry><option>-i</option></entry>
        <entry><literal>listen_addresses = '*'</></entry>
       </row>
       <row>
        <entry><option>-k <replaceable>x</replaceable></option></entry>
        <entry><literal>unix_socket_directories = <replaceable>x</replaceable></></entry>
       </row>
       <row>
        <entry><option>-l</option></entry>
        <entry><literal>ssl = on</></entry>
       </row>
       <row>
        <entry><option>-N <replaceable>x</replaceable></option></entry>
        <entry><literal>max_connections = <replaceable>x</replaceable></></entry>
       </row>
       <row>
        <entry><option>-O</option></entry>
        <entry><literal>allow_system_table_mods = on</></entry>
       </row>
       <row>
        <entry><option>-p <replaceable>x</replaceable></option></entry>
        <entry><literal>port = <replaceable>x</replaceable></></entry>
       </row>
       <row>
        <entry><option>-P</option></entry>
        <entry><literal>ignore_system_indexes = on</></entry>
       </row>
       <row>
        <entry><option>-s</option></entry>
        <entry><literal>log_statement_stats = on</></entry>
       </row>
       <row>
        <entry><option>-S <replaceable>x</replaceable></option></entry>
        <entry><literal>work_mem = <replaceable>x</replaceable></></entry>
       </row>
       <row>
        <entry><option>-tpa</option>, <option>-tpl</option>, <option>-te</option></entry>
        <entry><literal>log_parser_stats = on</>,
        <literal>log_planner_stats = on</>,
        <literal>log_executor_stats = on</></entry>
       </row>
       <row>
        <entry><option>-W <replaceable>x</replaceable></option></entry>
        <entry><literal>post_auth_delay = <replaceable>x</replaceable></></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  </sect1>
</chapter>
