<!-- doc/src/sgml/pgstatstatements.sgml -->

<sect1 id="pgstatstatements" xreflabel="pg_stat_statements">
 <title>pg_stat_statements</title>

 <indexterm zone="pgstatstatements">
  <primary>pg_stat_statements</primary>
 </indexterm>

 <para>
  <filename>pg_stat_statements</filename>模块提供一种方法追踪一个服务器所执行的所有 SQL 语句的执行统计信息。
 </para>

 <para>
  该模块必须通过在<filename>postgresql.conf</>的<xref linkend="guc-shared-preload-libraries">中增加<literal>pg_stat_statements</>来载入，因为它需要额外的共享内存。这意味着增加或移除该模块需要一次服务器重启。
 </para>
 
 <!-- 
 <para>
   When <filename>pg_stat_statements</filename> is loaded, it tracks
   statistics across all databases of the server.  To access and manipulate
   these statistics, the module provides a view, <structname>pg_stat_statements</>,
   and the utility functions <function>pg_stat_statements_reset</> and
   <function>pg_stat_statements</>.  These are not available globally but
   can be enabled for a specific database with
   <command>CREATE EXTENSION pg_stat_statements</>.
 </para>
 -->
 <para>
   当加载<filename>pg_stat_statements</filename>时，
   它跟踪服务器所有数据库的统计信息。为了访问和操纵这些统计，
   该模块提供了一个视图<structname>pg_stat_statements</>和工具函数
   <function>pg_stat_statements_reset</>和<function>pg_stat_statements</>。
   这些不是全局可用的，但可以使用<command>CREATE EXTENSION pg_stat_statements</>
   为特定数据库启用。
 </para>

 <sect2>
  <title><structname>pg_stat_statements</structname>视图</title>

  <!-- 
  <para>
   The statistics gathered by the module are made available via a
   view named <structname>pg_stat_statements</>.  This view
   contains one row for each distinct database ID, user ID and query
   ID (up to the maximum number of distinct statements that the module
   can track).  The columns of the view are shown in
   <xref linkend="pgstatstatements-columns">.
  </para>
  -->
  <para>
   该模块收集的统计信息通过一个名为
   <structname>pg_stat_statements</>的系统视图提供。
   这个视图为每个不同的数据库 ID、用户 ID 和查询 ID
   （最多到该模块可以追踪的不同语句的最大数量）包含一行。该视图的列显示在
   <xref linkend="pgstatstatements-columns">中。
  </para>

  <table id="pgstatstatements-columns">
   <title><structname>pg_stat_statements</>列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>userid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>执行该语句的用户的 OID</entry>
     </row>

     <row>
      <entry><structfield>dbid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <entry>在其中执行该语句的数据库的 OID</entry>
     </row>
     
     <row>
      <entry><structfield>queryid</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>内部哈希码，从语句的解析树计算得来</entry>
     </row>

    <row>
      <entry><structfield>query</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>语句的文本形式</entry>
     </row>

     <row>
      <entry><structfield>calls</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>被执行的次数</entry>
     </row>

     <row>
      <entry><structfield>total_time</structfield></entry>
      <entry><type>double precision</type></entry>
      <entry></entry>
      <entry>在该语句中花费的总时间，以毫秒计</entry>
     </row>

     <row>
      <entry><structfield>min_time</structfield></entry>
      <entry><type>double precision</type></entry>
      <entry></entry>
      <!-- 
      <entry>Minimum time spent in the statement, in milliseconds</entry>
      -->
      <entry>在语句中花费的最短时间，以毫秒为单位</entry>
     </row>

     <row>
      <entry><structfield>max_time</structfield></entry>
      <entry><type>double precision</type></entry>
      <entry></entry>
      <!-- 
      <entry>Maximum time spent in the statement, in milliseconds</entry>
      -->
      <entry>在语句中花费的最长时间，以毫秒为单位</entry>
     </row>

     <row>
      <entry><structfield>mean_time</structfield></entry>
      <entry><type>double precision</type></entry>
      <entry></entry>
      <!-- 
      <entry>Mean time spent in the statement, in milliseconds</entry>
      -->
      <entry>在语句中花费的平均时间，以毫秒为单位</entry>
     </row>

     <row>
      <entry><structfield>stddev_time</structfield></entry>
      <entry><type>double precision</type></entry>
      <entry></entry>
      <!-- 
      <entry>Population standard deviation of time spent in the statement, in milliseconds</entry>
      -->
      <entry>在语句中花费的人口标准偏差时间，以毫秒为单位</entry>
     </row>

     <row>
      <entry><structfield>rows</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>该语句检索或影响的行总数</entry>
     </row>

     <row>
      <entry><structfield>shared_blks_hit</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>该语句造成的共享块缓冲命中总数</entry>
     </row>

     <row>
      <entry><structfield>shared_blks_read</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>该语句读取的共享块的总数</entry>
     </row>

     <row>
      <entry><structfield>shared_blks_dirtied</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>该语句弄脏的共享块的总数</entry>
     </row>

     <row>
      <entry><structfield>shared_blks_written</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>该语句写入的共享块的总数</entry>
     </row>

     <row>
      <entry><structfield>local_blks_hit</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>该语句造成的本地块缓冲命中总数</entry>
     </row>

     <row>
      <entry><structfield>local_blks_read</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>该语句读取的本地块的总数</entry>
     </row>

     <row>
      <entry><structfield>local_blks_dirtied</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>该语句弄脏的本地块的总数</entry>
     </row>

     <row>
      <entry><structfield>local_blks_written</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>该语句写入的本地块的总数</entry>
     </row>

     <row>
      <entry><structfield>temp_blks_read</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>该语句读取的临时块的总数</entry>
     </row>

     <row>
      <entry><structfield>temp_blks_written</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>该语句写入的临时块的总数</entry>
     </row>

     <row>
      <entry><structfield>blk_read_time</structfield></entry>
      <entry><type>double precision</type></entry>
      <entry></entry>
      <entry>
        该语句花在读取块上的总时间，以毫秒计（如果<xref linkend="guc-track-io-timing">被启用，否则为零）
      </entry>
     </row>

     <row>
      <entry><structfield>blk_write_time</structfield></entry>
      <entry><type>double precision</type></entry>
      <entry></entry>
      <entry>
        该语句花在写入块上的总时间，以毫秒计（如果<xref linkend="guc-track-io-timing">被启用，否则为零）
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <!-- 
  <para>
   For security reasons, non-superusers are not allowed to see the SQL
   text or <structfield>queryid</structfield> of queries executed by other users.
   They can see the statistics, however, if the view has been installed in their
   database.
  </para> 
  -->
  <para>
   出于安全原因，不允许非超级用户查看其它用户执行的 SQL 文本或者
   <structfield>queryid</structfield>。
   不过，如果视图已经安装到他们的数据库中，他们就可以查看统计信息。
  </para>

  <para>
   只要可规划的查询（即<command>SELECT</>、<command>INSERT</>、<command>UPDATE</>以及<command>DELETE</>）根据一种内部哈希计算具有相同的查询结构，它们就会被组合到一个单一的<structname>pg_stat_statements</>项。通常，对于这里的目的，如果两个查询除了查询中的文本常量值之外在语义上等效，它们将会被认为是相同的。不过，功能性命令（即所有其他命令）会严格地以它们的文本查询字符串为基础进行比较。
  </para>

  <para>
   当为了把一个查询与其他查询匹配，常数值会被忽略，在<structname>pg_stat_statements</>显示中它会被一个<literal>?</literal>所替换。查询文本的剩余部分就是具有与该<structname>pg_stat_statements</>项相关的特定<structfield>queryid</>哈希值的第一个查询的文本。
  </para>

  <para>
   在某些情况中，具有明显不同文本的查询可能会被融合到一个单一的<structname>pg_stat_statements</>项。通常这只会发生在语义等价的查询身上，但是也有很小的机会因为哈希碰撞的原因导致无关的查询被融合到一个项中（不过，对于属于不同用户或数据库的查询来说不会发生这种情况）。
  </para>

  <para>
   由于<structfield>queryid</>哈希值是根据查询被解析和分析后的表达计算的，对立的情况也可能存在：如果具有相同文本的查询由于参数（如不同的<varname>search_path</>设置）的原因而具有不同的含义，它们就可能作为不同的项存在。
  </para>
  
  <para>
   <structname>pg_stat_statements</>的使用者可能希望使用
   <structfield>queryid</>（也许会与<structfield>dbid</>和<structfield>userid</>组合）作为一个项比查询文本更稳定和可靠的标识符。但是，有一点很重要的是，对于<structfield>queryid</>哈希值稳定性只有有限的保障。因为该标识符是从解析分析后的树得来的，它的值是以这种形式出现的内部对象标识符的函数。这有一些违背直觉的含义。例如，如果有两个查询引用了同一个表，但是该表在两次查询之间被删除并且重建，显然这两个查询是完全一致的，但是<filename>pg_stat_statements</>将把它们认为是不同的。哈希处理也对机器架构以及平台的其他方面的差别很敏感。更进一步，认为<productname>PostgreSQL</>的不同主版本之间<structfield>queryid</>将会保持稳定是不安全的。
  </para>

  <para>
   根据经验，只有在底层服务器版本以及目录元数据细节保持完全相同时，<structfield>queryid</>值才能被假定为稳定并且可比。两台参与到基于物理 WAL 重放的复制中的服务器会对相同的查询给出一样的<structfield>queryid</>值。但是，逻辑复制模式并不保证在所有相关细节上都保持完全一样的复制，因此在逻辑复制机之间计算代价时，<structfield>queryid</>并非是一个有用的标识符。如果有疑问，推荐直接进行测试。
  </para>

  <!-- 
  <para>
   The representative query texts are kept in an external disk file, and do
   not consume shared memory.  Therefore, even very lengthy query texts can
   be stored successfully.  However, if many long query texts are
   accumulated, the external file might grow unmanageably large.  As a
   recovery method if that happens, <filename>pg_stat_statements</> may
   choose to discard the query texts, whereupon all existing entries in
   the <structname>pg_stat_statements</> view will show
   null <structfield>query</> fields, though the statistics associated with
   each <structfield>queryid</> are preserved.  If this happens, consider
   reducing <varname>pg_stat_statements.max</varname> to prevent
   recurrences.
  </para>
  -->
  <para>
   代表性查询文本保存在外部磁盘文件中，并且不消耗共享内存。因此，
   即使非常冗长的查询文本也可以成功存储。然而，如果许多长的查询文本被累积，
   则外部文件可能变得不可管理地大。如果发生这种情况，作为恢复方法，
   <filename>pg_stat_statements</>可以选择丢弃查询文本，其中
   <structname>pg_stat_statements</>视图中的所有现有条目将显示空的
   <structfield>query</>字段，尽管与每个<structfield>queryid</>
   相关联的统计信息被保留。如果发生这种情况，请考虑减少
   <varname>pg_stat_statements.max</varname>以防止重现。
  </para>
 </sect2>

 <sect2>
  <title>函数</title>

  <variablelist>
   <varlistentry>
   <term>
     <function>pg_stat_statements_reset() 返回 void</function>
   <indexterm>
    <primary>pg_stat_statements_reset</primary>
   </indexterm>
    </term>

    <listitem>
     <para>
      <function>pg_stat_statements_reset</function>抛弃目前由<filename>pg_stat_statements</>收集的所有统计信息。默认情况下，这个函数只能被超级用户执行。
     </para>
    </listitem>
   </varlistentry>
   
   <varlistentry>
    <term>
     <function>pg_stat_statements(showtext boolean) returns setof record</function>
     <indexterm>
      <primary>pg_stat_statements</primary>
      <secondary>function</secondary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <structname>pg_stat_statements</structname>视图按照一个也叫
      <function>pg_stat_statements</>的函数来定义。客户端可以直接调用
      <function>pg_stat_statements</function>函数，并且通过指定
      <literal>showtext := false</literal>来忽略查询文本（即，对应于视图的
      <structfield>query</>列的<literal>OUT</literal>参数将返回空值）。
      这个特性是为了支持不想重复接收长度不定的查询文本的外部工具而设计的。
      这类工具可以转而自行缓存第一个观察到的查询文本，因为这就是
      <filename>pg_stat_statements</>自己所做的全部工作，并且只在需要的
      时候检索查询文本。因为服务器会把查询文本存储在一个文件中，这种方法可
      以降低重复检查<structname>pg_stat_statements</structname>数据的
      物理 I/O。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

 <sect2>
  <title>配置参数</title>

  <variablelist>
   <varlistentry>
    <term>
     <varname>pg_stat_statements.max</varname> (<type>integer</type>)
    </term>

    <listitem>
     <para>
      <varname>pg_stat_statements.max</varname>是由该模块跟踪的语句的最大数目（即<structname>pg_stat_statements</>视图中行的最大数量）。如果观测到的可区分的语句超过这个数量，最少被执行的语句的信息将会被丢弃。默认值为 5000。这个参数只能在服务器启动时设置。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <varname>pg_stat_statements.track</varname> (<type>enum</type>)
    </term>

    <listitem>
     <para>
      <varname>pg_stat_statements.track</varname>控制哪些语句会被该模块计数。指定<literal>top</>可以跟踪顶层语句（那些直接由客户端发出的语句），指定<literal>all</>还可以跟踪嵌套的语句（例如在函数中调用的语句），指定<literal>none</>可以禁用语句统计信息收集。默认值是<literal>top</>。
      只有超级用户能够改变这个设置。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <varname>pg_stat_statements.track_utility</varname> (<type>boolean</type>)
    </term>

    <listitem>
     <para>
      <varname>pg_stat_statements.track_utility</varname>控制该模块是否会跟踪工具命令。工具命令是除了<command>SELECT</>、<command>INSERT</>、
      <command>UPDATE</>和<command>DELETE</>之外所有的其他命令。默认值是<literal>on</>。
      只有超级用户能够改变这个设置。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <varname>pg_stat_statements.save</varname> (<type>boolean</type>)
    </term>

    <listitem>
     <para>
      <varname>pg_stat_statements.save</varname>指定是否在服务器关闭之后还保存语句统计信息。如果被设置为<literal>off</>，那么关闭后不保存统计信息并且在服务器启动时也不会重新载入统计信息。默认值为<literal>on</>。这个参数只能在<filename>postgresql.conf</>文件中或者在服务器命令行上设置。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   该模块要求与<varname>pg_stat_statements.max</varname>成比例的额外共享内存。注意只要该模块被载入就会消耗这么多的内存，即便<varname>pg_stat_statements.track</>被设置为<literal>none</>。
  </para>

  <para>
   这些参数必须在<filename>postgresql.conf</>中设置。典型的用法可能是：

<programlisting>
# postgresql.conf
shared_preload_libraries = 'pg_stat_statements'

pg_stat_statements.max = 10000
pg_stat_statements.track = all
</programlisting>
  </para>
 </sect2>

 <sect2>
  <title>示例输出</title>

<screen>
bench=# SELECT pg_stat_statements_reset();

$ pgbench -i bench
$ pgbench -c10 -t300 bench

bench=# \x
bench=# SELECT query, calls, total_time, rows, 100.0 * shared_blks_hit /
               nullif(shared_blks_hit + shared_blks_read, 0) AS hit_percent
          FROM pg_stat_statements ORDER BY total_time DESC LIMIT 5;
-[ RECORD 1 ]---------------------------------------------------------------------
query       | UPDATE pgbench_branches SET bbalance = bbalance + ? WHERE bid = ?;
calls       | 3000
total_time  | 9609.00100000002
rows        | 2836
hit_percent | 99.9778970000200936
-[ RECORD 2 ]---------------------------------------------------------------------
query       | UPDATE pgbench_tellers SET tbalance = tbalance + ? WHERE tid = ?;
calls       | 3000
total_time  | 8015.156
rows        | 2990
hit_percent | 99.9731126579631345
-[ RECORD 3 ]---------------------------------------------------------------------
query       | copy pgbench_accounts from stdin
calls       | 1
total_time  | 310.624
rows        | 100000
hit_percent | 0.30395136778115501520
-[ RECORD 4 ]---------------------------------------------------------------------
query       | UPDATE pgbench_accounts SET abalance = abalance + ? WHERE aid = ?;
calls       | 3000
total_time  | 271.741999999997
rows        | 3000
hit_percent | 93.7968855088209426
-[ RECORD 5 ]---------------------------------------------------------------------
query       | alter table pgbench_accounts add primary key (aid)
calls       | 1
total_time  | 81.42
rows        | 0
hit_percent | 34.4947735191637631
</screen>
 </sect2>

 <sect2>
  <title>作者</title>

  <para>
   Takahiro Itagaki <email>itagaki.takahiro@oss.ntt.co.jp</email>。Peter Geoghegan <email>peter@2ndquadrant.com</email>为它加入了查询正规化的功能。
  </para>
 </sect2>

</sect1>
