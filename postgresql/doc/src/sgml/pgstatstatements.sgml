<!-- doc/src/sgml/pgstatstatements.sgml -->

<sect1 id="pgstatstatements" xreflabel="pg_stat_statements">
 <title>pg_stat_statements</title>

 <indexterm zone="pgstatstatements">
  <primary>pg_stat_statements</primary>
 </indexterm>

 <!--
<para>
  The <filename>pg_stat_statements</filename> module provides a means for
  tracking execution statistics of all SQL statements executed by a server.
 </para>
-->
<para>
<filename>pg_stat_statements</filename>模块提供一种跟踪执行统计服务器执行的所有SQL语句的手段。
</para>

 <!--
<para>
  The module must be loaded by adding <literal>pg_stat_statements</> to
  <xref linkend="guc-shared-preload-libraries"> in
  <filename>postgresql.conf</>, because it requires additional shared memory.
  This means that a server restart is needed to add or remove the module.
 </para>
-->
<para>
该模块必须通过在<filename>postgresql.conf</>中添加<literal>pg_stat_statements</>
到<xref linkend="guc-shared-preload-libraries">来加载，因为它需要额外的共享内存。
这意味着添加或删除这个模块都需要重启服务器。
</para>

 <sect2>
  <!--
  <title>The <structname>pg_stat_statements</structname> View</title>
  -->
  <title><structname>pg_stat_statements</structname> 视图</title>

  <!--
<para>
   The statistics gathered by the module are made available via a
   system view named <structname>pg_stat_statements</>.  This view
   contains one row for each distinct database ID, user ID and query
   ID (up to the maximum number of distinct statements that the module
   can track).  The columns of the view are shown in
   <xref linkend="pgstatstatements-columns">.
  </para>
-->
<para>
该模块收集的统计通过一个名为<structname>pg_stat_statements</>的系统视图使其可用。
这个模块为每个不同的查询、数据库ID和用户ID（取决于该模块可以追踪的不同语句的最大值）
包含一行。视图的字段显示在<xref linkend="pgstatstatements-columns">中。
</para>

  <table id="pgstatstatements-columns">
   <!-- 
   <title><structname>pg_stat_statements</> Columns</title>
   -->
   <title><structname>pg_stat_statements</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>参考</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>userid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <!--
  <entry>OID of user who executed the statement</entry>
  -->
  <entry>执行该语句的用户的OID</entry>
     </row>

     <row>
      <entry><structfield>dbid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <!--
  <entry>OID of database in which the statement was executed</entry>
  -->
  <entry>执行该语句的数据库的OID</entry>
     </row>

     <row>
      <entry><structfield>queryid</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <!-- 
      <entry>Internal hash code, computed from the statement's parse tree</entry>
      -->
      <entry>内部哈希代码，从声明的分析树中计算而来</entry>
     </row>

     <row>
      <entry><structfield>query</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <!--
  <entry>Text of a representative statement</entry>
  -->
  <entry>有代表性的语句的文本</entry>
     </row>

     <row>
      <entry><structfield>calls</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <!--
  <entry>Number of times executed</entry>
  -->
  <entry>执行的次数</entry>
     </row>

     <row>
      <entry><structfield>total_time</structfield></entry>
      <entry><type>double precision</type></entry>
      <entry></entry>
      <!--
  <entry>Total time spent in the statement, in milliseconds</entry>
  -->
  <entry>该语句花费的总时间，以毫秒计</entry>
     </row>

     <row>
      <entry><structfield>rows</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <!--
  <entry>Total number of rows retrieved or affected by the statement</entry>
  -->
  <entry>该语句恢复或影响的行的总数</entry>
     </row>

     <row>
      <entry><structfield>shared_blks_hit</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <!--
  <entry>Total number of shared block cache hits by the statement</entry>
  -->
  <entry>该语句命中的共享块缓存的总数</entry>
     </row>

     <row>
      <entry><structfield>shared_blks_read</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <!--
  <entry>Total number of shared blocks read by the statement</entry>
  -->
  <entry>该语句读取的共享块的总数</entry>
     </row>

     <row>
      <entry><structfield>shared_blks_dirtied</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <!--
  <entry>Total number of shared blocks dirtied by the statement</entry>
  -->
  <entry>该语句弄脏的共享块的总数</entry>
     </row>

     <row>
      <entry><structfield>shared_blks_written</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <!-- 
  <entry>Total number of shared blocks written by the statement</entry>
  -->
  <entry>该语句写入的共享块的总数</entry>
     </row>

     <row>
      <entry><structfield>local_blks_hit</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <!--
  <entry>Total number of local block cache hits by the statement</entry>
  -->
  <entry>该语句命中的本地块缓存的总数</entry>
     </row>

     <row>
      <entry><structfield>local_blks_read</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <!--
  <entry>Total number of local blocks read by the statement</entry>
  -->
  <entry>该语句读取的本地块的总数</entry>
     </row>

     <row>
      <entry><structfield>local_blks_dirtied</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <!--
  <entry>Total number of local blocks dirtied by the statement</entry>
  -->
  <entry>该语句弄脏的本地块的总数</entry>
     </row>

     <row>
      <entry><structfield>local_blks_written</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <!--
  <entry>Total number of local blocks written by the statement</entry>
  -->
  <entry>该语句写入的本地块的总数</entry>
     </row>

     <row>
      <entry><structfield>temp_blks_read</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <!--
  <entry>Total number of temp blocks read by the statement</entry>
  -->
  <entry>该语句读取的临时块的总数</entry>
     </row>

     <row>
      <entry><structfield>temp_blks_written</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <!--
  <entry>Total number of temp blocks written by the statement</entry>
  -->
 <entry>该语句写入的临时块的总数</entry>
     </row>

     <row>
      <entry><structfield>blk_read_time</structfield></entry>
      <entry><type>double precision</type></entry>
      <entry></entry>
      <entry>
        <!--
Total time the statement spent reading blocks, in milliseconds
        (if <xref linkend="guc-track-io-timing"> is enabled, otherwise zero)
-->
该语句读取块花费的总时间，以毫秒计
（如果启用了<xref linkend="guc-track-io-timing">，否则为0）
      </entry>
     </row>

     <row>
      <entry><structfield>blk_write_time</structfield></entry>
      <entry><type>double precision</type></entry>
      <entry></entry>
      <entry>
        <!--
Total time the statement spent writing blocks, in milliseconds
        (if <xref linkend="guc-track-io-timing"> is enabled, otherwise zero)
-->
该语句写入块花费的总时间，以毫秒计
（如果启用了<xref linkend="guc-track-io-timing">，否则为0）
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   This view, and the functions <function>pg_stat_statements_reset</>
   and <function>pg_stat_statements</>, are available only in
   databases they have been specifically installed into by installing
   the <literal>pg_stat_statements</> extension.
   However, statistics are tracked across all databases of the server
   whenever the <filename>pg_stat_statements</filename> module is loaded
   into the server, regardless of presence of the view.
  </para>
-->
<para>
这个视图和函数<function>pg_stat_statements_reset</>和
<function>pg_stat_statements</>，只有在通过安装
<literal>pg_stat_statements</>扩展特别安装到的数据库中可用。
不过，当<filename>pg_stat_statements</filename>模块加载到服务器中时，
统计跟踪该服务器中的所有数据库，不管该视图是否存在。
</para>

  <!--
<para>
   For security reasons, non-superusers are not allowed to see the SQL
   text or <structfield>queryid</structfield> of queries executed by other users.  They can see
   the statistics, however, if the view has been installed in their
   database.
  </para>
-->
<para>
为了安全起见，不允许非超级用户查看其它用户执行的查询的SQL文本或<structfield>queryid</structfield>。
不过，如果视图已经安装到他们的数据库中，那么他们可以看到统计。
</para>

  <!--
<para>
   Plannable queries (that is, <command>SELECT</>, <command>INSERT</>,
   <command>UPDATE</>, and <command>DELETE</>) are combined into a single
   <structname>pg_stat_statements</> entry whenever they have identical query
   structures according to an internal hash calculation.  Typically, two
   queries will be considered the same for this purpose if they are
   semantically equivalent except for the values of literal constants
   appearing in the query.  Utility commands (that is, all other commands)
   are compared strictly on the basis of their textual query strings, however.
  </para>
-->
<para>
可计划的查询（也就是，<command>SELECT</>, <command>INSERT</>,
   <command>UPDATE</>, 和 <command>DELETE</>）组合成为一个<structname>pg_stat_statements</>，
当它们根据一个内部哈希计算有相同的查询结构时。典型的，如果两个查询语义上相等，
除了查询中字面常量的值之外，我们认为这两个查询相同。工具命令（也就是，所有其他命令）
是直接基于它们的文本查询字符串比较的。
</para>

  <!--
<para>
   When a constant's value has been ignored for purposes of matching the
   query to other queries, the constant is replaced by <literal>?</literal>
   in the <structname>pg_stat_statements</> display.  The rest of the query
   text is that of the first query that had the particular
   <structfield>queryid</> hash value associated with the
   <structname>pg_stat_statements</> entry.
  </para>
-->
<para>
当一个常量的值为了匹配其他查询而忽略时，该常量在<structname>pg_stat_statements</>
的显示中被<literal>?</literal>替代。查询文本的剩余部分是第一个查询特定
<structfield>queryid</>散列值与<structname>pg_stat_statements</>相关条目。
</para>

  <!--
<para>
   In some cases, queries with visibly different texts might get merged into a
   single <structname>pg_stat_statements</> entry.  Normally this will happen
   only for semantically equivalent queries, but there is a small chance of
   hash collisions causing unrelated queries to be merged into one entry.
   (This cannot happen for queries belonging to different users or databases,
   however.)
  </para>
-->
<para>
在一些情况下，带有明显不同文本的查询可能合并到一个<structname>pg_stat_statements</>。
通常这只在语义相等的查询上发生，但是有很小的可能哈希冲突导致不相关的查询被合并到一个条目。
（不过，这对于属于不同用户或数据库的查询来说是不会发生的。）
</para>

  <!--
<para>
   Since the <structfield>queryid</> hash value is computed on the
   post-parse-analysis representation of the queries, the opposite is
   also possible: queries with identical texts might appear as
   separate entries, if they have different meanings as a result of
   factors such as different <varname>search_path</> settings.
  </para>
-->
<para>
因为哈希值是基于分析查询的表示法之后来计算的，相反的也是可能的：
带有相同文本的查询可能表现为单独的条目，如果它们因为一个因素的结果有不同的含义，
比如不同的<varname>search_path</>设置。
</para>

<!-- 
  <para>
   Consumers of <literal>pg_stat_statements</> may wish to use
   <structfield>queryid</> (perhaps in combination with
   <structfield>dbid</> and <structfield>userid</>) as a more stable
   and reliable identifier for each entry than its query text.
   However, it is important to understand that there are only limited
   guarantees around the stability of the <structfield>queryid</> hash
   value.  Since the identifier is derived from the
   post-parse-analysis tree, its value is a function of, among other
   things, the internal object identifiers appearing in this representation.
   This has some counterintuitive implications.  For example,
   <literal>pg_stat_statements</> will consider two apparently-identical
   queries to be distinct, if they reference a table that was dropped
   and recreated between the executions of the two queries.
   The hashing process is also sensitive to differences in
   machine architecture and other facets of the platform.
   Furthermore, it is not safe to assume that <structfield>queryid</>
   will be stable across major versions of <productname>PostgreSQL</>.
  </para>
-->
<para>
<literal>pg_stat_statements</>的消耗者可能希望将<structfield>queryid</>
（可能和<structfield>dbid</>和<structfield>userid</>结合使用）
用作每个条目更稳定可靠的标识符而不是它的查询文本。
但是，重要的是要理解<structfield>queryid</>哈希值的稳定性保证是有限的。
因为标识符来源于post-parse-analysis树，
它的值是在其他事物之上，出现在这个表示法中的内部对象标识符的一个函数。
这有一些违背常理。例如，如果在两个查询的执行期间它们引用的表删除之后又重新创建了，
那么<literal>pg_stat_statements</>将认为这两个看起来相同的查询是不同的。
哈希过程对机器架构和平台其他方面的不同也是敏感的。
另外，对<structfield>queryid</>跨<productname>PostgreSQL</>
的主要版本还是稳定的这种假设是不安全的。
</para>
<!-- 
  <para>
   As a rule of thumb, <structfield>queryid</> values can be assumed to be
   stable and comparable only so long as the underlying server version and
   catalog metadata details stay exactly the same.  Two servers
   participating in replication based on physical WAL replay can be expected
   to have identical <structfield>queryid</> values for the same query.
   However, logical replication schemes do not promise to keep replicas
   identical in all relevant details, so <structfield>queryid</> will
   not be a useful identifier for accumulating costs across a set of logical
   replicas.  If in doubt, direct testing is recommended.
  </para>
-->
<para>
根据经验，只要底层服务器版本和目录元数据细节保持完全相同，
<structfield>queryid</>的值就可以假设为稳定和可比较的。
参与到基于物理WAL重放复制中的两个服务器，对于相同的查询可以预计为有不同的
<structfield>queryid</>值。不过，逻辑复制模式并不保证复制品在所有相关细节上都相同，
所以<structfield>queryid</>对于累加一系列逻辑复制的消耗来说不是一个有用的标识符。
如果有怀疑，建议直接做测试。
</para>

 </sect2>

 <sect2>
  <!--
  <title>Functions</title>
  -->
  <title>函数</title>

  <variablelist>
   <varlistentry>
    <term>
     <function>pg_stat_statements_reset() returns void</function>
   <indexterm>
    <primary>pg_stat_statements_reset</primary>
   </indexterm>
    </term>

    <listitem>
     <!--
<para>
      <function>pg_stat_statements_reset</function> discards all statistics
      gathered so far by <filename>pg_stat_statements</>.
      By default, this function can only be executed by superusers.
     </para>
-->
<para>
<function>pg_stat_statements_reset</function>抛弃所有<filename>pg_stat_statements</>
到目前为止收集的统计。缺省的，这个函数只能被超级用户执行。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <function>pg_stat_statements(showtext boolean) returns setof record</function>
     <indexterm>
      <primary>pg_stat_statements</primary>
      <secondary>function</secondary>
     </indexterm>
    </term>

    <listitem>

<!-- 
     <para>
      The <structname>pg_stat_statements</structname> view is defined in
      terms of a function also named <function>pg_stat_statements</>.
      It is possible for clients to call
      the <function>pg_stat_statements</function> function directly, and by
      specifying <literal>showtext := false</literal> have query text be
      omitted (that is, the <literal>OUT</literal> argument that corresponds
      to the view's <structfield>query</> column will return nulls).  This
      feature is intended to support external tools that might wish to avoid
      the overhead of repeatedly retrieving query texts of indeterminate
      length.  Such tools can instead cache the first query text observed
      for each entry themselves, since that is
      all <filename>pg_stat_statements</> itself does, and then retrieve
      query texts only as needed.  Since the server stores query texts in a
      file, this approach may reduce physical I/O for repeated examination
      of the <structname>pg_stat_statements</structname> data.
     </para>
-->
<para>
<structname>pg_stat_statements</structname>视图的定义是为了一个也叫做
<function>pg_stat_statements</>的函数。客户端可以直接调用
<function>pg_stat_statements</>函数，并且通过声明
<literal>showtext := false</literal>省略查询文本（也就是，对应于视图的
<structfield>query</>字段的<literal>OUT</literal>参数将返回空）。
这个特性是为了支持想要避免重复检索不确定查询文本长度的总开销的外部工具。
这样的工具可以为每个条目本身缓存首先看到的查询文本，
所有<filename>pg_stat_statements</>本身也是这样做的，
然后只在需要时检索查询文本。因为服务器将查询文本存储在一个文件中，
所以这个方法可以减少重复检查<structname>pg_stat_statements</structname>
数据的物理I/O。
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

 <sect2>
  <!--
  <title>Configuration Parameters</title>
  -->
  <title>配置参数</title>

  <variablelist>
   <varlistentry>
    <term>
     <varname>pg_stat_statements.max</varname> (<type>integer</type>)
    </term>

    <listitem>
     <!--
<para>
      <varname>pg_stat_statements.max</varname> is the maximum number of
      statements tracked by the module (i.e., the maximum number of rows
      in the <structname>pg_stat_statements</> view).  If more distinct
      statements than that are observed, information about the least-executed
      statements is discarded.
      The default value is 5000.
      This parameter can only be set at server start.
     </para>
-->
<para>
<varname>pg_stat_statements.max</varname>是该模块追踪语句的最大值
（也就是，<structname>pg_stat_statements</>视图中的最大行数）。
如果观察了比这更多的不同的语句，则会抛弃执行最少的语句的信息。
缺省值是5000。这个参数只能在服务器启动时设置。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <varname>pg_stat_statements.track</varname> (<type>enum</type>)
    </term>

    <listitem>
     <!--
<para>
      <varname>pg_stat_statements.track</varname> controls which statements
      are counted by the module.
      Specify <literal>top</> to track top-level statements (those issued
      directly by clients), <literal>all</> to also track nested statements
      (such as statements invoked within functions), or <literal>none</> to
      disable statement statistics collection.
      The default value is <literal>top</>.
      Only superusers can change this setting.
     </para>
-->
<para>
<varname>pg_stat_statements.track</varname>控制哪个语句可以被该模块计数。
声明<literal>top</>来跟踪顶级的语句（直接通过客户端发出的语句）。<literal>all</>
也跟踪嵌套的语句（比如包含在函数中的语句），或<literal>none</>禁用语句状态收集。
缺省值是<literal>top</>。只有超级用户可以更改这个设置。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <varname>pg_stat_statements.track_utility</varname> (<type>boolean</type>)
    </term>

    <listitem>
     <!--
<para>
      <varname>pg_stat_statements.track_utility</varname> controls whether
      utility commands are tracked by the module.  Utility commands are
      all those other than <command>SELECT</>, <command>INSERT</>,
      <command>UPDATE</> and <command>DELETE</>.
      The default value is <literal>on</>.
      Only superusers can change this setting.
     </para>
-->
<para>
<varname>pg_stat_statements.track_utility</varname>控制该模块是否追踪工具命令。
工具命令是除了<command>SELECT</>, <command>INSERT</>, <command>UPDATE</> 和 
<command>DELETE</>的所有命令。缺省值是<literal>on</>。只有超级用户可以更改这个设置。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <varname>pg_stat_statements.save</varname> (<type>boolean</type>)
    </term>

    <listitem>
     <!--
<para>
      <varname>pg_stat_statements.save</varname> specifies whether to
      save statement statistics across server shutdowns.
      If it is <literal>off</> then statistics are not saved at
      shutdown nor reloaded at server start.
      The default value is <literal>on</>.
      This parameter can only be set in the <filename>postgresql.conf</>
      file or on the server command line.
     </para>
-->
<para>
<varname>pg_stat_statements.save</varname>指定在服务器关闭时是否保存语句状态。
如果是<literal>off</>，那么在服务器关闭时不保存状态，在服务器启动时也不重新加载。
缺省值是<literal>on</>。这个参数只可以在<filename>postgresql.conf</>
文件中或者服务器命令行中设置。
</para>
    </listitem>
   </varlistentry>
  </variablelist>

  <!--
<para>
   The module requires additional shared memory proportional to
   <varname>pg_stat_statements.max</varname>.  Note that this
   memory is consumed whenever the module is loaded, even if
   <varname>pg_stat_statements.track</> is set to <literal>none</>.
  </para>
-->
<para>
该模块需要额外的共享内存与
<varname>pg_stat_statements.max</varname>成比例。请注意，
这个内存在该模块加载时被消耗，即使<varname>pg_stat_statements.track</>
设置为<literal>none</>。
</para>

<para>
   <!-- 
   These parameters must be set in <filename>postgresql.conf</>.
   Typical usage might be: 
   -->
   这些参数必须在<filename>postgresql.conf</>中设置。典型的用法是：

<programlisting>
# postgresql.conf
shared_preload_libraries = 'pg_stat_statements'

pg_stat_statements.max = 10000
pg_stat_statements.track = all
</programlisting>
  </para>
 </sect2>

 <sect2>
  <!--
  <title>Sample Output</title>
  -->
  <title>示例输出</title>

<screen>
bench=# SELECT pg_stat_statements_reset();

$ pgbench -i bench
$ pgbench -c10 -t300 bench

bench=# \x
bench=# SELECT query, calls, total_time, rows, 100.0 * shared_blks_hit /
               nullif(shared_blks_hit + shared_blks_read, 0) AS hit_percent
          FROM pg_stat_statements ORDER BY total_time DESC LIMIT 5;
-[ RECORD 1 ]---------------------------------------------------------------------
query       | UPDATE pgbench_branches SET bbalance = bbalance + ? WHERE bid = ?;
calls       | 3000
total_time  | 9609.00100000002
rows        | 2836
hit_percent | 99.9778970000200936
-[ RECORD 2 ]---------------------------------------------------------------------
query       | UPDATE pgbench_tellers SET tbalance = tbalance + ? WHERE tid = ?;
calls       | 3000
total_time  | 8015.156
rows        | 2990
hit_percent | 99.9731126579631345
-[ RECORD 3 ]---------------------------------------------------------------------
query       | copy pgbench_accounts from stdin
calls       | 1
total_time  | 310.624
rows        | 100000
hit_percent | 0.30395136778115501520
-[ RECORD 4 ]---------------------------------------------------------------------
query       | UPDATE pgbench_accounts SET abalance = abalance + ? WHERE aid = ?;
calls       | 3000
total_time  | 271.741999999997
rows        | 3000
hit_percent | 93.7968855088209426
-[ RECORD 5 ]---------------------------------------------------------------------
query       | alter table pgbench_accounts add primary key (aid)
calls       | 1
total_time  | 81.42
rows        | 0
hit_percent | 34.4947735191637631
</screen>
 </sect2>

 <sect2>
  <!--
  <title>Authors</title>
  -->
  <title>作者</title>

  <!--
<para>
   Takahiro Itagaki <email>itagaki.takahiro@oss.ntt.co.jp</email>.
   Query normalization added by Peter Geoghegan <email>peter@2ndquadrant.com</email>.
  </para>
-->
<para>
Takahiro Itagaki <email>itagaki.takahiro@oss.ntt.co.jp</email>。
Peter Geoghegan <email>peter@2ndquadrant.com</email>添加了查询正常化。
</para>
 </sect2>

</sect1>
