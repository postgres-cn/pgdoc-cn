<!-- doc/src/sgml/libpq.sgml -->

<chapter id="libpq">
 <!--
 <title><application>libpq</application> - C Library</title>
 -->
 <title><application>libpq</application> - C 库</title>

 <indexterm zone="libpq">
  <primary>libpq</primary>
 </indexterm>

 <indexterm zone="libpq">
  <primary>C</primary>
 </indexterm>

 <!--
<para>
  <application>libpq</application> is the <acronym>C</acronym>
  application programmer's interface to <productname>PostgreSQL</>.
  <application>libpq</> is a set of library functions that allow
  client programs to pass queries to the <productname>PostgreSQL</>
  backend server and to receive the results of these queries.
 </para>
-->
<para>
<application>libpq</application>是<productname>PostgreSQL</>的
<acronym>C</acronym>应用程序接口。<application>libpq</>
是一套允许客户程序向<productname>PostgreSQL</>
服务器服务进程发送查询并且获得查询返回的库函数。
</para>

 <!--
<para>
  <application>libpq</> is also the underlying engine for several
  other <productname>PostgreSQL</> application interfaces, including
  those written for C++, Perl, Python, Tcl and <application>ECPG</>.
  So some aspects of <application>libpq</>'s behavior will be
  important to you if you use one of those packages.  In particular,
  <xref linkend="libpq-envars">,
  <xref linkend="libpq-pgpass"> and
  <xref linkend="libpq-ssl">
  describe behavior that is visible to the user of any application
  that uses <application>libpq</>.
 </para>
-->
<para>
<application>libpq</>同时也是其他几个<productname>PostgreSQL</>
应用接口下面的引擎，包括 C++，Perl，Python，Tcl 和<application>ECPG</>。
所以如果你使用这些软件包，<application>libpq</>
某些方面的特性会对你非常重要。特别是<xref linkend="libpq-envars">，
<xref linkend="libpq-pgpass">和<xref linkend="libpq-ssl">
描述了任何使用<application>libpq</>的应用的用户可见的行为。
</para>

 <!--
<para>
  Some short programs are included at the end of this chapter (<xref linkend="libpq-example">) to show how
  to write programs that use <application>libpq</application>.  There are also several
  complete examples of <application>libpq</application> applications in the
  directory <filename>src/test/examples</filename> in the source code distribution.
 </para>
-->
<para>
本章末尾有三个小程序显示如何利用<application>libpq</application>书写程序。
（<xref linkend="libpq-example">）在源代码发布的<filename>src/test/examples</filename>
目录里面有几个完整的<application>libpq</application>应用的例子。
</para>

 <!--
<para>
  Client programs that use <application>libpq</application> must
  include the header file
  <filename>libpq-fe.h</filename><indexterm><primary>libpq-fe.h</></>
  and must link with the <application>libpq</application> library.
 </para>
-->
<para>
使用<application>libpq</application>的前端程序必须包括头文件
<filename>libpq-fe.h</filename><indexterm><primary>libpq-fe.h</></>
并且必须与<application>libpq</application>库链接。
</para>

 <sect1 id="libpq-connect">
  <!--
  <title>Database Connection Control Functions</title>
  -->
  <title>数据库连接控制函数</title>
<para>
  <!--
   The following functions deal with making a connection to a
   <productname>PostgreSQL</productname> backend server.  An
   application program can have several backend connections open at
   one time.  (One reason to do that is to access more than one
   database.)  Each connection is represented by a
   <structname>PGconn</><indexterm><primary>PGconn</></> object, which
   is obtained from the function <function>PQconnectdb</>,
   <function>PQconnectdbParams</>, or
   <function>PQsetdbLogin</>.  Note that these functions will always
   return a non-null object pointer, unless perhaps there is too
   little memory even to allocate the <structname>PGconn</> object.
   The <function>PQstatus</> function should be called to check
   the return value for a successful connection before queries are sent
   via the connection object.
-->
下面的函数处理与<productname>PostgreSQL</productname>服务器联接的事情。
一个应用程序一次可以与多个服务器建立联接。
（这么做的原因之一是访问多于一个数据库。） 每个连接都是用一个从函数
<function>PQconnectdb</>、<function>PQconnectdbParams</>或<function>PQsetdbLogin</>
获得的<structname>PGconn</><indexterm><primary>PGconn</></>对象表示。
注意，这些函数总是返回一个非空的对象指针，除非存储器少得连个
<structname>PGconn</>对象都分配不出来。在把查询发送给连接对象之前，
可以调用<function>PQstatus</>函数来检查一下返回值看看连接是否成功。
   <warning>
<!-- 
   <para>
     On Unix, forking a process with open libpq connections can lead to
     unpredictable results because the parent and child processes share
     the same sockets and operating system resources.  For this reason,
     such usage is not recommended, though doing an <function>exec</> from
     the child process to load a new executable is safe.
    </para>
-->
<para>
在Unix上，用打开的libpq连接分支化一个过程会导致不可预知的结果，
因为父进程和子进程共享同一个套接字和操作系统资源。因为这个原因，
不建议这样的使用，尽管从子进程中执行<function>exec</>
加载一个新的可执行文件是安全的。
</para>
   </warning>

   <note>
    <!--
<para>
     On Windows, there is a way to improve performance if a single
     database connection is repeatedly started and shutdown.  Internally,
     libpq calls <function>WSAStartup()</> and <function>WSACleanup()</> for connection startup
     and shutdown, respectively.  <function>WSAStartup()</> increments an internal
     Windows library reference count which is decremented by <function>WSACleanup()</>.
     When the reference count is just one, calling <function>WSACleanup()</> frees
     all resources and all DLLs are unloaded.  This is an expensive
     operation.  To avoid this, an application can manually call
     <function>WSAStartup()</> so resources will not be freed when the last database
     connection is closed.
    </para>
-->
<para>
在Windows上，如果一个数据库连接重复的启动和关闭，有一个方式提高性能。
内部的，libpq为连接启动和关闭分别调用<function>WSAStartup()</>和<function>WSACleanup()</>。
<function>WSAStartup()</>增加一个内部Windows库引用计数，而<function>WSACleanup()</>
减少一个。当引用计数是一时，调用<function>WSACleanup()</>释放所有资源和所有DLL是空载的。
这是一个昂贵的操作。为了避免它，一个应用可以手动调用<function>WSACleanup()</>，
这样在最后一个数据库连接关闭时，资源将不会被释放。
</para>
   </note>

   <variablelist>
    <varlistentry id="libpq-pqconnectdbparams">
     <term><function>PQconnectdbParams</function><indexterm><primary>PQconnectdbParams</></></term>
     <listitem>
<para>
<!--
        Makes a new connection to the database server.
 -->
与数据库服务器建立一个新的连接。
<synopsis>
PGconn *PQconnectdbParams(const char * const *keywords,
                          const char * const *values,
                          int expand_dbname);
</synopsis>
      </para>

      <!--
<para>
       This function opens a new database connection using the parameters taken
       from two <symbol>NULL</symbol>-terminated arrays. The first,
       <literal>keywords</literal>, is defined as an array of strings, each one
       being a key word. The second, <literal>values</literal>, gives the value
       for each key word. Unlike <function>PQsetdbLogin</> below, the parameter
       set can be extended without changing the function signature, so use of
       this function (or its nonblocking analogs <function>PQconnectStartParams</>
       and <function>PQconnectPoll</function>) is preferred for new application
       programming.
      </para>
-->
<para>
这个函数用从两个<symbol>NULL</symbol>结束的数组中来的参数打开一个新的数据库连接。
第一个，<literal>keywords</literal>，定义为一个字符串的数组，每个都成为一个关键字。
第二个，<literal>values</literal>，给每个关键字一个值。与下面的<function>PQsetdbLogin</>
不同的是，我们可以不必更换函数签名（名字）就可以扩展参数集，
所以我们建议应用程序中使用这个函数（或者它的类似的非阻塞变种
<function>PQconnectStartParams</>和<function>PQconnectPoll</function>）。
</para>

      <!--
<para>
       The currently recognized parameter key words are listed in
       <xref linkend="libpq-paramkeywords">.
      </para>
-->
<para>
目前公认的参数关键字在<xref linkend="libpq-paramkeywords">中列出。
</para>

      <!--
<para>
       When <literal>expand_dbname</literal> is non-zero, the
       <parameter>dbname</parameter> key word value is allowed to be recognized
       as a connection string. Only the first occurrence of
       <parameter>dbname</parameter> is expanded this way, any subsequent
       <parameter>dbname</parameter> value is processed as plain database name. More
       details on the possible connection string formats appear in
       <xref linkend="libpq-connstring">.
      </para>
-->
<para>
当<literal>expand_dbname</literal>是非零的时，允许将<parameter>dbname</parameter>
的关键字值看做一个连接字符串。只有第一个出现的<parameter>dbname</parameter>
是这样展开的，任何随后的<parameter>dbname</parameter>值作为纯数据库名处理。
可能的格式的更详细信息在<xref linkend="libpq-connstring">
中显示。
</para>

      <!--
<para>
       The passed arrays can be empty to use all default parameters, or can
       contain one or more parameter settings. They should be matched in length.
       Processing will stop at the first <symbol>NULL</symbol> element
       in the <literal>keywords</literal> array.
      </para>
-->
<para>
传入的参数可以为空，表明使用所有缺省的参数，或者可以包含一个或更多个参数设置。
它们的长度应该匹配。处理将会在<literal>keywords</literal>数组的第一个
<symbol>NULL</symbol>元素停止。
</para>

      <!--
<para>
       If  any  parameter is <symbol>NULL</symbol> or an emptry string, the corresponding
       environment variable (see <xref linkend="libpq-envars">) is checked.
       If the  environment  variable is not set either, then the indicated
       built-in defaults are used.
      </para>
-->
<para>
如果任意参数是<symbol>NULL</symbol>或空字符串，则检查对应的环境变量（参阅<xref linkend="libpq-envars">）。
如果环境变量也没有设置，则使用指出的内建缺省。
</para>

      <!--
<para>
       In general key words are processed from the beginning of these arrays in index
       order. The effect of this is that when key words are repeated, the last processed
       value is retained. Therefore, through careful placement of the
       <parameter>dbname</parameter> key word, it is possible to determine what may
       be overridden by a <parameter>conninfo</parameter> string, and what may not.
      </para>
-->
<para>
通常，关键字是从这些数组的开始以索引的顺序处理的。这样的影响是，当关键字重复时，
获得最后处理的值。因此，通过小心的放置<parameter>dbname</parameter>关键字，
有可能决定哪个被<parameter>conninfo</parameter>字符串覆盖，哪个不被覆盖。
</para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconnectdb">
     <term><function>PQconnectdb</function><indexterm><primary>PQconnectdb</></></term>
     <listitem>    
<para>
<!--
       Makes a new connection to the database server.
-->
与数据库服务器建立一个新的连接。
<synopsis>
PGconn *PQconnectdb(const char *conninfo);
</synopsis>
      </para>

      <!--
<para>
       This function opens a new database connection using the parameters taken
       from the string <literal>conninfo</literal>.
      </para>
-->
<para>
这个函数用从一个字符串<literal>conninfo</literal>来的参数与数据库打开一个新的联接。
</para>

      <!--
<para>
       The passed string can be empty to use all default parameters, or it can
       contain one or more parameter settings separated by whitespace,
       or it can contain a <acronym>URI</acronym>.
       See <xref linkend="libpq-connstring"> for details.
     </para>
-->
<para>
传入的参数可以为空，表明使用所有缺省的参数，或者可以包含一个或更多个用空白间隔的参数设置，
或者它可以包含一个<acronym>URI</acronym>。参阅<xref linkend="libpq-connstring">获取细节。
</para>


    </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsetdblogin">
     <term><function>PQsetdbLogin</function><indexterm><primary>PQsetdbLogin</></></term>
     <listitem>
      
<para>
<!--
       Makes a new connection to the database server.
-->
   与数据库服务器建立一个新的连接。
<synopsis>
PGconn *PQsetdbLogin(const char *pghost,
                     const char *pgport,
                     const char *pgoptions,
                     const char *pgtty,
                     const char *dbName,
                     const char *login,
                     const char *pwd);
</synopsis>
       </para>

       <!--
<para>
        This is the predecessor of <function>PQconnectdb</function> with a fixed
        set of parameters.  It has the same functionality except that the
        missing parameters will always take on default values.  Write <symbol>NULL</symbol> or an
        empty string for any one of the fixed parameters that is to be defaulted.
      </para>
-->
<para>
这个函数是<function>PQconnectdb</function>前身，它有固定个数的参数。它有相同的功能，
只是在调用中那些它缺少的参数总是用缺省值。如果要给任意的固定参数设置缺省值，
那么写一个<symbol>NULL</symbol>或者一个空字串给它们。
</para>

      <!--
<para>
        If the <parameter>dbName</parameter> contains
        an <symbol>=</symbol> sign or has a valid connection <acronym>URI</acronym> prefix, it
        is taken as a <parameter>conninfo</parameter> string in exactly the same way as
        if it had been passed to <function>PQconnectdb</function>, and the remaining
        parameters are then applied as specified for <function>PQconnectdbParams</>.
      </para>
-->
<para>
如果<parameter>dbName</parameter>包含一个<symbol>=</symbol>符或者有一个有效的连接
<acronym>URI</acronym>前缀，它被看做一个<parameter>conninfo</parameter>字符串，
就和它已经被传递到<function>PQconnectdb</function>中完全一样，
然后剩余的参数就像为<function>PQconnectdbParams</>指定的那样应用。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsetdb">
     <term><function>PQsetdb</function><indexterm><primary>PQsetdb</></></term>
     <listitem>
      
<para>
<!--
   Makes a new connection to the database server.
-->
   与数据库服务器建立一个新的连接。
<synopsis>
PGconn *PQsetdb(char *pghost,
                char *pgport,
                char *pgoptions,
                char *pgtty,
                char *dbName);
</synopsis>
     </para>

     <!--
<para>
      This is a macro that calls <function>PQsetdbLogin</function> with null pointers
      for the <parameter>login</> and <parameter>pwd</> parameters.  It is provided
      for backward compatibility with very old programs.
     </para>
-->
<para>
这是一个调用<function>PQsetdbLogin</function>的宏，只是<parameter>login</>和<parameter>pwd</>
参数是空指针。提供这个函数是为了与非常老版本的程序兼容。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconnectstartparams">
     <term><function>PQconnectStartParams</function><indexterm><primary>PQconnectStartParams</></></term>
     <term><function>PQconnectStart</function><indexterm><primary>PQconnectStart</></></term>
     <term><function>PQconnectPoll</function><indexterm><primary>PQconnectPoll</></></term>
     <listitem>
      
<para>
<!--
       <indexterm><primary>nonblocking connection</primary></indexterm>
       Make a connection to the database server in a nonblocking manner.
-->
<indexterm><primary>非阻塞连接</primary></indexterm>
与数据库服务器建立一次非阻塞的联接。
<synopsis>
PGconn *PQconnectStartParams(const char * const *keywords,
                             const char * const *values,
                             int expand_dbname);

PGconn *PQconnectStart(const char *conninfo);

PostgresPollingStatusType PQconnectPoll(PGconn *conn);
</synopsis>
      </para>

      <!--
<para>
       These three functions are used to open a connection to a database server such
       that your application's thread of execution is not blocked on remote I/O
       whilst doing so. The point of this approach is that the waits for I/O to
       complete can occur in the application's main loop, rather than down inside
       <function>PQconnectdbParams</> or <function>PQconnectdb</>, and so the
       application can manage this operation in parallel with other activities.
      </para>
-->
<para>
这三个函数用于打开一个与数据库服务器之间的非阻塞的联接：
你的应用的执行线程在执行它的时候不会因远端的 I/O 而阻塞。
这个方法的要点是等待 I/O 结束可以发生在应用的主循环里，
而不是在<function>PQconnectdbParams</>或<function>PQconnectdb</>里，
这样应用可以把这件事与其它操作并发起来一起执行。
</para>

      <!--
<para>
       With <function>PQconnectStartParams</function>, the database connection is made
       using the parameters taken from the <literal>keywords</literal> and
       <literal>values</literal> arrays, and controlled by <literal>expand_dbname</literal>,
       as described above for <function>PQconnectdbParams</function>.
      </para>
-->
<para>
对于<function>PQconnectStartParams</function>，数据库联接是用从<literal>keywords</literal>
和<literal>values</literal>数组中取得的参数进行的，并且是使用<literal>expand_dbname</literal>
控制的，就像上面<function>PQconnectdbParams</function>里描述的一样。
</para>

      <!--
<para>
       With <function>PQconnectStart</function>, the database connection is made
       using the parameters taken from the string <literal>conninfo</literal> as
       described above for <function>PQconnectdb</function>.
      </para>
-->
<para>
对于<function>PQconnectStart</function>，数据库联接是用从<literal>conninfo</literal>
字符串里取得的参数进行的，这个字符串的格式与上面<function>PQconnectdb</function>
里描述的一样。
</para>

      
<para>
<!-- 
       Neither <function>PQconnectStartParams</function> nor <function>PQconnectStart</function>
       nor <function>PQconnectPoll</function> will block, so long as a number of
       restrictions are met: 
-->
<function>PQconnectStartParams</function>、<function>PQconnectStart</function>
和<function>PQconnectPoll</function>都不会阻塞（进程），不过有一些条件：
       <itemizedlist>
        <listitem>
<!--
         <para>
          The <literal>hostaddr</> and <literal>host</> parameters are used appropriately to ensure that
          name and reverse name queries are not made. See the documentation of
          these parameters in <xref linkend="libpq-paramkeywords"> for details.
         </para>
-->
<para>
必须正确提供<literal>hostaddr</>和<literal>host</>参数以确保不会发生正向或者反向的名字查找。
参阅<xref linkend="libpq-paramkeywords">里的这些参数的文档获取细节。
</para>
        </listitem>

        <listitem>
         <!--
<para>
          If you call <function>PQtrace</function>, ensure that the stream object
          into which you trace will not block.
         </para>
-->
<para>
如果你调用了<function>PQtrace</function>，确保你跟踪进入的流对象不会阻塞。
</para>
        </listitem>

        <listitem>
         <!--
<para>
          You ensure that the socket is in the appropriate state
          before calling <function>PQconnectPoll</function>, as described below.
         </para>
-->
<para>
你必须在调用<function>PQconnectPoll</function>之前确保 socket 处于正确的状态，
像下面描述的那样。
</para>
        </listitem>
       </itemizedlist>
      </para>

      <!--
<para>
       Note: use of <function>PQconnectStartParams</> is analogous to
       <function>PQconnectStart</> shown below.
      </para>
-->
<para>
注意：<function>PQconnectStartParams</>的使用类似于下面显示的<function>PQconnectStart</>。
</para>

      <!--
<para>
       To begin a nonblocking connection request, call <literal>conn = PQconnectStart("<replaceable>connection_info_string</>")</literal>.
       If <varname>conn</varname> is null, then <application>libpq</> has been unable to allocate a new <structname>PGconn</>
       structure. Otherwise, a valid <structname>PGconn</> pointer is returned (though not yet
       representing a valid connection to the database). On return from
       <function>PQconnectStart</function>, call <literal>status = PQstatus(conn)</literal>. If <varname>status</varname> equals
       <symbol>CONNECTION_BAD</symbol>, <function>PQconnectStart</function> has failed.
      </para>
-->
<para>
要开始一次非阻塞连接请求，调用<literal>conn = PQconnectStart("<replaceable>connection_info_string</>")</literal>。
如果<varname>conn</varname>是空，表明<application>libpq</>无法分配一个新的<structname>PGconn</>结构。
否则，返回一个有效的<structname>PGconn</>指针（尽管还不一定代表一个与数据库有效联接）。
<function>PQconnectStart</function>一返回，调用<literal>status = PQstatus(conn)</literal>。
如果<varname>status</varname>等于<symbol>CONNECTION_BAD</symbol>，<function>PQconnectStart</function>失败。
</para>

      <!--
<para>
       If <function>PQconnectStart</> succeeds, the next stage is to poll
       <application>libpq</> so that it can proceed with the connection sequence.
       Use <function>PQsocket(conn)</function> to obtain the descriptor of the
       socket underlying the database connection.
       Loop thus: If <function>PQconnectPoll(conn)</function> last returned
       <symbol>PGRES_POLLING_READING</symbol>, wait until the socket is ready to
       read (as indicated by <function>select()</>, <function>poll()</>, or
       similar system function).
       Then call <function>PQconnectPoll(conn)</function> again.
       Conversely, if <function>PQconnectPoll(conn)</function> last returned
       <symbol>PGRES_POLLING_WRITING</symbol>, wait until the socket is ready
       to write, then call <function>PQconnectPoll(conn)</function> again.
       If you have yet to call
       <function>PQconnectPoll</function>, i.e., just after the call to
       <function>PQconnectStart</function>, behave as if it last returned
       <symbol>PGRES_POLLING_WRITING</symbol>.  Continue this loop until
       <function>PQconnectPoll(conn)</function> returns
       <symbol>PGRES_POLLING_FAILED</symbol>, indicating the connection procedure
       has failed, or <symbol>PGRES_POLLING_OK</symbol>, indicating the connection
       has been successfully made.
      </para>
-->
<para>
如果<function>PQconnectStart</>成功了，下一个阶段是轮询<application>libpq</>，
这样它就可以继续连接序列动作。使用<function>PQsocket(conn)</function>
获取数据库链接下层的套接字描述符。像这样循环：如果<function>PQconnectPoll(conn)</function>
的最后一个返回是<symbol>PGRES_POLLING_READING</symbol>，那么就等到套接字准备好被读取了的时候
（就像系统函数<function>select()</>，<function>poll()</>，或者类似的系统调用声明的那样）。
然后再次调用<function>PQconnectPoll(conn)</function>。反过来，如果<function>PQconnectPoll(conn)</function>
最后返回<symbol>PGRES_POLLING_WRITING</symbol>，那么就等到套接字准备好可以写了，
然后再次调用<function>PQconnectPoll(conn)</function>。如果你还没调用<function>PQconnectPoll</function>，
比如，刚刚调用完<function>PQconnectStart</function>，那么按照它刚返回<symbol>PGRES_POLLING_WRITING</symbol>
的原则行动。继续这个循环直到<function>PQconnectPoll(conn)</function>返回<symbol>PGRES_POLLING_FAILED</symbol>，
表明连接过程失败，或者<symbol>PGRES_POLLING_OK</symbol>，表明连接成功建立。
</para>

      
<para>
<!-- 
       At any time during connection, the status of the connection can be
       checked by calling <function>PQstatus</>. If this call returns <symbol>CONNECTION_BAD</>, then the
       connection procedure has failed; if the call returns <function>CONNECTION_OK</>, then the
       connection is ready.  Both of these states are equally detectable
       from the return value of <function>PQconnectPoll</>, described above. Other states might also occur
       during (and only during) an asynchronous connection procedure. These
       indicate the current stage of the connection procedure and might be useful
       to provide feedback to the user for example. These statuses are:
-->
在连接的任意时刻，我们都可以通过调用<function>PQstatus</>来检查联接的状态。
如果这是<symbol>CONNECTION_BAD</>，那么联接过程失败；如果是<function>CONNECTION_OK</>，
那么联接已经做好。这两种状态同样也可以从上面的<function>PQconnectPoll</>的返回值里检测到。
其他状态可能（也只能）在一次异步联接过程中发生。这些标识连接过程的当前状态，
因而可能对给用户提供反馈有帮助。这些状态可能包括：
       <variablelist>
        <varlistentry id="libpq-connection-started">
         <term><symbol>CONNECTION_STARTED</symbol></term>
         <listitem>
<!--
          <para>
           Waiting for connection to be made.
          </para>
-->
<para>
等待进行连接。
</para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-made">
         <term><symbol>CONNECTION_MADE</symbol></term>
         <listitem>
          <!--
<para>
           Connection OK; waiting to send.
          </para>
-->
<para>
连接成功；等待发送。
</para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-awaiting-response">
         <term><symbol>CONNECTION_AWAITING_RESPONSE</symbol></term>
         <listitem>
          <!--
<para>
           Waiting for a response from the server.
          </para>
-->
<para>
等待来自服务器的响应。
</para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-auth-ok">
         <term><symbol>CONNECTION_AUTH_OK</symbol></term>
         <listitem>
          <!--
<para>
           Received authentication; waiting for backend start-up to finish.
          </para>
-->
<para>
已收到认证；等待后端启动结束。
</para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-ssl-startup">
         <term><symbol>CONNECTION_SSL_STARTUP</symbol></term>
         <listitem>
          <!--
<para>
           Negotiating SSL encryption.
          </para>
-->
<para>
协商 SSL 加密。
</para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-setenv">
         <term><symbol>CONNECTION_SETENV</symbol></term>
         <listitem>
          <!--
<para>
           Negotiating environment-driven parameter settings.
          </para>
-->
<para>
协商环境驱动的参数设置。
</para>
         </listitem>
        </varlistentry>
       </variablelist>

<!-- 
       Note that, although these constants will remain (in order to maintain
       compatibility), an application should never rely upon these occurring in a
       particular order, or at all, or on the status always being one of these
       documented values. An application might do something like this: 
-->
注意，尽管这些常量将保持下去（为了维持兼容性），应用决不应该依赖于这些常量以某种特定顺序出现，
或者是根本不应依赖于这些常量，或者是不应该依赖于这些状态总是某个文档声明的值。
一个应用可能像下面这样：
<programlisting>
switch(PQstatus(conn))
{
        case CONNECTION_STARTED:
            feedback = "Connecting...";
            break;

        case CONNECTION_MADE:
            feedback = "Connected to server...";
            break;
.
.
.
        default:
            feedback = "Connecting...";
}
</programlisting>
      </para>

      <!--
<para>
       The <literal>connect_timeout</literal> connection parameter is ignored
       when using <function>PQconnectPoll</function>; it is the application's
       responsibility to decide whether an excessive amount of time has elapsed.
       Otherwise, <function>PQconnectStart</function> followed by a
       <function>PQconnectPoll</function> loop is equivalent to
       <function>PQconnectdb</function>.
      </para>
-->
<para>
在使用<function>PQconnectPoll</function>的时候，连接参数<literal>connect_timeout</literal>
将被忽略；判断是否超时是应用的责任。否则，后面跟着一个<function>PQconnectPoll</function>
循环的<function>PQconnectStart</function>等效于<function>PQconnectdb</function>。
</para>

      <!--
<para>
       Note that if <function>PQconnectStart</function> returns a non-null pointer, you must call
       <function>PQfinish</function> when you are finished with it, in order to dispose of
       the structure and any associated memory blocks. This must be done even if
       the connection attempt fails or is abandoned.
      </para>
-->
<para>
要注意如果<function>PQconnectStart</function>返回一个非空的指针，你必须在使用完它（指针）
之后调用<function>PQfinish</function>，以处理那些结构和所有相关的存储块。
甚至是在连接尝试失败或放弃时也要这样处理。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconndefaults">
     <term><function>PQconndefaults</function><indexterm><primary>PQconndefaults</></></term>
     <listitem>
      
<para>
<!--
       Returns the default connection options.
-->
返回缺省的联接选项。
<synopsis>
PQconninfoOption *PQconndefaults(void);

typedef struct
{
    char   *keyword;   /* <!-- The keyword of the option -->选项的键字 */
    char   *envvar;    /* <!-- Fallback environment variable name -->退守的环境变量名 */
    char   *compiled;  /* <!-- Fallback compiled in default value --> 退守的编译时缺省值*/
    char   *val;       /* <!-- Option's current value, or NULL -->选项的当前值，或者 NULL */
    char   *label;     /* <!-- Label for field in connect dialog -->连接对话里字段的标识 */
    char   *dispchar;  /* <!-- Indicates how to display this field -->在连接对话里为此字段显示的字符。
                          <!-- in a connect dialog. Values are: -->数值有：
                          ""        <!-- Display entered value as is -->原样现实输入的数值
                          "*"       <!-- Password field - hide value -->口令字段 － 隐藏数值
                          "D"       <!-- Debug option - don't show by default -->调试选项 － 缺省的时候不显示 */
    int     dispsize;  /* <!-- Field size in characters for dialog --> 对话中字段的以字符计的大小 */
} PQconninfoOption;
</synopsis>
      </para>

      <!--
<para>
       Returns a connection options array.  This can be used to determine
       all possible <function>PQconnectdb</function> options and their
       current default values.  The return value points to an array of
       <structname>PQconninfoOption</structname> structures, which ends
       with an entry having a null <structfield>keyword</> pointer.  The
       null pointer is returned if memory could not be allocated. Note that
       the current default values (<structfield>val</structfield> fields)
       will depend on environment variables and other context.  A
       missing or invalid service file will be silently ignored.  Callers
       must treat the connection options data as read-only.
      </para>
-->
<para>
返回一个连接选项数组。可以用于获取所有可能的<function>PQconnectdb</function>
选项和它们的当前缺省值。返回值指向一个<structname>PQconninfoOption</structname>
结构的数组，该数组以一个有 NULL <structfield>keyword</>指针的条目结束。
如果无法分配内存，则返回空指针。注意当前缺省值（<structfield>val</structfield>域）
将依赖于环境变量和其他环境。丢失或者无效的服务文件将默默地忽略掉。
调用者必须把连接选项当作只读对待。
</para>

      <!--
<para>
       After processing the options array, free it by passing it to
       <function>PQconninfoFree</function>.  If this is not done, a small amount of memory
       is leaked for each call to <function>PQconndefaults</function>.
      </para>
-->
<para>
在处理完选项数组后，把数组交给<function>PQconninfoFree</function>释放。
如果没有这么做，每次调用<function>PQconndefaults</function>都会有一小部分内存泄漏。
</para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconninfo">
     <term><function>PQconninfo</function><indexterm><primary>PQconninfo</></></term>
     <listitem>
<para>
<!--
       Returns the connection options used by a live connection.
-->
返回活的连接使用的连接选项。
<synopsis>
PQconninfoOption *PQconninfo(PGconn *conn);
</synopsis>
      </para>

      <!--
<para>
       Returns a connection options array.  This can be used to determine
       all possible <function>PQconnectdb</function> options and the
       values that were used to connect to the server. The return
       value points to an array of <structname>PQconninfoOption</structname>
       structures, which ends with an entry having a null <structfield>keyword</>
       pointer. All notes above for <function>PQconndefaults</function> also
       apply to the result of <function>PQconninfo</function>.
      </para>
-->
<para>
返回一个连接选项数组。可以用于获取所有可能的<function>PQconnectdb</function>
选项和用于连接到服务器的值。返回值指向一个<structname>PQconninfoOption</structname>
结构的数组，该数组以一个有 NULL <structfield>keyword</>指针的条目结束。
以上所有<function>PQconndefaults</function>的注意事项也应用到<function>PQconninfo</function>
的结果。
</para>

     </listitem>
    </varlistentry>


    <varlistentry id="libpq-pqconninfoparse">
     <term><function>PQconninfoParse</function><indexterm><primary>PQconninfoParse</></></term>
     <listitem>
<para>
<!--
       Returns parsed connection options from the provided connection string.
-->
从提供的连接字符串中返回解析的连接选项。
<synopsis>
PQconninfoOption *PQconninfoParse(const char *conninfo, char **errmsg);
</synopsis>
      </para>

      <!--
<para>
       Parses a connection string and returns the resulting options as an
       array; or returns <symbol>NULL</> if there is a problem with the connection
       string.  This function can be used to extract
       the <function>PQconnectdb</function> options in the provided
       connection string.  The return value points to an array of
       <structname>PQconninfoOption</structname> structures, which ends
       with an entry having a null <structfield>keyword</> pointer.
      </para>
-->
<para>
解析连接字符串并作为数组返回结果选项；或者如果连接字符串有问题返回<symbol>NULL</>。
这个函数可以用来在提供的连接字符串中提取<function>PQconnectdb</function>选项。
返回值指向一个<structname>PQconninfoOption</structname>结构的数组，
该数组以一个有 NULL <structfield>keyword</>指针的条目结束。
</para>

      <!--
<para>
       All legal options will be present in the result array, but the
       <literal>PQconninfoOption</literal> for any option not present
       in the connection string will have <literal>val</literal> set to
       <literal>NULL</literal>; default values are not inserted.
      </para>
-->
<para>
所有合法选项将在结果数组中显示，但是<literal>PQconninfoOption</literal>
的任何没有在连接字符串中出现的选项将把<literal>val</literal>设置为<literal>NULL</literal>；
缺省值不插入。
</para>

      <!--
<para>
       If <literal>errmsg</> is not <symbol>NULL</>, then <literal>*errmsg</> is set
       to <symbol>NULL</> on success, else to a <function>malloc</>'d error string explaining
       the problem.  (It is also possible for <literal>*errmsg</> to be
       set to <symbol>NULL</> and the function to return <symbol>NULL</>;
       this indicates an out-of-memory condition.)
      </para>
-->
<para>
如果<literal>errmsg</>是非<symbol>NULL</>的，那么<literal>*errmsg</>在成功时设置为<symbol>NULL</>，
否则是<function>malloc</>的解释问题的错误字符串。（<literal>*errmsg</>设置为<symbol>NULL</>
并且函数返回<symbol>NULL</>是可能的；这表示一个内存溢出条件。）
</para>

      <!--
<para>
       After processing the options array, free it by passing it to
       <function>PQconninfoFree</function>.  If this is not done, some memory
       is leaked for each call to <function>PQconninfoParse</function>.
       Conversely, if an error occurs and <literal>errmsg</> is not <symbol>NULL</>,
       be sure to free the error string using <function>PQfreemem</>.
      </para>
-->
<para>
在处理完选项数组后，把数组交给<function>PQconninfoFree</function>释放。
如果没有这么做，每次调用<function>PQconndefaults</function>都会有一小部分内存泄漏。
相反的，如果错误发生了并且<literal>errmsg</>非<symbol>NULL</>，
确保使用<function>PQfreemem</>释放错误字符串。
</para>

   </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfinish">
     <term><function>PQfinish</function><indexterm><primary>PQfinish</></></term>
     <listitem>
      
<para>
<!--
       Closes  the  connection to the server.  Also frees
       memory used by the <structname>PGconn</structname> object.
-->
关闭与服务器的连接。同时释放被<structname>PGconn</structname>对象使用的存储器。
<synopsis>
void PQfinish(PGconn *conn);
</synopsis>
      </para>

      <!--
<para>
       Note that even if the server connection attempt fails (as
       indicated by <function>PQstatus</function>), the application should call <function>PQfinish</function>
       to free the memory used by the <structname>PGconn</structname> object.
       The <structname>PGconn</> pointer must not be used again after
       <function>PQfinish</function> has been called.
      </para>
-->
<para>
注意，即使与服务器的连接尝试失败（可由<function>PQstatus</function>判断），
应用也要调用<function>PQfinish</function>释放被<structname>PGconn</structname>
对象使用的存储器。不应该在调用<function>PQfinish</function>后再使用<structname>PGconn</>指针。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqreset">
     <term><function>PQreset</function><indexterm><primary>PQreset</></></term>
     <listitem>
      
<para>
<!--
       Resets the communication channel to the server.
-->
重置与服务器的通讯端口。
<synopsis>
void PQreset(PGconn *conn);
</synopsis>
      </para>

      <!--
<para>
       This function will close the connection
       to the server and attempt to  reestablish  a  new
       connection to the same server, using all the same
       parameters previously used.  This might be useful for
       error recovery if a working connection is lost.
      </para>
-->
<para>
此函数将关闭与服务器的连接并且试图与同一个服务器重建新的连接，
使用所有前面使用过的参数。这在失去工作连接后进行故障恢复时很有用。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqresetstart">
     <term><function>PQresetStart</function><indexterm><primary>PQresetStart</></></term>
     <term><function>PQresetPoll</function><indexterm><primary>PQresetPoll</></></term>
     <listitem>
      
<para>
<!--
       Reset the communication channel to the server, in a nonblocking manner.
-->
以非阻塞模式重置与服务器的通讯端口。
<synopsis>
int PQresetStart(PGconn *conn);

PostgresPollingStatusType PQresetPoll(PGconn *conn);
</synopsis>
      </para>

      <!--
<para>
       These functions will close the connection to the server and attempt to
       reestablish a new connection to the same server, using all the same
       parameters previously used. This can be useful for error recovery if a
       working connection is lost. They differ from <function>PQreset</function> (above) in that they
       act in a nonblocking manner. These functions suffer from the same
       restrictions as <function>PQconnectStartParams</>, <function>PQconnectStart</>
       and <function>PQconnectPoll</>.
      </para>
-->
<para>
此函数将关闭与服务器的连接并且试图与同一个服务器重建新的连接，使用所有前面使用过的参数。
这在失去工作连接后进行故障恢复时很有用。它们和上面的<function>PQreset</function>
的区别是它们工作在非阻塞模式。这些函数的使用有与上面<function>PQconnectStartParams</>、
<function>PQconnectStart</>和<function>PQconnectPoll</>一样的限制。
</para>

      <!--
<para>
       To initiate a connection reset, call
       <function>PQresetStart</function>. If it returns 0, the reset has
       failed. If it returns 1, poll the reset using
       <function>PQresetPoll</function> in exactly the same way as you
       would create the connection using <function>PQconnectPoll</function>.
     </para>
-->
<para>
要发起一次连接重置，调用<function>PQresetStart</function>。如果它返回 0，
那么重置失败。如果返回 1，用与使用<function>PQresetPoll</function>
建立连接的同样的方法使用<function>PQresetPoll</function>重置连接。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqpingparams">
     <term><function>PQpingParams</function><indexterm><primary>PQpingParams</></></term>
     <listitem>
      
<para>
<!-- 
       <function>PQpingParams</function> reports the status of the
       server.  It accepts connection parameters identical to those of
       <function>PQconnectdbParams</>, described above.  It is not
       necessary to supply correct user name, password, or database name
       values to obtain the server status; however, if incorrect values
       are provided, the server will log a failed connection attempt.
-->
<function>PQpingParams</function>报告服务器的状态。它接受和<function>PQconnectdbParams</>
一样的连接参数，在下面描述。不需要应用正确的用户名、密码或数据库名的值获取服务器状态；
不过，如果提供了不正确的值，服务器将记录一次失败的连接尝试。
<synopsis>
PGPing PQpingParams(const char * const *keywords,
                    const char * const *values,
                    int expand_dbname);
</synopsis>
<!-- 
       The function returns one of the following values:
-->
该函数返回下列的值之一：
       <variablelist>
        <varlistentry id="libpq-pqpingparams-pqping-ok">
         <term><literal>PQPING_OK</literal></term>
         <listitem>
<!--
          <para>
           The server is running and appears to be accepting connections.
          </para>
-->
<para>
服务器正在运行并且似乎接受了连接。
</para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pqpingparams-pqping-reject">
         <term><literal>PQPING_REJECT</literal></term>
         <listitem>
          <!--
<para>
           The server is running but is in a state that disallows connections
           (startup, shutdown, or crash recovery).
          </para>
-->
<para>
服务器正在运行，但是在一个不允许连接的状态（启动、关闭或崩溃恢复）。
</para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pqpingparams-pqping-no-response">
         <term><literal>PQPING_NO_RESPONSE</literal></term>
         <listitem>
          <!--
<para>
           The server could not be contacted.  This might indicate that the
           server is not running, or that there is something wrong with the
           given connection parameters (for example, wrong port number), or
           that there is a network connectivity problem (for example, a
           firewall blocking the connection request).
          </para>
-->
<para>
联系不上服务器。这可能表明服务器没有运行，或者给出的连接参数有什么错误
（例如，错误的端口号），或者网络连接有问题（例如，防火墙阻塞连接请求）。
</para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pqpingparams-pqping-no-attempt">
         <term><literal>PQPING_NO_ATTEMPT</literal></term>
         <listitem>
          <!--
<para>
           No attempt was made to contact the server, because the supplied
           parameters were obviously incorrect or there was some client-side
           problem (for example, out of memory).
          </para>
-->
<para>
没有尝试连接到服务器，因为提供的参数明显的不正确或者有一些客户端侧的问题（例如，内存溢出）。
</para>
         </listitem>
        </varlistentry>
       </variablelist>

      </para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqping">
     <term><function>PQping</function><indexterm><primary>PQping</></></term>
     <listitem>
     
<para>
 <!--
 <function>PQping</function> reports the status of the
       server.  It accepts connection parameters identical to those of
       <function>PQconnectdb</>, described above.  It is not
       necessary to supply correct user name, password, or database name
       values to obtain the server status; however, if incorrect values
       are provided, the server will log a failed connection attempt.
-->
<function>PQping</function>报告服务器的状态。它接受和<function>PQconnectdb</>
一样的连接参数，在下面描述。不需要应用正确的用户名、密码或数据库名的值获取服务器状态；
不过，如果提供了不正确的值，服务器将记录一次失败的连接尝试。
<synopsis>
PGPing PQping(const char *conninfo);
</synopsis>
      </para>

      <!--
<para>
       The return values are the same as for <function>PQpingParams</>.
      </para>
-->
<para>
返回值和<function>PQpingParams</>的相同。
</para>

     </listitem>
    </varlistentry>

   </variablelist>
  </para>

  <sect2 id="libpq-connstring">
   <!--
   <title>Connection Strings</title>
   -->
   <title>连接字符串</title>

   <indexterm zone="libpq-connstring">
    <primary><literal>conninfo</literal></primary>
   </indexterm>

   <indexterm zone="libpq-connstring">
    <primary><literal>URI</literal></primary>
   </indexterm>

   <!--
<para>
    Several <application>libpq</> functions parse a user-specified string to obtain
    connection parameters.  There are two accepted formats for these strings:
    plain <literal>keyword = value</literal> strings
    and <ulink url="http://www.ietf.org/rfc/rfc3986.txt">RFC
    3986</ulink> URIs.
   </para>
-->
<para>
几个<application>libpq</>函数分析用户指定的字符串以获取连接参数。
这些字符串有两个可接受的格式：纯<literal>keyword = value</literal>字符串和
<ulink url="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986</ulink> URIs。
</para>

   <sect3>
    <!--
<title>Keyword/Value Connection Strings</title>
-->
<title>关键字/值连接字符串</title>

   <!--
<para>
    In the first format, each parameter setting is in the form
    <literal>keyword = value</literal>.  Spaces around the equal sign are
    optional. To write an empty value, or a value containing spaces, surround it
    with single quotes, e.g., <literal>keyword = 'a value'</literal>. Single
    quotes and backslashes within
    the value must be escaped with a backslash, i.e., <literal>\'</literal> and
    <literal>\\</literal>.
   </para>
-->
<para>
在第一中格式中，每个参数以<literal>keyword = value</literal>的形式设置。
等号周围的空白是可选的。要写一个空值或者一个包含空白的值，你可以用一对单引号包围它们，
例如，<literal>keyword = 'a value'</literal>。数值内部的单引号和反斜杠必须用一个反斜杠转义，
比如，<literal>\'</literal>或<literal>\\</literal>。
</para>

   <!--
<para>
    Example:
<programlisting>
host=localhost port=5432 dbname=mydb connect_timeout=10
</programlisting>
   </para>
-->
<para>
示例：
<programlisting>
host=localhost port=5432 dbname=mydb connect_timeout=10
</programlisting>
</para>

   <!--
<para>
    The recognized parameter key words are listed in <xref
    linkend="libpq-paramkeywords">.
   </para>
-->
<para>
可识别的参数关键字在<xref linkend="libpq-paramkeywords">中列出。
</para>
   </sect3>

   <sect3>
    <!--
<title>Connection URIs</title>
-->
<title>连接URI</title>
<para>
<!--
   The general form for a connection <acronym>URI</acronym> is:
-->
连接<acronym>URI</acronym>的通用格式是：
<synopsis>
postgresql://[user[:password]@][netloc][:port][/dbname][?param1=value1&amp;...]
</synopsis>
   </para>

<para>
<!-- 
    The <acronym>URI</acronym> scheme designator can be either
    <literal>postgresql://</literal> or <literal>postgres://</literal>.  Each
    of the <acronym>URI</acronym> parts is optional.  The following examples
    illustrate valid <acronym>URI</acronym> syntax uses: 
-->
<acronym>URI</acronym>模式标识符可以是<literal>postgresql://</literal>或
<literal>postgres://</literal>。<acronym>URI</acronym>的每个部分都是可选的。
下列示例举例说明了有效的<acronym>URI</acronym>语法使用：
<programlisting>
postgresql://
postgresql://localhost
postgresql://localhost:5433
postgresql://localhost/mydb
postgresql://user@localhost
postgresql://user:secret@localhost
postgresql://other@localhost/otherdb?connect_timeout=10&amp;application_name=myapp
</programlisting>
<!-- 
    Components of the hierarchical part of the <acronym>URI</acronym> can also
    be given as parameters.  For example: 
-->
<acronym>URI</acronym>的层次部分的组件也可以作为参数给出。例如：
<programlisting>
postgresql:///mydb?host=localhost&amp;port=5433
</programlisting>
   </para>

   <!--
<para>
    Percent-encoding may be used to include symbols with special meaning in any
    of the <acronym>URI</acronym> parts.
   </para>
-->
<para>
百分号可以用在<acronym>URI</acronym>的任何部分来包含特殊含义的符号。
</para>

   <!--
<para>
    Any connection parameters not corresponding to key words listed in <xref
    linkend="libpq-paramkeywords"> are ignored and a warning message about them
    is sent to <filename>stderr</filename>.
   </para>
-->
<para>
忽略任何不对应于在<xref linkend="libpq-paramkeywords">列出的关键字的连接参数，
并将关于它们的警告消息发送到<filename>stderr</filename>。
</para>

   <!--
<para>
    For improved compatibility with JDBC connection <acronym>URI</acronym>s,
    instances of parameter <literal>ssl=true</literal> are translated into
    <literal>sslmode=require</literal>.
</para>
-->
<para>
为了提高JDBC连接<acronym>URI</acronym>的兼容性，参数<literal>ssl=true</literal>
的实例被翻译成<literal>sslmode=require</literal>。
</para>
  
<para>
<!--
    The host part may be either host name or an IP address.  To specify an
    IPv6 host address, enclose it in square brackets:
-->
主机部分是主机名或者IP地址。要指定一个IPv6主机地址，将它包含在方括号中：
<synopsis>
postgresql://[2001:db8::1234]/database
</synopsis>
   </para>
   
<para>
<!--
    The host component is interpreted as described for the parameter <xref
    linkend="libpq-connect-host">.  In particular, a Unix-domain socket
    connection is chosen if the host part is either empty or starts with a
    slash, otherwise a TCP/IP connection is initiated.  Note, however, that the
    slash is a reserved character in the hierarchical part of the URI.  So, to
    specify a non-standard Unix-domain socket directory, either omit the host
    specification in the URI and specify the host as a parameter, or
    percent-encode the path in the host component of the URI:
-->
主机部分解释为参数<xref linkend="libpq-connect-host">的描述。特别的，
如果主机部分为空或者以斜线开头，那么选择一个Unix域套接字连接，否则初始化一个TCP/IP连接。
不过要注意，斜线是URI分层部分的一个保留字符。所以，要指定一个非标准Unix域套接字路径，
要么在URI中省略主机声明并指定主机为一个参数，要么在URI的主机部分添加百分号：
<programlisting>
postgresql:///dbname?host=/var/lib/postgresql
postgresql://%2Fvar%2Flib%2Fpostgresql/dbname
</programlisting>
   </para>
   </sect3>
  </sect2>

  <sect2 id="libpq-paramkeywords">
   <!--
   <title>Parameter Key Words</title>
   -->
   <title>参数关键字</title>

   
<para>
<!-- 
    The currently recognized parameter key words are:
-->
目前可识别的参数键字是：
    <variablelist>
     <varlistentry id="libpq-connect-host" xreflabel="host">
      <term><literal>host</literal></term>
      <listitem>
<!--
       <para>
        Name of host to connect to.<indexterm><primary>host name</></>
        If this begins with a slash, it specifies Unix-domain
        communication rather than TCP/IP communication; the value is the
        name of the directory in which the socket file is stored.  The
        default behavior when <literal>host</literal> is not specified
        is to connect to a Unix-domain
        socket<indexterm><primary>Unix domain socket</></> in
        <filename>/tmp</filename> (or whatever socket directory was specified
        when <productname>PostgreSQL</> was built). On machines without
        Unix-domain sockets, the default is to connect to <literal>localhost</>.
       </para>
-->
<para>
要联接的主机名。<indexterm><primary>主机名</></>如果主机名以斜杠开头，
则它声明使用 Unix 域套接字通讯而不是 TCP/IP 通讯；该值就是套接字文件所存储的目录。
如果没有声明<literal>host</literal>，那么缺省时是与位于<filename>/tmp</filename>目录
（或者制作<productname>PostgreSQL</>的时候声明的套接字目录）里面的 Unix-域套接字连接。
<indexterm><primary>Unix 域套接字</></>
在没有 Unix 域套接字的机器上，缺省是与<literal>localhost</>连接。
</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-hostaddr" xreflabel="hostaddr">
      <term><literal>hostaddr</literal></term>
      <listitem>
       <!--
<para>
        Numeric IP address of host to connect to.  This should be in the
        standard IPv4 address format, e.g., <literal>172.28.40.9</>.  If
        your machine supports IPv6, you can also use those addresses.
        TCP/IP communication is
        always used when a nonempty string is specified for this parameter.
       </para>
-->
<para>
与之连接的主机的 IP 地址。这个应该是标准的IPv4 地址格式，比如，<literal>172.28.40.9</>。
如果你的机器支持 IPv6，那么你也可以使用 IPv6 的地址。如果声明了一个非空的字符串，
那么使用 TCP/IP 通讯机制。
</para>

       
<para>
<!-- 
        Using <literal>hostaddr</> instead of <literal>host</> allows the
        application to avoid a host name look-up, which might be important
        in applications with time constraints. However, a host name is
        required for GSSAPI or SSPI authentication
        methods, as well as for <literal>verify-full</> SSL
        certificate verification.  The following rules are used: 
-->
使用<literal>hostaddr</>取代<literal>host</>可以让应用避免一次主机名查找，
这一点对于那些有时间约束的应用来说可能是非常重要的。不过，GSSAPI
或SSPI认证方法和<literal>verify-full</> SSL证书验证要求主机（host）名。
因此，应用下面的规则：
        <itemizedlist>
         <listitem>
<!--
          <para>
           If <literal>host</> is specified without <literal>hostaddr</>,
           a host name lookup occurs.
          </para>
-->
<para>
如果声明了不带<literal>hostaddr</>的<literal>host</>那么就强制进行主机名查找。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           If <literal>hostaddr</> is specified without <literal>host</>,
           the value for <literal>hostaddr</> gives the server network address.
           The connection attempt will fail if the authentication
           method requires a host name.
          </para>
-->
<para>
如果声明中没有<literal>host</>，<literal>hostaddr</>的值给出服务器网络地址；
如果认证方法要求主机名，那么连接尝试将失败。
</para>
         </listitem>
         <listitem>
          <!--
<para>
           If both <literal>host</> and <literal>hostaddr</> are specified,
           the value for <literal>hostaddr</> gives the server network address.
           The value for <literal>host</> is ignored unless the
           authentication method requires it, in which case it will be
           used as the host name.
          </para>
-->
<para>
如果同时声明了<literal>host</>和<literal>hostaddr</>，那么<literal>hostaddr</>
的值作为服务器网络地址。<literal>host</>的值将被忽略，除非认证方法需要它，
在这种情况下它将被用作主机名。
</para>
         </listitem>
        </itemizedlist>
<!-- 
        Note that authentication is likely to fail if <literal>host</>
        is not the name of the server at network address <literal>hostaddr</>.
        Also, note that <literal>host</> rather than <literal>hostaddr</>
        is used to identify the connection in <filename>~/.pgpass</> (see
        <xref linkend="libpq-pgpass">). 
-->
要注意如果<literal>host</>不是网络地址<literal>hostaddr</>处的服务器名，
那么认证很有可能失败。同样，在<filename>~/.pgpass</>（参阅<xref linkend="libpq-pgpass">）
中是使用<literal>host</>而不是<literal>hostaddr</>来标识连接。
       </para>

       <!--
<para>
        Without either a host name or host address,
        <application>libpq</application> will connect using a
        local Unix-domain socket; or on machines without Unix-domain
        sockets, it will attempt to connect to <literal>localhost</>.
       </para>
-->
<para>
如果主机名（host）和主机地址都没有，那么<application>libpq</application>
将使用一个本地的 Unix 域套接字进行连接；或者是在没有 Unix 域套接字的机器上，
它将尝试与<literal>localhost</>连接。
</para>
       </listitem>
      </varlistentry>

      <varlistentry id="libpq-connect-port" xreflabel="port">
       <term><literal>port</literal></term>
       <listitem>
       <!--
<para>
        Port number to connect to at the server host, or socket file
        name extension for Unix-domain
        connections.<indexterm><primary>port</></>
       </para>
-->
<para>
主机服务器的端口号，或者在 Unix 域套接字联接时的套接字扩展文件名。<indexterm><primary>port</></>
</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-dbname" xreflabel="dbname">
      <term><literal>dbname</literal></term>
      <listitem>
      <!--
<para>
       The database name.  Defaults to be the same as the user name.
       In certain contexts, the value is checked for extended
       formats; see <xref linkend="libpq-connstring"> for more details on
       those.
      </para>
-->
<para>
数据库名。缺省和用户名相同。在某些情况下，为扩展的格式检查值；
参阅<xref linkend="libpq-connstring">获取更多信息。
</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-user" xreflabel="user">
      <term><literal>user</literal></term>
      <listitem>
      <!--
<para>
       <productname>PostgreSQL</productname> user name to connect as.
       Defaults to be the same as the operating system name of the user
       running the application.
      </para>
-->
<para>
要连接的<productname>PostgreSQL</productname>用户名。
缺省是与运行该应用的用户操作系统名同名的用户。
</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-password" xreflabel="password">
      <term><literal>password</literal></term>
      <listitem>
      <!--
<para>
       Password to be used if the server demands password authentication.
      </para>
-->
<para>
如果服务器要求口令认证，所用的口令。
</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-connect-timeout" xreflabel="connect_timeout">
      <term><literal>connect_timeout</literal></term>
      <listitem>
      <!--
<para>
       Maximum wait for connection, in seconds (write as a decimal integer
       string). Zero or not specified means wait indefinitely.  It is not
       recommended to use a timeout of less than 2 seconds.
      </para>
-->
<para>
连接的最大等待时间，以秒计（用十进制整数字串书写）。零或者不声明表示无穷。
我们不建议把连接超时的值设置得小于 2 秒。
</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-client-encoding" xreflabel="client_encoding">
      <term><literal>client_encoding</literal></term>
      <listitem>
      <!--
<para>
       This sets the <varname>client_encoding</varname>
       configuration parameter for this connection.  In addition to
       the values accepted by the corresponding server option, you
       can use <literal>auto</literal> to determine the right
       encoding from the current locale in the client
       (<envar>LC_CTYPE</envar> environment variable on Unix
       systems).
      </para>
-->
<para>
为这个连接设置<varname>client_encoding</varname>配置参数。
除了对应的服务器选项接受的值，你可以使用<literal>auto</literal>
从客户端中的当前环境中确定正确的编码（Unix系统上是
<envar>LC_CTYPE</envar>环境变量）。
</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-options" xreflabel="options">
      <term><literal>options</literal></term>
      <listitem>
       <!--
<para>
        Adds command-line options to send to the server at run-time.
        For example, setting this to <literal>-c geqo=off</> sets the
        session's value of the <varname>geqo</> parameter to
        <literal>off</>.  For a detailed discussion of the available
        options, consult <xref linkend="runtime-config">.
       </para>
-->
<para>
添加命令行选项以在运行时发送到服务器。例如，设置为<literal>-c geqo=off</>
设置<varname>geqo</>参数的会话的值为<literal>off</>。关于可用选项的详细讨论，
请查阅<xref linkend="runtime-config">。
</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-application-name" xreflabel="application_name">
      <term><literal>application_name</literal></term>
      <listitem>
       <!--
<para>
        Specifies a value for the <xref linkend="guc-application-name">
        configuration parameter.
       </para>
-->
<para>
为<xref linkend="guc-application-name">配置参数指定一个值。
</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-fallback-application-name" xreflabel="fallback_application_name">
      <term><literal>fallback_application_name</literal></term>
      <listitem>
       <!--
<para>
        Specifies a fallback value for the <xref
        linkend="guc-application-name"> configuration parameter.
        This value will be used if no value has been given for
        <literal>application_name</> via a connection parameter or the
        <envar>PGAPPNAME</envar> environment variable.  Specifying
        a fallback name is useful in generic utility programs that
        wish to set a default application name but allow it to be
        overridden by the user.
       </para>
-->
<para>
为<xref linkend="guc-application-name">配置参数指定一个回退值。
如果没有通过连接参数或<envar>PGAPPNAME</envar>环境变量给定
<literal>application_name</>值，那么将使用这个值。
在想要设置缺省应用名但是允许用户重写的通用实用程序中指定一个回退名是有用的。
</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-keepalives" xreflabel="keepalives">
      <term><literal>keepalives</literal></term>
      <listitem>
       <!--
<para>
        Controls whether client-side TCP keepalives are used. The default
        value is 1, meaning on, but you can change this to 0, meaning off,
        if keepalives are not wanted.  This parameter is ignored for
        connections made via a Unix-domain socket.
       </para>
-->
<para>
控制客户端侧的TCP保持激活是否使用。缺省值是1，意思为打开，但是如果不想要保持激活，
你可以更改为0，意思为关闭。通过Unix域套接字做的连接忽略这个参数。
</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-keepalives-idle" xreflabel="keepalives_idle">
      <term><literal>keepalives_idle</literal></term>
      <listitem>
       <!--
<para>
        Controls the number of seconds of inactivity after which TCP should
        send a keepalive message to the server.  A value of zero uses the
        system default. This parameter is ignored for connections made via a
        Unix-domain socket, or if keepalives are disabled. It is only supported
        on systems where the <symbol>TCP_KEEPIDLE</> or <symbol>TCP_KEEPALIVE</>
        socket option is available, and on Windows; on other systems, it has no
        effect.
       </para>
-->
<para>
在TCP应该发送一个保持激活的信息给服务器之后，控制不活动的秒数。
0值表示使用系统缺省。通过Unix域套接字做的连接或者如果禁用了保持激活则忽略这个参数。
只有在<symbol>TCP_KEEPIDLE</>和<symbol>TCP_KEEPALIVE</>套接字选项可用的系统上支持这个参数，
在Windows上还是在其他系统上是没什么影响的。
</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-keepalives-interval" xreflabel="keepalives_interval">
      <term><literal>keepalives_interval</literal></term>
      <listitem>
       <!--
<para>
        Controls the number of seconds after which a TCP keepalive message
        that is not acknowledged by the server should be retransmitted.  A
        value of zero uses the system default. This parameter is ignored for
        connections made via a Unix-domain socket, or if keepalives are disabled.
        It is only supported on systems where the <symbol>TCP_KEEPINTVL</>
        socket option is available, and on Windows; on other systems, it has no
        effect.
       </para>
-->
<para>
在TCP保持激活信息没有被应该传播的服务器承认之后，控制秒数。0值表示使用系统缺省。
通过Unix域套接字做的连接或者如果禁用了保持激活则忽略这个参数。
只有在<symbol>TCP_KEEPINTVL</>套接字选项可用的系统上支持这个参数，
在Windows上还是在其他系统上是没什么影响的。
</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-keepalives-count" xreflabel="keepalives_count">
      <term><literal>keepalives_count</literal></term>
      <listitem>
       <!--
<para>
        Controls the number of TCP keepalives that can be lost before the
        client's connection to the server is considered dead.  A value of
        zero uses the system default. This parameter is ignored for
        connections made via a Unix-domain socket, or if keepalives are disabled.
        It is only supported on systems where the <symbol>TCP_KEEPCNT</>
        socket option is available; on other systems, it has no effect.
       </para>
-->
<para>
在认为客户端到服务器的连接死亡之前，控制可以丢失的TCP保持激活的数量。0值表示使用系统缺省。
通过Unix域套接字做的连接或者如果禁用了保持激活则忽略这个参数。
只有在<symbol>TCP_KEEPINTVL</>套接字选项可用的系统上支持这个参数，
在Windows上还是在其他系统上是没什么影响的。
</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-tty" xreflabel="tty">
      <term><literal>tty</literal></term>
      <listitem>
      <!--
<para>
       Ignored (formerly, this specified where to send server debug output).
      </para>
-->
<para>
忽略（以前，这个选项声明服务器日志的输出方向）。
</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslmode" xreflabel="sslmode">
      <term><literal>sslmode</literal></term>
      <listitem>
       
<para>
<!-- 
        This option determines whether or with what priority a secure
        <acronym>SSL</> TCP/IP connection will be negotiated with the
        server. There are six modes:
-->
这个选项决定是否需要和服务器协商一个<acronym>SSL</> TCP/IP连接，
以及以什么样的安全优先级与服务器进行<acronym>SSL</> TCP/IP连接。
这里有六个模式：
        <variablelist>
         <varlistentry>
          <term><literal>disable</literal></term>
          <listitem>
<!--
           <para>
            only try a non-<acronym>SSL</> connection
           </para>
-->
<para>
只进行一个非<acronym>SSL</>连接
</para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>allow</literal></term>
          <listitem>
           <!--
<para>
            first try a non-<acronym>SSL</> connection; if that
            fails, try an <acronym>SSL</> connection
           </para>
-->
<para>
首先尝试一个非<acronym>SSL</>连接；如果失败，尝试一个<acronym>SSL</>连接
</para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>prefer</literal> (default)</term>
          <listitem>
           <!--
<para>
            first try an <acronym>SSL</> connection; if that fails,
            try a non-<acronym>SSL</> connection
           </para>
-->
<para>
首先尝试<acronym>SSL</>连接；如果失败，尝试一个非<acronym>SSL</>连接
</para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>require</literal></term>
          <listitem>
           <!--
<para>
            only try an <acronym>SSL</> connection. If a root CA
            file is present, verify the certificate in the same way as
            if <literal>verify-ca</literal> was specified
           </para>
-->
<para>
尝试一个<acronym>SSL</>连接。如果有根CA文件，则按照指定了<literal>verify-ca</literal>
的相同方式验证该证书
</para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>verify-ca</literal></term>
          <listitem>
           <!--
<para>
            only try an <acronym>SSL</> connection, and verify that
            the server certificate is issued by a trusted
            certificate authority (<acronym>CA</>)
           </para>
-->
<para>
只尝试一个<acronym>SSL</>连接，并核实服务器证书是由一个受信任的认证中心(<acronym>CA</>)发布的
</para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>verify-full</literal></term>
          <listitem>
           <!--
<para>
            only try an <acronym>SSL</> connection, verify that the
            server certificate is issued by a
            trusted <acronym>CA</> and that the server host name
            matches that in the certificate
           </para>
-->
<para>
只尝试一个<acronym>SSL</>连接，核实服务器证书是由受信任的<acronym>CA</>发布的，
并且该服务器主机名匹配证书中的服务器主机名。
</para>
          </listitem>
         </varlistentry>
        </variablelist>

<!-- 
        See <xref linkend="libpq-ssl"> for a detailed description of how
        these options work.
-->
参阅<xref linkend="libpq-ssl">获取这些选项工作的详细描述。
       </para>

       <!--
<para>
        <literal>sslmode</> is ignored for Unix domain socket
        communication.
        If <productname>PostgreSQL</> is compiled without SSL support,
        using options <literal>require</>, <literal>verify-ca</>, or
        <literal>verify-full</> will cause an error, while
        options <literal>allow</> and <literal>prefer</> will be
        accepted but <application>libpq</> will not actually attempt
        an <acronym>SSL</>
        connection.<indexterm><primary>SSL</><secondary
        sortas="libpq">with libpq</></indexterm>
       </para>
-->
<para>
Unix域套接字通信忽略<literal>sslmode</>。如果<productname>PostgreSQL</>
编译时没有打开 SSL 支持，那么使用选项<literal>require</>、<literal>verify-ca</>或
<literal>verify-full</>将导致一个错误，而选项<literal>allow</>和<literal>prefer</>
将被接受，但是<application>libpq</>实际上不会企图进行<acronym>SSL</>连接。
<indexterm><primary>SSL</><secondary sortas="libpq">with libpq</></indexterm>
</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-requiressl" xreflabel="requiressl">
      <term><literal>requiressl</literal></term>
      <listitem>
       <!--
<para>
        This option is deprecated in favor of the <literal>sslmode</>
        setting.
       </para>
-->
<para>
这个选项因为有了<literal>sslmode</>设置之后已经废弃了。
</para>

       <!--
<para>
        If set to 1, an <acronym>SSL</acronym> connection to the server
        is required (this is equivalent to <literal>sslmode</>
        <literal>require</>).  <application>libpq</> will then refuse
        to connect if the server does not accept an
        <acronym>SSL</acronym> connection.  If set to 0 (default),
        <application>libpq</> will negotiate the connection type with
        the server (equivalent to <literal>sslmode</>
        <literal>prefer</>).  This option is only available if
        <productname>PostgreSQL</> is compiled with SSL support.
       </para>
-->
<para>
如果设为1，则要求与服务器进行<acronym>SSL</acronym>联接（等效于<literal>sslmode</> 
<literal>require</>）。如果服务器不支持<acronym>SSL</acronym>，那么<application>libpq</>
将马上拒绝联接。设置为0（缺省），与服务器进行协商连接类型（等效于<literal>sslmode</> 
<literal>prefer</>）。这个选项只有在编译<productname>PostgreSQL</>时打开了 SSL 支持才有效。
</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslcompression" xreflabel="sslcompression">
      <term><literal>sslcompression</literal></term>
      <listitem>
       <!--
<para>
        If set to 1 (default), data sent over SSL connections will be
        compressed (this requires <productname>OpenSSL</> version
        0.9.8 or later).
        If set to 0, compression will be disabled (this requires
        <productname>OpenSSL</> 1.0.0 or later).
        This parameter is ignored if a connection without SSL is made,
        or if the version of <productname>OpenSSL</> used does not support
        it.
       </para>
-->
<para>
如果设置为1（缺省），通过SSL连接进行的数据发送将被压缩（这要求<productname>OpenSSL</>
版本0.9.8或更高）。如果设置为0，将禁用压缩（这需要<productname>OpenSSL</> 1.0.0或更高）。
如果连接没有通过SSL进行，或者如果使用的<productname>OpenSSL</>版本不支持它，则忽略该参数。
</para>
       <!--
<para>
        Compression uses CPU time, but can improve throughput if
        the network is the bottleneck.
        Disabling compression can improve response time and throughput
        if CPU performance is the limiting factor.
       </para>
-->
<para>
压缩使用CPU时间，但是如果网络是瓶颈，那么可以提高吞吐量。
如果CPU性能是限制因素，那么禁用压缩可以提高响应时间和吞吐量。
</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslcert" xreflabel="sslcert">
      <term><literal>sslcert</literal></term>
      <listitem>
       <!--
<para>
        This parameter specifies the file name of the client SSL
        certificate, replacing the default
        <filename>~/.postgresql/postgresql.crt</>.
        This parameter is ignored if an SSL connection is not made.
       </para>
-->
<para>
这个参数指定客户端SSL认证的文件名，替换缺省的<filename>~/.postgresql/postgresql.crt</>。
如果没有做SSL连接，则忽略这个参数。
</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslkey" xreflabel="sslkey">
      <term><literal>sslkey</literal></term>
      <listitem>
       <!--
<para>
        This parameter specifies the location for the secret key used for
        the client certificate. It can either specify a file name that will
        be used instead of the default
        <filename>~/.postgresql/postgresql.key</>, or it can specify a key
        obtained from an external <quote>engine</> (engines are
        <productname>OpenSSL</> loadable modules).  An external engine
        specification should consist of a colon-separated engine name and
        an engine-specific key identifier.  This parameter is ignored if an
        SSL connection is not made.
       </para>
-->
<para>
这个参数指定客户端使用的秘钥的位置。也可以指定一个用来替换缺省
<filename>~/.postgresql/postgresql.key</>的文件名，或者指定一个从外部
<quote>引擎</>获取的键（引擎是<productname>OpenSSL</>可加载模块）。
一个外部引擎声明应该包括一个由冒号分隔的引擎名字和特定于引擎的键标识符。
如果没有做SSL连接则忽略这个参数。
</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslrootcert" xreflabel="sslrootcert">
      <term><literal>sslrootcert</literal></term>
      <listitem>
       <!--
<para>
        This parameter specifies the name of a file containing SSL
        certificate authority (<acronym>CA</>) certificate(s).
        If the file exists, the server's certificate will be verified
        to be signed by one of these authorities.  The default is
        <filename>~/.postgresql/root.crt</>.
       </para>
-->
<para>
这个参数声明一个包含SSL认证授权(<acronym>CA</>)证书的文件名。
如果该文件存在，那么将要验证的服务器的证书将由这些授权之一签署。
缺省是<filename>~/.postgresql/root.crt</>。
</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslcrl" xreflabel="sslcrl">
      <term><literal>sslcrl</literal></term>
      <listitem>
       <!--
<para>
        This parameter specifies the file name of the SSL certificate
        revocation list (CRL).  Certificates listed in this file, if it
        exists, will be rejected while attempting to authenticate the
        server's certificate.  The default is
        <filename>~/.postgresql/root.crl</>.
       </para>
-->
<para>
这个参数声明SSL证书撤销列表(CRL)的文件名。在这个文件中列出的证书，
如果该文件存在，将在尝试认证服务器的证书时被拒绝。缺省是
<filename>~/.postgresql/root.crl</>。
</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-requirepeer" xreflabel="requirepeer">
      <term><literal>requirepeer</literal></term>
      <listitem>
       <!--
<para>
        This parameter specifies the operating-system user name of the
        server, for example <literal>requirepeer=postgres</literal>.
        When making a Unix-domain socket connection, if this
        parameter is set, the client checks at the beginning of the
        connection that the server process is running under the specified
        user name; if it is not, the connection is aborted with an error.
        This parameter can be used to provide server authentication similar
        to that available with SSL certificates on TCP/IP connections.
        (Note that if the Unix-domain socket is in
        <filename>/tmp</filename> or another publicly writable location,
        any user could start a server listening there.  Use this parameter
        to ensure that you are connected to a server run by a trusted user.)
        This option is only supported on platforms for which the
        <literal>peer</> authentication method is implemented; see
        <xref linkend="auth-peer">.
       </para>
-->
<para>
这个参数声明服务器的操作系统用户名，例如<literal>requirepeer=postgres</literal>。
当制作一个Unix域套接字连接时，如果设置了该参数，那么在连接的开始，
客户端检查服务器进程是否运行在指定的用户名之下；如果不是，则连接带有错误退出。
这个参数可以用来提供服务器认证，类似于在TCP/IP连接上可用SSL证书。
（请注意，如果Unix域套接字在<filename>/tmp</filename>中或另一个公开可写位置，
那么任意用户都可以在这里启动一个服务器监听。
使用这个参数确保你连接到一个受信任的用户运行的服务器。）
这个选项只有在实现了<literal>peer</>认证方法的平台上支持；参阅
<xref linkend="auth-peer">。
</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-krbsrvname" xreflabel="krbsrvname">
      <term><literal>krbsrvname</literal></term>
      <listitem>
       <!--
<para>
        Kerberos service name to use when authenticating with GSSAPI.
        This must match the service name specified in the server
        configuration for Kerberos authentication to succeed. (See also
        <xref linkend="gssapi-auth">.)
       </para>
-->
<para>
使用GSSAPI认证时使用的Kerberos服务名。
这个名字必须和服务器给Kerberos认证配置的服务名相同，才能认证成功。
（又见<xref linkend="gssapi-auth">。）
</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-gsslib" xreflabel="gsslib">
      <term><literal>gsslib</literal></term>
      <listitem>
       <!--
<para>
        GSS library to use for GSSAPI authentication. Only used on Windows.
        Set to <literal>gssapi</literal> to force libpq to use the GSSAPI
        library for authentication instead of the default SSPI.
       </para>
-->
<para>
为GSSAPI认证使用的GSS库。只在Windows上使用。设置为<literal>gssapi</literal>
强迫libpq为认证使用GSSAPI库而不是缺省的SSPI。
</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-service" xreflabel="service">
      <term><literal>service</literal></term>
      <listitem>
       <!--
<para>
        Service name to use for additional parameters.  It specifies a service
        name in <filename>pg_service.conf</filename> that holds additional connection parameters.
        This allows applications to specify only a service name so connection parameters
        can be centrally maintained. See <xref linkend="libpq-pgservice">.
       </para>
-->
<para>
用于额外参数的服务名。它在<filename>pg_service.conf</filename>里面声明一个服务名，
这个配置文件保存额外的连接参数。这样就允许应用只声明一个服务名，
而连接参数就可以在一个地方维护了。参阅<xref linkend="libpq-pgservice">。
</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>
 </sect1>

 <sect1 id="libpq-status">
  <!--
  <title>Connection Status Functions</title>
  -->
  <title>连接状态函数</title>

  <!--
<para>
   These functions can be used to interrogate the status
   of an existing database connection object.
  </para>
-->
<para>
这些函数可以用于询问现存数据库连接对象的状态。
</para>

  <tip>
   <!--
<para>
    <indexterm><primary>libpq-fe.h</></>
    <indexterm><primary>libpq-int.h</></>
    <application>libpq</application> application programmers should be careful to
    maintain the <structname>PGconn</structname> abstraction.  Use the accessor
    functions described below to get at the contents of <structname>PGconn</structname>.
    Reference to internal <structname>PGconn</structname> fields using
    <filename>libpq-int.h</> is not recommended because they are subject to change
    in the future.
   </para>
-->
<para>
<indexterm><primary>libpq-fe.h</></>
<indexterm><primary>libpq-int.h</></>
<application>libpq</application>应用程序员应该仔细维护<structname>PGconn</structname>结构。
使用下面的访问函数来获取<structname>PGconn</structname>的内容。不建议使用<filename>libpq-int.h</>
引用<structname>PGconn</structname>内部的字段，因为这些字段在今后可能被改变。
</para>
  </tip>

  
<para>
<!-- 
   The following functions return parameter values established at connection.
   These values are fixed for the life of the <structname>PGconn</> object.
-->
下面的函数返回连接建立时的参数值。这些参数在<structname>PGconn</>对象的生命期期间是固定的。
   <variablelist>
    <varlistentry id="libpq-pqdb">
     <term>
      <function>PQdb</function>
      <indexterm>
       <primary>PQdb</primary>
      </indexterm>
     </term>

     <listitem>

      <para>
<!-- 
      Returns the database name of the connection.
-->
返回连接的数据库名。
<synopsis>
char *PQdb(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pquser">
     <term>
      <function>PQuser</function>
      <indexterm>
       <primary>PQuser</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       Returns the user name of the connection.
-->
返回连接的用户名。
<synopsis>
char *PQuser(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqpass">
     <term>
      <function>PQpass</function>
      <indexterm>
       <primary>PQpass</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       Returns the password of the connection.
-->
返回连接的口令。
<synopsis>
char *PQpass(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqhost">
     <term>
      <function>PQhost</function>
      <indexterm>
       <primary>PQhost</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       Returns the server host name of the connection.
-->
返回连接的服务器主机名。
<synopsis>
char *PQhost(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqport">
     <term>
      <function>PQport</function>
      <indexterm>
       <primary>PQport</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       Returns the port of the connection.
-->
返回连接的端口号。
<synopsis>
char *PQport(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqtty">
     <term>
      <function>PQtty</function>
      <indexterm>
       <primary>PQtty</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       Returns the debug <acronym>TTY</acronym> of the connection.
       (This is obsolete, since the server no longer pays attention
       to the <acronym>TTY</acronym> setting, but the function remains
       for backward compatibility.)
-->
返回连接的调试控制台<acronym>TTY</acronym>。（这个已经过时了，
因为服务器不再注意<acronym>TTY</acronym>设置，这个函数的存在是为了向下兼容。）
<synopsis>
char *PQtty(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqoptions">
     <term>
      <function>PQoptions</function>
      <indexterm>
       <primary>PQoptions</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       Returns the command-line options passed in the connection request.
-->
返回连接请求中传递的命令行选项。
<synopsis>
char *PQoptions(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  
<para>
<!--
   The following functions return status data that can change as operations
   are executed on the <structname>PGconn</> object.
-->
下面的函数返回那些在对<structname>PGconn</>对象进行操作的过程中可能变化的状态数据。
   <variablelist>
    <varlistentry id="libpq-pqstatus">
     <term>
      <function>PQstatus</function>
      <indexterm>
       <primary>PQstatus</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       <!-- 
   Returns the status of the connection. 
   -->
返回连接的状态。   
<synopsis>
ConnStatusType PQstatus(const PGconn *conn);
</synopsis>
      </para>

      <!--
<para>
       The status can be one of a number of values.  However, only two of
       these are seen outside of an asynchronous connection procedure:
       <literal>CONNECTION_OK</literal> and
       <literal>CONNECTION_BAD</literal>. A good connection to the database
       has the status <literal>CONNECTION_OK</literal>.  A failed
       connection attempt is signaled by status
       <literal>CONNECTION_BAD</literal>.  Ordinarily, an OK status will
       remain so until <function>PQfinish</function>, but a communications
       failure might result in the status changing to
       <literal>CONNECTION_BAD</literal> prematurely.  In that case the
       application could try to recover by calling
       <function>PQreset</function>.
      </para>
-->
<para>
这个状态可以是一系列值之一。不过，我们在一个异步连接过程外面只能看到其中的两个：
<literal>CONNECTION_OK</literal>和<literal>CONNECTION_BAD</literal>。
成功连接到数据库返回状态<literal>CONNECTION_OK</literal>。
失败的连接尝试用状态<literal>CONNECTION_BAD</literal>标识。通常，
一个OK状态将保持到<function>PQfinish</function>，但是一个通讯失败可能会导致状态过早的改变为
<literal>CONNECTION_BAD</literal>。这时应用可以试着调用<function>PQreset</function>来恢复。
</para>

      <!--
<para>
       See the entry for <function>PQconnectStartParams</>, <function>PQconnectStart</>
       and <function>PQconnectPoll</> with regards to other status codes that
       might be returned.
      </para>
-->
<para>
参阅<function>PQconnectStartParams</>、<function>PQconnectStart</>和<function>PQconnectPoll</>
条目看看可能出现的其他状态码。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqtransactionstatus">
     <term>
      <function>PQtransactionStatus</function>
      <indexterm>
       <primary>PQtransactionStatus</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       Returns the current in-transaction status of the server.
-->
返回服务器的当前事务内状态。
<synopsis>
PGTransactionStatusType PQtransactionStatus(const PGconn *conn);
</synopsis>
<!-- 
       The status can be <literal>PQTRANS_IDLE</literal> (currently idle),
       <literal>PQTRANS_ACTIVE</literal> (a command is in progress),
       <literal>PQTRANS_INTRANS</literal> (idle, in a valid transaction block),
       or <literal>PQTRANS_INERROR</literal> (idle, in a failed transaction block).
       <literal>PQTRANS_UNKNOWN</literal> is reported if the connection is bad.
       <literal>PQTRANS_ACTIVE</literal> is reported only when a query
       has been sent to the server and not yet completed. 
-->
状态可以是<literal>PQTRANS_IDLE</literal>（当前空闲），<literal>PQTRANS_ACTIVE</literal>
（正在处理一个命令），<literal>PQTRANS_INTRANS</literal>（空闲，在一个合法的事务块内），
或者<literal>PQTRANS_INERROR</literal>（空闲，在一个失败的事务块内）。如果连接有问题，
则返回<literal>PQTRANS_UNKNOWN</literal>。只有在一个查询发送给了服务器并且还没有完成的时候才返回
<literal>PQTRANS_ACTIVE</literal>。
      </para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqparameterstatus">
     <term>
      <function>PQparameterStatus</function>
      <indexterm>
       <primary>PQparameterStatus</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       Looks up a current parameter setting of the server.
-->
查找服务器的一个当前参数设置。
<synopsis>
const char *PQparameterStatus(const PGconn *conn, const char *paramName);
</synopsis>
<!-- 
       Certain parameter values are reported by the server automatically at
       connection startup or whenever their values change.
       <function>PQparameterStatus</> can be used to interrogate these settings.
       It returns the current value of a parameter if known, or <symbol>NULL</symbol>
       if the parameter is not known.
-->
有些参数值在建立连接或者它们的值改变的时候会由服务器自动报告。
<function>PQparameterStatus</>可以用查询这些设置。如果参数已知，
那么它返回当前值，否则返回<symbol>NULL</symbol>。
      </para>

      <!--
<para>
       Parameters reported as of the current release include
       <varname>server_version</>,
       <varname>server_encoding</>,
       <varname>client_encoding</>,
       <varname>application_name</>,
       <varname>is_superuser</>,
       <varname>session_authorization</>,
       <varname>DateStyle</>,
       <varname>IntervalStyle</>,
       <varname>TimeZone</>,
       <varname>integer_datetimes</>, and
       <varname>standard_conforming_strings</>.
       (<varname>server_encoding</>, <varname>TimeZone</>, and
       <varname>integer_datetimes</> were not reported by releases before 8.0;
       <varname>standard_conforming_strings</> was not reported by releases
       before 8.1;
       <varname>IntervalStyle</> was not reported by releases before 8.4;
       <varname>application_name</> was not reported by releases before 9.0.)
       Note that
       <varname>server_version</>,
       <varname>server_encoding</> and
       <varname>integer_datetimes</>
       cannot change after startup.
      </para>
-->
<para>
当前版本报告的参数有<varname>server_version</>，<varname>server_encoding</>，
<varname>client_encoding</>，<varname>application_name</>，<varname>is_superuser</>，
<varname>session_authorization</>，<varname>DateStyle</>，<varname>IntervalStyle</>，
<varname>TimeZone</>，<varname>integer_datetimes</>和<varname>standard_conforming_strings</>。
（8.0之前的版本不报告<varname>server_encoding</>，<varname>TimeZone</>和
<varname>integer_datetimes</>；8.1之前的版本不报告<varname>standard_conforming_strings</>；
8.4之前的版本不报告<varname>IntervalStyle</>；9.0之前的版本不报告<varname>application_name</>。）
请注意<varname>server_version</>，<varname>server_encoding</>和<varname>integer_datetimes</>
不能再启动后修改。
</para>

      <!--
<para>
       Pre-3.0-protocol servers do not report parameter settings, but
       <application>libpq</> includes logic to obtain values for
       <varname>server_version</> and <varname>client_encoding</> anyway.
       Applications are encouraged to use <function>PQparameterStatus</>
       rather than <foreignphrase>ad hoc</> code to determine these values.
       (Beware however that on a pre-3.0 connection, changing
       <varname>client_encoding</> via <command>SET</> after connection
       startup will not be reflected by <function>PQparameterStatus</>.)
       For <varname>server_version</>, see also
       <function>PQserverVersion</>, which returns the information in a
       numeric form that is much easier to compare against.
      </para>
-->
<para>
协议版本3.0之前的服务器不会报告参数设置，但是<application>libpq</>
里包含一些逻辑用于获取<varname>server_version</>和<varname>client_encoding</>的数值。
我们鼓励应用里面使用<function>PQparameterStatus</>，而不是使用<foreignphrase>ad hoc</>
代码来检测这些值。（不过要注意，在3.0之前的连接协议里，启动后通过<command>SET</>
改变了<varname>client_encoding</>将不会被<function>PQparameterStatus</>反映出来。）
对于<varname>server_version</>，又见<function>PQserverVersion</>，
它返回数值形式，更容易进行比较。
</para>

      <!--
<para>
       If no value for <varname>standard_conforming_strings</> is reported,
       applications can assume it is <literal>off</>, that is, backslashes
       are treated as escapes in string literals.  Also, the presence of
       this parameter can be taken as an indication that the escape string
       syntax (<literal>E'...'</>) is accepted.
      </para>
-->
<para>
如果没有为<varname>standard_conforming_strings</>报告数值，应用可以假设它是<literal>off</>，
也就是说，在字符串文本里，把反斜杠当做转义。同样，如果出现了这个参数，
就可以当作一个指示，表示接受转义字符串(<literal>E'...'</>)的语法。
</para>

      <!--
<para>
       Although the returned pointer is declared <literal>const</>, it in fact
       points to mutable storage associated with the <literal>PGconn</> structure.
       It is unwise to assume the pointer will remain valid across queries.
      </para>
-->
<para>
尽管返回的指针声明为<literal>const</>，它实际上指向一个和<literal>PGconn</>
结构关联的可变存储区。因此假设这个指针跨查询保持有效是不明智的。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqprotocolversion">
     <term>
      <function>PQprotocolVersion</function>
      <indexterm>
       <primary>PQprotocolVersion</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!-- 
       Interrogates the frontend/backend protocol being used. 
-->
查询使用的前/后端协议。
<synopsis>
int PQprotocolVersion(const PGconn *conn);
</synopsis>
<!--
       Applications might wish to use this function to determine whether certain
       features are supported.  Currently, the possible values are 2 (2.0
       protocol), 3 (3.0 protocol), or zero (connection bad).  The
       protocol version will
       not change after connection startup is complete, but it could
       theoretically change during a connection reset.  The 3.0 protocol
       will normally be used when communicating with
       <productname>PostgreSQL</> 7.4 or later servers; pre-7.4 servers
       support only protocol 2.0.  (Protocol 1.0 is obsolete and not
       supported by <application>libpq</application>.)
-->
应用可能希望使用这个函数来判断某些特性是否被支持。目前，可能的数值是2
（2.0协议），3（3.0协议）或0（连接错误）。在连接启动完成之后，这个数值将不会改变，
但是在连接重置的过程中，理论上是可能改变的。在与<productname>PostgreSQL</> 7.4
或更高版本沟通时，通常使用3.0协议；7.4以前的服务器只支持协议2.0。
（协议1.0过时了，不被<application>libpq</application>支持。）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqserverversion">
     <term>
      <function>PQserverVersion</function>
      <indexterm>
       <primary>PQserverVersion</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
 Returns an integer representing the backend version.
--> 
返回一个整数，代表后端版本。 
<synopsis>
int PQserverVersion(const PGconn *conn);
</synopsis>
<!-- 
       Applications might use this function to determine the version of the database
       server they are connected to. The number is formed by converting
       the major, minor, and revision numbers into two-decimal-digit
       numbers and appending them together. For example, version 8.1.5
       will be returned as 80105, and version 8.2 will be returned as
       80200 (leading zeroes are not shown).  Zero is returned if the
       connection is bad. 
-->
应用可以使用这个函数判断它们连接的数据库服务器的版本。数字是通过把主、
次及版本号转换成两位十进制数并且把它们连接在一起组成的。例如，
版本8.1.5将被返回80105，版本8.2将被返回80200（前导零没有显示）。
如果连接失败，则返回零。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqerrormessage">
     <term>
      <function>PQerrorMessage</function>
      <indexterm>
       <primary>PQerrorMessage</primary>
      </indexterm>
     </term>

     <listitem>
<para>
<!--       <indexterm><primary>error message</></> Returns the error message
       most recently generated by an operation on the connection.
-->
<indexterm><primary>错误消息</></>返回连接中操作产生的最近的错误消息。
<synopsis>
char *PQerrorMessage(const PGconn *conn);
</synopsis>

      </para>

      <!--
<para>
       Nearly all <application>libpq</> functions will set a message for
       <function>PQerrorMessage</function> if they fail.  Note that by
       <application>libpq</application> convention, a nonempty
       <function>PQerrorMessage</function> result can consist of multiple lines,
       and will include a trailing newline. The caller should not free
       the result directly. It will be freed when the associated
       <structname>PGconn</> handle is passed to
       <function>PQfinish</function>.  The result string should not be
       expected to remain the same across operations on the
       <literal>PGconn</> structure.
      </para>
-->
<para>
几乎所有<application>libpq</>函数在失败时都会为<function>PQerrorMessage</function>
设置一个信息。注意，<application>libpq</application>的传统是，一个非空的
<function>PQerrorMessage</function>结果会由多行组成，并且将包含一个结尾的新行。
调用者不应该直接释放结果。结果的释放是在将<structname>PGconn</>句柄传递给
<function>PQfinish</function>的时候自动进行的。我们不能假设在不同的<literal>PGconn</>
结构操作中，结果字串都是一样的。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsocket">
     <term><function>PQsocket</function><indexterm><primary>PQsocket</></></term>
     <listitem>
      
<para>
<!--
       Obtains the file descriptor number of the connection socket to
       the server.  A valid descriptor will be greater than or equal
       to 0; a result of -1 indicates that no server connection is
       currently open.  (This will not change during normal operation,
       but could change during connection setup or reset.)
-->
获取与服务器连接的套接字的文件描述符编号。一个有效的描述符应该是大于或等于0；
结果为-1表示当前没有与服务器的连接打开。（在正常的操作中，这个结果不会改变，
但是可能在连接启动或者重置的过程中变化。）
<synopsis>
int PQsocket(const PGconn *conn);
</synopsis>

      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqbackendpid">
     <term><function>PQbackendPID</function><indexterm><primary>PQbackendPID</></></term>
     <listitem>
      
<para>
<!--
       Returns the process <acronym>ID</acronym> (PID)<indexterm>
        <primary>PID</>
        <secondary>determining PID of server process</>
        <tertiary>in libpq</>
       </indexterm>
       of the backend process handling this connection.
-->
返回后端进程处理此连接的进程号<acronym>ID</acronym> (PID)<indexterm>
        <primary>PID</>
        <secondary>确定服务器进程的PID</>
        <tertiary>在libpq中</></indexterm>
<synopsis>
int PQbackendPID(const PGconn *conn);
</synopsis>
      </para>

      <!--
<para>
       The backend <acronym>PID</acronym> is useful for debugging
       purposes and for comparison to <command>NOTIFY</command>
       messages (which include the <acronym>PID</acronym> of the
       notifying backend process).  Note that the
       <acronym>PID</acronym> belongs to a process executing on the
       database server host, not the local host!
      </para>
-->
<para>
这个后端<acronym>PID</acronym>在调试和对比<command>NOTIFY</command>
信息（包括发出通知的后端进程的<acronym>PID</acronym>）时很有用。
注意该<acronym>PID</acronym>属于运行数据库服务器主机的进程，
而不是本地主机！
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconnectionneedspassword">
     <term><function>PQconnectionNeedsPassword</function><indexterm><primary>PQconnectionNeedsPassword</></></term>
     <listitem>
      
<para>
<!--
       Returns true (1) if the connection authentication method
       required a password, but none was available.
       Returns false (0) if not.
-->
如果连接的认证方法需要一个密码则返回true (1)，但是没有可用的。
如果没有则返回false (0)。
<synopsis>
int PQconnectionNeedsPassword(const PGconn *conn);
</synopsis>
      </para>

      <!--
<para>
       This function can be applied after a failed connection attempt
       to decide whether to prompt the user for a password.
      </para>
-->
<para>
此功能可用于连接尝试失败后决定是否提示用户输入密码。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconnectionusedpassword">
     <term><function>PQconnectionUsedPassword</function><indexterm><primary>PQconnectionUsedPassword</></></term>
     <listitem>
      
<para>
<!--
       Returns true (1) if the connection authentication method
       used a password. Returns false (0) if not.
-->
如果连接的认证方法使用密码则返回true (1)。否则返回false (0)。
<synopsis>
int PQconnectionUsedPassword(const PGconn *conn);
</synopsis>
      </para>

      <!--
<para>
       This function can be applied after either a failed or successful
       connection attempt to detect whether the server demanded a password.
      </para>
-->
<para>
此功能可应用于失败或成功连接后尝试检测服务器是否要求密码。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqgetssl">
     <term><function>PQgetssl</function><indexterm><primary>PQgetssl</></></term>
     <listitem>
      
<para>
<!--
       <indexterm><primary>SSL</><secondary sortas="libpq">in libpq</secondary></indexterm>
       Returns the SSL structure used in the connection, or null
       if SSL is not in use.
-->
<indexterm><primary>SSL</><secondary sortas="libpq">在libpq中</secondary></indexterm>
返回连接中使用的SSL结构，或者没有使用SSL则返回null。
<synopsis>
void *PQgetssl(const PGconn *conn);
</synopsis>
      </para>

      <!--
<para>
       This structure can be used to verify encryption levels, check server
       certificates, and more. Refer to the <productname>OpenSSL</>
       documentation for information about this structure.
      </para>
-->
<para>
这个结构可以用于核实加密级别，检查服务器认证等信息。参考<productname>OpenSSL</>
文档获取关于这个结构的更多信息。
</para>
     
<para>
<!--
       The actual return value is of type <type>SSL *</type>,
       where <type>SSL</type> is a type defined by
       the <productname>OpenSSL</productname> library, but it is not declared
       this way to avoid requiring the <productname>OpenSSL</productname>
       header files.  To use this function, code along the following lines
       could be used:
-->
实际返回值的类型是<type>SSL *</type>，而<type>SSL</type>的类型是由
<productname>OpenSSL</productname>库定义的，但是没有用这种方式声明，
以避免请求<productname>OpenSSL</productname>头文件。要使用这个函数，
可以使用下面的代码行：
<programlisting><![CDATA[
#include <libpq-fe.h>
#include <openssl/ssl.h>

...

    SSL *ssl;

    dbconn = PQconnectdb(...);
    ...

    ssl = PQgetssl(dbconn);
    if (ssl)
    {
        /* use OpenSSL functions to access ssl */
    }
]]></programlisting>
      </para>
     </listitem>
    </varlistentry>

   </variablelist>
  </para>

 </sect1>

 <sect1 id="libpq-exec">
  <!--
  <title>Command Execution Functions</title>
  -->
  <title>命令执行函数</title>

  <!--
<para>
   Once a connection to a database server has been successfully
   established, the functions described here are used to perform
   SQL queries and commands.
  </para>
-->
<para>
一旦与数据库服务器的连接成功建立，便可以使用这里描述的函数执行SQL查询和命令。
</para>

  <sect2 id="libpq-exec-main">
   <!--
   <title>Main Functions</title>
   -->
   <title>主函数</title>

   
<para>
    <variablelist>
     <varlistentry id="libpq-pqexec">
      <term>
       <function>PQexec</function>
       <indexterm>
        <primary>PQexec</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
<!-- 
       Submits a command to the server and waits for the result.
-->
给服务器提交一条命令并且等待结果。
<synopsis>
PGresult *PQexec(PGconn *conn, const char *command);
</synopsis>
       </para>

       <!--
<para>
        Returns a <structname>PGresult</structname> pointer or possibly a null
        pointer.  A non-null pointer will generally be returned except in
        out-of-memory conditions or serious errors such as inability to send
        the command to the server.  The <function>PQresultStatus</> function
        should be called to check the return value for any errors (including
        the value of a null pointer, in which case it will return
        <symbol>PGRES_FATAL_ERROR</symbol>).  Use
        <function>PQerrorMessage</function> to get more information about such
        errors.
       </para>
-->
<para>
返回一个<structname>PGresult</structname>指针或者也可能是一个空指针。
通常返回一个非空指针，除非耗尽内存或发生了像不能把命令发送到服务器这样的严重错误。
应该调用<function>PQresultStatus</>函数来检查任何错误的返回值
（包括空指针的值，在这种情况下它将返回<symbol>PGRES_FATAL_ERROR</symbol>）。
使用<function>PQerrorMessage</function>获取有关错误的更多信息。
</para>
      </listitem>
     </varlistentry>
    </variablelist>
<!-- 
    The command string can include multiple SQL commands
    (separated by semicolons).  Multiple queries sent in a single
    <function>PQexec</> call are processed in a single transaction, unless
    there are explicit <command>BEGIN</command>/<command>COMMIT</command>
    commands included in the query string to divide it into multiple
    transactions.  Note however that the returned
    <structname>PGresult</structname> structure describes only the result
    of the last command executed from the string.  Should one of the
    commands fail, processing of the string stops with it and the returned
    <structname>PGresult</structname> describes the error condition. 
-->
命令字符串可以包括多个SQL命令（用分号分隔）。在一个<function>PQexec</>
调用中发送的多个查询是在一个事务里处理的，除非在查询字符串里有明确的
<command>BEGIN</command>/<command>COMMIT</command>命令把整个字符串分隔成多个事务。
请注意，返回的<structname>PGresult</structname>结构只描述字符串里执行的最后一条命令的结果。
如果有一个命令失败，那么字符串处理的过程就会停止，并且返回的<structname>PGresult</structname>
会描述错误条件。
   </para>

   
<para>
    <variablelist>
     <varlistentry id="libpq-pqexecparams">
      <term>
       <function>PQexecParams</function>
       <indexterm>
        <primary>PQexecParams</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
<!--
        Submits a command to the server and waits for the result,
        with the ability to pass parameters separately from the SQL
        command text.
-->
向服务器提交一条命令并且等待结果，还有独立于SQL命令文本传递参数的能力。
<synopsis>
PGresult *PQexecParams(PGconn *conn,
                       const char *command,
                       int nParams,
                       const Oid *paramTypes,
                       const char * const *paramValues,
                       const int *paramLengths,
                       const int *paramFormats,
                       int resultFormat);
</synopsis>
       </para>

       <!--
<para>
        <function>PQexecParams</> is like <function>PQexec</>, but offers additional
        functionality: parameter values can be specified separately from the command
        string proper, and query results can be requested in either text or binary
        format.  <function>PQexecParams</> is supported only in protocol 3.0 and later
        connections; it will fail when using protocol 2.0.
       </para>
-->
<para>
<function>PQexecParams</>类似<function>PQexec</>，但是提供了额外的功能：
参数值可以独立于命令字符串进行声明，并且可以要求查询结果的格式是文本或二进制的。
<function>PQexecParams</>只是在协议3.0及以后的版本中支持；在使用协议2.0的时候会失败。
</para>

       
<para>
<!-- 
        The function arguments are:
 -->
函数的参数是：
        <variablelist>
         <varlistentry>
          <term><parameter>conn</parameter></term>

          <listitem>
<!--
           <para>
            The connection object to send the command through.
           </para>
-->
<para>
连接对象通过它发送命令。
</para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>command</parameter></term>
          <listitem>
           <!--
<para>
            The SQL command string to be executed. If parameters are used,
            they are referred to in the command string as <literal>$1</>,
            <literal>$2</>, etc.
           </para>
-->
<para>
要执行的SQL命令字符串。如果使用参数，它们在命令字符串中被叫做<literal>$1</>、
<literal>$2</>等等。
</para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>nParams</parameter></term>
          <listitem>
           <!--
<para>
            The number of parameters supplied; it is the length of the arrays
            <parameter>paramTypes[]</>, <parameter>paramValues[]</>,
            <parameter>paramLengths[]</>, and <parameter>paramFormats[]</>. (The
            array pointers can be <symbol>NULL</symbol> when <parameter>nParams</>
            is zero.)
           </para>
-->
<para>
提供的参数数目；它是<parameter>paramTypes[]</>、<parameter>paramValues[]</>、
<parameter>paramLengths[]</>和<parameter>paramFormats[]</>数组的长度。
（当<parameter>nParams</>是0时，数组指针可以是<symbol>NULL</symbol>。）
</para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>paramTypes[]</parameter></term>
          <listitem>
           <!--
<para>
            Specifies, by OID, the data types to be assigned to the
            parameter symbols.  If <parameter>paramTypes</> is
            <symbol>NULL</symbol>, or any particular element in the array
            is zero, the server infers a data type for the parameter symbol
            in the same way it would do for an untyped literal string.
           </para>
-->
<para>
通过OID，将声明数据类型指定到参数标记。如果<parameter>paramTypes</>
是<symbol>NULL</symbol>，或数组中任何的特定参数是0，服务器为参数标记推断数据类型，
采用的方式与一个未定义类型的文本字符串相同。
</para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>paramValues[]</parameter></term>
          <listitem>
           <!--
<para>
            Specifies the actual values of the parameters.  A null pointer
            in this array means the corresponding parameter is null;
            otherwise the pointer points to a zero-terminated text string
            (for text format) or binary data in the format expected by the
            server (for binary format).
           </para>
-->
<para>
声明参数的实际值。在这个数组中的一个空指针表示相应的参数是空；
否则指针指向一个以零结尾的文本字符串（文本格式）或者服务器希望的格式的二进制数据
（二进制格式）。
</para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>paramLengths[]</parameter></term>
          <listitem>
           <!--
<para>
            Specifies the actual data lengths of binary-format parameters.
            It is ignored for null parameters and text-format parameters.
            The array pointer can be null when there are no binary parameters.
           </para>
-->
<para>
为二进制格式的参数声明实际数据长度。该设置忽略空参数或文本格式的参数。
如果没有二进制参数，那么数组指针可以为空。
</para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>paramFormats[]</parameter></term>
          <listitem>
           <!--
<para>
            Specifies whether parameters are text (put a zero in the
            array entry for the corresponding parameter) or binary (put
            a one in the array entry for the corresponding parameter).
            If the array pointer is null then all parameters are presumed
            to be text strings.
           </para>
-->
<para>
声明参数为文本（为相应参数在数组条目中放置一个0）还是二进制格式
（为相应参数在数组条目中放置一个1）。如果数组指针是空，那么所有参数被看做是文本字符串。
</para>
           <!--
<para>
            Values passed in binary format require knowledge of
            the internal representation expected by the backend.
            For example, integers must be passed in network byte
            order.  Passing <type>numeric</> values requires
            knowledge of the server storage format, as implemented
            in
            <filename>src/backend/utils/adt/numeric.c::numeric_send()</> and
            <filename>src/backend/utils/adt/numeric.c::numeric_recv()</>.
           </para>
-->
<para>
以二进制格式传递的值需要能够被后台识别的内部表示。例如，整数必须以网络字节顺序来传递。
传递<type>numeric</>值需要服务器存储格式的识别，如在
<filename>src/backend/utils/adt/numeric.c::numeric_send()</>和
<filename>src/backend/utils/adt/numeric.c::numeric_recv()</>中那样。
</para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>resultFormat</parameter></term>
          <listitem>
           <!--
<para>
            Specify zero to obtain results in text format, or one to obtain
            results in binary format.  (There is not currently a provision
            to obtain different result columns in different formats,
            although that is possible in the underlying protocol.)
           </para>
-->
<para>
声明0用于以文本格式获得结果，或1用于以二进制格式获得结果。
（目前没有规定以不同的格式来获取不同的结果列，即使底层协议中可能实现。）
</para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <!--
<para>
    The primary advantage of <function>PQexecParams</> over
    <function>PQexec</> is that parameter values can be separated from the
    command string, thus avoiding the need for tedious and error-prone
    quoting and escaping.
   </para>
-->
<para>
<function>PQexecParams</>相比<function>PQexec</>的主要优势是参数值可以从命令字符串中分离出来，
因此避免了繁琐和容易出错的引用和转义的需要。
</para>

   <!--
<para>
    Unlike <function>PQexec</>, <function>PQexecParams</> allows at most
    one SQL command in the given string.  (There can be semicolons in it,
    but not more than one nonempty command.)  This is a limitation of the
    underlying protocol, but has some usefulness as an extra defense against
    SQL-injection attacks.
   </para>
-->
<para>
和<function>PQexec</>不同的是，<function>PQexecParams</>在一个给出的字符串里最多允许一个SQL命令。
（里面可以有分号，但是不得超过一个非空的命令。）这是下层协议的一个限制，
但是也有些好处，比如作为对SQL注入攻击的额外防御。
</para>

   <tip>    
<para>
<!--
     Specifying parameter types via OIDs is tedious, particularly if you prefer
     not to hard-wire particular OID values into your program.  However, you can
     avoid doing so even in cases where the server by itself cannot determine the
     type of the parameter, or chooses a different type than you want.  In the
     SQL command text, attach an explicit cast to the parameter symbol to show what
     data type you will send.  For example:
-->
通过OID声明参数类型是非常繁琐的，尤其是你不希望在你的程序里写死特定的OID值的时候。
不过，你可以避免这么做，即使在服务器自己无法判断参数类型，
或者是选择了一种与你预期不同的参数类型的时候也一样。在SQL命令文本里，
给参数符号附加一个明确的类型转换，显示你准备发送的数据类型。比如：
<programlisting>
SELECT * FROM mytable WHERE x = $1::bigint;
</programlisting>
<!-- 
     This forces parameter <literal>$1</> to be treated as <type>bigint</>, whereas
     by default it would be assigned the same type as <literal>x</>.  Forcing the
     parameter type decision, either this way or by specifying a numeric type OID,
     is strongly recommended when sending parameter values in binary format, because
     binary format has less redundancy than text format and so there is less chance
     that the server will detect a type mismatch mistake for you. 
-->
这样强制参数<literal>$1</>当作<type>bigint</>看待，即使缺省情况下它会被赋予和
<literal>x</>一样的类型。在以二进制格式发送参数值的时候，
我们强烈建议通过这种方法或者是声明数字类型OID的方法强制类型判断，
因为二进制格式比文本格式少一些冗余，因此服务器就会少一些机会捕捉类型的错误匹配。
    </para>
   </tip>

   
<para>
    <variablelist>
     <varlistentry id="libpq-pqprepare">
      <term><function>PQprepare</function>
       <indexterm>
        <primary>PQprepare</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
<!--
        Submits a request to create a prepared statement with the
        given parameters, and waits for completion.
-->
用给定的参数提交请求，创建一个预备语句，然后等待结束。
<synopsis>
PGresult *PQprepare(PGconn *conn,
                    const char *stmtName,
                    const char *query,
                    int nParams,
                    const Oid *paramTypes);
</synopsis>
       </para>

       <!--
<para>
        <function>PQprepare</> creates a prepared statement for later
        execution with <function>PQexecPrepared</>.  This feature allows
        commands that will be used repeatedly to be parsed and planned just
        once, rather than each time they are executed.
        <function>PQprepare</> is supported only in protocol 3.0 and later
        connections; it will fail when using protocol 2.0.
       </para>
-->
<para>
<function>PQprepare</>创建一个为后面<function>PQexecPrepared</>执行用的预备语句。
这个特性允许那些重复使用的语句只分析和规划一次，而不是每次执行都分析规划。
只是在协议3.0和以后的连接里支持<function>PQprepare</>；在使用2.0协议的时候，它会失败。
</para>

       <!--
<para>
        The function creates a prepared statement named
        <parameter>stmtName</> from the <parameter>query</> string, which
        must contain a single SQL command.  <parameter>stmtName</> can be
        <literal>""</> to create an unnamed statement, in which case any
        pre-existing unnamed statement is automatically replaced; otherwise
        it is an error if the statement name is already defined in the
        current session.  If any parameters are used, they are referred
        to in the query as <literal>$1</>, <literal>$2</>, etc.
        <parameter>nParams</> is the number of parameters for which types
        are pre-specified in the array <parameter>paramTypes[]</>.  (The
        array pointer can be <symbol>NULL</symbol> when
        <parameter>nParams</> is zero.) <parameter>paramTypes[]</>
        specifies, by OID, the data types to be assigned to the parameter
        symbols.  If <parameter>paramTypes</> is <symbol>NULL</symbol>,
        or any particular element in the array is zero, the server assigns
        a data type to the parameter symbol in the same way it would do
        for an untyped literal string.  Also, the query can use parameter
        symbols with numbers higher than <parameter>nParams</>; data types
        will be inferred for these symbols as well.  (See
        <function>PQdescribePrepared</function> for a means to find out
        what data types were inferred.)
       </para>
-->
<para>
这个函数从<parameter>query</>字串里创建一个叫<parameter>stmtName</>的预备语句，
<parameter>query</>必须只包含一个 SQL 命令。<parameter>stmtName</>可以是<literal>""</>，
这样就创建一个无名的语句，这种情况下，任何前面存在的无名语句都会自动被代替；
否则，如果语句名已经在当前会话里定义，那就是一个错误。如果使用了参数，
那么在查询里它们引用成<literal>$1</>，<literal>$2</>等等。<parameter>nParams</>
是参数的个数，参数的类型在数组<parameter>paramTypes[]</>里事先声明好了。
（如果<parameter>nParams</>是零，那么这个数组指针可以是<symbol>NULL</symbol>。）
<parameter>paramTypes[]</>用 OID 的方式声明与参数符号关联的数据类型。
如果<parameter>paramTypes</>为<symbol>NULL</symbol>，或者数组中某个特定元素是零，
那么服务器将用处理无类型文本同样的方法给这个参数符号赋予数据类型。还有，
查询可以使用比<parameter>nParams</>数值更大的参数符号编号；
也为这些符号推断数据类型。（参阅<function>PQdescribePrepared</function>
作为一个找出推断的什么类型的手段。）
</para>

       <!--
<para>
        As with <function>PQexec</>, the result is normally a
        <structname>PGresult</structname> object whose contents indicate
        server-side success or failure.  A null result indicates
        out-of-memory or inability to send the command at all.  Use
        <function>PQerrorMessage</function> to get more information about
        such errors.
       </para>
-->
<para>
和<function>PQexec</>相似，结果通常是一个<structname>PGresult</structname>对象，
其内容表明服务器端是成功还是失败。空的结果表示内存耗尽或者完全不能发送命令。
使用<function>PQerrorMessage</function>获取有关这类错误的更多信息。
</para>
      </listitem>
     </varlistentry>
    </variablelist>
<!-- 
    Prepared statements for use with <function>PQexecPrepared</> can also
    be created by executing SQL <xref linkend="sql-prepare">
    statements.  Also, although there is no <application>libpq</>
    function for deleting a prepared statement, the SQL <xref
    linkend="sql-deallocate"> statement
    can be used for that purpose. 
-->
用于<function>PQexecPrepared</>的预备语句也可以通过执行SQL <xref linkend="sql-prepare">语句来创建。
还有，尽管没有<application>libpq</>函数可以删除一个预备语句，
SQL <xref linkend="sql-deallocate">语句却可以删除。
   </para>
  
<para>
    <variablelist>
     <varlistentry id="libpq-pqexecprepared">
      <term>
       <function>PQexecPrepared</function>
       <indexterm>
        <primary>PQexecPrepared</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
<!--
        Sends a request to execute a prepared statement with given
        parameters, and waits for the result.
-->
发送一个请求，执行一个带有给出参数的预备语句，并且等待结果。
<synopsis>
PGresult *PQexecPrepared(PGconn *conn,
                         const char *stmtName,
                         int nParams,
                         const char * const *paramValues,
                         const int *paramLengths,
                         const int *paramFormats,
                         int resultFormat);
</synopsis>
       </para>

       <!--
<para>
        <function>PQexecPrepared</> is like <function>PQexecParams</>,
        but the command to be executed is specified by naming a
        previously-prepared statement, instead of giving a query string.
        This feature allows commands that will be used repeatedly to be
        parsed and planned just once, rather than each time they are
        executed.  The statement must have been prepared previously in
        the current session.  <function>PQexecPrepared</> is supported
        only in protocol 3.0 and later connections; it will fail when
        using protocol 2.0.
       </para>
-->
<para>
<function>PQexecPrepared</>和<function>PQexecParams</>类似，
但是要执行的命令是通过命名一个前面准备好的语句声明的，而不是给出一个查询字串。
这个特性允许那些要重复使用的命令只进行一次分析和规划，而不是每次执行都来一遍。
这个语句必须在当前会话的前面已经准备好。<function>PQexecPrepared</>
只在协议 3.0 和以后的版本里支持；在使用 2.0 版本的协议的时候，它们会失败。
</para>

       <!--
<para>
        The parameters are identical to <function>PQexecParams</>, except that the
        name of a prepared statement is given instead of a query string, and the
        <parameter>paramTypes[]</> parameter is not present (it is not needed since
        the prepared statement's parameter types were determined when it was created).
       </para>
-->
<para>
参数和<function>PQexecParams</>一样，只是给出的是一个预备语句的名字，而不是一个查询字串，
并且没有<parameter>paramTypes[]</>参数（没必要，因为预备语句的参数类型是在创建的时候确定的）。
</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqdescribeprepared">
      <term>
       <function>PQdescribePrepared</function>
       <indexterm>
        <primary>PQdescribePrepared</primary>
       </indexterm>
      </term>

      <listitem>
       
<para>
<!--
        Submits a request to obtain information about the specified
        prepared statement, and waits for completion.
-->
提交请求以获取有关指定的预备语句的信息，并等待完成。
<synopsis>
PGresult *PQdescribePrepared(PGconn *conn, const char *stmtName);
</synopsis>
       </para>

       <!--
<para>
        <function>PQdescribePrepared</> allows an application to obtain
        information about a previously prepared statement.
        <function>PQdescribePrepared</> is supported only in protocol 3.0
        and later connections; it will fail when using protocol 2.0.
       </para>
-->
<para>
<function>PQdescribePrepared</>允许应用程序获取有关先前准备的语句的信息。
<function>PQdescribePrepared</>只在协议 3.0 和以后的版本里支持；
在使用 2.0 版本的协议的时候，它们会失败。
</para>

       <!--
<para>
        <parameter>stmtName</> can be <literal>""</> or <symbol>NULL</> to reference
        the unnamed statement, otherwise it must be the name of an existing
        prepared statement.  On success, a <structname>PGresult</> with
        status <literal>PGRES_COMMAND_OK</literal> is returned.  The
        functions <function>PQnparams</function> and
        <function>PQparamtype</function> can be applied to this
        <structname>PGresult</> to obtain information about the parameters
        of the prepared statement, and the functions
        <function>PQnfields</function>, <function>PQfname</function>,
        <function>PQftype</function>, etc provide information about the
        result columns (if any) of the statement.
       </para>
-->
<para>
<parameter>stmtName</>可以是<literal>""</>或<symbol>NULL</>以指向未命名声明，
要么必须与现有的预备语句同名。成功时，会返回一个带有<literal>PGRES_COMMAND_OK</literal>
的<structname>PGresult</>。可以在这个<structname>PGresult</>中使用
<function>PQnparams</function>和<function>PQparamtype</function>
函数以获得预备语句的参数信息，同时<function>PQnfields</function>，
<function>PQfname</function>，<function>PQftype</function>等函数提供声明的结果列（如果有）的信息。
</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqdescribeportal">
      <term>
       <function>PQdescribePortal</function>
       <indexterm>
        <primary>PQdescribePortal</primary>
       </indexterm>
      </term>

      <listitem>
       
<para>
<!--
        Submits a request to obtain information about the specified
        portal, and waits for completion.
-->
提交请求以获取有关指定的端口的信息，并等待完成。
<synopsis>
PGresult *PQdescribePortal(PGconn *conn, const char *portalName);
</synopsis>
       </para>

       <!--
<para>
        <function>PQdescribePortal</> allows an application to obtain
        information about a previously created portal.
        (<application>libpq</> does not provide any direct access to
        portals, but you can use this function to inspect the properties
        of a cursor created with a <command>DECLARE CURSOR</> SQL command.)
        <function>PQdescribePortal</> is supported only in protocol 3.0
        and later connections; it will fail when using protocol 2.0.
       </para>
-->
<para>
<function>PQdescribePortal</>允许应用程序获得关于之前创建的端口的信息。
（<application>libpq</>不提供与端口的直接连接，但可以使用这个函数来检查
<command>DECLARE CURSOR</>命令创建的游标的属性）。<function>PQdescribePortal</>
只支持3.0及其之后的连接协议；当使用协议2.0时会失败。
</para>

       <!--
<para>
        <parameter>portalName</> can be <literal>""</> or <symbol>NULL</> to reference
        the unnamed portal, otherwise it must be the name of an existing
        portal.  On success, a <structname>PGresult</> with status
        <literal>PGRES_COMMAND_OK</literal> is returned.  The functions
        <function>PQnfields</function>, <function>PQfname</function>,
        <function>PQftype</function>, etc can be applied to the
        <structname>PGresult</> to obtain information about the result
        columns (if any) of the portal.
       </para>
-->
<para>
<parameter>portalName</>可以是<literal>""</>或<symbol>NULL</>以指向未命名声明，
要么必须与现有的预备语句同名。成功时，会返回一个带有<literal>PGRES_COMMAND_OK</literal>
的<structname>PGresult</>。可以在<structname>PGresult</>中使用
<function>PQnfields</function>，<function>PQfname</function>，
<function>PQftype</function>等函数获取端口的结果列（如果有）的信息。
</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
   
<para>
<!--
    The <structname>PGresult</structname><indexterm><primary>PGresult</></>
    structure encapsulates the result returned by the server.
    <application>libpq</application> application programmers should be
    careful to maintain the <structname>PGresult</structname> abstraction.
    Use the accessor functions below to get at the contents of
    <structname>PGresult</structname>.  Avoid directly referencing the
    fields of the <structname>PGresult</structname> structure because they
    are subject to change in the future.
-->
<structname>PGresult</structname><indexterm><primary>PGresult</></>
结构封装了服务器返回的结果。<application>libpq</application>应该小心维护
<structname>PGresult</structname>的抽象。使用下面的访问函数获取
<structname>PGresult</structname>的内容。避免直接引用<structname>PGresult</structname>
里面的字段，因为它们在未来版本里可能会被修改。
    <variablelist>
     <varlistentry id="libpq-pqresultstatus">
      <term>
       <function>PQresultStatus</function>
       <indexterm>
        <primary>PQresultStatus</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
        <!--
Returns the result status of the command.
-->
返回命令的结果状态。
<synopsis>
ExecStatusType PQresultStatus(const PGresult *res);
</synopsis>
       </para>

       
<para>
<!-- 
        <function>PQresultStatus</function> can return one of the following values:
 -->
<function>PQresultStatus</function>可以返回下面数值之一：
        <variablelist>
         <varlistentry id="libpq-pgres-empty-query">
          <term><literal>PGRES_EMPTY_QUERY</literal></term>
          <listitem>
<!--
           <para>
            The string sent to the server was empty.
           </para>
-->
<para>
发送给服务器的字串是空的。
</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-command-ok">
          <term><literal>PGRES_COMMAND_OK</literal></term>
          <listitem>
           <!--
<para>
            Successful completion of a command returning no data.
           </para>
-->
<para>
成功完成一个不返回数据的命令。
</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-tuples-ok">
          <term><literal>PGRES_TUPLES_OK</literal></term>
          <listitem>
           <!--
<para>
            Successful completion of a command returning data (such as
            a <command>SELECT</> or <command>SHOW</>).
           </para>
-->
<para>
成功执行一个返回数据的查询（比如<command>SELECT</>或者<command>SHOW</>）。
</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-copy-out">
          <term><literal>PGRES_COPY_OUT</literal></term>
          <listitem>
           <!--
<para>
            Copy Out (from server) data transfer started.
           </para>
-->
<para>
（从服务器）Copy Out （拷贝出）数据传输开始。
</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-copy-in">
          <term><literal>PGRES_COPY_IN</literal></term>
          <listitem>
           <!--
<para>
            Copy In (to server) data transfer started.
           </para>
-->
<para>
Copy In（拷贝入）（到服务器）数据传输开始。
</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-bad-response">
          <term><literal>PGRES_BAD_RESPONSE</literal></term>
          <listitem>
           <!--
<para>
            The server's response was not understood.
           </para>
-->
<para>
服务器的响应无法理解。
</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-nonfatal-error">
          <term><literal>PGRES_NONFATAL_ERROR</literal></term>
          <listitem>
           <!--
<para>
            A nonfatal error (a notice or warning) occurred.
           </para>
-->
<para>
发生了一个非致命错误（通知或者警告）。
</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-fatal-error">
          <term><literal>PGRES_FATAL_ERROR</literal></term>
          <listitem>
           <!--
<para>
            A fatal error occurred.
           </para>
-->
<para>
发生了一个致命错误。
</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-copy-both">
          <term><literal>PGRES_COPY_BOTH</literal></term>
          <listitem>
           <!--
<para>
            Copy In/Out (to and from server) data transfer started.  This
            feature is currently used only for streaming replication,
            so this status should not occur in ordinary applications.
           </para>
-->
<para>
拷贝入/出（到和从服务器）数据传输开始。这个特性当前只用于流复制，
所以这个状态不会在普通应用中发生。
</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-single-tuple">
          <term><literal>PGRES_SINGLE_TUPLE</literal></term>
          <listitem>
           <!--
<para>
            The <structname>PGresult</> contains a single result tuple
            from the current command.  This status occurs only when
            single-row mode has been selected for the query
            (see <xref linkend="libpq-single-row-mode">).
           </para>
-->
<para>
<structname>PGresult</>包含一个来自当前命令的结果元组。
这个状态只在查询选择了单行模式时发生（参阅<xref linkend="libpq-single-row-mode">）。
</para>
          </listitem>
         </varlistentry>
        </variablelist>
<!-- 
        If the result status is <literal>PGRES_TUPLES_OK</literal> or
        <literal>PGRES_SINGLE_TUPLE</literal>, then
        the functions described below can be used to retrieve the rows
        returned by the query.  Note that a <command>SELECT</command>
        command that happens to retrieve zero rows still shows
        <literal>PGRES_TUPLES_OK</literal>.
        <literal>PGRES_COMMAND_OK</literal> is for commands that can never
        return rows (<command>INSERT</command> or <command>UPDATE</command>
        without a <literal>RETURNING</literal> clause,
        etc.). A response of <literal>PGRES_EMPTY_QUERY</literal> might
        indicate a bug in the client software. 
-->
如果结果状态是<literal>PGRES_TUPLES_OK</literal>或<literal>PGRES_SINGLE_TUPLE</literal>，
那么可以用下面的函数从查询的返回中抽取元组信息。注意一个碰巧检索了零条元组的
<command>SELECT</command>仍然显示<literal>PGRES_TUPLES_OK</literal>。
<literal>PGRES_COMMAND_OK</literal>用于不返回元组的命令（没有<literal>RETURNING</literal>
子句的<command>INSERT</command>，<command>UPDATE</command>等）。
返回<literal>PGRES_EMPTY_QUERY</literal>的响应通常意味着暴露了客户端软件里面的Bug。
       </para>

       <!--
<para>
        A result of status <symbol>PGRES_NONFATAL_ERROR</symbol> will
        never be returned directly by <function>PQexec</function> or other
        query execution functions; results of this kind are instead passed
        to the notice processor (see <xref
        linkend="libpq-notice-processing">).
       </para>
-->
<para>
状态为<symbol>PGRES_NONFATAL_ERROR</symbol>的结果永远不会直接由<function>PQexec</function>
或者其它查询执行函数返回；这类的结果会被传递给通知处理器
（参阅<xref linkend="libpq-notice-processing">）。
</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqresstatus">
      <term>
       <function>PQresStatus</function>
       <indexterm>
        <primary>PQresStatus</primary>
       </indexterm>
      </term>

      <listitem>
       
<para>
<!--
        Converts the enumerated type returned by
        <function>PQresultStatus</> into a string constant describing the
        status code. The caller should not free the result.
-->
把<function>PQresultStatus</>返回的枚举类型转换成一个描述状态码的字符串常量。
调用者不应该释放结果。
<synopsis>
char *PQresStatus(ExecStatusType status);
</synopsis>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqresulterrormessage">
      <term>
       <function>PQresultErrorMessage</function>
       <indexterm>
        <primary>PQresultErrorMessage</primary>
       </indexterm>
      </term>

      <listitem>
       
<para>
<!--
        Returns the error message associated with the command, or an empty string
        if there was no error.
-->
返回与查询关联的错误消息，或在没有错误时返回一个空字符串。
<synopsis>
char *PQresultErrorMessage(const PGresult *res);
</synopsis>
<!-- 
        If there was an error, the returned string will include a trailing
        newline.  The caller should not free the result directly. It will
        be freed when the associated <structname>PGresult</> handle is
        passed to <function>PQclear</function>. 
-->
如果有错误，那么返回的字串将包括一个结尾的新行。调用者不应该直接释放结果。
在相关的<structname>PGresult</>句柄传递给<function>PQclear</function>之后，它会自动释放。
       </para>

       <!--
<para>
        Immediately following a <function>PQexec</function> or
        <function>PQgetResult</function> call,
        <function>PQerrorMessage</function> (on the connection) will return
        the same string as <function>PQresultErrorMessage</function> (on
        the result).  However, a <structname>PGresult</structname> will
        retain its error message until destroyed, whereas the connection's
        error message will change when subsequent operations are done.
        Use <function>PQresultErrorMessage</function> when you want to
        know the status associated with a particular
        <structname>PGresult</structname>; use
        <function>PQerrorMessage</function> when you want to know the
        status from the latest operation on the connection.
       </para>
-->
<para>
紧跟在一个<function>PQexec</function>或<function>PQgetResult</function>调用后面，
<function>PQerrorMessage</function>（对连接）将返回与<function>PQresultErrorMessage</function>
(对结果)一样的字符串。不过，一个<structname>PGresult</structname>将保有其错误消息直到被删除，
而连接的错误消息将在后续的操作完成时被改变。当你想知道与某个<structname>PGresult</structname>
相关联的状态时用<function>PQresultErrorMessage</function>；
当你想知道与连接的最近一个操作相关联的状态时用<function>PQerrorMessage</function>。
</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqresulterrorfield">
      <term><function>PQresultErrorField</function><indexterm><primary>PQresultErrorField</></></term>
      <listitem>
       
<para>
<!--
        Returns an individual field of an error report.
-->
返回一个独立的错误报告字段。
<synopsis>
char *PQresultErrorField(const PGresult *res, int fieldcode);
</synopsis>
<!-- 
        <parameter>fieldcode</> is an error field identifier; see the symbols
        listed below.  <symbol>NULL</symbol> is returned if the
        <structname>PGresult</structname> is not an error or warning result,
        or does not include the specified field.  Field values will normally
        not include a trailing newline. The caller should not free the
        result directly. It will be freed when the
        associated <structname>PGresult</> handle is passed to
        <function>PQclear</function>. 
-->
<parameter>fieldcode</>是一个错误字段标识符；参阅下面列出的符号。
如果<structname>PGresult</structname>不是错误或者警告结果或者不包括指定的字段，
那么返回<symbol>NULL</symbol>。字段值通常将不包括结尾的新行。调用者不应该直接释放结果。
在相关联的<structname>PGresult</>句柄传递给<function>PQclear</function>之后，它将被自动释放。
       </para>

       
<para>
<!-- 
        The following field codes are available: 
-->
下列代码是可用的：
        <variablelist>
         <varlistentry id="libpq-pg-diag-severity">
          <term><symbol>PG_DIAG_SEVERITY</></term>
          <listitem>
<!--
           <para>
            The severity; the field contents are <literal>ERROR</>,
            <literal>FATAL</>, or <literal>PANIC</> (in an error message),
            or <literal>WARNING</>, <literal>NOTICE</>, <literal>DEBUG</>,
            <literal>INFO</>, or <literal>LOG</> (in a notice message), or
            a localized translation of one of these.  Always present.
           </para>
-->
<para>
严重程度，这个字段的内容是<literal>ERROR</>，<literal>FATAL</>或者<literal>PANIC</>
（在错误消息里），或者<literal>WARNING</>，<literal>NOTICE</>，<literal>DEBUG</>，
<literal>INFO</>或<literal>LOG</>（在通知消息里），或者是这些东西的一个本地化翻译。总是出现。
</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-sqlstate">
          <term>
           <symbol>PG_DIAG_SQLSTATE</>
          <indexterm>
           <primary>error codes</primary>
           <secondary>libpq</secondary>
          </indexterm>
          </term>
          <listitem>
           <!--
<para>
            The SQLSTATE code for the error. The SQLSTATE code identifies
            the type of error that has occurred; it can be used by
            front-end applications to perform specific operations (such
            as error handling) in response to a particular database error.
            For a list of the possible SQLSTATE codes, see <xref
            linkend="errcodes-appendix">. This field is not localizable,
            and is always present.
           </para>
-->
<para>
这个错误的SQLSTATE代码。SQLSTATE代码表示所发生的错误的类型；
可以由前端应用用于对特定的数据库错误执行特定的操作（比如错误处理）。
可能的SQLSTATE代码的列表，请查看<xref linkend="errcodes-appendix">。
这个字段是不能区域化的，并且总是出现。
</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-message-primary">
          <term><symbol>PG_DIAG_MESSAGE_PRIMARY</></term>
          <listitem>
           <!--
<para>
            The primary human-readable error message (typically one line).
            Always present.
           </para>
-->
<para>
主要的人类可读错误的信息（通常一行）。总是出现。
</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-message-detail">
          <term><symbol>PG_DIAG_MESSAGE_DETAIL</></term>
          <listitem>
           <!--
<para>
            Detail: an optional secondary error message carrying more
            detail about the problem.  Might run to multiple lines.
           </para>
-->
<para>
细节：一个可选的从属错误消息，里面有更多有关该问题的细节。可能有多行。
</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-message-hint">
          <term><symbol>PG_DIAG_MESSAGE_HINT</></term>
          <listitem>
           <!--
<para>
            Hint: an optional suggestion what to do about the problem.
            This is intended to differ from detail in that it offers advice
            (potentially inappropriate) rather than hard facts.  Might
            run to multiple lines.
           </para>
-->
<para>
提示：一个可选的有关如何处理该问题的建议。它和细节的区别是它提供了建议
（可能不太合适）而不光是事实。可能有好几行。
</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-statement-position">
          <term><symbol>PG_DIAG_STATEMENT_POSITION</></term>
          <listitem>
           <!--
<para>
            A string containing a decimal integer indicating an error cursor
            position as an index into the original statement string.  The
            first character has index 1, and positions are measured in
            characters not bytes.
           </para>
-->
<para>
一个包含十进制整数的字串，表明错误游标的位置，作为一个索引指向最初的语句字符串。
第一个字符的索引是 1，并且这个位置是用字符计，而不是用字节计。
</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-internal-position">
          <term><symbol>PG_DIAG_INTERNAL_POSITION</></term>
          <listitem>
           <!--
<para>
            This is defined the same as the
            <symbol>PG_DIAG_STATEMENT_POSITION</> field, but it is used
            when the cursor position refers to an internally generated
            command rather than the one submitted by the client.  The
            <symbol>PG_DIAG_INTERNAL_QUERY</> field will always appear when
            this field appears.
           </para>
-->
<para>
这个和<symbol>PG_DIAG_STATEMENT_POSITION</>字段定义是一样的，
区别是它在游标位置指向内部生成的命令时使用，而不是客户端提交的命令。如果出现了这个字段，
那么<symbol>PG_DIAG_INTERNAL_QUERY</>字段也总是出现。
</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-internal-query">
          <term><symbol>PG_DIAG_INTERNAL_QUERY</></term>
          <listitem>
           <!--
<para>
            The text of a failed internally-generated command.  This could
            be, for example, a SQL query issued by a PL/pgSQL function.
           </para>
-->
<para>
一个失败的内部生成的命令的文本。比如，这个可能是一个 PL/pgSQL 函数发出的 SQL 查询。
</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-context">
          <term><symbol>PG_DIAG_CONTEXT</></term>
          <listitem>
           <!--
<para>
            An indication of the context in which the error occurred.
            Presently this includes a call stack traceback of active
            procedural language functions and internally-generated queries.
            The trace is one entry per line, most recent first.
           </para>
-->
<para>
一个指示器，表明错误发生的环境。目前这个包括活跃的过程语言函数和内部生成的查询的调用堆栈跟踪。
跟踪是每行一条，最近的在上面。
</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-schema-name">
          <term><symbol>PG_DIAG_SCHEMA_NAME</></term>
          <listitem>
           <!--
<para>
            If the error was associated with a specific database object,
            the name of the schema containing that object, if any.
           </para>
-->
<para>
如果错误与特定的数据库对象相关，那么是包含该对象的模式名（如果有）。
</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-table-name">
          <term><symbol>PG_DIAG_TABLE_NAME</></term>
          <listitem>
           <!--
<para>
            If the error was associated with a specific table, the name of the
            table.  (Refer to the schema name field for the name of the
            table's schema.)
           </para>
-->
<para>
如果错误与特定的表相关，那么是该表的名字。（参考模式名字段获取表的模式的名字。）
</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-column-name">
          <term><symbol>PG_DIAG_COLUMN_NAME</></term>
          <listitem>
           <!--
<para>
            If the error was associated with a specific table column, the name
            of the column.  (Refer to the schema and table name fields to
            identify the table.)
           </para>
-->
<para>
如果错误与特定的表字段相关，那么是该字段的名字。（参考模式和表名字段识别该表。）
</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-datatype-name">
          <term><symbol>PG_DIAG_DATATYPE_NAME</></term>
          <listitem>
           <!--
<para>
            If the error was associated with a specific data type, the name of
            the data type.  (Refer to the schema name field for the name of
            the data type's schema.)
           </para>
-->
<para>
如果错误与特定的数据类型相关，那么是该数据类型的名字。（参考模式名字段获取数据类型的模式的名字。）
</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-constraint-name">
          <term><symbol>PG_DIAG_CONSTRAINT_NAME</></term>
          <listitem>
           <!--
<para>
            If the error was associated with a specific constraint, the name
            of the constraint.  Refer to fields listed above for the
            associated table or domain.  (For this purpose, indexes are
            treated as constraints, even if they weren't created with
            constraint syntax.)
           </para>
-->
<para>
如果错误与特定的约束相关，那么是该约束的名字。参考上面列出的字段获取相关的表或域。
（为了这个目的，索引被看做是约束，即使它们是用约束语法创建的。）
</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-source-file">
          <term><symbol>PG_DIAG_SOURCE_FILE</></term>
          <listitem>
           <!--
<para>
            The file name of the source-code location where the error was
            reported.
           </para>
-->
<para>
报告错误的源代码所在的文件名。
</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-source-line">
          <term><symbol>PG_DIAG_SOURCE_LINE</></term>
          <listitem>
           <!--
<para>
            The line number of the source-code location where the error
            was reported.
           </para>
-->
<para>
报告错误的源代码所在的行号。
</para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-source-function">
          <term><symbol>PG_DIAG_SOURCE_FUNCTION</></term>
          <listitem>
           <!--
<para>
            The name of the source-code function reporting the error.
           </para>
-->
<para>
报告错误的源代码函数的名字。
</para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>

       <note>
        <!--
<para>
         The fields for schema name, table name, column name, data type name,
         and constraint name are supplied only for a limited number of error
         types; see <xref linkend="errcodes-appendix">.  Do not assume that
         the presence of any of these fields guarantees the presence of
         another field.  Core error sources observe the interrelationships
         noted above, but user-defined functions may use these fields in other
         ways.  In the same vein, do not assume that these fields denote
         contemporary objects in the current database.
        </para>
-->
<para>
只为有限的错误类型提供模式名、表名、字段名、数据类型名和约束名字段；
参阅<xref linkend="errcodes-appendix">。不要假设这些字段的出现会保证其他字段的出现。
核心错误来源观察以上提到的相互关系，但是用户定义的函数可以以其他方式使用这些字段。
同样的，不要假设这些字段表示当前数据库中的同时期对象。
</para>
       </note>

       <!--
<para>
        The client is responsible for formatting displayed information to meet
        its needs; in particular it should break long lines as needed.
        Newline characters appearing in the error message fields should be
        treated as paragraph breaks, not line breaks.
       </para>
-->
<para>
按照自身的要求格式化显示信息是客户端的责任；特别是根据需要对长行进行折行。
在错误消息字段里出现的新行字符应该当作分段符号，而不是换行。
</para>

       <!--
<para>
        Errors generated internally by <application>libpq</application> will
        have severity and primary message, but typically no other fields.
        Errors returned by a pre-3.0-protocol server will include severity and
        primary message, and sometimes a detail message, but no other fields.
       </para>
-->
<para>
<application>libpq</application>生成的错误将会有严重性和主信息，但是通常没有其它字段。
3.0 协议之前返回的错误将包含严重性和主信息，有时候还有详细信息，但是没有其它字段。
</para>

       <!--
<para>
        Note that error fields are only available from
        <structname>PGresult</structname> objects, not
        <structname>PGconn</structname> objects; there is no
        <function>PQerrorField</function> function.
       </para>
-->
<para>
请注意这些错误字段只能从<structname>PGresult</structname>对象里获得，
而不是<structname>PGconn</structname>对象；没有<function>PQerrorField</function>函数。
</para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqclear">
      <term><function>PQclear</function><indexterm><primary>PQclear</></></term>
      <listitem>
       
<para>
<!--
        Frees  the  storage  associated with a
        <structname>PGresult</structname>.  Every command result should be
        freed via <function>PQclear</function> when it  is  no  longer
        needed.
-->
释放与<structname>PGresult</structname>相关联的存储空间。
任何不再需要的查询结果都应该用<function>PQclear</function>释放掉。
<synopsis>
void PQclear(PGresult *res);
</synopsis>
       </para>

       <!--
<para>
        You can keep a <structname>PGresult</structname> object around for
        as long as you need it; it does not go away when you issue a new
        command, nor even if you close the connection.  To get rid of it,
        you must call <function>PQclear</function>.  Failure to do this
        will result in memory leaks in your application.
       </para>
-->
<para>
只要你需要，你可以保留<structname>PGresult</structname>对象任意长的时间；
当你提交新的查询时它并不消失，甚至你断开连接后也是这样。要删除它，
你必须调用<function>PQclear</function>。不这么做将导致你应用中的内存泄漏。
</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="libpq-exec-select-info">
   <!-- 
   <title>Retrieving Query Result Information</title>
   -->
   <title>检索查询结果信息</title>

   <!--
<para>
    These functions are used to extract information from a
    <structname>PGresult</structname> object that represents a successful
    query result (that is, one that has status
    <literal>PGRES_TUPLES_OK</literal> or <literal>PGRES_SINGLE_TUPLE</>).
    They can also be used to extract
    information from a successful Describe operation: a Describe's result
    has all the same column information that actual execution of the query
    would provide, but it has zero rows.  For objects with other status values,
    these functions will act as though the result has zero rows and zero columns.
   </para>
-->
<para>
这些函数用于从一个代表着成功查询结果（也就是说，状态为<literal>PGRES_TUPLES_OK</literal>或
<literal>PGRES_SINGLE_TUPLE</>的查询）的<structname>PGresult</structname>对象中抽取信息。
它们也可以用于从一个成功描述操作中抽取信息：
一个描述的结果和实际查询的执行将要提供的结果有所有相同的字段信息，但是它有零行。
对于其它状态值的对象，他们的行为会好像他们有零行和零列一样。
</para>

   <variablelist>
    <varlistentry id="libpq-pqntuples">
     <term>
      <function>PQntuples</function>
      <indexterm>
       <primary>PQntuples</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       Returns the number of rows (tuples) in the query result.  Because
       it returns an integer result, large result sets might overflow the
       return value on 32-bit operating systems.
-->
返回查询结果里的行（元组）个数。因为它返回一个整数的结果，在32位操作系统上大型结果集可能溢出返回值。
<synopsis>
int PQntuples(const PGresult *res);
</synopsis>

      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqnfields">
     <term>
      <function>PQnfields</function>
      <indexterm>
       <primary>PQnfields</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       Returns the number of columns (fields) in each row of the query
       result.
-->
返回查询结果里数据行的列（字段）的个数。
<synopsis>
int PQnfields(const PGresult *res);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfname">
     <term>
      <function>PQfname</function>
      <indexterm>
       <primary>PQfname</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       Returns the column name associated with the given column number.
       Column numbers start at 0. The caller should not free the result
       directly. It will be freed when the associated
       <structname>PGresult</> handle is passed to
       <function>PQclear</function>.
-->
返回与给出的字段编号相关联的字段名。字段编号从 0 开始。调用者不应该直接释放结果。
在相关联的<structname>PGresult</>句柄传递给<function>PQclear</function>之后，结果会被自动释放。
<synopsis>
char *PQfname(const PGresult *res,
              int column_number);
</synopsis>
      </para>

      <!--
<para>
       <symbol>NULL</symbol> is returned if the column number is out of range.
      </para>
-->
<para>
如果字段编号超出范围，那么返回<symbol>NULL</symbol>。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfnumber">
     <term>
      <function>PQfnumber</function>
      <indexterm>
       <primary>PQfnumber</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       Returns the column number associated with the given column name.
-->
返回与给出的字段名相关的字段编号。
<synopsis>
int PQfnumber(const PGresult *res,
              const char *column_name);
</synopsis>
      </para>

      <!--
<para>
       -1 is returned if the given name does not match any column.
      </para>
-->
<para>
如果给出的名字不匹配任何字段，返回-1。
</para>
     
<para>
<!--
       The given name is treated like an identifier in an SQL command,
       that is, it is downcased unless double-quoted.  For example, given
       a query result generated from the SQL command:
-->
给出的名字是当作 SQL 命令里的一个标识符看待的，也就是说，如果没有加双引号，
那么会转换为小写。比如，如果我们有一个从 SQL 命令里生成的查询结果：
<programlisting>
SELECT 1 AS FOO, 2 AS "BAR";
</programlisting>
       <!-- 
   we would have the results: 
   -->
   那么我们会有下面的结果：
<programlisting>
PQfname(res, 0)              <lineannotation>foo</lineannotation>
PQfname(res, 1)              <lineannotation>BAR</lineannotation>
PQfnumber(res, "FOO")        <lineannotation>0</lineannotation>
PQfnumber(res, "foo")        <lineannotation>0</lineannotation>
PQfnumber(res, "BAR")        <lineannotation>-1</lineannotation>
PQfnumber(res, "\"BAR\"")    <lineannotation>1</lineannotation>
</programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqftable">
     <term>
      <function>PQftable</function>
      <indexterm>
       <primary>PQftable</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       Returns the OID of the table from which the given column was
       fetched.  Column numbers start at 0.
-->
返回我们抓取的字段所在的表的 OID。字段编号从 0 开始。
<synopsis>
Oid PQftable(const PGresult *res,
             int column_number);
</synopsis>
      </para>

      <!--
<para>
       <literal>InvalidOid</> is returned if the column number is out of range,
       or if the specified column is not a simple reference to a table column,
       or when using pre-3.0 protocol.
       You can query the system table <literal>pg_class</literal> to determine
       exactly which table is referenced.
      </para>
-->
<para>
如果字段编号超出了范围，或者声明的字段不是一个指向某个表的字段的简单引用，
或者使用了 3.0 版本之前的协议，那么就会返回<literal>InvalidOid</>。
你可以查询系统表<literal>pg_class</literal>来判断究竟引用了哪个表。
</para>

      <!--
<para>
       The type <type>Oid</type> and the constant
       <literal>InvalidOid</literal> will be defined when you include
       the <application>libpq</application> header file. They will both
       be some integer type.
      </para>
-->
<para>
在你包含<application>libpq</application>头文件的时候，就会定义类型<type>Oid</type>
和常量<literal>InvalidOid</literal>。他们都是相同的整数类型。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqftablecol">
     <term>
      <function>PQftablecol</function>
      <indexterm>
       <primary>PQftablecol</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       Returns the column number (within its table) of the column making
       up the specified query result column.  Query-result column numbers
       start at 0, but table columns have nonzero numbers.
-->
返回组成声明的查询结果字段的字段号（在它的表内部）。查询结果字段编号从 0 开始，
但是表字段编号不会是 0。
<synopsis>
int PQftablecol(const PGresult *res,
                int column_number);
</synopsis>
      </para>

      <!--
<para>
       Zero is returned if the column number is out of range, or if the
       specified column is not a simple reference to a table column, or
       when using pre-3.0 protocol.
      </para>
-->
<para>
如果字段编号超出范围，或者声明的字段并不是一个表字段的简单引用，
或者使用的是 3.0 之前的协议，那么返回零。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfformat">
     <term>
      <function>PQfformat</function>
      <indexterm>
       <primary>PQfformat</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       Returns the format code indicating the format of the given
       column.  Column numbers start at 0.
-->
返回说明给出字段的格式的格式代码。字段编号从 0 开始。
<synopsis>
int PQfformat(const PGresult *res,
              int column_number);
</synopsis>
      </para>

      <!--
<para>
       Format code zero indicates textual data representation, while format
       code one indicates binary representation.  (Other codes are reserved
       for future definition.)
      </para>
-->
<para>
格式码为 0 表示文本数据，而格式码是一表示二进制数据。（其它编码保留给将来定义。）
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqftype">
     <term>
      <function>PQftype</function>
      <indexterm>
       <primary>PQftype</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
      Returns the data type associated with the given  column number.
       The  integer  returned is the internal OID number of the type.
       Column numbers start at 0.
-->
返回与给定字段编号关联的数据类型。返回的整数是一个该类型的内部 OID 号。字段编号从0 开始。
<synopsis>
Oid PQftype(const PGresult *res,
            int column_number);
</synopsis>
      </para>

      <!--
<para>
       You can query the system table <literal>pg_type</literal> to
       obtain the names and properties of the various data types. The
       <acronym>OID</acronym>s of the built-in data types are defined
       in the file <filename>src/include/catalog/pg_type.h</filename>
       in the source tree.
      </para>
-->
<para>
你可以查询系统表<literal>pg_type</literal>以获取各种数据类型的名称和属性。
内建的数据类型的<acronym>OID</acronym>在源码树的
<filename>src/include/catalog/pg_type.h</filename>文件里定义。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfmod">
     <term>
      <function>PQfmod</function>
      <indexterm>
       <primary>PQfmod</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       Returns  the type modifier of the column associated with the
       given column number.  Column numbers start at 0.
-->
返回与给定字段编号相关联的字段的类型修饰符。字段编号从 0 开始。
<synopsis>
int PQfmod(const PGresult *res,
           int column_number);
</synopsis>
      </para>

      <!--
<para>
       The interpretation of modifier values is type-specific; they
       typically indicate precision or size limits.  The value -1 is
       used to indicate <quote>no information available</>.  Most data
       types do not use modifiers, in which case the value is always
       -1.
      </para>
-->
<para>
类型修饰符的值是类型相关的；他们通常包括精度或者尺寸限制。
数值 -1 用于表示<quote>没有可用信息</>。大多数数据类型不用修饰词，这种情况下该值总是-1。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfsize">
     <term>
      <function>PQfsize</function>
      <indexterm>
       <primary>PQfsize</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       Returns  the  size  in bytes of the column associated with the
       given column number.  Column numbers start at 0.
-->
返回与给定字段编号关联的字段以字节计的大小。字段编号从0 开始。
<synopsis>
int PQfsize(const PGresult *res,
            int column_number);
</synopsis>
      </para>

      <!--
<para>
       <function>PQfsize</> returns the space allocated for this column
       in a database row, in other words the size of the server's
       internal representation of the data type.  (Accordingly, it is
       not really very useful to clients.) A negative value indicates
       the data type is variable-length.
      </para>
-->
<para>
<function>PQfsize</>返回在数据库行里面给该数据字段分配的空间，
换句话说就是该数据类型在服务器的内部表现形式的大小（尺寸）。（因此，
这个对客户端没有什么用。） 负值表示该数据类型是可变长度。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqbinarytuples">
     <term>
      <function>PQbinaryTuples</function>
      <indexterm>
       <primary>PQbinaryTuples</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       Returns 1 if the <structname>PGresult</> contains binary data
       and 0 if it contains text data.
-->
如果<structname>PGresult</>包含二进制数据时返回 1，如果包含文本数据返回 0。
<synopsis>
int PQbinaryTuples(const PGresult *res);
</synopsis>
      </para>

      <!--
<para>
       This function is deprecated (except for its use in connection with
       <command>COPY</>), because it is possible for a single
       <structname>PGresult</> to contain text data in some columns and
       binary data in others.  <function>PQfformat</> is preferred.
       <function>PQbinaryTuples</> returns 1 only if all columns of the
       result are binary (format 1).
      </para>
-->
<para>
这个函数已经废弃了（除了还用于与<command>COPY</>连接之外），
因为我们可能在一个<structname>PGresult</>的某些字段里包含文本数据，
而另外一些字段包含二进制数据。更好的是使用<function>PQfformat</>。
<function>PQbinaryTuples</>只有在结果中的所有字段都是二进制（格式 1）的时候才返回 1。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqgetvalue">
     <term>
      <function>PQgetvalue</function>
       <indexterm>
        <primary>PQgetvalue</primary>
       </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       Returns a single field value of one row of a
       <structname>PGresult</structname>.  Row and column numbers start
       at 0.  The caller should not free the result directly.  It will
       be freed when the associated <structname>PGresult</> handle is
       passed to <function>PQclear</function>.
-->
返回一个<structname>PGresult</structname>里面一行的单独的一个字段的值。
行和字段编号从 0 开始。调用者不应该直接释放结果。在把<structname>PGresult</>
句柄传递给<function>PQclear</function>之后，结果会被自动释放。
<synopsis>
char *PQgetvalue(const PGresult *res,
                 int row_number,
                 int column_number);
</synopsis>
      </para>

      <!--
<para>
       For data in text format, the value returned by
       <function>PQgetvalue</function> is a null-terminated character
       string  representation of the field value.  For data in binary
       format, the value is in the binary representation determined by
       the data type's <function>typsend</> and <function>typreceive</>
       functions.  (The value is actually followed by a zero byte in
       this case too, but that is not ordinarily useful, since the
       value is likely to contain embedded nulls.)
      </para>
-->
<para>
对于文本格式的数据，<function>PQgetvalue</function>返回的值是一个表示字段值的空（NULL）
结尾的字符串。对于二进制格式，返回的值就是由该数据类型的<function>typsend</>
和<function>typreceive</>决定的二进制表现形式。（在这种情况下，
数值实际上也跟着一个字节零，但是通常这个字节没什么用处，因为数值本身很可能包含内嵌的空。）
</para>

      <!--
<para>
       An empty string is returned if the field value is null.  See
       <function>PQgetisnull</> to distinguish null values from
       empty-string values.
      </para>
-->
<para>
如果字段值是空，则返回一个空字串。参阅<function>PQgetisnull</>来区别空值和空字串值。
</para>

      <!--
<para>
       The pointer returned  by  <function>PQgetvalue</function> points
       to storage that is part of the <structname>PGresult</structname>
       structure.  One should not modify the data it points to, and one
       must explicitly copy the data into other storage if it is to be
       used past the lifetime of the  <structname>PGresult</structname>
       structure itself.
      </para>
-->
<para>
<function>PQgetvalue</function>返回的指针指向一个本身是<structname>PGresult</structname>
结构的一部分的存储区域。我们不能更改它，并且如果我们要在<structname>PGresult</structname>
结构的生存期后还要使用它的话，我们必须明确地把该数值拷贝到其他存储器中。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqgetisnull">
     <term>
      <function>PQgetisnull</function>
      <indexterm>
       <primary>PQgetisnull</primary>
      </indexterm>
      <indexterm>
       <!--
   <primary>null value</primary>
       <secondary sortas="libpq">in libpq</secondary>
   -->
   <primary>空值</primary>
       <secondary sortas="libpq">在libpq中</secondary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       Tests a field for a null value.  Row and column numbers start
       at 0.
-->
测试一个字段是否为空（NULL）。行和字段编号从 0 开始。
<synopsis>
int PQgetisnull(const PGresult *res,
                int row_number,
                int column_number);
</synopsis>
      </para>

      <!--
<para>
       This function returns  1 if the field is null and 0 if it
       contains a non-null value.  (Note that
       <function>PQgetvalue</function> will return an empty string,
       not a null pointer, for a null field.)
      </para>
-->
<para>
如果该域包含 NULL，函数返回 1，如果包含非空（non-null ）值，返回 0。
（注意，对一个 NULL 字段，<function>PQgetvalue</function>将返回一个空字符串，不是一个空指针。）
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqgetlength">
     <term>
     <function>PQgetlength</function>
     <indexterm>
      <primary>PQgetlength</primary>
     </indexterm></term>

     <listitem>
      
<para>
<!--
       Returns the actual length of a field value in bytes.  Row and
       column numbers start at 0.
-->
返回以字节计的字段的长度。行和字段编号从 0 开始。
<synopsis>
int PQgetlength(const PGresult *res,
                int row_number,
                int column_number);
</synopsis>
      </para>

      <!--
<para>
       This is the actual data length for the particular data value,
       that is, the size of the object pointed to by
       <function>PQgetvalue</function>.  For text data format this is
       the same as <function>strlen()</>.  For binary format this is
       essential information.  Note that one should <emphasis>not</>
       rely on <function>PQfsize</function> to obtain the actual data
       length.
      </para>
-->
<para>
这是特定数值的实际数据长度，也就是说，<function>PQgetvalue</function>指向的对象的大小。
对于文本数据格式，它和<function>strlen()</>相同。对于二进制格式，这是基本信息。
请注意我们<emphasis>不</>应该依靠<function>PQfsize</function> 获取实际数据长度。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqnparams">
     <term>
      <function>PQnparams</function>
      <indexterm>
       <primary>PQnparams</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       Returns the number of parameters of a prepared statement.
-->
返回一个预备语句中的参数的数目。
<synopsis>
int PQnparams(const PGresult *res);
</synopsis>
      </para>

      <!--
<para>
       This function is only useful when inspecting the result of
       <function>PQdescribePrepared</>.  For other types of queries it
       will return zero.
      </para>
-->
<para>
只有在检查<function>PQdescribePrepared</>的结果时，这个函数是有用的。
对于其他类型的查询将返回零。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqparamtype">
     <term>
      <function>PQparamtype</function>
      <indexterm>
       <primary>PQparamtype</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       Returns the data type of the indicated statement parameter.
       Parameter numbers start at 0.
-->
返回指示语句中的参数的数据类型。参数编号从0开始。
<synopsis>
Oid PQparamtype(const PGresult *res, int param_number);
</synopsis>
      </para>

      <!--
<para>
       This function is only useful when inspecting the result of
       <function>PQdescribePrepared</>.  For other types of queries it
       will return zero.
      </para>
-->
<para>
只有在检查<function>PQdescribePrepared</>的结果时，这个函数是有用的。
对于其他类型的查询将返回零。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqprint">
     <term>
      <function>PQprint</function>
      <indexterm>
       <primary>PQprint</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       Prints out all the rows and,  optionally,  the column names  to
       the specified output stream.
-->
向指定的输出流打印所有的行和（可选的）字段名称。
<synopsis>
void PQprint(FILE *fout,      /* <!-- output stream -->输出流 */
             const PGresult *res,
             const PQprintOpt *po);
typedef struct
{
    pqbool  header;      /* <!-- print output field headings and row count -->打印输出字段头和行计数 */
    pqbool  align;       /* <!-- fill align the fields -->填充对齐字段 */
    pqbool  standard;    /* <!-- old brain dead format -->旧的格式 */
    pqbool  html3;       /* <!-- output HTML tables -->输出HTML表 */
    pqbool  expanded;    /* <!-- expand tables -->扩展表 */
    pqbool  pager;       /* <!-- use pager for output if needed -->必要时在输出中使用分页器 */
    char    *fieldSep;   /* <!-- field separator -->字段分隔符 */
    char    *tableOpt;   /* <!-- attributes for HTML table element -->HTML表格元素的属性 */
    char    *caption;    /* <!-- HTML table caption -->HTML表标题 */
    char    **fieldName; /* <!-- null-terminated array of replacement field names -->替换字段名组成的空结尾的数组 */
} PQprintOpt;
</synopsis>
      </para>

      <!--
<para>
       This function was formerly used by <application>psql</application>
       to print query results, but this is no longer the case.  Note
       that it assumes all the data is in text format.
      </para>
-->
<para>
这个函数以前被<application>psql</application>用于打印查询结果，但是现在已经不用这个函数了。
请注意它假设所有的数据都是文本格式。
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 id="libpq-exec-nonselect">
   <!--
   <title>Retrieving Other Result Information</title>
   -->
   <title>检索其它命令的结果信息</title>

   <!--
<para>
    These functions are used to extract other information from
    <structname>PGresult</structname> objects.
   </para>
-->
<para>
这些函数用于从<structname>PGresult</structname>对象里检索其他信息。
</para>

   <variablelist>
    <varlistentry id="libpq-pqcmdstatus">
     <term>
      <function>PQcmdStatus</function>
      <indexterm>
       <primary>PQcmdStatus</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       Returns the command status tag from the SQL command that generated
       the <structname>PGresult</structname>.
-->
返回产生<structname>PGresult</structname>的 SQL 命令的命令状态标签。
<synopsis>
char *PQcmdStatus(PGresult *res);
</synopsis>
      </para>

      <!--
<para>
       Commonly this is just the name of the command, but it might include
       additional data such as the number of rows processed. The caller
       should not free the result directly. It will be freed when the
       associated <structname>PGresult</> handle is passed to
       <function>PQclear</function>.
      </para>
-->
<para>
通常这只是命令的名字，但是它可能包括额外的数据，比如处理过的行数。调用者不应该直接释放结果。
结果会在把<structname>PGresult</>句柄传递给<function>PQclear</function>的时候释放。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqcmdtuples">
     <term>
      <function>PQcmdTuples</function>
      <indexterm>
       <primary>PQcmdTuples</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       Returns the number of rows affected by the SQL command.
-->
返回被 SQL 命令影响的行的数量。
<synopsis>
char *PQcmdTuples(PGresult *res);
</synopsis>
      </para>

      <!--
<para>
       This function returns a string containing the number of rows
       affected by the <acronym>SQL</> statement that generated the
       <structname>PGresult</>. This function can only be used following
       the execution of a <command>SELECT</>, <command>CREATE TABLE AS</>,
       <command>INSERT</>, <command>UPDATE</>, <command>DELETE</>,
       <command>MOVE</>, <command>FETCH</>, or <command>COPY</> statement,
       or an <command>EXECUTE</> of a prepared query that contains an
       <command>INSERT</>, <command>UPDATE</>, or <command>DELETE</> statement.
       If the command that generated the <structname>PGresult</> was anything
       else, <function>PQcmdTuples</> returns an empty string. The caller
       should not free the return value directly. It will be freed when
       the associated <structname>PGresult</> handle is passed to
       <function>PQclear</function>.
      </para>
-->
<para>
这个函数返回一个字符串，包含<structname>PGresult</>产生的<acronym>SQL</>语句影响的行数。
这个函数只能用于下列的执行：<command>SELECT</>，<command>CREATE TABLE AS</>，<command>INSERT</>，
<command>UPDATE</>，<command>DELETE</>，<command>MOVE</>，<command>FETCH</>，或者
<command>COPY</>语句，或者是一个包含<command>INSERT</>，<command>UPDATE</>或<command>DELETE</>
语句的预备查询的<command>EXECUTE</>。如果生成这个<structname>PGresult</>的命令是其他的东西，
那么<function>PQcmdTuples</>返回一个空字串。调用者不应该直接释放返回的数值。
在相关联的<structname>PGresult</>被传递给<function>PQclear</function>之后，它会被自动释放。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqoidvalue">
     <term>
      <function>PQoidValue</function>
      <indexterm>
       <primary>PQoidValue</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       Returns the OID<indexterm><primary>OID</><secondary>in libpq</></>
       of the inserted row, if the <acronym>SQL</> command was an
       <command>INSERT</> that inserted exactly one row into a table that
       has OIDs, or a <command>EXECUTE</> of a prepared query containing
       a suitable <command>INSERT</> statement.  Otherwise, this function
       returns <literal>InvalidOid</literal>. This function will also
       return <literal>InvalidOid</literal> if the table affected by the
       <command>INSERT</> statement does not contain OIDs.
-->
返回插入的行的OID<indexterm><primary>OID</><secondary>in libpq</></>，
如果<acronym>SQL</>命令是<command>INSERT</>，插入了正好一行到有OID的表格，
或者是一个包含合适<command>INSERT</>语句的预备查询<command>EXECUTE</>的时候。
否则，函数返回<literal>InvalidOid</literal>。如果受<command>INSERT</>
影响的表不包含 OID，也返回<literal>InvalidOid</literal>。
<synopsis>
Oid PQoidValue(const PGresult *res);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqoidstatus">
     <term>
      <function>PQoidStatus</function>
      <indexterm>
       <primary>PQoidStatus</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       This function is deprecated in favor of
       <function>PQoidValue</function> and is not thread-safe.
       It returns a string with the OID of the inserted row, while
       <function>PQoidValue</function> returns the OID value.
-->
为了支持<function>PQoidValue</function>，这个函数已经废弃了，并且不是线程安全的。
它返回插入行的带有OID的字符串，而<function>PQoidValue</function>返回OID值。
<synopsis>
char *PQoidStatus(const PGresult *res);
</synopsis>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>

  <sect2 id="libpq-exec-escape-string">
   <!--
   <title>Escaping Strings for Inclusion in SQL Commands</title>
   -->
   <title>转义包含在SQL命令中的字符串</title>

   <indexterm zone="libpq-exec-escape-string">
    <!--
<primary>escaping strings</primary>
    <secondary>in libpq</secondary>
-->
<primary>转义字符串</primary>
    <secondary>在libpq中</secondary>
   </indexterm>

   <variablelist>
    <varlistentry id="libpq-pqescapeliteral">
     <term>
      <function>PQescapeLiteral</function>
      <indexterm>
       <primary>PQescapeLiteral</primary>
      </indexterm>
     </term>

     <listitem>
<para>
<synopsis>
char *PQescapeLiteral(PGconn *conn, const char *str, size_t length);
</synopsis>
     </para>

     <!--
<para>
      <function>PQescapeLiteral</function> escapes a string for
      use within an SQL command.  This is useful when inserting data
      values as literal constants in SQL commands.  Certain characters
      (such as quotes and backslashes) must be escaped to prevent them
      from being interpreted specially by the SQL parser.
      <function>PQescapeLiteral</> performs this operation.
     </para>
-->
<para>
<function>PQescapeLiteral</function>为在 SQL 命令中使用字串而对之进行转义处理。
在我们向 SQL 命令里把数据值当作文本常量插入的时候很有用。有些字符
（比如单引号和反斜杠）必须被转义，以避免他们被 SQL 分析器作为特殊字符解析。
<function>PQescapeLiteral</>执行这个操作。
</para>

     <!--
<para>
      <function>PQescapeLiteral</> returns an escaped version of the
      <parameter>str</parameter> parameter in memory allocated with
      <function>malloc()</>.  This memory should be freed using
      <function>PQfreemem()</> when the result is no longer needed.
      A terminating zero byte is not required, and should not be
      counted in <parameter>length</>.  (If a terminating zero byte is found
      before <parameter>length</> bytes are processed,
      <function>PQescapeLiteral</> stops at the zero; the behavior is
      thus rather like <function>strncpy</>.) The
      return string has all special characters replaced so that they can
      be properly processed by the <productname>PostgreSQL</productname>
      string literal parser.  A terminating zero byte is also added.  The
      single quotes that must surround <productname>PostgreSQL</productname>
      string literals are included in the result string.
     </para>
-->
<para>
<function>PQescapeLiteral</>返回一个内存中分配有<function>malloc()</>的
<parameter>str</parameter>参数的转义版本。当结果不再需要时，需要通过<function>PQfreemem()</>
来释放这块内存。不需要一个0字节结束，并且不应以<parameter>length</>计数。
（如果在处理<parameter>length</>字节之前出现0字节的结束，<function>PQescapeLiteral</>
在此处结束；这个行为有点像<function>strncpy</>）。返回的字符串中所有特殊字符都替换掉了，
因此可以很好的被<productname>PostgreSQL</productname>字符串文本解析器处理，同样，
允许增加一个0字节结尾。必须在<productname>PostgreSQL</productname>
字符串文本两边的单引号包含在结果字符串中。
</para>

     <!--
<para>
      On error, <function>PQescapeLiteral</> returns <symbol>NULL</> and a suitable
      message is stored in the <parameter>conn</> object.
     </para>
-->
<para>
一旦错误，<function>PQescapeLiteral</>返回<symbol>NULL</>并在<parameter>conn</>对象中存储合适的信息。
</para>

     <tip>
      <!--
<para>
       It is especially important to do proper escaping when handling
       strings that were received from an untrustworthy source.
       Otherwise there is a security risk: you are vulnerable to
       <quote>SQL injection</> attacks wherein unwanted SQL commands are
       fed to your database.
      </para>
-->
<para>
处理从不可信来源收到的字符串时必须进行合适的转义，否则存在一定的安全风险：
容易受到<quote>SQL 注入</>攻击，数据库中会被写入未知的SQL命令。
</para>
     </tip>

     <!--
<para>
      Note that it is not necessary nor correct to do escaping when a data
      value is passed as a separate parameter in <function>PQexecParams</> or
      its sibling routines.
     </para>
-->
<para>
需要注意的是，当一个数据以<function>PQexecParams</>或它的兄弟格式，
作为一个单独的参数传递时，做转义是不必要，也是不正确的。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqescapeidentifier">
     <term>
      <function>PQescapeIdentifier</function>
      <indexterm>
       <primary>PQescapeIdentifier</primary>
      </indexterm>
     </term>

     <listitem>
<para>
<synopsis>
char *PQescapeIdentifier(PGconn *conn, const char *str, size_t length);
</synopsis>
     </para>

     <!--
<para>
      <function>PQescapeIdentifier</function> escapes a string for
      use as an SQL identifier, such as a table, column, or function name.
      This is useful when a user-supplied identifier might contain
      special characters that would otherwise not be interpreted as part
      of the identifier by the SQL parser, or when the identifier might
      contain upper case characters whose case should be preserved.
     </para>
-->
<para>
<function>PQescapeIdentifier</function>转义一个字符串作为一个SQL标识符使用，
如一个表，列，或函数名。当一个用户自定义标识符需要包含特殊的字符，
否则将不能被SQL解析器解析为标识符的一部分时，或者当标识符需要包含大写字母，
且这种情况必须保留时，这样做是很有用的。
</para>

     <!--
<para>
      <function>PQescapeIdentifier</> returns a version of the
      <parameter>str</parameter> parameter escaped as an SQL identifier
      in memory allocated with <function>malloc()</>.  This memory must be
      freed using <function>PQfreemem()</> when the result is no longer
      needed.  A terminating zero byte is not required, and should not be
      counted in <parameter>length</>.  (If a terminating zero byte is found
      before <parameter>length</> bytes are processed,
      <function>PQescapeIdentifier</> stops at the zero; the behavior is
      thus rather like <function>strncpy</>.) The
      return string has all special characters replaced so that it
      will be properly processed as an SQL identifier.  A terminating zero byte
      is also added.  The return string will also be surrounded by double
      quotes.
     </para>
-->
<para>
<function>PQescapeIdentifier</>返回<parameter>str</parameter>参数转义为一个内存中分配有
<function>malloc()</>的SQL标识符的版本。当结果不再需要时，这块内存必须使用
<function>PQfreemem()</>来释放。不需要一个0字节结束，并且不应以<parameter>length</>计数。
（如果在处理<parameter>length</>字节之前出现0字节的结束，<function>PQescapeIdentifier</>
在此处结束；这个行为比较像<function>strncpy</>）。返回的字符串中所有特殊字符都替换掉了，
因此可以很好的作为SQL标识符被处理。也可以添加一个结尾的0字节。返回字符串也是被双引号环绕。
</para>

     <!--
<para>
      On error, <function>PQescapeIdentifier</> returns <symbol>NULL</> and a suitable
      message is stored in the <parameter>conn</> object.
     </para>
-->
<para>
出错时，<function>PQescapeIdentifier</>返回<symbol>NULL</>，并且在<parameter>conn</>对象中存贮合适的信息。
</para>

     <tip>
      <!--
<para>
       As with string literals, to prevent SQL injection attacks,
       SQL identifiers must be escaped when they are received from an
       untrustworthy source.
      </para>
-->
<para>
由于带有字符串常量，为阻止SQL注入攻击，当从一个不可信任资源获得时，SQL标识符必须转义。
</para>
     </tip>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqescapestringconn">
     <term>
      <function>PQescapeStringConn</function>
      <indexterm>
       <primary>PQescapeStringConn</primary>
      </indexterm>
     </term>

     <listitem>
<para>
<synopsis>
size_t PQescapeStringConn(PGconn *conn,
                          char *to, const char *from, size_t length,
                          int *error);
</synopsis>
     </para>

     <!--
<para>
      <function>PQescapeStringConn</> escapes string literals, much like
      <function>PQescapeLiteral</>.  Unlike <function>PQescapeLiteral</>,
      the caller is responsible for providing an appropriately sized buffer.
      Furthermore, <function>PQescapeStringConn</> does not generate the
      single quotes that must surround <productname>PostgreSQL</> string
      literals; they should be provided in the SQL command that the
      result is inserted into.  The parameter <parameter>from</> points to
      the first character of the string that is to be escaped, and the
      <parameter>length</> parameter gives the number of bytes in this
      string.  A terminating zero byte is not required, and should not be
      counted in <parameter>length</>.  (If a terminating zero byte is found
      before <parameter>length</> bytes are processed,
      <function>PQescapeStringConn</> stops at the zero; the behavior is
      thus rather like <function>strncpy</>.) <parameter>to</> shall point
      to a buffer that is able to hold at least one more byte than twice
      the value of <parameter>length</>, otherwise the behavior is undefined.
      Behavior is likewise undefined if the <parameter>to</> and
      <parameter>from</> strings overlap.
     </para>
-->
<para>
<function>PQescapeStringConn</>转义字符串常量，比较像<function>PQescapeLiteral</>。
不同于<function>PQescapeLiteral</>，请求应该提供一个适当大小的缓冲区。更重要的是，
<function>PQescapeStringConn</>不会生成一个必须在<productname>PostgreSQL</>
字符串常量两端的单引号；SQL命令中应该提供，这样结果中会被插入。<parameter>from</>
参数指向字符串的第一个字符（用以转义），<parameter>length</>参数指出了在这个字符串中的字节数。
不需要一个0字节结束，并且不应以<parameter>length</>计数。
（如果在处理<parameter>length</>字节之前出现0字节的结束，<function>PQescapeStringConn</>
在此处结束；这个行为比较像<function>strncpy</>）。<parameter>to</>应该指向一个包含至少多于两倍
<parameter>length</>大小的缓冲区，要么就不会定义该行为。如果<parameter>to</>和<parameter>from</>
字符串交叠，那么也不会定义该行为。
</para>

     <!--
<para>
      If the <parameter>error</> parameter is not <symbol>NULL</>, then
      <literal>*error</> is set to zero on success, nonzero on error.
      Presently the only possible error conditions involve invalid multibyte
      encoding in the source string.  The output string is still generated
      on error, but it can be expected that the server will reject it as
      malformed.  On error, a suitable message is stored in the
      <parameter>conn</> object, whether or not <parameter>error</> is <symbol>NULL</>.
     </para>
-->
<para>
<parameter>error</>参数非<symbol>NULL</>，那么在成功的时候<literal>*error</>会被设置为零，
失败的时候设置为非0。目前唯一可能的错误条件涉及在源字符串中无效的多字节编码。
输出字符串同样产生错误，但服务器可以视其为异常以拒绝。一旦发生错误，
一条合适的信息会存储在<parameter>conn</>对象中，无论<parameter>error</>是否为<symbol>NULL</>。
</para>

     <!--
<para>
      <function>PQescapeStringConn</> returns the number of bytes written
      to <parameter>to</>, not including the terminating zero byte.
     </para>
-->
<para>
<function>PQescapeStringConn</>返回写到<parameter>to</>的字节数，不包含0字节终止。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqescapestring">
     <term>
      <function>PQescapeString</function>
      <indexterm>
       <primary>PQescapeString</primary>
      </indexterm>
     </term>

     <listitem>
     
<para>
<!--
       <function>PQescapeString</> is an older, deprecated version of
       <function>PQescapeStringConn</>.
-->
<function>PQescapeString</>是一个老的，已经被<function>PQescapeStringConn</>弃用了的版本。
<synopsis>
size_t PQescapeString (char *to, const char *from, size_t length);
</synopsis>
     </para>

     <!--
<para>
      The only difference from <function>PQescapeStringConn</> is that
      <function>PQescapeString</> does not take <structname>PGconn</>
      or <parameter>error</> parameters.
      Because of this, it cannot adjust its behavior depending on the
      connection properties (such as character encoding) and therefore
      <emphasis>it might give the wrong results</>.  Also, it has no way
      to report error conditions.
     </para>
-->
<para>
与<function>PQescapeStringConn</>唯一的不同是，<function>PQescapeString</>
不使用<structname>PGconn</>或<parameter>error</>参数。因此，不能够根据连接属性
（如字符编码）来调整其行为，因此<emphasis>可能会给出错误的结果</>，同样，不会报告错误条件。
</para>

     <!--
<para>
      <function>PQescapeString</> can be used safely in
      client programs that work with only one <productname>PostgreSQL</>
      connection at a time (in this case it can find out what it needs to
      know <quote>behind the scenes</>).  In other contexts it is a security
      hazard and should be avoided in favor of
      <function>PQescapeStringConn</>.
     </para>
-->
<para>
<function>PQescapeString</>可以在客户端编程（一次只有一个<productname>PostgreSQL</>连接）
中安全的使用。在这种情况下，它可以找到<quote>在屏幕背后</>想要知道的。在其他情况下，
这是一个安全隐患，使用<function>PQescapeStringConn</>时应该避免。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqescapebyteaconn">
     <term>
      <function>PQescapeByteaConn</function>
      <indexterm>
       <primary>PQescapeByteaConn</primary>
      </indexterm>
     </term>

     <listitem>
     
<para>
<!--
       Escapes binary data for use within an SQL command with the type
       <type>bytea</type>.  As with <function>PQescapeStringConn</function>,
       this is only used when inserting data directly into an SQL command string.
-->
转义那些在 SQL 命令中使用的用<type>bytea</type>表示的二进制数据。
和<function>PQescapeStringConn</function>一样，这个函数只有在直接向 SQL 字串插入数据的时候使用。
<synopsis>
unsigned char *PQescapeByteaConn(PGconn *conn,
                                 const unsigned char *from,
                                 size_t from_length,
                                 size_t *to_length);
</synopsis>
      </para>

      <!--
<para>
       Certain byte values must be escaped when used as part of a
       <type>bytea</type> literal in an <acronym>SQL</acronym> statement.
       <function>PQescapeByteaConn</function> escapes bytes using
       either hex encoding or backslash escaping.  See <xref
       linkend="datatype-binary"> for more information.
      </para>
-->
<para>
在<acronym>SQL</acronym>语句中用做<type>bytea</type>字串文本的一部分的时候，
有些字节值必需转义。<function>PQescapeByteaConn</function>转义字节使用十六进制编码或反斜杠转义。
参阅<xref linkend="datatype-binary">获取更多信息。
</para>

      <!--
<para>
       The <parameter>from</parameter> parameter points to the first
       byte of the string that is to be escaped, and the
       <parameter>from_length</parameter> parameter gives the number of
       bytes in this binary string.  (A terminating zero byte is
       neither necessary nor counted.)  The <parameter>to_length</parameter>
       parameter points to a variable that will hold the resultant
       escaped string length. This result string length includes the terminating
       zero byte of the result.
      </para>
-->
<para>
<parameter>from</parameter>参数指向需要转义的字串的第一个字节，<parameter>from_length</parameter>
参数反映在这个二进制字串（结尾的字节零既不必要也不计算在内）里字节的个数。
<parameter>to_length</parameter>参数指向一个变量，它保存转义后字符串长度的结果。
结果字串长度包括结果结尾的零字节。
</para>

      <!--
<para>
       <function>PQescapeByteaConn</> returns an escaped version of the
       <parameter>from</parameter> parameter binary string in memory
       allocated with <function>malloc()</>.  This memory should be freed using
       <function>PQfreemem()</> when the result is no longer needed.  The
       return string has all special characters replaced so that they can
       be properly processed by the <productname>PostgreSQL</productname>
       string literal parser, and the <type>bytea</type> input function. A
       terminating zero byte is also added.  The single quotes that must
       surround <productname>PostgreSQL</productname> string literals are
       not part of the result string.
      </para>
-->
<para>
<function>PQescapeByteaConn</>在内存中返回一个<parameter>from</parameter>
参数的二进制字串的转义后的版本，这片内存是用<function>malloc()</>分配的
在不再需要结果的时候，必须用<function>PQfreemem()</>释放内存。
返回的字串已经把所有特殊的字符替换掉了，这样他们就可以由<productname>PostgreSQL</productname>
的字串文本分析器以及<type>bytea</type>的输入函数正确地处理。同时还追加了一个结尾的字节零。
那些必需包围在<productname>PostgreSQL</productname>字串文本周围的单引号并非结果字串的一部分。
</para>

      <!--
<para>
       On error, a null pointer is returned, and a suitable error message
       is stored in the <parameter>conn</> object.  Currently, the only
       possible error is insufficient memory for the result string.
      </para>
-->
<para>
当出错时，返回一个空指针，一个合适的错误消息会被储存在<parameter>conn</>对象中，
当前唯一可能的错误是结果字符串的内存不足。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqescapebytea">
     <term>
      <function>PQescapeBytea</function>
      <indexterm>
       <primary>PQescapeBytea</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       <function>PQescapeBytea</> is an older, deprecated version of
       <function>PQescapeByteaConn</>.
-->
<function>PQescapeBytea</>是<function>PQescapeByteaConn</>的一个旧的，过时的版本。
<synopsis>
unsigned char *PQescapeBytea(const unsigned char *from,
                             size_t from_length,
                             size_t *to_length);
</synopsis>
      </para>

      <!--
<para>
       The only difference from <function>PQescapeByteaConn</> is that
       <function>PQescapeBytea</> does not take a <structname>PGconn</>
       parameter.  Because of this, <function>PQescapeBytea</> can
       only be used safely in client programs that use a single
       <productname>PostgreSQL</> connection at a time (in this case
       it can find out what it needs to know <quote>behind the
       scenes</>).  It <emphasis>might give the wrong results</> if
       used in programs that use multiple database connections (use
       <function>PQescapeByteaConn</> in such cases).
      </para>
-->
<para>
与<function>PQescapeByteaConn</>唯一的不同之处在于，<function>PQescapeByteaConn</>
不使用<structname>PGconn</>参数，因此，<function>PQescapeBytea</>可以在客户端编程
（一次只有一个<productname>PostgreSQL</>连接）中安全的使用。在这种情况下，
它可以找到<quote>在屏幕背后</>想要知道的。如果在编程中使用多个数据库连接
（在这种情况下使用<function>PQescapeByteaConn</>），那么<emphasis>可能会给出错误结果</>。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqunescapebytea">
     <term>
      <function>PQunescapeBytea</function>
      <indexterm>
       <primary>PQunescapeBytea</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       Converts a string representation of binary data into binary data
       &mdash; the reverse of <function>PQescapeBytea</function>.  This
       is needed when retrieving <type>bytea</type> data in text format,
       but not when retrieving it in binary format.
-->
把一个二进制数据的字符串表现形式转换成二进制数据&mdash;
<function>PQescapeBytea</function>的反作用。在以文本格式抽取<type>bytea</type>
数据的时候是必须的，但是在以二进制格式抽取的时候是不必要的。
<synopsis>
unsigned char *PQunescapeBytea(const unsigned char *from, size_t *to_length);
</synopsis>
      </para>

      <!--
<para>
       The <parameter>from</parameter> parameter points to a string
       such as might be returned by <function>PQgetvalue</function> when applied
       to a <type>bytea</type> column. <function>PQunescapeBytea</function>
       converts this string representation into its binary representation.
       It returns a pointer to a buffer allocated with
       <function>malloc()</function>, or <symbol>NULL</> on error, and puts the size of
       the buffer in <parameter>to_length</parameter>. The result must be
       freed using <function>PQfreemem</> when it is no longer needed.
      </para>
-->
<para>
<parameter>from</parameter>参数指向一个字符串，比如应用到<type>bytea</type>字段时，
<function>PQgetvalue</function>返回的。<function>PQunescapeBytea</function>
把它的字串表现形式转换成二进制形式，它返回一个用<function>malloc()</function>
分配的指向该缓冲区的指针，或者是出错时返回<symbol>NULL</>，缓冲区的尺寸放在
<parameter>to_length</parameter>里。在不再需要这个结果之后，
这片内存必须用<function>PQfreemem</>释放。
</para>

      <!--
<para>
       This conversion is not exactly the inverse of
       <function>PQescapeBytea</function>, because the string is not expected
       to be <quote>escaped</> when received from <function>PQgetvalue</function>.
       In particular this means there is no need for string quoting considerations,
       and so no need for a <structname>PGconn</> parameter.
      </para>
-->
<para>
这个转换不正好是<function>PQescapeBytea</function>逆转换，因为，当从
<function>PQgetvalue</function>接收时，字符串不希望被<quote>转义</>。尤其是，这意味着，
不需要考虑字符串引用，并且不需要<structname>PGconn</>参数。
</para>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>

 </sect1>

 <sect1 id="libpq-async">
  <!--
  <title>Asynchronous Command Processing</title>
  -->
  <title>异步命令处理</title>

  <indexterm zone="libpq-async">
   <!--
   <primary>nonblocking connection</primary>
   -->
   <primary>非阻塞连接</primary>
  </indexterm>

  
<para>
<!--    The <function>PQexec</function> function is adequate for submitting
   commands in normal, synchronous applications.  It has a few
   deficiencies, however, that can be of importance to some users:
-->
<function>PQexec</function>函数对普通的同步应用里提交命令已经是足够用的了。
但是它却有几个缺陷，而这些缺陷可能对某些用户很重要：
   <itemizedlist>
    <listitem>
<!--
     <para>
      <function>PQexec</function> waits for the command to be completed.
      The application might have other work to do (such as maintaining a
      user interface), in which case it won't want to block waiting for
      the response.
     </para>
-->
<para>
<function>PQexec</function>等待命令结束。而应用可能还有其它的工作要做
（比如维护用户界面等），这个时候它可不想阻塞在这里等待响应。
</para>
    </listitem>

    <listitem>
     <!--
<para>
      Since the execution of the client application is suspended while it
      waits for the result, it is hard for the application to decide that
      it would like to try to cancel the ongoing command.  (It can be done
      from a signal handler, but not otherwise.)
     </para>
-->
<para>
因为客户端应用在等待结果的时候是处于挂起状态的，所以应用很难判断它是否该尝试结束正在进行的命令。
（这个事情可以在一个信号处理器中做，但是没别的方法。）
</para>
    </listitem>

    <listitem>
     <!--
<para>
      <function>PQexec</function> can return only one
      <structname>PGresult</structname> structure.  If the submitted command
      string contains multiple <acronym>SQL</acronym> commands, all but
      the last <structname>PGresult</structname> are discarded by
      <function>PQexec</function>.
     </para>
-->
<para>
<function>PQexec</function>只能返回一个<structname>PGresult</structname>结构。
如果提交的命令字符串包含多个<acronym>SQL</acronym>命令，除了最后一个
<structname>PGresult</structname>以外都会被<function>PQexec</function>丢弃。
</para>
    </listitem>

    <listitem>
     <!--
<para>
      <function>PQexec</function> always collects the command's entire result,
      buffering it in a single <structname>PGresult</structname>.  While
      this simplifies error-handling logic for the application, it can be
      impractical for results containing many rows.
     </para>
-->
<para>
<function>PQexec</function>总是收集命令的整个结果，将其缓存在一个<structname>PGresult</structname>中。
虽然这为应用简化了错误处理逻辑，但是对于包含多行的结果是不切实际的。
</para>
    </listitem>
   </itemizedlist>
  </para>

  
<para>
<!-- 
   Applications that do not like these limitations can instead use the
   underlying functions that <function>PQexec</function> is built from:
   <function>PQsendQuery</function> and <function>PQgetResult</function>.
   There are also
   <function>PQsendQueryParams</function>,
   <function>PQsendPrepare</function>,
   <function>PQsendQueryPrepared</function>,
   <function>PQsendDescribePrepared</function>, and
   <function>PQsendDescribePortal</function>,
   which can be used with <function>PQgetResult</function> to duplicate
   the functionality of
   <function>PQexecParams</function>,
   <function>PQprepare</function>,
   <function>PQexecPrepared</function>,
   <function>PQdescribePrepared</function>, and
   <function>PQdescribePortal</function>
   respectively. 
-->
不想受到这些限制的应用可以改用下面的函数，这些函数也是构造<function>PQexec</function>
的函数：<function>PQsendQuery</function>和<function>PQgetResult</function>。
也有<function>PQsendQueryParams</function>，<function>PQsendPrepare</function>，
<function>PQsendQueryPrepared</function>，<function>PQsendDescribePrepared</function>
和<function>PQsendDescribePortal</function>，他们可以和<function>PQgetResult</function>
一起使用，分别用于复制<function>PQexecParams</function>，<function>PQprepare</function>，
<function>PQexecPrepared</function>，<function>PQdescribePrepared</function>
和<function>PQdescribePortal</function>的功能。

   <variablelist>
    <varlistentry id="libpq-pqsendquery">
     <term>
      <function>PQsendQuery</function>
      <indexterm>
       <primary>PQsendQuery</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Submits a command to the server without waiting for the result(s).
       1 is returned if the command was successfully dispatched and 0 if
       not (in which case, use <function>PQerrorMessage</> to get more
       information about the failure).
-->
向服务器提交一个命令而不等待结果。如果查询成功发送则返回 1，否则返回 0。
（此时，可以用<function>PQerrorMessage</>获取关于失败的信息）。
<synopsis>
int PQsendQuery(PGconn *conn, const char *command);
</synopsis>

<!-- 
       After successfully calling <function>PQsendQuery</function>, call
       <function>PQgetResult</function> one or more times to obtain the
       results.  <function>PQsendQuery</function> cannot be called again
       (on the same connection) until <function>PQgetResult</function>
       has returned a null pointer, indicating that the command is done. 
-->
在成功调用<function>PQsendQuery</function>后，调用<function>PQgetResult</function>
一次或者多次获取结果。在<function>PQgetResult</function>返回 NULL 指针，
表明命令完成之前，我们不能再调用<function>PQsendQuery</function>（在同一次连接里）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsendqueryparams">
     <term>
      <function>PQsendQueryParams</function>
      <indexterm>
       <primary>PQsendQueryParams</primary>
      </indexterm>
     </term>

     <listitem>      
<para>
<!--
       Submits a command and separate parameters to the server without
       waiting for the result(s).
-->
给服务器提交一个命令和分隔的参数，而不等待结果。
<synopsis>
int PQsendQueryParams(PGconn *conn,
                      const char *command,
                      int nParams,
                      const Oid *paramTypes,
                      const char * const *paramValues,
                      const int *paramLengths,
                      const int *paramFormats,
                      int resultFormat);
</synopsis>

<!-- 
       This is equivalent to <function>PQsendQuery</function> except that
       query parameters can be specified separately from the query string.
       The function's parameters are handled identically to
       <function>PQexecParams</function>.  Like
       <function>PQexecParams</function>, it will not work on 2.0-protocol
       connections, and it allows only one command in the query string. 
-->
这个等效于<function>PQsendQuery</function>，只是查询参数可以和查询字串分开声明。
函数的参数处理和<function>PQexecParams</function>一样。
和<function>PQexecParams</function>类似，它不能在 2.0 版本的协议连接上工作，
并且它只允许在查询字串里出现一条命令。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsendprepare">
     <term>
      <function>PQsendPrepare</>
      <indexterm>
       <primary>PQsendPrepare</primary>
      </indexterm>
     </term>

     <listitem>      
<para>
<!--
       Sends a request to create a prepared statement with the given
       parameters, without waiting for completion.
-->
发送一个请求，创建一个给定参数的预备语句，而不等待结束。
<synopsis>
int PQsendPrepare(PGconn *conn,
                  const char *stmtName,
                  const char *query,
                  int nParams,
                  const Oid *paramTypes);
</synopsis>

<!-- 
       This is an asynchronous version of <function>PQprepare</>: it
       returns 1 if it was able to dispatch the request, and 0 if not.
       After a successful call, call <function>PQgetResult</function> to
       determine whether the server successfully created the prepared
       statement.  The function's parameters are handled identically to
       <function>PQprepare</function>.  Like
       <function>PQprepare</function>, it will not work on 2.0-protocol
       connections. 
-->
这是<function>PQprepare</>的异步版本：如果它能发送这个请求，则返回 1，如果不能，则返回 0。
在成功调用之后，调用<function>PQgetResult</function>判断服务器是否成功创建了预备语句。
这个函数的参数的处理和<function>PQprepare</function>一样。类似<function>PQprepare</function>，
它不能在 2.0 版本协议的连接上运转。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsendqueryprepared">
     <term>
      <function>PQsendQueryPrepared</function>
      <indexterm>
       <primary>PQsendQueryPrepared</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       Sends a request to execute a prepared statement with given
       parameters, without waiting for the result(s).
-->
发送一个请求执行带有给出参数的预备语句，不等待结果。
<synopsis>
int PQsendQueryPrepared(PGconn *conn,
                        const char *stmtName,
                        int nParams,
                        const char * const *paramValues,
                        const int *paramLengths,
                        const int *paramFormats,
                        int resultFormat);
</synopsis>

<!-- 
       This is similar to <function>PQsendQueryParams</function>, but
       the command to be executed is specified by naming a
       previously-prepared statement, instead of giving a query string.
       The function's parameters are handled identically to
       <function>PQexecPrepared</function>.  Like
       <function>PQexecPrepared</function>, it will not work on
       2.0-protocol connections. 
-->
这个函数类似<function>PQsendQueryParams</function>，
但是要执行的命令是通过给一个前面准备好的语句命名来声明的，而不是给出一个查询字串。
函数的参数处理和<function>PQexecPrepared</function>一样。
类似<function>PQexecPrepared</function>，它也不能在 2.0 版本的协议连接上工作。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsenddescribeprepared">
     <term>
      <function>PQsendDescribePrepared</>
      <indexterm>
       <primary>PQsendDescribePrepared</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       Submits a request to obtain information about the specified
       prepared statement, without waiting for completion.
-->
提交一个请求，获取关于指定的预备语句的信息，不等待结果。
<synopsis>
int PQsendDescribePrepared(PGconn *conn, const char *stmtName);
</synopsis>

<!-- 
       This is an asynchronous version of <function>PQdescribePrepared</>:
       it returns 1 if it was able to dispatch the request, and 0 if not.
       After a successful call, call <function>PQgetResult</function> to
       obtain the results.  The function's parameters are handled
       identically to <function>PQdescribePrepared</function>.  Like
       <function>PQdescribePrepared</function>, it will not work on
       2.0-protocol connections. 
-->
这是<function>PQdescribePrepared</>的一个异步版本：如果它能发送这个请求，则返回 1，
如果不能，则返回 0。在成功调用之后，调用<function>PQgetResult</function>获取结果。
这个函数的参数的处理和<function>PQdescribePrepared</function>一样。
类似<function>PQdescribePrepared</function>，它不能在 2.0 版本协议的连接上运转。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsenddescribeportal">
     <term>
      <function>PQsendDescribePortal</>
      <indexterm>
       <primary>PQsendDescribePortal</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       Submits a request to obtain information about the specified
       portal, without waiting for completion.
-->
发出请求，以获得关于指定端口的信息，不需要等待完成。
<synopsis>
int PQsendDescribePortal(PGconn *conn, const char *portalName);
</synopsis>

<!-- 
       This is an asynchronous version of <function>PQdescribePortal</>:
       it returns 1 if it was able to dispatch the request, and 0 if not.
       After a successful call, call <function>PQgetResult</function> to
       obtain the results.  The function's parameters are handled
       identically to <function>PQdescribePortal</function>.  Like
       <function>PQdescribePortal</function>, it will not work on
       2.0-protocol connections. 
-->
这是一个<function>PQdescribePortal</>的异步版本：如果它能发送这个请求，那么返回1，
否则返回0。成功调用之后，通过<function>PQgetResult</function>获得结果。
函数参数处理与<function>PQdescribePortal</function>相同。
类似于<function>PQdescribePortal</function>，不能在2.0的协议连接上工作。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqgetresult">
     <term>
      <function>PQgetResult</function>
      <indexterm>
       <primary>PQgetResult</primary>
      </indexterm>
     </term>

     <listitem>      
<para>
<!--
       Waits for the next result from a prior
       <function>PQsendQuery</function>,
       <function>PQsendQueryParams</function>,
       <function>PQsendPrepare</function>,
       <function>PQsendQueryPrepared</function>,
       <function>PQsendDescribePrepared</function>, or
       <function>PQsendDescribePortal</function>
       call, and returns it.
       A null pointer is returned when the command is complete and there
       will be no more results.
-->
等待从前面<function>PQsendQuery</function>，<function>PQsendQueryParams</function>，
<function>PQsendPrepare</function>，<function>PQsendQueryPrepared</function>，
<function>PQsendDescribePrepared</function>或者<function>PQsendDescribePortal</function>
调用返回的下一个结果，然后返回之。当命令结束并且没有更多结果后返回 NULL。
<synopsis>
PGresult *PQgetResult(PGconn *conn);
</synopsis>
      </para>

      <!--
<para>
       <function>PQgetResult</function> must be called repeatedly until
       it returns a null pointer, indicating that the command is done.
       (If called when no command is active,
       <function>PQgetResult</function> will just return a null pointer
       at once.) Each non-null result from
       <function>PQgetResult</function> should be processed using the
       same <structname>PGresult</> accessor functions previously
       described.  Don't forget to free each result object with
       <function>PQclear</function> when done with it.  Note that
       <function>PQgetResult</function> will block only if a command is
       active and the necessary response data has not yet been read by
       <function>PQconsumeInput</function>.
      </para>
-->
<para>
必须重复的调用<function>PQgetResult</function>，直到它返回空指针，表明该命令结束。
（如果在没有活跃的命令时调用，<function>PQgetResult</function>将只是立即返回一个空指针。）
每个<function>PQgetResult</function>返回的非 NULL 结果都应该用前面描述的
<structname>PGresult</>访问函数进行分析。不要忘了在结束分析后用<function>PQclear</function>
释放每个结果对象。注意，<function>PQgetResult</function>
只是在有一个命令是活跃的而且必须返回数的据还没有被<function>PQconsumeInput</function>读取时阻塞。
</para>

      <note>
       <!--
<para>
        Even when <function>PQresultStatus</function> indicates a fatal
        error, <function>PQgetResult</function> should be called until it
        returns a null pointer, to allow <application>libpq</> to
        process the error information completely.
       </para>
-->
<para>
即使在<function>PQresultStatus</function>表明一个致命的错误时，
也应该调用<function>PQgetResult</function>直到它返回一个空指针，
以允许<application>libpq</>完全的处理错误消息。
</para>
      </note>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <!--
<para>
   Using <function>PQsendQuery</function> and
   <function>PQgetResult</function> solves one of
   <function>PQexec</function>'s problems:  If a command string contains
   multiple <acronym>SQL</acronym> commands, the results of those commands
   can be obtained individually.  (This allows a simple form of overlapped
   processing, by the way: the client can be handling the results of one
   command while the server is still working on later queries in the same
   command string.)
  </para>
-->
<para>
使用<function>PQsendQuery</function>和<function>PQgetResult</function>解决了
<function>PQexec</function>的一个问题：如果一个命令字符串包含多个
<acronym>SQL</acronym>命令，这些命令的结果可以独立的获得。（这样就允许一种简单的重叠处理模式，
顺便说一句：客户端可以处理一个命令的结果而服务器可以仍然在处理同一命令字符串后面的查询。）
</para>

  <!--
<para>
   Another frequently-desired feature that can be obtained with
   <function>PQsendQuery</function> and <function>PQgetResult</function>
   is retrieving large query results a row at a time.  This is discussed
   in <xref linkend="libpq-single-row-mode">.
  </para>
-->
<para>
另一个可以用<function>PQsendQuery</function>和<function>PQgetResult</function>
获得的经常需要的特性是一次检索大型连续查询结果。这在
<xref linkend="libpq-single-row-mode">中讨论。
</para>

  
<para>
<!-- 
   By itself, calling <function>PQgetResult</function>
   will still cause the client to block until the server completes the
   next <acronym>SQL</acronym> command.  This can be avoided by proper
   use of two more functions:
-->
单独的，调用<function>PQgetResult</function>将仍然导致客户端阻塞，
直到服务器完成下一个<acronym>SQL</acronym>命令。可以通过适当的使用两个函数避免：
   <variablelist>
    <varlistentry id="libpq-pqconsumeinput">
     <term>
      <function>PQconsumeInput</function>
      <indexterm>
       <primary>PQconsumeInput</primary>
      </indexterm>
     </term>

     <listitem>

      <para>
<!--
       If input is available from the server, consume it.
-->
如果存在服务器来的输入可用，则使用之。
<synopsis>
int PQconsumeInput(PGconn *conn);
</synopsis>
      </para>

      <!--
<para>
       <function>PQconsumeInput</function> normally returns 1 indicating
       <quote>no error</quote>, but returns 0 if there was some kind of
       trouble (in which case <function>PQerrorMessage</function> can be
       consulted).  Note that the result does not say whether any input
       data was actually collected. After calling
       <function>PQconsumeInput</function>, the application can check
       <function>PQisBusy</function> and/or
       <function>PQnotifies</function> to see if their state has changed.
      </para>
-->
<para>
<function>PQconsumeInput</function>通常返回 1 表明<quote>没有错误</quote>，
而返回 0 表明有某种错误发生，（这个时候可以用<function>PQerrorMessage</function>）。
注意这个结果并不表明实际上是否收集了输入数据。在调用<function>PQconsumeInput</function>
之后，应用可以检查<function>PQisBusy</function>和/或<function>PQnotifies</function>
看一眼它们的状态是否改变。
</para>

      <!--
<para>
       <function>PQconsumeInput</function> can be called even if the
       application is not prepared to deal with a result or notification
       just yet.  The function will read available data and save it in
       a buffer, thereby causing a <function>select()</function>
       read-ready indication to go away.  The application can thus use
       <function>PQconsumeInput</function> to clear the
       <function>select()</function> condition immediately, and then
       examine the results at leisure.
      </para>
-->
<para>
<function>PQconsumeInput</function>可以在应用还没有做好处理结果或通知的情况下被调用。
这个函数将读取可用的数据并且在一个缓冲区里保存它，这样导致一个<function>select()</function>
读准备好标识的生成。这样应用就可以使用<function>PQconsumeInput</function>
立即清掉<function>select()</function>条件，然后在空闲的时候检查结果。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqisbusy">
     <term>
      <function>PQisBusy</function>
      <indexterm>
       <primary>PQisBusy</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       Returns 1 if a command is busy, that is,
       <function>PQgetResult</function> would block waiting for input.
       A 0 return indicates that <function>PQgetResult</function> can be
       called with assurance of not blocking.
-->
在查询忙的时候返回 1 ，也就是说，<function>PQgetResult</function>将阻塞住等待输入。
一个 0 的返回表明这时调用<function>PQgetResult</function>保证不阻塞。
<synopsis>
int PQisBusy(PGconn *conn);
</synopsis>
      </para>

      <!--
<para>
       <function>PQisBusy</function> will not itself attempt to read data
       from the server; therefore <function>PQconsumeInput</function>
       must be invoked first, or the busy state will never end.
      </para>
-->
<para>
<function>PQisBusy</function>本身将不会试图从服务器读取数据；
所以必须先调用<function>PQconsumeInput</function>，否则将永远不会消除忙状态。
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <!--
<para>
   A typical application using these functions will have a main loop that
   uses <function>select()</function> or <function>poll()</> to wait for
   all the conditions that it must respond to.  One of the conditions
   will be input available from the server, which in terms of
   <function>select()</function> means readable data on the file
   descriptor identified by <function>PQsocket</function>.  When the main
   loop detects input ready, it should call
   <function>PQconsumeInput</function> to read the input.  It can then
   call <function>PQisBusy</function>, followed by
   <function>PQgetResult</function> if <function>PQisBusy</function>
   returns false (0).  It can also call <function>PQnotifies</function>
   to detect <command>NOTIFY</> messages (see <xref
   linkend="libpq-notify">).
  </para>
-->
<para>
一个使用这些函数的典型的应用将有一个主循环使用<function>select()</function>
或<function>poll()</>等待所有它必须处理的条件。其中一个条件将会是服务器来的数据已准备好，
从<function>select()</function>的角度来看就是<function>PQsocket</function>
标识的文件描述符上已经有可读取的数据。当主循环侦测到输入准备好，
它将调用<function>PQconsumeInput</function>读取输入。然后可以调用<function>PQisBusy</function>，
返回 false (0)后面可以跟着<function>PQgetResult</function>。同样它（用户应用）
可以调用<function>PQnotifies</function>检测<command>NOTIFY</>信息
（参阅<xref linkend="libpq-notify">）。
</para>

  <!--
<para>
   A client that uses
   <function>PQsendQuery</function>/<function>PQgetResult</function>
   can also attempt to cancel a command that is still being processed
   by the server; see <xref linkend="libpq-cancel">.  But regardless of
   the return value of <function>PQcancel</function>, the application
   must continue with the normal result-reading sequence using
   <function>PQgetResult</function>.  A successful cancellation will
   simply cause the command to terminate sooner than it would have
   otherwise.
  </para>
-->
<para>
一个使用<function>PQsendQuery</function>/<function>PQgetResult</function>
的客户端同样也可以试图取消一个正在被服务器处理的命令。参阅<xref linkend="libpq-cancel">。
但是，不管<function>PQcancel</function>返回的值是多少，应用都必须使用
<function>PQgetResult</function>进行正常的读取结果的动作序列。
一次成功的取消只会导致命令比正常情况下快些结束。
</para>

  
<para>
<!-- 
   By using the functions described above, it is possible to avoid
   blocking while waiting for input from the database server.  However,
   it is still possible that the application will block waiting to send
   output to the server.  This is relatively uncommon but can happen if
   very long SQL commands or data values are sent.  (It is much more
   probable if the application sends data via <command>COPY IN</command>,
   however.)  To prevent this possibility and achieve completely
   nonblocking database operation, the following additional functions
   can be used.
-->
通过使用上面描述的函数，我们可以避免在等待来自数据库服务器的输入时的阻塞。
不过，应用还是有可能阻塞在给服务器发送输出上。这种情况比较少见，但是也可能发生，
尤其是我们要发送非常长的 SQL 命令或者数据值的时候。（不过，
最有可能的是在应用通过<command>COPY IN</command>发送数据的时候。）为了避免这个可能性，
实现完全的非阻塞数据库操作，我们可以使用下列额外的函数。
   <variablelist>
    <varlistentry id="libpq-pqsetnonblocking">
     <term>
      <function>PQsetnonblocking</function>
      <indexterm>
       <primary>PQsetnonblocking</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!-- 
      Sets the nonblocking status of the connection.
-->
把连接的状态设置为非阻塞。
<synopsis>
int PQsetnonblocking(PGconn *conn, int arg);
</synopsis>
      </para>

      <!--
<para>
       Sets the state of the connection to nonblocking if
       <parameter>arg</parameter> is 1, or blocking if
       <parameter>arg</parameter> is 0.  Returns 0 if OK, -1 if error.
      </para>
-->
<para>
如果<parameter>arg</parameter>为 1，把连接状态设置为非阻塞，
如果<parameter>arg</parameter>为 0，把连接状态设置为阻塞。如果 OK 返回 0，如果错误返回 -1。
</para>

      <!--
<para>
       In the nonblocking state, calls to
       <function>PQsendQuery</function>, <function>PQputline</function>,
       <function>PQputnbytes</function>, and
       <function>PQendcopy</function> will not block but instead return
       an error if they need to be called again.
      </para>
-->
<para>
在非阻塞状态，调用<function>PQsendQuery</function>，<function>PQputline</function>，
<function>PQputnbytes</function>，和<function>PQendcopy</function>的时候不被阻塞，
而是在如果需要再次调用它们时将返回一个错误。
</para>

      <!--
<para>
       Note that <function>PQexec</function> does not honor nonblocking
       mode; if it is called, it will act in blocking fashion anyway.
      </para>
-->
<para>
请注意<function>PQexec</function>不会在意任何非阻塞模式；如果调用了
<function>PQexec</function>，那么它的行为总是阻塞的。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqisnonblocking">
     <term>
      <function>PQisnonblocking</function>
      <indexterm>
       <primary>PQisnonblocking</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       Returns the blocking status of the database connection.
-->
返回数据库连接的阻塞状态。
<synopsis>
int PQisnonblocking(const PGconn *conn);
</synopsis>
      </para>

      <!--
<para>
       Returns 1 if the connection is set to nonblocking mode and 0 if
       blocking.
      </para>
-->
<para>
如果连接设置为非阻塞状态，返回 1，如果是阻塞状态返回 0。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqflush">
     <term>
      <function>PQflush</function>
       <indexterm>
        <primary>PQflush</primary>
       </indexterm>
      </term>

      <listitem>      
<para>
<!--
       Attempts to flush any queued output data to the server.  Returns
       0 if successful (or if the send queue is empty), -1 if it failed
       for some reason, or 1 if it was unable to send all the data in
       the send queue yet (this case can only occur if the connection
       is nonblocking).
-->
试图把任何正在排队的数据冲刷到服务器，如果成功（或者发送队列为空）返回 0，
如果因某种原因失败返回 -1，或者是在无法把发送队列中的所有数据都发送出去，返回 1。
（这种情况只有在连接为不阻塞模式的时候才会出现）。
<synopsis>
int PQflush(PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <!--
<para>
   After sending any command or data on a nonblocking connection, call
   <function>PQflush</function>.  If it returns 1, wait for the socket
   to become read- or write-ready.  If it becomes write-ready, call
   <function>PQflush</function> again.  If it becomes read-ready, call
   <function>PQconsumeInput</function>, then call
   <function>PQflush</function> again.  Repeat until
   <function>PQflush</function> returns 0.  (It is necessary to check for
   read-ready and drain the input with <function>PQconsumeInput</function>,
   because the server can block trying to send us data, e.g. NOTICE
   messages, and won't read our data until we read its.)  Once
   <function>PQflush</function> returns 0, wait for the socket to be
   read-ready and then read the response as described above.
  </para>
-->
<para>
在一个非阻塞的连接上发送任何命令或者数据之后，调用<function>PQflush</function>。
如果返回 1，就等待套接字写准备好或者读准备好。如果它变成读准备好，则再次调用
<function>PQflush</function>。如果它变成写准备好，则调用<function>PQconsumeInput</function>，
然后再次调用<function>PQflush</function>。重复这个操作直到它返回 0。
（有必要检查读准备好并使用<function>PQconsumeInput</function>耗尽输入，
因为服务器可以阻塞尝试发送我们的数据，比如NOTICE信息，并且不会读取我们的数据，
直到我们读取它。）一旦<function>PQflush</function>返回 0，
则等待套接字为读准备好，准备好之后就像上面那样读取响应。
</para>

 </sect1>

 <sect1 id="libpq-single-row-mode">
  <!--
  <title>Retrieving Query Results Row-By-Row</title>
  -->
  <title>逐行检索查询结果</title>

  <indexterm zone="libpq-single-row-mode">
   <primary>libpq</primary>
   <!-- <secondary>single-row mode</secondary> -->
   <secondary>单行模式</secondary>
  </indexterm>

  <!--
<para>
   Ordinarily, <application>libpq</> collects a SQL command's
   entire result and returns it to the application as a single
   <structname>PGresult</structname>.  This can be unworkable for commands
   that return a large number of rows.  For such cases, applications can use
   <function>PQsendQuery</function> and <function>PQgetResult</function> in
   <firstterm>single-row mode</>.  In this mode, the result row(s) are
   returned to the application one at a time, as they are received from the
   server.
  </para>
-->
<para>
通常，<application>libpq</>收集SQL命令的全部结果并作为单个<structname>PGresult</structname>
返回到应用中。这对于返回大量行的命令是不可能实现的。对于这种情况，
应用可以在<firstterm>单行模式</>中使用<function>PQsendQuery</function>和<function>PQgetResult</function>。
在这个模式中，结果行一次返回一行到应用中，就像从服务器中接收到它们一样。
</para>

  <!--
<para>
   To enter single-row mode, call <function>PQsetSingleRowMode</function>
   immediately after a successful call of <function>PQsendQuery</function>
   (or a sibling function).  This mode selection is effective only for the
   currently executing query.  Then call <function>PQgetResult</function>
   repeatedly, until it returns null, as documented in <xref
   linkend="libpq-async">.  If the query returns any rows, they are returned
   as individual <structname>PGresult</structname> objects, which look like
   normal query results except for having status code
   <literal>PGRES_SINGLE_TUPLE</literal> instead of
   <literal>PGRES_TUPLES_OK</literal>.  After the last row, or immediately if
   the query returns zero rows, a zero-row object with status
   <literal>PGRES_TUPLES_OK</literal> is returned; this is the signal that no
   more rows will arrive.  (But note that it is still necessary to continue
   calling <function>PQgetResult</function> until it returns null.)  All of
   these <structname>PGresult</structname> objects will contain the same row
   description data (column names, types, etc) that an ordinary
   <structname>PGresult</structname> object for the query would have.
   Each object should be freed with <function>PQclear</function> as usual.
  </para>
-->
<para>
要进入单行模式，在成功调用<function>PQsendQuery</function>（或者一个兄弟函数）
之后立即调用<function>PQsetSingleRowMode</function>。这种模式选择只对当前执行的查询有效。
然后重复的调用<function>PQgetResult</function>，直到它返回空，在<xref linkend="libpq-async">
中记录。如果查询返回任意行，它们作为独立的<structname>PGresult</structname>对象返回，
就像普通的查询结果，除了状态码是<literal>PGRES_SINGLE_TUPLE</literal>而不是
<literal>PGRES_TUPLES_OK</literal>。在最后一行之后，或者一旦查询返回零行，
返回一个带有状态<literal>PGRES_TUPLES_OK</literal>的零行对象；
这是没有更多行的一个信号。（但是，请注意，仍然需要继续调用<function>PQgetResult</function>
直到它返回空。）所有这些<structname>PGresult</structname>对象将包含相同的描述数据
（字段名、类型等），就像该查询的一个普通<structname>PGresult</structname>对象拥有的那样。
像往常一样，每个对象都应该使用<function>PQclear</function>释放。
</para>

  
<para>
   <variablelist>
    <varlistentry id="libpq-pqsetsinglerowmode">
     <term>
      <function>PQsetSingleRowMode</function>
      <indexterm>
       <primary>PQsetSingleRowMode</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Select single-row mode for the currently-executing query.
-->
为当前执行的查询选择单行模式。
<synopsis>
int PQsetSingleRowMode(PGconn *conn);
</synopsis>
      </para>

      <!--
<para>
       This function can only be called immediately after
       <function>PQsendQuery</function> or one of its sibling functions,
       before any other operation on the connection such as
       <function>PQconsumeInput</function> or
       <function>PQgetResult</function>.  If called at the correct time,
       the function activates single-row mode for the current query and
       returns 1.  Otherwise the mode stays unchanged and the function
       returns 0.  In any case, the mode reverts to normal after
       completion of the current query.
      </para>
-->
<para>
这个函数只能在<function>PQsendQuery</function>或它的一个兄弟函数之后立即调用，
在任何连接上的其他操作，比如<function>PQconsumeInput</function>或
<function>PQgetResult</function>之前。如果在正确的时间调用了，
该函数为当前查询激活单行模式并返回1。否则模式保持不变并返回0。在任何情况下，
该模式在当前查询完成之后恢复到正常。
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <caution>
   <!--
<para>
    While processing a query, the server may return some rows and then
    encounter an error, causing the query to be aborted.  Ordinarily,
    <application>libpq</> discards any such rows and reports only the
    error.  But in single-row mode, those rows will have already been
    returned to the application.  Hence, the application will see some
    <literal>PGRES_SINGLE_TUPLE</literal> <structname>PGresult</structname>
    objects followed by a <literal>PGRES_FATAL_ERROR</literal> object.  For
    proper transactional behavior, the application must be designed to
    discard or undo whatever has been done with the previously-processed
    rows, if the query ultimately fails.
   </para>
-->
<para>
处理一个查询时，服务器可能返回一些行然后遇到一个错误，导致查询退出。通常，
<application>libpq</>丢弃任何这样的行并且只报告错误。但是在单行模式中，
这些行将早已返回到应用中。因此，应用将看到一些
<literal>PGRES_SINGLE_TUPLE</literal> <structname>PGresult</structname>
对象跟随在<literal>PGRES_FATAL_ERROR</literal>对象后面。对于适当的事务行为，
如果查询最终失败了，那么应用必须设计为抛弃或撤销先前处理的行。
</para>
  </caution>

 </sect1>

 <sect1 id="libpq-cancel">
  <!--
  <title>Canceling Queries in Progress</title>
  -->
  <title>取消正在处理的查询</title>

  <indexterm zone="libpq-cancel">
   <!--
   <primary>canceling</primary>
   <secondary>SQL command</secondary>
   -->
   <primary>取消</primary>
   <secondary>SQL 命令</secondary>
  </indexterm>

  
<para>
<!-- 
   A client application can request cancellation of a command that is
   still being processed by the server, using the functions described in
   this section.
-->
一个客户端应用可以使用本节描述的函数，要求取消一个仍在被服务器处理的命令。
   <variablelist>
    <varlistentry id="libpq-pqgetcancel">
     <term>
      <function>PQgetCancel</function>
      <indexterm>
       <primary>PQgetCancel</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Creates a data structure containing the information needed to cancel
       a command issued through a particular database connection.
-->
创建一个数据结构，这个数据结构包含通过特定数据库连接取消一个命令所需要的信息。
<synopsis>
PGcancel *PQgetCancel(PGconn *conn);
</synopsis>
      </para>

      <!--
<para>
       <function>PQgetCancel</function> creates a
       <structname>PGcancel</><indexterm><primary>PGcancel</></> object
       given a <structname>PGconn</> connection object.  It will return
       <symbol>NULL</> if the given <parameter>conn</> is <symbol>NULL</> or an invalid
       connection.  The <structname>PGcancel</> object is an opaque
       structure that is not meant to be accessed directly by the
       application; it can only be passed to <function>PQcancel</function>
       or <function>PQfreeCancel</function>.
      </para>
-->
<para>
给出一个<structname>PGconn</>连接对象，<function>PQgetCancel</function>创建一个
<structname>PGcancel</><indexterm><primary>PGcancel</></>对象。如果给出的<parameter>conn</>
是<symbol>NULL</>或者是一个无效的连接，那么它将返回<symbol>NULL</>。
<structname>PGcancel</>对象是一个不透明的结构，不应该为应用所直接访问；
我们只能把它传递给<function>PQcancel</function>或者<function>PQfreeCancel</function>。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfreecancel">
     <term>
      <function>PQfreeCancel</function>
      <indexterm>
       <primary>PQfreeCancel</primary>
      </indexterm>
     </term>

     <listitem>      
<para>
<!--
       Frees a data structure created by <function>PQgetCancel</function>.
-->
释放<function>PQgetCancel</function>创建的数据结构。
<synopsis>
void PQfreeCancel(PGcancel *cancel);
</synopsis>
      </para>

      <!--
<para>
       <function>PQfreeCancel</function> frees a data object previously created
       by <function>PQgetCancel</function>.
      </para>
-->
<para>
<function>PQfreeCancel</function>释放一个由前面的<function>PQgetCancel</function>创建的数据对象。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqcancel">
     <term>
      <function>PQcancel</function>
      <indexterm>
       <primary>PQcancel</primary>
      </indexterm>
     </term>

     <listitem>     
<para>
<!--
       Requests that the server abandon processing of the current command.
-->
要求服务器放弃处理当前命令。
<synopsis>
int PQcancel(PGcancel *cancel, char *errbuf, int errbufsize);
</synopsis>
      </para>

      <!--
<para>
       The return value is 1 if the cancel request was successfully
       dispatched and 0 if not.  If not, <parameter>errbuf</> is filled
       with an explanatory error message.  <parameter>errbuf</>
       must be a char array of size <parameter>errbufsize</> (the
       recommended size is 256 bytes).
      </para>
-->
<para>
如果取消请求成功发送，则返回值为 1，否则为 0。如果不成功，则<parameter>errbuf</>
里面会填充解释的错误消息。<parameter>errbuf</>必须是一个大小为<parameter>errbufsize</>
的 char 数组（建议大小为 256 字节）。
</para>

      <!--
<para>
       Successful dispatch is no guarantee that the request will have
       any effect, however.  If the cancellation is effective, the current
       command will terminate early and return an error result.  If the
       cancellation fails (say, because the server was already done
       processing the command), then there will be no visible result at
       all.
      </para>
-->
<para>
不过，成功发送取消请求并不保证请求会有任何效果。如果取消生效，
那么当前的命令将提前结束并且返回一个错误的结果。如果取消失败（也就是说，
因为服务器已经完成命令的处理），那么就根本不会有可见的结果。
</para>

      <!--
<para>
       <function>PQcancel</function> can safely be invoked from a signal
       handler, if the <parameter>errbuf</> is a local variable in the
       signal handler.  The <structname>PGcancel</> object is read-only
       as far as <function>PQcancel</function> is concerned, so it can
       also be invoked from a thread that is separate from the one
       manipulating the <structname>PGconn</> object.
      </para>
-->
<para>
如果<parameter>errbuf</>是信号句柄里的一个局部变量，那么<function>PQcancel</function>
可以在一个信号句柄里安全地调用。在<function>PQcancel</function>涉及的范围里，
<structname>PGcancel</>对象都是只读的， 因此我们也可以从一个与处理<structname>PGconn</>
对象的线程分离的线程里处理它。
</para>
     </listitem>
    </varlistentry>
   </variablelist>

   <variablelist>
    <varlistentry id="libpq-pqrequestcancel">
     <term>
      <function>PQrequestCancel</function>
      <indexterm>
       <primary>PQrequestCancel</primary>
      </indexterm>
     </term>

     <listitem>     
<para>
<!--
       <function>PQrequestCancel</function> is a deprecated variant of
       <function>PQcancel</function>.
-->
<function>PQrequestCancel</function>是<function>PQcancel</function>的一个废弃的变种。
<synopsis>
int PQrequestCancel(PGconn *conn);
</synopsis>
      </para>

      <!--
<para>
       Requests that the server abandon processing of the current
       command.  It operates directly on the
       <structname>PGconn</> object, and in case of failure stores the
       error message in the <structname>PGconn</> object (whence it can
       be retrieved by <function>PQerrorMessage</function>).  Although
       the functionality is the same, this approach creates hazards for
       multiple-thread programs and signal handlers, since it is possible
       that overwriting the <structname>PGconn</>'s error message will
       mess up the operation currently in progress on the connection.
      </para>
-->
<para>
要求服务器放弃对当前命令的处理。它直接在<structname>PGconn</>对象上进行操作，
并且如果失败，就会在<structname>PGconn</>对象里存储错误消息（因此可以用
<function>PQerrorMessage</function>检索出来。）尽管功能一样，
但是这个方法在多线程程序里和信号句柄里会有危险，因为它可能覆盖<structname>PGconn</>
的错误消息，因此将可能把当前连接正在处理的操作打乱。
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

 </sect1>

 <sect1 id="libpq-fastpath">
  <!--
  <title>The Fast-Path Interface</title>
  -->
  <title>捷径接口</title>

  <indexterm zone="libpq-fastpath">
   <!--
   <primary>fast path</primary>
   -->
   <primary>快速通道</primary>
  </indexterm>

  <!--
<para>
   <productname>PostgreSQL</productname> provides a fast-path interface
   to send simple function calls to the server.
  </para>
-->
<para>
<productname>PostgreSQL</productname>提供一个向服务器发送简单的函数调用的捷径接口。
</para>

  <tip>
   <!--
<para>
    This interface is somewhat obsolete, as one can achieve similar
    performance and greater functionality by setting up a prepared
    statement to define the function call.  Then, executing the statement
    with binary transmission of parameters and results substitutes for a
    fast-path function call.
   </para>
-->
<para>
这个接口在某种程度上已经废弃了，因为我们可以通过设置一个预备语句来定义函数调用，
从而达到类似的性能和更强大的功能。然后，用二进制参数和结果传输执行该语句，替换一次捷径函数调用。
</para>
  </tip>

  
<para>
<!--
   The function <function>PQfn</function><indexterm><primary>PQfn</></>
   requests execution of a server function via the fast-path interface:
-->
函数<function>PQfn</function><indexterm><primary>PQfn</></>请求允许通过捷径接口执行服务器函数。
<synopsis>
PGresult *PQfn(PGconn *conn,
               int fnid,
               int *result_buf,
               int *result_len,
               int result_is_int,
               const PQArgBlock *args,
               int nargs);

typedef struct
{
    int len;
    int isint;
    union
    {
        int *ptr;
        int integer;
    } u;
} PQArgBlock;
</synopsis>
  </para>

  <!--
<para>
   The <parameter>fnid</> argument is the OID of the function to be
   executed.  <parameter>args</> and <parameter>nargs</> define the
   parameters to be passed to the function; they must match the declared
   function argument list.  When the <parameter>isint</> field of a
   parameter structure is true, the <parameter>u.integer</> value is sent
   to the server as an integer of the indicated length (this must be 1,
   2 or 4 bytes); proper byte-swapping occurs.  When <parameter>isint</>
   is false, the indicated number of bytes at <parameter>*u.ptr</> are
   sent with no processing; the data must be in the format expected by
   the server for binary transmission of the function's argument data
   type.  (The declaration of <parameter>u.ptr</> as being of
   type <type>int *</> is historical; it would be better to consider
   it <type>void *</>.)
   <parameter>result_buf</parameter> points to the buffer in which to place
   the function's return value.  The caller must  have  allocated sufficient
   space to store the return value.  (There is no check!) The actual result
   length in bytes will be returned in the integer pointed to  by
   <parameter>result_len</parameter>.  If a 2- or 4-byte integer result
   is expected, set <parameter>result_is_int</parameter> to 1, otherwise
   set it to 0.  Setting <parameter>result_is_int</parameter> to 1 causes
   <application>libpq</> to byte-swap the value if necessary, so that it
   is delivered as a proper <type>int</type> value for the client machine;
   note that a 4-byte integer is delivered into <parameter>*result_buf</>
   for either allowed result size.   
   When <parameter>result_is_int</> is 0, the binary-format byte string
   sent by the server is returned unmodified. (In this case it's better
   to consider <parameter>result_buf</parameter> as being of
   type <type>void *</>.)
  </para>
-->
<para>
<parameter>fnid</>参数是待执行的函数的对象标识（OID）。<parameter>args</>和<parameter>nargs</>
定义了要传递给函数的参数；它们必须匹配已经声明了的函数参数列表。如果某个参数结构的
<parameter>isint</>字段是真，那么<parameter>u.integer</>值以指定长度（必须是1，2 或者 4 字节）
的整数发送给服务器；这时候会进行恰当的字节序交换（byte-swapping）。如果<parameter>isint</>为假，
那么在<parameter>*u.ptr</>里面的指定字节数的数据将不做任何处理发送出去；
这些数据必须是服务器预期的该函数参数类型的二进制传输格式。
（类型为<type>int *</>的<parameter>u.ptr</>的声明是过去式了；最好认为它是<type>void *</>。）
<parameter>result_buf</parameter>指向放置该函数的返回值的缓冲区。
调用者必须为返回值分配足够的空间（这里没有检查！）。
实际的返回值长度（以字节计）将被放在<parameter>result_len</parameter>指向的整数里返回。
如果预期返回值是 2 或 4 字节整数，把<parameter>result_is_int</parameter>设为 1；否则设为 0。
把<parameter>result_is_int</parameter>设为 1 告诉<application>libpq</>必要时交换数值字节序，
这样就可以正确地传输成客户机上的<type>int</type>值；请注意，为了每种允许的结果尺寸，
传递4字节整数到<parameter>*result_buf</>。当<parameter>result_is_int</>是 0 时，
服务器发送回来的字节串不做修改直接返回。（在这种情况下，
最好认为<parameter>result_buf</parameter>是类型<type>void *</>。）
</para>

  <!--
<para>
   <function>PQfn</function> always returns a valid
   <structname>PGresult</structname> pointer. The result status should be
   checked before the result is used.   The caller is responsible for
   freeing  the  <structname>PGresult</structname>  with
   <function>PQclear</function> when it is no longer needed.
  </para>
-->
<para>
<function>PQfn</function>总是返回一个有效的<structname>PGresult</structname>指针。
在使用结果之前应该检查结果状态。当结果不再使用后，调用者有义务使用
<function>PQclear</function>释放<structname>PGresult</structname>。
</para>

  <!--
<para>
   Note that it is not possible to handle null arguments, null results,
   nor set-valued results when using this interface.
  </para>
-->
<para>
请注意我们没办法处理空值的参数，空的结果，也没办法在使用这个接口的时候设置有值的结果。
</para>

 </sect1>

 <sect1 id="libpq-notify">
  <!--
  <title>Asynchronous Notification</title>
  -->
  <title>异步通知</title>

  <indexterm zone="libpq-notify">
   <primary>NOTIFY</primary>
   <!-- 
   <secondary>in libpq</secondary>
   -->
   <secondary>在libpq中</secondary>
  </indexterm>

  <!--
<para>
   <productname>PostgreSQL</productname> offers asynchronous notification
   via the <command>LISTEN</command> and <command>NOTIFY</command>
   commands.  A client session registers its interest in a particular
   notification channel with the <command>LISTEN</command> command (and
   can stop listening with the <command>UNLISTEN</command> command).  All
   sessions listening on a particular channel will be notified
   asynchronously when a <command>NOTIFY</command> command with that
   channel name is executed by any session. A <quote>payload</> string can
   be passed to communicate additional data to the listeners.
  </para>
-->
<para>
<productname>PostgreSQL</productname>通过<command>LISTEN</command>和<command>NOTIFY</command>
命令提供对异步通知的支持。一个客户端会话用<command>LISTEN</command>命令注册一个它感兴趣的通知条件
（也可以用<command>UNLISTEN</command>命令停止监听）。所有正在监听某一通知条件的会话在该条件名的
<command>NOTIFY</command>（通知）被任何会话执行后都将被异步地通知。
一个<quote>payload</>可以向听众传达额外的数据。
</para>

  <!--
<para>
   <application>libpq</application> applications submit
   <command>LISTEN</command>, <command>UNLISTEN</command>,
   and <command>NOTIFY</command> commands as
   ordinary SQL commands.  The arrival of <command>NOTIFY</command>
   messages can subsequently be detected by calling
   <function>PQnotifies</function>.<indexterm><primary>PQnotifies</></>
  </para>
-->
<para>
<application>libpq</application>应用把<command>LISTEN</command>，<command>UNLISTEN</command>
和<command>NOTIFY</command>命令作为普通的 SQL 命令提交。随后通过调用
<function>PQnotifies</function><indexterm><primary>PQnotifies</></>可以侦测到<command>NOTIFY</command>消息的到达。
</para>

<para>
<!-- 
   The function <function>PQnotifies</function> returns the next notification
   from a list of unhandled notification messages received from the server.
   It returns a null pointer if there are no pending notifications.  Once a
   notification is returned from <function>PQnotifies</>, it is considered
   handled and will be removed from the list of notifications.
-->
函数<function>PQnotifies</function>从一个来自服务器的未处理的通知信息列表中返回下一条通知。
如果没有未处理的消息则返回 NULL 指针。一旦<function>PQnotifies</>返回一条通知，
该通知会被认为已处理并且将被从通知列表中删除。
<synopsis>
PGnotify *PQnotifies(PGconn *conn);

typedef struct pgNotify
{
    char *relname;              /* <!-- notification channel name -->通知的通道名字 */
    int  be_pid;                /* <!-- process ID of notifying server process -->通知服务器进程的进程ID */
    char *extra;                /* <!-- notification payload string -->通知负载字符串 */
} PGnotify;
</synopsis>

<!-- 
   After processing a <structname>PGnotify</structname> object returned
   by <function>PQnotifies</function>, be sure to free it with
   <function>PQfreemem</function>.  It is sufficient to free the
   <structname>PGnotify</structname> pointer; the
   <structfield>relname</structfield> and <structfield>extra</structfield>
   fields do not represent separate allocations.  (The names of these fields
   are historical; in particular, channel names need not have anything to
   do with relation names.) 
-->
在处理完<function>PQnotifies</function>返回的<structname>PGnotify</structname>对象后，
别忘了用<function>PQfreemem</function>把它释放。释放<structname>PGnotify</structname>
指针就足够了；<structfield>relname</structfield>和<structfield>extra</structfield>
字段并未代表独立分配的内存。（这些领域的名称是历史性的，尤其是频道名称与名称没有什么关系。）
  </para>

  <!--
<para>
   <xref linkend="libpq-example-2"> gives a sample program that illustrates
   the use of asynchronous notification.
  </para>
-->
<para>
<xref linkend="libpq-example-2">给出了一个简单的程序，举例说明异步通知的使用。
</para>

  <!--
<para>
   <function>PQnotifies</function> does not actually read data from the
   server; it just returns messages previously absorbed by another
   <application>libpq</application> function.  In prior releases of
   <application>libpq</application>, the only way to ensure timely receipt
   of <command>NOTIFY</> messages was to constantly submit commands, even
   empty ones, and then check <function>PQnotifies</function> after each
   <function>PQexec</function>.  While this still works, it is deprecated
   as a waste of processing power.
  </para>
-->
<para>
<function>PQnotifies</function>实际上并不读取服务器数据；它只是返回被前面的另一个
<application>libpq</application>函数吸收的信息。在以前的<application>libpq</application>
版本里，周期性的收到<command>NOTIFY</>信息的唯一方法是持续的提交命令，
即使是空查询也可以，并且在每次<function>PQexec</function>后检查<function>PQnotifies</function>。
现在这个方法也还能工作，不过我们认为它太浪费处理器时间而废弃了它。
</para>

  <!--
<para>
   A better way to check for <command>NOTIFY</> messages when you have no
   useful commands to execute is to call
   <function>PQconsumeInput</function>, then check
   <function>PQnotifies</function>.  You can use
   <function>select()</function> to wait for data to arrive from the
   server, thereby using no <acronym>CPU</acronym> power unless there is
   something to do.  (See <function>PQsocket</function> to obtain the file
   descriptor number to use with <function>select()</function>.) Note that
   this will work OK whether you submit commands with
   <function>PQsendQuery</function>/<function>PQgetResult</function> or
   simply use <function>PQexec</function>.  You should, however, remember
   to check <function>PQnotifies</function> after each
   <function>PQgetResult</function> or <function>PQexec</function>, to
   see if any notifications came in during the processing of the command.
  </para>
-->
<para>
在你没有可用的命令提交时检查<command>NOTIFY</>消息的更好的方法是调用
<function>PQconsumeInput</function>，然后检查<function>PQnotifies</function>。
你可以使用<function>select()</function>来等待服务器数据的到达，
这样在没有数据可处理时可以不浪费<acronym>CPU</acronym>时间。（参阅
<function>PQsocket</function>获取用于<function>select()</function>的文件描述符。）
注意这种方法不管你使用<function>PQsendQuery</function>/<function>PQgetResult</function>
还是简单的<function>PQexec</function>来执行命令都能工作。不过，你应该记住在每次
<function>PQgetResult</function>或<function>PQexec</function>后检查
<function>PQnotifies</function>，看看在处理命令的过程中是否有通知到达。
</para>

 </sect1>

 <sect1 id="libpq-copy">
  <!--
  <title>Functions Associated with the <command>COPY</command> Command</title>
  -->
  <title>与<command>COPY</command>命令相关的函数</title>

  <indexterm zone="libpq-copy">
   <primary>COPY</primary>
   <secondary>with libpq</secondary>
  </indexterm>

  <!--
<para>
   The <command>COPY</command> command in
   <productname>PostgreSQL</productname> has options to read from or write
   to the network connection used by <application>libpq</application>.
   The functions described in this section allow applications to take
   advantage of this capability by supplying or consuming copied data.
  </para>
-->
<para>
<productname>PostgreSQL</productname>里的<command>COPY</command>命令里有用于
<application>libpq</application>从网络连接读出或者写入的选项。
本节描述的函数允许应用通过提供或者消耗拷贝数据，充分利用这个功能。
</para>

  <!--
<para>
   The overall process is that the application first issues the SQL
   <command>COPY</command> command via <function>PQexec</function> or one
   of the equivalent functions.  The response to this (if there is no
   error in the command) will be a <structname>PGresult</> object bearing
   a status code of <literal>PGRES_COPY_OUT</literal> or
   <literal>PGRES_COPY_IN</literal> (depending on the specified copy
   direction).  The application should then use the functions of this
   section to receive or transmit data rows.  When the data transfer is
   complete, another <structname>PGresult</> object is returned to indicate
   success or failure of the transfer.  Its status will be
   <literal>PGRES_COMMAND_OK</literal> for success or
   <literal>PGRES_FATAL_ERROR</literal> if some problem was encountered.
   At this point further SQL commands can be issued via
   <function>PQexec</function>.  (It is not possible to execute other SQL
   commands using the same connection while the <command>COPY</command>
   operation is in progress.)
  </para>
-->
<para>
整个过程是应用首先通过<function>PQexec</function>或者一个等效的函数发出
<command>COPY</command>命令。对这个命令的响应（如果命令无误）
将是一个带着状态码<literal>PGRES_COPY_OUT</literal>或者<literal>PGRES_COPY_IN</literal>
的<structname>PGresult</>（具体根据声明的拷贝方向）。
应用然后就应该使用本节的函数接受或者发送数据行。在数据传输结束之后，
返回另外一个<structname>PGresult</>对象以表明传输的成功或者失败。它的状态将是
<literal>PGRES_COMMAND_OK</literal>表示成功或者如果发生了一些问题，是
<literal>PGRES_FATAL_ERROR</literal>。这个时候开始我们可以通过<function>PQexec</function>
发出更多 SQL 命令。（<command>COPY</command>操作在处理的过程中，
我们不可能用同一个连接执行其它 SQL 命令。
</para>

  <!--
<para>
   If a <command>COPY</command> command is issued via
   <function>PQexec</function> in a string that could contain additional
   commands, the application must continue fetching results via
   <function>PQgetResult</> after completing the <command>COPY</command>
   sequence.  Only when <function>PQgetResult</> returns
   <symbol>NULL</symbol> is it certain that the <function>PQexec</function>
   command string is done and it is safe to issue more commands.
  </para>
-->
<para>
如果一个<command>COPY</command>是通过<function>PQexec</function>
在一个可以包含额外命令的字串里发出的，那么应用在完成<command>COPY</command>
序列之后必须继续用<function>PQgetResult</>抓取结果。只有在<function>PQgetResult</>
返回<symbol>NULL</symbol>的时候，我们才能确信<function>PQexec</function>
的命令字串已经处理完毕，并且已经可以安全地发出更多命令。
</para>

  <!--
<para>
   The functions of this section should be executed only after obtaining
   a result status of <literal>PGRES_COPY_OUT</literal> or
   <literal>PGRES_COPY_IN</literal> from <function>PQexec</function> or
   <function>PQgetResult</function>.
  </para>
-->
<para>
本节的这些函数应该只在从<function>PQexec</function>或<function>PQgetResult</function>
获得了<literal>PGRES_COPY_OUT</literal>或<literal>PGRES_COPY_IN</literal>结果状态的情况下执行。
</para>
  
<para>
<!-- 
   A <structname>PGresult</> object bearing one of these status values
   carries some additional data about the <command>COPY</command> operation
   that is starting.  This additional data is available using functions
   that are also used in connection with query results:
-->
一个承载了这些状态值之一地<structname>PGresult</>对象运载了某些有关正在开始的
<command>COPY</command>操作的额外信息。这些额外的数据可以用那些同时也处理查询结果的函数获取。
   <variablelist>
    <varlistentry id="libpq-pqnfields-1">
     <term>
      <function>PQnfields</function>
      <indexterm>
       <primary>PQnfields</primary>
       <secondary>with COPY</secondary>
      </indexterm>
     </term>

     <listitem>
<!--
      <para>
       Returns the number of columns (fields) to be copied.
      </para>
-->
<para>
返回要拷贝的字段（数据域）个数
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqbinarytuples-1">
     <term>
      <function>PQbinaryTuples</function>
      <indexterm>
       <primary>PQbinaryTuples</primary>
       <secondary>with COPY</secondary>
      </indexterm>
     </term>

     <listitem>
      <!--
<para>
       0 indicates the overall copy format is textual (rows separated by
       newlines, columns separated by separator characters, etc).  1
       indicates the overall copy format is binary.  See <xref
       linkend="sql-copy"> for more information.
      </para>
-->
<para>
0 表示全部拷贝格式都是文本的（行之间用换行分隔，字段用分隔符分隔，等等）。
1 表示全部拷贝格式都是二进制。参阅<xref linkend="sql-copy">获取更多信息。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfformat-1">
     <term>
      <function>PQfformat</function>
      <indexterm>
       <primary>PQfformat</primary>
       <secondary>with COPY</secondary>
      </indexterm>
     </term>

     <listitem>
      <!--
<para>
       Returns the format code (0 for text, 1 for binary) associated with
       each column of the copy operation.  The per-column format codes
       will always be zero when the overall copy format is textual, but
       the binary format can support both text and binary columns.
       (However, as of the current implementation of <command>COPY</>,
       only binary columns appear in a binary copy; so the per-column
       formats always match the overall format at present.)
      </para>
-->
<para>
返回和拷贝操作的每个字段相关的格式代码（0 是文本，1 是二进制）。
如果全部拷贝格式是文本，那么每字段的格式码将总是零，但是（整体）
二进制格式可以支持文本和二进制字段并存。（不过，就目前的<command>COPY</>实现，
在二进制拷贝里只出现二进制字段；所以目前每字段的格式总是匹配整体格式。）
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <note>
   <!--
<para>
    These additional data values are only available when using protocol
    3.0.  When using protocol 2.0, all these functions will return 0.
   </para>
-->
<para>
这些额外的数据值只能在使用 3.0 版本的协议的时候获得。在使用 2.0 版本的协议时，所有这些函数都返回 0。
</para>
  </note>

  <sect2 id="libpq-copy-send">
   <!--
   <title>Functions for Sending <command>COPY</command> Data</title>
   -->
   <title>用于发送<command>COPY</command>数据的函数</title>

   <!--
<para>
    These functions are used to send data during <literal>COPY FROM
    STDIN</>.  They will fail if called when the connection is not in
    <literal>COPY_IN</> state.
   </para>
-->
<para>
这些函数用于在<literal>COPY FROM STDIN</>过程中发送数据。
如果在连接不是处于<literal>COPY_IN</>状态下，它们会失败。
</para>

   <variablelist>
    <varlistentry id="libpq-pqputcopydata">
     <term>
      <function>PQputCopyData</function>
      <indexterm>
       <primary>PQputCopyData</primary>
      </indexterm>
     </term>

     <listitem>      
<para>
<!--
       Sends data to the server during <literal>COPY_IN</> state.
-->
在<literal>COPY_IN</>状态里向服务器发送数据。
<synopsis>
int PQputCopyData(PGconn *conn,
                  const char *buffer,
                  int nbytes);
</synopsis>
      </para>

      <!--
<para>
       Transmits the <command>COPY</command> data in the specified
       <parameter>buffer</>, of length <parameter>nbytes</>, to the server.
       The result is 1 if the data was sent, zero if it was not sent
       because the attempt would block (this case is only possible if the
       connection is in nonblocking mode), or -1 if an error occurred.
       (Use <function>PQerrorMessage</function> to retrieve details if
       the return value is -1.  If the value is zero, wait for write-ready
       and try again.)
      </para>
-->
<para>
传输指定的<parameter>buffer</>里的，长度为<parameter>nbytes</>的<command>COPY</command>
数据到服务器。如果数据发送成功，结果是 1，如果因为发送企图会阻塞
（这种情况只有在连接是非阻塞模式时才有可能）而没有成功，那么是零，
或者是在发生错误的时候是 -1。（如果返回 -1，那么使用<function>PQerrorMessage</function>
检索细节。如果值是零，那么等待写准备好然后重试。）
</para>

      <!--
<para>
       The application can divide the <command>COPY</command> data stream
       into buffer loads of any convenient size.  Buffer-load boundaries
       have no semantic significance when sending.  The contents of the
       data stream must match the data format expected by the
       <command>COPY</> command; see <xref linkend="sql-copy"> for details.
      </para>
-->
<para>
应用可以把<command>COPY</command>数据流分隔成任意合适的大小放到缓冲区里。在发送的时候，
缓冲区的边界没有什么特殊的语意。数据流的内容必须匹配<command>COPY</>命令预期的数据格式；
参阅<xref linkend="sql-copy">获取细节。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqputcopyend">
     <term>
      <function>PQputCopyEnd</function>
      <indexterm>
       <primary>PQputCopyEnd</primary>
      </indexterm>
     </term>

     <listitem>      
<para>
<!--
       Sends end-of-data indication to the server during <literal>COPY_IN</> state.
-->
在<literal>COPY_IN</>状态里向服务器发送数据完毕的指示。
<synopsis>
int PQputCopyEnd(PGconn *conn,
                 const char *errormsg);
</synopsis>
      </para>

      <!--
<para>
       Ends the <literal>COPY_IN</> operation successfully if
       <parameter>errormsg</> is <symbol>NULL</symbol>.  If
       <parameter>errormsg</> is not <symbol>NULL</symbol> then the
       <command>COPY</> is forced to fail, with the string pointed to by
       <parameter>errormsg</> used as the error message.  (One should not
       assume that this exact error message will come back from the server,
       however, as the server might have already failed the
       <command>COPY</> for its own reasons.  Also note that the option
       to force failure does not work when using pre-3.0-protocol
       connections.)
      </para>
-->
<para>
如果<parameter>errormsg</>是<symbol>NULL</symbol>，则成功结束<literal>COPY_IN</>操作。
如果<parameter>errormsg</>不是<symbol>NULL</symbol>则<command>COPY</>操作被强制失败，
<parameter>errormsg</>指向的字串是错误消息。（我们不能认为同样的错误消息可能会从服务器传回，
因为服务器可能已经因为自己的原因让<command>COPY</>失败。
还要注意的是在使用 3.0 版本之前的协议连接时，强制失败的选项是不能用的。）
</para>

      <!--
<para>
       The result is 1 if the termination data was sent, zero if it was
       not sent because the attempt would block (this case is only possible
       if the connection is in nonblocking mode), or -1 if an error
       occurred.  (Use <function>PQerrorMessage</function> to retrieve
       details if the return value is -1.  If the value is zero, wait for
       write-ready and try again.)
      </para>
-->
<para>
如果终止数据发送，则结果为 1，如果发送企图会阻塞（只有在连接是在非阻塞模式的情况下才可能出现这个情况），
则为零，如果发生错误则返回 -1。（如果返回值是 -1，用<function>PQerrorMessage</function>
检索细节。如果值是零，那么等待写准备好然后重新尝试。）
</para>

      <!--
<para>
       After successfully calling <function>PQputCopyEnd</>, call
       <function>PQgetResult</> to obtain the final result status of the
       <command>COPY</> command.  One can wait for this result to be
       available in the usual way.  Then return to normal operation.
      </para>
-->
<para>
在成功调用<function>PQputCopyEnd</>之后，调用<function>PQgetResult</>获取<command>COPY</>
命令的最终结果状态。我们可以用平常的方法来等待这个结果可用。然后返回到正常的操作。
</para>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>

  <sect2 id="libpq-copy-receive">
   <!--
   <title>Functions for Receiving <command>COPY</command> Data</title>
   -->
   <title>用于接收<command>COPY</command>数据的函数</title>

   <!--
<para>
    These functions are used to receive data during <literal>COPY TO
    STDOUT</>.  They will fail if called when the connection is not in
    <literal>COPY_OUT</> state.
   </para>
-->
<para>
这些函数用于在<literal>COPY TO STDOUT</>的过程中检索数据。
如果连接不在<literal>COPY_OUT</>状态，那么他们将会失败。
</para>

   <variablelist>
    <varlistentry id="libpq-pqgetcopydata">
     <term>
      <function>PQgetCopyData</function>
      <indexterm>
       <primary>PQgetCopyData</primary>
      </indexterm>
     </term>

     <listitem>      
<para>
<!--
       Receives data from the server during <literal>COPY_OUT</> state.
-->
在<literal>COPY_OUT</>状态下从服务器接收数据。
<synopsis>
int PQgetCopyData(PGconn *conn,
                  char **buffer,
                  int async);
</synopsis>
      </para>

      <!--
<para>
       Attempts to obtain another row of data from the server during a
       <command>COPY</command>.  Data is always returned one data row at
       a time; if only a partial row is available, it is not returned.
       Successful return of a data row involves allocating a chunk of
       memory to hold the data.  The <parameter>buffer</> parameter must
       be non-<symbol>NULL</symbol>.  <parameter>*buffer</> is set to
       point to the allocated memory, or to <symbol>NULL</symbol> in cases
       where no buffer is returned.  A non-<symbol>NULL</symbol> result
       buffer should be freed using <function>PQfreemem</> when no longer
       needed.
      </para>
-->
<para>
在一个<command>COPY</command>的过程中试图从服务器获取另外一行数据。数据总是每次返回一个数据行；
如果只有一部分行可用，那么它不会被返回。成功返回一个数据行包括分配一个内存块来保存这些数据。
<parameter>buffer</>参数必须是非<symbol>NULL</symbol>。<parameter>*buffer</>
设置为指向分配出来的内存的指针，或者是如果没有返回缓冲区，那么为<symbol>NULL</symbol>。
一个非<symbol>NULL</symbol>的结果缓冲区在不再需要的时候必须用<function>PQfreemem</>释放。
</para>

      <!--
<para>
       When a row is successfully returned, the return value is the number
       of data bytes in the row (this will always be greater than zero).
       The returned string is always null-terminated, though this is
       probably only useful for textual <command>COPY</command>.  A result
       of zero indicates that the <command>COPY</command> is still in
       progress, but no row is yet available (this is only possible when
       <parameter>async</> is true).  A result of -1 indicates that the
       <command>COPY</command> is done.  A result of -2 indicates that an
       error occurred (consult <function>PQerrorMessage</> for the reason).
      </para>
-->
<para>
在成功返回一行之后，那么返回的值就是该数据行里数据的字节数（这个将总是大于零）。
返回的字串总是空结尾的，虽然可能只是对文本的<command>COPY</command>有用。
一个零的结果表示该<command>COPY</command>仍然在处理中，但是还没有可以用的行
（这个只有在<parameter>async</>为真的时候才可能）。一个结果为 -1 的值表示
<command>COPY</command>已经结束。结果为 -2 表示发生了错误（参考<function>PQerrorMessage</>获取原因）。
</para>

      <!--
<para>
       When <parameter>async</> is true (not zero),
       <function>PQgetCopyData</> will not block waiting for input; it
       will return zero if the <command>COPY</command> is still in progress
       but no complete row is available.  (In this case wait for read-ready
       and then call <function>PQconsumeInput</> before calling
       <function>PQgetCopyData</> again.)  When <parameter>async</> is
       false (zero), <function>PQgetCopyData</> will block until data is
       available or the operation completes.
      </para>
-->
<para>
在<parameter>async</>为真的时候（非零），<function>PQgetCopyData</>将不会阻塞住等待输入；
如果该<command>COPY</command>仍在处理过程中并且没有可用的完整行，那么它将返回零。
（在这种情况下它等待读准备好，然后在再次调用<function>PQgetCopyData</>之前，
调用<function>PQconsumeInput</>。）在<parameter>async</>是假（零）的时候，
<function>PQgetCopyData</>将阻塞住，直到数据可用或者操作完成。
</para>

      <!--
<para>
       After <function>PQgetCopyData</> returns -1, call
       <function>PQgetResult</> to obtain the final result status of the
       <command>COPY</> command.  One can wait for this result to be
       available in the usual way.  Then return to normal operation.
      </para>
-->
<para>
在<function>PQgetCopyData</>返回 -1 之后，调用<function>PQgetResult</>获取
<command>COPY</>命令的最后结果状态。我们可以用通常的方法等待这个结果可用。然后返回到正常操作。
</para>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>

  <sect2 id="libpq-copy-deprecated">
   <!--
   <title>Obsolete Functions for <command>COPY</command></title>
   -->
   <title>用于<command>COPY</command>的废弃的函数</title>

   <!--
<para>
    These functions represent older methods of handling <command>COPY</>.
    Although they still work, they are deprecated due to poor error handling,
    inconvenient methods of detecting end-of-data, and lack of support for binary
    or nonblocking transfers.
   </para>
-->
<para>
下面的这些函数代表了以前的处理<command>COPY</>的方法。尽管他们还能用，但是现在已经废弃了，
因为他们的错误处理实在是太糟糕了，并且检测数据结束的方法也很不方便，并且缺少对二进制和非阻塞传输的支持。
</para>

   <variablelist>
    <varlistentry id="libpq-pqgetline">
     <term>
      <function>PQgetline</function>
      <indexterm>
       <primary>PQgetline</primary>
      </indexterm>
     </term>

     <listitem>     
<para>
<!--
       Reads  a  newline-terminated  line  of  characters (transmitted
       by the server) into a buffer string of size <parameter>length</>.
-->
读取一个以新行符结尾的字符行（由服务器传输）到一个长度为<parameter>length</>的字符串缓冲区。
<synopsis>
int PQgetline(PGconn *conn,
              char *buffer,
              int length);
</synopsis>
      </para>

      <!--
<para>
       This function copies up to <parameter>length</>-1 characters into
       the buffer and converts the terminating newline into a zero byte.
       <function>PQgetline</function> returns <symbol>EOF</symbol> at the
       end of input, 0 if the entire line has been read, and 1 if the
       buffer is full but the terminating newline has not yet been read.
       </para>
-->
<para>
这个函数拷贝最多<parameter>length</>-1个字符到缓冲区里，然后把终止的新行符转换成一个字节零。
<function>PQgetline</function>在输入结束时返回<symbol>EOF</symbol>，如果整行都被读取了返回 0，
如果缓冲区填满了而还没有遇到结束的新行符则返回 1。
</para>
       <!--
<para>
       Note that the application must check to see if a new line consists
       of  the  two characters  <literal>\.</literal>, which  indicates
       that the server has finished sending the results  of  the
       <command>COPY</command> command.  If  the  application might receive
       lines that are more than <parameter>length</>-1  characters  long,
       care is needed to be sure it recognizes the <literal>\.</literal>
       line correctly (and does not, for example, mistake the end of a
       long data line for a terminator line).
      </para>
-->
<para>
注意，应用程序必须检查新行是否包含两个字符<literal>\.</literal>，
这表明服务器已经完成了<command>COPY</command>命令的结果的发送。
如果应用可能收到超过<parameter>length</>-1字符长的字符，我们就应该确保正确识别
<literal>\.</literal>行（例如，不要把一个长的数据行的结束当作一个终止行）。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqgetlineasync">
     <term>
      <function>PQgetlineAsync</function>
      <indexterm>
       <primary>PQgetlineAsync</primary>
      </indexterm>
     </term>

     <listitem>      
<para>
<!--
       Reads a row of <command>COPY</command> data (transmitted  by the
       server) into a buffer without blocking.
-->
不阻塞地读取一行<command>COPY</command>数据（由服务器传输）到一个缓冲区中。
<synopsis>
int PQgetlineAsync(PGconn *conn,
                   char *buffer,
                   int bufsize);
</synopsis>
      </para>

      <!--
<para>
       This function is similar to <function>PQgetline</function>, but it can be used
       by applications
       that must read <command>COPY</command> data asynchronously, that is, without blocking.
       Having issued the <command>COPY</command> command and gotten a <literal>PGRES_COPY_OUT</literal>
       response, the
       application should call <function>PQconsumeInput</function> and
       <function>PQgetlineAsync</function> until the
       end-of-data signal is detected.
       </para>
-->
<para>
这个函数类似于<function>PQgetline</function>，但是可以用于那些必须异步读取<command>COPY</command>
数据的应用，也就是不阻塞的应用。在使用了<command>COPY</command>命令和获取了<literal>PGRES_COPY_OUT</literal>
响应之后，应用应该调用<function>PQconsumeInput</function>和<function>PQgetlineAsync</function>
直到收到数据结束的信号。
</para>
       <!--
<para>
       Unlike <function>PQgetline</function>, this function takes
       responsibility for detecting end-of-data.
      </para>
-->
<para>
不像<function>PQgetline</function>，这个函数负责检测数据结束。
</para>

      <!--
<para>
       On each call, <function>PQgetlineAsync</function> will return data if a
       complete data row is available in <application>libpq</>'s input buffer.
       Otherwise, no data is returned until the rest of the row arrives.
       The function returns -1 if the end-of-copy-data marker has been recognized,
       or 0 if no data is available, or a positive number giving the number of
       bytes of data returned.  If -1 is returned, the caller must next call
       <function>PQendcopy</function>, and then return to normal processing.
      </para>
-->
<para>
在每次调用时，如果<application>libpq</>的输入缓冲区内有可用的一个完整的数据行，
<function>PQgetlineAsync</function>都将返回数据。否则，在其他数据到达之前不会返回数据。
如果见到了拷贝数据结束的标志，此函数返回 -1，如果没有可用数据，
或者是给出一个正数表明返回的数据的字节数，返回 0。如果返回 -1，调用者下一步必须调用
<function>PQendcopy</function>，然后回到正常处理。
</para>

      <!--
<para>
       The data returned will not extend beyond a data-row boundary.  If possible
       a whole row will be returned at one time.  But if the buffer offered by
       the caller is too small to hold a row sent by the server, then a partial
       data row will be returned.  With textual data this can be detected by testing
       whether the last returned byte is <literal>\n</literal> or not.  (In a binary
       <command>COPY</>, actual parsing of the <command>COPY</> data format will be needed to make the
       equivalent determination.)
       The returned string is not null-terminated.  (If you want to add a
       terminating null, be sure to pass a <parameter>bufsize</parameter> one smaller
       than the room actually available.)
      </para>
-->
<para>
返回的数据将不超过一行的范围。如果可能，每次将返回一个完整行。但如果调用者提供的缓冲区太小，
无法容下服务器发出的整行，那么将返回部分行。对于文本数据，这个可以通过测试返回的最后一个字节是否是
<literal>\n</literal>来确认。（在二进制<command>COPY</>中，我们需要对<command>COPY</>
数据格式进行实际的分析，以便做相同的判断。）返回的字符串不是空结尾的。（如果你想得到一个空结尾的字串，
确保你传递了一个比实际可用空间少一字节的<parameter>bufsize</parameter>。）
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqputline">
     <term>
      <function>PQputline</function>
      <indexterm>
       <primary>PQputline</primary>
      </indexterm>
     </term>

     <listitem> 
<para>
<!--
       Sends  a  null-terminated  string  to  the server.  Returns 0 if
       OK and <symbol>EOF</symbol> if unable to send the string.
-->
向服务器发送一个空结尾的字符串。成功时返回 0，如果不能发送字符串返回<symbol>EOF</symbol>。
<synopsis>
int PQputline(PGconn *conn,
              const char *string);
</synopsis>
      </para>

      <!--
<para>
       The <command>COPY</command> data stream sent by a series of calls
       to <function>PQputline</function> has the same format as that
       returned by <function>PQgetlineAsync</function>, except that
       applications are not obliged to send exactly one data row per
       <function>PQputline</function> call; it is okay to send a partial
       line or multiple lines per call.
      </para>
-->
<para>
一系列<function>PQputline</function>调用发送的<command>COPY</command>数据流和
<function>PQgetlineAsync</function>返回的数据有着一样的格式，只是应用不需要明确地在每次
<function>PQputline</function>调用中发送一个数据行；每次调用发送多行或者部分行都是可以的。
</para>

      <note>
       <!--
<para>
        Before <productname>PostgreSQL</productname> protocol 3.0, it was necessary
        for the application to explicitly send the two characters
        <literal>\.</literal> as a final line to indicate to the server that it had
        finished sending <command>COPY</> data.  While this still works, it is deprecated and the
        special meaning of <literal>\.</literal> can be expected to be removed in a
        future release.  It is sufficient to call <function>PQendcopy</function> after
        having sent the actual data.
       </para>
-->
<para>
在<productname>PostgreSQL</productname>协议3.0之前，应用必须明确的发送两个字符<literal>\.</literal>
作为行结束，向服务器表明它已经完成了发送<command>COPY</>数据。虽然这个仍然工作，
但是已经废弃了，并且<literal>\.</literal>的特殊含义在将来的版本中有望删除。
在发送实际数据之后调用<function>PQendcopy</function>就足够了。
</para>
      </note>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqputnbytes">
     <term>
      <function>PQputnbytes</function>
      <indexterm>
       <primary>PQputnbytes</primary>
      </indexterm>
     </term>

     <listitem>     
<para>
<!--
       Sends  a  non-null-terminated  string  to  the server.  Returns
       0 if OK and <symbol>EOF</symbol> if unable to send the string.
-->
向服务器发送一个非空结尾的字符串。成功时返回 0，如果不能发送字符串返回<symbol>EOF</symbol>。
<synopsis>
int PQputnbytes(PGconn *conn,
                const char *buffer,
                int nbytes);
</synopsis>
      </para>

      <!--
<para>
       This is exactly like <function>PQputline</function>, except that the data
       buffer need not be null-terminated since the number of bytes to send is
       specified directly.  Use this procedure when sending binary data.
      </para>
-->
<para>
此函数类似<function>PQputline</function>，除了数据缓冲区不需要是空结尾的之外，
因为要发送的字节数是直接声明的。在发送二进制数据的时候使用这个过程。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqendcopy">
     <term>
      <function>PQendcopy</function>
      <indexterm>
       <primary>PQendcopy</primary>
      </indexterm>
     </term>

     <listitem>
      <!--
<para>
       Synchronizes with the server.
<synopsis>
int PQendcopy(PGconn *conn);
</synopsis>
       This function waits until the  server  has  finished  the copying.
       It should either be issued when the  last  string  has  been sent
       to  the  server using <function>PQputline</function> or when the
       last string has been  received  from  the  server using
       <function>PGgetline</function>.  It must be issued or the server
       will get <quote>out of sync</quote> with  the client.   Upon return
       from this function, the server is ready to receive the next SQL
       command.  The return value is 0  on  successful  completion,
       nonzero otherwise.  (Use <function>PQerrorMessage</function> to
       retrieve details if the return value is nonzero.)
      </para>
-->
<para>
与服务器同步。
<synopsis>
int PQendcopy(PGconn *conn);
</synopsis>
这个函数将等待直到服务器完成拷贝。你可以在用<function>PQputline</function>
向服务器发送完最后一个字符串后或者用<function>PGgetline</function>
从服务器获取最后一行字符串后调用它。我们必须调用这个函数，否则服务器可能会和前端
<quote>不同步</quote>。在这个函数返回后，服务器就已经准备好接收下一个 SQL 命令了。
成功时返回0，否则返回非零值。（如果返回值为非 0，用<function>PQerrorMessage</function>检索细节。）
</para>

      <!--
<para>
       When using <function>PQgetResult</function>, the application should
       respond to a <literal>PGRES_COPY_OUT</literal> result by executing
       <function>PQgetline</function> repeatedly, followed by
       <function>PQendcopy</function> after the terminator line is seen.
       It should then return to the <function>PQgetResult</function> loop
       until <function>PQgetResult</function> returns a null pointer.
       Similarly a <literal>PGRES_COPY_IN</literal> result is processed
       by a series of <function>PQputline</function> calls followed by
       <function>PQendcopy</function>, then return to the
       <function>PQgetResult</function> loop.  This arrangement will
       ensure that a <command>COPY</command> command embedded in a series
       of <acronym>SQL</acronym> commands will be executed correctly.
      </para>
-->
<para>
在使用<function>PQgetResult</function>时，应用应该对<literal>PGRES_COPY_OUT</literal>
的结果做出反应：重复调用<function>PQgetline</function>，并且在收到结束行时调用
<function>PQendcopy</function>。然后应该返回到<function>PQgetResult</function>
循环直到<function>PQgetResult</function>返回空指针。类似地，<literal>PGRES_COPY_IN</literal>
结果是用一系列<function>PQputline</function>调用最后跟着<function>PQendcopy</function>，
然后返回到<function>PQgetResult</function>循环。这样的排列将保证嵌入到一系列
<acronym>SQL</acronym>命令里的<command>COPY</command>命令将被正确执行。
</para>

      <!--
<para>
       Older applications are likely to submit a <command>COPY</command>
       via <function>PQexec</function> and assume that the transaction
       is done after <function>PQendcopy</function>.  This will work
       correctly only if the <command>COPY</command> is the only
       <acronym>SQL</acronym> command in the command string.
      </para>
-->
<para>
旧的应用大多通过<function>PQexec</function>提交一个<command>COPY</command>
命令并且假设在<function>PQendcopy</function>后事务完成。这样只有在<command>COPY</command>
是命令字串里的唯一的<acronym>SQL</acronym>命令时才能正确工作。
</para>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>

 </sect1>

 <sect1 id="libpq-control">
  <!--
  <title>Control Functions</title>
  -->
  <title>控制函数</title>

  <!--
<para>
   These functions control miscellaneous details of <application>libpq</>'s
   behavior.
  </para>
-->
<para>
这些函数控制许多<application>libpq</>其他行为的细节。
</para>

  <variablelist>
   <varlistentry id="libpq-pqclientencoding">
    <term>
     <function>PQclientEncoding</function>
     <indexterm>
      <primary>PQclientEncoding</primary>
     </indexterm>
    </term>

    <listitem>    
<para>
<!--
      Returns the client encoding.
-->
返回客户端编码。
<synopsis>
int PQclientEncoding(const PGconn *<replaceable>conn</replaceable>);
</synopsis>
<!-- 
      Note that it returns the encoding ID, not a symbolic string
      such as <literal>EUC_JP</literal>. If unsuccessful, it returns -1.
      To convert an encoding ID to an encoding name, you
      can use:
-->
请注意，它返回编码ID，而不是一个符号串如<literal>EUC_JP</literal>。
如果未成功，它返回-1。转换编码的ID为一个编码名称，你可以使用：
<synopsis>
char *pg_encoding_to_char(int <replaceable>encoding_id</replaceable>);
</synopsis>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqsetclientencoding">
    <term>
     <function>PQsetClientEncoding</function>
     <indexterm>
      <primary>PQsetClientEncoding</primary>
     </indexterm>
    </term>

    <listitem>    
<para>
<!--
      Sets the client encoding.
-->
设置客户端编码。
<synopsis>
int PQsetClientEncoding(PGconn *<replaceable>conn</replaceable>, const char *<replaceable>encoding</replaceable>);
</synopsis>
<!-- 
      <replaceable>conn</replaceable> is a connection to the server,
      and <replaceable>encoding</replaceable> is the encoding you want to
      use. If the function successfully sets the encoding, it returns 0,
      otherwise -1. The current encoding for this connection can be
      determined by using <function>PQclientEncoding</>. 
-->
<replaceable>conn</replaceable>是一个到服务器的连接，<replaceable>encoding</replaceable>
是你想要的编码使用。如果函数成功设置编码，则返回0，否则返回-1。
这个链接的当前编码可以通过<function>PQclientEncoding</>确定。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqseterrorverbosity">
    <term>
     <function>PQsetErrorVerbosity</function>
     <indexterm>
      <primary>PQsetErrorVerbosity</primary>
     </indexterm>
    </term>

    <listitem>    
<para>
<!--
      Determines the verbosity of messages returned by
      <function>PQerrorMessage</> and <function>PQresultErrorMessage</>.
-->
决定<function>PQerrorMessage</>和<function>PQresultErrorMessage</>返回的信息的冗余程度。
<synopsis>
typedef enum
{
    PQERRORS_TERSE,
    PQERRORS_DEFAULT,
    PQERRORS_VERBOSE
} PGVerbosity;

PGVerbosity PQsetErrorVerbosity(PGconn *conn, PGVerbosity verbosity);
</synopsis>

<!-- 
      <function>PQsetErrorVerbosity</> sets the verbosity mode, returning
      the connection's previous setting.  In <firstterm>TERSE</> mode,
      returned messages include severity, primary text, and position only;
      this will normally fit on a single line.  The default mode produces
      messages that include the above plus any detail, hint, or context
      fields (these might span multiple lines).  The <firstterm>VERBOSE</>
      mode includes all available fields.  Changing the verbosity does not
      affect the messages available from already-existing
      <structname>PGresult</> objects, only subsequently-created ones. 
-->
<function>PQsetErrorVerbosity</>设置冗余模式，返回连接的前一个设置。在<firstterm>TERSE</>模式下，
返回的消息只包括严重性，主信息，以及位置信息；这些东西通常只有一行。
缺省模式生成的消息包括上面的信息加上任何细节，提示，或者环境字段（这些可能跨越几行）。
<firstterm>VERBOSE</>模式包括所有可以获得的字段。修改冗余模式不会影响我们从已经存在
<structname>PGresult</>对象中获取的信息，只有随后创建的<structname>PGresult</>对象才受到影响。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqtrace">
    <term>
     <function>PQtrace</function>
     <indexterm>
      <primary>PQtrace</primary>
     </indexterm>
    </term>

    <listitem>     
<para>
<!--
      Enables  tracing of the client/server communication to a debugging file stream.
-->
打开对前端/服务器通讯的跟踪，把调试信息输出到一个文件流里。
<synopsis>
void PQtrace(PGconn *conn, FILE *stream);
</synopsis>
     </para>

     <note>
      <!--
<para>
       On Windows, if the <application>libpq</> library and an application are
       compiled with different flags, this function call will crash the
       application because the internal representation of the <literal>FILE</>
       pointers differ.  Specifically, multithreaded/single-threaded,
       release/debug, and static/dynamic flags should be the same for the
       library and all applications using that library.
      </para>
-->
<para>
在Windows上，如果<application>libpq</>库和应用使用了不同的标志编译，
那么这个函数调用会导致应用崩溃，因为<literal>FILE</>指针的内部表现形式是不一样的。
特别是多线程/单线程，发布/调试，以及静态/动态标志应该是库和所有使用库的应用都一致。
</para>
     </note>

    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pquntrace">
    <term>
     <function>PQuntrace</function>
     <indexterm>
      <primary>PQuntrace</primary>
     </indexterm>
    </term>

    <listitem>    
<para>
<!--
      Disables tracing started by <function>PQtrace</function>.
-->
关闭<function>PQtrace</function>打开的跟踪。
<synopsis>
void PQuntrace(PGconn *conn);
</synopsis>
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

 </sect1>

 <sect1 id="libpq-misc">
  <!--
  <title>Miscellaneous Functions</title>
  -->
  <title>各种函数</title>

  <!--
<para>
   As always, there are some functions that just don't fit anywhere.
  </para>
-->
<para>
一如往常，也有一些函数，只是不是在任何地方都适合。
</para>

  <variablelist>
   <varlistentry id="libpq-pqfreemem">
    <term>
     <function>PQfreemem</function>
     <indexterm>
      <primary>PQfreemem</primary>
     </indexterm>
    </term>

    <listitem>    
<para>
<!--
      Frees memory allocated by <application>libpq</>.
-->
释放<application>libpq</>分配的内存。
<synopsis>
void PQfreemem(void *ptr);
</synopsis>
     </para>

     <!--
<para>
      Frees memory allocated by <application>libpq</>, particularly
      <function>PQescapeByteaConn</function>,
      <function>PQescapeBytea</function>,
      <function>PQunescapeBytea</function>,
      and <function>PQnotifies</function>.
      It is particularly important that this function, rather than
      <function>free()</>, be used on Microsoft Windows.  This is because
      allocating memory in a DLL and releasing it in the application works
      only if multithreaded/single-threaded, release/debug, and static/dynamic
      flags are the same for the DLL and the application.  On non-Microsoft
      Windows platforms, this function is the same as the standard library
      function <function>free()</>.
     </para>
-->
<para>
释放<application>libpq</>分配的内存，尤其是<function>PQescapeByteaConn</function>，
<function>PQescapeBytea</function>，<function>PQunescapeBytea</function>和<function>PQnotifies</function>。
尤其重要的是，在Windows系统上使用这个函数，而不是<function>free()</>。
这是因为只有DLL和应用程序的多线程/单线程，发布/调试，静态/动态标志是相同的时，
才在一个DLL中分配内存，并在应用程序工作时释放内存。在非Windows平台上，
这个函数与标准库函数<function>free()</>相同。
</para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqconninfofree">
    <term>
     <function>PQconninfoFree</function>
     <indexterm>
      <primary>PQconninfoFree</primary>
     </indexterm>
    </term>

    <listitem>     
<para>
<!--
      Frees the data structures allocated by
      <function>PQconndefaults</> or <function>PQconninfoParse</>.
-->
释放<function>PQconndefaults</>或<function>PQconninfoParse</>分配的数据结构。
<synopsis>
void PQconninfoFree(PQconninfoOption *connOptions);
</synopsis>
     </para>

     <!--
<para>
      A simple <function>PQfreemem</function> will not do for this, since
      the array contains references to subsidiary strings.
     </para>
-->
<para>
一个简单的<function>PQfreemem</function>不会这样做，因为数组包含对子字符串的引用。
</para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqencryptpassword">
    <term>
     <function>PQencryptPassword</function>
     <indexterm>
      <primary>PQencryptPassword</primary>
     </indexterm>
    </term>

    <listitem>     
<para>
<!--
      Prepares the encrypted form of a <productname>PostgreSQL</> password.
-->
准备一个<productname>PostgreSQL</>密码的加密形式：
<synopsis>
char * PQencryptPassword(const char *passwd, const char *user);
</synopsis>
<!-- 
      This function is intended to be used by client applications that
      wish to send commands like <literal>ALTER USER joe PASSWORD
      'pwd'</>.  It is good practice not to send the original cleartext
      password in such a command, because it might be exposed in command
      logs, activity displays, and so on.  Instead, use this function to
      convert the password to encrypted form before it is sent.  The
      arguments are the cleartext password, and the SQL name of the user
      it is for.  The return value is a string allocated by
      <function>malloc</function>, or <symbol>NULL</symbol> if out of
      memory.  The caller can assume the string doesn't contain any
      special characters that would require escaping.  Use
      <function>PQfreemem</> to free the result when done with it. 
-->
这个函数旨在用于那些发送类似于<literal>ALTER USER joe PASSWORD 'pwd'</>命令的客户端应用程序。
这是一个很好的方法，这种命令不发送原始的明文密码，因为它可能被暴露在命令日志，活动显示中等等。
相反，在发送前，使用这个函数可以将密码转换为加密的形式。参数是明文密码和用户的SQL名字。
返回值是<function>malloc</function>分配的一个字符串，或超出内存时为<symbol>NULL</symbol>。
调用可以认为字符串中不包含需要转义的特殊字符。当使用结束之后，用<function>PQfreemem</>进行释放。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqmakeemptypgresult">
    <term>
     <function>PQmakeEmptyPGresult</function>
     <indexterm>
      <primary>PQmakeEmptyPGresult</primary>
     </indexterm>
    </term>

    <listitem>    
<para>
<!--
      Constructs an empty <structname>PGresult</structname> object with the given status.
-->
用给定的状态构造一个空<structname>PGresult</structname>对象。
<synopsis>
PGresult *PQmakeEmptyPGresult(PGconn *conn, ExecStatusType status);
</synopsis>
     </para>
     <!--
<para>
      This is <application>libpq</>'s internal function to allocate and
      initialize an empty <structname>PGresult</structname> object.  This
      function returns <symbol>NULL</> if memory could not be allocated. It is
      exported because some applications find it useful to generate result
      objects (particularly objects with error status) themselves.  If
      <parameter>conn</parameter> is not null and <parameter>status</>
      indicates an error, the current error message of the specified
      connection is copied into the <structname>PGresult</structname>.
      Also, if <parameter>conn</parameter> is not null, any event procedures
      registered in the connection are copied into the
      <structname>PGresult</structname>.  (They do not get
      <literal>PGEVT_RESULTCREATE</> calls, but see
      <function>PQfireResultCreateEvents</function>.)
      Note that <function>PQclear</function> should eventually be called
      on the object, just as with a <structname>PGresult</structname>
      returned by <application>libpq</application> itself.
     </para>
-->
<para>
这是<application>libpq</>的内部函数，用于分配和初始化一个空<structname>PGresult</structname>对象。
如果不能分配内存，那么这个函数返回<symbol>NULL</>。这是输出，
因为一些应用程序发现它可以有效的生成结果对象本身（特别是带有错误状态的对象）。
如果<parameter>conn</parameter>非空，并且<parameter>status</>用于表示一个错误，
那么指定连接的当前错误消息被复制到<structname>PGresult</structname>中。同时，
如果<parameter>conn</parameter>非空，那么连接中的任何事件过程会被复制到
<structname>PGresult</structname>中。（它们不会获得<literal>PGEVT_RESULTCREATE</>请求，
但会看到<function>PQfireResultCreateEvents</function>）。需要注意的是随着<application>libpq</application>
本身返回<structname>PGresult</structname>时，对象最后应该请求<function>PQclear</function>。
</para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqfireresultcreateevents">
    <term>
     <function>PQfireResultCreateEvents</function>
     <indexterm>
      <primary>PQfireResultCreateEvents</primary>
     </indexterm>
    </term>
    <listitem>
     
<para>
<!--
      Fires a <literal>PGEVT_RESULTCREATE</literal> event (see <xref
      linkend="libpq-events">) for each event procedure registered in the
      <structname>PGresult</structname> object.  Returns non-zero for success,
      zero if any event procedure fails.
-->
为<structname>PGresult</structname>对象中的每个事件过程触发一个<literal>PGEVT_RESULTCREATE</literal>事件
（参阅<xref linkend="libpq-events">）。成功时返回非0，如果任何事件过程失败返回0。
<synopsis>
int PQfireResultCreateEvents(PGconn *conn, PGresult *res);
</synopsis>
     </para>

     <!--
<para>
      The <literal>conn</> argument is passed through to event procedures
      but not used directly.  It can be <symbol>NULL</> if the event
      procedures won't use it.
     </para>
-->
<para>
<literal>conn</>被传送给事件过程，但不会被直接使用。如果事件过程不使用它，则会返回<symbol>NULL</>。
</para>

     <!--
<para>
      Event procedures that have already received a
      <literal>PGEVT_RESULTCREATE</> or <literal>PGEVT_RESULTCOPY</> event
      for this object are not fired again.
     </para>
-->
<para>
已经接收到这个对象的<literal>PGEVT_RESULTCREATE</>或<literal>PGEVT_RESULTCOPY</>
事件的事件过程不会被再次触发。
</para>

     <!--
<para>
      The main reason that this function is separate from
      <function>PQmakeEmptyPGresult</function> is that it is often appropriate
      to create a <structname>PGresult</structname> and fill it with data
      before invoking the event procedures.
     </para>
-->
<para>
这个函数与<function>PQmakeEmptyPGresult</function>分开的主要原因是它经常创建一个
<structname>PGresult</structname>，并且在调用事件过程之前就用数据对其进行填充。
</para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqcopyresult">
    <term>
     <function>PQcopyResult</function>
     <indexterm>
      <primary>PQcopyResult</primary>
     </indexterm>
    </term>

    <listitem>    
<para>
<!--
      Makes a copy of a <structname>PGresult</structname> object.  The copy is
      not linked to the source result in any way and
      <function>PQclear</function> must be called when the copy is no longer
      needed.  If the function fails, <symbol>NULL</> is returned.
-->
完成一个<structname>PGresult</structname>对象的拷贝。这个拷贝不会以任何方式来连接到资源结果，
并且当该拷贝不再需要时，需要调用<function>PQclear</function>进行清理。如果函数失败，返回<symbol>NULL</>。
<synopsis>
PGresult *PQcopyResult(const PGresult *src, int flags);
</synopsis>
     </para>

     <!--
<para>
      This is not intended to make an exact copy.  The returned result is
      always put into <literal>PGRES_TUPLES_OK</literal> status, and does not
      copy any error message in the source.  (It does copy the command status
      string, however.)  The <parameter>flags</parameter> argument determines
      what else is copied.  It is a bitwise OR of several flags.
      <literal>PG_COPYRES_ATTRS</literal> specifies copying the source
      result's attributes (column definitions).
      <literal>PG_COPYRES_TUPLES</literal> specifies copying the source
      result's tuples.  (This implies copying the attributes, too.)
      <literal>PG_COPYRES_NOTICEHOOKS</literal> specifies
      copying the source result's notify hooks.
      <literal>PG_COPYRES_EVENTS</literal> specifies copying the source
      result's events.  (But any instance data associated with the source
      is not copied.)
     </para>
-->
<para>
不会制作一个明确的拷贝。返回的结果通常会是<literal>PGRES_TUPLES_OK</literal>状态，
并且不会拷贝资源中的错误消息，然而会拷贝命令状态字符串。<parameter>flags</parameter>
决定其他需要拷贝的。通常是几个<literal>PG_COPYRES_ATTRS</literal>的按位或。
<literal>PG_COPYRES_ATTRS</literal>声明复制源结果的属性（列定义）。
<literal>PG_COPYRES_TUPLES</literal>声明复制源结果的元组（这意味着也复制属性）。
<literal>PG_COPYRES_NOTICEHOOKS</literal>声明复制源结果的通知陷阱。
<literal>PG_COPYRES_EVENTS</literal>声明负值源结果的事件。（但任何与源关联的实例数据不会被复制。）
</para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqsetresultattrs">
    <term>
     <function>PQsetResultAttrs</function>
     <indexterm>
      <primary>PQsetResultAttrs</primary>
     </indexterm>
    </term>

    <listitem>     
<para>
<!--
      Sets the attributes of a <structname>PGresult</structname> object.
-->
设置<structname>PGresult</structname>对象的属性。
<synopsis>
int PQsetResultAttrs(PGresult *res, int numAttributes, PGresAttDesc *attDescs);
</synopsis>
     </para>

     <!--
<para>
      The provided <parameter>attDescs</parameter> are copied into the result.
      If the <parameter>attDescs</parameter> pointer is <symbol>NULL</> or
      <parameter>numAttributes</parameter> is less than one, the request is
      ignored and the function succeeds.  If <parameter>res</parameter>
      already contains attributes, the function will fail.  If the function
      fails, the return value is zero.  If the function succeeds, the return
      value is non-zero.
     </para>
-->
<para>
提供的<parameter>attDescs</parameter>被复制到结果中。如果<parameter>attDescs</parameter>
指针为<symbol>NULL</>，或<parameter>numAttributes</parameter>小于1，那么请求将被忽略，
并且函数成功。如果<parameter>res</parameter>已经有了属性，那么函数会失败。如果函数失败，
会返回0。如果函数成功，会返回非0。
</para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqsetvalue">
    <term>
     <function>PQsetvalue</function>
     <indexterm>
      <primary>PQsetvalue</primary>
     </indexterm>
    </term>

    <listitem>    
<para>
<!--
      Sets a tuple field value of a <structname>PGresult</structname> object.
-->
设置<structname>PGresult</structname>对象的元组字段值。
<synopsis>
int PQsetvalue(PGresult *res, int tup_num, int field_num, char *value, int len);
</synopsis>
     </para>

     <!--
<para>
      The function will automatically grow the result's internal tuples array
      as needed.  However, the <parameter>tup_num</parameter> argument must be
      less than or equal to <function>PQntuples</function>, meaning this
      function can only grow the tuples array one tuple at a time.  But any
      field of any existing tuple can be modified in any order.  If a value at
      <parameter>field_num</parameter> already exists, it will be overwritten.
      If <parameter>len</parameter> is -1 or
      <parameter>value</parameter> is <symbol>NULL</>, the field value
      will be set to an SQL null value.  The
      <parameter>value</parameter> is copied into the result's private storage,
      thus is no longer needed after the function
      returns.  If the function fails, the return value is zero.  If the
      function succeeds, the return value is non-zero.
     </para>
-->
<para>
这个函数会自动按需增加结果的内置元组。然而，<parameter>tup_num</parameter>
参数必须小于等于<function>PQntuples</function>，意味着这个函数一次只能增加一个元组。
但已存在的任意的元组中的任意字段可以以任意顺序进行调整。如果<parameter>field_num</parameter>
中的一个值已经存在，会被覆盖重写。如果<parameter>len</parameter>是-1，或<parameter>value</parameter>
是<symbol>NULL</>，字段值会被设置为一个SQL空值。<parameter>value</parameter>
被复制到结果的私有存储中，因此函数返回结果后就不再需要了。如果函数失败，会返回0。
如果函数成功，会返回非0。
</para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqresultalloc">
    <term>
     <function>PQresultAlloc</function>
     <indexterm>
      <primary>PQresultAlloc</primary>
     </indexterm>
    </term>

    <listitem>     
<para>
<!--
      Allocate subsidiary storage for a <structname>PGresult</structname> object.
-->
为<structname>PGresult</structname>对象分配子存储。
<synopsis>
void *PQresultAlloc(PGresult *res, size_t nBytes);
</synopsis>
     </para>

     <!--
<para>
      Any memory allocated with this function will be freed when
      <parameter>res</parameter> is cleared.  If the function fails,
      the return value is <symbol>NULL</>.  The result is
      guaranteed to be adequately aligned for any type of data,
      just as for <function>malloc</>.
     </para>
-->
<para>
当<parameter>res</parameter>被清理时，该函数分配的内存也会被释放掉。如果函数失败，
返回<symbol>NULL</>。结果是保证任何类型的数据能够充分对齐，如同对<function>malloc</>一样。
</para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqlibversion">
    <term>
     <function>PQlibVersion</function>
     <indexterm>
      <primary>PQlibVersion</primary>
      <seealso>PQserverVersion</seealso>
     </indexterm>
    </term>

    <listitem>     
<para>
<!--
      Return the version of <productname>libpq</> that is being used.
-->
返回正在使用的<productname>libpq</>的版本。
<synopsis>
int PQlibVersion(void);
</synopsis>
     </para>

     <!--
<para>
      The result of this function can be used to determine, at
      run time, if specific functionality is available in the currently
      loaded version of libpq. The function can be used, for example,
      to determine which connection options are available for
      <function>PQconnectdb</> or if the <literal>hex</> <type>bytea</>
      output added in PostgreSQL 9.0 is supported.
     </para>
-->
<para>
如果特定的功能在libpq当前加载的版本中可用，那么用于决定运行时此函数的结果。
该函数可以使用，比如，用来确定可用于<function>PQconnectdb</>的连接选项，
或者是否支持PostgreSQL 9.0中添加的<literal>hex</> <type>bytea</>输出。
</para>

     <!--
<para>
      The number is formed by converting the major, minor, and revision
      numbers into two-decimal-digit numbers and appending them together.
      For example, version 9.1 will be returned as 90100, and version
      9.1.2 will be returned as 90102 (leading zeroes are not shown).
     </para>
-->
<para>
数字是通过把主、次及版本号转换成两位十进制数并且把它们连接在一起组成的。例如，
版本9.1将被返回901000，版本9.1.2将被返回90102（前导零没有显示）。
</para>

     <note>
      <!--
<para>
       This function appeared in <productname>PostgreSQL</> version 9.1, so
       it cannot be used to detect required functionality in earlier
       versions, since linking to it will create a link dependency
       on version 9.1.
      </para>
-->
<para>
这个函数是在<productname>PostgreSQL</>版本9.1中出现的，所以它不能用来在较早的版本中检测所需功能，
因此连接它将在版本9.1上创建一个连接依赖。
</para>
     </note>
    </listitem>
   </varlistentry>

  </variablelist>

 </sect1>

 <sect1 id="libpq-notice-processing">
  <!--
  <title>Notice Processing</title>
  -->
  <title>通知处理</title>

  <indexterm zone="libpq-notice-processing">
   <!--
   <primary>notice processing</primary>
   <secondary>in libpq</secondary>
   -->
   <primary>通知处理</primary>
   <secondary>在libpq中</secondary>
  </indexterm>

  <!--
<para>
   Notice and warning messages generated by the server are not returned
   by the query execution functions, since they do not imply failure of
   the query.  Instead they are passed to a notice handling function, and
   execution continues normally after the handler returns.  The default
   notice handling function prints the message on
   <filename>stderr</filename>, but the application can override this
   behavior by supplying its own handling function.
  </para>
-->
<para>
服务器生成的通知和警告消息都不会由查询执行函数返回，因为他们并不蕴涵着查询的失败。
它们会被传递给一个通知处理函数，然后在该处理返回之后继续正常执行。
缺省的通知处理函数在<filename>stderr</filename>上打印该信息，
但是应用可以通过提供自己的处理函数来覆盖这个行为。
</para>

  <!--
<para>
   For historical reasons, there are two levels of notice handling, called
   the notice receiver and notice processor.  The default behavior is for
   the notice receiver to format the notice and pass a string to the notice
   processor for printing.  However, an application that chooses to provide
   its own notice receiver will typically ignore the notice processor
   layer and just do all the work in the notice receiver.
  </para>
-->
<para>
由于历史原因，系统里存在两个级别的通知处理，分别叫做通知接收器和通知处理器。
缺省的行为是通知接收器格式化通知然后传递给通知处理器一个字串进行打印。
不过，对于自行处理这些事情的应用而言，通常是忽略通知处理器层，而只是在通知接收器里完成所有动作。
</para>
  
<para>
<!--
   The function <function>PQsetNoticeReceiver</function>
   <indexterm><primary>notice receiver</></>
   <indexterm><primary>PQsetNoticeReceiver</></> sets or
   examines the current notice receiver for a connection object.
   Similarly, <function>PQsetNoticeProcessor</function>
   <indexterm><primary>notice processor</></>
   <indexterm><primary>PQsetNoticeProcessor</></> sets or
   examines the current notice processor.
-->
函数<function>PQsetNoticeReceiver</function><indexterm><primary>通知接收器</></>
<indexterm><primary>PQsetNoticeReceiver</></>为一个连接对象设置或者检查当前的通知接收器。
类似的是<function>PQsetNoticeProcessor</function><indexterm><primary>通知处理器</></>
<indexterm><primary>PQsetNoticeProcessor</></>设置或者检查当前的通知处理器。
<synopsis>
typedef void (*PQnoticeReceiver) (void *arg, const PGresult *res);

PQnoticeReceiver
PQsetNoticeReceiver(PGconn *conn,
                    PQnoticeReceiver proc,
                    void *arg);

typedef void (*PQnoticeProcessor) (void *arg, const char *message);

PQnoticeProcessor
PQsetNoticeProcessor(PGconn *conn,
                     PQnoticeProcessor proc,
                     void *arg);
</synopsis>

<!-- 
   Each of these functions returns the previous notice receiver or
   processor function pointer, and sets the new value.  If you supply a
   null function pointer, no action is taken, but the current pointer is
   returned. 
-->
这些函数都返回前一个通知接收器或者处理器函数指针，然后设置新的数值。
如果你提供一个空函数指针，那么就不会执行任何动作，但是返回当前指针。
  </para>

  <!--
<para>
   When a notice or warning message is received from the server, or
   generated internally by <application>libpq</application>, the notice
   receiver function is called.  It is passed the message in the form of
   a <symbol>PGRES_NONFATAL_ERROR</symbol>
   <structname>PGresult</structname>.  (This allows the receiver to extract
   individual fields using <function>PQresultErrorField</>, or the complete
   preformatted message using <function>PQresultErrorMessage</>.) The same
   void pointer passed to <function>PQsetNoticeReceiver</function> is also
   passed.  (This pointer can be used to access application-specific state
   if needed.)
  </para>
-->
<para>
当我们从服务器获取一个注意或者警告消息的时候，或者是收到<application>libpq</application>
内部生成的类似信息时，通知接收器函数将被调用。消息会以一个<symbol>PGRES_NONFATAL_ERROR</symbol>
的<structname>PGresult</structname>的形式传递。（这就允许接收器用 <function>PQresultErrorField</>
抽取独立的字段，或者用<function>PQresultErrorMessage</>完成预先格式化好的信息。）
传递给<function>PQsetNoticeReceiver</function>的同一个 void 指针也同样传递给该函数。
（必要时，这个指针可以用来访问应用相关的状态。）
</para>

  <!--
<para>
   The default notice receiver simply extracts the message (using
   <function>PQresultErrorMessage</>) and passes it to the notice
   processor.
  </para>
-->
<para>
缺省的通知接收器只是简单的抽取信息（使用<function>PQresultErrorMessage</>）
然后传递给通知处理器。
</para>

  <!--
<para>
   The notice processor is responsible for handling a notice or warning
   message given in text form.  It is passed the string text of the message
   (including a trailing newline), plus a void pointer that is the same
   one passed to <function>PQsetNoticeProcessor</function>.  (This pointer
   can be used to access application-specific state if needed.)
  </para>
-->
<para>
通知处理器负责处理一个以文本形式给出的注意或者警告消息。系统传递给他消息的字串文本
（包括结尾的新行符），加上一个和传递给<function>PQsetNoticeProcessor</function>
一样的 void （无类型）指针。（必要时，这个指针可以用来访问应用相关的状态。）
</para>
 
<para>
<!--
   The default notice processor is simply:
-->
缺省的通知处理器就是：
<programlisting>
static void
defaultNoticeProcessor(void *arg, const char *message)
{
    fprintf(stderr, "%s", message);
}
</programlisting>
  </para>

  <!--
<para>
   Once you have set a notice receiver or processor, you should expect
   that that function could be called as long as either the
   <structname>PGconn</> object or <structname>PGresult</> objects made
   from it exist.  At creation of a <structname>PGresult</>, the
   <structname>PGconn</>'s current notice handling pointers are copied
   into the <structname>PGresult</> for possible use by functions like
   <function>PQgetvalue</function>.
  </para>
-->
<para>
一旦你设置了注意消息接收器或者处理器，那么你就应该准备好在<structname>PGconn</>
对象或者<structname>PGresult</>对象开始存在的时候起就有人调用它们。在创建
<structname>PGresult</>的时候，<structname>PGconn</>的当前通知处理指针被拷贝到
<structname>PGresult</>，以便被类似<function>PQgetvalue</function>这样的函数使用。
</para>

 </sect1>

 <sect1 id="libpq-events">
  <!--
  <title>Event System</title>
  -->
  <title>事件系统</title>

  <!--
<para>
   <application>libpq</application>'s event system is designed to notify
   registered event handlers about interesting
   <application>libpq</application> events, such as the creation or
   destruction of <structname>PGconn</structname> and
   <structname>PGresult</structname> objects.  A principal use case is that
   this allows applications to associate their own data with a
   <structname>PGconn</structname> or <structname>PGresult</structname>
   and ensure that that data is freed at an appropriate time.
  </para>
-->
<para>
<application>libpq</application>事件系统用于通知对<application>libpq</application>
事件感兴趣的注册事件处理过程，如创建或删除<structname>PGconn</structname>和
<structname>PGresult</structname>对象。一个主要的使用原因是，它允许应用程序通过一个
<structname>PGconn</structname>或<structname>PGresult</structname>关联它们自己的数据，
并且确保数据在适当的时候释放。
</para>

  <!--
<para>
   Each registered event handler is associated with two pieces of data,
   known to <application>libpq</application> only as opaque <literal>void *</>
   pointers.  There is a <firstterm>passthrough</> pointer that is provided
   by the application when the event handler is registered with a
   <structname>PGconn</>.  The passthrough pointer never changes for the
   life of the <structname>PGconn</> and all <structname>PGresult</>s
   generated from it; so if used, it must point to long-lived data.
   In addition there is an <firstterm>instance data</> pointer, which starts
   out <symbol>NULL</> in every <structname>PGconn</> and <structname>PGresult</>.
   This pointer can be manipulated using the
   <function>PQinstanceData</function>,
   <function>PQsetInstanceData</function>,
   <function>PQresultInstanceData</function> and
   <function>PQsetResultInstanceData</function> functions.  Note that
   unlike the passthrough pointer, instance data of a <structname>PGconn</>
   is not automatically inherited by <structname>PGresult</>s created from
   it.  <application>libpq</application> does not know what passthrough
   and instance data pointers point to (if anything) and will never attempt
   to free them &mdash; that is the responsibility of the event handler.
  </para>
-->
<para>
每个注册的事件处理程序与两片数据相关联，已知的<application>libpq</application>
只作为不透明的<literal>void *</>指针。当事件处理程序注册带有<structname>PGconn</>时，
应用程序会提供一个<firstterm>passthrough</>指针。传递指针在由它产生的<structname>PGconn</>
和所有的<structname>PGresult</>的生命周期中永远不会改变，它指向生命周期长的数据。
除此之外，还有一个<firstterm>instance data</>指针，它从每个<structname>PGconn</>和
<structname>PGresult</>中的<symbol>NULL</>开始。这个指针可以与<function>PQinstanceData</function>，
<function>PQsetInstanceData</function>，<function>PQresultInstanceData</function>和
<function>PQsetResultInstanceData</function>函数一起使用。需要注意的是不同于传递指针，
一个<structname>PGconn</>的实例数据不会被由它产生的<structname>PGresult</>自动继承。
<application>libpq</application>不知道传递和实例数据指针指向的是什么，并且不会尝试去释放它们；
这对事件处理程序是一种保证。
</para>

  <sect2 id="libpq-events-types">
   <!--
   <title>Event Types</title>
   -->
   <title>事件类型</title>

   <!--
<para>
    The enum <literal>PGEventId</> names the types of events handled by
    the event system.  All its values have names beginning with
    <literal>PGEVT</literal>.  For each event type, there is a corresponding
    event info structure that carries the parameters passed to the event
    handlers.  The event types are:
   </para>
-->
<para>
枚举<literal>PGEventId</>命名事件系统处理的事件的类型。所有的命名值都是从
<literal>PGEVT</literal>开始。对每个事件类型来说，有一个相应的事件信息结构，
用于传送传递给事件处理程序的参数。事件类型如下：
</para>

   <variablelist>
    <varlistentry id="libpq-pgevt-register">
     <term><literal>PGEVT_REGISTER</literal></term>
     <listitem>
      
<para>
<!--
       The register event occurs when <function>PQregisterEventProc</function>
       is called.  It is the ideal time to initialize any
       <literal>instanceData</literal> an event procedure may need.  Only one
       register event will be fired per event handler per connection.  If the
       event procedure fails, the registration is aborted.
-->
当调用<function>PQregisterEventProc</function>时，会发生注册的事件。这是一个理想化的时间，
用于初始化任意<literal>instanceData</literal>，可能需要一个事件过程。
每次连接中的每个事件处理程序只会触发一个注册了的事件。如果事件过程失败，会终止注册。
<synopsis>
typedef struct
{
    PGconn *conn;
} PGEventRegister;
</synopsis>

<!-- 
       When a <literal>PGEVT_REGISTER</literal> event is received, the
       <parameter>evtInfo</parameter> pointer should be cast to a
       <structname>PGEventRegister *</structname>.  This structure contains a
       <structname>PGconn</structname> that should be in the
       <literal>CONNECTION_OK</literal> status; guaranteed if one calls
       <function>PQregisterEventProc</function> right after obtaining a good
       <structname>PGconn</structname>.  When returning a failure code, all
       cleanup must be performed as no <literal>PGEVT_CONNDESTROY</literal>
       event will be sent. 
-->
当接收到<literal>PGEVT_REGISTER</literal>时，<parameter>evtInfo</parameter>
指针应该被转换为一个<structname>PGEventRegister *</structname>。
这个结构包含了一个<literal>CONNECTION_OK</literal>状态的<structname>PGconn</structname>；
用以保证在获得一个好的<structname>PGconn</structname>之后立即请求调用
<function>PQregisterEventProc</function>。当返回一个错误代码时，必须执行所有的清理，
因为没有<literal>PGEVT_CONNDESTROY</literal>会被发送。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pgevt-connreset">
     <term><literal>PGEVT_CONNRESET</literal></term>
     <listitem>
<para>
<!--
       The connection reset event is fired on completion of
       <function>PQreset</function> or <function>PQresetPoll</function>.  In
       both cases, the event is only fired if the reset was successful.  If
       the event procedure fails, the entire connection reset will fail; the
       <structname>PGconn</structname> is put into
       <literal>CONNECTION_BAD</literal> status and
       <function>PQresetPoll</function> will return
       <literal>PGRES_POLLING_FAILED</literal>.
-->
<function>PQreset</function>或<function>PQresetPoll</function>函数完成时，触发连接复位事件。
在这两种情况下，只有重置成功时才会触发事件。如果事件过程失败，整个连接复位都会失败；
<structname>PGconn</structname>被置为<literal>CONNECTION_BAD</literal>状态并且
<function>PQresetPoll</function>将返回<literal>PGRES_POLLING_FAILED</literal>。
<synopsis>
typedef struct
{
    PGconn *conn;
} PGEventConnReset;
</synopsis>

<!-- 
       When a <literal>PGEVT_CONNRESET</literal> event is received, the
       <parameter>evtInfo</parameter> pointer should be cast to a
       <structname>PGEventConnReset *</structname>.  Although the contained
       <structname>PGconn</structname> was just reset, all event data remains
       unchanged.  This event should be used to reset/reload/requery any
       associated <literal>instanceData</literal>.  Note that even if the
       event procedure fails to process <literal>PGEVT_CONNRESET</>, it will
       still receive a <literal>PGEVT_CONNDESTROY</> event when the connection
       is closed. 
-->
当接收到一个<literal>PGEVT_CONNRESET</literal>事件时，<parameter>evtInfo</parameter>
指针应该被转换为一个<structname>PGEventConnReset *</structname>。尽管包含的
<structname>PGconn</structname>被重置了，但所有事件数据不会改变。
这个事件应该用于reset/reload/requery任何关联的<literal>instanceData</literal>。
需要注意的是即使事件过程在处理<literal>PGEVT_CONNRESET</>时失败了，当连接关闭时，
仍会接收一个<literal>PGEVT_CONNDESTROY</>事件。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pgevt-conndestroy">
     <term><literal>PGEVT_CONNDESTROY</literal></term>
     <listitem>
      
<para>
<!--
       The connection destroy event is fired in response to
       <function>PQfinish</function>.  It is the event procedure's
       responsibility to properly clean up its event data as libpq has no
       ability to manage this memory.  Failure to clean up will lead
       to memory leaks.
-->
在响应<function>PQfinish</function>时会触发连接破坏事件。这是事件过程的职责：
合适的清理它的事件数据，因为libpq没有能力管理这部分内存。失败的清理会导致内存溢出。
<synopsis>
typedef struct
{
    PGconn *conn;
} PGEventConnDestroy;
</synopsis>

<!-- 
       When a <literal>PGEVT_CONNDESTROY</literal> event is received, the
       <parameter>evtInfo</parameter> pointer should be cast to a
       <structname>PGEventConnDestroy *</structname>.  This event is fired
       prior to <function>PQfinish</function> performing any other cleanup.
       The return value of the event procedure is ignored since there is no
       way of indicating a failure from <function>PQfinish</function>.  Also,
       an event procedure failure should not abort the process of cleaning up
       unwanted memory. 
-->
当接收到一个<literal>PGEVT_CONNDESTROY</literal>事件时，<parameter>evtInfo</parameter>
指针应该被转换为一个<structname>PGEventConnDestroy *</structname>。
在<function>PQfinish</function>执行清理之前会触发该事件。事件过程的返回值会被忽略，
因为没有很好的方式从<function>PQfinish</function>指出失败。同样，
一个事件过程失败不应该中止清理不需要的内存的过程。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pgevt-resultcreate">
     <term><literal>PGEVT_RESULTCREATE</literal></term>
     <listitem>     
<para>
<!--
       The result creation event is fired in response to any query execution
       function that generates a result, including
       <function>PQgetResult</function>.  This event will only be fired after
       the result has been created successfully.
-->
回应任意产生一个结果（包括<function>PQgetResult</function>）的查询执行函数时，
会触发结果创建事件。这个事件只有在成功创建结果时才会被触发。
<synopsis>
typedef struct
{
    PGconn *conn;
    PGresult *result;
} PGEventResultCreate;
</synopsis>

<!-- 
       When a <literal>PGEVT_RESULTCREATE</literal> event is received, the
       <parameter>evtInfo</parameter> pointer should be cast to a
       <structname>PGEventResultCreate *</structname>.  The
       <parameter>conn</parameter> is the connection used to generate the
       result.  This is the ideal place to initialize any
       <literal>instanceData</literal> that needs to be associated with the
       result.  If the event procedure fails, the result will be cleared and
       the failure will be propagated.  The event procedure must not try to
       <function>PQclear</> the result object for itself.  When returning a
       failure code, all cleanup must be performed as no
       <literal>PGEVT_RESULTDESTROY</literal> event will be sent. 
-->
当接收到一个<literal>PGEVT_RESULTCREATE</literal>事件时，<parameter>evtInfo</parameter>
指针应该被转换为一个<structname>PGEventResultCreate *</structname>。<parameter>conn</parameter>
是用于产生结果的连接。这是理想的位置，用于初始化任意需要与结果相关联的<literal>instanceData</literal>。
如果事件过程失败，结果会被清理并且传播该失败。事件过程不应该尝试自己<function>PQclear</>结果对象。
当返回一个错误代码时，必须执行所有的清理，因为没有<literal>PGEVT_RESULTDESTROY</literal>会被发送。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pgevt-resultcopy">
     <term><literal>PGEVT_RESULTCOPY</literal></term>
     <listitem>
      
<para>
<!--
       The result copy event is fired in response to
       <function>PQcopyResult</function>.  This event will only be fired after
       the copy is complete.  Only event procedures that have
       successfully handled the <literal>PGEVT_RESULTCREATE</literal>
       or <literal>PGEVT_RESULTCOPY</literal> event for the source result
       will receive <literal>PGEVT_RESULTCOPY</literal> events.
-->
在响应<function>PQcopyResult</function>时会触发结果拷贝事件。只有在拷贝完成时，
才会触发该事件。只有那些为源结果成功处理<literal>PGEVT_RESULTCREATE</literal>或
<literal>PGEVT_RESULTCOPY</literal>事件的事件过程才会收到<literal>PGEVT_RESULTCOPY</literal>事件。
<synopsis>
typedef struct
{
    const PGresult *src;
    PGresult *dest;
} PGEventResultCopy;
</synopsis>

<!-- 
       When a <literal>PGEVT_RESULTCOPY</literal> event is received, the
       <parameter>evtInfo</parameter> pointer should be cast to a
       <structname>PGEventResultCopy *</structname>.  The
       <parameter>src</parameter> result is what was copied while the
       <parameter>dest</parameter> result is the copy destination.  This event
       can be used to provide a deep copy of <literal>instanceData</literal>,
       since <literal>PQcopyResult</literal> cannot do that.  If the event
       procedure fails, the entire copy operation will fail and the
       <parameter>dest</parameter> result will be cleared.   When returning a
       failure code, all cleanup must be performed as no
       <literal>PGEVT_RESULTDESTROY</literal> event will be sent for the
       destination result. 
-->
当接收到一个<literal>PGEVT_RESULTCOPY</literal>事件时，<parameter>evtInfo</parameter>
指针应该被转换为一个<structname>PGEventResultCopy *</structname>。<parameter>src</parameter>
结果是当<parameter>dest</parameter> 为拷贝目标时要进行拷贝的。这个事件用于提供一个
<literal>instanceData</literal>的深度拷贝，因为<literal>PQcopyResult</literal>做不到。
如果事件过程失败，整个拷贝过程都将失败，并且<parameter>dest</parameter>结果也会被清理。
当返回一个错误代码时，必须执行所有的清理，因为没有<literal>PGEVT_RESULTDESTROY</literal>事件会被发送。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pgevt-resultdestroy">
     <term><literal>PGEVT_RESULTDESTROY</literal></term>
     <listitem>
      
<para>
<!--
       The result destroy event is fired in response to a
       <function>PQclear</function>.  It is the event procedure's
       responsibility to properly clean up its event data as libpq has no
       ability to manage this memory.  Failure to clean up will lead
       to memory leaks.
-->
在回应<function>PQclear</function>时会触发结果破坏事件。这是事件过程的责任；
合理清理它的事件数据，因为libpq没有能力管理这块内存。清理失败会导致内存溢出。
<synopsis>
typedef struct
{
    PGresult *result;
} PGEventResultDestroy;
</synopsis>

<!-- 
       When a <literal>PGEVT_RESULTDESTROY</literal> event is received, the
       <parameter>evtInfo</parameter> pointer should be cast to a
       <structname>PGEventResultDestroy *</structname>.  This event is fired
       prior to <function>PQclear</function> performing any other cleanup.
       The return value of the event procedure is ignored since there is no
       way of indicating a failure from <function>PQclear</function>.  Also,
       an event procedure failure should not abort the process of cleaning up
       unwanted memory. 
-->
当接收到一个<literal>PGEVT_RESULTDESTROY</literal>事件时，<parameter>evtInfo</parameter>
指针应该被转换为一个<structname>PGEventResultDestroy *</structname>。
这个事件会在<function>PQclear</function>执行清理之前被触发。事件过程的返回结果会被忽略，
因为没有一个方式能够从<function>PQclear</function>指出失败。同样，
一个事件过程失败不应该中止对不需要内存的清理。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 id="libpq-events-proc">
   <!--
   <title>Event Callback Procedure</title>
   -->
   <title>事件回调过程</title>

   <variablelist>
    <varlistentry id="libpq-pgeventproc">
     <term>
      <literal>PGEventProc</literal>
      <indexterm>
       <primary>PGEventProc</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       <literal>PGEventProc</literal> is a typedef for a pointer to an
       event procedure, that is, the user callback function that receives
       events from libpq.  The signature of an event procedure must be
-->
<literal>PGEventProc</literal>是一个事件过程中指针的typedef，也就是，
从libpq接收事件的用户回调函数。事件过程的用法必须如下：
<synopsis>
int eventproc(PGEventId evtId, void *evtInfo, void *passThrough)
</synopsis>

<!-- 
       The <parameter>evtId</parameter> parameter indicates which
       <literal>PGEVT</literal> event occurred.  The
       <parameter>evtInfo</parameter> pointer must be cast to the appropriate
       structure type to obtain further information about the event.
       The <parameter>passThrough</parameter> parameter is the pointer
       provided to <function>PQregisterEventProc</function> when the event
       procedure was registered.  The function should return a non-zero value
       if it succeeds and zero if it fails.
-->
<parameter>evtId</parameter>参数指出要发生哪个<literal>PGEVT</literal>事件。
<parameter>evtInfo</parameter>指针必须被转换为合适的结构类型以获取有关该事件的进一步信息。
<parameter>passThrough</parameter>是当事件过程被注册时，提供给
<function>PQregisterEventProc</function>的指针。这个函数应该返回一个非0的值，如果成功的话，反之，返回0。
      </para>

      <!--
<para>
       A particular event procedure can be registered only once in any
       <structname>PGconn</>.  This is because the address of the procedure
       is used as a lookup key to identify the associated instance data.
      </para>
-->
<para>
在任意<structname>PGconn</>中，一个特殊的事件过程只能注册一次。
这是因为过程地址被用于作为查询关键字，以识别相关的实例数据。
</para>

      <caution>
       <!--
<para>
        On Windows, functions can have two different addresses: one visible
        from outside a DLL and another visible from inside the DLL.  One
        should be careful that only one of these addresses is used with
        <application>libpq</>'s event-procedure functions, else confusion will
        result.  The simplest rule for writing code that will work is to
        ensure that event procedures are declared <literal>static</>.  If the
        procedure's address must be available outside its own source file,
        expose a separate function to return the address.
       </para>
-->
<para>
在Windows上，函数可以有两个不同的地址：一个是内部DLL可见的，另一个是外部DLL可见的。
需要注意的是，<application>libpq</>事件过程函数只会使用其中一个地址，否则会造成混乱。
有效的编写代码的简单规则是为了保证事件过程声明为<literal>static</>。
如果过程地址在它的源文件之外是可用的，公开一个单独的函数以返回地址。
</para>
      </caution>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 id="libpq-events-funcs">
   <!--
   <title>Event Support Functions</title>
   -->
   <title>事件支持函数</title>

    <variablelist>
    <varlistentry id="libpq-pqregistereventproc">
     <term>
      <function>PQregisterEventProc</function>
      <indexterm>
       <primary>PQregisterEventProc</primary>
      </indexterm>
     </term>

     <listitem>
      
<para>
<!--
       Registers an event callback procedure with libpq.
-->
用libpq注册一个事件回调过程。
<synopsis>
int PQregisterEventProc(PGconn *conn, PGEventProc proc,
                        const char *name, void *passThrough);
</synopsis>
      </para>

      <!--
<para>
       An event procedure must be registered once on each
       <structname>PGconn</> you want to receive events about.  There is no
       limit, other than memory, on the number of event procedures that
       can be registered with a connection.  The function returns a non-zero
       value if it succeeds and zero if it fails.
      </para>
-->
<para>
在每个<structname>PGconn</>中必须注册一次事件过程，用于希望接受到的事件。除了内存之外，
对于一次连接注册的事件过程个数没有限制。如果成功，则返回一个非0的值，否则返回0。
</para>

      <!--
<para>
       The <parameter>proc</parameter> argument will be called when a libpq
       event is fired.  Its memory address is also used to lookup
       <literal>instanceData</literal>.  The <parameter>name</parameter>
       argument is used to refer to the event procedure in error messages.
       This value cannot be <symbol>NULL</> or a zero-length string.  The name string is
       copied into the <structname>PGconn</>, so what is passed need not be
       long-lived.  The <parameter>passThrough</parameter> pointer is passed
       to the <parameter>proc</parameter> whenever an event occurs. This
       argument can be <symbol>NULL</>.
      </para>
-->
<para>
当一个libpq事件被触发时，会调用一个<parameter>proc</parameter>参数。
内存地址同样会被用于查找<literal>instanceData</literal>。<parameter>name</parameter>
用于指出在错误消息中的事件过程。这个值不能为<symbol>NULL</>或一个长度为0的字符串。
名字字符串被拷贝到<structname>PGconn</>中，因此被传递的不需要拥有很长的生命周期。
<parameter>passThrough</parameter>指针被传递到<parameter>proc</parameter>，
不管何时触发事件。这个参数可以是<symbol>NULL</>。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsetinstancedata">
     <term>
      <function>PQsetInstanceData</function>
      <indexterm>
       <primary>PQsetInstanceData</primary>
      </indexterm>
     </term>
     <listitem>
      
<para>
<!--
       Sets the connection <parameter>conn</>'s <literal>instanceData</>
       for procedure <parameter>proc</> to <parameter>data</>.  This
       returns non-zero for success and zero for failure.  (Failure is
       only possible if <parameter>proc</> has not been properly
       registered in <parameter>conn</>.)
-->
为<parameter>proc</>到<parameter>data</>的过程设置连接<parameter>conn</>
的<literal>instanceData</>。成功则返回一个非0值，否则返回0。
只有<parameter>proc</>没有成功在<parameter>conn</>注册时才会发生失败。
<synopsis>
int PQsetInstanceData(PGconn *conn, PGEventProc proc, void *data);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqinstancedata">
     <term>
      <function>PQinstanceData</function>
      <indexterm>
       <primary>PQinstanceData</primary>
      </indexterm>
     </term>
     <listitem>
      
<para>
<!--
       Returns the
       connection <parameter>conn</>'s <literal>instanceData</literal>
       associated with procedure <parameter>proc</>,
       or <symbol>NULL</symbol> if there is none.
-->
返回与<parameter>proc</>过程，或<symbol>NULL</symbol>（如果存在空）
相关的<parameter>conn</>的<literal>instanceData</literal>。
<synopsis>
void *PQinstanceData(const PGconn *conn, PGEventProc proc);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqresultsetinstancedata">
     <term>
      <function>PQresultSetInstanceData</function>
      <indexterm>
       <primary>PQresultSetInstanceData</primary>
      </indexterm>
     </term>
     <listitem>
      
<para>
<!--
       Sets the result's <literal>instanceData</>
       for <parameter>proc</> to <parameter>data</>.  This returns
       non-zero for success and zero for failure.  (Failure is only
       possible if <parameter>proc</> has not been properly registered
       in the result.)
-->
为<parameter>proc</>到<parameter>data</>的过程设置结果的<literal>instanceData</>。
成功则返回一个非0值，否则返回0。只有<parameter>proc</>没有成功在结果注册时才会发生失败。
<synopsis>
int PQresultSetInstanceData(PGresult *res, PGEventProc proc, void *data);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqresultinstancedata">
     <term>
      <function>PQresultInstanceData</function>
      <indexterm>
       <primary>PQresultInstanceData</primary>
      </indexterm>
     </term>
     <listitem>
      
<para>
<!--
       Returns the result's <literal>instanceData</> associated with <parameter>proc</>, or <symbol>NULL</>
       if there is none.
-->
返回与<parameter>proc</>过程，或<symbol>NULL</>（如果存在空）相关的结果的<literal>instanceData</>。
<synopsis>
void *PQresultInstanceData(const PGresult *res, PGEventProc proc);
</synopsis>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 id="libpq-events-example">
   <!--
   <title>Event Example</title>
   -->
   <title>事件例子</title>

   <!--
<para>
    Here is a skeleton example of managing private data associated with
    libpq connections and results.
   </para>
-->
<para>
一个管理与libpq连接和结果相关的私有数据的例子：
</para>

<!--
<programlisting>
<![CDATA[
/* required header for libpq events (note: includes libpq-fe.h) */
#include <libpq-events.h>

/* The instanceData */
typedef struct
{
    int n;
    char *str;
} mydata;

/* PGEventProc */
static int myEventProc(PGEventId evtId, void *evtInfo, void *passThrough);

int
main(void)
{
    mydata *data;
    PGresult *res;
    PGconn *conn = PQconnectdb("dbname = postgres");

    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        PQfinish(conn);
        return 1;
    }

    /* called once on any connection that should receive events.
     * Sends a PGEVT_REGISTER to myEventProc.
     */
    if (!PQregisterEventProc(conn, myEventProc, "mydata_proc", NULL))
    {
        fprintf(stderr, "Cannot register PGEventProc\n");
        PQfinish(conn);
        return 1;
    }

    /* conn instanceData is available */
    data = PQinstanceData(conn, myEventProc);

    /* Sends a PGEVT_RESULTCREATE to myEventProc */
    res = PQexec(conn, "SELECT 1 + 1");

    /* result instanceData is available */
    data = PQresultInstanceData(res, myEventProc);

    /* If PG_COPYRES_EVENTS is used, sends a PGEVT_RESULTCOPY to myEventProc */
    res_copy = PQcopyResult(res, PG_COPYRES_TUPLES | PG_COPYRES_EVENTS);

    /* result instanceData is available if PG_COPYRES_EVENTS was
     * used during the PQcopyResult call.
     */
    data = PQresultInstanceData(res_copy, myEventProc);

    /* Both clears send a PGEVT_RESULTDESTROY to myEventProc */
    PQclear(res);
    PQclear(res_copy);

    /* Sends a PGEVT_CONNDESTROY to myEventProc */
    PQfinish(conn);

    return 0;
}

static int
myEventProc(PGEventId evtId, void *evtInfo, void *passThrough)
{
    switch (evtId)
    {
        case PGEVT_REGISTER:
        {
            PGEventRegister *e = (PGEventRegister *)evtInfo;
            mydata *data = get_mydata(e->conn);

            /* associate app specific data with connection */
            PQsetInstanceData(e->conn, myEventProc, data);
            break;
        }

        case PGEVT_CONNRESET:
        {
            PGEventConnReset *e = (PGEventConnReset *)evtInfo;
            mydata *data = PQinstanceData(e->conn, myEventProc);

            if (data)
              memset(data, 0, sizeof(mydata));
            break;
        }

        case PGEVT_CONNDESTROY:
        {
            PGEventConnDestroy *e = (PGEventConnDestroy *)evtInfo;
            mydata *data = PQinstanceData(e->conn, myEventProc);

            /* free instance data because the conn is being destroyed */
            if (data)
              free_mydata(data);
            break;
        }

        case PGEVT_RESULTCREATE:
        {
            PGEventResultCreate *e = (PGEventResultCreate *)evtInfo;
            mydata *conn_data = PQinstanceData(e->conn, myEventProc);
            mydata *res_data = dup_mydata(conn_data);

            /* associate app specific data with result (copy it from conn) */
            PQsetResultInstanceData(e->result, myEventProc, res_data);
            break;
        }

        case PGEVT_RESULTCOPY:
        {
            PGEventResultCopy *e = (PGEventResultCopy *)evtInfo;
            mydata *src_data = PQresultInstanceData(e->src, myEventProc);
            mydata *dest_data = dup_mydata(src_data);

            /* associate app specific data with result (copy it from a result) */
            PQsetResultInstanceData(e->dest, myEventProc, dest_data);
            break;
        }

        case PGEVT_RESULTDESTROY:
        {
            PGEventResultDestroy *e = (PGEventResultDestroy *)evtInfo;
            mydata *data = PQresultInstanceData(e->result, myEventProc);

            /* free instance data because the result is being destroyed */
            if (data)
              free_mydata(data);
            break;
        }

        /* unknown event ID, just return TRUE. */
        default:
            break;
    }

    return TRUE; /* event processing succeeded */
}
]]>
</programlisting>
-->
<programlisting><![CDATA[
/* 需要libpq事件的头文件 (注意：包括 libpq-fe.h) */
#include <libpq-events.h>

/* The instanceData */
typedef struct
{
    int n;
    char *str;
} mydata;

/* PGEventProc */
static int myEventProc(PGEventId evtId, void *evtInfo, void *passThrough);

int
main(void)
{
    mydata *data;
    PGresult *res;
    PGconn *conn = PQconnectdb("dbname = postgres");

    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        PQfinish(conn);
        return 1;
    }

    /* 在任何应该接收事件的连接上调用一次。
     * 发送一个 PGEVT_REGISTER 到 myEventProc。
     */
    if (!PQregisterEventProc(conn, myEventProc, "mydata_proc", NULL))
    {
        fprintf(stderr, "Cannot register PGEventProc\n");
        PQfinish(conn);
        return 1;
    }


    /* conn instanceData 是可用的 */
    data = PQinstanceData(conn, myEventProc);

    /* 发送一个 PGEVT_RESULTCREATE 到 myEventProc */
    res = PQexec(conn, "SELECT 1 + 1");

    /* 结果 instanceData 是可用的 */
    data = PQresultInstanceData(res, myEventProc);

    /* 如果使用了 PG_COPYRES_EVENTS，发送一个 PGEVT_RESULTCOPY到 myEventProc */
    res_copy = PQcopyResult(res, PG_COPYRES_TUPLES | PG_COPYRES_EVENTS);

    /* 结果 instanceData 是可用的，如果 PG_COPYRES_EVENTS 
     * 在PQcopyResult调用期间使用了的话。
     */
    data = PQresultInstanceData(res_copy, myEventProc);

    /* 两个clears都发送 PGEVT_RESULTDESTROY 到 myEventProc */
    PQclear(res);
    PQclear(res_copy);

    /* 发送一个 PGEVT_CONNDESTROY 到 myEventProc */
    PQfinish(conn);

    return 0;
}

static int
myEventProc(PGEventId evtId, void *evtInfo, void *passThrough)
{
    switch (evtId)
    {
        case PGEVT_REGISTER:
        {
            PGEventRegister *e = (PGEventRegister *)evtInfo;
            mydata *data = get_mydata(e->conn);

            /* 将应用程序特定的数据与连接相关联 */
            PQsetInstanceData(e->conn, myEventProc, data);
            break;
        }

        case PGEVT_CONNRESET:
        {
            PGEventConnReset *e = (PGEventConnReset *)evtInfo;
            mydata *data = PQinstanceData(e->conn, myEventProc);

            if (data)
              memset(data, 0, sizeof(mydata));
            break;
        }

        case PGEVT_CONNDESTROY:
        {
            PGEventConnDestroy *e = (PGEventConnDestroy *)evtInfo;
            mydata *data = PQinstanceData(e->conn, myEventProc);

            /* 释放实例数据，因为conn被破坏了 */
            if (data)
              free_mydata(data);
            break;
        }

        case PGEVT_RESULTCREATE:
        {
            PGEventResultCreate *e = (PGEventResultCreate *)evtInfo;
            mydata *conn_data = PQinstanceData(e->conn, myEventProc);
            mydata *res_data = dup_mydata(conn_data);

            /* 将应用程序特定的数据与结果相关联 (从conn中拷贝) */
            PQsetResultInstanceData(e->result, myEventProc, res_data);
            break;
        }

        case PGEVT_RESULTCOPY:
        {
            PGEventResultCopy *e = (PGEventResultCopy *)evtInfo;
            mydata *src_data = PQresultInstanceData(e->src, myEventProc);
            mydata *dest_data = dup_mydata(src_data);

            /* 将应用程序特定的数据与结果相关联 (从结果中拷贝) */
            PQsetResultInstanceData(e->dest, myEventProc, dest_data);
            break;
        }

        case PGEVT_RESULTDESTROY:
        {
            PGEventResultDestroy *e = (PGEventResultDestroy *)evtInfo;
            mydata *data = PQresultInstanceData(e->result, myEventProc);

            /* 释放实例数据，因为结果被破坏了 */
            if (data)
              free_mydata(data);
            break;
        }

        /* 未知事件ID，只是返回TRUE。*/
        default:
            break;
    }

    return TRUE; /* 事件处理成功 */
}
]]>
</programlisting>
  </sect2>
 </sect1>

 <sect1 id="libpq-envars">
  <!--
  <title>Environment Variables</title>
  -->
  <title>环境变量</title>

  <indexterm zone="libpq-envars">
   <!--
   <primary>environment variable</primary>
   -->
   <primary>环境变量</primary>
  </indexterm>

  
<para>
<!-- 
   The following environment variables can be used to select default
   connection parameter values, which will be used by
   <function>PQconnectdb</>, <function>PQsetdbLogin</> and
   <function>PQsetdb</> if no value is directly specified by the calling
   code.  These are useful to avoid hard-coding database connection
   information into simple client applications, for example.
-->
下面的环境变量可以用于选择缺省的连接参数值，这些值将被<function>PQconnectdb</>
，<function>PQsetdbLogin</>和<function>PQsetdb</>使用，如果调用代码没有直接声明相应值的话。
比如，这些（环境变量）可以避免把硬编码数据库连接信息写入简单的客户端应用中。
   <itemizedlist>
    <listitem>

     <para>
      <indexterm>
       <primary><envar>PGHOST</envar></primary>
      </indexterm>
<!--
     <envar>PGHOST</envar> behaves the same as the <xref
      linkend="libpq-connect-host"> connection parameter.
-->
<envar>PGHOST</envar>与<xref linkend="libpq-connect-host">连接参数表现行为相同。
     </para>
    </listitem>

    <listitem>
     
<para>
      <indexterm>
       <primary><envar>PGHOSTADDR</envar></primary>
      </indexterm>
<!--
      <envar>PGHOSTADDR</envar> behaves the same as the <xref
      linkend="libpq-connect-hostaddr"> connection parameter.
      This can be set instead of or in addition to <envar>PGHOST</envar>
      to avoid DNS lookup overhead.
-->
<envar>PGHOSTADDR</envar>与hostaddr连接参数表现行为相同。这样可以代替或除去PGHOST以避免DNS查找的开销。
     </para>
    </listitem>

    <listitem>
     
<para>
      <indexterm>
       <primary><envar>PGPORT</envar></primary>
      </indexterm>
<!--
      <envar>PGPORT</envar> behaves the same as the <xref
      linkend="libpq-connect-port"> connection parameter.
-->
<envar>PGPORT</envar>与<xref linkend="libpq-connect-port">连接参数表现行为相同。
     </para>
    </listitem>

    <listitem>
     
<para>
      <indexterm>
       <primary><envar>PGDATABASE</envar></primary>
      </indexterm>
<!--
      <envar>PGDATABASE</envar> behaves the same as the <xref
      linkend="libpq-connect-dbname"> connection parameter.
-->
<envar>PGDATABASE</envar>与<xref linkend="libpq-connect-dbname">连接参数表现行为相同。
      </para>
    </listitem>

    <listitem>
     
<para>
      <indexterm>
       <primary><envar>PGUSER</envar></primary>
      </indexterm>
<!--
      <envar>PGUSER</envar> behaves the same as the <xref
      linkend="libpq-connect-user"> connection parameter.
-->
<envar>PGUSER</envar>与<xref linkend="libpq-connect-user">连接参数表现行为相同。
     </para>
    </listitem>

    <listitem>
     
<para>
      <indexterm>
       <primary><envar>PGPASSWORD</envar></primary>
      </indexterm>
<!--
      <envar>PGPASSWORD</envar> behaves the same as the <xref
      linkend="libpq-connect-password"> connection parameter.
      Use of this environment variable
      is not recommended for security reasons, as some operating systems
      allow non-root users to see process environment variables via
      <application>ps</>; instead consider using the
      <filename>~/.pgpass</> file (see <xref linkend="libpq-pgpass">).
-->
<envar>PGPASSWORD</envar>与<xref linkend="libpq-connect-password">连接参数表现行为相同。
出于安全原因是不推荐使用这个环境变量的，因为某些操作系统允许非root用户通过<application>ps</>
看到进程的环境变量，而是考虑使用<filename>~/.pgpass</>的文件（详情请看<xref linkend="libpq-pgpass">）。
     </para>
    </listitem>

    <listitem>
     
<para>
      <indexterm>
       <primary><envar>PGPASSFILE</envar></primary>
      </indexterm>
<!--
      <envar>PGPASSFILE</envar> specifies the name of the password file to
      use for lookups.  If not set, it defaults to <filename>~/.pgpass</>
      (see <xref linkend="libpq-pgpass">).
-->
<envar>PGPASSFILE</envar>指定密码文件的名称用于查找。如果没有设置，
默认为<filename>~/.pgpass</>（见<xref linkend="libpq-pgpass">）。
     </para>
    </listitem>

    <listitem>
     
<para>
      <indexterm>
       <primary><envar>PGSERVICE</envar></primary>
      </indexterm>
<!--
      <envar>PGSERVICE</envar> behaves the same as the <xref
      linkend="libpq-connect-service"> connection parameter.
-->
<envar>PGSERVICE</envar>与<xref linkend="libpq-connect-service">连接参数表现行为相同。
     </para>
    </listitem>

    <listitem>
     
<para>
      <indexterm>
       <primary><envar>PGSERVICEFILE</envar></primary>
      </indexterm>
<!--
      <envar>PGSERVICEFILE</envar> specifies the name of the per-user
      connection service file.  If not set, it defaults
      to <filename>~/.pg_service.conf</>
      (see <xref linkend="libpq-pgservice">).
-->
<envar>PGSERVICEFILE</envar>指定连接服务的文件中每个用户的名字，
如果没有设置默认<filename>~/.pg_service.conf</> (见<xref linkend="libpq-pgservice">)。
     </para>
    </listitem>

    <listitem>
     
<para>
      <indexterm>
       <primary><envar>PGREALM</envar></primary>
      </indexterm>
<!--
      <envar>PGREALM</envar> sets the Kerberos realm to use with
      <productname>PostgreSQL</productname>, if  it is different from the
      local realm.  If <envar>PGREALM</envar> is set,
      <application>libpq</application> applications will attempt
      authentication  with  servers for this realm and use separate ticket
      files to avoid conflicts with local ticket files.   This
      environment  variable is only used if GSSAPI authentication is
      selected by the server.
-->
<envar>PGREALM</envar>设置与<productname>PostgreSQL</productname>一起使用的 Kerberos 域，
如果该域与本地域不同的话。如果设置了<envar>PGREALM</envar>，<application>libpq</application>
应用将试图用这个域（realm）与服务器进行认证并且使用独立的门票文件（ticket files）
以避免与本地的门票文件冲突。只有在服务器选择了 GSSAPI 认证时才使用这个环境变量。
     </para>
    </listitem>

    <listitem>
     
<para>
      <indexterm>
       <primary><envar>PGOPTIONS</envar></primary>
      </indexterm>
<!--
      <envar>PGOPTIONS</envar> behaves the same as the <xref
      linkend="libpq-connect-options"> connection parameter.
-->
<envar>PGOPTIONS</envar>与<xref linkend="libpq-connect-options">连接参数表现行为相同。
     </para>
    </listitem>

    <listitem>
     
<para>
      <indexterm>
       <primary><envar>PGAPPNAME</envar></primary>
      </indexterm>
<!--
      <envar>PGAPPNAME</envar> behaves the same as the <xref
      linkend="libpq-connect-application-name"> connection parameter.
-->
<envar>PGAPPNAME</envar>与<xref linkend="libpq-connect-application-name">连接参数表现行为相同。
     </para>
    </listitem>

    <listitem>
     
<para>
      <indexterm>
       <primary><envar>PGSSLMODE</envar></primary>
      </indexterm>
<!--
      <envar>PGSSLMODE</envar> behaves the same as the <xref
      linkend="libpq-connect-sslmode"> connection parameter.
-->
<envar>PGSSLMODE</envar>与<xref linkend="libpq-connect-sslmode">连接参数表现行为相同。
     </para>
    </listitem>

    <listitem>
     
<para>
      <indexterm>
       <primary><envar>PGREQUIRESSL</envar></primary>
      </indexterm>
<!--
      <envar>PGREQUIRESSL</envar> behaves the same as the <xref
      linkend="libpq-connect-requiressl"> connection parameter.
-->
<envar>PGREQUIRESSL</envar>与<xref linkend="libpq-connect-requiressl">连接参数表现行为相同。
     </para>
    </listitem>

    <listitem>
     
<para>
      <indexterm>
       <primary><envar>PGSSLCOMPRESSION</envar></primary>
      </indexterm>
<!--
      <envar>PGSSLCOMPRESSION</envar> behaves the same as the <xref
      linkend="libpq-connect-sslcompression"> connection parameter.
-->
<envar>PGSSLCOMPRESSION</envar>与<xref linkend="libpq-connect-sslcompression">连接参数表现行为相同。
     </para>
    </listitem>

    <listitem>
     
<para>
      <indexterm>
       <primary><envar>PGSSLCERT</envar></primary>
      </indexterm>
<!--
      <envar>PGSSLCERT</envar> behaves the same as the <xref
      linkend="libpq-connect-sslcert"> connection parameter.
-->
<envar>PGSSLCERT</envar>与<xref linkend="libpq-connect-sslcert">连接参数表现行为相同。
     </para>
    </listitem>

    <listitem>
     
<para>
      <indexterm>
       <primary><envar>PGSSLKEY</envar></primary>
      </indexterm>
<!--
      <envar>PGSSLKEY</envar> behaves the same as the <xref
      linkend="libpq-connect-sslkey"> connection parameter.
-->
<envar>PGSSLKEY</envar>与<xref linkend="libpq-connect-sslkey">连接参数表现行为相同。
     </para>
    </listitem>

    <listitem>
     
<para>
      <indexterm>
       <primary><envar>PGSSLROOTCERT</envar></primary>
      </indexterm>
<!--
      <envar>PGSSLROOTCERT</envar>  behaves the same as the <xref
      linkend="libpq-connect-sslrootcert"> connection parameter.
-->
<envar>PGSSLROOTCERT</envar>与<xref linkend="libpq-connect-sslrootcert">连接参数表现行为相同。
     </para>
    </listitem>

    <listitem>
     
<para>
      <indexterm>
       <primary><envar>PGSSLCRL</envar></primary>
      </indexterm>
<!--
      <envar>PGSSLCRL</envar>  behaves the same as the <xref
      linkend="libpq-connect-sslcrl"> connection parameter.
-->
<envar>PGSSLCRL</envar>与<xref linkend="libpq-connect-sslcrl">连接参数表现行为相同。
     </para>
    </listitem>

    <listitem>
     
<para>
      <indexterm>
       <primary><envar>PGREQUIREPEER</envar></primary>
      </indexterm>
<!--
      <envar>PGREQUIREPEER</envar> behaves the same as the <xref
      linkend="libpq-connect-requirepeer"> connection parameter.
-->
<envar>PGREQUIREPEER</envar>与<xref linkend="libpq-connect-requirepeer">连接参数表现行为相同。
     </para>
    </listitem>

    <listitem>
     
<para>
      <indexterm>
       <primary><envar>PGKRBSRVNAME</envar></primary>
      </indexterm>
<!--
      <envar>PGKRBSRVNAME</envar>  behaves the same as the <xref
      linkend="libpq-connect-krbsrvname"> connection parameter.
-->
<envar>PGKRBSRVNAME</envar>与<xref linkend="libpq-connect-krbsrvname">连接参数表现行为相同。
     </para>
    </listitem>

    <listitem>
     
<para>
      <indexterm>
       <primary><envar>PGGSSLIB</envar></primary>
      </indexterm>
<!--
      <envar>PGGSSLIB</envar> behaves the same as the <xref
      linkend="libpq-connect-gsslib"> connection parameter.
-->
<envar>PGGSSLIB</envar>与<xref linkend="libpq-connect-gsslib">连接参数表现行为相同。
     </para>
    </listitem>

    <listitem>
     
<para>
      <indexterm>
       <primary><envar>PGCONNECT_TIMEOUT</envar></primary>
      </indexterm>
<!--
      <envar>PGCONNECT_TIMEOUT</envar>  behaves the same as the <xref
      linkend="libpq-connect-connect-timeout"> connection parameter.
-->
<envar>PGCONNECT_TIMEOUT</envar>与<xref linkend="libpq-connect-connect-timeout">连接参数表现行为相同。
     </para>
    </listitem>

    <listitem>
     
<para>
      <indexterm>
       <primary><envar>PGCLIENTENCODING</envar></primary>
      </indexterm>
<!--
      <envar>PGCLIENTENCODING</envar> behaves the same as the <xref
      linkend="libpq-connect-client-encoding"> connection parameter.
-->
<envar>PGCLIENTENCODING</envar>与<xref linkend="libpq-connect-client-encoding">连接参数表现行为相同。
     </para>
    </listitem>
   </itemizedlist>
  </para>

  
<para>
<!-- 
   The following environment variables can be used to specify default
   behavior for each <productname>PostgreSQL</productname> session.  (See
   also the <xref linkend="sql-alterrole">
   and <xref linkend="sql-alterdatabase">
   commands for ways to set default behavior on a per-user or per-database
   basis.) 
-->
下面的环境变量可以用于为每个<productname>PostgreSQL</productname>会话声明缺省特性。
（又见<xref linkend="sql-alterrole">和<xref linkend="sql-alterdatabase">命令，
在每用户或每数据库的基础上设置缺省行为。）

   <itemizedlist>
    <listitem>

     <para>
      <indexterm>
       <primary><envar>PGDATESTYLE</envar></primary>
      </indexterm>
<!--
      <envar>PGDATESTYLE</envar> sets the default style of date/time
      representation.  (Equivalent to <literal>SET datestyle TO
      ...</literal>.)
-->
<envar>PGDATESTYLE</envar>设置缺省的日期/时间表现形式。（等效于<literal>SET datestyle TO ...</literal>。）
     </para>
    </listitem>

    <listitem>
     
<para>
      <indexterm>
       <primary><envar>PGTZ</envar></primary>
      </indexterm>
<!--
      <envar>PGTZ</envar> sets the default time zone.  (Equivalent to
      <literal>SET timezone TO ...</literal>.)
-->
<envar>PGTZ</envar>设置缺省的时区。（等效于<literal>SET timezone TO ...</literal>。）
     </para>
    </listitem>

    <listitem>
     
<para>
      <indexterm>
       <primary><envar>PGGEQO</envar></primary>
      </indexterm>
<!--
      <envar>PGGEQO</envar> sets the default mode for the genetic query
      optimizer.  (Equivalent to <literal>SET geqo TO ...</literal>.)
-->
<envar>PGGEQO</envar>为基因优化器设置缺省模式。（等效于<literal>SET geqo TO ...</literal>。）
     </para>
    </listitem>
   </itemizedlist>

<!--
    Refer to the <acronym>SQL</acronym> command <xref linkend="sql-set">
   for information on correct values for these
   environment variables. 
-->
请参考<acronym>SQL</acronym>命令<xref linkend="sql-set">获取这些环境变量的正确数值。
  </para>

  
<para>
<!-- 
   The following environment variables determine internal behavior of
   <application>libpq</application>; they override compiled-in defaults.
-->
下面的环境变量决定<application>libpq</application>的内部行为；它们覆盖编译的缺省。
   <itemizedlist>
    <listitem>

     <para>
      <indexterm>
       <primary><envar>PGSYSCONFDIR</envar></primary>
      </indexterm>
<!--
      <envar>PGSYSCONFDIR</envar> sets the directory containing the
      <filename>pg_service.conf</> file and in a future version
      possibly other system-wide configuration files.
-->
<envar>PGSYSCONFDIR</envar>设置包含<filename>pg_service.conf</>
文件和未来版本中可能的其他系统范围的配置文件的目录。
     </para>
    </listitem>

    <listitem>
     
<para>
      <indexterm>
       <primary><envar>PGLOCALEDIR</envar></primary>
      </indexterm>
<!--
      <envar>PGLOCALEDIR</envar> sets the directory containing the
      <literal>locale</> files for message internationalization.
-->
<envar>PGLOCALEDIR</envar>设置包含信息国际化的<literal>locale</>文件目录。
     </para>
    </listitem>
   </itemizedlist>
  </para>

 </sect1>


 <sect1 id="libpq-pgpass">
  <!--
  <title>The Password File</title>
  -->
  <title>口令文件</title>

  <indexterm zone="libpq-pgpass">
   <!--
   <primary>password file</primary>
   -->
   <primary>口令文件</primary>
  </indexterm>
  <indexterm zone="libpq-pgpass">
   <primary>.pgpass</primary>
  </indexterm>

  <!--
<para>
   The file <filename>.pgpass</filename> in a user's home directory or the
   file referenced by <envar>PGPASSFILE</envar> can contain passwords to
   be used if the connection requires a password (and no password has been
   specified  otherwise). On Microsoft Windows the file is named
   <filename>%APPDATA%\postgresql\pgpass.conf</> (where
   <filename>%APPDATA%</> refers to the Application Data subdirectory in
   the user's profile).
  </para>
-->
<para>
用户家目录中的<filename>.pgpass</filename>或者<envar>PGPASSFILE</envar>
引用的文件是一个可以包含口令的文件。如果连接要求口令（并且没有用其它方法声明口令），
那么可以用它。 在 Microsoft Windows 上，文件名字是<filename>%APPDATA%\postgresql\pgpass.conf</>
（<filename>%APPDATA%</>指用户配置里的 Application Data 子目录）。
</para>
 
<para>
<!--
   This file should contain lines of the following format:
-->
这个文件应该有下面这样的格式行：
<synopsis>
<replaceable>hostname</replaceable>:<replaceable>port</replaceable>:<replaceable>database</replaceable>:<replaceable>username</replaceable>:<replaceable>password</replaceable>
</synopsis>
<!-- 
   (You can add a reminder comment to the file by copying the line above and
   preceding it with <literal>#</>.)
   Each of the first four fields can be a literal value, or
   <literal>*</literal>, which matches anything.  The password field from
   the first line that matches the current connection parameters will be
   used.  (Therefore, put more-specific entries first when you are using
   wildcards.) If an entry needs to contain <literal>:</literal> or
   <literal>\</literal>, escape this character with <literal>\</literal>.
   A host name of <literal>localhost</> matches both TCP (host name
   <literal>localhost</>) and Unix domain socket (<literal>pghost</> empty
   or the default socket directory) connections coming from the local
   machine. In a standby server, a database name of <literal>replication</>
   matches streaming replication connections made to the master server.
   The <literal>database</> field is of limited usefulness because
   users have the same password for all databases in the same cluster. 
-->
你可以通过复制上面的行并且在前面添加<literal>#</>用于添加提醒注释到文件，
头四个字段每个都可以是一个文本值，或者<literal>*</literal>，它匹配所有的东西。
第一个匹配当前连接参数的口令行的口令域将得以使用。（因此，如果你使用了通配符，
那么应该把最具体的记录放在前面。）如果记录包含<literal>:</literal>或者<literal>\</literal>，
应该用<literal>\</literal>转义。一个<literal>localhost</>的主机名匹配来自本机的
TCP（主机名<literal>localhost</>）和Unix域套接字（<literal>pghost</>为空或缺省的套接字目录）连接。
在备用服务器中，一个名字为<literal>replication</>的数据库被匹配到主服务器的流复制连接。
<literal>database</>字段用处有限，因为对同一集群中所有数据库用户有相同密码。
  </para>

  <!--
<para>
   On Unix systems, the permissions on <filename>.pgpass</filename> must
   disallow any access to world or group; achieve this by the command
   <command>chmod 0600 ~/.pgpass</command>.  If the permissions are less
   strict than this, the file will be ignored.  On Microsoft Windows, it
   is assumed that the file is stored in a directory that is secure, so
   no special permissions check is made.
  </para>
-->
<para>
在linux系统中，<filename>.pgpass</filename>的权限必须不允许任何全局或者同组的用户访问；
我们可以用命令<command>chmod 0600 ~/.pgpass</command>实现这个目的。如果权限比这个松，
这个文件将被忽略。在Microsoft Windows上，假定该文件存储在一个安全的目录中，所以没有做特殊的权限检查。
</para>
 </sect1>


 <sect1 id="libpq-pgservice">
  <!--
  <title>The Connection Service File</title>
  -->
  <title>连接服务的文件</title>

  <indexterm zone="libpq-pgservice">
   <!--
   <primary>connection service file</primary>
   -->
   <primary>连接服务的文件</primary>
  </indexterm>
  <indexterm zone="libpq-pgservice">
   <primary>pg_service.conf</primary>
  </indexterm>
  <indexterm zone="libpq-pgservice">
   <primary>.pg_service.conf</primary>
  </indexterm>

  <!--
<para>
   The connection service file allows libpq connection parameters to be
   associated with a single service name. That service name can then be
   specified by a libpq connection, and the associated settings will be
   used. This allows connection parameters to be modified without requiring
   a recompile of the libpq application. The service name can also be
   specified using the <envar>PGSERVICE</envar> environment variable.
  </para>
-->
<para>
连接服务文件允许libpq连接参数可以与一个单一的服务名称相关联。
服务名之后可以被一个libpq连接声明，并且会使用相关设置。
允许连接参数无需要求一个重新编译的libpq应用进行修改。
服务名同样可以用<envar>PGSERVICE</envar>环境变量进行声明。
</para>

  <!--
<para>
   The connection service file can be a per-user service file
   at <filename>~/.pg_service.conf</filename> or the location
   specified by the environment variable <envar>PGSERVICEFILE</envar>,
   or it can be a system-wide file
   at <filename>`pg_config --sysconfdir`/pg_service.conf</filename> or in the directory
   specified by the environment variable
   <envar>PGSYSCONFDIR</envar>.  If service definitions with the same
   name exist in the user and the system file, the user file takes
   precedence.
  </para>
-->
<para>
连接服务文件可以是在<filename>~/.pg_service.conf</filename>，或者<envar>PGSERVICEFILE</envar>
环境变量声明位置中的一个按用户的服务文件，也可以是一个位于<filename>`pg_config --sysconfdir`/pg_service.conf</filename>，
或者<envar>PGSYSCONFDIR</envar>环境变量声明位置中的一个全系统文件。
如果定义的服务名与在用户和系统文件中的名字相同，那么用户文件优先。
</para>

  
<para>
<!--
   The file uses an <quote>INI file</quote> format where the section
   name is the service name and the parameters are connection
   parameters; see <xref linkend="libpq-paramkeywords"> for a list.  For
   example:
-->
该文件使用<quote>INI file</quote>格式（章节名是服务名，并且参数是连接参数）；
参阅<xref linkend="libpq-paramkeywords">获取一个列表，例如：
<programlisting>
# comment
[mydb]
host=somehost
port=5433
user=admin
</programlisting>
<!-- 
   An example file is provided at
   <filename>share/pg_service.conf.sample</filename>. 
-->
在<filename>share/pg_service.conf.sample</filename>中提供了一个示例文件。
  </para>
 </sect1>


 <sect1 id="libpq-ldap">
  <!--
  <title>LDAP Lookup of Connection Parameters</title>
  -->
  <title>LDAP查找连接参数</title>

  <indexterm zone="libpq-ldap">
   <!--
   <primary>LDAP connection parameter lookup</primary>
   -->
   <primary>LDAP连接参数查找</primary>
  </indexterm>

  <!--
<para>
   If <application>libpq</application> has been compiled with LDAP support (option
   <literal><option>-&#045;with-ldap</option></literal> for <command>configure</command>)
   it is possible to retrieve connection options like <literal>host</literal>
   or <literal>dbname</literal> via LDAP from a central server.
   The advantage is that if the connection parameters for a database change,
   the connection information doesn't have to be updated on all client machines.
  </para>
-->
<para>
如果<application>libpq</application>已经通过LDAP支持（<command>configure</command>
的<literal><option>--with-ldap</option></literal>）进行了编译，可以从一个中央服务器，
通过LDAP检索连接选项，如<literal>host</literal>或<literal>dbname</literal>。
这样做的好处是，如果一个数据库连接参数发生了改变，在所有客户端的连接信息不必进行改变。
</para>

<para>
<!--
   LDAP connection parameter lookup uses the connection service file
   <filename>pg_service.conf</filename> (see <xref
   linkend="libpq-pgservice">).  A line in a
   <filename>pg_service.conf</filename> stanza that starts with
   <literal>ldap://</literal> will be recognized as an LDAP URL and an
   LDAP query will be performed. The result must be a list of
   <literal>keyword = value</literal> pairs which will be used to set
   connection options.  The URL must conform to RFC 1959 and be of the
   form
-->
LDAP连接参数查找使用连接服务文件<filename>pg_service.conf</filename>(参阅
<xref linkend="libpq-pgservice">)。在<filename>pg_service.conf</filename>
中的以<literal>ldap://</literal>开始的一行被看做是一个LDAP URL，
并且会执行一个LDAP查询。返回结果会是一个<literal>keyword = value</literal>的列表，
用于设置连接选项。URL必须符合RFC 1959，并且是如下形式：
<synopsis>
ldap://[<replaceable>hostname</replaceable>[:<replaceable>port</replaceable>]]/<replaceable>search_base</replaceable>?<replaceable>attribute</replaceable>?<replaceable>search_scope</replaceable>?<replaceable>filter</replaceable>
</synopsis>
<!-- 
   where <replaceable>hostname</replaceable> defaults to
   <literal>localhost</literal> and <replaceable>port</replaceable>
   defaults to 389. 
-->
这里<replaceable>hostname</replaceable>缺省为<literal>localhost</literal>
和<replaceable>port</replaceable>缺省为389。
  </para>

  <!--
<para>
   Processing of <filename>pg_service.conf</filename> is terminated after
   a successful LDAP lookup, but is continued if the LDAP server cannot
   be contacted.  This is to provide a fallback with further LDAP URL
   lines that point to different LDAP servers, classical <literal>keyword
   = value</literal> pairs, or default connection options.  If you would
   rather get an error message in this case, add a syntactically incorrect
   line after the LDAP URL.
  </para>
-->
<para>
<filename>pg_service.conf</filename>的处理在LDAP成功查找之后就会被终止，
但如果不能成功连接LDAP服务，那么会继续。
这是为了进一步指向不同的LDAP服务器的LDAP URL线而提供的一个回滚，
标准的<literal>keyword = value</literal>对格式，或缺省的连接参数。
如果想在这种情况下获得一个错误消息，可以在LDAP URL后添加一个语法不正确的行。
</para>
 
<para>
<!--
   A sample LDAP entry that has been created with the LDIF file
-->
LDIF文件创建的一个样本LDAP条目：
<programlisting>
version:1
dn:cn=mydatabase,dc=mycompany,dc=com
changetype:add
objectclass:top
objectclass:device
cn:mydatabase
description:host=dbserver.mycompany.com
description:port=5439
description:dbname=mydb
description:user=mydb_user
description:sslmode=require
</programlisting>
<!-- 
   might be queried with the following LDAP URL: 
-->
可能被下列的 LDAP URL查询：
<programlisting>
ldap://ldap.mycompany.com/dc=mycompany,dc=com?description?one?(cn=mydatabase)
</programlisting>
  </para>
  
<para>
<!--
   You can also mix regular service file entries with LDAP lookups.
   A complete example for a stanza in <filename>pg_service.conf</filename>
   would be:
-->
也可以通过LDAP查找来混合日常服务文件。一个<filename>pg_service.conf</filename>
中完整的一节的例子如下：
<programlisting>
# only host and port are stored in LDAP, specify dbname and user explicitly
[customerdb]
dbname=customer
user=appuser
ldap://ldap.acme.com/cn=dbserver,cn=hosts?pgconnectinfo?base?(objectclass=*)
</programlisting>
  </para>

 </sect1>


 <sect1 id="libpq-ssl">
  <!--
  <title>SSL Support</title>
  -->
  <title>SSL 支持</title>

  <indexterm zone="libpq-ssl">
   <primary>SSL</primary>
  </indexterm>

  <!--
<para>
   <productname>PostgreSQL</> has native support for using <acronym>SSL</>
   connections to encrypt client/server communications for increased
   security. See <xref linkend="ssl-tcp"> for details about the server-side
   <acronym>SSL</> functionality.
  </para>
-->
<para>
<productname>PostgreSQL</>本机支持使用<acronym>SSL</>连接对客户端/服务器通讯进行加密，
以增强安全性。参阅<xref linkend="ssl-tcp">获取服务器端<acronym>SSL</>功能的细节。
</para>

  <!--
<para>
   <application>libpq</application> reads the system-wide
   <productname>OpenSSL</productname> configuration file. By default, this
   file is named <filename>openssl.cnf</filename> and is located in the
   directory reported by <literal>openssl version -d</>.  This default
   can be overridden by setting environment variable
   <envar>OPENSSL_CONF</envar> to the name of the desired configuration
   file.
  </para>
-->
<para>
<application>libpq</application>读取全系统<productname>OpenSSL</productname>配置文件，
默认情况下，文件命名为<filename>openssl.cnf</filename>并且存放在<literal>openssl version -d</>
报告的目录中。此默认可以通过设置环境变量<envar>OPENSSL_CONF</envar>为所需配置文件的名称来重写。
</para>

 <sect2 id="libq-ssl-certificates">
  <!-- 
  <title>Client Verification of Server Certificates</title>
  -->
  <title>服务器证书的客户端验证</title>

  <!--
<para>
   By default, <productname>PostgreSQL</> will not perform any verification of
   the server certificate. This means that it is possible to spoof the server
   identity (for example by modifying a DNS record or by taking over the server
   IP address) without the client knowing. In order to prevent spoofing,
   <acronym>SSL</> certificate verification must be used.
  </para>
-->
<para>
缺省，<productname>PostgreSQL</>不会执行任何服务器证书验证。
这就意味着可以在客户端没有察觉的情况下骗过服务认证（如，通过修改一个DNS记录或接管服务IP地址）。
为了避免这种情况，必须使用<acronym>SSL</>证书认证。
</para>

  <!--
<para>
   If the parameter <literal>sslmode</> is set to <literal>verify-ca</>,
   libpq will verify that the server is trustworthy by checking the
   certificate chain up to a trusted certificate authority
   (<acronym>CA</>). If <literal>sslmode</> is set to <literal>verify-full</>,
   libpq will <emphasis>also</> verify that the server host name matches its
   certificate. The SSL connection will fail if the server certificate cannot
   be verified. <literal>verify-full</> is recommended in most
   security-sensitive environments.
  </para>
-->
<para>
如果<literal>sslmode</>参数设置为<literal>verify-ca</>，
libpq将通过检查受信任的证书颁发机构的证书链(<acronym>CA</>)来验证服务是可信任的。
如果<literal>sslmode</>设置为<literal>verify-full</>，
libpq<emphasis>也</>会通过验证服务主机名匹配认证来认为服务是可信任的。
如果服务验证不能被通过，那么SSL连接会失败。在大多数对安全要求较高的环境中，
建议使用<literal>verify-full</>。
</para>

  <!--
<para>
   In <literal>verify-full</> mode, the <literal>cn</> (Common Name) attribute
   of the certificate is matched against the host name. If the <literal>cn</>
   attribute starts with an asterisk (<literal>*</>), it will be treated as
   a wildcard, and will match all characters <emphasis>except</> a dot
   (<literal>.</>). This means the certificate will not match subdomains.
   If the connection is made using an IP address instead of a host name, the
   IP address will be matched (without doing any DNS lookups).
  </para>
-->
<para>
在<literal>verify-full</>模式下，认证的<literal>cn</>(Common Name)属性与主机名进行匹配。
如果<literal>cn</>以<literal>*</>开始，会被看做是一个通配符，并且会匹配<emphasis>除了</>
点（<literal>.</>）之外的所有字符。这就意味着认证不会匹配子域名。
如果是使用IP而不是主机名进行连接，会进行IP匹配检查（不会做DNS检查）。
</para>

  <!--
<para>
   To allow server certificate verification, the certificate(s) of one or more
   trusted <acronym>CA</>s must be
   placed in the file <filename>~/.postgresql/root.crt</> in the user's home
   directory. If intermediate <acronym>CA</>s appear in
   <filename>root.crt</filename>, the file must also contain certificate
   chains to their root <acronym>CA</>s. (On Microsoft Windows the file is named
   <filename>%APPDATA%\postgresql\root.crt</filename>.)
  </para>
-->
<para>
为了允许服务器认证通过，一个或多个信任的<acronym>CA</>认证必须放在用户的home目录下的
<filename>~/.postgresql/root.crt</>文件中。如果中介<acronym>CA</>
出现在<filename>root.crt</filename>中，该文件必须也包含到它们的根<acronym>CA</>
的证书链。Windows下的文件名是<filename>%APPDATA%\postgresql\root.crt</filename>。
</para>

  <!--
<para>
   Certificate Revocation List (CRL) entries are also checked
   if the file <filename>~/.postgresql/root.crl</filename> exists
   (<filename>%APPDATA%\postgresql\root.crl</filename> on Microsoft
   Windows).
  </para>
-->
<para>
如果存在<filename>~/.postgresql/root.crl</filename>文件（Windows下是
<filename>%APPDATA%\postgresql\root.crl</filename>文件），同样也会检查证书吊销列表（CRL）。
</para>

  <!--
<para>
   The location of the root certificate file and the CRL can be changed by
   setting
   the connection parameters <literal>sslrootcert</> and <literal>sslcrl</>
   or the environment variables <envar>PGSSLROOTCERT</> and <envar>PGSSLCRL</>.
  </para>
-->
<para>
root认证文件和CRL的位置可以通过设置<literal>sslrootcert</>和<literal>sslcrl</>连接参数，
或<envar>PGSSLROOTCERT</>和<envar>PGSSLCRL</>环境变量进行修改。
</para>

  <note>
   <!--
<para>
    For backwards compatibility with earlier versions of PostgreSQL, if a
    root CA file exists, the behavior of
    <literal>sslmode</literal>=<literal>require</literal> will be the same
    as that of <literal>verify-ca</literal>, meaning the server certificate
    is validated against the CA. Relying on this behavior is discouraged,
    and applications that need certificate validation should always use
    <literal>verify-ca</literal> or <literal>verify-full</literal>.
   </para>
-->
<para>
为了与早期PostgreSQL版本兼容，如果存在一个根CA文件，<literal>sslmode</literal>=<literal>require</literal>
的行为将和<literal>verify-ca</literal>表现的相同，意味着服务器证书是经过CA验证的。
不建议依赖于这个行为，需要证书验证的应用应该总是使用<literal>verify-ca</literal>
或<literal>verify-full</literal>。
</para>
  </note>
 </sect2>

 <sect2 id="libpq-ssl-clientcert">
  <!--
  <title>Client Certificates</title>
  -->
  <title>客户端证书</title>

  <!--
<para>
   If the server requests a trusted client certificate,
   <application>libpq</application> will send the certificate stored in
   file <filename>~/.postgresql/postgresql.crt</> in the user's home
   directory.  The certificate must be signed by one of the certificate
   authorities (<acronym>CA</acronym>) trusted by the server.  A matching
   private key file <filename>~/.postgresql/postgresql.key</> must also
   be present. The private
   key file must not allow any access to world or group; achieve this by the
   command <command>chmod 0600 ~/.postgresql/postgresql.key</command>.
   On Microsoft Windows these files are named
   <filename>%APPDATA%\postgresql\postgresql.crt</filename> and
   <filename>%APPDATA%\postgresql\postgresql.key</filename>, and there
   is no special permissions check since the directory is presumed secure.
   The location of the certificate and key files can be overridden by the
   connection parameters <literal>sslcert</> and <literal>sslkey</> or the
   environment variables <envar>PGSSLCERT</> and <envar>PGSSLKEY</>.
  </para>
-->
<para>
如果服务器要求一个信任的客户端认证，<application>libpq</application>将发送存储在用户home目录中
<filename>~/.postgresql/postgresql.crt</>文件中的证书。该证书必须由服务器信任的证书认证
（<acronym>CA</acronym>）之一签名。同时也必须出示一个匹配的私钥文件
<filename>~/.postgresql/postgresql.key</>。私钥文件不允许任何对世界或组的访问；
通过<command>chmod 0600 ~/.postgresql/postgresql.key</command>命令可以实现。
在Windows上，这个文件是<filename>%APPDATA%\postgresql\postgresql.crt</filename>
和<filename>%APPDATA%\postgresql\postgresql.key</filename>，同时没有特定的权限检查，
因为目录被认为是安全的。证书和key文件的位置可以通过<literal>sslcert</>和<literal>sslkey</>连接参数，
或<envar>PGSSLCERT</>和<envar>PGSSLKEY</>环境变量进行覆盖重写。
</para>

  <!--
<para>
   In some cases, the client certificate might be signed by an
   <quote>intermediate</> certificate authority, rather than one that is
   directly trusted by the server.  To use such a certificate, append the
   certificate of the signing authority to the <filename>postgresql.crt</>
   file, then its parent authority's certificate, and so on up to a certificate
   authority, <quote>root</> or <quote>intermediate</>, that is trusted by
   the server, i.e. signed by a certificate in the server's
   <filename>root.crt</filename> file.
  </para>
-->
<para>
在一些情况下，客户端认证可能会被一个<quote>intermediate</>的证书认证来签名，
而不是一个能直接被服务信任的。为了使用一个这种认证，向<filename>postgresql.crt</>
文件追加证书签字权，并且直到认证授权，<quote>root</>或<quote>intermediate</>，
都可以被服务器信任，也就是在服务器的<filename>root.crt</filename>
文件中通过证书签约。
</para>

  <!--
<para>
   Note that the client's <filename>~/.postgresql/root.crt</> lists the top-level CAs
   that are considered trusted for signing server certificates.  In principle it need
   not list the CA that signed the client's certificate, though in most cases
   that CA would also be trusted for server certificates.
  </para>
-->
<para>
需要注意的是，客户端的<filename>~/.postgresql/root.crt</>列出了最高级别的CA，
认为对签名服务证书来说是可信任的。原则上，不需要列出签名客户端认证的CA，
尽管在大多数情况下，CA仍会被认为对服务器认证是可信任的。
</para>

 </sect2>

 <sect2 id="libpq-ssl-protection">
  <!--
  <title>Protection Provided in Different Modes</title>
  -->
  <title>在不同的模式提供保护</title>

  
<para>
<!-- 
   The different values for the <literal>sslmode</> parameter provide different
   levels of protection. SSL can provide
   protection against three types of attacks: 
-->
<literal>sslmode</>参数的不同值提供了不同的保护级别。SSL可以为三种攻击提供保护：

   <variablelist>
    <varlistentry>
     <!--
 <term>Eavesdropping</term>
 -->
 <term>Eavesdropping（窃听）</term>
     <listitem>
<!--
      <para>If a third party can examine the network traffic between the
       client and the server, it can read both connection information (including
       the user name and password) and the data that is passed. <acronym>SSL</>
       uses encryption to prevent this.
      </para>
-->
<para>
如果一个第三方可以在客户端与服务器端之间检查网络通信，那么它就能读取两边的连接信息
（包括用户名和密码）以及传递的数据。对此，<acronym>SSL</>通过加密进行防护。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <!-- 
 <term>Man in the middle (<acronym>MITM</>)</term>
 -->
 <term>裁判(<acronym>MITM</>)</term>
     <listitem>
      <!--
<para>If a third party can modify the data while passing between the
       client and server, it can pretend to be the server and therefore see and
       modify data <emphasis>even if it is encrypted</>. The third party can then
       forward the connection information and data to the original server,
       making it impossible to detect this attack. Common vectors to do this
       include DNS poisoning and address hijacking, whereby the client is directed
       to a different server than intended. There are also several other
       attack methods that can accomplish this. <acronym>SSL</> uses certificate
       verification to prevent this, by authenticating the server to the client.
      </para>
-->
<para>
如果客户端和服务器端进行传递数据的时候，第三方可以对其进行修改，那么他就能伪装成服务器，
然后查看或修改数据（<emphasis>即使是加密的</>）。第三方接着可以向原始服务器发出连接信息和数据，
最终造成无法防护这种攻击。这种攻击常用的载体有DNS中毒或IP绑架，
即客户端被定向到预期之外的不同的服务器。同样还有几种其他的方法也能做到这种攻击。
<acronym>SSL</>通过服务器到客户端的证书验证来阻止这种攻击。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <!-- 
 <term>Impersonation</term>
 -->
 <term>Impersonation（模拟）</term>
     <listitem>
      <!--
<para>If a third party can pretend to be an authorized client, it can
       simply access data it should not have access to. Typically this can
       happen through insecure password management. <acronym>SSL</> uses
       client certificates to prevent this, by making sure that only holders
       of valid certificates can access the server.
      </para>
-->
<para>
如果第三方可以伪装成一个认证了的客户端，那么它就能轻松访问到它本来不能访问的数据。
典型的，如不安全的密钥管理，就会造成这种情况。<acronym>SSL</>
通过客户端认证来阻止这种情况，即确保只有知道有效认证的人员才能访问连接服务器。
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <!--
<para>
   For a connection to be known secure, SSL usage must be configured
   on <emphasis>both the client and the server</> before the connection
   is made. If it is only configured on the server, the client may end up
   sending sensitive information (e.g. passwords) before
   it knows that the server requires high security. In libpq, secure
   connections can be ensured
   by setting the <literal>sslmode</> parameter to <literal>verify-full</> or
   <literal>verify-ca</>, and providing the system with a root certificate to
   verify against. This is analogous to using an <literal>https</>
   <acronym>URL</> for encrypted web browsing.
  </para>
-->
<para>
对于一个被称为安全的连接来说，进行连接之前，必须在<emphasis>客户端和服务器端都</>进行SSL配置。
如果只在服务器端进行配置，在它知道服务器端需要高级认证之前不会发送敏感信息（如密码等）。
在libpq中，可以通过将<literal>sslmode</>参数设置为<literal>verify-full</>或<literal>verify-ca</>
来确保安全连接，并且为系统提供一个root认证以进行安全认证。类似于使用<literal>https</>
和<acronym>URL</>进行加密网页浏览。
</para>

  <!--
<para>
   Once the server has been authenticated, the client can pass sensitive data.
   This means that up until this point, the client does not need to know if
   certificates will be used for authentication, making it safe to specify that
   only in the server configuration.
  </para>
-->
<para>
一旦服务器已经认证，客户端就可以发送敏感信息。这就意味着直到这一刻，客户端都不需要知道，
是否认证需要证书，只在服务器配置，对其安全地指定。
</para>

  <!--
<para>
   All <acronym>SSL</> options carry overhead in the form of encryption and
   key-exchange, so there is a tradeoff that has to be made between performance
   and security. <xref linkend="libpq-ssl-sslmode-statements">
   illustrates the risks the different <literal>sslmode</> values
   protect against, and what statement they make about security and overhead.
  </para>
-->
<para>
所有以加密和密钥交换方式得<acronym>SSL</>选项都会产生开销，因此在性能和安全之间需要进行一个权衡。
<xref linkend="libpq-ssl-sslmode-statements">说明不同<literal>sslmode</>值的安全风险，
以及关于安全和开销所做出的声明：
</para>

  <table id="libpq-ssl-sslmode-statements">
   <!--
   <title>SSL Mode Descriptions</title>
   -->
   <title>SSL 模式说明</title>
   <tgroup cols="4">
    <thead>
     <row>
      <!--
  <entry><literal>sslmode</></entry>
      <entry>Eavesdropping protection</entry>
      <entry><acronym>MITM</> protection</entry>
      <entry>Statement</entry>
  -->
  <entry><literal>sslmode</></entry>
      <entry>窃听保护</entry>
      <entry><acronym>MITM</>保护</entry>
      <entry>声明</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <!--
  <entry><literal>disable</></entry>
      <entry>No</entry>
      <entry>No</entry>
      <entry>I don't care about security, and I don't want to pay the overhead
       of encryption.
      </entry>
  -->
  <entry><literal>disable</></entry>
      <entry>否</entry>
      <entry>否</entry>
      <entry>我不关心安全，我不想来支付加密的开销。
      </entry>
     </row>

     <row>
      <!--
  <entry><literal>allow</></entry>
      <entry>Maybe</entry>
      <entry>No</entry>
      <entry>I don't care about security, but I will pay the overhead of
       encryption if the server insists on it.
      </entry>
  -->
  <entry><literal>allow</></entry>
      <entry>可能</entry>
      <entry>否</entry>
      <entry>我不关心安全性，但我会支付的加密开销，如果服务器的坚持的话。
      </entry>
     </row>

     <row>
      <!--
  <entry><literal>prefer</></entry>
      <entry>Maybe</entry>
      <entry>No</entry>
      <entry>I don't care about encryption, but I wish to pay the overhead of
       encryption if the server supports it.
      </entry>
  -->
  <entry><literal>prefer</></entry>
      <entry>可能</entry>
      <entry>否</entry>
      <entry>我不关心加密，但我想支付加密开销，如果服务器支持它。
      </entry>
     </row>

     <row>
      <!--
  <entry><literal>require</></entry>
      <entry>Yes</entry>
      <entry>No</entry>
      <entry>I want my data to be encrypted, and I accept the overhead. I trust
       that the network will make sure I always connect to the server I want.
      </entry>
  -->
  <entry><literal>require</></entry>
      <entry>是</entry>
      <entry>否</entry>
      <entry>我希望我的数据加密，我接受开销。我相信该网络将确保我始终连接到我想要的服务器。
      </entry>
     </row>

     <row>
      <!--
  <entry><literal>verify-ca</></entry>
      <entry>Yes</entry>
      <entry><literal>Depends on CA</>-policy</entry>
      <entry>I want my data encrypted, and I accept the overhead. I want to be
       sure that I connect to a server that I trust.
      </entry>
  -->
  <entry><literal>verify-ca</></entry>
      <entry>是</entry>
      <entry><literal>取决于CA</>的政策</entry>
      <entry>我希望我的数据加密，我接受开销。我想要确保我连接到了一个我信任的服务器。
      </entry>
     </row>

     <row>
      <!--
  <entry><literal>verify-full</></entry>
       <entry>Yes</entry>
       <entry>Yes</entry>
       <entry>I want my data encrypted, and I accept the overhead. I want to be
        sure that I connect to a server I trust, and that it's the one I
        specify.
       </entry>
   -->
   <entry><literal>verify-full</></entry>
       <entry>是</entry>
       <entry>是</entry>
       <entry>我希望我的数据加密，我接受开销。我想要确保我连接到了一个我信任的服务器，
   并且是我指定的那个服务器。
       </entry>
      </row>

    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   The difference between <literal>verify-ca</> and <literal>verify-full</>
   depends on the policy of the root <acronym>CA</>. If a public
   <acronym>CA</> is used, <literal>verify-ca</> allows connections to a server
   that <emphasis>somebody else</> may have registered with the <acronym>CA</>.
   In this case, <literal>verify-full</> should always be used. If
   a local <acronym>CA</> is used, or even a self-signed certificate, using
   <literal>verify-ca</> often provides enough protection.
  </para>
-->
<para>
<literal>verify-ca</>和<literal>verify-full</>之间的不同是根据root <acronym>CA</>的政策。
如果使用的是一个公用<acronym>CA</>，<literal>verify-ca</>允许那些带有<acronym>CA</>
注册的客户端对服务器进行连接访问。在这种情况下，应该使用<literal>verify-full</>。
如果使用的是一个本地<acronym>CA</>，甚至是一个自签名证书，
使用<literal>verify-ca</>通常会提供充分的保护。
</para>

  <!--
<para>
   The default value for <literal>sslmode</> is <literal>prefer</>. As is shown
   in the table, this makes no sense from a security point of view, and it only
   promises performance overhead if possible. It is only provided as the default
   for backward compatibility, and is not recommended in secure deployments.
  </para>
-->
<para>
<literal>sslmode</>缺省值是<literal>prefer</>。如在表中说明的那样，
从安全角度来看这样做是没有意义的，并且如果可能的话，它只承诺性能的开销。
它仅提供了缺省向后兼容性，在安全部署中不建议使用。
</para>

 </sect2>

 <sect2 id="libpq-ssl-fileusage">
  <!--
  <title>SSL Client File Usage</title>
  -->
  <title>SSL 客户端文件的使用</title>

  <!--
<para>
   <xref linkend="libpq-ssl-file-usage"> summarizes the files that are
   relevant to the SSL setup on the client.
  </para>
-->
<para>
<xref linkend="libpq-ssl-file-usage">总结了与客户端SSL设置相关的文件。
</para>

  <table id="libpq-ssl-file-usage">
   <!--
   <title>Libpq/Client SSL File Usage</title>
   -->
   <title>libpq/客户端SSL文件的使用</title>
   <tgroup cols="3">
    <thead>
     <row>
      <!--
  <entry>File</entry>
      <entry>Contents</entry>
      <entry>Effect</entry>
  -->
  <entry>文件</entry>
      <entry>内容</entry>
      <entry>影响</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry><filename>~/.postgresql/postgresql.crt</></entry>
      <!--
  <entry>client certificate</entry>
      <entry>requested by server</entry>
  -->
  <entry>客户端证书</entry>
      <entry>服务器要求的</entry>
     </row>

     <row>
      <entry><filename>~/.postgresql/postgresql.key</></entry>
      <!--
  <entry>client private key</entry>
      <entry>proves client certificate sent by owner; does not indicate
      certificate owner is trustworthy</entry>
  -->
  <entry>客户端的私钥</entry>
      <entry>证明由所有者发送的客户端证书，并不表示证书拥有者是值得信赖的</entry>
     </row>

     <row>
      <entry><filename>~/.postgresql/root.crt</></entry>
      <!-- 
  <entry>trusted certificate authorities</entry>
      <entry>checks that server certificate is signed by a trusted certificate
      authority</entry>
  -->
  <entry>受信任的证书颁发机构</entry>
      <entry>检查服务器证书是由受信任的证书机关签署。</entry>
     </row>

     <row>
      <entry><filename>~/.postgresql/root.crl</></entry>
      <!--
  <entry>certificates revoked by certificate authorities</entry>
      <entry>server certificate must not be on this list</entry>
  -->
  <entry>证书颁发机构吊销证书</entry>
      <entry>服务器证书必须不在这个名单</entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect2>

 <sect2 id="libpq-ssl-initialize">
  <!--
  <title>SSL Library Initialization</title>
  -->
  <title>SSL 库初始化</title>

  <!--
<para>
   If your application initializes <literal>libssl</> and/or
   <literal>libcrypto</> libraries and <application>libpq</application>
   is built with <acronym>SSL</> support, you should call
   <function>PQinitOpenSSL</> to tell <application>libpq</application>
   that the <literal>libssl</> and/or <literal>libcrypto</> libraries
   have been initialized by your application, so that
   <application>libpq</application> will not also initialize those libraries.
   <!-&#045; If this URL changes replace it with a URL to www.archive.org. &#045;->
   See <ulink
   url="http://h71000.www7.hp.com/doc/83final/BA554_90007/ch04.html"></ulink>
   for details on the SSL API.
  </para>
-->
<para>
如果应用程序初始化<literal>libcrypto</>和/或<literal>libssl</>库以及<application>libpq</application>
编译为支持<acronym>SSL</>，应该调用<function>PQinitOpenSSL</>来告诉<application>libpq</application>
说<literal>libssl</>和/或<literal>libcrypto</>库已经被应用程序初始化了，
因此<application>libpq</application>将不会再初始化这些库。参阅
<ulink url="http://h71000.www7.hp.com/doc/83final/BA554_90007/ch04.html"></ulink>
获取关于SSL API的详细信息。
</para>

  
<para>
   <variablelist>
    <varlistentry id="libpq-pqinitopenssl">
     <term>
      <function>PQinitOpenSSL</function>
      <indexterm>
       <primary>PQinitOpenSSL</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       <!--
   Allows applications to select which security libraries to initialize.
   -->
   允许应用程序选择安全库初始化。
<synopsis>
void PQinitOpenSSL(int do_ssl, int do_crypto);
</synopsis>
      </para>

      <!--
<para>
       When <parameter>do_ssl</> is non-zero, <application>libpq</application>
       will initialize the <application>OpenSSL</> library before first
       opening a database connection.  When <parameter>do_crypto</> is
       non-zero, the <literal>libcrypto</> library will be initialized.  By
       default (if <function>PQinitOpenSSL</> is not called), both libraries
       are initialized.  When SSL support is not compiled in, this function is
       present but does nothing.
      </para>
-->
<para>
当<parameter>do_ssl</>为非0时，在第一次打开一个数据库连接之前，<application>libpq</application>
将初始化<application>OpenSSL</>库。当<parameter>do_crypto</>为非0时，<literal>libcrypto</>
库将被初始化。缺省(如果<function>PQinitOpenSSL</>没有被调用)，两个库都会被初始化。
如果没有编译SSL支持，会提供该函数，但不会做任何事情。
</para>

      <!--
<para>
       If your application uses and initializes either <application>OpenSSL</>
       or its underlying <literal>libcrypto</> library, you <emphasis>must</>
       call this function with zeroes for the appropriate parameter(s)
       before first opening a database connection.  Also be sure that you
       have done that initialization before opening a database connection.
      </para>
-->
<para>
如果应用程序使用并初始化<application>OpenSSL</>，或其底层<literal>libcrypto</>库，
那么在第一次打开一个数据库连接之前，<emphasis>必须</>调用这个函数（带有适当0值的参数）。
同样要确保在打开一个数据库连接之前做过初始化。
</para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqinitssl">
     <term>
      <function>PQinitSSL</function>
      <indexterm>
       <primary>PQinitSSL</primary>
      </indexterm>
     </term>

     <listitem>
<para>
       <!--
   Allows applications to select which security libraries to initialize.
   -->
   允许应用程序选择初始化哪个安全库。
<synopsis>
void PQinitSSL(int do_ssl);
</synopsis>
      </para>

      <!--
<para>
       This function is equivalent to
       <literal>PQinitOpenSSL(do_ssl, do_ssl)</>.
       It is sufficient for applications that initialize both or neither
       of <application>OpenSSL</> and <literal>libcrypto</>.
      </para>
-->
<para>
此功能相当于<literal>PQinitOpenSSL(do_ssl, do_ssl)</>。
它的应用是足够的同时初始化或都不初始化<application>OpenSSL</>和<literal>libcrypto</>。
</para>

      <!--
<para>
       <function>PQinitSSL</> has been present since
       <productname>PostgreSQL</> 8.0, while <function>PQinitOpenSSL</>
       was added in <productname>PostgreSQL</> 8.4, so <function>PQinitSSL</>
       might be preferable for applications that need to work with older
       versions of <application>libpq</application>.
      </para>
-->
<para>
<function>PQinitSSL</>在<productname>PostgreSQL</> 8.0就已经出现了，
而<function>PQinitOpenSSL</>是在<productname>PostgreSQL</> 8.4添加进来的。
所以对老版本的<application>libpq</application>的使用，<function>PQinitSSL</>是对应用程序的不错的选择。
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </sect2>

 </sect1>


 <sect1 id="libpq-threading">
  <!--
  <title>Behavior in Threaded Programs</title>
  -->
  <title>在多线程程序里的行为</title>

  <indexterm zone="libpq-threading">
   <!--
   <primary>threads</primary>
   <secondary>with libpq</secondary>
   -->
   <primary>线程</primary>
   <secondary>在libpq中</secondary>
  </indexterm>

  <!--
<para>
   <application>libpq</application> is reentrant and thread-safe by default.
   You might need to use special compiler command-line
   options when you compile your application code.  Refer to your
   system's documentation for information about how to build
   thread-enabled applications, or look in
   <filename>src/Makefile.global</filename> for <literal>PTHREAD_CFLAGS</>
   and <literal>PTHREAD_LIBS</>.  This function allows the querying of
   <application>libpq</application>'s thread-safe status:
  </para>
-->
<para>
<application>libpq</application>是可重入的并且是线程安全的。另外，
在你编译自己的应用代码时，可能需要使用额外的编译器命令行选项。
参考你的系统的文档获取关于如果建立线程可用的应用的信息，
或在<filename>src/Makefile.global</filename>中查看<literal>PTHREAD_CFLAGS</>
和<literal>PTHREAD_LIBS</>。此功能允许查询<application>libpq</application>的线程安全状态：
</para>

  <variablelist>
   <varlistentry id="libpq-pqisthreadsafe">
    <term>
     <function>PQisthreadsafe</function>
     <indexterm>
      <primary>PQisthreadsafe</primary>
     </indexterm>
    </term>

    <listitem>    
<para>
<!--
      Returns the thread safety status of the
      <application>libpq</application> library.
-->
返回<application>libpq</application>库的线程安全状态。
<synopsis>
int PQisthreadsafe();
</synopsis>
     </para>

     <!--
<para>
      Returns 1 if the <application>libpq</application> is thread-safe
      and 0 if it is not.
     </para>
-->
<para>
<application>libpq</application>是线程安全的时，返回1 ；如果不是返回0。
</para>
    </listitem>
   </varlistentry>
  </variablelist>

  <!--
<para>
   One thread restriction is that no two threads attempt to manipulate
   the same <structname>PGconn</> object at the same time. In particular,
   you cannot issue concurrent commands from different threads through
   the same connection object. (If you need to run concurrent commands,
   use multiple connections.)
  </para>
-->
<para>
一个线程限制是，两个线程不能试图同时操作同一个<structname>PGconn</>对象。特别是，
你不能从不同的线程里通过同一个连接对象发出并发的命令。（如果你需要运行并行命令，
请使用多个连接。）
</para>

  <!--
<para>
   <structname>PGresult</> objects are normally read-only after creation,
   and so can be passed around freely between threads.  However, if you use
   any of the <structname>PGresult</>-modifying functions described in
   <xref linkend="libpq-misc"> or <xref linkend="libpq-events">, it's up
   to you to avoid concurrent operations on the same <structname>PGresult</>,
   too.
  </para>
-->
<para>
<structname>PGresult</>对象在创建后是只读的，因此可以自由地在线程之间传递。然而，
如果你使用在<xref linkend="libpq-misc">和<xref linkend="libpq-events">
中描述的任何<structname>PGresult</>修改函数，那么它也取决于你可以避免同一
<structname>PGresult</>上的并发操作。
</para>

  <!--
<para>
   The deprecated functions <function>PQrequestCancel</function> and
   <function>PQoidStatus</function> are not thread-safe and should not be
   used in multithread programs.  <function>PQrequestCancel</function>
   can be replaced by <function>PQcancel</function>.
   <function>PQoidStatus</function> can be replaced by
   <function>PQoidValue</function>.
  </para>
-->
<para>
过时了的函数<function>PQrequestCancel</function>和<function>PQoidStatus</function>
都是线程不安全的，因此不应该在一个多线程的程序里面使用。<function>PQrequestCancel</function>
可以由<function>PQcancel</function>代替。<function>PQoidStatus</function>可以由
<function>PQoidValue</function>代替。
</para>

  <!--
<para>
   If you are using Kerberos inside your application (in addition to inside
   <application>libpq</application>), you will need to do locking around
   Kerberos calls because Kerberos functions are not thread-safe.  See
   function <function>PQregisterThreadLock</> in the
   <application>libpq</application> source code for a way to do cooperative
   locking between <application>libpq</application> and your application.
  </para>
-->
<para>
如果在你的应用内部使用了 Kerberos （而不仅仅是<application>libpq</application>里面），
你就需要在 Kerberos 调用周围锁住，因为 Kerberos 函数不是线程安全的。
参阅<application>libpq</application>源代码里面的<function>PQregisterThreadLock</>
获取一个在<application>libpq</application>和你的应用之间进行恰当锁定的方法。
</para>

  <!--
<para>
   If you experience problems with threaded applications, run the program
   in <filename>src/tools/thread</> to see if your platform has
   thread-unsafe functions.  This program is run by
   <filename>configure</filename>, but for binary distributions your
   library might not match the library used to build the binaries.
  </para>
-->
<para>
如果你的线程应用有问题，那么运行一个在<filename>src/tools/thread</>里的程序，
看看你的平台是否有线程不安全的函数。这个程序由<filename>configure</filename>运行，
但如果是二进制版本，你的库可能就不能和制作二进制的那个库匹配了。
</para>
 </sect1>


 <sect1 id="libpq-build">
  <!--
  <title>Building <application>libpq</application> Programs</title>
  -->
  <title>制作<application>libpq</application>程序</title>

  <indexterm zone="libpq-build">
   <!--
   <primary>compiling</primary>
   <secondary>libpq applications</secondary>
   -->
   <primary>编译</primary>
   <secondary>libpq应用</secondary>
  </indexterm>

  
<para>
<!-- 
   To build (i.e., compile and link) a program using
   <application>libpq</application> you need to do all of the following
   things: 
-->
要制作（也就是说编译和链接）你的<application>libpq</application>程序，
你需要做下面的一些事情：

   <itemizedlist>
    <listitem>

     <para>
<!--
      Include the <filename>libpq-fe.h</filename> header file:
-->
包含<filename>libpq-fe.h</filename>头文件：
<programlisting>
#include &lt;libpq-fe.h&gt;
</programlisting>
<!-- 
      If you failed to do that then you will normally get error messages
      from your compiler similar to: 
-->
如果你没干这件事，那么你通常会看到类似下面这样的来自编译器的错误消息∶
<screen>
foo.c: In function `main':
foo.c:34: `PGconn' undeclared (first use in this function)
foo.c:35: `PGresult' undeclared (first use in this function)
foo.c:54: `CONNECTION_BAD' undeclared (first use in this function)
foo.c:68: `PGRES_COMMAND_OK' undeclared (first use in this function)
foo.c:95: `PGRES_TUPLES_OK' undeclared (first use in this function)
</screen>
     </para>
    </listitem>

    <listitem>
     
<para>
<!--
      Point your compiler to the directory where the <productname>PostgreSQL</> header
      files were installed, by supplying the
      <literal>-I<replaceable>directory</replaceable></literal> option
      to your compiler.  (In some cases the compiler will look into
      the directory in question by default, so you can omit this
      option.)  For instance, your compile command line could look
      like:
-->
告诉你的编译器<productname>PostgreSQL</>头文件的安装位置，方法是给你的编译器提供
<literal>-I<replaceable>directory</replaceable></literal>选项。(有些时候编译器会查找缺省的目录，
因此你可以忽略这些选项。) 比如，你的编译命令行看起来像：
<programlisting>
cc -c -I/usr/local/pgsql/include testprog.c
</programlisting>
      <!--
  If you are using makefiles then add the option to the
      <varname>CPPFLAGS</varname> variable:
  -->
  如果你在使用制作文件(makefile)，那么向<varname>CPPFLAGS</varname>变量中增加下面的选项：
<programlisting>
CPPFLAGS += -I/usr/local/pgsql/include
</programlisting>
     </para>

     
<para>
<!--
      If there is any chance that your program might be compiled by
      other users then you should not hardcode the directory location
      like that.  Instead, you can run the utility
      <command>pg_config</command><indexterm><primary>pg_config</><secondary
      sortas="libpq">with libpq</></> to find out where the header
      files are on the local system:
-->
如果你的程序可能会被别人编译，那么你应该避免像上面那样把目录路径写成硬编码。
取而代之的是你可以运行<command>pg_config</command><indexterm><primary>pg_config</>
<secondary sortas="libpq">with libpq</></>工具找出头文件在系统的什么地方：
<screen>
<prompt>$</prompt> pg_config -&#045;includedir
<computeroutput>/usr/local/include</computeroutput>
</screen>
     </para>
    
<para>
<!--
      If you
      have <command>pkg-config</command><indexterm><primary>pkg-config</primary><secondary sortas="libpq">with
      libpq</secondary></indexterm> installed, you can run instead:
-->
如果你安装了<command>pkg-config</command><indexterm><primary>pkg-config</primary><secondary sortas="libpq">with
      libpq</secondary></indexterm>，你可以运行：
<screen>
<prompt>$</prompt> pkg-config --cflags libpq
<computeroutput>-I/usr/local/include</computeroutput>
</screen>
      <!-- 
  Note that this will already include the <option>-I</option> in front of
      the path. 
  -->
  注意路径的前面早已包括<option>-I</option>。
     </para>

     
<para>
<!--
      Failure to specify the correct option to the compiler will
      result in an error message such as:
-->
如果没能给编译器提供正确的选项将产生类似下面这样的错误消息：
<screen>
testlibpq.c:8:22: libpq-fe.h: No such file or directory
</screen>
     </para>
    </listitem>

    <listitem>
     
<para>
<!--
      When linking the final program, specify the option
      <literal>-lpq</literal> so that the <application>libpq</application>
      library gets pulled in, as well as the option
      <literal>-L<replaceable>directory</replaceable></literal> to point
      the compiler to the directory where the
      <application>libpq</application> library resides.  (Again, the
      compiler will search some directories by default.)  For maximum
      portability, put the <option>-L</option> option before the
      <option>-lpq</option> option.  For example:
-->
在链接最后的程序的时候，声明选项<literal>-lpq</literal>，这样就可以把
<application>libpq</application>库链接进来，还要声明
<literal>-L<replaceable>directory</replaceable></literal>以告诉编译器
<application>libpq</application>所处的目录。(同样，编译器也会搜索一些缺省的目录。)
为了尽可能提高可移植性，你应该把<option>-L</option>选项放在<option>-lpq</option>选项前面。比如：
<programlisting>
cc -o testprog testprog1.o testprog2.o -L/usr/local/pgsql/lib -lpq
</programlisting>
     </para>
     
<para>
<!--
      You can find out the library directory using
      <command>pg_config</command> as well:
-->
你也可以用<command>pg_config</command>找出库目录：
<screen>
<prompt>$</prompt> pg_config -&#045;libdir
<computeroutput>/usr/local/pgsql/lib</computeroutput>
</screen>
     </para>
    
<para>
<!--
     Or again use <command>pkg-config</command>:
-->
或再次使用<command>pkg-config</command>：
<screen>
<prompt>$</prompt> pkg-config --libs libpq
<computeroutput>-L/usr/local/pgsql/lib -lpq</computeroutput>
</screen>
      <!--
  Note again that this prints the full options, not only the path.
  -->
  请注意，这会输出全部选项，而不只是路径。
     </para>
    
<para>
<!--
      Error messages that point to problems in this area could look like
      the following:
-->
指向这类问题的错误消息会是类似下面这个样子。
<screen>
testlibpq.o: In function `main':
testlibpq.o(.text+0x60): undefined reference to `PQsetdbLogin'
testlibpq.o(.text+0x71): undefined reference to `PQstatus'
testlibpq.o(.text+0xa4): undefined reference to `PQerrorMessage'
</screen>
      <!-- 
  This means you forgot <option>-lpq</option>. 
  -->
  这意味着你忘记了<option>-lpq</option>。
<screen>
/usr/bin/ld: cannot find -lpq
</screen>
      <!--
  This means you forgot the <option>-L</option> option or did not
      specify the right directory.
  -->
  这意味着你忘记<option>-L</option>了或没有指定正确的目录。
     </para>
    </listitem>
   </itemizedlist>
  </para>

 </sect1>


 <sect1 id="libpq-example">
  <!--
  <title>Example Programs</title>
  -->
  <title>例子程序</title>

  <!--
<para>
   These examples and others can be found in the
   directory <filename>src/test/examples</filename> in the source code
   distribution.
  </para>
-->
<para>
这些例子和其他的可以在字典<filename>src/test/examples</filename>的源代码分布中找到。
</para>

  <example id="libpq-example-1">
  <!--
  <title><application>libpq</application> Example Program 1</title>
  -->
   <title><application>libpq</application> 例子程序 1</title>

<!--
<programlisting>
<![CDATA[
/*
 * testlibpq.c
 *
 *      Test the C version of libpq, the PostgreSQL frontend library.
 */
#include <stdio.h>
#include <stdlib.h>
#include <libpq-fe.h>

static void
exit_nicely(PGconn *conn)
{
    PQfinish(conn);
    exit(1);
}

int
main(int argc, char **argv)
{
    const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    int         nFields;
    int         i,
                j;

    /*
     * If the user supplies a parameter on the command line, use it as the
     * conninfo string; otherwise default to setting dbname=postgres and using
     * environment variables or defaults for all other connection parameters.
     */
    if (argc > 1)
        conninfo = argv[1];
    else
        conninfo = "dbname = postgres";

    /* Make a connection to the database */
    conn = PQconnectdb(conninfo);

    /* Check to see that the backend connection was successfully made */
    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        exit_nicely(conn);
    }

    /*
     * Our test case here involves using a cursor, for which we must be inside
     * a transaction block.  We could do the whole thing with a single
     * PQexec() of "select * from pg_database", but that's too trivial to make
     * a good example.
     */

    /* Start a transaction block */
    res = PQexec(conn, "BEGIN");
    if (PQresultStatus(res) != PGRES_COMMAND_OK)
    {
        fprintf(stderr, "BEGIN command failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    /*
     * Should PQclear PGresult whenever it is no longer needed to avoid memory
     * leaks
     */
    PQclear(res);

    /*
     * Fetch rows from pg_database, the system catalog of databases
     */
    res = PQexec(conn, "DECLARE myportal CURSOR FOR select * from pg_database");
    if (PQresultStatus(res) != PGRES_COMMAND_OK)
    {
        fprintf(stderr, "DECLARE CURSOR failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }
    PQclear(res);

    res = PQexec(conn, "FETCH ALL in myportal");
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        fprintf(stderr, "FETCH ALL failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    /* first, print out the attribute names */
    nFields = PQnfields(res);
    for (i = 0; i < nFields; i++)
        printf("%-15s", PQfname(res, i));
    printf("\n\n");

    /* next, print out the rows */
    for (i = 0; i < PQntuples(res); i++)
    {
        for (j = 0; j < nFields; j++)
            printf("%-15s", PQgetvalue(res, i, j));
        printf("\n");
    }

    PQclear(res);

    /* close the portal ... we don't bother to check for errors ... */
    res = PQexec(conn, "CLOSE myportal");
    PQclear(res);

    /* end the transaction */
    res = PQexec(conn, "END");
    PQclear(res);

    /* close the connection to the database and cleanup */
    PQfinish(conn);

    return 0;
}
]]>
</programlisting>
-->
<programlisting><![CDATA[
/*
 * testlibpq.c
 *
 *      测试libpq的C版本，PostgreSQL前端库。
 */
#include <stdio.h>
#include <stdlib.h>
#include <libpq-fe.h>

static void
exit_nicely(PGconn *conn)
{
    PQfinish(conn);
    exit(1);
}

int
main(int argc, char **argv)
{
    const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    int         nFields;
    int         i,
                j;

    /*
     * 如果用户在命令行上提供了一个参数，则拿它当作 conninfo 字串使用；
     * 否则缺省为 dbname=postgres 并且使用环境变量或者所有其它连接参数
     * 都使用缺省值。
     */
    if (argc > 1)
        conninfo = argv[1];
    else
        conninfo = "dbname = postgres";

    /* 连接数据库 */
    conn = PQconnectdb(conninfo);

    /* 检查后端连接成功建立 */
    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        exit_nicely(conn);
    }

    /*
     * 我们的测试实例涉及游标的使用，这个时候我们必须使用事务块。
     * 我们可以把全部事情放在一个  "select * from pg_database"
     * PQexec() 里，不过那样太简单了，不是个好例子。
     */

    /* 开始一个事务块 */
    res = PQexec(conn, "BEGIN");
    if (PQresultStatus(res) != PGRES_COMMAND_OK)
    {
        fprintf(stderr, "BEGIN command failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    /*
     * 应该在结果不需要的时候 PQclear PGresult，以避免内存泄漏
     */
    PQclear(res);

    /*
     * 从系统表 pg_database（数据库的系统目录）里抓取数据
     */
    res = PQexec(conn, "DECLARE myportal CURSOR FOR select * from pg_database");
    if (PQresultStatus(res) != PGRES_COMMAND_OK)
    {
        fprintf(stderr, "DECLARE CURSOR failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }
    PQclear(res);

    res = PQexec(conn, "FETCH ALL in myportal");
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        fprintf(stderr, "FETCH ALL failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    /* 首先，打印属性名称 */
    nFields = PQnfields(res);
    for (i = 0; i < nFields; i++)
        printf("%-15s", PQfname(res, i));
    printf("\n\n");

    /* 然后打印行 */
    for (i = 0; i < PQntuples(res); i++)
    {
        for (j = 0; j < nFields; j++)
            printf("%-15s", PQgetvalue(res, i, j));
        printf("\n");
    }

    PQclear(res);

    /* 关闭入口 ... 我们不用检查错误 ... */
    res = PQexec(conn, "CLOSE myportal");
    PQclear(res);

    /* 结束事务 */
    res = PQexec(conn, "END");
    PQclear(res);

    /* 关闭数据库连接并清理 */
    PQfinish(conn);

    return 0;
}
]]>
</programlisting>
  </example>

  <example id="libpq-example-2">
   <!--
   <title><application>libpq</application> Example Program 2</title>
   -->
   <title><application>libpq</application> 例子程序 2</title>

<!--
<programlisting>
<![CDATA[
/*
 * testlibpq2.c
 *      Test of the asynchronous notification interface
 *
 * Start this program, then from psql in another window do
 *   NOTIFY TBL2;
 * Repeat four times to get this program to exit.
 *
 * Or, if you want to get fancy, try this:
 * populate a database with the following commands
 * (provided in src/test/examples/testlibpq2.sql):
 *
 *   CREATE TABLE TBL1 (i int4);
 *
 *   CREATE TABLE TBL2 (i int4);
 *
 *   CREATE RULE r1 AS ON INSERT TO TBL1 DO
 *     (INSERT INTO TBL2 VALUES (new.i); NOTIFY TBL2);
 *
 * and do this four times:
 *
 *   INSERT INTO TBL1 VALUES (10);
 */
#ifdef WIN32
#include <windows.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/time.h>
#include <sys/types.h>
#include "libpq-fe.h"

static void
exit_nicely(PGconn *conn)
{
    PQfinish(conn);
    exit(1);
}

int
main(int argc, char **argv)
{
    const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    PGnotify   *notify;
    int         nnotifies;

    /*
     * If the user supplies a parameter on the command line, use it as the
     * conninfo string; otherwise default to setting dbname=postgres and using
     * environment variables or defaults for all other connection parameters.
     */
    if (argc > 1)
        conninfo = argv[1];
    else
        conninfo = "dbname = postgres";

    /* Make a connection to the database */
    conn = PQconnectdb(conninfo);

    /* Check to see that the backend connection was successfully made */
    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        exit_nicely(conn);
    }

    /*
     * Issue LISTEN command to enable notifications from the rule's NOTIFY.
     */
    res = PQexec(conn, "LISTEN TBL2");
    if (PQresultStatus(res) != PGRES_COMMAND_OK)
    {
        fprintf(stderr, "LISTEN command failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    /*
     * should PQclear PGresult whenever it is no longer needed to avoid memory
     * leaks
     */
    PQclear(res);

    /* Quit after four notifies are received. */
    nnotifies = 0;
    while (nnotifies < 4)
    {
        /*
         * Sleep until something happens on the connection.  We use select(2)
         * to wait for input, but you could also use poll() or similar
         * facilities.
         */
        int         sock;
        fd_set      input_mask;

        sock = PQsocket(conn);

        if (sock < 0)
            break;              /* shouldn't happen */

        FD_ZERO(&input_mask);
        FD_SET(sock, &input_mask);

        if (select(sock + 1, &input_mask, NULL, NULL, NULL) < 0)
        {
            fprintf(stderr, "select() failed: %s\n", strerror(errno));
            exit_nicely(conn);
        }

        /* Now check for input */
        PQconsumeInput(conn);
        while ((notify = PQnotifies(conn)) != NULL)
        {
            fprintf(stderr,
                    "ASYNC NOTIFY of '%s' received from backend PID %d\n",
                    notify->relname, notify->be_pid);
            PQfreemem(notify);
            nnotifies++;
        }
    }

    fprintf(stderr, "Done.\n");

    /* close the connection to the database and cleanup */
    PQfinish(conn);

    return 0;
}
]]>
</programlisting>
-->
<programlisting><![CDATA[
/*
 * testlibpq2.c
 *      测试异步通知接口
 *
 * 运行此程序，然后从另外一个窗口的 psql 里运行
 *   NOTIFY TBL2;
 * 重复四次，直到程序退出
 *
 * 或者，如果你想好玩一点，用下面命令填充数据库：
 * （在 src/test/examples/testlibpq2.sql 里提供）：
 *
 *   CREATE TABLE TBL1 (i int4);
 *
 *   CREATE TABLE TBL2 (i int4);
 *
 *   CREATE RULE r1 AS ON INSERT TO TBL1 DO
 *     (INSERT INTO TBL2 VALUES (new.i); NOTIFY TBL2);
 *
 * 然后做四次：
 *
 *   INSERT INTO TBL1 VALUES (10);
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/time.h>
#include <libpq-fe.h>

static void
exit_nicely(PGconn *conn)
{
    PQfinish(conn);
    exit(1);
}

int
main(int argc, char **argv)
{
    const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    PGnotify   *notify;
    int         nnotifies;

    /*
     * 如果用户在命令行上提供了参数，
     * 那么拿它当作 conninfo 字串；否则缺省设置是 dbname=postgres
     * 并且对其它连接使用环境变量或者缺省值。
     */
    if (argc > 1)
        conninfo = argv[1];
    else
        conninfo = "dbname = postgres";

    /* 和数据库建立连接 */
    conn = PQconnectdb(conninfo);

    /* 检查一下与服务器的连接是否成功建立 */
    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        exit_nicely(conn);
    }

    /*
     * 发出 LISTEN 命令打开来自规则 NOTIFY 的通知
     */
    res = PQexec(conn, "LISTEN TBL2");
    if (PQresultStatus(res) != PGRES_COMMAND_OK)
    {
        fprintf(stderr, "LISTEN command failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    /*
     * 如果不再需要了，我们应该 PQclear PGresult ，以避免内存泄漏
     */
    PQclear(res);

    /* 收到四次通知之后退出。 */
    nnotifies = 0;
    while (nnotifies < 4)
    {
        /*
         * 睡眠，直到某些事件发生。我们使用 select(2) 等待输入，
         * 但是也可以用 poll() 或者类似的设施。
         */
        int         sock;
        fd_set      input_mask;

        sock = PQsocket(conn);

        if (sock < 0)
            break;              /* 不应该发生 */

        FD_ZERO(&input_mask);
        FD_SET(sock, &input_mask);

        if (select(sock + 1, &input_mask, NULL, NULL, NULL) < 0)
        {
            fprintf(stderr, "select() failed: %s\n", strerror(errno));
            exit_nicely(conn);
        }

        /* 现在检查输入 */
        PQconsumeInput(conn);
        while ((notify = PQnotifies(conn)) != NULL)
        {
            fprintf(stderr,
                    "ASYNC NOTIFY of '%s' received from backend PID %d\n",
                    notify->relname, notify->be_pid);
            PQfreemem(notify);
            nnotifies++;
        }
    }

    fprintf(stderr, "Done.\n");

    /* 关闭数据连接并清理 */
    PQfinish(conn);

    return 0;
}
]]>
</programlisting>
  </example>

  <example id="libpq-example-3">
   <!--
   <title><application>libpq</application> Example Program 3</title>
   -->
   <title><application>libpq</application> 例子程序 3</title>

<!--
<programlisting>
<![CDATA[
/*
 * testlibpq3.c
 *      Test out-of-line parameters and binary I/O.
 *
 * Before running this, populate a database with the following commands
 * (provided in src/test/examples/testlibpq3.sql):
 *
 * CREATE TABLE test1 (i int4, t text, b bytea);
 *
 * INSERT INTO test1 values (1, 'joe''s place', '\\000\\001\\002\\003\\004');
 * INSERT INTO test1 values (2, 'ho there', '\\004\\003\\002\\001\\000');
 *
 * The expected output is:
 *
 * tuple 0: got
 *  i = (4 bytes) 1
 *  t = (11 bytes) 'joe's place'
 *  b = (5 bytes) \000\001\002\003\004
 *
 * tuple 0: got
 *  i = (4 bytes) 2
 *  t = (8 bytes) 'ho there'
 *  b = (5 bytes) \004\003\002\001\000
 */

#ifdef WIN32
#include <windows.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <sys/types.h>
#include "libpq-fe.h"

/* for ntohl/htonl */
#include <netinet/in.h>
#include <arpa/inet.h>


static void
exit_nicely(PGconn *conn)
{
    PQfinish(conn);
    exit(1);
}

/*
 * This function prints a query result that is a binary-format fetch from
 * a table defined as in the comment above.  We split it out because the
 * main() function uses it twice.
 */
static void
show_binary_results(PGresult *res)
{
    int         i,
                j;
    int         i_fnum,
                t_fnum,
                b_fnum;

    /* Use PQfnumber to avoid assumptions about field order in result */
    i_fnum = PQfnumber(res, "i");
    t_fnum = PQfnumber(res, "t");
    b_fnum = PQfnumber(res, "b");

    for (i = 0; i < PQntuples(res); i++)
    {
        char       *iptr;
        char       *tptr;
        char       *bptr;
        int         blen;
        int         ival;

        /* Get the field values (we ignore possibility they are null!) */
        iptr = PQgetvalue(res, i, i_fnum);
        tptr = PQgetvalue(res, i, t_fnum);
        bptr = PQgetvalue(res, i, b_fnum);

        /*
         * The binary representation of INT4 is in network byte order, which
         * we'd better coerce to the local byte order.
         */
        ival = ntohl(*((uint32_t *) iptr));

        /*
         * The binary representation of TEXT is, well, text, and since libpq
         * was nice enough to append a zero byte to it, it'll work just fine
         * as a C string.
         *
         * The binary representation of BYTEA is a bunch of bytes, which could
         * include embedded nulls so we have to pay attention to field length.
         */
        blen = PQgetlength(res, i, b_fnum);

        printf("tuple %d: got\n", i);
        printf(" i = (%d bytes) %d\n",
               PQgetlength(res, i, i_fnum), ival);
        printf(" t = (%d bytes) '%s'\n",
               PQgetlength(res, i, t_fnum), tptr);
        printf(" b = (%d bytes) ", blen);
        for (j = 0; j < blen; j++)
            printf("\\%03o", bptr[j]);
        printf("\n\n");
    }
}

int
main(int argc, char **argv)
{
    const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    const char *paramValues[1];
    int         paramLengths[1];
    int         paramFormats[1];
    uint32_t    binaryIntVal;

    /*
     * If the user supplies a parameter on the command line, use it as the
     * conninfo string; otherwise default to setting dbname=postgres and using
     * environment variables or defaults for all other connection parameters.
     */
    if (argc > 1)
        conninfo = argv[1];
    else
        conninfo = "dbname = postgres";

    /* Make a connection to the database */
    conn = PQconnectdb(conninfo);

    /* Check to see that the backend connection was successfully made */
    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        exit_nicely(conn);
    }

    /*
     * The point of this program is to illustrate use of PQexecParams() with
     * out-of-line parameters, as well as binary transmission of data.
     *
     * This first example transmits the parameters as text, but receives the
     * results in binary format.  By using out-of-line parameters we can avoid
     * a lot of tedious mucking about with quoting and escaping, even though
     * the data is text.  Notice how we don't have to do anything special with
     * the quote mark in the parameter value.
     */

    /* Here is our out-of-line parameter value */
    paramValues[0] = "joe's place";

    res = PQexecParams(conn,
                       "SELECT * FROM test1 WHERE t = $1",
                       1,       /* one param */
                       NULL,    /* let the backend deduce param type */
                       paramValues,
                       NULL,    /* don't need param lengths since text */
                       NULL,    /* default to all text params */
                       1);      /* ask for binary results */

    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        fprintf(stderr, "SELECT failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    show_binary_results(res);

    PQclear(res);

    /*
     * In this second example we transmit an integer parameter in binary form,
     * and again retrieve the results in binary form.
     *
     * Although we tell PQexecParams we are letting the backend deduce
     * parameter type, we really force the decision by casting the parameter
     * symbol in the query text.  This is a good safety measure when sending
     * binary parameters.
     */

    /* Convert integer value "2" to network byte order */
    binaryIntVal = htonl((uint32_t) 2);

    /* Set up parameter arrays for PQexecParams */
    paramValues[0] = (char *) &binaryIntVal;
    paramLengths[0] = sizeof(binaryIntVal);
    paramFormats[0] = 1;        /* binary */

    res = PQexecParams(conn,
                       "SELECT * FROM test1 WHERE i = $1::int4",
                       1,       /* one param */
                       NULL,    /* let the backend deduce param type */
                       paramValues,
                       paramLengths,
                       paramFormats,
                       1);      /* ask for binary results */

    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        fprintf(stderr, "SELECT failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    show_binary_results(res);

    PQclear(res);

    /* close the connection to the database and cleanup */
    PQfinish(conn);

    return 0;
}
]]>
</programlisting>
-->
<programlisting><![CDATA[
/*
 * testlibpq3.c
 *      测试外联参数和二进制I/O。
 *
 * 在运行这个例子之前，用下面的命令填充一个数据库
 * （在 src/test/examples/testlibpq3.sql 里提供）：
 *
 * CREATE TABLE test1 (i int4, t text, b bytea);
 *
 * INSERT INTO test1 values (1, 'joe''s place', '\\000\\001\\002\\003\\004');
 * INSERT INTO test1 values (2, 'ho there', '\\004\\003\\002\\001\\000');
 *
 * 期望的输出是：
 *
 * tuple 0: got
 *  i = (4 bytes) 1
 *  t = (11 bytes) 'joe's place'
 *  b = (5 bytes) \000\001\002\003\004
 *
 * tuple 0: got
 *  i = (4 bytes) 2
 *  t = (8 bytes) 'ho there'
 *  b = (5 bytes) \004\003\002\001\000
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <libpq-fe.h>

/* for ntohl/htonl */
#include <netinet/in.h>
#include <arpa/inet.h>


static void
exit_nicely(PGconn *conn)
{
    PQfinish(conn);
    exit(1);
}

/*
 * 这个函数打印查询结果，这些结果是二进制格式，从上面的
 * 注释里面创建的表中抓取出来的。我们把这个函数单独拆出来
 * 是因为 main() 函数用了它两次。
 */
static void
show_binary_results(PGresult *res)
{
    int         i,
                j;
    int         i_fnum,
                t_fnum,
                b_fnum;

    /* 使用 PQfnumber 来避免对结果中的字段顺序进行假设 */
    i_fnum = PQfnumber(res, "i");
    t_fnum = PQfnumber(res, "t");
    b_fnum = PQfnumber(res, "b");

    for (i = 0; i < PQntuples(res); i++)
    {
        char       *iptr;
        char       *tptr;
        char       *bptr;
        int         blen;
        int         ival;

        /* 获取字段值（我们忽略了它们可能为空的这个可能！） */
        iptr = PQgetvalue(res, i, i_fnum);
        tptr = PQgetvalue(res, i, t_fnum);
        bptr = PQgetvalue(res, i, b_fnum);

        /*
         * INT4 的二进制表现形式是网络字节序，
         * 我们最好转换成本地字节序。
         */
        ival = ntohl(*((uint32_t *) iptr));

        /*
         * TEXT 的二进制表现形式是，嗯，文本，因此 libpq 足够给它附加一个字节零，
         * 因此把它看做 C 字串就挺好。
         *
         * BYTEA 的二进制表现形式是一堆字节，里面可能包含嵌入的空值，
         * 因此我们必须注意字段长度。
         */
        blen = PQgetlength(res, i, b_fnum);

        printf("tuple %d: got\n", i);
        printf(" i = (%d bytes) %d\n",
               PQgetlength(res, i, i_fnum), ival);
        printf(" t = (%d bytes) '%s'\n",
               PQgetlength(res, i, t_fnum), tptr);
        printf(" b = (%d bytes) ", blen);
        for (j = 0; j < blen; j++)
            printf("\\%03o", bptr[j]);
        printf("\n\n");
    }
}

int
main(int argc, char **argv)
{
    const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    const char *paramValues[1];
    int         paramLengths[1];
    int         paramFormats[1];
    uint32_t    binaryIntVal;

    /*
     * 如果用户在命令行上提供了参数，
     * 那么拿它当作 conninfo 字串；否则缺省设置是 dbname=postgres
     * 并且对其它连接参数使用环境变量或者缺省值。
     */
    if (argc > 1)
        conninfo = argv[1];
    else
        conninfo = "dbname = postgres";

    /* 和数据库建立连接 */
    conn = PQconnectdb(conninfo);

    /* 检查一下与服务器的连接是否成功建立 */
    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        exit_nicely(conn);
    }

    /*
     * 这个程序是用来演示使用外联参数的 PQexecParams()，
     * 以及数据的二进制传输。第一个例子使用文本传输参数，
     * 但是用二进制格式接收结果。通过使用外联参数，我们可以避免大量
     * 枯燥的字串的引用和转义，即使数据是文本。请注意我们这里不需要对参数值里的引号
     * 做任何特殊的处理。
     */

    /* 这里是我们的外联参数值 */
    paramValues[0] = "joe's place";

    res = PQexecParams(conn,
                       "SELECT * FROM test1 WHERE t = $1",
                       1,       /* 一个参数 */
                       NULL,    /* 让后端推出参数类型 */
                       paramValues,
                       NULL,    /* 因为是文本，所以必须要参数长度 */
                       NULL,    /* 缺省是全部文本参数 */
                       1);      /* 要求二进制结果 */

    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        fprintf(stderr, "SELECT failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    show_binary_results(res);

    PQclear(res);

    /*
     * 在这个第二个例子里，我们以二进制格式传输一个整数参数，
     * 然后还是以二进制格式检索结果。
     *
     * 尽管我们告诉 PQexecParams，我们让后端推导参数类型，
     * 实际上我们通过在查询字串里转换参数符号的方法强制了决定的做出。
     * 在发送二进制参数的时候，这是一个很好的安全检查。
     */

    /* 把整数值 "2" 转换成网络字节序 */
    binaryIntVal = htonl((uint32_t) 2);

    /* 为 PQexecParams 设置参数数组 */
    paramValues[0] = (char *) &binaryIntVal;
    paramLengths[0] = sizeof(binaryIntVal);
    paramFormats[0] = 1;        /* 二进制 */

    res = PQexecParams(conn,
                       "SELECT * FROM test1 WHERE i = $1::int4",
                       1,       /* 一个参数 */
                       NULL,    /* 让后端推导参数类型 */
                       paramValues,
                       paramLengths,
                       paramFormats,
                       1);      /* 要求二进制结果 */

    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        fprintf(stderr, "SELECT failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    show_binary_results(res);

    PQclear(res);

    /* 关闭与数据库的连接并清理 */
    PQfinish(conn);

    return 0;
}
]]>
</programlisting>
  </example>

 </sect1>
</chapter>
