<!-- doc/src/sgml/libpq.sgml -->

<chapter id="libpq">
<!-- pgdoc-cn_start sig_en=29025d3d5f7b69cf8f7ba2e62b92a484 sig_cn_org=None source=14.1 
 <title><application>libpq</application> &mdash; C Library</title>
________________________________________________________-->
 <title><application>libpq</application> - C 库</title>
<!-- pgdoc-cn_end sig_en=29025d3d5f7b69cf8f7ba2e62b92a484 -->

<!-- pgdoc-cn_start sig_en=813173e220456e0b75ca27f5005dd89f sig_cn_org=None source=14.1 
 <indexterm zone="libpq">
  <primary>libpq</primary>
 </indexterm>
________________________________________________________-->
 <indexterm zone="libpq">
  <primary>libpq</primary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=813173e220456e0b75ca27f5005dd89f -->

<!-- pgdoc-cn_start sig_en=c29d4aeab2bbee16208b9fb826a3a3b8 sig_cn_org=None source=14.1 
 <indexterm zone="libpq">
  <primary>C</primary>
 </indexterm>
________________________________________________________-->
 <indexterm zone="libpq">
  <primary>C</primary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=c29d4aeab2bbee16208b9fb826a3a3b8 -->

<!-- pgdoc-cn_start sig_en=fde1f7a4535c2c3003a55b481cfc2e40 sig_cn_org=None source=14.1 
 <para>
  <application>libpq</application> is the <acronym>C</acronym>
  application programmer's interface to <productname>PostgreSQL</productname>.
  <application>libpq</application> is a set of library functions that allow
  client programs to pass queries to the <productname>PostgreSQL</productname>
  backend server and to receive the results of these queries.
 </para>
________________________________________________________-->
 <para>
  <application>libpq</application>是应用程序员使用<productname>PostgreSQL</productname>的<acronym>C</acronym>接口。<application>libpq</application>是一个库函数的集合，它们允许客户端程序传递查询给<productname>PostgreSQL</productname>后端服务器并且接收这些查询的结果。
 </para>
<!-- pgdoc-cn_end sig_en=fde1f7a4535c2c3003a55b481cfc2e40 -->

<!-- pgdoc-cn_start sig_en=766fde18e31f3e0c1447b8abd38468ff sig_cn_org=None source=14.1 
 <para>
  <application>libpq</application> is also the underlying engine for several
  other <productname>PostgreSQL</productname> application interfaces, including
  those written for C++, Perl, Python, Tcl and <application>ECPG</application>.
  So some aspects of <application>libpq</application>'s behavior will be
  important to you if you use one of those packages.  In particular,
  <xref linkend="libpq-envars"/>,
  <xref linkend="libpq-pgpass"/> and
  <xref linkend="libpq-ssl"/>
  describe behavior that is visible to the user of any application
  that uses <application>libpq</application>.
 </para>
________________________________________________________-->
 <para>
  <application>libpq</application>也是很多其他<productname>PostgreSQL</productname>应用接口的底层引擎，包括为 C++、Perl、Python、Tcl 和 <application>ECPG</application>编写的接口。如果你使用那些包，某些方面的<application>libpq</application>行为将会对你很重要。特别是，<xref linkend="libpq-envars"/>、<xref linkend="libpq-pgpass"/>和<xref linkend="libpq-ssl"/>描述了任何使用<application>libpq</application>的应用的用户可见的行为。
 </para>
<!-- pgdoc-cn_end sig_en=766fde18e31f3e0c1447b8abd38468ff -->

<!-- pgdoc-cn_start sig_en=c98d2bcdb740afb0ffb984bd9b7c0289 sig_cn_org=None source=14.1 
 <para>
  Some short programs are included at the end of this chapter (<xref linkend="libpq-example"/>) to show how
  to write programs that use <application>libpq</application>.  There are also several
  complete examples of <application>libpq</application> applications in the
  directory <filename>src/test/examples</filename> in the source code distribution.
 </para>
________________________________________________________-->
 <para>
  在本章的末尾（<xref linkend="libpq-example"/>）包括了一些短程序来展示如何编写使用<application>libpq</application>的应用。在源代码发布的<filename>src/test/examples</filename>目录中还有一些完整的<application>libpq</application>应用的例子。
 </para>
<!-- pgdoc-cn_end sig_en=c98d2bcdb740afb0ffb984bd9b7c0289 -->

<!-- pgdoc-cn_start sig_en=f7a9e5768c5e14a43342ab2572389738 sig_cn_org=None source=14.1 
 <para>
  Client programs that use <application>libpq</application> must
  include the header file
  <filename>libpq-fe.h</filename><indexterm><primary>libpq-fe.h</primary></indexterm>
  and must link with the <application>libpq</application> library.
 </para>
________________________________________________________-->
 <para>
  使用<application>libpq</application>的客户端程序必须包括头文件<filename>libpq-fe.h</filename><indexterm><primary>libpq-fe.h</primary></indexterm>并必须与<application>libpq</application>库链接在一起。
 </para>
<!-- pgdoc-cn_end sig_en=f7a9e5768c5e14a43342ab2572389738 -->

 <sect1 id="libpq-connect">
<!-- pgdoc-cn_start sig_en=7d08b4b4bdeb9adf0ba734cca071365a sig_cn_org=None source=14.1 
  <title>Database Connection Control Functions</title>
________________________________________________________-->
  <title>数据库连接控制函数</title>
<!-- pgdoc-cn_end sig_en=7d08b4b4bdeb9adf0ba734cca071365a -->

<!-- pgdoc-cn_start sig_en=008f00da48f44405428bcd4699bccd71 sig_cn_org=None source=14.1 
  <para>
   The following functions deal with making a connection to a
   <productname>PostgreSQL</productname> backend server.  An
   application program can have several backend connections open at
   one time.  (One reason to do that is to access more than one
   database.)  Each connection is represented by a
   <structname>PGconn</structname><indexterm><primary>PGconn</primary></indexterm> object, which
   is obtained from the function <xref linkend="libpq-PQconnectdb"/>,
   <xref linkend="libpq-PQconnectdbParams"/>, or
   <xref linkend="libpq-PQsetdbLogin"/>.  Note that these functions will always
   return a non-null object pointer, unless perhaps there is too
   little memory even to allocate the <structname>PGconn</structname> object.
   The <xref linkend="libpq-PQstatus"/> function should be called to check
   the return value for a successful connection before queries are sent
   via the connection object.

   <warning>
    <para>
     If untrusted users have access to a database that has not adopted a
     <link linkend="ddl-schemas-patterns">secure schema usage pattern</link>,
     begin each session by removing publicly-writable schemas from
     <varname>search_path</varname>.  One can set parameter key
     word <literal>options</literal> to
     value <literal>-csearch_path=</literal>.  Alternately, one can
     issue <literal>PQexec(<replaceable>conn</replaceable>, "SELECT
     pg_catalog.set_config('search_path', '', false)")</literal> after
     connecting.  This consideration is not specific
     to <application>libpq</application>; it applies to every interface for
     executing arbitrary SQL commands.
    </para>
   </warning>

   <warning>
    <para>
     On Unix, forking a process with open libpq connections can lead to
     unpredictable results because the parent and child processes share
     the same sockets and operating system resources.  For this reason,
     such usage is not recommended, though doing an <function>exec</function> from
     the child process to load a new executable is safe.
    </para>
   </warning>

   <variablelist>
    <varlistentry id="libpq-PQconnectdbParams">
     <term><function>PQconnectdbParams</function><indexterm><primary>PQconnectdbParams</primary></indexterm></term>
     <listitem>
      <para>
       Makes a new connection to the database server.

<synopsis>
PGconn *PQconnectdbParams(const char * const *keywords,
                          const char * const *values,
                          int expand_dbname);
</synopsis>
      </para>

      <para>
       This function opens a new database connection using the parameters taken
       from two <symbol>NULL</symbol>-terminated arrays. The first,
       <literal>keywords</literal>, is defined as an array of strings, each one
       being a key word. The second, <literal>values</literal>, gives the value
       for each key word. Unlike <xref linkend="libpq-PQsetdbLogin"/> below, the parameter
       set can be extended without changing the function signature, so use of
       this function (or its nonblocking analogs <xref linkend="libpq-PQconnectStartParams"/>
       and <function>PQconnectPoll</function>) is preferred for new application
       programming.
      </para>

      <para>
       The currently recognized parameter key words are listed in
       <xref linkend="libpq-paramkeywords"/>.
      </para>

      <para>
       The passed arrays can be empty to use all default parameters, or can
       contain one or more parameter settings. They must be matched in length.
       Processing will stop at the first <symbol>NULL</symbol> entry
       in the <literal>keywords</literal> array.
       Also, if the <literal>values</literal> entry associated with a
       non-<symbol>NULL</symbol> <literal>keywords</literal> entry is
       <symbol>NULL</symbol> or an empty string, that entry is ignored and
       processing continues with the next pair of array entries.
      </para>

      <para>
       When <literal>expand_dbname</literal> is non-zero, the value for
       the first <parameter>dbname</parameter> key word is checked to see
       if it is a <firstterm>connection string</firstterm>.  If so, it
       is <quote>expanded</quote> into the individual connection
       parameters extracted from the string.  The value is considered to
       be a connection string, rather than just a database name, if it
       contains an equal sign (<literal>=</literal>) or it begins with a
       URI scheme designator.  (More details on connection string formats
       appear in <xref linkend="libpq-connstring"/>.)  Only the first
       occurrence of <parameter>dbname</parameter> is treated in this way;
       any subsequent <parameter>dbname</parameter> parameter is processed
       as a plain database name.
      </para>

      <para>
       In general the parameter arrays are processed from start to end.
       If any key word is repeated, the last value (that is
       not <symbol>NULL</symbol> or empty) is used.  This rule applies in
       particular when a key word found in a connection string conflicts
       with one appearing in the <literal>keywords</literal> array.  Thus,
       the programmer may determine whether array entries can override or
       be overridden by values taken from a connection string.  Array
       entries appearing before an expanded <parameter>dbname</parameter>
       entry can be overridden by fields of the connection string, and in
       turn those fields are overridden by array entries appearing
       after <parameter>dbname</parameter> (but, again, only if those
       entries supply non-empty values).
      </para>

      <para>
       After processing all the array entries and any expanded connection
       string, any connection parameters that remain unset are filled with
       default values.  If an unset parameter's corresponding environment
       variable (see <xref linkend="libpq-envars"/>) is set, its value is
       used.  If the environment variable is not set either, then the
       parameter's built-in default value is used.
      </para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQconnectdb">
     <term><function>PQconnectdb</function><indexterm><primary>PQconnectdb</primary></indexterm></term>
     <listitem>
      <para>
       Makes a new connection to the database server.

<synopsis>
PGconn *PQconnectdb(const char *conninfo);
</synopsis>
      </para>

      <para>
       This function opens a new database connection using the parameters taken
       from the string <literal>conninfo</literal>.
      </para>

      <para>
       The passed string can be empty to use all default parameters, or it can
       contain one or more parameter settings separated by whitespace,
       or it can contain a <acronym>URI</acronym>.
       See <xref linkend="libpq-connstring"/> for details.
     </para>


    </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQsetdbLogin">
     <term><function>PQsetdbLogin</function><indexterm><primary>PQsetdbLogin</primary></indexterm></term>
     <listitem>
      <para>
       Makes a new connection to the database server.
<synopsis>
PGconn *PQsetdbLogin(const char *pghost,
                     const char *pgport,
                     const char *pgoptions,
                     const char *pgtty,
                     const char *dbName,
                     const char *login,
                     const char *pwd);
</synopsis>
       </para>

       <para>
        This is the predecessor of <xref linkend="libpq-PQconnectdb"/> with a fixed
        set of parameters.  It has the same functionality except that the
        missing parameters will always take on default values.  Write <symbol>NULL</symbol> or an
        empty string for any one of the fixed parameters that is to be defaulted.
      </para>

      <para>
        If the <parameter>dbName</parameter> contains
        an <symbol>=</symbol> sign or has a valid connection <acronym>URI</acronym> prefix, it
        is taken as a <parameter>conninfo</parameter> string in exactly the same way as
        if it had been passed to <xref linkend="libpq-PQconnectdb"/>, and the remaining
        parameters are then applied as specified for <xref linkend="libpq-PQconnectdbParams"/>.
      </para>

      <para>
        <literal>pgtty</literal> is no longer used and any value passed will
        be ignored.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQsetdb">
     <term><function>PQsetdb</function><indexterm><primary>PQsetdb</primary></indexterm></term>
     <listitem>
      <para>
   Makes a new connection to the database server.
<synopsis>
PGconn *PQsetdb(char *pghost,
                char *pgport,
                char *pgoptions,
                char *pgtty,
                char *dbName);
</synopsis>
     </para>

     <para>
      This is a macro that calls <xref linkend="libpq-PQsetdbLogin"/> with null pointers
      for the <parameter>login</parameter> and <parameter>pwd</parameter> parameters.  It is provided
      for backward compatibility with very old programs.
     </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQconnectStartParams">
     <term><function>PQconnectStartParams</function><indexterm><primary>PQconnectStartParams</primary></indexterm></term>
     <term><function>PQconnectStart</function><indexterm><primary>PQconnectStart</primary></indexterm></term>
     <term><function>PQconnectPoll</function><indexterm><primary>PQconnectPoll</primary></indexterm></term>
     <listitem>
      <para>
       <indexterm><primary>nonblocking connection</primary></indexterm>
       Make a connection to the database server in a nonblocking manner.

<synopsis>
PGconn *PQconnectStartParams(const char * const *keywords,
                             const char * const *values,
                             int expand_dbname);

PGconn *PQconnectStart(const char *conninfo);

PostgresPollingStatusType PQconnectPoll(PGconn *conn);
</synopsis>
      </para>

      <para>
       These three functions are used to open a connection to a database server such
       that your application's thread of execution is not blocked on remote I/O
       whilst doing so. The point of this approach is that the waits for I/O to
       complete can occur in the application's main loop, rather than down inside
       <xref linkend="libpq-PQconnectdbParams"/> or <xref linkend="libpq-PQconnectdb"/>, and so the
       application can manage this operation in parallel with other activities.
      </para>

      <para>
       With <xref linkend="libpq-PQconnectStartParams"/>, the database connection is made
       using the parameters taken from the <literal>keywords</literal> and
       <literal>values</literal> arrays, and controlled by <literal>expand_dbname</literal>,
       as described above for <xref linkend="libpq-PQconnectdbParams"/>.
      </para>

      <para>
       With <function>PQconnectStart</function>, the database connection is made
       using the parameters taken from the string <literal>conninfo</literal> as
       described above for <xref linkend="libpq-PQconnectdb"/>.
      </para>

      <para>
       Neither <xref linkend="libpq-PQconnectStartParams"/> nor <function>PQconnectStart</function>
       nor <function>PQconnectPoll</function> will block, so long as a number of
       restrictions are met:
       <itemizedlist>
        <listitem>
         <para>
          The <literal>hostaddr</literal> parameter must be used appropriately
          to prevent DNS queries from being made.  See the documentation of
          this parameter in <xref linkend="libpq-paramkeywords"/> for details.
         </para>
        </listitem>

        <listitem>
         <para>
          If you call <xref linkend="libpq-PQtrace"/>, ensure that the stream object
          into which you trace will not block.
         </para>
        </listitem>

        <listitem>
         <para>
          You must ensure that the socket is in the appropriate state
          before calling <function>PQconnectPoll</function>, as described below.
         </para>
        </listitem>
       </itemizedlist>
      </para>

      <para>
       To begin a nonblocking connection request,
       call <function>PQconnectStart</function>
       or <xref linkend="libpq-PQconnectStartParams"/>.  If the result is null,
       then <application>libpq</application> has been unable to allocate a
       new <structname>PGconn</structname> structure.  Otherwise, a
       valid <structname>PGconn</structname> pointer is returned (though not
       yet representing a valid connection to the database).  Next
       call <literal>PQstatus(conn)</literal>.  If the result
       is <symbol>CONNECTION_BAD</symbol>, the connection attempt has already
       failed, typically because of invalid connection parameters.
      </para>

      <para>
       If <function>PQconnectStart</function>
       or <xref linkend="libpq-PQconnectStartParams"/> succeeds, the next stage
       is to poll <application>libpq</application> so that it can proceed with
       the connection sequence.
       Use <function>PQsocket(conn)</function> to obtain the descriptor of the
       socket underlying the database connection.
       (Caution: do not assume that the socket remains the same
       across <function>PQconnectPoll</function> calls.)
       Loop thus: If <function>PQconnectPoll(conn)</function> last returned
       <symbol>PGRES_POLLING_READING</symbol>, wait until the socket is ready to
       read (as indicated by <function>select()</function>, <function>poll()</function>, or
       similar system function).
       Then call <function>PQconnectPoll(conn)</function> again.
       Conversely, if <function>PQconnectPoll(conn)</function> last returned
       <symbol>PGRES_POLLING_WRITING</symbol>, wait until the socket is ready
       to write, then call <function>PQconnectPoll(conn)</function> again.
       On the first iteration, i.e., if you have yet to call
       <function>PQconnectPoll</function>, behave as if it last returned
       <symbol>PGRES_POLLING_WRITING</symbol>.  Continue this loop until
       <function>PQconnectPoll(conn)</function> returns
       <symbol>PGRES_POLLING_FAILED</symbol>, indicating the connection procedure
       has failed, or <symbol>PGRES_POLLING_OK</symbol>, indicating the connection
       has been successfully made.
      </para>

      <para>
       At any time during connection, the status of the connection can be
       checked by calling <xref linkend="libpq-PQstatus"/>. If this call returns <symbol>CONNECTION_BAD</symbol>, then the
       connection procedure has failed; if the call returns <function>CONNECTION_OK</function>, then the
       connection is ready.  Both of these states are equally detectable
       from the return value of <function>PQconnectPoll</function>, described above. Other states might also occur
       during (and only during) an asynchronous connection procedure. These
       indicate the current stage of the connection procedure and might be useful
       to provide feedback to the user for example. These statuses are:

       <variablelist>
        <varlistentry id="libpq-connection-started">
         <term><symbol>CONNECTION_STARTED</symbol></term>
         <listitem>
          <para>
           Waiting for connection to be made.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-made">
         <term><symbol>CONNECTION_MADE</symbol></term>
         <listitem>
          <para>
           Connection OK; waiting to send.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-awaiting-response">
         <term><symbol>CONNECTION_AWAITING_RESPONSE</symbol></term>
         <listitem>
          <para>
           Waiting for a response from the server.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-auth-ok">
         <term><symbol>CONNECTION_AUTH_OK</symbol></term>
         <listitem>
          <para>
           Received authentication; waiting for backend start-up to finish.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-ssl-startup">
         <term><symbol>CONNECTION_SSL_STARTUP</symbol></term>
         <listitem>
          <para>
           Negotiating SSL encryption.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-setenv">
         <term><symbol>CONNECTION_SETENV</symbol></term>
         <listitem>
          <para>
           Negotiating environment-driven parameter settings.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-check-writable">
         <term><symbol>CONNECTION_CHECK_WRITABLE</symbol></term>
         <listitem>
          <para>
           Checking if connection is able to handle write transactions.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-consume">
         <term><symbol>CONNECTION_CONSUME</symbol></term>
         <listitem>
          <para>
           Consuming any remaining response messages on connection.
          </para>
         </listitem>
        </varlistentry>
       </variablelist>

       Note that, although these constants will remain (in order to maintain
       compatibility), an application should never rely upon these occurring in a
       particular order, or at all, or on the status always being one of these
       documented values. An application might do something like this:
<programlisting>
switch(PQstatus(conn))
{
        case CONNECTION_STARTED:
            feedback = "Connecting...";
            break;

        case CONNECTION_MADE:
            feedback = "Connected to server...";
            break;
.
.
.
        default:
            feedback = "Connecting...";
}
</programlisting>
      </para>

      <para>
       The <literal>connect_timeout</literal> connection parameter is ignored
       when using <function>PQconnectPoll</function>; it is the application's
       responsibility to decide whether an excessive amount of time has elapsed.
       Otherwise, <function>PQconnectStart</function> followed by a
       <function>PQconnectPoll</function> loop is equivalent to
       <xref linkend="libpq-PQconnectdb"/>.
      </para>

      <para>
       Note that when <function>PQconnectStart</function>
       or <xref linkend="libpq-PQconnectStartParams"/> returns a non-null
       pointer, you must call <xref linkend="libpq-PQfinish"/> when you are
       finished with it, in order to dispose of the structure and any
       associated memory blocks.  This must be done even if the connection
       attempt fails or is abandoned.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQconndefaults">
     <term><function>PQconndefaults</function><indexterm><primary>PQconndefaults</primary></indexterm></term>
     <listitem>
      <para>
       Returns the default connection options.
<synopsis>
PQconninfoOption *PQconndefaults(void);

typedef struct
{
    char   *keyword;   /* The keyword of the option */
    char   *envvar;    /* Fallback environment variable name */
    char   *compiled;  /* Fallback compiled in default value */
    char   *val;       /* Option's current value, or NULL */
    char   *label;     /* Label for field in connect dialog */
    char   *dispchar;  /* Indicates how to display this field
                          in a connect dialog. Values are:
                          ""        Display entered value as is
                          "*"       Password field - hide value
                          "D"       Debug option - don't show by default */
    int     dispsize;  /* Field size in characters for dialog */
} PQconninfoOption;
</synopsis>
      </para>

      <para>
       Returns a connection options array.  This can be used to determine
       all possible <xref linkend="libpq-PQconnectdb"/> options and their
       current default values.  The return value points to an array of
       <structname>PQconninfoOption</structname> structures, which ends
       with an entry having a null <structfield>keyword</structfield> pointer.  The
       null pointer is returned if memory could not be allocated. Note that
       the current default values (<structfield>val</structfield> fields)
       will depend on environment variables and other context.  A
       missing or invalid service file will be silently ignored.  Callers
       must treat the connection options data as read-only.
      </para>

      <para>
       After processing the options array, free it by passing it to
       <xref linkend="libpq-PQconninfoFree"/>.  If this is not done, a small amount of memory
       is leaked for each call to <xref linkend="libpq-PQconndefaults"/>.
      </para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQconninfo">
     <term><function>PQconninfo</function><indexterm><primary>PQconninfo</primary></indexterm></term>
     <listitem>
      <para>
       Returns the connection options used by a live connection.
<synopsis>
PQconninfoOption *PQconninfo(PGconn *conn);
</synopsis>
      </para>

      <para>
       Returns a connection options array.  This can be used to determine
       all possible <xref linkend="libpq-PQconnectdb"/> options and the
       values that were used to connect to the server. The return
       value points to an array of <structname>PQconninfoOption</structname>
       structures, which ends with an entry having a null <structfield>keyword</structfield>
       pointer. All notes above for <xref linkend="libpq-PQconndefaults"/> also
       apply to the result of <xref linkend="libpq-PQconninfo"/>.
      </para>

     </listitem>
    </varlistentry>


    <varlistentry id="libpq-PQconninfoParse">
     <term><function>PQconninfoParse</function><indexterm><primary>PQconninfoParse</primary></indexterm></term>
     <listitem>
      <para>
       Returns parsed connection options from the provided connection string.

<synopsis>
PQconninfoOption *PQconninfoParse(const char *conninfo, char **errmsg);
</synopsis>
      </para>

      <para>
       Parses a connection string and returns the resulting options as an
       array; or returns <symbol>NULL</symbol> if there is a problem with the connection
       string.  This function can be used to extract
       the <xref linkend="libpq-PQconnectdb"/> options in the provided
       connection string.  The return value points to an array of
       <structname>PQconninfoOption</structname> structures, which ends
       with an entry having a null <structfield>keyword</structfield> pointer.
      </para>

      <para>
       All legal options will be present in the result array, but the
       <literal>PQconninfoOption</literal> for any option not present
       in the connection string will have <literal>val</literal> set to
       <literal>NULL</literal>; default values are not inserted.
      </para>

      <para>
       If <literal>errmsg</literal> is not <symbol>NULL</symbol>, then <literal>*errmsg</literal> is set
       to <symbol>NULL</symbol> on success, else to a <function>malloc</function>'d error string explaining
       the problem.  (It is also possible for <literal>*errmsg</literal> to be
       set to <symbol>NULL</symbol> and the function to return <symbol>NULL</symbol>;
       this indicates an out-of-memory condition.)
      </para>

      <para>
       After processing the options array, free it by passing it to
       <xref linkend="libpq-PQconninfoFree"/>.  If this is not done, some memory
       is leaked for each call to <xref linkend="libpq-PQconninfoParse"/>.
       Conversely, if an error occurs and <literal>errmsg</literal> is not <symbol>NULL</symbol>,
       be sure to free the error string using <xref linkend="libpq-PQfreemem"/>.
      </para>

   </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQfinish">
     <term><function>PQfinish</function><indexterm><primary>PQfinish</primary></indexterm></term>
     <listitem>
      <para>
       Closes  the  connection to the server.  Also frees
       memory used by the <structname>PGconn</structname> object.
<synopsis>
void PQfinish(PGconn *conn);
</synopsis>
      </para>

      <para>
       Note that even if the server connection attempt fails (as
       indicated by <xref linkend="libpq-PQstatus"/>), the application should call <xref linkend="libpq-PQfinish"/>
       to free the memory used by the <structname>PGconn</structname> object.
       The <structname>PGconn</structname> pointer must not be used again after
       <xref linkend="libpq-PQfinish"/> has been called.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQreset">
     <term><function>PQreset</function><indexterm><primary>PQreset</primary></indexterm></term>
     <listitem>
      <para>
       Resets the communication channel to the server.
<synopsis>
void PQreset(PGconn *conn);
</synopsis>
      </para>

      <para>
       This function will close the connection
       to the server and attempt to establish a new
       connection, using all the same
       parameters previously used.  This might be useful for
       error recovery if a working connection is lost.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQresetStart">
     <term><function>PQresetStart</function><indexterm><primary>PQresetStart</primary></indexterm></term>
     <term><function>PQresetPoll</function><indexterm><primary>PQresetPoll</primary></indexterm></term>
     <listitem>
      <para>
       Reset the communication channel to the server, in a nonblocking manner.

<synopsis>
int PQresetStart(PGconn *conn);

PostgresPollingStatusType PQresetPoll(PGconn *conn);
</synopsis>
      </para>

      <para>
       These functions will close the connection to the server and attempt to
       establish a new connection, using all the same
       parameters previously used. This can be useful for error recovery if a
       working connection is lost. They differ from <xref linkend="libpq-PQreset"/> (above) in that they
       act in a nonblocking manner. These functions suffer from the same
       restrictions as <xref linkend="libpq-PQconnectStartParams"/>, <function>PQconnectStart</function>
       and <function>PQconnectPoll</function>.
      </para>

      <para>
       To initiate a connection reset, call
       <xref linkend="libpq-PQresetStart"/>. If it returns 0, the reset has
       failed. If it returns 1, poll the reset using
       <function>PQresetPoll</function> in exactly the same way as you
       would create the connection using <function>PQconnectPoll</function>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQpingParams">
     <term><function>PQpingParams</function><indexterm><primary>PQpingParams</primary></indexterm></term>
     <listitem>
      <para>
       <xref linkend="libpq-PQpingParams"/> reports the status of the
       server.  It accepts connection parameters identical to those of
       <xref linkend="libpq-PQconnectdbParams"/>, described above.  It is not
       necessary to supply correct user name, password, or database name
       values to obtain the server status; however, if incorrect values
       are provided, the server will log a failed connection attempt.

<synopsis>
PGPing PQpingParams(const char * const *keywords,
                    const char * const *values,
                    int expand_dbname);
</synopsis>

       The function returns one of the following values:

       <variablelist>
        <varlistentry id="libpq-PQpingParams-PQPING_OK">
         <term><literal>PQPING_OK</literal></term>
         <listitem>
          <para>
           The server is running and appears to be accepting connections.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-PQpingParams-PQPING_REJECT">
         <term><literal>PQPING_REJECT</literal></term>
         <listitem>
          <para>
           The server is running but is in a state that disallows connections
           (startup, shutdown, or crash recovery).
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-PQpingParams-PQPING_NO_RESPONSE">
         <term><literal>PQPING_NO_RESPONSE</literal></term>
         <listitem>
          <para>
           The server could not be contacted.  This might indicate that the
           server is not running, or that there is something wrong with the
           given connection parameters (for example, wrong port number), or
           that there is a network connectivity problem (for example, a
           firewall blocking the connection request).
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-PQpingParams-PQPING_NO_ATTEMPT">
         <term><literal>PQPING_NO_ATTEMPT</literal></term>
         <listitem>
          <para>
           No attempt was made to contact the server, because the supplied
           parameters were obviously incorrect or there was some client-side
           problem (for example, out of memory).
          </para>
         </listitem>
        </varlistentry>
       </variablelist>

      </para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQping">
     <term><function>PQping</function><indexterm><primary>PQping</primary></indexterm></term>
     <listitem>
      <para>
       <xref linkend="libpq-PQping"/> reports the status of the
       server.  It accepts connection parameters identical to those of
       <xref linkend="libpq-PQconnectdb"/>, described above.  It is not
       necessary to supply correct user name, password, or database name
       values to obtain the server status; however, if incorrect values
       are provided, the server will log a failed connection attempt.

<synopsis>
PGPing PQping(const char *conninfo);
</synopsis>
      </para>

      <para>
       The return values are the same as for <xref linkend="libpq-PQpingParams"/>.
      </para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsetsslkeypasshook-openssl">
     <term><function>PQsetSSLKeyPassHook_OpenSSL</function><indexterm><primary>PQsetSSLKeyPassHook_OpenSSL</primary></indexterm></term>
     <listitem>
      <para>
       <function>PQsetSSLKeyPassHook_OpenSSL</function> lets an application override
       <application>libpq</application>'s <link linkend="libpq-ssl-clientcert">default
       handling of encrypted client certificate key files</link> using
       <xref linkend="libpq-connect-sslpassword"/> or interactive prompting.

<synopsis>
void PQsetSSLKeyPassHook_OpenSSL(PQsslKeyPassHook_OpenSSL_type hook);
</synopsis>

       The application passes a pointer to a callback function with signature:
<programlisting>
int callback_fn(char *buf, int size, PGconn *conn);
</programlisting>
       which <application>libpq</application> will then call
       <emphasis>instead of</emphasis> its default
       <function>PQdefaultSSLKeyPassHook_OpenSSL</function> handler. The
       callback should determine the password for the key and copy it to
       result-buffer <parameter>buf</parameter> of size
       <parameter>size</parameter>. The string in <parameter>buf</parameter>
       must be null-terminated. The callback must return the length of the
       password stored in <parameter>buf</parameter> excluding the null
       terminator. On failure, the callback should set
       <literal>buf[0] = '\0'</literal> and return 0. See
       <function>PQdefaultSSLKeyPassHook_OpenSSL</function> in
       <application>libpq</application>'s source code for an example.
      </para>

      <para>
       If the user specified an explicit key location,
       its path will be in <literal>conn->sslkey</literal> when the callback
       is invoked. This will be empty if the default key path is being used.
       For keys that are engine specifiers, it is up to engine implementations
       whether they use the <productname>OpenSSL</productname> password
       callback or define their own handling.
      </para>

      <para>
       The app callback may choose to delegate unhandled cases to
       <function>PQdefaultSSLKeyPassHook_OpenSSL</function>,
       or call it first and try something else if it returns 0, or completely override it.
      </para>

      <para>
       The callback <emphasis>must not</emphasis> escape normal flow control with exceptions,
       <function>longjmp(...)</function>, etc. It must return normally.
      </para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqgetsslkeypasshook-openssl">
     <term><function>PQgetSSLKeyPassHook_OpenSSL</function><indexterm><primary>PQgetSSLKeyPassHook_OpenSSL</primary></indexterm></term>
     <listitem>
      <para>
       <function>PQgetSSLKeyPassHook_OpenSSL</function> returns the current
       client certificate key password hook, or <literal>NULL</literal>
       if none has been set.

<synopsis>
PQsslKeyPassHook_OpenSSL_type PQgetSSLKeyPassHook_OpenSSL(void);
</synopsis>
      </para>

     </listitem>
    </varlistentry>

   </variablelist>
  </para>
________________________________________________________-->
  <para>
   下列函数会建立到一个<productname>PostgreSQL</productname>后端服务器的连接。
   一个应用程序可以在一个时刻打开多个后端连接（原因之一就是为了访问多个数据库）。
   每个连接用一个<structname>PGconn</structname><indexterm><primary>PGconn</primary></indexterm>对象表示，它从函数<xref linkend="libpq-PQconnectdb"/>、<xref linkend="libpq-PQconnectdbParams"/>，或<xref linkend="libpq-PQsetdbLogin"/>得到。
   注意这些函数将总是返回一个非空的对象指针，除非正好没有内存来分配<structname>PGconn</structname>对象。
   在通过该连接对象发送查询之前，应该调用<xref linkend="libpq-PQstatus"/>函数来检查返回值以确定是否得到了一个成功的连接。

   <warning>
    <para>
     如果不可信用户能够访问一个没有采用<link linkend="ddl-schemas-patterns">安全方案使用模式</link>的数据库，开始每个会话时应该从<varname>search_path</varname>中移除公共可写的方案。我们可以把参数关键词<literal>options</literal>设置为<literal>-csearch_path=</literal>。也可以在连接后发出<literal>PQexec(<replaceable>conn</replaceable>, "SELECT pg_catalog.set_config('search_path', '', false)")</literal>。这种考虑并非专门针对<application>libpq</application>，它适用于每一种用来执行任意SQL命令的接口。
    </para>
   </warning>

   <warning>
    <para>
     在 Unix 上，复制一个拥有打开 libpq 连接的进程可能导致不可以预料的结果，因为父进程和子进程会共享相同的套接字和操作系统资源。出于这个原因，我们不推荐这样的用法，尽管从子进程执行一个<function>exec</function>来载入新的可执行代码是安全的。
    </para>
   </warning>

   <variablelist>
    <varlistentry id="libpq-PQconnectdbParams">
     <term><function>PQconnectdbParams</function><indexterm><primary>PQconnectdbParams</primary></indexterm></term>
     <listitem>
      <para>
       开启一个到数据库服务器的新连接。

<synopsis>
PGconn *PQconnectdbParams(const char * const *keywords,
                          const char * const *values,
                          int expand_dbname);
</synopsis>
      </para>

      <para>
       这个函数使用从两个以<symbol>NULL</symbol>结尾的数组中取得的参数打开一个新的数据库连接。第一个数组<literal>keywords</literal>被定义为一个字符串数组，每一个元素是一个关键词。第二个数组<literal>values</literal>给出了每个关键词的值。和下面的<xref linkend="libpq-PQsetdbLogin"/>不同，可以在不改变函数签名的情况下扩展参数集合，因此使用这个函数（或者与之相似的非阻塞的<xref linkend="libpq-PQconnectStartParams"/>和<function>PQconnectPoll</function>）对于新应用编程要更好。 
      </para>

      <para>
       当前能被识别的参数关键词被列举在<xref linkend="libpq-paramkeywords"/>中。
      </para>

      <para>
       被传递的数组可以为空，这样就会使用所有默认参数。
       也可以只包含一个或几个参数设置。他们在长度上必须匹配。
       对于参数数组的处理将会停止于<literal>keywords</literal>数组中第一个<symbol>NULL</symbol>元素。
       而且，如果与非-<symbol>NULL</symbol> <literal>keywords</literal>条目相关联的<literal>values</literal>条目为<symbol>NULL</symbol>或者空字符串，则忽略该项并继续处理下一对数组项。
      </para>

      <para>
       当<literal>expand_dbname</literal>为非零时，会检查第一个<parameter>dbname</parameter>关键词的值以查看它是否为一个<firstterm>connection string</firstterm>。
       如果是，它被<quote>扩展</quote>到从字符串中提取的单独的连接参数。
       该值被认为是一个连接字符串，而不仅是一个数据库名称，如果它包含一个等号(<literal>=</literal>)或者它以URI模式标志符开头，
       (有关连接字符串格式的更多详情可见<xref linkend="libpq-connstring"/>。)
       只有<parameter>dbname</parameter>的第一次出现会按这种方式处理，任何后续<parameter>dbname</parameter>值会被当做一个普通数据库名处理。
      </para>

      <para>
       通常，参数数组从开头到结尾进行处理。
       当关键词有重复时，使用最后一个值(不是 <symbol>NULL</symbol> 或空)。
       此规则特别适用于连接字符串中的关键字与一个出现在<literal>keywords</literal>数组中的关键字冲突的情况。
       因此，程序员可以决定数组条目是否能被覆盖或用连接字符串获取的值覆盖。
       出现在扩展的<parameter>dbname</parameter>条目之前的数组条目可以被连接字符串的字段所覆盖，反之，这些字段被<parameter>dbname</parameter>之后出现的数组条目所覆盖。(但是，再有，只有在那些条目支持非空值时。)
      </para>

      <para>
       在处理完所有数组条目和任何扩展的连接字符串后，所有未设置的连接参数都将使用默认值填充。
       如果一个未设置参数的相关环境变量(参见 <xref linkend="libpq-envars"/>)被设置了，它的值会被使用。
       如果环境变量未被设置，则使用参数的内置默认值。
      </para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQconnectdb">
     <term><function>PQconnectdb</function><indexterm><primary>PQconnectdb</primary></indexterm></term>
     <listitem>
      <para>
       开启一个到数据库服务器的新连接。

<synopsis>
PGconn *PQconnectdb(const char *conninfo);
</synopsis>
      </para>

      <para>
       这个函数使用从字符串<literal>conninfo</literal>中得到的参数开启一个新的数据库连接。
      </para>

      <para>
       被传递的字符串可以为空，这样将会使用所有的默认参数。也可以包含由空格分隔的一个或多个参数设置，还可以包含一个<acronym>URI</acronym>。详见<xref linkend="libpq-connstring"/>。
     </para>


    </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQsetdbLogin">
     <term><function>PQsetdbLogin</function><indexterm><primary>PQsetdbLogin</primary></indexterm></term>
     <listitem>
      <para>
       开启一个到数据库服务器的新连接。
<synopsis>
PGconn *PQsetdbLogin(const char *pghost,
                     const char *pgport,
                     const char *pgoptions,
                     const char *pgtty,
                     const char *dbName,
                     const char *login,
                     const char *pwd);
</synopsis>
       </para>

       <para>
        这是<xref linkend="libpq-PQconnectdb"/>的带有固定参数集合的前辈。它具有相同的功能，不过其中缺失的参数将总是采用默认值。对任意一个固定参数写<symbol>NULL</symbol>或一个空字符串将会使它采用默认值。
      </para>

      <para>
        如果<parameter>dbName</parameter>包含一个<symbol>=</symbol>符号或者具有一个合法的连接<acronym>URI</acronym>前缀，它会被当作一个<parameter>conninfo</parameter>字符串，就好像它已经被传递给了<xref linkend="libpq-PQconnectdb"/>，并且剩余的参数则被应用为指定给<xref linkend="libpq-PQconnectdbParams"/>。
      </para>

      <para>
        <literal>pgtty</literal> 已经不再使用，任何传递的值将被忽略。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQsetdb">
     <term><function>PQsetdb</function><indexterm><primary>PQsetdb</primary></indexterm></term>
     <listitem>
      <para>
   开启一个到数据库服务器的新连接。
<synopsis>
PGconn *PQsetdb(char *pghost,
                char *pgport,
                char *pgoptions,
                char *pgtty,
                char *dbName);
</synopsis>
     </para>

     <para>
      这是一个调用<xref linkend="libpq-PQsetdbLogin"/>的宏，其中为<parameter>login</parameter>和<parameter>pwd</parameter>参数使用空指针。提供它是为了向后兼容非常老的程序。
     </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQconnectStartParams">
     <term><function>PQconnectStartParams</function><indexterm><primary>PQconnectStartParams</primary></indexterm></term>
     <term><function>PQconnectStart</function><indexterm><primary>PQconnectStart</primary></indexterm></term>
     <term><function>PQconnectPoll</function><indexterm><primary>PQconnectPoll</primary></indexterm></term>
     <listitem>
      <para>
       <indexterm><primary>nonblocking connection</primary></indexterm>
       以非阻塞的方式建立一个到数据库服务器的连接。

<synopsis>
PGconn *PQconnectStartParams(const char * const *keywords,
                             const char * const *values,
                             int expand_dbname);

PGconn *PQconnectStart(const char *conninfo);

PostgresPollingStatusType PQconnectPoll(PGconn *conn);
</synopsis>
      </para>

      <para>
       这三个函数被用来开启一个到数据库服务器的连接，这样你的应用的执行线程不会因为远程的I/O而被阻塞。这种方法的要点在于等待 I/O 完成可能在应用的主循环中发生，而不是在<xref linkend="libpq-PQconnectdbParams"/> 或 <xref linkend="libpq-PQconnectdb"/>中，并且因此应用能够把这种操作和其他动作并行处理。
      </para>

      <para>
       在<xref linkend="libpq-PQconnectStartParams"/>中，数据库连接使用从<literal>keywords</literal>和<literal>values</literal>数组中取得的参数创建，并且被<literal>expand_dbname</literal>控制，这和之前描述的<xref linkend="libpq-PQconnectdbParams"/>相同。
      </para>

      <para>
       在<function>PQconnectStart</function>中，数据库连接使用从字符串<literal>conninfo</literal>中取得的参数创建，这和之前描述的<xref linkend="libpq-PQconnectdb"/>相同。
      </para>

      <para>
       只要满足一些限制，<xref linkend="libpq-PQconnectStartParams"/>或<function>PQconnectStart</function>或<function>PQconnectPoll</function>都不会阻塞：
       <itemizedlist>
        <listitem>
         <para>
          <literal>hostaddr</literal>和<literal>host</literal>参数必须被合适地使用，以防止做DNS查询。详见<xref linkend="libpq-paramkeywords"/>中这些参数的文档。
         </para>
        </listitem>

        <listitem>
         <para>
          如果你调用<xref linkend="libpq-PQtrace"/>，确保你追踪的该流对象不会阻塞。
         </para>
        </listitem>

        <listitem>
         <para>
          如后文所述，你必须要确保在调用<function>PQconnectPoll</function>之前，套接字处于合适的状态。
         </para>
        </listitem>
       </itemizedlist>
      </para>

      <para>
       要开始无阻塞的连接请求，可调用<function>PQconnectStart</function>或者<xref linkend="libpq-PQconnectStartParams"/>。如果结果为空，则<application>libpq</application>无法分配一个新的<structname>PGconn</structname>结构。否则，一个有效的<structname>PGconn</structname>指针会被返回（不过还没有表示一个到数据库的有效连接）。接下来调用<literal>PQstatus(conn)</literal>。如果结果是<symbol>CONNECTION_BAD</symbol>，则连接尝试已经失败，通常是因为有无效的连接参数。
      </para>

      <para>
       如果<function>PQconnectStart</function>或<xref linkend="libpq-PQconnectStartParams"/>成功，下一个阶段是轮询<application>libpq</application>，这样它能够继续进行连接序列。使用<function>PQsocket(conn)</function>来获得该数据库连接底层的套接字描述符（警告：不要假定在<function>PQconnectPoll</function>调用之间套接字会保持相同）。这样循环：如果<function>PQconnectPoll(conn)</function>上一次返回<symbol>PGRES_POLLING_READING</symbol>，等到该套接字准备好读取（按照<function>select()</function>、<function>poll()</function>或类似的系统函数所指示的）。则再次调用<function>PQconnectPoll(conn)</function>。反之，如果<function>PQconnectPoll(conn)</function>上一次返回<symbol>PGRES_POLLING_WRITING</symbol>，等到该套接字准备好写入，则再次调用<function>PQconnectPoll(conn)</function>。在第一次迭代时，即如果你还没有调用<function>PQconnectPoll</function>，行为就像是它上次返回了<symbol>PGRES_POLLING_WRITING</symbol>。持续这个循环直到<function>PQconnectPoll(conn)</function>返回<symbol>PGRES_POLLING_FAILED</symbol>指示连接过程已经失败，或者返回<symbol>PGRES_POLLING_OK</symbol>指示连接已经被成功地建立。
      </para>

      <para>
       在连接期间的任意时刻，该连接的状态可以通过调用<xref linkend="libpq-PQstatus"/>来检查。如果这个调用返回<symbol>CONNECTION_BAD</symbol>，那么连接过程已经失败。如果该调用返回<symbol>CONNECTION_OK</symbol>，则该连接已经准备好。如前所述，这些状态同样都可以从<function>PQconnectPoll</function>的返回值检测。在一个异步连接过程中（也只有在这个过程中）也可能出现其他状态。这些状态指示该连接过程的当前阶段，并且可能有助于为用户提供反馈。这些状态是：

       <variablelist>
        <varlistentry id="libpq-connection-started">
         <term><symbol>CONNECTION_STARTED</symbol></term>
         <listitem>
          <para>
           等待连接被建立。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-made">
         <term><symbol>CONNECTION_MADE</symbol></term>
         <listitem>
          <para>
           连接 OK，等待发送。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-awaiting-response">
         <term><symbol>CONNECTION_AWAITING_RESPONSE</symbol></term>
         <listitem>
          <para>
           等待来自服务器的一个回应。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-auth-ok">
         <term><symbol>CONNECTION_AUTH_OK</symbol></term>
         <listitem>
          <para>
           收到认证，等待后端启动结束。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-ssl-startup">
         <term><symbol>CONNECTION_SSL_STARTUP</symbol></term>
         <listitem>
          <para>
           协商 SSL 加密。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-setenv">
         <term><symbol>CONNECTION_SETENV</symbol></term>
         <listitem>
          <para>
           协商环境驱动的参数设置。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-check-writable">
         <term><symbol>CONNECTION_CHECK_WRITABLE</symbol></term>
         <listitem>
          <para>
           检查连接是否能够处理写事务。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-consume">
         <term><symbol>CONNECTION_CONSUME</symbol></term>
         <listitem>
          <para>
           消费连接上的任何剩下的响应消息。
          </para>
         </listitem>
        </varlistentry>
       </variablelist>

       注意，尽管这些常数将被保留（为了维护兼容性），一个应用永远不应该依赖这些状态按照特定顺序出现，或者根本就不依赖它们，或者不依赖状态总是这些文档中所说的值。一个应用可能做些这样的事情：
<programlisting>
switch(PQstatus(conn))
{
        case CONNECTION_STARTED:
            feedback = "Connecting...";
            break;

        case CONNECTION_MADE:
            feedback = "Connected to server...";
            break;
.
.
.
        default:
            feedback = "Connecting...";
}
</programlisting>
      </para>

      <para>
       在使用<function>PQconnectPoll</function>时，连接参数<literal>connect_timeout</literal>会被忽略：判断是否超时是应用的责任。否则，<function>PQconnectStart</function>后面跟着<function>PQconnectPoll</function>循环等效于<xref linkend="libpq-PQconnectdb"/>。
      </para>

      <para>
       注意当<function>PQconnectStart</function>或<xref linkend="libpq-PQconnectStartParams"/>返回一个非空的指针时，你必须在用完它之后调用<xref linkend="libpq-PQfinish"/>来处理那些结构和任何相关的内存块。即使连接尝试失败或被放弃时也必须完成这些工作。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQconndefaults">
     <term><function>PQconndefaults</function><indexterm><primary>PQconndefaults</primary></indexterm></term>
     <listitem>
      <para>
       返回默认连接选项。
<synopsis>
PQconninfoOption *PQconndefaults(void);

typedef struct
{
    char   *keyword;   /* 该选项的关键词 */
    char   *envvar;    /* 依赖的环境变量名 */
    char   *compiled;  /* 依赖的内建默认值 */
    char   *val;       /* 选项的当前值，或者 NULL */
    char   *label;     /* 连接对话框中域的标签 */
    char   *dispchar;  /* 指示如何在一个连接对话框中显示这个域。值是：
                          ""        显示输入的值
                          "*"       口令域 - 隐藏值
                          "D"       调试选项 - 默认不显示 */
    int     dispsize;  /* 用于对话框的以字符计的域尺寸 */
} PQconninfoOption;
</synopsis>
      </para>

      <para>
       返回一个连接选项数组。这可以用来确定用于连接服务器的所有可能的<xref linkend="libpq-PQconnectdb"/>选项和它们的当前缺省值。返回值指向一个<structname>PQconninfoOption</structname>结构的数组，该数组以一个包含空<structfield>keyword</structfield>指针的条目结束。如果无法分配内存，则返回该空指针。注意当前缺省值（<structfield>val</structfield>域）将依赖于环境变量和其他上下文。一个缺失或者无效的服务文件将会被无声地忽略掉。调用者必须把连接选项当作只读对待。
      </para>

      <para>
       在处理完选项数组后，把它交给<xref linkend="libpq-PQconninfoFree"/>释放。如果没有这么做， 每次调用<xref linkend="libpq-PQconndefaults"/>都会导致一小部分内存泄漏。
      </para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQconninfo">
     <term><function>PQconninfo</function><indexterm><primary>PQconninfo</primary></indexterm></term>
     <listitem>
      <para>
       返回被一个活动连接使用的连接选项。
<synopsis>
PQconninfoOption *PQconninfo(PGconn *conn);
</synopsis>
      </para>

      <para>
       返回一个连接选项数组。这可以用来确定用于连接服务器的所有可能的<xref linkend="libpq-PQconnectdb"/>选项和它们的当前缺省值。
       返回值指向一个<structname>PQconninfoOption</structname>结构的数组，该数组以一个包含空<structfield>keyword</structfield>指针的条目结束。
       上述所有对于<xref linkend="libpq-PQconndefaults"/>的注解也适用于<xref linkend="libpq-PQconninfo"/>的结果。
      </para>

     </listitem>
    </varlistentry>


    <varlistentry id="libpq-PQconninfoParse">
     <term><function>PQconninfoParse</function><indexterm><primary>PQconninfoParse</primary></indexterm></term>
     <listitem>
      <para>
       返回从提供的连接字符串中解析到的连接选项。

<synopsis>
PQconninfoOption *PQconninfoParse(const char *conninfo, char **errmsg);
</synopsis>
      </para>

      <para>
       解析一个连接字符串并且将结果选项作为一个数组返回，或者在连接字符串有问题时返回<symbol>NULL</symbol>。这个函数可以用来抽取所提供的连接字符串中的<xref linkend="libpq-PQconnectdb"/>选项。返回值指向一个<structname>PQconninfoOption</structname>结构的数组，该数组以一个包含空<structfield>keyword</structfield>指针的条目结束。
      </para>

      <para>
       所有合法选项将出现在结果数组中，但是任何在连接字符串中没有出现的选项的<literal>PQconninfoOption</literal>的<literal>val</literal>会被设置为<literal>NULL</literal>，默认值不会被插入。
      </para>

      <para>
       如果<literal>errmsg</literal>不是<symbol>NULL</symbol>，那么成功时<literal>*errmsg</literal>会被设置为<symbol>NULL</symbol>， 否则设置为被<function>malloc</function>过的错误字符串以说明该问题（也可以将<literal>*errmsg</literal>设置为<symbol>NULL</symbol>并且函数返回<symbol>NULL</symbol>，这表示一种内存耗尽的情况）。
      </para>

      <para>
       在处理完选项数组后，把它交给<xref linkend="libpq-PQconninfoFree"/>释放。如果没有这么做， 每次调用<xref linkend="libpq-PQconninfoParse"/>都会导致一小部分内存泄漏。反过来，如果发生一个错误并且<literal>errmsg</literal>不是<symbol>NULL</symbol>，确保使用<xref linkend="libpq-PQfreemem"/>释放错误字符串。
      </para>

   </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQfinish">
     <term><function>PQfinish</function><indexterm><primary>PQfinish</primary></indexterm></term>
     <listitem>
      <para>
       关闭与服务器的连接。同时释放<structname>PGconn</structname>对象使用的内存。
<synopsis>
void PQfinish(PGconn *conn);
</synopsis>
      </para>

      <para>
       注意，即使与服务器的连接尝试失败（由<xref linkend="libpq-PQstatus"/>指示），应用也应当调用<xref linkend="libpq-PQfinish"/>来释放<structname>PGconn</structname>对象使用的内存。不能在调用<xref linkend="libpq-PQfinish"/>之后再使用<structname>PGconn</structname>指针。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQreset">
     <term><function>PQreset</function><indexterm><primary>PQreset</primary></indexterm></term>
     <listitem>
      <para>
       重置与服务器的通讯通道。
<synopsis>
void PQreset(PGconn *conn);
</synopsis>
      </para>

      <para>
       此函数将关闭与服务器的连接，并尝试建立一个新连接，用之前使用过的所有参数。
       这可能有助于在工作连接丢失后的错误恢复。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQresetStart">
     <term><function>PQresetStart</function><indexterm><primary>PQresetStart</primary></indexterm></term>
     <term><function>PQresetPoll</function><indexterm><primary>PQresetPoll</primary></indexterm></term>
     <listitem>
      <para>
       以非阻塞方式重置与服务器的通讯通道。

<synopsis>
int PQresetStart(PGconn *conn);

PostgresPollingStatusType PQresetPoll(PGconn *conn);
</synopsis>
      </para>

      <para>
       这些函数将关闭与服务器的连接，并且使用所有之前使用过的参数尝试建立一个新连接。
       这可能有助于在工作连接丢失后的错误恢复。
       它们和上面的<xref linkend="libpq-PQreset"/>的不同在于它们工作在非阻塞方式。
       这些函数受到<xref linkend="libpq-PQconnectStartParams"/>、<function>PQconnectStart</function>和<function>PQconnectPoll</function>相同的限制。
      </para>

      <para>
       要发起一次连接重置，调用<xref linkend="libpq-PQresetStart"/>。如果它返回 0，那么重置失败。如果返回 1，用与使用<function>PQresetPoll</function>建立连接的相同方法使用<function>PQconnectPoll</function>重置连接。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQpingParams">
     <term><function>PQpingParams</function><indexterm><primary>PQpingParams</primary></indexterm></term>
     <listitem>
      <para>
       <xref linkend="libpq-PQpingParams"/>报告服务器的状态。它接受与<xref linkend="libpq-PQconnectdbParams"/>相同的连接参数，如上所述。获得服务器状态不需要提供正确的用户名、口令或数据库名。不过，如果提供了不正确的值，服务器将记录一次失败的连接尝试。

<synopsis>
PGPing PQpingParams(const char * const *keywords,
                    const char * const *values,
                    int expand_dbname);
</synopsis>

       该函数返回下列值之一：

       <variablelist>
        <varlistentry id="libpq-PQpingParams-PQPING_OK">
         <term><literal>PQPING_OK</literal></term>
         <listitem>
          <para>
           服务器正在运行，并且看起来可以接受连接。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-PQpingParams-PQPING_REJECT">
         <term><literal>PQPING_REJECT</literal></term>
         <listitem>
          <para>
           服务器正在运行，但是处于一种不允许连接的状态（启动、关闭或崩溃恢复）。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-PQpingParams-PQPING_NO_RESPONSE">
         <term><literal>PQPING_NO_RESPONSE</literal></term>
         <listitem>
          <para>
           无法联系到服务器。这可能表示服务器没有运行，或者给定的连接参数中有些错误（例如，错误的端口号），或者有一个网络连接问题（例如，一个防火墙阻断了连接请求）。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-PQpingParams-PQPING_NO_ATTEMPT">
         <term><literal>PQPING_NO_ATTEMPT</literal></term>
         <listitem>
          <para>
           没有尝试联系服务器，因为提供的参数显然不正确，或者有一些客户端问题（例如，内存用完）。
          </para>
         </listitem>
        </varlistentry>
       </variablelist>

      </para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQping">
     <term><function>PQping</function><indexterm><primary>PQping</primary></indexterm></term>
     <listitem>
      <para>
       <xref linkend="libpq-PQping"/>报告服务器的状态。它接受与<xref linkend="libpq-PQconnectdb"/>相同的连接参数。获得服务器状态不需要提供正确的用户名、口令或数据库名。不过，如果提供了不正确的值，服务器将记录一次失败的连接尝试。

<synopsis>
PGPing PQping(const char *conninfo);
</synopsis>
      </para>

      <para>
       返回值和<xref linkend="libpq-PQpingParams"/>相同。
      </para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsetsslkeypasshook-openssl">
     <term><function>PQsetSSLKeyPassHook_OpenSSL</function><indexterm><primary>PQsetSSLKeyPassHook_OpenSSL</primary></indexterm></term>
     <listitem>
      <para>
       <function>PQsetSSLKeyPassHook_OpenSSL</function> 令一个应用取代 <application>libpq</application>的 <link linkend="libpq-ssl-clientcert">default handling of encrypted client certificate key files</link> ，
       使用<xref linkend="libpq-connect-sslpassword"/> 或交互提示方式。

<synopsis>
void PQsetSSLKeyPassHook_OpenSSL(PQsslKeyPassHook_OpenSSL_type hook);
</synopsis>

       应用程序传递一个指针到带签名的回调函数：
<programlisting>
int callback_fn(char *buf, int size, PGconn *conn);
</programlisting>
       <application>libpq</application>将调用<emphasis>而不是（instead of）</emphasis>它的默认<function>PQdefaultSSLKeyPassHook_OpenSSL</function>处理程序。
       回调函数应该确定密钥的密码并将其复制到大小为<parameter>size</parameter>的结果缓冲区<parameter>buf</parameter>中。
       <parameter>buf</parameter>中的字符串必须以空终止符(null-terminated)。
       回调函数必须返回存储在<parameter>buf</parameter>中的密码的长度，不包括空终止符。
       如果失败，回调函数应该设置<literal>buf[0] = '\0'</literal>并返回0。
       参见<application>libpq</application>源代码中的<function>PQdefaultSSLKeyPassHook_OpenSSL</function>以获得示例。
      </para>

      <para>
       如果用户指定了一个显式的密钥位置，那么当调用回调时，它的路径将在<literal>conn->sslkey</literal>中。
       如果使用默认密钥路径，则这将为空。
       对于作为引擎说明符的密钥，由引擎实现决定它们是使用<productname>OpenSSL</productname>密码回调还是定义自己的处理方式。
      </para>

      <para>
       应用回调可能会选择将未处理的案例委派给<function>PQdefaultSSLKeyPassHook_OpenSSL</function>，或者先调用它，并且如果它返回0时再尝试其他方法，或者完全覆盖它。
      </para>

      <para>
       除了例外、<function>longjmp(...)</function>等，回调<emphasis>务必不可</emphasis>逃避正常的流控制。它必须正常返回。
      </para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqgetsslkeypasshook-openssl">
     <term><function>PQgetSSLKeyPassHook_OpenSSL</function><indexterm><primary>PQgetSSLKeyPassHook_OpenSSL</primary></indexterm></term>
     <listitem>
      <para>
       <function>PQgetSSLKeyPassHook_OpenSSL</function>返回当前客户端证书密钥密码钩子，如果没有设置则返回<literal>NULL</literal>。

<synopsis>
PQsslKeyPassHook_OpenSSL_type PQgetSSLKeyPassHook_OpenSSL(void);
</synopsis>
      </para>

     </listitem>
    </varlistentry>

   </variablelist>
  </para>
<!-- pgdoc-cn_end sig_en=008f00da48f44405428bcd4699bccd71 -->

  <sect2 id="libpq-connstring">
<!-- pgdoc-cn_start sig_en=8cb8defaec18a76a38f21fe467e4ce53 sig_cn_org=None source=14.1 
   <title>Connection Strings</title>
________________________________________________________-->
   <title>连接字符串</title>
<!-- pgdoc-cn_end sig_en=8cb8defaec18a76a38f21fe467e4ce53 -->

   <indexterm zone="libpq-connstring">
    <primary><literal>conninfo</literal></primary>
   </indexterm>

   <indexterm zone="libpq-connstring">
    <primary><literal>URI</literal></primary>
   </indexterm>

<!-- pgdoc-cn_start sig_en=8843a9d3b353f580d64dfda6b78b3b69 sig_cn_org=cc1fe5a351416a7e0fa4eb664b2eb8be source=15.7 
   <para>
    Several <application>libpq</application> functions parse a user-specified string to obtain
    connection parameters.  There are two accepted formats for these strings:
    plain keyword/value strings
    and URIs.  URIs generally follow
    <ulink url="https://datatracker.ietf.org/doc/html/rfc3986">RFC
    3986</ulink>, except that multi-host connection strings are allowed
    as further described below.
   </para>
________________________________________________________-->
   <para>
    几个<application>libpq</application>函数解析用户指定的字符串以获取连接参数。
    这些字符串有两种被接受的格式：普通的关键字/值字符串和URI。URI通常遵循
    <ulink url="https://datatracker.ietf.org/doc/html/rfc3986">RFC
    3986</ulink>，除了允许多主机连接字符串，如下面进一步描述的那样。
</para>
<!-- pgdoc-cn_end sig_en=8843a9d3b353f580d64dfda6b78b3b69 -->

   <sect3>
<!-- pgdoc-cn_start sig_en=e417c0ed35876ceb5e0204d51480ef1f sig_cn_org=None source=14.1 
    <title>Keyword/Value Connection Strings</title>
________________________________________________________-->
    <title>关键词/值连接字符串</title>
<!-- pgdoc-cn_end sig_en=e417c0ed35876ceb5e0204d51480ef1f -->

<!-- pgdoc-cn_start sig_en=d205bd711314d1f4ec8fb546eec72bf0 sig_cn_org=None source=14.1 
   <para>
    In the keyword/value format, each parameter setting is in the form
    <replaceable>keyword</replaceable> <literal>=</literal>
    <replaceable>value</replaceable>, with space(s) between settings.
    Spaces around a setting's equal sign are
    optional. To write an empty value, or a value containing spaces, surround it
    with single quotes, for example <literal>keyword = 'a value'</literal>.
    Single quotes and backslashes within
    a value must be escaped with a backslash, i.e., <literal>\'</literal> and
    <literal>\\</literal>.
   </para>
________________________________________________________-->
   <para>
    在关键词/值格式中，每一个参数设置的形式都是<replaceable>关键词</replaceable> <literal>=</literal> <replaceable>值</replaceable>，在设置之间有空白。
    设置的等号周围的空白是可选的。
    要写一个空值或一个包含空白的值，将它用单引号包围，例如<literal>关键词 = 'a value'</literal>。
    值里面的单引号和反斜线必须用一个反斜线转义，即<literal>\'</literal>和<literal>\\</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=d205bd711314d1f4ec8fb546eec72bf0 -->

<!-- pgdoc-cn_start sig_en=d653ea8bd82d503df589f1e7b36775ac sig_cn_org=None source=14.1 
   <para>
    Example:
<programlisting>
host=localhost port=5432 dbname=mydb connect_timeout=10
</programlisting>
   </para>
________________________________________________________-->
   <para>
    例子：
<programlisting>
host=localhost port=5432 dbname=mydb connect_timeout=10
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=d653ea8bd82d503df589f1e7b36775ac -->

<!-- pgdoc-cn_start sig_en=8bd2d4c2f1e1ce26aef5d8720c62e502 sig_cn_org=None source=14.1 
   <para>
    The recognized parameter key words are listed in <xref
    linkend="libpq-paramkeywords"/>.
   </para>
________________________________________________________-->
   <para>
    能被识别的参数关键词在<xref linkend="libpq-paramkeywords"/>中列出。
   </para>
<!-- pgdoc-cn_end sig_en=8bd2d4c2f1e1ce26aef5d8720c62e502 -->
   </sect3>

   <sect3>
<!-- pgdoc-cn_start sig_en=7d6a4b1bd32540283d9fcf7bc5124308 sig_cn_org=None source=14.1 
    <title>Connection URIs</title>
________________________________________________________-->
    <title>连接 URI</title>
<!-- pgdoc-cn_end sig_en=7d6a4b1bd32540283d9fcf7bc5124308 -->

<!-- pgdoc-cn_start sig_en=9d043e49ab1dc55bc0430af73a03ce78 sig_cn_org=None source=14.1 
   <para>
   The general form for a connection <acronym>URI</acronym> is:
<synopsis>
postgresql://<optional><replaceable>userspec</replaceable>@</optional><optional><replaceable>hostspec</replaceable></optional><optional>/<replaceable>dbname</replaceable></optional><optional>?<replaceable>paramspec</replaceable></optional>

<phrase>where <replaceable>userspec</replaceable> is:</phrase>

<replaceable>user</replaceable><optional>:<replaceable>password</replaceable></optional>

<phrase>and <replaceable>hostspec</replaceable> is:</phrase>

<optional><replaceable>host</replaceable></optional><optional>:<replaceable>port</replaceable></optional><optional>,...</optional>

<phrase>and <replaceable>paramspec</replaceable> is:</phrase>

<replaceable>name</replaceable>=<replaceable>value</replaceable><optional>&amp;...</optional>
</synopsis>
   </para>
________________________________________________________-->
   <para>
   一个连接<acronym>URI</acronym>的一般形式是：
<synopsis>
postgresql://<optional><replaceable>userspec</replaceable>@</optional><optional><replaceable>hostspec</replaceable></optional><optional>/<replaceable>dbname</replaceable></optional><optional>?<replaceable>paramspec</replaceable></optional>

<phrase>where <replaceable>userspec</replaceable> is:</phrase>

<replaceable>user</replaceable><optional>:<replaceable>password</replaceable></optional>

<phrase>and <replaceable>hostspec</replaceable> is:</phrase>

<optional><replaceable>host</replaceable></optional><optional>:<replaceable>port</replaceable></optional><optional>,...</optional>

<phrase>and <replaceable>paramspec</replaceable> is:</phrase>

<replaceable>name</replaceable>=<replaceable>value</replaceable><optional>&amp;...</optional>
</synopsis>
   </para>
<!-- pgdoc-cn_end sig_en=9d043e49ab1dc55bc0430af73a03ce78 -->

<!-- pgdoc-cn_start sig_en=7dc15dc088341c4c741b87b348870e90 sig_cn_org=None source=14.1 
   <para>
    The <acronym>URI</acronym> scheme designator can be either
    <literal>postgresql://</literal> or <literal>postgres://</literal>.  Each
    of the remaining <acronym>URI</acronym> parts is optional.  The
    following examples illustrate valid <acronym>URI</acronym> syntax:
<programlisting>
postgresql://
postgresql://localhost
postgresql://localhost:5433
postgresql://localhost/mydb
postgresql://user@localhost
postgresql://user:secret@localhost
postgresql://other@localhost/otherdb?connect_timeout=10&amp;application_name=myapp
postgresql://host1:123,host2:456/somedb?target_session_attrs=any&amp;application_name=myapp
</programlisting>
    Values that would normally appear in the hierarchical part of
    the <acronym>URI</acronym> can alternatively be given as named
    parameters.  For example:
<programlisting>
postgresql:///mydb?host=localhost&amp;port=5433
</programlisting>
    All named parameters must match key words listed in
    <xref linkend="libpq-paramkeywords"/>, except that for compatibility
    with JDBC connection <acronym>URI</acronym>s, instances
    of <literal>ssl=true</literal> are translated into
    <literal>sslmode=require</literal>.
   </para>
________________________________________________________-->
   <para>
    <acronym>URI</acronym>模式标志符可以是<literal>postgresql://</literal>或<literal>postgres://</literal>。
    每一个剩下的<acronym>URI</acronym>部分都是可选的。
    下列例子展示了合法的<acronym>URI</acronym>语法：
<programlisting>
postgresql://
postgresql://localhost
postgresql://localhost:5433
postgresql://localhost/mydb
postgresql://user@localhost
postgresql://user:secret@localhost
postgresql://other@localhost/otherdb?connect_timeout=10&amp;application_name=myapp
postgresql://host1:123,host2:456/somedb?target_session_attrs=any&amp;application_name=myapp
</programlisting>
    通常出现在<acronym>URI</acronym>的层次部分的值，也能够以命名参数的方式给出。例如：
<programlisting>
postgresql:///mydb?host=localhost&amp;port=5433
</programlisting>
    全部的命名参数必须匹配<xref linkend="libpq-paramkeywords"/>中列出的关键词，除了与JDBC连接<acronym>URI</acronym>兼容之外，<literal>ssl=true</literal>的实例转换到<literal>sslmode=require</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=7dc15dc088341c4c741b87b348870e90 -->

<!-- pgdoc-cn_start sig_en=f94281f8e2a10a359413fdf658b072c6 sig_cn_org=945be0e0210c7c4cab3f42c37330a59d source=15.7 
   <para>
    The connection <acronym>URI</acronym> needs to be encoded with <ulink
    url="https://datatracker.ietf.org/doc/html/rfc3986#section-2.1">percent-encoding</ulink>
    if it includes symbols with special meaning in any of its parts.  Here is
    an example where the equal sign (<literal>=</literal>) is replaced with
    <literal>%3D</literal> and the space character with
    <literal>%20</literal>:
<programlisting>
postgresql://user@localhost:5433/mydb?options=-c%20synchronous_commit%3Doff
</programlisting>
   </para>
________________________________________________________-->
   <para>
    连接<acronym>URI</acronym>需要使用<ulink
    url="https://datatracker.ietf.org/doc/html/rfc3986#section-2.1">百分号编码</ulink>
    对其进行编码，如果其中包含具有特殊含义的符号。这里是一个示例，其中等号(<literal>=</literal>)被替换为
    <literal>%3D</literal>，空格字符被替换为
    <literal>%20</literal>:
<programlisting>
postgresql://user@localhost:5433/mydb?options=-c%20synchronous_commit%3Doff
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=f94281f8e2a10a359413fdf658b072c6 -->

<!-- pgdoc-cn_start sig_en=f69d5e69b9f2a86ad3174e460703bf03 sig_cn_org=None source=14.1 
   <para>
    The host part may be either a host name or an IP address.  To specify an
    IPv6 address, enclose it in square brackets:
<synopsis>
postgresql://[2001:db8::1234]/database
</synopsis>
   </para>
________________________________________________________-->
   <para>
    主机部分可能是主机名或一个 IP 地址。要指定一个 IPv6 地址，将它封闭在方括号中：
<synopsis>
postgresql://[2001:db8::1234]/database
</synopsis>
   </para>
<!-- pgdoc-cn_end sig_en=f69d5e69b9f2a86ad3174e460703bf03 -->

<!-- pgdoc-cn_start sig_en=d31760327ecc9fc6ddd8db61ad515f18 sig_cn_org=None source=14.1 
   <para>
    The host part is interpreted as described for the parameter <xref
    linkend="libpq-connect-host"/>.  In particular, a Unix-domain socket
    connection is chosen if the host part is either empty or looks like an
    absolute path name,
    otherwise a TCP/IP connection is initiated.  Note, however, that the
    slash is a reserved character in the hierarchical part of the URI.  So, to
    specify a non-standard Unix-domain socket directory, either omit the host
    part of the URI and specify the host as a named parameter, or
    percent-encode the path in the host part of the URI:
<programlisting>
postgresql:///dbname?host=/var/lib/postgresql
postgresql://%2Fvar%2Flib%2Fpostgresql/dbname
</programlisting>
   </para>
________________________________________________________-->
   <para>
    主机组件会被按照参数<xref linkend="libpq-connect-host"/>对应的描述来解释。
    特别地，如果主机部分是空或看起来像一个绝对路径名称，将使用一个 Unix 域套接字连接，否则将启动一个 TCP/IP 连接。
    不过要注意，斜线是 URI 层次部分中的一个保留字符。
    因此，要指定一个非标准的 Unix 域套接字目录，要么忽略 URI 中的主机部分并且指定该主机为一个命名参数，要么在 URI 的主机部分用百分号编码路径：
<programlisting>
postgresql:///dbname?host=/var/lib/postgresql
postgresql://%2Fvar%2Flib%2Fpostgresql/dbname
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=d31760327ecc9fc6ddd8db61ad515f18 -->

<!-- pgdoc-cn_start sig_en=be89e86e355b483e40c43f6497f658c8 sig_cn_org=None source=14.1 
   <para>
    It is possible to specify multiple host components, each with an optional
    port component, in a single URI.  A URI of the form
    <literal>postgresql://host1:port1,host2:port2,host3:port3/</literal>
    is equivalent to a connection string of the form
    <literal>host=host1,host2,host3 port=port1,port2,port3</literal>.
    As further described below, each
    host will be tried in turn until a connection is successfully established.
   </para>
________________________________________________________-->
   <para>
    可以在一个URI中指定多个主机，每一个都有一个可选的端口。
    一个形式为<literal>postgresql://host1:port1,host2:port2,host3:port3/</literal>的URI等效于<literal>host=host1,host2,host3 port=port1,port2,port3</literal>形式的连接字符串。
    如下所述，每一个主机都将被尝试，直到成功地建立一个连接。
   </para>
<!-- pgdoc-cn_end sig_en=be89e86e355b483e40c43f6497f658c8 -->
   </sect3>

   <sect3 id="libpq-multiple-hosts">
<!-- pgdoc-cn_start sig_en=47b032af20e84fe19f4d9cb4668d04f2 sig_cn_org=None source=14.1 
     <title>Specifying Multiple Hosts</title>
________________________________________________________-->
     <title>指定多个主机</title>
<!-- pgdoc-cn_end sig_en=47b032af20e84fe19f4d9cb4668d04f2 -->

<!-- pgdoc-cn_start sig_en=6528e70aadc81235dda0176c1a4cfee6 sig_cn_org=None source=14.1 
     <para>
       It is possible to specify multiple hosts to connect to, so that they are
       tried in the given order. In the Keyword/Value format, the <literal>host</literal>,
       <literal>hostaddr</literal>, and <literal>port</literal> options accept comma-separated
       lists of values. The same number of elements must be given in each
       option that is specified, such
       that e.g., the first <literal>hostaddr</literal> corresponds to the first host name,
       the second <literal>hostaddr</literal> corresponds to the second host name, and so
       forth. As an exception, if only one <literal>port</literal> is specified, it
       applies to all the hosts.
     </para>
________________________________________________________-->
     <para>
       可以指定多个要连接的主机，这样它们会按给定的顺序被尝试。
       在键/值格式中，<literal>host</literal>、<literal>hostaddr</literal>和<literal>port</literal>选项都接受逗号分隔的值列表。
       在指定的每一个选项中都必须给出相同数量的元素，这样第一个<literal>hostaddr</literal>对应于第一个主机名，第二个<literal>hostaddr</literal>对应于第二个主机名，以此类推。
       不过，如果仅指定一个<literal>port</literal>，它将被应用于所有的主机。
     </para>
<!-- pgdoc-cn_end sig_en=6528e70aadc81235dda0176c1a4cfee6 -->

<!-- pgdoc-cn_start sig_en=db2206e9b38d5a9d42c1743689ec0a74 sig_cn_org=None source=14.1 
     <para>
       In the connection URI format, you can list multiple <literal>host:port</literal> pairs
       separated by commas in the <literal>host</literal> component of the URI.
     </para>
________________________________________________________-->
     <para>
       在连接URI格式中，在URI的<literal>host</literal>部分我们可以列出多个由逗号分隔的<literal>host:port</literal>对。
     </para>
<!-- pgdoc-cn_end sig_en=db2206e9b38d5a9d42c1743689ec0a74 -->

<!-- pgdoc-cn_start sig_en=70b482f1b4836663f3690aa115810535 sig_cn_org=None source=14.1 
     <para>
       In either format, a single host name can translate to multiple network
       addresses. A common example of this is a host that has both an IPv4 and
       an IPv6 address.
     </para>
________________________________________________________-->
     <para>
       不管是哪一种格式，单一的主机名可以被翻译成多个网络地址。常见的例子是一个主机同时具有IPv4和IPv6地址。
     </para>
<!-- pgdoc-cn_end sig_en=70b482f1b4836663f3690aa115810535 -->

<!-- pgdoc-cn_start sig_en=e2426786c363f37edd9c69fb39b0961b sig_cn_org=None source=14.1 
     <para>
       When multiple hosts are specified, or when a single host name is
       translated to multiple addresses,  all the hosts and addresses will be
       tried in order, until one succeeds. If none of the hosts can be reached,
       the connection fails. If a connection is established successfully, but
       authentication fails, the remaining hosts in the list are not tried.
     </para>
________________________________________________________-->
     <para>
       当多个主机被指定时或者单个主机名被翻译成多个地址时，所有的主机和地址都将按照顺序被尝试，直至遇到一个成功的。如果没有主机可以到达，则连接失败。如果成功地建立一个连接但是认证失败，也不会尝试列表中剩下的主机。
     </para>
<!-- pgdoc-cn_end sig_en=e2426786c363f37edd9c69fb39b0961b -->

<!-- pgdoc-cn_start sig_en=5fc3f84bbfa143db47818a3ecf893132 sig_cn_org=None source=14.1 
     <para>
       If a password file is used, you can have different passwords for
       different hosts. All the other connection options are the same for every
       host in the list; it is not possible to e.g., specify different
       usernames for different hosts.
     </para>
________________________________________________________-->
     <para>
       如果使用了口令文件，可以为不同的主机使用不同的口令。所有其他连接选项对列表中的每一台主机都是相同的，例如不能为不同的主机指定不同的用户名。
     </para>
<!-- pgdoc-cn_end sig_en=5fc3f84bbfa143db47818a3ecf893132 -->
   </sect3>
  </sect2>

  <sect2 id="libpq-paramkeywords">
<!-- pgdoc-cn_start sig_en=87f962641f7ab0791295a8c21b241207 sig_cn_org=None source=14.1 
   <title>Parameter Key Words</title>
________________________________________________________-->
   <title>参数关键词</title>
<!-- pgdoc-cn_end sig_en=87f962641f7ab0791295a8c21b241207 -->

<!-- pgdoc-cn_start sig_en=d7714fd8a4737ce44aa1e3b561fbf603 sig_cn_org=76795c313b157be58fe39dc1ea287027 source=15.7 
   <para>
    The currently recognized parameter key words are:

    <variablelist>
     <varlistentry id="libpq-connect-host" xreflabel="host">
________________________________________________________-->
   <para>
    目前被识别的参数关键字包括:

    <variablelist>
     <varlistentry id="libpq-connect-host" xreflabel="host">
<!-- pgdoc-cn_end sig_en=d7714fd8a4737ce44aa1e3b561fbf603 -->
      <term><literal>host</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=a838e1f1a04edcaf5b363ec778f8ce08 sig_cn_org=1cc235b04650c8a05e523647995001f1 source=15.7 
       <para>
        Name of host to connect to.<indexterm><primary>host
        name</primary></indexterm> If a host name looks like an absolute path
        name, it specifies Unix-domain communication rather than TCP/IP
        communication; the value is the name of the directory in which the
        socket file is stored.  (On Unix, an absolute path name begins with a
        slash.  On Windows, paths starting with drive letters are also
        recognized.)  If the host name starts with <literal>@</literal>, it is
        taken as a Unix-domain socket in the abstract namespace (currently
        supported on Linux and Windows).
        The default behavior when <literal>host</literal> is not
        specified, or is empty, is to connect to a Unix-domain
        socket<indexterm><primary>Unix domain socket</primary></indexterm> in
        <filename>/tmp</filename> (or whatever socket directory was specified
        when <productname>PostgreSQL</productname> was built).  On Windows and
        on machines without Unix-domain sockets, the default is to connect to
        <literal>localhost</literal>.
       </para>
________________________________________________________-->
       <para>
        要连接的主机名。<indexterm><primary>主机名</primary></indexterm>如果主机名看起来像绝对路径名，
        则指定的是Unix域通信而不是TCP/IP通信；该值是存储套接字文件的目录的名称。
        （在Unix上，绝对路径名以斜杠开头。在Windows上，以驱动器号开头的路径也被识别。）
        如果主机名以<literal>@</literal>开头，则将其视为抽象命名空间中的Unix域套接字（目前在Linux和Windows上支持）。
        当未指定<literal>host</literal>或为空时，默认行为是连接到Unix域套接字<indexterm><primary>Unix域套接字</primary></indexterm>在
        <filename>/tmp</filename>（或在构建<productname>PostgreSQL</productname>时指定的套接字目录）中。在Windows和
        没有Unix域套接字的机器上，默认是连接到<literal>localhost</literal>。
       </para>
<!-- pgdoc-cn_end sig_en=a838e1f1a04edcaf5b363ec778f8ce08 -->
<!-- pgdoc-cn_start sig_en=6934ee2ecbe34ce76d98a2bc1156a6fa sig_cn_org=5ab64073ee5cfa152229e7fba3e75656 source=15.7 
       <para>
        A comma-separated list of host names is also accepted, in which case
        each host name in the list is tried in order; an empty item in the
        list selects the default behavior as explained above. See
        <xref linkend="libpq-multiple-hosts"/> for details.
       </para>
________________________________________________________-->
       <para>
        也可以接受一个逗号分隔的主机名列表，此时列表中的每个主机名将按顺序尝试；
        列表中的空项将选择上述默认行为。详细信息请参见<xref linkend="libpq-multiple-hosts"/>。
       </para>
<!-- pgdoc-cn_end sig_en=6934ee2ecbe34ce76d98a2bc1156a6fa -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-hostaddr" xreflabel="hostaddr">
      <term><literal>hostaddr</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=31dc1060a6c46c6a5510e09f99355fc2 sig_cn_org=7e6ded5ce79ae921d2f145fc28767ddd source=15.7 
       <para>
        Numeric IP address of host to connect to.  This should be in the
        standard IPv4 address format, e.g., <literal>172.28.40.9</literal>.  If
        your machine supports IPv6, you can also use those addresses.
        TCP/IP communication is
        always used when a nonempty string is specified for this parameter.
        If this parameter is not specified, the value of <literal>host</literal>
        will be looked up to find the corresponding IP address &mdash; or, if
        <literal>host</literal> specifies an IP address, that value will be
        used directly.
       </para>
________________________________________________________-->
       <para>
        要连接的主机的数字IP地址。这应该是标准的IPv4地址格式，例如，<literal>172.28.40.9</literal>。
        如果您的机器支持IPv6，也可以使用这些地址。当为此参数指定非空字符串时，总是使用TCP/IP通信。
        如果未指定此参数，则将查找<literal>host</literal>的值以查找相应的IP地址 — 或者，如果<literal>host</literal>指定了IP地址，则将直接使用该值。
       </para>
<!-- pgdoc-cn_end sig_en=31dc1060a6c46c6a5510e09f99355fc2 -->

<!-- pgdoc-cn_start sig_en=b67d440cfef34de21f0771618fdb4d1e sig_cn_org=3d296cb047c6ade14dc32be588950fe6 source=15.7 
       <para>
        Using <literal>hostaddr</literal> allows the
        application to avoid a host name look-up, which might be important
        in applications with time constraints. However, a host name is
        required for GSSAPI or SSPI authentication
        methods, as well as for <literal>verify-full</literal> SSL
        certificate verification.  The following rules are used:
        <itemizedlist>
         <listitem>
          <para>
           If <literal>host</literal> is specified
           without <literal>hostaddr</literal>, a host name lookup occurs.
           (When using <function>PQconnectPoll</function>, the lookup occurs
           when <function>PQconnectPoll</function> first considers this host
           name, and it may cause <function>PQconnectPoll</function> to block
           for a significant amount of time.)
          </para>
         </listitem>
         <listitem>
          <para>
           If <literal>hostaddr</literal> is specified without <literal>host</literal>,
           the value for <literal>hostaddr</literal> gives the server network address.
           The connection attempt will fail if the authentication
           method requires a host name.
          </para>
         </listitem>
         <listitem>
          <para>
           If both <literal>host</literal> and <literal>hostaddr</literal> are specified,
           the value for <literal>hostaddr</literal> gives the server network address.
           The value for <literal>host</literal> is ignored unless the
           authentication method requires it, in which case it will be
           used as the host name.
          </para>
         </listitem>
        </itemizedlist>
        Note that authentication is likely to fail if <literal>host</literal>
        is not the name of the server at network address <literal>hostaddr</literal>.
        Also, when both <literal>host</literal> and <literal>hostaddr</literal>
        are specified, <literal>host</literal>
        is used to identify the connection in a password file (see
        <xref linkend="libpq-pgpass"/>).
       </para>
________________________________________________________-->
       <para>
        使用<literal>hostaddr</literal>允许应用程序避免主机名查找，这在有时间限制的应用程序中可能很重要。
        但是，对于GSSAPI或SSPI身份验证方法以及<literal>verify-full</literal> SSL证书验证，需要主机名。
        使用以下规则：
        <itemizedlist>
         <listitem>
          <para>
           如果指定了<literal>host</literal>而没有指定<literal>hostaddr</literal>，则会发生主机名查找。
           （当使用<function>PQconnectPoll</function>时，查找发生在<function>PQconnectPoll</function>首次考虑此主机名时，
           并且可能导致<function>PQconnectPoll</function>阻塞一段时间。）
          </para>
         </listitem>
         <listitem>
          <para>
           如果指定了<literal>hostaddr</literal>而没有指定<literal>host</literal>，
           则<literal>hostaddr</literal>的值给出服务器的网络地址。
           如果身份验证方法需要主机名，则连接尝试将失败。
          </para>
         </listitem>
         <listitem>
          <para>
           如果同时指定了<literal>host</literal>和<literal>hostaddr</literal>，
           则<literal>hostaddr</literal>的值给出服务器的网络地址。
           除非身份验证方法需要，否则<literal>host</literal>的值将被忽略，
           在这种情况下，它将用作主机名。
          </para>
         </listitem>
        </itemizedlist>
        请注意，如果<literal>host</literal>不是网络地址<literal>hostaddr</literal>上服务器的名称，
        则身份验证可能会失败。
        此外，当同时指定<literal>host</literal>和<literal>hostaddr</literal>时，
        <literal>host</literal>用于在密码文件中标识连接（请参阅<xref linkend="libpq-pgpass"/>）。
       </para>
<!-- pgdoc-cn_end sig_en=b67d440cfef34de21f0771618fdb4d1e -->

<!-- pgdoc-cn_start sig_en=ed6d482bb1bf456f46a337011244f7c9 sig_cn_org=1483999406fee51f14da6efe1b74cd06 source=15.7 
       <para>
        A comma-separated list of <literal>hostaddr</literal> values is also
        accepted, in which case each host in the list is tried in order.
        An empty item in the list causes the corresponding host name to be
        used, or the default host name if that is empty as well. See
        <xref linkend="libpq-multiple-hosts"/> for details.
       </para>
________________________________________________________-->
       <para>
        也可以接受一个逗号分隔的<literal>hostaddr</literal>值列表，此时将按顺序尝试列表中的每个主机。
        列表中的空项会导致使用相应的主机名，如果主机名也为空，则使用默认主机名。详见
        <xref linkend="libpq-multiple-hosts"/>。
       </para>
<!-- pgdoc-cn_end sig_en=ed6d482bb1bf456f46a337011244f7c9 -->
<!-- pgdoc-cn_start sig_en=d5560d803addd6c365a83967baa1a6df sig_cn_org=edcab63afe9e0611d57cc352e926bdf1 source=15.7 
       <para>
        Without either a host name or host address,
        <application>libpq</application> will connect using a local
        Unix-domain socket; or on Windows and on machines without Unix-domain
        sockets, it will attempt to connect to <literal>localhost</literal>.
       </para>
________________________________________________________-->
       <para>
        没有主机名或主机地址，
        <application>libpq</application>将使用本地的Unix域套接字进行连接；
        或者在Windows和没有Unix域套接字的机器上，它将尝试连接到<literal>localhost</literal>。
       </para>
<!-- pgdoc-cn_end sig_en=d5560d803addd6c365a83967baa1a6df -->
       </listitem>
      </varlistentry>

      <varlistentry id="libpq-connect-port" xreflabel="port">
       <term><literal>port</literal></term>
       <listitem>
<!-- pgdoc-cn_start sig_en=56287e3cbb7c4f13630754a40e106f8d sig_cn_org=f4488a2cc5f1746e99c301890d281bc0 source=15.7 
       <para>
        Port number to connect to at the server host, or socket file
        name extension for Unix-domain
        connections.<indexterm><primary>port</primary></indexterm>
        If multiple hosts were given in the <literal>host</literal> or
        <literal>hostaddr</literal> parameters, this parameter may specify a
        comma-separated list of ports of the same length as the host list, or
        it may specify a single port number to be used for all hosts.
        An empty string, or an empty item in a comma-separated list,
        specifies the default port number established
        when <productname>PostgreSQL</productname> was built.
       </para>
________________________________________________________-->
       <para>
        连接到服务器主机的端口号，或者Unix域连接的套接字文件名扩展。
        <indexterm><primary>端口</primary></indexterm>
        如果在<literal>host</literal>或<literal>hostaddr</literal>参数中给出了多个主机，
        则此参数可以指定与主机列表长度相同的逗号分隔的端口列表，或者可以指定用于所有主机的单个端口号。
        空字符串，或逗号分隔列表中的空项，指定了在构建<productname>PostgreSQL</productname>时建立的默认端口号。
</para>
<!-- pgdoc-cn_end sig_en=56287e3cbb7c4f13630754a40e106f8d -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-dbname" xreflabel="dbname">
      <term><literal>dbname</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=6652165db7edcf3e7d4a1b127be1c7a9 sig_cn_org=8db85a8aedbef00dbe082473fef5bd1b source=15.7 
      <para>
       The database name.  Defaults to be the same as the user name.
       In certain contexts, the value is checked for extended
       formats; see <xref linkend="libpq-connstring"/> for more details on
       those.
      </para>
________________________________________________________-->
      <para>
       数据库名称。默认为与用户名相同。在某些情况下，该值会被检查是否为扩展格式；
       有关更多详细信息，请参阅<xref linkend="libpq-connstring"/>。
</para>
<!-- pgdoc-cn_end sig_en=6652165db7edcf3e7d4a1b127be1c7a9 -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-user" xreflabel="user">
      <term><literal>user</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=041fcac1000063d0700da52619773fea sig_cn_org=0b7dbd0890a0c074182fecd4dfca2240 source=15.7 
      <para>
       <productname>PostgreSQL</productname> user name to connect as.
       Defaults to be the same as the operating system name of the user
       running the application.
      </para>
________________________________________________________-->
      <para>
       <productname>PostgreSQL</productname>用户连接的用户名。
       默认为运行应用程序的操作系统用户名相同。
      </para>
<!-- pgdoc-cn_end sig_en=041fcac1000063d0700da52619773fea -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-password" xreflabel="password">
      <term><literal>password</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=05a6a0b913f2c1f76e3ebdfc0500e79f sig_cn_org=63ce56d6b3cacb643725fd4645fe6052 source=15.7 
      <para>
       Password to be used if the server demands password authentication.
      </para>
________________________________________________________-->
      <para>
       如果服务器要求密码验证，则使用密码。
      </para>
<!-- pgdoc-cn_end sig_en=05a6a0b913f2c1f76e3ebdfc0500e79f -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-passfile" xreflabel="passfile">
      <term><literal>passfile</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=856dc276e149de4cf0dfb59fe23a06a1 sig_cn_org=e16f796703d8f2af21cbba96017b401a source=15.7 
      <para>
       Specifies the name of the file used to store passwords
       (see <xref linkend="libpq-pgpass"/>).
       Defaults to <filename>~/.pgpass</filename>, or
       <filename>%APPDATA%\postgresql\pgpass.conf</filename> on Microsoft Windows.
       (No error is reported if this file does not exist.)
      </para>
________________________________________________________-->
      <para>
       指定用于存储密码的文件名（参见<xref linkend="libpq-pgpass"/>）。
       默认为<filename>~/.pgpass</filename>，或在Microsoft Windows上为<filename>%APPDATA%\postgresql\pgpass.conf</filename>。
       （如果此文件不存在，则不会报告错误。）
      </para>
<!-- pgdoc-cn_end sig_en=856dc276e149de4cf0dfb59fe23a06a1 -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-channel-binding" xreflabel="channel_binding">
      <term><literal>channel_binding</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=ddc532c4a30f492f8b81c77af5c1d415 sig_cn_org=17234577477318fc58f5b3ee14cbf683 source=15.7 
      <para>
        This option controls the client's use of channel binding. A setting
        of <literal>require</literal> means that the connection must employ
        channel binding, <literal>prefer</literal> means that the client will
        choose channel binding if available, and <literal>disable</literal>
        prevents the use of channel binding. The default
        is <literal>prefer</literal> if
        <productname>PostgreSQL</productname> is compiled with SSL support;
        otherwise the default is <literal>disable</literal>.
      </para>
________________________________________________________-->
      <para>
        这个选项控制客户端对通道绑定的使用。设置为<literal>require</literal>表示连接必须使用通道绑定，
        <literal>prefer</literal>表示客户端将在可用时选择通道绑定，
        而<literal>disable</literal>则阻止使用通道绑定。默认情况下，
        如果<productname>PostgreSQL</productname>是使用SSL支持编译的，则默认为<literal>prefer</literal>;
        否则默认为<literal>disable</literal>。
      </para>
<!-- pgdoc-cn_end sig_en=ddc532c4a30f492f8b81c77af5c1d415 -->
<!-- pgdoc-cn_start sig_en=f6f09ea94cdf75ba2b4eb86f7d0fde0a sig_cn_org=da7cb711add7db86c3a97fa520e0a949 source=15.7 
      <para>
        Channel binding is a method for the server to authenticate itself to
        the client. It is only supported over SSL connections
        with <productname>PostgreSQL</productname> 11 or later servers using
        the <literal>SCRAM</literal> authentication method.
      </para>
________________________________________________________-->
      <para>
        Channel binding是服务器向客户端进行身份验证的一种方法。它仅在使用<productname>PostgreSQL</productname> 11或更高版本服务器，并使用<literal>SCRAM</literal>身份验证方法的SSL连接中受支持。
      </para>
<!-- pgdoc-cn_end sig_en=f6f09ea94cdf75ba2b4eb86f7d0fde0a -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-connect-timeout" xreflabel="connect_timeout">
      <term><literal>connect_timeout</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=f776694495239bce5557d39cce9f3c72 sig_cn_org=ef99d4b2a483444288e8b7bb72bd6e72 source=15.7 
      <para>
       Maximum time to wait while connecting, in seconds (write as a decimal integer,
       e.g., <literal>10</literal>).  Zero, negative, or not specified means
       wait indefinitely.  The minimum allowed timeout is 2 seconds, therefore
       a value of <literal>1</literal> is interpreted as <literal>2</literal>.
       This timeout applies separately to each host name or IP address.
       For example, if you specify two hosts and <literal>connect_timeout</literal>
       is 5, each host will time out if no connection is made within 5
       seconds, so the total time spent waiting for a connection might be
       up to 10 seconds.
      </para>
________________________________________________________-->
      <para>
       连接时的最长等待时间，以秒为单位（写成十进制整数，例如，<literal>10</literal>）。
       零、负值或未指定表示无限等待。最小允许的超时时间为2秒，因此
       <literal>1</literal>的值被解释为<literal>2</literal>。
       此超时时间分别适用于每个主机名或IP地址。
       例如，如果指定了两个主机和<literal>connect_timeout</literal>
       为5，如果在5秒内没有建立连接，每个主机将超时，
       因此等待连接的总时间可能长达10秒。
      </para>
<!-- pgdoc-cn_end sig_en=f776694495239bce5557d39cce9f3c72 -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-client-encoding" xreflabel="client_encoding">
      <term><literal>client_encoding</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=0434a6ac9543f7101b2865fa69df741a sig_cn_org=7d46bf377090b5bed04fc6f422fc2040 source=15.7 
      <para>
       This sets the <varname>client_encoding</varname>
       configuration parameter for this connection.  In addition to
       the values accepted by the corresponding server option, you
       can use <literal>auto</literal> to determine the right
       encoding from the current locale in the client
       (<envar>LC_CTYPE</envar> environment variable on Unix
       systems).
      </para>
________________________________________________________-->
      <para>
       这将为此连接设置<varname>client_encoding</varname>配置参数。除了对应服务器选项接受的值外，
       您还可以使用<literal>auto</literal>来从客户端的当前区域设置（Unix系统上的<envar>LC_CTYPE</envar>环境变量）确定正确的编码。
      </para>
<!-- pgdoc-cn_end sig_en=0434a6ac9543f7101b2865fa69df741a -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-options" xreflabel="options">
      <term><literal>options</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=0f70a5447e1acd04dda89fb8919b5cee sig_cn_org=11ac0af2e0bec99fcb2e7639546d11aa source=15.7 
       <para>
        Specifies command-line options to send to the server at connection
        start.  For example, setting this to <literal>-c geqo=off</literal> sets the
        session's value of the <varname>geqo</varname> parameter to
        <literal>off</literal>.  Spaces within this string are considered to
        separate command-line arguments, unless escaped with a backslash
        (<literal>\</literal>); write <literal>\\</literal> to represent a literal
        backslash.  For a detailed discussion of the available
        options, consult <xref linkend="runtime-config"/>.
       </para>
________________________________________________________-->
       <para>
        指定连接开始时发送到服务器的命令行选项。例如，将其设置为<literal>-c geqo=off</literal>会将会话的<varname>geqo</varname>参数的值设置为<literal>off</literal>。
        此字符串中的空格被视为分隔命令行参数，除非用反斜杠（<literal>\</literal>）转义；写<literal>\\</literal>表示字面上的反斜杠。
        有关可用选项的详细讨论，请参阅<xref linkend="runtime-config"/>。
       </para>
<!-- pgdoc-cn_end sig_en=0f70a5447e1acd04dda89fb8919b5cee -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-application-name" xreflabel="application_name">
      <term><literal>application_name</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=1132deda855f734f27ecc2ac8e093e81 sig_cn_org=81d8b39ca8562e6a3b2acb65d55abdb7 source=15.7 
       <para>
        Specifies a value for the <xref linkend="guc-application-name"/>
        configuration parameter.
       </para>
________________________________________________________-->
       <para>
        指定<xref linkend="guc-application-name"/>配置参数的值。
       </para>
<!-- pgdoc-cn_end sig_en=1132deda855f734f27ecc2ac8e093e81 -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-fallback-application-name" xreflabel="fallback_application_name">
      <term><literal>fallback_application_name</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=e5f0abf73c1c5dd98ff346e008027aad sig_cn_org=d5b38717a19b3420f7386cd195624cb9 source=15.7 
       <para>
        Specifies a fallback value for the <xref
        linkend="guc-application-name"/> configuration parameter.
        This value will be used if no value has been given for
        <literal>application_name</literal> via a connection parameter or the
        <envar>PGAPPNAME</envar> environment variable.  Specifying
        a fallback name is useful in generic utility programs that
        wish to set a default application name but allow it to be
        overridden by the user.
       </para>
________________________________________________________-->
       <para>
        指定<xref linkend="guc-application-name"/>配置参数的回退值。
        如果没有通过连接参数或<envar>PGAPPNAME</envar>环境变量为<literal>application_name</literal>指定值，
        则将使用此值。在通用实用程序中指定回退名称很有用，该程序希望设置默认应用程序名称，
        但允许用户覆盖它。
       </para>
<!-- pgdoc-cn_end sig_en=e5f0abf73c1c5dd98ff346e008027aad -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-keepalives" xreflabel="keepalives">
      <term><literal>keepalives</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=38f4178600e072495a309ddb9cfe23a3 sig_cn_org=4a9457a4f579626c913667970fbfbc09 source=15.7 
       <para>
        Controls whether client-side TCP keepalives are used. The default
        value is 1, meaning on, but you can change this to 0, meaning off,
        if keepalives are not wanted.  This parameter is ignored for
        connections made via a Unix-domain socket.
       </para>
________________________________________________________-->
       <para>
        控制是否使用客户端TCP保持活动。默认值为1，表示开启，但如果不想要保持活动，可以将其更改为0，表示关闭。
        对于通过Unix域套接字进行的连接，此参数将被忽略。
       </para>
<!-- pgdoc-cn_end sig_en=38f4178600e072495a309ddb9cfe23a3 -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-keepalives-idle" xreflabel="keepalives_idle">
      <term><literal>keepalives_idle</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=c5a8643a9052bd7292c7578b69c0ce5e sig_cn_org=44a4c94299af11ce11b87cecd6795dcd source=15.7 
       <para>
        Controls the number of seconds of inactivity after which TCP should
        send a keepalive message to the server.  A value of zero uses the
        system default. This parameter is ignored for connections made via a
        Unix-domain socket, or if keepalives are disabled.
        It is only supported on systems where <symbol>TCP_KEEPIDLE</symbol> or
        an equivalent socket option is available, and on Windows; on other
        systems, it has no effect.
       </para>
________________________________________________________-->
       <para>
        控制在多少秒的不活动后，TCP应向服务器发送保持活动消息。值为零使用系统默认值。
        对通过Unix域套接字进行的连接或禁用保持活活动的连接，此参数将被忽略。
        仅在支持<symbol>TCP_KEEPIDLE</symbol>或等效套接字选项的系统以及Windows上支持；
        在其他系统上，它没有任何效果。
       </para>
<!-- pgdoc-cn_end sig_en=c5a8643a9052bd7292c7578b69c0ce5e -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-keepalives-interval" xreflabel="keepalives_interval">
      <term><literal>keepalives_interval</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=ea4b4ab3bea45c8d75339b5ea0dd7874 sig_cn_org=7de930e0138718a2f6d07d1b7fcf13eb source=15.7 
       <para>
        Controls the number of seconds after which a TCP keepalive message
        that is not acknowledged by the server should be retransmitted.  A
        value of zero uses the system default. This parameter is ignored for
        connections made via a Unix-domain socket, or if keepalives are disabled.
        It is only supported on systems where <symbol>TCP_KEEPINTVL</symbol> or
        an equivalent socket option is available, and on Windows; on other
        systems, it has no effect.
       </para>
________________________________________________________-->
       <para>
        控制在服务器未确认的情况下重新传输TCP保持活动消息的秒数。值为零时使用系统默认值。
        此参数在通过Unix域套接字进行连接或禁用保持活动时将被忽略。
        仅在支持<symbol>TCP_KEEPINTVL</symbol>或等效套接字选项的系统和Windows上支持；
        在其他系统上，此参数无效。
       </para>
<!-- pgdoc-cn_end sig_en=ea4b4ab3bea45c8d75339b5ea0dd7874 -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-keepalives-count" xreflabel="keepalives_count">
      <term><literal>keepalives_count</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=6a772362d204e8e2f0059a3a09aea7e6 sig_cn_org=ed21d46e20384b6159d6f691802def24 source=15.7 
       <para>
        Controls the number of TCP keepalives that can be lost before the
        client's connection to the server is considered dead.  A value of
        zero uses the system default. This parameter is ignored for
        connections made via a Unix-domain socket, or if keepalives are disabled.
        It is only supported on systems where <symbol>TCP_KEEPCNT</symbol> or
        an equivalent socket option is available; on other systems, it has no
        effect.
       </para>
________________________________________________________-->
       <para>
        控制在客户端与服务器之间连接被视为断开之前可以丢失的TCP keepalive数量。
        值为零时使用系统默认值。对通过Unix域套接字建立的连接或禁用keepalives的连接，此参数将被忽略。
        仅在支持<symbol>TCP_KEEPCNT</symbol>或等效套接字选项的系统上受支持；
        在其他系统上，此参数无效。
       </para>
<!-- pgdoc-cn_end sig_en=6a772362d204e8e2f0059a3a09aea7e6 -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-tcp-user-timeout" xreflabel="tcp_user_timeout">
      <term><literal>tcp_user_timeout</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=a24819d4ee1fbdb29a68e181d6f2f373 sig_cn_org=4be005c8a3a90fd93fd8ef8bdf12e4c5 source=15.7 
       <para>
        Controls the number of milliseconds that transmitted data may
        remain unacknowledged before a connection is forcibly closed.
        A value of zero uses the system default. This parameter is
        ignored for connections made via a Unix-domain socket.
        It is only supported on systems where <symbol>TCP_USER_TIMEOUT</symbol>
        is available; on other systems, it has no effect.
       </para>
________________________________________________________-->
       <para>
        控制在连接在强制关闭之前，传输数据可以保持未被确认的毫秒数。
        值为零时使用系统默认值。此参数对通过Unix域套接字进行的连接无效。
        仅在支持<symbol>TCP_USER_TIMEOUT</symbol>的系统上受支持；在其他系统上，它没有效果。
       </para>
<!-- pgdoc-cn_end sig_en=a24819d4ee1fbdb29a68e181d6f2f373 -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-replication" xreflabel="replication">
      <term><literal>replication</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=425d9d44c5ace81296fc7a96ce2e2980 sig_cn_org=ce2375a62ccb51e4099f46eff6e93514 source=15.7 
      <para>
       This option determines whether the connection should use the
       replication protocol instead of the normal protocol.  This is what
       PostgreSQL replication connections as well as tools such as
       <application>pg_basebackup</application> use internally, but it can
       also be used by third-party applications.  For a description of the
       replication protocol, consult <xref linkend="protocol-replication"/>.
      </para>
________________________________________________________-->
      <para>
       这个选项确定连接是否应该使用复制协议而不是正常协议。这就是PostgreSQL复制连接以及诸如
       <application>pg_basebackup</application>这样的工具在内部使用的方式，但也可以被第三方应用程序使用。
       要了解复制协议的描述，请参考<xref linkend="protocol-replication"/>。
      </para>
<!-- pgdoc-cn_end sig_en=425d9d44c5ace81296fc7a96ce2e2980 -->

<!-- pgdoc-cn_start sig_en=260b2c79e68dcb9a62af11b2cee36c40 sig_cn_org=8a58864dd760514517a8a74b32e8100b source=15.7 
      <para>
       The following values, which are case-insensitive, are supported:
       <variablelist>
        <varlistentry>
         <term>
          <literal>true</literal>, <literal>on</literal>,
          <literal>yes</literal>, <literal>1</literal>
         </term>
         <listitem>
          <para>
           The connection goes into physical replication mode.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>database</literal></term>
         <listitem>
          <para>
           The connection goes into logical replication mode, connecting to
           the database specified in the <literal>dbname</literal> parameter.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term>
          <literal>false</literal>, <literal>off</literal>,
          <literal>no</literal>, <literal>0</literal>
         </term>
         <listitem>
          <para>
           The connection is a regular one, which is the default behavior.
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>
________________________________________________________-->
      <para>
       支持以下值（不区分大小写）：
       <variablelist>
        <varlistentry>
         <term>
          <literal>true</literal>, <literal>on</literal>,
          <literal>yes</literal>, <literal>1</literal>
         </term>
         <listitem>
          <para>
           连接进入物理复制模式。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>database</literal></term>
         <listitem>
          <para>
           连接进入逻辑复制模式，连接到<literal>dbname</literal>参数中指定的数据库。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term>
          <literal>false</literal>, <literal>off</literal>,
          <literal>no</literal>, <literal>0</literal>
         </term>
         <listitem>
          <para>
           连接是常规连接，这是默认行为。
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>
<!-- pgdoc-cn_end sig_en=260b2c79e68dcb9a62af11b2cee36c40 -->

<!-- pgdoc-cn_start sig_en=74ec126ddb065a67011542c3196ca9ab sig_cn_org=45839bb2f2a80ac8ce344f5a63cf2050 source=15.7 
      <para>
       In physical or logical replication mode, only the simple query protocol
       can be used.
      </para>
________________________________________________________-->
      <para>
       在物理或逻辑复制模式下，只能使用简单查询协议。
      </para>
<!-- pgdoc-cn_end sig_en=74ec126ddb065a67011542c3196ca9ab -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-gssencmode" xreflabel="gssencmode">
      <term><literal>gssencmode</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=1124ec546ca4f1b365a517ebd13ba8ca sig_cn_org=718a58c8277719c476a917c0c0945b30 source=15.7 
       <para>
        This option determines whether or with what priority a secure
        <acronym>GSS</acronym> TCP/IP connection will be negotiated with the
        server. There are three modes:

        <variablelist>
         <varlistentry>
          <term><literal>disable</literal></term>
          <listitem>
           <para>
            only try a non-<acronym>GSSAPI</acronym>-encrypted connection
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>prefer</literal> (default)</term>
          <listitem>
           <para>
            if there are <acronym>GSSAPI</acronym> credentials present (i.e.,
            in a credentials cache), first try
            a <acronym>GSSAPI</acronym>-encrypted connection; if that fails or
            there are no credentials, try a
            non-<acronym>GSSAPI</acronym>-encrypted connection.  This is the
            default when <productname>PostgreSQL</productname> has been
            compiled with <acronym>GSSAPI</acronym> support.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>require</literal></term>
          <listitem>
           <para>
            only try a <acronym>GSSAPI</acronym>-encrypted connection
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>
________________________________________________________-->
       <para>
        这个选项确定是否以及如何优先与服务器协商安全的<acronym>GSS</acronym> TCP/IP连接。有三种模式：

        <variablelist>
         <varlistentry>
          <term><literal>disable</literal></term>
          <listitem>
           <para>
            仅尝试非<acronym>GSSAPI</acronym>加密连接
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>prefer</literal> (默认)</term>
          <listitem>
           <para>
            如果存在<acronym>GSSAPI</acronym>凭据（即在凭据缓存中），首先尝试
            <acronym>GSSAPI</acronym>加密连接；如果失败或没有凭据，则尝试
            非<acronym>GSSAPI</acronym>加密连接。这是在编译<productname>PostgreSQL</productname>时使用<acronym>GSSAPI</acronym>支持时的默认设置。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>require</literal></term>
          <listitem>
           <para>
            仅尝试<acronym>GSSAPI</acronym>加密连接
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>
<!-- pgdoc-cn_end sig_en=1124ec546ca4f1b365a517ebd13ba8ca -->

<!-- pgdoc-cn_start sig_en=d7dd8e209c8d04d003cc090c1ad6264f sig_cn_org=8a5ac3a5355835da914c5a1652ac77d8 source=15.7 
       <para>
        <literal>gssencmode</literal> is ignored for Unix domain socket
        communication.  If <productname>PostgreSQL</productname> is compiled
        without GSSAPI support, using the <literal>require</literal> option
        will cause an error, while <literal>prefer</literal> will be accepted
        but <application>libpq</application> will not actually attempt
        a <acronym>GSSAPI</acronym>-encrypted
        connection.<indexterm><primary>GSSAPI</primary><secondary sortas="libpq">with
        libpq</secondary></indexterm>
       </para>
________________________________________________________-->
       <para>
        <literal>gssencmode</literal>在Unix域套接字通信中被忽略。如果<productname>PostgreSQL</productname>没有编译GSSAPI支持，
        使用<literal>require</literal>选项将导致错误，而<literal>prefer</literal>将被接受，但<application>libpq</application>实际上不会尝试
        进行<acronym>GSSAPI</acronym>加密连接。<indexterm><primary>GSSAPI</primary><secondary sortas="libpq">与libpq</secondary></indexterm>
       </para>
<!-- pgdoc-cn_end sig_en=d7dd8e209c8d04d003cc090c1ad6264f -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslmode" xreflabel="sslmode">
      <term><literal>sslmode</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=85e4ee4ac9ccae90addd9931d61524a8 sig_cn_org=466b27c99c763b705cbc0a34415b5d39 source=15.7 
       <para>
        This option determines whether or with what priority a secure
        <acronym>SSL</acronym> TCP/IP connection will be negotiated with the
        server. There are six modes:

        <variablelist>
         <varlistentry>
          <term><literal>disable</literal></term>
          <listitem>
           <para>
            only try a non-<acronym>SSL</acronym> connection
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>allow</literal></term>
          <listitem>
           <para>
            first try a non-<acronym>SSL</acronym> connection; if that
            fails, try an <acronym>SSL</acronym> connection
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>prefer</literal> (default)</term>
          <listitem>
           <para>
            first try an <acronym>SSL</acronym> connection; if that fails,
            try a non-<acronym>SSL</acronym> connection
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>require</literal></term>
          <listitem>
           <para>
            only try an <acronym>SSL</acronym> connection. If a root CA
            file is present, verify the certificate in the same way as
            if <literal>verify-ca</literal> was specified
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>verify-ca</literal></term>
          <listitem>
           <para>
            only try an <acronym>SSL</acronym> connection, and verify that
            the server certificate is issued by a trusted
            certificate authority (<acronym>CA</acronym>)
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>verify-full</literal></term>
          <listitem>
           <para>
            only try an <acronym>SSL</acronym> connection, verify that the
            server certificate is issued by a
            trusted <acronym>CA</acronym> and that the requested server host name
            matches that in the certificate
           </para>
          </listitem>
         </varlistentry>
        </variablelist>

        See <xref linkend="libpq-ssl"/> for a detailed description of how
        these options work.
       </para>
________________________________________________________-->
       <para>
        这个选项确定是否以及以何种优先级与服务器协商安全的<acronym>SSL</acronym> TCP/IP连接。有六种模式：

        <variablelist>
         <varlistentry>
          <term><literal>disable</literal></term>
          <listitem>
           <para>
            仅尝试非<acronym>SSL</acronym>连接
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>allow</literal></term>
          <listitem>
           <para>
            首先尝试非<acronym>SSL</acronym>连接；如果失败，则尝试<acronym>SSL</acronym>连接
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>prefer</literal> (默认)</term>
          <listitem>
           <para>
            首先尝试<acronym>SSL</acronym>连接；如果失败，则尝试非<acronym>SSL</acronym>连接
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>require</literal></term>
          <listitem>
           <para>
            仅尝试<acronym>SSL</acronym>连接。如果存在根CA文件，则验证证书的方式与指定了<literal>verify-ca</literal>时相同
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>verify-ca</literal></term>
          <listitem>
           <para>
            仅尝试<acronym>SSL</acronym>连接，并验证服务器证书是否由受信任的证书颁发机构（<acronym>CA</acronym>）颁发
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>verify-full</literal></term>
          <listitem>
           <para>
            仅尝试<acronym>SSL</acronym>连接，验证服务器证书是否由受信任的<acronym>CA</acronym>颁发，并且请求的服务器主机名与证书中的匹配
           </para>
          </listitem>
         </varlistentry>
        </variablelist>

        详细了解这些选项如何工作，请参阅<xref linkend="libpq-ssl"/>。
       </para>
<!-- pgdoc-cn_end sig_en=85e4ee4ac9ccae90addd9931d61524a8 -->

<!-- pgdoc-cn_start sig_en=ed6a4fc24e0b67552209142727bc469f sig_cn_org=fe54c29770e0f8d712a8fdeea1df900d source=15.7 
       <para>
        <literal>sslmode</literal> is ignored for Unix domain socket
        communication.
        If <productname>PostgreSQL</productname> is compiled without SSL support,
        using options <literal>require</literal>, <literal>verify-ca</literal>, or
        <literal>verify-full</literal> will cause an error, while
        options <literal>allow</literal> and <literal>prefer</literal> will be
        accepted but <application>libpq</application> will not actually attempt
        an <acronym>SSL</acronym>
        connection.<indexterm><primary>SSL</primary><secondary
        sortas="libpq">with libpq</secondary></indexterm>
       </para>
________________________________________________________-->
       <para>
        <literal>sslmode</literal>被忽略用于Unix域套接字通信。
        如果<productname>PostgreSQL</productname>没有SSL支持编译，
        使用选项<literal>require</literal>、<literal>verify-ca</literal>或
        <literal>verify-full</literal>会导致错误，而选项<literal>allow</literal>和<literal>prefer</literal>
        将被接受，但<application>libpq</application>实际上不会尝试建立<acronym>SSL</acronym>
        连接。<indexterm><primary>SSL</primary><secondary
        sortas="libpq">使用libpq的SSL</secondary></indexterm>
       </para>
<!-- pgdoc-cn_end sig_en=ed6a4fc24e0b67552209142727bc469f -->

<!-- pgdoc-cn_start sig_en=09c18879953d9f3c641019a59752b78f sig_cn_org=0646020cf7c812568132db7c5229b456 source=15.7 
       <para>
        Note that if <acronym>GSSAPI</acronym> encryption is possible,
        that will be used in preference to <acronym>SSL</acronym>
        encryption, regardless of the value of <literal>sslmode</literal>.
        To force use of <acronym>SSL</acronym> encryption in an
        environment that has working <acronym>GSSAPI</acronym>
        infrastructure (such as a Kerberos server), also
        set <literal>gssencmode</literal> to <literal>disable</literal>.
       </para>
________________________________________________________-->
       <para>
        请注意，如果可能使用<acronym>GSSAPI</acronym>加密，
        则优先使用该加密，而不考虑<acronym>SSL</acronym>的值。要在具有可用<acronym>GSSAPI</acronym>
        基础设施（如Kerberos服务器）的环境中强制使用
        <acronym>SSL</acronym>加密，还需将
        <literal>gssencmode</literal>设置为<literal>disable</literal>。
       </para>
<!-- pgdoc-cn_end sig_en=09c18879953d9f3c641019a59752b78f -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-requiressl" xreflabel="requiressl">
      <term><literal>requiressl</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=49ecc7d1c0125443a1308b8e27ad7a95 sig_cn_org=4ab4a181aea644b98c055302e8e3cb5f source=15.7 
       <para>
        This option is deprecated in favor of the <literal>sslmode</literal>
        setting.
       </para>
________________________________________________________-->
       <para>
        此选项已被<literal>sslmode</literal>设置所取代。
       </para>
<!-- pgdoc-cn_end sig_en=49ecc7d1c0125443a1308b8e27ad7a95 -->

<!-- pgdoc-cn_start sig_en=5dfb3b6311c9cd3a59e12cefd947ddd3 sig_cn_org=e6f130878c00f819f6503abc3292f171 source=15.7 
       <para>
        If set to 1, an <acronym>SSL</acronym> connection to the server
        is required (this is equivalent to <literal>sslmode</literal>
        <literal>require</literal>).  <application>libpq</application> will then refuse
        to connect if the server does not accept an
        <acronym>SSL</acronym> connection.  If set to 0 (default),
        <application>libpq</application> will negotiate the connection type with
        the server (equivalent to <literal>sslmode</literal>
        <literal>prefer</literal>).  This option is only available if
        <productname>PostgreSQL</productname> is compiled with SSL support.
       </para>
________________________________________________________-->
       <para>
        如果设置为1，则需要与服务器建立<acronym>SSL</acronym>连接（这相当于<literal>sslmode</literal>
        <literal>require</literal>）。<application>libpq</application>将拒绝连接，如果服务器不接受
        <acronym>SSL</acronym>连接。如果设置为0（默认值），
        <application>libpq</application>将与服务器协商连接类型（相当于<literal>sslmode</literal>
        <literal>prefer</literal>）。此选项仅在<productname>PostgreSQL</productname>编译时启用SSL支持。
       </para>
<!-- pgdoc-cn_end sig_en=5dfb3b6311c9cd3a59e12cefd947ddd3 -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslcompression" xreflabel="sslcompression">
      <term><literal>sslcompression</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=835f5ae2f57086b0b2b9b63eb45f501d sig_cn_org=f91c40096ff4df10e2361785f02f8d58 source=15.7 
       <para>
        If set to 1, data sent over SSL connections will be compressed.  If
        set to 0, compression will be disabled.  The default is 0.  This
        parameter is ignored if a connection without SSL is made.
       </para>
________________________________________________________-->
       <para>
        如果设置为1，通过SSL连接发送的数据将被压缩。如果设置为0，将禁用压缩。默认值为0。
        如果进行非SSL连接，则忽略此参数。
       </para>
<!-- pgdoc-cn_end sig_en=835f5ae2f57086b0b2b9b63eb45f501d -->

<!-- pgdoc-cn_start sig_en=d8b5802bef98174f7bc77b3bb96799c8 sig_cn_org=275738532a787e61fd69d8cea74b23d2 source=15.7 
       <para>
        SSL compression is nowadays considered insecure and its use is no
        longer recommended.  <productname>OpenSSL</productname> 1.1.0 disables
        compression by default, and many operating system distributions
        disable it in prior versions as well, so setting this parameter to on
        will not have any effect if the server does not accept compression.
        <productname>PostgreSQL</productname> 14 disables compression
        completely in the backend.
       </para>
________________________________________________________-->
       <para>
        SSL压缩现在被认为是不安全的，不再建议使用。 <productname>OpenSSL</productname> 1.1.0默认禁用压缩，
        许多操作系统发行版也在之前的版本中禁用了压缩，因此如果服务器不接受压缩，将此参数设置为on将不会产生任何效果。
        <productname>PostgreSQL</productname> 14在后端完全禁用了压缩。
       </para>
<!-- pgdoc-cn_end sig_en=d8b5802bef98174f7bc77b3bb96799c8 -->

<!-- pgdoc-cn_start sig_en=23ca4b843653fdb2ef922d4c64e06cc1 sig_cn_org=f285f1f8b7de27c82571bcf5e09076a4 source=15.7 
       <para>
        If security is not a primary concern, compression can improve
        throughput if the network is the bottleneck.  Disabling compression
        can improve response time and throughput if CPU performance is the
        limiting factor.
       </para>
________________________________________________________-->
       <para>
        如果安全性不是主要考虑因素，压缩可以提高吞吐量，如果网络是瓶颈的话。如果CPU性能是限制因素，禁用压缩可以提高响应时间和吞吐量。
       </para>
<!-- pgdoc-cn_end sig_en=23ca4b843653fdb2ef922d4c64e06cc1 -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslcert" xreflabel="sslcert">
      <term><literal>sslcert</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=a8fa9f549b1c9c950de8550f41aac981 sig_cn_org=909705ff3cb2d2e7dc55dcc9d83c79e6 source=15.7 
       <para>
        This parameter specifies the file name of the client SSL
        certificate, replacing the default
        <filename>~/.postgresql/postgresql.crt</filename>.
        This parameter is ignored if an SSL connection is not made.
       </para>
________________________________________________________-->
       <para>
        这个参数指定客户端SSL证书的文件名，替换默认的
        <filename>~/.postgresql/postgresql.crt</filename>。
        如果没有建立SSL连接，则此参数将被忽略。
       </para>
<!-- pgdoc-cn_end sig_en=a8fa9f549b1c9c950de8550f41aac981 -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslkey" xreflabel="sslkey">
      <term><literal>sslkey</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=f92767d12132e9b2201f85eb936aff04 sig_cn_org=c6b914c8fc6bfa53640ac05e42b1a96e source=15.7 
       <para>
        This parameter specifies the location for the secret key used for
        the client certificate. It can either specify a file name that will
        be used instead of the default
        <filename>~/.postgresql/postgresql.key</filename>, or it can specify a key
        obtained from an external <quote>engine</quote> (engines are
        <productname>OpenSSL</productname> loadable modules).  An external engine
        specification should consist of a colon-separated engine name and
        an engine-specific key identifier.  This parameter is ignored if an
        SSL connection is not made.
       </para>
________________________________________________________-->
       <para>
        这个参数指定了用于客户端证书的密钥的位置。它可以指定一个文件名，该文件名将被用来替代默认的
        <filename>~/.postgresql/postgresql.key</filename>，或者它可以指定一个从外部<quote>引擎</quote>
        （引擎是<productname>OpenSSL</productname>可加载模块）获取的密钥。外部引擎规范应该包括一个由冒号分隔的引擎名称和
        一个引擎特定的密钥标识符。如果没有进行SSL连接，则此参数将被忽略。
       </para>
<!-- pgdoc-cn_end sig_en=f92767d12132e9b2201f85eb936aff04 -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslpassword" xreflabel="sslpassword">
      <term><literal>sslpassword</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=b3b112ab64502b528ec7e96f7c835508 sig_cn_org=d8bce61a1228b26328ce5a02d70c1b54 source=15.7 
       <para>
        This parameter specifies the password for the secret key specified in
        <literal>sslkey</literal>, allowing client certificate private keys
        to be stored in encrypted form on disk even when interactive passphrase
        input is not practical.
       </para>
________________________________________________________-->
       <para>
        这个参数指定了在<literal>sslkey</literal>中指定的密钥的密码，允许客户端证书私钥在磁盘上以加密形式存储，即使交互式密码输入不可行。
       </para>
<!-- pgdoc-cn_end sig_en=b3b112ab64502b528ec7e96f7c835508 -->
<!-- pgdoc-cn_start sig_en=5332ee1d81d4c77d7178e661046f66d5 sig_cn_org=289a6e1c1f67afc10336e417d88f6db7 source=15.7 
       <para>
        Specifying this parameter with any non-empty value suppresses the
        <literal>Enter PEM pass phrase:</literal>
        prompt that <productname>OpenSSL</productname> will emit by default
        when an encrypted client certificate key is provided to
        <literal>libpq</literal>.
       </para>
________________________________________________________-->
       <para>
        指定此参数为任何非空值将抑制<literal>Enter PEM pass phrase:</literal>
        当提供加密的客户端证书密钥给<literal>libpq</literal>时，
        <productname>OpenSSL</productname>默认会发出的提示。
       </para>
<!-- pgdoc-cn_end sig_en=5332ee1d81d4c77d7178e661046f66d5 -->
<!-- pgdoc-cn_start sig_en=d32467ca22c7af98c4d687032c40b855 sig_cn_org=8e392e95db5a9d0a0d5a861ff824670b source=15.7 
       <para>
        If the key is not encrypted this parameter is ignored. The parameter
        has no effect on keys specified by <productname>OpenSSL</productname>
        engines unless the engine uses the <productname>OpenSSL</productname>
        password callback mechanism for prompts.
       </para>
________________________________________________________-->
       <para>
        如果密钥未加密，则忽略此参数。该参数对由<productname>OpenSSL</productname>引擎指定的密钥没有影响，除非引擎使用<productname>OpenSSL</productname>密码回调机制进行提示。
       </para>
<!-- pgdoc-cn_end sig_en=d32467ca22c7af98c4d687032c40b855 -->
<!-- pgdoc-cn_start sig_en=a153d539344039d68f0f984d5f484cff sig_cn_org=076a26fb52a395e8af6077defabd303e source=15.7 
       <para>
        There is no environment variable equivalent to this option, and no
        facility for looking it up in <filename>.pgpass</filename>. It can be
        used in a service file connection definition. Users with
        more sophisticated uses should consider using <productname>OpenSSL</productname> engines and
        tools like PKCS#11 or USB crypto offload devices.
       </para>
________________________________________________________-->
       <para>
        没有与此选项等效的环境变量，也没有在<filename>.pgpass</filename>中查找它的功能。它可以在服务文件连接定义中使用。
        使用更复杂功能的用户应考虑使用<productname>OpenSSL</productname>引擎和类似PKCS#11或USB加密卸载设备的工具。
       </para>
<!-- pgdoc-cn_end sig_en=a153d539344039d68f0f984d5f484cff -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslrootcert" xreflabel="sslrootcert">
      <term><literal>sslrootcert</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=aa1b814e73983eaca31084cf9b5cb022 sig_cn_org=579847f0f50c32d3998a66ae48cea5ea source=15.7 
       <para>
        This parameter specifies the name of a file containing SSL
        certificate authority (<acronym>CA</acronym>) certificate(s).
        If the file exists, the server's certificate will be verified
        to be signed by one of these authorities.  The default is
        <filename>~/.postgresql/root.crt</filename>.
       </para>
________________________________________________________-->
       <para>
        这个参数指定一个包含SSL证书颁发机构（<acronym>CA</acronym>）证书的文件名。
        如果文件存在，服务器的证书将被验证是否由这些机构之一签名。
        默认值是<filename>~/.postgresql/root.crt</filename>。
       </para>
<!-- pgdoc-cn_end sig_en=aa1b814e73983eaca31084cf9b5cb022 -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslcrl" xreflabel="sslcrl">
      <term><literal>sslcrl</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=2e24940f2e11b8057e770bf3a1851383 sig_cn_org=11d9bd5e01f845d7b6ac406dbc3784bb source=15.7 
       <para>
        This parameter specifies the file name of the SSL server certificate
        revocation list (CRL).  Certificates listed in this file, if it
        exists, will be rejected while attempting to authenticate the
        server's certificate.  If neither
        <xref linkend='libpq-connect-sslcrl'/> nor
        <xref linkend='libpq-connect-sslcrldir'/> is set, this setting is
        taken as
        <filename>~/.postgresql/root.crl</filename>.
       </para>
________________________________________________________-->
       <para>
        这个参数指定SSL服务器证书吊销列表（CRL）的文件名。如果存在该文件中列出的证书，在尝试验证服务器证书时将被拒绝。
        如果既没有设置<xref linkend='libpq-connect-sslcrl'/>也没有设置<xref linkend='libpq-connect-sslcrldir'/>，
        则将采用<filename>~/.postgresql/root.crl</filename>。
       </para>
<!-- pgdoc-cn_end sig_en=2e24940f2e11b8057e770bf3a1851383 -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslcrldir" xreflabel="sslcrldir">
      <term><literal>sslcrldir</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=ce2888de2beb360a6acf01fc05f9fd8d sig_cn_org=9c42fffc27e186b9dd36acf2b4fb54e0 source=15.7 
       <para>
        This parameter specifies the directory name of the SSL server certificate
        revocation list (CRL).  Certificates listed in the files in this
        directory, if it exists, will be rejected while attempting to
        authenticate the server's certificate.
       </para>
________________________________________________________-->
       <para>
        这个参数指定SSL服务器证书吊销列表（CRL）的目录名称。如果存在该目录中的文件中列出的证书，在尝试验证服务器证书时将被拒绝。
       </para>
<!-- pgdoc-cn_end sig_en=ce2888de2beb360a6acf01fc05f9fd8d -->

<!-- pgdoc-cn_start sig_en=df6de75bff37e9e36bb43286f13df899 sig_cn_org=5f6f9e0a072c3aa958958cfd3360baf1 source=15.7 
       <para>
        The directory needs to be prepared with the
        <productname>OpenSSL</productname> command
        <literal>openssl rehash</literal> or <literal>c_rehash</literal>.  See
        its documentation for details.
       </para>
________________________________________________________-->
       <para>
        目录需要使用<productname>OpenSSL</productname>命令
        <literal>openssl rehash</literal>或<literal>c_rehash</literal>进行准备。详细信息请参阅其文档。
       </para>
<!-- pgdoc-cn_end sig_en=df6de75bff37e9e36bb43286f13df899 -->

<!-- pgdoc-cn_start sig_en=ed1f2e12ff76e247e874d47c0660b183 sig_cn_org=0839f06fb0063041962a2876519d9eac source=15.7 
       <para>
        Both <literal>sslcrl</literal> and <literal>sslcrldir</literal> can be
        specified together.
       </para>
________________________________________________________-->
       <para>
        <literal>sslcrl</literal>和<literal>sslcrldir</literal>可以一起指定。
       </para>
<!-- pgdoc-cn_end sig_en=ed1f2e12ff76e247e874d47c0660b183 -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslsni" xreflabel="sslsni">
<!-- pgdoc-cn_start sig_en=a24a9c545a1c05a1c93a80f06d769828 sig_cn_org=d346872808aa9d5a3cbfc3cbfcca2dcc source=15.7 
      <term><literal>sslsni</literal><indexterm><primary>Server Name Indication</primary></indexterm></term>
________________________________________________________-->
      <term><literal>sslsni</literal><indexterm><primary>Server Name Indication</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=a24a9c545a1c05a1c93a80f06d769828 -->
      <listitem>
<!-- pgdoc-cn_start sig_en=150fa97f5e54b53458e5d285f7be8361 sig_cn_org=c5c45519363a379a6e40e19b72d0296c source=15.7 
       <para>
        If set to 1 (default), libpq sets the TLS extension <quote>Server Name
        Indication</quote> (<acronym>SNI</acronym>) on SSL-enabled connections.
        By setting this parameter to 0, this is turned off.
       </para>
________________________________________________________-->
       <para>
        如果设置为1（默认值），libpq会在启用SSL的连接上设置TLS扩展<quote>Server Name Indication</quote>（<acronym>SNI</acronym>）。
        通过将此参数设置为0，可以关闭此功能。
       </para>
<!-- pgdoc-cn_end sig_en=150fa97f5e54b53458e5d285f7be8361 -->

<!-- pgdoc-cn_start sig_en=95f46ad12d52df52ddcfe5c34945242d sig_cn_org=239e28b57420ac0f9e66dad1bc7796bb source=15.7 
       <para>
        The Server Name Indication can be used by SSL-aware proxies to route
        connections without having to decrypt the SSL stream.  (Note that this
        requires a proxy that is aware of the PostgreSQL protocol handshake,
        not just any SSL proxy.)  However, <acronym>SNI</acronym> makes the
        destination host name appear in cleartext in the network traffic, so
        it might be undesirable in some cases.
       </para>
________________________________________________________-->
       <para>
        服务器名称指示可以被SSL感知代理使用，以便在不解密SSL流的情况下路由连接。
        （请注意，这需要一个了解PostgreSQL协议握手的代理，而不仅仅是任何SSL代理。）
        然而，<acronym>SNI</acronym>会使目标主机名以明文形式出现在网络流量中，因此在某些情况下可能不希望使用。
       </para>
<!-- pgdoc-cn_end sig_en=95f46ad12d52df52ddcfe5c34945242d -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-requirepeer" xreflabel="requirepeer">
      <term><literal>requirepeer</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=e0121f42e90d0f6a2a51296c29eefc05 sig_cn_org=64e1a11498cdff317e653ce6c863d6c1 source=15.7 
       <para>
        This parameter specifies the operating-system user name of the
        server, for example <literal>requirepeer=postgres</literal>.
        When making a Unix-domain socket connection, if this
        parameter is set, the client checks at the beginning of the
        connection that the server process is running under the specified
        user name; if it is not, the connection is aborted with an error.
        This parameter can be used to provide server authentication similar
        to that available with SSL certificates on TCP/IP connections.
        (Note that if the Unix-domain socket is in
        <filename>/tmp</filename> or another publicly writable location,
        any user could start a server listening there.  Use this parameter
        to ensure that you are connected to a server run by a trusted user.)
        This option is only supported on platforms for which the
        <literal>peer</literal> authentication method is implemented; see
        <xref linkend="auth-peer"/>.
       </para>
________________________________________________________-->
       <para>
        这个参数指定了服务器的操作系统用户名，例如<literal>requirepeer=postgres</literal>。
        在建立Unix域套接字连接时，如果设置了这个参数，客户端会在连接开始时检查服务器进程是否在指定的用户下运行；
        如果不是，则连接会因错误而中止。
        这个参数可用于提供类似于在TCP/IP连接上使用SSL证书的服务器身份验证。
        （请注意，如果Unix域套接字位于<filename>/tmp</filename>或其他公共可写位置，
        任何用户都可以在那里启动一个服务器监听。使用这个参数来确保您连接到由受信任用户运行的服务器。）
        此选项仅在实现了<literal>peer</literal>身份验证方法的平台上受支持；请参见<xref linkend="auth-peer"/>。
       </para>
<!-- pgdoc-cn_end sig_en=e0121f42e90d0f6a2a51296c29eefc05 -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-ssl-min-protocol-version" xreflabel="ssl_min_protocol_version">
      <term><literal>ssl_min_protocol_version</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=9d5b71668e57a2a6821a04fb25117f15 sig_cn_org=1b49336713577ff94c7205ae67f73557 source=15.7 
       <para>
        This parameter specifies the minimum SSL/TLS protocol version to allow
        for the connection. Valid values are <literal>TLSv1</literal>,
        <literal>TLSv1.1</literal>, <literal>TLSv1.2</literal> and
        <literal>TLSv1.3</literal>. The supported protocols depend on the
        version of <productname>OpenSSL</productname> used, older versions
        not supporting the most modern protocol versions. If not specified,
        the default is <literal>TLSv1.2</literal>, which satisfies industry
        best practices as of this writing.
       </para>
________________________________________________________-->
       <para>
        这个参数指定连接允许的最低SSL/TLS协议版本。有效值为<literal>TLSv1</literal>，
        <literal>TLSv1.1</literal>，<literal>TLSv1.2</literal>和
        <literal>TLSv1.3</literal>。支持的协议取决于所使用的
        <productname>OpenSSL</productname>版本，旧版本不支持最现代的协议版本。
        如果未指定，默认值为<literal>TLSv1.2</literal>，符合本文撰写时的行业最佳实践。
       </para>
<!-- pgdoc-cn_end sig_en=9d5b71668e57a2a6821a04fb25117f15 -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-ssl-max-protocol-version" xreflabel="ssl_max_protocol_version">
      <term><literal>ssl_max_protocol_version</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=c3a25beb42dd451736eb354fc9be8c38 sig_cn_org=41a52d2ef33fd8dcb10998773a2ecdef source=15.7 
       <para>
        This parameter specifies the maximum SSL/TLS protocol version to allow
        for the connection. Valid values are <literal>TLSv1</literal>,
        <literal>TLSv1.1</literal>, <literal>TLSv1.2</literal> and
        <literal>TLSv1.3</literal>. The supported protocols depend on the
        version of <productname>OpenSSL</productname> used, older versions
        not supporting the most modern protocol versions. If not set, this
        parameter is ignored and the connection will use the maximum bound
        defined by the backend, if set. Setting the maximum protocol version
        is mainly useful for testing or if some component has issues working
        with a newer protocol.
       </para>
________________________________________________________-->
       <para>
        这个参数指定连接允许的最大SSL/TLS协议版本。有效值为<literal>TLSv1</literal>，
        <literal>TLSv1.1</literal>，<literal>TLSv1.2</literal>和
        <literal>TLSv1.3</literal>。支持的协议取决于使用的<productname>OpenSSL</productname>
        版本，旧版本不支持最新的协议版本。如果未设置，将忽略此参数，并且连接将使用后端定义的最大限制，
        如果设置。设置最大协议版本主要用于测试或者某些组件无法使用较新协议时。
       </para>
<!-- pgdoc-cn_end sig_en=c3a25beb42dd451736eb354fc9be8c38 -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-krbsrvname" xreflabel="krbsrvname">
      <term><literal>krbsrvname</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=2604d10a54b5c0b634a6b9410e1064ff sig_cn_org=1df226b064ebbd69aa4c93d04d2caab4 source=15.7 
       <para>
        Kerberos service name to use when authenticating with GSSAPI.
        This must match the service name specified in the server
        configuration for Kerberos authentication to succeed. (See also
        <xref linkend="gssapi-auth"/>.)
        The default value is normally <literal>postgres</literal>,
        but that can be changed when
        building <productname>PostgreSQL</productname> via
        the <option>-&minus;with-krb-srvnam</option> option
        of <application>configure</application>.
        In most environments, this parameter never needs to be changed.
        Some Kerberos implementations might require a different service name,
        such as Microsoft Active Directory which requires the service name
        to be in upper case (<literal>POSTGRES</literal>).
       </para>
________________________________________________________-->
       <para>
        用于使用GSSAPI进行身份验证时要使用的Kerberos服务名称。
        这必须与服务器配置中指定的Kerberos身份验证服务名称匹配，才能成功进行身份验证。
        （另请参见<xref linkend="gssapi-auth"/>。）
        默认值通常为<literal>postgres</literal>，
        但在构建<productname>PostgreSQL</productname>时可以通过
        <option>--with-krb-srvnam</option>选项进行更改
        <application>configure</application>。
        在大多数环境中，通常不需要更改此参数。
        一些Kerberos实现可能需要不同的服务名称，
        例如Microsoft Active Directory需要服务名称为大写（<literal>POSTGRES</literal>）。
       </para>
<!-- pgdoc-cn_end sig_en=2604d10a54b5c0b634a6b9410e1064ff -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-gsslib" xreflabel="gsslib">
      <term><literal>gsslib</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=a1b4c4e85fecbcfbaaf62ba0abd2cd11 sig_cn_org=0db09e8bebbc910cb7a28f85e724c3a5 source=15.7 
       <para>
        GSS library to use for GSSAPI authentication.
        Currently this is disregarded except on Windows builds that include
        both GSSAPI and SSPI support.  In that case, set
        this to <literal>gssapi</literal> to cause libpq to use the GSSAPI
        library for authentication instead of the default SSPI.
       </para>
________________________________________________________-->
       <para>
        用于GSSAPI身份验证的GSS库。
        目前，除了包含GSSAPI和SSPI支持的Windows构建之外，这将被忽略。
        在这种情况下，将其设置为<literal>gssapi</literal>，以使libpq使用GSSAPI库进行身份验证，而不是默认的SSPI。
       </para>
<!-- pgdoc-cn_end sig_en=a1b4c4e85fecbcfbaaf62ba0abd2cd11 -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-service" xreflabel="service">
      <term><literal>service</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=368ab9c3c10826da4314c6ebb2329f82 sig_cn_org=6708e5a992d02515693956d22d0a7c69 source=15.7 
       <para>
        Service name to use for additional parameters.  It specifies a service
        name in <filename>pg_service.conf</filename> that holds additional connection parameters.
        This allows applications to specify only a service name so connection parameters
        can be centrally maintained. See <xref linkend="libpq-pgservice"/>.
       </para>
________________________________________________________-->
       <para>
        用于额外参数的服务名称。它指定了<filename>pg_service.conf</filename>中保存额外连接参数的服务名称。
        这允许应用程序只指定一个服务名称，以便可以集中维护连接参数。参见<xref linkend="libpq-pgservice"/>。
</para>
<!-- pgdoc-cn_end sig_en=368ab9c3c10826da4314c6ebb2329f82 -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-target-session-attrs" xreflabel="target_session_attrs">
      <term><literal>target_session_attrs</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=bb1d06c3d848fbec67ec93705e3ce285 sig_cn_org=2fb8fab11dd9c3dc16948da64735dd81 source=15.7 
       <para>
        This option determines whether the session must have certain
        properties to be acceptable.  It's typically used in combination
        with multiple host names to select the first acceptable alternative
        among several hosts.  There are six modes:

        <variablelist>
         <varlistentry>
          <term><literal>any</literal> (default)</term>
          <listitem>
           <para>
            any successful connection is acceptable
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>read-write</literal></term>
          <listitem>
           <para>
            session must accept read-write transactions by default (that
            is, the server must not be in hot standby mode and
            the <varname>default_transaction_read_only</varname> parameter
            must be <literal>off</literal>)
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>read-only</literal></term>
          <listitem>
           <para>
            session must not accept read-write transactions by default (the
            converse)
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>primary</literal></term>
          <listitem>
           <para>
            server must not be in hot standby mode
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>standby</literal></term>
          <listitem>
           <para>
            server must be in hot standby mode
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>prefer-standby</literal></term>
          <listitem>
           <para>
            first try to find a standby server, but if none of the listed
            hosts is a standby server, try again in <literal>any</literal>
            mode
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>
________________________________________________________-->
       <para>
        这个选项确定会话是否必须具有某些属性才能被接受。通常与多个主机名结合使用，
        以选择在几个主机中选择第一个可接受的替代方案。有六种模式：

        <variablelist>
         <varlistentry>
          <term><literal>any</literal>（默认）</term>
          <listitem>
           <para>
            任何成功的连接都是可接受的
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>read-write</literal></term>
          <listitem>
           <para>
            会话必须默认接受读写事务（即，服务器不能处于热备模式，
            并且<varname>default_transaction_read_only</varname>参数必须为<literal>off</literal>）
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>read-only</literal></term>
          <listitem>
           <para>
            会话默认不接受读写事务（相反）
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>primary</literal></term>
          <listitem>
           <para>
            服务器不能处于热备模式
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>standby</literal></term>
          <listitem>
           <para>
            服务器必须处于热备模式
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>prefer-standby</literal></term>
          <listitem>
           <para>
            首先尝试找到一个热备服务器，但如果列出的主机中没有一个是热备服务器，
            则再次尝试<literal>any</literal>模式
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>
<!-- pgdoc-cn_end sig_en=bb1d06c3d848fbec67ec93705e3ce285 -->
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>
 </sect1>

 <sect1 id="libpq-status">
<!-- pgdoc-cn_start sig_en=ff4546b9b91c97df116ec3918bdc9779 sig_cn_org=None source=14.1 
  <title>Connection Status Functions</title>
________________________________________________________-->
  <title>连接状态函数</title>
<!-- pgdoc-cn_end sig_en=ff4546b9b91c97df116ec3918bdc9779 -->

<!-- pgdoc-cn_start sig_en=b456b838db1e67fa92f53e9a00ccf6b6 sig_cn_org=None source=14.1 
  <para>
   These functions can be used to interrogate the status
   of an existing database connection object.
  </para>
________________________________________________________-->
  <para>
   这些函数可以被用来询问一个已有数据库连接对象的状态。
  </para>
<!-- pgdoc-cn_end sig_en=b456b838db1e67fa92f53e9a00ccf6b6 -->

  <tip>
<!-- pgdoc-cn_start sig_en=4946fc6c0c22c21a7cece8439922a0d9 sig_cn_org=None source=14.1 
   <para>
    <indexterm><primary>libpq-fe.h</primary></indexterm>
    <indexterm><primary>libpq-int.h</primary></indexterm>
    <application>libpq</application> application programmers should be careful to
    maintain the <structname>PGconn</structname> abstraction.  Use the accessor
    functions described below to get at the contents of <structname>PGconn</structname>.
    Reference to internal <structname>PGconn</structname> fields using
    <filename>libpq-int.h</filename> is not recommended because they are subject to change
    in the future.
   </para>
________________________________________________________-->
   <para>
    <indexterm><primary>libpq-fe.h</primary></indexterm>
    <indexterm><primary>libpq-int.h</primary></indexterm>
    <application>libpq</application>应用程序员应该小心地维护<structname>PGconn</structname>抽象。使用下面描述的访问函数来理解<structname>PGconn</structname>的内容。我们不推荐使用<filename>libpq-int.h</filename>引用内部的<structname>PGconn</structname>域，因为它们可能在未来改变。
   </para>
<!-- pgdoc-cn_end sig_en=4946fc6c0c22c21a7cece8439922a0d9 -->
  </tip>

<!-- pgdoc-cn_start sig_en=78486a6ba868bf515c09267005b9c0b2 sig_cn_org=None source=14.1 
  <para>
   The following functions return parameter values established at connection.
   These values are fixed for the life of the connection.  If a multi-host
   connection string is used, the values of <xref linkend="libpq-PQhost"/>,
   <xref linkend="libpq-PQport"/>, and <xref linkend="libpq-PQpass"/> can change if a new connection
   is established using the same <structname>PGconn</structname> object.  Other values
   are fixed for the lifetime of the <structname>PGconn</structname> object.

   <variablelist>
    <varlistentry id="libpq-PQdb">
     <term><function>PQdb</function><indexterm><primary>PQdb</primary></indexterm></term>

     <listitem>
      <para>
       Returns the database name of the connection.
<synopsis>
char *PQdb(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQuser">
     <term><function>PQuser</function><indexterm><primary>PQuser</primary></indexterm></term>

     <listitem>
      <para>
       Returns the user name of the connection.
<synopsis>
char *PQuser(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQpass">
     <term><function>PQpass</function><indexterm><primary>PQpass</primary></indexterm></term>

     <listitem>
      <para>
       Returns the password of the connection.
<synopsis>
char *PQpass(const PGconn *conn);
</synopsis>
      </para>

      <para>
       <xref linkend="libpq-PQpass"/> will return either the password specified
       in the connection parameters, or if there was none and the password
       was obtained from the <link linkend="libpq-pgpass">password
       file</link>, it will return that.  In the latter case,
       if multiple hosts were specified in the connection parameters, it is
       not possible to rely on the result of <xref linkend="libpq-PQpass"/> until
       the connection is established.  The status of the connection can be
       checked using the function <xref linkend="libpq-PQstatus"/>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQhost">
     <term><function>PQhost</function><indexterm><primary>PQhost</primary></indexterm></term>

     <listitem>
      <para>
       Returns the server host name of the active connection.
       This can be a host name, an IP address, or a directory path if the
       connection is via Unix socket.  (The path case can be distinguished
       because it will always be an absolute path, beginning
       with <literal>/</literal>.)
<synopsis>
char *PQhost(const PGconn *conn);
</synopsis>
      </para>

      <para>
       If the connection parameters specified both <literal>host</literal> and
       <literal>hostaddr</literal>, then <xref linkend="libpq-PQhost"/> will
       return the <literal>host</literal> information.  If only
       <literal>hostaddr</literal> was specified, then that is returned.
       If multiple hosts were specified in the connection parameters,
       <xref linkend="libpq-PQhost"/> returns the host actually connected to.
      </para>

      <para>
       <xref linkend="libpq-PQhost"/> returns <symbol>NULL</symbol> if the
       <parameter>conn</parameter> argument is <symbol>NULL</symbol>.
       Otherwise, if there is an error producing the host information (perhaps
       if the connection has not been fully established or there was an
       error), it returns an empty string.
      </para>

      <para>
       If multiple hosts were specified in the connection parameters, it is
       not possible to rely on the result of <xref linkend="libpq-PQhost"/> until
       the connection is established.  The status of the connection can be
       checked using the function <xref linkend="libpq-PQstatus"/>.
      </para>
     </listitem>
    </varlistentry>


    <varlistentry id="libpq-PQhostaddr">
     <term><function>PQhostaddr</function><indexterm><primary>PQhostaddr</primary></indexterm></term>

     <listitem>
      <para>
       Returns the server IP address of the active connection.
       This can be the address that a host name resolved to,
       or an IP address provided through the <literal>hostaddr</literal>
       parameter.
<synopsis>
char *PQhostaddr(const PGconn *conn);
</synopsis>
      </para>

      <para>
       <xref linkend="libpq-PQhostaddr"/> returns <symbol>NULL</symbol> if the
       <parameter>conn</parameter> argument is <symbol>NULL</symbol>.
       Otherwise, if there is an error producing the host information
       (perhaps if the connection has not been fully established or
       there was an error), it returns an empty string.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQport">
     <term><function>PQport</function><indexterm><primary>PQport</primary></indexterm></term>

     <listitem>
      <para>
       Returns the port of the active connection.

<synopsis>
char *PQport(const PGconn *conn);
</synopsis>
      </para>

      <para>
       If multiple ports were specified in the connection parameters,
       <xref linkend="libpq-PQport"/> returns the port actually connected to.
      </para>

      <para>
       <xref linkend="libpq-PQport"/> returns <symbol>NULL</symbol> if the
       <parameter>conn</parameter> argument is <symbol>NULL</symbol>.
       Otherwise, if there is an error producing the port information (perhaps
       if the connection has not been fully established or there was an
       error), it returns an empty string.
      </para>

      <para>
       If multiple ports were specified in the connection parameters, it is
       not possible to rely on the result of <xref linkend="libpq-PQport"/> until
       the connection is established.  The status of the connection can be
       checked using the function <xref linkend="libpq-PQstatus"/>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQtty">
     <term><function>PQtty</function><indexterm><primary>PQtty</primary></indexterm></term>

     <listitem>
      <para>
       This function no longer does anything, but it remains for backwards
       compatibility.  The function always return an empty string, or
       <symbol>NULL</symbol> if the <parameter>conn</parameter> argument is
       <symbol>NULL</symbol>.

<synopsis>
char *PQtty(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQoptions">
     <term><function>PQoptions</function><indexterm><primary>PQoptions</primary></indexterm></term>

     <listitem>
      <para>
       Returns the command-line options passed in the connection request.
<synopsis>
char *PQoptions(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
________________________________________________________-->
  <para>
   下列函数返回一个连接所建立的参数值。这些值在连接的生命期中是固定的。
   如果使用的是多主机连接字符串，如果使用同一个<structname>PGconn</structname>对象建立新连接，<xref linkend="libpq-PQhost"/>,<xref linkend="libpq-PQport"/>, 和 <xref linkend="libpq-PQpass"/> 可能会改变。其他值在<structname>PGconn</structname>对象的一生中都是固定的。

   <variablelist>
    <varlistentry id="libpq-PQdb">
     <term><function>PQdb</function><indexterm><primary>PQdb</primary></indexterm></term>

     <listitem>
      <para>
       返回该连接的数据库名。
<synopsis>
char *PQdb(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQuser">
     <term><function>PQuser</function><indexterm><primary>PQuser</primary></indexterm></term>

     <listitem>
      <para>
       返回该连接的用户名。
<synopsis>
char *PQuser(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQpass">
     <term><function>PQpass</function><indexterm><primary>PQpass</primary></indexterm></term>

     <listitem>
      <para>
       返回该连接的口令。
<synopsis>
char *PQpass(const PGconn *conn);
</synopsis>
      </para>

      <para>
       <xref linkend="libpq-PQpass"/>将返回连接参数中指定的口令，如果连接参数中没有口令并且能从<link linkend="libpq-pgpass">口令文件</link>中得到口令，则它将返回得到的口令。
       在后一种情况中，如果连接参数中指定了多个主机，在连接被建立之前都不能依赖<xref linkend="libpq-PQpass"/>的结果。连接的状态可以用函数<xref linkend="libpq-PQpass"/>检查。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQhost">
     <term><function>PQhost</function><indexterm><primary>PQhost</primary></indexterm></term>

     <listitem>
      <para>
       返回活跃连接的服务器主机名。可能是主机名、IP 地址或者一个目录路径（如果通过 Unix 套接字连接，路径的情况很容易区分，因为路径总是一个绝对路径，以<literal>/</literal>开始）。
<synopsis>
char *PQhost(const PGconn *conn);
</synopsis>
      </para>

      <para>
       如果连接参数同时指定了<literal>host</literal>和<literal>hostaddr</literal>，则<xref linkend="libpq-PQhost"/>将返回<literal>host</literal>信息。
       如果仅指定了<literal>hostaddr</literal>，则返回它。如果在连接参数中指定了多个主机，<xref linkend="libpq-PQhost"/>返回实际连接到的主机。
      </para>

      <para>
       如果<parameter>conn</parameter>参数是<symbol>NULL</symbol>，则<xref linkend="libpq-PQhost"/>返回<symbol>NULL</symbol>。否则，如果有一个错误产生主机信息（或许是连接没有被完全建立或者有什么错误），它会返回一个空字符串。
      </para>

      <para>
       如果在连接参数中指定了多个主机，则在连接建立之前都不能依赖于<xref linkend="libpq-PQhost"/>的结果。连接的状态可以用函数<xref linkend="libpq-PQstatus"/>检查。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQhostaddr">
     <term><function>PQhostaddr</function><indexterm><primary>PQhostaddr</primary></indexterm></term>

     <listitem>
      <para>
       返回活动连接的服务器 IP 地址。这可以是主机名解析出的地址，也可以是通过<literal>hostaddr</literal>参数提供的 IP 地址。
<synopsis>
char *PQhostaddr(const PGconn *conn);
</synopsis>
      </para>

      <para>
      如果<parameter>conn</parameter> 参数为 <symbol>NULL</symbol>则 <xref linkend="libpq-PQhostaddr"/> 返回 <symbol>NULL</symbol> 。
      否则，如果生成主机信息时出现错误（如果连接尚未完全建立或出现错误），则返回一个空字符串。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQport">
     <term><function>PQport</function><indexterm><primary>PQport</primary></indexterm></term>

     <listitem>
      <para>
       返回活跃连接的端口。

<synopsis>
char *PQport(const PGconn *conn);
</synopsis>
      </para>

      <para>
       如果在连接参数中指定了多个端口，<xref linkend="libpq-PQport"/>返回实际连接到的端口。
      </para>

      <para>
       如果<parameter>conn</parameter>参数是<symbol>NULL</symbol>，则<xref linkend="libpq-PQport"/>返回<symbol>NULL</symbol>。否则，如果有一个错误产生端口信息（或许是连接没有被完全建立或者有什么错误），它会返回一个空字符串。
      </para>

      <para>
       如果在连接参数中指定了多个端口，则在连接建立之前都不能依赖于<xref linkend="libpq-PQport"/>的结果。连接的状态可以用函数<xref linkend="libpq-PQstatus"/>检查。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQtty">
     <term><function>PQtty</function><indexterm><primary>PQtty</primary></indexterm></term>

     <listitem>
      <para>
       这个函数不再做任何事，但是它保持了向后兼容。
       这个函数总是返回一个空字符串，或者<symbol>NULL</symbol>，如果<parameter>conn</parameter>为<symbol>NULL</symbol>。

<synopsis>
char *PQtty(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQoptions">
     <term><function>PQoptions</function><indexterm><primary>PQoptions</primary></indexterm></term>

     <listitem>
      <para>
       返回被传递给连接请求的命令行选项。
<synopsis>
char *PQoptions(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
<!-- pgdoc-cn_end sig_en=78486a6ba868bf515c09267005b9c0b2 -->

<!-- pgdoc-cn_start sig_en=9a01098fe6a923761a0ce28fa3266a7a sig_cn_org=None source=14.1 
  <para>
   The following functions return status data that can change as operations
   are executed on the <structname>PGconn</structname> object.

   <variablelist>
    <varlistentry id="libpq-PQstatus">
     <term><function>PQstatus</function><indexterm><primary>PQstatus</primary></indexterm></term>

     <listitem>
      <para>
       Returns the status of the connection.
<synopsis>
ConnStatusType PQstatus(const PGconn *conn);
</synopsis>
      </para>

      <para>
       The status can be one of a number of values.  However, only two of
       these are seen outside of an asynchronous connection procedure:
       <literal>CONNECTION_OK</literal> and
       <literal>CONNECTION_BAD</literal>. A good connection to the database
       has the status <literal>CONNECTION_OK</literal>.  A failed
       connection attempt is signaled by status
       <literal>CONNECTION_BAD</literal>.  Ordinarily, an OK status will
       remain so until <xref linkend="libpq-PQfinish"/>, but a communications
       failure might result in the status changing to
       <literal>CONNECTION_BAD</literal> prematurely.  In that case the
       application could try to recover by calling
       <xref linkend="libpq-PQreset"/>.
      </para>

      <para>
       See the entry for <xref linkend="libpq-PQconnectStartParams"/>, <function>PQconnectStart</function>
       and <function>PQconnectPoll</function> with regards to other status codes that
       might be returned.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQtransactionStatus">
     <term><function>PQtransactionStatus</function><indexterm><primary>PQtransactionStatus</primary></indexterm></term>

     <listitem>
      <para>
       Returns the current in-transaction status of the server.

<synopsis>
PGTransactionStatusType PQtransactionStatus(const PGconn *conn);
</synopsis>

       The status can be <literal>PQTRANS_IDLE</literal> (currently idle),
       <literal>PQTRANS_ACTIVE</literal> (a command is in progress),
       <literal>PQTRANS_INTRANS</literal> (idle, in a valid transaction block),
       or <literal>PQTRANS_INERROR</literal> (idle, in a failed transaction block).
       <literal>PQTRANS_UNKNOWN</literal> is reported if the connection is bad.
       <literal>PQTRANS_ACTIVE</literal> is reported only when a query
       has been sent to the server and not yet completed.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQparameterStatus">
     <term><function>PQparameterStatus</function><indexterm><primary>PQparameterStatus</primary></indexterm></term>

     <listitem>
      <para>
       Looks up a current parameter setting of the server.

<synopsis>
const char *PQparameterStatus(const PGconn *conn, const char *paramName);
</synopsis>

       Certain parameter values are reported by the server automatically at
       connection startup or whenever their values change.
       <xref linkend="libpq-PQparameterStatus"/> can be used to interrogate these settings.
       It returns the current value of a parameter if known, or <symbol>NULL</symbol>
       if the parameter is not known.
      </para>

      <para>
       Parameters reported as of the current release include
       <varname>server_version</varname>,
       <varname>server_encoding</varname>,
       <varname>client_encoding</varname>,
       <varname>application_name</varname>,
       <varname>default_transaction_read_only</varname>,
       <varname>in_hot_standby</varname>,
       <varname>is_superuser</varname>,
       <varname>session_authorization</varname>,
       <varname>DateStyle</varname>,
       <varname>IntervalStyle</varname>,
       <varname>TimeZone</varname>,
       <varname>integer_datetimes</varname>, and
       <varname>standard_conforming_strings</varname>.
       (<varname>server_encoding</varname>, <varname>TimeZone</varname>, and
       <varname>integer_datetimes</varname> were not reported by releases before 8.0;
       <varname>standard_conforming_strings</varname> was not reported by releases
       before 8.1;
       <varname>IntervalStyle</varname> was not reported by releases before 8.4;
       <varname>application_name</varname> was not reported by releases before
       9.0;
       <varname>default_transaction_read_only</varname> and
       <varname>in_hot_standby</varname> were not reported by releases before
       14.)
       Note that
       <varname>server_version</varname>,
       <varname>server_encoding</varname> and
       <varname>integer_datetimes</varname>
       cannot change after startup.
      </para>

      <para>
       If no value for <varname>standard_conforming_strings</varname> is reported,
       applications can assume it is <literal>off</literal>, that is, backslashes
       are treated as escapes in string literals.  Also, the presence of
       this parameter can be taken as an indication that the escape string
       syntax (<literal>E'...'</literal>) is accepted.
      </para>

      <para>
       Although the returned pointer is declared <literal>const</literal>, it in fact
       points to mutable storage associated with the <literal>PGconn</literal> structure.
       It is unwise to assume the pointer will remain valid across queries.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQprotocolVersion">
     <term><function>PQprotocolVersion</function><indexterm><primary>PQprotocolVersion</primary></indexterm></term>

     <listitem>
      <para>
       Interrogates the frontend/backend protocol being used.
<synopsis>
int PQprotocolVersion(const PGconn *conn);
</synopsis>
       Applications might wish to use this function to determine whether certain
       features are supported.  Currently, the possible values are 3
       (3.0 protocol), or zero (connection bad).  The protocol version will
       not change after connection startup is complete, but it could
       theoretically change during a connection reset.  The 3.0 protocol is
       supported by <productname>PostgreSQL</productname> server versions 7.4
       and above.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQserverVersion">
     <term><function>PQserverVersion</function><indexterm><primary>PQserverVersion</primary></indexterm></term>

     <listitem>
      <para>
       Returns an integer representing the server version.
<synopsis>
int PQserverVersion(const PGconn *conn);
</synopsis>
      </para>

      <para>
       Applications might use this function to determine the version of the
       database server they are connected to.  The result is formed by
       multiplying the server's major version number by 10000 and adding
       the minor version number.  For example, version 10.1 will be
       returned as 100001, and version 11.0 will be returned as 110000.
       Zero is returned if the connection is bad.
      </para>

      <para>
       Prior to major version 10, <productname>PostgreSQL</productname> used
       three-part version numbers in which the first two parts together
       represented the major version.  For those
       versions, <xref linkend="libpq-PQserverVersion"/> uses two digits for each
       part; for example version 9.1.5 will be returned as 90105, and
       version 9.2.0 will be returned as 90200.
      </para>

      <para>
       Therefore, for purposes of determining feature compatibility,
       applications should divide the result of <xref linkend="libpq-PQserverVersion"/>
       by 100 not 10000 to determine a logical major version number.
       In all release series, only the last two digits differ between
       minor releases (bug-fix releases).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQerrorMessage">
     <term><function>PQerrorMessage</function><indexterm><primary>PQerrorMessage</primary></indexterm></term>

     <listitem>
      <para>
       <indexterm><primary>error message</primary></indexterm> Returns the error message
       most recently generated by an operation on the connection.

<synopsis>
char *PQerrorMessage(const PGconn *conn);
</synopsis>

      </para>

      <para>
       Nearly all <application>libpq</application> functions will set a message for
       <xref linkend="libpq-PQerrorMessage"/> if they fail.  Note that by
       <application>libpq</application> convention, a nonempty
       <xref linkend="libpq-PQerrorMessage"/> result can consist of multiple lines,
       and will include a trailing newline. The caller should not free
       the result directly. It will be freed when the associated
       <structname>PGconn</structname> handle is passed to
       <xref linkend="libpq-PQfinish"/>.  The result string should not be
       expected to remain the same across operations on the
       <literal>PGconn</literal> structure.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQsocket">
     <term><function>PQsocket</function><indexterm><primary>PQsocket</primary></indexterm></term>
     <listitem>
      <para>
       Obtains the file descriptor number of the connection socket to
       the server.  A valid descriptor will be greater than or equal
       to 0; a result of -1 indicates that no server connection is
       currently open.  (This will not change during normal operation,
       but could change during connection setup or reset.)

<synopsis>
int PQsocket(const PGconn *conn);
</synopsis>

      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQbackendPID">
     <term><function>PQbackendPID</function><indexterm><primary>PQbackendPID</primary></indexterm></term>
     <listitem>
      <para>
       Returns the process <acronym>ID</acronym> (PID)<indexterm>
        <primary>PID</primary>
        <secondary>determining PID of server process</secondary>
        <tertiary>in libpq</tertiary>
       </indexterm>
       of the backend process handling this connection.

<synopsis>
int PQbackendPID(const PGconn *conn);
</synopsis>
      </para>

      <para>
       The backend <acronym>PID</acronym> is useful for debugging
       purposes and for comparison to <command>NOTIFY</command>
       messages (which include the <acronym>PID</acronym> of the
       notifying backend process).  Note that the
       <acronym>PID</acronym> belongs to a process executing on the
       database server host, not the local host!
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQconnectionNeedsPassword">
     <term><function>PQconnectionNeedsPassword</function><indexterm><primary>PQconnectionNeedsPassword</primary></indexterm></term>
     <listitem>
      <para>
       Returns true (1) if the connection authentication method
       required a password, but none was available.
       Returns false (0) if not.

<synopsis>
int PQconnectionNeedsPassword(const PGconn *conn);
</synopsis>
      </para>

      <para>
       This function can be applied after a failed connection attempt
       to decide whether to prompt the user for a password.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQconnectionUsedPassword">
     <term><function>PQconnectionUsedPassword</function><indexterm><primary>PQconnectionUsedPassword</primary></indexterm></term>
     <listitem>
      <para>
       Returns true (1) if the connection authentication method
       used a password. Returns false (0) if not.

<synopsis>
int PQconnectionUsedPassword(const PGconn *conn);
</synopsis>
      </para>

      <para>
       This function can be applied after either a failed or successful
       connection attempt to detect whether the server demanded a password.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
________________________________________________________-->
  <para>
   下列函数返回会随着在<structname>PGconn</structname>对象上执行的操作改变的状态数据。

   <variablelist>
    <varlistentry id="libpq-PQstatus">
     <term><function>PQstatus</function><indexterm><primary>PQstatus</primary></indexterm></term>

     <listitem>
      <para>
       返回该连接的状态。
<synopsis>
ConnStatusType PQstatus(const PGconn *conn);
</synopsis>
      </para>

      <para>
       该状态可以是一系列值之一。不过，其中只有两个在一个异步连接过程之外可见：<literal>CONNECTION_OK</literal>和<literal>CONNECTION_BAD</literal>。
       一个到数据库的完好连接的状态为<literal>CONNECTION_OK</literal>。一个失败的连接尝试则由状态<literal>CONNECTION_BAD</literal>表示。
       通常，一个 OK 状态将一直保持到<xref linkend="libpq-PQfinish"/>，但是一次通信失败可能导致该状态过早地改变为<literal>CONNECTION_BAD</literal>。
       在那种情况下，该应用可以通过调用<xref linkend="libpq-PQreset"/>尝试恢复。
      </para>

      <para>
       关于其他可能会被返回的状态代码，请见<xref linkend="libpq-PQconnectStartParams"/>、<function>PQconnectStart</function>和<function>PQconnectPoll</function>的条目。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQtransactionStatus">
     <term><function>PQtransactionStatus</function><indexterm><primary>PQtransactionStatus</primary></indexterm></term>

     <listitem>
      <para>
       返回服务器的当前事务内状态。

<synopsis>
PGTransactionStatusType PQtransactionStatus(const PGconn *conn);
</synopsis>

       该状态可能是<literal>PQTRANS_IDLE</literal>（当前空闲）、<literal>PQTRANS_ACTIVE</literal>（一个命令运行中）、<literal>PQTRANS_INTRANS</literal>（空闲，处于一个合法的事务块中）或者<literal>PQTRANS_INERROR</literal>（空闲，处于一个失败的事务块中）。如果该连接损坏，将会报告<literal>PQTRANS_UNKNOWN</literal>。只有当一个查询已经被发送给服务器并且还没有完成时，才会报告<literal>PQTRANS_ACTIVE</literal>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQparameterStatus">
     <term><function>PQparameterStatus</function><indexterm><primary>PQparameterStatus</primary></indexterm></term>

     <listitem>
      <para>
       查找服务器的一个当前参数设置。

<synopsis>
const char *PQparameterStatus(const PGconn *conn, const char *paramName);
</synopsis>

       某一参数值会被服务器在连接开始或值改变时自动报告。<xref linkend="libpq-PQparameterStatus"/>可以被用来询问这些设置。它为已知的参数返回当前值，为未知的参数返回<symbol>NULL</symbol>。
      </para>

      <para>
       自当前发布开始会被报告的参数包括
       <varname>server_version</varname>、
       <varname>server_encoding</varname>、
       <varname>client_encoding</varname>、
       <varname>application_name</varname>、
       <varname>default_transaction_read_only</varname>,
       <varname>in_hot_standby</varname>,
       <varname>is_superuser</varname>、
       <varname>session_authorization</varname>、
       <varname>DateStyle</varname>、
       <varname>IntervalStyle</varname>、
       <varname>TimeZone</varname>、
       <varname>integer_datetimes</varname>以及
       <varname>standard_conforming_strings</varname>。
       （<varname>server_encoding</varname>、<varname>TimeZone</varname>以及<varname>integer_datetimes</varname>在 8.0 以前的发布中不被报告；
       <varname>standard_conforming_strings</varname>在 8.1 以前的发布中不被报告；
       <varname>IntervalStyle</varname>在 8.4 以前的发布中不被报告；
       <varname>application_name</varname>在 9.0 以前的发布中不被报告；
       <varname>default_transaction_read_only</varname> 和 <varname>in_hot_standby</varname> 再14以前的发布中不被报告）
       注意 <varname>server_version</varname>、
       <varname>server_encoding</varname>以及
       <varname>integer_datetimes</varname>在启动之后无法改变。
      </para>

      <para>
       如果没有为<varname>standard_conforming_strings</varname>报告值，应用能假设它是<literal>off</literal>，也就是说反斜线会被视为字符串中的转义。还有，这个参数的存在可以被作为转义字符串语法（<literal>E'...'</literal>）被接受的指示。
      </para>

      <para>
       尽管被返回的指针被声明成<literal>const</literal>，它事实上指向与<literal>PGconn</literal>结构相关的可变存储。假定该指针在存储之间保持有效是不明智的。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQprotocolVersion">
     <term><function>PQprotocolVersion</function><indexterm><primary>PQprotocolVersion</primary></indexterm></term>

     <listitem>
      <para>
       询问所使用的 前端/后端协议。
<synopsis>
int PQprotocolVersion(const PGconn *conn);
</synopsis>
       应用可能希望用这个函数来确定某些特性是否被支持。当前，可能值是3（3.0 协议）或零（连接损坏）。
       协议版本在连接启动完成后将不会改变，但是理论上在连接重置期间是可以改变的。
       3.0 协议被<productname>PostgreSQL</productname> 7.4 或以后的服务器版本所支持。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQserverVersion">
     <term><function>PQserverVersion</function><indexterm><primary>PQserverVersion</primary></indexterm></term>

     <listitem>
      <para>
       返回一个表示服务器版本的整数。
<synopsis>
int PQserverVersion(const PGconn *conn);
</synopsis>
      </para>

      <para>
       应用可能会使用这个函数来判断它们连接到的数据库服务器的版本。结果通过将服务器的主版本号乘以10000再加上次版本号形成。例如，版本10.1将被返回为100001，而版本11.0将被返回为110000。如果连接无效则返回零。
      </para>

      <para>
       在主版本10之前，<productname>PostgreSQL</productname>采用一种由三个部分组成的版本号，其中前两部分共同表示主版本。对于那些版本，<xref linkend="libpq-PQserverVersion"/>为每个部分使用两个数字，例如版本9.1.5将被返回为90105，而版本9.2.0将被返回为90200。
      </para>

      <para>
       因此，出于判断特性兼容性的目的，应用应该将<xref linkend="libpq-PQserverVersion"/>的结果除以100而不是10000来判断逻辑的主版本号。在所有的发行序列中，只有最后两个数字在次发行（问题修正发行）之间不同。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQerrorMessage">
     <term><function>PQerrorMessage</function><indexterm><primary>PQerrorMessage</primary></indexterm></term>

     <listitem>
      <para>
       <indexterm><primary>错误消息</primary></indexterm>返回连接上的一个操作最近产生的错误消息。

<synopsis>
char *PQerrorMessage(const PGconn *conn);
</synopsis>

      </para>

      <para>
       几乎所有的<application>libpq</application>在失败时都会为<xref linkend="libpq-PQerrorMessage"/>设置一个消息。
       注意按照<application>libpq</application>习惯，一个非空<xref linkend="libpq-PQerrorMessage"/>结果由多行构成，并且将包括一个尾部新行。
       调用者不应该直接释放结果。当相关的<structname>PGconn</structname>句柄被传递给<xref linkend="libpq-PQfinish"/>时，它将被释放。在<literal>PGconn</literal>结构上的多个操作之间，不能指望结果字符串会保持不变。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQsocket">
     <term><function>PQsocket</function><indexterm><primary>PQsocket</primary></indexterm></term>
     <listitem>
      <para>
       获得到服务器连接套接字的文件描述符号。一个合法的描述符将会大于等于零。结果为 -1 表示当前没有打开服务器连接（在普通操作期间这将不会改变，但是在连接设置或重置期间可能改变）。

<synopsis>
int PQsocket(const PGconn *conn);
</synopsis>

      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQbackendPID">
     <term><function>PQbackendPID</function><indexterm><primary>PQbackendPID</primary></indexterm></term>
     <listitem>
      <para>
       返回处理这个连接的后端进程的进程<acronym>ID</acronym>（PID）。<indexterm>
        <primary>PID</primary>
        <secondary>确定服务器进程的 PID</secondary>
        <tertiary>in libpq</tertiary>
       </indexterm>

<synopsis>
int PQbackendPID(const PGconn *conn);
</synopsis>
      </para>

      <para>
       后端<acronym>PID</acronym>有助于调试目的并且可用于与<command>NOTIFY</command>消息（它包括发出提示的后端进程的<acronym>PID</acronym>）进行比较。注意<acronym>PID</acronym>属于一个在数据库服务器主机上执行的进程，而不是本地主机进程！
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQconnectionNeedsPassword">
     <term><function>PQconnectionNeedsPassword</function><indexterm><primary>PQconnectionNeedsPassword</primary></indexterm></term>
     <listitem>
      <para>
       如果连接认证方法要求一个口令但没有可用的口令，返回真（1）。否则返回假（0）。

<synopsis>
int PQconnectionNeedsPassword(const PGconn *conn);
</synopsis>
      </para>

      <para>
       这个函数可以在连接尝试失败后被应用于决定是否向用户提示要求一个口令。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQconnectionUsedPassword">
     <term><function>PQconnectionUsedPassword</function><indexterm><primary>PQconnectionUsedPassword</primary></indexterm></term>
     <listitem>
      <para>
       如果连接认证方法使用一个口令，返回真（1）。否则返回假（0）。

<synopsis>
int PQconnectionUsedPassword(const PGconn *conn);
</synopsis>
      </para>

      <para>
       这个函数能在一次连接尝试失败或成功后用于检测该服务器是否要求一个口令。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
<!-- pgdoc-cn_end sig_en=9a01098fe6a923761a0ce28fa3266a7a -->

<!-- pgdoc-cn_start sig_en=c9ccb2a91d53470d953afe497fd56ec7 sig_cn_org=59bf19804b6c05e90d18e4999f78667f source=15.7 
  <para>
    The following functions return information related to SSL. This information
    usually doesn't change after a connection is established.

    <variablelist>
    <varlistentry id="libpq-PQsslInUse">
________________________________________________________-->
  <para>
    以下函数返回与SSL相关的信息。这些信息通常在建立连接后不会更改。

    <variablelist>
    <varlistentry id="libpq-PQsslInUse">
<!-- pgdoc-cn_end sig_en=c9ccb2a91d53470d953afe497fd56ec7 -->
<!-- pgdoc-cn_start sig_en=d29dd92d62cd3204128f791970daf1ed sig_cn_org=d29dd92d62cd3204128f791970daf1ed source=15.7 
     <term><function>PQsslInUse</function><indexterm><primary>PQsslInUse</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQsslInUse</function><indexterm><primary>PQsslInUse</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=d29dd92d62cd3204128f791970daf1ed -->
     <listitem>
<!-- pgdoc-cn_start sig_en=d63a4df1b26d411dcdf4cf59af0d4af4 sig_cn_org=1039f304322de5cc72d07d3436f76c06 source=15.7 
      <para>
        Returns true (1) if the connection uses SSL, false (0) if not.

<synopsis>
int PQsslInUse(const PGconn *conn);
</synopsis>
      </para>
________________________________________________________-->
      <para>
        返回true（1）如果连接使用SSL，返回false（0）如果不使用。

<synopsis>
int PQsslInUse(const PGconn *conn);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=d63a4df1b26d411dcdf4cf59af0d4af4 -->

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQsslAttribute">
<!-- pgdoc-cn_start sig_en=2c3838767e3854660500c04b8657ec0f sig_cn_org=2c3838767e3854660500c04b8657ec0f source=15.7 
     <term><function>PQsslAttribute</function><indexterm><primary>PQsslAttribute</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQsslAttribute</function><indexterm><primary>PQsslAttribute</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=2c3838767e3854660500c04b8657ec0f -->
     <listitem>
<!-- pgdoc-cn_start sig_en=436a9d0c25001aac8a19a1c081254be9 sig_cn_org=4c2d699ed547b13993feed1ceec6ea3f source=15.7 
      <para>
        Returns SSL-related information about the connection.

<synopsis>
const char *PQsslAttribute(const PGconn *conn, const char *attribute_name);
</synopsis>
      </para>
________________________________________________________-->
      <para>
        返回与连接相关的SSL信息。

<synopsis>
const char *PQsslAttribute(const PGconn *conn, const char *attribute_name);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=436a9d0c25001aac8a19a1c081254be9 -->

<!-- pgdoc-cn_start sig_en=0b0cf22819e789e5f9fd9f6b8848e481 sig_cn_org=874099d7e536cbf2000bbe73d9eb44e7 source=15.7 
      <para>
       The list of available attributes varies depending on the SSL library
       being used and the type of connection.  Returns NULL if the connection
       does not use SSL or the specified attribute name is not defined for the
       library in use.
      </para>
________________________________________________________-->
      <para>
       可用属性列表因使用的SSL库和连接类型而异。如果连接不使用SSL或指定的属性名称对于所使用的库未定义，则返回NULL。
      </para>
<!-- pgdoc-cn_end sig_en=0b0cf22819e789e5f9fd9f6b8848e481 -->

<!-- pgdoc-cn_start sig_en=08eeaa5314d3b3d21e6b1bb631bd6575 sig_cn_org=6f4ff5936a57e5f8eddde544cc5a795f source=15.7 
      <para>
       The following attributes are commonly available:
       <variablelist>
        <varlistentry>
         <term><literal>library</literal></term>
          <listitem>
           <para>
            Name of the SSL implementation in use. (Currently, only
            <literal>"OpenSSL"</literal> is implemented)
           </para>
          </listitem>
         </varlistentry>
        <varlistentry>
         <term><literal>protocol</literal></term>
          <listitem>
           <para>
             SSL/TLS version in use. Common values
             are <literal>"TLSv1"</literal>, <literal>"TLSv1.1"</literal>
             and <literal>"TLSv1.2"</literal>, but an implementation may
             return other strings if some other protocol is used.
           </para>
          </listitem>
         </varlistentry>
        <varlistentry>
         <term><literal>key_bits</literal></term>
          <listitem>
           <para>
            Number of key bits used by the encryption algorithm.
           </para>
          </listitem>
         </varlistentry>
        <varlistentry>
         <term><literal>cipher</literal></term>
          <listitem>
           <para>
            A short name of the ciphersuite used, e.g.,
            <literal>"DHE-RSA-DES-CBC3-SHA"</literal>. The names are specific
            to each SSL implementation.
           </para>
          </listitem>
         </varlistentry>
        <varlistentry>
         <term><literal>compression</literal></term>
          <listitem>
           <para>
            Returns "on" if SSL compression is in use, else it returns "off".
           </para>
          </listitem>
         </varlistentry>
       </variablelist>
      </para>
________________________________________________________-->
      <para>
       常见的属性如下：
       <variablelist>
        <varlistentry>
         <term><literal>library</literal></term>
          <listitem>
           <para>
            使用的SSL实现的名称。（目前只实现了<literal>"OpenSSL"</literal>）
           </para>
          </listitem>
         </varlistentry>
        <varlistentry>
         <term><literal>protocol</literal></term>
          <listitem>
           <para>
             使用的SSL/TLS版本。常见值为<literal>"TLSv1"</literal>、<literal>"TLSv1.1"</literal>
             和<literal>"TLSv1.2"</literal>，但如果使用其他协议，则实现可能返回其他字符串。
           </para>
          </listitem>
         </varlistentry>
        <varlistentry>
         <term><literal>key_bits</literal></term>
          <listitem>
           <para>
            加密算法使用的密钥位数。
           </para>
          </listitem>
         </varlistentry>
        <varlistentry>
         <term><literal>cipher</literal></term>
          <listitem>
           <para>
            使用的密码套件的简称，例如<literal>"DHE-RSA-DES-CBC3-SHA"</literal>。这些名称特定于每个SSL实现。
           </para>
          </listitem>
         </varlistentry>
        <varlistentry>
         <term><literal>compression</literal></term>
          <listitem>
           <para>
            如果使用SSL压缩，则返回"on"，否则返回"off"。
           </para>
          </listitem>
         </varlistentry>
       </variablelist>
      </para>
<!-- pgdoc-cn_end sig_en=08eeaa5314d3b3d21e6b1bb631bd6575 -->

<!-- pgdoc-cn_start sig_en=3d613023ef28ce00c0ceeec58dc2f3b2 sig_cn_org=b225d8fd300a05ca5de5f34852e6376c source=15.7 
      <para>
       As a special case, the <literal>library</literal> attribute may be
       queried without a connection by passing NULL as
       the <literal>conn</literal> argument.  The result will be the default
       SSL library name, or NULL if <application>libpq</application> was
       compiled without any SSL support.  (Prior
       to <productname>PostgreSQL</productname> version 15, passing NULL as
       the <literal>conn</literal> argument always resulted in NULL.
       Client programs needing to differentiate between the newer and older
       implementations of this case may check the
       <literal>LIBPQ_HAS_SSL_LIBRARY_DETECTION</literal> feature macro.)
      </para>
________________________________________________________-->
      <para>
       作为一个特例，可以在没有连接的情况下通过将NULL作为<literal>conn</literal>参数来查询<literal>library</literal>属性。
       结果将是默认的SSL库名称，或者如果<application>libpq</application>在没有任何SSL支持的情况下编译，则为NULL。
       （在<productname>PostgreSQL</productname>版本15之前，将NULL作为<literal>conn</literal>参数传递总是导致NULL。
       需要区分这种情况的新旧实现的客户端程序可以检查<literal>LIBPQ_HAS_SSL_LIBRARY_DETECTION</literal>特征宏。）
      </para>
<!-- pgdoc-cn_end sig_en=3d613023ef28ce00c0ceeec58dc2f3b2 -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQsslAttributeNames">
<!-- pgdoc-cn_start sig_en=a9e27c0e5fb703811321552767b333e3 sig_cn_org=a9e27c0e5fb703811321552767b333e3 source=15.7 
     <term><function>PQsslAttributeNames</function><indexterm><primary>PQsslAttributeNames</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQsslAttributeNames</function><indexterm><primary>PQsslAttributeNames</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=a9e27c0e5fb703811321552767b333e3 -->
     <listitem>
<!-- pgdoc-cn_start sig_en=952de88ee7d6f7e657093c305dd96220 sig_cn_org=d66a4d258263c57dc560b5c34fd248f1 source=15.7 
      <para>
       Returns an array of SSL attribute names available.
       The array is terminated by a NULL pointer.
<synopsis>
const char * const * PQsslAttributeNames(const PGconn *conn);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       返回可用的SSL属性名称数组。
       数组以NULL指针结尾。
<synopsis>
const char * const * PQsslAttributeNames(const PGconn *conn);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=952de88ee7d6f7e657093c305dd96220 -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQsslStruct">
<!-- pgdoc-cn_start sig_en=313bdba4365d608ee95059243cf0cc14 sig_cn_org=313bdba4365d608ee95059243cf0cc14 source=15.7 
     <term><function>PQsslStruct</function><indexterm><primary>PQsslStruct</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQsslStruct</function><indexterm><primary>PQsslStruct</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=313bdba4365d608ee95059243cf0cc14 -->
     <listitem>
<!-- pgdoc-cn_start sig_en=8ee5dec6a7449a51f972581a0febb683 sig_cn_org=0a1b07d8f4bf2dc6c659c7bcccf3127e source=15.7 
      <para>
       Returns a pointer to an SSL-implementation-specific object describing
       the connection.  Returns NULL if the connection is not encrypted
       or the requested type of object is not available from the connection's
       SSL implementation.
<synopsis>
void *PQsslStruct(const PGconn *conn, const char *struct_name);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       返回一个指向描述连接的SSL实现特定对象的指针。如果连接未加密或SSL实现不提供连接的请求对象类型，则返回NULL。
<synopsis>
void *PQsslStruct(const PGconn *conn, const char *struct_name);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=8ee5dec6a7449a51f972581a0febb683 -->
<!-- pgdoc-cn_start sig_en=3721edfad053bcd79a9353150efac098 sig_cn_org=4b487dcbb1c950250a9b9653450a68d4 source=15.7 
      <para>
       The struct(s) available depend on the SSL implementation in use.
       For <productname>OpenSSL</productname>, there is one struct,
       available under the name <literal>OpenSSL</literal>,
       and it returns a pointer to
       <productname>OpenSSL</productname>'s <literal>SSL</literal> struct.
       To use this function, code along the following lines could be used:
<programlisting><![CDATA[
#include <libpq-fe.h>
#include <openssl/ssl.h>

...

    SSL *ssl;

    dbconn = PQconnectdb(...);
    ...

    ssl = PQsslStruct(dbconn, "OpenSSL");
    if (ssl)
    {
        /* use OpenSSL functions to access ssl */
    }
]]></programlisting>
      </para>
________________________________________________________-->
      <para>
       可用的结构体取决于正在使用的SSL实现。
       对于<productname>OpenSSL</productname>，有一个结构体，
       可以通过名称<literal>OpenSSL</literal>获得，
       并返回一个指向<productname>OpenSSL</productname>的<literal>SSL</literal>结构体的指针。
       要使用这个函数，可以使用以下代码：
<programlisting><![CDATA[
#include <libpq-fe.h>
#include <openssl/ssl.h>

...

    SSL *ssl;

    dbconn = PQconnectdb(...);
    ...

    ssl = PQsslStruct(dbconn, "OpenSSL");
    if (ssl)
    {
        /* 使用OpenSSL函数访问ssl */
    }
]]></programlisting>
      </para>
<!-- pgdoc-cn_end sig_en=3721edfad053bcd79a9353150efac098 -->
<!-- pgdoc-cn_start sig_en=25b80e5b86bb08e349527266680d4c9e sig_cn_org=52b17b6eb97ed55559d5e1af1f1210ec source=15.7 
      <para>
       This structure can be used to verify encryption levels, check server
       certificates, and more. Refer to the <productname>OpenSSL</productname>
       documentation for information about this structure.
      </para>
________________________________________________________-->
      <para>
       这个结构可用于验证加密级别，检查服务器证书等。请参考<productname>OpenSSL</productname>
       文档以获取有关此结构的信息。
      </para>
<!-- pgdoc-cn_end sig_en=25b80e5b86bb08e349527266680d4c9e -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQgetssl">
<!-- pgdoc-cn_start sig_en=1bac5d2fc5f471715060f6f8a90813f0 sig_cn_org=1bac5d2fc5f471715060f6f8a90813f0 source=15.7 
     <term><function>PQgetssl</function><indexterm><primary>PQgetssl</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQgetssl</function><indexterm><primary>PQgetssl</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=1bac5d2fc5f471715060f6f8a90813f0 -->
     <listitem>
<!-- pgdoc-cn_start sig_en=6615fdd8a1ea427a40476588eb3e6703 sig_cn_org=dce58af6b797f38f49e1c0f9c43abf03 source=15.7 
      <para>
       <indexterm><primary>SSL</primary><secondary sortas="libpq">in libpq</secondary></indexterm>
       Returns the SSL structure used in the connection, or NULL
       if SSL is not in use.

<synopsis>
void *PQgetssl(const PGconn *conn);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       <indexterm><primary>SSL</primary><secondary sortas="libpq">在libpq中</secondary></indexterm>
       返回在连接中使用的SSL结构，如果未使用SSL，则返回NULL。

<synopsis>
void *PQgetssl(const PGconn *conn);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=6615fdd8a1ea427a40476588eb3e6703 -->

<!-- pgdoc-cn_start sig_en=d651167ed67f6f6ec07ab01d7a8aa7b2 sig_cn_org=18b70069e7fd5631ceae3b9392e890a3 source=15.7 
      <para>
       This function is equivalent to <literal>PQsslStruct(conn, "OpenSSL")</literal>. It should
       not be used in new applications, because the returned struct is
       specific to <productname>OpenSSL</productname> and will not be
       available if another <acronym>SSL</acronym> implementation is used.
       To check if a connection uses SSL, call
       <xref linkend="libpq-PQsslInUse"/> instead, and for more details about the
       connection, use <xref linkend="libpq-PQsslAttribute"/>.
      </para>
________________________________________________________-->
      <para>
       这个函数等同于<literal>PQsslStruct(conn, "OpenSSL")</literal>。不应该在新应用程序中使用，
       因为返回的结构特定于<productname>OpenSSL</productname>，如果使用另一个<acronym>SSL</acronym>实现，
       则不可用。要检查连接是否使用SSL，请调用<xref linkend="libpq-PQsslInUse"/>，
       要获取有关连接的更多详细信息，请使用<xref linkend="libpq-PQsslAttribute"/>。
      </para>
<!-- pgdoc-cn_end sig_en=d651167ed67f6f6ec07ab01d7a8aa7b2 -->
     </listitem>
    </varlistentry>

   </variablelist>
  </para>

 </sect1>

 <sect1 id="libpq-exec">
<!-- pgdoc-cn_start sig_en=099063028e2847142bf2edf3683acfc6 sig_cn_org=None source=14.1 
  <title>Command Execution Functions</title>
________________________________________________________-->
  <title>命令执行函数</title>
<!-- pgdoc-cn_end sig_en=099063028e2847142bf2edf3683acfc6 -->

<!-- pgdoc-cn_start sig_en=009bf5d0c232b6cb9979c105b9b4f61a sig_cn_org=None source=14.1 
  <para>
   Once a connection to a database server has been successfully
   established, the functions described here are used to perform
   SQL queries and commands.
  </para>
________________________________________________________-->
  <para>
   一旦到一个数据库服务器的连接被成功建立，这里描述的函数可以被用来执行 SQL 查询和命令。
  </para>
<!-- pgdoc-cn_end sig_en=009bf5d0c232b6cb9979c105b9b4f61a -->

  <sect2 id="libpq-exec-main">
<!-- pgdoc-cn_start sig_en=d7c9aa8497269c48a0ab9927c1836837 sig_cn_org=None source=14.1 
   <title>Main Functions</title>
________________________________________________________-->
   <title>主要函数</title>
<!-- pgdoc-cn_end sig_en=d7c9aa8497269c48a0ab9927c1836837 -->

<!-- pgdoc-cn_start sig_en=11c5a3200c2b0e041cb5e3479953f90b sig_cn_org=None source=14.1 
   <para>
    <variablelist>
     <varlistentry id="libpq-PQexec">
      <term><function>PQexec</function><indexterm><primary>PQexec</primary></indexterm></term>

      <listitem>
       <para>
        Submits a command to the server and waits for the result.

<synopsis>
PGresult *PQexec(PGconn *conn, const char *command);
</synopsis>
       </para>

       <para>
        Returns a <structname>PGresult</structname> pointer or possibly a null
        pointer.  A non-null pointer will generally be returned except in
        out-of-memory conditions or serious errors such as inability to send
        the command to the server.  The <xref linkend="libpq-PQresultStatus"/> function
        should be called to check the return value for any errors (including
        the value of a null pointer, in which case it will return
        <symbol>PGRES_FATAL_ERROR</symbol>).  Use
        <xref linkend="libpq-PQerrorMessage"/> to get more information about such
        errors.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    The command string can include multiple SQL commands
    (separated by semicolons).  Multiple queries sent in a single
    <xref linkend="libpq-PQexec"/> call are processed in a single transaction, unless
    there are explicit <command>BEGIN</command>/<command>COMMIT</command>
    commands included in the query string to divide it into multiple
    transactions.  (See <xref linkend="protocol-flow-multi-statement"/>
    for more details about how the server handles multi-query strings.)
    Note however that the returned
    <structname>PGresult</structname> structure describes only the result
    of the last command executed from the string.  Should one of the
    commands fail, processing of the string stops with it and the returned
    <structname>PGresult</structname> describes the error condition.
   </para>
________________________________________________________-->
   <para>
    <variablelist>
     <varlistentry id="libpq-PQexec">
      <term><function>PQexec</function><indexterm><primary>PQexec</primary></indexterm></term>

      <listitem>
       <para>
        提交一个命令给服务器并且等待结果。

<synopsis>
PGresult *PQexec(PGconn *conn, const char *command);
</synopsis>
       </para>

       <para>
        返回一个<structname>PGresult</structname>指针或者可能是一个空指针。
        除了内存不足的情况或者由于严重错误无法将命令发送给服务器之外，一般都会返回一个非空指针。
        <xref linkend="libpq-PQresultStatus"/>函数应当被调用来检查返回值是否代表错误（包括空指针的值，它会返回<symbol>PGRES_FATAL_ERROR</symbol>）。
        用<xref linkend="libpq-PQerrorMessage"/>可得到关于那些错误的详细信息。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    命令字符串可以包括多个 SQL 命令（用分号分隔）。
    在一次<xref linkend="libpq-PQexec"/>调用中被发送的多个查询会在一个事务中处理，除非其中有显式的<command>BEGIN</command>/<command>COMMIT</command>命令将该查询字符串划分成多个事务（服务器如何处理多查询字符串的更多细节请参考<xref linkend="protocol-flow-multi-statement"/>）。
    但是注意，返回的<structname>PGresult</structname>结构只描述该字符串中被执行的最后一个命令的结果。
    如果一个命令失败，该字符串的处理会在它那里停止并且返回的<structname>PGresult</structname>会描述错误情况。
   </para>
<!-- pgdoc-cn_end sig_en=11c5a3200c2b0e041cb5e3479953f90b -->

<!-- pgdoc-cn_start sig_en=3c96090d8b52692abcc3b8f397d0522f sig_cn_org=None source=14.1 
   <para>
    <variablelist>
     <varlistentry id="libpq-PQexecParams">
      <term><function>PQexecParams</function><indexterm><primary>PQexecParams</primary></indexterm></term>

      <listitem>
       <para>
        Submits a command to the server and waits for the result,
        with the ability to pass parameters separately from the SQL
        command text.

<synopsis>
PGresult *PQexecParams(PGconn *conn,
                       const char *command,
                       int nParams,
                       const Oid *paramTypes,
                       const char * const *paramValues,
                       const int *paramLengths,
                       const int *paramFormats,
                       int resultFormat);
</synopsis>
       </para>

       <para>
        <xref linkend="libpq-PQexecParams"/> is like <xref linkend="libpq-PQexec"/>, but offers additional
        functionality: parameter values can be specified separately from the command
        string proper, and query results can be requested in either text or binary
        format.
       </para>

       <para>
        The function arguments are:

        <variablelist>
         <varlistentry>
          <term><parameter>conn</parameter></term>

          <listitem>
           <para>
            The connection object to send the command through.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>command</parameter></term>
          <listitem>
           <para>
            The SQL command string to be executed. If parameters are used,
            they are referred to in the command string as <literal>$1</literal>,
            <literal>$2</literal>, etc.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>nParams</parameter></term>
          <listitem>
           <para>
            The number of parameters supplied; it is the length of the arrays
            <parameter>paramTypes[]</parameter>, <parameter>paramValues[]</parameter>,
            <parameter>paramLengths[]</parameter>, and <parameter>paramFormats[]</parameter>. (The
            array pointers can be <symbol>NULL</symbol> when <parameter>nParams</parameter>
            is zero.)
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>paramTypes[]</parameter></term>
          <listitem>
           <para>
            Specifies, by OID, the data types to be assigned to the
            parameter symbols.  If <parameter>paramTypes</parameter> is
            <symbol>NULL</symbol>, or any particular element in the array
            is zero, the server infers a data type for the parameter symbol
            in the same way it would do for an untyped literal string.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>paramValues[]</parameter></term>
          <listitem>
           <para>
            Specifies the actual values of the parameters.  A null pointer
            in this array means the corresponding parameter is null;
            otherwise the pointer points to a zero-terminated text string
            (for text format) or binary data in the format expected by the
            server (for binary format).
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>paramLengths[]</parameter></term>
          <listitem>
           <para>
            Specifies the actual data lengths of binary-format parameters.
            It is ignored for null parameters and text-format parameters.
            The array pointer can be null when there are no binary parameters.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>paramFormats[]</parameter></term>
          <listitem>
           <para>
            Specifies whether parameters are text (put a zero in the
            array entry for the corresponding parameter) or binary (put
            a one in the array entry for the corresponding parameter).
            If the array pointer is null then all parameters are presumed
            to be text strings.
           </para>
           <para>
            Values passed in binary format require knowledge of
            the internal representation expected by the backend.
            For example, integers must be passed in network byte
            order.  Passing <type>numeric</type> values requires
            knowledge of the server storage format, as implemented
            in
            <filename>src/backend/utils/adt/numeric.c::numeric_send()</filename> and
            <filename>src/backend/utils/adt/numeric.c::numeric_recv()</filename>.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>resultFormat</parameter></term>
          <listitem>
           <para>
            Specify zero to obtain results in text format, or one to obtain
            results in binary format.  (There is not currently a provision
            to obtain different result columns in different formats,
            although that is possible in the underlying protocol.)
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
________________________________________________________-->
   <para>
    <variablelist>
     <varlistentry id="libpq-PQexecParams">
      <term><function>PQexecParams</function><indexterm><primary>PQexecParams</primary></indexterm></term>

      <listitem>
       <para>
        提交一个命令给服务器并且等待结果，它可以在 SQL 命令文本之外独立地传递参数。

<synopsis>
PGresult *PQexecParams(PGconn *conn,
                       const char *command,
                       int nParams,
                       const Oid *paramTypes,
                       const char * const *paramValues,
                       const int *paramLengths,
                       const int *paramFormats,
                       int resultFormat);
</synopsis>
       </para>

       <para>
        <xref linkend="libpq-PQexecParams"/>与<xref linkend="libpq-PQexec"/>相似，但是提供了额外的功能：参数值可以与命令字符串分开指定，并且可以以文本或二进制格式请求查询结果。
       </para>

       <para>
        该函数的参数是：

        <variablelist>
         <varlistentry>
          <term><parameter>conn</parameter></term>

          <listitem>
           <para>
            要在其中发送命令的连接对象。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>command</parameter></term>
          <listitem>
           <para>
            要执行的 SQL 命令字符串。如果使用了参数，它们在该命令字符串中被引用为<literal>$1</literal>、<literal>$2</literal>等。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>nParams</parameter></term>
          <listitem>
           <para>
            提供的参数数量。它是数组<parameter>paramTypes[]</parameter>、<parameter>paramValues[]</parameter>、<parameter>paramLengths[]</parameter>和<parameter>paramFormats[]</parameter>的长度（当<parameter>nParams</parameter>为零时，数组指针可以是<symbol>NULL</symbol>）。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>paramTypes[]</parameter></term>
          <listitem>
           <para>
            通过 OID 指定要赋予给参数符号的数据类型。如果<parameter>paramTypes</parameter>为<symbol>NULL</symbol>或者该数组中任何特定元素为零，服务器会用对待未知类型文字串的方式为参数符号推测一种数据类型。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>paramValues[]</parameter></term>
          <listitem>
           <para>
            指定参数的实际值。这个数组中的一个空指针表示对应的参数为空，否则该指针指向一个以零终止的文本字符串（用于文本格式）或者以服务器所期待格式的二进制数据（用于二进制格式）。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>paramLengths[]</parameter></term>
          <listitem>
           <para>
            指定二进制格式参数的实际数据长度。它对空参数和文本格式参数被忽略。当没有二进制参数时，该数组指针可以为空。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>paramFormats[]</parameter></term>
          <listitem>
           <para>
            指定参数是否为文本（在参数相应的数组项中放一个零）或二进制（在参数相应的数组项中放一个一）。如果该数组指针为空，那么所有参数都会被假定为文本串。
           </para>
           <para>
            以二进制格式传递的值要求后端所期待的内部表示形式的知识。例如，整数必须以网络字节序被传递。传递<type>numeric</type>值要求关于服务器存储格式的知识，正如<filename>src/backend/utils/adt/numeric.c::numeric_send()</filename>以及<filename>src/backend/utils/adt/numeric.c::numeric_recv()</filename>中所实现的。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>resultFormat</parameter></term>
          <listitem>
           <para>
            指定零来得到文本格式的结果，或者指定一来得到二进制格式的结果（目前没有规定要求以不同格式得到不同的结果列，尽管在底层协议中这是可以实现的）。
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
<!-- pgdoc-cn_end sig_en=3c96090d8b52692abcc3b8f397d0522f -->

<!-- pgdoc-cn_start sig_en=28f0660d6f71edf18e9c048a0a9f34aa sig_cn_org=None source=14.1 
   <para>
    The primary advantage of <xref linkend="libpq-PQexecParams"/> over
    <xref linkend="libpq-PQexec"/> is that parameter values can be separated from the
    command string, thus avoiding the need for tedious and error-prone
    quoting and escaping.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="libpq-PQexecParams"/>相对于<xref linkend="libpq-PQexec"/>的主要优点是参数值可以从命令串中分离，因此避免了冗长的书写、容易发生错误的引用以及转义。
   </para>
<!-- pgdoc-cn_end sig_en=28f0660d6f71edf18e9c048a0a9f34aa -->

<!-- pgdoc-cn_start sig_en=0642e0b70b6cb3212988b5d26fcf8b9e sig_cn_org=None source=14.1 
   <para>
    Unlike <xref linkend="libpq-PQexec"/>, <xref linkend="libpq-PQexecParams"/> allows at most
    one SQL command in the given string.  (There can be semicolons in it,
    but not more than one nonempty command.)  This is a limitation of the
    underlying protocol, but has some usefulness as an extra defense against
    SQL-injection attacks.
   </para>
________________________________________________________-->
   <para>
    和<xref linkend="libpq-PQexec"/>不同，<xref linkend="libpq-PQexecParams"/>至多允许在给定串中出现一个 SQL 命令（其中可以有分号，但是不能有超过一个非空命令）。这是底层协议的一个限制，但是有助于抵抗 SQL 注入攻击。
   </para>
<!-- pgdoc-cn_end sig_en=0642e0b70b6cb3212988b5d26fcf8b9e -->

   <tip>
<!-- pgdoc-cn_start sig_en=dc332b1b0cd9e51a724557f6eb32467a sig_cn_org=None source=14.1 
    <para>
     Specifying parameter types via OIDs is tedious, particularly if you prefer
     not to hard-wire particular OID values into your program.  However, you can
     avoid doing so even in cases where the server by itself cannot determine the
     type of the parameter, or chooses a different type than you want.  In the
     SQL command text, attach an explicit cast to the parameter symbol to show what
     data type you will send.  For example:
<programlisting>
SELECT * FROM mytable WHERE x = $1::bigint;
</programlisting>
     This forces parameter <literal>$1</literal> to be treated as <type>bigint</type>, whereas
     by default it would be assigned the same type as <literal>x</literal>.  Forcing the
     parameter type decision, either this way or by specifying a numeric type OID,
     is strongly recommended when sending parameter values in binary format, because
     binary format has less redundancy than text format and so there is less chance
     that the server will detect a type mismatch mistake for you.
    </para>
________________________________________________________-->
    <para>
     通过 OID 指定参数类型很罗嗦，特别是如果你不愿意将特定的 OID 值硬编码到你的程序中时。不过，即使服务器本身也无法确定参数的类型，你可以避免这样做，或者选择一种与你想要的不同的类型。在 SQL 命令文本中，附加一个显式造型给参数符号来表示你将发送什么样的数据类型。例如：
<programlisting>
SELECT * FROM mytable WHERE x = $1::bigint;
</programlisting>
     这强制参数<literal>$1</literal>被当作<type>bigint</type>，而默认情况下它将被赋予与<literal>x</literal>相同的类型。当以二进制格式发送参数值时，我们强烈推荐以这种方式或通过指定一个数字类型的 OID 来强制参数类型决定。因为二进制格式比文本格式具有更少的冗余，并且因此服务器将不会有更多机会为你检测一个类型匹配错误。
    </para>
<!-- pgdoc-cn_end sig_en=dc332b1b0cd9e51a724557f6eb32467a -->
   </tip>

<!-- pgdoc-cn_start sig_en=6560d07a3869d56b2165a54cf0831ae8 sig_cn_org=None source=14.1 
   <para>
    <variablelist>
     <varlistentry id="libpq-PQprepare">
      <term><function>PQprepare</function><indexterm><primary>PQprepare</primary></indexterm></term>

      <listitem>
       <para>
        Submits a request to create a prepared statement with the
        given parameters, and waits for completion.
<synopsis>
PGresult *PQprepare(PGconn *conn,
                    const char *stmtName,
                    const char *query,
                    int nParams,
                    const Oid *paramTypes);
</synopsis>
       </para>

       <para>
        <xref linkend="libpq-PQprepare"/> creates a prepared statement for later
        execution with <xref linkend="libpq-PQexecPrepared"/>.  This feature allows
        commands to be executed repeatedly without being parsed and
        planned each time;  see <xref linkend="sql-prepare"/> for details.
       </para>

       <para>
        The function creates a prepared statement named
        <parameter>stmtName</parameter> from the <parameter>query</parameter> string, which
        must contain a single SQL command.  <parameter>stmtName</parameter> can be
        <literal>""</literal> to create an unnamed statement, in which case any
        pre-existing unnamed statement is automatically replaced; otherwise
        it is an error if the statement name is already defined in the
        current session.  If any parameters are used, they are referred
        to in the query as <literal>$1</literal>, <literal>$2</literal>, etc.
        <parameter>nParams</parameter> is the number of parameters for which types
        are pre-specified in the array <parameter>paramTypes[]</parameter>.  (The
        array pointer can be <symbol>NULL</symbol> when
        <parameter>nParams</parameter> is zero.) <parameter>paramTypes[]</parameter>
        specifies, by OID, the data types to be assigned to the parameter
        symbols.  If <parameter>paramTypes</parameter> is <symbol>NULL</symbol>,
        or any particular element in the array is zero, the server assigns
        a data type to the parameter symbol in the same way it would do
        for an untyped literal string.  Also, the query can use parameter
        symbols with numbers higher than <parameter>nParams</parameter>; data types
        will be inferred for these symbols as well.  (See
        <xref linkend="libpq-PQdescribePrepared"/> for a means to find out
        what data types were inferred.)
       </para>

       <para>
        As with <xref linkend="libpq-PQexec"/>, the result is normally a
        <structname>PGresult</structname> object whose contents indicate
        server-side success or failure.  A null result indicates
        out-of-memory or inability to send the command at all.  Use
        <xref linkend="libpq-PQerrorMessage"/> to get more information about
        such errors.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    Prepared statements for use with <xref linkend="libpq-PQexecPrepared"/> can also
    be created by executing SQL <xref linkend="sql-prepare"/>
    statements.  Also, although there is no <application>libpq</application>
    function for deleting a prepared statement, the SQL <xref
    linkend="sql-deallocate"/> statement
    can be used for that purpose.
   </para>
________________________________________________________-->
   <para>
    <variablelist>
     <varlistentry id="libpq-PQprepare">
      <term><function>PQprepare</function><indexterm><primary>PQprepare</primary></indexterm></term>

      <listitem>
       <para>
        提交一个请求用给定参数创建一个预备语句并且等待完成。
<synopsis>
PGresult *PQprepare(PGconn *conn,
                    const char *stmtName,
                    const char *query,
                    int nParams,
                    const Oid *paramTypes);
</synopsis>
       </para>

       <para>
        <xref linkend="libpq-PQprepare"/>创建一个后面会由<xref linkend="libpq-PQexecPrepared"/>执行的预备语句。
        这个特性允许命令被反复执行而无需每次都进行解析和规划，详见<xref linkend="sql-prepare"/>。
       </para>

       <para>
        该函数从<parameter>query</parameter>串创建一个名为<parameter>stmtName</parameter>的预备语句，该串必须包含一个单一 SQL 命令。
        <parameter>stmtName</parameter>可以是<literal>""</literal>来创建一个未命名语句，在这种情况下任何已存在未命名语句将被自动替换。
        如果语句名称已经在当前会话中被定义，则是一种错误。如果使用了任何参数，它们在查询中以<literal>$1</literal>、<literal>$2</literal>等引用。
        <parameter>nParams</parameter>是参数的个数，其类型在数组<parameter>paramTypes[]</parameter>中被预先指定（当<parameter>nParams</parameter>为零时，该数组指针可以是<symbol>NULL</symbol>）。
        <parameter>paramTypes[]</parameter>通过 OID 指定要赋予给参数符号的数据类型。
        如果<parameter>paramTypes</parameter>是<symbol>NULL</symbol>或者该数组中任何特定元素为零，服务器会用对待未知类型文字串的方式为参数符号推测一种数据类型。
        还有，查询能够使用编号高于<parameter>nParams</parameter>的参数符号，它们的数据类型也会被自动推测（找出推测出的数据类型的方法见<xref linkend="libpq-PQdescribePrepared"/>）。
       </para>

       <para>
        正如<xref linkend="libpq-PQexec"/>一样，结果通常是一个<structname>PGresult</structname>对象，其内容代表服务器端成功或失败。
        一个空结果表示内存不足或者根本无法发送命令。关于错误的更多信息请见<xref linkend="libpq-PQerrorMessage"/>。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    用于<xref linkend="libpq-PQexecPrepared"/>的预备语句也能通过执行 SQL <xref linkend="sql-prepare"/>语句来创建。
    还有，尽管没有<application>libpq</application>函数来删除一个预备语句，SQL <xref linkend="sql-deallocate"/>语句可被用于此目的。
   </para>
<!-- pgdoc-cn_end sig_en=6560d07a3869d56b2165a54cf0831ae8 -->

   <para>
    <variablelist>
     <varlistentry id="libpq-PQexecPrepared">
<!-- pgdoc-cn_start sig_en=a7ab50e0a80fcc0bbe93208a995066fe sig_cn_org=a7ab50e0a80fcc0bbe93208a995066fe source=15.7 
      <term><function>PQexecPrepared</function><indexterm><primary>PQexecPrepared</primary></indexterm></term>
________________________________________________________-->
      <term><function>PQexecPrepared</function><indexterm><primary>PQexecPrepared</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=a7ab50e0a80fcc0bbe93208a995066fe -->

      <listitem>
<!-- pgdoc-cn_start sig_en=b9b414481fbeffedc255d3f1920a97b6 sig_cn_org=293b314cd0e50ef445c2db3f084ac0a0 source=15.7 
       <para>
        Sends a request to execute a prepared statement with given
        parameters, and waits for the result.
<synopsis>
PGresult *PQexecPrepared(PGconn *conn,
                         const char *stmtName,
                         int nParams,
                         const char * const *paramValues,
                         const int *paramLengths,
                         const int *paramFormats,
                         int resultFormat);
</synopsis>
       </para>
________________________________________________________-->
       <para>
        发送一个请求来执行一个带有给定参数的预处理语句，并等待结果。
<synopsis>
PGresult *PQexecPrepared(PGconn *conn,
                         const char *stmtName,
                         int nParams,
                         const char * const *paramValues,
                         const int *paramLengths,
                         const int *paramFormats,
                         int resultFormat);
</synopsis>
       </para>
<!-- pgdoc-cn_end sig_en=b9b414481fbeffedc255d3f1920a97b6 -->

<!-- pgdoc-cn_start sig_en=23b40b2b07be76fa2cb619ea0b5ebc04 sig_cn_org=cea414573562b798b38bc6d7417f3c4a source=15.7 
       <para>
        <xref linkend="libpq-PQexecPrepared"/> is like <xref linkend="libpq-PQexecParams"/>,
        but the command to be executed is specified by naming a
        previously-prepared statement, instead of giving a query string.
        This feature allows commands that will be used repeatedly to be
        parsed and planned just once, rather than each time they are
        executed.  The statement must have been prepared previously in
        the current session.
       </para>
________________________________________________________-->
       <para>
        <xref linkend="libpq-PQexecPrepared"/>类似于<xref linkend="libpq-PQexecParams"/>，
        但要执行的命令是通过指定先前准备好的语句来指定，而不是提供查询字符串。
        此功能允许重复使用的命令只被解析和计划一次，而不是每次执行时都要进行。
        该语句必须在当前会话中先前准备好。
       </para>
<!-- pgdoc-cn_end sig_en=23b40b2b07be76fa2cb619ea0b5ebc04 -->

<!-- pgdoc-cn_start sig_en=7348a707c906aa758cd42901dc29041c sig_cn_org=7f7ae471ac0c26ef0e36f33aa0ff7e36 source=15.7 
       <para>
        The parameters are identical to <xref linkend="libpq-PQexecParams"/>, except that the
        name of a prepared statement is given instead of a query string, and the
        <parameter>paramTypes[]</parameter> parameter is not present (it is not needed since
        the prepared statement's parameter types were determined when it was created).
       </para>
________________________________________________________-->
       <para>
        参数与<xref linkend="libpq-PQexecParams"/>相同，只是给出了预处理语句的名称而不是查询字符串，
        并且<parameter>paramTypes[]</parameter>参数不存在（因为在创建预处理语句时已确定了参数类型）。
</para>
<!-- pgdoc-cn_end sig_en=7348a707c906aa758cd42901dc29041c -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-PQdescribePrepared">
<!-- pgdoc-cn_start sig_en=dff50467e7575ffd6f577f2105a040d1 sig_cn_org=dff50467e7575ffd6f577f2105a040d1 source=15.7 
      <term><function>PQdescribePrepared</function><indexterm><primary>PQdescribePrepared</primary></indexterm></term>
________________________________________________________-->
      <term><function>PQdescribePrepared</function><indexterm><primary>PQdescribePrepared</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=dff50467e7575ffd6f577f2105a040d1 -->

      <listitem>
<!-- pgdoc-cn_start sig_en=4510c1d52f200a285015bcb7b33642ce sig_cn_org=5e8e58d4e01620f5392057f35e89e44d source=15.7 
       <para>
        Submits a request to obtain information about the specified
        prepared statement, and waits for completion.
<synopsis>
PGresult *PQdescribePrepared(PGconn *conn, const char *stmtName);
</synopsis>
       </para>
________________________________________________________-->
       <para>
        提交请求以获取有关指定准备好的语句的信息，并等待完成。
<synopsis>
PGresult *PQdescribePrepared(PGconn *conn, const char *stmtName);
</synopsis>
       </para>
<!-- pgdoc-cn_end sig_en=4510c1d52f200a285015bcb7b33642ce -->

<!-- pgdoc-cn_start sig_en=6656fe30435f6f4380986d3c4dea6647 sig_cn_org=6c1149ef7ee2ab38a4fc40306e115074 source=15.7 
       <para>
        <xref linkend="libpq-PQdescribePrepared"/> allows an application to obtain
        information about a previously prepared statement.
       </para>
________________________________________________________-->
       <para>
        <xref linkend="libpq-PQdescribePrepared"/>允许应用程序获取关于先前准备的语句的信息。
       </para>
<!-- pgdoc-cn_end sig_en=6656fe30435f6f4380986d3c4dea6647 -->

<!-- pgdoc-cn_start sig_en=b712763c731f98121ce2f143e1cf0c41 sig_cn_org=c7fa54460affd689eede607fd31ddc7f source=15.7 
       <para>
        <parameter>stmtName</parameter> can be <literal>""</literal> or <symbol>NULL</symbol> to reference
        the unnamed statement, otherwise it must be the name of an existing
        prepared statement.  On success, a <structname>PGresult</structname> with
        status <literal>PGRES_COMMAND_OK</literal> is returned.  The
        functions <xref linkend="libpq-PQnparams"/> and
        <xref linkend="libpq-PQparamtype"/> can be applied to this
        <structname>PGresult</structname> to obtain information about the parameters
        of the prepared statement, and the functions
        <xref linkend="libpq-PQnfields"/>, <xref linkend="libpq-PQfname"/>,
        <xref linkend="libpq-PQftype"/>, etc. provide information about the
        result columns (if any) of the statement.
       </para>
________________________________________________________-->
       <para>
        <parameter>stmtName</parameter>可以是<literal>""</literal>或<symbol>NULL</symbol>来引用
        未命名的语句，否则必须是现有准备好的语句的名称。成功时，返回一个
        状态为<literal>PGRES_COMMAND_OK</literal>的<structname>PGresult</structname>。
        函数<xref linkend="libpq-PQnparams"/>和
        <xref linkend="libpq-PQparamtype"/>可以应用于此
        <structname>PGresult</structname>以获取有关准备语句参数的信息，
        函数<xref linkend="libpq-PQnfields"/>、<xref linkend="libpq-PQfname"/>、
        <xref linkend="libpq-PQftype"/>等提供有关语句的结果列（如果有）的信息。
       </para>
<!-- pgdoc-cn_end sig_en=b712763c731f98121ce2f143e1cf0c41 -->
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-PQdescribePortal">
<!-- pgdoc-cn_start sig_en=e3c592a9d871f2e94a0058ac6e875098 sig_cn_org=e3c592a9d871f2e94a0058ac6e875098 source=15.7 
      <term><function>PQdescribePortal</function><indexterm><primary>PQdescribePortal</primary></indexterm></term>
________________________________________________________-->
      <term><function>PQdescribePortal</function><indexterm><primary>PQdescribePortal</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=e3c592a9d871f2e94a0058ac6e875098 -->

      <listitem>
<!-- pgdoc-cn_start sig_en=fda6b09bdbd323556b340a28c31de0a6 sig_cn_org=7d115a9d760f843feecd0db92cd2e863 source=15.7 
       <para>
        Submits a request to obtain information about the specified
        portal, and waits for completion.
<synopsis>
PGresult *PQdescribePortal(PGconn *conn, const char *portalName);
</synopsis>
       </para>
________________________________________________________-->
       <para>
        提交请求以获取有关指定门户的信息，并等待完成。
<synopsis>
PGresult *PQdescribePortal(PGconn *conn, const char *portalName);
</synopsis>
       </para>
<!-- pgdoc-cn_end sig_en=fda6b09bdbd323556b340a28c31de0a6 -->

<!-- pgdoc-cn_start sig_en=b15c0c7b0ea52d923445a970c89ccc9c sig_cn_org=d3179d54752957b139e2a95cde5da4bd source=15.7 
       <para>
        <xref linkend="libpq-PQdescribePortal"/> allows an application to obtain
        information about a previously created portal.
        (<application>libpq</application> does not provide any direct access to
        portals, but you can use this function to inspect the properties
        of a cursor created with a <command>DECLARE CURSOR</command> SQL command.)
       </para>
________________________________________________________-->
       <para>
        <xref linkend="libpq-PQdescribePortal"/>允许应用程序获取有关先前创建的portal的信息。
        (<application>libpq</application>不直接提供对portals的访问，但您可以使用此函数检查使用<command>DECLARE CURSOR</command> SQL命令创建的游标的属性。)
       </para>
<!-- pgdoc-cn_end sig_en=b15c0c7b0ea52d923445a970c89ccc9c -->

<!-- pgdoc-cn_start sig_en=b56a39a577c338a16dafe1da87557f6e sig_cn_org=ec3d73ba6c689f3d032de41113fe056a source=15.7 
       <para>
        <parameter>portalName</parameter> can be <literal>""</literal> or <symbol>NULL</symbol> to reference
        the unnamed portal, otherwise it must be the name of an existing
        portal.  On success, a <structname>PGresult</structname> with status
        <literal>PGRES_COMMAND_OK</literal> is returned.  The functions
        <xref linkend="libpq-PQnfields"/>, <xref linkend="libpq-PQfname"/>,
        <xref linkend="libpq-PQftype"/>, etc. can be applied to the
        <structname>PGresult</structname> to obtain information about the result
        columns (if any) of the portal.
       </para>
________________________________________________________-->
       <para>
        <parameter>portalName</parameter>可以是<literal>""</literal>或<symbol>NULL</symbol>来引用未命名的portal，
        否则必须是现有portal的名称。成功时，将返回一个带有状态<literal>PGRES_COMMAND_OK</literal>的<structname>PGresult</structname>。
        函数<xref linkend="libpq-PQnfields"/>、<xref linkend="libpq-PQfname"/>、<xref linkend="libpq-PQftype"/>等可应用于
        <structname>PGresult</structname>，以获取有关portal的结果列（如果有）的信息。
       </para>
<!-- pgdoc-cn_end sig_en=b56a39a577c338a16dafe1da87557f6e -->
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

<!-- pgdoc-cn_start sig_en=3129b2e0d6d3b2161da7ec663766dcec sig_cn_org=None source=14.1 
   <para>
    The <structname>PGresult</structname><indexterm><primary>PGresult</primary></indexterm>
    structure encapsulates the result returned by the server.
    <application>libpq</application> application programmers should be
    careful to maintain the <structname>PGresult</structname> abstraction.
    Use the accessor functions below to get at the contents of
    <structname>PGresult</structname>.  Avoid directly referencing the
    fields of the <structname>PGresult</structname> structure because they
    are subject to change in the future.

    <variablelist>
     <varlistentry id="libpq-PQresultStatus">
      <term><function>PQresultStatus</function><indexterm><primary>PQresultStatus</primary></indexterm></term>

      <listitem>
       <para>
        Returns the result status of the command.
<synopsis>
ExecStatusType PQresultStatus(const PGresult *res);
</synopsis>
       </para>

       <para>
        <xref linkend="libpq-PQresultStatus"/> can return one of the following values:

        <variablelist>
         <varlistentry id="libpq-pgres-empty-query">
          <term><literal>PGRES_EMPTY_QUERY</literal></term>
          <listitem>
           <para>
            The string sent to the server was empty.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-command-ok">
          <term><literal>PGRES_COMMAND_OK</literal></term>
          <listitem>
           <para>
            Successful completion of a command returning no data.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-tuples-ok">
          <term><literal>PGRES_TUPLES_OK</literal></term>
          <listitem>
           <para>
            Successful completion of a command returning data (such as
            a <command>SELECT</command> or <command>SHOW</command>).
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-copy-out">
          <term><literal>PGRES_COPY_OUT</literal></term>
          <listitem>
           <para>
            Copy Out (from server) data transfer started.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-copy-in">
          <term><literal>PGRES_COPY_IN</literal></term>
          <listitem>
           <para>
            Copy In (to server) data transfer started.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-bad-response">
          <term><literal>PGRES_BAD_RESPONSE</literal></term>
          <listitem>
           <para>
            The server's response was not understood.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-nonfatal-error">
          <term><literal>PGRES_NONFATAL_ERROR</literal></term>
          <listitem>
           <para>
            A nonfatal error (a notice or warning) occurred.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-fatal-error">
          <term><literal>PGRES_FATAL_ERROR</literal></term>
          <listitem>
           <para>
            A fatal error occurred.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-copy-both">
          <term><literal>PGRES_COPY_BOTH</literal></term>
          <listitem>
           <para>
            Copy In/Out (to and from server) data transfer started.  This
            feature is currently used only for streaming replication,
            so this status should not occur in ordinary applications.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-single-tuple">
          <term><literal>PGRES_SINGLE_TUPLE</literal></term>
          <listitem>
           <para>
            The <structname>PGresult</structname> contains a single result tuple
            from the current command.  This status occurs only when
            single-row mode has been selected for the query
            (see <xref linkend="libpq-single-row-mode"/>).
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-pipeline-sync">
          <term><literal>PGRES_PIPELINE_SYNC</literal></term>
          <listitem>
           <para>
            The <structname>PGresult</structname> represents a
            synchronization point in pipeline mode, requested by
            <xref linkend="libpq-PQpipelineSync"/>.
            This status occurs only when pipeline mode has been selected.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-pipeline-aborted">
          <term><literal>PGRES_PIPELINE_ABORTED</literal></term>
          <listitem>
           <para>
            The <structname>PGresult</structname> represents a pipeline that has
            received an error from the server.  <function>PQgetResult</function>
            must be called repeatedly, and each time it will return this status code
            until the end of the current pipeline, at which point it will return
            <literal>PGRES_PIPELINE_SYNC</literal> and normal processing can
            resume.
           </para>
          </listitem>
         </varlistentry>

        </variablelist>

        If the result status is <literal>PGRES_TUPLES_OK</literal> or
        <literal>PGRES_SINGLE_TUPLE</literal>, then
        the functions described below can be used to retrieve the rows
        returned by the query.  Note that a <command>SELECT</command>
        command that happens to retrieve zero rows still shows
        <literal>PGRES_TUPLES_OK</literal>.
        <literal>PGRES_COMMAND_OK</literal> is for commands that can never
        return rows (<command>INSERT</command> or <command>UPDATE</command>
        without a <literal>RETURNING</literal> clause,
        etc.). A response of <literal>PGRES_EMPTY_QUERY</literal> might
        indicate a bug in the client software.
       </para>

       <para>
        A result of status <symbol>PGRES_NONFATAL_ERROR</symbol> will
        never be returned directly by <xref linkend="libpq-PQexec"/> or other
        query execution functions; results of this kind are instead passed
        to the notice processor (see <xref
        linkend="libpq-notice-processing"/>).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-PQresStatus">
      <term><function>PQresStatus</function><indexterm><primary>PQresStatus</primary></indexterm></term>

      <listitem>
       <para>
        Converts the enumerated type returned by
        <xref linkend="libpq-PQresultStatus"/> into a string constant describing the
        status code. The caller should not free the result.

<synopsis>
char *PQresStatus(ExecStatusType status);
</synopsis>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-PQresultErrorMessage">
      <term><function>PQresultErrorMessage</function><indexterm><primary>PQresultErrorMessage</primary></indexterm></term>

      <listitem>
       <para>
        Returns the error message associated with the command, or an empty string
        if there was no error.
<synopsis>
char *PQresultErrorMessage(const PGresult *res);
</synopsis>
        If there was an error, the returned string will include a trailing
        newline.  The caller should not free the result directly. It will
        be freed when the associated <structname>PGresult</structname> handle is
        passed to <xref linkend="libpq-PQclear"/>.
       </para>

       <para>
        Immediately following a <xref linkend="libpq-PQexec"/> or
        <xref linkend="libpq-PQgetResult"/> call,
        <xref linkend="libpq-PQerrorMessage"/> (on the connection) will return
        the same string as <xref linkend="libpq-PQresultErrorMessage"/> (on
        the result).  However, a <structname>PGresult</structname> will
        retain its error message until destroyed, whereas the connection's
        error message will change when subsequent operations are done.
        Use <xref linkend="libpq-PQresultErrorMessage"/> when you want to
        know the status associated with a particular
        <structname>PGresult</structname>; use
        <xref linkend="libpq-PQerrorMessage"/> when you want to know the
        status from the latest operation on the connection.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-PQresultVerboseErrorMessage">
      <term><function>PQresultVerboseErrorMessage</function><indexterm><primary>PQresultVerboseErrorMessage</primary></indexterm></term>

      <listitem>
       <para>
        Returns a reformatted version of the error message associated with
        a <structname>PGresult</structname> object.
<synopsis>
char *PQresultVerboseErrorMessage(const PGresult *res,
                                  PGVerbosity verbosity,
                                  PGContextVisibility show_context);
</synopsis>
        In some situations a client might wish to obtain a more detailed
        version of a previously-reported error.
        <xref linkend="libpq-PQresultVerboseErrorMessage"/> addresses this need
        by computing the message that would have been produced
        by <xref linkend="libpq-PQresultErrorMessage"/> if the specified
        verbosity settings had been in effect for the connection when the
        given <structname>PGresult</structname> was generated.  If
        the <structname>PGresult</structname> is not an error result,
        <quote>PGresult is not an error result</quote> is reported instead.
        The returned string includes a trailing newline.
       </para>

       <para>
        Unlike most other functions for extracting data from
        a <structname>PGresult</structname>, the result of this function is a freshly
        allocated string.  The caller must free it
        using <function>PQfreemem()</function> when the string is no longer needed.
       </para>

       <para>
        A NULL return is possible if there is insufficient memory.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-PQresultErrorField">
      <term><function>PQresultErrorField</function><indexterm><primary>PQresultErrorField</primary></indexterm></term>
      <listitem>
       <para>
        Returns an individual field of an error report.
<synopsis>
char *PQresultErrorField(const PGresult *res, int fieldcode);
</synopsis>
        <parameter>fieldcode</parameter> is an error field identifier; see the symbols
        listed below.  <symbol>NULL</symbol> is returned if the
        <structname>PGresult</structname> is not an error or warning result,
        or does not include the specified field.  Field values will normally
        not include a trailing newline. The caller should not free the
        result directly. It will be freed when the
        associated <structname>PGresult</structname> handle is passed to
        <xref linkend="libpq-PQclear"/>.
       </para>

       <para>
        The following field codes are available:
        <variablelist>
         <varlistentry id="libpq-pg-diag-severity">
          <term><symbol>PG_DIAG_SEVERITY</symbol></term>
          <listitem>
           <para>
            The severity; the field contents are <literal>ERROR</literal>,
            <literal>FATAL</literal>, or <literal>PANIC</literal> (in an error message),
            or <literal>WARNING</literal>, <literal>NOTICE</literal>, <literal>DEBUG</literal>,
            <literal>INFO</literal>, or <literal>LOG</literal> (in a notice message), or
            a localized translation of one of these.  Always present.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-PG-diag-severity-nonlocalized">
          <term><symbol>PG_DIAG_SEVERITY_NONLOCALIZED</symbol></term>
          <listitem>
           <para>
            The severity; the field contents are <literal>ERROR</literal>,
            <literal>FATAL</literal>, or <literal>PANIC</literal> (in an error message),
            or <literal>WARNING</literal>, <literal>NOTICE</literal>, <literal>DEBUG</literal>,
            <literal>INFO</literal>, or <literal>LOG</literal> (in a notice message).
            This is identical to the <symbol>PG_DIAG_SEVERITY</symbol> field except
            that the contents are never localized.  This is present only in
            reports generated by <productname>PostgreSQL</productname> versions 9.6
            and later.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-sqlstate">
          <term><symbol>PG_DIAG_SQLSTATE</symbol><indexterm
          ><primary>error codes</primary><secondary>libpq</secondary></indexterm></term>
          <listitem>
           <para>
            The SQLSTATE code for the error. The SQLSTATE code identifies
            the type of error that has occurred; it can be used by
            front-end applications to perform specific operations (such
            as error handling) in response to a particular database error.
            For a list of the possible SQLSTATE codes, see <xref
            linkend="errcodes-appendix"/>. This field is not localizable,
            and is always present.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-message-primary">
          <term><symbol>PG_DIAG_MESSAGE_PRIMARY</symbol></term>
          <listitem>
           <para>
            The primary human-readable error message (typically one line).
            Always present.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-message-detail">
          <term><symbol>PG_DIAG_MESSAGE_DETAIL</symbol></term>
          <listitem>
           <para>
            Detail: an optional secondary error message carrying more
            detail about the problem.  Might run to multiple lines.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-message-hint">
          <term><symbol>PG_DIAG_MESSAGE_HINT</symbol></term>
          <listitem>
           <para>
            Hint: an optional suggestion what to do about the problem.
            This is intended to differ from detail in that it offers advice
            (potentially inappropriate) rather than hard facts.  Might
            run to multiple lines.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-statement-position">
          <term><symbol>PG_DIAG_STATEMENT_POSITION</symbol></term>
          <listitem>
           <para>
            A string containing a decimal integer indicating an error cursor
            position as an index into the original statement string.  The
            first character has index 1, and positions are measured in
            characters not bytes.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-internal-position">
          <term><symbol>PG_DIAG_INTERNAL_POSITION</symbol></term>
          <listitem>
           <para>
            This is defined the same as the
            <symbol>PG_DIAG_STATEMENT_POSITION</symbol> field, but it is used
            when the cursor position refers to an internally generated
            command rather than the one submitted by the client.  The
            <symbol>PG_DIAG_INTERNAL_QUERY</symbol> field will always appear when
            this field appears.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-internal-query">
          <term><symbol>PG_DIAG_INTERNAL_QUERY</symbol></term>
          <listitem>
           <para>
            The text of a failed internally-generated command.  This could
            be, for example, an SQL query issued by a PL/pgSQL function.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-context">
          <term><symbol>PG_DIAG_CONTEXT</symbol></term>
          <listitem>
           <para>
            An indication of the context in which the error occurred.
            Presently this includes a call stack traceback of active
            procedural language functions and internally-generated queries.
            The trace is one entry per line, most recent first.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-schema-name">
          <term><symbol>PG_DIAG_SCHEMA_NAME</symbol></term>
          <listitem>
           <para>
            If the error was associated with a specific database object,
            the name of the schema containing that object, if any.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-table-name">
          <term><symbol>PG_DIAG_TABLE_NAME</symbol></term>
          <listitem>
           <para>
            If the error was associated with a specific table, the name of the
            table.  (Refer to the schema name field for the name of the
            table's schema.)
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-column-name">
          <term><symbol>PG_DIAG_COLUMN_NAME</symbol></term>
          <listitem>
           <para>
            If the error was associated with a specific table column, the name
            of the column.  (Refer to the schema and table name fields to
            identify the table.)
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-datatype-name">
          <term><symbol>PG_DIAG_DATATYPE_NAME</symbol></term>
          <listitem>
           <para>
            If the error was associated with a specific data type, the name of
            the data type.  (Refer to the schema name field for the name of
            the data type's schema.)
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-constraint-name">
          <term><symbol>PG_DIAG_CONSTRAINT_NAME</symbol></term>
          <listitem>
           <para>
            If the error was associated with a specific constraint, the name
            of the constraint.  Refer to fields listed above for the
            associated table or domain.  (For this purpose, indexes are
            treated as constraints, even if they weren't created with
            constraint syntax.)
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-source-file">
          <term><symbol>PG_DIAG_SOURCE_FILE</symbol></term>
          <listitem>
           <para>
            The file name of the source-code location where the error was
            reported.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-source-line">
          <term><symbol>PG_DIAG_SOURCE_LINE</symbol></term>
          <listitem>
           <para>
            The line number of the source-code location where the error
            was reported.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-source-function">
          <term><symbol>PG_DIAG_SOURCE_FUNCTION</symbol></term>
          <listitem>
           <para>
            The name of the source-code function reporting the error.
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>

       <note>
        <para>
         The fields for schema name, table name, column name, data type name,
         and constraint name are supplied only for a limited number of error
         types; see <xref linkend="errcodes-appendix"/>.  Do not assume that
         the presence of any of these fields guarantees the presence of
         another field.  Core error sources observe the interrelationships
         noted above, but user-defined functions may use these fields in other
         ways.  In the same vein, do not assume that these fields denote
         contemporary objects in the current database.
        </para>
       </note>

       <para>
        The client is responsible for formatting displayed information to meet
        its needs; in particular it should break long lines as needed.
        Newline characters appearing in the error message fields should be
        treated as paragraph breaks, not line breaks.
       </para>

       <para>
        Errors generated internally by <application>libpq</application> will
        have severity and primary message, but typically no other fields.
       </para>

       <para>
        Note that error fields are only available from
        <structname>PGresult</structname> objects, not
        <structname>PGconn</structname> objects; there is no
        <function>PQerrorField</function> function.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-PQclear">
      <term><function>PQclear</function><indexterm><primary>PQclear</primary></indexterm></term>
      <listitem>
       <para>
        Frees  the  storage  associated with a
        <structname>PGresult</structname>.  Every command result should be
        freed via <xref linkend="libpq-PQclear"/> when it  is  no  longer
        needed.

<synopsis>
void PQclear(PGresult *res);
</synopsis>
       </para>

       <para>
        You can keep a <structname>PGresult</structname> object around for
        as long as you need it; it does not go away when you issue a new
        command, nor even if you close the connection.  To get rid of it,
        you must call <xref linkend="libpq-PQclear"/>.  Failure to do this
        will result in memory leaks in your application.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
________________________________________________________-->
   <para>
    <structname>PGresult</structname><indexterm><primary>PGresult</primary></indexterm>结构封装了由服务器返回的结果。<application>libpq</application>应用程序员应该小心地维护<structname>PGresult</structname>的抽象。使用下面的存储器函数来得到<structname>PGresult</structname>的内容。避免直接引用<structname>PGresult</structname>结构的域，因为它们可能在未来更改。

    <variablelist>
     <varlistentry id="libpq-PQresultStatus">
      <term><function>PQresultStatus</function><indexterm><primary>PQresultStatus</primary></indexterm></term>

      <listitem>
       <para>
        返回该命令的结果状态。
<synopsis>
ExecStatusType PQresultStatus(const PGresult *res);
</synopsis>
       </para>

       <para>
        <xref linkend="libpq-PQresultStatus"/>能返回下列值之一：

        <variablelist>
         <varlistentry id="libpq-pgres-empty-query">
          <term><literal>PGRES_EMPTY_QUERY</literal></term>
          <listitem>
           <para>
            发送给服务器的字符串为空。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-command-ok">
          <term><literal>PGRES_COMMAND_OK</literal></term>
          <listitem>
           <para>
            一个不返回数据的命令成功完成。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-tuples-ok">
          <term><literal>PGRES_TUPLES_OK</literal></term>
          <listitem>
           <para>
            一个返回数据的命令（例如<command>SELECT</command>或者<command>SHOW</command>）成功完成。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-copy-out">
          <term><literal>PGRES_COPY_OUT</literal></term>
          <listitem>
           <para>
            从服务器复制出数据的传输开始。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-copy-in">
          <term><literal>PGRES_COPY_IN</literal></term>
          <listitem>
           <para>
            复制数据到服务器的传输开始。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-bad-response">
          <term><literal>PGRES_BAD_RESPONSE</literal></term>
          <listitem>
           <para>
            无法理解服务器的响应。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-nonfatal-error">
          <term><literal>PGRES_NONFATAL_ERROR</literal></term>
          <listitem>
           <para>
            发生了一次非致命错误（一个提示或警告）。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-fatal-error">
          <term><literal>PGRES_FATAL_ERROR</literal></term>
          <listitem>
           <para>
            发生了一次致命错误。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-copy-both">
          <term><literal>PGRES_COPY_BOTH</literal></term>
          <listitem>
           <para>
            向服务器复制数据/从服务器复制数据的传输开始。这个特性当前只被用于流复制，因此这个状态应该不会在普通应用中出现。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-single-tuple">
          <term><literal>PGRES_SINGLE_TUPLE</literal></term>
          <listitem>
           <para>
            <structname>PGresult</structname>包含来自于当前命令的一个单一结果元组。这个状态只在查询选择了单一行模式时发生（见<xref linkend="libpq-single-row-mode"/>）。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-pipeline-sync">
          <term><literal>PGRES_PIPELINE_SYNC</literal></term>
          <listitem>
           <para>
            <structname>PGresult</structname>表示管道模式中的同步点，由<xref linkend="libpq-PQpipelineSync"/>请求。
            此状态仅在选择管道模式时发生。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-pipeline-aborted">
          <term><literal>PGRES_PIPELINE_ABORTED</literal></term>
          <listitem>
           <para>
            <structname>PGresult</structname>表示从服务器接收到错误的管道。
            <function>PQgetResult</function>必须被重复调用，并且每次它都会返回这个状态码，直到当前管道结束，此时它将返回<literal>PGRES_PIPELINE_SYNC</literal>，并且正常的处理可以继续。
           </para>
          </listitem>
         </varlistentry>
        </variablelist>

        如果结果状态是<literal>PGRES_TUPLES_OK</literal>或者<literal>PGRES_SINGLE_TUPLE</literal>，那么下面所描述的函数能被用来检索该查询所返回的行。注意，一个恰好检索零行的<command>SELECT</command>命令仍然会显示<literal>PGRES_TUPLES_OK</literal>。<literal>PGRES_COMMAND_OK</literal>用于从不返回行的命令（不带<literal>RETURNING</literal>子句的<command>INSERT</command>或者<command>UPDATE</command>等）。一个<literal>PGRES_EMPTY_QUERY</literal>可能表示客户端软件中的一个缺陷。
       </para>

       <para>
        一个状态为<symbol>PGRES_NONFATAL_ERROR</symbol>的结果将不会被<xref linkend="libpq-PQexec"/>或者其他查询执行函数直接返回，这类结果将被传递给提示处理器（见 <xref linkend="libpq-notice-processing"/>）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-PQresStatus">
      <term><function>PQresStatus</function><indexterm><primary>PQresStatus</primary></indexterm></term>

      <listitem>
       <para>
        将<xref linkend="libpq-PQresultStatus"/>返回的枚举转换成描述状态编码的字符串常量。调用者不应该释放结果。

<synopsis>
char *PQresStatus(ExecStatusType status);
</synopsis>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-PQresultErrorMessage">
      <term><function>PQresultErrorMessage</function><indexterm><primary>PQresultErrorMessage</primary></indexterm></term>

      <listitem>
       <para>
        返回与该命令相关的错误消息，如果有错误则会返回一个空字符串。
<synopsis>
char *PQresultErrorMessage(const PGresult *res);
</synopsis>
        如果有一个错误，被返回的字符串将包含一个收尾的新行。调用者不应该直接释放结果。它将在相关的<structname>PGresult</structname>句柄被传递给<xref linkend="libpq-PQclear"/>之后被释放。
       </para>

       <para>
        紧跟着一个<xref linkend="libpq-PQexec"/> 或 <xref linkend="libpq-PQgetResult"/>调用，<xref linkend="libpq-PQerrorMessage"/>（在连接上）将返回与<xref linkend="libpq-PQresultErrorMessage"/>相同的字符串（在结果上）。
        不过，一个<structname>PGresult</structname>将保持它的错误消息直到被销毁，而连接的错误消息将在后续操作被执行时被更改。
        当你想要知道与一个特定<structname>PGresult</structname>相关的状态，使用<xref linkend="libpq-PQresultErrorMessage"/>。
        而当你想要知道连接上最后一个操作的状态，使用<xref linkend="libpq-PQerrorMessage"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-PQresultVerboseErrorMessage">
      <term><function>PQresultVerboseErrorMessage</function><indexterm><primary>PQresultVerboseErrorMessage</primary></indexterm></term>

      <listitem>
       <para>
        返回与<structname>PGresult</structname>对象相关的错误消息的重新格式化的版本。
<synopsis>
char *PQresultVerboseErrorMessage(const PGresult *res,
                                  PGVerbosity verbosity,
                                  PGContextVisibility show_context);
</synopsis>
        在有些情况下，客户端可能希望得到之前报告过的错误的更加详尽的版本。
        如果在产生给定<structname>PGresult</structname>的连接上 verbosity 设置有效，<xref linkend="libpq-PQresultVerboseErrorMessage"/>会通过计算已经被<xref linkend="libpq-PQresultErrorMessage"/>产生过的消息来满足这种需求。
        如果<structname>PGresult</structname>不是一个错误结果，则会报告<quote>PGresult is not an error result</quote>。返回的字符串包括一个新行作为结尾。
       </para>

       <para>
        和大部分从<structname>PGresult</structname>中提取数据的其他函数不同，这个函数的结果是一个全新分配的字符串。调用者在不需要这个字符串以后，必须使用<function>PQfreemem()</function>释放它。
       </para>

       <para>
        如果内存不足，可能会返回 NULL。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-PQresultErrorField">
      <term><function>PQresultErrorField</function><indexterm><primary>PQresultErrorField</primary></indexterm></term>
      <listitem>
       <para>
        返回一个错误报告的一个域。
<synopsis>
char *PQresultErrorField(const PGresult *res, int fieldcode);
</synopsis>
        <parameter>fieldcode</parameter>是一个错误域标识符，见下列符号。
        如果<structname>PGresult</structname>不是一个错误或者警告结果或者不包括指定域，会返回<symbol>NULL</symbol>。
        域通常不包括一个收尾的新行。调用者不应该直接释放结果。
        它将在相关的<structname>PGresult</structname>句柄被传递给<xref linkend="libpq-PQclear"/>之后被释放。
       </para>

       <para>
        下列域代码可用：
        <variablelist>
         <varlistentry id="libpq-pg-diag-severity">
          <term><symbol>PG_DIAG_SEVERITY</symbol></term>
          <listitem>
           <para>
            严重性。域的内容是<literal>ERROR</literal>、<literal>FATAL</literal>或<literal>PANIC</literal>（在一个错误消息中）。或者是<literal>WARNING</literal>、<literal>NOTICE</literal>、<literal>DEBUG</literal>、<literal>INFO</literal>或<literal>LOG</literal>（在一个提示消息中）。或者是其中之一的一个本地化翻译。总是存在。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-PG-diag-severity-nonlocalized">
          <term><symbol>PG_DIAG_SEVERITY_NONLOCALIZED</symbol></term>
          <listitem>
           <para>
            域的内容是<literal>ERROR</literal>、<literal>FATAL</literal>或<literal>PANIC</literal>（在一个错误消息中）。或者是<literal>WARNING</literal>、<literal>NOTICE</literal>、<literal>DEBUG</literal>、<literal>INFO</literal>或<literal>LOG</literal>（在一个提示消息中）。这和<symbol>PG_DIAG_SEVERITY</symbol>域相同，不过内容不会被本地化。只存在于<productname>PostgreSQL</productname> 9.6 版本以后产生的报告中。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-sqlstate">
          <term><symbol>PG_DIAG_SQLSTATE</symbol><indexterm
          ><primary>error codes</primary><secondary>libpq</secondary></indexterm></term>
          <listitem>
           <para>
            用于错误的 SQLSTATE 代码。SQLSTATE 代码标识了已经发生的错误的类型，它可以被前端应用用来执行特定操作（例如错误处理）来响应一个特定数据库错误。一个可能的 SQLSTATE 代码列表可见<xref linkend="errcodes-appendix"/>。这个域无法被本地化，并且总是存在。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-message-primary">
          <term><symbol>PG_DIAG_MESSAGE_PRIMARY</symbol></term>
          <listitem>
           <para>
            主要的人类可读的错误消息（通常是一行）。总是存在。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-message-detail">
          <term><symbol>PG_DIAG_MESSAGE_DETAIL</symbol></term>
          <listitem>
           <para>
            细节：一个可选的次级错误消息，它携带了关于问题的等多细节。可能有多行。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-message-hint">
          <term><symbol>PG_DIAG_MESSAGE_HINT</symbol></term>
          <listitem>
           <para>
            提示：一个关于如何处理该问题的可选建议。它与细节的区别在于它提供了建议（可能不合适）而不是铁的事实。可能有多行。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-statement-position">
          <term><symbol>PG_DIAG_STATEMENT_POSITION</symbol></term>
          <listitem>
           <para>
            包含一个十进制整数的字符串，它表示一个错误游标位置，该位置是原始语句字符串的索引。第一个字符的索引是 1，位置以字符计算而不是以及字节计算。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-internal-position">
          <term><symbol>PG_DIAG_INTERNAL_POSITION</symbol></term>
          <listitem>
           <para>
            这被定义为与<symbol>PG_DIAG_STATEMENT_POSITION</symbol>域相同，但是它被用在游标位置引用一个内部产生的命令而不是客户端提交的命令时。当这个域出现时，<symbol>PG_DIAG_INTERNAL_QUERY</symbol>域将总是出现。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-internal-query">
          <term><symbol>PG_DIAG_INTERNAL_QUERY</symbol></term>
          <listitem>
           <para>
            一个失败的内部产生的命令的文本。例如，这可能是由一个 PL/pgSQL 函数发出的 SQL 查询。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-context">
          <term><symbol>PG_DIAG_CONTEXT</symbol></term>
          <listitem>
           <para>
            指示错误发生的环境。当前这包括活动过程语言函数的调用栈追踪以及内部生成的查询。追踪是每行一项，最近的排在最前面。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-schema-name">
          <term><symbol>PG_DIAG_SCHEMA_NAME</symbol></term>
          <listitem>
           <para>
            如果错误与某个特定的数据库对象相关，这里是包含该对象的模式名（如果有）。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-table-name">
          <term><symbol>PG_DIAG_TABLE_NAME</symbol></term>
          <listitem>
           <para>
            如果错误与某个特定表相关，这里是该表的名字（该表的模式参考模式名域）。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-column-name">
          <term><symbol>PG_DIAG_COLUMN_NAME</symbol></term>
          <listitem>
           <para>
            如果错误与一个特定表列相关，这里是该表列的名字（参考模式和表名域来标识该表）。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-datatype-name">
          <term><symbol>PG_DIAG_DATATYPE_NAME</symbol></term>
          <listitem>
           <para>
            如果错误与一个特定数据类型相关，这里是该数据了行的名字（该数据类型的模式名参考模式名域）。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-constraint-name">
          <term><symbol>PG_DIAG_CONSTRAINT_NAME</symbol></term>
          <listitem>
           <para>
            如果错误与一个特定约束相关，这里是该约束的名字。相关的表或域参考上面列出的域（为了这个目的，索引也被视作约束，即使它们不是用约束语法创建的）。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-source-file">
          <term><symbol>PG_DIAG_SOURCE_FILE</symbol></term>
          <listitem>
           <para>
            报告错误的源代码所在的文件名。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-source-line">
          <term><symbol>PG_DIAG_SOURCE_LINE</symbol></term>
          <listitem>
           <para>
            报告错误的源代码行号。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-source-function">
          <term><symbol>PG_DIAG_SOURCE_FUNCTION</symbol></term>
          <listitem>
           <para>
            报告错误的源代码函数的名字。
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>

       <note>
        <para>
         用于模式名、表名、列名、数据类型名和约束名的域只提供给有限的错误类型，见<xref linkend="errcodes-appendix"/>。不要假定任何这些域的存在保证另一个域的存在。核心错误源会遵守上面提到的内在联系，但是用户定义的函数可能以其他方式使用这些域。同样地，不要假定这些域代表当前数据库中同类的对象。
        </para>
       </note>

       <para>
        客户端负责格式化显示信息来迎合它的需要，特别是根据需要打断长的行。出现在错误消息域中的新行字符应该被当作分段而不是换行。
       </para>

       <para>
        <application>libpq</application>内部产生的错误将有严重和主要消息，但是通常没有其他域。
       </para>

       <para>
        注意错误与只从<structname>PGresult</structname>对象中有效，对<structname>PGconn</structname>对象无效。没有<function>PQerrorField</function>函数。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-PQclear">
      <term><function>PQclear</function><indexterm><primary>PQclear</primary></indexterm></term>
      <listitem>
       <para>
        Frees  the  storage  associated with a
        释放与一个<structname>PGresult</structname>相关的存储。每一个命令结果不再需要时应该用<xref linkend="libpq-PQclear"/>释放。

<synopsis>
void PQclear(PGresult *res);
</synopsis>
       </para>

       <para>
        你可以按照需要保留<structname>PGresult</structname>对象，当你发出一个新命令时它也不会消失，甚至关闭连接时也不会消失。
        要去掉它，你必须调用<xref linkend="libpq-PQclear"/>。没有这样做将会导致在应用中的内存泄露。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
<!-- pgdoc-cn_end sig_en=3129b2e0d6d3b2161da7ec663766dcec -->
  </sect2>

  <sect2 id="libpq-exec-select-info">
<!-- pgdoc-cn_start sig_en=cec434a79c231c2b1421a77f4d76d285 sig_cn_org=None source=14.1 
   <title>Retrieving Query Result Information</title>
________________________________________________________-->
   <title>检索查询结果信息</title>
<!-- pgdoc-cn_end sig_en=cec434a79c231c2b1421a77f4d76d285 -->

<!-- pgdoc-cn_start sig_en=f1249adbc723d5318577619f264a19cf sig_cn_org=None source=14.1 
   <para>
    These functions are used to extract information from a
    <structname>PGresult</structname> object that represents a successful
    query result (that is, one that has status
    <literal>PGRES_TUPLES_OK</literal> or <literal>PGRES_SINGLE_TUPLE</literal>).
    They can also be used to extract
    information from a successful Describe operation: a Describe's result
    has all the same column information that actual execution of the query
    would provide, but it has zero rows.  For objects with other status values,
    these functions will act as though the result has zero rows and zero columns.
   </para>
________________________________________________________-->
   <para>
    这些函数被用来从一个代表成功查询结果（也就是状态为<literal>PGRES_TUPLES_OK</literal>或者<literal>PGRES_SINGLE_TUPLE</literal>）的<structname>PGresult</structname>对象中抽取信息。它们也可以被用来从一个成功的 Describe 操作中抽取信息：一个 Describe 的结果具有和该查询被实际执行所提供的完全相同的列信息，但是它没有行。对于其他状态值的对象，这些函数会认为结果具有零行和零列。
   </para>
<!-- pgdoc-cn_end sig_en=f1249adbc723d5318577619f264a19cf -->

   <variablelist>
    <varlistentry id="libpq-PQntuples">
<!-- pgdoc-cn_start sig_en=c4db0371be97efe911375ec5b89d7ce6 sig_cn_org=None source=14.1 
     <term><function>PQntuples</function><indexterm><primary>PQntuples</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQntuples</function><indexterm><primary>PQntuples</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=c4db0371be97efe911375ec5b89d7ce6 -->

     <listitem>
<!-- pgdoc-cn_start sig_en=c38179992d324913b74c8ab5421c81eb sig_cn_org=None source=14.1 
      <para>
       Returns the number of rows (tuples) in the query result.
       (Note that <structname>PGresult</structname> objects are limited to no more
       than <literal>INT_MAX</literal> rows, so an <type>int</type> result is
       sufficient.)

<synopsis>
int PQntuples(const PGresult *res);
</synopsis>

      </para>
________________________________________________________-->
      <para>
       返回查询结果中的行（元组）数（注意，<structname>PGresult</structname>对象被限制为不超过<literal>INT_MAX</literal>行，因此一个<type>int</type>结果就足够了）。

<synopsis>
int PQntuples(const PGresult *res);
</synopsis>

      </para>
<!-- pgdoc-cn_end sig_en=c38179992d324913b74c8ab5421c81eb -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQnfields">
<!-- pgdoc-cn_start sig_en=c9fb7091312860ab55ffe86d415bc944 sig_cn_org=None source=14.1 
     <term><function>PQnfields</function><indexterm><primary>PQnfields</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQnfields</function><indexterm><primary>PQnfields</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=c9fb7091312860ab55ffe86d415bc944 -->

     <listitem>
<!-- pgdoc-cn_start sig_en=b256817cb5aff03b5bd7c8e515c9b487 sig_cn_org=None source=14.1 
      <para>
       Returns the number of columns (fields) in each row of the query
       result.

<synopsis>
int PQnfields(const PGresult *res);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       返回查询结果中每一行的列（域）数。

<synopsis>
int PQnfields(const PGresult *res);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=b256817cb5aff03b5bd7c8e515c9b487 -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQfname">
<!-- pgdoc-cn_start sig_en=634b95a243ce3cd967ae3f3a5c372378 sig_cn_org=None source=14.1 
     <term><function>PQfname</function><indexterm><primary>PQfname</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQfname</function><indexterm><primary>PQfname</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=634b95a243ce3cd967ae3f3a5c372378 -->

     <listitem>
<!-- pgdoc-cn_start sig_en=4ebea04a1c3476cdcec1fc9bd76957e4 sig_cn_org=None source=14.1 
      <para>
       Returns the column name associated with the given column number.
       Column numbers start at 0. The caller should not free the result
       directly. It will be freed when the associated
       <structname>PGresult</structname> handle is passed to
       <xref linkend="libpq-PQclear"/>.
<synopsis>
char *PQfname(const PGresult *res,
              int column_number);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       返回与给定列号相关联的列名。列号从 0 开始。调用者不应该直接释放该结果。它将在相关的<structname>PGresult</structname>句柄被传递给<xref linkend="libpq-PQclear"/>之后被释放。
<synopsis>
char *PQfname(const PGresult *res,
              int column_number);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=4ebea04a1c3476cdcec1fc9bd76957e4 -->

<!-- pgdoc-cn_start sig_en=b0b67ce51f262dbfeabd586468483142 sig_cn_org=None source=14.1 
      <para>
       <symbol>NULL</symbol> is returned if the column number is out of range.
      </para>
________________________________________________________-->
      <para>
       如果列号超出范围，将返回<symbol>NULL</symbol>。
      </para>
<!-- pgdoc-cn_end sig_en=b0b67ce51f262dbfeabd586468483142 -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQfnumber">
<!-- pgdoc-cn_start sig_en=82d260d8146e97dc423b2c5bb535863c sig_cn_org=None source=14.1 
     <term><function>PQfnumber</function><indexterm><primary>PQfnumber</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQfnumber</function><indexterm><primary>PQfnumber</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=82d260d8146e97dc423b2c5bb535863c -->

     <listitem>
<!-- pgdoc-cn_start sig_en=ba561b0af36a2454bf1f51e568f1c6c0 sig_cn_org=None source=14.1 
      <para>
       Returns the column number associated with the given column name.
<synopsis>
int PQfnumber(const PGresult *res,
              const char *column_name);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       返回与给定列名相关联的列号。
<synopsis>
int PQfnumber(const PGresult *res,
              const char *column_name);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=ba561b0af36a2454bf1f51e568f1c6c0 -->

<!-- pgdoc-cn_start sig_en=3a06721aa8cf4bc468da630d91a71842 sig_cn_org=None source=14.1 
      <para>
       -1 is returned if the given name does not match any column.
      </para>
________________________________________________________-->
      <para>
       如果给定的名字不匹配任何列，将返回 -1。
      </para>
<!-- pgdoc-cn_end sig_en=3a06721aa8cf4bc468da630d91a71842 -->

<!-- pgdoc-cn_start sig_en=5c4b0a09411d33f406625085896193c3 sig_cn_org=None source=14.1 
      <para>
       The given name is treated like an identifier in an SQL command,
       that is, it is downcased unless double-quoted.  For example, given
       a query result generated from the SQL command:
<programlisting>
SELECT 1 AS FOO, 2 AS "BAR";
</programlisting>
       we would have the results:
<programlisting>
PQfname(res, 0)              <lineannotation>foo</lineannotation>
PQfname(res, 1)              <lineannotation>BAR</lineannotation>
PQfnumber(res, "FOO")        <lineannotation>0</lineannotation>
PQfnumber(res, "foo")        <lineannotation>0</lineannotation>
PQfnumber(res, "BAR")        <lineannotation>-1</lineannotation>
PQfnumber(res, "\"BAR\"")    <lineannotation>1</lineannotation>
</programlisting>
      </para>
________________________________________________________-->
      <para>
       给定的名称被视作一个 SQL 命令中的一个标识符，也就是说，除非被双引号引用，它是小写形式的。例如，给定一个 SQL 命令：
<programlisting>
SELECT 1 AS FOO, 2 AS "BAR";
</programlisting>
       我们将得到结果：
<programlisting>
PQfname(res, 0)              <lineannotation>foo</lineannotation>
PQfname(res, 1)              <lineannotation>BAR</lineannotation>
PQfnumber(res, "FOO")        <lineannotation>0</lineannotation>
PQfnumber(res, "foo")        <lineannotation>0</lineannotation>
PQfnumber(res, "BAR")        <lineannotation>-1</lineannotation>
PQfnumber(res, "\"BAR\"")    <lineannotation>1</lineannotation>
</programlisting>
      </para>
<!-- pgdoc-cn_end sig_en=5c4b0a09411d33f406625085896193c3 -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQftable">
<!-- pgdoc-cn_start sig_en=8947f1f7a04769b1e2c88a4eed5556f0 sig_cn_org=None source=14.1 
     <term><function>PQftable</function><indexterm><primary>PQftable</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQftable</function><indexterm><primary>PQftable</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=8947f1f7a04769b1e2c88a4eed5556f0 -->

     <listitem>
<!-- pgdoc-cn_start sig_en=3d5cde65fc93d7ffc8a11675cc0dcfe3 sig_cn_org=None source=14.1 
      <para>
       Returns the OID of the table from which the given column was
       fetched.  Column numbers start at 0.
<synopsis>
Oid PQftable(const PGresult *res,
             int column_number);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       返回给定列从中取出的表的 OID。列号从 0 开始。
<synopsis>
Oid PQftable(const PGresult *res,
             int column_number);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=3d5cde65fc93d7ffc8a11675cc0dcfe3 -->

<!-- pgdoc-cn_start sig_en=37f4c0bf2365e489c81d1537835597ec sig_cn_org=None source=14.1 
      <para>
       <literal>InvalidOid</literal> is returned if the column number is out of range,
       or if the specified column is not a simple reference to a table column.
       You can query the system table <literal>pg_class</literal> to determine
       exactly which table is referenced.
      </para>
________________________________________________________-->
      <para>
       如果列号超出范围或者指定的列不是对一个表列的简单引用时，返回<literal>InvalidOid</literal>。
       你可以查询系统表<literal>pg_class</literal>来确定究竟是哪个表被引用。
      </para>
<!-- pgdoc-cn_end sig_en=37f4c0bf2365e489c81d1537835597ec -->

<!-- pgdoc-cn_start sig_en=5c3eefebdc854ae04bb400de07cf2f07 sig_cn_org=None source=14.1 
      <para>
       The type <type>Oid</type> and the constant
       <literal>InvalidOid</literal> will be defined when you include
       the <application>libpq</application> header file. They will both
       be some integer type.
      </para>
________________________________________________________-->
      <para>
       当你包括<application>libpq</application>头文件，类型<type>oid</type>以及常数<literal>InvalidOid</literal>将被定义。它们将都是某种整数类型。
      </para>
<!-- pgdoc-cn_end sig_en=5c3eefebdc854ae04bb400de07cf2f07 -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQftablecol">
<!-- pgdoc-cn_start sig_en=d46273d4739257c8eb4b3d523243421c sig_cn_org=None source=14.1 
     <term><function>PQftablecol</function><indexterm><primary>PQftablecol</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQftablecol</function><indexterm><primary>PQftablecol</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=d46273d4739257c8eb4b3d523243421c -->

     <listitem>
<!-- pgdoc-cn_start sig_en=f2979f6d4a919af8c5744ee5aec6cda7 sig_cn_org=None source=14.1 
      <para>
       Returns the column number (within its table) of the column making
       up the specified query result column.  Query-result column numbers
       start at 0, but table columns have nonzero numbers.
<synopsis>
int PQftablecol(const PGresult *res,
                int column_number);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       返回构成指定查询结果列的列（在其表中）的列号。查询结果列号从 0 开始，但是表列具有非零编号。
<synopsis>
int PQftablecol(const PGresult *res,
                int column_number);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=f2979f6d4a919af8c5744ee5aec6cda7 -->

<!-- pgdoc-cn_start sig_en=61aaa9931fd6bd42d31973f09f920d1f sig_cn_org=None source=14.1 
      <para>
       Zero is returned if the column number is out of range, or if the
       specified column is not a simple reference to a table column.
      </para>
________________________________________________________-->
      <para>
       如果列号超出范围或者指定的列不是对一个表列的简单引用时，返回零。
      </para>
<!-- pgdoc-cn_end sig_en=61aaa9931fd6bd42d31973f09f920d1f -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQfformat">
<!-- pgdoc-cn_start sig_en=8dbe0c61b2f3d082764c8af2d991c012 sig_cn_org=None source=14.1 
     <term><function>PQfformat</function><indexterm><primary>PQfformat</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQfformat</function><indexterm><primary>PQfformat</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=8dbe0c61b2f3d082764c8af2d991c012 -->

     <listitem>
<!-- pgdoc-cn_start sig_en=a1bc19a602f3f0c1fb4f7eb92ed4ec58 sig_cn_org=None source=14.1 
      <para>
       Returns the format code indicating the format of the given
       column.  Column numbers start at 0.
<synopsis>
int PQfformat(const PGresult *res,
              int column_number);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       返回指示给定列格式的格式编码。列号从 0 开始。
<synopsis>
int PQfformat(const PGresult *res,
              int column_number);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=a1bc19a602f3f0c1fb4f7eb92ed4ec58 -->

<!-- pgdoc-cn_start sig_en=ad564cb63a0d0a59e792cf5a5c3e25ba sig_cn_org=None source=14.1 
      <para>
       Format code zero indicates textual data representation, while format
       code one indicates binary representation.  (Other codes are reserved
       for future definition.)
      </para>
________________________________________________________-->
      <para>
       格式代码零指示文本数据表示，而格式代码一表示二进制表示（其他代码被保留用于未来的定义）。
      </para>
<!-- pgdoc-cn_end sig_en=ad564cb63a0d0a59e792cf5a5c3e25ba -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQftype">
<!-- pgdoc-cn_start sig_en=5cbb3639e453027ba00b77921d5bbcd6 sig_cn_org=None source=14.1 
     <term><function>PQftype</function><indexterm><primary>PQftype</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQftype</function><indexterm><primary>PQftype</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=5cbb3639e453027ba00b77921d5bbcd6 -->

     <listitem>
<!-- pgdoc-cn_start sig_en=0b2e38bf5ac5a3af68cf3a9ecf58199a sig_cn_org=None source=14.1 
      <para>
       Returns the data type associated with the given  column number.
       The  integer  returned is the internal OID number of the type.
       Column numbers start at 0.
<synopsis>
Oid PQftype(const PGresult *res,
            int column_number);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       返回与给定列号相关联的数据类型。被返回的整数是该类型的内部 OID 号。列号从 0 开始。
<synopsis>
Oid PQftype(const PGresult *res,
            int column_number);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=0b2e38bf5ac5a3af68cf3a9ecf58199a -->

<!-- pgdoc-cn_start sig_en=5c1d6a700dbf93010dc2e8ec59b8ce01 sig_cn_org=None source=14.1 
      <para>
       You can query the system table <literal>pg_type</literal> to
       obtain the names and properties of the various data types. The
       <acronym>OID</acronym>s of the built-in data types are defined
       in the file <filename>catalog/pg_type_d.h</filename>
       in the <productname>PostgreSQL</productname>
       installation's <filename>include</filename> directory.
      </para>
________________________________________________________-->
      <para>
       你可以查询系统表<literal>pg_type</literal>来得到多个数据类型的名字和属性。
       内建数据类型的<acronym>OID</acronym>被定义在<productname>PostgreSQL</productname>安装的<filename>include</filename>目录中的<filename>catalog/pg_type_d.h</filename>文件中。
      </para>
<!-- pgdoc-cn_end sig_en=5c1d6a700dbf93010dc2e8ec59b8ce01 -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQfmod">
<!-- pgdoc-cn_start sig_en=fa65ed8376130183155c2e2fc3b87fdb sig_cn_org=None source=14.1 
     <term><function>PQfmod</function><indexterm><primary>PQfmod</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQfmod</function><indexterm><primary>PQfmod</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=fa65ed8376130183155c2e2fc3b87fdb -->

     <listitem>
<!-- pgdoc-cn_start sig_en=ccbefdeb8b728bc1590fd111a8b23de0 sig_cn_org=None source=14.1 
      <para>
       Returns  the type modifier of the column associated with the
       given column number.  Column numbers start at 0.
<synopsis>
int PQfmod(const PGresult *res,
           int column_number);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       返回与给定列号相关联的列的修饰符类型。列号从 0 开始。
<synopsis>
int PQfmod(const PGresult *res,
           int column_number);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=ccbefdeb8b728bc1590fd111a8b23de0 -->

<!-- pgdoc-cn_start sig_en=f0b24591056f3af2daa9d5e5bc2e3709 sig_cn_org=None source=14.1 
      <para>
       The interpretation of modifier values is type-specific; they
       typically indicate precision or size limits.  The value -1 is
       used to indicate <quote>no information available</quote>.  Most data
       types do not use modifiers, in which case the value is always
       -1.
      </para>
________________________________________________________-->
      <para>
       修饰符值的解释是与类型相关的，它们通常指示精度或尺寸限制。值 -1 被用来指示<quote>没有信息可用</quote>。大部分的数据类型不适用修饰符，在那种情况中值总是 -1。
      </para>
<!-- pgdoc-cn_end sig_en=f0b24591056f3af2daa9d5e5bc2e3709 -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQfsize">
<!-- pgdoc-cn_start sig_en=6ad1eb1cb7defbd0fc3c769dd22aca5f sig_cn_org=None source=14.1 
     <term><function>PQfsize</function><indexterm><primary>PQfsize</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQfsize</function><indexterm><primary>PQfsize</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=6ad1eb1cb7defbd0fc3c769dd22aca5f -->

     <listitem>
<!-- pgdoc-cn_start sig_en=a82de17f91b06081fe62fd6cbd4f04c8 sig_cn_org=None source=14.1 
      <para>
       Returns  the  size  in bytes of the column associated with the
       given column number.  Column numbers start at 0.
<synopsis>
int PQfsize(const PGresult *res,
            int column_number);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       返回与给定列号相关的列的尺寸（以字节计）。列号从 0 开始。
<synopsis>
int PQfsize(const PGresult *res,
            int column_number);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=a82de17f91b06081fe62fd6cbd4f04c8 -->

<!-- pgdoc-cn_start sig_en=3537249f71067e630f62199ccd58388c sig_cn_org=None source=14.1 
      <para>
       <xref linkend="libpq-PQfsize"/> returns the space allocated for this column
       in a database row, in other words the size of the server's
       internal representation of the data type.  (Accordingly, it is
       not really very useful to clients.) A negative value indicates
       the data type is variable-length.
      </para>
________________________________________________________-->
      <para>
       <xref linkend="libpq-PQfsize"/>返回在一个数据库行中为这个列分配的空间，换句话说是服务器对该数据类型的内部表示的尺寸（因此，它对客户端并不是真地非常有用）。一个负值指示该数据类型是变长的。
      </para>
<!-- pgdoc-cn_end sig_en=3537249f71067e630f62199ccd58388c -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQbinaryTuples">
<!-- pgdoc-cn_start sig_en=452fcc5f6852e29c0496d53af996351a sig_cn_org=None source=14.1 
     <term><function>PQbinaryTuples</function><indexterm><primary>PQbinaryTuples</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQbinaryTuples</function><indexterm><primary>PQbinaryTuples</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=452fcc5f6852e29c0496d53af996351a -->

     <listitem>
<!-- pgdoc-cn_start sig_en=a1b3d9e6c1ffa60e7cd011d7a6dca908 sig_cn_org=None source=14.1 
      <para>
       Returns 1 if the <structname>PGresult</structname> contains binary data
       and 0 if it contains text data.
<synopsis>
int PQbinaryTuples(const PGresult *res);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       如果<structname>PGresult</structname>包含二进制数据，返回 1。如果包含的是文本数据，返回 0。
<synopsis>
int PQbinaryTuples(const PGresult *res);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=a1b3d9e6c1ffa60e7cd011d7a6dca908 -->

<!-- pgdoc-cn_start sig_en=28255c96dcc381893d16001c7f7e7acc sig_cn_org=None source=14.1 
      <para>
       This function is deprecated (except for its use in connection with
       <command>COPY</command>), because it is possible for a single
       <structname>PGresult</structname> to contain text data in some columns and
       binary data in others.  <xref linkend="libpq-PQfformat"/> is preferred.
       <xref linkend="libpq-PQbinaryTuples"/> returns 1 only if all columns of the
       result are binary (format 1).
      </para>
________________________________________________________-->
      <para>
       这个函数已经被废弃（除了与<command>COPY</command>一起使用），因为一个单一<structname>PGresult</structname>可以在某些列中包含文本数据而且在另一些列中包含二进制数据。
       <xref linkend="libpq-PQfformat"/>要更好。只有结果的所有列是二进制（格式 1）时<xref linkend="libpq-PQbinaryTuples"/>才返回 1。
      </para>
<!-- pgdoc-cn_end sig_en=28255c96dcc381893d16001c7f7e7acc -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQgetvalue">
<!-- pgdoc-cn_start sig_en=d2a3477ed487946a8330661d26752c61 sig_cn_org=None source=14.1 
     <term><function>PQgetvalue</function><indexterm><primary>PQgetvalue</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQgetvalue</function><indexterm><primary>PQgetvalue</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=d2a3477ed487946a8330661d26752c61 -->

     <listitem>
<!-- pgdoc-cn_start sig_en=6a23aaae1a82730b6bfd61c04b234ac7 sig_cn_org=None source=14.1 
      <para>
       Returns a single field value of one row of a
       <structname>PGresult</structname>.  Row and column numbers start
       at 0.  The caller should not free the result directly.  It will
       be freed when the associated <structname>PGresult</structname> handle is
       passed to <xref linkend="libpq-PQclear"/>.
<synopsis>
char *PQgetvalue(const PGresult *res,
                 int row_number,
                 int column_number);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       返回一个<structname>PGresult</structname>的一行的单一域值。行和列号从 0 开始。调用者不应该直接释放该结果。
       它将在相关的<structname>PGresult</structname>句柄被传递给<xref linkend="libpq-PQclear"/>之后被释放。
<synopsis>
char *PQgetvalue(const PGresult *res,
                 int row_number,
                 int column_number);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=6a23aaae1a82730b6bfd61c04b234ac7 -->

<!-- pgdoc-cn_start sig_en=ae238d9d7337d03df0e74dda9c741141 sig_cn_org=None source=14.1 
      <para>
       For data in text format, the value returned by
       <xref linkend="libpq-PQgetvalue"/> is a null-terminated character
       string  representation of the field value.  For data in binary
       format, the value is in the binary representation determined by
       the data type's <function>typsend</function> and <function>typreceive</function>
       functions.  (The value is actually followed by a zero byte in
       this case too, but that is not ordinarily useful, since the
       value is likely to contain embedded nulls.)
      </para>
________________________________________________________-->
      <para>
       对于文本格式的数据，<xref linkend="libpq-PQgetvalue"/>返回的值是该域值的一种空值结束的字符串表示。对于二进制格式的数据，该值是由该数据类型的<function>typsend</function>和<function>typreceive</function>函数决定的二进制表示（在这种情况下该值实际上也跟随着一个零字节，但是这通常没有用处，因为该值很可能包含嵌入的空）。
      </para>
<!-- pgdoc-cn_end sig_en=ae238d9d7337d03df0e74dda9c741141 -->

<!-- pgdoc-cn_start sig_en=110b8bb4f8199330bd739c57b3b2e593 sig_cn_org=None source=14.1 
      <para>
       An empty string is returned if the field value is null.  See
       <xref linkend="libpq-PQgetisnull"/> to distinguish null values from
       empty-string values.
      </para>
________________________________________________________-->
      <para>
       如果该域值为空，则返回一个空串。关于区分空值和空字符串值请见<xref linkend="libpq-PQgetisnull"/>。
      </para>
<!-- pgdoc-cn_end sig_en=110b8bb4f8199330bd739c57b3b2e593 -->

<!-- pgdoc-cn_start sig_en=23c6a1dd75edc3e00bc3c070df01ea79 sig_cn_org=None source=14.1 
      <para>
       The pointer returned  by  <xref linkend="libpq-PQgetvalue"/> points
       to storage that is part of the <structname>PGresult</structname>
       structure.  One should not modify the data it points to, and one
       must explicitly copy the data into other storage if it is to be
       used past the lifetime of the  <structname>PGresult</structname>
       structure itself.
      </para>
________________________________________________________-->
      <para>
       <xref linkend="libpq-PQgetvalue"/>返回的指针指向作为<structname>PGresult</structname>结构一部分的存储。我们不应该修改它指向的数据，并且如果要在超过<structname>PGresult</structname>结构本身的生命期之外使用它，我们必须显式地把该数据拷贝到其他存储中。
      </para>
<!-- pgdoc-cn_end sig_en=23c6a1dd75edc3e00bc3c070df01ea79 -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQgetisnull">
<!-- pgdoc-cn_start sig_en=ebefc55efe76df78039ab10778cff32f sig_cn_org=None source=14.1 
     <term><function>PQgetisnull</function><indexterm
     ><primary>PQgetisnull</primary></indexterm><indexterm
     ><primary>null value</primary><secondary sortas="libpq">in libpq</secondary></indexterm></term>
________________________________________________________-->
     <term><function>PQgetisnull</function><indexterm
     ><primary>PQgetisnull</primary></indexterm><indexterm
     ><primary>null value</primary><secondary sortas="libpq">in libpq</secondary></indexterm></term>
<!-- pgdoc-cn_end sig_en=ebefc55efe76df78039ab10778cff32f -->

     <listitem>
<!-- pgdoc-cn_start sig_en=a8fad9f70fae5c5770109d818cfbd3d1 sig_cn_org=None source=14.1 
      <para>
       Tests a field for a null value.  Row and column numbers start
       at 0.
<synopsis>
int PQgetisnull(const PGresult *res,
                int row_number,
                int column_number);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       测试一个域是否为空值。行号和列号从 0 开始。
<synopsis>
int PQgetisnull(const PGresult *res,
                int row_number,
                int column_number);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=a8fad9f70fae5c5770109d818cfbd3d1 -->

<!-- pgdoc-cn_start sig_en=b69e6e303da6c23e537110afdd12c0f5 sig_cn_org=None source=14.1 
      <para>
       This function returns  1 if the field is null and 0 if it
       contains a non-null value.  (Note that
       <xref linkend="libpq-PQgetvalue"/> will return an empty string,
       not a null pointer, for a null field.)
      </para>
________________________________________________________-->
      <para>
       如果该域是空，这个函数返回 1。如果它包含一个非空值，则返回 0（注意<xref linkend="libpq-PQgetvalue"/>将为一个空域返回一个空串，不是一个空指针）。
      </para>
<!-- pgdoc-cn_end sig_en=b69e6e303da6c23e537110afdd12c0f5 -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQgetlength">
<!-- pgdoc-cn_start sig_en=12d473c1c6ccd11430944b2ab21384da sig_cn_org=None source=14.1 
     <term><function>PQgetlength</function><indexterm><primary>PQgetlength</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQgetlength</function><indexterm><primary>PQgetlength</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=12d473c1c6ccd11430944b2ab21384da -->

     <listitem>
<!-- pgdoc-cn_start sig_en=f76ea868889b281b6d8022ac88174835 sig_cn_org=None source=14.1 
      <para>
       Returns the actual length of a field value in bytes.  Row and
       column numbers start at 0.
<synopsis>
int PQgetlength(const PGresult *res,
                int row_number,
                int column_number);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       返回一个域值的真实长度，以字节计。行号和列号从 0 开始。
<synopsis>
int PQgetlength(const PGresult *res,
                int row_number,
                int column_number);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=f76ea868889b281b6d8022ac88174835 -->

<!-- pgdoc-cn_start sig_en=d5d6099c1d0f1f70c5836b0dbbe37ef9 sig_cn_org=None source=14.1 
      <para>
       This is the actual data length for the particular data value,
       that is, the size of the object pointed to by
       <xref linkend="libpq-PQgetvalue"/>.  For text data format this is
       the same as <function>strlen()</function>.  For binary format this is
       essential information.  Note that one should <emphasis>not</emphasis>
       rely on <xref linkend="libpq-PQfsize"/> to obtain the actual data
       length.
      </para>
________________________________________________________-->
      <para>
       这是特定数据值的真实数据长度，也就是<xref linkend="libpq-PQgetvalue"/>指向的对象的尺寸。
       对于文本数据格式，这和<function>strlen()</function>相同。对于二进制格式这是基本信息。
       注意我们<emphasis>不</emphasis>应该依赖于<xref linkend="libpq-PQfsize"/>来得到真值的数据长度。
      </para>
<!-- pgdoc-cn_end sig_en=d5d6099c1d0f1f70c5836b0dbbe37ef9 -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQnparams">
<!-- pgdoc-cn_start sig_en=3e73eee780c428085b6c7a1f65b77e24 sig_cn_org=None source=14.1 
     <term><function>PQnparams</function><indexterm><primary>PQnparams</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQnparams</function><indexterm><primary>PQnparams</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=3e73eee780c428085b6c7a1f65b77e24 -->

     <listitem>
<!-- pgdoc-cn_start sig_en=3cca0a2de0ed9d14b6f6adec07015964 sig_cn_org=None source=14.1 
      <para>
       Returns the number of parameters of a prepared statement.
<synopsis>
int PQnparams(const PGresult *res);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       返回一个预备语句的参数数量。
<synopsis>
int PQnparams(const PGresult *res);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=3cca0a2de0ed9d14b6f6adec07015964 -->

<!-- pgdoc-cn_start sig_en=a0cdf058f5060441b3224748f242d269 sig_cn_org=None source=14.1 
      <para>
       This function is only useful when inspecting the result of
       <xref linkend="libpq-PQdescribePrepared"/>.  For other types of queries it
       will return zero.
      </para>
________________________________________________________-->
      <para>
       只有在查看<xref linkend="libpq-PQdescribePrepared"/>的结果时，这个函数才有用。对于其他类型的查询，它将返回零。
      </para>
<!-- pgdoc-cn_end sig_en=a0cdf058f5060441b3224748f242d269 -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQparamtype">
<!-- pgdoc-cn_start sig_en=10f8affd4c19c1172cdb642f03868095 sig_cn_org=None source=14.1 
     <term><function>PQparamtype</function><indexterm><primary>PQparamtype</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQparamtype</function><indexterm><primary>PQparamtype</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=10f8affd4c19c1172cdb642f03868095 -->

     <listitem>
<!-- pgdoc-cn_start sig_en=2ea945b8412192318d4f08db41ef53ad sig_cn_org=None source=14.1 
      <para>
       Returns the data type of the indicated statement parameter.
       Parameter numbers start at 0.
<synopsis>
Oid PQparamtype(const PGresult *res, int param_number);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       返回所指示的语句参数的数据类型。参数号从 0 开始。
<synopsis>
Oid PQparamtype(const PGresult *res, int param_number);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=2ea945b8412192318d4f08db41ef53ad -->

<!-- pgdoc-cn_start sig_en=a0cdf058f5060441b3224748f242d269 sig_cn_org=None source=14.1 
      <para>
       This function is only useful when inspecting the result of
       <xref linkend="libpq-PQdescribePrepared"/>.  For other types of queries it
       will return zero.
      </para>
________________________________________________________-->
      <para>
       只有在查看<xref linkend="libpq-PQdescribePrepared"/>的结果时，这个函数才有用。对于其他类型的查询，它将返回零。
      </para>
<!-- pgdoc-cn_end sig_en=a0cdf058f5060441b3224748f242d269 -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQprint">
<!-- pgdoc-cn_start sig_en=d001402c2444bbc348f06c66224b613d sig_cn_org=None source=14.1 
     <term><function>PQprint</function><indexterm><primary>PQprint</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQprint</function><indexterm><primary>PQprint</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=d001402c2444bbc348f06c66224b613d -->

     <listitem>
<!-- pgdoc-cn_start sig_en=bd91c8584f9d80c9dc9ed059f9f38c1e sig_cn_org=None source=14.1 
      <para>
       Prints out all the rows and,  optionally,  the column names  to
       the specified output stream.
<synopsis>
void PQprint(FILE *fout,      /* output stream */
             const PGresult *res,
             const PQprintOpt *po);
typedef struct
{
    pqbool  header;      /* print output field headings and row count */
    pqbool  align;       /* fill align the fields */
    pqbool  standard;    /* old brain dead format */
    pqbool  html3;       /* output HTML tables */
    pqbool  expanded;    /* expand tables */
    pqbool  pager;       /* use pager for output if needed */
    char    *fieldSep;   /* field separator */
    char    *tableOpt;   /* attributes for HTML table element */
    char    *caption;    /* HTML table caption */
    char    **fieldName; /* null-terminated array of replacement field names */
} PQprintOpt;
</synopsis>
      </para>
________________________________________________________-->
      <para>
       将所有的行打印到指定的输出流，以及有选择地将列名打印到指定的输出流。
<synopsis>
void PQprint(FILE *fout,      /* 输出流 */
             const PGresult *res,
             const PQprintOpt *po);
typedef struct
{
    pqbool  header;      /* 打印输出域标题和行计数 */
    pqbool  align;       /* 填充对齐域 */
    pqbool  standard;    /* 旧的格式 */
    pqbool  html3;       /* 输出 HTML 表格 */
    pqbool  expanded;    /* 扩展表格 */
    pqbool  pager;       /* 如果必要为输出使用页 */
    char    *fieldSep;   /* 域分隔符 */
    char    *tableOpt;   /* 用于 HTML 表格元素的属性 */
    char    *caption;    /* HTML 表格标题 */
    char    **fieldName; /* 替换域名称的空终止数组 */
} PQprintOpt;
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=bd91c8584f9d80c9dc9ed059f9f38c1e -->

<!-- pgdoc-cn_start sig_en=7bd8a27b850e4fd34dfb0e9f84d512d5 sig_cn_org=None source=14.1 
      <para>
       This function was formerly used by <application>psql</application>
       to print query results, but this is no longer the case.  Note
       that it assumes all the data is in text format.
      </para>
________________________________________________________-->
      <para>
       这个函数以前被<application>psql</application>用来打印查询结果，但是现在不是这样了。注意它假定所有的数据都是文本格式。
      </para>
<!-- pgdoc-cn_end sig_en=7bd8a27b850e4fd34dfb0e9f84d512d5 -->
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 id="libpq-exec-nonselect">
<!-- pgdoc-cn_start sig_en=b881a3d8de47dd3505be1a35a707ffba sig_cn_org=None source=14.1 
   <title>Retrieving Other Result Information</title>
________________________________________________________-->
   <title>检索其他结果信息</title>
<!-- pgdoc-cn_end sig_en=b881a3d8de47dd3505be1a35a707ffba -->

<!-- pgdoc-cn_start sig_en=2dead99b8aa7c3647c1d970860fa242e sig_cn_org=None source=14.1 
   <para>
    These functions are used to extract other information from
    <structname>PGresult</structname> objects.
   </para>
________________________________________________________-->
   <para>
    这些函数被用来从<structname>PGresult</structname>对象中抽取其他信息。
   </para>
<!-- pgdoc-cn_end sig_en=2dead99b8aa7c3647c1d970860fa242e -->

   <variablelist>
    <varlistentry id="libpq-PQcmdStatus">
<!-- pgdoc-cn_start sig_en=52d4a9c9ed51ed57d8341c36063284df sig_cn_org=None source=14.1 
     <term><function>PQcmdStatus</function><indexterm><primary>PQcmdStatus</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQcmdStatus</function><indexterm><primary>PQcmdStatus</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=52d4a9c9ed51ed57d8341c36063284df -->

     <listitem>
<!-- pgdoc-cn_start sig_en=fb680ffb1949a2ad15d85a1e5fabaa6d sig_cn_org=None source=14.1 
      <para>
       Returns the command status tag from the SQL command that generated
       the <structname>PGresult</structname>.
<synopsis>
char *PQcmdStatus(PGresult *res);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       返回来自于产生<structname>PGresult</structname>的 SQL 命令的命令状态标签。
<synopsis>
char *PQcmdStatus(PGresult *res);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=fb680ffb1949a2ad15d85a1e5fabaa6d -->

<!-- pgdoc-cn_start sig_en=40fc5bc80ea5ac57d03fb85a5cc7cd89 sig_cn_org=None source=14.1 
      <para>
       Commonly this is just the name of the command, but it might include
       additional data such as the number of rows processed. The caller
       should not free the result directly. It will be freed when the
       associated <structname>PGresult</structname> handle is passed to
       <xref linkend="libpq-PQclear"/>.
      </para>
________________________________________________________-->
      <para>
       通常这就是该命令的名称，但是它可能包括额外数据，例如已被处理的行数。调用者不应该直接释放该结果。它将在相关的<structname>PGresult</structname>句柄被传递给<xref linkend="libpq-PQclear"/>之后被释放。
      </para>
<!-- pgdoc-cn_end sig_en=40fc5bc80ea5ac57d03fb85a5cc7cd89 -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQcmdTuples">
<!-- pgdoc-cn_start sig_en=da6822e8b9c47f4653e5fc34c8d35099 sig_cn_org=None source=14.1 
     <term><function>PQcmdTuples</function><indexterm><primary>PQcmdTuples</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQcmdTuples</function><indexterm><primary>PQcmdTuples</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=da6822e8b9c47f4653e5fc34c8d35099 -->

     <listitem>
<!-- pgdoc-cn_start sig_en=887c37af81af5eddf45f4988b542603d sig_cn_org=None source=14.1 
      <para>
       Returns the number of rows affected by the SQL command.
<synopsis>
char *PQcmdTuples(PGresult *res);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       返回受该 SQL 命令影响的行数。
<synopsis>
char *PQcmdTuples(PGresult *res);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=887c37af81af5eddf45f4988b542603d -->

<!-- pgdoc-cn_start sig_en=9b69dbc41a4dbaca032705bcf54b1c80 sig_cn_org=d6363290d8db6ac0922cbef0d4e546b5 source=15.7 
      <para>
       This function returns a string containing the number of rows
       affected by the <acronym>SQL</acronym> statement that generated the
       <structname>PGresult</structname>. This function can only be used following
       the execution of a <command>SELECT</command>, <command>CREATE TABLE AS</command>,
       <command>INSERT</command>, <command>UPDATE</command>, <command>DELETE</command>,
       <command>MERGE</command>, <command>MOVE</command>, <command>FETCH</command>,
       or <command>COPY</command> statement, or an <command>EXECUTE</command> of a
       prepared query that contains an <command>INSERT</command>,
       <command>UPDATE</command>, <command>DELETE</command>,
       or <command>MERGE</command> statement.
       If the command that generated the <structname>PGresult</structname> was anything
       else, <xref linkend="libpq-PQcmdTuples"/> returns an empty string. The caller
       should not free the return value directly. It will be freed when
       the associated <structname>PGresult</structname> handle is passed to
       <xref linkend="libpq-PQclear"/>.
      </para>
________________________________________________________-->
      <para>
       该函数返回一个字符串，其中包含由生成<structname>PGresult</structname>的<acronym>SQL</acronym>语句影响的行数。
       该函数只能在执行<command>SELECT</command>、<command>CREATE TABLE AS</command>、
       <command>INSERT</command>、<command>UPDATE</command>、<command>DELETE</command>、
       <command>MERGE</command>、<command>MOVE</command>、<command>FETCH</command>或<command>COPY</command>语句，
       或包含<command>INSERT</command>、<command>UPDATE</command>、<command>DELETE</command>或<command>MERGE</command>语句的预处理查询的<command>EXECUTE</command>之后使用。
       如果生成<structname>PGresult</structname>的命令是其他任何命令，<xref linkend="libpq-PQcmdTuples"/>将返回一个空字符串。
       调用者不应直接释放返回值。当关联的<structname>PGresult</structname>句柄传递给<xref linkend="libpq-PQclear"/>时，它将被释放。
      </para>
<!-- pgdoc-cn_end sig_en=9b69dbc41a4dbaca032705bcf54b1c80 -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQoidValue">
<!-- pgdoc-cn_start sig_en=99c9035781b5a9955fe25ea8d82f70a6 sig_cn_org=None source=14.1 
     <term><function>PQoidValue</function><indexterm><primary>PQoidValue</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQoidValue</function><indexterm><primary>PQoidValue</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=99c9035781b5a9955fe25ea8d82f70a6 -->

     <listitem>
<!-- pgdoc-cn_start sig_en=f82139400894334d4580cb1a7db65abd sig_cn_org=None source=14.1 
      <para>
       Returns the OID<indexterm><primary>OID</primary><secondary>in libpq</secondary></indexterm>
       of the inserted row, if the <acronym>SQL</acronym> command was an
       <command>INSERT</command> that inserted exactly one row into a table that
       has OIDs, or a <command>EXECUTE</command> of a prepared query containing
       a suitable <command>INSERT</command> statement.  Otherwise, this function
       returns <literal>InvalidOid</literal>. This function will also
       return <literal>InvalidOid</literal> if the table affected by the
       <command>INSERT</command> statement does not contain OIDs.
<synopsis>
Oid PQoidValue(const PGresult *res);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       如果该<acronym>SQL</acronym>命令是一个正好将一行插入到具有 OID 的表的<command>INSERT</command>，或者是一个包含合适<command>INSERT</command>语句的预备查询的<command>EXECUTE</command>，这个函数返回被插入行的 OID<indexterm><primary>OID</primary><secondary>in libpq</secondary></indexterm>。否则，这个函数返回<literal>InvalidOid</literal>。如果被<command>INSERT</command>语句影响的表不包含 OID，这个函数也将返回<literal>InvalidOid</literal>。
<synopsis>
Oid PQoidValue(const PGresult *res);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=f82139400894334d4580cb1a7db65abd -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQoidStatus">
<!-- pgdoc-cn_start sig_en=b4c1afa33b981c7e6c224bf17189345a sig_cn_org=None source=14.1 
     <term><function>PQoidStatus</function><indexterm><primary>PQoidStatus</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQoidStatus</function><indexterm><primary>PQoidStatus</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=b4c1afa33b981c7e6c224bf17189345a -->

     <listitem>
<!-- pgdoc-cn_start sig_en=c70a5ccdfd6c099fd4bb4e1332d06e1e sig_cn_org=None source=14.1 
      <para>
       This function is deprecated in favor of
       <xref linkend="libpq-PQoidValue"/> and is not thread-safe.
       It returns a string with the OID of the inserted row, while
       <xref linkend="libpq-PQoidValue"/> returns the OID value.
<synopsis>
char *PQoidStatus(const PGresult *res);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       这个函数已经被<xref linkend="libpq-PQoidValue"/>取代，并且不是线程安全的。它返回包含被插入行的 OID 的一个字符串，而<xref linkend="libpq-PQoidValue"/>返回 OID 值。
<synopsis>
char *PQoidStatus(const PGresult *res);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=c70a5ccdfd6c099fd4bb4e1332d06e1e -->

     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>

  <sect2 id="libpq-exec-escape-string">
<!-- pgdoc-cn_start sig_en=9f140445a76b0e8f2d3830af3c6dc7df sig_cn_org=None source=14.1 
   <title>Escaping Strings for Inclusion in SQL Commands</title>
________________________________________________________-->
   <title>用于包含在 SQL 命令中的转移串</title>
<!-- pgdoc-cn_end sig_en=9f140445a76b0e8f2d3830af3c6dc7df -->

<!-- pgdoc-cn_start sig_en=e6d99da43adcb0177ada2aeac4398fee sig_cn_org=None source=14.1 
   <indexterm zone="libpq-exec-escape-string">
    <primary>escaping strings</primary>
    <secondary>in libpq</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="libpq-exec-escape-string">
    <primary>escaping strings</primary>
    <secondary>in libpq</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=e6d99da43adcb0177ada2aeac4398fee -->

   <variablelist>
    <varlistentry id="libpq-PQescapeLiteral">
<!-- pgdoc-cn_start sig_en=5253b911c5744cb23461ff7b6f0f5e7f sig_cn_org=None source=14.1 
     <term><function>PQescapeLiteral</function><indexterm><primary>PQescapeLiteral</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQescapeLiteral</function><indexterm><primary>PQescapeLiteral</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=5253b911c5744cb23461ff7b6f0f5e7f -->

     <listitem>
<!-- pgdoc-cn_start sig_en=0d3534a97c27e16dc07643bdbba0960b sig_cn_org=None source=14.1 
     <para>
<synopsis>
char *PQescapeLiteral(PGconn *conn, const char *str, size_t length);
</synopsis>
     </para>
________________________________________________________-->
     <para>
<synopsis>
char *PQescapeLiteral(PGconn *conn, const char *str, size_t length);
</synopsis>
     </para>
<!-- pgdoc-cn_end sig_en=0d3534a97c27e16dc07643bdbba0960b -->

<!-- pgdoc-cn_start sig_en=d85f9f02c245ee373e5706a8adb43812 sig_cn_org=None source=14.1 
     <para>
      <xref linkend="libpq-PQescapeLiteral"/> escapes a string for
      use within an SQL command.  This is useful when inserting data
      values as literal constants in SQL commands.  Certain characters
      (such as quotes and backslashes) must be escaped to prevent them
      from being interpreted specially by the SQL parser.
      <xref linkend="libpq-PQescapeLiteral"/> performs this operation.
     </para>
________________________________________________________-->
     <para>
      为了让一个串能用在 SQL 命令中，<xref linkend="libpq-PQescapeLiteral"/>可对它进行转义。
      当在 SQL 命令中插入一个数据值作为文字常量时，这个函数很有用。一些字符（例如引号和反斜线）必须被转义以防止它们被 SQL 解析器解释成特殊的意思。
      <xref linkend="libpq-PQescapeLiteral"/>执行这种操作。
     </para>
<!-- pgdoc-cn_end sig_en=d85f9f02c245ee373e5706a8adb43812 -->

<!-- pgdoc-cn_start sig_en=74fd7f58581894f020c6ca0ffcef23a0 sig_cn_org=None source=14.1 
     <para>
      <xref linkend="libpq-PQescapeLiteral"/> returns an escaped version of the
      <parameter>str</parameter> parameter in memory allocated with
      <function>malloc()</function>.  This memory should be freed using
      <function>PQfreemem()</function> when the result is no longer needed.
      A terminating zero byte is not required, and should not be
      counted in <parameter>length</parameter>.  (If a terminating zero byte is found
      before <parameter>length</parameter> bytes are processed,
      <xref linkend="libpq-PQescapeLiteral"/> stops at the zero; the behavior is
      thus rather like <function>strncpy</function>.) The
      return string has all special characters replaced so that they can
      be properly processed by the <productname>PostgreSQL</productname>
      string literal parser.  A terminating zero byte is also added.  The
      single quotes that must surround <productname>PostgreSQL</productname>
      string literals are included in the result string.
     </para>
________________________________________________________-->
     <para>
      <xref linkend="libpq-PQescapeLiteral"/>返回一个<parameter>str</parameter>参数的已被转义版本，该版本被放在用<function>malloc()</function>分配的内存中。
      当该结果不再被需要时，这个内存应该用<function>PQfreemem()</function>释放。
      一个终止的零字节不是必须的，并且不应该被计入<parameter>length</parameter>（如果在<parameter>length</parameter>字节被处理之前找到一个终止字节，<xref linkend="libpq-PQescapeLiteral"/>会停止在零，该行为更像<function>strncpy</function>）。
      返回串中的所有特殊字符都被替换掉，这样它们能被<productname>PostgreSQL</productname>字符串解析器正确地处理。
      还会加上一个终止零字节。包括在结果串中的<productname>PostgreSQL</productname>字符串必须用单引号包围。
     </para>
<!-- pgdoc-cn_end sig_en=74fd7f58581894f020c6ca0ffcef23a0 -->

<!-- pgdoc-cn_start sig_en=a8b3c10efcd7927fa7560aa5a4e8bc19 sig_cn_org=None source=14.1 
     <para>
      On error, <xref linkend="libpq-PQescapeLiteral"/> returns <symbol>NULL</symbol> and a suitable
      message is stored in the <parameter>conn</parameter> object.
     </para>
________________________________________________________-->
     <para>
      发生错误时，<xref linkend="libpq-PQescapeLiteral"/>返回<symbol>NULL</symbol>并且一个合适的消息会被存储在<parameter>conn</parameter>对象中。
     </para>
<!-- pgdoc-cn_end sig_en=a8b3c10efcd7927fa7560aa5a4e8bc19 -->

     <tip>
<!-- pgdoc-cn_start sig_en=46bfbd1ab22a8b4d99f00d263732bdcd sig_cn_org=None source=14.1 
      <para>
       It is especially important to do proper escaping when handling
       strings that were received from an untrustworthy source.
       Otherwise there is a security risk: you are vulnerable to
       <quote>SQL injection</quote> attacks wherein unwanted SQL commands are
       fed to your database.
      </para>
________________________________________________________-->
      <para>
       在处理从一个非可信源接收到的串时，做正确的转义特别重要。否则就会有安全性风险：你容易受到<quote>SQL 注入</quote>攻击，其中可能会有预期之外的 SQL 语句会被喂给你的数据库。
      </para>
<!-- pgdoc-cn_end sig_en=46bfbd1ab22a8b4d99f00d263732bdcd -->
     </tip>

<!-- pgdoc-cn_start sig_en=d5da7d7643dd5ec632dca2e6b6566771 sig_cn_org=None source=14.1 
     <para>
      Note that it is neither necessary nor correct to do escaping when a data
      value is passed as a separate parameter in <xref linkend="libpq-PQexecParams"/> or
      its sibling routines.
     </para>
________________________________________________________-->
     <para>
      注意，当一个数据值被作为<xref linkend="libpq-PQexecParams"/>或其兄弟例程中的一个独立参数传递时，没有必要做转义而且做转义也不正确。
     </para>
<!-- pgdoc-cn_end sig_en=d5da7d7643dd5ec632dca2e6b6566771 -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQescapeIdentifier">
<!-- pgdoc-cn_start sig_en=1d595f09880ea60e8adf5a1525d29ff1 sig_cn_org=None source=14.1 
     <term><function>PQescapeIdentifier</function><indexterm><primary>PQescapeIdentifier</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQescapeIdentifier</function><indexterm><primary>PQescapeIdentifier</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=1d595f09880ea60e8adf5a1525d29ff1 -->

     <listitem>
<!-- pgdoc-cn_start sig_en=8258b079d25ee9cca3d3db11ee69dde1 sig_cn_org=None source=14.1 
     <para>
<synopsis>
char *PQescapeIdentifier(PGconn *conn, const char *str, size_t length);
</synopsis>
     </para>
________________________________________________________-->
     <para>
<synopsis>
char *PQescapeIdentifier(PGconn *conn, const char *str, size_t length);
</synopsis>
     </para>
<!-- pgdoc-cn_end sig_en=8258b079d25ee9cca3d3db11ee69dde1 -->

<!-- pgdoc-cn_start sig_en=7720ac0b5f6ffc5c7d08dc86fb318c1f sig_cn_org=None source=14.1 
     <para>
      <xref linkend="libpq-PQescapeIdentifier"/> escapes a string for
      use as an SQL identifier, such as a table, column, or function name.
      This is useful when a user-supplied identifier might contain
      special characters that would otherwise not be interpreted as part
      of the identifier by the SQL parser, or when the identifier might
      contain upper case characters whose case should be preserved.
     </para>
________________________________________________________-->
     <para>
      <xref linkend="libpq-PQescapeIdentifier"/>转义一个要用作 SQL 标识符的字符串，例如表名、列名或函数名。当一个用户提供的标识符可能包含被 SQL 解析器解释为标识符一部分的特殊字符时，或者当该标识符可能包含大小写形式应该被保留的大写字符时，这个函数很有用。
     </para>
<!-- pgdoc-cn_end sig_en=7720ac0b5f6ffc5c7d08dc86fb318c1f -->

<!-- pgdoc-cn_start sig_en=942024161c6b28ed5610e5aa1a7f8c09 sig_cn_org=None source=14.1 
     <para>
      <xref linkend="libpq-PQescapeIdentifier"/> returns a version of the
      <parameter>str</parameter> parameter escaped as an SQL identifier
      in memory allocated with <function>malloc()</function>.  This memory must be
      freed using <function>PQfreemem()</function> when the result is no longer
      needed.  A terminating zero byte is not required, and should not be
      counted in <parameter>length</parameter>.  (If a terminating zero byte is found
      before <parameter>length</parameter> bytes are processed,
      <xref linkend="libpq-PQescapeIdentifier"/> stops at the zero; the behavior is
      thus rather like <function>strncpy</function>.) The
      return string has all special characters replaced so that it
      will be properly processed as an SQL identifier.  A terminating zero byte
      is also added.  The return string will also be surrounded by double
      quotes.
     </para>
________________________________________________________-->
     <para>
      <xref linkend="libpq-PQescapeIdentifier"/>返回一个<parameter>str</parameter>参数的已被转义为 SQL 标识符的版本，该版本被放在用<function>malloc()</function>分配的内存中。
      当该结果不再被需要时，这个内存应该用<function>PQfreemem()</function>释放。
      一个终止的零字节不是必须的，并且不应该被计入<parameter>length</parameter>（如果在<parameter>length</parameter>字节被处理之前找到一个终止字节，<xref linkend="libpq-PQescapeIdentifier"/>会停止在零，该行为更像<function>strncpy</function>）。
      返回串中的所有特殊字符都被替换掉，这样它们能被作为一个 SQL 标识符正确地处理。还会加上一个终止零字节。返回串也将被双引号包围。
     </para>
<!-- pgdoc-cn_end sig_en=942024161c6b28ed5610e5aa1a7f8c09 -->

<!-- pgdoc-cn_start sig_en=ccce1990bc188898e77935a67bb379e6 sig_cn_org=None source=14.1 
     <para>
      On error, <xref linkend="libpq-PQescapeIdentifier"/> returns <symbol>NULL</symbol> and a suitable
      message is stored in the <parameter>conn</parameter> object.
     </para>
________________________________________________________-->
     <para>
      发生错误时，<xref linkend="libpq-PQescapeIdentifier"/>返回<symbol>NULL</symbol>并且一个合适的消息会被存储在<parameter>conn</parameter>对象中。
     </para>
<!-- pgdoc-cn_end sig_en=ccce1990bc188898e77935a67bb379e6 -->

     <tip>
<!-- pgdoc-cn_start sig_en=f27cd74ad71fce780624fb665af22789 sig_cn_org=None source=14.1 
      <para>
       As with string literals, to prevent SQL injection attacks,
       SQL identifiers must be escaped when they are received from an
       untrustworthy source.
      </para>
________________________________________________________-->
      <para>
       与字符串一样，要阻止 SQL 注入攻击，当从一个不可信的来源接收到 SQL 标识符时，它们必须被转义。
      </para>
<!-- pgdoc-cn_end sig_en=f27cd74ad71fce780624fb665af22789 -->
     </tip>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQescapeStringConn">
<!-- pgdoc-cn_start sig_en=7ba162495ea82aa031589573b1c66637 sig_cn_org=None source=14.1 
     <term><function>PQescapeStringConn</function><indexterm><primary>PQescapeStringConn</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQescapeStringConn</function><indexterm><primary>PQescapeStringConn</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=7ba162495ea82aa031589573b1c66637 -->

     <listitem>
<!-- pgdoc-cn_start sig_en=2638ad5c2517498511ba2a416d9e10fa sig_cn_org=None source=14.1 
     <para>
<synopsis>
size_t PQescapeStringConn(PGconn *conn,
                          char *to, const char *from, size_t length,
                          int *error);
</synopsis>
     </para>
________________________________________________________-->
     <para>
<synopsis>
size_t PQescapeStringConn(PGconn *conn,
                          char *to, const char *from, size_t length,
                          int *error);
</synopsis>
     </para>
<!-- pgdoc-cn_end sig_en=2638ad5c2517498511ba2a416d9e10fa -->

<!-- pgdoc-cn_start sig_en=d5add1da8ea73825693bced60d2bf8f4 sig_cn_org=None source=14.1 
     <para>
      <xref linkend="libpq-PQescapeStringConn"/> escapes string literals, much like
      <xref linkend="libpq-PQescapeLiteral"/>.  Unlike <xref linkend="libpq-PQescapeLiteral"/>,
      the caller is responsible for providing an appropriately sized buffer.
      Furthermore, <xref linkend="libpq-PQescapeStringConn"/> does not generate the
      single quotes that must surround <productname>PostgreSQL</productname> string
      literals; they should be provided in the SQL command that the
      result is inserted into.  The parameter <parameter>from</parameter> points to
      the first character of the string that is to be escaped, and the
      <parameter>length</parameter> parameter gives the number of bytes in this
      string.  A terminating zero byte is not required, and should not be
      counted in <parameter>length</parameter>.  (If a terminating zero byte is found
      before <parameter>length</parameter> bytes are processed,
      <xref linkend="libpq-PQescapeStringConn"/> stops at the zero; the behavior is
      thus rather like <function>strncpy</function>.) <parameter>to</parameter> shall point
      to a buffer that is able to hold at least one more byte than twice
      the value of <parameter>length</parameter>, otherwise the behavior is undefined.
      Behavior is likewise undefined if the <parameter>to</parameter> and
      <parameter>from</parameter> strings overlap.
     </para>
________________________________________________________-->
     <para>
      <xref linkend="libpq-PQescapeStringConn"/>转义字符串，它很像<xref linkend="libpq-PQescapeLiteral"/>。
      与<xref linkend="libpq-PQescapeLiteral"/>不一样的是，调用者负责提供一个合适尺寸的缓冲区。
      此外，<xref linkend="libpq-PQescapeStringConn"/>不产生必须包围<productname>PostgreSQL</productname>字符串的单引号。
      它们应该在结果要插入的 SQL 命令中提供。参数<parameter>from</parameter>指向要被转义的串的第一个字符，并且<parameter>length</parameter>参数给出了这个串中的字节数。
      一个终止的零字节不是必须的，并且不应该被计入<parameter>length</parameter>（如果在<parameter>length</parameter>字节被处理之前找到一个终止字节，<xref linkend="libpq-PQescapeStringConn"/>会停止在零，该行为更像<function>strncpy</function>）。
      <parameter>to</parameter>应当指向一个缓冲区，它能够保持至少比<parameter>length</parameter>值的两倍还要多至少一个字节，否则该行为是未被定义的。
      如果<parameter>to</parameter>和<parameter>from</parameter>串重叠，行为也是未被定义的。
     </para>
<!-- pgdoc-cn_end sig_en=d5add1da8ea73825693bced60d2bf8f4 -->

<!-- pgdoc-cn_start sig_en=128624708314e64796405cccfc2c7e2c sig_cn_org=None source=14.1 
     <para>
      If the <parameter>error</parameter> parameter is not <symbol>NULL</symbol>, then
      <literal>*error</literal> is set to zero on success, nonzero on error.
      Presently the only possible error conditions involve invalid multibyte
      encoding in the source string.  The output string is still generated
      on error, but it can be expected that the server will reject it as
      malformed.  On error, a suitable message is stored in the
      <parameter>conn</parameter> object, whether or not <parameter>error</parameter> is <symbol>NULL</symbol>.
     </para>
________________________________________________________-->
     <para>
      如果<parameter>error</parameter>参数不是<symbol>NULL</symbol>，那么成功时<literal>*error</literal>被设置为零，错误时设置为非零。当前唯一可能的错误情况涉及源串中非法的多字节编码。错误时仍然会产生输出串，但是可以预期服务器将认为它是畸形的并且拒绝它。在发生错误时，一个合适的消息被存储在<parameter>conn</parameter>对象中，不管<parameter>error</parameter>是不是<symbol>NULL</symbol>。
     </para>
<!-- pgdoc-cn_end sig_en=128624708314e64796405cccfc2c7e2c -->

<!-- pgdoc-cn_start sig_en=2b1ded6efc576d5517f71a8050934f78 sig_cn_org=None source=14.1 
     <para>
      <xref linkend="libpq-PQescapeStringConn"/> returns the number of bytes written
      to <parameter>to</parameter>, not including the terminating zero byte.
     </para>
________________________________________________________-->
     <para>
      <xref linkend="libpq-PQescapeStringConn"/>返回写到<parameter>to</parameter>的字节数，不包括终止的零字节。
     </para>
<!-- pgdoc-cn_end sig_en=2b1ded6efc576d5517f71a8050934f78 -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQescapeString">
<!-- pgdoc-cn_start sig_en=3e37d3064bf3ac81cd8d5242c30c9bac sig_cn_org=None source=14.1 
     <term><function>PQescapeString</function><indexterm><primary>PQescapeString</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQescapeString</function><indexterm><primary>PQescapeString</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=3e37d3064bf3ac81cd8d5242c30c9bac -->

     <listitem>
<!-- pgdoc-cn_start sig_en=9ae632ad3c18cf36df8291e1b1d28d3e sig_cn_org=None source=14.1 
     <para>
       <xref linkend="libpq-PQescapeString"/> is an older, deprecated version of
       <xref linkend="libpq-PQescapeStringConn"/>.
<synopsis>
size_t PQescapeString (char *to, const char *from, size_t length);
</synopsis>
     </para>
________________________________________________________-->
     <para>
       <xref linkend="libpq-PQescapeString"/>是一个更老的被废弃的<xref linkend="libpq-PQescapeStringConn"/>版本。
<synopsis>
size_t PQescapeString (char *to, const char *from, size_t length);
</synopsis>
     </para>
<!-- pgdoc-cn_end sig_en=9ae632ad3c18cf36df8291e1b1d28d3e -->

<!-- pgdoc-cn_start sig_en=d4ee983951ceb5bf568c99bd1ecc7214 sig_cn_org=None source=14.1 
     <para>
      The only difference from <xref linkend="libpq-PQescapeStringConn"/> is that
      <xref linkend="libpq-PQescapeString"/> does not take <structname>PGconn</structname>
      or <parameter>error</parameter> parameters.
      Because of this, it cannot adjust its behavior depending on the
      connection properties (such as character encoding) and therefore
      <emphasis>it might give the wrong results</emphasis>.  Also, it has no way
      to report error conditions.
     </para>
________________________________________________________-->
     <para>
      <xref linkend="libpq-PQescapeStringConn"/>和<xref linkend="libpq-PQescapeString"/>之间的唯一区别是不需要<structname>PGconn</structname>或<parameter>error</parameter>参数。
      正因为如此，它不能基于连接属性（例如字符编码）调整它的行为并且因此<emphasis>它可能给出错误的结果</emphasis>。还有，它没有方法报告错误情况。
     </para>
<!-- pgdoc-cn_end sig_en=d4ee983951ceb5bf568c99bd1ecc7214 -->

<!-- pgdoc-cn_start sig_en=352efe82e89782b947eaa6998494d6ac sig_cn_org=None source=14.1 
     <para>
      <xref linkend="libpq-PQescapeString"/> can be used safely in
      client programs that work with only one <productname>PostgreSQL</productname>
      connection at a time (in this case it can find out what it needs to
      know <quote>behind the scenes</quote>).  In other contexts it is a security
      hazard and should be avoided in favor of
      <xref linkend="libpq-PQescapeStringConn"/>.
     </para>
________________________________________________________-->
     <para>
      <xref linkend="libpq-PQescapeString"/>可以在一次只使用一个<productname>PostgreSQL</productname>连接的客户端程序中安全地使用（在这种情况下它可以<quote>在现象后面</quote>找出它需要知道的东西）。
      在其他环境中它是一个安全性灾难并且应该用<xref linkend="libpq-PQescapeStringConn"/>来避免。
     </para>
<!-- pgdoc-cn_end sig_en=352efe82e89782b947eaa6998494d6ac -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQescapeByteaConn">
<!-- pgdoc-cn_start sig_en=0de2b67d0ea64e7c608388f103d6dff0 sig_cn_org=None source=14.1 
     <term><function>PQescapeByteaConn</function><indexterm><primary>PQescapeByteaConn</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQescapeByteaConn</function><indexterm><primary>PQescapeByteaConn</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=0de2b67d0ea64e7c608388f103d6dff0 -->

     <listitem>
<!-- pgdoc-cn_start sig_en=452e8c203b7e038e1ae91547c3036e9a sig_cn_org=None source=14.1 
     <para>
       Escapes binary data for use within an SQL command with the type
       <type>bytea</type>.  As with <xref linkend="libpq-PQescapeStringConn"/>,
       this is only used when inserting data directly into an SQL command string.
<synopsis>
unsigned char *PQescapeByteaConn(PGconn *conn,
                                 const unsigned char *from,
                                 size_t from_length,
                                 size_t *to_length);
</synopsis>
      </para>
________________________________________________________-->
     <para>
       把要用于一个 SQL 命令的二进制数据用类型<type>bytea</type>转义。和<xref linkend="libpq-PQescapeStringConn"/>一样，只有在将数据直接插入到一个 SQL 命令串时才使用它。
<synopsis>
unsigned char *PQescapeByteaConn(PGconn *conn,
                                 const unsigned char *from,
                                 size_t from_length,
                                 size_t *to_length);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=452e8c203b7e038e1ae91547c3036e9a -->

<!-- pgdoc-cn_start sig_en=07fa9f0c8a56b63a3faeec16fb8081c7 sig_cn_org=None source=14.1 
      <para>
       Certain byte values must be escaped when used as part of a
       <type>bytea</type> literal in an <acronym>SQL</acronym> statement.
       <xref linkend="libpq-PQescapeByteaConn"/> escapes bytes using
       either hex encoding or backslash escaping.  See <xref
       linkend="datatype-binary"/> for more information.
      </para>
________________________________________________________-->
      <para>
       当某些字节值被用作一个<acronym>SQL</acronym>语句中的<type>bytea</type>文字的一部分时，它们必须被转义。
       <xref linkend="libpq-PQescapeByteaConn"/>转义使用十六进制编码或反斜线转义的字节。详见<xref linkend="datatype-binary"/>。
      </para>
<!-- pgdoc-cn_end sig_en=07fa9f0c8a56b63a3faeec16fb8081c7 -->

<!-- pgdoc-cn_start sig_en=726016f97074d469f4835325138cfd6e sig_cn_org=None source=14.1 
      <para>
       The <parameter>from</parameter> parameter points to the first
       byte of the string that is to be escaped, and the
       <parameter>from_length</parameter> parameter gives the number of
       bytes in this binary string.  (A terminating zero byte is
       neither necessary nor counted.)  The <parameter>to_length</parameter>
       parameter points to a variable that will hold the resultant
       escaped string length. This result string length includes the terminating
       zero byte of the result.
      </para>
________________________________________________________-->
      <para>
       <parameter>from</parameter>参数指向要被转义的串的第一个字节，并且<parameter>from_length</parameter>参数给出这个二进制串中的字节数（一个终止的零字节是不需要的也是不被计算的）。<parameter>to_length</parameter>参数指向一个将保持生成的已转义串长度的变量。这个结果串长度包括结果的终止零字节。
      </para>
<!-- pgdoc-cn_end sig_en=726016f97074d469f4835325138cfd6e -->

<!-- pgdoc-cn_start sig_en=a8a081cea5d5a428e0a71724dd8c6c42 sig_cn_org=None source=14.1 
      <para>
       <xref linkend="libpq-PQescapeByteaConn"/> returns an escaped version of the
       <parameter>from</parameter> parameter binary string in memory
       allocated with <function>malloc()</function>.  This memory should be freed using
       <function>PQfreemem()</function> when the result is no longer needed.  The
       return string has all special characters replaced so that they can
       be properly processed by the <productname>PostgreSQL</productname>
       string literal parser, and the <type>bytea</type> input function. A
       terminating zero byte is also added.  The single quotes that must
       surround <productname>PostgreSQL</productname> string literals are
       not part of the result string.
      </para>
________________________________________________________-->
      <para>
       <xref linkend="libpq-PQescapeByteaConn"/>返回一个<parameter>from</parameter>参数的已被转义为二进制串的版本，该版本被放在用<function>malloc()</function>分配的内存中。
       当该结果不再被需要时，这个内存应该用<function>PQfreemem()</function>释放。
       返回串中的所有特殊字符都被替换掉，这样它们能被<productname>PostgreSQL</productname>的字符串解析器以及<type>bytea</type>输入函数正确地处理。
       还会加上一个终止零字节。不是结果串一部分的<productname>PostgreSQL</productname>字符串必须被单引号包围。
      </para>
<!-- pgdoc-cn_end sig_en=a8a081cea5d5a428e0a71724dd8c6c42 -->

<!-- pgdoc-cn_start sig_en=5b6cff5d43db32758f3e86a04049459f sig_cn_org=None source=14.1 
      <para>
       On error, a null pointer is returned, and a suitable error message
       is stored in the <parameter>conn</parameter> object.  Currently, the only
       possible error is insufficient memory for the result string.
      </para>
________________________________________________________-->
      <para>
       在发生错误时，将返回一个空指针，并且一个合适的错误消息被存储在<parameter>conn</parameter>对象中。当前，唯一可能的错误是没有足够的内存用于结果串。
      </para>
<!-- pgdoc-cn_end sig_en=5b6cff5d43db32758f3e86a04049459f -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQescapeBytea">
<!-- pgdoc-cn_start sig_en=2a822728c27e998f7c7609a62cc3139d sig_cn_org=None source=14.1 
     <term><function>PQescapeBytea</function><indexterm><primary>PQescapeBytea</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQescapeBytea</function><indexterm><primary>PQescapeBytea</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=2a822728c27e998f7c7609a62cc3139d -->

     <listitem>
<!-- pgdoc-cn_start sig_en=431deb01ac845bb4d9d91dd6542fea21 sig_cn_org=None source=14.1 
      <para>
       <xref linkend="libpq-PQescapeBytea"/> is an older, deprecated version of
       <xref linkend="libpq-PQescapeByteaConn"/>.
<synopsis>
unsigned char *PQescapeBytea(const unsigned char *from,
                             size_t from_length,
                             size_t *to_length);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       <xref linkend="libpq-PQescapeBytea"/>是一个更老的被废弃的<xref linkend="libpq-PQescapeByteaConn"/>版本。
<synopsis>
unsigned char *PQescapeBytea(const unsigned char *from,
                             size_t from_length,
                             size_t *to_length);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=431deb01ac845bb4d9d91dd6542fea21 -->

<!-- pgdoc-cn_start sig_en=cfe44bec7ef62824208bf1b11215ae9b sig_cn_org=None source=14.1 
      <para>
       The only difference from <xref linkend="libpq-PQescapeByteaConn"/> is that
       <xref linkend="libpq-PQescapeBytea"/> does not take a <structname>PGconn</structname>
       parameter.  Because of this, <xref linkend="libpq-PQescapeBytea"/> can
       only be used safely in client programs that use a single
       <productname>PostgreSQL</productname> connection at a time (in this case
       it can find out what it needs to know <quote>behind the
       scenes</quote>).  It <emphasis>might give the wrong results</emphasis> if
       used in programs that use multiple database connections (use
       <xref linkend="libpq-PQescapeByteaConn"/> in such cases).
      </para>
________________________________________________________-->
      <para>
       与<xref linkend="libpq-PQescapeByteaConn"/>的唯一区别是<xref linkend="libpq-PQescapeBytea"/>不用一个<structname>PGconn</structname>参数。
       正因为这样，<xref linkend="libpq-PQescapeBytea"/>只能在一次只使用一个<productname>PostgreSQL</productname>连接的客户端程序中安全地使用（在这种情况下它可以<quote>在现象后面</quote>找出它需要知道的东西）。
       如果在有多个数据库连接的程序中使用，它<emphasis>可能给出错误的结果</emphasis>（在那种情况下使用<xref linkend="libpq-PQescapeByteaConn"/>）。
      </para>
<!-- pgdoc-cn_end sig_en=cfe44bec7ef62824208bf1b11215ae9b -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQunescapeBytea">
<!-- pgdoc-cn_start sig_en=811fbe35f56ed57c2bea2fc949b66f66 sig_cn_org=None source=14.1 
     <term><function>PQunescapeBytea</function><indexterm><primary>PQunescapeBytea</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQunescapeBytea</function><indexterm><primary>PQunescapeBytea</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=811fbe35f56ed57c2bea2fc949b66f66 -->

     <listitem>
<!-- pgdoc-cn_start sig_en=769768217760c79432ab693a43377ad8 sig_cn_org=None source=14.1 
      <para>
       Converts a string representation of binary data into binary data
       &mdash; the reverse of <xref linkend="libpq-PQescapeBytea"/>.  This
       is needed when retrieving <type>bytea</type> data in text format,
       but not when retrieving it in binary format.

<synopsis>
unsigned char *PQunescapeBytea(const unsigned char *from, size_t *to_length);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       将二进制数据的一个字符串表示转换成二进制数据 &mdash; 它是<xref linkend="libpq-PQescapeBytea"/>的逆向函数。当检索文本格式的<type>bytea</type>数据时，需要这个函数，但检索二进制个事时则不需要它。

<synopsis>
unsigned char *PQunescapeBytea(const unsigned char *from, size_t *to_length);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=769768217760c79432ab693a43377ad8 -->

<!-- pgdoc-cn_start sig_en=16e7682d29b8d7f95c7eb5b9b48904c6 sig_cn_org=None source=14.1 
      <para>
       The <parameter>from</parameter> parameter points to a string
       such as might be returned by <xref linkend="libpq-PQgetvalue"/> when applied
       to a <type>bytea</type> column. <xref linkend="libpq-PQunescapeBytea"/>
       converts this string representation into its binary representation.
       It returns a pointer to a buffer allocated with
       <function>malloc()</function>, or <symbol>NULL</symbol> on error, and puts the size of
       the buffer in <parameter>to_length</parameter>. The result must be
       freed using <xref linkend="libpq-PQfreemem"/> when it is no longer needed.
      </para>
________________________________________________________-->
      <para>
       <parameter>from</parameter>参数指向一个字符串，例如<xref linkend="libpq-PQgetvalue"/>被应用到一个<type>bytea</type>列上所返回的。
       <xref linkend="libpq-PQunescapeBytea"/>把这个串表示转换成它的二进制表示。
       它返回一个指向用<function>malloc()</function>分配的缓冲区的指针，在错误时返回<symbol>NULL</symbol>，并且把缓冲区的尺寸放在<parameter>to_length</parameter>中。
       当结果不再需要时，它必须使用<xref linkend="libpq-PQfreemem"/>释放。
      </para>
<!-- pgdoc-cn_end sig_en=16e7682d29b8d7f95c7eb5b9b48904c6 -->

<!-- pgdoc-cn_start sig_en=5bad7fd4978d86cdcaea896aa41efdad sig_cn_org=None source=14.1 
      <para>
       This conversion is not exactly the inverse of
       <xref linkend="libpq-PQescapeBytea"/>, because the string is not expected
       to be <quote>escaped</quote> when received from <xref linkend="libpq-PQgetvalue"/>.
       In particular this means there is no need for string quoting considerations,
       and so no need for a <structname>PGconn</structname> parameter.
      </para>
________________________________________________________-->
      <para>
       这种转换并不完全是<function>PQescapeBytea</function>的逆函数，因为当从<function>PQgetvalue</function>接收到字符串时，我们并不能期待它被<quote>转义</quote>。特别地这意味着不需要考虑字符串引用，并且因此也不需要一个参数。
      </para>
<!-- pgdoc-cn_end sig_en=5bad7fd4978d86cdcaea896aa41efdad -->
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>

 </sect1>

 <sect1 id="libpq-async">
<!-- pgdoc-cn_start sig_en=3a627aa0361969ae6f8b27e07d030a9b sig_cn_org=None source=14.1 
  <title>Asynchronous Command Processing</title>
________________________________________________________-->
  <title>异步命令处理</title>
<!-- pgdoc-cn_end sig_en=3a627aa0361969ae6f8b27e07d030a9b -->

<!-- pgdoc-cn_start sig_en=d625e3de7bbfcd846a2655dedf5837a7 sig_cn_org=None source=14.1 
  <indexterm zone="libpq-async">
   <primary>nonblocking connection</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="libpq-async">
   <primary>非阻塞连接</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=d625e3de7bbfcd846a2655dedf5837a7 -->

<!-- pgdoc-cn_start sig_en=6966fe255eef640ca39b35db5076fed6 sig_cn_org=None source=14.1 
  <para>
   The <xref linkend="libpq-PQexec"/> function is adequate for submitting
   commands in normal, synchronous applications.  It has a few
   deficiencies, however, that can be of importance to some users:

   <itemizedlist>
    <listitem>
     <para>
      <xref linkend="libpq-PQexec"/> waits for the command to be completed.
      The application might have other work to do (such as maintaining a
      user interface), in which case it won't want to block waiting for
      the response.
     </para>
    </listitem>

    <listitem>
     <para>
      Since the execution of the client application is suspended while it
      waits for the result, it is hard for the application to decide that
      it would like to try to cancel the ongoing command.  (It can be done
      from a signal handler, but not otherwise.)
     </para>
    </listitem>

    <listitem>
     <para>
      <xref linkend="libpq-PQexec"/> can return only one
      <structname>PGresult</structname> structure.  If the submitted command
      string contains multiple <acronym>SQL</acronym> commands, all but
      the last <structname>PGresult</structname> are discarded by
      <xref linkend="libpq-PQexec"/>.
     </para>
    </listitem>

    <listitem>
     <para>
      <xref linkend="libpq-PQexec"/> always collects the command's entire result,
      buffering it in a single <structname>PGresult</structname>.  While
      this simplifies error-handling logic for the application, it can be
      impractical for results containing many rows.
     </para>
    </listitem>
   </itemizedlist>
  </para>
________________________________________________________-->
  <para>
   <xref linkend="libpq-PQexec"/>函数对于在普通的同步应用中提交命令是足以胜任的。不过，它的一些缺点可能对某些用户很重要： 

   <itemizedlist>
    <listitem>
     <para>
      <xref linkend="libpq-PQexec"/>会等待命令完成。该应用可能有其他的工作要做（例如维护用户界面），这时它将不希望阻塞等待回应。
     </para>
    </listitem>

    <listitem>
     <para>
      因为客户端应用的执行在它等待结果时会被挂起，对于应用来说很难决定要不要尝试取消正在进行的命令（这可以在一个信号处理器中完成，但别无他法）。
     </para>
    </listitem>

    <listitem>
     <para>
      <xref linkend="libpq-PQexec"/>只能返回一个<structname>PGresult</structname>结构。
      如果提交的命令串包含多个<acronym>SQL</acronym>命令， 除了最后一个<structname>PGresult</structname>之外都会被<xref linkend="libpq-PQexec"/>丢弃。
     </para>
    </listitem>

    <listitem>
     <para>
      <xref linkend="libpq-PQexec"/>总是收集命令的整个结果，把它缓存在一个单一的<structname>PGresult</structname>中。虽然这简化了应用的错误处理逻辑，它对于包含很多行的结果并不现实。
     </para>
    </listitem>
   </itemizedlist>
  </para>
<!-- pgdoc-cn_end sig_en=6966fe255eef640ca39b35db5076fed6 -->

<!-- pgdoc-cn_start sig_en=f06bf051a412e7e266a1fbf367dfdbba sig_cn_org=4f00435e54361d7ced3854a5985b66d3 source=15.7 
  <para>
   Applications that do not like these limitations can instead use the
   underlying functions that <xref linkend="libpq-PQexec"/> is built from:
   <xref linkend="libpq-PQsendQuery"/> and <xref linkend="libpq-PQgetResult"/>.
   There are also
   <xref linkend="libpq-PQsendQueryParams"/>,
   <xref linkend="libpq-PQsendPrepare"/>,
   <xref linkend="libpq-PQsendQueryPrepared"/>,
   <xref linkend="libpq-PQsendDescribePrepared"/>, and
   <xref linkend="libpq-PQsendDescribePortal"/>,
   which can be used with <xref linkend="libpq-PQgetResult"/> to duplicate
   the functionality of
   <xref linkend="libpq-PQexecParams"/>,
   <xref linkend="libpq-PQprepare"/>,
   <xref linkend="libpq-PQexecPrepared"/>,
   <xref linkend="libpq-PQdescribePrepared"/>, and
   <xref linkend="libpq-PQdescribePortal"/>
   respectively.

   <variablelist>
    <varlistentry id="libpq-PQsendQuery">
________________________________________________________-->
  <para>
   不喜欢这些限制的应用程序可以使用构建自<xref linkend="libpq-PQexec"/>的底层函数：
   <xref linkend="libpq-PQsendQuery"/>和<xref linkend="libpq-PQgetResult"/>。
   还有
   <xref linkend="libpq-PQsendQueryParams"/>,
   <xref linkend="libpq-PQsendPrepare"/>,
   <xref linkend="libpq-PQsendQueryPrepared"/>,
   <xref linkend="libpq-PQsendDescribePrepared"/>,以及
   <xref linkend="libpq-PQsendDescribePortal"/>,
   可以与<xref linkend="libpq-PQgetResult"/>一起使用，复制
   <xref linkend="libpq-PQexecParams"/>,
   <xref linkend="libpq-PQprepare"/>,
   <xref linkend="libpq-PQexecPrepared"/>,
   <xref linkend="libpq-PQdescribePrepared"/>,和
   <xref linkend="libpq-PQdescribePortal"/>
   的功能。

   <variablelist>
    <varlistentry id="libpq-PQsendQuery">
<!-- pgdoc-cn_end sig_en=f06bf051a412e7e266a1fbf367dfdbba -->
<!-- pgdoc-cn_start sig_en=fa2b9101a560c37b5ee297541edbbb84 sig_cn_org=fa2b9101a560c37b5ee297541edbbb84 source=15.7 
     <term><function>PQsendQuery</function><indexterm><primary>PQsendQuery</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQsendQuery</function><indexterm><primary>PQsendQuery</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=fa2b9101a560c37b5ee297541edbbb84 -->

     <listitem>
<!-- pgdoc-cn_start sig_en=a4f12cbd3c55e211bd62f86a338e6ff5 sig_cn_org=621d07c8c924b419ef55662a3cb708ee source=15.7 
      <para>
       Submits a command to the server without waiting for the result(s).
       1 is returned if the command was successfully dispatched and 0 if
       not (in which case, use <xref linkend="libpq-PQerrorMessage"/> to get more
       information about the failure).
<synopsis>
int PQsendQuery(PGconn *conn, const char *command);
</synopsis>

       After successfully calling <xref linkend="libpq-PQsendQuery"/>, call
       <xref linkend="libpq-PQgetResult"/> one or more times to obtain the
       results.  <xref linkend="libpq-PQsendQuery"/> cannot be called again
       (on the same connection) until <xref linkend="libpq-PQgetResult"/>
       has returned a null pointer, indicating that the command is done.
      </para>
________________________________________________________-->
      <para>
       提交一个命令到服务器，而不等待结果。
       如果成功发送命令，则返回1，如果失败则返回0（在这种情况下，使用<xref linkend="libpq-PQerrorMessage"/>获取更多关于失败的信息）。
<synopsis>
int PQsendQuery(PGconn *conn, const char *command);
</synopsis>

       成功调用<xref linkend="libpq-PQsendQuery"/>后，调用一次或多次<xref linkend="libpq-PQgetResult"/>来获取结果。
       在<xref linkend="libpq-PQgetResult"/>返回空指针，表示命令执行完成之前，无法再次调用<xref linkend="libpq-PQsendQuery"/>（在同一连接上）。
      </para>
<!-- pgdoc-cn_end sig_en=a4f12cbd3c55e211bd62f86a338e6ff5 -->

<!-- pgdoc-cn_start sig_en=3cb07f2c43ab286873d46c1c96000e9b sig_cn_org=7c1a687537fc6feab515a8b0ff83d557 source=15.7 
      <para>
       In pipeline mode, this function is disallowed.
      </para>
________________________________________________________-->
      <para>
       在管道模式下，此函数被禁止使用。
      </para>
<!-- pgdoc-cn_end sig_en=3cb07f2c43ab286873d46c1c96000e9b -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQsendQueryParams">
<!-- pgdoc-cn_start sig_en=6a9cba1e9c2d5ac0cf9b14a4bb76d52a sig_cn_org=6a9cba1e9c2d5ac0cf9b14a4bb76d52a source=15.7 
     <term><function>PQsendQueryParams</function><indexterm><primary>PQsendQueryParams</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQsendQueryParams</function><indexterm><primary>PQsendQueryParams</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=6a9cba1e9c2d5ac0cf9b14a4bb76d52a -->

     <listitem>
<!-- pgdoc-cn_start sig_en=b356553068e7dff4c439d9598bd1305c sig_cn_org=66c9af948c497ec1ae310bd5c93b4ecd source=15.7 
      <para>
       Submits a command and separate parameters to the server without
       waiting for the result(s).
<synopsis>
int PQsendQueryParams(PGconn *conn,
                      const char *command,
                      int nParams,
                      const Oid *paramTypes,
                      const char * const *paramValues,
                      const int *paramLengths,
                      const int *paramFormats,
                      int resultFormat);
</synopsis>

       This is equivalent to <xref linkend="libpq-PQsendQuery"/> except that
       query parameters can be specified separately from the query string.
       The function's parameters are handled identically to
       <xref linkend="libpq-PQexecParams"/>.  Like
       <xref linkend="libpq-PQexecParams"/>, it allows only one command in the
       query string.
      </para>
________________________________________________________-->
      <para>
       提交一个命令和参数到服务器，而不等待结果。
<synopsis>
int PQsendQueryParams(PGconn *conn,
                      const char *command,
                      int nParams,
                      const Oid *paramTypes,
                      const char * const *paramValues,
                      const int *paramLengths,
                      const int *paramFormats,
                      int resultFormat);
</synopsis>

       这相当于<xref linkend="libpq-PQsendQuery"/>，不同之处在于可以单独指定查询参数而不是与查询字符串一起指定。
       函数的参数处理方式与<xref linkend="libpq-PQexecParams"/>完全相同。与<xref linkend="libpq-PQexecParams"/>一样，它在查询字符串中只允许一个命令。
      </para>
<!-- pgdoc-cn_end sig_en=b356553068e7dff4c439d9598bd1305c -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQsendPrepare">
<!-- pgdoc-cn_start sig_en=9d7b4ae99f411e9c5d7737e058a96136 sig_cn_org=9d7b4ae99f411e9c5d7737e058a96136 source=15.7 
     <term><function>PQsendPrepare</function><indexterm><primary>PQsendPrepare</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQsendPrepare</function><indexterm><primary>PQsendPrepare</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=9d7b4ae99f411e9c5d7737e058a96136 -->

     <listitem>
<!-- pgdoc-cn_start sig_en=688dcd6e5691a7d52537830e61defc4c sig_cn_org=2ba4ff865bdc4b017d60f3a886b8af56 source=15.7 
      <para>
       Sends a request to create a prepared statement with the given
       parameters, without waiting for completion.
<synopsis>
int PQsendPrepare(PGconn *conn,
                  const char *stmtName,
                  const char *query,
                  int nParams,
                  const Oid *paramTypes);
</synopsis>

       This is an asynchronous version of <xref linkend="libpq-PQprepare"/>: it
       returns 1 if it was able to dispatch the request, and 0 if not.
       After a successful call, call <xref linkend="libpq-PQgetResult"/> to
       determine whether the server successfully created the prepared
       statement.  The function's parameters are handled identically to
       <xref linkend="libpq-PQprepare"/>.
      </para>
________________________________________________________-->
      <para>
       发送一个请求来创建一个带有给定参数的预处理语句，而不等待完成。
<synopsis>
int PQsendPrepare(PGconn *conn,
                  const char *stmtName,
                  const char *query,
                  int nParams,
                  const Oid *paramTypes);
</synopsis>

       这是<xref linkend="libpq-PQprepare"/>的异步版本：如果能够分派请求，则返回1，否则返回0。
       成功调用后，调用<xref linkend="libpq-PQgetResult"/>来确定服务器是否成功创建了预处理语句。
       该函数的参数处理方式与<xref linkend="libpq-PQprepare"/>完全相同。
      </para>
<!-- pgdoc-cn_end sig_en=688dcd6e5691a7d52537830e61defc4c -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQsendQueryPrepared">
<!-- pgdoc-cn_start sig_en=581f882483e9ca7c07d4277c8b8ba53e sig_cn_org=581f882483e9ca7c07d4277c8b8ba53e source=15.7 
     <term><function>PQsendQueryPrepared</function><indexterm><primary>PQsendQueryPrepared</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQsendQueryPrepared</function><indexterm><primary>PQsendQueryPrepared</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=581f882483e9ca7c07d4277c8b8ba53e -->

     <listitem>
<!-- pgdoc-cn_start sig_en=5a6a52c6c547d163333b4655f48ecd94 sig_cn_org=32df12d04535eb3d6041f01a718d3a74 source=15.7 
      <para>
       Sends a request to execute a prepared statement with given
       parameters, without waiting for the result(s).
<synopsis>
int PQsendQueryPrepared(PGconn *conn,
                        const char *stmtName,
                        int nParams,
                        const char * const *paramValues,
                        const int *paramLengths,
                        const int *paramFormats,
                        int resultFormat);
</synopsis>

       This is similar to <xref linkend="libpq-PQsendQueryParams"/>, but
       the command to be executed is specified by naming a
       previously-prepared statement, instead of giving a query string.
       The function's parameters are handled identically to
       <xref linkend="libpq-PQexecPrepared"/>.
      </para>
________________________________________________________-->
      <para>
       发送一个请求来执行一个准备好的语句，带有给定的参数，而不等待结果。
<synopsis>
int PQsendQueryPrepared(PGconn *conn,
                        const char *stmtName,
                        int nParams,
                        const char * const *paramValues,
                        const int *paramLengths,
                        const int *paramFormats,
                        int resultFormat);
</synopsis>

       这类似于<xref linkend="libpq-PQsendQueryParams"/>，但要执行的命令是通过指定一个之前准备好的语句的名称来指定，而不是提供一个查询字符串。
       函数的参数处理方式与<xref linkend="libpq-PQexecPrepared"/>完全相同。
      </para>
<!-- pgdoc-cn_end sig_en=5a6a52c6c547d163333b4655f48ecd94 -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQsendDescribePrepared">
<!-- pgdoc-cn_start sig_en=5b34e77731244ea56045c457c0d50671 sig_cn_org=5b34e77731244ea56045c457c0d50671 source=15.7 
     <term><function>PQsendDescribePrepared</function><indexterm><primary>PQsendDescribePrepared</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQsendDescribePrepared</function><indexterm><primary>PQsendDescribePrepared</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=5b34e77731244ea56045c457c0d50671 -->

     <listitem>
<!-- pgdoc-cn_start sig_en=5b16bb5aec82b0729a9ccc86b888d609 sig_cn_org=e68ba989f7c824cd29393661b70d650a source=15.7 
      <para>
       Submits a request to obtain information about the specified
       prepared statement, without waiting for completion.
<synopsis>
int PQsendDescribePrepared(PGconn *conn, const char *stmtName);
</synopsis>

       This is an asynchronous version of <xref linkend="libpq-PQdescribePrepared"/>:
       it returns 1 if it was able to dispatch the request, and 0 if not.
       After a successful call, call <xref linkend="libpq-PQgetResult"/> to
       obtain the results.  The function's parameters are handled
       identically to <xref linkend="libpq-PQdescribePrepared"/>.
      </para>
________________________________________________________-->
      <para>
       提交请求以获取关于指定预处理语句的信息，而无需等待完成。
<synopsis>
int PQsendDescribePrepared(PGconn *conn, const char *stmtName);
</synopsis>

       这是<xref linkend="libpq-PQdescribePrepared"/>的异步版本：
       如果能够发送请求，则返回1，否则返回0。
       成功调用后，调用<xref linkend="libpq-PQgetResult"/>来获取结果。
       函数的参数处理方式与<xref linkend="libpq-PQdescribePrepared"/>相同。
      </para>
<!-- pgdoc-cn_end sig_en=5b16bb5aec82b0729a9ccc86b888d609 -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQsendDescribePortal">
<!-- pgdoc-cn_start sig_en=cb33339cd28f52a61431f056c39f4947 sig_cn_org=cb33339cd28f52a61431f056c39f4947 source=15.7 
     <term><function>PQsendDescribePortal</function><indexterm><primary>PQsendDescribePortal</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQsendDescribePortal</function><indexterm><primary>PQsendDescribePortal</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=cb33339cd28f52a61431f056c39f4947 -->

     <listitem>
<!-- pgdoc-cn_start sig_en=64559daaa8f2ac067b562e4451cb9130 sig_cn_org=b449394284a256b4dae9cfd69919219b source=15.7 
      <para>
       Submits a request to obtain information about the specified
       portal, without waiting for completion.
<synopsis>
int PQsendDescribePortal(PGconn *conn, const char *portalName);
</synopsis>

       This is an asynchronous version of <xref linkend="libpq-PQdescribePortal"/>:
       it returns 1 if it was able to dispatch the request, and 0 if not.
       After a successful call, call <xref linkend="libpq-PQgetResult"/> to
       obtain the results.  The function's parameters are handled
       identically to <xref linkend="libpq-PQdescribePortal"/>.
      </para>
________________________________________________________-->
      <para>
       提交请求以获取有关指定门户的信息，而无需等待完成。
<synopsis>
int PQsendDescribePortal(PGconn *conn, const char *portalName);
</synopsis>

       这是<xref linkend="libpq-PQdescribePortal"/>的异步版本：
       如果能够发送请求，则返回1，否则返回0。
       成功调用后，调用<xref linkend="libpq-PQgetResult"/>以获取结果。
       该函数的参数处理方式与<xref linkend="libpq-PQdescribePortal"/>相同。
      </para>
<!-- pgdoc-cn_end sig_en=64559daaa8f2ac067b562e4451cb9130 -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQgetResult">
<!-- pgdoc-cn_start sig_en=0c80bc0d6a45b57dea4e1617cdc5fc95 sig_cn_org=0c80bc0d6a45b57dea4e1617cdc5fc95 source=15.7 
     <term><function>PQgetResult</function><indexterm><primary>PQgetResult</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQgetResult</function><indexterm><primary>PQgetResult</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=0c80bc0d6a45b57dea4e1617cdc5fc95 -->

     <listitem>
<!-- pgdoc-cn_start sig_en=f69e8a8c55d578270294ae914cef40aa sig_cn_org=7e48f710f209adfd6a8dfda7839bee36 source=15.7 
      <para>
       Waits for the next result from a prior
       <xref linkend="libpq-PQsendQuery"/>,
       <xref linkend="libpq-PQsendQueryParams"/>,
       <xref linkend="libpq-PQsendPrepare"/>,
       <xref linkend="libpq-PQsendQueryPrepared"/>,
       <xref linkend="libpq-PQsendDescribePrepared"/>,
       <xref linkend="libpq-PQsendDescribePortal"/>, or
       <xref linkend="libpq-PQpipelineSync"/>
       call, and returns it.
       A null pointer is returned when the command is complete and there
       will be no more results.
<synopsis>
PGresult *PQgetResult(PGconn *conn);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       等待来自先前的<xref linkend="libpq-PQsendQuery"/>、
       <xref linkend="libpq-PQsendQueryParams"/>、
       <xref linkend="libpq-PQsendPrepare"/>、
       <xref linkend="libpq-PQsendQueryPrepared"/>、
       <xref linkend="libpq-PQsendDescribePrepared"/>、
       <xref linkend="libpq-PQsendDescribePortal"/>或
       <xref linkend="libpq-PQpipelineSync"/>
       调用的下一个结果，并返回它。
       当命令完成且不会再有更多结果时，将返回空指针。
<synopsis>
PGresult *PQgetResult(PGconn *conn);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=f69e8a8c55d578270294ae914cef40aa -->

<!-- pgdoc-cn_start sig_en=4f93e748c2af5bade357946f58e66b7b sig_cn_org=fc1beae4ed34c7eb9f686cd6ff187644 source=15.7 
      <para>
       <xref linkend="libpq-PQgetResult"/> must be called repeatedly until
       it returns a null pointer, indicating that the command is done.
       (If called when no command is active,
       <xref linkend="libpq-PQgetResult"/> will just return a null pointer
       at once.) Each non-null result from
       <xref linkend="libpq-PQgetResult"/> should be processed using the
       same <structname>PGresult</structname> accessor functions previously
       described.  Don't forget to free each result object with
       <xref linkend="libpq-PQclear"/> when done with it.  Note that
       <xref linkend="libpq-PQgetResult"/> will block only if a command is
       active and the necessary response data has not yet been read by
       <xref linkend="libpq-PQconsumeInput"/>.
      </para>
________________________________________________________-->
      <para>
       必须重复调用<xref linkend="libpq-PQgetResult"/>直到返回空指针，表示命令已完成。
       （如果在没有活动命令时调用，
       <xref linkend="libpq-PQgetResult"/>将立即返回空指针。）每个非空结果从
       <xref linkend="libpq-PQgetResult"/>应该使用先前描述的相同<structname>PGresult</structname>访问器函数进行处理。
       完成后不要忘记使用<xref linkend="libpq-PQclear"/>释放每个结果对象。请注意，
       <xref linkend="libpq-PQgetResult"/>仅在有命令处于活动状态且必要的响应数据尚未被
       <xref linkend="libpq-PQconsumeInput"/>读取时才会阻塞。
      </para>
<!-- pgdoc-cn_end sig_en=4f93e748c2af5bade357946f58e66b7b -->

<!-- pgdoc-cn_start sig_en=44ba3d7401f28fcdb0b363272195b8f2 sig_cn_org=36986178c7c2e15c6224c279d96668ff source=15.7 
      <para>
       In pipeline mode, <function>PQgetResult</function> will return normally
       unless an error occurs; for any subsequent query sent after the one
       that caused the error until (and excluding) the next synchronization point,
       a special result of type <literal>PGRES_PIPELINE_ABORTED</literal> will
       be returned, and a null pointer will be returned after it.
       When the pipeline synchronization point is reached, a result of type
       <literal>PGRES_PIPELINE_SYNC</literal> will be returned.
       The result of the next query after the synchronization point follows
       immediately (that is, no null pointer is returned after
       the synchronization point.)
      </para>
________________________________________________________-->
      <para>
       在管道模式下，<function>PQgetResult</function>将正常返回，除非发生错误；
       对于在导致错误的查询之后发送的任何后续查询，直到（但不包括）下一个同步点，
       将返回特殊类型的结果<literal>PGRES_PIPELINE_ABORTED</literal>，
       并在其后返回空指针。
       当达到管道同步点时，将返回类型为<literal>PGRES_PIPELINE_SYNC</literal>的结果。
       在同步点之后立即跟随下一个查询的结果
       （即，在同步点之后不会返回空指针）。
      </para>
<!-- pgdoc-cn_end sig_en=44ba3d7401f28fcdb0b363272195b8f2 -->

      <note>
<!-- pgdoc-cn_start sig_en=c7df0f5ca9fbf052098e50adb7655e81 sig_cn_org=a032139839be142ff2a1108d479246bd source=15.7 
       <para>
        Even when <xref linkend="libpq-PQresultStatus"/> indicates a fatal
        error, <xref linkend="libpq-PQgetResult"/> should be called until it
        returns a null pointer, to allow <application>libpq</application> to
        process the error information completely.
       </para>
________________________________________________________-->
       <para>
        即使<xref linkend="libpq-PQresultStatus"/>指示发生了致命错误，也应该调用<xref linkend="libpq-PQgetResult"/>直到它返回一个空指针，
        以便<application>libpq</application>完全处理错误信息。
</para>
<!-- pgdoc-cn_end sig_en=c7df0f5ca9fbf052098e50adb7655e81 -->
      </note>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

<!-- pgdoc-cn_start sig_en=03e959dcac106c96f14aa9c48c1c1775 sig_cn_org=None source=14.1 
  <para>
   Using <xref linkend="libpq-PQsendQuery"/> and
   <xref linkend="libpq-PQgetResult"/> solves one of
   <xref linkend="libpq-PQexec"/>'s problems:  If a command string contains
   multiple <acronym>SQL</acronym> commands, the results of those commands
   can be obtained individually.  (This allows a simple form of overlapped
   processing, by the way: the client can be handling the results of one
   command while the server is still working on later queries in the same
   command string.)
  </para>
________________________________________________________-->
  <para>
   使用<xref linkend="libpq-PQsendQuery"/>和<xref linkend="libpq-PQgetResult"/>解决了<xref linkend="libpq-PQexec"/>的一个问题：如果一个命令字符串包含多个<acronym>SQL</acronym>命令，这些命令的结果可以被个别地获得（顺便说一句：这样就允许一种简单的重叠处理形式， 客户端可以处理一个命令的结果，而同时服务器可以继续处理同一命令字符串中后面的查询）。
  </para>
<!-- pgdoc-cn_end sig_en=03e959dcac106c96f14aa9c48c1c1775 -->

<!-- pgdoc-cn_start sig_en=eb99d5a217eafe3b9a875e7751aa94af sig_cn_org=None source=14.1 
  <para>
   Another frequently-desired feature that can be obtained with
   <xref linkend="libpq-PQsendQuery"/> and <xref linkend="libpq-PQgetResult"/>
   is retrieving large query results a row at a time.  This is discussed
   in <xref linkend="libpq-single-row-mode"/>.
  </para>
________________________________________________________-->
  <para>
   可以被<xref linkend="libpq-PQsendQuery"/>和<xref linkend="libpq-PQgetResult"/>获得的另一种常常想要的特性是一次从大型结果中检索一行。这会在<xref linkend="libpq-single-row-mode"/>中讨论。
  </para>
<!-- pgdoc-cn_end sig_en=eb99d5a217eafe3b9a875e7751aa94af -->

<!-- pgdoc-cn_start sig_en=018a758a39bd61a1f86b646e09a8167d sig_cn_org=None source=14.1 
  <para>
   By itself, calling <xref linkend="libpq-PQgetResult"/>
   will still cause the client to block until the server completes the
   next <acronym>SQL</acronym> command.  This can be avoided by proper
   use of two more functions:

   <variablelist>
    <varlistentry id="libpq-PQconsumeInput">
     <term><function>PQconsumeInput</function><indexterm><primary>PQconsumeInput</primary></indexterm>
     </term>

     <listitem>
      <para>
       If input is available from the server, consume it.
<synopsis>
int PQconsumeInput(PGconn *conn);
</synopsis>
      </para>

      <para>
       <xref linkend="libpq-PQconsumeInput"/> normally returns 1 indicating
       <quote>no error</quote>, but returns 0 if there was some kind of
       trouble (in which case <xref linkend="libpq-PQerrorMessage"/> can be
       consulted).  Note that the result does not say whether any input
       data was actually collected. After calling
       <xref linkend="libpq-PQconsumeInput"/>, the application can check
       <xref linkend="libpq-PQisBusy"/> and/or
       <function>PQnotifies</function> to see if their state has changed.
      </para>

      <para>
       <xref linkend="libpq-PQconsumeInput"/> can be called even if the
       application is not prepared to deal with a result or notification
       just yet.  The function will read available data and save it in
       a buffer, thereby causing a <function>select()</function>
       read-ready indication to go away.  The application can thus use
       <xref linkend="libpq-PQconsumeInput"/> to clear the
       <function>select()</function> condition immediately, and then
       examine the results at leisure.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQisBusy">
     <term><function>PQisBusy</function><indexterm><primary>PQisBusy</primary></indexterm></term>

     <listitem>
      <para>
       Returns 1 if a command is busy, that is,
       <xref linkend="libpq-PQgetResult"/> would block waiting for input.
       A 0 return indicates that <xref linkend="libpq-PQgetResult"/> can be
       called with assurance of not blocking.
<synopsis>
int PQisBusy(PGconn *conn);
</synopsis>
      </para>

      <para>
       <xref linkend="libpq-PQisBusy"/> will not itself attempt to read data
       from the server; therefore <xref linkend="libpq-PQconsumeInput"/>
       must be invoked first, or the busy state will never end.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
________________________________________________________-->
  <para>
   就其本身而言，调用<xref linkend="libpq-PQgetResult"/>将仍会导致客户端阻塞，直到服务器完成下一个<acronym>SQL</acronym>命令。可以通过正确使用两个函数来避免这种情况：

   <variablelist>
    <varlistentry id="libpq-PQconsumeInput">
     <term><function>PQconsumeInput</function><indexterm><primary>PQconsumeInput</primary></indexterm>
     </term>

     <listitem>
      <para>
       如果有来自服务器的输入可用，则使用之。
<synopsis>
int PQconsumeInput(PGconn *conn);
</synopsis>
      </para>

      <para>
       <xref linkend="libpq-PQconsumeInput"/>通常返回 1 表明<quote>没有错误</quote>，而返回 0 表明有某种麻烦发生（此时可以用<xref linkend="libpq-PQerrorMessage"/>）。
       注意该结果并不表明是否真正收集了任何输入数据。在调用<xref linkend="libpq-PQconsumeInput"/>之后，应用可以检查<xref linkend="libpq-PQisBusy"/>和/或<function>PQnotifies</function>来看看它们的状态是否改变。
      </para>

      <para>
       即使应用还不准备处理一个结果或通知，<xref linkend="libpq-PQconsumeInput"/>也可以被调用。
       这个函数将读取可用的数 据并且把它保存在一个缓冲区中，从而导致一个<function>select()</function>的读准备好指示消失。
       因此应用可以使用<xref linkend="libpq-PQconsumeInput"/>立即清除<function>select()</function>条件，并且在空闲时再检查结果。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQisBusy">
     <term><function>PQisBusy</function><indexterm><primary>PQisBusy</primary></indexterm></term>

     <listitem>
      <para>
       如果一个命令繁忙则返回 1，也就是说<xref linkend="libpq-PQgetResult"/>会阻塞等待输入。返回 0 表示可以调用<xref linkend="libpq-PQgetResult"/>而不用担心阻塞。
<synopsis>
int PQisBusy(PGconn *conn);
</synopsis>
      </para>

      <para>
       <xref linkend="libpq-PQisBusy"/>本身将不会尝试从服务器读取数据，因此必须先调用<xref linkend="libpq-PQconsumeInput"/>，否则繁忙状态将永远不会结束。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
<!-- pgdoc-cn_end sig_en=018a758a39bd61a1f86b646e09a8167d -->

<!-- pgdoc-cn_start sig_en=f2502024d02eeb0c4638df185e11901a sig_cn_org=None source=14.1 
  <para>
   A typical application using these functions will have a main loop that
   uses <function>select()</function> or <function>poll()</function> to wait for
   all the conditions that it must respond to.  One of the conditions
   will be input available from the server, which in terms of
   <function>select()</function> means readable data on the file
   descriptor identified by <xref linkend="libpq-PQsocket"/>.  When the main
   loop detects input ready, it should call
   <xref linkend="libpq-PQconsumeInput"/> to read the input.  It can then
   call <xref linkend="libpq-PQisBusy"/>, followed by
   <xref linkend="libpq-PQgetResult"/> if <xref linkend="libpq-PQisBusy"/>
   returns false (0).  It can also call <function>PQnotifies</function>
   to detect <command>NOTIFY</command> messages (see <xref
   linkend="libpq-notify"/>).
  </para>
________________________________________________________-->
  <para>
   一个使用这些函数的典型应用将有一个主循环，在主循环中会使用<function>select()</function>或<function>poll()</function>等待所有它必须响应的情况。
   其中之一将是来自服务器的输入可用，对<function>select()</function>来说意味着<xref linkend="libpq-PQsocket"/>标识的文件描述符上有可读的数据。
   当主循环检测到输入准备好时，它将调用<xref linkend="libpq-PQconsumeInput"/>读取输入。
   然后它可以调用<xref linkend="libpq-PQisBusy"/>，如果<xref linkend="libpq-PQisBusy"/>返回假（0）则接着调用<xref linkend="libpq-PQgetResult"/>。
   它还可以调用<function>PQnotifies</function>检测<command>NOTIFY</command>消息（见<xref linkend="libpq-notify"/>）。
  </para>
<!-- pgdoc-cn_end sig_en=f2502024d02eeb0c4638df185e11901a -->

<!-- pgdoc-cn_start sig_en=914c691c01ee8d10b2a1fc6bc56de22a sig_cn_org=None source=14.1 
  <para>
   A client that uses
   <xref linkend="libpq-PQsendQuery"/>/<xref linkend="libpq-PQgetResult"/>
   can also attempt to cancel a command that is still being processed
   by the server; see <xref linkend="libpq-cancel"/>.  But regardless of
   the return value of <xref linkend="libpq-PQcancel"/>, the application
   must continue with the normal result-reading sequence using
   <xref linkend="libpq-PQgetResult"/>.  A successful cancellation will
   simply cause the command to terminate sooner than it would have
   otherwise.
  </para>
________________________________________________________-->
  <para>
   一个使用<xref linkend="libpq-PQsendQuery"/>/<xref linkend="libpq-PQgetResult"/>的客户端也可以尝试取消一个正在被服务器处理的命令，见<xref linkend="libpq-cancel"/>。
   但是，不管<xref linkend="libpq-PQcancel"/>的返回值是什么，应用都必须继续使用<xref linkend="libpq-PQgetResult"/>进行正常的结果读取序列。一次成功的取消只会导致命令比不取消时更快终止。
  </para>
<!-- pgdoc-cn_end sig_en=914c691c01ee8d10b2a1fc6bc56de22a -->

<!-- pgdoc-cn_start sig_en=b0e1308e3404f534a1acb4311b271da9 sig_cn_org=d80228279669362a3c90a9500a34d20d source=15.7 
  <para>
   By using the functions described above, it is possible to avoid
   blocking while waiting for input from the database server.  However,
   it is still possible that the application will block waiting to send
   output to the server.  This is relatively uncommon but can happen if
   very long SQL commands or data values are sent.  (It is much more
   probable if the application sends data via <command>COPY IN</command>,
   however.)  To prevent this possibility and achieve completely
   nonblocking database operation, the following additional functions
   can be used.

   <variablelist>
    <varlistentry id="libpq-PQsetnonblocking">
     <term><function>PQsetnonblocking</function><indexterm><primary>PQsetnonblocking</primary></indexterm></term>

     <listitem>
      <para>
       Sets the nonblocking status of the connection.
<synopsis>
int PQsetnonblocking(PGconn *conn, int arg);
</synopsis>
      </para>

      <para>
       Sets the state of the connection to nonblocking if
       <parameter>arg</parameter> is 1, or blocking if
       <parameter>arg</parameter> is 0.  Returns 0 if OK, -1 if error.
      </para>

      <para>
       In the nonblocking state, successful calls to
       <xref linkend="libpq-PQsendQuery"/>, <xref linkend="libpq-PQputline"/>,
       <xref linkend="libpq-PQputnbytes"/>, <xref linkend="libpq-PQputCopyData"/>,
       and <xref linkend="libpq-PQendcopy"/> will not block;  their changes
       are stored in the local output buffer until they are flushed.
       Unsuccessful calls will return an error and must be retried.
      </para>

      <para>
       Note that <xref linkend="libpq-PQexec"/> does not honor nonblocking
       mode; if it is called, it will act in blocking fashion anyway.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQisnonblocking">
     <term><function>PQisnonblocking</function><indexterm><primary>PQisnonblocking</primary></indexterm></term>

     <listitem>
      <para>
       Returns the blocking status of the database connection.
<synopsis>
int PQisnonblocking(const PGconn *conn);
</synopsis>
      </para>

      <para>
       Returns 1 if the connection is set to nonblocking mode and 0 if
       blocking.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQflush">
     <term><function>PQflush</function><indexterm><primary>PQflush</primary></indexterm></term>

      <listitem>
       <para>
       Attempts to flush any queued output data to the server.  Returns
       0 if successful (or if the send queue is empty), -1 if it failed
       for some reason, or 1 if it was unable to send all the data in
       the send queue yet (this case can only occur if the connection
       is nonblocking).
<synopsis>
int PQflush(PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
________________________________________________________-->
  <para>
   通过使用上面描述的函数，可以避免在等待来自数据库服务器的输入时阻塞。
   然而，应用程序仍然可能会在等待向服务器发送输出时阻塞。
   这在发送非常长的SQL命令或数据值时可能会发生，尽管这相对不常见。
   （如果应用程序通过<command>COPY IN</command>发送数据，则更有可能发生。）
   为了防止这种可能性并实现完全非阻塞的数据库操作，可以使用以下附加函数。

   <variablelist>
    <varlistentry id="libpq-PQsetnonblocking">
     <term><function>PQsetnonblocking</function><indexterm><primary>PQsetnonblocking</primary></indexterm></term>

     <listitem>
      <para>
       设置连接的非阻塞状态。
<synopsis>
int PQsetnonblocking(PGconn *conn, int arg);
</synopsis>
      </para>

      <para>
       如果<parameter>arg</parameter>为1，则将连接状态设置为非阻塞，如果
       <parameter>arg</parameter>为0，则设置为阻塞。如果成功返回0，出错返回-1。
      </para>

      <para>
       在非阻塞状态下，成功调用<xref linkend="libpq-PQsendQuery"/>、
       <xref linkend="libpq-PQputline"/>、<xref linkend="libpq-PQputnbytes"/>、
       <xref linkend="libpq-PQputCopyData"/>和<xref linkend="libpq-PQendcopy"/>不会阻塞；
       它们的更改将存储在本地输出缓冲区中，直到刷新为止。
       不成功的调用将返回错误，必须重试。
      </para>

      <para>
       请注意，<xref linkend="libpq-PQexec"/>不遵守非阻塞模式；如果调用它，它将以阻塞方式执行。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQisnonblocking">
     <term><function>PQisnonblocking</function><indexterm><primary>PQisnonblocking</primary></indexterm></term>

     <listitem>
      <para>
       返回数据库连接的阻塞状态。
<synopsis>
int PQisnonblocking(const PGconn *conn);
</synopsis>
      </para>

      <para>
       如果连接设置为非阻塞模式，则返回1，如果为阻塞，则返回0。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQflush">
     <term><function>PQflush</function><indexterm><primary>PQflush</primary></indexterm></term>

      <listitem>
       <para>
       尝试将任何排队的输出数据刷新到服务器。如果成功（或发送队列为空），则返回0；
       如果由于某种原因失败，则返回-1；如果尚未能够发送发送队列中的所有数据（只有在连接为非阻塞时才会发生此情况），
       则返回1。
<synopsis>
int PQflush(PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
<!-- pgdoc-cn_end sig_en=b0e1308e3404f534a1acb4311b271da9 -->

<!-- pgdoc-cn_start sig_en=ab7fe2fda6250c4b07814c476b8e9d4d sig_cn_org=None source=14.1 
  <para>
   After sending any command or data on a nonblocking connection, call
   <xref linkend="libpq-PQflush"/>.  If it returns 1, wait for the socket
   to become read- or write-ready.  If it becomes write-ready, call
   <xref linkend="libpq-PQflush"/> again.  If it becomes read-ready, call
   <xref linkend="libpq-PQconsumeInput"/>, then call
   <xref linkend="libpq-PQflush"/> again.  Repeat until
   <xref linkend="libpq-PQflush"/> returns 0.  (It is necessary to check for
   read-ready and drain the input with <xref linkend="libpq-PQconsumeInput"/>,
   because the server can block trying to send us data, e.g., NOTICE
   messages, and won't read our data until we read its.)  Once
   <xref linkend="libpq-PQflush"/> returns 0, wait for the socket to be
   read-ready and then read the response as described above.
  </para>
________________________________________________________-->
  <para>
   在一个非阻塞连接上发送任何命令或者数据之后，要调用<xref linkend="libpq-PQflush"/>。
   如果它返回 1，就要等待套接字变成读准备好或写准备好。如果它变为写准备好，应再次调用<xref linkend="libpq-PQflush"/>。
   如果它变为读准备好，则应先调用<xref linkend="libpq-PQconsumeInput"/>，然后再调用<xref linkend="libpq-PQflush"/>。
   一直重复直到<xref linkend="libpq-PQflush"/>返回 0（有必要检查读准备好并且用<xref linkend="libpq-PQconsumeInput"/>耗尽输入，因为服务器可能阻塞给我们发送数据的尝试，例如 NOTICE 消息，并且在我们读它的数据之前它都不会读我们的数据）。
   一旦<xref linkend="libpq-PQflush"/>返回 0，应等待套接字变成读准备好并且接着按照上文所述读取响应。
  </para>
<!-- pgdoc-cn_end sig_en=ab7fe2fda6250c4b07814c476b8e9d4d -->

 </sect1>

 <sect1 id="libpq-pipeline-mode">
<!-- pgdoc-cn_start sig_en=623587e595b86be8441efaa63e859cb3 sig_cn_org=None source=14.1 
  <title>Pipeline Mode</title>
________________________________________________________-->
  <title>管道模式</title>
<!-- pgdoc-cn_end sig_en=623587e595b86be8441efaa63e859cb3 -->

<!-- pgdoc-cn_start sig_en=6f3a128be03a190bb33d104aaed12fad sig_cn_org=None source=14.1 
  <indexterm zone="libpq-pipeline-mode">
   <primary>libpq</primary>
   <secondary>pipeline mode</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="libpq-pipeline-mode">
   <primary>libpq</primary>
   <secondary>管道模式</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=6f3a128be03a190bb33d104aaed12fad -->

<!-- pgdoc-cn_start sig_en=0e4031c29033c270826c4020cfb5de1f sig_cn_org=None source=14.1 
  <indexterm zone="libpq-pipeline-mode">
   <primary>pipelining</primary>
   <secondary>in libpq</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="libpq-pipeline-mode">
   <primary>pipelining</primary>
   <secondary>in libpq</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=0e4031c29033c270826c4020cfb5de1f -->

<!-- pgdoc-cn_start sig_en=09da493a824ebe3e8227c95ea91613d8 sig_cn_org=None source=14.1 
  <indexterm zone="libpq-pipeline-mode">
   <primary>batch mode</primary>
   <secondary>in libpq</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="libpq-pipeline-mode">
   <primary>batch mode</primary>
   <secondary>in libpq</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=09da493a824ebe3e8227c95ea91613d8 -->

<!-- pgdoc-cn_start sig_en=b7f743c341e9acd1183154f484361fab sig_cn_org=None source=14.1 
  <para>
   <application>libpq</application> pipeline mode allows applications to
   send a query without having to read the result of the previously
   sent query.  Taking advantage of the pipeline mode, a client will wait
   less for the server, since multiple queries/results can be
   sent/received in a single network transaction.
  </para>
________________________________________________________-->
  <para>
   <application>libpq</application> 管道模式允许应用发送查询而无需读取先前发送查询的结果。
   利用管道模式的优点，客户端将对服务器等待的更少，因为可以在单个网络事务中发送/接收多个查询/结果。
  </para>
<!-- pgdoc-cn_end sig_en=b7f743c341e9acd1183154f484361fab -->

<!-- pgdoc-cn_start sig_en=ec16d54b17cf38c48d1aaff760231d34 sig_cn_org=None source=14.1 
  <para>
   While pipeline mode provides a significant performance boost, writing
   clients using the pipeline mode is more complex because it involves
   managing a queue of pending queries and finding which result
   corresponds to which query in the queue.
  </para>
________________________________________________________-->
  <para>
   虽然管道模式提供了显著的性能提升，
   使用管道模式写客户端会更加复杂，因为它涉及到管理一个挂起查询的队列，并查找队列中的哪个结果对应于哪个查询。
  </para>
<!-- pgdoc-cn_end sig_en=ec16d54b17cf38c48d1aaff760231d34 -->

<!-- pgdoc-cn_start sig_en=7b165f577e10cee0d9b3c03ae7bf9026 sig_cn_org=None source=14.1 
  <para>
   Pipeline mode also generally consumes more memory on both the client and server,
   though careful and aggressive management of the send/receive queue can mitigate
   this.  This applies whether or not the connection is in blocking or non-blocking
   mode.
  </para>
________________________________________________________-->
  <para>
   管道模式通常也会在客户端和服务器上面消耗更多的内存，尽管仔细和积极地管理发送/接收队列可以减轻这种消耗。
   这适用于连接是否处于阻塞或非阻塞模式。
  </para>
<!-- pgdoc-cn_end sig_en=7b165f577e10cee0d9b3c03ae7bf9026 -->

<!-- pgdoc-cn_start sig_en=65d9769d7bed6b7e6751219b7f7664c5 sig_cn_org=6f6aa15aa3bcd483324c0498c5c6b430 source=15.7 
  <para>
   While <application>libpq</application>'s pipeline API was introduced in
   <productname>PostgreSQL</productname> 14, it is a client-side feature
   which doesn't require special server support and works on any server
   that supports the v3 extended query protocol.  For more information see
   <xref linkend="protocol-flow-pipelining"/>.
  </para>
________________________________________________________-->
  <para>
   虽然<application>libpq</application>的流水线API是在<productname>PostgreSQL</productname> 14中引入的，
   但它是一个客户端特性，不需要特殊的服务器支持，并且适用于支持v3扩展查询协议的任何服务器。
   欲了解更多信息，请参阅<xref linkend="protocol-flow-pipelining"/>。
</para>
<!-- pgdoc-cn_end sig_en=65d9769d7bed6b7e6751219b7f7664c5 -->

  <sect2 id="libpq-pipeline-using">
<!-- pgdoc-cn_start sig_en=e884650c0a331f8fa9ea53e00242fa1b sig_cn_org=None source=14.1 
   <title>Using Pipeline Mode</title>
________________________________________________________-->
   <title>使用管道模式</title>
<!-- pgdoc-cn_end sig_en=e884650c0a331f8fa9ea53e00242fa1b -->

<!-- pgdoc-cn_start sig_en=eebaaced5399323ca9c93d568d614ca9 sig_cn_org=c37c702da76703b7bbfe01b0baee9ce4 source=15.7 
   <para>
    To issue pipelines, the application must switch the connection
    into pipeline mode,
    which is done with <xref linkend="libpq-PQenterPipelineMode"/>.
    <xref linkend="libpq-PQpipelineStatus"/> can be used
    to test whether pipeline mode is active.
    In pipeline mode, only <link linkend="libpq-async">asynchronous operations</link>
    that utilize the extended query protocol
    are permitted, command strings containing multiple SQL commands are
    disallowed, and so is <literal>COPY</literal>.
    Using synchronous command execution functions
    such as <function>PQfn</function>,
    <function>PQexec</function>,
    <function>PQexecParams</function>,
    <function>PQprepare</function>,
    <function>PQexecPrepared</function>,
    <function>PQdescribePrepared</function>,
    <function>PQdescribePortal</function>,
    is an error condition.
    <function>PQsendQuery</function> is
    also disallowed, because it uses the simple query protocol.
    Once all dispatched commands have had their results processed, and
    the end pipeline result has been consumed, the application may return
    to non-pipelined mode with <xref linkend="libpq-PQexitPipelineMode"/>.
   </para>
________________________________________________________-->
   <para>
    要发出管道命令，应用程序必须将连接切换到管道模式，
    可以通过<xref linkend="libpq-PQenterPipelineMode"/>来完成。
    可以使用<xref linkend="libpq-PQpipelineStatus"/>来测试管道模式是否激活。
    在管道模式下，只允许使用扩展查询协议的<link linkend="libpq-async">异步操作</link>，
    不允许包含多个SQL命令的命令字符串，也不允许使用<literal>COPY</literal>命令。
    使用同步命令执行函数，如<function>PQfn</function>、
    <function>PQexec</function>、
    <function>PQexecParams</function>、
    <function>PQprepare</function>、
    <function>PQexecPrepared</function>、
    <function>PQdescribePrepared</function>、
    <function>PQdescribePortal</function>，
    都会导致错误。
    也不允许使用<function>PQsendQuery</function>，因为它使用简单查询协议。
    一旦所有已分派的命令的结果已被处理，并且
    结束管道结果已被消耗，应用程序可以通过<xref linkend="libpq-PQexitPipelineMode"/>返回
    到非管道模式。
</para>
<!-- pgdoc-cn_end sig_en=eebaaced5399323ca9c93d568d614ca9 -->

   <note>
<!-- pgdoc-cn_start sig_en=34437837dfd22dea85904250214fd1aa sig_cn_org=None source=14.1 
    <para>
     It is best to use pipeline mode with <application>libpq</application> in
     <link linkend="libpq-PQsetnonblocking">non-blocking mode</link>. If used
     in blocking mode it is possible for a client/server deadlock to occur.
      <footnote>
       <para>
        The client will block trying to send queries to the server, but the
        server will block trying to send results to the client from queries
        it has already processed. This only occurs when the client sends
        enough queries to fill both its output buffer and the server's receive
        buffer before it switches to processing input from the server,
        but it's hard to predict exactly when that will happen.
       </para>
      </footnote>
    </para>
________________________________________________________-->
    <para>
     最好在<application>libpq</application>在<link linkend="libpq-PQsetnonblocking">non-blocking mode</link>的时候使用管道模式。
     如果在阻塞模式下使用，它可能发生客户端/服务器死锁。
      <footnote>
       <para>
        客户端将阻止尝试发送查询到服务器，但服务器将阻止从它已经处理的查询向客户端发送结果。
        这只有当客户端在它切换到处理从服务器的输入之前发送足够的查询来填充其输出缓冲区和服务器的接收缓冲区，才会发生这种情况，但很难准确预测何时将发生。
       </para>
      </footnote>
    </para>
<!-- pgdoc-cn_end sig_en=34437837dfd22dea85904250214fd1aa -->
   </note>

   <sect3 id="libpq-pipeline-sending">
<!-- pgdoc-cn_start sig_en=8e737679ee42061d9a9d9726e4da1b50 sig_cn_org=None source=14.1 
    <title>Issuing Queries</title>
________________________________________________________-->
    <title>发出查询</title>
<!-- pgdoc-cn_end sig_en=8e737679ee42061d9a9d9726e4da1b50 -->

<!-- pgdoc-cn_start sig_en=398eaa7e9162132ac2ecf7aa3708cecb sig_cn_org=39c848fe53f6b7a9c0478161f928ef9a source=15.7 
    <para>
     After entering pipeline mode, the application dispatches requests using
     <xref linkend="libpq-PQsendQueryParams"/>
     or its prepared-query sibling
     <xref linkend="libpq-PQsendQueryPrepared"/>.
     These requests are queued on the client-side until flushed to the server;
     this occurs when <xref linkend="libpq-PQpipelineSync"/> is used to
     establish a synchronization point in the pipeline,
     or when <xref linkend="libpq-PQflush"/> is called.
     The functions <xref linkend="libpq-PQsendPrepare"/>,
     <xref linkend="libpq-PQsendDescribePrepared"/>, and
     <xref linkend="libpq-PQsendDescribePortal"/> also work in pipeline mode.
     Result processing is described below.
    </para>
________________________________________________________-->
    <para>
     进入管道模式后，应用程序使用<xref linkend="libpq-PQsendQueryParams"/>或其准备查询的兄弟节点<xref linkend="libpq-PQsendQueryPrepared"/>来分派请求。
     这些请求在客户端排队，直到刷新到服务器端；当使用<xref linkend="libpq-PQpipelineSync"/>建立管道中的同步点时，或者调用<xref linkend="libpq-PQflush"/>时，会发生这种情况。
     函数<xref linkend="libpq-PQsendPrepare"/>、<xref linkend="libpq-PQsendDescribePrepared"/>和<xref linkend="libpq-PQsendDescribePortal"/>在管道模式下也可以工作。
     结果处理如下所述。
    </para>
<!-- pgdoc-cn_end sig_en=398eaa7e9162132ac2ecf7aa3708cecb -->

<!-- pgdoc-cn_start sig_en=7c8318068179afb2b75942d2e70bae33 sig_cn_org=None source=14.1 
    <para>
     The server executes statements, and returns results, in the order the
     client sends them.  The server will begin executing the commands in the
     pipeline immediately, not waiting for the end of the pipeline.
     Note that results are buffered on the server side; the server flushes
     that buffer when a synchronization point is established with
     <function>PQpipelineSync</function>, or when
     <function>PQsendFlushRequest</function> is called.
     If any statement encounters an error, the server aborts the current
     transaction and does not execute any subsequent command in the queue
     until the next synchronization point;
     a <literal>PGRES_PIPELINE_ABORTED</literal> result is produced for
     each such command.
     (This remains true even if the commands in the pipeline would rollback
     the transaction.)
     Query processing resumes after the synchronization point.
    </para>
________________________________________________________-->
    <para>
     服务器执行语句，并返回结果，按客户端发送它们的顺序。
     服务器将立即开始执行管道中的命令，不等待管道的结束。
     注意，结果被缓冲在服务器端端;当使用<function>PQpipelineSync</function>建立同步点时，或者<function>PQsendFlushRequest</function>被调用时，服务器会刷新该缓冲区。
     如果任何语句遇到错误，服务器将中止当前事务，并且不执行队列中的任何后续命令，直到下一个同步点;对于每一个这样的命令都会产生一个<literal>PGRES_PIPELINE_ABORTED</literal>结果。
     (即使管道中的命令将回滚事务，依然如此。)
     查询处理在同步点之后恢复。
    </para>
<!-- pgdoc-cn_end sig_en=7c8318068179afb2b75942d2e70bae33 -->

<!-- pgdoc-cn_start sig_en=661ac6cceeabac500b2605b53d3c9cb7 sig_cn_org=None source=14.1 
    <para>
     It's fine for one operation to depend on the results of a
     prior one; for example, one query may define a table that the next
     query in the same pipeline uses. Similarly, an application may
     create a named prepared statement and execute it with later
     statements in the same pipeline.
    </para>
________________________________________________________-->
    <para>
     一个操作依赖于前一个操作的结果是没问题的;
     例如，一个查询可以定义一个同一管道中的下一个查询将用到的表。
     类似地，应用可以创建一个命名的预处理语句，并在同一管道中与后续语句一起执行它。
    </para>
<!-- pgdoc-cn_end sig_en=661ac6cceeabac500b2605b53d3c9cb7 -->
   </sect3>

   <sect3 id="libpq-pipeline-results">
<!-- pgdoc-cn_start sig_en=07dca73a6cd538061440956a2df3d0c2 sig_cn_org=None source=14.1 
    <title>Processing Results</title>
________________________________________________________-->
    <title>处理结果</title>
<!-- pgdoc-cn_end sig_en=07dca73a6cd538061440956a2df3d0c2 -->

<!-- pgdoc-cn_start sig_en=772adfb93497665a9fb14f9041b7732e sig_cn_org=None source=14.1 
    <para>
     To process the result of one query in a pipeline, the application calls
     <function>PQgetResult</function> repeatedly and handles each result
     until <function>PQgetResult</function> returns null.
     The result from the next query in the pipeline may then be retrieved using
     <function>PQgetResult</function> again and the cycle repeated.
     The application handles individual statement results as normal.
     When the results of all the queries in the pipeline have been
     returned, <function>PQgetResult</function> returns a result
     containing the status value <literal>PGRES_PIPELINE_SYNC</literal>
    </para>
________________________________________________________-->
    <para>
     为了在管道中处理一个查询的结果，应用重复调用<function>PQgetResult</function>并处理每个结果，直到<function>PQgetResult</function>返回空。
     可以再次使用<function>PQgetResult</function>检索管道中下一个查询的结果，并且循环重复
     应用像通常一样处理单个语句结果。
     当管道中所有查询的结果都返回时，<function>PQgetResult</function>返回一个结果，其包含状态值<literal>PGRES_PIPELINE_SYNC</literal>。
    </para>
<!-- pgdoc-cn_end sig_en=772adfb93497665a9fb14f9041b7732e -->

<!-- pgdoc-cn_start sig_en=c8cfb59233dbbb18713b947079dd09d1 sig_cn_org=None source=14.1 
    <para>
     The client may choose to defer result processing until the complete
     pipeline has been sent, or interleave that with sending further
     queries in the pipeline; see <xref linkend="libpq-pipeline-interleave"/>.
    </para>
________________________________________________________-->
    <para>
     客户端可以选择延迟结果处理，直到完整的管道被发送，或者与管道中发送的更多的查询交错在一起;参见<xref linkend="libpq-pipeline-interleave"/>。
    </para>
<!-- pgdoc-cn_end sig_en=c8cfb59233dbbb18713b947079dd09d1 -->

<!-- pgdoc-cn_start sig_en=b70ea9a6e6890f5df720240796f8fa2b sig_cn_org=None source=14.1 
    <para>
     To enter single-row mode, call <function>PQsetSingleRowMode</function>
     before retrieving results with <function>PQgetResult</function>.
     This mode selection is effective only for the query currently
     being processed. For more information on the use of
     <function>PQsetSingleRowMode</function>,
     refer to <xref linkend="libpq-single-row-mode"/>.
    </para>
________________________________________________________-->
    <para>
     要进入单行模式，在使用<function>PQgetResult</function>检索结果之前调用<function>PQsetSingleRowMode</function>。
     此模式选择仅对当前处理的查询有效。
     有关使用<function>PQsetSingleRowMode</function>的更多信息，请参阅<xref linkend="libpq-single-row-mode"/>。
    </para>
<!-- pgdoc-cn_end sig_en=b70ea9a6e6890f5df720240796f8fa2b -->

<!-- pgdoc-cn_start sig_en=b0781df65a6ac11c844f37b1b2184745 sig_cn_org=None source=14.1 
    <para>
     <function>PQgetResult</function> behaves the same as for normal
     asynchronous processing except that it may contain the new
     <type>PGresult</type> types <literal>PGRES_PIPELINE_SYNC</literal>
     and <literal>PGRES_PIPELINE_ABORTED</literal>.
     <literal>PGRES_PIPELINE_SYNC</literal> is reported exactly once for each
     <function>PQpipelineSync</function> at the corresponding point
     in the pipeline.
     <literal>PGRES_PIPELINE_ABORTED</literal> is emitted in place of a normal
     query result for the first error and all subsequent results
     until the next <literal>PGRES_PIPELINE_SYNC</literal>;
     see <xref linkend="libpq-pipeline-errors"/>.
    </para>
________________________________________________________-->
    <para>
     <function>PQgetResult</function>行为与普通异步处理相同，除了它可能包含新的<type>PGresult</type>类型<literal>PGRES_PIPELINE_SYNC</literal> 和<literal>PGRES_PIPELINE_ABORTED</literal>。
     对于每个在管道中相应的点的<function>PQpipelineSync</function>，<literal>PGRES_PIPELINE_SYNC</literal>确定报告一次。
     <literal>PGRES_PIPELINE_ABORTED</literal>在第一个错误和所有后续结果的正常查询结果中发出，直到下一个<literal>PGRES_PIPELINE_SYNC</literal>;参见<xref linkend="libpq-pipeline-errors"/>。
    </para>
<!-- pgdoc-cn_end sig_en=b0781df65a6ac11c844f37b1b2184745 -->

<!-- pgdoc-cn_start sig_en=860292cd8a1a238f5189a033a47e11b0 sig_cn_org=None source=14.1 
    <para>
     <function>PQisBusy</function>, <function>PQconsumeInput</function>, etc
     operate as normal when processing pipeline results.  In particular,
     a call to <function>PQisBusy</function> in the middle of a pipeline
     returns 0 if the results for all the queries issued so far have been
     consumed.
    </para>
________________________________________________________-->
    <para>
     <function>PQisBusy</function>、<function>PQconsumeInput</function>、等正常操作，在处理管道结果时。
     特别是，在管道中间调用<function>PQisBusy</function> 时，如果到目前为止发出的所有查询的结果都已被消耗，则返回0。
    </para>
<!-- pgdoc-cn_end sig_en=860292cd8a1a238f5189a033a47e11b0 -->

<!-- pgdoc-cn_start sig_en=e50260b6752719bc8b51248d759305fa sig_cn_org=None source=14.1 
    <para>
     <application>libpq</application> does not provide any information to the
     application about the query currently being processed (except that
     <function>PQgetResult</function> returns null to indicate that we start
     returning the results of next query). The application must keep track
     of the order in which it sent queries, to associate them with their
     corresponding results.
     Applications will typically use a state machine or a FIFO queue for this.
    </para>
________________________________________________________-->
    <para>
     <application>libpq</application>不向应用提供有关当前正在处理的查询的任何信息(除了<function>PQgetResult</function>返回空，以表示我们开始返回下一个查询的结果)。
     应用必须保持跟踪它发送查询的顺序，以将它们与相应的结果相关联。
     应用通常会为此使用状态机或FIFO队列。
    </para>
<!-- pgdoc-cn_end sig_en=e50260b6752719bc8b51248d759305fa -->

   </sect3>

   <sect3 id="libpq-pipeline-errors">
<!-- pgdoc-cn_start sig_en=6886733ebecc00092d52eab7cd0aad90 sig_cn_org=None source=14.1 
    <title>Error Handling</title>
________________________________________________________-->
    <title>错误处理</title>
<!-- pgdoc-cn_end sig_en=6886733ebecc00092d52eab7cd0aad90 -->

<!-- pgdoc-cn_start sig_en=068bb9caa10a93c53dc9f79faee935f0 sig_cn_org=None source=14.1 
    <para>
     From the client's perspective, after <function>PQresultStatus</function>
     returns <literal>PGRES_FATAL_ERROR</literal>,
     the pipeline is flagged as aborted.
     <function>PQresultStatus</function> will report a
     <literal>PGRES_PIPELINE_ABORTED</literal> result for each remaining queued
     operation in an aborted pipeline. The result for
     <function>PQpipelineSync</function> is reported as
     <literal>PGRES_PIPELINE_SYNC</literal> to signal the end of the aborted pipeline
     and resumption of normal result processing.
    </para>
________________________________________________________-->
    <para>
     从客户端的视角，在<function>PQresultStatus</function>返回<literal>PGRES_FATAL_ERROR</literal>之后，管道被标记为中止。
     <function>PQresultStatus</function>将报告一个<literal>PGRES_PIPELINE_ABORTED</literal>结果，对中止的管道中的每一个剩余的排队操作。
     <function>PQpipelineSync</function>的结果报告为<literal>PGRES_PIPELINE_SYNC</literal>，以表示中止管道的结束并恢复正常的结果处理。
    </para>
<!-- pgdoc-cn_end sig_en=068bb9caa10a93c53dc9f79faee935f0 -->

<!-- pgdoc-cn_start sig_en=941fb0e13e8d75804ea8c958981bf8cb sig_cn_org=None source=14.1 
    <para>
     The client <emphasis>must</emphasis> process results with
     <function>PQgetResult</function> during error recovery.
    </para>
________________________________________________________-->
    <para>
     在错误恢复时，客户端<emphasis>必须</emphasis> 使用 <function>PQgetResult</function>处理结果。
    </para>
<!-- pgdoc-cn_end sig_en=941fb0e13e8d75804ea8c958981bf8cb -->

<!-- pgdoc-cn_start sig_en=9ff00e5e9b556dc702613ccac99527f8 sig_cn_org=None source=14.1 
    <para>
     If the pipeline used an implicit transaction, then operations that have
     already executed are rolled back and operations that were queued to follow
     the failed operation are skipped entirely. The same behavior holds if the
     pipeline starts and commits a single explicit transaction (i.e. the first
     statement is <literal>BEGIN</literal> and the last is
     <literal>COMMIT</literal>) except that the session remains in an aborted
     transaction state at the end of the pipeline. If a pipeline contains
     <emphasis>multiple explicit transactions</emphasis>, all transactions that
     committed prior to the error remain committed, the currently in-progress
     transaction is aborted, and all subsequent operations are skipped completely,
     including subsequent transactions.  If a pipeline synchronization point
     occurs with an explicit transaction block in aborted state, the next pipeline
     will become aborted immediately unless the next command puts the transaction
     in normal mode with <command>ROLLBACK</command>.
    </para>
________________________________________________________-->
    <para>
     如果管道使用隐式事务，那么已经执行的操作将被回滚，而排队跟在失败操作的操作将被完全跳过。
     同样的行为也会发生，如果管道开始并提交单个显式事务(也就是，第一个语句是<literal>BEGIN</literal> ，最后一个是<literal>COMMIT</literal>)，除非会话在管道结束时保持在中止事务状态。
     如果管道包含<emphasis>multiple explicit transactions</emphasis>，所有错误之前提交的事务会继续提交，当前正在进行的事务被中止，所有后续操作被完全跳过，包括后续的事务。
     如果管道同步点发生时显式事务块为中止状态，则下一个管道将立即中止，除非下一个命令使用<command>ROLLBACK</command>将事务置于正常模式。
    </para>
<!-- pgdoc-cn_end sig_en=9ff00e5e9b556dc702613ccac99527f8 -->

    <note>
<!-- pgdoc-cn_start sig_en=ab0636228935bdf4e5d9fc5d17928225 sig_cn_org=None source=14.1 
     <para>
      The client must not assume that work is committed when it
      <emphasis>sends</emphasis> a <literal>COMMIT</literal> &mdash; only when the
      corresponding result is received to confirm the commit is complete.
      Because errors arrive asynchronously, the application needs to be able to
      restart from the last <emphasis>received</emphasis> committed change and
      resend work done after that point if something goes wrong.
     </para>
________________________________________________________-->
     <para>
      客户端绝对不可以假设工作已经被提交，当它<emphasis>sends</emphasis>一个<literal>COMMIT</literal> &mdash;只有相应的结果被接收时，才能确认提交已完成。
      因为错误是异步到达的，如果出现错误，应用需要能够从最后一个<emphasis>received</emphasis>到的提交的更改重新开始，并重新发送在该点之后完成的工作。
     </para>
<!-- pgdoc-cn_end sig_en=ab0636228935bdf4e5d9fc5d17928225 -->
    </note>
   </sect3>

   <sect3 id="libpq-pipeline-interleave">
<!-- pgdoc-cn_start sig_en=99079dc4c5bcafa894b56074bfd3d4e8 sig_cn_org=None source=14.1 
    <title>Interleaving Result Processing and Query Dispatch</title>
________________________________________________________-->
    <title>交叉结果处理和查询分派</title>
<!-- pgdoc-cn_end sig_en=99079dc4c5bcafa894b56074bfd3d4e8 -->

<!-- pgdoc-cn_start sig_en=f7aa2b0e97e718efbe2402926e44e91c sig_cn_org=None source=14.1 
    <para>
     To avoid deadlocks on large pipelines the client should be structured
     around a non-blocking event loop using operating system facilities
     such as <function>select</function>, <function>poll</function>,
     <function>WaitForMultipleObjectEx</function>, etc.
    </para>
________________________________________________________-->
    <para>
     为避免大型管道上的死锁，客户端将被围绕非阻塞事件循环构建，通过使用操作系统工具，如<function>select</function>, <function>poll</function>,     <function>WaitForMultipleObjectEx</function>等等，
    </para>
<!-- pgdoc-cn_end sig_en=f7aa2b0e97e718efbe2402926e44e91c -->

<!-- pgdoc-cn_start sig_en=647dd41d25e14dbb166fccdd95103fd5 sig_cn_org=None source=14.1 
    <para>
     The client application should generally maintain a queue of work
     remaining to be dispatched and a queue of work that has been dispatched
     but not yet had its results processed. When the socket is writable
     it should dispatch more work. When the socket is readable it should
     read results and process them, matching them up to the next entry in
     its corresponding results queue.  Based on available memory, results from the
     socket should be read frequently: there's no need to wait until the
     pipeline end to read the results.  Pipelines should be scoped to logical
     units of work, usually (but not necessarily) one transaction per pipeline.
     There's no need to exit pipeline mode and re-enter it between pipelines,
     or to wait for one pipeline to finish before sending the next.
    </para>
________________________________________________________-->
    <para>
     客户端应用通常应该维护一个尚未分派的工作队列和一个已分派但尚未处理结果的工作队列。
     当套接字是可写时，它将可以分派更多的工作。
     当套接字是可读时，它将读取结果并处理它们，将它们匹配到相应结果队列中的下一个条目。
     基于可用内存，来自套接字的结果将被经常读取:这里不需要等到管道结束才读取结果。
     管道将范围涵盖到工作的逻辑单元，通常(但不是必然)每个管道一个事务。
     在管道之间，不需要退出管道模式再重新进入管道模式，也不需要等待一个管道结束后再发送下一个。
    </para>
<!-- pgdoc-cn_end sig_en=647dd41d25e14dbb166fccdd95103fd5 -->

<!-- pgdoc-cn_start sig_en=98ea9cb3cada935d8403b08f75186f68 sig_cn_org=None source=14.1 
    <para>
     An example using <function>select()</function> and a simple state
     machine to track sent and received work is in
     <filename>src/test/modules/libpq_pipeline/libpq_pipeline.c</filename>
     in the PostgreSQL source distribution.
    </para>
________________________________________________________-->
    <para>
     一个使用<function>select()</function>和一个简单状态机来跟踪发送和接收工作的例子，在PostgreSQL源代码发行版的<filename>src/test/modules/libpq_pipeline/libpq_pipeline.c</filename>文件中。
    </para>
<!-- pgdoc-cn_end sig_en=98ea9cb3cada935d8403b08f75186f68 -->
   </sect3>
  </sect2>

  <sect2 id="libpq-pipeline-functions">
<!-- pgdoc-cn_start sig_en=5ce6ffa6c616658dd03e0044c3634883 sig_cn_org=None source=14.1 
   <title>Functions Associated with Pipeline Mode</title>
________________________________________________________-->
   <title>与管道模式关联的函数</title>
<!-- pgdoc-cn_end sig_en=5ce6ffa6c616658dd03e0044c3634883 -->

   <variablelist>

    <varlistentry id="libpq-PQpipelineStatus">
<!-- pgdoc-cn_start sig_en=ea8f18d7ef5cbd1b5274bd014fe10d51 sig_cn_org=None source=14.1 
     <term><function>PQpipelineStatus</function><indexterm><primary>PQpipelineStatus</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQpipelineStatus</function><indexterm><primary>PQpipelineStatus</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=ea8f18d7ef5cbd1b5274bd014fe10d51 -->

     <listitem>
<!-- pgdoc-cn_start sig_en=1acc762e725ccb73b91ff782afe8b90f sig_cn_org=None source=14.1 
      <para>
      Returns the current pipeline mode status of the
      <application>libpq</application> connection.
<synopsis>
PGpipelineStatus PQpipelineStatus(const PGconn *conn);
</synopsis>
      </para>
________________________________________________________-->
      <para>
      返回<application>libpq</application>连接的当前管道模式状态。
<synopsis>
PGpipelineStatus PQpipelineStatus(const PGconn *conn);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=1acc762e725ccb73b91ff782afe8b90f -->

<!-- pgdoc-cn_start sig_en=3b2b72de140f02f423f86543edc39456 sig_cn_org=None source=14.1 
      <para>
       <function>PQpipelineStatus</function> can return one of the following values:

       <variablelist>
        <varlistentry>
         <term>
          <literal>PQ_PIPELINE_ON</literal>
         </term>
         <listitem>
          <para>
           The <application>libpq</application> connection is in
           pipeline mode.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term>
          <literal>PQ_PIPELINE_OFF</literal>
         </term>
         <listitem>
          <para>
           The <application>libpq</application> connection is
           <emphasis>not</emphasis> in pipeline mode.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term>
          <literal>PQ_PIPELINE_ABORTED</literal>
         </term>
         <listitem>
          <para>
           The <application>libpq</application> connection is in pipeline
           mode and an error occurred while processing the current pipeline.
           The aborted flag is cleared when <function>PQgetResult</function>
           returns a result of type <literal>PGRES_PIPELINE_SYNC</literal>.
          </para>
         </listitem>
        </varlistentry>

       </variablelist>
      </para>
________________________________________________________-->
      <para>
       <function>PQpipelineStatus</function> 可以返回下列值中的一个:

       <variablelist>
        <varlistentry>
         <term>
          <literal>PQ_PIPELINE_ON</literal>
         </term>
         <listitem>
          <para>
           <application>libpq</application> 连接处于管道模式。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term>
          <literal>PQ_PIPELINE_OFF</literal>
         </term>
         <listitem>
          <para>
           <application>libpq</application> 连接 <emphasis>不</emphasis> 是管道模式。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term>
          <literal>PQ_PIPELINE_ABORTED</literal>
         </term>
         <listitem>
          <para>
           <application>libpq</application>连接处于管道模式，并且在处理当前管道时发生了错误。
           当<function>PQgetResult</function>返回<literal>PGRES_PIPELINE_SYNC</literal>类型的结果时，中止标志被清除。
          </para>
         </listitem>
        </varlistentry>

       </variablelist>
      </para>
<!-- pgdoc-cn_end sig_en=3b2b72de140f02f423f86543edc39456 -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQenterPipelineMode">
<!-- pgdoc-cn_start sig_en=e1b7a894a8176e91faa99203e95ee751 sig_cn_org=None source=14.1 
     <term><function>PQenterPipelineMode</function><indexterm><primary>PQenterPipelineMode</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQenterPipelineMode</function><indexterm><primary>PQenterPipelineMode</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=e1b7a894a8176e91faa99203e95ee751 -->

     <listitem>
<!-- pgdoc-cn_start sig_en=fdb59f871b841ca0db701d841cea342e sig_cn_org=None source=14.1 
      <para>
      Causes a connection to enter pipeline mode if it is currently idle or
      already in pipeline mode.

<synopsis>
int PQenterPipelineMode(PGconn *conn);
</synopsis>

      </para>
________________________________________________________-->
      <para>
      造成连接进入管道模式，如果它当前空闲或已经是管道模式。

<synopsis>
int PQenterPipelineMode(PGconn *conn);
</synopsis>

      </para>
<!-- pgdoc-cn_end sig_en=fdb59f871b841ca0db701d841cea342e -->
<!-- pgdoc-cn_start sig_en=7e03a1215fae96b2fe82dda584c2033f sig_cn_org=None source=14.1 
      <para>
       Returns 1 for success.
       Returns 0 and has no effect if the connection is not currently
       idle, i.e., it has a result ready, or it is waiting for more
       input from the server, etc.
       This function does not actually send anything to the server,
       it just changes the <application>libpq</application> connection
       state.
      </para>
________________________________________________________-->
      <para>
       成功返回1.
       如果连接当前不是空闲的，返回0并且无影响，也就是说，它已经有了一个结果，或者它正在等待服务器的更多输入，等等。
       这个函数实际上不向服务器发送任何东西，它只是更改<application>libpq</application>连接状态。
      </para>
<!-- pgdoc-cn_end sig_en=7e03a1215fae96b2fe82dda584c2033f -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQexitPipelineMode">
<!-- pgdoc-cn_start sig_en=022c33b000b15401784668f82c935d3b sig_cn_org=None source=14.1 
     <term><function>PQexitPipelineMode</function><indexterm><primary>PQexitPipelineMode</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQexitPipelineMode</function><indexterm><primary>PQexitPipelineMode</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=022c33b000b15401784668f82c935d3b -->

     <listitem>
<!-- pgdoc-cn_start sig_en=4839cefc73761c4b974fcc0db7c01f76 sig_cn_org=None source=14.1 
      <para>
       Causes a connection to exit pipeline mode if it is currently in pipeline mode
       with an empty queue and no pending results.
<synopsis>
int PQexitPipelineMode(PGconn *conn);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       造成连接退出管道模式，如果连接当前以空队列处于管道模式，并且没有待处理的结果。
<synopsis>
int PQexitPipelineMode(PGconn *conn);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=4839cefc73761c4b974fcc0db7c01f76 -->
<!-- pgdoc-cn_start sig_en=a18ba9d6eb20873b0b42e1245c3e4dfc sig_cn_org=None source=14.1 
      <para>
       Returns 1 for success.  Returns 1 and takes no action if not in
       pipeline mode. If the current statement isn't finished processing,
       or <function>PQgetResult</function> has not been called to collect
       results from all previously sent query, returns 0 (in which case,
       use <xref linkend="libpq-PQerrorMessage"/> to get more information
       about the failure).
      </para>
________________________________________________________-->
      <para>
       成功则返回1。
       如果不是管道模式，则返回1并且不采取操作。
       如果当前语句没有完成处理，或者<function>PQgetResult</function>尚未被调用以收集所有先前发送查询的结果，则返回0(在这种情况下，使用<xref linkend="libpq-PQerrorMessage"/>以获取关于故障的更多信息)。
      </para>
<!-- pgdoc-cn_end sig_en=a18ba9d6eb20873b0b42e1245c3e4dfc -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQpipelineSync">
<!-- pgdoc-cn_start sig_en=653a1f9032e8a53fc64bea3c15336e39 sig_cn_org=None source=14.1 
     <term><function>PQpipelineSync</function><indexterm><primary>PQpipelineSync</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQpipelineSync</function><indexterm><primary>PQpipelineSync</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=653a1f9032e8a53fc64bea3c15336e39 -->

     <listitem>
<!-- pgdoc-cn_start sig_en=32f899d5f6a08b60873947fea17cf333 sig_cn_org=None source=14.1 
      <para>
       Marks a synchronization point in a pipeline by sending a
       <link linkend="protocol-flow-ext-query">sync message</link>
       and flushing the send buffer. This serves as
       the delimiter of an implicit transaction and an error recovery
       point; see <xref linkend="libpq-pipeline-errors"/>.

<synopsis>
int PQpipelineSync(PGconn *conn);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       通过发送<link linkend="protocol-flow-ext-query">sync message</link>并刷新发送缓冲区的方式来标记管道中的同步点。
       它用作隐式事务的定界符和错误恢复点；参见<xref linkend="libpq-pipeline-errors"/>。

<synopsis>
int PQpipelineSync(PGconn *conn);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=32f899d5f6a08b60873947fea17cf333 -->
<!-- pgdoc-cn_start sig_en=0a46937077bf3e9eb6476b05934cf4a8 sig_cn_org=None source=14.1 
      <para>
       Returns 1 for success. Returns 0 if the connection is not in
       pipeline mode or sending a
       <link linkend="protocol-flow-ext-query">sync message</link>
       failed.
      </para>
________________________________________________________-->
      <para>
       成功就返回1。
       如果连接不是管道模式或者发送<link linkend="protocol-flow-ext-query">sync message</link>失败，则返回0。
      </para>
<!-- pgdoc-cn_end sig_en=0a46937077bf3e9eb6476b05934cf4a8 -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQsendFlushRequest">
<!-- pgdoc-cn_start sig_en=16754f48ec27bcadc655a856f9387efc sig_cn_org=None source=14.1 
     <term><function>PQsendFlushRequest</function><indexterm><primary>PQsendFlushRequest</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQsendFlushRequest</function><indexterm><primary>PQsendFlushRequest</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=16754f48ec27bcadc655a856f9387efc -->

      <listitem>
<!-- pgdoc-cn_start sig_en=a340254f6eb9d9607dd23961a69f45fc sig_cn_org=None source=14.1 
       <para>
        Sends a request for the server to flush its output buffer.
<synopsis>
int PQsendFlushRequest(PGconn *conn);
</synopsis>
       </para>
________________________________________________________-->
       <para>
        发送一个请求到服务器以刷新它的输出缓冲区。
<synopsis>
int PQsendFlushRequest(PGconn *conn);
</synopsis>
       </para>
<!-- pgdoc-cn_end sig_en=a340254f6eb9d9607dd23961a69f45fc -->

<!-- pgdoc-cn_start sig_en=0e16b24fd2d934b8a3cdac9432809b72 sig_cn_org=None source=14.1 
       <para>
        Returns 1 for success.  Returns 0 on any failure.
       </para>
________________________________________________________-->
       <para>
        成功就返回1。
        任何失败则返回0。
       </para>
<!-- pgdoc-cn_end sig_en=0e16b24fd2d934b8a3cdac9432809b72 -->
<!-- pgdoc-cn_start sig_en=497a904e83fc971b278de82dcb9ab6f9 sig_cn_org=None source=14.1 
       <para>
        The server flushes its output buffer automatically as a result of
        <function>PQpipelineSync</function> being called, or
        on any request when not in pipeline mode; this function is useful
        to cause the server to flush its output buffer in pipeline mode
        without establishing a synchronization point.
        Note that the request is not itself flushed to the server automatically;
        use <function>PQflush</function> if necessary.
       </para>
________________________________________________________-->
       <para>
        当<function>PQpipelineSync</function>被调用的结果，或者在非管道模式下的任何请求时，服务器自动刷新它的输出缓冲区;这个函数用于使得服务器在不建立同步点的情况下以管道模式刷新其输出缓冲区。
        请注意，请求不是自身能自动刷新到服务器;如果需要时使用<function>PQflush</function>。
       </para>
<!-- pgdoc-cn_end sig_en=497a904e83fc971b278de82dcb9ab6f9 -->
      </listitem>
     </varlistentry>
   </variablelist>
  </sect2>

  <sect2 id="libpq-pipeline-tips">
<!-- pgdoc-cn_start sig_en=b4f9bcbfeb98eee96115b9d316d48afa sig_cn_org=None source=14.1 
   <title>When to Use Pipeline Mode</title>
________________________________________________________-->
   <title>何时使用管道模式</title>
<!-- pgdoc-cn_end sig_en=b4f9bcbfeb98eee96115b9d316d48afa -->

<!-- pgdoc-cn_start sig_en=aa715dca7db45b0b8c98a466169c7c2c sig_cn_org=None source=14.1 
   <para>
    Much like asynchronous query mode, there is no meaningful performance
    overhead when using pipeline mode. It increases client application complexity,
    and extra caution is required to prevent client/server deadlocks, but
    pipeline mode can offer considerable performance improvements, in exchange for
    increased memory usage from leaving state around longer.
   </para>
________________________________________________________-->
   <para>
    非常像异步查询模式，在使用管道模式时没有明显的性能开销。
    它增加了客户端应用的复杂性，并且需要特别注意以防止客户端/服务器死锁。
    但是管道模式可以提供相当大的性能改进，以换取内存使用率的增加，从离开撞到到更久。
   </para>
<!-- pgdoc-cn_end sig_en=aa715dca7db45b0b8c98a466169c7c2c -->

<!-- pgdoc-cn_start sig_en=898055f1715eed5c8e3d9f107e787d77 sig_cn_org=None source=14.1 
   <para>
    Pipeline mode is most useful when the server is distant, i.e., network latency
    (<quote>ping time</quote>) is high, and also when many small operations
    are being performed in rapid succession.  There is usually less benefit
    in using pipelined commands when each query takes many multiples of the client/server
    round-trip time to execute.  A 100-statement operation run on a server
    300 ms round-trip-time away would take 30 seconds in network latency alone
    without pipelining; with pipelining it may spend as little as 0.3 s waiting for
    results from the server.
   </para>
________________________________________________________-->
   <para>
    当服务器比较远，即网络延迟(<quote>ping time</quote>)高的时候，管道模式最有用，以及在许多小操作正在快速连续执行的时候。
    当每个查询的执行时间是客户端/服务器往返时间的许多倍时，使用管道命令的优势通常会更少。
    不用管道模式，在往返时间为300毫秒的服务器上运行一个100条语句的操作，仅网络延迟就需要30秒;使用管道，等待来自服务器的结果可能只消耗仅仅0.3秒。
   </para>
<!-- pgdoc-cn_end sig_en=898055f1715eed5c8e3d9f107e787d77 -->

<!-- pgdoc-cn_start sig_en=2581d087661369e55875f0a1472ef8bd sig_cn_org=None source=14.1 
   <para>
    Use pipelined commands when your application does lots of small
    <literal>INSERT</literal>, <literal>UPDATE</literal> and
    <literal>DELETE</literal> operations that can't easily be transformed
    into operations on sets, or into a <literal>COPY</literal> operation.
   </para>
________________________________________________________-->
   <para>
    当你的应用需要完成很多小的<literal>INSERT</literal>, <literal>UPDATE</literal> 和 <literal>DELETE</literal> 操作，并且不能方便的转换到集合操作或者 <literal>COPY</literal>操作时，用管道命令。
   </para>
<!-- pgdoc-cn_end sig_en=2581d087661369e55875f0a1472ef8bd -->

<!-- pgdoc-cn_start sig_en=1470f8aa8a6dc0b841f8b6336340fab3 sig_cn_org=None source=14.1 
   <para>
    Pipeline mode is not useful when information from one operation is required by
    the client to produce the next operation. In such cases, the client
    would have to introduce a synchronization point and wait for a full client/server
    round-trip to get the results it needs. However, it's often possible to
    adjust the client design to exchange the required information server-side.
    Read-modify-write cycles are especially good candidates; for example:
<programlisting>
BEGIN;
SELECT x FROM mytable WHERE id = 42 FOR UPDATE;
-&minus; result: x=2
-&minus; client adds 1 to x:
UPDATE mytable SET x = 3 WHERE id = 42;
COMMIT;
</programlisting>
    could be much more efficiently done with:
<programlisting>
UPDATE mytable SET x = x + 1 WHERE id = 42;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    当来自一个操作的信息需要客户端产生下一个操作时，管道模式是没有用的。
    在这种情况下，客户机将不得不引入一个同步点，并等待完整的客户端/服务器往返以获取它需要的结果。
    但是，通常可以调整客户端设计以交换服务器端所需的信息。
    读-修改-写循环是非常好的选择;例如:
<programlisting>
BEGIN;
SELECT x FROM mytable WHERE id = 42 FOR UPDATE;
-- result: x=2
-- client adds 1 to x:
UPDATE mytable SET x = 3 WHERE id = 42;
COMMIT;
</programlisting>
    could be much more efficiently done with:
<programlisting>
UPDATE mytable SET x = x + 1 WHERE id = 42;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=1470f8aa8a6dc0b841f8b6336340fab3 -->

<!-- pgdoc-cn_start sig_en=bd206fc6f14014e3e7c60ff8508c2491 sig_cn_org=None source=14.1 
   <para>
    Pipelining is less useful, and more complex, when a single pipeline contains
    multiple transactions (see <xref linkend="libpq-pipeline-errors"/>).
   </para>
________________________________________________________-->
   <para>
    当单个管道包含多个事务时，管道的作用更小，而且更复杂(参见<xref linkend="libpq-pipeline-errors"/>)。
   </para>
<!-- pgdoc-cn_end sig_en=bd206fc6f14014e3e7c60ff8508c2491 -->
  </sect2>
 </sect1>

 <sect1 id="libpq-single-row-mode">
<!-- pgdoc-cn_start sig_en=5d391eaee88911319418335bf3eb1298 sig_cn_org=None source=14.1 
  <title>Retrieving Query Results Row-by-Row</title>
________________________________________________________-->
  <title>一行一行地检索查询结果</title>
<!-- pgdoc-cn_end sig_en=5d391eaee88911319418335bf3eb1298 -->

<!-- pgdoc-cn_start sig_en=b4274e9af6400b78c42290604b664c4b sig_cn_org=None source=14.1 
  <indexterm zone="libpq-single-row-mode">
   <primary>libpq</primary>
   <secondary>single-row mode</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="libpq-single-row-mode">
   <primary>libpq</primary>
   <secondary>single-row mode</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=b4274e9af6400b78c42290604b664c4b -->

<!-- pgdoc-cn_start sig_en=fec7ce694bfec1b8ef30261b7d454ada sig_cn_org=None source=14.1 
  <para>
   Ordinarily, <application>libpq</application> collects an SQL command's
   entire result and returns it to the application as a single
   <structname>PGresult</structname>.  This can be unworkable for commands
   that return a large number of rows.  For such cases, applications can use
   <xref linkend="libpq-PQsendQuery"/> and <xref linkend="libpq-PQgetResult"/> in
   <firstterm>single-row mode</firstterm>.  In this mode, the result row(s) are
   returned to the application one at a time, as they are received from the
   server.
  </para>
________________________________________________________-->
  <para>
   通常，<application>libpq</application>会收集一个 SQL 命令的整个结果并且把它作为单个<structname>PGresult</structname>返回给应用。这对于返回大量行的命令是行不通的。
   对于这类情况，应用可以使用<xref linkend="libpq-PQsendQuery"/>和<xref linkend="libpq-PQgetResult"/>的<firstterm>单行模式</firstterm>。
   在这种模式中，结果行以一次一行的方式被返回给应用。
  </para>
<!-- pgdoc-cn_end sig_en=fec7ce694bfec1b8ef30261b7d454ada -->

<!-- pgdoc-cn_start sig_en=5b1c965603e1c0d713e602c2e1a243cf sig_cn_org=636d19cf237aae8c88c715f591fcd1ce source=15.7 
  <para>
   To enter single-row mode, call <xref linkend="libpq-PQsetSingleRowMode"/>
   immediately after a successful call of <xref linkend="libpq-PQsendQuery"/>
   (or a sibling function).  This mode selection is effective only for the
   currently executing query.  Then call <xref linkend="libpq-PQgetResult"/>
   repeatedly, until it returns null, as documented in <xref
   linkend="libpq-async"/>.  If the query returns any rows, they are returned
   as individual <structname>PGresult</structname> objects, which look like
   normal query results except for having status code
   <literal>PGRES_SINGLE_TUPLE</literal> instead of
   <literal>PGRES_TUPLES_OK</literal>.  After the last row, or immediately if
   the query returns zero rows, a zero-row object with status
   <literal>PGRES_TUPLES_OK</literal> is returned; this is the signal that no
   more rows will arrive.  (But note that it is still necessary to continue
   calling <xref linkend="libpq-PQgetResult"/> until it returns null.)  All of
   these <structname>PGresult</structname> objects will contain the same row
   description data (column names, types, etc.) that an ordinary
   <structname>PGresult</structname> object for the query would have.
   Each object should be freed with <xref linkend="libpq-PQclear"/> as usual.
  </para>
________________________________________________________-->
  <para>
   要进入单行模式，请在成功调用<xref linkend="libpq-PQsendQuery"/>（或其兄弟函数）后立即调用
   <xref linkend="libpq-PQsetSingleRowMode"/>。此模式选择仅对当前执行的查询有效。
   然后重复调用<xref linkend="libpq-PQgetResult"/>，直到它返回null，如<xref
   linkend="libpq-async"/>中所述。如果查询返回任何行，它们将作为单独的<structname>PGresult</structname>对象返回，
   它们看起来像普通的查询结果，只是具有状态码<literal>PGRES_SINGLE_TUPLE</literal>而不是
   <literal>PGRES_TUPLES_OK</literal>。在最后一行之后，或者如果查询返回零行，则返回一个带有状态
   <literal>PGRES_TUPLES_OK</literal>的零行对象；这是没有更多行将到达的信号。
   （但请注意，仍然需要继续调用<xref linkend="libpq-PQgetResult"/>直到它返回null。）
   所有这些<structname>PGresult</structname>对象将包含与普通查询的<structname>PGresult</structname>对象相同的行描述数据
   （列名、类型等）。每个对象应像往常一样使用<xref linkend="libpq-PQclear"/>释放。
</para>
<!-- pgdoc-cn_end sig_en=5b1c965603e1c0d713e602c2e1a243cf -->

<!-- pgdoc-cn_start sig_en=a357cb83097da0b2cc76992b02c53389 sig_cn_org=None source=14.1 
  <para>
   When using pipeline mode, single-row mode needs to be activated for each
   query in the pipeline before retrieving results for that query
   with <function>PQgetResult</function>.
   See <xref linkend="libpq-pipeline-mode"/> for more information.
  </para>
________________________________________________________-->
  <para>
   当使用管道模式时，在使用<function>PQgetResult</function>检索该查询的结果之前，管道中的每个查询需要被激活单行模式。
   参见<xref linkend="libpq-pipeline-mode"/> 了解更多信息。
  </para>
<!-- pgdoc-cn_end sig_en=a357cb83097da0b2cc76992b02c53389 -->

<!-- pgdoc-cn_start sig_en=49d773121efcdfb4851b6db50b1bc056 sig_cn_org=None source=14.1 
  <para>
   <variablelist>
    <varlistentry id="libpq-PQsetSingleRowMode">
     <term><function>PQsetSingleRowMode</function><indexterm><primary>PQsetSingleRowMode</primary></indexterm></term>

     <listitem>
      <para>
       Select single-row mode for the currently-executing query.

<synopsis>
int PQsetSingleRowMode(PGconn *conn);
</synopsis>
      </para>

      <para>
       This function can only be called immediately after
       <xref linkend="libpq-PQsendQuery"/> or one of its sibling functions,
       before any other operation on the connection such as
       <xref linkend="libpq-PQconsumeInput"/> or
       <xref linkend="libpq-PQgetResult"/>.  If called at the correct time,
       the function activates single-row mode for the current query and
       returns 1.  Otherwise the mode stays unchanged and the function
       returns 0.  In any case, the mode reverts to normal after
       completion of the current query.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
________________________________________________________-->
  <para>
   <variablelist>
    <varlistentry id="libpq-PQsetSingleRowMode">
     <term><function>PQsetSingleRowMode</function><indexterm><primary>PQsetSingleRowMode</primary></indexterm></term>

     <listitem>
      <para>
       为当前正在执行的查询选择单行模式。

<synopsis>
int PQsetSingleRowMode(PGconn *conn);
</synopsis>
      </para>

      <para>
       这个函数只能在调用<xref linkend="libpq-PQsendQuery"/>或一个其兄弟函数之后立刻调用，并且要在任何连接上的其他操作之前调用，例如<xref linkend="libpq-PQconsumeInput"/>或<xref linkend="libpq-PQgetResult"/>。
       如果在正确的时间被调用，该函数会为当前查询激活单行模式并且返回 1。否则模式会保持不变并且该函数返回 0。
       在任何情况下，当前查询结束之后模式都会恢复到正常。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
<!-- pgdoc-cn_end sig_en=49d773121efcdfb4851b6db50b1bc056 -->

  <caution>
<!-- pgdoc-cn_start sig_en=c3d94500be9e5ca654a10e70714ba2f0 sig_cn_org=None source=14.1 
   <para>
    While processing a query, the server may return some rows and then
    encounter an error, causing the query to be aborted.  Ordinarily,
    <application>libpq</application> discards any such rows and reports only the
    error.  But in single-row mode, those rows will have already been
    returned to the application.  Hence, the application will see some
    <literal>PGRES_SINGLE_TUPLE</literal> <structname>PGresult</structname>
    objects followed by a <literal>PGRES_FATAL_ERROR</literal> object.  For
    proper transactional behavior, the application must be designed to
    discard or undo whatever has been done with the previously-processed
    rows, if the query ultimately fails.
   </para>
________________________________________________________-->
   <para>
    在处理一个查询时，服务器可能返回一些行并且接着遇到一个错误导致查询被中断。通常，<application>libpq</application>会丢弃掉这样的行并且至报告错误。但是在单行模式中，那些行（错误之前返回的行）已经被返回给应用。因此，应用将看到一些<literal>PGRES_SINGLE_TUPLE</literal> <structname>PGresult</structname>对象并且然后看到一个<literal>PGRES_FATAL_ERROR</literal>对象。为了得到正确的事务行为，如果查询最终失败，应用必须被设计为丢弃或者撤销使用之前处理的行完成的事情。
   </para>
<!-- pgdoc-cn_end sig_en=c3d94500be9e5ca654a10e70714ba2f0 -->
  </caution>

 </sect1>

 <sect1 id="libpq-cancel">
<!-- pgdoc-cn_start sig_en=dc26c89b4664a6f983199049e83bb527 sig_cn_org=None source=14.1 
  <title>Canceling Queries in Progress</title>
________________________________________________________-->
  <title>取消进行中的查询</title>
<!-- pgdoc-cn_end sig_en=dc26c89b4664a6f983199049e83bb527 -->

<!-- pgdoc-cn_start sig_en=6d5ccf3be8aa554eb3d360efa197ed62 sig_cn_org=None source=14.1 
  <indexterm zone="libpq-cancel">
   <primary>canceling</primary>
   <secondary>SQL command</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="libpq-cancel">
   <primary>canceling</primary>
   <secondary>SQL command</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=6d5ccf3be8aa554eb3d360efa197ed62 -->

<!-- pgdoc-cn_start sig_en=5f42a60a7829530613882aa713648acb sig_cn_org=d210b0e9cf51f75035f6493d4fad3507 source=15.7 
  <para>
   A client application can request cancellation of a command that is
   still being processed by the server, using the functions described in
   this section.

   <variablelist>
    <varlistentry id="libpq-PQgetCancel">
________________________________________________________-->
  <para>
   客户端应用程序可以使用本节中描述的函数请求取消服务器仍在处理的命令。

   <variablelist>
    <varlistentry id="libpq-PQgetCancel">
<!-- pgdoc-cn_end sig_en=5f42a60a7829530613882aa713648acb -->
<!-- pgdoc-cn_start sig_en=e953064ea617f4c7c87b45260a3953f3 sig_cn_org=e953064ea617f4c7c87b45260a3953f3 source=15.7 
     <term><function>PQgetCancel</function><indexterm><primary>PQgetCancel</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQgetCancel</function><indexterm><primary>PQgetCancel</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=e953064ea617f4c7c87b45260a3953f3 -->

     <listitem>
<!-- pgdoc-cn_start sig_en=6379038a24365088534cfc65d28ab966 sig_cn_org=b75ab54581096966b3c2627a744fe079 source=15.7 
      <para>
       Creates a data structure containing the information needed to cancel
       a command issued through a particular database connection.
<synopsis>
PGcancel *PQgetCancel(PGconn *conn);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       创建一个包含取消通过特定数据库连接发出的命令所需信息的数据结构。
<synopsis>
PGcancel *PQgetCancel(PGconn *conn);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=6379038a24365088534cfc65d28ab966 -->

<!-- pgdoc-cn_start sig_en=bd81e780b1750e59ec5b03013ac77334 sig_cn_org=8e5a33307e18f17250281b4882b2fe0a source=15.7 
      <para>
       <xref linkend="libpq-PQgetCancel"/> creates a
       <structname>PGcancel</structname><indexterm><primary>PGcancel</primary></indexterm> object
       given a <structname>PGconn</structname> connection object.  It will return
       <symbol>NULL</symbol> if the given <parameter>conn</parameter> is <symbol>NULL</symbol> or an invalid
       connection.  The <structname>PGcancel</structname> object is an opaque
       structure that is not meant to be accessed directly by the
       application; it can only be passed to <xref linkend="libpq-PQcancel"/>
       or <xref linkend="libpq-PQfreeCancel"/>.
      </para>
________________________________________________________-->
      <para>
       <xref linkend="libpq-PQgetCancel"/>创建一个<structname>PGcancel</structname>
       <indexterm><primary>PGcancel</primary></indexterm>对象，给定一个<structname>PGconn</structname>连接对象。
       如果给定的<parameter>conn</parameter>是<symbol>NULL</symbol>或无效连接，则返回<symbol>NULL</symbol>。
       <structname>PGcancel</structname>对象是一个不透明结构，不应直接被应用程序访问；它只能传递给<xref linkend="libpq-PQcancel"/>
       或<xref linkend="libpq-PQfreeCancel"/>。
      </para>
<!-- pgdoc-cn_end sig_en=bd81e780b1750e59ec5b03013ac77334 -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQfreeCancel">
<!-- pgdoc-cn_start sig_en=27ca1f24717ea9ce98ce8658316898de sig_cn_org=27ca1f24717ea9ce98ce8658316898de source=15.7 
     <term><function>PQfreeCancel</function><indexterm><primary>PQfreeCancel</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQfreeCancel</function><indexterm><primary>PQfreeCancel</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=27ca1f24717ea9ce98ce8658316898de -->

     <listitem>
<!-- pgdoc-cn_start sig_en=be756d5be3a9e5634b4d6ab1501011ab sig_cn_org=ed5bcffbb977493b8efbd6ccda02fe6e source=15.7 
      <para>
       Frees a data structure created by <xref linkend="libpq-PQgetCancel"/>.
<synopsis>
void PQfreeCancel(PGcancel *cancel);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       释放由<xref linkend="libpq-PQgetCancel"/>创建的数据结构。
<synopsis>
void PQfreeCancel(PGcancel *cancel);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=be756d5be3a9e5634b4d6ab1501011ab -->

<!-- pgdoc-cn_start sig_en=70d4237406d5e117ab8b651be710c992 sig_cn_org=00a15907c992aaae5058bcb659822e3f source=15.7 
      <para>
       <xref linkend="libpq-PQfreeCancel"/> frees a data object previously created
       by <xref linkend="libpq-PQgetCancel"/>.
      </para>
________________________________________________________-->
      <para>
       <xref linkend="libpq-PQfreeCancel"/>释放先前由<xref linkend="libpq-PQgetCancel"/>创建的数据对象。
      </para>
<!-- pgdoc-cn_end sig_en=70d4237406d5e117ab8b651be710c992 -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQcancel">
<!-- pgdoc-cn_start sig_en=f31ec8baec3e1c5c67f3b1117592fcdb sig_cn_org=f31ec8baec3e1c5c67f3b1117592fcdb source=15.7 
     <term><function>PQcancel</function><indexterm><primary>PQcancel</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQcancel</function><indexterm><primary>PQcancel</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=f31ec8baec3e1c5c67f3b1117592fcdb -->

     <listitem>
<!-- pgdoc-cn_start sig_en=675127d95e13b8c69840f17ccc60e793 sig_cn_org=3153010a9bff4edd55887e3b38479a71 source=15.7 
      <para>
       Requests that the server abandon processing of the current command.
<synopsis>
int PQcancel(PGcancel *cancel, char *errbuf, int errbufsize);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       请求服务器放弃当前命令的处理。
<synopsis>
int PQcancel(PGcancel *cancel, char *errbuf, int errbufsize);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=675127d95e13b8c69840f17ccc60e793 -->

<!-- pgdoc-cn_start sig_en=51201291ebd4f920cb2cf2b51a6a1adf sig_cn_org=f6c84204c4819712b939daef61fea4cc source=15.7 
      <para>
       The return value is 1 if the cancel request was successfully
       dispatched and 0 if not.  If not, <parameter>errbuf</parameter> is filled
       with an explanatory error message.  <parameter>errbuf</parameter>
       must be a char array of size <parameter>errbufsize</parameter> (the
       recommended size is 256 bytes).
      </para>
________________________________________________________-->
      <para>
       返回值为1表示取消请求成功发送，为0表示未成功发送。如果未成功发送，<parameter>errbuf</parameter>将填充一个解释性错误消息。
	   <parameter>errbuf</parameter>必须是大小为<parameter>errbufsize</parameter>的char数组（建议大小为256字节）。
      </para>
<!-- pgdoc-cn_end sig_en=51201291ebd4f920cb2cf2b51a6a1adf -->

<!-- pgdoc-cn_start sig_en=e95068ab0cffa7714080012aa45c95a7 sig_cn_org=65fcab49e0a66221a4b916c221d82301 source=15.7 
      <para>
       Successful dispatch is no guarantee that the request will have
       any effect, however.  If the cancellation is effective, the current
       command will terminate early and return an error result.  If the
       cancellation fails (say, because the server was already done
       processing the command), then there will be no visible result at
       all.
      </para>
________________________________________________________-->
      <para>
       成功的调度并不保证请求会产生任何效果。然而，如果取消操作成功，当前命令将提前终止并返回错误结果。
	   如果取消操作失败（比如，因为服务器已经完成了命令的处理），那么将不会有任何可见的结果。
      </para>
<!-- pgdoc-cn_end sig_en=e95068ab0cffa7714080012aa45c95a7 -->

<!-- pgdoc-cn_start sig_en=9934d835ce3044e04c2c09560a06fe83 sig_cn_org=d11a13a6ccb20d12657a04717a452e9c source=15.7 
      <para>
       <xref linkend="libpq-PQcancel"/> can safely be invoked from a signal
       handler, if the <parameter>errbuf</parameter> is a local variable in the
       signal handler.  The <structname>PGcancel</structname> object is read-only
       as far as <xref linkend="libpq-PQcancel"/> is concerned, so it can
       also be invoked from a thread that is separate from the one
       manipulating the <structname>PGconn</structname> object.
      </para>
________________________________________________________-->
      <para>
       <xref linkend="libpq-PQcancel"/>可以安全地从信号处理程序中调用，如果<parameter>errbuf</parameter>是信号处理程序中的局部变量。
       就<xref linkend="libpq-PQcancel"/>而言，<structname>PGcancel</structname>对象是只读的，因此它也可以从与操作<structname>PGconn</structname>对象的线程分离的线程中调用。
      </para>
<!-- pgdoc-cn_end sig_en=9934d835ce3044e04c2c09560a06fe83 -->
     </listitem>
    </varlistentry>
   </variablelist>

   <variablelist>
    <varlistentry id="libpq-PQrequestCancel">
<!-- pgdoc-cn_start sig_en=df0b38d3ece6aebd429397a23fe20cb7 sig_cn_org=df0b38d3ece6aebd429397a23fe20cb7 source=15.7 
     <term><function>PQrequestCancel</function><indexterm><primary>PQrequestCancel</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQrequestCancel</function><indexterm><primary>PQrequestCancel</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=df0b38d3ece6aebd429397a23fe20cb7 -->

     <listitem>
<!-- pgdoc-cn_start sig_en=c6719a6640411c76bdd1825b2b00e9e8 sig_cn_org=b4cf324d4f3d13a1b4166994634ebe1f source=15.7 
      <para>
       <xref linkend="libpq-PQrequestCancel"/> is a deprecated variant of
       <xref linkend="libpq-PQcancel"/>.
<synopsis>
int PQrequestCancel(PGconn *conn);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       <xref linkend="libpq-PQrequestCancel"/> 是 <xref linkend="libpq-PQcancel"/> 的一个已弃用的变体。
<synopsis>
int PQrequestCancel(PGconn *conn);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=c6719a6640411c76bdd1825b2b00e9e8 -->

<!-- pgdoc-cn_start sig_en=6247209fd4db2737499fa136d8e84a41 sig_cn_org=a0bb0849803520c78e8378e2e1ecbdb7 source=15.7 
      <para>
       Requests that the server abandon processing of the current
       command.  It operates directly on the
       <structname>PGconn</structname> object, and in case of failure stores the
       error message in the <structname>PGconn</structname> object (whence it can
       be retrieved by <xref linkend="libpq-PQerrorMessage"/>).  Although
       the functionality is the same, this approach is not safe within
       multiple-thread programs or signal handlers, since it is possible
       that overwriting the <structname>PGconn</structname>'s error message will
       mess up the operation currently in progress on the connection.
      </para>
________________________________________________________-->
      <para>
       请求服务器放弃当前命令的处理。它直接作用于<structname>PGconn</structname>对象，
       失败时将错误消息存储在<structname>PGconn</structname>对象中（可以通过<xref linkend="libpq-PQerrorMessage"/>检索）。
       尽管功能相同，但这种方法在多线程程序或信号处理程序中不安全，因为可能会覆盖<structname>PGconn</structname>的错误消息，
       从而破坏当前连接上正在进行的操作。
      </para>
<!-- pgdoc-cn_end sig_en=6247209fd4db2737499fa136d8e84a41 -->
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

 </sect1>

 <sect1 id="libpq-fastpath">
<!-- pgdoc-cn_start sig_en=7a2ecc39cccd43c9dbedbbd081536621 sig_cn_org=None source=14.1 
  <title>The Fast-Path Interface</title>
________________________________________________________-->
  <title>快速路径接口</title>
<!-- pgdoc-cn_end sig_en=7a2ecc39cccd43c9dbedbbd081536621 -->

<!-- pgdoc-cn_start sig_en=6cb6e21e302081575ad32c2b851d8b38 sig_cn_org=None source=14.1 
  <indexterm zone="libpq-fastpath">
   <primary>fast path</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="libpq-fastpath">
   <primary>fast path</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=6cb6e21e302081575ad32c2b851d8b38 -->

<!-- pgdoc-cn_start sig_en=02ef3dc2d33f476f35f1620989ac3bfc sig_cn_org=None source=14.1 
  <para>
   <productname>PostgreSQL</productname> provides a fast-path interface
   to send simple function calls to the server.
  </para>
________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>提供一种快速路径接口来向服务器发送简单的函数调用。
  </para>
<!-- pgdoc-cn_end sig_en=02ef3dc2d33f476f35f1620989ac3bfc -->

  <tip>
<!-- pgdoc-cn_start sig_en=173c5be2595a549ccb06371f6e6c4ed5 sig_cn_org=None source=14.1 
   <para>
    This interface is somewhat obsolete, as one can achieve similar
    performance and greater functionality by setting up a prepared
    statement to define the function call.  Then, executing the statement
    with binary transmission of parameters and results substitutes for a
    fast-path function call.
   </para>
________________________________________________________-->
   <para>
    这个接口在某种程度上已被废弃，因为我们可以通过创建一个定义该函数调用的预备语句来达到类似或者更强大的功能。然后，用参数和结果的二进制传输执行该语句，从而取代快速函数调用。 
   </para>
<!-- pgdoc-cn_end sig_en=173c5be2595a549ccb06371f6e6c4ed5 -->
  </tip>

<!-- pgdoc-cn_start sig_en=5253f63c2385cf4a2362ce7338dfbd42 sig_cn_org=None source=14.1 
  <para>
   The function <function id="libpq-PQfn">PQfn</function><indexterm><primary>PQfn</primary></indexterm>
   requests execution of a server function via the fast-path interface:
<synopsis>
PGresult *PQfn(PGconn *conn,
               int fnid,
               int *result_buf,
               int *result_len,
               int result_is_int,
               const PQArgBlock *args,
               int nargs);

typedef struct
{
    int len;
    int isint;
    union
    {
        int *ptr;
        int integer;
    } u;
} PQArgBlock;
</synopsis>
  </para>
________________________________________________________-->
  <para>
   函数<function id="libpq-PQfn">PQfn</function><indexterm><primary>PQfn</primary></indexterm>请求通过快速路径接口执行服务器函数。
<synopsis>
PGresult *PQfn(PGconn *conn,
               int fnid,
               int *result_buf,
               int *result_len,
               int result_is_int,
               const PQArgBlock *args,
               int nargs);

typedef struct
{
    int len;
    int isint;
    union
    {
        int *ptr;
        int integer;
    } u;
} PQArgBlock;
</synopsis>
  </para>
<!-- pgdoc-cn_end sig_en=5253f63c2385cf4a2362ce7338dfbd42 -->

<!-- pgdoc-cn_start sig_en=583327ca806901f41985366f5e271712 sig_cn_org=None source=14.1 
  <para>
   The <parameter>fnid</parameter> argument is the OID of the function to be
   executed.  <parameter>args</parameter> and <parameter>nargs</parameter> define the
   parameters to be passed to the function; they must match the declared
   function argument list.  When the <parameter>isint</parameter> field of a
   parameter structure is true, the <parameter>u.integer</parameter> value is sent
   to the server as an integer of the indicated length (this must be
   2 or 4 bytes); proper byte-swapping occurs.  When <parameter>isint</parameter>
   is false, the indicated number of bytes at <parameter>*u.ptr</parameter> are
   sent with no processing; the data must be in the format expected by
   the server for binary transmission of the function's argument data
   type.  (The declaration of <parameter>u.ptr</parameter> as being of
   type <type>int *</type> is historical; it would be better to consider
   it <type>void *</type>.)
   <parameter>result_buf</parameter> points to the buffer in which to place
   the function's return value.  The caller must have allocated sufficient
   space to store the return value.  (There is no check!) The actual result
   length in bytes will be returned in the integer pointed to by
   <parameter>result_len</parameter>.  If a 2- or 4-byte integer result
   is expected, set <parameter>result_is_int</parameter> to 1, otherwise
   set it to 0.  Setting <parameter>result_is_int</parameter> to 1 causes
   <application>libpq</application> to byte-swap the value if necessary, so that it
   is delivered as a proper <type>int</type> value for the client machine;
   note that a 4-byte integer is delivered into <parameter>*result_buf</parameter>
   for either allowed result size.
   When <parameter>result_is_int</parameter> is 0, the binary-format byte string
   sent by the server is returned unmodified. (In this case it's better
   to consider <parameter>result_buf</parameter> as being of
   type <type>void *</type>.)
  </para>
________________________________________________________-->
  <para>
   <parameter>fnid</parameter>参数是要被执行的函数的 OID。<parameter>args</parameter>和<parameter>nargs</parameter>定义了要传递给函数的参数；它们必须匹配已声明的函数参数列表。当一个参数结构的<parameter>isint</parameter>域为真时，<parameter>u.integer</parameter>值被以指定长度（必须是 1、2 或者 4 字节）整数的形式发送给服务器；这时候会发生恰当的字节交换。当<parameter>isint</parameter>为假时，<parameter>*u.ptr</parameter>中指定数量的字节将不做任何处理被发送出去；这些数据必须是服务器 预期的用于该函数参数数据类型的二进制传输的格式（由于历史原因<parameter>u.ptr</parameter>被声明为类型<type>int *</type>，其实把它考虑成<type>void *</type>会更好）。<parameter>result_buf</parameter>是放置该函数返回值的缓冲区。调用者必须已经分配了足够的空间来存储返回值（这里没有检查！）。实际的结果长度将被放在<parameter>result_len</parameter>指向的整数中返回。如果预期结果是 2 或 4 字节整数，把<parameter>result_is_int</parameter>设为 1；否则设为 0。把<parameter>result_is_int</parameter>设为 1 导致<application>libpq</application>在必要时对值进行交换字节，这样它就作为对客户端机器正确的<type>int</type>值被传输，注意对任一种允许的结果大小都会传递一个 4 字节到<parameter>*result_buf</parameter>。当<parameter>result_is_int</parameter>是 0 时，服务器发送的二进制格式字节将不做修改直接返回（在这种情况下，把<parameter>result_buf</parameter>考虑为类型<type>void *</type>更好）。
  </para>
<!-- pgdoc-cn_end sig_en=583327ca806901f41985366f5e271712 -->

<!-- pgdoc-cn_start sig_en=6bc4a2ad6f2d3d9a16c03378247bfbcb sig_cn_org=None source=14.1 
  <para>
   <function>PQfn</function> always returns a valid
   <structname>PGresult</structname> pointer, with
   status <literal>PGRES_COMMAND_OK</literal> for success
   or <literal>PGRES_FATAL_ERROR</literal> if some problem was encountered.
   The result status should be
   checked before the result is used.   The caller is responsible for
   freeing  the  <structname>PGresult</structname>  with
   <xref linkend="libpq-PQclear"/> when it is no longer needed.
  </para>
________________________________________________________-->
  <para>
   <function>PQfn</function>总是返回一个有效的<structname>PGresult</structname>指针，包括状态<literal>PGRES_COMMAND_OK</literal> 表示成功或者<literal>PGRES_FATAL_ERROR</literal>在出现什么问题时。
   在使用结果之前应该检查结果状态。
   当结果不再使用后，调用者有义务使用<xref linkend="libpq-PQclear"/>释放<structname>PGresult</structname>。
  </para>
<!-- pgdoc-cn_end sig_en=6bc4a2ad6f2d3d9a16c03378247bfbcb -->

<!-- pgdoc-cn_start sig_en=6ffc41d516ec4dbe4392fff121173c2e sig_cn_org=None source=14.1 
  <para>
   To pass a NULL argument to the function, set
   the <parameter>len</parameter> field of that parameter structure
   to <literal>-1</literal>; the <parameter>isint</parameter>
   and <parameter>u</parameter> fields are then irrelevant.
  </para>
________________________________________________________-->
  <para>
   要传递NULL参数到函数，将参数结构的<parameter>len</parameter>字段设置为<literal>-1</literal>;<parameter>isint</parameter> 和 <parameter>u</parameter> 字段就不相关了。
  </para>
<!-- pgdoc-cn_end sig_en=6ffc41d516ec4dbe4392fff121173c2e -->

<!-- pgdoc-cn_start sig_en=376d727b6b7cc337c1e71d1034a307b3 sig_cn_org=None source=14.1 
  <para>
   If the function returns NULL, <parameter>*result_len</parameter> is set
   to <literal>-1</literal>, and <parameter>*result_buf</parameter> is not
   modified.
  </para>
________________________________________________________-->
  <para>
   如果函数返回 NULL, <parameter>*result_len</parameter> 被设置为 <literal>-1</literal>, 并且 <parameter>*result_buf</parameter> 不调整。
  </para>
<!-- pgdoc-cn_end sig_en=376d727b6b7cc337c1e71d1034a307b3 -->

<!-- pgdoc-cn_start sig_en=76d4fdb3ef8ebb4bc38962e070ebfd44 sig_cn_org=None source=14.1 
  <para>
   Note that it is not possible to handle set-valued results when using
   this interface.  Also, the function must be a plain function, not an
   aggregate, window function, or procedure.
  </para>
________________________________________________________-->
  <para>
   注意在使用此接口时，不能够处理集-值结果。
   此外，函数必须是一个普通函数，而不是聚合、窗口函数或过程。
  </para>
<!-- pgdoc-cn_end sig_en=76d4fdb3ef8ebb4bc38962e070ebfd44 -->

 </sect1>

 <sect1 id="libpq-notify">
<!-- pgdoc-cn_start sig_en=b1742a5ef4ba981c38332b2507e1ba93 sig_cn_org=None source=14.1 
  <title>Asynchronous Notification</title>
________________________________________________________-->
  <title>异步提示</title>
<!-- pgdoc-cn_end sig_en=b1742a5ef4ba981c38332b2507e1ba93 -->

<!-- pgdoc-cn_start sig_en=540dd7401cc317bd03223cf9f3786026 sig_cn_org=None source=14.1 
  <indexterm zone="libpq-notify">
   <primary>NOTIFY</primary>
   <secondary>in libpq</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="libpq-notify">
   <primary>NOTIFY</primary>
   <secondary>in libpq</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=540dd7401cc317bd03223cf9f3786026 -->

<!-- pgdoc-cn_start sig_en=8c1a7d7db5b970279b1425333a8b4dfa sig_cn_org=None source=14.1 
  <para>
   <productname>PostgreSQL</productname> offers asynchronous notification
   via the <command>LISTEN</command> and <command>NOTIFY</command>
   commands.  A client session registers its interest in a particular
   notification channel with the <command>LISTEN</command> command (and
   can stop listening with the <command>UNLISTEN</command> command).  All
   sessions listening on a particular channel will be notified
   asynchronously when a <command>NOTIFY</command> command with that
   channel name is executed by any session. A <quote>payload</quote> string can
   be passed to communicate additional data to the listeners.
  </para>
________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>通过<command>LISTEN</command>和<command>NOTIFY</command>命令提供了异步通知。一个客户端会话用<command>LISTEN</command>命令在一个特定的通知频道中注册它感兴趣的通知（也可以用<command>UNLISTEN</command>命令停止监听）。当任何会话执行一个带有特定频道名的<command>NOTIFY</command>命令时，所有正在监听该频道的会话会被异步通知。可以传递一个<quote>载荷</quote>字符串来与监听者沟通附加的数据。
  </para>
<!-- pgdoc-cn_end sig_en=8c1a7d7db5b970279b1425333a8b4dfa -->

<!-- pgdoc-cn_start sig_en=fac03b7710c38d150c5da507134c21fe sig_cn_org=None source=14.1 
  <para>
   <application>libpq</application> applications submit
   <command>LISTEN</command>, <command>UNLISTEN</command>,
   and <command>NOTIFY</command> commands as
   ordinary SQL commands.  The arrival of <command>NOTIFY</command>
   messages can subsequently be detected by calling
   <function id="libpq-PQnotifies">PQnotifies</function>.<indexterm><primary>PQnotifies</primary></indexterm>
  </para>
________________________________________________________-->
  <para>
   <application>libpq</application>应用把<command>LISTEN</command>、<command>UNLISTEN</command>和<command>NOTIFY</command>命令作为通常的 SQL 命令提交。
   随后通过调用<function id="libpq-PQnotifies">PQnotifies</function>.<indexterm><primary>PQnotifies</primary></indexterm>来检测<command>NOTIFY</command>消息的到达。
  </para>
<!-- pgdoc-cn_end sig_en=fac03b7710c38d150c5da507134c21fe -->

<!-- pgdoc-cn_start sig_en=30d7f464a4417054196258a261efa25f sig_cn_org=None source=14.1 
  <para>
   The function <function>PQnotifies</function> returns the next notification
   from a list of unhandled notification messages received from the server.
   It returns a null pointer if there are no pending notifications.  Once a
   notification is returned from <function>PQnotifies</function>, it is considered
   handled and will be removed from the list of notifications.

<synopsis>
PGnotify *PQnotifies(PGconn *conn);

typedef struct pgNotify
{
    char *relname;              /* notification channel name */
    int  be_pid;                /* process ID of notifying server process */
    char *extra;                /* notification payload string */
} PGnotify;
</synopsis>

   After processing a <structname>PGnotify</structname> object returned
   by <function>PQnotifies</function>, be sure to free it with
   <xref linkend="libpq-PQfreemem"/>.  It is sufficient to free the
   <structname>PGnotify</structname> pointer; the
   <structfield>relname</structfield> and <structfield>extra</structfield>
   fields do not represent separate allocations.  (The names of these fields
   are historical; in particular, channel names need not have anything to
   do with relation names.)
  </para>
________________________________________________________-->
  <para>
   函数<function>PQnotifies</function>从来自服务器的未处理通知消息列表中返回下一个通知。如果没有待处理的信息则返回一个空指针。一旦<function>PQnotifies</function>返回一个通知，该通知会被认为已处理并且将被从通知列表中删除。

<synopsis>
PGnotify *PQnotifies(PGconn *conn);

typedef struct pgNotify
{
    char *relname;              /* notification channel name */
    int  be_pid;                /* process ID of notifying server process */
    char *extra;                /* notification payload string */
} PGnotify;
</synopsis>

   在处理完<function>PQnotifies</function>返回的<structname>PGnotify</structname>对象后，别忘了用<xref linkend="libpq-PQfreemem"/>把它释放。
   释放<structname>PGnotify</structname>指针就足够了；<structfield>relname</structfield>和<structfield>extra</structfield>域并不代表独立分配的内存（这些域的名称是历史性的，尤其是频道名称与关系名称没有什么联系）。
  </para>
<!-- pgdoc-cn_end sig_en=30d7f464a4417054196258a261efa25f -->

<!-- pgdoc-cn_start sig_en=2c8076b68f46f110fe06266054710938 sig_cn_org=None source=14.1 
  <para>
   <xref linkend="libpq-example-2"/> gives a sample program that illustrates
   the use of asynchronous notification.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="libpq-example-2"/>给出了一个例子程序展示异步通知的使用。
  </para>
<!-- pgdoc-cn_end sig_en=2c8076b68f46f110fe06266054710938 -->

<!-- pgdoc-cn_start sig_en=967769a02c9027422de29e247caf4763 sig_cn_org=None source=14.1 
  <para>
   <function>PQnotifies</function> does not actually read data from the
   server; it just returns messages previously absorbed by another
   <application>libpq</application> function.  In ancient releases of
   <application>libpq</application>, the only way to ensure timely receipt
   of <command>NOTIFY</command> messages was to constantly submit commands, even
   empty ones, and then check <function>PQnotifies</function> after each
   <xref linkend="libpq-PQexec"/>.  While this still works, it is deprecated
   as a waste of processing power.
  </para>
________________________________________________________-->
  <para>
   <function>PQnotifies</function>实际上并不从服务器读取数据；它只是返回被另一个<application>libpq</application>函数之前吸收的消息。
   在以前的<application>libpq</application>版本中，及时收到<command>NOTIFY</command>消息的唯一方法是持续地提交命令，即使是空命令也可以，并且在每次<xref linkend="libpq-PQexec"/>后检查<function>PQnotifies</function>。 
   虽然这个方法还能用，但是由于太过浪费处理能力已被废弃。
  </para>
<!-- pgdoc-cn_end sig_en=967769a02c9027422de29e247caf4763 -->

<!-- pgdoc-cn_start sig_en=6dfa8af3a3134d3e78c017831c042a01 sig_cn_org=None source=14.1 
  <para>
   A better way to check for <command>NOTIFY</command> messages when you have no
   useful commands to execute is to call
   <xref linkend="libpq-PQconsumeInput"/>, then check
   <function>PQnotifies</function>.  You can use
   <function>select()</function> to wait for data to arrive from the
   server, thereby using no <acronym>CPU</acronym> power unless there is
   something to do.  (See <xref linkend="libpq-PQsocket"/> to obtain the file
   descriptor number to use with <function>select()</function>.) Note that
   this will work OK whether you submit commands with
   <xref linkend="libpq-PQsendQuery"/>/<xref linkend="libpq-PQgetResult"/> or
   simply use <xref linkend="libpq-PQexec"/>.  You should, however, remember
   to check <function>PQnotifies</function> after each
   <xref linkend="libpq-PQgetResult"/> or <xref linkend="libpq-PQexec"/>, to
   see if any notifications came in during the processing of the command.
  </para>
________________________________________________________-->
  <para>
   当你没有可用的命令提交时，一种更好的检查<command>NOTIFY</command>消息的方法是调用<xref linkend="libpq-PQconsumeInput"/>，然后检查<function>PQnotifies</function>。
   你可以使用<function>select()</function>来等待服务器数据到达，这样在无事可做时可以不浪费<acronym>CPU</acronym>能力（参考<xref linkend="libpq-PQsocket"/>来获得用于<function>select()</function>的文件描述符）。
   注意不管是用<xref linkend="libpq-PQsendQuery"/>/<xref linkend="libpq-PQgetResult"/>提交命令还是简单地使用<xref linkend="libpq-PQexec"/>，这种方法都能正常工作。
   不过，你应该记住在每次<xref linkend="libpq-PQgetResult"/> 或 <xref linkend="libpq-PQexec"/>之后检查<function>PQnotifies</function>，看看在命令的处理过程中是否有通知到达。
  </para>
<!-- pgdoc-cn_end sig_en=6dfa8af3a3134d3e78c017831c042a01 -->

 </sect1>

 <sect1 id="libpq-copy">
<!-- pgdoc-cn_start sig_en=a708e9d123cdac7a7c5f4c4baa5cfa04 sig_cn_org=None source=14.1 
  <title>Functions Associated with the <command>COPY</command> Command</title>
________________________________________________________-->
  <title><command>COPY</command>命令相关的函数</title>
<!-- pgdoc-cn_end sig_en=a708e9d123cdac7a7c5f4c4baa5cfa04 -->

<!-- pgdoc-cn_start sig_en=5bc2fe96eb90c8290c01f1f222748061 sig_cn_org=None source=14.1 
  <indexterm zone="libpq-copy">
   <primary>COPY</primary>
   <secondary>with libpq</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="libpq-copy">
   <primary>COPY</primary>
   <secondary>with libpq</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=5bc2fe96eb90c8290c01f1f222748061 -->

<!-- pgdoc-cn_start sig_en=c6a671a2f68755b08d358060afb7395f sig_cn_org=None source=14.1 
  <para>
   The <command>COPY</command> command in
   <productname>PostgreSQL</productname> has options to read from or write
   to the network connection used by <application>libpq</application>.
   The functions described in this section allow applications to take
   advantage of this capability by supplying or consuming copied data.
  </para>
________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>中的<command>COPY</command>命令有用于<application>libpq</application>的对网络连接读出或者写入的选项。这一节描述的函数允许应用通过提供或者消耗已拷贝的数据来充分利用这个功能。
  </para>
<!-- pgdoc-cn_end sig_en=c6a671a2f68755b08d358060afb7395f -->

<!-- pgdoc-cn_start sig_en=f66fdf2f5fb58c15b550641cc6319d59 sig_cn_org=None source=14.1 
  <para>
   The overall process is that the application first issues the SQL
   <command>COPY</command> command via <xref linkend="libpq-PQexec"/> or one
   of the equivalent functions.  The response to this (if there is no
   error in the command) will be a <structname>PGresult</structname> object bearing
   a status code of <literal>PGRES_COPY_OUT</literal> or
   <literal>PGRES_COPY_IN</literal> (depending on the specified copy
   direction).  The application should then use the functions of this
   section to receive or transmit data rows.  When the data transfer is
   complete, another <structname>PGresult</structname> object is returned to indicate
   success or failure of the transfer.  Its status will be
   <literal>PGRES_COMMAND_OK</literal> for success or
   <literal>PGRES_FATAL_ERROR</literal> if some problem was encountered.
   At this point further SQL commands can be issued via
   <xref linkend="libpq-PQexec"/>.  (It is not possible to execute other SQL
   commands using the same connection while the <command>COPY</command>
   operation is in progress.)
  </para>
________________________________________________________-->
  <para>
   整个处理是应用首先通过<xref linkend="libpq-PQexec"/>或者一个等效的函数发出 SQL <command>COPY</command>命令。
   对这个命令的响应（如果命令无误）将是一个状态代码是<literal>PGRES_COPY_OUT</literal>或 者<literal>PGRES_COPY_IN</literal>（取决于指定的拷贝方向）的<structname>PGresult</structname>对象。
   应用然后就应该使用这一节的函数接收或者传送数据行。在数据传输结束之后，另外一个<structname>PGresult</structname>对象会被返回以表明传输的成功或者失败。
   它的状态将是：<literal>PGRES_COMMAND_OK</literal>表示成功，<literal>PGRES_FATAL_ERROR</literal>表示发生了一些问题。
   此时我们可以通过<xref linkend="libpq-PQexec"/>发出进一步的 SQL 命令（在<command>COPY</command>操作的处理过程中，不能用同一个连接执行其它 SQL 命令）。
  </para>
<!-- pgdoc-cn_end sig_en=f66fdf2f5fb58c15b550641cc6319d59 -->

<!-- pgdoc-cn_start sig_en=5947955b8765a39607c701988f7f7d79 sig_cn_org=None source=14.1 
  <para>
   If a <command>COPY</command> command is issued via
   <xref linkend="libpq-PQexec"/> in a string that could contain additional
   commands, the application must continue fetching results via
   <xref linkend="libpq-PQgetResult"/> after completing the <command>COPY</command>
   sequence.  Only when <xref linkend="libpq-PQgetResult"/> returns
   <symbol>NULL</symbol> is it certain that the <xref linkend="libpq-PQexec"/>
   command string is done and it is safe to issue more commands.
  </para>
________________________________________________________-->
  <para>
   如果一个<command>COPY</command>命令是通过<xref linkend="libpq-PQexec"/>在一个可能包含额外命令的字符串中发出的，那么应用在完成<command>COPY</command>序列之后必须继续用<xref linkend="libpq-PQgetResult"/>取得结果。
   只有在<xref linkend="libpq-PQgetResult"/>返回<symbol>NULL</symbol>时，我们才能确信<xref linkend="libpq-PQexec"/>的命令字符串已经处理完毕， 并且可以安全地发出更多命令。 
  </para>
<!-- pgdoc-cn_end sig_en=5947955b8765a39607c701988f7f7d79 -->

<!-- pgdoc-cn_start sig_en=e478b2e559817e7f6b37691ca55c747f sig_cn_org=None source=14.1 
  <para>
   The functions of this section should be executed only after obtaining
   a result status of <literal>PGRES_COPY_OUT</literal> or
   <literal>PGRES_COPY_IN</literal> from <xref linkend="libpq-PQexec"/> or
   <xref linkend="libpq-PQgetResult"/>.
  </para>
________________________________________________________-->
  <para>
   这一节的函数应该只在从<xref linkend="libpq-PQexec"/> 或 <xref linkend="libpq-PQgetResult"/>获得了<literal>PGRES_COPY_OUT</literal>或<literal>PGRES_COPY_IN</literal>结果状态的后执行。
  </para>
<!-- pgdoc-cn_end sig_en=e478b2e559817e7f6b37691ca55c747f -->

<!-- pgdoc-cn_start sig_en=e9b34f3d52068b87ab008a35d570f8ef sig_cn_org=3e9d966cc91188202f9d714c170261b1 source=15.7 
  <para>
   A <structname>PGresult</structname> object bearing one of these status values
   carries some additional data about the <command>COPY</command> operation
   that is starting.  This additional data is available using functions
   that are also used in connection with query results:

   <variablelist>
    <varlistentry id="libpq-PQnfields-1">
     <term><function>PQnfields</function><indexterm
     ><primary>PQnfields</primary><secondary>with COPY</secondary></indexterm></term>

     <listitem>
      <para>
       Returns the number of columns (fields) to be copied.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQbinaryTuples-1">
     <term><function>PQbinaryTuples</function><indexterm
     ><primary>PQbinaryTuples</primary><secondary>with COPY</secondary></indexterm></term>

     <listitem>
      <para>
       0 indicates the overall copy format is textual (rows separated by
       newlines, columns separated by separator characters, etc.).  1
       indicates the overall copy format is binary.  See <xref
       linkend="sql-copy"/> for more information.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQfformat-1">
     <term><function>PQfformat</function><indexterm
     ><primary>PQfformat</primary><secondary>with COPY</secondary></indexterm></term>

     <listitem>
      <para>
       Returns the format code (0 for text, 1 for binary) associated with
       each column of the copy operation.  The per-column format codes
       will always be zero when the overall copy format is textual, but
       the binary format can support both text and binary columns.
       (However, as of the current implementation of <command>COPY</command>,
       only binary columns appear in a binary copy; so the per-column
       formats always match the overall format at present.)
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
________________________________________________________-->
  <para>
   一个<structname>PGresult</structname>对象具有这些状态值之一，携带有关<command>COPY</command>操作开始的一些附加数据。
   可以使用与查询结果相关的函数来获取这些附加数据：

   <variablelist>
    <varlistentry id="libpq-PQnfields-1">
     <term><function>PQnfields</function><indexterm
     ><primary>PQnfields</primary><secondary>with COPY</secondary></indexterm></term>

     <listitem>
      <para>
       返回要复制的列（字段）的数量。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQbinaryTuples-1">
     <term><function>PQbinaryTuples</function><indexterm
     ><primary>PQbinaryTuples</primary><secondary>with COPY</secondary></indexterm></term>

     <listitem>
      <para>
       0表示整体复制格式为文本（行由换行符分隔，列由分隔符分隔等）。1表示整体复制格式为二进制。
       有关更多信息，请参见<xref linkend="sql-copy"/>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQfformat-1">
     <term><function>PQfformat</function><indexterm
     ><primary>PQfformat</primary><secondary>with COPY</secondary></indexterm></term>

     <listitem>
      <para>
       返回与复制操作的每列关联的格式代码（0表示文本，1表示二进制）。
       当整体复制格式为文本时，每列的格式代码始终为零，但二进制格式可以支持文本和二进制列。
       （但是，截至当前<command>COPY</command>的实现，只有二进制列出现在二进制复制中；
       因此，每列格式目前始终与整体格式匹配。）
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
<!-- pgdoc-cn_end sig_en=e9b34f3d52068b87ab008a35d570f8ef -->

  <sect2 id="libpq-copy-send">
<!-- pgdoc-cn_start sig_en=e094c3ba5300b53d4b550f4db22b6b59 sig_cn_org=None source=14.1 
   <title>Functions for Sending <command>COPY</command> Data</title>
________________________________________________________-->
   <title>用于发送<command>COPY</command>数据的函数</title>
<!-- pgdoc-cn_end sig_en=e094c3ba5300b53d4b550f4db22b6b59 -->

<!-- pgdoc-cn_start sig_en=4f8a2a37603d993111389fbc0a18347e sig_cn_org=None source=14.1 
   <para>
    These functions are used to send data during <literal>COPY FROM
    STDIN</literal>.  They will fail if called when the connection is not in
    <literal>COPY_IN</literal> state.
   </para>
________________________________________________________-->
   <para>
    这些函数用于在<literal>COPY FROM STDIN</literal>期间发送数据。如果在连接不是<literal>COPY_IN</literal>状态，调用它们会失败。
   </para>
<!-- pgdoc-cn_end sig_en=4f8a2a37603d993111389fbc0a18347e -->

   <variablelist>
    <varlistentry id="libpq-PQputCopyData">
<!-- pgdoc-cn_start sig_en=b6642fff6488940c45282202ca3ddfd5 sig_cn_org=None source=14.1 
     <term><function>PQputCopyData</function><indexterm><primary>PQputCopyData</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQputCopyData</function><indexterm><primary>PQputCopyData</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=b6642fff6488940c45282202ca3ddfd5 -->

     <listitem>
<!-- pgdoc-cn_start sig_en=d859bbe9e427e0f8dfd9f4613047aa55 sig_cn_org=None source=14.1 
      <para>
       Sends data to the server during <literal>COPY_IN</literal> state.
<synopsis>
int PQputCopyData(PGconn *conn,
                  const char *buffer,
                  int nbytes);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       在<literal>COPY_IN</literal>状态中向服务器发送数据。
<synopsis>
int PQputCopyData(PGconn *conn,
                  const char *buffer,
                  int nbytes);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=d859bbe9e427e0f8dfd9f4613047aa55 -->

<!-- pgdoc-cn_start sig_en=46ec0c7ff518a02dbb4763b4a95c1cbc sig_cn_org=None source=14.1 
      <para>
       Transmits the <command>COPY</command> data in the specified
       <parameter>buffer</parameter>, of length <parameter>nbytes</parameter>, to the server.
       The result is 1 if the data was queued, zero if it was not queued
       because of full buffers (this will only happen in nonblocking mode),
       or -1 if an error occurred.
       (Use <xref linkend="libpq-PQerrorMessage"/> to retrieve details if
       the return value is -1.  If the value is zero, wait for write-ready
       and try again.)
      </para>
________________________________________________________-->
      <para>
       传输指定<parameter>buffer</parameter>中长度为<parameter>nbytes</parameter>的<command>COPY</command>数据到服务器。
       如果数据被放在队列中，结果是 1；如果因为缓冲区满而无法被放在队列中（只可能发生在连接是非阻塞模式时），那么结果是零；如果发生错误，结果为 -1（如果返回值为 -1，那么使用<xref linkend="libpq-PQerrorMessage"/>检索细节。如果值是零，那么等待写准备好然后重试）。
      </para>
<!-- pgdoc-cn_end sig_en=46ec0c7ff518a02dbb4763b4a95c1cbc -->

<!-- pgdoc-cn_start sig_en=9c9990a1f1610422d3c8b50ef1a14b68 sig_cn_org=None source=14.1 
      <para>
       The application can divide the <command>COPY</command> data stream
       into buffer loads of any convenient size.  Buffer-load boundaries
       have no semantic significance when sending.  The contents of the
       data stream must match the data format expected by the
       <command>COPY</command> command; see <xref linkend="sql-copy"/> for details.
      </para>
________________________________________________________-->
      <para>
       应用可以把<command>COPY</command>数据流划分成任意方便的大小放到缓冲区中。在发送时，缓冲区载荷的边界没有什么语意。数据流的内容必须匹配<command>COPY</command>命令预期的数据格式；详见<xref linkend="sql-copy"/>。
      </para>
<!-- pgdoc-cn_end sig_en=9c9990a1f1610422d3c8b50ef1a14b68 -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQputCopyEnd">
<!-- pgdoc-cn_start sig_en=6d15702d73ea6261ccd4aaab10f8920b sig_cn_org=None source=14.1 
     <term><function>PQputCopyEnd</function><indexterm><primary>PQputCopyEnd</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQputCopyEnd</function><indexterm><primary>PQputCopyEnd</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=6d15702d73ea6261ccd4aaab10f8920b -->

     <listitem>
<!-- pgdoc-cn_start sig_en=beb0ba1e8deeef9b2e5e298592ad6c35 sig_cn_org=None source=14.1 
      <para>
       Sends end-of-data indication to the server during <literal>COPY_IN</literal> state.
<synopsis>
int PQputCopyEnd(PGconn *conn,
                 const char *errormsg);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       在<literal>COPY_IN</literal>状态中向服务器发送数据结束的指示。
<synopsis>
int PQputCopyEnd(PGconn *conn,
                 const char *errormsg);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=beb0ba1e8deeef9b2e5e298592ad6c35 -->

<!-- pgdoc-cn_start sig_en=b150a6ab33bf52f9068e2706cf8651a7 sig_cn_org=None source=14.1 
      <para>
       Ends the <literal>COPY_IN</literal> operation successfully if
       <parameter>errormsg</parameter> is <symbol>NULL</symbol>.  If
       <parameter>errormsg</parameter> is not <symbol>NULL</symbol> then the
       <command>COPY</command> is forced to fail, with the string pointed to by
       <parameter>errormsg</parameter> used as the error message.  (One should not
       assume that this exact error message will come back from the server,
       however, as the server might have already failed the
       <command>COPY</command> for its own reasons.)
      </para>
________________________________________________________-->
      <para>
       如果<parameter>errormsg</parameter>是<symbol>NULL</symbol>，则成功结束<literal>COPY_IN</literal>操作。
       如果<parameter>errormsg</parameter>不是<symbol>NULL</symbol>则<command>COPY</command>被强制失败，<parameter>errormsg</parameter>指向的字符串是错误消息。
       （不过，我们不应假定这个准确的错误信息将会从服务器传回，因为服务器可能已经因为其自身原因导致<command>COPY</command>失败。）。
      </para>
<!-- pgdoc-cn_end sig_en=b150a6ab33bf52f9068e2706cf8651a7 -->

<!-- pgdoc-cn_start sig_en=5e53512c8985ee4465ea8e3e51190c83 sig_cn_org=None source=14.1 
      <para>
       The result is 1 if the termination message was sent; or in
       nonblocking mode, this may only indicate that the termination
       message was successfully queued.  (In nonblocking mode, to be
       certain that the data has been sent, you should next wait for
       write-ready and call <xref linkend="libpq-PQflush"/>, repeating until it
       returns zero.)  Zero indicates that the function could not queue
       the termination message because of full buffers; this will only
       happen in nonblocking mode.  (In this case, wait for
       write-ready and try the <xref linkend="libpq-PQputCopyEnd"/> call
       again.)  If a hard error occurs, -1 is returned; you can use
       <xref linkend="libpq-PQerrorMessage"/> to retrieve details.
      </para>
________________________________________________________-->
      <para>
       如果终止消息被发送，则结果为 1；在非阻塞模式中，结果为 1 也可能只表示终止消息被成功地放在了发送队列中
       （在非阻塞模式中，要确认数据确实被发送出去，你应该接着等待写准备好并且调用<xref linkend="libpq-PQflush"/>，重复这些直到返回零）。
       零表示该函数由于缓冲区满而无法将该终止消息放在队列中，这只会发生在非阻塞模式中（在这种情况下，等待写准备好并且再次尝试<xref linkend="libpq-PQputCopyEnd"/>调用）。
       如果发生系统错误，则返回 -1，可以使用<xref linkend="libpq-PQerrorMessage"/>检索详情。
      </para>
<!-- pgdoc-cn_end sig_en=5e53512c8985ee4465ea8e3e51190c83 -->

<!-- pgdoc-cn_start sig_en=54fbd780e94ac72d5781d9a36bbc66db sig_cn_org=None source=14.1 
      <para>
       After successfully calling <xref linkend="libpq-PQputCopyEnd"/>, call
       <xref linkend="libpq-PQgetResult"/> to obtain the final result status of the
       <command>COPY</command> command.  One can wait for this result to be
       available in the usual way.  Then return to normal operation.
      </para>
________________________________________________________-->
      <para>
       在成功调用<xref linkend="libpq-PQputCopyEnd"/>之后，调用<xref linkend="libpq-PQgetResult"/>获取<command>COPY</command>命令的最终结果状态。
       我们可以用平常的方法来等待这个结果可用。然后返回到正常的操作。
      </para>
<!-- pgdoc-cn_end sig_en=54fbd780e94ac72d5781d9a36bbc66db -->
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>

  <sect2 id="libpq-copy-receive">
<!-- pgdoc-cn_start sig_en=fa8ccbfeab5f96d9e0c299ec37a39223 sig_cn_org=None source=14.1 
   <title>Functions for Receiving <command>COPY</command> Data</title>
________________________________________________________-->
   <title>用于接收<command>COPY</command>数据的函数</title>
<!-- pgdoc-cn_end sig_en=fa8ccbfeab5f96d9e0c299ec37a39223 -->

<!-- pgdoc-cn_start sig_en=db8c23982289da865e34a57076408b24 sig_cn_org=None source=14.1 
   <para>
    These functions are used to receive data during <literal>COPY TO
    STDOUT</literal>.  They will fail if called when the connection is not in
    <literal>COPY_OUT</literal> state.
   </para>
________________________________________________________-->
   <para>
    这些函数用于在<literal>COPY TO STDOUT</literal>的过程中接收数据。如果连接不在<literal>COPY_OUT</literal>状态，那么调用它们将会失败。
   </para>
<!-- pgdoc-cn_end sig_en=db8c23982289da865e34a57076408b24 -->

   <variablelist>
    <varlistentry id="libpq-PQgetCopyData">
<!-- pgdoc-cn_start sig_en=eeba4f8445b863ff42c951a51e3cab05 sig_cn_org=None source=14.1 
     <term><function>PQgetCopyData</function><indexterm><primary>PQgetCopyData</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQgetCopyData</function><indexterm><primary>PQgetCopyData</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=eeba4f8445b863ff42c951a51e3cab05 -->

     <listitem>
<!-- pgdoc-cn_start sig_en=110bcfea64f4cc5c9ba7a02a61f45497 sig_cn_org=None source=14.1 
      <para>
       Receives data from the server during <literal>COPY_OUT</literal> state.
<synopsis>
int PQgetCopyData(PGconn *conn,
                  char **buffer,
                  int async);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       在<literal>COPY_OUT</literal>状态下从服务器接收数据。
<synopsis>
int PQgetCopyData(PGconn *conn,
                  char **buffer,
                  int async);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=110bcfea64f4cc5c9ba7a02a61f45497 -->

<!-- pgdoc-cn_start sig_en=fce685207682f26b57cc5e6d3fa68216 sig_cn_org=None source=14.1 
      <para>
       Attempts to obtain another row of data from the server during a
       <command>COPY</command>.  Data is always returned one data row at
       a time; if only a partial row is available, it is not returned.
       Successful return of a data row involves allocating a chunk of
       memory to hold the data.  The <parameter>buffer</parameter> parameter must
       be non-<symbol>NULL</symbol>.  <parameter>*buffer</parameter> is set to
       point to the allocated memory, or to <symbol>NULL</symbol> in cases
       where no buffer is returned.  A non-<symbol>NULL</symbol> result
       buffer should be freed using <xref linkend="libpq-PQfreemem"/> when no longer
       needed.
      </para>
________________________________________________________-->
      <para>
       在一个<command>COPY</command>期间尝试从服务器获取另外一行数据。数据总是以每次一个数据行的方式被返回；如果只有一个部分行可用，那么它不会被返回。
       成功返回一个数据行涉及到分配一块内存来保存该数据。<parameter>buffer</parameter>参数必须为非<symbol>NULL</symbol>。
       <parameter>*buffer</parameter>被设置为指向分配到的内存的指针，或者是在没有返回缓冲区的情况下指向<symbol>NULL</symbol>。
       一个非<symbol>NULL</symbol>的结果缓冲区在不需要时必须用<xref linkend="libpq-PQfreemem"/>释放。
      </para>
<!-- pgdoc-cn_end sig_en=fce685207682f26b57cc5e6d3fa68216 -->

<!-- pgdoc-cn_start sig_en=b05f43fa001704bf4e3b91610928c33a sig_cn_org=None source=14.1 
      <para>
       When a row is successfully returned, the return value is the number
       of data bytes in the row (this will always be greater than zero).
       The returned string is always null-terminated, though this is
       probably only useful for textual <command>COPY</command>.  A result
       of zero indicates that the <command>COPY</command> is still in
       progress, but no row is yet available (this is only possible when
       <parameter>async</parameter> is true).  A result of -1 indicates that the
       <command>COPY</command> is done.  A result of -2 indicates that an
       error occurred (consult <xref linkend="libpq-PQerrorMessage"/> for the reason).
      </para>
________________________________________________________-->
      <para>
       在成功返回一行之后，返回的值就是该数据行里数据的字节数（将是大于零）。
       被返回的字符串总是空终止的，虽然这可能只是对文本<command>COPY</command>有用。 
       一个零结果表示该<command>COPY</command>仍然在处理中，但是还没有可用的行（只在<parameter>async</parameter>为真时才可能）。
       一个 -1 结果表示<command>COPY</command>已经完成。-2 结果表示发生了错误（参考<xref linkend="libpq-PQerrorMessage"/>获取原因）。
      </para>
<!-- pgdoc-cn_end sig_en=b05f43fa001704bf4e3b91610928c33a -->

<!-- pgdoc-cn_start sig_en=e007a8961c756a47ca08dbf92de06c85 sig_cn_org=None source=14.1 
      <para>
       When <parameter>async</parameter> is true (not zero),
       <xref linkend="libpq-PQgetCopyData"/> will not block waiting for input; it
       will return zero if the <command>COPY</command> is still in progress
       but no complete row is available.  (In this case wait for read-ready
       and then call <xref linkend="libpq-PQconsumeInput"/> before calling
       <xref linkend="libpq-PQgetCopyData"/> again.)  When <parameter>async</parameter> is
       false (zero), <xref linkend="libpq-PQgetCopyData"/> will block until data is
       available or the operation completes.
      </para>
________________________________________________________-->
      <para>
       当<parameter>async</parameter>为真时（非零），<xref linkend="libpq-PQgetCopyData"/>将不会阻塞等待输入；
       如果<command>COPY</command>仍在处理过程中并且没有可用的完整行，那么它将返回零
       （在这种情况下等待读准备好，然后在再次调用<xref linkend="libpq-PQgetCopyData"/>之前，调用<xref linkend="libpq-PQconsumeInput"/>）。
       当<parameter>async</parameter>为假（零）时，<function>PQgetCopyData</function>将阻塞，直到数据可用或者操作完成。
      </para>
<!-- pgdoc-cn_end sig_en=e007a8961c756a47ca08dbf92de06c85 -->

<!-- pgdoc-cn_start sig_en=45c9752d840ee36966130d2f9d78a211 sig_cn_org=None source=14.1 
      <para>
       After <xref linkend="libpq-PQgetCopyData"/> returns -1, call
       <xref linkend="libpq-PQgetResult"/> to obtain the final result status of the
       <command>COPY</command> command.  One can wait for this result to be
       available in the usual way.  Then return to normal operation.
      </para>
________________________________________________________-->
      <para>
       在<xref linkend="libpq-PQgetCopyData"/>返回 -1 之后，调用<xref linkend="libpq-PQgetResult"/>获取<command>COPY</command>命令的最后结果状态。
       我们可以用平常的方法来等待这个结果可用。然后返回到正常的操作。
      </para>
<!-- pgdoc-cn_end sig_en=45c9752d840ee36966130d2f9d78a211 -->
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>

  <sect2 id="libpq-copy-deprecated">
<!-- pgdoc-cn_start sig_en=f1a8078674d169d29e33d77006f43db3 sig_cn_org=None source=14.1 
   <title>Obsolete Functions for <command>COPY</command></title>
________________________________________________________-->
   <title>用于<command>COPY</command>的废弃函数</title>
<!-- pgdoc-cn_end sig_en=f1a8078674d169d29e33d77006f43db3 -->

<!-- pgdoc-cn_start sig_en=fe29229686a17ca716299a691d7a93c1 sig_cn_org=None source=14.1 
   <para>
    These functions represent older methods of handling <command>COPY</command>.
    Although they still work, they are deprecated due to poor error handling,
    inconvenient methods of detecting end-of-data, and lack of support for binary
    or nonblocking transfers.
   </para>
________________________________________________________-->
   <para>
    这些函数代表了以前的处理<command>COPY</command>的方法。尽管它们还能用，但是现在已经被废弃，因为它们的错误处理很糟糕、检测结束数据的方法也不方便，并且缺少对二进制或非阻塞传输的支持。
   </para>
<!-- pgdoc-cn_end sig_en=fe29229686a17ca716299a691d7a93c1 -->

   <variablelist>
    <varlistentry id="libpq-PQgetline">
<!-- pgdoc-cn_start sig_en=137dbe98814fd4f9587d645b55092a9c sig_cn_org=None source=14.1 
     <term><function>PQgetline</function><indexterm><primary>PQgetline</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQgetline</function><indexterm><primary>PQgetline</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=137dbe98814fd4f9587d645b55092a9c -->

     <listitem>
<!-- pgdoc-cn_start sig_en=9c209bc06171986289699867d5251718 sig_cn_org=None source=14.1 
      <para>
       Reads  a  newline-terminated  line  of  characters (transmitted
       by the server) into a buffer string of size <parameter>length</parameter>.
<synopsis>
int PQgetline(PGconn *conn,
              char *buffer,
              int length);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       读取一个以新行终止的字符行到（由服务器传输） 到一个长度为<parameter>length</parameter>的字符串缓冲区。
<synopsis>
int PQgetline(PGconn *conn,
              char *buffer,
              int length);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=9c209bc06171986289699867d5251718 -->

<!-- pgdoc-cn_start sig_en=8df08d9f47c309f482dee4ff1fb177cf sig_cn_org=None source=14.1 
      <para>
       This function copies up to <parameter>length</parameter>-1 characters into
       the buffer and converts the terminating newline into a zero byte.
       <xref linkend="libpq-PQgetline"/> returns <symbol>EOF</symbol> at the
       end of input, 0 if the entire line has been read, and 1 if the
       buffer is full but the terminating newline has not yet been read.
       </para>
________________________________________________________-->
      <para>
       这个函数拷贝最多<parameter>length</parameter>-1 个字符到该缓冲区中，并且把终止的新行转换成一个零字节。
       <xref linkend="libpq-PQgetline"/>在输入结束时返回<symbol>EOF</symbol>，如果整行都被读取则返回 0，如果缓冲区填满了而还没有遇到结束的新行则返回  1。
       </para>
<!-- pgdoc-cn_end sig_en=8df08d9f47c309f482dee4ff1fb177cf -->
<!-- pgdoc-cn_start sig_en=6b65572a8bf23ed7d17a32c6d0fefd5c sig_cn_org=None source=14.1 
       <para>
       Note that the application must check to see if a new line consists
       of  the  two characters  <literal>\.</literal>, which  indicates
       that the server has finished sending the results  of  the
       <command>COPY</command> command.  If  the  application might receive
       lines that are more than <parameter>length</parameter>-1  characters  long,
       care is needed to be sure it recognizes the <literal>\.</literal>
       line correctly (and does not, for example, mistake the end of a
       long data line for a terminator line).
      </para>
________________________________________________________-->
       <para>
       注意，应用必须检查是否一个新行包含两个字符<literal>\.</literal>，这表明服务器 已经完成了<command>COPY</command>命令的结果发送。如果应用可能收到超过<parameter>length</parameter>-1 字符长的行， 我们就应该确保正确识别<literal>\.</literal>行（例如，不要把一个长数据行的结束当作一个终止行）。
      </para>
<!-- pgdoc-cn_end sig_en=6b65572a8bf23ed7d17a32c6d0fefd5c -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQgetlineAsync">
<!-- pgdoc-cn_start sig_en=51e1fc99f57fb8794378b827cb019981 sig_cn_org=None source=14.1 
     <term><function>PQgetlineAsync</function><indexterm><primary>PQgetlineAsync</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQgetlineAsync</function><indexterm><primary>PQgetlineAsync</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=51e1fc99f57fb8794378b827cb019981 -->

     <listitem>
<!-- pgdoc-cn_start sig_en=7ddb887dc2a184aad0c213bfef29edb7 sig_cn_org=None source=14.1 
      <para>
       Reads a row of <command>COPY</command> data (transmitted  by the
       server) into a buffer without blocking.
<synopsis>
int PQgetlineAsync(PGconn *conn,
                   char *buffer,
                   int bufsize);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       不阻塞地读取一行<command>COPY</command>数据（由服务器传输）到一个缓冲区中。
<synopsis>
int PQgetlineAsync(PGconn *conn,
                   char *buffer,
                   int bufsize);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=7ddb887dc2a184aad0c213bfef29edb7 -->

<!-- pgdoc-cn_start sig_en=fb45aa1333617638d74be99e1a9e9e2f sig_cn_org=None source=14.1 
      <para>
       This function is similar to <xref linkend="libpq-PQgetline"/>, but it can be used
       by applications
       that must read <command>COPY</command> data asynchronously, that is, without blocking.
       Having issued the <command>COPY</command> command and gotten a <literal>PGRES_COPY_OUT</literal>
       response, the
       application should call <xref linkend="libpq-PQconsumeInput"/> and
       <xref linkend="libpq-PQgetlineAsync"/> until the
       end-of-data signal is detected.
       </para>
________________________________________________________-->
      <para>
       这个函数类似于<xref linkend="libpq-PQgetline"/>，但是可以被用于那些必须异步读取<command>COPY</command>数据的应用， 也就是不阻塞的应用。
       在发出了<command>COPY</command>命令并得到了<literal>PGRES_COPY_OUT</literal>响应之后，
       应用应该调用<xref linkend="libpq-PQconsumeInput"/> 和 <xref linkend="libpq-PQgetlineAsync"/>直到检测到结束数据的信号。
       </para>
<!-- pgdoc-cn_end sig_en=fb45aa1333617638d74be99e1a9e9e2f -->
<!-- pgdoc-cn_start sig_en=ae8854aa8054e2decabdf33dd1df5938 sig_cn_org=None source=14.1 
       <para>
       Unlike <xref linkend="libpq-PQgetline"/>, this function takes
       responsibility for detecting end-of-data.
      </para>
________________________________________________________-->
       <para>
       不像<xref linkend="libpq-PQgetline"/>，这个函数负责检测结束数据。
      </para>
<!-- pgdoc-cn_end sig_en=ae8854aa8054e2decabdf33dd1df5938 -->

<!-- pgdoc-cn_start sig_en=99a7dd2b039dad87758657ed00160910 sig_cn_org=None source=14.1 
      <para>
       On each call, <xref linkend="libpq-PQgetlineAsync"/> will return data if a
       complete data row is available in <application>libpq</application>'s input buffer.
       Otherwise, no data is returned until the rest of the row arrives.
       The function returns -1 if the end-of-copy-data marker has been recognized,
       or 0 if no data is available, or a positive number giving the number of
       bytes of data returned.  If -1 is returned, the caller must next call
       <xref linkend="libpq-PQendcopy"/>, and then return to normal processing.
      </para>
________________________________________________________-->
      <para>
       在每次调用时，如果<application>libpq</application>的输入缓冲区中有一个完整的数据行可用，<xref linkend="libpq-PQgetlineAsync"/>都将返回数据。
       否则，在剩余行到达之前不会返回数据。如果识别到拷贝数据结束的标志，此函数返回 -1；如果没有可用数据则返回 0； 
       或者是给出一个正数给出被返回的字节数。如果返回 -1，调用者下一步必须调用<xref linkend="libpq-PQendcopy"/>，然后回到正常处理。
      </para>
<!-- pgdoc-cn_end sig_en=99a7dd2b039dad87758657ed00160910 -->

<!-- pgdoc-cn_start sig_en=bea4fd66f7bdda408799d4059f687212 sig_cn_org=None source=14.1 
      <para>
       The data returned will not extend beyond a data-row boundary.  If possible
       a whole row will be returned at one time.  But if the buffer offered by
       the caller is too small to hold a row sent by the server, then a partial
       data row will be returned.  With textual data this can be detected by testing
       whether the last returned byte is <literal>\n</literal> or not.  (In a binary
       <command>COPY</command>, actual parsing of the <command>COPY</command> data format will be needed to make the
       equivalent determination.)
       The returned string is not null-terminated.  (If you want to add a
       terminating null, be sure to pass a <parameter>bufsize</parameter> one smaller
       than the room actually available.)
      </para>
________________________________________________________-->
      <para>
       返回的数据将不超过一个数据行的范围。如果可能，每次将返回一个完整行。但如果调用者提供的缓冲区太小不足以容下服务器发送的行，那么将返回部分行。对于文本数据，这可以通过测试返回的最后一个字节是否<literal>\n</literal>来检测（在二进制<command>COPY</command>中， 需要对<command>COPY</command>数据格式进行实际的分析，以便做相同的判断）。被返回的字符串不是空结尾的（如果你想增加一个终止空，确保传递一个比实际可用空间少一字节的<parameter>bufsize</parameter>）。
      </para>
<!-- pgdoc-cn_end sig_en=bea4fd66f7bdda408799d4059f687212 -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQputline">
<!-- pgdoc-cn_start sig_en=3fe3bbb1f025d336410bec7ef59c5d77 sig_cn_org=None source=14.1 
     <term><function>PQputline</function><indexterm><primary>PQputline</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQputline</function><indexterm><primary>PQputline</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=3fe3bbb1f025d336410bec7ef59c5d77 -->

     <listitem>
<!-- pgdoc-cn_start sig_en=4d70c0a04ee7e78621656b456ad987ed sig_cn_org=None source=14.1 
      <para>
       Sends  a  null-terminated  string  to  the server.  Returns 0 if
       OK and <symbol>EOF</symbol> if unable to send the string.
<synopsis>
int PQputline(PGconn *conn,
              const char *string);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       向服务器发送一个空终止的字符串。如果 OK 则返回 0；如果不能发送字符串则返回<symbol>EOF</symbol>。
<synopsis>
int PQputline(PGconn *conn,
              const char *string);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=4d70c0a04ee7e78621656b456ad987ed -->

<!-- pgdoc-cn_start sig_en=8e14ebdae035e69750a41f4613212b22 sig_cn_org=None source=14.1 
      <para>
       The <command>COPY</command> data stream sent by a series of calls
       to <xref linkend="libpq-PQputline"/> has the same format as that
       returned by <xref linkend="libpq-PQgetlineAsync"/>, except that
       applications are not obliged to send exactly one data row per
       <xref linkend="libpq-PQputline"/> call; it is okay to send a partial
       line or multiple lines per call.
      </para>
________________________________________________________-->
      <para>
       一系列<xref linkend="libpq-PQputline"/>调用发送的<command>COPY</command>数据流和<xref linkend="libpq-PQgetlineAsync"/>返回的数据具有相同的格式， 
       只是应用不需要每次<xref linkend="libpq-PQputline"/>调用中发送刚好一个数据行；在每次调用中发送多行或者部分行都是可以的。
      </para>
<!-- pgdoc-cn_end sig_en=8e14ebdae035e69750a41f4613212b22 -->

      <note>
<!-- pgdoc-cn_start sig_en=c715aff00d314cd8bbdd47ec80d60e08 sig_cn_org=None source=14.1 
       <para>
        Before <productname>PostgreSQL</productname> protocol 3.0, it was necessary
        for the application to explicitly send the two characters
        <literal>\.</literal> as a final line to indicate to the server that it had
        finished sending <command>COPY</command> data.  While this still works, it is deprecated and the
        special meaning of <literal>\.</literal> can be expected to be removed in a
        future release.  It is sufficient to call <xref linkend="libpq-PQendcopy"/> after
        having sent the actual data.
       </para>
________________________________________________________-->
       <para>
        在<productname>PostgreSQL</productname>协议 3.0 之前，应用必须显式地发送两个字符<literal>\.</literal>作为最后一行来指示服务器已经完成发送<command>COPY</command>数据。
        虽然这么做仍然有效，但是它已经被废弃并且<literal>\.</literal>的特殊含义可能在将来的版本中删除。
        在发送完实际数据之后， 调用<xref linkend="libpq-PQendcopy"/>就足够了。
       </para>
<!-- pgdoc-cn_end sig_en=c715aff00d314cd8bbdd47ec80d60e08 -->
      </note>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQputnbytes">
<!-- pgdoc-cn_start sig_en=10807a00423f844c2eeb0474f1cf531a sig_cn_org=None source=14.1 
     <term><function>PQputnbytes</function><indexterm><primary>PQputnbytes</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQputnbytes</function><indexterm><primary>PQputnbytes</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=10807a00423f844c2eeb0474f1cf531a -->

     <listitem>
<!-- pgdoc-cn_start sig_en=5e28f6eeef8f4798023965a76b80c59e sig_cn_org=None source=14.1 
      <para>
       Sends  a  non-null-terminated  string  to  the server.  Returns
       0 if OK and <symbol>EOF</symbol> if unable to send the string.
<synopsis>
int PQputnbytes(PGconn *conn,
                const char *buffer,
                int nbytes);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       向服务器发送一个非空终止的字符串。如果 OK 则返回 0，如果不能发送字符串则返回<symbol>EOF</symbol>。
<synopsis>
int PQputnbytes(PGconn *conn,
                const char *buffer,
                int nbytes);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=5e28f6eeef8f4798023965a76b80c59e -->

<!-- pgdoc-cn_start sig_en=941ca371b29a0ba6172920192111d127 sig_cn_org=None source=14.1 
      <para>
       This is exactly like <xref linkend="libpq-PQputline"/>, except that the data
       buffer need not be null-terminated since the number of bytes to send is
       specified directly.  Use this procedure when sending binary data.
      </para>
________________________________________________________-->
      <para>
       这个函数类似<xref linkend="libpq-PQputline"/>，除了数据缓冲区不需要是空终止，因为要发送的字节数是直接指定的。在发送二进制数据时使用这个过程。
      </para>
<!-- pgdoc-cn_end sig_en=941ca371b29a0ba6172920192111d127 -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQendcopy">
<!-- pgdoc-cn_start sig_en=71c7317f0af3d16b299781c2cfdbd128 sig_cn_org=None source=14.1 
     <term><function>PQendcopy</function><indexterm><primary>PQendcopy</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQendcopy</function><indexterm><primary>PQendcopy</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=71c7317f0af3d16b299781c2cfdbd128 -->

     <listitem>
<!-- pgdoc-cn_start sig_en=a62e9e8488763fc5b9a504d38cd16a52 sig_cn_org=None source=14.1 
      <para>
       Synchronizes with the server.
<synopsis>
int PQendcopy(PGconn *conn);
</synopsis>
       This function waits until the  server  has  finished  the copying.
       It should either be issued when the  last  string  has  been sent
       to  the  server using <xref linkend="libpq-PQputline"/> or when the
       last string has been  received  from  the  server using
       <function>PQgetline</function>.  It must be issued or the server
       will get <quote>out of sync</quote> with  the client.   Upon return
       from this function, the server is ready to receive the next SQL
       command.  The return value is 0  on  successful  completion,
       nonzero otherwise.  (Use <xref linkend="libpq-PQerrorMessage"/> to
       retrieve details if the return value is nonzero.)
      </para>
________________________________________________________-->
      <para>
       与服务器同步。
<synopsis>
int PQendcopy(PGconn *conn);
</synopsis>
       这个函数等待服务器完成拷贝。当最后一个字符串已经用<xref linkend="libpq-PQputline"/>发送给服务器时或者当最后一个字符串已经用<function>PQgetline</function>从服务器接收到时，就会发出这个函数。
       这个函数必须被发出，否则服务器将会和客户端<quote>不同步</quote>。从这个函数返回后，服务器就已经准备好接收下一个 SQL 命令了。函数成功完成时返回值为 0，否则返回非零值（如果返回值为非零值，用<xref linkend="libpq-PQerrorMessage"/>检索详情）。
      </para>
<!-- pgdoc-cn_end sig_en=a62e9e8488763fc5b9a504d38cd16a52 -->

<!-- pgdoc-cn_start sig_en=d7c2bfd80eeace4ec7c981dba5d322e1 sig_cn_org=None source=14.1 
      <para>
       When using <xref linkend="libpq-PQgetResult"/>, the application should
       respond to a <literal>PGRES_COPY_OUT</literal> result by executing
       <xref linkend="libpq-PQgetline"/> repeatedly, followed by
       <xref linkend="libpq-PQendcopy"/> after the terminator line is seen.
       It should then return to the <xref linkend="libpq-PQgetResult"/> loop
       until <xref linkend="libpq-PQgetResult"/> returns a null pointer.
       Similarly a <literal>PGRES_COPY_IN</literal> result is processed
       by a series of <xref linkend="libpq-PQputline"/> calls followed by
       <xref linkend="libpq-PQendcopy"/>, then return to the
       <xref linkend="libpq-PQgetResult"/> loop.  This arrangement will
       ensure that a <command>COPY</command> command embedded in a series
       of <acronym>SQL</acronym> commands will be executed correctly.
      </para>
________________________________________________________-->
      <para>
       在使用<xref linkend="libpq-PQgetResult"/>时，应用应该通过反复调用<xref linkend="libpq-PQgetline"/>并且在看到终止行后调用<xref linkend="libpq-PQendcopy"/>来响应<literal>PGRES_COPY_OUT</literal>结果。
       然后它应该返回到<xref linkend="libpq-PQgetResult"/>循环直到<xref linkend="libpq-PQgetResult"/>返回一个空指针。
       类似地，<literal>PGRES_COPY_IN</literal>结果会用一系列<xref linkend="libpq-PQputline"/>加上之后的<xref linkend="libpq-PQendcopy"/>来处理，然后返 回到<xref linkend="libpq-PQgetResult"/>循环。
       这样的安排将保证嵌入到一系列<acronym>SQL</acronym>命令中的<command>COPY</command>命令将被正确执行。
      </para>
<!-- pgdoc-cn_end sig_en=d7c2bfd80eeace4ec7c981dba5d322e1 -->

<!-- pgdoc-cn_start sig_en=4bcfbeafdad027a219cdeb9fa36ae64e sig_cn_org=None source=14.1 
      <para>
       Older applications are likely to submit a <command>COPY</command>
       via <xref linkend="libpq-PQexec"/> and assume that the transaction
       is done after <xref linkend="libpq-PQendcopy"/>.  This will work
       correctly only if the <command>COPY</command> is the only
       <acronym>SQL</acronym> command in the command string.
      </para>
________________________________________________________-->
      <para>
       旧的应用很可能会通过<xref linkend="libpq-PQexec"/>提交一个<command>COPY</command>命令并且假定事务在<xref linkend="libpq-PQendcopy"/>之后完成。
       只有在<command>COPY</command>是命令字符串中唯一的<acronym>SQL</acronym>命令时才能正确工作。
      </para>
<!-- pgdoc-cn_end sig_en=4bcfbeafdad027a219cdeb9fa36ae64e -->
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>

 </sect1>

 <sect1 id="libpq-control">
<!-- pgdoc-cn_start sig_en=14cdc592741f5c36c9e797fa5cd6756e sig_cn_org=None source=14.1 
  <title>Control Functions</title>
________________________________________________________-->
  <title>控制函数</title>
<!-- pgdoc-cn_end sig_en=14cdc592741f5c36c9e797fa5cd6756e -->

<!-- pgdoc-cn_start sig_en=90ece3f954ad499429902ac6d4ae1a32 sig_cn_org=None source=14.1 
  <para>
   These functions control miscellaneous details of <application>libpq</application>'s
   behavior.
  </para>
________________________________________________________-->
  <para>
   这些函数控制<application>libpq</application>行为各种各样的细节。
  </para>
<!-- pgdoc-cn_end sig_en=90ece3f954ad499429902ac6d4ae1a32 -->

  <variablelist>
   <varlistentry id="libpq-PQclientEncoding">
<!-- pgdoc-cn_start sig_en=9bca01f234e1777650b6733254a65761 sig_cn_org=None source=14.1 
    <term><function>PQclientEncoding</function><indexterm><primary>PQclientEncoding</primary></indexterm></term>
________________________________________________________-->
    <term><function>PQclientEncoding</function><indexterm><primary>PQclientEncoding</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=9bca01f234e1777650b6733254a65761 -->

    <listitem>
<!-- pgdoc-cn_start sig_en=62462e917a95f5d296cc1d85ffc276b8 sig_cn_org=None source=14.1 
     <para>
      Returns the client encoding.
<synopsis>
int PQclientEncoding(const PGconn *<replaceable>conn</replaceable>);
</synopsis>

      Note that it returns the encoding ID, not a symbolic string
      such as <literal>EUC_JP</literal>. If unsuccessful, it returns -1.
      To convert an encoding ID to an encoding name, you
      can use:

<synopsis>
char *pg_encoding_to_char(int <replaceable>encoding_id</replaceable>);
</synopsis>
     </para>
________________________________________________________-->
     <para>
      返回客户端编码。
<synopsis>
int PQclientEncoding(const PGconn *<replaceable>conn</replaceable>);
</synopsis>

      请注意，它返回的是编码 ID，而不是一个符号串字符串，如<literal>EUC_JP</literal>。如果不成功，它会返回 -1。要把一个编码 ID 转换为为一个编码名称，可以用：

<synopsis>
char *pg_encoding_to_char(int <replaceable>encoding_id</replaceable>);
</synopsis>
     </para>
<!-- pgdoc-cn_end sig_en=62462e917a95f5d296cc1d85ffc276b8 -->
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQsetClientEncoding">
<!-- pgdoc-cn_start sig_en=0968a45ac9308fdcd3c0253ac5c2c950 sig_cn_org=None source=14.1 
    <term><function>PQsetClientEncoding</function><indexterm><primary>PQsetClientEncoding</primary></indexterm></term>
________________________________________________________-->
    <term><function>PQsetClientEncoding</function><indexterm><primary>PQsetClientEncoding</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=0968a45ac9308fdcd3c0253ac5c2c950 -->

    <listitem>
<!-- pgdoc-cn_start sig_en=358aeefb72f31b8be76fd409526dd213 sig_cn_org=None source=14.1 
     <para>
      Sets the client encoding.
<synopsis>
int PQsetClientEncoding(PGconn *<replaceable>conn</replaceable>, const char *<replaceable>encoding</replaceable>);
</synopsis>

      <replaceable>conn</replaceable> is a connection to the server,
      and <replaceable>encoding</replaceable> is the encoding you want to
      use. If the function successfully sets the encoding, it returns 0,
      otherwise -1. The current encoding for this connection can be
      determined by using <xref linkend="libpq-PQclientEncoding"/>.
     </para>
________________________________________________________-->
     <para>
      设置客户端编码。
<synopsis>
int PQsetClientEncoding(PGconn *<replaceable>conn</replaceable>, const char *<replaceable>encoding</replaceable>);
</synopsis>

      <replaceable>conn</replaceable>是一个到服务器的连接，而<replaceable>encoding</replaceable>是你想使用的编码。
      如果函数成功地设置编码，则返回 0，否则返回 -1。这个连接的当前编码可以使用<xref linkend="libpq-PQclientEncoding"/>确定。
     </para>
<!-- pgdoc-cn_end sig_en=358aeefb72f31b8be76fd409526dd213 -->
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQsetErrorVerbosity">
<!-- pgdoc-cn_start sig_en=9e147c2b03184564ab50fd53b64bc9bb sig_cn_org=None source=14.1 
    <term><function>PQsetErrorVerbosity</function><indexterm><primary>PQsetErrorVerbosity</primary></indexterm></term>
________________________________________________________-->
    <term><function>PQsetErrorVerbosity</function><indexterm><primary>PQsetErrorVerbosity</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=9e147c2b03184564ab50fd53b64bc9bb -->

    <listitem>
<!-- pgdoc-cn_start sig_en=157f987a27bc3adc34410909756f083f sig_cn_org=None source=14.1 
     <para>
      Determines the verbosity of messages returned by
      <xref linkend="libpq-PQerrorMessage"/> and <xref linkend="libpq-PQresultErrorMessage"/>.
<synopsis>
typedef enum
{
    PQERRORS_TERSE,
    PQERRORS_DEFAULT,
    PQERRORS_VERBOSE,
    PQERRORS_SQLSTATE
} PGVerbosity;

PGVerbosity PQsetErrorVerbosity(PGconn *conn, PGVerbosity verbosity);
</synopsis>

      <xref linkend="libpq-PQsetErrorVerbosity"/> sets the verbosity mode,
      returning the connection's previous setting.
      In <firstterm>TERSE</firstterm> mode, returned messages include
      severity, primary text, and position only; this will normally fit on a
      single line.  The <firstterm>DEFAULT</firstterm> mode produces messages
      that include the above plus any detail, hint, or context fields (these
      might span multiple lines).  The <firstterm>VERBOSE</firstterm> mode
      includes all available fields.  The <firstterm>SQLSTATE</firstterm>
      mode includes only the error severity and the <symbol>SQLSTATE</symbol>
      error code, if one is available (if not, the output is like
      <firstterm>TERSE</firstterm> mode).
     </para>
________________________________________________________-->
     <para>
      决定<xref linkend="libpq-PQerrorMessage"/> 和 <xref linkend="libpq-PQresultErrorMessage"/>返回的消息的细节程度。
<synopsis>
typedef enum
{
    PQERRORS_TERSE,
    PQERRORS_DEFAULT,
    PQERRORS_VERBOSE,
    PQERRORS_SQLSTATE
} PGVerbosity;

PGVerbosity PQsetErrorVerbosity(PGconn *conn, PGVerbosity verbosity);
</synopsis>

      <xref linkend="libpq-PQsetErrorVerbosity"/>设置细节模式，并返回该连接的前一个设置。
      在<firstterm>TERSE</firstterm>模式下，返回的消息只包括严重性、主要文本以及位置；这些东西通常放在一个单一行中。
      <firstterm>DEFAULT</firstterm>模式生成的消息包括上面的信息加上任何细节、提示或者上下文域（这些可能跨越多行）。
      <firstterm>VERBOSE</firstterm>模式包括所有可以可用的域。修改细节模式不会影响来自已有<structname>PGresult</structname>对象中的可用消息。
      只有随后创建的<structname>PGresult</structname>对象才受到影响。
      <firstterm>SQLSTATE</firstterm>模式仅包括错误严重性和<symbol>SQLSTATE</symbol>错误代码，如果其中之一是可用的（如果没有，输出类似于<firstterm>TERSE</firstterm>模式）。
     </para>
<!-- pgdoc-cn_end sig_en=157f987a27bc3adc34410909756f083f -->

<!-- pgdoc-cn_start sig_en=da14eec32f4d037d54171783603330a3 sig_cn_org=None source=14.1 
     <para>
      Changing the verbosity setting does not affect the messages available
      from already-existing <structname>PGresult</structname> objects, only
      subsequently-created ones.
      (But see <xref linkend="libpq-PQresultVerboseErrorMessage"/> if you
      want to print a previous error with a different verbosity.)
     </para>
________________________________________________________-->
     <para>
      更改详细程度设置不会影响已存在的<structname>PGresult</structname>对象的可用的消息，只会影响随后创建的对象。
      （如果想要用不同的详细程度打印之前的错误，请见<xref linkend="libpq-PQresultVerboseErrorMessage"/> ）
     </para>
<!-- pgdoc-cn_end sig_en=da14eec32f4d037d54171783603330a3 -->
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQsetErrorContextVisibility">
<!-- pgdoc-cn_start sig_en=a51b244a4461c51150a3f081eeaf2ec5 sig_cn_org=None source=14.1 
    <term><function>PQsetErrorContextVisibility</function><indexterm><primary>PQsetErrorContextVisibility</primary></indexterm></term>
________________________________________________________-->
    <term><function>PQsetErrorContextVisibility</function><indexterm><primary>PQsetErrorContextVisibility</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=a51b244a4461c51150a3f081eeaf2ec5 -->

    <listitem>
<!-- pgdoc-cn_start sig_en=794f0d6b50d159831545e39df6637f4f sig_cn_org=None source=14.1 
     <para>
      Determines the handling of <literal>CONTEXT</literal> fields in messages
      returned by <xref linkend="libpq-PQerrorMessage"/>
      and <xref linkend="libpq-PQresultErrorMessage"/>.
<synopsis>
typedef enum
{
    PQSHOW_CONTEXT_NEVER,
    PQSHOW_CONTEXT_ERRORS,
    PQSHOW_CONTEXT_ALWAYS
} PGContextVisibility;

PGContextVisibility PQsetErrorContextVisibility(PGconn *conn, PGContextVisibility show_context);
</synopsis>

      <xref linkend="libpq-PQsetErrorContextVisibility"/> sets the context display mode,
      returning the connection's previous setting.  This mode controls
      whether the <literal>CONTEXT</literal> field is included in messages.
      The <firstterm>NEVER</firstterm> mode
      never includes <literal>CONTEXT</literal>, while <firstterm>ALWAYS</firstterm> always
      includes it if available.  In <firstterm>ERRORS</firstterm> mode (the
      default), <literal>CONTEXT</literal> fields are included only in error
      messages, not in notices and warnings.
      (However, if the verbosity setting is <firstterm>TERSE</firstterm>
      or <firstterm>SQLSTATE</firstterm>, <literal>CONTEXT</literal> fields
      are omitted regardless of the context display mode.)
     </para>
________________________________________________________-->
     <para>
      决定如何处理<xref linkend="libpq-PQerrorMessage"/> 和 <xref linkend="libpq-PQresultErrorMessage"/>返回的消息中的<literal>CONTEXT</literal>域。
<synopsis>
typedef enum
{
    PQSHOW_CONTEXT_NEVER,
    PQSHOW_CONTEXT_ERRORS,
    PQSHOW_CONTEXT_ALWAYS
} PGContextVisibility;

PGContextVisibility PQsetErrorContextVisibility(PGconn *conn, PGContextVisibility show_context);
</synopsis>

      <xref linkend="libpq-PQsetErrorContextVisibility"/>设置上下文显示模式，返回该连接上之前的设置。
      这个模式控制消息中是否包括<literal>CONTEXT</literal>域。
      <firstterm>NEVER</firstterm>模式不会包括<literal>CONTEXT</literal>，而<firstterm>ALWAYS</firstterm>则尽可能地包括这个域。
      在<firstterm>ERRORS</firstterm>模式（默认）中，只在错误消息中包括<literal>CONTEXT</literal>域，而在通知和警告消息中不会包括。
      （但是，如果详细程度设置为 <firstterm>TERSE</firstterm> 或<firstterm>SQLSTATE</firstterm>，则无论上下文显示模式如何，都会省略<literal>CONTEXT</literal>字段。）
     </para>
<!-- pgdoc-cn_end sig_en=794f0d6b50d159831545e39df6637f4f -->

<!-- pgdoc-cn_start sig_en=431f3510218e4dd6bcc848d706c58a99 sig_cn_org=None source=14.1 
     <para>
      Changing this mode does not
      affect the messages available from
      already-existing <structname>PGresult</structname> objects, only
      subsequently-created ones.
      (But see <xref linkend="libpq-PQresultVerboseErrorMessage"/> if you
      want to print a previous error with a different display mode.)
     </para>
________________________________________________________-->
     <para>
      更改这个模式不会影响从已经存在的<structname>PGresult</structname>对象项中得到的消息，只会影响后续创建的<structname>PGresult</structname>对象
      （如果想要用不同的详细程度打印之前的错误，请见<xref linkend="libpq-PQresultVerboseErrorMessage"/>）。
     </para>
<!-- pgdoc-cn_end sig_en=431f3510218e4dd6bcc848d706c58a99 -->
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQtrace">
<!-- pgdoc-cn_start sig_en=aad0268d260ab530e5d278ccf4f3e765 sig_cn_org=None source=14.1 
    <term><function>PQtrace</function><indexterm><primary>PQtrace</primary></indexterm></term>
________________________________________________________-->
    <term><function>PQtrace</function><indexterm><primary>PQtrace</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=aad0268d260ab530e5d278ccf4f3e765 -->

    <listitem>
<!-- pgdoc-cn_start sig_en=df563728ca6912624eeef8dddf48ce0c sig_cn_org=None source=14.1 
     <para>
      Enables tracing of the client/server communication to a debugging file
      stream.
<synopsis>
void PQtrace(PGconn *conn, FILE *stream);
</synopsis>
     </para>
________________________________________________________-->
     <para>
      启用对客户端/服务器通讯的跟踪，把跟踪信息输出到一个调试文件流中。
<synopsis>
void PQtrace(PGconn *conn, FILE *stream);
</synopsis>
     </para>
<!-- pgdoc-cn_end sig_en=df563728ca6912624eeef8dddf48ce0c -->

<!-- pgdoc-cn_start sig_en=b585b2b78ca616710a2a74352e56f369 sig_cn_org=None source=14.1 
     <para>
      Each line consists of: an optional timestamp, a direction indicator
      (<literal>F</literal> for messages from client to server
      or <literal>B</literal> for messages from server to client),
      message length, message type, and message contents.
      Non-message contents fields (timestamp, direction, length and message type)
      are separated by a tab. Message contents are separated by a space.
      Protocol strings are enclosed in double quotes, while strings used as data
      values are enclosed in single quotes.  Non-printable chars are printed as
      hexadecimal escapes.
      Further message-type-specific detail can be found in
      <xref linkend="protocol-message-formats"/>.
     </para>
________________________________________________________-->
     <para>
      每行包括:一个可选的时间戳，一个方向指示器(<literal>F</literal>表示从客户端到服务器的消息或<literal>B</literal>表示从服务器到客户端的消息)，消息长度、消息类型、和消息内容。
      非消息内容字段(时间戳、方向、长度和消息类型)由一个制表符分隔。
      消息内容用空格分隔。
      协议字符串用双引号括起来，而用作数据值的字符串用单引号括起来。
      不可打印的字符被打印为十六进制转义。
      更多消息-类型-特定的详情可以在<xref linkend="protocol-message-formats"/>中发现。
     </para>
<!-- pgdoc-cn_end sig_en=b585b2b78ca616710a2a74352e56f369 -->

     <note>
<!-- pgdoc-cn_start sig_en=182e21c28a78031b830e213642c3e33d sig_cn_org=None source=14.1 
      <para>
       On Windows, if the <application>libpq</application> library and an application are
       compiled with different flags, this function call will crash the
       application because the internal representation of the <literal>FILE</literal>
       pointers differ.  Specifically, multithreaded/single-threaded,
       release/debug, and static/dynamic flags should be the same for the
       library and all applications using that library.
      </para>
________________________________________________________-->
      <para>
       在 Windows上，如果<application>libpq</application>库和应用使用了不同的标志编译，那么这个函数调用会导致应用崩溃，因为<literal>FILE</literal>指针的内部表达是不一样的。特别是多线程/单线程、发布/调试 以及静态/动态标志应该是库和所有使用库的应用都一致。
      </para>
<!-- pgdoc-cn_end sig_en=182e21c28a78031b830e213642c3e33d -->
     </note>

    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQsetTraceFlags">
<!-- pgdoc-cn_start sig_en=9c785f70bf2cf1a47412a090c15df68e sig_cn_org=None source=14.1 
    <term><function>PQsetTraceFlags</function><indexterm><primary>PQsetTraceFlags</primary></indexterm></term>
________________________________________________________-->
    <term><function>PQsetTraceFlags</function><indexterm><primary>PQsetTraceFlags</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=9c785f70bf2cf1a47412a090c15df68e -->

    <listitem>
<!-- pgdoc-cn_start sig_en=3be778898114fc67345f29fc83193f10 sig_cn_org=None source=14.1 
     <para>
      Controls the tracing behavior of client/server communication.
<synopsis>
void PQsetTraceFlags(PGconn *conn, int flags);
</synopsis>
     </para>
________________________________________________________-->
     <para>
      控制客户端/服务器通信的跟踪行为。
<synopsis>
void PQsetTraceFlags(PGconn *conn, int flags);
</synopsis>
     </para>
<!-- pgdoc-cn_end sig_en=3be778898114fc67345f29fc83193f10 -->

<!-- pgdoc-cn_start sig_en=a038616693242485cc0e0afa848b3223 sig_cn_org=None source=14.1 
     <para>
      <literal>flags</literal> contains flag bits describing the operating mode
      of tracing.
      If <literal>flags</literal> contains <literal>PQTRACE_SUPPRESS_TIMESTAMPS</literal>,
      then the timestamp is not included when printing each message.
      If <literal>flags</literal> contains <literal>PQTRACE_REGRESS_MODE</literal>,
      then some fields are redacted when printing each message, such as object
      OIDs, to make the output more convenient to use in testing frameworks.
      This function must be called after calling <function>PQtrace</function>.
     </para>
________________________________________________________-->
     <para>
      <literal>flags</literal>包含描述跟踪的操作模式的标志位。
      如果<literal>flags</literal>包含<literal>PQTRACE_SUPPRESS_TIMESTAMPS</literal>，则在打印每条消息时不包括时间戳。
      如果<literal>flags</literal>包含<literal>PQTRACE_REGRESS_MODE</literal>，那么在打印每个消息时将修改一些字段，例如对象OIDs，以使输出在测试框架中更方便地使用。
      这个函数必须在调用<function>PQtrace</function>之后调用。
     </para>
<!-- pgdoc-cn_end sig_en=a038616693242485cc0e0afa848b3223 -->

    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQuntrace">
<!-- pgdoc-cn_start sig_en=c4e07760373eb35ff454f4b4b710cbb6 sig_cn_org=None source=14.1 
    <term><function>PQuntrace</function><indexterm><primary>PQuntrace</primary></indexterm></term>
________________________________________________________-->
    <term><function>PQuntrace</function><indexterm><primary>PQuntrace</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=c4e07760373eb35ff454f4b4b710cbb6 -->

    <listitem>
<!-- pgdoc-cn_start sig_en=477fec969af85db1c698ed62c3a955b3 sig_cn_org=None source=14.1 
     <para>
      Disables tracing started by <xref linkend="libpq-PQtrace"/>.
<synopsis>
void PQuntrace(PGconn *conn);
</synopsis>
     </para>
________________________________________________________-->
     <para>
      禁用<xref linkend="libpq-PQtrace"/>打开的跟踪。
<synopsis>
void PQuntrace(PGconn *conn);
</synopsis>
     </para>
<!-- pgdoc-cn_end sig_en=477fec969af85db1c698ed62c3a955b3 -->
    </listitem>
   </varlistentry>
  </variablelist>

 </sect1>

 <sect1 id="libpq-misc">
<!-- pgdoc-cn_start sig_en=2cc2f5ebd1f5c2bb3a6979848514c545 sig_cn_org=None source=14.1 
  <title>Miscellaneous Functions</title>
________________________________________________________-->
  <title>杂项函数</title>
<!-- pgdoc-cn_end sig_en=2cc2f5ebd1f5c2bb3a6979848514c545 -->

<!-- pgdoc-cn_start sig_en=66fcfc0ca7c9e36e71405714ee769723 sig_cn_org=None source=14.1 
  <para>
   As always, there are some functions that just don't fit anywhere.
  </para>
________________________________________________________-->
  <para>
   一如往常，总有一些函数不适合放在任何其他地方。
  </para>
<!-- pgdoc-cn_end sig_en=66fcfc0ca7c9e36e71405714ee769723 -->

  <variablelist>
   <varlistentry id="libpq-PQfreemem">
<!-- pgdoc-cn_start sig_en=49e39ff3d05b87fa7c2568b8ac0c14cb sig_cn_org=None source=14.1 
    <term><function>PQfreemem</function><indexterm><primary>PQfreemem</primary></indexterm></term>
________________________________________________________-->
    <term><function>PQfreemem</function><indexterm><primary>PQfreemem</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=49e39ff3d05b87fa7c2568b8ac0c14cb -->

    <listitem>
<!-- pgdoc-cn_start sig_en=75990284fa949c30b477f1acf14abd75 sig_cn_org=None source=14.1 
     <para>
      Frees memory allocated by <application>libpq</application>.
<synopsis>
void PQfreemem(void *ptr);
</synopsis>
     </para>
________________________________________________________-->
     <para>
      释放<application>libpq</application>分配的内存。
<synopsis>
void PQfreemem(void *ptr);
</synopsis>
     </para>
<!-- pgdoc-cn_end sig_en=75990284fa949c30b477f1acf14abd75 -->

<!-- pgdoc-cn_start sig_en=c4ee9462caec4a40328011fd26c038f5 sig_cn_org=None source=14.1 
     <para>
      Frees memory allocated by <application>libpq</application>, particularly
      <xref linkend="libpq-PQescapeByteaConn"/>,
      <xref linkend="libpq-PQescapeBytea"/>,
      <xref linkend="libpq-PQunescapeBytea"/>,
      and <function>PQnotifies</function>.
      It is particularly important that this function, rather than
      <function>free()</function>, be used on Microsoft Windows.  This is because
      allocating memory in a DLL and releasing it in the application works
      only if multithreaded/single-threaded, release/debug, and static/dynamic
      flags are the same for the DLL and the application.  On non-Microsoft
      Windows platforms, this function is the same as the standard library
      function <function>free()</function>.
     </para>
________________________________________________________-->
     <para>
      释放<application>libpq</application>分配的内存，尤其是<xref linkend="libpq-PQescapeByteaConn"/>,<xref linkend="libpq-PQescapeBytea"/>,<xref linkend="libpq-PQunescapeBytea"/>,和<function>PQnotifies</function>分配的内存。
      特别重要的是，在微软 Windows 上使用这个函数，而不是<function>free()</function>。
      这是因为只有 DLL 和应用的当多线程/单线程、发布/调试以及静态/动态标志相同时，才能在一个 DLL 中分配内存并且在应用中释放它。
      在非微软 Windows 平台上，这个函数与标准库函数<function>free()</function>相同。
     </para>
<!-- pgdoc-cn_end sig_en=c4ee9462caec4a40328011fd26c038f5 -->
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQconninfoFree">
<!-- pgdoc-cn_start sig_en=7d7a82e0c96750e567389915a6537a86 sig_cn_org=None source=14.1 
    <term><function>PQconninfoFree</function><indexterm><primary>PQconninfoFree</primary></indexterm></term>
________________________________________________________-->
    <term><function>PQconninfoFree</function><indexterm><primary>PQconninfoFree</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=7d7a82e0c96750e567389915a6537a86 -->

    <listitem>
<!-- pgdoc-cn_start sig_en=c6c878687fe2c4b66ebf64b7e4dd2c17 sig_cn_org=None source=14.1 
     <para>
      Frees the data structures allocated by
      <xref linkend="libpq-PQconndefaults"/> or <xref linkend="libpq-PQconninfoParse"/>.
<synopsis>
void PQconninfoFree(PQconninfoOption *connOptions);
</synopsis>
     </para>
________________________________________________________-->
     <para>
      释放<xref linkend="libpq-PQconndefaults"/> 或 <xref linkend="libpq-PQconninfoParse"/>分配的数据结构。
<synopsis>
void PQconninfoFree(PQconninfoOption *connOptions);
</synopsis>
     </para>
<!-- pgdoc-cn_end sig_en=c6c878687fe2c4b66ebf64b7e4dd2c17 -->

<!-- pgdoc-cn_start sig_en=fcb27ecd801b5a472e882ff3208514de sig_cn_org=None source=14.1 
     <para>
      A simple <xref linkend="libpq-PQfreemem"/> will not do for this, since
      the array contains references to subsidiary strings.
     </para>
________________________________________________________-->
     <para>
      一个简单的<xref linkend="libpq-PQfreemem"/>不会做这些，因为数组包含对子字符串的引用。
     </para>
<!-- pgdoc-cn_end sig_en=fcb27ecd801b5a472e882ff3208514de -->
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQencryptPasswordConn">
<!-- pgdoc-cn_start sig_en=80e654697b2f44b5d03818399daa5b43 sig_cn_org=None source=14.1 
    <term><function>PQencryptPasswordConn</function><indexterm><primary>PQencryptPasswordConn</primary></indexterm></term>
________________________________________________________-->
    <term><function>PQencryptPasswordConn</function><indexterm><primary>PQencryptPasswordConn</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=80e654697b2f44b5d03818399daa5b43 -->

    <listitem>
<!-- pgdoc-cn_start sig_en=81a59caa90a83355d147e5a933835cce sig_cn_org=None source=14.1 
     <para>
      Prepares the encrypted form of a <productname>PostgreSQL</productname> password.
<synopsis>
char *PQencryptPasswordConn(PGconn *conn, const char *passwd, const char *user, const char *algorithm);
</synopsis>
      This function is intended to be used by client applications that
      wish to send commands like <literal>ALTER USER joe PASSWORD
      'pwd'</literal>.  It is good practice not to send the original cleartext
      password in such a command, because it might be exposed in command
      logs, activity displays, and so on.  Instead, use this function to
      convert the password to encrypted form before it is sent.
     </para>
________________________________________________________-->
     <para>
      准备一个<productname>PostgreSQL</productname>口令的加密形式。
<synopsis>
char *PQencryptPasswordConn(PGconn *conn, const char *passwd, const char *user, const char *algorithm);
</synopsis>
      这个函数旨在用于那些希望发送类似于<literal>ALTER USER joe PASSWORD 'pwd'</literal>命令的客户端应用。不在这样一个命令中发送原始的明文密码是一个好习惯，因为它可能被暴露在命令日志、活动显示等等中。相反，在发送之前使用这个函数可以将口令转换为加密的形式。
     </para>
<!-- pgdoc-cn_end sig_en=81a59caa90a83355d147e5a933835cce -->

<!-- pgdoc-cn_start sig_en=d00be3a83d95889ed1d48434cbc99e54 sig_cn_org=None source=14.1 
     <para>
      The <parameter>passwd</parameter> and <parameter>user</parameter> arguments
      are the cleartext password, and the SQL name of the user it is for.
      <parameter>algorithm</parameter> specifies the encryption algorithm
      to use to encrypt the password. Currently supported algorithms are
      <literal>md5</literal> and <literal>scram-sha-256</literal> (<literal>on</literal> and
      <literal>off</literal> are also accepted as aliases for <literal>md5</literal>, for
      compatibility with older server versions). Note that support for
      <literal>scram-sha-256</literal> was introduced in <productname>PostgreSQL</productname>
      version 10, and will not work correctly with older server versions. If
      <parameter>algorithm</parameter> is <symbol>NULL</symbol>, this function will query
      the server for the current value of the
      <xref linkend="guc-password-encryption"/> setting. That can block, and
      will fail if the current transaction is aborted, or if the connection
      is busy executing another query. If you wish to use the default
      algorithm for the server but want to avoid blocking, query
      <varname>password_encryption</varname> yourself before calling
      <xref linkend="libpq-PQencryptPasswordConn"/>, and pass that value as the
      <parameter>algorithm</parameter>.
     </para>
________________________________________________________-->
     <para>
      <parameter>passwd</parameter>和<parameter>user</parameter>参数是明文口令以及用户的SQL名称。
      <parameter>algorithm</parameter>指定用来加密口令的加密算法。
      当前支持的算法是<literal>md5</literal>和<literal>scram-sha-256</literal>（<literal>on</literal>和<literal>off</literal>也被接受作为<literal>md5</literal>的别名，用于与较老的服务器版本兼容）。
      注意，对<literal>scram-sha-256</literal>支持是在<productname>PostgreSQL</productname>版本10中引入的，并且在老的服务器版本上无法工作。
      如果<parameter>algorithm</parameter>是<symbol>NULL</symbol>，这个函数将向服务器查询<xref linkend="guc-password-encryption"/>设置的当前值。
      这种行为可能会阻塞当前事务，并且当前事务被中止或者连接正忙于执行另一个查询时会失败。
      如果希望为服务器使用默认的算法但避免阻塞，应在调用<xref linkend="libpq-PQencryptPasswordConn"/>之前查询你自己的<varname>password_encryption</varname>，并且将该值作为<parameter>algorithm</parameter>传入。
     </para>
<!-- pgdoc-cn_end sig_en=d00be3a83d95889ed1d48434cbc99e54 -->

<!-- pgdoc-cn_start sig_en=8716246b72b2d0f37cf222ad47916fc7 sig_cn_org=None source=14.1 
     <para>
      The return value is a string allocated by <function>malloc</function>.
      The caller can assume the string doesn't contain any special characters
      that would require escaping.  Use <xref linkend="libpq-PQfreemem"/> to free the
      result when done with it. On error, returns <symbol>NULL</symbol>, and
      a suitable message is stored in the connection object.
     </para>
________________________________________________________-->
     <para>
      返回值是一个由<function>malloc</function>分配的字符串。调用者可以假设该字符串不含有需要转义的任何特殊字符。
      在处理完它之后，用<xref linkend="libpq-PQfreemem"/>释放结果。发生错误时，返回的是<symbol>NULL</symbol>，并且适当的消息会被存储在连接对象中。
     </para>
<!-- pgdoc-cn_end sig_en=8716246b72b2d0f37cf222ad47916fc7 -->

    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQencryptPassword">
<!-- pgdoc-cn_start sig_en=0fc53e0a50a1f6ec22feb85c9314d0e9 sig_cn_org=None source=14.1 
    <term><function>PQencryptPassword</function><indexterm><primary>PQencryptPassword</primary></indexterm></term>
________________________________________________________-->
    <term><function>PQencryptPassword</function><indexterm><primary>PQencryptPassword</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=0fc53e0a50a1f6ec22feb85c9314d0e9 -->

    <listitem>
<!-- pgdoc-cn_start sig_en=3c709b6c51249d7006579b5c344a0c9c sig_cn_org=None source=14.1 
     <para>
      Prepares the md5-encrypted form of a <productname>PostgreSQL</productname> password.
<synopsis>
char *PQencryptPassword(const char *passwd, const char *user);
</synopsis>
      <xref linkend="libpq-PQencryptPassword"/> is an older, deprecated version of
      <xref linkend="libpq-PQencryptPasswordConn"/>. The difference is that
      <xref linkend="libpq-PQencryptPassword"/> does not
      require a connection object, and <literal>md5</literal> is always used as the
      encryption algorithm.
     </para>
________________________________________________________-->
     <para>
      准备一个<productname>PostgreSQL</productname>口令的md5加密形式。
<synopsis>
char *PQencryptPassword(const char *passwd, const char *user);
</synopsis>
      <xref linkend="libpq-PQencryptPassword"/>是<xref linkend="libpq-PQencryptPasswordConn"/>的一个较老的已经被废弃的版本。其差别是<xref linkend="libpq-PQencryptPassword"/>不要求一个连接对象，并且总是用<literal>md5</literal>作为加密算法。
     </para>
<!-- pgdoc-cn_end sig_en=3c709b6c51249d7006579b5c344a0c9c -->
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQmakeEmptyPGresult">
<!-- pgdoc-cn_start sig_en=46049b48a3b527c63ab2c8424d5cc486 sig_cn_org=None source=14.1 
    <term><function>PQmakeEmptyPGresult</function><indexterm><primary>PQmakeEmptyPGresult</primary></indexterm></term>
________________________________________________________-->
    <term><function>PQmakeEmptyPGresult</function><indexterm><primary>PQmakeEmptyPGresult</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=46049b48a3b527c63ab2c8424d5cc486 -->

    <listitem>
<!-- pgdoc-cn_start sig_en=268599e24ecd9fd8609f22684663aafa sig_cn_org=None source=14.1 
     <para>
      Constructs an empty <structname>PGresult</structname> object with the given status.
<synopsis>
PGresult *PQmakeEmptyPGresult(PGconn *conn, ExecStatusType status);
</synopsis>
     </para>
________________________________________________________-->
     <para>
      用给定的状态，构造一个空<structname>PGresult</structname>对象。
<synopsis>
PGresult *PQmakeEmptyPGresult(PGconn *conn, ExecStatusType status);
</synopsis>
     </para>
<!-- pgdoc-cn_end sig_en=268599e24ecd9fd8609f22684663aafa -->

<!-- pgdoc-cn_start sig_en=5a7ee00099ff105c96e2b89ed97a3879 sig_cn_org=None source=14.1 
     <para>
      This is <application>libpq</application>'s internal function to allocate and
      initialize an empty <structname>PGresult</structname> object.  This
      function returns <symbol>NULL</symbol> if memory could not be allocated. It is
      exported because some applications find it useful to generate result
      objects (particularly objects with error status) themselves.  If
      <parameter>conn</parameter> is not null and <parameter>status</parameter>
      indicates an error, the current error message of the specified
      connection is copied into the <structname>PGresult</structname>.
      Also, if <parameter>conn</parameter> is not null, any event procedures
      registered in the connection are copied into the
      <structname>PGresult</structname>.  (They do not get
      <literal>PGEVT_RESULTCREATE</literal> calls, but see
      <xref linkend="libpq-PQfireResultCreateEvents"/>.)
      Note that <xref linkend="libpq-PQclear"/> should eventually be called
      on the object, just as with a <structname>PGresult</structname>
      returned by <application>libpq</application> itself.
     </para>
________________________________________________________-->
     <para>
      这是<application>libpq</application>内部用于分配并初始化一个空<structname>PGresult</structname>对象的函数。
      如果不能分配内存，那么这个函数返回<symbol>NULL</symbol>。
      它也是可以对外使用的，因为一些应用认为它可以用于产生结果对象（特别是带有错误状态的对象）本身。
      如果<parameter>conn</parameter>非空，并且<parameter>status</parameter>表示一个错误，那么指定连接的当前错误消息会被复制到<structname>PGresult</structname>中。
      如果<parameter>conn</parameter>非空，那么连接中的任何已注册事件过程也会被复制到<structname>PGresult</structname>中（它们不会获得<literal>PGEVT_RESULTCREATE</literal>调用，但会看到<xref linkend="libpq-PQfireResultCreateEvents"/>）。
      注意在该对象上最终应该调用<xref linkend="libpq-PQclear"/>，正如对<application>libpq</application>本身返回的<structname>PGresult</structname>对象所作的那样。
     </para>
<!-- pgdoc-cn_end sig_en=5a7ee00099ff105c96e2b89ed97a3879 -->
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQfireResultCreateEvents">
<!-- pgdoc-cn_start sig_en=1085f28d9329fca0d01cac11a0e36e07 sig_cn_org=None source=14.1 
    <term><function>PQfireResultCreateEvents</function><indexterm><primary>PQfireResultCreateEvents</primary></indexterm></term>
________________________________________________________-->
    <term><function>PQfireResultCreateEvents</function><indexterm><primary>PQfireResultCreateEvents</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=1085f28d9329fca0d01cac11a0e36e07 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=23b0bf416c4beaf0fcd31aad235062d5 sig_cn_org=None source=14.1 
     <para>
      Fires a <literal>PGEVT_RESULTCREATE</literal> event (see <xref
      linkend="libpq-events"/>) for each event procedure registered in the
      <structname>PGresult</structname> object.  Returns non-zero for success,
      zero if any event procedure fails.

<synopsis>
int PQfireResultCreateEvents(PGconn *conn, PGresult *res);
</synopsis>
     </para>
________________________________________________________-->
     <para>
      为每一个在<structname>PGresult</structname>对象中注册的事件过程触发一个<literal>PGEVT_RESULTCREATE</literal>事件（见<xref linkend="libpq-events"/>）。成功时返回非 0，如果任何事件过程失败则返回 0。

<synopsis>
int PQfireResultCreateEvents(PGconn *conn, PGresult *res);
</synopsis>
     </para>
<!-- pgdoc-cn_end sig_en=23b0bf416c4beaf0fcd31aad235062d5 -->

<!-- pgdoc-cn_start sig_en=51bcc51d3995a3791a07439839387849 sig_cn_org=None source=14.1 
     <para>
      The <literal>conn</literal> argument is passed through to event procedures
      but not used directly.  It can be <symbol>NULL</symbol> if the event
      procedures won't use it.
     </para>
________________________________________________________-->
     <para>
      <literal>conn</literal>参数被传送给事件过程，但不会被直接使用。如果事件过程不使用它，则会返回<symbol>NULL</symbol>。
     </para>
<!-- pgdoc-cn_end sig_en=51bcc51d3995a3791a07439839387849 -->

<!-- pgdoc-cn_start sig_en=990231cb3879eaccd032480411faa39f sig_cn_org=None source=14.1 
     <para>
      Event procedures that have already received a
      <literal>PGEVT_RESULTCREATE</literal> or <literal>PGEVT_RESULTCOPY</literal> event
      for this object are not fired again.
     </para>
________________________________________________________-->
     <para>
      已经接收到这个对象的<literal>PGEVT_RESULTCREATE</literal>或<literal>PGEVT_RESULTCOPY</literal>事件的事件过程不会被再次触发。
     </para>
<!-- pgdoc-cn_end sig_en=990231cb3879eaccd032480411faa39f -->

<!-- pgdoc-cn_start sig_en=30742359cb7c2f287b28bdf178305180 sig_cn_org=None source=14.1 
     <para>
      The main reason that this function is separate from
      <xref linkend="libpq-PQmakeEmptyPGresult"/> is that it is often appropriate
      to create a <structname>PGresult</structname> and fill it with data
      before invoking the event procedures.
     </para>
________________________________________________________-->
     <para>
      这个函数与<xref linkend="libpq-PQmakeEmptyPGresult"/>分开的主要原因是在调用事件过程之前创建一个<structname>PGresult</structname>并且填充它常常是合适的。
     </para>
<!-- pgdoc-cn_end sig_en=30742359cb7c2f287b28bdf178305180 -->
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQcopyResult">
<!-- pgdoc-cn_start sig_en=b75e0dcaac73f477288d1252b1fb9105 sig_cn_org=None source=14.1 
    <term><function>PQcopyResult</function><indexterm><primary>PQcopyResult</primary></indexterm></term>
________________________________________________________-->
    <term><function>PQcopyResult</function><indexterm><primary>PQcopyResult</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=b75e0dcaac73f477288d1252b1fb9105 -->

    <listitem>
<!-- pgdoc-cn_start sig_en=ec9193b0839ba27ede2b7b6dd2c21410 sig_cn_org=None source=14.1 
     <para>
      Makes a copy of a <structname>PGresult</structname> object.  The copy is
      not linked to the source result in any way and
      <xref linkend="libpq-PQclear"/> must be called when the copy is no longer
      needed.  If the function fails, <symbol>NULL</symbol> is returned.

<synopsis>
PGresult *PQcopyResult(const PGresult *src, int flags);
</synopsis>
     </para>
________________________________________________________-->
     <para>
      为一个<structname>PGresult</structname>对象创建一个拷贝。
      这个拷贝不会以任何方式链接到源结果，并且当该拷贝不再需要时，必须调用<xref linkend="libpq-PQclear"/>进行清理。如果函数失败，返回<symbol>NULL</symbol>。

<synopsis>
PGresult *PQcopyResult(const PGresult *src, int flags);
</synopsis>
     </para>
<!-- pgdoc-cn_end sig_en=ec9193b0839ba27ede2b7b6dd2c21410 -->

<!-- pgdoc-cn_start sig_en=99a9a31bdb42cdb4b5d27cbf4637b709 sig_cn_org=4fbd938fef1db01e4f0fe4578d9b8594 source=15.7 
     <para>
      This is not intended to make an exact copy.  The returned result is
      always put into <literal>PGRES_TUPLES_OK</literal> status, and does not
      copy any error message in the source.  (It does copy the command status
      string, however.)  The <parameter>flags</parameter> argument determines
      what else is copied.  It is a bitwise OR of several flags.
      <literal>PG_COPYRES_ATTRS</literal> specifies copying the source
      result's attributes (column definitions).
      <literal>PG_COPYRES_TUPLES</literal> specifies copying the source
      result's tuples.  (This implies copying the attributes, too.)
      <literal>PG_COPYRES_NOTICEHOOKS</literal> specifies
      copying the source result's notify hooks.
      <literal>PG_COPYRES_EVENTS</literal> specifies copying the source
      result's events.  (But any instance data associated with the source
      is not copied.)
      The event procedures receive <literal>PGEVT_RESULTCOPY</literal> events.
     </para>
________________________________________________________-->
     <para>
      这不是为了制作一个精确的副本。返回的结果总是放在<literal>PGRES_TUPLES_OK</literal>状态中，并且不复制源中的任何错误消息。
	  （但是会复制命令状态字符串。）<parameter>flags</parameter>参数确定要复制的其他内容。它是几个标志的按位或。
	  <literal>PG_COPYRES_ATTRS</literal>指定复制源结果的属性（列定义）。
	  <literal>PG_COPYRES_TUPLES</literal>指定复制源结果的元组。（这也意味着复制属性。）
	  <literal>PG_COPYRES_NOTICEHOOKS</literal>指定复制源结果的通知钩子。
	  <literal>PG_COPYRES_EVENTS</literal>指定复制源结果的事件。（但不复制与源相关的任何实例数据。）
	  事件程序接收<literal>PGEVT_RESULTCOPY</literal>事件。
     </para>
<!-- pgdoc-cn_end sig_en=99a9a31bdb42cdb4b5d27cbf4637b709 -->
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQsetResultAttrs">
<!-- pgdoc-cn_start sig_en=727b03c14d2b2507ab76bb350622d1c3 sig_cn_org=None source=14.1 
    <term><function>PQsetResultAttrs</function><indexterm><primary>PQsetResultAttrs</primary></indexterm></term>
________________________________________________________-->
    <term><function>PQsetResultAttrs</function><indexterm><primary>PQsetResultAttrs</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=727b03c14d2b2507ab76bb350622d1c3 -->

    <listitem>
<!-- pgdoc-cn_start sig_en=b7dd48695470be9e754a4f3c2ebb6d4f sig_cn_org=None source=14.1 
     <para>
      Sets the attributes of a <structname>PGresult</structname> object.
<synopsis>
int PQsetResultAttrs(PGresult *res, int numAttributes, PGresAttDesc *attDescs);
</synopsis>
     </para>
________________________________________________________-->
     <para>
      设置<structname>PGresult</structname>对象的属性。
<synopsis>
int PQsetResultAttrs(PGresult *res, int numAttributes, PGresAttDesc *attDescs);
</synopsis>
     </para>
<!-- pgdoc-cn_end sig_en=b7dd48695470be9e754a4f3c2ebb6d4f -->

<!-- pgdoc-cn_start sig_en=8cd859934d44568625709fda23ca52a9 sig_cn_org=None source=14.1 
     <para>
      The provided <parameter>attDescs</parameter> are copied into the result.
      If the <parameter>attDescs</parameter> pointer is <symbol>NULL</symbol> or
      <parameter>numAttributes</parameter> is less than one, the request is
      ignored and the function succeeds.  If <parameter>res</parameter>
      already contains attributes, the function will fail.  If the function
      fails, the return value is zero.  If the function succeeds, the return
      value is non-zero.
     </para>
________________________________________________________-->
     <para>
      提供的<parameter>attDescs</parameter>被复制到结果中。如果<parameter>attDescs</parameter>指针为<symbol>NULL</symbol>或<parameter>numAttributes</parameter>小于1，那么请求将被忽略并且函数成功。如果<parameter>res</parameter>已经包含属性，那么函数会失败。如果函数失败，返回值是 0。如果函数成功，返回值是非 0。
     </para>
<!-- pgdoc-cn_end sig_en=8cd859934d44568625709fda23ca52a9 -->
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQsetvalue">
<!-- pgdoc-cn_start sig_en=cf76142ccb8de838aed5d49f61f3aba4 sig_cn_org=None source=14.1 
    <term><function>PQsetvalue</function><indexterm><primary>PQsetvalue</primary></indexterm></term>
________________________________________________________-->
    <term><function>PQsetvalue</function><indexterm><primary>PQsetvalue</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=cf76142ccb8de838aed5d49f61f3aba4 -->

    <listitem>
<!-- pgdoc-cn_start sig_en=5a745dfef9613c1c290cd2d4c40c97d8 sig_cn_org=None source=14.1 
     <para>
      Sets a tuple field value of a <structname>PGresult</structname> object.
<synopsis>
int PQsetvalue(PGresult *res, int tup_num, int field_num, char *value, int len);
</synopsis>
     </para>
________________________________________________________-->
     <para>
      设置一个<structname>PGresult</structname>对象的一个元组域值。
<synopsis>
int PQsetvalue(PGresult *res, int tup_num, int field_num, char *value, int len);
</synopsis>
     </para>
<!-- pgdoc-cn_end sig_en=5a745dfef9613c1c290cd2d4c40c97d8 -->

<!-- pgdoc-cn_start sig_en=2a0ae96e225e0ae70d08de01e4d2961a sig_cn_org=None source=14.1 
     <para>
      The function will automatically grow the result's internal tuples array
      as needed.  However, the <parameter>tup_num</parameter> argument must be
      less than or equal to <xref linkend="libpq-PQntuples"/>, meaning this
      function can only grow the tuples array one tuple at a time.  But any
      field of any existing tuple can be modified in any order.  If a value at
      <parameter>field_num</parameter> already exists, it will be overwritten.
      If <parameter>len</parameter> is -1 or
      <parameter>value</parameter> is <symbol>NULL</symbol>, the field value
      will be set to an SQL null value.  The
      <parameter>value</parameter> is copied into the result's private storage,
      thus is no longer needed after the function
      returns.  If the function fails, the return value is zero.  If the
      function succeeds, the return value is non-zero.
     </para>
________________________________________________________-->
     <para>
      这个函数将自动按需增加结果的内置元组数组。但是，<parameter>tup_num</parameter>参数必须小于等于<xref linkend="libpq-PQntuples"/>，意味着这个函数对元组数组一次只能增加一个元组。
      但已存在的任意元组中的任意域可以以任意顺序进行调整。如果<parameter>field_num</parameter>的一个值已经存在，它会被覆盖。
      如果<parameter>len</parameter>是 -1，或<parameter>value</parameter>是<symbol>NULL</symbol>， 该域值会被设置为一个 SQL 空值。
      <parameter>value</parameter>会被复制到结果的私有存储中，因此函数返回后就不再需要了。如果函数失败，返回值是 0。如果函数成功，返回值会是非 0。
     </para>
<!-- pgdoc-cn_end sig_en=2a0ae96e225e0ae70d08de01e4d2961a -->
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQresultAlloc">
<!-- pgdoc-cn_start sig_en=65a00db31cf91a0055c82eb90932f4c4 sig_cn_org=None source=14.1 
    <term><function>PQresultAlloc</function><indexterm><primary>PQresultAlloc</primary></indexterm></term>
________________________________________________________-->
    <term><function>PQresultAlloc</function><indexterm><primary>PQresultAlloc</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=65a00db31cf91a0055c82eb90932f4c4 -->

    <listitem>
<!-- pgdoc-cn_start sig_en=ef7eab3c1e85894b24310392b6d45540 sig_cn_org=None source=14.1 
     <para>
      Allocate subsidiary storage for a <structname>PGresult</structname> object.
<synopsis>
void *PQresultAlloc(PGresult *res, size_t nBytes);
</synopsis>
     </para>
________________________________________________________-->
     <para>
      为一个<structname>PGresult</structname>对象分配附属存储。
<synopsis>
void *PQresultAlloc(PGresult *res, size_t nBytes);
</synopsis>
     </para>
<!-- pgdoc-cn_end sig_en=ef7eab3c1e85894b24310392b6d45540 -->

<!-- pgdoc-cn_start sig_en=b6d30f88baf3e80febf100980dacf4d6 sig_cn_org=None source=14.1 
     <para>
      Any memory allocated with this function will be freed when
      <parameter>res</parameter> is cleared.  If the function fails,
      the return value is <symbol>NULL</symbol>.  The result is
      guaranteed to be adequately aligned for any type of data,
      just as for <function>malloc</function>.
     </para>
________________________________________________________-->
     <para>
      当<parameter>res</parameter>被清除时，这个函数分配的内存也会被释放掉。如果函数失败，返回值是<symbol>NULL</symbol>。结果被保证为按照数据的任意类型充分地对齐，正如<function>malloc</function>所作的。
     </para>
<!-- pgdoc-cn_end sig_en=b6d30f88baf3e80febf100980dacf4d6 -->
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQresultMemorySize">
<!-- pgdoc-cn_start sig_en=d240d4261eb264ae05939634059324bf sig_cn_org=None source=14.1 
    <term><function>PQresultMemorySize</function><indexterm><primary>PQresultMemorySize</primary></indexterm></term>
________________________________________________________-->
    <term><function>PQresultMemorySize</function><indexterm><primary>PQresultMemorySize</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=d240d4261eb264ae05939634059324bf -->

    <listitem>
<!-- pgdoc-cn_start sig_en=b78586a8c08d2f65f95d0c7cee948979 sig_cn_org=None source=14.1 
     <para>
      Retrieves the number of bytes allocated for
      a <structname>PGresult</structname> object.
<synopsis>
size_t PQresultMemorySize(const PGresult *res);
</synopsis>
     </para>
________________________________________________________-->
     <para>
      检索为<structname>PGresult</structname>对象分配的字节数。
<synopsis>
size_t PQresultMemorySize(const PGresult *res);
</synopsis>
     </para>
<!-- pgdoc-cn_end sig_en=b78586a8c08d2f65f95d0c7cee948979 -->

<!-- pgdoc-cn_start sig_en=b35421b06a48f125adc47333c191afba sig_cn_org=None source=14.1 
     <para>
      This value is the sum of all <function>malloc</function> requests
      associated with the <structname>PGresult</structname> object, that is,
      all the space that will be freed by <xref linkend="libpq-PQclear"/>.
      This information can be useful for managing memory consumption.
     </para>
________________________________________________________-->
     <para>
      此值是与<structname>PGresult</structname>对象关联的所有<function>malloc</function>请求的总和，就是说，<xref linkend="libpq-PQclear"/>将释放的所有空间。此信息可用于管理内存消耗。
     </para>
<!-- pgdoc-cn_end sig_en=b35421b06a48f125adc47333c191afba -->
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQlibVersion">
<!-- pgdoc-cn_start sig_en=281b8d15ec162e936e89f313e73f6520 sig_cn_org=None source=14.1 
    <term><function>PQlibVersion</function><indexterm
    ><primary>PQlibVersion</primary><seealso>PQserverVersion</seealso></indexterm></term>
________________________________________________________-->
    <term><function>PQlibVersion</function><indexterm
    ><primary>PQlibVersion</primary><seealso>PQserverVersion</seealso></indexterm></term>
<!-- pgdoc-cn_end sig_en=281b8d15ec162e936e89f313e73f6520 -->

    <listitem>
<!-- pgdoc-cn_start sig_en=4f2ed52848d8d906b23cf0891f01b409 sig_cn_org=None source=14.1 
     <para>
      Return the version of <productname>libpq</productname> that is being used.
<synopsis>
int PQlibVersion(void);
</synopsis>
     </para>
________________________________________________________-->
     <para>
      返回所使用的<productname>libpq</productname>版本。
<synopsis>
int PQlibVersion(void);
</synopsis>
     </para>
<!-- pgdoc-cn_end sig_en=4f2ed52848d8d906b23cf0891f01b409 -->

<!-- pgdoc-cn_start sig_en=78cf0a5e80e920a4aca96319a089fae9 sig_cn_org=None source=14.1 
     <para>
      The result of this function can be used to determine, at
      run time, whether specific functionality is available in the currently
      loaded version of libpq. The function can be used, for example,
      to determine which connection options are available in
      <xref linkend="libpq-PQconnectdb"/>.
     </para>
________________________________________________________-->
     <para>
      在运行时，这个函数的结果可以被用来决定在当前已载入的 libpq 版本中特定的功能是否可用。
      例如，这个函数可以被用来决定哪些选项可以被用于<xref linkend="libpq-PQconnectdb"/>。
     </para>
<!-- pgdoc-cn_end sig_en=78cf0a5e80e920a4aca96319a089fae9 -->

<!-- pgdoc-cn_start sig_en=97d0dba5b620c44a09421d1bf30204d3 sig_cn_org=None source=14.1 
     <para>
      The result is formed by multiplying the library's major version
      number by 10000 and adding the minor version number.  For example,
      version 10.1 will be returned as 100001, and version 11.0 will be
      returned as 110000.
     </para>
________________________________________________________-->
     <para>
      结果通过将库的主版本号乘以10000再加上次版本号形成。例如，版本10.1将被返回为100001，而版本11.0将被返回为110000。
     </para>
<!-- pgdoc-cn_end sig_en=97d0dba5b620c44a09421d1bf30204d3 -->

<!-- pgdoc-cn_start sig_en=e14d7dca56b44a1ab94d0b5094c59dea sig_cn_org=None source=14.1 
     <para>
      Prior to major version 10, <productname>PostgreSQL</productname> used
      three-part version numbers in which the first two parts together
      represented the major version.  For those
      versions, <xref linkend="libpq-PQlibVersion"/> uses two digits for each
      part; for example version 9.1.5 will be returned as 90105, and
      version 9.2.0 will be returned as 90200.
     </para>
________________________________________________________-->
     <para>
      在主版本10之前，<productname>PostgreSQL</productname>采用一种由三个部分组成的版本号，其中前两部分共同表示主版本。
      对于那些版本，<xref linkend="libpq-PQlibVersion"/>为每个部分使用两个数字，例如版本9.1.5将被返回为90105，而版本9.2.0将被返回为90200。
     </para>
<!-- pgdoc-cn_end sig_en=e14d7dca56b44a1ab94d0b5094c59dea -->

<!-- pgdoc-cn_start sig_en=1bb941e85ed820a85adbfdbd5fd1a30d sig_cn_org=None source=14.1 
     <para>
      Therefore, for purposes of determining feature compatibility,
      applications should divide the result of <xref linkend="libpq-PQlibVersion"/>
      by 100 not 10000 to determine a logical major version number.
      In all release series, only the last two digits differ between
      minor releases (bug-fix releases).
     </para>
________________________________________________________-->
     <para>
      因此，出于判断特性兼容性的目的，应用应该将<xref linkend="libpq-PQlibVersion"/>的结果除以100而不是10000来判断逻辑的主版本号。
      在所有的发行序列中，只有最后两个数字在次发行（问题修正发行）之间不同。
     </para>
<!-- pgdoc-cn_end sig_en=1bb941e85ed820a85adbfdbd5fd1a30d -->

     <note>
<!-- pgdoc-cn_start sig_en=e1c08c7872c5ffa7af42d2ff88ec1782 sig_cn_org=None source=14.1 
      <para>
       This function appeared in <productname>PostgreSQL</productname> version 9.1, so
       it cannot be used to detect required functionality in earlier
       versions, since calling it will create a link dependency
       on version 9.1 or later.
      </para>
________________________________________________________-->
      <para>
       这个函数出现于<productname>PostgreSQL</productname>版本 9.1，因此它不能被用来在早期的版本中检测所需的功能，因为调用它将会创建一个对版本9.1及其后版本的链接依赖。
      </para>
<!-- pgdoc-cn_end sig_en=e1c08c7872c5ffa7af42d2ff88ec1782 -->
     </note>
    </listitem>
   </varlistentry>

  </variablelist>

 </sect1>

 <sect1 id="libpq-notice-processing">
<!-- pgdoc-cn_start sig_en=5b941aa523278dee22a5bd91bef7f3fb sig_cn_org=None source=14.1 
  <title>Notice Processing</title>
________________________________________________________-->
  <title>通知处理</title>
<!-- pgdoc-cn_end sig_en=5b941aa523278dee22a5bd91bef7f3fb -->

<!-- pgdoc-cn_start sig_en=af3391ece6b790fecfa99f41120d9755 sig_cn_org=None source=14.1 
  <indexterm zone="libpq-notice-processing">
   <primary>notice processing</primary>
   <secondary>in libpq</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="libpq-notice-processing">
   <primary>notice processing</primary>
   <secondary>in libpq</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=af3391ece6b790fecfa99f41120d9755 -->

<!-- pgdoc-cn_start sig_en=db00bbea31b5b9fb61952bcb612af970 sig_cn_org=None source=14.1 
  <para>
   Notice and warning messages generated by the server are not returned
   by the query execution functions, since they do not imply failure of
   the query.  Instead they are passed to a notice handling function, and
   execution continues normally after the handler returns.  The default
   notice handling function prints the message on
   <filename>stderr</filename>, but the application can override this
   behavior by supplying its own handling function.
  </para>
________________________________________________________-->
  <para>
   服务器产生的通知和警告消息不会被查询执行函数返回，因为它们不代表查询失败。它们可以被传递给一个通知处理函数，并且在处理者返回后执行会继续正常进行。默认的处理函数会把消息打印在<filename>stderr</filename>上，但是应用可以通过提供它自己的处理函数来重载这种行为。
  </para>
<!-- pgdoc-cn_end sig_en=db00bbea31b5b9fb61952bcb612af970 -->

<!-- pgdoc-cn_start sig_en=daee4020f30a44266c60dfb4697eef53 sig_cn_org=None source=14.1 
  <para>
   For historical reasons, there are two levels of notice handling, called
   the notice receiver and notice processor.  The default behavior is for
   the notice receiver to format the notice and pass a string to the notice
   processor for printing.  However, an application that chooses to provide
   its own notice receiver will typically ignore the notice processor
   layer and just do all the work in the notice receiver.
  </para>
________________________________________________________-->
  <para>
   由于历史原因，通知处理有两个级别，称为通知接收器和通知处理器。通知接收器的默认行为是格式化通知并且将一个字符串传递给通知处理器来打印。不过，如果一个应用选择提供自己的通知接收器，它通常会忽略通知处理器层并且在通知接收器中完成所有工作。
  </para>
<!-- pgdoc-cn_end sig_en=daee4020f30a44266c60dfb4697eef53 -->

<!-- pgdoc-cn_start sig_en=f5cef2d695d3818f5d28a4ebc24adf7c sig_cn_org=None source=14.1 
  <para>
   The function <function id="libpq-PQsetNoticeReceiver">PQsetNoticeReceiver</function>
   <indexterm><primary>notice receiver</primary></indexterm>
   <indexterm><primary>PQsetNoticeReceiver</primary></indexterm> sets or
   examines the current notice receiver for a connection object.
   Similarly, <function id="libpq-PQsetNoticeProcessor">PQsetNoticeProcessor</function>
   <indexterm><primary>notice processor</primary></indexterm>
   <indexterm><primary>PQsetNoticeProcessor</primary></indexterm> sets or
   examines the current notice processor.

<synopsis>
typedef void (*PQnoticeReceiver) (void *arg, const PGresult *res);

PQnoticeReceiver
PQsetNoticeReceiver(PGconn *conn,
                    PQnoticeReceiver proc,
                    void *arg);

typedef void (*PQnoticeProcessor) (void *arg, const char *message);

PQnoticeProcessor
PQsetNoticeProcessor(PGconn *conn,
                     PQnoticeProcessor proc,
                     void *arg);
</synopsis>

   Each of these functions returns the previous notice receiver or
   processor function pointer, and sets the new value.  If you supply a
   null function pointer, no action is taken, but the current pointer is
   returned.
  </para>
________________________________________________________-->
  <para>
   函数<function id="libpq-PQsetNoticeReceiver">PQsetNoticeReceiver</function>
   <indexterm><primary>notice receiver</primary></indexterm>
   <indexterm><primary>PQsetNoticeReceiver</primary></indexterm>为一个连接对象设置或者检查当前的通知接收器。
   相似地，<function id="libpq-PQsetNoticeProcessor">PQsetNoticeProcessor</function>
   <indexterm><primary>notice processor</primary></indexterm>
   <indexterm><primary>PQsetNoticeProcessor</primary></indexterm>设置或检查当前的通知处理器。

<synopsis>
typedef void (*PQnoticeReceiver) (void *arg, const PGresult *res);

PQnoticeReceiver
PQsetNoticeReceiver(PGconn *conn,
                    PQnoticeReceiver proc,
                    void *arg);

typedef void (*PQnoticeProcessor) (void *arg, const char *message);

PQnoticeProcessor
PQsetNoticeProcessor(PGconn *conn,
                     PQnoticeProcessor proc,
                     void *arg);
</synopsis>

   这些函数中的每一个会返回之前的通知接收器或处理器函数指针，并且设置新值。如果你提供了一个空函数指针，将不会采取任何动作，只会返回当前指针。
  </para>
<!-- pgdoc-cn_end sig_en=f5cef2d695d3818f5d28a4ebc24adf7c -->

<!-- pgdoc-cn_start sig_en=551e62e2447e37263d6c3ab268bc1338 sig_cn_org=None source=14.1 
  <para>
   When a notice or warning message is received from the server, or
   generated internally by <application>libpq</application>, the notice
   receiver function is called.  It is passed the message in the form of
   a <symbol>PGRES_NONFATAL_ERROR</symbol>
   <structname>PGresult</structname>.  (This allows the receiver to extract
   individual fields using <xref linkend="libpq-PQresultErrorField"/>, or obtain a
   complete preformatted message using <xref linkend="libpq-PQresultErrorMessage"/>
   or <xref linkend="libpq-PQresultVerboseErrorMessage"/>.)  The same
   void pointer passed to <function>PQsetNoticeReceiver</function> is also
   passed.  (This pointer can be used to access application-specific state
   if needed.)
  </para>
________________________________________________________-->
  <para>
   当接收到一个服务器产生的或者<application>libpq</application>内部产生的通知或警告消息，通知接收器函数会被调用。
   它会以一种<symbol>PGRES_NONFATAL_ERROR</symbol> <structname>PGresult</structname>的形式传递该消息
   （这允许接收器使用<xref linkend="libpq-PQresultErrorField"/>抽取个别的域，或者使用<xref linkend="libpq-PQresultErrorMessage"/>或者<xref linkend="libpq-PQresultVerboseErrorMessage"/>得到一个完整的预格式化的消息）。
   被传递给<function>PQsetNoticeReceiver</function>的同一个空指针也被传递（必要时，这个指针可以被用来访问应用相关的状态）。
  </para>
<!-- pgdoc-cn_end sig_en=551e62e2447e37263d6c3ab268bc1338 -->

<!-- pgdoc-cn_start sig_en=22fb45a8d66b904f65dc7111dc4a9808 sig_cn_org=None source=14.1 
  <para>
   The default notice receiver simply extracts the message (using
   <xref linkend="libpq-PQresultErrorMessage"/>) and passes it to the notice
   processor.
  </para>
________________________________________________________-->
  <para>
   默认的通知接收器会简单地抽取消息（使用<xref linkend="libpq-PQresultErrorMessage"/>）并且将它传递给通知处理器。
  </para>
<!-- pgdoc-cn_end sig_en=22fb45a8d66b904f65dc7111dc4a9808 -->

<!-- pgdoc-cn_start sig_en=7090201d4b7d119fb42a54bed88c7fd3 sig_cn_org=None source=14.1 
  <para>
   The notice processor is responsible for handling a notice or warning
   message given in text form.  It is passed the string text of the message
   (including a trailing newline), plus a void pointer that is the same
   one passed to <function>PQsetNoticeProcessor</function>.  (This pointer
   can be used to access application-specific state if needed.)
  </para>
________________________________________________________-->
  <para>
   通知处理器负责处理一个以文本形式给出的通知或警告消息。该消息的字符串文本（包括一个收尾的新行）被传递给通知处理器，外加一个同时被传递给<function>PQsetNoticeProcessor</function>的空指针（必要时，这个指针可以被用来访问应用相关的状态）。
  </para>
<!-- pgdoc-cn_end sig_en=7090201d4b7d119fb42a54bed88c7fd3 -->

<!-- pgdoc-cn_start sig_en=a72ec6430e2e0ec037ccb7e97d655bd6 sig_cn_org=None source=14.1 
  <para>
   The default notice processor is simply:
<programlisting>
static void
defaultNoticeProcessor(void *arg, const char *message)
{
    fprintf(stderr, "%s", message);
}
</programlisting>
  </para>
________________________________________________________-->
  <para>
   默认的通知处理器很简单：
<programlisting>
static void
defaultNoticeProcessor(void *arg, const char *message)
{
    fprintf(stderr, "%s", message);
}
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=a72ec6430e2e0ec037ccb7e97d655bd6 -->

<!-- pgdoc-cn_start sig_en=e6a71c1c669c9e2a65020cc834ec90f7 sig_cn_org=None source=14.1 
  <para>
   Once you have set a notice receiver or processor, you should expect
   that that function could be called as long as either the
   <structname>PGconn</structname> object or <structname>PGresult</structname> objects made
   from it exist.  At creation of a <structname>PGresult</structname>, the
   <structname>PGconn</structname>'s current notice handling pointers are copied
   into the <structname>PGresult</structname> for possible use by functions like
   <xref linkend="libpq-PQgetvalue"/>.
  </para>
________________________________________________________-->
  <para>
   一旦你设定了一个通知接收器或处理器，你应该期待只要<structname>PGconn</structname>对象或者从它构造出的<structname>PGresult</structname>对象存在，该函数就应该能被调用。
   在一个<structname>PGresult</structname>创建时，<structname>PGconn</structname>的当前通知处理指针被复制到<structname>PGresult</structname>中，以备类似<xref linkend="libpq-PQgetvalue"/>的函数使用。
  </para>
<!-- pgdoc-cn_end sig_en=e6a71c1c669c9e2a65020cc834ec90f7 -->

 </sect1>

 <sect1 id="libpq-events">
<!-- pgdoc-cn_start sig_en=7648f2e63e486e0eda69d98738ab046d sig_cn_org=None source=14.1 
  <title>Event System</title>
________________________________________________________-->
  <title>事件系统</title>
<!-- pgdoc-cn_end sig_en=7648f2e63e486e0eda69d98738ab046d -->

<!-- pgdoc-cn_start sig_en=fa4e5bf40a879d13c7076029dcdb011c sig_cn_org=None source=14.1 
  <para>
   <application>libpq</application>'s event system is designed to notify
   registered event handlers about interesting
   <application>libpq</application> events, such as the creation or
   destruction of <structname>PGconn</structname> and
   <structname>PGresult</structname> objects.  A principal use case is that
   this allows applications to associate their own data with a
   <structname>PGconn</structname> or <structname>PGresult</structname>
   and ensure that that data is freed at an appropriate time.
  </para>
________________________________________________________-->
  <para>
   <application>libpq</application>的事件系统被设计为通知已注册的事件处理器它感兴趣的<application>libpq</application>事件，例如<structname>PGconn</structname>以及<structname>PGresult</structname>对象的创建和毁灭。一种主要的使用情况是这允许应用将自己的数据与一个<structname>PGconn</structname>或者<structname>PGresult</structname>关联在一起，并且确保那些数据在适当的时候被释放。
  </para>
<!-- pgdoc-cn_end sig_en=fa4e5bf40a879d13c7076029dcdb011c -->

<!-- pgdoc-cn_start sig_en=8a29efd6e54fccd326b47495b95a9de4 sig_cn_org=cc497c341fe1865715c530a9556228d0 source=15.7 
  <para>
   Each registered event handler is associated with two pieces of data,
   known to <application>libpq</application> only as opaque <literal>void *</literal>
   pointers.  There is a <firstterm>pass-through</firstterm> pointer that is provided
   by the application when the event handler is registered with a
   <structname>PGconn</structname>.  The pass-through pointer never changes for the
   life of the <structname>PGconn</structname> and all <structname>PGresult</structname>s
   generated from it; so if used, it must point to long-lived data.
   In addition there is an <firstterm>instance data</firstterm> pointer, which starts
   out <symbol>NULL</symbol> in every <structname>PGconn</structname> and <structname>PGresult</structname>.
   This pointer can be manipulated using the
   <xref linkend="libpq-PQinstanceData"/>,
   <xref linkend="libpq-PQsetInstanceData"/>,
   <xref linkend="libpq-PQresultInstanceData"/> and
   <xref linkend="libpq-PQresultSetInstanceData"/> functions.  Note that
   unlike the pass-through pointer, instance data of a <structname>PGconn</structname>
   is not automatically inherited by <structname>PGresult</structname>s created from
   it.  <application>libpq</application> does not know what pass-through
   and instance data pointers point to (if anything) and will never attempt
   to free them &mdash; that is the responsibility of the event handler.
  </para>
________________________________________________________-->
  <para>
   每个注册的事件处理程序都与两个数据相关联，<application>libpq</application>仅将其视为不透明的<literal>void *</literal>指针。
   有一个<firstterm>透传</firstterm>指针，当事件处理程序与<structname>PGconn</structname>注册时，应用程序提供。
   透传指针在<structname>PGconn</structname>及其生成的所有<structname>PGresult</structname>的生命周期内永远不会更改；
   因此，如果使用，它必须指向长期存在的数据。
   此外，还有一个<firstterm>实例数据</firstterm>指针，在每个<structname>PGconn</structname>和<structname>PGresult</structname>中一开始都是<symbol>NULL</symbol>。
   可以使用<xref linkend="libpq-PQinstanceData"/>、<xref linkend="libpq-PQsetInstanceData"/>、
   <xref linkend="libpq-PQresultInstanceData"/>和<xref linkend="libpq-PQresultSetInstanceData"/>函数来操作此指针。
   请注意，与透传指针不同，<structname>PGconn</structname>的实例数据不会自动继承到从中创建的<structname>PGresult</structname>。
   <application>libpq</application>不知道透传和实例数据指针指向的内容（如果有的话），也永远不会尝试释放它们 —— 这是事件处理程序的责任。
</para>
<!-- pgdoc-cn_end sig_en=8a29efd6e54fccd326b47495b95a9de4 -->

  <sect2 id="libpq-events-types">
<!-- pgdoc-cn_start sig_en=45b79f38e148defdc4e086d3e7dd2c26 sig_cn_org=None source=14.1 
   <title>Event Types</title>
________________________________________________________-->
   <title>事件类型</title>
<!-- pgdoc-cn_end sig_en=45b79f38e148defdc4e086d3e7dd2c26 -->

<!-- pgdoc-cn_start sig_en=38a774693adc9a9c6e67cb79cd346edf sig_cn_org=None source=14.1 
   <para>
    The enum <literal>PGEventId</literal> names the types of events handled by
    the event system.  All its values have names beginning with
    <literal>PGEVT</literal>.  For each event type, there is a corresponding
    event info structure that carries the parameters passed to the event
    handlers.  The event types are:
   </para>
________________________________________________________-->
   <para>
    枚举<literal>PGEventId</literal>命名了事件系统处理的事件类型。它的所有值的名称都以<literal>PGEVT</literal>开始。对于每一种事件类型，都有一个相应的事件信息结构用来承载传递给事件处理器的参数。事件类型是：
   </para>
<!-- pgdoc-cn_end sig_en=38a774693adc9a9c6e67cb79cd346edf -->

   <variablelist>
    <varlistentry id="libpq-pgevt-register">
     <term><literal>PGEVT_REGISTER</literal></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=5b7c47e0eff2aaa28fcefd7c4372e7c2 sig_cn_org=a96f17919e7ddae3728cb15fedc560a7 source=15.7 
      <para>
       The register event occurs when <xref linkend="libpq-PQregisterEventProc"/>
       is called.  It is the ideal time to initialize any
       <literal>instanceData</literal> an event procedure may need.  Only one
       register event will be fired per event handler per connection.  If the
       event procedure fails (returns zero), the registration is cancelled.

<synopsis>
typedef struct
{
    PGconn *conn;
} PGEventRegister;
</synopsis>

       When a <literal>PGEVT_REGISTER</literal> event is received, the
       <parameter>evtInfo</parameter> pointer should be cast to a
       <structname>PGEventRegister *</structname>.  This structure contains a
       <structname>PGconn</structname> that should be in the
       <literal>CONNECTION_OK</literal> status; guaranteed if one calls
       <xref linkend="libpq-PQregisterEventProc"/> right after obtaining a good
       <structname>PGconn</structname>.  When returning a failure code, all
       cleanup must be performed as no <literal>PGEVT_CONNDESTROY</literal>
       event will be sent.
      </para>
________________________________________________________-->
      <para>
       注册事件发生在调用<xref linkend="libpq-PQregisterEventProc"/>时。这是初始化任何事件过程可能需要的<literal>instanceData</literal>的理想时间。每个事件处理程序每个连接只会触发一次注册事件。如果事件过程失败（返回零），注册将被取消。

<synopsis>
typedef struct
{
    PGconn *conn;
} PGEventRegister;
</synopsis>

       当接收到<literal>PGEVT_REGISTER</literal>事件时，<parameter>evtInfo</parameter>指针应该转换为<structname>PGEventRegister *</structname>。这个结构包含一个应该处于<literal>CONNECTION_OK</literal>状态的<structname>PGconn</structname>；如果在获得一个良好的<structname>PGconn</structname>后立即调用<xref linkend="libpq-PQregisterEventProc"/>，则保证这一点。当返回一个失败代码时，所有清理工作必须完成，因为不会发送任何<literal>PGEVT_CONNDESTROY</literal>事件。
      </para>
<!-- pgdoc-cn_end sig_en=5b7c47e0eff2aaa28fcefd7c4372e7c2 -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pgevt-connreset">
     <term><literal>PGEVT_CONNRESET</literal></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=8cc7304ea86dd605c2925f284db4f27c sig_cn_org=cdc679c399406b042bf5cba0f82c8915 source=15.7 
      <para>
       The connection reset event is fired on completion of
       <xref linkend="libpq-PQreset"/> or <function>PQresetPoll</function>.  In
       both cases, the event is only fired if the reset was successful.
       The return value of the event procedure is ignored
       in <productname>PostgreSQL</productname> v15 and later.
       With earlier versions, however, it's important to return success
       (nonzero) or the connection will be aborted.

<synopsis>
typedef struct
{
    PGconn *conn;
} PGEventConnReset;
</synopsis>

       When a <literal>PGEVT_CONNRESET</literal> event is received, the
       <parameter>evtInfo</parameter> pointer should be cast to a
       <structname>PGEventConnReset *</structname>.  Although the contained
       <structname>PGconn</structname> was just reset, all event data remains
       unchanged.  This event should be used to reset/reload/requery any
       associated <literal>instanceData</literal>.  Note that even if the
       event procedure fails to process <literal>PGEVT_CONNRESET</literal>, it will
       still receive a <literal>PGEVT_CONNDESTROY</literal> event when the connection
       is closed.
      </para>
________________________________________________________-->
      <para>
       连接重置事件在完成<xref linkend="libpq-PQreset"/>或<function>PQresetPoll</function>后触发。
       在这两种情况下，只有在重置成功时才会触发事件。
       在<productname>PostgreSQL</productname> v15及更高版本中，事件过程的返回值将被忽略。
       然而，在早期版本中，重要的是返回成功（非零），否则连接将被中止。

<synopsis>
typedef struct
{
    PGconn *conn;
} PGEventConnReset;
</synopsis>

       当接收到<literal>PGEVT_CONNRESET</literal>事件时，<parameter>evtInfo</parameter>指针应转换为<structname>PGEventConnReset *</structname>。
       尽管包含的<structname>PGconn</structname>刚刚被重置，但所有事件数据仍保持不变。
       此事件应用于重置/重新加载/重新查询任何相关的<literal>instanceData</literal>。
       请注意，即使事件过程未能处理<literal>PGEVT_CONNRESET</literal>，当连接关闭时仍会收到<literal>PGEVT_CONNDESTROY</literal>事件。
      </para>
<!-- pgdoc-cn_end sig_en=8cc7304ea86dd605c2925f284db4f27c -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pgevt-conndestroy">
     <term><literal>PGEVT_CONNDESTROY</literal></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=3d4aaf3be1d63dfd094106159ff0ac15 sig_cn_org=None source=14.1 
      <para>
       The connection destroy event is fired in response to
       <xref linkend="libpq-PQfinish"/>.  It is the event procedure's
       responsibility to properly clean up its event data as libpq has no
       ability to manage this memory.  Failure to clean up will lead
       to memory leaks.

<synopsis>
typedef struct
{
    PGconn *conn;
} PGEventConnDestroy;
</synopsis>

       When a <literal>PGEVT_CONNDESTROY</literal> event is received, the
       <parameter>evtInfo</parameter> pointer should be cast to a
       <structname>PGEventConnDestroy *</structname>.  This event is fired
       prior to <xref linkend="libpq-PQfinish"/> performing any other cleanup.
       The return value of the event procedure is ignored since there is no
       way of indicating a failure from <xref linkend="libpq-PQfinish"/>.  Also,
       an event procedure failure should not abort the process of cleaning up
       unwanted memory.
      </para>
________________________________________________________-->
      <para>
       为了响应<xref linkend="libpq-PQfinish"/>，连接销毁事件会被触发。由于 libpq 没有能力管理事件数据，事件过程有责任正确地清理它的事件数据。清理失败将会导致内存泄露。

<synopsis>
typedef struct
{
    PGconn *conn;
} PGEventConnDestroy;
</synopsis>

       当接收到一个<literal>PGEVT_CONNDESTROY</literal>事件时，<parameter>evtInfo</parameter>指针应该被造型为<structname>PGEventConnDestroy *</structname>。
       这个事件在<xref linkend="libpq-PQfinish"/>执行任何其他清理之前被触发。
       该事件过程的返回值被忽略，因为没有办法指示一个来自<xref linkend="libpq-PQfinish"/>的失败。还有，一个事件过程失败不该中断对不需要的内存的清理。
      </para>
<!-- pgdoc-cn_end sig_en=3d4aaf3be1d63dfd094106159ff0ac15 -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pgevt-resultcreate">
     <term><literal>PGEVT_RESULTCREATE</literal></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=626297a768fe49ee8a31d17b9ff9d7aa sig_cn_org=e750d3994e13873a20b3a5cf61e70bc8 source=15.7 
      <para>
       The result creation event is fired in response to any query execution
       function that generates a result, including
       <xref linkend="libpq-PQgetResult"/>.  This event will only be fired after
       the result has been created successfully.

<synopsis>
typedef struct
{
    PGconn *conn;
    PGresult *result;
} PGEventResultCreate;
</synopsis>

       When a <literal>PGEVT_RESULTCREATE</literal> event is received, the
       <parameter>evtInfo</parameter> pointer should be cast to a
       <structname>PGEventResultCreate *</structname>.  The
       <parameter>conn</parameter> is the connection used to generate the
       result.  This is the ideal place to initialize any
       <literal>instanceData</literal> that needs to be associated with the
       result.  If an event procedure fails (returns zero), that event
       procedure will be ignored for the remaining lifetime of the result;
       that is, it will not receive <literal>PGEVT_RESULTCOPY</literal>
       or <literal>PGEVT_RESULTDESTROY</literal> events for this result or
       results copied from it.
      </para>
________________________________________________________-->
      <para>
       结果创建事件是响应任何生成结果的查询执行函数而触发的，包括
       <xref linkend="libpq-PQgetResult"/>。此事件只会在结果成功创建后触发。

<synopsis>
typedef struct
{
    PGconn *conn;
    PGresult *result;
} PGEventResultCreate;
</synopsis>

       当接收到<literal>PGEVT_RESULTCREATE</literal>事件时，
       应将<parameter>evtInfo</parameter>指针转换为
       <structname>PGEventResultCreate *</structname>。 
       <parameter>conn</parameter>是用于生成结果的连接。
       这是初始化需要与结果关联的任何<literal>instanceData</literal>的理想位置。
       如果事件过程失败（返回零），那么该事件过程将在结果的剩余生命周期内被忽略；
       也就是说，它将不会接收到针对此结果或从中复制的结果的
       <literal>PGEVT_RESULTCOPY</literal>或<literal>PGEVT_RESULTDESTROY</literal>事件。
      </para>
<!-- pgdoc-cn_end sig_en=626297a768fe49ee8a31d17b9ff9d7aa -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pgevt-resultcopy">
     <term><literal>PGEVT_RESULTCOPY</literal></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=3029b67eb996b3b183b956fbe3f1a8f9 sig_cn_org=d4c2ae20bc172e2454177640e2e2cf0d source=15.7 
      <para>
       The result copy event is fired in response to
       <xref linkend="libpq-PQcopyResult"/>.  This event will only be fired after
       the copy is complete.  Only event procedures that have
       successfully handled the <literal>PGEVT_RESULTCREATE</literal>
       or <literal>PGEVT_RESULTCOPY</literal> event for the source result
       will receive <literal>PGEVT_RESULTCOPY</literal> events.

<synopsis>
typedef struct
{
    const PGresult *src;
    PGresult *dest;
} PGEventResultCopy;
</synopsis>

       When a <literal>PGEVT_RESULTCOPY</literal> event is received, the
       <parameter>evtInfo</parameter> pointer should be cast to a
       <structname>PGEventResultCopy *</structname>.  The
       <parameter>src</parameter> result is what was copied while the
       <parameter>dest</parameter> result is the copy destination.  This event
       can be used to provide a deep copy of <literal>instanceData</literal>,
       since <literal>PQcopyResult</literal> cannot do that.  If an event
       procedure fails (returns zero), that event procedure will be
       ignored for the remaining lifetime of the new result; that is, it
       will not receive <literal>PGEVT_RESULTCOPY</literal>
       or <literal>PGEVT_RESULTDESTROY</literal> events for that result or
       results copied from it.
      </para>
________________________________________________________-->
      <para>
       结果复制事件是响应于<xref linkend="libpq-PQcopyResult"/>而触发的。此事件仅在复制完成后触发。
       只有成功处理源结果的<literal>PGEVT_RESULTCREATE</literal>或<literal>PGEVT_RESULTCOPY</literal>事件的事件过程才会接收<literal>PGEVT_RESULTCOPY</literal>事件。

<synopsis>
typedef struct
{
    const PGresult *src;
    PGresult *dest;
} PGEventResultCopy;
</synopsis>

       当接收到<literal>PGEVT_RESULTCOPY</literal>事件时，<parameter>evtInfo</parameter>指针应转换为<structname>PGEventResultCopy *</structname>。
       <parameter>src</parameter>结果是被复制的内容，而<parameter>dest</parameter>结果是复制的目标。此事件可用于提供<literal>instanceData</literal>的深度复制，因为<literal>PQcopyResult</literal>无法做到这一点。
       如果事件过程失败（返回零），那个事件过程将在新结果的剩余生命周期内被忽略；也就是说，它将不会接收<literal>PGEVT_RESULTCOPY</literal>或<literal>PGEVT_RESULTDESTROY</literal>事件，无论是针对该结果还是针对从中复制的结果。
      </para>
<!-- pgdoc-cn_end sig_en=3029b67eb996b3b183b956fbe3f1a8f9 -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pgevt-resultdestroy">
     <term><literal>PGEVT_RESULTDESTROY</literal></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=710149c928f7e6630c7e0455d329d63e sig_cn_org=None source=14.1 
      <para>
       The result destroy event is fired in response to a
       <xref linkend="libpq-PQclear"/>.  It is the event procedure's
       responsibility to properly clean up its event data as libpq has no
       ability to manage this memory.  Failure to clean up will lead
       to memory leaks.

<synopsis>
typedef struct
{
    PGresult *result;
} PGEventResultDestroy;
</synopsis>

       When a <literal>PGEVT_RESULTDESTROY</literal> event is received, the
       <parameter>evtInfo</parameter> pointer should be cast to a
       <structname>PGEventResultDestroy *</structname>.  This event is fired
       prior to <xref linkend="libpq-PQclear"/> performing any other cleanup.
       The return value of the event procedure is ignored since there is no
       way of indicating a failure from <xref linkend="libpq-PQclear"/>.  Also,
       an event procedure failure should not abort the process of cleaning up
       unwanted memory.
      </para>
________________________________________________________-->
      <para>
       为了响应<xref linkend="libpq-PQclear"/>，结果销毁事件会被触发。由于 libpq 没有能力管理事件数据，事件过程有责任正确地清理它的事件数据。清理失败将会导致内存泄露。

<synopsis>
typedef struct
{
    PGresult *result;
} PGEventResultDestroy;
</synopsis>

       当接收到一个<literal>PGEVT_RESULTDESTROY</literal>事件时，<parameter>evtInfo</parameter>指针应该被造型为<structname>PGEventResultDestroy *</structname>。
       这个事件在<xref linkend="libpq-PQclear"/>执行任何其他清理之前被触发。该事件过程的返回值被忽略，因为没有办法指示来自<xref linkend="libpq-PQclear"/>的失败。
       还有，一个事件过程失败不该中断不需要的内存的清理过程。
      </para>
<!-- pgdoc-cn_end sig_en=710149c928f7e6630c7e0455d329d63e -->
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 id="libpq-events-proc">
<!-- pgdoc-cn_start sig_en=689c1c5298488739c3503a5b29fa1f9d sig_cn_org=None source=14.1 
   <title>Event Callback Procedure</title>
________________________________________________________-->
   <title>事件回调函数</title>
<!-- pgdoc-cn_end sig_en=689c1c5298488739c3503a5b29fa1f9d -->

   <variablelist>
    <varlistentry id="libpq-PGEventProc">
<!-- pgdoc-cn_start sig_en=bad70fd20ff7d5d4234f702ecd8cf4cc sig_cn_org=None source=14.1 
     <term><literal>PGEventProc</literal><indexterm><primary>PGEventProc</primary></indexterm></term>
________________________________________________________-->
     <term><literal>PGEventProc</literal><indexterm><primary>PGEventProc</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=bad70fd20ff7d5d4234f702ecd8cf4cc -->

     <listitem>
<!-- pgdoc-cn_start sig_en=0615ff454139b2af8cf6e77e6c64cd40 sig_cn_org=None source=14.1 
      <para>
       <literal>PGEventProc</literal> is a typedef for a pointer to an
       event procedure, that is, the user callback function that receives
       events from libpq.  The signature of an event procedure must be

<synopsis>
int eventproc(PGEventId evtId, void *evtInfo, void *passThrough)
</synopsis>

       The <parameter>evtId</parameter> parameter indicates which
       <literal>PGEVT</literal> event occurred.  The
       <parameter>evtInfo</parameter> pointer must be cast to the appropriate
       structure type to obtain further information about the event.
       The <parameter>passThrough</parameter> parameter is the pointer
       provided to <xref linkend="libpq-PQregisterEventProc"/> when the event
       procedure was registered.  The function should return a non-zero value
       if it succeeds and zero if it fails.
      </para>
________________________________________________________-->
      <para>
       <literal>PGEventProc</literal>是到一个事件过程的指针的 typedef，也就是从 libpq 接收事件的用户回调函数。一个事件过程的原型必须是

<synopsis>
int eventproc(PGEventId evtId, void *evtInfo, void *passThrough)
</synopsis>

       <parameter>evtId</parameter>指示发生了哪一个<literal>PGEVT</literal>事件。
       <parameter>evtInfo</parameter>指针必须被造型为合适的结构类型才能获得关于事件的进一步信息。
       当事件过程已被注册时，<parameter>passThrough</parameter>参数是提供给<xref linkend="libpq-PQregisterEventProc"/>的指针。
       如果成功，该函数应该返回非零值，失败则返回零。
      </para>
<!-- pgdoc-cn_end sig_en=0615ff454139b2af8cf6e77e6c64cd40 -->

<!-- pgdoc-cn_start sig_en=cf0efed6f79bc895f32f446411ed7b52 sig_cn_org=None source=14.1 
      <para>
       A particular event procedure can be registered only once in any
       <structname>PGconn</structname>.  This is because the address of the procedure
       is used as a lookup key to identify the associated instance data.
      </para>
________________________________________________________-->
      <para>
       在任何一个<structname>PGconn</structname>中，一个特定事件过程只能被注册一次。这是因为该过程的地址被用作查找键来标识相关的实例数据。
      </para>
<!-- pgdoc-cn_end sig_en=cf0efed6f79bc895f32f446411ed7b52 -->

      <caution>
<!-- pgdoc-cn_start sig_en=ea3da47cf4d510d27760ef1ad85a3129 sig_cn_org=None source=14.1 
       <para>
        On Windows, functions can have two different addresses: one visible
        from outside a DLL and another visible from inside the DLL.  One
        should be careful that only one of these addresses is used with
        <application>libpq</application>'s event-procedure functions, else confusion will
        result.  The simplest rule for writing code that will work is to
        ensure that event procedures are declared <literal>static</literal>.  If the
        procedure's address must be available outside its own source file,
        expose a separate function to return the address.
       </para>
________________________________________________________-->
       <para>
        在 Windows 上，函数能够有两个不同的地址：一个对 DLL 之外可见而另一个对 DLL 之内可见。我们应当小心只有其中之一会被用于<application>libpq</application>的事件过程函数，否则将会产生混淆。编写代码的最简单规则是将所有的事件过程声明为<literal>static</literal>。如果过程的地址必须对它自己的源代码文件之外可见，提供一个单独的函数来返回该地址。
       </para>
<!-- pgdoc-cn_end sig_en=ea3da47cf4d510d27760ef1ad85a3129 -->
      </caution>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 id="libpq-events-funcs">
<!-- pgdoc-cn_start sig_en=d591bbd95d67304220309cfa4e80be99 sig_cn_org=None source=14.1 
   <title>Event Support Functions</title>
________________________________________________________-->
   <title>事件支持函数</title>
<!-- pgdoc-cn_end sig_en=d591bbd95d67304220309cfa4e80be99 -->

    <variablelist>
    <varlistentry id="libpq-PQregisterEventProc">
<!-- pgdoc-cn_start sig_en=a04f73f3d0cf7bab8fcb67d21b652490 sig_cn_org=None source=14.1 
     <term><function>PQregisterEventProc</function><indexterm><primary>PQregisterEventProc</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQregisterEventProc</function><indexterm><primary>PQregisterEventProc</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=a04f73f3d0cf7bab8fcb67d21b652490 -->

     <listitem>
<!-- pgdoc-cn_start sig_en=cf14465a816ddab09a031d237a1f387a sig_cn_org=None source=14.1 
      <para>
       Registers an event callback procedure with libpq.

<synopsis>
int PQregisterEventProc(PGconn *conn, PGEventProc proc,
                        const char *name, void *passThrough);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       为 libpq 注册一个事件回调过程。

<synopsis>
int PQregisterEventProc(PGconn *conn, PGEventProc proc,
                        const char *name, void *passThrough);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=cf14465a816ddab09a031d237a1f387a -->

<!-- pgdoc-cn_start sig_en=c8f2344f6b3b7bcdd4773345a1864835 sig_cn_org=None source=14.1 
      <para>
       An event procedure must be registered once on each
       <structname>PGconn</structname> you want to receive events about.  There is no
       limit, other than memory, on the number of event procedures that
       can be registered with a connection.  The function returns a non-zero
       value if it succeeds and zero if it fails.
      </para>
________________________________________________________-->
      <para>
       在每一个你想要接收事件的<structname>PGconn</structname>上必须注册一个事件过程。和内存不同，没有限制说一个连接上能注册多少个事件过程。如果该函数成功，它会返回一个非零值。如果它失败，则会返回零。
      </para>
<!-- pgdoc-cn_end sig_en=c8f2344f6b3b7bcdd4773345a1864835 -->

<!-- pgdoc-cn_start sig_en=ac93ff8f0bf783b479596a747ad8ed8e sig_cn_org=None source=14.1 
      <para>
       The <parameter>proc</parameter> argument will be called when a libpq
       event is fired.  Its memory address is also used to lookup
       <literal>instanceData</literal>.  The <parameter>name</parameter>
       argument is used to refer to the event procedure in error messages.
       This value cannot be <symbol>NULL</symbol> or a zero-length string.  The name string is
       copied into the <structname>PGconn</structname>, so what is passed need not be
       long-lived.  The <parameter>passThrough</parameter> pointer is passed
       to the <parameter>proc</parameter> whenever an event occurs. This
       argument can be <symbol>NULL</symbol>.
      </para>
________________________________________________________-->
      <para>
       当一个 libpq 事件被触发时，<parameter>proc</parameter>参数将被调用。它的内存地址也被用来查找<literal>instanceData</literal>。<parameter>name</parameter>参数被用来在错误消息中引用该事件过程。这个值不能是<symbol>NULL</symbol>或一个零长度串。名字串被复制到<structname>PGconn</structname>中，因此传递进来的东西不需要长期存在。当一个事件发生时，<parameter>passThrough</parameter>指针被传递给<parameter>proc</parameter>。这个参数可以是<symbol>NULL</symbol>。
      </para>
<!-- pgdoc-cn_end sig_en=ac93ff8f0bf783b479596a747ad8ed8e -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQsetInstanceData">
<!-- pgdoc-cn_start sig_en=00d4b97777c0787346994bc8013cfd8a sig_cn_org=None source=14.1 
     <term><function>PQsetInstanceData</function><indexterm><primary>PQsetInstanceData</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQsetInstanceData</function><indexterm><primary>PQsetInstanceData</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=00d4b97777c0787346994bc8013cfd8a -->
     <listitem>
<!-- pgdoc-cn_start sig_en=3724b40c306933500f724a42b81bb324 sig_cn_org=None source=14.1 
      <para>
       Sets the connection <parameter>conn</parameter>'s <literal>instanceData</literal>
       for procedure <parameter>proc</parameter> to <parameter>data</parameter>.  This
       returns non-zero for success and zero for failure.  (Failure is
       only possible if <parameter>proc</parameter> has not been properly
       registered in <parameter>conn</parameter>.)

<synopsis>
int PQsetInstanceData(PGconn *conn, PGEventProc proc, void *data);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       设置连接<parameter>conn</parameter>的用于过程<parameter>proc</parameter>的<literal>instanceData</literal>为<parameter>data</parameter>。它在成功时返回非零值，失败时返回零（只有<parameter>proc</parameter>没有被正确地注册在<parameter>conn</parameter>中，才可能会失败）。

<synopsis>
int PQsetInstanceData(PGconn *conn, PGEventProc proc, void *data);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=3724b40c306933500f724a42b81bb324 -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQinstanceData">
<!-- pgdoc-cn_start sig_en=938264fb96dd029f2d4776695523ec5c sig_cn_org=None source=14.1 
     <term><function>PQinstanceData</function><indexterm><primary>PQinstanceData</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQinstanceData</function><indexterm><primary>PQinstanceData</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=938264fb96dd029f2d4776695523ec5c -->
     <listitem>
<!-- pgdoc-cn_start sig_en=c19b809b63618af168b15f60179d6ba9 sig_cn_org=None source=14.1 
      <para>
       Returns the
       connection <parameter>conn</parameter>'s <literal>instanceData</literal>
       associated with procedure <parameter>proc</parameter>,
       or <symbol>NULL</symbol> if there is none.

<synopsis>
void *PQinstanceData(const PGconn *conn, PGEventProc proc);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       返回连接<parameter>conn</parameter>的与过程<parameter>proc</parameter>相关的<literal>instanceData</literal>，如果没有则返回<symbol>NULL</symbol>。

<synopsis>
void *PQinstanceData(const PGconn *conn, PGEventProc proc);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=c19b809b63618af168b15f60179d6ba9 -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQresultSetInstanceData">
<!-- pgdoc-cn_start sig_en=c8b0827b333d2b65521b63ea13dd1e82 sig_cn_org=None source=14.1 
     <term><function>PQresultSetInstanceData</function><indexterm><primary>PQresultSetInstanceData</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQresultSetInstanceData</function><indexterm><primary>PQresultSetInstanceData</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=c8b0827b333d2b65521b63ea13dd1e82 -->
     <listitem>
<!-- pgdoc-cn_start sig_en=926aa05e78e0191f330e0123e56e0761 sig_cn_org=None source=14.1 
      <para>
       Sets the result's <literal>instanceData</literal>
       for <parameter>proc</parameter> to <parameter>data</parameter>.  This returns
       non-zero for success and zero for failure.  (Failure is only
       possible if <parameter>proc</parameter> has not been properly registered
       in the result.)

<synopsis>
int PQresultSetInstanceData(PGresult *res, PGEventProc proc, void *data);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       把结果的用于<parameter>proc</parameter>的<literal>instanceData</literal>设置为<parameter>data</parameter>。成功返回非零，失败返回零（只有<parameter>proc</parameter>没有被正确地注册在<parameter>conn</parameter>中，才可能会失败）。

<synopsis>
int PQresultSetInstanceData(PGresult *res, PGEventProc proc, void *data);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=926aa05e78e0191f330e0123e56e0761 -->

<!-- pgdoc-cn_start sig_en=4d518a2e1c0582d1cb6d8ac1b208259d sig_cn_org=None source=14.1 
      <para>
       Beware that any storage represented by <parameter>data</parameter>
       will not be accounted for by <xref linkend="libpq-PQresultMemorySize"/>,
       unless it is allocated using <xref linkend="libpq-PQresultAlloc"/>.
       (Doing so is recommendable because it eliminates the need to free
       such storage explicitly when the result is destroyed.)
      </para>
________________________________________________________-->
      <para>
       请注意，<parameter>data</parameter>表示的任何存储都不会由<xref linkend="libpq-PQresultMemorySize"/>考虑，除非使用<xref linkend="libpq-PQresultAlloc"/>分配。
       （这样做是值得推荐的，因为它消除了在销毁结果时显式释放此类存储的需要。）
      </para>
<!-- pgdoc-cn_end sig_en=4d518a2e1c0582d1cb6d8ac1b208259d -->
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQresultInstanceData">
<!-- pgdoc-cn_start sig_en=62836503e01e1be22a551e1cd489f019 sig_cn_org=None source=14.1 
     <term><function>PQresultInstanceData</function><indexterm><primary>PQresultInstanceData</primary></indexterm></term>
________________________________________________________-->
     <term><function>PQresultInstanceData</function><indexterm><primary>PQresultInstanceData</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=62836503e01e1be22a551e1cd489f019 -->
     <listitem>
<!-- pgdoc-cn_start sig_en=6b55f110df9db21fcd5dd6fe63fca996 sig_cn_org=None source=14.1 
      <para>
       Returns the result's <literal>instanceData</literal> associated with <parameter>proc</parameter>, or <symbol>NULL</symbol>
       if there is none.

<synopsis>
void *PQresultInstanceData(const PGresult *res, PGEventProc proc);
</synopsis>
      </para>
________________________________________________________-->
      <para>
       返回结果的与过程<parameter>proc</parameter>相关的<literal>instanceData</literal>，如果没有则返回<symbol>NULL</symbol>。

<synopsis>
void *PQresultInstanceData(const PGresult *res, PGEventProc proc);
</synopsis>
      </para>
<!-- pgdoc-cn_end sig_en=6b55f110df9db21fcd5dd6fe63fca996 -->
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 id="libpq-events-example">
<!-- pgdoc-cn_start sig_en=fd88397a1658fa2f88c77367f50a99fb sig_cn_org=None source=14.1 
   <title>Event Example</title>
________________________________________________________-->
   <title>事件实例</title>
<!-- pgdoc-cn_end sig_en=fd88397a1658fa2f88c77367f50a99fb -->

<!-- pgdoc-cn_start sig_en=242c0b9dfa1d73a42d8c72d909df181e sig_cn_org=None source=14.1 
   <para>
    Here is a skeleton example of managing private data associated with
    libpq connections and results.
   </para>
________________________________________________________-->
   <para>
    这里是一个管理与 libpq 连接和结果相关的私有数据的例子的框架。
   </para>
<!-- pgdoc-cn_end sig_en=242c0b9dfa1d73a42d8c72d909df181e -->

<programlisting>
<![CDATA[
/* required header for libpq events (note: includes libpq-fe.h) */
#include <libpq-events.h>

/* The instanceData */
typedef struct
{
    int n;
    char *str;
} mydata;

/* PGEventProc */
static int myEventProc(PGEventId evtId, void *evtInfo, void *passThrough);

int
main(void)
{
    mydata *data;
    PGresult *res;
    PGconn *conn =
        PQconnectdb("dbname=postgres options=-csearch_path=");

    if (PQstatus(conn) != CONNECTION_OK)
    {
        /* PQerrorMessage's result includes a trailing newline */
        fprintf(stderr, "%s", PQerrorMessage(conn));
        PQfinish(conn);
        return 1;
    }

    /* called once on any connection that should receive events.
     * Sends a PGEVT_REGISTER to myEventProc.
     */
    if (!PQregisterEventProc(conn, myEventProc, "mydata_proc", NULL))
    {
        fprintf(stderr, "Cannot register PGEventProc\n");
        PQfinish(conn);
        return 1;
    }

    /* conn instanceData is available */
    data = PQinstanceData(conn, myEventProc);

    /* Sends a PGEVT_RESULTCREATE to myEventProc */
    res = PQexec(conn, "SELECT 1 + 1");

    /* result instanceData is available */
    data = PQresultInstanceData(res, myEventProc);

    /* If PG_COPYRES_EVENTS is used, sends a PGEVT_RESULTCOPY to myEventProc */
    res_copy = PQcopyResult(res, PG_COPYRES_TUPLES | PG_COPYRES_EVENTS);

    /* result instanceData is available if PG_COPYRES_EVENTS was
     * used during the PQcopyResult call.
     */
    data = PQresultInstanceData(res_copy, myEventProc);

    /* Both clears send a PGEVT_RESULTDESTROY to myEventProc */
    PQclear(res);
    PQclear(res_copy);

    /* Sends a PGEVT_CONNDESTROY to myEventProc */
    PQfinish(conn);

    return 0;
}

static int
myEventProc(PGEventId evtId, void *evtInfo, void *passThrough)
{
    switch (evtId)
    {
        case PGEVT_REGISTER:
        {
            PGEventRegister *e = (PGEventRegister *)evtInfo;
            mydata *data = get_mydata(e->conn);

            /* associate app specific data with connection */
            PQsetInstanceData(e->conn, myEventProc, data);
            break;
        }

        case PGEVT_CONNRESET:
        {
            PGEventConnReset *e = (PGEventConnReset *)evtInfo;
            mydata *data = PQinstanceData(e->conn, myEventProc);

            if (data)
              memset(data, 0, sizeof(mydata));
            break;
        }

        case PGEVT_CONNDESTROY:
        {
            PGEventConnDestroy *e = (PGEventConnDestroy *)evtInfo;
            mydata *data = PQinstanceData(e->conn, myEventProc);

            /* free instance data because the conn is being destroyed */
            if (data)
              free_mydata(data);
            break;
        }

        case PGEVT_RESULTCREATE:
        {
            PGEventResultCreate *e = (PGEventResultCreate *)evtInfo;
            mydata *conn_data = PQinstanceData(e->conn, myEventProc);
            mydata *res_data = dup_mydata(conn_data);

            /* associate app specific data with result (copy it from conn) */
            PQresultSetInstanceData(e->result, myEventProc, res_data);
            break;
        }

        case PGEVT_RESULTCOPY:
        {
            PGEventResultCopy *e = (PGEventResultCopy *)evtInfo;
            mydata *src_data = PQresultInstanceData(e->src, myEventProc);
            mydata *dest_data = dup_mydata(src_data);

            /* associate app specific data with result (copy it from a result) */
            PQresultSetInstanceData(e->dest, myEventProc, dest_data);
            break;
        }

        case PGEVT_RESULTDESTROY:
        {
            PGEventResultDestroy *e = (PGEventResultDestroy *)evtInfo;
            mydata *data = PQresultInstanceData(e->result, myEventProc);

            /* free instance data because the result is being destroyed */
            if (data)
              free_mydata(data);
            break;
        }

        /* unknown event ID, just return true. */
        default:
            break;
    }

    return true; /* event processing succeeded */
}
]]>
</programlisting>
  </sect2>
 </sect1>

 <sect1 id="libpq-envars">
<!-- pgdoc-cn_start sig_en=d820450d6ca30f50cdab74296def074e sig_cn_org=None source=14.1 
  <title>Environment Variables</title>
________________________________________________________-->
  <title>环境变量</title>
<!-- pgdoc-cn_end sig_en=d820450d6ca30f50cdab74296def074e -->

<!-- pgdoc-cn_start sig_en=86ad3fc66ebe9cca5339fba6b962ef39 sig_cn_org=None source=14.1 
  <indexterm zone="libpq-envars">
   <primary>environment variable</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="libpq-envars">
   <primary>环境变量</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=86ad3fc66ebe9cca5339fba6b962ef39 -->

<!-- pgdoc-cn_start sig_en=cc6aa74d2ff2d10d139125caadf0885d sig_cn_org=2339c534c726569e19abbc653f85969b source=15.7 
  <para>
   The following environment variables can be used to select default
   connection parameter values, which will be used by
   <xref linkend="libpq-PQconnectdb"/>, <xref linkend="libpq-PQsetdbLogin"/> and
   <xref linkend="libpq-PQsetdb"/> if no value is directly specified by the calling
   code.  These are useful to avoid hard-coding database connection
   information into simple client applications, for example.

   <itemizedlist>
    <listitem>
________________________________________________________-->
  <para>
  以下环境变量可用于选择默认连接参数值，这些值将被<xref linkend="libpq-PQconnectdb"/>，<xref linkend="libpq-PQsetdbLogin"/>和<xref linkend="libpq-PQsetdb"/>使用，如果调用代码没有直接指定值。这些对于避免将数据库连接信息硬编码到简单的客户端应用程序中非常有用，例如。

   <itemizedlist>
    <listitem>
<!-- pgdoc-cn_end sig_en=cc6aa74d2ff2d10d139125caadf0885d -->
<!-- pgdoc-cn_start sig_en=4e1f3473e26619744be5465011b0b012 sig_cn_org=8c5d0e45d9cfb904d6c4c6d72c4e6af3 source=15.7 
     <para>
      <indexterm>
       <primary><envar>PGHOST</envar></primary>
      </indexterm>
      <envar>PGHOST</envar> behaves the same as the <xref
      linkend="libpq-connect-host"/> connection parameter.
     </para>
________________________________________________________-->
     <para>
      <indexterm>
       <primary><envar>PGHOST</envar></primary>
      </indexterm>
      <envar>PGHOST</envar>的行为与<xref
      linkend="libpq-connect-host"/>连接参数相同。
     </para>
<!-- pgdoc-cn_end sig_en=4e1f3473e26619744be5465011b0b012 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=7af864a0cff24fe406bce5f5fbf2442c sig_cn_org=6ce805d29ddcc2d796e91f50825673a7 source=15.7 
     <para>
      <indexterm>
       <primary><envar>PGHOSTADDR</envar></primary>
      </indexterm>
      <envar>PGHOSTADDR</envar> behaves the same as the <xref
      linkend="libpq-connect-hostaddr"/> connection parameter.
      This can be set instead of or in addition to <envar>PGHOST</envar>
      to avoid DNS lookup overhead.
     </para>
________________________________________________________-->
     <para>
      <indexterm>
       <primary><envar>PGHOSTADDR</envar></primary>
      </indexterm>
      <envar>PGHOSTADDR</envar>的行为与<xref
      linkend="libpq-connect-hostaddr"/>连接参数相同。
      这可以替代或者与<envar>PGHOST</envar>一起设置，以避免DNS查找开销。
     </para>
<!-- pgdoc-cn_end sig_en=7af864a0cff24fe406bce5f5fbf2442c -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=f87bda89a15b424a5063fecbd4ab6fa3 sig_cn_org=26bd29ec00ea1754ad75f4d51ef0ce47 source=15.7 
     <para>
      <indexterm>
       <primary><envar>PGPORT</envar></primary>
      </indexterm>
      <envar>PGPORT</envar> behaves the same as the <xref
      linkend="libpq-connect-port"/> connection parameter.
     </para>
________________________________________________________-->
     <para>
      <indexterm>
       <primary><envar>PGPORT</envar></primary>
      </indexterm>
      <envar>PGPORT</envar>的行为与<xref
      linkend="libpq-connect-port"/>连接参数相同。
     </para>
<!-- pgdoc-cn_end sig_en=f87bda89a15b424a5063fecbd4ab6fa3 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=bff84320133678c5b0e9d58b384de867 sig_cn_org=0b5cc97a824ff6c86141c49f6eb40b1f source=15.7 
     <para>
      <indexterm>
       <primary><envar>PGDATABASE</envar></primary>
      </indexterm>
      <envar>PGDATABASE</envar> behaves the same as the <xref
      linkend="libpq-connect-dbname"/> connection parameter.
      </para>
________________________________________________________-->
     <para>
      <indexterm>
       <primary><envar>PGDATABASE</envar></primary>
      </indexterm>
      <envar>PGDATABASE</envar>的行为与<xref
      linkend="libpq-connect-dbname"/>连接参数相同。
      </para>
<!-- pgdoc-cn_end sig_en=bff84320133678c5b0e9d58b384de867 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=f5aaecafc22a010ad71102c7f8d771b6 sig_cn_org=6632081fe4873e675ebd42dcd6911e42 source=15.7 
     <para>
      <indexterm>
       <primary><envar>PGUSER</envar></primary>
      </indexterm>
      <envar>PGUSER</envar> behaves the same as the <xref
      linkend="libpq-connect-user"/> connection parameter.
     </para>
________________________________________________________-->
     <para>
      <indexterm>
       <primary><envar>PGUSER</envar></primary>
      </indexterm>
      <envar>PGUSER</envar>的行为与<xref
      linkend="libpq-connect-user"/>连接参数相同。
     </para>
<!-- pgdoc-cn_end sig_en=f5aaecafc22a010ad71102c7f8d771b6 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=0844baee54783b2be12f9280ee051959 sig_cn_org=a5ff6a78a641d646e5cbc0a6655a45cd source=15.7 
     <para>
      <indexterm>
       <primary><envar>PGPASSWORD</envar></primary>
      </indexterm>
      <envar>PGPASSWORD</envar> behaves the same as the <xref
      linkend="libpq-connect-password"/> connection parameter.
      Use of this environment variable
      is not recommended for security reasons, as some operating systems
      allow non-root users to see process environment variables via
      <application>ps</application>; instead consider using a password file
      (see <xref linkend="libpq-pgpass"/>).
     </para>
________________________________________________________-->
     <para>
      <indexterm>
       <primary><envar>PGPASSWORD</envar></primary>
      </indexterm>
      <envar>PGPASSWORD</envar>的行为与<xref linkend="libpq-connect-password"/>连接参数相同。
      出于安全原因，不建议使用此环境变量，因为一些操作系统允许非root用户通过<application>ps</application>查看进程环境变量；
      而应考虑使用密码文件（参见<xref linkend="libpq-pgpass"/>）。
     </para>
<!-- pgdoc-cn_end sig_en=0844baee54783b2be12f9280ee051959 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=2d77d9bc1cba3fe75b9ffe9e4faad6ff sig_cn_org=c112e7dee56fe11c49fd29f1cb7be639 source=15.7 
     <para>
      <indexterm>
       <primary><envar>PGPASSFILE</envar></primary>
      </indexterm>
      <envar>PGPASSFILE</envar> behaves the same as the <xref
      linkend="libpq-connect-passfile"/> connection parameter.
     </para>
________________________________________________________-->
     <para>
      <indexterm>
       <primary><envar>PGPASSFILE</envar></primary>
      </indexterm>
      <envar>PGPASSFILE</envar>的行为与<xref
      linkend="libpq-connect-passfile"/>连接参数相同。
     </para>
<!-- pgdoc-cn_end sig_en=2d77d9bc1cba3fe75b9ffe9e4faad6ff -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=52125337afd2dae422e864b94e4e03c8 sig_cn_org=32dccb516b93cd8115d9aa267281fc04 source=15.7 
     <para>
      <indexterm>
       <primary><envar>PGCHANNELBINDING</envar></primary>
      </indexterm>
      <envar>PGCHANNELBINDING</envar> behaves the same as the <xref
      linkend="libpq-connect-channel-binding"/> connection parameter.
     </para>
________________________________________________________-->
     <para>
      <indexterm>
       <primary><envar>PGCHANNELBINDING</envar></primary>
      </indexterm>
      <envar>PGCHANNELBINDING</envar>的行为与<xref
      linkend="libpq-connect-channel-binding"/>连接参数相同。
     </para>
<!-- pgdoc-cn_end sig_en=52125337afd2dae422e864b94e4e03c8 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=3c9746aaaa0b4a311ca72cf0d9ffbd5e sig_cn_org=32c053883f77a19667cad38d5f26aeb2 source=15.7 
     <para>
      <indexterm>
       <primary><envar>PGSERVICE</envar></primary>
      </indexterm>
      <envar>PGSERVICE</envar> behaves the same as the <xref
      linkend="libpq-connect-service"/> connection parameter.
     </para>
________________________________________________________-->
     <para>
      <indexterm>
       <primary><envar>PGSERVICE</envar></primary>
      </indexterm>
      <envar>PGSERVICE</envar>的行为与<xref
      linkend="libpq-connect-service"/>连接参数相同。
     </para>
<!-- pgdoc-cn_end sig_en=3c9746aaaa0b4a311ca72cf0d9ffbd5e -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=6a2134f1f122dc3505cb6df869c33e06 sig_cn_org=110e02177a1a5e0e4bc6f1ef805c0eec source=15.7 
     <para>
      <indexterm>
       <primary><envar>PGSERVICEFILE</envar></primary>
      </indexterm>
      <envar>PGSERVICEFILE</envar> specifies the name of the per-user
      connection service file
      (see <xref linkend="libpq-pgservice"/>).
      Defaults to <filename>~/.pg_service.conf</filename>, or
      <filename>%APPDATA%\postgresql\.pg_service.conf</filename> on
      Microsoft Windows.
     </para>
________________________________________________________-->
     <para>
      <indexterm>
       <primary><envar>PGSERVICEFILE</envar></primary>
      </indexterm>
      <envar>PGSERVICEFILE</envar>指定每个用户的连接服务文件的名称
      (参见<xref linkend="libpq-pgservice"/>)。
      默认为<filename>~/.pg_service.conf</filename>，或者在Microsoft Windows上为<filename>%APPDATA%\postgresql\.pg_service.conf</filename>。
     </para>
<!-- pgdoc-cn_end sig_en=6a2134f1f122dc3505cb6df869c33e06 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=d46b1a058915678f50789b40772bc08c sig_cn_org=fe4e25b8072282ab9b9db4a84d7d73f2 source=15.7 
     <para>
      <indexterm>
       <primary><envar>PGOPTIONS</envar></primary>
      </indexterm>
      <envar>PGOPTIONS</envar> behaves the same as the <xref
      linkend="libpq-connect-options"/> connection parameter.
     </para>
________________________________________________________-->
     <para>
      <indexterm>
       <primary><envar>PGOPTIONS</envar></primary>
      </indexterm>
      <envar>PGOPTIONS</envar>的行为与<xref
      linkend="libpq-connect-options"/>连接参数相同。
     </para>
<!-- pgdoc-cn_end sig_en=d46b1a058915678f50789b40772bc08c -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=6604ce379df679c060964d77a22c3730 sig_cn_org=7c44dcde5ada75a75dfbdfe9cf1adad9 source=15.7 
     <para>
      <indexterm>
       <primary><envar>PGAPPNAME</envar></primary>
      </indexterm>
      <envar>PGAPPNAME</envar> behaves the same as the <xref
      linkend="libpq-connect-application-name"/> connection parameter.
     </para>
________________________________________________________-->
     <para>
      <indexterm>
       <primary><envar>PGAPPNAME</envar></primary>
      </indexterm>
      <envar>PGAPPNAME</envar>的行为与<xref
      linkend="libpq-connect-application-name"/>连接参数相同。
     </para>
<!-- pgdoc-cn_end sig_en=6604ce379df679c060964d77a22c3730 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=f28406ad9d9466d1b283a40c63d5b5ba sig_cn_org=1ab9188b0082cf3f65a750c90b16efc3 source=15.7 
     <para>
      <indexterm>
       <primary><envar>PGSSLMODE</envar></primary>
      </indexterm>
      <envar>PGSSLMODE</envar> behaves the same as the <xref
      linkend="libpq-connect-sslmode"/> connection parameter.
     </para>
________________________________________________________-->
     <para>
      <indexterm>
       <primary><envar>PGSSLMODE</envar></primary>
      </indexterm>
      <envar>PGSSLMODE</envar>的行为与<xref
      linkend="libpq-connect-sslmode"/>连接参数相同。
     </para>
<!-- pgdoc-cn_end sig_en=f28406ad9d9466d1b283a40c63d5b5ba -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=9c3f152e61f598b29bd62408617ffdb5 sig_cn_org=8097a84e1078857212bdab5da379a8b2 source=15.7 
     <para>
      <indexterm>
       <primary><envar>PGREQUIRESSL</envar></primary>
      </indexterm>
      <envar>PGREQUIRESSL</envar> behaves the same as the <xref
      linkend="libpq-connect-requiressl"/> connection parameter.
      This environment variable is deprecated in favor of the
      <envar>PGSSLMODE</envar> variable; setting both variables suppresses the
      effect of this one.
     </para>
________________________________________________________-->
     <para>
      <indexterm>
       <primary><envar>PGREQUIRESSL</envar></primary>
      </indexterm>
      <envar>PGREQUIRESSL</envar>的行为与<xref
      linkend="libpq-connect-requiressl"/>连接参数相同。
      这个环境变量已被弃用，推荐使用<envar>PGSSLMODE</envar>变量；设置这两个变量会抑制这个变量的效果。
     </para>
<!-- pgdoc-cn_end sig_en=9c3f152e61f598b29bd62408617ffdb5 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=e8f97b96023089931643002325dbf313 sig_cn_org=336045c2129842e47c234aebadc2df6e source=15.7 
     <para>
      <indexterm>
       <primary><envar>PGSSLCOMPRESSION</envar></primary>
      </indexterm>
      <envar>PGSSLCOMPRESSION</envar> behaves the same as the <xref
      linkend="libpq-connect-sslcompression"/> connection parameter.
     </para>
________________________________________________________-->
     <para>
      <indexterm>
       <primary><envar>PGSSLCOMPRESSION</envar></primary>
      </indexterm>
      <envar>PGSSLCOMPRESSION</envar>的行为与<xref
      linkend="libpq-connect-sslcompression"/>连接参数相同。
     </para>
<!-- pgdoc-cn_end sig_en=e8f97b96023089931643002325dbf313 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=cb6e4a0ebe345418484dedde1fcbc836 sig_cn_org=3cd8ec7f8aa862d8f924de6d05fc99ae source=15.7 
     <para>
      <indexterm>
       <primary><envar>PGSSLCERT</envar></primary>
      </indexterm>
      <envar>PGSSLCERT</envar> behaves the same as the <xref
      linkend="libpq-connect-sslcert"/> connection parameter.
     </para>
________________________________________________________-->
     <para>
      <indexterm>
       <primary><envar>PGSSLCERT</envar></primary>
      </indexterm>
      <envar>PGSSLCERT</envar>的行为与<xref
      linkend="libpq-connect-sslcert"/>连接参数相同。
     </para>
<!-- pgdoc-cn_end sig_en=cb6e4a0ebe345418484dedde1fcbc836 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=d195f85066bb690071f3ffc1a2ab8b17 sig_cn_org=9b051c8655af5a5ba23b96c613a717c2 source=15.7 
     <para>
      <indexterm>
       <primary><envar>PGSSLKEY</envar></primary>
      </indexterm>
      <envar>PGSSLKEY</envar> behaves the same as the <xref
      linkend="libpq-connect-sslkey"/> connection parameter.
     </para>
________________________________________________________-->
     <para>
      <indexterm>
       <primary><envar>PGSSLKEY</envar></primary>
      </indexterm>
      <envar>PGSSLKEY</envar>的行为与<xref
      linkend="libpq-connect-sslkey"/>连接参数相同。
     </para>
<!-- pgdoc-cn_end sig_en=d195f85066bb690071f3ffc1a2ab8b17 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=76b7dcd82bbc5638a76f9c251a025616 sig_cn_org=c3bf038f3497e770f2464e67cff96cce source=15.7 
     <para>
      <indexterm>
       <primary><envar>PGSSLROOTCERT</envar></primary>
      </indexterm>
      <envar>PGSSLROOTCERT</envar>  behaves the same as the <xref
      linkend="libpq-connect-sslrootcert"/> connection parameter.
     </para>
________________________________________________________-->
     <para>
      <indexterm>
       <primary><envar>PGSSLROOTCERT</envar></primary>
      </indexterm>
      <envar>PGSSLROOTCERT</envar> 表现与<xref
      linkend="libpq-connect-sslrootcert"/>连接参数相同。
     </para>
<!-- pgdoc-cn_end sig_en=76b7dcd82bbc5638a76f9c251a025616 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=1c5aa28d11ddd53988903661591ce86f sig_cn_org=946afd21bc89f0cfdf21f22779bbbddd source=15.7 
     <para>
      <indexterm>
       <primary><envar>PGSSLCRL</envar></primary>
      </indexterm>
      <envar>PGSSLCRL</envar>  behaves the same as the <xref
      linkend="libpq-connect-sslcrl"/> connection parameter.
     </para>
________________________________________________________-->
     <para>
      <indexterm>
       <primary><envar>PGSSLCRL</envar></primary>
      </indexterm>
      <envar>PGSSLCRL</envar> 表现与<xref
      linkend="libpq-connect-sslcrl"/>连接参数相同。
     </para>
<!-- pgdoc-cn_end sig_en=1c5aa28d11ddd53988903661591ce86f -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=d7665696bebd7b1ab18de07c49a4011b sig_cn_org=997624b9af413695977465b1b2547e1b source=15.7 
     <para>
      <indexterm>
       <primary><envar>PGSSLCRLDIR</envar></primary>
      </indexterm>
      <envar>PGSSLCRLDIR</envar> behaves the same as the <xref
      linkend="libpq-connect-sslcrldir"/> connection parameter.
     </para>
________________________________________________________-->
     <para>
      <indexterm>
       <primary><envar>PGSSLCRLDIR</envar></primary>
      </indexterm>
      <envar>PGSSLCRLDIR</envar>的行为与<xref
      linkend="libpq-connect-sslcrldir"/>连接参数相同。
     </para>
<!-- pgdoc-cn_end sig_en=d7665696bebd7b1ab18de07c49a4011b -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=389eae5f1dc37a1ae009aa4aedf268f0 sig_cn_org=4d8a3c8ec5d20fb3d5eb573baa69f6d4 source=15.7 
     <para>
      <indexterm>
       <primary><envar>PGSSLSNI</envar></primary>
      </indexterm>
      <envar>PGSSLSNI</envar>  behaves the same as the <xref
      linkend="libpq-connect-sslsni"/> connection parameter.
     </para>
________________________________________________________-->
     <para>
      <indexterm>
       <primary><envar>PGSSLSNI</envar></primary>
      </indexterm>
      <envar>PGSSLSNI</envar> 表现与<xref
      linkend="libpq-connect-sslsni"/>连接参数相同。
     </para>
<!-- pgdoc-cn_end sig_en=389eae5f1dc37a1ae009aa4aedf268f0 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=3a8e154b3bc47bffb342a8f1ed859b17 sig_cn_org=1c1942cef3a348bb75eda8aa409a3546 source=15.7 
     <para>
      <indexterm>
       <primary><envar>PGREQUIREPEER</envar></primary>
      </indexterm>
      <envar>PGREQUIREPEER</envar> behaves the same as the <xref
      linkend="libpq-connect-requirepeer"/> connection parameter.
     </para>
________________________________________________________-->
     <para>
      <indexterm>
       <primary><envar>PGREQUIREPEER</envar></primary>
      </indexterm>
      <envar>PGREQUIREPEER</envar>的行为与<xref
      linkend="libpq-connect-requirepeer"/>连接参数相同。
     </para>
<!-- pgdoc-cn_end sig_en=3a8e154b3bc47bffb342a8f1ed859b17 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=027d6cd13fc11367e062f74c8ac6f417 sig_cn_org=aa25f66fdfe10268b09185b228b3a056 source=15.7 
     <para>
      <indexterm>
       <primary><envar>PGSSLMINPROTOCOLVERSION</envar></primary>
      </indexterm>
      <envar>PGSSLMINPROTOCOLVERSION</envar> behaves the same as the <xref
      linkend="libpq-connect-ssl-min-protocol-version"/> connection parameter.
     </para>
________________________________________________________-->
     <para>
      <indexterm>
       <primary><envar>PGSSLMINPROTOCOLVERSION</envar></primary>
      </indexterm>
      <envar>PGSSLMINPROTOCOLVERSION</envar>的行为与<xref
      linkend="libpq-connect-ssl-min-protocol-version"/>连接参数相同。
     </para>
<!-- pgdoc-cn_end sig_en=027d6cd13fc11367e062f74c8ac6f417 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=83fc9f49103dc5b25f090282a91dc99c sig_cn_org=8d138fdfc77b65e7161b431fa1dddab6 source=15.7 
     <para>
      <indexterm>
       <primary><envar>PGSSLMAXPROTOCOLVERSION</envar></primary>
      </indexterm>
      <envar>PGSSLMAXPROTOCOLVERSION</envar> behaves the same as the <xref
      linkend="libpq-connect-ssl-max-protocol-version"/> connection parameter.
     </para>
________________________________________________________-->
     <para>
      <indexterm>
       <primary><envar>PGSSLMAXPROTOCOLVERSION</envar></primary>
      </indexterm>
      <envar>PGSSLMAXPROTOCOLVERSION</envar>的行为与<xref
      linkend="libpq-connect-ssl-max-protocol-version"/>连接参数相同。
     </para>
<!-- pgdoc-cn_end sig_en=83fc9f49103dc5b25f090282a91dc99c -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=c7762515db5e0c54e335a0b7eb276601 sig_cn_org=b8b39b36e89827f5f889ec9581e86f46 source=15.7 
     <para>
      <indexterm>
       <primary><envar>PGGSSENCMODE</envar></primary>
      </indexterm>
      <envar>PGGSSENCMODE</envar> behaves the same as the <xref
      linkend="libpq-connect-gssencmode"/> connection parameter.
     </para>
________________________________________________________-->
     <para>
      <indexterm>
       <primary><envar>PGGSSENCMODE</envar></primary>
      </indexterm>
      <envar>PGGSSENCMODE</envar>的行为与<xref
      linkend="libpq-connect-gssencmode"/>连接参数相同。
     </para>
<!-- pgdoc-cn_end sig_en=c7762515db5e0c54e335a0b7eb276601 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=bdcb4f24e737a9cb754a746d6302cb47 sig_cn_org=0458b69d61120340060efe39fb03cee3 source=15.7 
     <para>
      <indexterm>
       <primary><envar>PGKRBSRVNAME</envar></primary>
      </indexterm>
      <envar>PGKRBSRVNAME</envar>  behaves the same as the <xref
      linkend="libpq-connect-krbsrvname"/> connection parameter.
     </para>
________________________________________________________-->
     <para>
      <indexterm>
       <primary><envar>PGKRBSRVNAME</envar></primary>
      </indexterm>
      <envar>PGKRBSRVNAME</envar> 表现与<xref
      linkend="libpq-connect-krbsrvname"/>连接参数相同。
     </para>
<!-- pgdoc-cn_end sig_en=bdcb4f24e737a9cb754a746d6302cb47 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=7dc62f4d0f88bc04b773361834f427e5 sig_cn_org=3344899f6c979486674af03fcd617c41 source=15.7 
     <para>
      <indexterm>
       <primary><envar>PGGSSLIB</envar></primary>
      </indexterm>
      <envar>PGGSSLIB</envar> behaves the same as the <xref
      linkend="libpq-connect-gsslib"/> connection parameter.
     </para>
________________________________________________________-->
     <para>
      <indexterm>
       <primary><envar>PGGSSLIB</envar></primary>
      </indexterm>
      <envar>PGGSSLIB</envar>的行为与<xref
      linkend="libpq-connect-gsslib"/>连接参数相同。
     </para>
<!-- pgdoc-cn_end sig_en=7dc62f4d0f88bc04b773361834f427e5 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=9093996e94959644548519afa38aaebf sig_cn_org=578381852b021591e6f6f0e519271411 source=15.7 
     <para>
      <indexterm>
       <primary><envar>PGCONNECT_TIMEOUT</envar></primary>
      </indexterm>
      <envar>PGCONNECT_TIMEOUT</envar>  behaves the same as the <xref
      linkend="libpq-connect-connect-timeout"/> connection parameter.
     </para>
________________________________________________________-->
     <para>
      <indexterm>
       <primary><envar>PGCONNECT_TIMEOUT</envar></primary>
      </indexterm>
      <envar>PGCONNECT_TIMEOUT</envar>的行为与<xref
      linkend="libpq-connect-connect-timeout"/>连接参数相同。
     </para>
<!-- pgdoc-cn_end sig_en=9093996e94959644548519afa38aaebf -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=a1f09235ccfb975948e3cfcde0efd7fa sig_cn_org=c23e9c93050a64425a13177d4463bfe2 source=15.7 
     <para>
      <indexterm>
       <primary><envar>PGCLIENTENCODING</envar></primary>
      </indexterm>
      <envar>PGCLIENTENCODING</envar> behaves the same as the <xref
      linkend="libpq-connect-client-encoding"/> connection parameter.
     </para>
________________________________________________________-->
     <para>
      <indexterm>
       <primary><envar>PGCLIENTENCODING</envar></primary>
      </indexterm>
      <envar>PGCLIENTENCODING</envar>的行为与<xref
      linkend="libpq-connect-client-encoding"/>连接参数相同。
     </para>
<!-- pgdoc-cn_end sig_en=a1f09235ccfb975948e3cfcde0efd7fa -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=b19cfc4bded9db03380241636cd283c2 sig_cn_org=d3475c0a246e707d5bd4ccd2e1ce65bd source=15.7 
     <para>
      <indexterm>
       <primary><envar>PGTARGETSESSIONATTRS</envar></primary>
      </indexterm>
      <envar>PGTARGETSESSIONATTRS</envar> behaves the same as the <xref
      linkend="libpq-connect-target-session-attrs"/> connection parameter.
     </para>
________________________________________________________-->
     <para>
      <indexterm>
       <primary><envar>PGTARGETSESSIONATTRS</envar></primary>
      </indexterm>
      <envar>PGTARGETSESSIONATTRS</envar>的行为与<xref
      linkend="libpq-connect-target-session-attrs"/>连接参数相同。
     </para>
<!-- pgdoc-cn_end sig_en=b19cfc4bded9db03380241636cd283c2 -->
    </listitem>
   </itemizedlist>
  </para>

<!-- pgdoc-cn_start sig_en=29985f48332336c054669e3d32619ef1 sig_cn_org=None source=14.1 
  <para>
   The following environment variables can be used to specify default
   behavior for each <productname>PostgreSQL</productname> session.  (See
   also the <xref linkend="sql-alterrole"/>
   and <xref linkend="sql-alterdatabase"/>
   commands for ways to set default behavior on a per-user or per-database
   basis.)

   <itemizedlist>
    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGDATESTYLE</envar></primary>
      </indexterm>
      <envar>PGDATESTYLE</envar> sets the default style of date/time
      representation.  (Equivalent to <literal>SET datestyle TO
      ...</literal>.)
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGTZ</envar></primary>
      </indexterm>
      <envar>PGTZ</envar> sets the default time zone.  (Equivalent to
      <literal>SET timezone TO ...</literal>.)
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGGEQO</envar></primary>
      </indexterm>
      <envar>PGGEQO</envar> sets the default mode for the genetic query
      optimizer.  (Equivalent to <literal>SET geqo TO ...</literal>.)
     </para>
    </listitem>
   </itemizedlist>

   Refer to the <acronym>SQL</acronym> command <xref linkend="sql-set"/>
   for information on correct values for these
   environment variables.
  </para>
________________________________________________________-->
  <para>
   下面的环境变量可用来为每一个<productname>PostgreSQL</productname>会话指定默认行为（为每一个用户或每一个数据库设置默认行为的方法还可见<xref linkend="sql-alterrole"/>和<xref linkend="sql-alterdatabase"/>命令）。

   <itemizedlist>
    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGDATESTYLE</envar></primary>
      </indexterm>
      <envar>PGDATESTYLE</envar>设置日期/时间表示的默认风格（等同于<literal>SET datestyle TO ...</literal>）。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGTZ</envar></primary>
      </indexterm>
      <envar>PGTZ</envar>设置默认的时区（等同于<literal>SET timezone TO ...</literal>）。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGGEQO</envar></primary>
      </indexterm>
      <envar>PGGEQO</envar>为遗传查询优化器设置默认模式（等同于<literal>SET geqo TO ...</literal>）。
     </para>
    </listitem>
   </itemizedlist>

   这些环境变量的正确值可参考<acronym>SQL</acronym> 命令 <xref linkend="sql-set"/>。
  </para>
<!-- pgdoc-cn_end sig_en=29985f48332336c054669e3d32619ef1 -->

<!-- pgdoc-cn_start sig_en=797503656978f5d8cf79c073f56f640b sig_cn_org=None source=14.1 
  <para>
   The following environment variables determine internal behavior of
   <application>libpq</application>; they override compiled-in defaults.

   <itemizedlist>
    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSYSCONFDIR</envar></primary>
      </indexterm>
      <envar>PGSYSCONFDIR</envar> sets the directory containing the
      <filename>pg_service.conf</filename> file and in a future version
      possibly other system-wide configuration files.
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGLOCALEDIR</envar></primary>
      </indexterm>
      <envar>PGLOCALEDIR</envar> sets the directory containing the
      <literal>locale</literal> files for message localization.
     </para>
    </listitem>
   </itemizedlist>
  </para>
________________________________________________________-->
  <para>
   下面的环境变量决定<application>libpq</application>的内部行为，它们会覆盖编译在程序中的默认值。

   <itemizedlist>
    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSYSCONFDIR</envar></primary>
      </indexterm>
      <envar>PGSYSCONFDIR</envar>设置包含<filename>pg_service.conf</filename>文件以及未来版本中可能出现的其他系统范围配置文件的目录。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGLOCALEDIR</envar></primary>
      </indexterm>
      <envar>PGLOCALEDIR</envar>设置包含用于消息本地化的<literal>locale</literal>文件的目录。
     </para>
    </listitem>
   </itemizedlist>
  </para>
<!-- pgdoc-cn_end sig_en=797503656978f5d8cf79c073f56f640b -->

 </sect1>


 <sect1 id="libpq-pgpass">
<!-- pgdoc-cn_start sig_en=814443d12470d8b96c54be8e26a01889 sig_cn_org=None source=14.1 
  <title>The Password File</title>
________________________________________________________-->
  <title>口令文件</title>
<!-- pgdoc-cn_end sig_en=814443d12470d8b96c54be8e26a01889 -->

<!-- pgdoc-cn_start sig_en=5c9e10ccade61aa30e1dafb20d5302b9 sig_cn_org=None source=14.1 
  <indexterm zone="libpq-pgpass">
   <primary>password file</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="libpq-pgpass">
   <primary>口令文件</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=5c9e10ccade61aa30e1dafb20d5302b9 -->
<!-- pgdoc-cn_start sig_en=9da34cfcaa61d880ff5bf107ff99fdbe sig_cn_org=None source=14.1 
  <indexterm zone="libpq-pgpass">
   <primary>.pgpass</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="libpq-pgpass">
   <primary>.pgpass</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=9da34cfcaa61d880ff5bf107ff99fdbe -->

<!-- pgdoc-cn_start sig_en=0604d70cfccaca581c97fe39e96bf8bf sig_cn_org=74a01b1ef99314b36f9606c24318dc5b source=15.7 
  <para>
   The file <filename>.pgpass</filename> in a user's home directory can
   contain passwords to
   be used if the connection requires a password (and no password has been
   specified otherwise). On Microsoft Windows the file is named
   <filename>%APPDATA%\postgresql\pgpass.conf</filename> (where
   <filename>%APPDATA%</filename> refers to the Application Data subdirectory in
   the user's profile).
   Alternatively, the password file to use can be specified
   using the connection parameter <xref linkend="libpq-connect-passfile"/>
   or the environment variable <envar>PGPASSFILE</envar>.
  </para>
________________________________________________________-->
  <para>
   用户的主目录中的文件<filename>.pgpass</filename>可以包含密码，
   如果连接需要密码（且未指定其他密码）。在Microsoft Windows中，
   该文件的名称为<filename>%APPDATA%\postgresql\pgpass.conf</filename>
   （其中<filename>%APPDATA%</filename>指用户配置文件中的应用数据子目录）。
   或者，可以使用连接参数<xref linkend="libpq-connect-passfile"/>
   或环境变量<envar>PGPASSFILE</envar>指定要使用的密码文件。
</para>
<!-- pgdoc-cn_end sig_en=0604d70cfccaca581c97fe39e96bf8bf -->

<!-- pgdoc-cn_start sig_en=b9c9a1da65f9b46237cceecfd7379450 sig_cn_org=None source=14.1 
  <para>
   This file should contain lines of the following format:
<synopsis>
<replaceable>hostname</replaceable>:<replaceable>port</replaceable>:<replaceable>database</replaceable>:<replaceable>username</replaceable>:<replaceable>password</replaceable>
</synopsis>
   (You can add a reminder comment to the file by copying the line above and
   preceding it with <literal>#</literal>.)
   Each of the first four fields can be a literal value, or
   <literal>*</literal>, which matches anything.  The password field from
   the first line that matches the current connection parameters will be
   used.  (Therefore, put more-specific entries first when you are using
   wildcards.) If an entry needs to contain <literal>:</literal> or
   <literal>\</literal>, escape this character with <literal>\</literal>.
   The host name field is matched to the <literal>host</literal> connection
   parameter if that is specified, otherwise to
   the <literal>hostaddr</literal> parameter if that is specified; if neither
   are given then the host name <literal>localhost</literal> is searched for.
   The host name <literal>localhost</literal> is also searched for when
   the connection is a Unix-domain socket connection and
   the <literal>host</literal> parameter
   matches <application>libpq</application>'s default socket directory path.
   In a standby server, a database field of <literal>replication</literal>
   matches streaming replication connections made to the primary server.
   The database field is of limited usefulness otherwise, because users have
   the same password for all databases in the same cluster.
  </para>
________________________________________________________-->
  <para>
   这个文件应该包含下列格式的行：
<synopsis>
<replaceable>hostname</replaceable>:<replaceable>port</replaceable>:<replaceable>database</replaceable>:<replaceable>username</replaceable>:<replaceable>password</replaceable>
</synopsis>
   （你可以向该文件增加一个提醒：把上面的行复制到该文件并且在前面加上<literal>#</literal>）。前四个域的每一个都可以是文字值或者匹配任何东西的<literal>*</literal>。第一个匹配当前连接参数的行中的口令域将被使用（因此，在使用通配符时把更特殊的项放在前面）。如果一个条目需要包含<literal>:</literal>或者<literal>\</literal>，用<literal>\</literal>对该字符转义。如果指定了<literal>host</literal>连接参数，主机名字段会被匹配到<literal>host</literal>，否则如果指定了<literal>hostaddr</literal>参数则匹配到<literal>hostaddr</literal>，如果两者都没有给出，则会搜索主机名<literal>localhost</literal>。当连接是一个Unix域套接字连接并且<literal>host</literal>参数匹配<application>libpq</application>的默认套接字目录路径时，也会搜索主机名<literal>localhost</literal>。在一台后备服务器上，值为<literal>replication</literal>的数据库字段匹配连接到主服务器的里复制连接。否则数据库字段的用途有限，因为用户对同一个集簇中的所有数据库都有相同的口令。
  </para>
<!-- pgdoc-cn_end sig_en=b9c9a1da65f9b46237cceecfd7379450 -->

<!-- pgdoc-cn_start sig_en=9195afeafe79255423f408fd7f454b02 sig_cn_org=None source=14.1 
  <para>
   On Unix systems, the permissions on a password file must
   disallow any access to world or group; achieve this by a command such as
   <command>chmod 0600 ~/.pgpass</command>.  If the permissions are less
   strict than this, the file will be ignored.  On Microsoft Windows, it
   is assumed that the file is stored in a directory that is secure, so
   no special permissions check is made.
  </para>
________________________________________________________-->
  <para>
   在 Unix 系统上，口令文件上的权限必须不允许所有人或组内访问，可以用<command>chmod 0600 ~/.pgpass</command>这样的命令实现。如果权限没有这么严格，该文件将被忽略。在微软 Windows 上，该文件被假定存储在一个安全的目录中，因此不会进行特别的权限检查。
  </para>
<!-- pgdoc-cn_end sig_en=9195afeafe79255423f408fd7f454b02 -->
 </sect1>


 <sect1 id="libpq-pgservice">
<!-- pgdoc-cn_start sig_en=4ce1afc147aa864b104fd3194a2d74e1 sig_cn_org=None source=14.1 
  <title>The Connection Service File</title>
________________________________________________________-->
  <title>连接服务文件</title>
<!-- pgdoc-cn_end sig_en=4ce1afc147aa864b104fd3194a2d74e1 -->

<!-- pgdoc-cn_start sig_en=a63e336aae01c6f9556fae1148b4ff6e sig_cn_org=None source=14.1 
  <indexterm zone="libpq-pgservice">
   <primary>connection service file</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="libpq-pgservice">
   <primary>连接服务文件</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=a63e336aae01c6f9556fae1148b4ff6e -->
<!-- pgdoc-cn_start sig_en=78211672a5e00762affdcd6531a37a0f sig_cn_org=None source=14.1 
  <indexterm zone="libpq-pgservice">
   <primary>pg_service.conf</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="libpq-pgservice">
   <primary>pg_service.conf</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=78211672a5e00762affdcd6531a37a0f -->
<!-- pgdoc-cn_start sig_en=c62e8f176dc192c2182ffd089b76da62 sig_cn_org=None source=14.1 
  <indexterm zone="libpq-pgservice">
   <primary>.pg_service.conf</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="libpq-pgservice">
   <primary>.pg_service.conf</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=c62e8f176dc192c2182ffd089b76da62 -->

<!-- pgdoc-cn_start sig_en=6d50357845a435df36d81d44c8babf20 sig_cn_org=None source=14.1 
  <para>
   The connection service file allows libpq connection parameters to be
   associated with a single service name. That service name can then be
   specified in a libpq connection string, and the associated settings will be
   used. This allows connection parameters to be modified without requiring
   a recompile of the libpq-using application. The service name can also be
   specified using the <envar>PGSERVICE</envar> environment variable.
  </para>
________________________________________________________-->
  <para>
   连接服务文件允许 libpq 连接参数与一个单一服务名称关联。
   那个服务名称可以在一个 libpq 连接字符串里面指定，与其相关的设置将被使用。
   这允许在不重新编译 libpq-using 应用的前提下修改连接参数。
   服务名称也可以被使用<envar>PGSERVICE</envar>环境变量来指定。
  </para>
<!-- pgdoc-cn_end sig_en=6d50357845a435df36d81d44c8babf20 -->

<!-- pgdoc-cn_start sig_en=8c8aaba44d1af03a18dfe47ef68b561b sig_cn_org=de2f907f075ba43a6ca5ab4042165136 source=15.7 
  <para>
   Service names can be defined in either a per-user service file or a
   system-wide file.  If the same service name exists in both the user
   and the system file, the user file takes precedence.
   By default, the per-user service file is named
   <filename>~/.pg_service.conf</filename>.
   On Microsoft Windows, it is named
   <filename>%APPDATA%\postgresql\.pg_service.conf</filename> (where
   <filename>%APPDATA%</filename> refers to the Application Data subdirectory
   in the user's profile).  A different file name can be specified by
   setting the environment variable <envar>PGSERVICEFILE</envar>.
   The system-wide file is named <filename>pg_service.conf</filename>.
   By default it is sought in the <filename>etc</filename> directory
   of the <productname>PostgreSQL</productname> installation
   (use <literal>pg_config -&minus;sysconfdir</literal> to identify this
   directory precisely).  Another directory, but not a different file
   name, can be specified by setting the environment variable
   <envar>PGSYSCONFDIR</envar>.
  </para>
________________________________________________________-->
  <para>
   服务名称可以在每个用户的服务文件或系统范围的文件中定义。如果同一个服务名称存在于用户文件和系统文件中，
   则用户文件优先。默认情况下，每个用户的服务文件名为<filename>~/.pg_service.conf</filename>。
   在Microsoft Windows上，它的名称为<filename>%APPDATA%\postgresql\.pg_service.conf</filename>
   （其中<filename>%APPDATA%</filename>指用户配置文件夹中的应用数据子目录）。
   可以通过设置环境变量<envar>PGSERVICEFILE</envar>来指定不同的文件名。
   系统范围的文件名为<filename>pg_service.conf</filename>。
   默认情况下，在<productname>PostgreSQL</productname>安装的<filename>etc</filename>目录中寻找
   （使用<literal>pg_config --sysconfdir</literal>来准确识别此目录）。可以通过设置环境变量
   <envar>PGSYSCONFDIR</envar>来指定另一个目录，但不能指定不同的文件名。
</para>
<!-- pgdoc-cn_end sig_en=8c8aaba44d1af03a18dfe47ef68b561b -->

<!-- pgdoc-cn_start sig_en=8f582ccdf36db7749c81d2531396e736 sig_cn_org=None source=14.1 
  <para>
   Either service file uses an <quote>INI file</quote> format where the section
   name is the service name and the parameters are connection
   parameters; see <xref linkend="libpq-paramkeywords"/> for a list.  For
   example:
<programlisting>
# comment
[mydb]
host=somehost
port=5433
user=admin
</programlisting>
   An example file is provided in
   the <productname>PostgreSQL</productname> installation at
   <filename>share/pg_service.conf.sample</filename>.
  </para>
________________________________________________________-->
  <para>
   或者服务文件使用一种<quote>INI 文件</quote>格式，其中小节名是服务名并且参数是连接参数。
   列表见<xref linkend="libpq-paramkeywords"/>。例如：
<programlisting>
# comment
[mydb]
host=somehost
port=5433
user=admin
</programlisting>
   在<productname>PostgreSQL</productname>安装的<filename>share/pg_service.conf.sample</filename>中提供了一个例子文件。
  </para>
<!-- pgdoc-cn_end sig_en=8f582ccdf36db7749c81d2531396e736 -->

<!-- pgdoc-cn_start sig_en=cbf9711bfe72df7add3ecff2602717e8 sig_cn_org=None source=14.1 
  <para>
   Connection parameters obtained from a service file are combined with
   parameters obtained from other sources.  A service file setting
   overrides the corresponding environment variable, and in turn can be
   overridden by a value given directly in the connection string.
   For example, using the above service file, a connection string
   <literal>service=mydb port=5434</literal> will use
   host <literal>somehost</literal>, port <literal>5434</literal>,
   user <literal>admin</literal>, and other parameters as set by
   environment variables or built-in defaults.
  </para>
________________________________________________________-->
  <para>
   从服务文件中获取的连接参数与从其他来源获取的参数相结合。
   服务文件设置覆盖相应的环境变量，然后反过来可以由连接字符串中直接给出的值覆盖。
   例如，使用上面的服务文件，连接字符串<literal>service=mydb port=5434</literal>将使用主机<literal>somehost</literal>，端口<literal>5434</literal>，
   用户<literal>admin</literal>，以及由环境变量或内置默认所设置的其他参数。
  </para>
<!-- pgdoc-cn_end sig_en=cbf9711bfe72df7add3ecff2602717e8 -->
 </sect1>


 <sect1 id="libpq-ldap">
<!-- pgdoc-cn_start sig_en=482fe0da26c7ea46d90bbfe39b5f57b4 sig_cn_org=None source=14.1 
  <title>LDAP Lookup of Connection Parameters</title>
________________________________________________________-->
  <title>连接参数的 LDAP 查找</title>
<!-- pgdoc-cn_end sig_en=482fe0da26c7ea46d90bbfe39b5f57b4 -->

<!-- pgdoc-cn_start sig_en=6b46271b42d4b7a08213fd8fa7f07319 sig_cn_org=None source=14.1 
  <indexterm zone="libpq-ldap">
   <primary>LDAP connection parameter lookup</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="libpq-ldap">
   <primary>LDAP 连接参数查找</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=6b46271b42d4b7a08213fd8fa7f07319 -->

<!-- pgdoc-cn_start sig_en=441b9a0d0811b009dbb1dd06d5732ca5 sig_cn_org=None source=14.1 
  <para>
   If <application>libpq</application> has been compiled with LDAP support (option
   <literal><option>-&minus;with-ldap</option></literal> for <command>configure</command>)
   it is possible to retrieve connection options like <literal>host</literal>
   or <literal>dbname</literal> via LDAP from a central server.
   The advantage is that if the connection parameters for a database change,
   the connection information doesn't have to be updated on all client machines.
  </para>
________________________________________________________-->
  <para>
   如果<application>libpq</application>已经在编译时打开了 LDAP 支持（<command>configure</command>的选项<literal><option>--with-ldap</option></literal>），就可以通过 LDAP 从一个中央服务器检索<literal>host</literal>或<literal>dbname</literal>之类的连接参数。这样做的好处是如果一个数据库的连接参数改变，不需要在所有的客户端机器上更新连接信息。
  </para>
<!-- pgdoc-cn_end sig_en=441b9a0d0811b009dbb1dd06d5732ca5 -->

<!-- pgdoc-cn_start sig_en=4055040f6a5db3e7466438b5d032c391 sig_cn_org=5b518ddfb83578946380e26d46651263 source=15.7 
  <para>
   LDAP connection parameter lookup uses the connection service file
   <filename>pg_service.conf</filename> (see <xref
   linkend="libpq-pgservice"/>).  A line in a
   <filename>pg_service.conf</filename> stanza that starts with
   <literal>ldap://</literal> will be recognized as an LDAP URL and an
   LDAP query will be performed. The result must be a list of
   <literal>keyword = value</literal> pairs which will be used to set
   connection options.  The URL must conform to
   <ulink url="https://datatracker.ietf.org/doc/html/rfc1959">RFC 1959</ulink>
   and be of the form
<synopsis>
ldap://[<replaceable>hostname</replaceable>[:<replaceable>port</replaceable>]]/<replaceable>search_base</replaceable>?<replaceable>attribute</replaceable>?<replaceable>search_scope</replaceable>?<replaceable>filter</replaceable>
</synopsis>
   where <replaceable>hostname</replaceable> defaults to
   <literal>localhost</literal> and <replaceable>port</replaceable>
   defaults to 389.
  </para>
________________________________________________________-->
  <para>
   LDAP连接参数查找使用连接服务文件<filename>pg_service.conf</filename>（参见<xref linkend="libpq-pgservice"/>）。
   在<filename>pg_service.conf</filename>段落中以<literal>ldap://</literal>开头的行将被识别为LDAP URL，并执行LDAP查询。
   结果必须是一组<literal>keyword = value</literal>对，将用于设置连接选项。
   URL必须符合<ulink url="https://datatracker.ietf.org/doc/html/rfc1959">RFC 1959</ulink>的形式为
<synopsis>
ldap://[<replaceable>hostname</replaceable>[:<replaceable>port</replaceable>]]/<replaceable>search_base</replaceable>?<replaceable>attribute</replaceable>?<replaceable>search_scope</replaceable>?<replaceable>filter</replaceable>
</synopsis>
   其中<replaceable>hostname</replaceable>默认为<literal>localhost</literal>，<replaceable>port</replaceable>默认为389。
</para>
<!-- pgdoc-cn_end sig_en=4055040f6a5db3e7466438b5d032c391 -->

<!-- pgdoc-cn_start sig_en=bd4eca90e3119bc58d24896d2a12f235 sig_cn_org=None source=14.1 
  <para>
   Processing of <filename>pg_service.conf</filename> is terminated after
   a successful LDAP lookup, but is continued if the LDAP server cannot
   be contacted.  This is to provide a fallback with further LDAP URL
   lines that point to different LDAP servers, classical <literal>keyword
   = value</literal> pairs, or default connection options.  If you would
   rather get an error message in this case, add a syntactically incorrect
   line after the LDAP URL.
  </para>
________________________________________________________-->
  <para>
   一次成功的 LDAP 查找后，<filename>pg_service.conf</filename>的处理被终止。但是如果联系不上 LDAP 则会继续处理<filename>pg_service.conf</filename>。这就提供了后手，可以加入更多指向不同 LDAP 服务器的 LDAP URL 行、经典的<literal>keyword = value</literal>对或者默认连接选项。如果你宁愿在这种情况下得到一个错误消息，在该 LDAP URL 之后增加一个语法错误的行。
  </para>
<!-- pgdoc-cn_end sig_en=bd4eca90e3119bc58d24896d2a12f235 -->

<!-- pgdoc-cn_start sig_en=19b2ae430fd0e1b68a9080caf537e49e sig_cn_org=None source=14.1 
  <para>
   A sample LDAP entry that has been created with the LDIF file
<programlisting>
version:1
dn:cn=mydatabase,dc=mycompany,dc=com
changetype:add
objectclass:top
objectclass:device
cn:mydatabase
description:host=dbserver.mycompany.com
description:port=5439
description:dbname=mydb
description:user=mydb_user
description:sslmode=require
</programlisting>
   might be queried with the following LDAP URL:
<programlisting>
ldap://ldap.mycompany.com/dc=mycompany,dc=com?description?one?(cn=mydatabase)
</programlisting>
  </para>
________________________________________________________-->
  <para>
   一个和 LDIF 文件一起创建的 LDAP 条目实例
<programlisting>
version:1
dn:cn=mydatabase,dc=mycompany,dc=com
changetype:add
objectclass:top
objectclass:device
cn:mydatabase
description:host=dbserver.mycompany.com
description:port=5439
description:dbname=mydb
description:user=mydb_user
description:sslmode=require
</programlisting>
   可以用下面的 LDAP URL 查询：
<programlisting>
ldap://ldap.mycompany.com/dc=mycompany,dc=com?description?one?(cn=mydatabase)
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=19b2ae430fd0e1b68a9080caf537e49e -->

<!-- pgdoc-cn_start sig_en=8567f23c193c671a640f2cbd462d4f9d sig_cn_org=None source=14.1 
  <para>
   You can also mix regular service file entries with LDAP lookups.
   A complete example for a stanza in <filename>pg_service.conf</filename>
   would be:
<programlisting>
# only host and port are stored in LDAP, specify dbname and user explicitly
[customerdb]
dbname=customer
user=appuser
ldap://ldap.acme.com/cn=dbserver,cn=hosts?pgconnectinfo?base?(objectclass=*)
</programlisting>
  </para>
________________________________________________________-->
  <para>
   你也可以将常规的服务文件条目和 LDAP 查找混合。<filename>pg_service.conf</filename>中一节的完整例子：
<programlisting>
# 只有主机和端口存储在LDAP中，显式指定dbname和user。
[customerdb]
dbname=customer
user=appuser
ldap://ldap.acme.com/cn=dbserver,cn=hosts?pgconnectinfo?base?(objectclass=*)
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=8567f23c193c671a640f2cbd462d4f9d -->

 </sect1>


 <sect1 id="libpq-ssl">
<!-- pgdoc-cn_start sig_en=c74da549c1ba1d1daa8ce5e3082159d0 sig_cn_org=None source=14.1 
  <title>SSL Support</title>
________________________________________________________-->
  <title>SSL 支持</title>
<!-- pgdoc-cn_end sig_en=c74da549c1ba1d1daa8ce5e3082159d0 -->

<!-- pgdoc-cn_start sig_en=4a83d3295f5529d12feddb8348a69890 sig_cn_org=12990e0b91058450de8a4045201c96a1 source=15.7 
  <indexterm zone="libpq-ssl">
   <primary>SSL</primary>
   <secondary>TLS</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="libpq-ssl">
   <primary>SSL</primary>
   <secondary>TLS</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=4a83d3295f5529d12feddb8348a69890 -->

<!-- pgdoc-cn_start sig_en=21ffb897ac4cf5dc46d99f4f15c135cc sig_cn_org=e4a15ebb95faf07035ebb51077a8fc2e source=15.7 
  <para>
   <productname>PostgreSQL</productname> has native support for using <acronym>SSL</acronym>
   connections to encrypt client/server communications using
   <acronym>TLS</acronym> protocols for increased security.
   See <xref linkend="ssl-tcp"/> for details about the server-side
   <acronym>SSL</acronym> functionality.
  </para>
________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>具有原生支持使用<acronym>SSL</acronym>连接来加密客户端/服务器通信，
   使用<acronym>TLS</acronym>协议以提高安全性。有关服务器端<acronym>SSL</acronym>功能的详细信息，请参见<xref linkend="ssl-tcp"/>。
</para>
<!-- pgdoc-cn_end sig_en=21ffb897ac4cf5dc46d99f4f15c135cc -->

<!-- pgdoc-cn_start sig_en=2fa578f5d5ccca1dbb7a7a891fea19de sig_cn_org=None source=14.1 
  <para>
   <application>libpq</application> reads the system-wide
   <productname>OpenSSL</productname> configuration file. By default, this
   file is named <filename>openssl.cnf</filename> and is located in the
   directory reported by <literal>openssl version -d</literal>.  This default
   can be overridden by setting environment variable
   <envar>OPENSSL_CONF</envar> to the name of the desired configuration
   file.
  </para>
________________________________________________________-->
  <para>
   <application>libpq</application>读取系统范围的<productname>OpenSSL</productname>配置文件。默认情况下，这个文件被命名为<filename>openssl.cnf</filename>并且位于<literal>openssl version -d</literal>所报告的目录中。可以通过设置环境变量<envar>OPENSSL_CONF</envar>把这个默认值覆盖为想要的配置文件的名称。
  </para>
<!-- pgdoc-cn_end sig_en=2fa578f5d5ccca1dbb7a7a891fea19de -->

 <sect2 id="libq-ssl-certificates">
<!-- pgdoc-cn_start sig_en=5999562f739216156a64cd0282afa63c sig_cn_org=None source=14.1 
  <title>Client Verification of Server Certificates</title>
________________________________________________________-->
  <title>服务器证书的客户端验证</title>
<!-- pgdoc-cn_end sig_en=5999562f739216156a64cd0282afa63c -->

<!-- pgdoc-cn_start sig_en=30840c262c99b51b5ee5947e5473f098 sig_cn_org=None source=14.1 
  <para>
   By default, <productname>PostgreSQL</productname> will not perform any verification of
   the server certificate. This means that it is possible to spoof the server
   identity (for example by modifying a DNS record or by taking over the server
   IP address) without the client knowing. In order to prevent spoofing,
   the client must be able to verify the server's identity via a chain of
   trust.  A chain of trust is established by placing a root (self-signed)
   certificate authority (<acronym>CA</acronym>) certificate on one
   computer and a leaf certificate <emphasis>signed</emphasis> by the
   root certificate on another computer.  It is also possible to use an
   <quote>intermediate</quote> certificate which is signed by the root
   certificate and signs leaf certificates.
  </para>
________________________________________________________-->
  <para>
   默认情况下，<productname>PostgreSQL</productname>将不会执行服务器证书的任何验证。这意味着可以在不被客户端知晓的情况下伪造服务器身份（例如通过修改一个 DNS 记录或者接管服务器的 IP 地址）。为了阻止哄骗，客户端必须能够通过一条信任链验证服务器的身份。信任链可以这样建立：在一台计算机上放置一个根（自签名的）证书机构（<acronym>CA</acronym>）的证书并且在另一台计算机上放置一个由根证书<emphasis>签发</emphasis>的叶子证书。还可以使用一种<quote>中间</quote>证书，它由根证书签发并且可以签发叶子证书。
  </para>
<!-- pgdoc-cn_end sig_en=30840c262c99b51b5ee5947e5473f098 -->

<!-- pgdoc-cn_start sig_en=c47b8f84e372f2b1c025640586b5b3f0 sig_cn_org=None source=14.1 
  <para>
   To allow the client to verify the identity of the server, place a root
   certificate on the client and a leaf certificate signed by the root
   certificate on the server.  To allow the server to verify the identity
   of the client, place a root certificate on the server and a leaf
   certificate signed by the root certificate on the client.  One or more
   intermediate certificates (usually stored with the leaf certificate)
   can also be used to link the leaf certificate to the root certificate.
  </para>
________________________________________________________-->
  <para>
   为了允许客户端验证服务器的身份，在客户端上放置一份根证书并且在服务器上放置由根证书签发的叶子证书。为了允许服务器验证客户端的身份，在服务器上放置一份根证书并且在客户端上放置由根证书签发的叶子证书。也可以使用一个或者更多个中间证书（通常与叶子证书存在一起）来将叶子证书链接到根证书。
  </para>
<!-- pgdoc-cn_end sig_en=c47b8f84e372f2b1c025640586b5b3f0 -->

<!-- pgdoc-cn_start sig_en=96c0f1ae708efd0e8b1129f9177e576f sig_cn_org=None source=14.1 
  <para>
   Once a chain of trust has been established, there are two ways for
   the client to validate the leaf certificate sent by the server.
   If the parameter <literal>sslmode</literal> is set to <literal>verify-ca</literal>,
   libpq will verify that the server is trustworthy by checking the
   certificate chain up to the root certificate stored on the client.
   If <literal>sslmode</literal> is set to <literal>verify-full</literal>,
   libpq will <emphasis>also</emphasis> verify that the server host
   name matches the name stored in the server certificate. The
   SSL connection will fail if the server certificate cannot be
   verified. <literal>verify-full</literal> is recommended in most
   security-sensitive environments.
  </para>
________________________________________________________-->
  <para>
   一旦信任链被建立起来，客户端有两种方法验证服务器发过来的叶子证书。如果参数<literal>sslmode</literal>被设置为<literal>verify-ca</literal>，libpq将通过检查该证书是否链接到存储在客户端上的根证书来验证服务器。如果<literal>sslmode</literal>被设置为<literal>verify-full</literal>，libpq<emphasis>还</emphasis>将验证服务器的主机名匹配存储在服务器证书中的名称。如果服务器证书无法被验证，则SSL连接将失败。在大部分对安全性很敏感的环境中，推荐使用<literal>verify-full</literal>。
  </para>
<!-- pgdoc-cn_end sig_en=96c0f1ae708efd0e8b1129f9177e576f -->

<!-- pgdoc-cn_start sig_en=a87cfd0f4969874b9b624902a19592cb sig_cn_org=9808794a2b8bcdbd8447dd8526665bd0 source=15.7 
  <para>
   In <literal>verify-full</literal> mode, the host name is matched against the
   certificate's Subject Alternative Name attribute(s) (SAN), or against the
   Common Name attribute if no SAN of type <literal>dNSName</literal> is
   present.  If the certificate's name attribute starts with an asterisk
   (<literal>*</literal>), the asterisk will be treated as
   a wildcard, which will match all characters <emphasis>except</emphasis> a dot
   (<literal>.</literal>). This means the certificate will not match subdomains.
   If the connection is made using an IP address instead of a host name, the
   IP address will be matched (without doing any DNS lookups) against SANs of
   type <literal>iPAddress</literal> or <literal>dNSName</literal>.  If no
   <literal>iPAddress</literal> SAN is present and no
   matching <literal>dNSName</literal> SAN is present, the host IP address is
   matched against the Common Name attribute.
  </para>
________________________________________________________-->
  <para>
   在<literal>verify-full</literal>模式下，主机名将与证书的主体替代名称属性（SAN）匹配，
   或者与通用名称属性匹配，如果没有类型为<literal>dNSName</literal>的SAN存在。
   如果证书的名称属性以星号（<literal>*</literal>）开头，那么星号将被视为通配符，
   可以匹配所有字符，<emphasis>除了</emphasis>点（<literal>.</literal>）。
   这意味着证书将不匹配子域。如果连接使用IP地址而不是主机名进行，
   则IP地址将与类型为<literal>iPAddress</literal>或<literal>dNSName</literal>的SAN匹配
   （不进行任何DNS查找）。如果没有<literal>iPAddress</literal> SAN存在，
   也没有匹配的<literal>dNSName</literal> SAN存在，则主机IP地址将与通用名称属性匹配。
</para>
<!-- pgdoc-cn_end sig_en=a87cfd0f4969874b9b624902a19592cb -->

  <note>
<!-- pgdoc-cn_start sig_en=ccaabf9b7a607e2ad4a9e1a2734b67f8 sig_cn_org=f83ff99d70f975694d4af67c55815cb6 source=15.7 
   <para>
    For backward compatibility with earlier versions of PostgreSQL, the host
    IP address is verified in a manner different
    from <ulink url="https://datatracker.ietf.org/doc/html/rfc6125">RFC 6125</ulink>.
    The host IP address is always matched against <literal>dNSName</literal>
    SANs as well as <literal>iPAddress</literal> SANs, and can be matched
    against the Common Name attribute if no relevant SANs exist.
   </para>
________________________________________________________-->
   <para>
    为了与早期版本的PostgreSQL向后兼容，主机IP地址的验证方式与
    <ulink url="https://datatracker.ietf.org/doc/html/rfc6125">RFC 6125</ulink>中的方式不同。
    主机IP地址始终与<literal>dNSName</literal> SANs以及<literal>iPAddress</literal> SANs匹配，
    如果不存在相关的SANs，则可以与通用名称属性匹配。
</para>
<!-- pgdoc-cn_end sig_en=ccaabf9b7a607e2ad4a9e1a2734b67f8 -->
  </note>

<!-- pgdoc-cn_start sig_en=434be73f25be2e51ec9426da239f900a sig_cn_org=None source=14.1 
  <para>
   To allow server certificate verification, one or more root certificates
   must be placed in the file <filename>~/.postgresql/root.crt</filename>
   in the user's home directory.  (On Microsoft Windows the file is named
   <filename>%APPDATA%\postgresql\root.crt</filename>.)  Intermediate
   certificates should also be added to the file if they are needed to link
   the certificate chain sent by the server to the root certificates
   stored on the client.
  </para>
________________________________________________________-->
  <para>
   要允许服务器证书验证，必须将一个或者更多个根证书放置在用户主目录下的<filename>~/.postgresql/root.crt</filename>文件中（在Microsoft Windows上该文件名为<filename>%APPDATA%\postgresql\root.crt</filename>）。如果需要把服务器发来的证书链链接到存储在客户端的根证书，还应该将中间证书加到该文件中。
  </para>
<!-- pgdoc-cn_end sig_en=434be73f25be2e51ec9426da239f900a -->

<!-- pgdoc-cn_start sig_en=ecee2e19fe9c1228d56ec5e67458a33c sig_cn_org=None source=14.1 
  <para>
   Certificate Revocation List (CRL) entries are also checked
   if the file <filename>~/.postgresql/root.crl</filename> exists
   (<filename>%APPDATA%\postgresql\root.crl</filename> on Microsoft
   Windows).
  </para>
________________________________________________________-->
  <para>
   如果文件<filename>~/.postgresql/root.crl</filename>存在（微软 Windows 上的<filename>%APPDATA%\postgresql\root.crl</filename>），证书撤销列表（CRL）项也会被检查。
  </para>
<!-- pgdoc-cn_end sig_en=ecee2e19fe9c1228d56ec5e67458a33c -->

<!-- pgdoc-cn_start sig_en=57fcc7c60519a57056ca2b55caf992ad sig_cn_org=a75fa25e6d7e432723cfaa43e682b7ad source=15.7 
  <para>
   The location of the root certificate file and the CRL can be changed by
   setting
   the connection parameters <literal>sslrootcert</literal> and <literal>sslcrl</literal>
   or the environment variables <envar>PGSSLROOTCERT</envar> and <envar>PGSSLCRL</envar>.
   <literal>sslcrldir</literal> or the environment variable <envar>PGSSLCRLDIR</envar>
   can also be used to specify a directory containing CRL files.
  </para>
________________________________________________________-->
  <para>
   根证书文件和CRL的位置可以通过设置连接参数<literal>sslrootcert</literal>和<literal>sslcrl</literal>
   或环境变量<envar>PGSSLROOTCERT</envar>和<envar>PGSSLCRL</envar>来更改。
   <literal>sslcrldir</literal>或环境变量<envar>PGSSLCRLDIR</envar>也可以用来指定包含CRL文件的目录。
</para>
<!-- pgdoc-cn_end sig_en=57fcc7c60519a57056ca2b55caf992ad -->

  <note>
<!-- pgdoc-cn_start sig_en=1e9a7e06f408b73e4a8b516cfd3e58dc sig_cn_org=None source=14.1 
   <para>
    For backwards compatibility with earlier versions of PostgreSQL, if a
    root CA file exists, the behavior of
    <literal>sslmode</literal>=<literal>require</literal> will be the same
    as that of <literal>verify-ca</literal>, meaning the server certificate
    is validated against the CA. Relying on this behavior is discouraged,
    and applications that need certificate validation should always use
    <literal>verify-ca</literal> or <literal>verify-full</literal>.
   </para>
________________________________________________________-->
   <para>
    为了与 PostgreSQL 的早期版本达到向后兼容，如果存在一个根 CA 文件，<literal>sslmode</literal>=<literal>require</literal>的行为将与<literal>verify-ca</literal>相同，即服务器证书根据 CA 验证。我们鼓励依赖这种行为，并且需要证书验证的应用应该总是使用<literal>verify-ca</literal>或者<literal>verify-full</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=1e9a7e06f408b73e4a8b516cfd3e58dc -->
  </note>
 </sect2>

 <sect2 id="libpq-ssl-clientcert">
<!-- pgdoc-cn_start sig_en=8046b285af1d04a18b6ac2a07b927346 sig_cn_org=None source=14.1 
  <title>Client Certificates</title>
________________________________________________________-->
  <title>客户端证书</title>
<!-- pgdoc-cn_end sig_en=8046b285af1d04a18b6ac2a07b927346 -->

<!-- pgdoc-cn_start sig_en=ec76001f6066099a65bc8d2d3b8986ef sig_cn_org=497c3606c75690ea399922a33b5ba8ef source=15.7 
  <para>
   If the server attempts to verify the identity of the
   client by requesting the client's leaf certificate,
   <application>libpq</application> will send the certificate(s) stored in
   file <filename>~/.postgresql/postgresql.crt</filename> in the user's home
   directory.  The certificates must chain to the root certificate trusted
   by the server.  A matching
   private key file <filename>~/.postgresql/postgresql.key</filename> must also
   be present.
   On Microsoft Windows these files are named
   <filename>%APPDATA%\postgresql\postgresql.crt</filename> and
   <filename>%APPDATA%\postgresql\postgresql.key</filename>.
   The location of the certificate and key files can be overridden by the
   connection parameters <literal>sslcert</literal>
   and <literal>sslkey</literal>, or by the
   environment variables <envar>PGSSLCERT</envar> and <envar>PGSSLKEY</envar>.
  </para>
________________________________________________________-->
  <para>
   如果服务器尝试通过请求客户端的叶证书来验证客户端的身份，
   <application>libpq</application>将发送存储在文件
   <filename>~/.postgresql/postgresql.crt</filename>中的证书，该文件位于用户的主目录中。
   证书必须链到服务器信任的根证书。匹配的
   私钥文件<filename>~/.postgresql/postgresql.key</filename>也必须存在。
   在Microsoft Windows上，这些文件的名称分别为
   <filename>%APPDATA%\postgresql\postgresql.crt</filename>和
   <filename>%APPDATA%\postgresql\postgresql.key</filename>。
   证书和密钥文件的位置可以通过连接参数
   <literal>sslcert</literal>和<literal>sslkey</literal>，
   或通过环境变量<envar>PGSSLCERT</envar>和<envar>PGSSLKEY</envar>来覆盖。
</para>
<!-- pgdoc-cn_end sig_en=ec76001f6066099a65bc8d2d3b8986ef -->

<!-- pgdoc-cn_start sig_en=9d57217068412360802bd81a33e84bd7 sig_cn_org=7b00a375c3d5c3d8120b92aa7908b00e source=15.7 
  <para>
   On Unix systems, the permissions on the private key file must disallow
   any access to world or group; achieve this by a command such as
   <command>chmod 0600 ~/.postgresql/postgresql.key</command>.
   Alternatively, the file can be owned by root and have group read access
   (that is, <literal>0640</literal> permissions).  That setup is intended
   for installations where certificate and key files are managed by the
   operating system.  The user of <application>libpq</application> should
   then be made a member of the group that has access to those certificate
   and key files.  (On Microsoft Windows, there is no file permissions
   check, since the <filename>%APPDATA%\postgresql</filename> directory is
   presumed secure.)
  </para>
________________________________________________________-->
  <para>
   在Unix系统上，私钥文件的权限必须禁止任何对世界或组的访问；可以通过类似以下命令来实现：
   <command>chmod 0600 ~/.postgresql/postgresql.key</command>。
   或者，该文件可以由root拥有并具有组读取权限（即<literal>0640</literal>权限）。
   该设置适用于由操作系统管理证书和密钥文件的安装。然后，<application>libpq</application>的用户应该成为具有对这些证书和密钥文件访问权限的组的成员。
   （在Microsoft Windows上，没有文件权限检查，因为假定<filename>%APPDATA%\postgresql</filename>目录是安全的。）
</para>
<!-- pgdoc-cn_end sig_en=9d57217068412360802bd81a33e84bd7 -->

<!-- pgdoc-cn_start sig_en=59fd0aff3693224f884f7771514cdeb2 sig_cn_org=None source=14.1 
  <para>
   The first certificate in <filename>postgresql.crt</filename> must be the
   client's certificate because it must match the client's private key.
   <quote>Intermediate</quote> certificates can be optionally appended
   to the file &mdash; doing so avoids requiring storage of intermediate
   certificates on the server (<xref linkend="guc-ssl-ca-file"/>).
  </para>
________________________________________________________-->
  <para>
   <filename>postgresql.crt</filename>中的第一个证书必须是客户端的证书，因为它必须匹配客户端的私钥。可以选择将<quote>中间</quote>证书追加到该文件 &mdash; 这样做避免了在服务器上存放中间证书的要求（<xref linkend="guc-ssl-ca-file"/>）。
  </para>
<!-- pgdoc-cn_end sig_en=59fd0aff3693224f884f7771514cdeb2 -->

<!-- pgdoc-cn_start sig_en=424b4f46c0c351ee03e9b6575650166a sig_cn_org=None source=14.1 
  <para>
   The certificate and key may be in PEM or ASN.1 DER format.
  </para>
________________________________________________________-->
  <para>
   证书和密钥可能是 PEM 或 ASN.1 DER 格式。
  </para>
<!-- pgdoc-cn_end sig_en=424b4f46c0c351ee03e9b6575650166a -->

<!-- pgdoc-cn_start sig_en=d4e16d1968e5f9e919371ba4e33724de sig_cn_org=None source=14.1 
  <para>
   The key may be
   stored in cleartext or encrypted with a passphrase using any algorithm
   supported by <productname>OpenSSL</productname>, like AES-128. If the key
   is stored encrypted, then the passphrase may be provided in the
   <xref linkend="libpq-connect-sslpassword"/> connection option. If an
   encrypted key is supplied and the <literal>sslpassword</literal> option
   is absent or blank, a password will be prompted for interactively by
   <productname>OpenSSL</productname> with a
   <literal>Enter PEM pass phrase:</literal> prompt if a TTY is available.
   Applications can override the client certificate prompt and the handling
   of the <literal>sslpassword</literal> parameter by supplying their own
   key password callback; see
   <xref linkend="libpq-pqsetsslkeypasshook-openssl"/>.
  </para>
________________________________________________________-->
  <para>
   密钥可以以明文存储，也可以使用<productname>OpenSSL</productname>支持的任何算法(例如AES-128)使用密码进行加密。
   如果密钥是加密存储的，那么可以在<xref linkend="libpq-connect-sslpassword"/>连接选项中提供密码。
   如果提供了加密密钥，而且<literal>sslpassword</literal>选项不存在或为空，如果TTY可用，那么<productname>OpenSSL</productname>将交互式地以<literal>Enter PEM pass phrase:</literal>提示输入密码。
   应用程序可以越过客户端证书提示和<literal>sslpassword</literal>参数的处理，通过提供它们自己的密钥密码回调;参见<xref linkend="libpq-pqsetsslkeypasshook-openssl"/>。
  </para>
<!-- pgdoc-cn_end sig_en=d4e16d1968e5f9e919371ba4e33724de -->

<!-- pgdoc-cn_start sig_en=1c377b2ac342bfc57bdcd26c23141909 sig_cn_org=None source=14.1 
  <para>
   For instructions on creating certificates, see <xref
   linkend="ssl-certificate-creation"/>.
  </para>
________________________________________________________-->
  <para>
   创建证书的指令请参考<xref linkend="ssl-certificate-creation"/>。
  </para>
<!-- pgdoc-cn_end sig_en=1c377b2ac342bfc57bdcd26c23141909 -->
 </sect2>

 <sect2 id="libpq-ssl-protection">
<!-- pgdoc-cn_start sig_en=a792238fc20694722a7cadcf265d188f sig_cn_org=None source=14.1 
  <title>Protection Provided in Different Modes</title>
________________________________________________________-->
  <title>不同模式中提供的保护</title>
<!-- pgdoc-cn_end sig_en=a792238fc20694722a7cadcf265d188f -->

<!-- pgdoc-cn_start sig_en=ebd5b92705316952a7534e80779b654f sig_cn_org=None source=14.1 
  <para>
   The different values for the <literal>sslmode</literal> parameter provide different
   levels of protection. SSL can provide
   protection against three types of attacks:

   <variablelist>
    <varlistentry>
     <term>Eavesdropping</term>
     <listitem>
      <para>If a third party can examine the network traffic between the
       client and the server, it can read both connection information (including
       the user name and password) and the data that is passed. <acronym>SSL</acronym>
       uses encryption to prevent this.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Man-in-the-middle (<acronym>MITM</acronym>)</term>
     <listitem>
      <para>If a third party can modify the data while passing between the
       client and server, it can pretend to be the server and therefore see and
       modify data <emphasis>even if it is encrypted</emphasis>. The third party can then
       forward the connection information and data to the original server,
       making it impossible to detect this attack. Common vectors to do this
       include DNS poisoning and address hijacking, whereby the client is directed
       to a different server than intended. There are also several other
       attack methods that can accomplish this. <acronym>SSL</acronym> uses certificate
       verification to prevent this, by authenticating the server to the client.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Impersonation</term>
     <listitem>
      <para>If a third party can pretend to be an authorized client, it can
       simply access data it should not have access to. Typically this can
       happen through insecure password management. <acronym>SSL</acronym> uses
       client certificates to prevent this, by making sure that only holders
       of valid certificates can access the server.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
________________________________________________________-->
  <para>
   <literal>sslmode</literal>参数的不同值提供了不同级别的保护。SSL 能够针对三类攻击提供保护：

   <variablelist>
    <varlistentry>
     <term>窃听</term>
     <listitem>
      <para>如果一个第三方能够检查客户端和服务器之间的网络流量，它能读取连接信息（包括用户名和口令）以及被传递的数据。<acronym>SSL</acronym>使用加密来阻止这种攻击。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>中间人（<acronym>MITM</acronym>）</term>
     <listitem>
      <para>如果一个第三方能对客户端和服务器之间传送的数据进行修改，它就能假装是服务器并且因此能看见并且修改数据，<emphasis>即使这些数据已被加密</emphasis>。然后第三方可以将连接信息和数据转送给原来的服务器，使得它不可能检测到攻击。这样做的通常途径包括 DNS 污染和地址劫持，借此客户端被重定向到一个不同的服务器。还有几种其他的攻击方式能够完成这种攻击。<acronym>SSL</acronym>使用证书验证让客户端认证服务器，就可以阻止这种攻击。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>模仿</term>
     <listitem>
      <para>如果一个第三方能假装是一个授权的客户端，它能够简单地访问它本不能访问的数据。通常这可以由不安全的口令管理所致。<acronym>SSL</acronym>使用客户端证书来确保只有持有合法证书的客户端才能访问服务器，这样就能阻止这种攻击。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
<!-- pgdoc-cn_end sig_en=ebd5b92705316952a7534e80779b654f -->

<!-- pgdoc-cn_start sig_en=dae1e2802790b4949361aa512a94b84a sig_cn_org=None source=14.1 
  <para>
   For a connection to be known SSL-secured, SSL usage must be configured
   on <emphasis>both the client and the server</emphasis> before the connection
   is made. If it is only configured on the server, the client may end up
   sending sensitive information (e.g., passwords) before
   it knows that the server requires high security. In libpq, secure
   connections can be ensured
   by setting the <literal>sslmode</literal> parameter to <literal>verify-full</literal> or
   <literal>verify-ca</literal>, and providing the system with a root certificate to
   verify against. This is analogous to using an <literal>https</literal>
   <acronym>URL</acronym> for encrypted web browsing.
  </para>
________________________________________________________-->
  <para>
   对于一个已知的SSL-secured连接，在连接被建立之前，SSL 使用必须被配置在<emphasis>客户端和服务器</emphasis>之上。如果只在服务器上配置，客户端在知道服务器要求高安全性之前可能会结束发送敏感信息（例如口令）。在 libpq 中，要确保连接安全，可以设置<literal>sslmode</literal>参数为<literal>verify-full</literal>或<literal>verify-ca</literal>并且为系统提供一个根证书用来验证。这类似于使用一个<literal>https</literal> <acronym>URL</acronym>进行加密网页浏览。
  </para>
<!-- pgdoc-cn_end sig_en=dae1e2802790b4949361aa512a94b84a -->

<!-- pgdoc-cn_start sig_en=943da44e9cab6d3316cb37032a4876c6 sig_cn_org=None source=14.1 
  <para>
   Once the server has been authenticated, the client can pass sensitive data.
   This means that up until this point, the client does not need to know if
   certificates will be used for authentication, making it safe to specify that
   only in the server configuration.
  </para>
________________________________________________________-->
  <para>
   一旦服务器已经被认证，客户端可以传递敏感数据。这意味着直到这一点，客户端都不需要知道是否证书将被用于认证，这样只需要在服务器配置中指定就比较安全。
  </para>
<!-- pgdoc-cn_end sig_en=943da44e9cab6d3316cb37032a4876c6 -->

<!-- pgdoc-cn_start sig_en=017122a17f68361c3b0ffe749f753547 sig_cn_org=None source=14.1 
  <para>
   All <acronym>SSL</acronym> options carry overhead in the form of encryption and
   key-exchange, so there is a trade-off that has to be made between performance
   and security. <xref linkend="libpq-ssl-sslmode-statements"/>
   illustrates the risks the different <literal>sslmode</literal> values
   protect against, and what statement they make about security and overhead.
  </para>
________________________________________________________-->
  <para>
   所有<acronym>SSL</acronym>选项都带来了加密和密钥交换的负荷，因此必须在性能和安全性之间做出平衡。<xref linkend="libpq-ssl-sslmode-statements"/>不同<literal>sslmode</literal>值所保护的风险，以及它们是怎样看待安全性和负荷的。
  </para>
<!-- pgdoc-cn_end sig_en=017122a17f68361c3b0ffe749f753547 -->

  <table id="libpq-ssl-sslmode-statements">
<!-- pgdoc-cn_start sig_en=58bda9876f392ecf38c1090551503d4b sig_cn_org=None source=14.1 
   <title>SSL Mode Descriptions</title>
________________________________________________________-->
   <title>SSL 模式描述</title>
<!-- pgdoc-cn_end sig_en=58bda9876f392ecf38c1090551503d4b -->
   <tgroup cols="4">
    <colspec colname="col1" colwidth="1*"/>
    <colspec colname="col2" colwidth="1*"/>
    <colspec colname="col3" colwidth="1*"/>
    <colspec colname="col4" colwidth="2*"/>
    <thead>
<!-- pgdoc-cn_start sig_en=f669eecf8a7fb63e1ce1a544eb9a513f sig_cn_org=None source=14.1 
     <row>
      <entry><literal>sslmode</literal></entry>
      <entry>Eavesdropping protection</entry>
      <entry><acronym>MITM</acronym> protection</entry>
      <entry>Statement</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>sslmode</literal></entry>
      <entry>窃听保护</entry>
      <entry><acronym>MITM</acronym>保护</entry>
      <entry>声明</entry>
     </row>
<!-- pgdoc-cn_end sig_en=f669eecf8a7fb63e1ce1a544eb9a513f -->
    </thead>

    <tbody>
<!-- pgdoc-cn_start sig_en=b15c88c05ecd7a94ca4ccbaaef89183e sig_cn_org=None source=14.1 
     <row>
      <entry><literal>disable</literal></entry>
      <entry>No</entry>
      <entry>No</entry>
      <entry>I don't care about security, and I don't want to pay the overhead
       of encryption.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>disable</literal></entry>
      <entry>No</entry>
      <entry>No</entry>
      <entry>我不关心安全性，并且我不想为加密增加负荷。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=b15c88c05ecd7a94ca4ccbaaef89183e -->

<!-- pgdoc-cn_start sig_en=8e558535162805d796966d5549b92f1f sig_cn_org=None source=14.1 
     <row>
      <entry><literal>allow</literal></entry>
      <entry>Maybe</entry>
      <entry>No</entry>
      <entry>I don't care about security, but I will pay the overhead of
       encryption if the server insists on it.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>allow</literal></entry>
      <entry>可能</entry>
      <entry>No</entry>
      <entry>我不关心安全性，但如果服务器坚持，我将承担加密带来的负荷。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=8e558535162805d796966d5549b92f1f -->

<!-- pgdoc-cn_start sig_en=0ab0bc4c75184a9674863a7a29863b70 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>prefer</literal></entry>
      <entry>Maybe</entry>
      <entry>No</entry>
      <entry>I don't care about encryption, but I wish to pay the overhead of
       encryption if the server supports it.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>prefer</literal></entry>
      <entry>可能</entry>
      <entry>No</entry>
      <entry>我不关心安全性，但如果服务器支持，我希望承担加密带来的负荷。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=0ab0bc4c75184a9674863a7a29863b70 -->

<!-- pgdoc-cn_start sig_en=3d76c13f5d2b60c7795acc3eaa5c97df sig_cn_org=None source=14.1 
     <row>
      <entry><literal>require</literal></entry>
      <entry>Yes</entry>
      <entry>No</entry>
      <entry>I want my data to be encrypted, and I accept the overhead. I trust
       that the network will make sure I always connect to the server I want.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>require</literal></entry>
      <entry>Yes</entry>
      <entry>No</entry>
      <entry>我想要对数据加密，并且我接受因此带来的负荷。我信任该网络会保证我总是连接到想要连接的服务器。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=3d76c13f5d2b60c7795acc3eaa5c97df -->

<!-- pgdoc-cn_start sig_en=efccb586d3157def4f55ba092a3743c8 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>verify-ca</literal></entry>
      <entry>Yes</entry>
      <entry>Depends on CA policy</entry>
      <entry>I want my data encrypted, and I accept the overhead. I want to be
       sure that I connect to a server that I trust.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>verify-ca</literal></entry>
      <entry>Yes</entry>
      <entry>Depends on CA policy</entry>
      <entry>我想要对数据加密，并且我接受因此带来的负荷。我想要确保我连接到的是我信任的服务器。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=efccb586d3157def4f55ba092a3743c8 -->

<!-- pgdoc-cn_start sig_en=c9ee07bc709366ed481b4ca1f5a4bd67 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>verify-full</literal></entry>
       <entry>Yes</entry>
       <entry>Yes</entry>
       <entry>I want my data encrypted, and I accept the overhead. I want to be
        sure that I connect to a server I trust, and that it's the one I
        specify.
       </entry>
      </row>
________________________________________________________-->
     <row>
      <entry><literal>verify-full</literal></entry>
       <entry>Yes</entry>
       <entry>Yes</entry>
       <entry>我想要对数据加密，并且我接受因此带来的负荷。我想要确保我连接到的是我信任的服务器，并且就是我指定的那一个。
       </entry>
      </row>
<!-- pgdoc-cn_end sig_en=c9ee07bc709366ed481b4ca1f5a4bd67 -->

    </tbody>
   </tgroup>
  </table>

<!-- pgdoc-cn_start sig_en=3d2730499b913efb4277bca7e19df69b sig_cn_org=None source=14.1 
  <para>
   The difference between <literal>verify-ca</literal> and <literal>verify-full</literal>
   depends on the policy of the root <acronym>CA</acronym>. If a public
   <acronym>CA</acronym> is used, <literal>verify-ca</literal> allows connections to a server
   that <emphasis>somebody else</emphasis> may have registered with the <acronym>CA</acronym>.
   In this case, <literal>verify-full</literal> should always be used. If
   a local <acronym>CA</acronym> is used, or even a self-signed certificate, using
   <literal>verify-ca</literal> often provides enough protection.
  </para>
________________________________________________________-->
  <para>
   <literal>verify-ca</literal>和<literal>verify-full</literal>之间的区别取决于根<literal>CA</literal>的策略。如果使用了一个公共<literal>CA</literal>，<literal>verify-ca</literal>允许连接到那些可能已经被<emphasis>其他人</emphasis>注册到该<literal>CA</literal>的服务器。在这种情况下，总是应该使用<literal>verify-full</literal>。如果使用了一个本地<literal>CA</literal>或者甚至是一个自签名的证书，使用<literal>verify-ca</literal>常常就可以提供足够的保护。
  </para>
<!-- pgdoc-cn_end sig_en=3d2730499b913efb4277bca7e19df69b -->

<!-- pgdoc-cn_start sig_en=b83232826dfafdc8aed6408488fb6066 sig_cn_org=None source=14.1 
  <para>
   The default value for <literal>sslmode</literal> is <literal>prefer</literal>. As is shown
   in the table, this makes no sense from a security point of view, and it only
   promises performance overhead if possible. It is only provided as the default
   for backward compatibility, and is not recommended in secure deployments.
  </para>
________________________________________________________-->
  <para>
   <literal>sslmode</literal>的默认值是<literal>prefer</literal>。如表中所示，这在安全性的角度来说没有意义，并且它只承诺可能的性能负荷。提供它作为默认值只是为了向后兼容，并且我们不推荐在安全部署中使用它。
  </para>
<!-- pgdoc-cn_end sig_en=b83232826dfafdc8aed6408488fb6066 -->

 </sect2>

 <sect2 id="libpq-ssl-fileusage">
<!-- pgdoc-cn_start sig_en=3fbc2f8dea404305ffd2fa70c042f1f6 sig_cn_org=None source=14.1 
  <title>SSL Client File Usage</title>
________________________________________________________-->
  <title>SSL 客户端文件使用</title>
<!-- pgdoc-cn_end sig_en=3fbc2f8dea404305ffd2fa70c042f1f6 -->

<!-- pgdoc-cn_start sig_en=1261f9fdda14af1e3801b1dee4aa7ac2 sig_cn_org=None source=14.1 
  <para>
   <xref linkend="libpq-ssl-file-usage"/> summarizes the files that are
   relevant to the SSL setup on the client.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="libpq-ssl-file-usage"/>总结了与客户端 SSL 设置相关的文件。
  </para>
<!-- pgdoc-cn_end sig_en=1261f9fdda14af1e3801b1dee4aa7ac2 -->

  <table id="libpq-ssl-file-usage">
<!-- pgdoc-cn_start sig_en=67c6597efbe07c51bb39d0f689aa9476 sig_cn_org=None source=14.1 
   <title>Libpq/Client SSL File Usage</title>
________________________________________________________-->
   <title>Libpq/客户端 SSL 文件用法</title>
<!-- pgdoc-cn_end sig_en=67c6597efbe07c51bb39d0f689aa9476 -->
   <tgroup cols="3">
    <thead>
<!-- pgdoc-cn_start sig_en=8226177a05f3318d561b773a4dacc434 sig_cn_org=None source=14.1 
     <row>
      <entry>File</entry>
      <entry>Contents</entry>
      <entry>Effect</entry>
     </row>
________________________________________________________-->
     <row>
      <entry>文件</entry>
      <entry>内容</entry>
      <entry>效果</entry>
     </row>
<!-- pgdoc-cn_end sig_en=8226177a05f3318d561b773a4dacc434 -->
    </thead>

    <tbody>

<!-- pgdoc-cn_start sig_en=83ddda6a42ddb9d98a16becfec66d59b sig_cn_org=None source=14.1 
     <row>
      <entry><filename>~/.postgresql/postgresql.crt</filename></entry>
      <entry>client certificate</entry>
      <entry>sent to server</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><filename>~/.postgresql/postgresql.crt</filename></entry>
      <entry>客户端证书</entry>
      <entry>发送到服务器</entry>
     </row>
<!-- pgdoc-cn_end sig_en=83ddda6a42ddb9d98a16becfec66d59b -->

<!-- pgdoc-cn_start sig_en=4a00d14ac75d98c8996e534d3d6b425d sig_cn_org=None source=14.1 
     <row>
      <entry><filename>~/.postgresql/postgresql.key</filename></entry>
      <entry>client private key</entry>
      <entry>proves client certificate sent by owner; does not indicate
      certificate owner is trustworthy</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><filename>~/.postgresql/postgresql.key</filename></entry>
      <entry>客户端私钥</entry>
      <entry>证明客户端证书是由拥有者发送；不代表证书拥有者可信</entry>
     </row>
<!-- pgdoc-cn_end sig_en=4a00d14ac75d98c8996e534d3d6b425d -->

<!-- pgdoc-cn_start sig_en=d2e178087b65b4ca3f94691d227ceace sig_cn_org=None source=14.1 
     <row>
      <entry><filename>~/.postgresql/root.crt</filename></entry>
      <entry>trusted certificate authorities</entry>
      <entry>checks that server certificate is signed by a trusted certificate
      authority</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><filename>~/.postgresql/root.crt</filename></entry>
      <entry>可信的证书机构</entry>
      <entry>检查服务器证书是由一个可信的证书机构签发</entry>
     </row>
<!-- pgdoc-cn_end sig_en=d2e178087b65b4ca3f94691d227ceace -->

<!-- pgdoc-cn_start sig_en=01c0e6dc77b7d3d6a22f6ef6432a15d2 sig_cn_org=None source=14.1 
     <row>
      <entry><filename>~/.postgresql/root.crl</filename></entry>
      <entry>certificates revoked by certificate authorities</entry>
      <entry>server certificate must not be on this list</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><filename>~/.postgresql/root.crl</filename></entry>
      <entry>被证书机构撤销的证书</entry>
      <entry>服务器证书不能在这个列表上</entry>
     </row>
<!-- pgdoc-cn_end sig_en=01c0e6dc77b7d3d6a22f6ef6432a15d2 -->

    </tbody>
   </tgroup>
  </table>
 </sect2>

 <sect2 id="libpq-ssl-initialize">
<!-- pgdoc-cn_start sig_en=f5ca35d7e1c14c826ab60ac296c9d7e9 sig_cn_org=None source=14.1 
  <title>SSL Library Initialization</title>
________________________________________________________-->
  <title>SSL 库初始化</title>
<!-- pgdoc-cn_end sig_en=f5ca35d7e1c14c826ab60ac296c9d7e9 -->

<!-- pgdoc-cn_start sig_en=ac186f1cfb05562b29b77a086808a84f sig_cn_org=cec349d8b7f0e51c3cbbf35a2ff09515 source=15.7 
  <para>
   If your application initializes <literal>libssl</literal> and/or
   <literal>libcrypto</literal> libraries and <application>libpq</application>
   is built with <acronym>SSL</acronym> support, you should call
   <xref linkend="libpq-PQinitOpenSSL"/> to tell <application>libpq</application>
   that the <literal>libssl</literal> and/or <literal>libcrypto</literal> libraries
   have been initialized by your application, so that
   <application>libpq</application> will not also initialize those libraries.
   However, this is unnecessary when using <productname>OpenSSL</productname>
   version 1.1.0 or later, as duplicate initializations are no longer problematic.
  </para>
________________________________________________________-->
  <para>
   如果您的应用程序初始化<literal>libssl</literal>和/或<literal>libcrypto</literal>库，并且<application>libpq</application>
   构建时带有<acronym>SSL</acronym>支持，您应该调用<xref linkend="libpq-PQinitOpenSSL"/>告诉<application>libpq</application>
   <literal>libssl</literal>和/或<literal>libcrypto</literal>库已被您的应用程序初始化，以便
   <application>libpq</application>不会再初始化这些库。
   但是，当使用<productname>OpenSSL</productname>版本1.1.0或更高版本时，重复初始化不再成问题。
</para>
<!-- pgdoc-cn_end sig_en=ac186f1cfb05562b29b77a086808a84f -->

<!-- pgdoc-cn_start sig_en=5f32de21c1d96332c2f7ceafda3dd6c2 sig_cn_org=None source=14.1 
  <para>
   <variablelist>
    <varlistentry id="libpq-PQinitOpenSSL">
     <term><function>PQinitOpenSSL</function><indexterm><primary>PQinitOpenSSL</primary></indexterm></term>

     <listitem>
      <para>
       Allows applications to select which security libraries to initialize.
<synopsis>
void PQinitOpenSSL(int do_ssl, int do_crypto);
</synopsis>
      </para>

      <para>
       When <parameter>do_ssl</parameter> is non-zero, <application>libpq</application>
       will initialize the <productname>OpenSSL</productname> library before first
       opening a database connection.  When <parameter>do_crypto</parameter> is
       non-zero, the <literal>libcrypto</literal> library will be initialized.  By
       default (if <xref linkend="libpq-PQinitOpenSSL"/> is not called), both libraries
       are initialized.  When SSL support is not compiled in, this function is
       present but does nothing.
      </para>

      <para>
       If your application uses and initializes either <productname>OpenSSL</productname>
       or its underlying <literal>libcrypto</literal> library, you <emphasis>must</emphasis>
       call this function with zeroes for the appropriate parameter(s)
       before first opening a database connection.  Also be sure that you
       have done that initialization before opening a database connection.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQinitSSL">
     <term><function>PQinitSSL</function><indexterm><primary>PQinitSSL</primary></indexterm></term><listitem>
      <para>
       Allows applications to select which security libraries to initialize.
<synopsis>
void PQinitSSL(int do_ssl);
</synopsis>
      </para>

      <para>
       This function is equivalent to
       <literal>PQinitOpenSSL(do_ssl, do_ssl)</literal>.
       It is sufficient for applications that initialize both or neither
       of <productname>OpenSSL</productname> and <literal>libcrypto</literal>.
      </para>

      <para>
       <xref linkend="libpq-PQinitSSL"/> has been present since
       <productname>PostgreSQL</productname> 8.0, while <xref linkend="libpq-PQinitOpenSSL"/>
       was added in <productname>PostgreSQL</productname> 8.4, so <xref linkend="libpq-PQinitSSL"/>
       might be preferable for applications that need to work with older
       versions of <application>libpq</application>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
________________________________________________________-->
  <para>
   <variablelist>
    <varlistentry id="libpq-PQinitOpenSSL">
     <term><function>PQinitOpenSSL</function><indexterm><primary>PQinitOpenSSL</primary></indexterm></term>

     <listitem>
      <para>
       允许应用选择要初始化哪个安全性库。
<synopsis>
void PQinitOpenSSL(int do_ssl, int do_crypto);
</synopsis>
      </para>

      <para>
       当<parameter>do_ssl</parameter>是非零时，<application>libpq</application>将在第一次打开数据库连接前初始化<productname>OpenSSL</productname>库。
       当<parameter>do_crypto</parameter>是非零时，<literal>libcrypto</literal>库将被初始化。
       默认情况下（如果没有调用<xref linkend="libpq-PQinitOpenSSL"/>），两个库都会被初始化。
       当 SSL 支持没有被编译时，这个函数也存在但是什么也不做。
      </para>

      <para>
       如果你的应用使用并且初始化<productname>OpenSSL</productname>或者它的底层<literal>libcrypto</literal>库，你<emphasis>必须</emphasis>在第一次打开数据库连接前以合适的非零参数调用这个函数。
       同时要确保在打开一个数据库连接前已经完成了初始化。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQinitSSL">
     <term><function>PQinitSSL</function><indexterm><primary>PQinitSSL</primary></indexterm></term><listitem>

      <para>
       允许应用选择要初始化哪个安全性库。
<synopsis>
void PQinitSSL(int do_ssl);
</synopsis>
      </para>

      <para>
       这个函数等效于<literal>PQinitOpenSSL(do_ssl, do_ssl)</literal>。
       这对于要么初始化<productname>OpenSSL</productname>以及<literal>libcrypto</literal>要么都不初始化的应用足够用了。
      </para>

      <para>
       <xref linkend="libpq-PQinitSSL"/>从<productname>PostgreSQL</productname> 8.0 就存在了，
       而<xref linkend="libpq-PQinitOpenSSL"/>直到<productname>PostgreSQL</productname> 8.4 才被加入，因此<xref linkend="libpq-PQinitSSL"/>可能对那些需要与旧版本<application>libpq</application>一起工作的应用来说更合适。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
<!-- pgdoc-cn_end sig_en=5f32de21c1d96332c2f7ceafda3dd6c2 -->
 </sect2>

 </sect1>


 <sect1 id="libpq-threading">
<!-- pgdoc-cn_start sig_en=bbbdac250549ab37f3c3813c90c11782 sig_cn_org=None source=14.1 
  <title>Behavior in Threaded Programs</title>
________________________________________________________-->
  <title>在线程化程序中的行为</title>
<!-- pgdoc-cn_end sig_en=bbbdac250549ab37f3c3813c90c11782 -->

<!-- pgdoc-cn_start sig_en=17f82250f07fb1f9f91b00e28212b10d sig_cn_org=None source=14.1 
  <indexterm zone="libpq-threading">
   <primary>threads</primary>
   <secondary>with libpq</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="libpq-threading">
   <primary>threads</primary>
   <secondary>with libpq</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=17f82250f07fb1f9f91b00e28212b10d -->

<!-- pgdoc-cn_start sig_en=f10f5db9c4d778305eb7c544d49987e9 sig_cn_org=None source=14.1 
  <para>
   <application>libpq</application> is reentrant and thread-safe by default.
   You might need to use special compiler command-line
   options when you compile your application code.  Refer to your
   system's documentation for information about how to build
   thread-enabled applications, or look in
   <filename>src/Makefile.global</filename> for <literal>PTHREAD_CFLAGS</literal>
   and <literal>PTHREAD_LIBS</literal>.  This function allows the querying of
   <application>libpq</application>'s thread-safe status:
  </para>
________________________________________________________-->
  <para>
   <application>libpq</application>默认是可再入的并且是线程安全的。你可能需要使用特殊的编译器命令行选项来编译你的应用代码。参考你的系统文档来了解如何编译启用线程的应用，或者在<filename>src/Makefile.global</filename>中查找<literal>PTHREAD_CFLAGS</literal>和<literal>PTHREAD_LIBS</literal>。这个函数允许查询<application>libpq</application>的线程安全状态：
  </para>
<!-- pgdoc-cn_end sig_en=f10f5db9c4d778305eb7c544d49987e9 -->

  <variablelist>
   <varlistentry id="libpq-PQisthreadsafe">
<!-- pgdoc-cn_start sig_en=c798c64b47569abad28322686d1390b6 sig_cn_org=None source=14.1 
    <term><function>PQisthreadsafe</function><indexterm><primary>PQisthreadsafe</primary></indexterm></term>
________________________________________________________-->
    <term><function>PQisthreadsafe</function><indexterm><primary>PQisthreadsafe</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=c798c64b47569abad28322686d1390b6 -->

    <listitem>
<!-- pgdoc-cn_start sig_en=7a22a108030f2e675f42ce4fc872af4d sig_cn_org=None source=14.1 
     <para>
      Returns the thread safety status of the
      <application>libpq</application> library.
<synopsis>
int PQisthreadsafe();
</synopsis>
     </para>
________________________________________________________-->
     <para>
      返回<application>libpq</application>库的线程安全状态。
<synopsis>
int PQisthreadsafe();
</synopsis>
     </para>
<!-- pgdoc-cn_end sig_en=7a22a108030f2e675f42ce4fc872af4d -->

<!-- pgdoc-cn_start sig_en=4b7736370a4581589d9a91298fba6be8 sig_cn_org=None source=14.1 
     <para>
      Returns 1 if the <application>libpq</application> is thread-safe
      and 0 if it is not.
     </para>
________________________________________________________-->
     <para>
      如果<application>libpq</application>是线程安全的则返回 1，否则返回 0。
     </para>
<!-- pgdoc-cn_end sig_en=4b7736370a4581589d9a91298fba6be8 -->
    </listitem>
   </varlistentry>
  </variablelist>

<!-- pgdoc-cn_start sig_en=4933543c9398adcedd9f523040150f7a sig_cn_org=None source=14.1 
  <para>
   One thread restriction is that no two threads attempt to manipulate
   the same <structname>PGconn</structname> object at the same time. In particular,
   you cannot issue concurrent commands from different threads through
   the same connection object. (If you need to run concurrent commands,
   use multiple connections.)
  </para>
________________________________________________________-->
  <para>
   一个线程限制是不允许两个线程同时尝试操纵同一个<structname>PGconn</structname>对象。特别是你不能从不同的线程通过同一个连接对象发出并发的命令（如果你需要运行并发命令，请使用多个连接）。
  </para>
<!-- pgdoc-cn_end sig_en=4933543c9398adcedd9f523040150f7a -->

<!-- pgdoc-cn_start sig_en=76008f3826a321707bbc5f64c197b1f5 sig_cn_org=None source=14.1 
  <para>
   <structname>PGresult</structname> objects are normally read-only after creation,
   and so can be passed around freely between threads.  However, if you use
   any of the <structname>PGresult</structname>-modifying functions described in
   <xref linkend="libpq-misc"/> or <xref linkend="libpq-events"/>, it's up
   to you to avoid concurrent operations on the same <structname>PGresult</structname>,
   too.
  </para>
________________________________________________________-->
  <para>
   <structname>PGresult</structname>对象在创建后通常是只读的，并且因此可以在线程之间自由地被传递。但是，如果你使用任何<xref linkend="libpq-misc"/>或<xref linkend="libpq-events"/>中描述的<structname>PGresult</structname>修改函数，你需要负责避免在同一个<structname>PGresult</structname>上的并发操作。
  </para>
<!-- pgdoc-cn_end sig_en=76008f3826a321707bbc5f64c197b1f5 -->

<!-- pgdoc-cn_start sig_en=d6ba6c681efff917d31d3564b8ddf2e4 sig_cn_org=None source=14.1 
  <para>
   The deprecated functions <xref linkend="libpq-PQrequestCancel"/> and
   <xref linkend="libpq-PQoidStatus"/> are not thread-safe and should not be
   used in multithread programs.  <xref linkend="libpq-PQrequestCancel"/>
   can be replaced by <xref linkend="libpq-PQcancel"/>.
   <xref linkend="libpq-PQoidStatus"/> can be replaced by
   <xref linkend="libpq-PQoidValue"/>.
  </para>
________________________________________________________-->
  <para>
   被废弃的函数<xref linkend="libpq-PQrequestCancel"/>以及<xref linkend="libpq-PQoidStatus"/>不是线程安全的并且不应当在多线程程序中使用。
   <xref linkend="libpq-PQrequestCancel"/>可以被替换为<xref linkend="libpq-PQcancel"/>。
   <xref linkend="libpq-PQoidStatus"/>可以被替换为<xref linkend="libpq-PQoidValue"/>。
  </para>
<!-- pgdoc-cn_end sig_en=d6ba6c681efff917d31d3564b8ddf2e4 -->

<!-- pgdoc-cn_start sig_en=de272f1b650b7f63fd7429f719ab5a88 sig_cn_org=None source=14.1 
  <para>
   If you are using Kerberos inside your application (in addition to inside
   <application>libpq</application>), you will need to do locking around
   Kerberos calls because Kerberos functions are not thread-safe.  See
   function <function>PQregisterThreadLock</function> in the
   <application>libpq</application> source code for a way to do cooperative
   locking between <application>libpq</application> and your application.
  </para>
________________________________________________________-->
  <para>
   如果你在应用中使用 Kerberos (除了在<application>libpq</application>中之外），你将需要对 Kerberos 调用加锁，因为 Kerberos 函数不是线程安全的。参考<application>libpq</application>源代码中的<function>PQregisterThreadLock</function>函数，那里有在<application>libpq</application>和应用之间做合作锁定的方法。
  </para>
<!-- pgdoc-cn_end sig_en=de272f1b650b7f63fd7429f719ab5a88 -->
 </sect1>


 <sect1 id="libpq-build">
<!-- pgdoc-cn_start sig_en=b08e4111b5715c43384befc5b8f2339c sig_cn_org=None source=14.1 
  <title>Building <application>libpq</application> Programs</title>
________________________________________________________-->
  <title>编译 <application>libpq</application> 程序</title>
<!-- pgdoc-cn_end sig_en=b08e4111b5715c43384befc5b8f2339c -->

<!-- pgdoc-cn_start sig_en=0114c57e91cdac98292897ae19e6b6eb sig_cn_org=None source=14.1 
  <indexterm zone="libpq-build">
   <primary>compiling</primary>
   <secondary>libpq applications</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="libpq-build">
   <primary>编译</primary>
   <secondary>libpq 应用</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=0114c57e91cdac98292897ae19e6b6eb -->

<!-- pgdoc-cn_start sig_en=1063f6644020421bd09acef8255b198c sig_cn_org=None source=14.1 
  <para>
   To build (i.e., compile and link) a program using
   <application>libpq</application> you need to do all of the following
   things:

   <itemizedlist>
    <listitem>
     <para>
      Include the <filename>libpq-fe.h</filename> header file:
<programlisting>
#include &lt;libpq-fe.h&gt;
</programlisting>
      If you failed to do that then you will normally get error messages
      from your compiler similar to:
<screen>
foo.c: In function `main':
foo.c:34: `PGconn' undeclared (first use in this function)
foo.c:35: `PGresult' undeclared (first use in this function)
foo.c:54: `CONNECTION_BAD' undeclared (first use in this function)
foo.c:68: `PGRES_COMMAND_OK' undeclared (first use in this function)
foo.c:95: `PGRES_TUPLES_OK' undeclared (first use in this function)
</screen>
     </para>
    </listitem>

    <listitem>
     <para>
      Point your compiler to the directory where the <productname>PostgreSQL</productname> header
      files were installed, by supplying the
      <literal>-I<replaceable>directory</replaceable></literal> option
      to your compiler.  (In some cases the compiler will look into
      the directory in question by default, so you can omit this
      option.)  For instance, your compile command line could look
      like:
<programlisting>
cc -c -I/usr/local/pgsql/include testprog.c
</programlisting>
      If you are using makefiles then add the option to the
      <varname>CPPFLAGS</varname> variable:
<programlisting>
CPPFLAGS += -I/usr/local/pgsql/include
</programlisting>
     </para>

     <para>
      If there is any chance that your program might be compiled by
      other users then you should not hardcode the directory location
      like that.  Instead, you can run the utility
      <command>pg_config</command><indexterm><primary>pg_config</primary><secondary
      sortas="libpq">with libpq</secondary></indexterm> to find out where the header
      files are on the local system:
<screen>
<prompt>$</prompt> pg_config -&minus;includedir
<computeroutput>/usr/local/include</computeroutput>
</screen>
     </para>

     <para>
      If you
      have <command>pkg-config</command><indexterm><primary>pkg-config</primary><secondary sortas="libpq">with
      libpq</secondary></indexterm> installed, you can run instead:
<screen>
<prompt>$</prompt> pkg-config -&minus;cflags libpq
<computeroutput>-I/usr/local/include</computeroutput>
</screen>
      Note that this will already include the <option>-I</option> in front of
      the path.
     </para>

     <para>
      Failure to specify the correct option to the compiler will
      result in an error message such as:
<screen>
testlibpq.c:8:22: libpq-fe.h: No such file or directory
</screen>
     </para>
    </listitem>

    <listitem>
     <para>
      When linking the final program, specify the option
      <literal>-lpq</literal> so that the <application>libpq</application>
      library gets pulled in, as well as the option
      <literal>-L<replaceable>directory</replaceable></literal> to point
      the compiler to the directory where the
      <application>libpq</application> library resides.  (Again, the
      compiler will search some directories by default.)  For maximum
      portability, put the <option>-L</option> option before the
      <option>-lpq</option> option.  For example:
<programlisting>
cc -o testprog testprog1.o testprog2.o -L/usr/local/pgsql/lib -lpq
</programlisting>
     </para>

     <para>
      You can find out the library directory using
      <command>pg_config</command> as well:
<screen>
<prompt>$</prompt> pg_config -&minus;libdir
<computeroutput>/usr/local/pgsql/lib</computeroutput>
</screen>
     </para>

     <para>
      Or again use <command>pkg-config</command>:
<screen>
<prompt>$</prompt> pkg-config -&minus;libs libpq
<computeroutput>-L/usr/local/pgsql/lib -lpq</computeroutput>
</screen>
      Note again that this prints the full options, not only the path.
     </para>

     <para>
      Error messages that point to problems in this area could look like
      the following:
<screen>
testlibpq.o: In function `main':
testlibpq.o(.text+0x60): undefined reference to `PQsetdbLogin'
testlibpq.o(.text+0x71): undefined reference to `PQstatus'
testlibpq.o(.text+0xa4): undefined reference to `PQerrorMessage'
</screen>
      This means you forgot <option>-lpq</option>.
<screen>
/usr/bin/ld: cannot find -lpq
</screen>
      This means you forgot the <option>-L</option> option or did not
      specify the right directory.
     </para>
    </listitem>
   </itemizedlist>
  </para>
________________________________________________________-->
  <para>
   要编译（即编译并且链接）一个使用<application>libpq</application>的程序，你需要做下列所有的事情：

   <itemizedlist>
    <listitem>
     <para>
      包括<filename>libpq-fe.h</filename>头文件：
<programlisting>
#include &lt;libpq-fe.h&gt;
</programlisting>
      如果你无法这样做，那么你通常会从你的编译器得到像这样的错误消息：
<screen>
foo.c: In function `main':
foo.c:34: `PGconn' undeclared (first use in this function)
foo.c:35: `PGresult' undeclared (first use in this function)
foo.c:54: `CONNECTION_BAD' undeclared (first use in this function)
foo.c:68: `PGRES_COMMAND_OK' undeclared (first use in this function)
foo.c:95: `PGRES_TUPLES_OK' undeclared (first use in this function)
</screen>
     </para>
    </listitem>

    <listitem>
     <para>
      通过为你的编译器提供<literal>-I<replaceable>directory</replaceable></literal>选项，向你的编译器指出<productname>PostgreSQL</productname>头文件安装在哪里（在某些情况下编译器默认将查看该目录，因此你可以忽略这个选项）。例如你的编译命令行可能看起来像：
<programlisting>
cc -c -I/usr/local/pgsql/include testprog.c
</programlisting>
      如果你在使用 makefile，那么把该选项加到<varname>CPPFLAGS</varname>变量中：
<programlisting>
CPPFLAGS += -I/usr/local/pgsql/include
</programlisting>
     </para>

     <para>
      如果你的程序可能由其他用户编译，那么你不应该像那样硬编码目录位置。你可以运行工具<command>pg_config</command><indexterm><primary>pg_config</primary><secondary
      sortas="libpq">with libpq</secondary></indexterm>在本地系统上找出头文件在哪里：
<screen>
<prompt>$</prompt> pg_config --includedir
<computeroutput>/usr/local/include</computeroutput>
</screen>
     </para>

     <para>
      如果你安装了<command>pkg-config</command><indexterm><primary>pkg-config</primary><secondary sortas="libpq">with
      libpq</secondary></indexterm>，你可以运行：
<screen>
<prompt>$</prompt> pkg-config --cflags libpq
<computeroutput>-I/usr/local/include</computeroutput>
</screen>
      注意这将在路径前面包括<option>-I</option>。
     </para>

     <para>
      无法为编译器指定正确的选项将导致一个错误消息，例如：
<screen>
testlibpq.c:8:22: libpq-fe.h: No such file or directory
</screen>
     </para>
    </listitem>

    <listitem>
     <para>
      当链接最终的程序时，指定选项<literal>-lpq</literal>，这样<application>libpq</application>库会被编译进去，也可以用选项<literal>-L<replaceable>directory</replaceable></literal>向编译器指出<application>libpq</application>库所在的位置（再次，编译器将默认搜索某些目录）。为了最大的可移植性，将<option>-L</option>选项放在<option>-lpq</option>选项前面。例如：
<programlisting>
cc -o testprog testprog1.o testprog2.o -L/usr/local/pgsql/lib -lpq
</programlisting>
     </para>

     <para>
      你也可以使用<command>pg_config</command>找出库目录：
<screen>
<prompt>$</prompt> pg_config --libdir
<computeroutput>/usr/local/pgsql/lib</computeroutput>
</screen>
     </para>

     <para>
      或者再次使用<command>pkg-config</command>：
<screen>
<prompt>$</prompt> pkg-config --libs libpq
<computeroutput>-L/usr/local/pgsql/lib -lpq</computeroutput>
</screen>
      再次提示这会打印出全部的选项，而不仅仅是路径。
     </para>

     <para>
      指出这一部分问题的错误消息可能看起来像：
<screen>
testlibpq.o: In function `main':
testlibpq.o(.text+0x60): undefined reference to `PQsetdbLogin'
testlibpq.o(.text+0x71): undefined reference to `PQstatus'
testlibpq.o(.text+0xa4): undefined reference to `PQerrorMessage'
</screen>
      This means you forgot <option>-lpq</option>.
<screen>
/usr/bin/ld: cannot find -lpq
</screen>
      这意味着你忘记了<option>-L</option>选项或者没有指定正确的目录。
     </para>
    </listitem>
   </itemizedlist>
  </para>
<!-- pgdoc-cn_end sig_en=1063f6644020421bd09acef8255b198c -->

 </sect1>


 <sect1 id="libpq-example">
<!-- pgdoc-cn_start sig_en=3aa3fbaa064c2c5e15164fe804ff8ffc sig_cn_org=None source=14.1 
  <title>Example Programs</title>
________________________________________________________-->
  <title>例子程序</title>
<!-- pgdoc-cn_end sig_en=3aa3fbaa064c2c5e15164fe804ff8ffc -->

<!-- pgdoc-cn_start sig_en=3da17895dd264f28d84e5706baba8682 sig_cn_org=None source=14.1 
  <para>
   These examples and others can be found in the
   directory <filename>src/test/examples</filename> in the source code
   distribution.
  </para>
________________________________________________________-->
  <para>
   这些例子和其他例子可以在源代码发布的<filename>src/test/examples</filename>目录中找到。
  </para>
<!-- pgdoc-cn_end sig_en=3da17895dd264f28d84e5706baba8682 -->

  <example id="libpq-example-1">
<!-- pgdoc-cn_start sig_en=34ac71108c87250251f79ff4a4fc6bec sig_cn_org=None source=14.1 
   <title><application>libpq</application> Example Program 1</title>
________________________________________________________-->
   <title><application>libpq</application> 例子程序 1</title>
<!-- pgdoc-cn_end sig_en=34ac71108c87250251f79ff4a4fc6bec -->

<programlisting>
<![CDATA[
/*
 * src/test/examples/testlibpq.c
 *
 *
 * testlibpq.c
 *
 *      Test the C version of libpq, the PostgreSQL frontend library.
 */
#include <stdio.h>
#include <stdlib.h>
#include "libpq-fe.h"

static void
exit_nicely(PGconn *conn)
{
    PQfinish(conn);
    exit(1);
}

int
main(int argc, char **argv)
{
    const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    int         nFields;
    int         i,
                j;

    /*
     * If the user supplies a parameter on the command line, use it as the
     * conninfo string; otherwise default to setting dbname=postgres and using
     * environment variables or defaults for all other connection parameters.
     */
    if (argc > 1)
        conninfo = argv[1];
    else
        conninfo = "dbname = postgres";

    /* Make a connection to the database */
    conn = PQconnectdb(conninfo);

    /* Check to see that the backend connection was successfully made */
    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "%s", PQerrorMessage(conn));
        exit_nicely(conn);
    }

    /* Set always-secure search path, so malicious users can't take control. */
    res = PQexec(conn,
                 "SELECT pg_catalog.set_config('search_path', '', false)");
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        fprintf(stderr, "SET failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    /*
     * Should PQclear PGresult whenever it is no longer needed to avoid memory
     * leaks
     */
    PQclear(res);

    /*
     * Our test case here involves using a cursor, for which we must be inside
     * a transaction block.  We could do the whole thing with a single
     * PQexec() of "select * from pg_database", but that's too trivial to make
     * a good example.
     */

    /* Start a transaction block */
    res = PQexec(conn, "BEGIN");
    if (PQresultStatus(res) != PGRES_COMMAND_OK)
    {
        fprintf(stderr, "BEGIN command failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }
    PQclear(res);

    /*
     * Fetch rows from pg_database, the system catalog of databases
     */
    res = PQexec(conn, "DECLARE myportal CURSOR FOR select * from pg_database");
    if (PQresultStatus(res) != PGRES_COMMAND_OK)
    {
        fprintf(stderr, "DECLARE CURSOR failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }
    PQclear(res);

    res = PQexec(conn, "FETCH ALL in myportal");
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        fprintf(stderr, "FETCH ALL failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    /* first, print out the attribute names */
    nFields = PQnfields(res);
    for (i = 0; i < nFields; i++)
        printf("%-15s", PQfname(res, i));
    printf("\n\n");

    /* next, print out the rows */
    for (i = 0; i < PQntuples(res); i++)
    {
        for (j = 0; j < nFields; j++)
            printf("%-15s", PQgetvalue(res, i, j));
        printf("\n");
    }

    PQclear(res);

    /* close the portal ... we don't bother to check for errors ... */
    res = PQexec(conn, "CLOSE myportal");
    PQclear(res);

    /* end the transaction */
    res = PQexec(conn, "END");
    PQclear(res);

    /* close the connection to the database and cleanup */
    PQfinish(conn);

    return 0;
}
]]>
</programlisting>
  </example>

  <example id="libpq-example-2">
<!-- pgdoc-cn_start sig_en=0ccbfe8e22f5d3d3d8f79361376312a1 sig_cn_org=None source=14.1 
   <title><application>libpq</application> Example Program 2</title>
________________________________________________________-->
   <title><application>libpq</application>例子程序 2</title>
<!-- pgdoc-cn_end sig_en=0ccbfe8e22f5d3d3d8f79361376312a1 -->

<programlisting>
<![CDATA[
/*
 * src/test/examples/testlibpq2.c
 *
 *
 * testlibpq2.c
 *      Test of the asynchronous notification interface
 *
 * Start this program, then from psql in another window do
 *   NOTIFY TBL2;
 * Repeat four times to get this program to exit.
 *
 * Or, if you want to get fancy, try this:
 * populate a database with the following commands
 * (provided in src/test/examples/testlibpq2.sql):
 *
 *   CREATE SCHEMA TESTLIBPQ2;
 *   SET search_path = TESTLIBPQ2;
 *   CREATE TABLE TBL1 (i int4);
 *   CREATE TABLE TBL2 (i int4);
 *   CREATE RULE r1 AS ON INSERT TO TBL1 DO
 *     (INSERT INTO TBL2 VALUES (new.i); NOTIFY TBL2);
 *
 * Start this program, then from psql do this four times:
 *
 *   INSERT INTO TESTLIBPQ2.TBL1 VALUES (10);
 */

#ifdef WIN32
#include <windows.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/time.h>
#include <sys/types.h>
#ifdef HAVE_SYS_SELECT_H
#include <sys/select.h>
#endif

#include "libpq-fe.h"

static void
exit_nicely(PGconn *conn)
{
    PQfinish(conn);
    exit(1);
}

int
main(int argc, char **argv)
{
    const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    PGnotify   *notify;
    int         nnotifies;

    /*
     * If the user supplies a parameter on the command line, use it as the
     * conninfo string; otherwise default to setting dbname=postgres and using
     * environment variables or defaults for all other connection parameters.
     */
    if (argc > 1)
        conninfo = argv[1];
    else
        conninfo = "dbname = postgres";

    /* Make a connection to the database */
    conn = PQconnectdb(conninfo);

    /* Check to see that the backend connection was successfully made */
    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "%s", PQerrorMessage(conn));
        exit_nicely(conn);
    }

    /* Set always-secure search path, so malicious users can't take control. */
    res = PQexec(conn,
                 "SELECT pg_catalog.set_config('search_path', '', false)");
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        fprintf(stderr, "SET failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    /*
     * Should PQclear PGresult whenever it is no longer needed to avoid memory
     * leaks
     */
    PQclear(res);

    /*
     * Issue LISTEN command to enable notifications from the rule's NOTIFY.
     */
    res = PQexec(conn, "LISTEN TBL2");
    if (PQresultStatus(res) != PGRES_COMMAND_OK)
    {
        fprintf(stderr, "LISTEN command failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }
    PQclear(res);

    /* Quit after four notifies are received. */
    nnotifies = 0;
    while (nnotifies < 4)
    {
        /*
         * Sleep until something happens on the connection.  We use select(2)
         * to wait for input, but you could also use poll() or similar
         * facilities.
         */
        int         sock;
        fd_set      input_mask;

        sock = PQsocket(conn);

        if (sock < 0)
            break;              /* shouldn't happen */

        FD_ZERO(&input_mask);
        FD_SET(sock, &input_mask);

        if (select(sock + 1, &input_mask, NULL, NULL, NULL) < 0)
        {
            fprintf(stderr, "select() failed: %s\n", strerror(errno));
            exit_nicely(conn);
        }

        /* Now check for input */
        PQconsumeInput(conn);
        while ((notify = PQnotifies(conn)) != NULL)
        {
            fprintf(stderr,
                    "ASYNC NOTIFY of '%s' received from backend PID %d\n",
                    notify->relname, notify->be_pid);
            PQfreemem(notify);
            nnotifies++;
            PQconsumeInput(conn);
        }
    }

    fprintf(stderr, "Done.\n");

    /* close the connection to the database and cleanup */
    PQfinish(conn);

    return 0;
}
]]>
</programlisting>
  </example>

  <example id="libpq-example-3">
<!-- pgdoc-cn_start sig_en=9714f926c401d8388d1e6401b659d562 sig_cn_org=None source=14.1 
   <title><application>libpq</application> Example Program 3</title>
________________________________________________________-->
   <title><application>libpq</application>例子程序 3</title>
<!-- pgdoc-cn_end sig_en=9714f926c401d8388d1e6401b659d562 -->

<programlisting>
<![CDATA[
/*
 * src/test/examples/testlibpq3.c
 *
 *
 * testlibpq3.c
 *      Test out-of-line parameters and binary I/O.
 *
 * Before running this, populate a database with the following commands
 * (provided in src/test/examples/testlibpq3.sql):
 *
 * CREATE SCHEMA testlibpq3;
 * SET search_path = testlibpq3;
 * SET standard_conforming_strings = ON;
 * CREATE TABLE test1 (i int4, t text, b bytea);
 * INSERT INTO test1 values (1, 'joe''s place', '\000\001\002\003\004');
 * INSERT INTO test1 values (2, 'ho there', '\004\003\002\001\000');
 *
 * The expected output is:
 *
 * tuple 0: got
 *  i = (4 bytes) 1
 *  t = (11 bytes) 'joe's place'
 *  b = (5 bytes) \000\001\002\003\004
 *
 * tuple 0: got
 *  i = (4 bytes) 2
 *  t = (8 bytes) 'ho there'
 *  b = (5 bytes) \004\003\002\001\000
 */

#ifdef WIN32
#include <windows.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <sys/types.h>
#include "libpq-fe.h"

/* for ntohl/htonl */
#include <netinet/in.h>
#include <arpa/inet.h>


static void
exit_nicely(PGconn *conn)
{
    PQfinish(conn);
    exit(1);
}

/*
 * This function prints a query result that is a binary-format fetch from
 * a table defined as in the comment above.  We split it out because the
 * main() function uses it twice.
 */
static void
show_binary_results(PGresult *res)
{
    int         i,
                j;
    int         i_fnum,
                t_fnum,
                b_fnum;

    /* Use PQfnumber to avoid assumptions about field order in result */
    i_fnum = PQfnumber(res, "i");
    t_fnum = PQfnumber(res, "t");
    b_fnum = PQfnumber(res, "b");

    for (i = 0; i < PQntuples(res); i++)
    {
        char       *iptr;
        char       *tptr;
        char       *bptr;
        int         blen;
        int         ival;

        /* Get the field values (we ignore possibility they are null!) */
        iptr = PQgetvalue(res, i, i_fnum);
        tptr = PQgetvalue(res, i, t_fnum);
        bptr = PQgetvalue(res, i, b_fnum);

        /*
         * The binary representation of INT4 is in network byte order, which
         * we'd better coerce to the local byte order.
         */
        ival = ntohl(*((uint32_t *) iptr));

        /*
         * The binary representation of TEXT is, well, text, and since libpq
         * was nice enough to append a zero byte to it, it'll work just fine
         * as a C string.
         *
         * The binary representation of BYTEA is a bunch of bytes, which could
         * include embedded nulls so we have to pay attention to field length.
         */
        blen = PQgetlength(res, i, b_fnum);

        printf("tuple %d: got\n", i);
        printf(" i = (%d bytes) %d\n",
               PQgetlength(res, i, i_fnum), ival);
        printf(" t = (%d bytes) '%s'\n",
               PQgetlength(res, i, t_fnum), tptr);
        printf(" b = (%d bytes) ", blen);
        for (j = 0; j < blen; j++)
            printf("\\%03o", bptr[j]);
        printf("\n\n");
    }
}

int
main(int argc, char **argv)
{
    const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    const char *paramValues[1];
    int         paramLengths[1];
    int         paramFormats[1];
    uint32_t    binaryIntVal;

    /*
     * If the user supplies a parameter on the command line, use it as the
     * conninfo string; otherwise default to setting dbname=postgres and using
     * environment variables or defaults for all other connection parameters.
     */
    if (argc > 1)
        conninfo = argv[1];
    else
        conninfo = "dbname = postgres";

    /* Make a connection to the database */
    conn = PQconnectdb(conninfo);

    /* Check to see that the backend connection was successfully made */
    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "%s", PQerrorMessage(conn));
        exit_nicely(conn);
    }

    /* Set always-secure search path, so malicious users can't take control. */
    res = PQexec(conn, "SET search_path = testlibpq3");
    if (PQresultStatus(res) != PGRES_COMMAND_OK)
    {
        fprintf(stderr, "SET failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }
    PQclear(res);

    /*
     * The point of this program is to illustrate use of PQexecParams() with
     * out-of-line parameters, as well as binary transmission of data.
     *
     * This first example transmits the parameters as text, but receives the
     * results in binary format.  By using out-of-line parameters we can avoid
     * a lot of tedious mucking about with quoting and escaping, even though
     * the data is text.  Notice how we don't have to do anything special with
     * the quote mark in the parameter value.
     */

    /* Here is our out-of-line parameter value */
    paramValues[0] = "joe's place";

    res = PQexecParams(conn,
                       "SELECT * FROM test1 WHERE t = $1",
                       1,       /* one param */
                       NULL,    /* let the backend deduce param type */
                       paramValues,
                       NULL,    /* don't need param lengths since text */
                       NULL,    /* default to all text params */
                       1);      /* ask for binary results */

    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        fprintf(stderr, "SELECT failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    show_binary_results(res);

    PQclear(res);

    /*
     * In this second example we transmit an integer parameter in binary form,
     * and again retrieve the results in binary form.
     *
     * Although we tell PQexecParams we are letting the backend deduce
     * parameter type, we really force the decision by casting the parameter
     * symbol in the query text.  This is a good safety measure when sending
     * binary parameters.
     */

    /* Convert integer value "2" to network byte order */
    binaryIntVal = htonl((uint32_t) 2);

    /* Set up parameter arrays for PQexecParams */
    paramValues[0] = (char *) &binaryIntVal;
    paramLengths[0] = sizeof(binaryIntVal);
    paramFormats[0] = 1;        /* binary */

    res = PQexecParams(conn,
                       "SELECT * FROM test1 WHERE i = $1::int4",
                       1,       /* one param */
                       NULL,    /* let the backend deduce param type */
                       paramValues,
                       paramLengths,
                       paramFormats,
                       1);      /* ask for binary results */

    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        fprintf(stderr, "SELECT failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    show_binary_results(res);

    PQclear(res);

    /* close the connection to the database and cleanup */
    PQfinish(conn);

    return 0;
}
]]>
</programlisting>
  </example>

 </sect1>
</chapter>
