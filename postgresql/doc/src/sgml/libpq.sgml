<!-- doc/src/sgml/libpq.sgml -->

<chapter id="libpq">
 <title><application>libpq</application> - C 库</title>

 <indexterm zone="libpq">
  <primary>libpq</primary>
 </indexterm>

 <indexterm zone="libpq">
  <primary>C</primary>
 </indexterm>

 <para>
  <application>libpq</application>是应用程序员使用<productname>PostgreSQL</>的<acronym>C</acronym>接口。<application>libpq</>是一个库函数的集合，它们允许客户端程序传递查询给<productname>PostgreSQL</>后端服务器并且接收这些查询的结果。
 </para>

 <para>
  <application>libpq</>也是很多其他<productname>PostgreSQL</>应用接口的底层引擎，包括为 C++、Perl、Python、Tcl 和 <application>ECPG</>编写的接口。如果你使用那些包，某些方面的<application>libpq</>行为将会对你很重要。特别是，<xref linkend="libpq-envars">、<xref linkend="libpq-pgpass">和<xref linkend="libpq-ssl">描述了任何使用<application>libpq</>的应用的用户可见的行为。
 </para>

 <para>
  在本章的末尾（<xref linkend="libpq-example">）包括了一些短程序来展示如何编写使用<application>libpq</application>的应用。在源代码发布的<filename>src/test/examples</filename>目录中还有一些完整的<application>libpq</application>应用的例子。
 </para>

 <para>
  使用<application>libpq</application>的客户端程序必须包括头文件<filename>libpq-fe.h</filename><indexterm><primary>libpq-fe.h</></>并必须与<application>libpq</application>库链接在一起。
 </para>

 <sect1 id="libpq-connect">
  <title>数据库连接控制函数</title>

  <para>
   下列函数会建立到一个<productname>PostgreSQL</productname>后端服务器的连接。一个应用程序可以在一个时刻打开多个后端连接（原因之一就是为了访问多个数据库）。每个连接用一个<structname>PGconn</><indexterm><primary>PGconn</></>对象表示，它从函数<function>PQconnectdb</>、<function>PQconnectdbParams</>或<function>PQsetdbLogin</>得到。注意这些函数将总是返回一个非空的对象指针，除非正好没有内存来分配<structname>PGconn</>对象。在通过该连接对象发送查询之前，应该调用<function>PQstatus</>函数来检查返回值以确定是否得到了一个成功的连接。

   <warning>
    <para>
     在 Unix 上，复制一个拥有打开 libpq 连接的进程可能导致不可以预料的结果，因为父进程和子进程会共享相同的套接字和操作系统资源。出于这个原因，我们不推荐这样的用法，尽管从子进程执行一个<function>exec</>来载入新的可执行代码是安全的。
    </para>
   </warning>

   <note>
    <para>
     在 Windows 上，如果一个单一数据库连接被反复地开启并且关闭，这是一种提升性能的方式。在内部，libpq 为开启和关闭分别调用<function>WSAStartup()</>和<function>WSACleanup()</>。<function>WSAStartup()</>会增加一个内部 Windows 库引用计数而<function>WSACleanup()</>则会减少之。当引用计数正好为一时，调用<function>WSACleanup()</>会释放所有资源并且所有 DLL 会被卸载。这是一种昂贵的操作。为了避免它，一个应用可以手动调用<function>WSAStartup()</>，这样当最后的数据库连接被关闭时资源不会被释放。
    </para>
   </note>

   <variablelist>
    <varlistentry id="libpq-pqconnectdbparams">
     <term><function>PQconnectdbParams</function><indexterm><primary>PQconnectdbParams</></></term>
     <listitem>
      <para>
       开启一个到数据库服务器的新连接。

<synopsis>
PGconn *PQconnectdbParams(const char * const *keywords,
                          const char * const *values,
                          int expand_dbname);
</synopsis>
      </para>

      <para>
       这个函数使用从两个以<symbol>NULL</symbol>结尾的数组中取得的参数打开一个新的数据库连接。第一个数组<literal>keywords</literal>被定义为一个字符串数组，每一个元素是一个关键词。第二个数组<literal>values</literal>给出了每个关键词的值。和下面的<function>PQsetdbLogin</>不同，可以在不改变函数签名的情况下扩展参数集合，因此使用这个函数（或者与之相似的非阻塞的<function>PQconnectStartParams</>和<function>PQconnectPoll</function>）对于新应用编程要更好。 
      </para>

      <para>
       当前能被识别的参数关键词被列举在<xref linkend="libpq-paramkeywords">中。
      </para>

      <para>
       其可能的格式详见<xref linkend="libpq-connstring">。
       当<literal>expand_dbname</literal>为非零时，<parameter>dbname</parameter>
       关键词的值被允许识别为一个连接字符串。只有<parameter>dbname</parameter>
       的第一次出现会按这种方式扩展，任何后续<parameter>dbname</parameter>值会被当
       做一个普通数据库名处理。有关可能的连接字符串格式的详情可见
       <xref linkend="libpq-connstring">。
      </para>

      <para>
       被传递的数组可以为空，这样就会使用所有默认参数。也可以只包含一个或几个参数设置。两个参数数组应该在长度上匹配。对于参数数组的处理将会停止于<literal>keywords</literal>数组中第一个非-<symbol>NULL</symbol>元素。
      </para>

      <para>
       如果任何一个参数是<symbol>NULL</symbol>或者一个空字符串，那么将会检查相应的环境变量（见<xref linkend="libpq-envars">）。如果该环境变量也没有被设置，那么将使用内建的默认值。
      </para>

      <para>
       通常，关键词的处理是从这些数组的头部开始并且以索引顺序进行。这样做的效果就是，当关键词有重复时，只会保留最后一个被处理的值。因此，通过小心地放置关键词<parameter>dbname</parameter>，可以决定什么会被一个<parameter>conninfo</parameter>字符串所重载，以及什么不会被重载。
      </para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconnectdb">
     <term><function>PQconnectdb</function><indexterm><primary>PQconnectdb</></></term>
     <listitem>
      <para>
       开启一个到数据库服务器的新连接。

<synopsis>
PGconn *PQconnectdb(const char *conninfo);
</synopsis>
      </para>

      <para>
       这个函数使用从字符串<literal>conninfo</literal>中得到的参数开启一个新的数据库连接。
      </para>

      <para>
       被传递的字符串可以为空，这样将会使用所有的默认参数。也可以包含由空格分隔的一个或多个参数设置，还可以包含一个<acronym>URI</acronym>。详见<xref linkend="libpq-connstring">。
     </para>


    </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsetdblogin">
     <term><function>PQsetdbLogin</function><indexterm><primary>PQsetdbLogin</></></term>
     <listitem>
      <para>
       开启一个到数据库服务器的新连接。
<synopsis>
PGconn *PQsetdbLogin(const char *pghost,
                     const char *pgport,
                     const char *pgoptions,
                     const char *pgtty,
                     const char *dbName,
                     const char *login,
                     const char *pwd);
</synopsis>
       </para>

       <para>
        这是<function>PQconnectdb</function>的带有固定参数集合的前辈。它具有相同的功能，不过其中缺失的参数将总是采用默认值。对任意一个固定参数写<symbol>NULL</symbol>或一个空字符串将会使它采用默认值。
      </para>

      <para>
        如果<parameter>dbName</parameter>包含一个<symbol>=</symbol>符号或者具有一个合法的连接<acronym>URI</acronym>前缀，它会被当作一个<parameter>conninfo</parameter>字符串，就好像它已经被传递给了<function>PQconnectdb</function>，并且剩余的参数则被应用为指定给<function>PQconnectdbParams</>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsetdb">
     <term><function>PQsetdb</function><indexterm><primary>PQsetdb</></></term>
     <listitem>
      <para>
   开启一个到数据库服务器的新连接。
<synopsis>
PGconn *PQsetdb(char *pghost,
                char *pgport,
                char *pgoptions,
                char *pgtty,
                char *dbName);
</synopsis>
     </para>

     <para>
      这是一个调用<function>PQsetdbLogin</function>的宏，其中为<parameter>login</>和<parameter>pwd</>参数使用空指针。提供它是为了向后兼容非常老的程序。
     </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconnectstartparams">
     <term><function>PQconnectStartParams</function><indexterm><primary>PQconnectStartParams</></></term>
     <term><function>PQconnectStart</function><indexterm><primary>PQconnectStart</></></term>
     <term><function>PQconnectPoll</function><indexterm><primary>PQconnectPoll</></></term>
     <listitem>
      <para>
       <indexterm><primary>nonblocking connection</primary></indexterm>
       以非阻塞的方式建立一个到数据库服务器的连接。

<synopsis>
PGconn *PQconnectStartParams(const char * const *keywords,
                             const char * const *values,
                             int expand_dbname);

PGconn *PQconnectStart(const char *conninfo);

PostgresPollingStatusType PQconnectPoll(PGconn *conn);
</synopsis>
      </para>

      <para>
       这三个函数被用来开启一个到数据库服务器的连接，这样你的应用的执行线程不会因为远程的I/O而被阻塞。这种方法的要点在于等待 I/O 完成可能在应用的主循环中发生，而不是在<function>PQconnectdbParams</>或<function>PQconnectdb</>中，并且因此应用能够把这种操作和其他动作并行处理。
      </para>

      <para>
       在<function>PQconnectStartParams</function>中，数据库连接使用从<literal>keywords</literal>和<literal>values</literal>数组中取得的参数创建，并且被<literal>expand_dbname</literal>控制，这和之前描述的<function>PQconnectdbParams</function>相同。
      </para>

      <para>
       在<function>PQconnectStart</function>中，数据库连接使用从字符串<literal>conninfo</literal>中取得的参数创建，这和之前描述的<function>PQconnectdb</function>相同。
      </para>

      <para>
       只要满足一些限制，<function>PQconnectStartParams</function>或<function>PQconnectStart</function>或<function>PQconnectPoll</function>都不会阻塞：
       <itemizedlist>
        <listitem>
         <para>
          <literal>hostaddr</>和<literal>host</>参数被合适地使用，以确保不会做名字或逆向名字查询。详见<xref linkend="libpq-paramkeywords">中这些参数的文档。
         </para>
        </listitem>

        <listitem>
         <para>
          如果你调用<function>PQtrace</function>，确保你追踪的该流对象不会阻塞。
         </para>
        </listitem>

        <listitem>
         <para>
          如后文所述，你要确保在调用<function>PQconnectPoll</function>之前，套接字处于合适的状态。
         </para>
        </listitem>
       </itemizedlist>
      </para>

      <para>
       注意：<function>PQconnectStartParams</>的使用和下文所示的<function>PQconnectStart</>类似。
      </para>

      <para>
       要开始一个非阻塞的连接请求，可调用<literal>conn = PQconnectStart("<replaceable>connection_info_string</>")</literal>。如果<varname>conn</varname>为空，那么<application>libpq</>无法分配一个新的<structname>PGconn</>结构。否则，一个合法的<structname>PGconn</>指针将被返回（尽管并不表示代表一个到数据库的合法连接）。在从<function>PQconnectStart</function>返回时，调用<literal>status = PQstatus(conn)</literal>。如果<varname>status</varname>等于<symbol>CONNECTION_BAD</symbol>，就说明<function>PQconnectStart</function>已经失败。
      </para>

      <para>
       如果<function>PQconnectStart</>成功，下一个阶段是轮询<application>libpq</>，这样它能够继续进行连接序列。使用<function>PQsocket(conn)</function>来获得该数据库连接底层的套接字描述符。这样循环：如果<function>PQconnectPoll(conn)</function>上一次返回<symbol>PGRES_POLLING_READING</symbol>，等到该套接字准备好读取（按照<function>select()</>、<function>poll()</>或类似的系统函数所指示的）。则再次调用<function>PQconnectPoll(conn)</function>。反之，如果<function>PQconnectPoll(conn)</function>上一次返回<symbol>PGRES_POLLING_WRITING</symbol>，等到该套接字准备好写入，则再次调用<function>PQconnectPoll(conn)</function>。如果你还没有调用<function>PQconnectPoll</function>，即刚好在对<function>PQconnectStart</function>的调用之后，行为就像是它上次返回了<symbol>PGRES_POLLING_WRITING</symbol>。持续这个循环直到<function>PQconnectPoll(conn)</function>返回<symbol>PGRES_POLLING_FAILED</symbol>指示连接过程已经失败，或者返回<symbol>PGRES_POLLING_OK</symbol>指示连接已经被成功地建立。
      </para>

      <para>
       在连接期间的任意时刻，该连接的状态可以通过调用<function>PQstatus</>来检查。如果这个调用返回<symbol>CONNECTION_BAD</>，那么连接过程已经失败。如果该调用返回<function>CONNECTION_OK</>，则该连接已经准备好。如前所述，这些状态同样都可以从<function>PQconnectPoll</>的返回值检测。在一个异步连接过程中（也只有在这个过程中）也可能出现其他状态。这些状态指示该连接过程的当前阶段，并且可能有助于为用户提供反馈。这些状态是：

       <variablelist>
        <varlistentry id="libpq-connection-started">
         <term><symbol>CONNECTION_STARTED</symbol></term>
         <listitem>
          <para>
           等待连接被建立。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-made">
         <term><symbol>CONNECTION_MADE</symbol></term>
         <listitem>
          <para>
           连接 OK，等待发送。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-awaiting-response">
         <term><symbol>CONNECTION_AWAITING_RESPONSE</symbol></term>
         <listitem>
          <para>
           等待来自服务器的一个回应。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-auth-ok">
         <term><symbol>CONNECTION_AUTH_OK</symbol></term>
         <listitem>
          <para>
           收到认证，等待后端启动结束。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-ssl-startup">
         <term><symbol>CONNECTION_SSL_STARTUP</symbol></term>
         <listitem>
          <para>
           协商 SSL 加密。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-setenv">
         <term><symbol>CONNECTION_SETENV</symbol></term>
         <listitem>
          <para>
           协商环境驱动的参数设置。
          </para>
         </listitem>
        </varlistentry>
       </variablelist>

       注意，尽管这些常数将被保留（为了维护兼容性），一个应用永远不应该依赖这些状态按照特定顺序出现，或者根本就不依赖它们，或者不依赖状态总是这些文档中所说的值。一个应用可能做些这样的事情：
<programlisting>
switch(PQstatus(conn))
{
        case CONNECTION_STARTED:
            feedback = "Connecting...";
            break;

        case CONNECTION_MADE:
            feedback = "Connected to server...";
            break;
.
.
.
        default:
            feedback = "Connecting...";
}
</programlisting>
      </para>

      <para>
       在使用<function>PQconnectPoll</function>时，连接参数<literal>connect_timeout</literal>会被忽略：判断是否超时是应用的责任。否则，<function>PQconnectStart</function>后面跟着后面跟着<function>PQconnectPoll</function>循环等效于<function>PQconnectdb</function>。
      </para>

      <para>
       注意如果<function>PQconnectStart</function>返回一个非空的指针，你必须在用完它之后调用<function>PQfinish</function>来处理那些结构和任何相关的内存块。即使连接尝试失败或被放弃时也必须完成这些工作。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconndefaults">
     <term><function>PQconndefaults</function><indexterm><primary>PQconndefaults</></></term>
     <listitem>
      <para>
       返回默认连接选项。
<synopsis>
PQconninfoOption *PQconndefaults(void);

typedef struct
{
    char   *keyword;   /* 该选项的关键词 */
    char   *envvar;    /* 依赖的环境变量名 */
    char   *compiled;  /* 依赖的内建默认值 */
    char   *val;       /* 选项的当前值，或者 NULL */
    char   *label;     /* 连接对话框中域的标签 */
    char   *dispchar;  /* 指示如何在一个连接对话框中显示这个域。值是：
                          ""        显示输入的值
                          "*"       口令域 - 隐藏值
                          "D"       调试选项 - 默认不显示 */
    int     dispsize;  /* 用于对话框的以字符计的域尺寸 */
} PQconninfoOption;
</synopsis>
      </para>

      <para>
       返回一个连接选项数组。这可以用来确定用于连接服务器的所有可能的<function>PQconnectdb</function>选项和它们的当前缺省值。返回值指向一个<structname>PQconninfoOption</structname>结构的数组，该数组以一个包含空<structfield>keyword</>指针的条目结束。如果无法分配内存，则返回该空指针。注意当前缺省值（<structfield>val</structfield>域）将依赖于环境变量和其他上下文。一个缺失或者无效的服务文件将会被无声地忽略掉。调用者必须把连接选项当作只读对待。
      </para>

      <para>
       在处理完选项数组后，把它交给<function>PQconninfoFree</function>释放。如果没有这么做， 每次调用<function>PQconndefaults</function>都会导致一小部分内存泄漏。
      </para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconninfo">
     <term><function>PQconninfo</function><indexterm><primary>PQconninfo</></></term>
     <listitem>
      <para>
       返回被一个活动连接使用的连接选项。
<synopsis>
PQconninfoOption *PQconninfo(PGconn *conn);
</synopsis>
      </para>

      <para>
       返回一个连接选项数组。这可以用来确定用于连接服务器的所有可能的<function>PQconnectdb</function>选项和它们的当前缺省值。返回值指向一个<structname>PQconninfoOption</structname>结构的数组，该数组以一个包含空<structfield>keyword</>指针的条目结束。上述所有对于<function>PQconndefaults</function>的注解也适用于<function>PQconninfo</function>的结果。
      </para>

     </listitem>
    </varlistentry>


    <varlistentry id="libpq-pqconninfoparse">
     <term><function>PQconninfoParse</function><indexterm><primary>PQconninfoParse</></></term>
     <listitem>
      <para>
       返回从提供的连接字符串中解析到的连接选项。

<synopsis>
PQconninfoOption *PQconninfoParse(const char *conninfo, char **errmsg);
</synopsis>
      </para>

      <para>
       解析一个连接字符串并且将结果选项作为一个数组返回，或者在连接字符串有问题时返回<symbol>NULL</>。这个函数可以用来抽取所提供的连接字符串中的<function>PQconnectdb</function>选项。返回值指向一个<structname>PQconninfoOption</structname>结构的数组，该数组以一个包含空<structfield>keyword</>指针的条目结束。
      </para>

      <para>
       所有合法选项将出现在结果数组中，但是任何在连接字符串中没有出现的选项的<literal>PQconninfoOption</literal>的<literal>val</literal>会被设置为<literal>NULL</literal>，默认值不会被插入。
      </para>

      <para>
       如果<literal>errmsg</>不是<symbol>NULL</>，那么成功时<literal>*errmsg</>会被设置为<symbol>NULL</>， 否则设置为被<function>malloc</>过的错误字符串以说明该问题（也可以将<literal>*errmsg</>设置为<symbol>NULL</>并且函数返回<symbol>NULL</>，这表示一种内存耗尽的情况）。
      </para>

      <para>
       在处理完选项数组后，把它交给<function>PQconninfoFree</function>释放。如果没有这么做， 每次调用<function>PQconninfoParse</function>都会导致一小部分内存泄漏。反过来，如果发生一个错误并且<literal>errmsg</>不是<symbol>NULL</>，确保使用<function>PQfreemem</>释放错误字符串。
      </para>

   </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfinish">
     <term><function>PQfinish</function><indexterm><primary>PQfinish</></></term>
     <listitem>
      <para>
       关闭与服务器的连接。同时释放<structname>PGconn</structname>对象使用的内存。
<synopsis>
void PQfinish(PGconn *conn);
</synopsis>
      </para>

      <para>
       注意，即使与服务器的连接尝试失败（由<function>PQstatus</function>指示），应用也应当调用<function>PQfinish</function>来释放<structname>PGconn</structname>对象使用的内存。不能在调用<function>PQfinish</function>之后再使用<structname>PGconn</>指针。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqreset">
     <term><function>PQreset</function><indexterm><primary>PQreset</></></term>
     <listitem>
      <para>
       重置与服务器的通讯通道。
<synopsis>
void PQreset(PGconn *conn);
</synopsis>
      </para>

      <para>
       此函数将关闭与服务器的连接，并且使用所有之前使用过的参数尝试重新建立与同一个服务器的连接。这可能有助于在工作连接丢失后的错误恢复。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqresetstart">
     <term><function>PQresetStart</function><indexterm><primary>PQresetStart</></></term>
     <term><function>PQresetPoll</function><indexterm><primary>PQresetPoll</></></term>
     <listitem>
      <para>
       以非阻塞方式重置与服务器的通讯通道。

<synopsis>
int PQresetStart(PGconn *conn);

PostgresPollingStatusType PQresetPoll(PGconn *conn);
</synopsis>
      </para>

      <para>
       这些函数将关闭与服务器的连接，并且使用所有之前使用过的参数尝试重新建立与同一个服务器的连接。这可能有助于在工作连接丢失后的错误恢复。它们和上面的<function>PQreset</function>的不同在于它们工作在非阻塞方式。这些函数受到<function>PQconnectStartParams</>、<function>PQconnectStart</>和<function>PQconnectPoll</>相同的限制。
      </para>

      <para>
       要发起一次连接重置，调用<function>PQresetStart</function>。如果它返回 0，那么重置失败。如果返回 1，用与使用<function>PQresetPoll</function>建立连接的相同方法使用<function>PQconnectPoll</function>重置连接。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqpingparams">
     <term><function>PQpingParams</function><indexterm><primary>PQpingParams</></></term>
     <listitem>
      <para>
       <function>PQpingParams</function>报告服务器的状态。它接受与<function>PQconnectdbParams</>相同的连接参数。获得服务器状态不需要提供正确的用户名、口令或数据库名。不过，如果提供了不正确的值，服务器将记录一次失败的连接尝试。

<synopsis>
PGPing PQpingParams(const char * const *keywords,
                    const char * const *values,
                    int expand_dbname);
</synopsis>

       该函数返回下列值之一：

       <variablelist>
        <varlistentry id="libpq-pqpingparams-pqping-ok">
         <term><literal>PQPING_OK</literal></term>
         <listitem>
          <para>
           服务器正在运行，并且看起来可以接受连接。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pqpingparams-pqping-reject">
         <term><literal>PQPING_REJECT</literal></term>
         <listitem>
          <para>
           服务器正在运行，但是处于一种不允许连接的状态（启动、关闭或崩溃恢复）。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pqpingparams-pqping-no-response">
         <term><literal>PQPING_NO_RESPONSE</literal></term>
         <listitem>
          <para>
           无法联系到服务器。这可能表示服务器没有运行，或者给定的连接参数中有些错误（例如，错误的端口号），或者有一个网络连接问题（例如，一个防火墙阻断了连接请求）。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pqpingparams-pqping-no-attempt">
         <term><literal>PQPING_NO_ATTEMPT</literal></term>
         <listitem>
          <para>
           没有尝试联系服务器，因为提供的参数显然不正确，或者有一些客户端问题（例如，内存用完）。
          </para>
         </listitem>
        </varlistentry>
       </variablelist>

      </para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqping">
     <term><function>PQping</function><indexterm><primary>PQping</></></term>
     <listitem>
      <para>
       <function>PQping</function>报告服务器的状态。它接受与<function>PQconnectdb</>相同的连接参数。获得服务器状态不需要提供正确的用户名、口令或数据库名。不过，如果提供了不正确的值，服务器将记录一次失败的连接尝试。

<synopsis>
PGPing PQping(const char *conninfo);
</synopsis>
      </para>

      <para>
       返回值和<function>PQpingParams</>相同。
      </para>

     </listitem>
    </varlistentry>

   </variablelist>
  </para>

  <sect2 id="libpq-connstring">
   <title>连接字符串</title>

   <indexterm zone="libpq-connstring">
    <primary><literal>conninfo</literal></primary>
   </indexterm>

   <indexterm zone="libpq-connstring">
    <primary><literal>URI</literal></primary>
   </indexterm>

   <para>
    几个<application>libpq</>函数会解析一个用户指定的字符串来获得连接参数。这些字符串有两种被接受的格式：纯<literal>关键词 = 值</literal>字符串以及<ulink url="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986</ulink> URI。
   </para>

   <sect3>
    <title>关键词/值连接字符串</title>

   <para>
    在第一种格式中，每一个参数设置的形式都是<literal>关键词 = 值</literal>。等号周围的空白是可选的。要写一个空值或一个包含空白的值，将它用单引号包围，例如<literal>关键词 = 'a value'</literal>。值里面的单引号和反斜线必须用一个反斜线转义，即<literal>\'</literal>和<literal>\\</literal>。
   </para>

   <para>
    例子：
<programlisting>
host=localhost port=5432 dbname=mydb connect_timeout=10
</programlisting>
   </para>

   <para>
    能被识别的参数关键词在<xref linkend="libpq-paramkeywords">中列出。
   </para>
   </sect3>

   <sect3>
    <title>连接 URI</title>

   <para>
   一个连接<acronym>URI</acronym>的一般形式是：
<synopsis>
postgresql://[user[:password]@][netloc][:port][/dbname][?param1=value1&amp;...]
</synopsis>
   </para>

   <para>
    <acronym>URI</acronym>模式标志符可以是<literal>postgresql://</literal>或<literal>postgres://</literal>。每一个<acronym>URI</acronym>部分都是可选的。下列例子展示了合法的<acronym>URI</acronym>语法：
<programlisting>
postgresql://
postgresql://localhost
postgresql://localhost:5433
postgresql://localhost/mydb
postgresql://user@localhost
postgresql://user:secret@localhost
postgresql://other@localhost/otherdb?connect_timeout=10&amp;application_name=myapp
</programlisting>
    <acronym>URI</acronym>的层次部分的组件可以作为参数给出。例如：
<programlisting>
postgresql:///mydb?host=localhost&amp;port=5433
</programlisting>
   </para>

   <para>
    在任意<acronym>URI</acronym>部分中可以使用百分号编码来包括有特殊含义的符号。
   </para>

   <para>
    任何不对应<xref linkend="libpq-paramkeywords">中列出的关键词的连接参数将被忽略并且关于它们的警告消息会被发送到<filename>stderr</filename>。
   </para>

   <para>
    为了提高和 JDBC 连接<acronym>URI</acronym>的兼容性，参数<literal>ssl=true</literal>的实例会被翻译成<literal>sslmode=require</literal>。
   </para>

   <para>
    主机部分可能是主机名或一个 IP 地址。要指定一个 IPv6 主机地址，将它封闭在方括号中：
<synopsis>
postgresql://[2001:db8::1234]/database
</synopsis>
   </para>

   <para>
    主机组件会被按照参数<xref linkend="libpq-connect-host">对应的描述来解释。特别地，如果主机部分是空或开始于一个斜线，将使用一个 Unix 域套接字连接，否则将启动一个 TCP/IP 连接。不过要注意，斜线是 URI 层次部分中的一个保留字符。因此，要指定一个非标准的 Unix 域套接字目录，要么忽略 URI 中的主机说明并且指定该主机为一个参数，要么在 URI 的主机部分用百分号编码路径：
<programlisting>
postgresql:///dbname?host=/var/lib/postgresql
postgresql://%2Fvar%2Flib%2Fpostgresql/dbname
</programlisting>
   </para>
   </sect3>
  </sect2>

  <sect2 id="libpq-paramkeywords">
   <title>参数关键词</title>

   <para>
    当前被识别的参数关键词是：

    <variablelist>
     <varlistentry id="libpq-connect-host" xreflabel="host">
      <term><literal>host</literal></term>
      <listitem>
       <para>
        要连接的主机名。<indexterm><primary>host name</></>如果它以一个斜线开始，则表示一个 Unix 域通信而不是 TCP/IP 通信，其值是存储套接字文件的目录名。当<literal>host</literal>没有指定时的默认行为是连接到一个<filename>/tmp</filename>（或者<productname>PostgreSQL</>编译时指定的任何套接字目录）中的 Unix 域套接字<indexterm><primary>Unix 域套接字</></>。在没有 Unix 域套接字的机器上，默认是连接到<literal>localhost</>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-hostaddr" xreflabel="hostaddr">
      <term><literal>hostaddr</literal></term>
      <listitem>
       <para>
        要连接的主机的数字 IP 地址。它应该是标准的 IPv4 地址格式，例如<literal>172.28.40.9</>。如果你的机器支持 IPv6，你也可以使用那些地址。当为这个参数指定一个非空字符串时，总是会使用 TCP/IP 通信。
       </para>

       <para>
        使用<literal>hostaddr</>代替<literal>host</>允许应用能避免一次主机名查找，这对于具有时间约束的应用可能非常重要。不过，GSSAPI 或 SSPI 认证方法以及<literal>verify-full</> SSL 证书验证还是要求一个主机名。使用的是下列规则：
        <itemizedlist>
         <listitem>
          <para>
           如果<literal>host</>被指定且没有<literal>hostaddr</>，将发生一次主机名查找。
          </para>
         </listitem>
         <listitem>
          <para>
           如果<literal>hostaddr</>被指定且没有<literal>host</>，<literal>hostaddr</>的值给出了服务器的网络地址。如果认证方法要求一个主机名则连接尝试将会失败。
          </para>
         </listitem>
         <listitem>
          <para>
           如果<literal>host</>和<literal>hostaddr</>都被指定，<literal>hostaddr</>的值给出服务器的网络地址。<literal>host</>的值将被忽略，除非认证方法要求它，在那种情况下它将被用作主机名。
          </para>
         </listitem>
        </itemizedlist>
        注意如果<literal>host</>不是网络地址<literal>hostaddr</>上的服务器名，认证很可能会失败。还有，注意<literal>host</>而不是<literal>hostaddr</>被用来标识<filename>~/.pgpass</>中的连接（见<xref linkend="libpq-pgpass">）。
       </para>

       <para>
        如果没有一个主机名或主机地址，<application>libpq</application>将尝试使用一个本地 Unix 域套接字连接，或者在没有 Unix 域套接字的机器上尝试连接到<literal>localhost</>。
       </para>
       </listitem>
      </varlistentry>

      <varlistentry id="libpq-connect-port" xreflabel="port">
       <term><literal>port</literal></term>
       <listitem>
       <para>
        在服务器主机上要连接的端口号，或者用于 Unix 域连接的套接字文件名扩展<indexterm><primary>port</></>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-dbname" xreflabel="dbname">
      <term><literal>dbname</literal></term>
      <listitem>
      <para>
       数据库名。默认和用户名相同。在一般的环境下，会为扩展格式检查该值，详见<xref linkend="libpq-connstring">。
      </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-user" xreflabel="user">
      <term><literal>user</literal></term>
      <listitem>
      <para>
       <productname>PostgreSQL</productname> 要作为哪个用户连接。默认与运行着该应用的用户的操作系统名相同。
      </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-password" xreflabel="password">
      <term><literal>password</literal></term>
      <listitem>
      <para>
       服务器要求口令认证时要使用的口令。
      </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-connect-timeout" xreflabel="connect_timeout">
      <term><literal>connect_timeout</literal></term>
      <listitem>
      <para>
       连接超时时间，以秒计（写成一个十进制整数字符串）。0 或未指定表示无限等待。我们不推荐使用低于 2 秒的超时时间。
      </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-client-encoding" xreflabel="client_encoding">
      <term><literal>client_encoding</literal></term>
      <listitem>
      <para>
       为连接设置<varname>client_encoding</varname>配置参数。除了被相应服务器选项所接受的值，你还能使用<literal>auto</literal>从客户端的当前区域（Unix 系统上的<envar>LC_CTYPE</envar>环境变量）决定正确的编码。
      </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-options" xreflabel="options">
      <term><literal>options</literal></term>
      <listitem>
       <para>
        增加在运行时发送给服务器的命令行选项。例如，设置这个参数为<literal>-c geqo=off</>会把会话的<varname>geqo</>参数值设置为<literal>off</>。可用选项的详细讨论请参考<xref linkend="runtime-config">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-application-name" xreflabel="application_name">
      <term><literal>application_name</literal></term>
      <listitem>
       <para>
        为<xref linkend="guc-application-name">配置参数指定一个值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-fallback-application-name" xreflabel="fallback_application_name">
      <term><literal>fallback_application_name</literal></term>
      <listitem>
       <para>
        为<xref linkend="guc-application-name">配置参数指定一个后补值。如果通过一个连接参数或<envar>PGAPPNAME</envar>环境变量没有为<literal>application_name</>给定一个值，将使用这个值。在希望设置一个默认应用名但不希望它被用户覆盖的一般工具程序中指定一个后补值很有用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-keepalives" xreflabel="keepalives">
      <term><literal>keepalives</literal></term>
      <listitem>
       <para>
        控制是否使用客户端的 TCP 保持存活机制。默认值是 1，表示打开。但是如果不想要保持存活机制，你可以改成 0 表示关闭。对于通过一个 Unix 域套接字建立的连接会忽略这个参数。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-keepalives-idle" xreflabel="keepalives_idle">
      <term><literal>keepalives_idle</literal></term>
      <listitem>
       <para>
        控制非活动多少秒之后 TCP 应该向服务器发送一个存活消息。零值表示使用系统默认值。对于一个通过 Unix 域套接字建立的连接将忽略这个参数，如果保持存活机制被禁用也将忽略这个参数。它只被<symbol>TCP_KEEPIDLE</>或<symbol>TCP_KEEPALIVE</>套接字选项可用的系统以及 Windows支持，在其他系统上，它没有效果。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-keepalives-interval" xreflabel="keepalives_interval">
      <term><literal>keepalives_interval</literal></term>
      <listitem>
       <para>
        控制一个 TCP 存活消息没有被服务器认可多少秒之后应该被重传。零值表示使用系统默认值。对于一个通过 Unix 域套接字建立的连接将忽略这个参数，如果保持存活机制被禁用也将忽略这个参数。它只被<symbol>TCP_KEEPINTVL</>套接字选项可用的系统以及 Windows支持，在其他系统上，它没有效果。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-keepalives-count" xreflabel="keepalives_count">
      <term><literal>keepalives_count</literal></term>
      <listitem>
       <para>
        控制该客户端到服务器的连接被认为死亡之前可以丢失的 TCP 保活消息数量。零值表示使用系统默认值。对于一个通过 Unix 域套接字建立的连接将忽略这个参数，如果保持存活机制被禁用也将忽略这个参数。它只被<symbol>TCP_KEEPCNT</>套接字选项可用的系统以及 Windows支持，在其他系统上，它没有效果。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-tty" xreflabel="tty">
      <term><literal>tty</literal></term>
      <listitem>
      <para>
       被忽略（之前，这指定向哪里发送服务器调试输出）。
      </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslmode" xreflabel="sslmode">
      <term><literal>sslmode</literal></term>
      <listitem>
       <para>
        这个选项决定一个<acronym>SSL</> TCP/IP连接是否将与服务器协商，或者决定以何种优先级协商。有六种模式：

        <variablelist>
         <varlistentry>
          <term><literal>disable</literal></term>
          <listitem>
           <para>
            只尝试非<acronym>SSL</>连接
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>allow</literal></term>
          <listitem>
           <para>
            首先尝试非<acronym>SSL</>连接，如果失败再尝试<acronym>SSL</>连接
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>prefer</literal>（默认）</term>
          <listitem>
           <para>
            首先尝试<acronym>SSL</>连接，如果失败再尝试非<acronym>SSL</>连接
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>require</literal></term>
          <listitem>
           <para>
            只尝试<acronym>SSL</>连接。如果存在一个根 CA 文件，以<literal>verify-ca</literal>被指定的相同方式验证该证书
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>verify-ca</literal></term>
          <listitem>
           <para>
            只尝试<acronym>SSL</>连接，并且验证服务器证书是由一个可信的证书机构颁发的（<acronym>CA</>）
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>verify-full</literal></term>
          <listitem>
           <para>
            只尝试<acronym>SSL</>连接，验证服务器证书是由一个可信的<acronym>CA</>颁发并且该服务器主机名匹配证书中的主机名
           </para>
          </listitem>
         </varlistentry>
        </variablelist>

        这些选项如何工作的详细描述见<xref linkend="libpq-ssl">。
       </para>

       <para>
        对于 Unix 域套接字通信，<literal>sslmode</>会被忽略。如果<productname>PostgreSQL</>被编译为不带 SSL 支持，使用选项<literal>require</>、<literal>verify-ca</>或<literal>verify-full</>将导致错误，而选项<literal>allow</>和<literal>prefer</>将会被接受但是<application>libpq</>将不会真正尝试<acronym>SSL</>连接。<indexterm><primary>SSL</><secondary
        sortas="libpq">with libpq</></indexterm>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-requiressl" xreflabel="requiressl">
      <term><literal>requiressl</literal></term>
      <listitem>
       <para>
        为了支持<literal>sslmode</>模式，这个选项已被废弃。
       </para>

       <para>
        如果设置为 1，则要求一个到服务器的<acronym>SSL</acronym>连接（这等效于<literal>sslmode</> <literal>require</>）。如果服务器不接受<acronym>SSL</acronym>连接，<application>libpq</>则将拒绝连接。如果设置为 0（默认），<application>libpq</>将与该服务器协商连接类型（等效于<literal>sslmode</> <literal>prefer</>）。只有<productname>PostgreSQL</>被编译为带有 SSL 支持，这个选项才可用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslcompression" xreflabel="sslcompression">
      <term><literal>sslcompression</literal></term>
      <listitem>
       <para>
        如果设置为 1（默认），SSL 连接之上传送的数据将被压缩（这要求<productname>OpenSSL</>版本 0.9.8 或更高）。如果设置为 0，压缩将被禁用（这要求<productname>OpenSSL</> 1.0.0 或更高）。如果建立的是一个没有 SSL 的连接，这个参数会被忽略。如果使用的<productname>OpenSSL</>版本不支持该参数，它也会被忽略。
       </para>
       <para>
        压缩会占用 CUP 时间，但是当瓶颈为网络时可以提高吞吐量。如果 CPU 性能是限制因素，禁用压缩能够改进响应时间和吞吐量。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslcert" xreflabel="sslcert">
      <term><literal>sslcert</literal></term>
      <listitem>
       <para>
        这个参数指定客户端 SSL 证书的文件名，它替换默认的<filename>~/.postgresql/postgresql.crt</>。如果没有建立 SSL 连接，这个参数会被忽略。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslkey" xreflabel="sslkey">
      <term><literal>sslkey</literal></term>
      <listitem>
       <para>
        这个参数指定用于客户端证书的密钥位置。它能指定一个会被用来替代默认的<filename>~/.postgresql/postgresql.key</>的文件名，或者它能够指定一个从外部<quote>引擎</>（引擎是<productname>OpenSSL</>的可载入模块）得到的密钥。一个外部引擎说明应该由一个冒号分隔的引擎名称以及一个引擎相关的关键标识符组成。如果没有建立 SSL 连接，这个参数会被忽略。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslrootcert" xreflabel="sslrootcert">
      <term><literal>sslrootcert</literal></term>
      <listitem>
       <para>
        这个参数指定一个包含 SSL 证书机构（<acronym>CA</>）证书的文件名称。如果该文件存在，服务器的证书将被验证是由这些机构之一签发。默认值是<filename>~/.postgresql/root.crt</>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslcrl" xreflabel="sslcrl">
      <term><literal>sslcrl</literal></term>
      <listitem>
       <para>
        这个参数指定 SSL 证书撤销列表（CRL）的文件名。列在这个文件中的证书如果存在，在尝试认证该服务器证书时会被拒绝。默认值是<filename>~/.postgresql/root.crl</>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-requirepeer" xreflabel="requirepeer">
      <term><literal>requirepeer</literal></term>
      <listitem>
       <para>
        这个参数指定服务器的操作系统用户，例如<literal>requirepeer=postgres</literal>。当建立一个 Unix 域套接字连接时，如果设置了这个参数，客户端在连接开始时检查服务器进程是否运行在指定的用户名之下。如果发现不是，该连接会被一个错误中断。这个参数能被用来提供与 TCP/IP 连接上 SSL 证书相似的服务器认证（注意，如果 Unix 域套接字在<filename>/tmp</filename>或另一个公共可写的位置，任何用户能启动一个在那里监听的服务器。使用这个参数来保证你连接的是一个由可信用户运行的服务器）。这个选项只在实现了<literal>peer</>认证方法的平台上受支持，见<xref linkend="auth-peer">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-krbsrvname" xreflabel="krbsrvname">
      <term><literal>krbsrvname</literal></term>
      <listitem>
       <para>
        当用 GSSAPI 认证时，要使用的 Kerberos 服务名。为了让 Kerberos 认证成功，这必须匹配在服务器配置中指定的服务名（另见<xref linkend="gssapi-auth">）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-gsslib" xreflabel="gsslib">
      <term><literal>gsslib</literal></term>
      <listitem>
       <para>
        用于 GSSAPI 认证的 GSS 库。只用在 Windows 上。设置为<literal>gssapi</literal>可强制 libpq 用 GSSAPI 库来代替默认的 SSPI 进行认证。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-service" xreflabel="service">
      <term><literal>service</literal></term>
      <listitem>
       <para>
        用于附加参数的服务名。它指定保持附加连接参数的<filename>pg_service.conf</filename>中的一个服务名。这允许应用只指定一个服务名，这样连接参数能被集中维护。见<xref linkend="libpq-pgservice">。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>
 </sect1>

 <sect1 id="libpq-status">
  <title>连接状态函数</title>

  <para>
   这些函数可以被用来询问一个已有数据库连接对象的状态。
  </para>

  <tip>
   <para>
    <indexterm><primary>libpq-fe.h</></>
    <indexterm><primary>libpq-int.h</></>
    <application>libpq</application>应用程序员应该小心地维护<structname>PGconn</structname>抽象。使用下面描述的访问函数来理解<structname>PGconn</structname>的内容。我们不推荐使用<filename>libpq-int.h</>引用内部的<structname>PGconn</structname>域，因为它们可能在未来改变。
   </para>
  </tip>

  <para>
   下列函数返回一个连接所建立的参数值。这些值在<structname>PGconn</>对象的生命期中是固定的。

   <variablelist>
    <varlistentry id="libpq-pqdb">
     <term>
      <function>PQdb</function>
      <indexterm>
       <primary>PQdb</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回该连接的数据库名。
<synopsis>
char *PQdb(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pquser">
     <term>
      <function>PQuser</function>
      <indexterm>
       <primary>PQuser</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回该连接的用户名。
<synopsis>
char *PQuser(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqpass">
     <term>
      <function>PQpass</function>
      <indexterm>
       <primary>PQpass</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回该连接的口令。
<synopsis>
char *PQpass(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqhost">
     <term>
      <function>PQhost</function>
      <indexterm>
       <primary>PQhost</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回该连接的服务器主机名。
<synopsis>
char *PQhost(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqport">
     <term>
      <function>PQport</function>
      <indexterm>
       <primary>PQport</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回该连接的端口。

<synopsis>
char *PQport(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqtty">
     <term>
      <function>PQtty</function>
      <indexterm>
       <primary>PQtty</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回该连接的调试<acronym>TTY</acronym>（这已被废弃，因为服务器不再关心<acronym>TTY</acronym>设置，但这个函数保持了向后兼容）。

<synopsis>
char *PQtty(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqoptions">
     <term>
      <function>PQoptions</function>
      <indexterm>
       <primary>PQoptions</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回被传递给连接请求的命令行选项。
<synopsis>
char *PQoptions(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   下列函数返回会随着在<structname>PGconn</>对象上执行的操作改变的状态数据。

   <variablelist>
    <varlistentry id="libpq-pqstatus">
     <term>
      <function>PQstatus</function>
      <indexterm>
       <primary>PQstatus</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回该连接的状态。
<synopsis>
ConnStatusType PQstatus(const PGconn *conn);
</synopsis>
      </para>

      <para>
       该状态可以是一系列值之一。不过，其中只有两个在一个异步连接过程之外可见：<literal>CONNECTION_OK</literal>和<literal>CONNECTION_BAD</literal>。一个到数据库的完好连接的状态为<literal>CONNECTION_OK</literal>。一个失败的连接尝试则由状态<literal>CONNECTION_BAD</literal>表示。通常，一个 OK 状态将一直保持到<function>PQfinish</function>，但是一次通信失败可能导致该状态过早地改变为<literal>CONNECTION_BAD</literal>。在那种情况下，该应用可以通过调用<function>PQreset</function>尝试恢复。
      </para>

      <para>
       关于其他可能会被返回的状态代码，请见<function>PQconnectStartParams</>、<function>PQconnectStart</>和<function>PQconnectPoll</>的条目。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqtransactionstatus">
     <term>
      <function>PQtransactionStatus</function>
      <indexterm>
       <primary>PQtransactionStatus</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回服务器的当前事务内状态。

<synopsis>
PGTransactionStatusType PQtransactionStatus(const PGconn *conn);
</synopsis>

       该状态可能是<literal>PQTRANS_IDLE</literal>（当前空闲）、
       <literal>PQTRANS_ACTIVE</literal>（一个命令运行中）、
       <literal>PQTRANS_INTRANS</literal>（空闲，处于一个合法的事务块中）
       或者<literal>PQTRANS_INERROR</literal>（空闲，处于一个失败的事务块中）。
       如果该连接损坏，将会报告<literal>PQTRANS_UNKNOWN</literal>。
       只有当一个查询已经被发送给服务器并且还没有完成时，才会报告<literal>PQTRANS_ACTIVE</literal>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqparameterstatus">
     <term>
      <function>PQparameterStatus</function>
      <indexterm>
       <primary>PQparameterStatus</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       查找服务器的一个当前参数设置。

<synopsis>
const char *PQparameterStatus(const PGconn *conn, const char *paramName);
</synopsis>

       某一参数值会被服务器在连接开始或值改变时自动报告。<function>PQparameterStatus</>可以被用来询问这些设置。它为已知的参数返回当前值，为未知的参数返回<symbol>NULL</symbol>。
      </para>

      <para>
       自当前发布开始会被报告的参数包括
       <varname>server_version</>、
       <varname>server_encoding</>、
       <varname>client_encoding</>、
       <varname>application_name</>、
       <varname>is_superuser</>、
       <varname>session_authorization</>、
       <varname>DateStyle</>、
       <varname>IntervalStyle</>、
       <varname>TimeZone</>、
       <varname>integer_datetimes</>以及
       <varname>standard_conforming_strings</>（
       <varname>server_encoding</>、<varname>TimeZone</>以及<varname>integer_datetimes</>在 8.0 以前的发布中不被报告；<varname>standard_conforming_strings</>在 8.1 以前的发布中不被报告；<varname>IntervalStyle</>在 8.4 以前的发布中不被报告；<varname>application_name</>在 9.0 以前的发布中不被报告）。注意
       <varname>server_version</>、
       <varname>server_encoding</>以及
       <varname>integer_datetimes</>在启动之后无法改变。
      </para>

      <para>
       3.0 之前协议的服务器不报告参数设置，但是<application>libpq</>包括获得<varname>server_version</>以及<varname>client_encoding</>值的逻辑。我们鼓励应用使用<function>PQparameterStatus</>而不是<foreignphrase>ad hoc</>代码来确定这些值（不过注意在一个 3.0 之前的连接上，连接开始后通过<command>SET</>改变<varname>client_encoding</>不会被<function>PQparameterStatus</>反映）。对于<varname>server_version</>（另见<function>PQserverVersion</>），它以一种数字形式返回信息，这样更容易进行比较。
      </para>

      <para>
       如果没有为<varname>standard_conforming_strings</>报告值，应用能假设它是<literal>off</>，也就是说反斜线会被视为字符串中的转义。还有，这个参数的存在可以被作为转义字符串语法（<literal>E'...'</>）被接受的指示。
      </para>

      <para>
       尽管被返回的指针被声明成<literal>const</>，它事实上指向与<literal>PGconn</>结构相关的可变存储。假定该指针在查询之间保持有效是不明智的。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqprotocolversion">
     <term>
      <function>PQprotocolVersion</function>
      <indexterm>
       <primary>PQprotocolVersion</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       询问所使用的 前端/后端协议。
<synopsis>
int PQprotocolVersion(const PGconn *conn);
</synopsis>
       应用可能希望用这个函数来确定某些特性是否被支持。当前，可能值是 2（2.0 协议）、3（3.0 协议）或零（连接损坏）。协议版本在连接启动完成后将不会改变，但是理论上在连接重置期间是可以改变的。当与<productname>PostgreSQL</> 7.4 或以后的服务器通信时通常使用 3.0 协议，7.4 之前的服务器只支持协议 2.0（协议 1.0 已被废弃并且不再被<application>libpq</application>支持）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqserverversion">
     <term>
      <function>PQserverVersion</function>
      <indexterm>
       <primary>PQserverVersion</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回一个表示后端版本的整数。
<synopsis>
int PQserverVersion(const PGconn *conn);
</synopsis>
       应用可能会使用这个函数来决定它们连接到的数据库服务器的版本。该数字通过将主、次和修订数字转换成两位十进制数并连接在一起形成。例如，版本 8.1.5 将被返回为 80105，版本 8.2 将被返回为 80200（前导零没有被显示）。如果连接损坏，将返回零。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqerrormessage">
     <term>
      <function>PQerrorMessage</function>
      <indexterm>
       <primary>PQerrorMessage</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       <indexterm><primary>错误消息</></>返回连接上的一个操作最近产生的错误消息。

<synopsis>
char *PQerrorMessage(const PGconn *conn);
</synopsis>

      </para>

      <para>
       几乎所有的<application>libpq</>在失败时都会为<function>PQerrorMessage</function>设置一个消息。注意按照<application>libpq</application>习惯，一个非空<function>PQerrorMessage</function>结果由多行构成，并且将包括一个尾部新行。调用者不应该直接释放结果。当相关的<structname>PGconn</>句柄被传递给<function>PQfinish</function>时，它将被释放。在<literal>PGconn</>结构上的多个操作之间，不能指望结果字符串会保持不变。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsocket">
     <term><function>PQsocket</function><indexterm><primary>PQsocket</></></term>
     <listitem>
      <para>
       获得到服务器连接套接字的文件描述符号。一个合法的描述符将会大于等于零。结果为 -1 表示当前没有打开服务器连接（在普通操作期间这将不会改变，但是在连接设置或重置期间可能改变）。

<synopsis>
int PQsocket(const PGconn *conn);
</synopsis>

      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqbackendpid">
     <term><function>PQbackendPID</function><indexterm><primary>PQbackendPID</></></term>
     <listitem>
      <para>
       返回处理这个连接的后端进程的进程<acronym>ID</acronym>（PID）。<indexterm>
        <primary>PID</>
        <secondary>确定服务器进程的 PID</>
        <tertiary>in libpq</>
       </indexterm>

<synopsis>
int PQbackendPID(const PGconn *conn);
</synopsis>
      </para>

      <para>
       后端<acronym>PID</acronym>有助于调试目的并且可用于与<command>NOTIFY</command>消息（它包括发出提示的后端进程的<acronym>PID</acronym>）进行比较。注意<acronym>PID</acronym>属于一个在数据库服务器主机上执行的进程，而不是本地主机进程！
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconnectionneedspassword">
     <term><function>PQconnectionNeedsPassword</function><indexterm><primary>PQconnectionNeedsPassword</></></term>
     <listitem>
      <para>
       如果连接认证方法要求一个口令但没有可用的口令，返回真（1）。否则返回假（0）。

<synopsis>
int PQconnectionNeedsPassword(const PGconn *conn);
</synopsis>
      </para>

      <para>
       这个函数可以在连接尝试失败后被应用于决定是否向用户提示要求一个口令。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconnectionusedpassword">
     <term><function>PQconnectionUsedPassword</function><indexterm><primary>PQconnectionUsedPassword</></></term>
     <listitem>
      <para>
       如果连接认证方法使用一个口令，返回真（1）。否则返回假（0）。

<synopsis>
int PQconnectionUsedPassword(const PGconn *conn);
</synopsis>
      </para>

      <para>
       这个函数能在一次连接尝试失败或成功后用于检测该服务器是否要求一个口令。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqgetssl">
     <term><function>PQgetssl</function><indexterm><primary>PQgetssl</></></term>
     <listitem>
      <para>
       <indexterm><primary>SSL</><secondary sortas="libpq">in libpq</secondary></indexterm>
       返回在连接中使用的 SSL 结构，如果没有使用 SSL 则返回空。

<synopsis>
void *PQgetssl(const PGconn *conn);
</synopsis>
      </para>

      <para>
       这个结构可以被用来验证加密级别、检查服务器证书等等。关于这个结构可参考<productname>OpenSSL</>文档。
      </para>

      <para>
       真正的返回值是<type>SSL *</type>类型，其中<type>SSL</type>是<productname>OpenSSL</productname>库定义的一种类型，但是为了避免要求<productname>OpenSSL</productname>头文件，它没有以这种方式声明。要使用这个函数，可以使用下列代码：
<programlisting><![CDATA[
#include <libpq-fe.h>
#include <openssl/ssl.h>

...

    SSL *ssl;

    dbconn = PQconnectdb(...);
    ...

    ssl = PQgetssl(dbconn);
    if (ssl)
    {
        /* 使用 OpenSSL 函数访问 ssl */
    }
]]></programlisting>
      </para>
     </listitem>
    </varlistentry>

   </variablelist>
  </para>

 </sect1>

 <sect1 id="libpq-exec">
  <title>命令执行函数</title>

  <para>
   一旦到一个数据库服务器的连接被成功建立，这里描述的函数可以被用来执行 SQL 查询和命令。
  </para>

  <sect2 id="libpq-exec-main">
   <title>主要函数</title>

   <para>
    <variablelist>
     <varlistentry id="libpq-pqexec">
      <term>
       <function>PQexec</function>
       <indexterm>
        <primary>PQexec</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
        提交一个命令给服务器并且等待结果。

<synopsis>
PGresult *PQexec(PGconn *conn, const char *command);
</synopsis>
       </para>

       <para>
        返回一个<structname>PGresult</structname>指针或者可能是一个空指针。除了内存不足的情况或者由于严重错误无法将命令发送给服务器之外，一般都会返回一个非空指针。<function>PQresultStatus</>函数应当被调用来检查返回值是否代表错误（包括空指针的值，它会返回<symbol>PGRES_FATAL_ERROR</symbol>）。用<function>PQerrorMessage</function>可得到关于那些错误的详细信息。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    命令字符串可以包括多个 SQL 命令（用分号分隔）。在一次<function>PQexec</>调用中被发送的多个查询会在一个事务中处理，除非其中有显式的<command>BEGIN</command>/<command>COMMIT</command>命令将该查询字符串划分成多个事务。但是注意，返回的<structname>PGresult</structname>结构只描述该字符串中被执行的最后一个命令的结果。如果一个命令失败，该字符串的处理会在它那里停止并且返回的<structname>PGresult</structname>会描述错误情况。
   </para>

   <para>
    <variablelist>
     <varlistentry id="libpq-pqexecparams">
      <term>
       <function>PQexecParams</function>
       <indexterm>
        <primary>PQexecParams</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
        提交一个命令给服务器并且等待结果，它可以在 SQL 命令文本之外独立地传递参数。

<synopsis>
PGresult *PQexecParams(PGconn *conn,
                       const char *command,
                       int nParams,
                       const Oid *paramTypes,
                       const char * const *paramValues,
                       const int *paramLengths,
                       const int *paramFormats,
                       int resultFormat);
</synopsis>
       </para>

       <para>
        <function>PQexecParams</>与<function>PQexec</>相似，但是提供了额外的功能：参数值可以与命令字符串分开指定，并且可以以文本或二进制格式请求查询结果。<function>PQexecParams</>只在 3.0 协议及其后的连接中被支持，当使用 2.0 协议时它会失败。
       </para>

       <para>
        该函数的参数是：

        <variablelist>
         <varlistentry>
          <term><parameter>conn</parameter></term>

          <listitem>
           <para>
            要在其中发送命令的连接对象。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>command</parameter></term>
          <listitem>
           <para>
            要执行的 SQL 命令字符串。如果使用了参数，它们在该命令字符串中被引用为<literal>$1</>、<literal>$2</>等。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>nParams</parameter></term>
          <listitem>
           <para>
            提供的参数数量。它是数组<parameter>paramTypes[]</>、<parameter>paramValues[]</>、<parameter>paramLengths[]</>和<parameter>paramFormats[]</>的长度（当<parameter>nParams</>为零时，数组指针可以是<symbol>NULL</symbol>）。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>paramTypes[]</parameter></term>
          <listitem>
           <para>
            通过 OID 指定要赋予给参数符号的数据类型。如果<parameter>paramTypes</>为<symbol>NULL</symbol>或者该数组中任何特定元素为零，服务器会用对待未知类型文字串的方式为参数符号推测一种数据类型。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>paramValues[]</parameter></term>
          <listitem>
           <para>
            指定参数的实际值。这个数组中的一个空指针表示对应的参数为空，否则该指针指向一个以零终止的文本字符串（用于文本格式）或者以服务器所期待格式的二进制数据（用于二进制格式）。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>paramLengths[]</parameter></term>
          <listitem>
           <para>
            指定二进制格式参数的实际数据长度。它对空参数和文本格式参数被忽略。当没有二进制参数时，该数组指针可以为空。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>paramFormats[]</parameter></term>
          <listitem>
           <para>
            指定参数是否为文本（在参数相应的数组项中放一个零）或二进制（在参数相应的数组项中放一个一）。如果该数组指针为空，那么所有参数都会被假定为文本串。
           </para>
           <para>
            以二进制格式传递的值要求后端所期待的内部表示形式的知识。例如，整数必须以网络字节序被传递。传递<type>numeric</>值要求关于服务器存储格式的知识，正如<filename>src/backend/utils/adt/numeric.c::numeric_send()</>以及<filename>src/backend/utils/adt/numeric.c::numeric_recv()</>中所实现的。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>resultFormat</parameter></term>
          <listitem>
           <para>
            指定零来得到文本格式的结果，或者指定一来得到二进制格式的结果（目前没有规定要求以不同格式得到不同的结果列，尽管在底层协议中这是可以实现的）。
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    <function>PQexecParams</>相对于<function>PQexec</>的主要优点是参数值可以从命令串中分离，因此避免了冗长的书写、容易发生错误的引用以及转义。
   </para>

   <para>
    和<function>PQexec</>不同，<function>PQexecParams</>至多允许在给定串中出现一个 SQL 命令（其中可以有分号，但是不能有超过一个非空命令）。这是底层协议的一个限制，但是有助于抵抗 SQL 注入攻击。
   </para>

   <tip>
    <para>
     通过 OID 指定参数类型很罗嗦，特别是如果你不愿意将特定的 OID 值硬编码到你的程序中时。不过，即使服务器本身也无法确定参数的类型，你可以避免这样做，或者选择一种与你想要的不同的类型。在 SQL 命令文本中，附加一个显式造型给参数符号来表示你将发送什么样的数据类型。例如：
<programlisting>
SELECT * FROM mytable WHERE x = $1::bigint;
</programlisting>
     这强制参数<literal>$1</>被当作<type>bigint</>，而默认情况下它将被赋予与<literal>x</>相同的类型。当以二进制格式发送参数值时，我们强烈推荐以这种方式或通过指定一个数字类型的 OID 来强制参数类型决定。因为二进制格式比文本格式具有更少的冗余，并且因此服务器将不会有更多机会为你检测一个类型匹配错误。
    </para>
   </tip>

   <para>
    <variablelist>
     <varlistentry id="libpq-pqprepare">
      <term><function>PQprepare</function>
       <indexterm>
        <primary>PQprepare</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
        提交一个请求用给定参数创建一个预备语句并且等待完成。
<synopsis>
PGresult *PQprepare(PGconn *conn,
                    const char *stmtName,
                    const char *query,
                    int nParams,
                    const Oid *paramTypes);
</synopsis>
       </para>

       <para>
        <function>PQprepare</>创建一个后面会由<function>PQexecPrepared</>执行的预备语句。这种特性允许将被反复执行的命令只被解析和规划一次，而不是在每次被执行时都解析和规划。<function>PQprepare</>只在协议 3.0 及之后的连接中被支持，当使用协议 2.0 时它将失败。
       </para>

       <para>
        该函数从<parameter>query</>串创建一个名为<parameter>stmtName</>的预备语句，该串必须包含一个单一 SQL 命令。<parameter>stmtName</>可以是<literal>""</>来创建一个未命名语句，在这种情况下任何已存在未命名语句将被自动替换。如果语句名称已经在当前会话中被定义，则是一种错误。如果使用了任何参数，它们在查询中以<literal>$1</>、<literal>$2</>等引用。<parameter>nParams</>是参数的个数，其类型在数组<parameter>paramTypes[]</>中被预先指定（当<parameter>nParams</>为零时，该数组指针可以是<symbol>NULL</symbol>）。<parameter>paramTypes[]</>通过 OID 指定要赋予给参数符号的数据类型。如果<parameter>paramTypes</>是<symbol>NULL</symbol>或者该数组中任何特定元素为零，服务器会用对待未知类型文字串的方式为参数符号推测一种数据类型。还有，查询能够使用编号高于<parameter>nParams</>的参数符号，它们的数据类型也会被自动推测（找出推测出的数据类型的方法见<function>PQdescribePrepared</function>）。
       </para>

       <para>
        正如<function>PQexec</>一样，结果通常是一个<structname>PGresult</structname>对象，其内容代表服务器端成功或失败。一个空结果表示内存不足或者根本无法发送命令。关于错误的更多信息请见<function>PQerrorMessage</function>。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    用于<function>PQexecPrepared</>的预备语句也能通过执行 SQL <xref linkend="sql-prepare">语句来创建。还有，尽管没有<application>libpq</>函数来删除一个预备语句，SQL <xref linkend="sql-deallocate">语句可被用于此目的。
   </para>

   <para>
    <variablelist>
     <varlistentry id="libpq-pqexecprepared">
      <term>
       <function>PQexecPrepared</function>
       <indexterm>
        <primary>PQexecPrepared</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
        发送一个请求来用给定参数执行一个预备语句，并且等待结果。
<synopsis>
PGresult *PQexecPrepared(PGconn *conn,
                         const char *stmtName,
                         int nParams,
                         const char * const *paramValues,
                         const int *paramLengths,
                         const int *paramFormats,
                         int resultFormat);
</synopsis>
       </para>

       <para>
        <function>PQexecPrepared</>像<function>PQexecParams</>，但是要被执行的命令是用之前准备的语句的名字指定，而不是指定一个查询串。这个特性允许将被重复使用的命令只被解析和规划一次，而不是在每次被执行时都被解析和规划。这个语句必须之前在当前会话中已经被准备好。<function>PQexecPrepared</>仅被协议 3.0 及之后的连接支持，当使用协议 2.0 时它会失败。
       </para>

       <para>
        参数和<function>PQexecParams</>相同，除了给定的是一个预备语句的名称而不是一个查询语句，以及不存在<parameter>paramTypes[]</>参数（因为预备语句的参数类型已经在它被创建时决定好了）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqdescribeprepared">
      <term>
       <function>PQdescribePrepared</function>
       <indexterm>
        <primary>PQdescribePrepared</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
        提交一个请求来获得有关指定预备语句的信息，并且等待完成。
<synopsis>
PGresult *PQdescribePrepared(PGconn *conn, const char *stmtName);
</synopsis>
       </para>

       <para>
        <function>PQdescribePrepared</>允许一个应用获得有关一个之前预备好的语句的信息。<function>PQdescribePrepared</>仅被协议 3.0 及之后的连接支持，当使用协议 2.0 时它会失败。
       </para>

       <para>
        <parameter>stmtName</>可以用<literal>""</>或者<symbol>NULL</>来引用未命名语句，否则它必须是一个现有预备语句的名字。如果成功，一个<structname>PGresult</>以及状态<literal>PGRES_COMMAND_OK</literal>会被返回。函数<function>PQnparams</function>和<function>PQparamtype</function>可以被应用到这个<structname>PGresult</>来得到关于该预备语句参数的额外信息，而函数<function>PQnfields</function>、<function>PQfname</function>、<function>PQftype</function>等提供该语句结果列（如果有）的信息。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqdescribeportal">
      <term>
       <function>PQdescribePortal</function>
       <indexterm>
        <primary>PQdescribePortal</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
        提交一个请求来得到有关指定入口的信息，并且等待完成。
<synopsis>
PGresult *PQdescribePortal(PGconn *conn, const char *portalName);
</synopsis>
       </para>

       <para>
        <function>PQdescribePortal</>允许一个应用获得有关一个之前被创建的入口的信息（<application>libpq</>不提供对入口任何直接的访问，但是你可以使用这个函数来观察一个通过<command>DECLARE CURSOR</> SQL 命令创建的游标的属性）。<function>PQdescribePortal</>仅被协议 3.0 及之后的连接支持，当使用协议 2.0 时它会失败。
       </para>

       <para>
        <parameter>portalName</>可以用<literal>""</>或者<symbol>NULL</>来引用未命名入口，否则它必须是一个现有入口的名字。如果成功，一个<structname>PGresult</>和状态<literal>PGRES_COMMAND_OK</literal>会被返回。函数<function>PQnfields</function>、<function>PQfname</function>、<function>PQftype</function>等可以被应用到<structname>PGresult</>来获得有关该入口结果列（如果有）的信息。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    <structname>PGresult</structname><indexterm><primary>PGresult</></>结构封装了由服务器返回的结果。<application>libpq</application>应用程序员应该小心地维护<structname>PGresult</structname>的抽象。使用下面的存储器函数来得到<structname>PGresult</structname>的内容。避免直接引用<structname>PGresult</structname>结构的域，因为它们可能在未来更改。

    <variablelist>
     <varlistentry id="libpq-pqresultstatus">
      <term>
       <function>PQresultStatus</function>
       <indexterm>
        <primary>PQresultStatus</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
        返回该命令的结果状态。
<synopsis>
ExecStatusType PQresultStatus(const PGresult *res);
</synopsis>
       </para>

       <para>
        <function>PQresultStatus</function>能返回下列值之一：

        <variablelist>
         <varlistentry id="libpq-pgres-empty-query">
          <term><literal>PGRES_EMPTY_QUERY</literal></term>
          <listitem>
           <para>
            发送给服务器的字符串为空。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-command-ok">
          <term><literal>PGRES_COMMAND_OK</literal></term>
          <listitem>
           <para>
            一个不返回数据的命令成功完成。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-tuples-ok">
          <term><literal>PGRES_TUPLES_OK</literal></term>
          <listitem>
           <para>
            一个返回数据的命令（例如<command>SELECT</>或者<command>SHOW</>）成功完成。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-copy-out">
          <term><literal>PGRES_COPY_OUT</literal></term>
          <listitem>
           <para>
            从服务器复制出数据的传输开始。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-copy-in">
          <term><literal>PGRES_COPY_IN</literal></term>
          <listitem>
           <para>
            复制数据到服务器的传输开始。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-bad-response">
          <term><literal>PGRES_BAD_RESPONSE</literal></term>
          <listitem>
           <para>
            无法理解服务器的响应。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-nonfatal-error">
          <term><literal>PGRES_NONFATAL_ERROR</literal></term>
          <listitem>
           <para>
            发生了一次非致命错误（一个提示或警告）。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-fatal-error">
          <term><literal>PGRES_FATAL_ERROR</literal></term>
          <listitem>
           <para>
            发生了一次致命错误。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-copy-both">
          <term><literal>PGRES_COPY_BOTH</literal></term>
          <listitem>
           <para>
            向服务器复制数据/从服务器复制数据的传输开始。这个特性当前只被用于流复制，因此这个状态应该不会在普通应用中出现。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-single-tuple">
          <term><literal>PGRES_SINGLE_TUPLE</literal></term>
          <listitem>
           <para>
            <structname>PGresult</>包含来自于当前命令的一个单一结果元组。这个状态只在查询选择了单一行模式时发生（见<xref linkend="libpq-single-row-mode">）。
           </para>
          </listitem>
         </varlistentry>
        </variablelist>

        如果结果状态是<literal>PGRES_TUPLES_OK</literal>或者<literal>PGRES_SINGLE_TUPLE</literal>，那么下面所描述的函数能被用来检索该查询所返回的行。注意，一个恰好检索零行的<command>SELECT</command>命令仍然会显示<literal>PGRES_TUPLES_OK</literal>。<literal>PGRES_COMMAND_OK</literal>用于从不返回行的命令（不带<literal>RETURNING</literal>子句的<command>INSERT</command>或者<command>UPDATE</command>等）。一个<literal>PGRES_EMPTY_QUERY</literal>可能表示客户端软件中的一个缺陷。
       </para>

       <para>
        一个状态为<symbol>PGRES_NONFATAL_ERROR</symbol>的结果将不会被<function>PQexec</function>或者其他查询执行函数直接返回，这类结果将被传递给提示处理器（见 <xref linkend="libpq-notice-processing">）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqresstatus">
      <term>
       <function>PQresStatus</function>
       <indexterm>
        <primary>PQresStatus</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
        将<function>PQresultStatus</>返回的枚举转换成描述状态编码的字符串常量。调用者不应该释放结果。

<synopsis>
char *PQresStatus(ExecStatusType status);
</synopsis>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqresulterrormessage">
      <term>
       <function>PQresultErrorMessage</function>
       <indexterm>
        <primary>PQresultErrorMessage</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
        返回与该命令相关的错误消息，如果有错误则会返回一个空字符串。
<synopsis>
char *PQresultErrorMessage(const PGresult *res);
</synopsis>
        如果有一个错误，被返回的字符串将包含一个收尾的新行。调用者不应该直接释放结果。它将在相关的<structname>PGresult</>句柄被传递给<function>PQclear</function>之后被释放。
       </para>

       <para>
        紧跟着一个<function>PQexec</function>或<function>PQgetResult</function>调用，<function>PQerrorMessage</function>（在连接上）将返回与<function>PQresultErrorMessage</function>相同的字符串（在结果上）。不过，一个<structname>PGresult</structname>将保持它的错误消息直到被销毁，而连接的错误消息将在后续操作被执行时被更改。当你想要知道与一个特定<structname>PGresult</structname>相关的状态，使用<function>PQresultErrorMessage</function>。而当你想要知道连接上最后一个操作的状态，使用<function>PQerrorMessage</function>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqresulterrorfield">
      <term><function>PQresultErrorField</function><indexterm><primary>PQresultErrorField</></></term>
      <listitem>
       <para>
        返回一个错误报告的一个域。
<synopsis>
char *PQresultErrorField(const PGresult *res, int fieldcode);
</synopsis>
        <parameter>fieldcode</>是一个错误域标识符，见下列符号。如果<structname>PGresult</structname>不是一个错误或者警告结果或者不包括指定域，会返回<symbol>NULL</symbol>。域通常不包括一个收尾的新行。调用者不应该直接释放结果。它将在相关的<structname>PGresult</>句柄被传递给<function>PQclear</function>之后被释放。
       </para>

       <para>
        下列域代码可用：
        <variablelist>
         <varlistentry id="libpq-pg-diag-severity">
          <term><symbol>PG_DIAG_SEVERITY</></term>
          <listitem>
           <para>
            严重。域的内容是<literal>ERROR</>、<literal>FATAL</>或<literal>PANIC</>（在一个错误消息中）。或者是<literal>WARNING</>、<literal>NOTICE</>、<literal>DEBUG</>、<literal>INFO</>或<literal>LOG</>（在一个提示消息中）。或者是其中之一的一个本地化翻译。总是存在。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-sqlstate">
          <term><symbol>PG_DIAG_SQLSTATE</>
          <indexterm>
           <primary>error codes</primary>
           <secondary>libpq</secondary>
          </indexterm></term>
          <listitem>
           <para>
            用于错误的 SQLSTATE 代码。SQLSTATE 代码标识了已经发生的错误的类型，它可以被前端应用用来执行特定操作（例如错误处理）来响应一个特定数据库错误。一个可能的 SQLSTATE 代码列表可见<xref linkend="errcodes-appendix">。这个域无法被本地化，并且总是存在。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-message-primary">
          <term><symbol>PG_DIAG_MESSAGE_PRIMARY</></term>
          <listitem>
           <para>
            主要的人类可读的错误消息（通常是一行）。总是存在。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-message-detail">
          <term><symbol>PG_DIAG_MESSAGE_DETAIL</></term>
          <listitem>
           <para>
            细节：一个可选的次级错误消息，它携带了关于问题的更多细节。可能有多行。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-message-hint">
          <term><symbol>PG_DIAG_MESSAGE_HINT</></term>
          <listitem>
           <para>
            提示：一个关于如何处理该问题的可选建议。它与细节的区别在于它提供了建议（可能不合适）而不是铁的事实。可能有多行。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-statement-position">
          <term><symbol>PG_DIAG_STATEMENT_POSITION</></term>
          <listitem>
           <para>
            A string containing a decimal integer indicating an error cursor
            position as an index into the original statement string.  The
            first character has index 1, and positions are measured in
            characters not bytes.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-internal-position">
          <term><symbol>PG_DIAG_INTERNAL_POSITION</></term>
          <listitem>
           <para>
            这被定义为与<symbol>PG_DIAG_STATEMENT_POSITION</>域相同，但是它被用在游标位置引用一个内部产生的命令而不是客户端提交的命令时。当这个域出现时，<symbol>PG_DIAG_INTERNAL_QUERY</>域将总是出现。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-internal-query">
          <term><symbol>PG_DIAG_INTERNAL_QUERY</></term>
          <listitem>
           <para>
            一个失败的内部产生的命令的文本。例如，这可能是由一个 PL/pgSQL 函数发出的 SQL 查询。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-context">
          <term><symbol>PG_DIAG_CONTEXT</></term>
          <listitem>
           <para>
            指示错误发生的环境。当前这包括活动过程语言函数的调用栈追踪以及内部生成的查询。追踪是每行一项，最近的排在最前面。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-schema-name">
          <term><symbol>PG_DIAG_SCHEMA_NAME</></term>
          <listitem>
           <para>
            如果错误与某个特定的数据库对象相关，这里是包含该对象的模式名（如果有）。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-table-name">
          <term><symbol>PG_DIAG_TABLE_NAME</></term>
          <listitem>
           <para>
            如果错误与某个特定表相关，这里是该表的名字（该表的模式参考模式名域）。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-column-name">
          <term><symbol>PG_DIAG_COLUMN_NAME</></term>
          <listitem>
           <para>
            如果错误与一个特定表列相关，这里是该表列的名字（参考模式和表名域来标识该表）。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-datatype-name">
          <term><symbol>PG_DIAG_DATATYPE_NAME</></term>
          <listitem>
           <para>
            如果错误与一个特定数据类型相关，这里是该数据类型的名字（该数据类型的模式名参考模式名域）。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-constraint-name">
          <term><symbol>PG_DIAG_CONSTRAINT_NAME</></term>
          <listitem>
           <para>
            如果错误与一个特定约束相关，这里是该约束的名字。相关的表或域参考上面列出的域（为了这个目的，索引也被视作约束，即使它们不是用约束语法创建的）。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-source-file">
          <term><symbol>PG_DIAG_SOURCE_FILE</></term>
          <listitem>
           <para>
            报告错误的源代码所在的文件名。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-source-line">
          <term><symbol>PG_DIAG_SOURCE_LINE</></term>
          <listitem>
           <para>
            报告错误的源代码行号。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-source-function">
          <term><symbol>PG_DIAG_SOURCE_FUNCTION</></term>
          <listitem>
           <para>
            报告错误的源代码函数的名字。
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>

       <note>
        <para>
         用于模式名、表明、列名、数据类型名和约束名的域只提供给有限的错误类型，见<xref linkend="errcodes-appendix">。不要假定任何这些域的存在保证另一个域的存在。核心错误源会遵守上面提到的内在联系，但是用户定义的函数可能以其他方式使用这些域。同样地，不要假定这些域代表当前数据库中同类的对象。
        </para>
       </note>

       <para>
        客户端负责格式化显示信息来迎合它的需要，特别是根据需要打断长的行。出现在错误消息域中的新行字符应该被当作分段而不是换行。
       </para>

       <para>
        <application>libpq</application>内部产生的错误将有严重和主要消息，但是通常没有其他域。3.0 协议之前的服务器返回的错误将包括严重和主要消息，并且有时候还有细节消息，但是没有其他域。
       </para>

       <para>
        注意错误域只对<structname>PGresult</structname>对象中有效，对<structname>PGconn</structname>对象无效。没有<function>PQerrorField</function>函数。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqclear">
      <term><function>PQclear</function><indexterm><primary>PQclear</></></term>
      <listitem>
       <para>
        Frees  the  storage  associated with a
        释放与一个<structname>PGresult</structname>相关的存储。每一个命令结果不再需要时应该用<function>PQclear</function>释放。

<synopsis>
void PQclear(PGresult *res);
</synopsis>
       </para>

       <para>
        你可以按照需要保留<structname>PGresult</structname>对象，当你发出一个新命令时它也不会消失，甚至关闭连接时也不会消失。要去掉它，你必须调用<function>PQclear</function>。没有这样做将会导致在应用中的内存泄露。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="libpq-exec-select-info">
   <title>检索查询结果信息</title>

   <para>
    这些函数被用来从一个代表成功查询结果（也就是状态为<literal>PGRES_TUPLES_OK</literal>或者<literal>PGRES_SINGLE_TUPLE</>）的<structname>PGresult</structname>对象中抽取信息。它们也可以被用来从一个成功的 Describe 操作中抽取信息：一个 Describe 的结果具有和该查询被实际执行所提供的完全相同的列信息，但是它没有行。对于其他状态值的对象，这些函数会认为结果具有零行和零列。
   </para>

   <variablelist>
    <varlistentry id="libpq-pqntuples">
     <term>
      <function>PQntuples</function>
      <indexterm>
       <primary>PQntuples</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回查询结果中的行（元组）数。因为它返回一个整数结果，在 32 位操作系统上大型的结果集可能使返回值溢出。

<synopsis>
int PQntuples(const PGresult *res);
</synopsis>

      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqnfields">
     <term>
      <function>PQnfields</function>
      <indexterm>
       <primary>PQnfields</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回查询结果中每一行的列（域）数。

<synopsis>
int PQnfields(const PGresult *res);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfname">
     <term>
      <function>PQfname</function>
      <indexterm>
       <primary>PQfname</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回与给定列号相关联的列名。列号从 0 开始。调用者不应该直接释放该结果。它将在相关的<structname>PGresult</>句柄被传递给<function>PQclear</function>之后被释放。
<synopsis>
char *PQfname(const PGresult *res,
              int column_number);
</synopsis>
      </para>

      <para>
       如果列号超出范围，将返回<symbol>NULL</symbol>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfnumber">
     <term>
      <function>PQfnumber</function>
      <indexterm>
       <primary>PQfnumber</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回与给定列名相关联的列号。
<synopsis>
int PQfnumber(const PGresult *res,
              const char *column_name);
</synopsis>
      </para>

      <para>
       如果给定的名字不匹配任何列，将返回 -1。
      </para>

      <para>
       给定的名称被视作一个 SQL 命令中的一个标识符，也就是说，除非被双引号引用，它是小写形式的。例如，给定一个 SQL 命令：
<programlisting>
SELECT 1 AS FOO, 2 AS "BAR";
</programlisting>
       我们将得到结果：
<programlisting>
PQfname(res, 0)              <lineannotation>foo</lineannotation>
PQfname(res, 1)              <lineannotation>BAR</lineannotation>
PQfnumber(res, "FOO")        <lineannotation>0</lineannotation>
PQfnumber(res, "foo")        <lineannotation>0</lineannotation>
PQfnumber(res, "BAR")        <lineannotation>-1</lineannotation>
PQfnumber(res, "\"BAR\"")    <lineannotation>1</lineannotation>
</programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqftable">
     <term>
      <function>PQftable</function>
      <indexterm>
       <primary>PQftable</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回取出给定列的表的 OID。列号从 0 开始。
<synopsis>
Oid PQftable(const PGresult *res,
             int column_number);
</synopsis>
      </para>

      <para>
       如果列号超出范围或者指定的列不是对一个表列的简单引用或者在使用 3.0 协议时，返回<literal>InvalidOid</>。你可以查询系统表<literal>pg_class</literal>来确定究竟是哪个表被引用。
      </para>

      <para>
       当你包括<application>libpq</application>头文件，类型<type>Oid</type>以及常数<literal>InvalidOid</literal>将被定义。它们将都是某种整数类型。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqftablecol">
     <term>
      <function>PQftablecol</function>
      <indexterm>
       <primary>PQftablecol</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回构成指定查询结果列的列（在其表中）的列号。查询结果列号从 0 开始，但是表列具有非零编号。
<synopsis>
int PQftablecol(const PGresult *res,
                int column_number);
</synopsis>
      </para>

      <para>
       如果列号超出范围或者指定的列不是对一个表列的简单引用或者在使用 3.0 协议时，返回零。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfformat">
     <term>
      <function>PQfformat</function>
      <indexterm>
       <primary>PQfformat</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回指示给定列格式的格式编码。列号从 0 开始。
<synopsis>
int PQfformat(const PGresult *res,
              int column_number);
</synopsis>
      </para>

      <para>
       格式代码零指示文本数据表示，而格式代码一表示二进制表示（其他代码被保留用于未来的定义）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqftype">
     <term>
      <function>PQftype</function>
      <indexterm>
       <primary>PQftype</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回与给定列号相关联的数据类型。被返回的整数是该类型的内部 OID 号。列号从 0 开始。
<synopsis>
Oid PQftype(const PGresult *res,
            int column_number);
</synopsis>
      </para>

      <para>
       你可以查询系统表<literal>pg_type</literal>来得到多个数据类型的名字和属性。内建数据类型的<acronym>OID</acronym>被定义在源代码树中的文件<filename>src/include/catalog/pg_type.h</filename>中。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfmod">
     <term>
      <function>PQfmod</function>
      <indexterm>
       <primary>PQfmod</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回与给定列号相关联的列的修饰符类型。列号从 0 开始。
<synopsis>
int PQfmod(const PGresult *res,
           int column_number);
</synopsis>
      </para>

      <para>
       修饰符值的解释是与类型相关的，它们通常指示精度或尺寸限制。值 -1 被用来指示<quote>没有信息可用</>。大部分的数据类型不适用修饰符，在那种情况中值总是 -1。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfsize">
     <term>
      <function>PQfsize</function>
      <indexterm>
       <primary>PQfsize</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回与给定列号相关的列的尺寸（以字节计）。列号从 0 开始。
<synopsis>
int PQfsize(const PGresult *res,
            int column_number);
</synopsis>
      </para>

      <para>
       <function>PQfsize</>返回在一个数据库行中为这个列分配的空间，换句话说是服务器对该数据类型的内部表示的尺寸（因此，它对客户端并不是真地非常有用）。一个负值指示该数据类型是变长的。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqbinarytuples">
     <term>
      <function>PQbinaryTuples</function>
      <indexterm>
       <primary>PQbinaryTuples</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       如果<structname>PGresult</>包含二进制数据，返回 1。如果包含的是文本数据，返回 0。
<synopsis>
int PQbinaryTuples(const PGresult *res);
</synopsis>
      </para>

      <para>
       这个函数已经被废弃（除了与<command>COPY</>一起使用），因为一个单一<structname>PGresult</>可以在某些列中包含文本数据而且在另一些列中包含二进制数据。<function>PQfformat</>要更好。只有结果的所有列是二进制（格式 1）时<function>PQbinaryTuples</>才返回 1。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqgetvalue">
     <term>
      <function>PQgetvalue</function>
       <indexterm>
        <primary>PQgetvalue</primary>
       </indexterm>
     </term>

     <listitem>
      <para>
       返回一个<structname>PGresult</structname>的一行的单一域值。行和列号从 0 开始。调用者不应该直接释放该结果。它将在相关的<structname>PGresult</>句柄被传递给<function>PQclear</function>之后被释放。
<synopsis>
char *PQgetvalue(const PGresult *res,
                 int row_number,
                 int column_number);
</synopsis>
      </para>

      <para>
       对于文本格式的数据，<function>PQgetvalue</function>返回的值是该域值的一种空值结束的字符串表示。对于二进制格式的数据，该值是由该数据类型的<function>typsend</>和<function>typreceive</>函数决定的二进制表示（在这种情况下该值实际上也跟随着一个零字节，但是这通常没有用处，因为该值很可能包含嵌入的空）。
      </para>

      <para>
       如果该域值为空，则返回一个空串。关于区分空值和空字符串值请见<function>PQgetisnull</>。
      </para>

      <para>
       <function>PQgetvalue</function>返回的指针指向作为<structname>PGresult</structname>结构一部分的存储。我们不应该修改它指向的数据，并且如果要在超过<structname>PGresult</structname>结构本身的生命期之外使用它，我们必须显式地把该数据拷贝到其他存储中。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqgetisnull">
     <term>
      <function>PQgetisnull</function>
      <indexterm>
       <primary>PQgetisnull</primary>
      </indexterm>
      <indexterm>
       <primary>null value</primary>
       <secondary sortas="libpq">in libpq</secondary>
      </indexterm>
     </term>

     <listitem>
      <para>
       测试一个域是否为空值。行号和列号从 0 开始。
<synopsis>
int PQgetisnull(const PGresult *res,
                int row_number,
                int column_number);
</synopsis>
      </para>

      <para>
       如果该域是空，这个函数返回 1。如果它包含一个非空值，则返回 0（注意<function>PQgetvalue</function>将为一个空域返回一个空串，不是一个空指针）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqgetlength">
     <term>
     <function>PQgetlength</function>
     <indexterm>
      <primary>PQgetlength</primary>
     </indexterm></term>

     <listitem>
      <para>
       返回一个域值的真实长度，以字节计。行号和列号从 0 开始。
<synopsis>
int PQgetlength(const PGresult *res,
                int row_number,
                int column_number);
</synopsis>
      </para>

      <para>
       这是特定数据值的真实数据长度，也就是<function>PQgetvalue</function>指向的对象的尺寸。对于文本数据格式，这和<function>strlen()</>相同。对于二进制格式这是基本信息。注意我们<emphasis>不</>应该依赖于<function>PQfsize</function>来得到真实的数据长度。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqnparams">
     <term>
      <function>PQnparams</function>
      <indexterm>
       <primary>PQnparams</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回一个预备语句的参数数量。
<synopsis>
int PQnparams(const PGresult *res);
</synopsis>
      </para>

      <para>
       只有在查看<function>PQdescribePrepared</>的结果时，这个函数才有用。对于其他类型的查询，它将返回零。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqparamtype">
     <term>
      <function>PQparamtype</function>
      <indexterm>
       <primary>PQparamtype</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回所指示的语句参数的数据类型。参数号从 0 开始。
<synopsis>
Oid PQparamtype(const PGresult *res, int param_number);
</synopsis>
      </para>

      <para>
       只有在查看<function>PQdescribePrepared</>的结果时，这个函数才有用。对于其他类型的查询，它将返回零。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqprint">
     <term>
      <function>PQprint</function>
      <indexterm>
       <primary>PQprint</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       将所有的行打印到指定的输出流，以及有选择地将列名打印到指定的输出流。
<synopsis>
void PQprint(FILE *fout,      /* 输出流 */
             const PGresult *res,
             const PQprintOpt *po);
typedef struct
{
    pqbool  header;      /* 打印输出域标题和行计数 */
    pqbool  align;       /* 填充对齐域 */
    pqbool  standard;    /* 旧的格式 */
    pqbool  html3;       /* 输出 HTML 表格 */
    pqbool  expanded;    /* 扩展表格 */
    pqbool  pager;       /* 如果必要为输出使用页 */
    char    *fieldSep;   /* 域分隔符 */
    char    *tableOpt;   /* 用于 HTML 表格元素的属性 */
    char    *caption;    /* HTML 表格标题 */
    char    **fieldName; /* 替换域名称的空终止数组 */
} PQprintOpt;
</synopsis>
      </para>

      <para>
       这个函数以前被<application>psql</application>用来打印查询结果，但是现在不是这样了。注意它假定所有的数据都是文本格式。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 id="libpq-exec-nonselect">
   <title>检索其他结果信息</title>

   <para>
    这些函数被用来从<structname>PGresult</structname>对象中抽取其他信息。
   </para>

   <variablelist>
    <varlistentry id="libpq-pqcmdstatus">
     <term>
      <function>PQcmdStatus</function>
      <indexterm>
       <primary>PQcmdStatus</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回来自于产生<structname>PGresult</structname>的 SQL 命令的命令状态标签。
<synopsis>
char *PQcmdStatus(PGresult *res);
</synopsis>
      </para>

      <para>
       通常这就是该命令的名称，但是它可能包括额外数据，例如已被处理的行数。调用者不应该直接释放该结果。它将在相关的<structname>PGresult</>句柄被传递给<function>PQclear</function>之后被释放。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqcmdtuples">
     <term>
      <function>PQcmdTuples</function>
      <indexterm>
       <primary>PQcmdTuples</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回受该 SQL 命令影响的行数。
<synopsis>
char *PQcmdTuples(PGresult *res);
</synopsis>
      </para>

      <para>
       这个函数返回一个字符串，其中包含着产生<structname>PGresult</>的<acronym>SQL</>语句影响的行数。这个只能被用于下列情况：执行一个<command>SELECT</>、<command>CREATE TABLE AS</>、<command>INSERT</>、<command>UPDATE</>、<command>DELETE</>、<command>MOVE</>、<command>FETCH</>或<command>COPY</>语句，或者一个包含<command>INSERT</>、<command>UPDATE</>或<command>DELETE</>语句的预备查询的<command>EXECUTE</>。如果产生<structname>PGresult</>的命令是其他什么东西，<function>PQcmdTuples</>会返回一个空串。调用者不应该直接释放该结果。它将在相关的<structname>PGresult</>句柄被传递给<function>PQclear</function>之后被释放。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqoidvalue">
     <term>
      <function>PQoidValue</function>
      <indexterm>
       <primary>PQoidValue</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       如果该<acronym>SQL</>命令是一个正好将一行插入到具有 OID 的表的<command>INSERT</>，或者是一个包含合适<command>INSERT</>语句的预备查询的<command>EXECUTE</>，这个函数返回被插入行的 OID<indexterm><primary>OID</><secondary>in libpq</></>。否则，这个函数返回<literal>InvalidOid</literal>。如果被<command>INSERT</>语句影响的表不包含 OID，这个函数也将返回<literal>InvalidOid</literal>。
<synopsis>
Oid PQoidValue(const PGresult *res);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqoidstatus">
     <term>
      <function>PQoidStatus</function>
      <indexterm>
       <primary>PQoidStatus</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       由于支持<function>PQoidValue</function>以及不是线程安全的，这个函数已经被废弃。它返回包含被插入行的 OID 的一个字符串，而<function>PQoidValue</function>返回 OID 值。
<synopsis>
char *PQoidStatus(const PGresult *res);
</synopsis>
      </para>

     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>

  <sect2 id="libpq-exec-escape-string">
   <title>用于包含在 SQL 命令中的转移字符串</title>

   <indexterm zone="libpq-exec-escape-string">
    <primary>escaping strings</primary>
    <secondary>in libpq</secondary>
   </indexterm>

   <variablelist>
    <varlistentry id="libpq-pqescapeliteral">
     <term>
      <function>PQescapeLiteral</function>
      <indexterm>
       <primary>PQescapeLiteral</primary>
      </indexterm>
     </term>

     <listitem>
     <para>
<synopsis>
char *PQescapeLiteral(PGconn *conn, const char *str, size_t length);
</synopsis>
     </para>

     <para>
      为了让一个串能用在 SQL 命令中，<function>PQescapeLiteral</function>可对它进行转义。当在 SQL 命令中插入一个数据值作为文字常量时，这个函数很有用。一些字符（例如引号和反斜线）必须被转义以防止它们被 SQL 解析器解释成特殊的意思。<function>PQescapeLiteral</>执行这种操作。
     </para>

     <para>
      <function>PQescapeLiteral</>返回一个<parameter>str</parameter>参数的已被转义版本，该版本被放在用<function>malloc()</>分配的内存中。当该结果不再被需要时，这个内存应该用<function>PQfreemem()</>释放。一个终止的零字节不是必须的，并且不应该被计入<parameter>length</>（如果在<parameter>length</>字节被处理之前找到一个终止字节，<function>PQescapeLiteral</>会停止在零，该行为更像<function>strncpy</>）。返回串中的所有特殊字符都被替换掉，这样它们能被<productname>PostgreSQL</productname>字符串解析器正确地处理。还会加上一个终止零字节。包括在结果串中的<productname>PostgreSQL</productname>字符串必须用单引号包围。
     </para>

     <para>
      发生错误时，<function>PQescapeLiteral</>返回<symbol>NULL</>并且一个合适的消息会被存储在<parameter>conn</>对象中。
     </para>

     <tip>
      <para>
       在处理从一个非可信源接收到的串时，做正确的转义特别重要。否则就会有安全性风险：你容易受到<quote>SQL 注入</>攻击，其中可能会有预期之外的 SQL 语句会被喂给你的数据库。
      </para>
     </tip>

     <para>
      注意，当一个数据值被作为<function>PQexecParams</>或其兄弟例程中的一个独立参数传递时，没有必要做转义而且做转义也不正确。
     </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqescapeidentifier">
     <term>
      <function>PQescapeIdentifier</function>
      <indexterm>
       <primary>PQescapeIdentifier</primary>
      </indexterm>
     </term>

     <listitem>
     <para>
<synopsis>
char *PQescapeIdentifier(PGconn *conn, const char *str, size_t length);
</synopsis>
     </para>

     <para>
      <function>PQescapeIdentifier</function>转义一个要用作 SQL 标识符的字符串，例如表名、列名或函数名。当一个用户提供的标识符可能包含被 SQL 解析器解释为标识符一部分的特殊字符时，或者当该标识符可能包含大小写形式应该被保留的大写字符时，这个函数很有用。
     </para>

     <para>
      <function>PQescapeIdentifier</>返回一个<parameter>str</parameter>参数的已被转义为 SQL 标识符的版本，该版本被放在用<function>malloc()</>分配的内存中。当该结果不再被需要时，这个内存应该用<function>PQfreemem()</>释放。一个终止的零字节不是必须的，并且不应该被计入<parameter>length</>（如果在<parameter>length</>字节被处理之前找到一个终止字节，<function>PQescapeIdentifier</>会停止在零，该行为更像<function>strncpy</>）。返回串中的所有特殊字符都被替换掉，这样它们能被作为一个 SQL 标识符正确地处理。还会加上一个终止零字节。返回串也将被双引号包围。
     </para>

     <para>
      发生错误时，<function>PQescapeIdentifier</>返回<symbol>NULL</>并且一个合适的消息会被存储在<parameter>conn</>对象中。
     </para>

     <tip>
      <para>
       与字符串一样，要阻止 SQL 注入攻击，当从一个不可信的来源接收到 SQL 标识符时，它们必须被转义。
      </para>
     </tip>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqescapestringconn">
     <term>
      <function>PQescapeStringConn</function>
      <indexterm>
       <primary>PQescapeStringConn</primary>
      </indexterm>
     </term>

     <listitem>
     <para>
<synopsis>
size_t PQescapeStringConn(PGconn *conn,
                          char *to, const char *from, size_t length,
                          int *error);
</synopsis>
     </para>

     <para>
      <function>PQescapeStringConn</>转义字符串，它很像<function>PQescapeLiteral</>。与<function>PQescapeLiteral</>不一样的是，调用者负责提供一个合适尺寸的缓冲区。此外，<function>PQescapeStringConn</>不产生必须包围<productname>PostgreSQL</>字符串的单引号。它们应该在结果要插入的 SQL 命令中提供。参数<parameter>from</>指向要被转义的串的第一个字符，并且<parameter>length</>参数给出了这个串中的字节数。一个终止的零字节不是必须的，并且不应该被计入<parameter>length</>（如果在<parameter>length</>字节被处理之前找到一个终止字节，<function>PQescapeStringConn</>会停止在零，该行为更像<function>strncpy</>）。 <parameter>to</>应当指向一个缓冲区，它能够保持至少比<parameter>length</>值的两倍还要多至少一个字节，否则该行为是未被定义的。如果<parameter>to</>和<parameter>from</>串重叠，行为也是未被定义的。
     </para>

     <para>
      如果<parameter>error</>参数不是<symbol>NULL</>，那么成功时<literal>*error</>被设置为零，错误时设置为非零。当前唯一可能的错误情况涉及源串中非法的多字节编码。错误时仍然会产生输出串，但是可以预期服务器将认为它是畸形的并且拒绝它。在发生错误时，一个合适的消息被存储在<parameter>conn</>对象中，不管<parameter>error</>是不是<symbol>NULL</>。
     </para>

     <para>
      <function>PQescapeStringConn</>返回写到<parameter>to</>的字节数，不包括终止的零字节。
     </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqescapestring">
     <term>
      <function>PQescapeString</function>
      <indexterm>
       <primary>PQescapeString</primary>
      </indexterm>
     </term>

     <listitem>
     <para>
       <function>PQescapeString</>是一个更老的被废弃的<function>PQescapeStringConn</>版本。
<synopsis>
size_t PQescapeString (char *to, const char *from, size_t length);
</synopsis>
     </para>

     <para>
      <function>PQescapeStringConn</>和<function>PQescapeString</>之间的唯一区别是不需要<structname>PGconn</>或<parameter>error</>参数。正因为如此，它不能基于连接属性（例如字符编码）调整它的行为并且因此<emphasis>它可能给出错误的结果</>。还有，它没有方法报告错误情况。
     </para>

     <para>
      <function>PQescapeString</>可以在一次只使用一个<productname>PostgreSQL</>连接的客户端程序中安全地使用（在这种情况下它可以<quote>在现象后面</>找出它需要知道的东西）。在其他环境中它是一个安全性灾难并且应该用<function>PQescapeStringConn</>来避免。
     </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqescapebyteaconn">
     <term>
      <function>PQescapeByteaConn</function>
      <indexterm>
       <primary>PQescapeByteaConn</primary>
      </indexterm>
     </term>

     <listitem>
     <para>
       把要用于一个 SQL 命令的二进制数据用类型<type>bytea</type>转义。和<function>PQescapeStringConn</function>一样，只有在将数据直接插入到一个 SQL 命令串时才使用它。
<synopsis>
unsigned char *PQescapeByteaConn(PGconn *conn,
                                 const unsigned char *from,
                                 size_t from_length,
                                 size_t *to_length);
</synopsis>
      </para>

      <para>
       当某些字节值被用作一个<acronym>SQL</acronym>语句中的<type>bytea</type>文字的一部分时，它们必须被转义。<function>PQescapeByteaConn</function>转义使用十六进制编码或反斜线转义的字节。详见<xref linkend="datatype-binary">。
      </para>

      <para>
       <parameter>from</parameter>参数指向要被转义的串的第一个字节，并且<parameter>from_length</parameter>参数给出这个二进制串中的字节数（一个终止的零字节是不需要的也是不被计算的）。<parameter>to_length</parameter>参数指向一个将保持生成的已转义串长度的变量。这个结果串长度包括结果的终止零字节。
      </para>

      <para>
       <function>PQescapeByteaConn</>返回一个<parameter>from</parameter>参数的已被转义为二进制串的版本，该版本被放在用<function>malloc()</>分配的内存中。当该结果不再被需要时，这个内存应该用<function>PQfreemem()</>释放。返回串中的所有特殊字符都被替换掉，这样它们能被<productname>PostgreSQL</productname>的字符串解析器以及<type>bytea</type>输入函数正确地处理。还会加上一个终止零字节。不是结果串一部分的<productname>PostgreSQL</productname>字符串必须被单引号包围。
      </para>

      <para>
       在发生错误时，将返回一个空指针，并且一个合适的错误消息被存储在<parameter>conn</>对象中。当前，唯一可能的错误是没有足够的内存用于结果串。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqescapebytea">
     <term>
      <function>PQescapeBytea</function>
      <indexterm>
       <primary>PQescapeBytea</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       <function>PQescapeBytea</>是一个更老的被废弃的<function>PQescapeByteaConn</>版本。
<synopsis>
unsigned char *PQescapeBytea(const unsigned char *from,
                             size_t from_length,
                             size_t *to_length);
</synopsis>
      </para>

      <para>
       与<function>PQescapeByteaConn</>的唯一区别是<function>PQescapeBytea</>不用一个<structname>PGconn</>参数。正因为这样，<function>PQescapeBytea</>只能在一次只使用一个<productname>PostgreSQL</>连接的客户端程序中安全地使用（在这种情况下它可以<quote>在现象后面</>找出它需要知道的东西）。如果在有多个数据库连接的程序中使用，它<emphasis>可能给出错误的结果</>（在那种情况下使用<function>PQescapeByteaConn</>）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqunescapebytea">
     <term>
      <function>PQunescapeBytea</function>
      <indexterm>
       <primary>PQunescapeBytea</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       将二进制数据的一个字符串表示转换成二进制数据 &mdash; 它是<function>PQescapeBytea</function>的逆向函数。当检索文本格式的<type>bytea</type>数据时，需要这个函数，但检索二进制个事时则不需要它。

<synopsis>
unsigned char *PQunescapeBytea(const unsigned char *from, size_t *to_length);
</synopsis>
      </para>

      <para>
       <parameter>from</parameter>参数指向一个字符串，例如<function>PQgetvalue</function>被应用到一个<type>bytea</type>列上所返回的。<function>PQunescapeBytea</function>把这个串表示转换成它的二进制表示。它返回一个指向用<function>malloc()</function>分配的缓冲区的指针，在错误时返回<symbol>NULL</>，并且把缓冲区的尺寸放在<parameter>to_length</parameter>中。当结果不再需要时，它必须使用<function>PQfreemem</>释放。
      </para>

      <para>
       这种转换并不完全是<function>PQescapeBytea</function>的逆函数，因为当从<function>PQgetvalue</function>接收到字符串时，我们并不能期待它被<quote>转义</>。特别地这意味着不需要考虑字符串引用，并且因此也不需要一个参数。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>

 </sect1>

 <sect1 id="libpq-async">
  <title>异步命令处理</title>

  <indexterm zone="libpq-async">
   <primary>非阻塞连接</primary>
  </indexterm>

  <para>
   <function>PQexec</function>函数对于在普通的同步应用中提交命令是足以胜任的。不过，它的一些缺点可能对某些用户很重要： 

   <itemizedlist>
    <listitem>
     <para>
      <function>PQexec</function>会等待命令完成。该应用可能有其他的工作要做（例如维护用户界面），这时它将不希望阻塞等待回应。
     </para>
    </listitem>

    <listitem>
     <para>
      因为客户端应用的执行在它等待结果时会被挂起，对于应用来说很难决定要不要尝试取消正在进行的命令（这可以在一个信号处理器中完成，但别无他法）。
     </para>
    </listitem>

    <listitem>
     <para>
      <function>PQexec</function>只能返回一个<structname>PGresult</structname>结构。如果提交的命令串包含多个<acronym>SQL</acronym>命令， 除了最后一个<structname>PGresult</structname>之外都会被<function>PQexec</function>丢弃。
     </para>
    </listitem>

    <listitem>
     <para>
      <function>PQexec</function>总是收集命令的整个结果，把它缓存在一个单一的<structname>PGresult</structname>中。虽然这简化了应用的错误处理逻辑，它对于包含很多行的结果并不现实。
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   不想受到这些限制的应用可以改用构建<function>PQexec</function>的底层函数：<function>PQsendQuery</function>以及<function>PQgetResult</function>。还有
   <function>PQsendQueryParams</function>、
   <function>PQsendPrepare</function>、
   <function>PQsendQueryPrepared</function>、
   <function>PQsendDescribePrepared</function>以及
   <function>PQsendDescribePortal</function>，
   它们可以与<function>PQgetResult</function>一起使用来分别复制<function>PQexecParams</function>、
   <function>PQprepare</function>、
   <function>PQexecPrepared</function>、
   <function>PQdescribePrepared</function>和
   <function>PQdescribePortal</function>的功能。

   <variablelist>
    <varlistentry id="libpq-pqsendquery">
     <term>
      <function>PQsendQuery</function>
      <indexterm>
       <primary>PQsendQuery</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       向服务器提交一个命令而不等待结果。如果该命令被成功发送则返回 1，否则返回 0（此时，可以用<function>PQerrorMessage</>获取关于失败的信息）。
<synopsis>
int PQsendQuery(PGconn *conn, const char *command);
</synopsis>

       在成功调用<function>PQsendQuery</function>后，调用<function>PQgetResult</function>一次或者多次来获取结果。在<function>PQgetResult</function>返回一个空指针之前，都不能再次调用<function>PQsendQuery</function>，返回的空指针指示该命令已经完成。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsendqueryparams">
     <term>
      <function>PQsendQueryParams</function>
      <indexterm>
       <primary>PQsendQueryParams</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       向服务器提交一个命令和单独的参数，而不等待结果。
<synopsis>
int PQsendQueryParams(PGconn *conn,
                      const char *command,
                      int nParams,
                      const Oid *paramTypes,
                      const char * const *paramValues,
                      const int *paramLengths,
                      const int *paramFormats,
                      int resultFormat);
</synopsis>

       这个函数等效于<function>PQsendQuery</function>，不过查询参数可以独立于查询字符串分开指定。该函数的参数处理和<function>PQexecParams</function>一样。和<function>PQexecParams</function>类似，它不能在 2.0 协议的连接上工作，并且它只允许在查询字符串中有一条命令。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsendprepare">
     <term>
      <function>PQsendPrepare</>
      <indexterm>
       <primary>PQsendPrepare</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       发送一个请求用给定参数创建一个预备语句，而不等待完成。
<synopsis>
int PQsendPrepare(PGconn *conn,
                  const char *stmtName,
                  const char *query,
                  int nParams,
                  const Oid *paramTypes);
</synopsis>

       这个函数是<function>PQprepare</>的异步版本：如果它能发送这个请求，则返回 1；如果不能，则返回 0。在成功调用之后，调用<function>PQgetResult</function>判断服务器是否成功创建了预备语句。这个函数的参数的处理和<function>PQprepare</function>一样。和<function>PQprepare</function>类似，它不能在 2.0 协议的连接上工作。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsendqueryprepared">
     <term>
      <function>PQsendQueryPrepared</function>
      <indexterm>
       <primary>PQsendQueryPrepared</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       发送一个请求用给定参数执行一个预备语句，而不等待结果。
<synopsis>
int PQsendQueryPrepared(PGconn *conn,
                        const char *stmtName,
                        int nParams,
                        const char * const *paramValues,
                        const int *paramLengths,
                        const int *paramFormats,
                        int resultFormat);
</synopsis>

       这个函数与<function>PQsendQueryParams</function>类似，但是要执行的命令是通过一个之前已经命名的预备语句指定， 而不是一个给出的查询字符串。该函数的参数处理和<function>PQexecPrepared</function>一样。和<function>PQexecPrepared</function>类似，它不能在 2.0 协议的连接上工作。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsenddescribeprepared">
     <term>
      <function>PQsendDescribePrepared</>
      <indexterm>
       <primary>PQsendDescribePrepared</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       发送一个请求获得指定的预备语句的信息，但不等待完成。
<synopsis>
int PQsendDescribePrepared(PGconn *conn, const char *stmtName);
</synopsis>

       这个函数是<function>PQdescribePrepared</>的一个异步版本：如果它能够发送请求，则返回 1；否则，返回 0。在一次成功的调用后，调用<function>PQgetResult</function>来得到结果。该函数的参数处理和<function>PQdescribePrepared</function>一样。和<function>PQdescribePrepared</function>类似，它不能在 2.0 协议的连接上工作。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsenddescribeportal">
     <term>
      <function>PQsendDescribePortal</>
      <indexterm>
       <primary>PQsendDescribePortal</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       提交一个请求来获得关于指定入口的信息，但不等待完成。
<synopsis>
int PQsendDescribePortal(PGconn *conn, const char *portalName);
</synopsis>

       这个函数是<function>PQdescribePortal</>的一个异步版本：如果它能够发送请求，则返回 1；否则，返回 0。在一次成功的调用后，调用<function>PQgetResult</function>来得到结果。该函数的参数处理和<function>PQdescribePortal</function>一样。和<function>PQdescribePortal</function>类似，它不能在 2.0 协议的连接上工作。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqgetresult">
     <term>
      <function>PQgetResult</function>
      <indexterm>
       <primary>PQgetResult</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       等待来自于一个之前的
       <function>PQsendQuery</function>、
       <function>PQsendQueryParams</function>、
       <function>PQsendPrepare</function>、
       <function>PQsendQueryPrepared</function>、
       <function>PQsendDescribePrepared</function>或
       <function>PQsendDescribePortal</function>调用的结果，并且返回它。当该命令完成并且没有更多结果时，将返回一个空指针。
<synopsis>
PGresult *PQgetResult(PGconn *conn);
</synopsis>
      </para>

      <para>
       <function>PQgetResult</function>必须被反复调用直到它返回一个空指针，空指针表示该命令完成（如果在没有命令活动时被调用，<function>PQgetResult</function>将立即返回一个空指针）。每一个来自<function>PQgetResult</function>的非空结果应该使用之前描述的同一个<structname>PGresult</>访问器处理。不要忘记在处理完之后释放每一个结果对象。注意，只有一个命令是活动的并且<function>PQconsumeInput</function>还没有读取必要的响应数据时， <function>PQgetResult</function>将会阻塞。
      </para>

      <note>
       <para>
        即使当<function>PQresultStatus</function>指出一个致命错误时，<function>PQgetResult</function>也应当被调用直到它返回一个空指针，以允许<application>libpq</>完全处理该错误信息。
       </para>
      </note>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   使用<function>PQsendQuery</function>和<function>PQgetResult</function>解决了<function>PQexec</function>的一个问题：如果一个命令字符串包含多个<acronym>SQL</acronym>命令，这些命令的结果可以被个别地获得（顺便说一句：这样就允许一种简单的重叠处理形式， 客户端可以处理一个命令的结果，而同时服务器可以继续处理同一命令字符串中后面的查询）。
  </para>

  <para>
   可以被<function>PQsendQuery</function>和<function>PQgetResult</function>获得的另一种常常想要的特性是一次从大型结果中检索一行。这会在<xref linkend="libpq-single-row-mode">中讨论。
  </para>

  <para>
   如果只调用<function>PQgetResult</function>（不调用<function>PQsendQuery</function>等）将仍会导致客户端阻塞直到服务器完成下一个<acronym>SQL</acronym>命令。用两个函数的正确使用可以避免这种情况：

   <variablelist>
    <varlistentry id="libpq-pqconsumeinput">
     <term>
      <function>PQconsumeInput</function>
      <indexterm>
       <primary>PQconsumeInput</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       如果有来自服务器的输入可用，则使用之。
<synopsis>
int PQconsumeInput(PGconn *conn);
</synopsis>
      </para>

      <para>
       <function>PQconsumeInput</function>通常返回 1 表明<quote>没有错误</quote>，而返回 0 表明有某种麻烦发生（此时可以用<function>PQerrorMessage</function>）。注意该结果并不表明是否真正收集了任何输入数据。在调用<function>PQconsumeInput</function>之后，应用可以检查<function>PQisBusy</function>和/或<function>PQnotifies</function>来看看它们的状态是否改变。
      </para>

      <para>
       即使应用还不准备处理一个结果或通知，<function>PQconsumeInput</function>也可以被调用。这个函数将读取可用的数 据并且把它保存在一个缓冲区中，从而导致一个<function>select()</function>的读准备好指示消失。因此应用可以使用<function>PQconsumeInput</function>立即清除<function>select()</function>条件，并且在空闲时再检查结果。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqisbusy">
     <term>
      <function>PQisBusy</function>
      <indexterm>
       <primary>PQisBusy</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       如果一个命令繁忙则返回 1，也就是说<function>PQgetResult</function>会阻塞等待输入。返回 0 表示可以调用<function>PQgetResult</function>而不用担心阻塞。
<synopsis>
int PQisBusy(PGconn *conn);
</synopsis>
      </para>

      <para>
       <function>PQisBusy</function>本身将不会尝试从服务器读取数据，因此必须先调用<function>PQconsumeInput</function>，否则繁忙状态将永远不会结束。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   一个使用这些函数的典型应用将有一个主循环，在主循环中会使用<function>select()</function>或<function>poll()</>等待所有它必须响应的情况。其中之一将是来自服务器的输入可用，对<function>select()</function>来说意味着<function>PQsocket</function>标识的文件描述符上有可读的数据。当主循环检测到输入准备好时，它将调用<function>PQconsumeInput</function>读取输入。然后它可以调用<function>PQisBusy</function>，如果<function>PQisBusy</function>返回假（0）则接着调用<function>PQgetResult</function>。它还可以调用<function>PQnotifies</function>检测<command>NOTIFY</>消息（见<xref linkend="libpq-notify">）。
  </para>

  <para>
   一个使用<function>PQsendQuery</function>/<function>PQgetResult</function>的客户端也可以尝试取消一个正在被服务器处理的命令，见<xref linkend="libpq-cancel">。但是，不管<function>PQcancel</function>的返回值是什么，应用都必须继续使用<function>PQgetResult</function>进行正常的结果读取序列。一次成功的取消只会导致命令比不取消时更快终止。
  </para>

  <para>
   通过使用上述函数，我们可以避免在等待来自数据库服务器的输入时被阻塞。不过，在应用发送输出给服务器时还是可能出现阻塞。这种情况比较少见，但是如果发送非常长的 SQL 命令或者数据值时确实可能发生（不过，最有可能是在应用通过<command>COPY IN</command>发送数据时）。为了避免这种可能性并且实现完全地非阻塞数据库操作，可以使用下列附加函数。

   <variablelist>
    <varlistentry id="libpq-pqsetnonblocking">
     <term>
      <function>PQsetnonblocking</function>
      <indexterm>
       <primary>PQsetnonblocking</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       把连接的状态设置为非阻塞。
<synopsis>
int PQsetnonblocking(PGconn *conn, int arg);
</synopsis>
      </para>

      <para>
       如果<parameter>arg</parameter>为 1，把连接状态设置为非阻塞；如果<parameter>arg</parameter>为 0，把连接状态设置为阻塞。如果 OK 返回 0，如果错误返回 -1。
      </para>

      <para>
       在非阻塞状态，调用
       <function>PQsendQuery</function>、<function>PQputline</function>、
       <function>PQputnbytes</function>和
       <function>PQendcopy</function>将不会阻塞，但是如果它们需要被再次调用则会返回一个错误。
      </para>

      <para>
       注意<function>PQexec</function>不会遵循任何非阻塞模式；如果调用<function>PQexec</function>，那么它的行为总是阻塞的。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqisnonblocking">
     <term>
      <function>PQisnonblocking</function>
      <indexterm>
       <primary>PQisnonblocking</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回数据库连接的阻塞状态。
<synopsis>
int PQisnonblocking(const PGconn *conn);
</synopsis>
      </para>

      <para>
       如果连接被设置为非阻塞状态，返回 1，如果是阻塞状态返回 0。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqflush">
     <term>
      <function>PQflush</function>
       <indexterm>
        <primary>PQflush</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
       尝试把任何正在排队的输出数据刷到服务器。如果成功（或者发送队列为空）返回 0， 如果因某种原因失败则返回 -1，或者如果还无法把发送队列中的所有数据都发送出去，则返回 1（这种情况只在连接为非阻塞时候才会发生）。
<synopsis>
int PQflush(PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
  
  <para>
   在一个非阻塞连接上发送任何命令或者数据之后，要调用<function>PQflush</function>。
   如果它返回 1，就要等待套接字变成读准备好或写准备好。如果它变为写准备好，应再次调用
   <function>PQflush</function>。如果它变为读准备好，则应先调用
   <function>PQconsumeInput</function>，然后再调用<function>PQflush</function>。
   一直重复直到<function>PQflush</function>返回 0（有必要检查读准备好并且用
   <function>PQconsumeInput</function>耗尽输入，因为服务器可能阻塞给我们发送数据
   的尝试，例如 NOTICE 消息，并且在我们读它的数据之前它都不会读我们的数据）。一旦
   <function>PQflush</function>返回 0，应等待套接字变成读准备好并且接着按照上文所述
   读取响应。
  </para>

  <para>
   在一个非阻塞的连接上发送任何命令或者数据之后，调用<function>PQflush</function>。如果返回 1， 就等待套接字变成写准备好然后再次调用它；重复直到它返回 0。一旦<function>PQflush</function>返回 0，则等待套接字变成读准备好，并且接着按上述的方式读取回应。
  </para>

 </sect1>

 <sect1 id="libpq-single-row-mode">
  <title>一行一行地检索查询结果</title>

  <indexterm zone="libpq-single-row-mode">
   <primary>libpq</primary>
   <secondary>single-row mode</secondary>
  </indexterm>

  <para>
   通常，<application>libpq</>会收集一个 SQL 命令的整个结果并且把它作为单个<structname>PGresult</structname>返回给应用。这对于返回大量行的命令是行不通的。对于这类情况，应用可以使用<function>PQsendQuery</function>和<function>PQgetResult</function>的<firstterm>单行模式</>。在这种模式中，结果行以一次一行的方式被返回给应用。
  </para>

  <para>
   要进入到单行模式，在一次成功的<function>PQsendQuery</function>（或者其他兄弟函数）调用后立即调用<function>PQsetSingleRowMode</function>。这种模式选择只对当前正在执行的查询有效。然后反复调用<function>PQgetResult</function>，直到它返回空，如<xref linkend="libpq-async">中所示。如果该查询返回行，它们会作为单个的<structname>PGresult</structname>对象返回，它们看起来都像普通的查询结果，只不过其状态代码是<literal>PGRES_SINGLE_TUPLE</literal>而非<literal>PGRES_TUPLES_OK</literal>。在最后一行之后或者紧接着该查询返回零行之后，一个状态为<literal>PGRES_TUPLES_OK</literal>的零行对象会被返回，这就是代表不会有更多行的信号（但是注意仍然有必要继续调用<function>PQgetResult</function>直到它返回空）。所有这些<structname>PGresult</structname>对象将包含相同的行描述数据（列名、类型等等），这些数据和通常一个查询的<structname>PGresult</structname>对象的相同。每一个对象都应该按常规用<function>PQclear</function>释放。
  </para>

  <para>
   <variablelist>
    <varlistentry id="libpq-pqsetsinglerowmode">
     <term>
      <function>PQsetSingleRowMode</function>
      <indexterm>
       <primary>PQsetSingleRowMode</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       为当前正在执行的查询选择单行模式。

<synopsis>
int PQsetSingleRowMode(PGconn *conn);
</synopsis>
      </para>

      <para>
       这个函数只能在调用<function>PQsendQuery</function>或一个其兄弟函数之后立刻调用，并且要在任何连接上的其他操作之前调用，例如<function>PQconsumeInput</function>或<function>PQgetResult</function>。如果在正确的时间被调用，该函数会为当前查询激活单行模式并且返回 1。否则模式会保持不变并且该函数返回 0。在任何情况下，当前查询结束之后模式都会恢复到正常。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <caution>
   <para>
    在处理一个查询时，服务器可能返回一些行并且接着遇到一个错误导致查询被中断。通常，<application>libpq</>会丢弃掉这样的行并且至报告错误。但是在单行模式中，那些行（错误之前返回的行）已经被返回给应用。因此，应用将看到一些<literal>PGRES_SINGLE_TUPLE</literal> <structname>PGresult</structname>对象并且然后看到一个<literal>PGRES_FATAL_ERROR</literal>对象。为了得到正确的事务行为，如果查询最终失败，应用必须被设计为丢弃或者撤销使用之前处理的行完成的事情。
   </para>
  </caution>

 </sect1>

 <sect1 id="libpq-cancel">
  <title>取消进行中的查询</title>

  <indexterm zone="libpq-cancel">
   <primary>canceling</primary>
   <secondary>SQL command</secondary>
  </indexterm>

  <para>
   一个客户端应用可以使用本节描述的函数请求取消一个仍在被服务器处理的命令。

   <variablelist>
    <varlistentry id="libpq-pqgetcancel">
     <term>
      <function>PQgetCancel</function>
      <indexterm>
       <primary>PQgetCancel</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       创建一个数据结构，这个数据结构包含取消一个通过特定数据库连接发出的命令所需要的信息。
<synopsis>
PGcancel *PQgetCancel(PGconn *conn);
</synopsis>
      </para>

      <para>
       给出一个PQgetCancel连接对象，PQgetCancel创建一个 PGcancel对象。如果给出 的conn是NULL或者是一个无效的连接，那么它将返回NULL。PGcancel对象是一个不透明的结构， 不应该为应用所直接访问；我们只能把它传递给PQcancel或者PQfreeCancel。
       给定一个<structname>PGconn</>连接对象，<function>PQgetCancel</function>创建一个<structname>PGcancel</><indexterm><primary>PGcancel</></>对象。如果给定的<parameter>conn</>为<symbol>NULL</>或者一个不合法的连接，它将返回<symbol>NULL</>。<structname>PGcancel</>对象是一个透明的结构，它不能直接被应用访问。它只能被传递给<function>PQcancel</function>或<function>PQfreeCancel</function>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfreecancel">
     <term>
      <function>PQfreeCancel</function>
      <indexterm>
       <primary>PQfreeCancel</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       释放一个由<function>PQgetCancel</function>创建的数据结构。
<synopsis>
void PQfreeCancel(PGcancel *cancel);
</synopsis>
      </para>

      <para>
       PQfreeCancel释放一个由前面的PQgetCancel创建的数据对象。
       <function>PQfreeCancel</function>释放一个之前由<function>PQgetCancel</function>创建的数据对象。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqcancel">
     <term>
      <function>PQcancel</function>
      <indexterm>
       <primary>PQcancel</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       要求服务器放弃当前命令的处理。
<synopsis>
int PQcancel(PGcancel *cancel, char *errbuf, int errbufsize);
</synopsis>
      </para>

      <para>
       如果取消请求成功发送，则返回值为 1，否则为 0。如果不成功，则<parameter>errbuf</>会被填充一个解释性的错误消息。<parameter>errbuf</>必须是一个尺寸为<parameter>errbufsize</>的字符数组（推荐尺寸为 256 字节）。，解释为何不成功。errbuf必须是 一个大小为errbufsize的 char 数组（建议大小为 256 字节）。
      </para>

      <para>
       不过，成功的发送并不保证请求会有任何效果。如果取消有效，那么当前的命令将提前终止并且返回一个错误结果。如果取消失败（也就是说， 因为服务器已经完成命令的处理），那么就根本不会有可见的结果。
      </para>

      <para>
       如果PQcancel是信号句柄里的一个局部变量，那么PQcancel可以在一个信号 句柄里安全地调用。在PQcancel涉及的范围里，PQcancel对象都是只读的， 因此我们也可以从一个与处理PGconn对象的线程分离的线程里处理它。
       如果<parameter>errbuf</>是信号处理器中的一个局部变量，<function>PQcancel</function>可以从一个信号处理器中安全地调用。在<structname>PGcancel</>有关的范围内，<function>PQcancel</function>都是只读的，因此也可以在一个从操纵<structname>PGconn</>对象的线程中独立出来的线程中调用它。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   <variablelist>
    <varlistentry id="libpq-pqrequestcancel">
     <term>
      <function>PQrequestCancel</function>
      <indexterm>
       <primary>PQrequestCancel</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       <function>PQrequestCancel</function>是<function>PQcancel</function>的一个被废弃的变体。
<synopsis>
int PQrequestCancel(PGconn *conn);
</synopsis>
      </para>

      <para>
       要求服务器放弃当前命令的处理。它直接在<structname>PGconn</>对象上进行操作， 并且如果失败，就会在<structname>PGconn</>对象里存储错误消息（因此可以用<function>PQerrorMessage</function>检索出来）。 尽管功能相同，这个方法在多线程程序里和信号处理器里会带来危险，因为它可能 覆盖<structname>PGconn</>的错误消息，进而将当前连接上正在处理的操作搞乱。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

 </sect1>

 <sect1 id="libpq-fastpath">
  <title>快速路径接口</title>

  <indexterm zone="libpq-fastpath">
   <primary>fast path</primary>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname>提供一种快速路径接口来向服务器发送简单的函数调用。
  </para>

  <tip>
   <para>
    这个接口在某种程度上已被废弃，因为我们可以通过创建一个定义该函数调用的预备语句来达到类似或者更强大的功能。然后，用参数和结果的二进制传输执行该语句，从而取代快速函数调用。 
   </para>
  </tip>

  <para>
   函数<function>PQfn</function><indexterm><primary>PQfn</></>请求通过快速路径接口执行服务器函数。
<synopsis>
PGresult *PQfn(PGconn *conn,
               int fnid,
               int *result_buf,
               int *result_len,
               int result_is_int,
               const PQArgBlock *args,
               int nargs);

typedef struct
{
    int len;
    int isint;
    union
    {
        int *ptr;
        int integer;
    } u;
} PQArgBlock;
</synopsis>
  </para>

  <para>
   <parameter>fnid</>参数是要被执行的函数的 OID。<parameter>args</>和
   <parameter>nargs</>定义了要传递给函数的参数；它们必须匹配已声明的函数
   参数列表。当一个参数结构的<parameter>isint</>域为真时，
   <parameter>u.integer</>值被以指定长度（必须是 1、2 或者 4 字节）整数的
   形式发送给服务器；这时候会发生恰当的字节交换。当<parameter>isint</>为
   假时，<parameter>*u.ptr</>中指定数量的字节将不做任何处理被发送出去；
   这些数据必须是服务器 预期的用于该函数参数数据类型的二进制传输的格式（由于
   历史原因<parameter>u.ptr</>被声明为类型<type>int *</>，其实把它考虑成
   <type>void *</>会更好）。<parameter>result_buf</parameter>是放置该函
   数返回值的缓冲区。调用者必须已经分配了足够的空间来存储返回值（这里没有检
   查！）。实际的结果长度将被放在<parameter>result_len</parameter>指向的
   整数中返回。如果预期结果是 2 或 4 字节整数，把
   <parameter>result_is_int</parameter>设为 1；否则设为 0。把
   <parameter>result_is_int</parameter>设为 1 导致<application>libpq</>
   在必要时对值进行交换字节，这样它就作为对客户端机器正确的<type>int</type>
   值被传输，注意对任一种允许的结果大小都会传递一个 4 字节到
   <parameter>*result_buf</>。当<parameter>result_is_int</>是 0 时，服务
   器发送的二进制格式字节将不做修改直接返回（在这种情况下，把
   <parameter>result_buf</parameter>考虑为类型<type>void *</>更好）。
  </para>

  <para>
   <function>PQfn</function>总是返回一个有效的<structname>PGresult</structname>指针。在使用结果之前应该检查结果状态。当结果不再使用后，调用者有义务使用<function>PQclear</function>释放<structname>PGresult</structname>。
  </para>

  <para>
   注意我们没办法处理空参数、空结果，也没办法在使用这个接口时处理集值结果。
  </para>

 </sect1>

 <sect1 id="libpq-notify">
  <title>异步提示</title>

  <indexterm zone="libpq-notify">
   <primary>NOTIFY</primary>
   <secondary>in libpq</secondary>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname>通过<command>LISTEN</command>和<command>NOTIFY</command>命令提供了异步通知。一个客户端会话用<command>LISTEN</command>命令在一个特定的通知频道中注册它感兴趣的通知（也可以用<command>UNLISTEN</command>命令停止监听）。当任何会话执行一个带有特定频道名的<command>NOTIFY</command>命令时，所有正在监听该频道的会话会被异步通知。可以传递一个<quote>载荷</>字符串来与监听者沟通附加的数据。
  </para>

  <para>
   <application>libpq</application>应用把<command>LISTEN</command>、<command>UNLISTEN</command>和<command>NOTIFY</command>命令作为通常的 SQL 命令提交。 随后通过调用<function>PQnotifies</function><indexterm><primary>PQnotifies</></>来检测<command>NOTIFY</command>消息的到达。
  </para>

  <para>
   函数<function>PQnotifies</function>从来自服务器的未处理通知消息列表中返回下一个通知。如果没有待处理的信息则返回一个空指针。一旦<function>PQnotifies</>返回一个通知，该通知会被认为已处理并且将被从通知列表中删除。

<synopsis>
PGnotify *PQnotifies(PGconn *conn);

typedef struct pgNotify
{
    char *relname;              /* notification channel name */
    int  be_pid;                /* process ID of notifying server process */
    char *extra;                /* notification payload string */
} PGnotify;
</synopsis>

   在处理完<function>PQnotifies</function>返回的<structname>PGnotify</structname>对象后，别忘了用<function>PQfreemem</function>把它释放。释放<structname>PGnotify</structname>指针就足够了；<structfield>relname</structfield>和<structfield>extra</structfield>域并不代表独立分配的内存（这些域的名称是历史性的，尤其是频道名称与关系名称没有什么联系）。
  </para>

  <para>
   <xref linkend="libpq-example-2">给出了一个例子程序展示异步通知的使用。
  </para>

  <para>
   <function>PQnotifies</function>实际上并不从服务器读取数据；它只是返回被另一个<application>libpq</application>函数之前吸收的消息。在以前的<application>libpq</application>版本中，及时收到<command>NOTIFY</>消息的唯一方法是持续地提交命令，即使是空命令也可以，并且在每次<function>PQexec</function>后检查<function>PQnotifies</function>。 虽然这个方法还能用，但是由于太过浪费处理能力已被废弃。
  </para>

  <para>
   当你没有可用的命令提交时，一种更好的检查<command>NOTIFY</>消息的方法是调用<function>PQconsumeInput</function>，然后检查<function>PQnotifies</function>。你可以使用<function>select()</function>来等待服务器数据到达，这样在无事可做时可以不浪费<acronym>CPU</acronym>能力（参考<function>PQsocket</function>来获得用于<function>select()</function>的文件描述符）。注意不管是用<function>PQsendQuery</function>/<function>PQgetResult</function>提交命令还是简单地使用<function>PQexec</function>，这种方法都能正常工作。不过，你应该记住在每次<function>PQgetResult</function>或<function>PQexec</function>之后检查<function>PQnotifies</function>，看看在命令的处理过程中是否有通知到达。
  </para>

 </sect1>

 <sect1 id="libpq-copy">
  <title><command>COPY</command>命令相关的函数</title>

  <indexterm zone="libpq-copy">
   <primary>COPY</primary>
   <secondary>with libpq</secondary>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname>中的<command>COPY</command>命令有用于<application>libpq</application>的对网络连接读出或者写入的选项。这一节描述的函数允许应用通过提供或者消耗已拷贝的数据来充分利用这个功能。
  </para>

  <para>
   整个处理是应用首先通过<function>PQexec</function>或者一个等效的函数发出 SQL <command>COPY</command>命令。对这个命令的响应（如果命令无误）将是一个状态代码是<literal>PGRES_COPY_OUT</literal>或 者<literal>PGRES_COPY_IN</literal>（取决于指定的拷贝方向）的<structname>PGresult</>对象。应用然后就应该使用这一节的函数接收或者传送数据行。在数据传输结束之后，另外一个<structname>PGresult</>对象会被返回以表明传输的成功或者失败。它的状态将是：<literal>PGRES_COMMAND_OK</literal>表示成功，<literal>PGRES_FATAL_ERROR</literal>表示发生了一些问题。此时我们可以通过<function>PQexec</function>发出进一步的 SQL 命令（在<command>COPY</command>操作的处理过程中，不能用同一个连接执行其它 SQL 命令）。
  </para>

  <para>
   如果一个<command>COPY</command>命令是通过<function>PQexec</function>在一个可能包含额外命令的字符串中发出的，那么应用在完成<command>COPY</command>序列之后必须继续用<function>PQgetResult</>取得结果。只有在<function>PQgetResult</>返回<symbol>NULL</symbol>时，我们才能确信<function>PQexec</function>的命令字符串已经处理完毕， 并且可以安全地发出更多命令。 
  </para>

  <para>
   这一节的函数应该只在从<function>PQexec</function>或<function>PQgetResult</function>获得了<literal>PGRES_COPY_OUT</literal>或<literal>PGRES_COPY_IN</literal>结果状态的后执行。
  </para>

  <para>
   一个承载了这些状态值之一的<structname>PGresult</>对象携带了正在开始的<command>COPY</command>操作的一些额外数据。这些额外的数据可以用于那些与带查询结果的连接一起使用的函数：

   <variablelist>
    <varlistentry id="libpq-pqnfields-1">
     <term>
      <function>PQnfields</function>
      <indexterm>
       <primary>PQnfields</primary>
       <secondary>with COPY</secondary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回要拷贝的列（域）的个数。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqbinarytuples-1">
     <term>
      <function>PQbinaryTuples</function>
      <indexterm>
       <primary>PQbinaryTuples</primary>
       <secondary>with COPY</secondary>
      </indexterm>
     </term>

     <listitem>
      <para>
       0 表示整体拷贝格式都是文本（行用新行分隔，列用分隔字符分隔等等）。1 表示整体拷贝格式都是二进制。详见<xref linkend="sql-copy">。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfformat-1">
     <term>
      <function>PQfformat</function>
      <indexterm>
       <primary>PQfformat</primary>
       <secondary>with COPY</secondary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回与拷贝操的每列相关的格式代码（0 是文本，1 是二进制）。当整体拷贝格式是文本时，那么每列的格式代码将总是零，但是二进制格式可以同时支持文本和二进制列（不过，就目前的<command>COPY</>实现而言，二进制拷贝中只会出现二进制列；所以目前每列的格式总是匹配总体格式）。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <note>
   <para>
    这些额外的数据值只在使用协议 3.0 时可用。在使用协议 2.0 时，所有这些函数都返回 0。
   </para>
  </note>

  <sect2 id="libpq-copy-send">
   <title>用于发送<command>COPY</command>数据的函数</title>

   <para>
    这些函数用于在<literal>COPY FROM STDIN</>期间发送数据。如果在连接不是<literal>COPY_IN</>状态，调用它们会失败。
   </para>

   <variablelist>
    <varlistentry id="libpq-pqputcopydata">
     <term>
      <function>PQputCopyData</function>
      <indexterm>
       <primary>PQputCopyData</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       在<literal>COPY_IN</>状态中向服务器发送数据。
<synopsis>
int PQputCopyData(PGconn *conn,
                  const char *buffer,
                  int nbytes);
</synopsis>
      </para>

      <para>
       传输指定<parameter>buffer</>中长度为<parameter>nbytes</>的<command>COPY</command>数据到服务器。如果数据发送成功，结果是 1；如果因为被阻塞（只可能发生在连接是非阻塞模式时）而没有发送，那么结果是零；如果发生错误，结果为 -1（如果返回值为 -1，那么使用<function>PQerrorMessage</function>检索细节。如果值是零，那么等待写准备好然后重试）。
      </para>

      <para>
       应用可以把<command>COPY</command>数据流划分成任意方便的大小放到缓冲区中。在发送时，缓冲区载荷的边界没有什么语意。数据流的内容必须匹配<command>COPY</>命令预期的数据格式；详见<xref linkend="sql-copy">。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqputcopyend">
     <term>
      <function>PQputCopyEnd</function>
      <indexterm>
       <primary>PQputCopyEnd</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       在<literal>COPY_IN</>状态中向服务器发送数据结束的指示。
<synopsis>
int PQputCopyEnd(PGconn *conn,
                 const char *errormsg);
</synopsis>
      </para>

      <para>
       如果<parameter>errormsg</>是<symbol>NULL</symbol>，则成功结束<literal>COPY_IN</>操作。如果<parameter>errormsg</>不是<symbol>NULL</symbol>则<command>COPY</>被强制失败，<parameter>errormsg</>指向的字符串是错误消息（不过，我们不应假定这个准确的错误信息将会从服务器传回，因为服务器可能已经因为其自身原因导致<command>COPY</>失败。还要注意的是在使用 3.0 协议之前的连接时，强制失败的选项是不能用的）。
      </para>

      <para>
       如果终止数据被发送，则结果为 1；如果因为发送企图会阻塞（只有在连接是在非阻塞模式时才可能出现）而没有被发送，则结果为零；如果发生错误则返回 -1（如果返回值是 -1，用<function>PQerrorMessage</function>检索详情。如果值是零，那么等待写准备好然后重新尝试）。
      </para>

      <para>
       在成功调用<function>PQputCopyEnd</>之后，调用<function>PQgetResult</>获取<command>COPY</>命令的最终结果状态。我们可以用平常的方法来等待这个结果可用。然后返回到正常的操作。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>

  <sect2 id="libpq-copy-receive">
   <title>用于接收<command>COPY</command>数据的函数</title>

   <para>
    这些函数用于在<literal>COPY TO STDOUT</>的过程中接收数据。如果连接不在<literal>COPY_OUT</>状态，那么调用它们将会失败。
   </para>

   <variablelist>
    <varlistentry id="libpq-pqgetcopydata">
     <term>
      <function>PQgetCopyData</function>
      <indexterm>
       <primary>PQgetCopyData</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       在<literal>COPY_OUT</>状态下从服务器接收数据。
<synopsis>
int PQgetCopyData(PGconn *conn,
                  char **buffer,
                  int async);
</synopsis>
      </para>

      <para>
       在一个<command>COPY</command>期间尝试从服务器获取另外一行数据。数据总是以每次一个数据行的方式被返回；如果只有一个部分行可用，那么它不会被返回。成功返回一个数据行涉及到分配一块内存来保存该数据。<parameter>buffer</>参数必须为非<symbol>NULL</symbol>。<parameter>*buffer</>被设置为指向分配到的内存的指针，或者是在没有返回缓冲区的情况下指向<symbol>NULL</symbol>。一个非<symbol>NULL</symbol>的结果缓冲区在不需要时必须用<function>PQfreemem</>释放。
      </para>

      <para>
       在成功返回一行之后，返回的值就是该数据行里数据的字节数（将是大于零）。被返回的字符串总是空终止的，虽然这可能只是对文本<command>COPY</command>有用。 一个零结果表示该<command>COPY</command>仍然在处理中，但是还没有可用的行（只在<parameter>async</>为真时才可能）。一个 -1 结果表示<command>COPY</command>已经完成。-2 结果表示发生了错误（参考<function>PQerrorMessage</>获取原因）。
      </para>

      <para>
       当<parameter>async</>为真时（非零），<function>PQgetCopyData</>将不会阻塞等待输入；如果<command>COPY</command>仍在处理过程中并且没有可用的完整行，那么它将返回零（在这种情况下等待读准备好，然后在再次调用<function>PQgetCopyData</>之前，调用<function>PQconsumeInput</>）。当<parameter>async</>为假（零）时，<function>PQgetCopyData</>将阻塞，直到数据可用或者操作完成。
      </para>

      <para>
       在<function>PQgetCopyData</>返回 -1 之后，调用<function>PQgetResult</>获取<command>COPY</>命令的最后结果状态。我们可以用平常的方法来等待这个结果可用。然后返回到正常的操作。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>

  <sect2 id="libpq-copy-deprecated">
   <title>用于<command>COPY</command>的废弃函数</title>

   <para>
    这些函数代表了以前的处理<command>COPY</>的方法。尽管它们还能用，但是现在已经被废弃，因为它们的错误处理很糟糕、检测结束数据的方法也不方便，并且缺少对二进制或非阻塞传输的支持。
   </para>

   <variablelist>
    <varlistentry id="libpq-pqgetline">
     <term>
      <function>PQgetline</function>
      <indexterm>
       <primary>PQgetline</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       读取一个以新行终止的字符行到（由服务器传输） 到一个长度为<parameter>length</>的字符串缓冲区。
<synopsis>
int PQgetline(PGconn *conn,
              char *buffer,
              int length);
</synopsis>
      </para>

      <para>
       这个函数拷贝最多<parameter>length</>-1 个字符到该缓冲区中，并且把终止的新行转换成一个零字节。<function>PQgetline</function>在输入结束时返回<symbol>EOF</symbol>，如果整行都被读取则返回 0，如果缓冲区填满了而还没有遇到结束的新行则返回  1。
       </para>
       <para>
       注意，应用必须检查是否一个新行包含两个字符<literal>\.</literal>，这表明服务器 已经完成了<command>COPY</command>命令的结果发送。如果应用可能收到超过<parameter>length</>-1 字符长的行， 我们就应该确保正确识别<literal>\.</literal>行（例如，不要把一个长数据行的结束当作一个终止行）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqgetlineasync">
     <term>
      <function>PQgetlineAsync</function>
      <indexterm>
       <primary>PQgetlineAsync</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       不阻塞地读取一行<command>COPY</command>数据（由服务器传输）到一个缓冲区中。
<synopsis>
int PQgetlineAsync(PGconn *conn,
                   char *buffer,
                   int bufsize);
</synopsis>
      </para>

      <para>
       这个函数类似于<function>PQgetline</function>，但是可以被用于那些必须异步读取<command>COPY</command>数据的应用， 也就是不阻塞的应用。在发出了<command>COPY</command>命令并得到了<literal>PGRES_COPY_OUT</literal>响应之后，应用应该调用<function>PQconsumeInput</function>和<function>PQgetlineAsync</function>直到检测到结束数据的信号。
       </para>
       <para>
       不像<function>PQgetline</function>，这个函数负责检测结束数据。
      </para>

      <para>
       在每次调用时，如果<application>libpq</>的输入缓冲区中有一个完整的数据行可用，<function>PQgetlineAsync</function>都将返回数据。否则，在剩余行到达之前不会返回数据。如果识别到拷贝数据结束的标志，此函数返回 -1；如果没有可用数据则返回 0； 或者是给出一个正数给出被返回的字节数。如果返回 -1，调用者下一步必须调用<function>PQendcopy</function>，然后回到正常处理。
      </para>

      <para>
       返回的数据将不超过一个数据行的范围。如果可能，每次将返回一个完整行。但如果调用者提供的缓冲区太小不足以容下服务器发送的行，那么将返回部分行。对于文本数据，这可以通过测试返回的最后一个字节是否<literal>\n</literal>来检测（在二进制<command>COPY</>中， 需要对<command>COPY</>数据格式进行实际的分析，以便做相同的判断）。被返回的字符串不是空结尾的（如果你想增加一个终止空，确保传递一个比实际可用空间少一字节的<parameter>bufsize</parameter>）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqputline">
     <term>
      <function>PQputline</function>
      <indexterm>
       <primary>PQputline</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       向服务器发送一个空终止的字符串。如果 OK 则返回 0；如果不能发送字符串则返回<symbol>EOF</symbol>。
<synopsis>
int PQputline(PGconn *conn,
              const char *string);
</synopsis>
      </para>

      <para>
       一系列<function>PQputline</function>调用发送的<command>COPY</command>数据流和<function>PQgetlineAsync</function>返回的数据具有相同的格式， 只是应用不需要每次<function>PQputline</function>调用中发送刚好一个数据行；在每次调用中发送多行或者部分行都是可以的。
      </para>

      <note>
       <para>
        在<productname>PostgreSQL</productname>协议 3.0 之前，应用必须显式地发送两个字符<literal>\.</literal>作为最后一行来指示服务器已经完成发送<command>COPY</>数据。虽然这么做仍然有效，但是它已经被废弃并且<literal>\.</literal>的特殊含义可能在将来的版本中删除。在发送完实际数据之后， 调用<function>PQendcopy</function>就足够了。
       </para>
      </note>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqputnbytes">
     <term>
      <function>PQputnbytes</function>
      <indexterm>
       <primary>PQputnbytes</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       向服务器发送一个非空终止的字符串。如果 OK 则返回 0，如果不能发送字符串则返回<symbol>EOF</symbol>。
<synopsis>
int PQputnbytes(PGconn *conn,
                const char *buffer,
                int nbytes);
</synopsis>
      </para>

      <para>
       这个函数类似<function>PQputline</function>，除了数据缓冲区不需要是空终止，因为要发送的字节数是直接指定的。在发送二进制数据时使用这个过程。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqendcopy">
     <term>
      <function>PQendcopy</function>
      <indexterm>
       <primary>PQendcopy</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       与服务器同步。
<synopsis>
int PQendcopy(PGconn *conn);
</synopsis>
       这个函数等待服务器完成拷贝。当最后一个字符串已经用<function>PQputline</function>发送给服务器时或者当最后一个字符串已经用<function>PGgetline</function>从服务器接收到时，就会发出这个函数。这个函数必须被发出，否则服务器将会和客户端<quote>不同步</quote>。从这个函数返回后，服务器就已经准备好接收下一个 SQL 命令了。函数成功完成时返回值为 0，否则返回非零值（如果返回值为非零值，用<function>PQerrorMessage</function>检索详情）。
      </para>

      <para>
       在使用<function>PQgetResult</function>时，应用应该通过反复调用<function>PQgetline</function>并且在看到终止行后调用<function>PQendcopy</function>来响应<literal>PGRES_COPY_OUT</literal>结果。然后它应该返回到<function>PQgetResult</function>循环直到<function>PQgetResult</function>返回一个空指针。类似地，<literal>PGRES_COPY_IN</literal>结果会用一系列<function>PQputline</function>加上之后的<function>PQendcopy</function>来处理，然后返 回到<function>PQgetResult</function>循环。这样的安排将保证嵌入到一系列<acronym>SQL</acronym>命令中的<command>COPY</command>命令将被正确执行。
      </para>

      <para>
       旧的应用很可能会通过<function>PQexec</function>提交一个<command>COPY</command>命令并且假定事务在<function>PQendcopy</function>之后完成。只有在<command>COPY</command>是命令字符串中唯一的<acronym>SQL</acronym>命令时才能正确工作。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>

 </sect1>

 <sect1 id="libpq-control">
  <title>控制函数</title>

  <para>
   这些函数控制<application>libpq</>行为各种各样的细节。
  </para>

  <variablelist>
   <varlistentry id="libpq-pqclientencoding">
    <term>
     <function>PQclientEncoding</function>
     <indexterm>
      <primary>PQclientEncoding</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      返回客户端编码。
<synopsis>
int PQclientEncoding(const PGconn *<replaceable>conn</replaceable>);
</synopsis>

      请注意，它返回的是编码 ID，而不是一个符号串字符串，如<literal>EUC_JP</literal>。
      如果不成功，它会返回 -1。要把一个编码 ID 转换为为一个编码名称，可以用：

<synopsis>
char *pg_encoding_to_char(int <replaceable>encoding_id</replaceable>);
</synopsis>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqsetclientencoding">
    <term>
     <function>PQsetClientEncoding</function>
     <indexterm>
      <primary>PQsetClientEncoding</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      设置客户端编码。
<synopsis>
int PQsetClientEncoding(PGconn *<replaceable>conn</replaceable>, const char *<replaceable>encoding</replaceable>);
</synopsis>

      <replaceable>conn</replaceable>是一个到服务器的连接，而<replaceable>encoding</replaceable>是你想使用的编码。如果函数成功地设置编码，则返回 0，否则返回 -1。这个连接的当前编码可以使用<function>PQclientEncoding</>确定。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqseterrorverbosity">
    <term>
     <function>PQsetErrorVerbosity</function>
     <indexterm>
      <primary>PQsetErrorVerbosity</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      决定<function>PQerrorMessage</>和<function>PQresultErrorMessage</>返回的消息的细节程度。
<synopsis>
typedef enum
{
    PQERRORS_TERSE,
    PQERRORS_DEFAULT,
    PQERRORS_VERBOSE
} PGVerbosity;

PGVerbosity PQsetErrorVerbosity(PGconn *conn, PGVerbosity verbosity);
</synopsis>

      <function>PQsetErrorVerbosity</>设置细节模式，并返回该连接的前一个设置。在<firstterm>TERSE</>模式下，返回的消息只包括严重性、主要文本以及位置；这些东西通常放在一个单一行中。缺省模式生成的消息包括上面的信息加上任何细节、提示或者上下文域（这些可能跨越多行）。<firstterm>VERBOSE</>模式包括所有可以可用的域。修改细节模式不会影响来自已有<structname>PGresult</>对象中的可用消息。只有随后创建的<structname>PGresult</>对象才受到影响。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqtrace">
    <term>
     <function>PQtrace</function>
     <indexterm>
      <primary>PQtrace</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      启用对客户端/服务器通讯的跟踪，把跟踪信息输出到一个调试文件流中。
<synopsis>
void PQtrace(PGconn *conn, FILE *stream);
</synopsis>
     </para>

     <note>
      <para>
       在 Windows 商，如果<application>libpq</>库和应用使用了不同的标志编译，那么这个函数调用会导致应用崩溃，因为<literal>FILE</>指针的内部表达是不一样的。特别是多线程/单线程、发布/调试 以及静态/动态标志应该是库和所有使用库的应用都一致。
      </para>
     </note>

    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pquntrace">
    <term>
     <function>PQuntrace</function>
     <indexterm>
      <primary>PQuntrace</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      禁用<function>PQtrace</function>打开的跟踪。
<synopsis>
void PQuntrace(PGconn *conn);
</synopsis>
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

 </sect1>

 <sect1 id="libpq-misc">
  <title>杂项函数</title>

  <para>
   一如往常，总有一些函数不适合放在任何其他地方。
  </para>

  <variablelist>
   <varlistentry id="libpq-pqfreemem">
    <term>
     <function>PQfreemem</function>
     <indexterm>
      <primary>PQfreemem</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      释放<application>libpq</>分配的内存。
<synopsis>
void PQfreemem(void *ptr);
</synopsis>
     </para>

     <para>
      释放<application>libpq</>分配的内存，尤其是<function>PQescapeByteaConn</function>、<function>PQescapeBytea</function>、<function>PQunescapeBytea</function>和<function>PQnotifies</function>分配的内存。特别重要的是，在微软 Windows 上使用这个函数，而不是<function>free()</>。这是因为只有 DLL 和应用的当多线程/单线程、发布/调试以及静态/动态标志相同时，才能在一个 DLL 中分配内存并且在应用中释放它。在非微软 Windows 平台上，这个函数与标准库函数<function>free()</>相同。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqconninfofree">
    <term>
     <function>PQconninfoFree</function>
     <indexterm>
      <primary>PQconninfoFree</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      释放<function>PQconndefaults</>或<function>PQconninfoParse</>分配的数据结构。
<synopsis>
void PQconninfoFree(PQconninfoOption *connOptions);
</synopsis>
     </para>

     <para>
      一个简单的<function>PQfreemem</function>不会做这些，因为数组包含对子字符串的引用。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqencryptpassword">
    <term>
     <function>PQencryptPassword</function>
     <indexterm>
      <primary>PQencryptPassword</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      准备一个<productname>PostgreSQL</>口令的加密形式。
<synopsis>
char * PQencryptPassword(const char *passwd, const char *user);
</synopsis>
      这个函数旨在用于那些希望发送类似于<literal>ALTER USER joe PASSWORD 'pwd'</>命令的客户端应用。不在这样一个命令中发送原始的明文密码是一个好习惯，因为它可能被暴露在命令日志、活动显示等等中。相反，在发送之前使用这个函数可以将口令转换为加密的形式。这个函数的参数是明文口令和要使用该口令的用户的 SQL 名。返回值是<function>malloc</function>分配的一个字符串，如果内存不足会返回<symbol>NULL</symbol>。调用者可以假定该字符串中不包含任何需要转义的特殊字符。当使用结束之后，用<function>PQfreemem</>进行释放。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqmakeemptypgresult">
    <term>
     <function>PQmakeEmptyPGresult</function>
     <indexterm>
      <primary>PQmakeEmptyPGresult</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      用给定的状态，构造一个空<structname>PGresult</structname>对象。
<synopsis>
PGresult *PQmakeEmptyPGresult(PGconn *conn, ExecStatusType status);
</synopsis>
     </para>

     <para>
      这是<application>libpq</>内部用于分配并初始化一个空<structname>PGresult</structname>对象的函数。如果不能分配内存，那么这个函数返回<symbol>NULL</>。它也是可以对外使用的，因为一些应用认为它可以用于产生结果对象（特别是带有错误状态的对象）本身。如果<parameter>conn</parameter>非空，并且<parameter>status</>表示一个错误，那么指定连接的当前错误消息会被复制到<structname>PGresult</structname>中。如果<parameter>conn</parameter>非空，那么连接中的任何已注册事件过程也会被复制到<structname>PGresult</structname>中（它们不会获得<literal>PGEVT_RESULTCREATE</>调用，但会看到<function>PQfireResultCreateEvents</function>）。注意在该对象上最终应该调用<function>PQclear</function>，正如对<application>libpq</application>本身返回的<structname>PGresult</structname>对象所作的那样。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqfireresultcreateevents">
    <term>
     <function>PQfireResultCreateEvents</function>
     <indexterm>
      <primary>PQfireResultCreateEvents</primary>
     </indexterm>
    </term>
    <listitem>
     <para>
      为每一个在<structname>PGresult</structname>对象中注册的事件过程触发一个<literal>PGEVT_RESULTCREATE</literal>事件（见<xref linkend="libpq-events">）。成功时返回非 0，如果任何事件过程失败则返回 0。

<synopsis>
int PQfireResultCreateEvents(PGconn *conn, PGresult *res);
</synopsis>
     </para>

     <para>
      <literal>conn</>参数被传送给事件过程，但不会被直接使用。如果事件过程不使用它，则会返回<symbol>NULL</>。
     </para>

     <para>
      已经接收到这个对象的<literal>PGEVT_RESULTCREATE</>或<literal>PGEVT_RESULTCOPY</>事件的事件过程不会被再次触发。
     </para>

     <para>
      这个函数与<function>PQmakeEmptyPGresult</function>分开的主要原因是在调用事件过程之前创建一个<structname>PGresult</structname>并且填充它常常是合适的。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqcopyresult">
    <term>
     <function>PQcopyResult</function>
     <indexterm>
      <primary>PQcopyResult</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      为一个<structname>PGresult</structname>对象创建一个拷贝。这个拷贝不会以任何方式链接到源结果，并且当该拷贝不再需要时，必须调用<function>PQclear</function>进行清理。如果函数失败，返回<symbol>NULL</>。

<synopsis>
PGresult *PQcopyResult(const PGresult *src, int flags);
</synopsis>
     </para>

     <para>
      这个函数的意图并非是制作一个准确的拷贝。返回的结果总是会被放入<literal>PGRES_TUPLES_OK</literal>状态，并且不会拷贝来源中的任何错误消息（不过它确实会拷贝命令状态字符串）。<parameter>flags</parameter>参数决定还要拷贝些什么。它通常是几个标志的按位 OR。<literal>PG_COPYRES_ATTRS</literal>指定复制源结果的属性（列定义）。<literal>PG_COPYRES_TUPLES</literal>指定复制源结果的元组（这也意味着复制属性）。<literal>PG_COPYRES_NOTICEHOOKS</literal>指定复制源结果的提醒钩子。<literal>PG_COPYRES_EVENTS</literal>指定复制源结果的事件（但是不会复制与源结果相关的实例数据）。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqsetresultattrs">
    <term>
     <function>PQsetResultAttrs</function>
     <indexterm>
      <primary>PQsetResultAttrs</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      设置<structname>PGresult</structname>对象的属性。
<synopsis>
int PQsetResultAttrs(PGresult *res, int numAttributes, PGresAttDesc *attDescs);
</synopsis>
     </para>

     <para>
      提供的<parameter>attDescs</parameter>被复制到结果中。如果<parameter>attDescs</parameter>指针为<symbol>NULL</>或<parameter>numAttributes</parameter>小于1，那么请求将被忽略并且函数成功。如果<parameter>res</parameter>已经包含属性，那么函数会失败。如果函数失败，返回值是 0。如果函数成功，返回值是非 0。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqsetvalue">
    <term>
     <function>PQsetvalue</function>
     <indexterm>
      <primary>PQsetvalue</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      设置一个<structname>PGresult</structname>对象的一个元组域值。
<synopsis>
int PQsetvalue(PGresult *res, int tup_num, int field_num, char *value, int len);
</synopsis>
     </para>

     <para>
      这个函数将自动按需增加结果的内置元组数组。但是，<parameter>tup_num</parameter>参数必须小于等于<function>PQntuples</function>，意味着这个函数对元组数组一次只能增加一个元组。但已存在的任意元组中的任意域可以以任意顺序进行调整。如果<parameter>field_num</parameter>的一个值已经存在，它会被覆盖。如果<parameter>len</parameter>是 -1，或<parameter>value</parameter>是<symbol>NULL</>， 该域值会被设置为一个 SQL 空值。<parameter>value</parameter>会被复制到结果的私有存储中，因此函数返回后就不再需要了。如果函数失败，返回值是 0。如果函数成功，返回值会是非 0。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqresultalloc">
    <term>
     <function>PQresultAlloc</function>
     <indexterm>
      <primary>PQresultAlloc</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      为一个<structname>PGresult</structname>对象分配附属存储。
<synopsis>
void *PQresultAlloc(PGresult *res, size_t nBytes);
</synopsis>
     </para>

     <para>
      当<parameter>res</parameter>被清除时，这个函数分配的内存也会被释放掉。如果函数失败，返回值是<symbol>NULL</>。结果被保证为按照数据的任意类型充分地对齐，正如<function>malloc</>所作的。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqlibversion">
    <term>
     <function>PQlibVersion</function>
     <indexterm>
      <primary>PQlibVersion</primary>
      <seealso>PQserverVersion</seealso>
     </indexterm>
    </term>

    <listitem>
     <para>
      返回所使用的<productname>libpq</>版本。
<synopsis>
int PQlibVersion(void);
</synopsis>
     </para>

     <para>
      在运行时，这个函数的结果可以被用来决定在当前已载入的 libpq 版本中特定的功能是否可用。例如，这个函数可以被用来决定哪些选项可以被用于<function>PQconnectdb</>或者 PostgreSQL 9.0 中加入的<literal>hex</> <type>bytea</>输出是否被支持。
     </para>

     <para>
      该数字是通过将主数字、次数字和修订数字转换为两位十进制数字并且将它们追加在一起形成的。例如，版本 9.1 将被返回为 90100，并且 9.1.2 将被返回为 90102（前导零不被显示）。
     </para>

     <note>
      <para>
       这个函数出现于<productname>PostgreSQL</>版本 9.1，因此它不能被用来在早期的版本中检测所需的功能，因为链接到它将会创建一个对版本 9.1 的链接依赖。
      </para>
     </note>
    </listitem>
   </varlistentry>

  </variablelist>

 </sect1>

 <sect1 id="libpq-notice-processing">
  <title>通知处理</title>

  <indexterm zone="libpq-notice-processing">
   <primary>notice processing</primary>
   <secondary>in libpq</secondary>
  </indexterm>

  <para>
   服务器产生的通知和警告消息不会被查询执行函数返回，因为它们不代表查询失败。它们可以被传递给一个通知处理函数，并且在处理者返回后执行会继续正常进行。默认的处理函数会把消息打印在<filename>stderr</filename>上，但是应用可以通过提供它自己的处理函数来重载这种行为。
  </para>

  <para>
   由于历史原因，通知处理有两个级别，称为通知接收器和通知处理器。通知接收器的默认行为是格式化通知并且将一个字符串传递给通知处理器来打印。不过，如果一个应用选择提供自己的通知接收器，它通常会忽略通知处理器层并且在通知接收器中完成所有工作。
  </para>

  <para>
   函数<function>PQsetNoticeReceiver</function>
   <indexterm><primary>notice receiver</></>
   <indexterm><primary>PQsetNoticeReceiver</></>为一个连接对象设置或者检查当前的通知接收器。相似地，
   <function>PQsetNoticeProcessor</function>
   <indexterm><primary>notice processor</></>
   <indexterm><primary>PQsetNoticeProcessor</></>设置或检查当前的通知处理器。

<synopsis>
typedef void (*PQnoticeReceiver) (void *arg, const PGresult *res);

PQnoticeReceiver
PQsetNoticeReceiver(PGconn *conn,
                    PQnoticeReceiver proc,
                    void *arg);

typedef void (*PQnoticeProcessor) (void *arg, const char *message);

PQnoticeProcessor
PQsetNoticeProcessor(PGconn *conn,
                     PQnoticeProcessor proc,
                     void *arg);
</synopsis>

   这些函数中的每一个会返回之前的通知接收器或处理器函数指针，并且设置新值。如果你提供了一个空函数指针，将不会采取任何动作，只会返回当前指针。
  </para>

  <para>
   当接收到一个服务器产生的或者<application>libpq</application>内部产生的通知或警告消息，通知接收器函数会被调用。它会以一种<symbol>PGRES_NONFATAL_ERROR</symbol> <structname>PGresult</structname>的形式传递该消息（这允许接收器使用<function>PQresultErrorField</>抽取个别的域，或者使用<function>PQresultErrorMessage</>完成预格式化的消息）。被传递给<function>PQsetNoticeReceiver</function>的同一个空指针也被传递（必要时，这个指针可以被用来访问应用相关的状态）。
  </para>

  <para>
   默认的通知接收器会简单地抽取消息（使用<function>PQresultErrorMessage</>）并且将它传递给通知处理器。
  </para>

  <para>
   通知处理器负责处理一个以文本形式给出的通知或警告消息。该消息的字符串文本（包括一个收尾的新行）被传递给通知处理器，外加一个同时被传递给<function>PQsetNoticeProcessor</function>的空指针（必要时，这个指针可以被用来访问应用相关的状态）。
  </para>

  <para>
   默认的通知处理器很简单：
<programlisting>
static void
defaultNoticeProcessor(void *arg, const char *message)
{
    fprintf(stderr, "%s", message);
}
</programlisting>
  </para>

  <para>
   一旦你设定了一个通知接收器或处理器，你应该期待只要<structname>PGconn</>对象或者从它构造出的<structname>PGresult</>对象存在，该函数就应该能被调用。在一个<structname>PGresult</>创建时，<structname>PGconn</>的当前通知处理指针被复制到<structname>PGresult</>中，以备类似<function>PQgetvalue</function>的函数使用。
  </para>

 </sect1>

 <sect1 id="libpq-events">
  <title>事件系统</title>

  <para>
   <application>libpq</application>的事件系统被设计为通知已注册的事件处理器它感兴趣的<application>libpq</application>事件，例如<structname>PGconn</structname>以及<structname>PGresult</structname>对象的创建和毁灭。一种主要的使用情况是这允许应用将自己的数据与一个<structname>PGconn</structname>或者<structname>PGresult</structname>关联在一起，并且确保那些数据在适当的时候被释放。
  </para>

  <para>
   每一个已注册的事件处理器与两部分数据相关，对于<application>libpq</application>它们只是透明的<literal>void *</>指针。当事件处理器被注册到一个<structname>PGconn</>时，会有一个应用提供的<firstterm>转移</>指针。该转移指针在<structname>PGconn</>及其产生的所有<structname>PGresult</>的生命期内都不会改变。因此，如果使用它，它必须指向长期存在的数据。此外，还有一个<firstterm>instance data</>指针，它在每一个<structname>PGconn</>和<structname>PGresult</>中都开始于<symbol>NULL</>。这个指针可以使用
   <function>PQinstanceData</function>、
   <function>PQsetInstanceData</function>、
   <function>PQresultInstanceData</function>和
   <function>PQsetResultInstanceData</function>函数操纵。注意和转移指针不同，一个<structname>PGconn</>的实例数据不会被从它创建的<structname>PGresult</>自动继承。<application>libpq</application>不知道转移和实例数据指针指向的是什么（如果有），并且将不会尝试释放它们 &mdash; 那是事件处理器的责任。
  </para>

  <sect2 id="libpq-events-types">
   <title>事件类型</title>

   <para>
    枚举<literal>PGEventId</>命名了事件系统处理的事件类型。它的所有值的名称都以<literal>PGEVT</literal>开始。对于每一种事件类型，都有一个相应的事件信息结构用来承载传递给事件处理器的参数。事件类型是：
   </para>

   <variablelist>
    <varlistentry id="libpq-pgevt-register">
     <term><literal>PGEVT_REGISTER</literal></term>
     <listitem>
      <para>
       当<function>PQregisterEventProc</function>被调用时，注册事件会发生。这是一个初始化每一个事件过程都可能需要的<literal>instanceData</literal>的最佳时机。每个连接的每个事件处理器只会触发一个注册事件。如果该事件过程失败，注册会被中止。

<synopsis>
typedef struct
{
    PGconn *conn;
} PGEventRegister;
</synopsis>

       当收到一个<literal>PGEVT_REGISTER</literal>事件时，<parameter>evtInfo</parameter>指针应该被造型为<structname>PGEventRegister *</structname>。这个结构包含一个状态应该为<literal>CONNECTION_OK</literal>的<structname>PGconn</structname>，保证在得到一个良好的<structname>PGconn</structname>之后能马上调用<function>PQregisterEventProc</function>。当返回一个失败代码时，所有的清理都必须被执行而不会发送<literal>PGEVT_CONNDESTROY</literal>事件。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pgevt-connreset">
     <term><literal>PGEVT_CONNRESET</literal></term>
     <listitem>
      <para>
       连接重置事件在<function>PQreset</function>或<function>PQresetPoll</function>完成时被触发。在两种情况中，只有重置成功才会触发该事件。如果事件过程失败，整个连接重置将失败，<structname>PGconn</structname>会被置为<literal>CONNECTION_BAD</literal>状态并且<function>PQresetPoll</function>将返回<literal>PGRES_POLLING_FAILED</literal>。

<synopsis>
typedef struct
{
    PGconn *conn;
} PGEventConnReset;
</synopsis>

       当收到一个<literal>PGEVT_CONNRESET</literal>事件时，<parameter>evtInfo</parameter>指针应该被造型为<structname>PGEventConnReset *</structname>。尽管所包含的<structname>PGconn</structname>刚被重置，所有的事件数据还是保持不变。这个事件应该被用来重置/重载/重新查询任何相关的<literal>instanceData</literal>。注意即使事件过程无法处理<literal>PGEVT_CONNRESET</>，它仍将在连接被关闭时接收到一个<literal>PGEVT_CONNDESTROY</>事件。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pgevt-conndestroy">
     <term><literal>PGEVT_CONNDESTROY</literal></term>
     <listitem>
      <para>
       为了响应<function>PQfinish</function>，连接销毁事件会被触发。由于 libpq 没有能力管理事件数据，事件过程有责任正确地清理它的事件数据。清理失败将会导致内存泄露。

<synopsis>
typedef struct
{
    PGconn *conn;
} PGEventConnDestroy;
</synopsis>

       当接收到一个<literal>PGEVT_CONNDESTROY</literal>事件时，<parameter>evtInfo</parameter>指针应该被造型为<structname>PGEventConnDestroy *</structname>。这个事件在<function>PQfinish</function>执行任何其他清理之前被触发。该事件过程的返回值被忽略，因为没有办法指示一个来自<function>PQfinish</function>的失败。还有，一个事件过程失败不该中断对不需要的内存的清理。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pgevt-resultcreate">
     <term><literal>PGEVT_RESULTCREATE</literal></term>
     <listitem>
      <para>
       为了响应任何生成一个结果的查询执行函数，结果创建事件会被触发。这些函数包括<function>PQgetResult</function>。这个事件只有在结果被成功地创建之后才会被触发。

<synopsis>
typedef struct
{
    PGconn *conn;
    PGresult *result;
} PGEventResultCreate;
</synopsis>

       当接收到一个<literal>PGEVT_RESULTCREATE</literal>事件时，<parameter>evtInfo</parameter>指针应该被造型为<structname>PGEventResultCreate *</structname>。<parameter>conn</parameter>是用来产生结果的连接。这是初始化任何需要与结果关联的<literal>instanceData</literal>的理想位置。如果该事件过程失败，结果将被清除并且失败将会被传播。该事件过程不能尝试自己<function>PQclear</>结果对象。当返回一个失败代码时，所有清理必须被执行而不会发送<literal>PGEVT_RESULTDESTROY</literal>事件。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pgevt-resultcopy">
     <term><literal>PGEVT_RESULTCOPY</literal></term>
     <listitem>
      <para>
       为了响应<function>PQcopyResult</function>，结果复制事件会被触发。这个事件只会在复制完成后才被触发。只有成功地处理了<literal>PGEVT_RESULTCREATE</literal>和<literal>PGEVT_RESULTCOPY</literal>事件的事件过程才将会收到<literal>PGEVT_RESULTCOPY</literal>事件。

<synopsis>
typedef struct
{
    const PGresult *src;
    PGresult *dest;
} PGEventResultCopy;
</synopsis>

       当收到一个<literal>PGEVT_RESULTCOPY</literal>事件时，<parameter>evtInfo</parameter>指针应该被造型为<structname>PGEventResultCopy *</structname>。<parameter>src</parameter>结果是要被复制的，而<parameter>dest</parameter>结果则是复制的目的地。这个事件可以被用来提供<literal>instanceData</literal>的一份深度副本，因为<literal>PQcopyResult</literal>没法这样做。如果该事件过程失败，整个复制操作将失败并且<parameter>dest</parameter>结果将被清除。当返回一个失败代码时，所有清理必须被执行而不会为目标结果发送<literal>PGEVT_RESULTDESTROY</literal>事件。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pgevt-resultdestroy">
     <term><literal>PGEVT_RESULTDESTROY</literal></term>
     <listitem>
      <para>
       为了响应<function>PQclear</function>，结果销毁事件会被触发。由于 libpq 没有能力管理事件数据，事件过程有责任正确地清理它的事件数据。清理失败将会导致内存泄露。

<synopsis>
typedef struct
{
    PGresult *result;
} PGEventResultDestroy;
</synopsis>

       当接收到一个<literal>PGEVT_RESULTDESTROY</literal>事件时，<parameter>evtInfo</parameter>指针应该被造型为<structname>PGEventResultDestroy *</structname>。这个事件在<function>PQclear</function>执行任何其他清理之前被触发。该事件过程的返回值被忽略，因为没有办法指示来自<function>PQclear</function>的失败。还有，一个事件过程失败不该中断不需要的内存的清理过程。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 id="libpq-events-proc">
   <title>事件回调函数</title>

   <variablelist>
    <varlistentry id="libpq-pgeventproc">
     <term>
      <literal>PGEventProc</literal>
      <indexterm>
       <primary>PGEventProc</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       <literal>PGEventProc</literal>是到一个事件过程的指针的 typedef，也就是从 libpq 接收事件的用户回调函数。一个事件过程的原型必须是

<synopsis>
int eventproc(PGEventId evtId, void *evtInfo, void *passThrough)
</synopsis>

       <parameter>evtId</parameter>指示发生了哪一个<literal>PGEVT</literal>事件。<parameter>evtInfo</parameter>指针必须被造型为合适的结构类型才能获得关于事件的进一步信息。当事件过程已被注册时，<parameter>passThrough</parameter>参数是提供给<function>PQregisterEventProc</function>的指针。如果成功，该函数应该返回非零值，失败则返回零。
      </para>

      <para>
       在任何一个<structname>PGconn</>中，一个特定事件过程只能被注册一次。这是因为该过程的地址被用作查找键来标识相关的实例数据。
      </para>

      <caution>
       <para>
        在 Windows 上，函数能够有两个不同的地址：一个对 DLL 之外可见而另一个对 DLL 之内可见。我们应当小心只有其中之一会被用于<application>libpq</>的事件过程函数，否则将会产生混淆。编写代码的最简单规则是将所有的事件过程声明为<literal>static</>。如果过程的地址必须对它自己的源代码文件之外可见，提供一个单独的函数来返回该地址。
       </para>
      </caution>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 id="libpq-events-funcs">
   <title>事件支持函数</title>

    <variablelist>
    <varlistentry id="libpq-pqregistereventproc">
     <term>
      <function>PQregisterEventProc</function>
      <indexterm>
       <primary>PQregisterEventProc</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       为 libpq 注册一个事件回调过程。

<synopsis>
int PQregisterEventProc(PGconn *conn, PGEventProc proc,
                        const char *name, void *passThrough);
</synopsis>
      </para>

      <para>
       在每一个你想要接收事件的<structname>PGconn</>上必须注册一个事件过程。和内存不同，没有限制说一个连接上能注册多少个事件过程。如果该函数成功，它会返回一个非零值。如果它失败，则会返回零。
      </para>

      <para>
       当一个 libpq 事件被触发时，<parameter>proc</parameter>参数将被调用。它的内存地址也被用来查找<literal>instanceData</literal>。<parameter>name</parameter>参数被用来在错误消息中引用该事件过程。这个值不能是<symbol>NULL</>或一个零长度串。名字串被复制到<structname>PGconn</>中，因此传递进来的东西不需要长期存在。当一个事件发生时，<parameter>passThrough</parameter>指针被传递给<parameter>proc</parameter>。这个参数可以是<symbol>NULL</>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsetinstancedata">
     <term>
      <function>PQsetInstanceData</function>
      <indexterm>
       <primary>PQsetInstanceData</primary>
      </indexterm>
     </term>
     <listitem>
      <para>
       设置连接<parameter>conn</>的用于过程<parameter>proc</>的<literal>instanceData</>为<parameter>data</>。它在成功时返回非零值，失败时返回零（只有<parameter>proc</>没有被正确地注册在<parameter>conn</>中，才可能会失败）。

<synopsis>
int PQsetInstanceData(PGconn *conn, PGEventProc proc, void *data);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqinstancedata">
     <term>
      <function>PQinstanceData</function>
      <indexterm>
       <primary>PQinstanceData</primary>
      </indexterm>
     </term>
     <listitem>
      <para>
       返回连接<parameter>conn</>的与过程<parameter>proc</>相关的<literal>instanceData</literal>，如果没有则返回<symbol>NULL</symbol>。

<synopsis>
void *PQinstanceData(const PGconn *conn, PGEventProc proc);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqresultsetinstancedata">
     <term>
      <function>PQresultSetInstanceData</function>
      <indexterm>
       <primary>PQresultSetInstanceData</primary>
      </indexterm>
     </term>
     <listitem>
      <para>
       把结果的用于<parameter>proc</>的<literal>instanceData</>设置为<parameter>data</>。成功返回非零，失败返回零（只有<parameter>proc</>没有被正确地注册在<parameter>conn</>中，才可能会失败）。

<synopsis>
int PQresultSetInstanceData(PGresult *res, PGEventProc proc, void *data);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqresultinstancedata">
     <term>
      <function>PQresultInstanceData</function>
      <indexterm>
       <primary>PQresultInstanceData</primary>
      </indexterm>
     </term>
     <listitem>
      <para>
       返回结果的与过程<parameter>proc</>相关的<literal>instanceData</literal>，如果没有则返回<symbol>NULL</symbol>。

<synopsis>
void *PQresultInstanceData(const PGresult *res, PGEventProc proc);
</synopsis>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 id="libpq-events-example">
   <title>事件实例</title>

   <para>
    这里是一个管理与 libpq 连接和结果相关的私有数据的例子的框架。
   </para>

<programlisting>
<![CDATA[
/* 要求 libpq 事件的头文件（注意：包括 libpq-fe.h） */
#include <libpq-events.h>

/* instanceData */
typedef struct
{
    int n;
    char *str;
} mydata;

/* PGEventProc */
static int myEventProc(PGEventId evtId, void *evtInfo, void *passThrough);

int
main(void)
{
    mydata *data;
    PGresult *res;
    PGconn *conn = PQconnectdb("dbname = postgres");

    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        PQfinish(conn);
        return 1;
    }

    /* 在任何应该接收事件的连接上调用一次。
     * 发送一个 PGEVT_REGISTER 给 myEventProc。
     */
    if (!PQregisterEventProc(conn, myEventProc, "mydata_proc", NULL))
    {
        fprintf(stderr, "Cannot register PGEventProc\n");
        PQfinish(conn);
        return 1;
    }

    /* conn 的 instanceData 可用 */
    data = PQinstanceData(conn, myEventProc);

    /* 发送一个 PGEVT_RESULTCREATE 给 myEventProc */
    res = PQexec(conn, "SELECT 1 + 1");

    /* 结果的 instanceData 可用 */
    data = PQresultInstanceData(res, myEventProc);

    /* 如果使用了 PG_COPYRES_EVENTS，发送一个 PGEVT_RESULTCOPY 给 myEventProc */
    res_copy = PQcopyResult(res, PG_COPYRES_TUPLES | PG_COPYRES_EVENTS);

    /* 如果在 PQcopyResult 调用时使用了 PG_COPYRES_EVENTS，结果的 instanceData 可用。*/
    data = PQresultInstanceData(res_copy, myEventProc);

    /* 两个清除都发送一个 PGEVT_RESULTDESTROY 给 myEventProc */
    PQclear(res);
    PQclear(res_copy);

    /* 发送一个 PGEVT_CONNDESTROY 给 myEventProc */
    PQfinish(conn);

    return 0;
}

static int
myEventProc(PGEventId evtId, void *evtInfo, void *passThrough)
{
    switch (evtId)
    {
        case PGEVT_REGISTER:
        {
            PGEventRegister *e = (PGEventRegister *)evtInfo;
            mydata *data = get_mydata(e->conn);

            /* 将应用相关的数据与连接关联起来 */
            PQsetInstanceData(e->conn, myEventProc, data);
            break;
        }

        case PGEVT_CONNRESET:
        {
            PGEventConnReset *e = (PGEventConnReset *)evtInfo;
            mydata *data = PQinstanceData(e->conn, myEventProc);

            if (data)
              memset(data, 0, sizeof(mydata));
            break;
        }

        case PGEVT_CONNDESTROY:
        {
            PGEventConnDestroy *e = (PGEventConnDestroy *)evtInfo;
            mydata *data = PQinstanceData(e->conn, myEventProc);

            /* 因为连接正在被销毁，释放示例数据 */
            if (data)
              free_mydata(data);
            break;
        }

        case PGEVT_RESULTCREATE:
        {
            PGEventResultCreate *e = (PGEventResultCreate *)evtInfo;
            mydata *conn_data = PQinstanceData(e->conn, myEventProc);
            mydata *res_data = dup_mydata(conn_data);

            /* 把应用相关的数据与结果（从 conn 复制过来）关联起来 */
            PQsetResultInstanceData(e->result, myEventProc, res_data);
            break;
        }

        case PGEVT_RESULTCOPY:
        {
            PGEventResultCopy *e = (PGEventResultCopy *)evtInfo;
            mydata *src_data = PQresultInstanceData(e->src, myEventProc);
            mydata *dest_data = dup_mydata(src_data);

            /* 把应用相关的数据与结果（从一个结果复制过来）关联起来 */
            PQsetResultInstanceData(e->dest, myEventProc, dest_data);
            break;
        }

        case PGEVT_RESULTDESTROY:
        {
            PGEventResultDestroy *e = (PGEventResultDestroy *)evtInfo;
            mydata *data = PQresultInstanceData(e->result, myEventProc);

            /* 因为结果正在被销毁，释放实例数据 */
            if (data)
              free_mydata(data);
            break;
        }

        /* 未知事件 ID，只返回 TRUE。 */
        default:
            break;
    }

    return TRUE; /* 事件处理成功 */
}
]]>
</programlisting>
  </sect2>
 </sect1>

 <sect1 id="libpq-envars">
  <title>环境变量</title>

  <indexterm zone="libpq-envars">
   <primary>环境变量</primary>
  </indexterm>

  <para>
   下列环境变量能被用于选择默认的连接参数值，如果调用代码没有直接指定值，它们将被用于<function>PQconnectdb</>、<function>PQsetdbLogin</>和<function>PQsetdb</>。例如，这些有助于防止数据库连接信息被硬编码到简单的客户端应用中。

   <itemizedlist>
    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGHOST</envar></primary>
      </indexterm>
      <envar>PGHOST</envar>的行为和<xref linkend="libpq-connect-host">连接参数相同。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGHOSTADDR</envar></primary>
      </indexterm>
      <envar>PGHOSTADDR</envar>的行为和<xref linkend="libpq-connect-hostaddr">连接参数相同。可以设置它来替代或者作为<envar>PGHOST</envar>的补充来防止 DNS 查找负担。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGPORT</envar></primary>
      </indexterm>
      <envar>PGPORT</envar>的行为和<xref linkend="libpq-connect-port">连接参数相同。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGDATABASE</envar></primary>
      </indexterm>
      <envar>PGDATABASE</envar>的行为和<xref linkend="libpq-connect-dbname">连接参数相同。
      </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGUSER</envar></primary>
      </indexterm>
      <envar>PGUSER</envar>的行为和<xref linkend="libpq-connect-user">连接参数相同。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGPASSWORD</envar></primary>
      </indexterm>
      <envar>PGPASSWORD</envar>的行为和<xref linkend="libpq-connect-password">连接参数相同。出于安全原因，我们不推荐使用这个环境变量，因为某些操作系统允许非根用户通过<application>ps</>看到进程的环境变量。可以考虑使用<filename>~/.pgpass</>文件（见<xref linkend="libpq-pgpass">）。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGPASSFILE</envar></primary>
      </indexterm>
      <envar>PGPASSFILE</envar>指定要用于查找的口令文件的名称。如果没有设置，默认为<filename>~/.pgpass</>（见<xref linkend="libpq-pgpass">）。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSERVICE</envar></primary>
      </indexterm>
      <envar>PGSERVICE</envar>的行为和<xref linkend="libpq-connect-service">连接参数相同。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSERVICEFILE</envar></primary>
      </indexterm>
      <envar>PGSERVICEFILE</envar>指定针对每个用户的连接服务文件名。如果没有设置，默认为<filename>~/.pg_service.conf</>（见<xref linkend="libpq-pgservice">）。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGREALM</envar></primary>
      </indexterm>
      如果<productname>PostgreSQL</productname>要使用的 Kerberos 领域和本地领域不同，<envar>PGREALM</envar>可以设置它。如果<envar>PGREALM</envar>被设置，<application>libpq</application>应用将尝试通过服务器鉴定这个领域并且使用独立的票据文件来避免与本地票据文件冲突。只有在服务器选择了 GSSAPI 认证时，这个环境变量才被使用。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGOPTIONS</envar></primary>
      </indexterm>
      <envar>PGOPTIONS</envar>的行为和<xref linkend="libpq-connect-options">连接参数相同。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGAPPNAME</envar></primary>
      </indexterm>
      <envar>PGAPPNAME</envar>的行为和<xref linkend="libpq-connect-application-name">连接参数相同。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSSLMODE</envar></primary>
      </indexterm>
      <envar>PGSSLMODE</envar>的行为和<xref linkend="libpq-connect-sslmode">连接参数相同。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGREQUIRESSL</envar></primary>
      </indexterm>
      <envar>PGREQUIRESSL</envar>的行为和<xref linkend="libpq-connect-requiressl">连接参数相同。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSSLCOMPRESSION</envar></primary>
      </indexterm>
      <envar>PGSSLCOMPRESSION</envar>的行为和<xref linkend="libpq-connect-sslcompression">连接参数相同。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSSLCERT</envar></primary>
      </indexterm>
      <envar>PGSSLCERT</envar>的行为和<xref linkend="libpq-connect-sslcert">连接参数相同。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSSLKEY</envar></primary>
      </indexterm>
      <envar>PGSSLKEY</envar>的行为和<xref linkend="libpq-connect-sslkey">连接参数相同。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSSLROOTCERT</envar></primary>
      </indexterm>
      <envar>PGSSLROOTCERT</envar>的行为和<xref linkend="libpq-connect-sslrootcert">连接参数相同。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSSLCRL</envar></primary>
      </indexterm>
      <envar>PGSSLCRL</envar>的行为和<xref linkend="libpq-connect-sslcrl">连接参数相同。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGREQUIREPEER</envar></primary>
      </indexterm>
      <envar>PGREQUIREPEER</envar>的行为和<xref linkend="libpq-connect-requirepeer">连接参数相同。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGKRBSRVNAME</envar></primary>
      </indexterm>
      <envar>PGKRBSRVNAME</envar>的行为和<xref linkend="libpq-connect-krbsrvname">连接参数相同。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGGSSLIB</envar></primary>
      </indexterm>
      <envar>PGGSSLIB</envar>的行为和<xref linkend="libpq-connect-gsslib">连接参数相同。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGCONNECT_TIMEOUT</envar></primary>
      </indexterm>
      <envar>PGCONNECT_TIMEOUT</envar>的行为和<xref linkend="libpq-connect-connect-timeout">连接参数相同。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGCLIENTENCODING</envar></primary>
      </indexterm>
      <envar>PGCLIENTENCODING</envar>的行为和<xref linkend="libpq-connect-client-encoding">连接参数相同。
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   下面的环境变量可用来为每一个<productname>PostgreSQL</productname>会话指定默认行为（为每一个用户或每一个数据库设置默认行为的方法还可见<xref linkend="sql-alterrole">和<xref linkend="sql-alterdatabase">命令）。

   <itemizedlist>
    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGDATESTYLE</envar></primary>
      </indexterm>
      <envar>PGDATESTYLE</envar>设置日期/时间表示的默认风格（等同于<literal>SET datestyle TO ...</literal>）。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGTZ</envar></primary>
      </indexterm>
      <envar>PGTZ</envar>设置默认的时区（等同于<literal>SET timezone TO ...</literal>）。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGGEQO</envar></primary>
      </indexterm>
      <envar>PGGEQO</envar>为遗传查询优化器设置默认模式（等同于<literal>SET geqo TO ...</literal>）。
     </para>
    </listitem>
   </itemizedlist>

   这些环境变量的正确值可参考<acronym>SQL</acronym> 命令 <xref linkend="sql-set">。
  </para>

  <para>
   下面的环境变量决定<application>libpq</application>的内部行为，它们会覆盖编译在程序中的默认值。

   <itemizedlist>
    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSYSCONFDIR</envar></primary>
      </indexterm>
      <envar>PGSYSCONFDIR</envar>设置包含<filename>pg_service.conf</>文件以及未来版本中可能出现的其他系统范围配置文件的目录。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGLOCALEDIR</envar></primary>
      </indexterm>
      <envar>PGLOCALEDIR</envar>设置包含用于消息国际化的<literal>locale</>文件的目录。
     </para>
    </listitem>
   </itemizedlist>
  </para>

 </sect1>


 <sect1 id="libpq-pgpass">
  <title>口令文件</title>

  <indexterm zone="libpq-pgpass">
   <primary>口令文件</primary>
  </indexterm>
  <indexterm zone="libpq-pgpass">
   <primary>.pgpass</primary>
  </indexterm>

  <para>
   一个用户主目录中的<filename>.pgpass</filename>文件或者被<envar>PGPASSFILE</envar>引用的文件可能包含在连接需要时使用的口令（并且其他情况不会指定口令）。在微软的 Windows 上该文件被命名为<filename>%APPDATA%\postgresql\pgpass.conf</>（其中<filename>%APPDATA%</>指的是用户配置中的应用数据子目录）。
  </para>

  <para>
   这个文件应该包含下列格式的行：
<synopsis>
<replaceable>hostname</replaceable>:<replaceable>port</replaceable>:<replaceable>database</replaceable>:<replaceable>username</replaceable>:<replaceable>password</replaceable>
</synopsis>
   （你可以向该文件增加一个提醒：把上面的行复制到该文件并且在前面加上<literal>#</>）。前四个域的每一个都可以是文字值或者匹配任何东西的<literal>*</literal>。第一个匹配当前连接参数的行中的口令域将被使用（因此，在使用通配符时把更特殊的项放在前面）。如果一个条目需要包含<literal>:</literal>或者<literal>\</literal>，用<literal>\</literal>对该字符转义。一个<literal>localhost</>主机名匹配来自本地机器的 TCP （主机名<literal>localhost</>）和 Unix 域套接字（<literal>pghost</>为空或者默认套接字目录）连接。在一台后备服务器上，一个名为<literal>replication</>的数据库名匹配到主控服务器的流复制连接。<literal>database</>域的用途有限，因为用户对同一个集簇中所有数据库都有相同的口令。
  </para>

  <para>
   在 Unix 系统上，<filename>.pgpass</filename>上的权限必须不允许所有人或组内访问，可以用命令<command>chmod 0600 ~/.pgpass</command>实现。如果权限没有这么严格，该文件将被忽略。在微软 Windows 上，该文件被假定存储在一个安全的目录中，因此不会进行特别的权限检查。
  </para>
 </sect1>


 <sect1 id="libpq-pgservice">
  <title>连接服务文件</title>

  <indexterm zone="libpq-pgservice">
   <primary>连接服务文件</primary>
  </indexterm>
  <indexterm zone="libpq-pgservice">
   <primary>pg_service.conf</primary>
  </indexterm>
  <indexterm zone="libpq-pgservice">
   <primary>.pg_service.conf</primary>
  </indexterm>

  <para>
   连接服务文件允许 libpq 连接参数与一个单一服务名称关联。那个服务名称可以被一个 libpq 连接指定，与其相关的设置将被使用。这允许在不重新编译 libpq 应用的前提下修改连接参数。服务名称也可以被使用<envar>PGSERVICE</envar>环境变量来指定。
  </para>

  <para>
   连接服务文件可以是每个用户都有一个的服务文件，它位于<filename>~/.pg_service.conf</filename>或者环境变量<envar>PGSERVICEFILE</envar>指定的位置。它也可以是一个系统范围的文件，位于<filename>`pg_config --sysconfdir`/pg_service.conf</filename>的或者环境变量<envar>PGSYSCONFDIR</envar>指定的目录。如果相同名称的服务定义存在于用户和系统文件中，用户文件将优先考虑。
  </para>

  <para>
   该文件使用一种<quote>INI 文件</quote>格式，其中小节名是服务名并且参数是连接参数。列表见<xref linkend="libpq-paramkeywords">。例如：
<programlisting>
# comment
[mydb]
host=somehost
port=5433
user=admin
</programlisting>
   <filename>share/pg_service.conf.sample</filename>中提供了一个例子文件。
  </para>
 </sect1>


 <sect1 id="libpq-ldap">
  <title>连接参数的 LDAP 查找</title>

  <indexterm zone="libpq-ldap">
   <primary>LDAP 连接参数查找</primary>
  </indexterm>

  <para>
   如果<application>libpq</application>已经在编译时打开了 LDAP 支持（<command>configure</command>的选项<literal><option>--with-ldap</option></literal>），就可以通过 LDAP 从一个中央服务器检索<literal>host</literal>或<literal>dbname</literal>之类的连接参数。这样做的好处是如果一个数据库的连接参数改变，不需要在所有的客户端机器上更新连接信息。
  </para>

  <para>
   LDAP 连接参数查找使用连接服务文件<filename>pg_service.conf</filename>（见<xref linkend="libpq-pgservice">）。<filename>pg_service.conf</filename>中一个以<literal>ldap://</literal>开始的行将被识别为一个 LDAP URL 并且将执行一个 LDAP 查询。结果必须是一个<literal>keyword = value</literal>对列表，它将被用来设置连接选项。URL 必须遵循 RFC 1959 并且是形式
<synopsis>
ldap://[<replaceable>hostname</replaceable>[:<replaceable>port</replaceable>]]/<replaceable>search_base</replaceable>?<replaceable>attribute</replaceable>?<replaceable>search_scope</replaceable>?<replaceable>filter</replaceable>
</synopsis>
   其中<replaceable>hostname</replaceable>默认为<literal>localhost</literal>并且<replaceable>port</replaceable>默认为 389。
  </para>

  <para>
   一次成功的 LDAP 查找后，<filename>pg_service.conf</filename>的处理被终止。但是如果联系不上 LDAP 则会继续处理<filename>pg_service.conf</filename>。这就提供了后手，可以加入更多指向不同 LDAP 服务器的 LDAP URL 行、经典的<literal>keyword = value</literal>对或者默认连接选项。如果你宁愿在这种情况下得到一个错误消息，在该 LDAP URL 之后增加一个语法错误的行。
  </para>

  <para>
   一个和 LDIF 文件一起创建的 LDAP 条目实例
<programlisting>
version:1
dn:cn=mydatabase,dc=mycompany,dc=com
changetype:add
objectclass:top
objectclass:groupOfUniqueNames
cn:mydatabase
uniqueMember:host=dbserver.mycompany.com
uniqueMember:port=5439
uniqueMember:dbname=mydb
uniqueMember:user=mydb_user
uniqueMember:sslmode=require
</programlisting>
   可以用下面的 LDAP URL 查询：
<programlisting>
ldap://ldap.mycompany.com/dc=mycompany,dc=com?uniqueMember?one?(cn=mydatabase)
</programlisting>
  </para>

  <para>
   你也可以将常规的服务文件条目和 LDAP 查找混合。<filename>pg_service.conf</filename>中一节的完整例子：
<programlisting>
version:1
dn:cn=mydatabase,dc=mycompany,dc=com
changetype:add
objectclass:top
objectclass:device
cn:mydatabase
description:host=dbserver.mycompany.com
description:port=5439
description:dbname=mydb
description:user=mydb_user
description:sslmode=require
</programlisting>
   可以用下面的 LDAP URL 查询到：
<programlisting>
ldap://ldap.mycompany.com/dc=mycompany,dc=com?description?one?(cn=mydatabase)
</programlisting>
  </para>

 </sect1>


 <sect1 id="libpq-ssl">
  <title>SSL 支持</title>

  <indexterm zone="libpq-ssl">
   <primary>SSL</primary>
  </indexterm>

  <para>
   <productname>PostgreSQL</>本地支持使用<acronym>SSL</>连接加密客户端/服务器通信以提高安全性。关于服务器端的<acronym>SSL</>功能详见<xref linkend="ssl-tcp">。
  </para>

  <para>
   <application>libpq</application>读取系统范围的<productname>OpenSSL</productname>配置文件。默认情况下，这个文件被命名为<filename>openssl.cnf</filename>并且位于<literal>openssl version -d</>所报告的目录中。可以通过设置环境变量<envar>OPENSSL_CONF</envar>把这个默认值覆盖为想要的配置文件的名称。
  </para>

 <sect2 id="libq-ssl-certificates">
  <title>服务器证书的客户端验证</title>

  <para>
   默认情况下，<productname>PostgreSQL</>将不会执行服务器证书的任何验证。这意味着可以在不被客户端知晓的情况下伪造服务器身份（例如通过修改一个 DNS 记录或者接管服务器的 IP 地址）。为了阻止哄骗，必须使用<acronym>SSL</>证书验证。
  </para>

  <para>
   如果参数<literal>sslmode</>被设置为<literal>verify-ca</>，libpq 将通过检查证书链一直到一个可信的证书机构（<acronym>CA</>）来验证服务器是可信的。如果<literal>sslmode</>被设置为<literal>verify-full</>，libpq 将<emphasis>还会</>验证服务器主机名是否匹配它的证书。如果服务器证书不能被验证，SSL 连接将失败。在大部分对安全敏感的环境中，我们都推荐使用<literal>verify-full</>。
  </para>

  <para>
   在<literal>verify-full</>模式中，证书的<literal>cn</>（通用名）属性被用来与主机名匹配。如果<literal>cn</>属性开始于一个星号（<literal>*</>），它将被视作为一个通配符，并且将会匹配所有<emphasis>除了</>一个句点（<literal>.</>）之外的字符。这意味着该证书将不会匹配子域。如果连接是使用一个 IP 地址而不是一个主机名创建的，该 IP 地址将被匹配（不做任何 DNS 查找）。
  </para>

  <para>
   要允许服务器证书验证，一个或多个可信的<acronym>CA</>必须被放置在服务器主目录下的文件<filename>~/.postgresql/root.crt</>中。如果中间<acronym>CA</>出现在<filename>root.crt</filename>中，该文件必须也包含到它们的根<acronym>CA</>的证书链（在微软 Windows 上该文件被命名为<filename>%APPDATA%\postgresql\root.crt</filename>）。
  </para>

  <para>
   如果文件<filename>~/.postgresql/root.crl</filename>存在（微软 Windows 上的<filename>%APPDATA%\postgresql\root.crl</filename>），证书撤销列表（CRL）项也会被检查。
  </para>

  <para>
   根证书文件和 CRL 的位置可以通过设置连接参数<literal>sslrootcert</>和<literal>sslcrl</>或环境变量<envar>PGSSLROOTCERT</>和<envar>PGSSLCRL</>改变。
  </para>

  <note>
   <para>
    为了与 PostgreSQL 的早期版本达到向后兼容，如果存在一个根 CA 文件，<literal>sslmode</literal>=<literal>require</literal>的行为将与<literal>verify-ca</literal>相同，即服务器证书根据 CA 验证。我们鼓励依赖这种行为，并且需要证书验证的应用应该总是使用<literal>verify-ca</literal>或者<literal>verify-full</literal>。
   </para>
  </note>
 </sect2>

 <sect2 id="libpq-ssl-clientcert">
  <title>客户端证书</title>

  <para>
   如果服务器要求一个可信的客户端证书，<application>libpq</application>将发送用户主目录中<filename>~/.postgresql/postgresql.crt</>文件存储的证书。该证书必须由一个受服务器信任的证书机构（<acronym>CA</acronym>）签发。也必须存在一个私钥文件<filename>~/.postgresql/postgresql.key</>。该私钥文件不能允许全部用户或者组用户的任何访问，可以通过命令<command>chmod 0600 ~/.postgresql/postgresql.key</command>实现。在微软 Windows 上这些文件被命名为<filename>%APPDATA%\postgresql\postgresql.crt</filename>和<filename>%APPDATA%\postgresql\postgresql.key</filename>，不会有特别的权限检查，因为该目录已经被假定为安全。证书和密钥文件的位置可以使用连接参数<literal>sslcert</>和<literal>sslkey</>或者环境变量<envar>PGSSLCERT</>和<envar>PGSSLKEY</>覆盖。
  </para>

  <para>
   要使用这样一个证书，将签发机构的证书加入到<filename>postgresql.crt</>文件，
   然后是它的上级机构的证书，并且一直到一个受服务器信任的证书机构（
   <quote>根</>机构或者<quote>中间</>机构），即由该服务器的
   <filename>root.crt</filename>文件中的一个证书签发。
  </para>

  <para>
   注意客户端的<filename>~/.postgresql/root.crt</>列出了被认为可信的能用于签发服务器证书的顶层 CA。原则上不需要列出签发客户端证书的 CA，大部分情况下这些 CA 也被信任可以用于服务器证书。
  </para>

 </sect2>

 <sect2 id="libpq-ssl-protection">
  <title>不同模式中提供的保护</title>

  <para>
   <literal>sslmode</>参数的不同值提供了不同级别的保护。SSL 能够针对三类攻击提供保护：

   <variablelist>
    <varlistentry>
     <term>窃听</term>
     <listitem>
      <para>如果一个第三方能够检查客户端和服务器之间的网络流量，它能读取连接信息（包括用户名和口令）以及被传递的数据。<acronym>SSL</>使用加密来阻止这种攻击。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>中间人（<acronym>MITM</>）</term>
     <listitem>
      <para>如果一个第三方能对客户端和服务器之间传送的数据进行修改，它就能假装是服务器并且因此能看见并且修改数据，<emphasis>即使这些数据已被加密</>。然后第三方可以将连接信息和数据转送给原来的服务器，使得它不可能检测到攻击。这样做的通常途径包括 DNS 污染和地址劫持，借此客户端被重定向到一个不同的服务器。还有几种其他的攻击方式能够完成这种攻击。<acronym>SSL</>使用证书验证让客户端认证服务器，就可以阻止这种攻击。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>模仿</term>
     <listitem>
      <para>如果一个第三方能假装是一个授权的客户端，它能够简单地访问它本不能访问的数据。通常这可以由不安全的口令管理所致。<acronym>SSL</>使用客户端证书来确保只有持有合法证书的客户端才能访问服务器，这样就能阻止这种攻击。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   对于一个已知安全的连接，在连接被建立之前，SSL 使用必须被配置在<emphasis>客户端和服务器</>之上。如果只在服务器上配置，客户端在知道服务器要求高安全性之前可能会结束发送敏感信息（例如口令）。在 libpq 中，要确保连接安全，可以设置<literal>sslmode</>参数为<literal>verify-full</>或<literal>verify-ca</>并且为系统提供一个根证书用来验证。这类似于使用一个<literal>https</> <acronym>URL</>进行加密网页浏览。
  </para>

  <para>
   一旦服务器已经被认证，客户端可以传递敏感数据。这意味着直到这一点，客户端都不需要知道是否证书将被用于认证，这样只需要在服务器配置中指定就比较安全。
  </para>

  <para>
   所有<acronym>SSL</>选项都带来了加密和密钥交换的负荷，因此必须在性能和安全性之间做出平衡。<xref linkend="libpq-ssl-sslmode-statements">不同<literal>sslmode</>值所保护的风险，以及它们是怎样看待安全性和负荷的。
  </para>

  <table id="libpq-ssl-sslmode-statements">
   <title>SSL 模式描述</title>
   <tgroup cols="4">
    <thead>
     <row>
      <entry><literal>sslmode</></entry>
      <entry>窃听保护</entry>
      <entry><acronym>MITM</>保护</entry>
      <entry>声明</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>disable</></entry>
      <entry>No</entry>
      <entry>No</entry>
      <entry>我不关心安全性，并且我不想为加密增加负荷。
      </entry>
     </row>

     <row>
      <entry><literal>allow</></entry>
      <entry>可能</entry>
      <entry>No</entry>
      <entry>我不关心安全性，但如果服务器坚持，我将承担加密带来的负荷。
      </entry>
     </row>

     <row>
      <entry><literal>prefer</></entry>
      <entry>可能</entry>
      <entry>No</entry>
      <entry>我不关心安全性，但如果服务器支持，我希望承担加密带来的负荷。
      </entry>
     </row>

     <row>
      <entry><literal>require</></entry>
      <entry>Yes</entry>
      <entry>No</entry>
      <entry>我想要对数据加密，并且我接受因此带来的负荷。我信任该网络会保证我总是连接到想要连接的服务器。
      </entry>
     </row>

     <row>
      <entry><literal>verify-ca</></entry>
      <entry>Yes</entry>
      <entry><literal>取决于 CA</>-策略</entry>
      <entry>我想要对数据加密，并且我接受因此带来的负荷。我想要确保我连接到的是我信任的服务器。
      </entry>
     </row>

     <row>
      <entry><literal>verify-full</></entry>
       <entry>Yes</entry>
       <entry>Yes</entry>
       <entry>我想要对数据加密，并且我接受因此带来的负荷。我想要确保我连接到的是我信任的服务器，并且就是我指定的那一个。
       </entry>
      </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   <literal>verify-ca</>和<literal>verify-full</>之间的区别取决于根<acronym>CA</>的策略。如果使用了一个公共<acronym>CA</>，<literal>verify-ca</>允许连接到那些可能已经被<emphasis>其他人</>注册到该<acronym>CA</>的服务器。在这种情况下，总是应该使用<literal>verify-full</>。如果使用了一个本地<acronym>CA</>或者甚至是一个自签名的证书，使用<literal>verify-ca</>常常就可以提供足够的保护。
  </para>

  <para>
   <literal>sslmode</>的默认值是<literal>prefer</>。如表中所示，这在安全性的角度来说没有意义，并且它只承诺可能的性能负荷。提供它作为默认值只是为了向后兼容，并且我们不推荐在安全部署中使用它。
  </para>

 </sect2>

 <sect2 id="libpq-ssl-fileusage">
  <title>SSL 客户端文件使用</title>

  <para>
   <xref linkend="libpq-ssl-file-usage">总结了与客户端 SSL 设置相关的文件。
  </para>

  <table id="libpq-ssl-file-usage">
   <title>Libpq/客户端 SSL 文件用法</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>文件</entry>
      <entry>内容</entry>
      <entry>效果</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry><filename>~/.postgresql/postgresql.crt</></entry>
      <entry>客户端证书</entry>
      <entry>由服务器要求</entry>
     </row>

     <row>
      <entry><filename>~/.postgresql/postgresql.key</></entry>
      <entry>客户端私钥</entry>
      <entry>证明客户端证书是由拥有者发送；不代表证书拥有者可信</entry>
     </row>

     <row>
      <entry><filename>~/.postgresql/root.crt</></entry>
      <entry>可信的证书机构</entry>
      <entry>检查服务器证书是由一个可信的证书机构签发</entry>
     </row>

     <row>
      <entry><filename>~/.postgresql/root.crl</></entry>
      <entry>被证书机构撤销的证书</entry>
      <entry>服务器证书不能在这个列表上</entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect2>

 <sect2 id="libpq-ssl-initialize">
  <title>SSL 库初始化</title>

  <para>
   如果你的应用初始化<literal>libssl</>或<literal>libcrypto</>库以及带有<acronym>SSL</>支持的<application>libpq</application>，你应该调用<function>PQinitOpenSSL</>来告诉<application>libpq</application>：<literal>libssl</>或<literal>libcrypto</>库已经被你的应用初始化，这样<application>libpq</application>将不会也去初始化那些库。
   <!-- If this URL changes replace it with a URL to www.archive.org. -->
   关于 SSL API 详见<ulink
   url="http://h71000.www7.hp.com/doc/83final/BA554_90007/ch04.html"></ulink>。
  </para>

  <para>
   <variablelist>
    <varlistentry id="libpq-pqinitopenssl">
     <term>
      <function>PQinitOpenSSL</function>
      <indexterm>
       <primary>PQinitOpenSSL</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       允许应用选择要初始化哪个安全性库。
<synopsis>
void PQinitOpenSSL(int do_ssl, int do_crypto);
</synopsis>
      </para>

      <para>
       当<parameter>do_ssl</>是非零时，<application>libpq</application>将在第一次打开数据库连接前初始化<application>OpenSSL</>库。当<parameter>do_crypto</>是非零时，<literal>libcrypto</>库将被初始化。默认情况下（如果没有调用<function>PQinitOpenSSL</>），两个库都会被初始化。当 SSL 支持没有被编译时，这个函数也存在但是什么也不做。
      </para>

      <para>
       如果你的应用使用并且初始化<application>OpenSSL</>或者它的底层<literal>libcrypto</>库，你<emphasis>必须</>在第一次打开数据库连接前以合适的非零参数调用这个函数。同时要确保在打开一个数据库连接前已经完成了初始化。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqinitssl">
     <term>
      <function>PQinitSSL</function>
      <indexterm>
       <primary>PQinitSSL</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       允许应用选择要初始化哪个安全性库。
<synopsis>
void PQinitSSL(int do_ssl);
</synopsis>
      </para>

      <para>
       这个函数等效于<literal>PQinitOpenSSL(do_ssl, do_ssl)</>。这对于要么初始化<application>OpenSSL</>以及<literal>libcrypto</>要么都不初始化的应用足够用了。
      </para>

      <para>
       <function>PQinitSSL</>从<productname>PostgreSQL</> 8.0 就存在了，而<function>PQinitOpenSSL</>直到<productname>PostgreSQL</> 8.4 才被加入，因此<function>PQinitSSL</>可能对那些需要与旧版本<application>libpq</application>一起工作的应用来说更合适。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </sect2>

 </sect1>


 <sect1 id="libpq-threading">
  <title>在线程化程序中的行为</title>

  <indexterm zone="libpq-threading">
   <primary>threads</primary>
   <secondary>with libpq</secondary>
  </indexterm>

  <para>
   <application>libpq</application>默认是可再入的并且是线程安全的。你可能需要使用特殊的编译器命令行选项来编译你的应用代码。参考你的系统文档来了解如何编译启用线程的应用，或者在<filename>src/Makefile.global</filename>中查找<literal>PTHREAD_CFLAGS</>和<literal>PTHREAD_LIBS</>。这个函数允许查询<application>libpq</application>的线程安全状态：
  </para>

  <variablelist>
   <varlistentry id="libpq-pqisthreadsafe">
    <term>
     <function>PQisthreadsafe</function>
     <indexterm>
      <primary>PQisthreadsafe</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      返回<application>libpq</application>库的线程安全状态。
<synopsis>
int PQisthreadsafe();
</synopsis>
     </para>

     <para>
      如果<application>libpq</application>是线程安全的则返回 1，否则返回 0。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   一个线程限制是不允许两个线程同时尝试操纵同一个<structname>PGconn</>对象。特别是你不能从不同的线程通过同一个连接对象发出并发的命令（如果你需要运行并发命令，请使用多个连接）。
  </para>

  <para>
   <structname>PGresult</>对象在创建后通常是只读的，并且因此可以在线程之间自由地被传递。但是，如果你使用任何<xref linkend="libpq-misc">或<xref linkend="libpq-events">中描述的<structname>PGresult</>修改函数，你需要负责避免在同一个<structname>PGresult</>上的并发操作。
  </para>

  <para>
   被废弃的函数<function>PQrequestCancel</function>以及<function>PQoidStatus</function>不时线程安全的并且不应当在多线程程序中使用。<function>PQrequestCancel</function>可以被替换为<function>PQcancel</function>。<function>PQoidStatus</function>可以被替换为<function>PQoidValue</function>。
  </para>

  <para>
   如果你在应用中使用 Kerberos (除了在<application>libpq</application>中之外），你将需要对 Kerberos 调用加锁，因为 Kerberos 函数不是线程安全的。参考<application>libpq</application>源代码中的<function>PQregisterThreadLock</>函数，那里有在<application>libpq</application>和应用之间做合作锁定的方法。
  </para>

  <para>
   如果你在线程化应用中碰到问题，将该程序运行在<filename>src/tools/thread</>来查看是否你的平台有线程不安全的函数。这个程序会被<filename>configure</filename>运行，但是对于二进制发布，你的库可能不匹配用来编译二进制的库。
  </para>
 </sect1>


 <sect1 id="libpq-build">
  <title>编译 <application>libpq</application> 程序</title>

  <indexterm zone="libpq-build">
   <primary>编译</primary>
   <secondary>libpq 应用</secondary>
  </indexterm>

  <para>
   要编译（即编译并且链接）一个使用<application>libpq</application>的程序，你需要做下列所有的事情：

   <itemizedlist>
    <listitem>
     <para>
      包括<filename>libpq-fe.h</filename>头文件：
<programlisting>
#include &lt;libpq-fe.h&gt;
</programlisting>
      如果你无法这样做，那么你通常会从你的编译器得到像这样的错误消息：
<screen>
foo.c: In function `main':
foo.c:34: `PGconn' undeclared (first use in this function)
foo.c:35: `PGresult' undeclared (first use in this function)
foo.c:54: `CONNECTION_BAD' undeclared (first use in this function)
foo.c:68: `PGRES_COMMAND_OK' undeclared (first use in this function)
foo.c:95: `PGRES_TUPLES_OK' undeclared (first use in this function)
</screen>
     </para>
    </listitem>

    <listitem>
     <para>
      通过为你的编译器提供<literal>-I<replaceable>directory</replaceable></literal>选项，向你的编译器指出<productname>PostgreSQL</>头文件安装在哪里（在某些情况下编译器默认将查看该目录，因此你可以忽略这个选项）。例如你的编译命令行可能看起来像：
<programlisting>
cc -c -I/usr/local/pgsql/include testprog.c
</programlisting>
      如果你在使用 makefile，那么把该选项加到<varname>CPPFLAGS</varname>变量中：
<programlisting>
CPPFLAGS += -I/usr/local/pgsql/include
</programlisting>
     </para>

     <para>
      如果你的程序可能由其他用户编译，那么你不应该像那样硬编码目录位置。你可以运行工具<command>pg_config</command><indexterm><primary>pg_config</><secondary
      sortas="libpq">with libpq</></>在本地系统上找出头文件在哪里：
<screen>
<prompt>$</prompt> pg_config --includedir
<computeroutput>/usr/local/include</computeroutput>
</screen>
     </para>

     <para>
      如果你安装了<command>pkg-config</command><indexterm><primary>pkg-config</primary><secondary sortas="libpq">with
      libpq</secondary></indexterm>，你可以运行：
<screen>
<prompt>$</prompt> pkg-config --cflags libpq
<computeroutput>-I/usr/local/include</computeroutput>
</screen>
      注意这将在路径前面包括<option>-I</option>。
     </para>

     <para>
      无法为编译器指定正确的选项将导致一个错误消息，例如：
<screen>
testlibpq.c:8:22: libpq-fe.h: No such file or directory
</screen>
     </para>
    </listitem>

    <listitem>
     <para>
      当链接最终的程序时，指定选项<literal>-lpq</literal>，这样<application>libpq</application>库会被编译进去，也可以用选项<literal>-L<replaceable>directory</replaceable></literal>向编译器指出<application>libpq</application>库所在的位置（再次，编译器将默认搜索某些目录）。为了最大的可移植性，将<option>-L</option>选项放在<option>-lpq</option>选项前面。例如：
<programlisting>
cc -o testprog testprog1.o testprog2.o -L/usr/local/pgsql/lib -lpq
</programlisting>
     </para>

     <para>
      你也可以使用<command>pg_config</command>找出库目录：
<screen>
<prompt>$</prompt> pg_config --libdir
<computeroutput>/usr/local/pgsql/lib</computeroutput>
</screen>
     </para>

     <para>
      或者再次使用<command>pkg-config</command>：
<screen>
<prompt>$</prompt> pkg-config --libs libpq
<computeroutput>-L/usr/local/pgsql/lib -lpq</computeroutput>
</screen>
      再次提示这会打印出全部的选项，而不仅仅是路径。
     </para>

     <para>
      指出这一部分问题的错误消息可能看起来像：
<screen>
testlibpq.o: In function `main':
testlibpq.o(.text+0x60): undefined reference to `PQsetdbLogin'
testlibpq.o(.text+0x71): undefined reference to `PQstatus'
testlibpq.o(.text+0xa4): undefined reference to `PQerrorMessage'
</screen>
      This means you forgot <option>-lpq</option>.
<screen>
/usr/bin/ld: cannot find -lpq
</screen>
      这意味着你忘记了<option>-L</option>选项或者没有指定正确的目录。
     </para>
    </listitem>
   </itemizedlist>
  </para>

 </sect1>


 <sect1 id="libpq-example">
  <title>例子程序</title>

  <para>
   这些例子和其他例子可以在源代码发布的<filename>src/test/examples</filename>目录中找到。
  </para>

  <example id="libpq-example-1">
   <title><application>libpq</application> 例子程序 1</title>

<programlisting>
<![CDATA[
/*
 * testlibpq.c
 *
 *      测试 libpq（PostgreSQL 前端库） 的 C 版本。
 */
#include <stdio.h>
#include <stdlib.h>
#include <libpq-fe.h>

static void
exit_nicely(PGconn *conn)
{
    PQfinish(conn);
    exit(1);
}

int
main(int argc, char **argv)
{
    const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    int         nFields;
    int         i,
                j;

    /*
     * 如果用户在命令行上提供了一个参数，将它用作连接信息串。
     * 否则默认用设置 dbname=postgres 并且为所有其他链接参数使用环境变量或默认值。
     */
    if (argc > 1)
        conninfo = argv[1];
    else
        conninfo = "dbname = postgres";

    /* 建立到数据库的一个连接 */
    conn = PQconnectdb(conninfo);

    /* 检查看后端连接是否成功建立 */
    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        exit_nicely(conn);
    }

    /*
     * 我们的测试案例这里涉及使用一个游标，对它我们必须用在一个事务块内。
     * 我们可以在一个单一的 "select * from pg_database" 的 PQexec() 中做整个事情，
     * 但是作为一个好的例子它太琐碎。
     */

    /* 开始一个事务块 */
    res = PQexec(conn, "BEGIN");
    if (PQresultStatus(res) != PGRES_COMMAND_OK)
    {
        fprintf(stderr, "BEGIN command failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    /*
     * 任何时候不再需要 PGresult 时，应该 PQclear 它来避免内存泄露
     */
    PQclear(res);

    /*
     * 从 pg_database 取得行，它是数据库的系统目录
     */
    res = PQexec(conn, "DECLARE myportal CURSOR FOR select * from pg_database");
    if (PQresultStatus(res) != PGRES_COMMAND_OK)
    {
        fprintf(stderr, "DECLARE CURSOR failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }
    PQclear(res);

    res = PQexec(conn, "FETCH ALL in myportal");
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        fprintf(stderr, "FETCH ALL failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    /* 首先，打印出属性名 */
    nFields = PQnfields(res);
    for (i = 0; i < nFields; i++)
        printf("%-15s", PQfname(res, i));
    printf("\n\n");

    /* 接下来，打印出行 */
    for (i = 0; i < PQntuples(res); i++)
    {
        for (j = 0; j < nFields; j++)
            printf("%-15s", PQgetvalue(res, i, j));
        printf("\n");
    }

    PQclear(res);

    /* 关闭入口，我们不需要考虑检查错误 */
    res = PQexec(conn, "CLOSE myportal");
    PQclear(res);

    /* 结束事务 */
    res = PQexec(conn, "END");
    PQclear(res);

    /* 关闭到数据库的连接并且清理 */
    PQfinish(conn);

    return 0;
}
]]>
</programlisting>
  </example>

  <example id="libpq-example-2">
   <title><application>libpq</application>例子程序 2</title>

<programlisting>
<![CDATA[
/*
 * testlibpq2.c
 *      测试异步通知接口
 *
 * 开始这个程序，然后在另一个窗口的 psql 中做
 *   NOTIFY TBL2;
 * 重复四次来让这个程序退出。
 *
 * 或者，如果你想要得到奇妙的事情，尝试：
 * 用下列命令填充一个数据库
 * （在 src/test/examples/testlibpq2.sql 中提供）
 *
 *   CREATE TABLE TBL1 (i int4);
 *
 *   CREATE TABLE TBL2 (i int4);
 *
 *   CREATE RULE r1 AS ON INSERT TO TBL1 DO
 *     (INSERT INTO TBL2 VALUES (new.i); NOTIFY TBL2);
 *
 * 并且把这个做四次：
 *
 *   INSERT INTO TBL1 VALUES (10);
 */
#ifdef WIN32
#include <windows.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/time.h>
#include <sys/types.h>
#include "libpq-fe.h"

static void
exit_nicely(PGconn *conn)
{
    PQfinish(conn);
    exit(1);
}

int
main(int argc, char **argv)
{
    const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    PGnotify   *notify;
    int         nnotifies;

    /*
     * 用过用户在命令行上提供了一个参数，将它用作连接信息串。
     * 否则默认用设置 dbname=postgres 并且为所有其他链接参数使用环境变量或默认值。
     */
    if (argc > 1)
        conninfo = argv[1];
    else
        conninfo = "dbname = postgres";

    /* 建立一个到数据库的连接 */
    conn = PQconnectdb(conninfo);

    /* 检查后端连接是否成功建立 */
    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        exit_nicely(conn);
    }

    /*
     * 发出 LISTEN 命令启用来自规则的 NOTIFY 的通知。
     */
    res = PQexec(conn, "LISTEN TBL2");
    if (PQresultStatus(res) != PGRES_COMMAND_OK)
    {
        fprintf(stderr, "LISTEN command failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    /*
     * 任何时候不再需要 PGresult 时，应该 PQclear 它来避免内存泄露
     */
    PQclear(res);

    /* 在接收到四个通知后退出。 */
    nnotifies = 0;
    while (nnotifies < 4)
    {
        /*
         * 休眠到在连接上发生某些事情。我们使用 select(2) 来等待输入，但是你也可以使用 poll() 或相似的设施。
         */
        int         sock;
        fd_set      input_mask;

        sock = PQsocket(conn);

        if (sock < 0)
            break;              /* 不应该发生 */

        FD_ZERO(&input_mask);
        FD_SET(sock, &input_mask);

        if (select(sock + 1, &input_mask, NULL, NULL, NULL) < 0)
        {
            fprintf(stderr, "select() failed: %s\n", strerror(errno));
            exit_nicely(conn);
        }

        /* 现在检查输入 */
        PQconsumeInput(conn);
        while ((notify = PQnotifies(conn)) != NULL)
        {
            fprintf(stderr,
                    "ASYNC NOTIFY of '%s' received from backend PID %d\n",
                    notify->relname, notify->be_pid);
            PQfreemem(notify);
            nnotifies++;
        }
    }

    fprintf(stderr, "Done.\n");

    /* 关闭到数据库的连接并且清理 */
    PQfinish(conn);

    return 0;
}
]]>
</programlisting>
  </example>

  <example id="libpq-example-3">
   <title><application>libpq</application>例子程序 3</title>

<programlisting>
<![CDATA[
/*
 * testlibpq3.c
 *      测试线外参数和二进制 I/O。
 *
 * 在运行之前，使用下列命令填充一个数据库（在 src/test/examples/testlibpq3.sql 中提供）
 *
 * CREATE TABLE test1 (i int4, t text, b bytea);
 *
 * INSERT INTO test1 values (1, 'joe''s place', '\\000\\001\\002\\003\\004');
 * INSERT INTO test1 values (2, 'ho there', '\\004\\003\\002\\001\\000');
 *
 * 期待的输出是：
 *
 * tuple 0: got
 *  i = (4 bytes) 1
 *  t = (11 bytes) 'joe's place'
 *  b = (5 bytes) \000\001\002\003\004
 *
 * tuple 0: got
 *  i = (4 bytes) 2
 *  t = (8 bytes) 'ho there'
 *  b = (5 bytes) \004\003\002\001\000
 */
#ifdef WIN32
#include <windows.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <sys/types.h>
#include "libpq-fe.h"

/* for ntohl/htonl */
#include <netinet/in.h>
#include <arpa/inet.h>


static void
exit_nicely(PGconn *conn)
{
    PQfinish(conn);
    exit(1);
}

/*
 * 这个函数打印一个查询结果，该结果以二进制格式从上面的注释中定义的表中取得。
 * 我们把它分离出来是因为 main() 函数需要使用它两次。
 */
static void
show_binary_results(PGresult *res)
{
    int         i,
                j;
    int         i_fnum,
                t_fnum,
                b_fnum;

    /* 使用 PQfnumber 来避免假定结果中域的顺序 */
    i_fnum = PQfnumber(res, "i");
    t_fnum = PQfnumber(res, "t");
    b_fnum = PQfnumber(res, "b");

    for (i = 0; i < PQntuples(res); i++)
    {
        char       *iptr;
        char       *tptr;
        char       *bptr;
        int         blen;
        int         ival;

        /* 得到域值（我们忽略它们为空值的可能性！） */
        iptr = PQgetvalue(res, i, i_fnum);
        tptr = PQgetvalue(res, i, t_fnum);
        bptr = PQgetvalue(res, i, b_fnum);

        /*
         * INT4 的二进制表示是按照网络字节序的，我们最好强制为本地字节序。
         */
        ival = ntohl(*((uint32_t *) iptr));

        /*
         * TEXT 的二进制表示是文本，并且因为 libpq 会为它追加一个零字节，它将工作得和 C 字符串一样好。
         *
         * BYTEA 的二进制表示是一堆字节，其中可能包含嵌入的空值，因此我们必须注意域长度。
         */
        blen = PQgetlength(res, i, b_fnum);

        printf("tuple %d: got\n", i);
        printf(" i = (%d bytes) %d\n",
               PQgetlength(res, i, i_fnum), ival);
        printf(" t = (%d bytes) '%s'\n",
               PQgetlength(res, i, t_fnum), tptr);
        printf(" b = (%d bytes) ", blen);
        for (j = 0; j < blen; j++)
            printf("\\%03o", bptr[j]);
        printf("\n\n");
    }
}

int
main(int argc, char **argv)
{
    const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    const char *paramValues[1];
    int         paramLengths[1];
    int         paramFormats[1];
    uint32_t    binaryIntVal;

    /*
     * 如果用户在命令行上提供了一个参数，将它用作连接信息串。
     * 否则默认用设置 dbname=postgres 并且为所有其他链接参数使用环境变量或默认值。
     */
    if (argc > 1)
        conninfo = argv[1];
    else
        conninfo = "dbname = postgres";

    /* 建立一个到数据库的连接 */
    conn = PQconnectdb(conninfo);

    /* 检查看后端连接是否成功被建立 */
    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        exit_nicely(conn);
    }

    /*
     * 这个程序的要点在于用线外参数展示 PQexecParams() 的使用，以及数据的二进制传输。
     *
     * 第一个例子将参数作为文本传输，但是以二进制格式接收结果。
     * 通过使用线外参数，我们能够避免使用繁杂的引用和转义，即便数据是文本。
     * 注意我们怎么才能对参数值中的引号不做任何事情。
     */

    /* 这里是我们的线外参数值 */
    paramValues[0] = "joe's place";

    res = PQexecParams(conn,
                       "SELECT * FROM test1 WHERE t = $1",
                       1,       /* 一个参数 */
                       NULL,    /* 让后端推导参数类型 */
                       paramValues,
                       NULL,    /* 因为文本不需要参数长度 */
                       NULL,    /* 对所有文本参数的默认值 */
                       1);      /* 要求二进制结果 */

    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        fprintf(stderr, "SELECT failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    show_binary_results(res);

    PQclear(res);

    /*
     * 在第二个例子中，我们以二进制形式传输一个整数参数，并且再次以二进制形式接收结果。
     *
     * 尽管我们告诉 PQexecParams 我们让后端推导参数类型，我们实际上通过在查询文本中造型参数符号来强制该决定。
     * 在发送二进制参数时，这是一种好的安全测度。
     */

    /* 将整数值 "2" 转换为网络字节序 */
    binaryIntVal = htonl((uint32_t) 2);

    /* 为 PQexecParams 设置参数数组 */
    paramValues[0] = (char *) &binaryIntVal;
    paramLengths[0] = sizeof(binaryIntVal);
    paramFormats[0] = 1;        /* binary */

    res = PQexecParams(conn,
                       "SELECT * FROM test1 WHERE i = $1::int4",
                       1,       /* 一个参数 */
                       NULL,    /* 让后端推导参数类型 */
                       paramValues,
                       paramLengths,
                       paramFormats,
                       1);      /* 要求二进制结果 */

    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        fprintf(stderr, "SELECT failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    show_binary_results(res);

    PQclear(res);

    /* 关闭到数据库的连接并清理 */
    PQfinish(conn);

    return 0;
}
]]>
</programlisting>
  </example>

 </sect1>
</chapter>
