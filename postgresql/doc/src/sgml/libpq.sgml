<!-- doc/src/sgml/libpq.sgml -->

<chapter id="libpq">
<!--==========================orignal english content==========================
 <title><application>libpq</application> - C Library</title>
____________________________________________________________________________-->
 <title><application>libpq</application> - C 库</title>

<!--==========================orignal english content==========================
 <indexterm zone="libpq">
  <primary>libpq</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="libpq">
  <primary>libpq</primary>
 </indexterm>

<!--==========================orignal english content==========================
 <indexterm zone="libpq">
  <primary>C</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="libpq">
  <primary>C</primary>
 </indexterm>

<!--==========================orignal english content==========================
 <para>
  <application>libpq</application> is the <acronym>C</acronym>
  application programmer's interface to <productname>PostgreSQL</>.
  <application>libpq</> is a set of library functions that allow
  client programs to pass queries to the <productname>PostgreSQL</>
  backend server and to receive the results of these queries.
 </para>
____________________________________________________________________________-->
 <para>
  <application>libpq</application>是应用程序员使用<productname>PostgreSQL</>的<acronym>C</acronym>接口。<application>libpq</>是一个库函数的集合，它们允许客户端程序传递查询给<productname>PostgreSQL</>后端服务器并且接收这些查询的结果。
 </para>

<!--==========================orignal english content==========================
 <para>
  <application>libpq</> is also the underlying engine for several
  other <productname>PostgreSQL</> application interfaces, including
  those written for C++, Perl, Python, Tcl and <application>ECPG</>.
  So some aspects of <application>libpq</>'s behavior will be
  important to you if you use one of those packages.  In particular,
  <xref linkend="libpq-envars">,
  <xref linkend="libpq-pgpass"> and
  <xref linkend="libpq-ssl">
  describe behavior that is visible to the user of any application
  that uses <application>libpq</>.
 </para>
____________________________________________________________________________-->
 <para>
  <application>libpq</>也是很多其他<productname>PostgreSQL</>应用接口的底层引擎，包括为 C++、Perl、Python、Tcl 和 <application>ECPG</>编写的接口。如果你使用那些包，某些方面的<application>libpq</>行为将会对你很重要。特别是，<xref linkend="libpq-envars">、<xref linkend="libpq-pgpass">和<xref linkend="libpq-ssl">描述了任何使用<application>libpq</>的应用的用户可见的行为。
 </para>

<!--==========================orignal english content==========================
 <para>
  Some short programs are included at the end of this chapter (<xref linkend="libpq-example">) to show how
  to write programs that use <application>libpq</application>.  There are also several
  complete examples of <application>libpq</application> applications in the
  directory <filename>src/test/examples</filename> in the source code distribution.
 </para>
____________________________________________________________________________-->
 <para>
  在本章的末尾（<xref linkend="libpq-example">）包括了一些短程序来展示如何编写使用<application>libpq</application>的应用。在源代码发布的<filename>src/test/examples</filename>目录中还有一些完整的<application>libpq</application>应用的例子。
 </para>

<!--==========================orignal english content==========================
 <para>
  Client programs that use <application>libpq</application> must
  include the header file
  <filename>libpq-fe.h</filename><indexterm><primary>libpq-fe.h</></>
  and must link with the <application>libpq</application> library.
 </para>
____________________________________________________________________________-->
 <para>
  使用<application>libpq</application>的客户端程序必须包括头文件<filename>libpq-fe.h</filename><indexterm><primary>libpq-fe.h</></>并必须与<application>libpq</application>库链接在一起。
 </para>

 <sect1 id="libpq-connect">
<!--==========================orignal english content==========================
  <title>Database Connection Control Functions</title>
____________________________________________________________________________-->
  <title>数据库连接控制函数</title>

<!--==========================orignal english content==========================
  <para>
   The following functions deal with making a connection to a
   <productname>PostgreSQL</productname> backend server.  An
   application program can have several backend connections open at
   one time.  (One reason to do that is to access more than one
   database.)  Each connection is represented by a
   <structname>PGconn</><indexterm><primary>PGconn</></> object, which
   is obtained from the function <function>PQconnectdb</>,
   <function>PQconnectdbParams</>, or
   <function>PQsetdbLogin</>.  Note that these functions will always
   return a non-null object pointer, unless perhaps there is too
   little memory even to allocate the <structname>PGconn</> object.
   The <function>PQstatus</> function should be called to check
   the return value for a successful connection before queries are sent
   via the connection object.

   <warning>
    <para>
     On Unix, forking a process with open libpq connections can lead to
     unpredictable results because the parent and child processes share
     the same sockets and operating system resources.  For this reason,
     such usage is not recommended, though doing an <function>exec</> from
     the child process to load a new executable is safe.
    </para>
   </warning>

   <note>
    <para>
     On Windows, there is a way to improve performance if a single
     database connection is repeatedly started and shutdown.  Internally,
     libpq calls <function>WSAStartup()</> and <function>WSACleanup()</> for connection startup
     and shutdown, respectively.  <function>WSAStartup()</> increments an internal
     Windows library reference count which is decremented by <function>WSACleanup()</>.
     When the reference count is just one, calling <function>WSACleanup()</> frees
     all resources and all DLLs are unloaded.  This is an expensive
     operation.  To avoid this, an application can manually call
     <function>WSAStartup()</> so resources will not be freed when the last database
     connection is closed.
    </para>
   </note>

   <variablelist>
    <varlistentry id="libpq-pqconnectdbparams">
     <term><function>PQconnectdbParams</function><indexterm><primary>PQconnectdbParams</></></term>
     <listitem>
      <para>
       Makes a new connection to the database server.

<synopsis>
PGconn *PQconnectdbParams(const char * const *keywords,
                          const char * const *values,
                          int expand_dbname);
</synopsis>
      </para>

      <para>
       This function opens a new database connection using the parameters taken
       from two <symbol>NULL</symbol>-terminated arrays. The first,
       <literal>keywords</literal>, is defined as an array of strings, each one
       being a key word. The second, <literal>values</literal>, gives the value
       for each key word. Unlike <function>PQsetdbLogin</> below, the parameter
       set can be extended without changing the function signature, so use of
       this function (or its nonblocking analogs <function>PQconnectStartParams</>
       and <function>PQconnectPoll</function>) is preferred for new application
       programming.
      </para>

      <para>
       The currently recognized parameter key words are listed in
       <xref linkend="libpq-paramkeywords">.
      </para>

      <para>
       When <literal>expand_dbname</literal> is non-zero, the
       <parameter>dbname</parameter> key word value is allowed to be recognized
       as a connection string. Only the first occurrence of
       <parameter>dbname</parameter> is expanded this way, any subsequent
       <parameter>dbname</parameter> value is processed as plain database name. More
       details on the possible connection string formats appear in
       <xref linkend="libpq-connstring">.
      </para>

      <para>
       The passed arrays can be empty to use all default parameters, or can
       contain one or more parameter settings. They should be matched in length.
       Processing will stop at the first <symbol>NULL</symbol> element
       in the <literal>keywords</literal> array.
      </para>

      <para>
       If  any  parameter is <symbol>NULL</symbol> or an empty string, the corresponding
       environment variable (see <xref linkend="libpq-envars">) is checked.
       If the  environment  variable is not set either, then the indicated
       built-in defaults are used.
      </para>

      <para>
       In general key words are processed from the beginning of these arrays in index
       order. The effect of this is that when key words are repeated, the last processed
       value is retained. Therefore, through careful placement of the
       <parameter>dbname</parameter> key word, it is possible to determine what may
       be overridden by a <parameter>conninfo</parameter> string, and what may not.
      </para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconnectdb">
     <term><function>PQconnectdb</function><indexterm><primary>PQconnectdb</></></term>
     <listitem>
      <para>
       Makes a new connection to the database server.

<synopsis>
PGconn *PQconnectdb(const char *conninfo);
</synopsis>
      </para>

      <para>
       This function opens a new database connection using the parameters taken
       from the string <literal>conninfo</literal>.
      </para>

      <para>
       The passed string can be empty to use all default parameters, or it can
       contain one or more parameter settings separated by whitespace,
       or it can contain a <acronym>URI</acronym>.
       See <xref linkend="libpq-connstring"> for details.
     </para>


    </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsetdblogin">
     <term><function>PQsetdbLogin</function><indexterm><primary>PQsetdbLogin</></></term>
     <listitem>
      <para>
       Makes a new connection to the database server.
<synopsis>
PGconn *PQsetdbLogin(const char *pghost,
                     const char *pgport,
                     const char *pgoptions,
                     const char *pgtty,
                     const char *dbName,
                     const char *login,
                     const char *pwd);
</synopsis>
       </para>

       <para>
        This is the predecessor of <function>PQconnectdb</function> with a fixed
        set of parameters.  It has the same functionality except that the
        missing parameters will always take on default values.  Write <symbol>NULL</symbol> or an
        empty string for any one of the fixed parameters that is to be defaulted.
      </para>

      <para>
        If the <parameter>dbName</parameter> contains
        an <symbol>=</symbol> sign or has a valid connection <acronym>URI</acronym> prefix, it
        is taken as a <parameter>conninfo</parameter> string in exactly the same way as
        if it had been passed to <function>PQconnectdb</function>, and the remaining
        parameters are then applied as specified for <function>PQconnectdbParams</>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsetdb">
     <term><function>PQsetdb</function><indexterm><primary>PQsetdb</></></term>
     <listitem>
      <para>
   Makes a new connection to the database server.
<synopsis>
PGconn *PQsetdb(char *pghost,
                char *pgport,
                char *pgoptions,
                char *pgtty,
                char *dbName);
</synopsis>
     </para>

     <para>
      This is a macro that calls <function>PQsetdbLogin</function> with null pointers
      for the <parameter>login</> and <parameter>pwd</> parameters.  It is provided
      for backward compatibility with very old programs.
     </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconnectstartparams">
     <term><function>PQconnectStartParams</function><indexterm><primary>PQconnectStartParams</></></term>
     <term><function>PQconnectStart</function><indexterm><primary>PQconnectStart</></></term>
     <term><function>PQconnectPoll</function><indexterm><primary>PQconnectPoll</></></term>
     <listitem>
      <para>
       <indexterm><primary>nonblocking connection</primary></indexterm>
       Make a connection to the database server in a nonblocking manner.

<synopsis>
PGconn *PQconnectStartParams(const char * const *keywords,
                             const char * const *values,
                             int expand_dbname);

PGconn *PQconnectStart(const char *conninfo);

PostgresPollingStatusType PQconnectPoll(PGconn *conn);
</synopsis>
      </para>

      <para>
       These three functions are used to open a connection to a database server such
       that your application's thread of execution is not blocked on remote I/O
       whilst doing so. The point of this approach is that the waits for I/O to
       complete can occur in the application's main loop, rather than down inside
       <function>PQconnectdbParams</> or <function>PQconnectdb</>, and so the
       application can manage this operation in parallel with other activities.
      </para>

      <para>
       With <function>PQconnectStartParams</function>, the database connection is made
       using the parameters taken from the <literal>keywords</literal> and
       <literal>values</literal> arrays, and controlled by <literal>expand_dbname</literal>,
       as described above for <function>PQconnectdbParams</function>.
      </para>

      <para>
       With <function>PQconnectStart</function>, the database connection is made
       using the parameters taken from the string <literal>conninfo</literal> as
       described above for <function>PQconnectdb</function>.
      </para>

      <para>
       Neither <function>PQconnectStartParams</function> nor <function>PQconnectStart</function>
       nor <function>PQconnectPoll</function> will block, so long as a number of
       restrictions are met:
       <itemizedlist>
        <listitem>
         <para>
          The <literal>hostaddr</> and <literal>host</> parameters are used appropriately to ensure that
          name and reverse name queries are not made. See the documentation of
          these parameters in <xref linkend="libpq-paramkeywords"> for details.
         </para>
        </listitem>

        <listitem>
         <para>
          If you call <function>PQtrace</function>, ensure that the stream object
          into which you trace will not block.
         </para>
        </listitem>

        <listitem>
         <para>
          You ensure that the socket is in the appropriate state
          before calling <function>PQconnectPoll</function>, as described below.
         </para>
        </listitem>
       </itemizedlist>
      </para>

      <para>
       Note: use of <function>PQconnectStartParams</> is analogous to
       <function>PQconnectStart</> shown below.
      </para>

      <para>
       To begin a nonblocking connection request, call <literal>conn = PQconnectStart("<replaceable>connection_info_string</>")</literal>.
       If <varname>conn</varname> is null, then <application>libpq</> has been unable to allocate a new <structname>PGconn</>
       structure. Otherwise, a valid <structname>PGconn</> pointer is returned (though not yet
       representing a valid connection to the database). On return from
       <function>PQconnectStart</function>, call <literal>status = PQstatus(conn)</literal>. If <varname>status</varname> equals
       <symbol>CONNECTION_BAD</symbol>, <function>PQconnectStart</function> has failed.
      </para>

      <para>
       If <function>PQconnectStart</> succeeds, the next stage is to poll
       <application>libpq</> so that it can proceed with the connection sequence.
       Use <function>PQsocket(conn)</function> to obtain the descriptor of the
       socket underlying the database connection.
       Loop thus: If <function>PQconnectPoll(conn)</function> last returned
       <symbol>PGRES_POLLING_READING</symbol>, wait until the socket is ready to
       read (as indicated by <function>select()</>, <function>poll()</>, or
       similar system function).
       Then call <function>PQconnectPoll(conn)</function> again.
       Conversely, if <function>PQconnectPoll(conn)</function> last returned
       <symbol>PGRES_POLLING_WRITING</symbol>, wait until the socket is ready
       to write, then call <function>PQconnectPoll(conn)</function> again.
       If you have yet to call
       <function>PQconnectPoll</function>, i.e., just after the call to
       <function>PQconnectStart</function>, behave as if it last returned
       <symbol>PGRES_POLLING_WRITING</symbol>.  Continue this loop until
       <function>PQconnectPoll(conn)</function> returns
       <symbol>PGRES_POLLING_FAILED</symbol>, indicating the connection procedure
       has failed, or <symbol>PGRES_POLLING_OK</symbol>, indicating the connection
       has been successfully made.
      </para>

      <para>
       At any time during connection, the status of the connection can be
       checked by calling <function>PQstatus</>. If this call returns <symbol>CONNECTION_BAD</>, then the
       connection procedure has failed; if the call returns <function>CONNECTION_OK</>, then the
       connection is ready.  Both of these states are equally detectable
       from the return value of <function>PQconnectPoll</>, described above. Other states might also occur
       during (and only during) an asynchronous connection procedure. These
       indicate the current stage of the connection procedure and might be useful
       to provide feedback to the user for example. These statuses are:

       <variablelist>
        <varlistentry id="libpq-connection-started">
         <term><symbol>CONNECTION_STARTED</symbol></term>
         <listitem>
          <para>
           Waiting for connection to be made.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-made">
         <term><symbol>CONNECTION_MADE</symbol></term>
         <listitem>
          <para>
           Connection OK; waiting to send.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-awaiting-response">
         <term><symbol>CONNECTION_AWAITING_RESPONSE</symbol></term>
         <listitem>
          <para>
           Waiting for a response from the server.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-auth-ok">
         <term><symbol>CONNECTION_AUTH_OK</symbol></term>
         <listitem>
          <para>
           Received authentication; waiting for backend start-up to finish.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-ssl-startup">
         <term><symbol>CONNECTION_SSL_STARTUP</symbol></term>
         <listitem>
          <para>
           Negotiating SSL encryption.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-setenv">
         <term><symbol>CONNECTION_SETENV</symbol></term>
         <listitem>
          <para>
           Negotiating environment-driven parameter settings.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-check-writable">
         <term><symbol>CONNECTION_CHECK_WRITABLE</symbol></term>
         <listitem>
          <para>
           Checking if connection is able to handle write transactions.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-consume">
         <term><symbol>CONNECTION_CONSUME</symbol></term>
         <listitem>
          <para>
           Consuming any remaining response messages on connection.
          </para>
         </listitem>
        </varlistentry>
       </variablelist>

       Note that, although these constants will remain (in order to maintain
       compatibility), an application should never rely upon these occurring in a
       particular order, or at all, or on the status always being one of these
       documented values. An application might do something like this:
<programlisting>
switch(PQstatus(conn))
{
        case CONNECTION_STARTED:
            feedback = "Connecting...";
            break;

        case CONNECTION_MADE:
            feedback = "Connected to server...";
            break;
.
.
.
        default:
            feedback = "Connecting...";
}
</programlisting>
      </para>

      <para>
       The <literal>connect_timeout</literal> connection parameter is ignored
       when using <function>PQconnectPoll</function>; it is the application's
       responsibility to decide whether an excessive amount of time has elapsed.
       Otherwise, <function>PQconnectStart</function> followed by a
       <function>PQconnectPoll</function> loop is equivalent to
       <function>PQconnectdb</function>.
      </para>

      <para>
       Note that if <function>PQconnectStart</function> returns a non-null pointer, you must call
       <function>PQfinish</function> when you are finished with it, in order to dispose of
       the structure and any associated memory blocks. This must be done even if
       the connection attempt fails or is abandoned.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconndefaults">
     <term><function>PQconndefaults</function><indexterm><primary>PQconndefaults</></></term>
     <listitem>
      <para>
       Returns the default connection options.
<synopsis>
PQconninfoOption *PQconndefaults(void);

typedef struct
{
    char   *keyword;   /* The keyword of the option */
    char   *envvar;    /* Fallback environment variable name */
    char   *compiled;  /* Fallback compiled in default value */
    char   *val;       /* Option's current value, or NULL */
    char   *label;     /* Label for field in connect dialog */
    char   *dispchar;  /* Indicates how to display this field
                          in a connect dialog. Values are:
                          ""        Display entered value as is
                          "*"       Password field - hide value
                          "D"       Debug option - don't show by default */
    int     dispsize;  /* Field size in characters for dialog */
} PQconninfoOption;
</synopsis>
      </para>

      <para>
       Returns a connection options array.  This can be used to determine
       all possible <function>PQconnectdb</function> options and their
       current default values.  The return value points to an array of
       <structname>PQconninfoOption</structname> structures, which ends
       with an entry having a null <structfield>keyword</> pointer.  The
       null pointer is returned if memory could not be allocated. Note that
       the current default values (<structfield>val</structfield> fields)
       will depend on environment variables and other context.  A
       missing or invalid service file will be silently ignored.  Callers
       must treat the connection options data as read-only.
      </para>

      <para>
       After processing the options array, free it by passing it to
       <function>PQconninfoFree</function>.  If this is not done, a small amount of memory
       is leaked for each call to <function>PQconndefaults</function>.
      </para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconninfo">
     <term><function>PQconninfo</function><indexterm><primary>PQconninfo</></></term>
     <listitem>
      <para>
       Returns the connection options used by a live connection.
<synopsis>
PQconninfoOption *PQconninfo(PGconn *conn);
</synopsis>
      </para>

      <para>
       Returns a connection options array.  This can be used to determine
       all possible <function>PQconnectdb</function> options and the
       values that were used to connect to the server. The return
       value points to an array of <structname>PQconninfoOption</structname>
       structures, which ends with an entry having a null <structfield>keyword</>
       pointer. All notes above for <function>PQconndefaults</function> also
       apply to the result of <function>PQconninfo</function>.
      </para>

     </listitem>
    </varlistentry>


    <varlistentry id="libpq-pqconninfoparse">
     <term><function>PQconninfoParse</function><indexterm><primary>PQconninfoParse</></></term>
     <listitem>
      <para>
       Returns parsed connection options from the provided connection string.

<synopsis>
PQconninfoOption *PQconninfoParse(const char *conninfo, char **errmsg);
</synopsis>
      </para>

      <para>
       Parses a connection string and returns the resulting options as an
       array; or returns <symbol>NULL</> if there is a problem with the connection
       string.  This function can be used to extract
       the <function>PQconnectdb</function> options in the provided
       connection string.  The return value points to an array of
       <structname>PQconninfoOption</structname> structures, which ends
       with an entry having a null <structfield>keyword</> pointer.
      </para>

      <para>
       All legal options will be present in the result array, but the
       <literal>PQconninfoOption</literal> for any option not present
       in the connection string will have <literal>val</literal> set to
       <literal>NULL</literal>; default values are not inserted.
      </para>

      <para>
       If <literal>errmsg</> is not <symbol>NULL</>, then <literal>*errmsg</> is set
       to <symbol>NULL</> on success, else to a <function>malloc</>'d error string explaining
       the problem.  (It is also possible for <literal>*errmsg</> to be
       set to <symbol>NULL</> and the function to return <symbol>NULL</>;
       this indicates an out-of-memory condition.)
      </para>

      <para>
       After processing the options array, free it by passing it to
       <function>PQconninfoFree</function>.  If this is not done, some memory
       is leaked for each call to <function>PQconninfoParse</function>.
       Conversely, if an error occurs and <literal>errmsg</> is not <symbol>NULL</>,
       be sure to free the error string using <function>PQfreemem</>.
      </para>

   </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfinish">
     <term><function>PQfinish</function><indexterm><primary>PQfinish</></></term>
     <listitem>
      <para>
       Closes  the  connection to the server.  Also frees
       memory used by the <structname>PGconn</structname> object.
<synopsis>
void PQfinish(PGconn *conn);
</synopsis>
      </para>

      <para>
       Note that even if the server connection attempt fails (as
       indicated by <function>PQstatus</function>), the application should call <function>PQfinish</function>
       to free the memory used by the <structname>PGconn</structname> object.
       The <structname>PGconn</> pointer must not be used again after
       <function>PQfinish</function> has been called.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqreset">
     <term><function>PQreset</function><indexterm><primary>PQreset</></></term>
     <listitem>
      <para>
       Resets the communication channel to the server.
<synopsis>
void PQreset(PGconn *conn);
</synopsis>
      </para>

      <para>
       This function will close the connection
       to the server and attempt to  reestablish  a  new
       connection to the same server, using all the same
       parameters previously used.  This might be useful for
       error recovery if a working connection is lost.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqresetstart">
     <term><function>PQresetStart</function><indexterm><primary>PQresetStart</></></term>
     <term><function>PQresetPoll</function><indexterm><primary>PQresetPoll</></></term>
     <listitem>
      <para>
       Reset the communication channel to the server, in a nonblocking manner.

<synopsis>
int PQresetStart(PGconn *conn);

PostgresPollingStatusType PQresetPoll(PGconn *conn);
</synopsis>
      </para>

      <para>
       These functions will close the connection to the server and attempt to
       reestablish a new connection to the same server, using all the same
       parameters previously used. This can be useful for error recovery if a
       working connection is lost. They differ from <function>PQreset</function> (above) in that they
       act in a nonblocking manner. These functions suffer from the same
       restrictions as <function>PQconnectStartParams</>, <function>PQconnectStart</>
       and <function>PQconnectPoll</>.
      </para>

      <para>
       To initiate a connection reset, call
       <function>PQresetStart</function>. If it returns 0, the reset has
       failed. If it returns 1, poll the reset using
       <function>PQresetPoll</function> in exactly the same way as you
       would create the connection using <function>PQconnectPoll</function>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqpingparams">
     <term><function>PQpingParams</function><indexterm><primary>PQpingParams</></></term>
     <listitem>
      <para>
       <function>PQpingParams</function> reports the status of the
       server.  It accepts connection parameters identical to those of
       <function>PQconnectdbParams</>, described above.  It is not
       necessary to supply correct user name, password, or database name
       values to obtain the server status; however, if incorrect values
       are provided, the server will log a failed connection attempt.

<synopsis>
PGPing PQpingParams(const char * const *keywords,
                    const char * const *values,
                    int expand_dbname);
</synopsis>

       The function returns one of the following values:

       <variablelist>
        <varlistentry id="libpq-pqpingparams-pqping-ok">
         <term><literal>PQPING_OK</literal></term>
         <listitem>
          <para>
           The server is running and appears to be accepting connections.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pqpingparams-pqping-reject">
         <term><literal>PQPING_REJECT</literal></term>
         <listitem>
          <para>
           The server is running but is in a state that disallows connections
           (startup, shutdown, or crash recovery).
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pqpingparams-pqping-no-response">
         <term><literal>PQPING_NO_RESPONSE</literal></term>
         <listitem>
          <para>
           The server could not be contacted.  This might indicate that the
           server is not running, or that there is something wrong with the
           given connection parameters (for example, wrong port number), or
           that there is a network connectivity problem (for example, a
           firewall blocking the connection request).
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pqpingparams-pqping-no-attempt">
         <term><literal>PQPING_NO_ATTEMPT</literal></term>
         <listitem>
          <para>
           No attempt was made to contact the server, because the supplied
           parameters were obviously incorrect or there was some client-side
           problem (for example, out of memory).
          </para>
         </listitem>
        </varlistentry>
       </variablelist>

      </para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqping">
     <term><function>PQping</function><indexterm><primary>PQping</></></term>
     <listitem>
      <para>
       <function>PQping</function> reports the status of the
       server.  It accepts connection parameters identical to those of
       <function>PQconnectdb</>, described above.  It is not
       necessary to supply correct user name, password, or database name
       values to obtain the server status; however, if incorrect values
       are provided, the server will log a failed connection attempt.

<synopsis>
PGPing PQping(const char *conninfo);
</synopsis>
      </para>

      <para>
       The return values are the same as for <function>PQpingParams</>.
      </para>

     </listitem>
    </varlistentry>

   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   下列函数会建立到一个<productname>PostgreSQL</productname>后端服务器的连接。一个应用程序可以在一个时刻打开多个后端连接（原因之一就是为了访问多个数据库）。每个连接用一个<structname>PGconn</><indexterm><primary>PGconn</></>对象表示，它从函数<function>PQconnectdb</>、<function>PQconnectdbParams</>或<function>PQsetdbLogin</>得到。注意这些函数将总是返回一个非空的对象指针，除非正好没有内存来分配<structname>PGconn</>对象。在通过该连接对象发送查询之前，应该调用<function>PQstatus</>函数来检查返回值以确定是否得到了一个成功的连接。

   <warning>
    <para>
     在 Unix 上，复制一个拥有打开 libpq 连接的进程可能导致不可以预料的结果，因为父进程和子进程会共享相同的套接字和操作系统资源。出于这个原因，我们不推荐这样的用法，尽管从子进程执行一个<function>exec</>来载入新的可执行代码是安全的。
    </para>
   </warning>

   <note>
    <para>
     在 Windows 上，如果一个单一数据库连接被反复地开启并且关闭，这是一种提升性能的方式。在内部，libpq 为开启和关闭分别调用<function>WSAStartup()</>和<function>WSACleanup()</>。<function>WSAStartup()</>会增加一个内部 Windows 库引用计数而<function>WSACleanup()</>则会减少之。当引用计数正好为一时，调用<function>WSACleanup()</>会释放所有资源并且所有 DLL 会被卸载。这是一种昂贵的操作。为了避免它，一个应用可以手动调用<function>WSAStartup()</>，这样当最后的数据库连接被关闭时资源不会被释放。
    </para>
   </note>

   <variablelist>
    <varlistentry id="libpq-pqconnectdbparams">
     <term><function>PQconnectdbParams</function><indexterm><primary>PQconnectdbParams</></></term>
     <listitem>
      <para>
       开启一个到数据库服务器的新连接。

<synopsis>
PGconn *PQconnectdbParams(const char * const *keywords,
                          const char * const *values,
                          int expand_dbname);
</synopsis>
      </para>

      <para>
       这个函数使用从两个以<symbol>NULL</symbol>结尾的数组中取得的参数打开一个新的数据库连接。第一个数组<literal>keywords</literal>被定义为一个字符串数组，每一个元素是一个关键词。第二个数组<literal>values</literal>给出了每个关键词的值。和下面的<function>PQsetdbLogin</>不同，可以在不改变函数签名的情况下扩展参数集合，因此使用这个函数（或者与之相似的非阻塞的<function>PQconnectStartParams</>和<function>PQconnectPoll</function>）对于新应用编程要更好。 
      </para>

      <para>
       当前能被识别的参数关键词被列举在<xref linkend="libpq-paramkeywords">中。
      </para>

      <para>
       其可能的格式详见<xref linkend="libpq-connstring">。
       当<literal>expand_dbname</literal>为非零时，<parameter>dbname</parameter>
       关键词的值被允许识别为一个连接字符串。只有<parameter>dbname</parameter>
       的第一次出现会按这种方式扩展，任何后续<parameter>dbname</parameter>值会被当
       做一个普通数据库名处理。有关可能的连接字符串格式的详情可见
       <xref linkend="libpq-connstring">。
      </para>

      <para>
       被传递的数组可以为空，这样就会使用所有默认参数。也可以只包含一个或几个参数设置。两个参数数组应该在长度上匹配。对于参数数组的处理将会停止于<literal>keywords</literal>数组中第一个非-<symbol>NULL</symbol>元素。
      </para>

      <para>
       如果任何一个参数是<symbol>NULL</symbol>或者一个空字符串，
       那么将会检查相应的环境变量（见<xref linkend="libpq-envars">）。
       如果该环境变量也没有被设置，那么将使用指示的内建默认值。
      </para>

      <para>
       通常，关键词的处理是从这些数组的头部开始并且以索引顺序进行。这样做的效果就是，当关键词有重复时，只会保留最后一个被处理的值。因此，通过小心地放置关键词<parameter>dbname</parameter>，可以决定什么会被一个<parameter>conninfo</parameter>字符串所重载，以及什么不会被重载。
      </para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconnectdb">
     <term><function>PQconnectdb</function><indexterm><primary>PQconnectdb</></></term>
     <listitem>
      <para>
       开启一个到数据库服务器的新连接。

<synopsis>
PGconn *PQconnectdb(const char *conninfo);
</synopsis>
      </para>

      <para>
       这个函数使用从字符串<literal>conninfo</literal>中得到的参数开启一个新的数据库连接。
      </para>

      <para>
       被传递的字符串可以为空，这样将会使用所有的默认参数。也可以包含由空格分隔的一个或多个参数设置，还可以包含一个<acronym>URI</acronym>。详见<xref linkend="libpq-connstring">。
     </para>


    </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsetdblogin">
     <term><function>PQsetdbLogin</function><indexterm><primary>PQsetdbLogin</></></term>
     <listitem>
      <para>
       开启一个到数据库服务器的新连接。
<synopsis>
PGconn *PQsetdbLogin(const char *pghost,
                     const char *pgport,
                     const char *pgoptions,
                     const char *pgtty,
                     const char *dbName,
                     const char *login,
                     const char *pwd);
</synopsis>
       </para>

       <para>
        这是<function>PQconnectdb</function>的带有固定参数集合的前辈。它具有相同的功能，不过其中缺失的参数将总是采用默认值。对任意一个固定参数写<symbol>NULL</symbol>或一个空字符串将会使它采用默认值。
      </para>

      <para>
        如果<parameter>dbName</parameter>包含一个<symbol>=</symbol>符号或者具有一个合法的连接<acronym>URI</acronym>前缀，它会被当作一个<parameter>conninfo</parameter>字符串，就好像它已经被传递给了<function>PQconnectdb</function>，并且剩余的参数则被应用为指定给<function>PQconnectdbParams</>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsetdb">
     <term><function>PQsetdb</function><indexterm><primary>PQsetdb</></></term>
     <listitem>
      <para>
   开启一个到数据库服务器的新连接。
<synopsis>
PGconn *PQsetdb(char *pghost,
                char *pgport,
                char *pgoptions,
                char *pgtty,
                char *dbName);
</synopsis>
     </para>

     <para>
      这是一个调用<function>PQsetdbLogin</function>的宏，其中为<parameter>login</>和<parameter>pwd</>参数使用空指针。提供它是为了向后兼容非常老的程序。
     </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconnectstartparams">
     <term><function>PQconnectStartParams</function><indexterm><primary>PQconnectStartParams</></></term>
     <term><function>PQconnectStart</function><indexterm><primary>PQconnectStart</></></term>
     <term><function>PQconnectPoll</function><indexterm><primary>PQconnectPoll</></></term>
     <listitem>
      <para>
       <indexterm><primary>nonblocking connection</primary></indexterm>
       以非阻塞的方式建立一个到数据库服务器的连接。

<synopsis>
PGconn *PQconnectStartParams(const char * const *keywords,
                             const char * const *values,
                             int expand_dbname);

PGconn *PQconnectStart(const char *conninfo);

PostgresPollingStatusType PQconnectPoll(PGconn *conn);
</synopsis>
      </para>

      <para>
       这三个函数被用来开启一个到数据库服务器的连接，这样你的应用的执行线程不会因为远程的I/O而被阻塞。这种方法的要点在于等待 I/O 完成可能在应用的主循环中发生，而不是在<function>PQconnectdbParams</>或<function>PQconnectdb</>中，并且因此应用能够把这种操作和其他动作并行处理。
      </para>

      <para>
       在<function>PQconnectStartParams</function>中，数据库连接使用从<literal>keywords</literal>和<literal>values</literal>数组中取得的参数创建，并且被<literal>expand_dbname</literal>控制，这和之前描述的<function>PQconnectdbParams</function>相同。
      </para>

      <para>
       在<function>PQconnectStart</function>中，数据库连接使用从字符串<literal>conninfo</literal>中取得的参数创建，这和之前描述的<function>PQconnectdb</function>相同。
      </para>

      <para>
       只要满足一些限制，<function>PQconnectStartParams</function>或<function>PQconnectStart</function>或<function>PQconnectPoll</function>都不会阻塞：
       <itemizedlist>
        <listitem>
         <para>
          <literal>hostaddr</>和<literal>host</>参数被合适地使用，以确保不会做名字或逆向名字查询。详见<xref linkend="libpq-paramkeywords">中这些参数的文档。
         </para>
        </listitem>

        <listitem>
         <para>
          如果你调用<function>PQtrace</function>，确保你追踪的该流对象不会阻塞。
         </para>
        </listitem>

        <listitem>
         <para>
          如后文所述，你要确保在调用<function>PQconnectPoll</function>之前，套接字处于合适的状态。
         </para>
        </listitem>
       </itemizedlist>
      </para>

      <para>
       注意：<function>PQconnectStartParams</>的使用和下文所示的<function>PQconnectStart</>类似。
      </para>

      <para>
       要开始一个非阻塞的连接请求，可调用<literal>conn = PQconnectStart("<replaceable>connection_info_string</>")</literal>。如果<varname>conn</varname>为空，那么<application>libpq</>无法分配一个新的<structname>PGconn</>结构。否则，一个合法的<structname>PGconn</>指针将被返回（尽管并不表示代表一个到数据库的合法连接）。在从<function>PQconnectStart</function>返回时，调用<literal>status = PQstatus(conn)</literal>。如果<varname>status</varname>等于<symbol>CONNECTION_BAD</symbol>，就说明<function>PQconnectStart</function>已经失败。
      </para>

      <para>
       如果<function>PQconnectStart</>成功，下一个阶段是轮询<application>libpq</>，这样它能够继续进行连接序列。使用<function>PQsocket(conn)</function>来获得该数据库连接底层的套接字描述符。这样循环：如果<function>PQconnectPoll(conn)</function>上一次返回<symbol>PGRES_POLLING_READING</symbol>，等到该套接字准备好读取（按照<function>select()</>、<function>poll()</>或类似的系统函数所指示的）。则再次调用<function>PQconnectPoll(conn)</function>。反之，如果<function>PQconnectPoll(conn)</function>上一次返回<symbol>PGRES_POLLING_WRITING</symbol>，等到该套接字准备好写入，则再次调用<function>PQconnectPoll(conn)</function>。如果你还没有调用<function>PQconnectPoll</function>，即刚好在对<function>PQconnectStart</function>的调用之后，行为就像是它上次返回了<symbol>PGRES_POLLING_WRITING</symbol>。持续这个循环直到<function>PQconnectPoll(conn)</function>返回<symbol>PGRES_POLLING_FAILED</symbol>指示连接过程已经失败，或者返回<symbol>PGRES_POLLING_OK</symbol>指示连接已经被成功地建立。
      </para>

      <para>
       在连接期间的任意时刻，该连接的状态可以通过调用<function>PQstatus</>来检查。如果这个调用返回<symbol>CONNECTION_BAD</>，那么连接过程已经失败。如果该调用返回<function>CONNECTION_OK</>，则该连接已经准备好。如前所述，这些状态同样都可以从<function>PQconnectPoll</>的返回值检测。在一个异步连接过程中（也只有在这个过程中）也可能出现其他状态。这些状态指示该连接过程的当前阶段，并且可能有助于为用户提供反馈。这些状态是：

       <variablelist>
        <varlistentry id="libpq-connection-started">
         <term><symbol>CONNECTION_STARTED</symbol></term>
         <listitem>
          <para>
           等待连接被建立。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-made">
         <term><symbol>CONNECTION_MADE</symbol></term>
         <listitem>
          <para>
           连接 OK，等待发送。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-awaiting-response">
         <term><symbol>CONNECTION_AWAITING_RESPONSE</symbol></term>
         <listitem>
          <para>
           等待来自服务器的一个回应。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-auth-ok">
         <term><symbol>CONNECTION_AUTH_OK</symbol></term>
         <listitem>
          <para>
           收到认证，等待后端启动结束。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-ssl-startup">
         <term><symbol>CONNECTION_SSL_STARTUP</symbol></term>
         <listitem>
          <para>
           协商 SSL 加密。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-setenv">
         <term><symbol>CONNECTION_SETENV</symbol></term>
         <listitem>
          <para>
           协商环境驱动的参数设置。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-check-writable">
         <term><symbol>CONNECTION_CHECK_WRITABLE</symbol></term>
         <listitem>
          <para>
           检查连接是否能够处理写入事务。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-consume">
         <term><symbol>CONNECTION_CONSUME</symbol></term>
         <listitem>
          <para>
           在连接上消费任何剩余的响应消息。
          </para>
         </listitem>
        </varlistentry>
		</variablelist>

       注意，尽管这些常数将被保留（为了维护兼容性），一个应用永远不应该依赖这些状态按照特定顺序出现，或者根本就不依赖它们，或者不依赖状态总是这些文档中所说的值。一个应用可能做些这样的事情：
<programlisting>
switch(PQstatus(conn))
{
        case CONNECTION_STARTED:
            feedback = "Connecting...";
            break;

        case CONNECTION_MADE:
            feedback = "Connected to server...";
            break;
.
.
.
        default:
            feedback = "Connecting...";
}
</programlisting>
      </para>

      <para>
       在使用<function>PQconnectPoll</function>时，连接参数<literal>connect_timeout</literal>会被忽略：判断是否超时是应用的责任。否则，<function>PQconnectStart</function>后面跟着后面跟着<function>PQconnectPoll</function>循环等效于<function>PQconnectdb</function>。
      </para>

      <para>
       注意如果<function>PQconnectStart</function>返回一个非空的指针，你必须在用完它之后调用<function>PQfinish</function>来处理那些结构和任何相关的内存块。即使连接尝试失败或被放弃时也必须完成这些工作。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconndefaults">
     <term><function>PQconndefaults</function><indexterm><primary>PQconndefaults</></></term>
     <listitem>
      <para>
       返回默认连接选项。
<synopsis>
PQconninfoOption *PQconndefaults(void);

typedef struct
{
    char   *keyword;   /* 该选项的关键词 */
    char   *envvar;    /* 依赖的环境变量名 */
    char   *compiled;  /* 依赖的内建默认值 */
    char   *val;       /* 选项的当前值，或者 NULL */
    char   *label;     /* 连接对话框中域的标签 */
    char   *dispchar;  /* 指示如何在一个连接对话框中显示这个域。值是：
                          ""        显示输入的值
                          "*"       口令域 - 隐藏值
                          "D"       调试选项 - 默认不显示 */
    int     dispsize;  /* 用于对话框的以字符计的域尺寸 */
} PQconninfoOption;
</synopsis>
      </para>

      <para>
       返回一个连接选项数组。这可以用来确定用于连接服务器的所有可能的<function>PQconnectdb</function>选项和它们的当前缺省值。返回值指向一个<structname>PQconninfoOption</structname>结构的数组，该数组以一个包含空<structfield>keyword</>指针的条目结束。如果无法分配内存，则返回该空指针。注意当前缺省值（<structfield>val</structfield>域）将依赖于环境变量和其他上下文。一个缺失或者无效的服务文件将会被无声地忽略掉。调用者必须把连接选项当作只读对待。
      </para>

      <para>
       在处理完选项数组后，把它交给<function>PQconninfoFree</function>释放。如果没有这么做， 每次调用<function>PQconndefaults</function>都会导致一小部分内存泄漏。
      </para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconninfo">
     <term><function>PQconninfo</function><indexterm><primary>PQconninfo</></></term>
     <listitem>
      <para>
       返回被一个活动连接使用的连接选项。
<synopsis>
PQconninfoOption *PQconninfo(PGconn *conn);
</synopsis>
      </para>

      <para>
       返回一个连接选项数组。这可以用来确定用于连接服务器的所有可能的<function>PQconnectdb</function>选项和它们的当前缺省值。返回值指向一个<structname>PQconninfoOption</structname>结构的数组，该数组以一个包含空<structfield>keyword</>指针的条目结束。上述所有对于<function>PQconndefaults</function>的注解也适用于<function>PQconninfo</function>的结果。
      </para>

     </listitem>
    </varlistentry>


    <varlistentry id="libpq-pqconninfoparse">
     <term><function>PQconninfoParse</function><indexterm><primary>PQconninfoParse</></></term>
     <listitem>
      <para>
       返回从提供的连接字符串中解析到的连接选项。

<synopsis>
PQconninfoOption *PQconninfoParse(const char *conninfo, char **errmsg);
</synopsis>
      </para>

      <para>
       解析一个连接字符串并且将结果选项作为一个数组返回，或者在连接字符串有问题时返回<symbol>NULL</>。这个函数可以用来抽取所提供的连接字符串中的<function>PQconnectdb</function>选项。返回值指向一个<structname>PQconninfoOption</structname>结构的数组，该数组以一个包含空<structfield>keyword</>指针的条目结束。
      </para>

      <para>
       所有合法选项将出现在结果数组中，但是任何在连接字符串中没有出现的选项的<literal>PQconninfoOption</literal>的<literal>val</literal>会被设置为<literal>NULL</literal>，默认值不会被插入。
      </para>

      <para>
       如果<literal>errmsg</>不是<symbol>NULL</>，那么成功时<literal>*errmsg</>会被设置为<symbol>NULL</>， 否则设置为被<function>malloc</>过的错误字符串以说明该问题（也可以将<literal>*errmsg</>设置为<symbol>NULL</>并且函数返回<symbol>NULL</>，这表示一种内存耗尽的情况）。
      </para>

      <para>
       在处理完选项数组后，把它交给<function>PQconninfoFree</function>释放。如果没有这么做， 每次调用<function>PQconninfoParse</function>都会导致一小部分内存泄漏。反过来，如果发生一个错误并且<literal>errmsg</>不是<symbol>NULL</>，确保使用<function>PQfreemem</>释放错误字符串。
      </para>

   </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfinish">
     <term><function>PQfinish</function><indexterm><primary>PQfinish</></></term>
     <listitem>
      <para>
       关闭与服务器的连接。同时释放<structname>PGconn</structname>对象使用的内存。
<synopsis>
void PQfinish(PGconn *conn);
</synopsis>
      </para>

      <para>
       注意，即使与服务器的连接尝试失败（由<function>PQstatus</function>指示），应用也应当调用<function>PQfinish</function>来释放<structname>PGconn</structname>对象使用的内存。不能在调用<function>PQfinish</function>之后再使用<structname>PGconn</>指针。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqreset">
     <term><function>PQreset</function><indexterm><primary>PQreset</></></term>
     <listitem>
      <para>
       重置与服务器的通讯通道。
<synopsis>
void PQreset(PGconn *conn);
</synopsis>
      </para>

      <para>
       此函数将关闭与服务器的连接，并且使用所有之前使用过的参数尝试重新建立与同一个服务器的连接。这可能有助于在工作连接丢失后的错误恢复。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqresetstart">
     <term><function>PQresetStart</function><indexterm><primary>PQresetStart</></></term>
     <term><function>PQresetPoll</function><indexterm><primary>PQresetPoll</></></term>
     <listitem>
      <para>
       以非阻塞方式重置与服务器的通讯通道。

<synopsis>
int PQresetStart(PGconn *conn);

PostgresPollingStatusType PQresetPoll(PGconn *conn);
</synopsis>
      </para>

      <para>
       这些函数将关闭与服务器的连接，并且使用所有之前使用过的参数尝试重新建立与同一个服务器的连接。这可能有助于在工作连接丢失后的错误恢复。它们和上面的<function>PQreset</function>的不同在于它们工作在非阻塞方式。这些函数受到<function>PQconnectStartParams</>、<function>PQconnectStart</>和<function>PQconnectPoll</>相同的限制。
      </para>

      <para>
       要发起一次连接重置，调用<function>PQresetStart</function>。如果它返回 0，那么重置失败。如果返回 1，用与使用<function>PQresetPoll</function>建立连接的相同方法使用<function>PQconnectPoll</function>重置连接。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqpingparams">
     <term><function>PQpingParams</function><indexterm><primary>PQpingParams</></></term>
     <listitem>
      <para>
       <function>PQpingParams</function>报告服务器的状态。它接受与<function>PQconnectdbParams</>相同的连接参数。获得服务器状态不需要提供正确的用户名、口令或数据库名。不过，如果提供了不正确的值，服务器将记录一次失败的连接尝试。

<synopsis>
PGPing PQpingParams(const char * const *keywords,
                    const char * const *values,
                    int expand_dbname);
</synopsis>

       该函数返回下列值之一：

       <variablelist>
        <varlistentry id="libpq-pqpingparams-pqping-ok">
         <term><literal>PQPING_OK</literal></term>
         <listitem>
          <para>
           服务器正在运行，并且看起来可以接受连接。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pqpingparams-pqping-reject">
         <term><literal>PQPING_REJECT</literal></term>
         <listitem>
          <para>
           服务器正在运行，但是处于一种不允许连接的状态（启动、关闭或崩溃恢复）。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pqpingparams-pqping-no-response">
         <term><literal>PQPING_NO_RESPONSE</literal></term>
         <listitem>
          <para>
           无法联系到服务器。这可能表示服务器没有运行，或者给定的连接参数中有些错误（例如，错误的端口号），或者有一个网络连接问题（例如，一个防火墙阻断了连接请求）。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pqpingparams-pqping-no-attempt">
         <term><literal>PQPING_NO_ATTEMPT</literal></term>
         <listitem>
          <para>
           没有尝试联系服务器，因为提供的参数显然不正确，或者有一些客户端问题（例如，内存用完）。
          </para>
         </listitem>
        </varlistentry>
       </variablelist>

      </para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqping">
     <term><function>PQping</function><indexterm><primary>PQping</></></term>
     <listitem>
      <para>
       <function>PQping</function>报告服务器的状态。它接受与<function>PQconnectdb</>相同的连接参数。获得服务器状态不需要提供正确的用户名、口令或数据库名。不过，如果提供了不正确的值，服务器将记录一次失败的连接尝试。

<synopsis>
PGPing PQping(const char *conninfo);
</synopsis>
      </para>

      <para>
       返回值和<function>PQpingParams</>相同。
      </para>

     </listitem>
    </varlistentry>

   </variablelist>
  </para>

  <sect2 id="libpq-connstring">
<!--==========================orignal english content==========================
   <title>Connection Strings</title>
____________________________________________________________________________-->
   <title>连接字符串</title>

<!--==========================orignal english content==========================
   <indexterm zone="libpq-connstring">
    <primary><literal>conninfo</literal></primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="libpq-connstring">
    <primary><literal>conninfo</literal></primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="libpq-connstring">
    <primary><literal>URI</literal></primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="libpq-connstring">
    <primary><literal>URI</literal></primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    Several <application>libpq</> functions parse a user-specified string to obtain
    connection parameters.  There are two accepted formats for these strings:
    plain <literal>keyword = value</literal> strings
    and URIs.  URIs generally follow
    <ulink url="https://tools.ietf.org/html/rfc3986">RFC
    3986</ulink>, except that multi-host connection strings are allowed
    as further described below.
   </para>
____________________________________________________________________________-->
   <para>
    几个<application>libpq</>函数会解析一个用户指定的字符串来获得连接参数。这些字符串有两种被接受的格式：纯<literal>关键词 = 值</literal>字符串以及URI。
	URI通常遵循
    <ulink url="https://tools.ietf.org/html/rfc3986">RFC
    3986</ulink>，除了允许多主机连接字符串，如下面进一步的描述。
   </para>

   <sect3>
<!--==========================orignal english content==========================
    <title>Keyword/Value Connection Strings</title>
____________________________________________________________________________-->
    <title>关键词/值连接字符串</title>

<!--==========================orignal english content==========================
   <para>
    In the first format, each parameter setting is in the form
    <literal>keyword = value</literal>.  Spaces around the equal sign are
    optional. To write an empty value, or a value containing spaces, surround it
    with single quotes, e.g., <literal>keyword = 'a value'</literal>. Single
    quotes and backslashes within
    the value must be escaped with a backslash, i.e., <literal>\'</literal> and
    <literal>\\</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    在第一种格式中，每一个参数设置的形式都是<literal>关键词 = 值</literal>。等号周围的空白是可选的。要写一个空值或一个包含空白的值，将它用单引号包围，例如<literal>关键词 = 'a value'</literal>。值里面的单引号和反斜线必须用一个反斜线转义，即<literal>\'</literal>和<literal>\\</literal>。
   </para>

<!--==========================orignal english content==========================
   <para>
    Example:
<programlisting>
host=localhost port=5432 dbname=mydb connect_timeout=10
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    例子：
<programlisting>
host=localhost port=5432 dbname=mydb connect_timeout=10
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    The recognized parameter key words are listed in <xref
    linkend="libpq-paramkeywords">.
   </para>
____________________________________________________________________________-->
   <para>
    能被识别的参数关键词在<xref linkend="libpq-paramkeywords">中列出。
   </para>
   </sect3>

   <sect3>
<!--==========================orignal english content==========================
    <title>Connection URIs</title>
____________________________________________________________________________-->
    <title>连接 URI</title>

<!--==========================orignal english content==========================
   <para>
   The general form for a connection <acronym>URI</acronym> is:
<synopsis>
postgresql://[user[:password]@][netloc][:port][,...][/dbname][?param1=value1&amp;...]
</synopsis>
   </para>
____________________________________________________________________________-->
   <para>
   一个连接<acronym>URI</acronym>的一般形式是：
<synopsis>
postgresql://[user[:password]@][netloc][:port][,...][/dbname][?param1=value1&amp;...]
</synopsis>
   </para>

<!--==========================orignal english content==========================
   <para>
    The <acronym>URI</acronym> scheme designator can be either
    <literal>postgresql://</literal> or <literal>postgres://</literal>.  Each
    of the <acronym>URI</acronym> parts is optional.  The following examples
    illustrate valid <acronym>URI</acronym> syntax uses:
<programlisting>
postgresql://
postgresql://localhost
postgresql://localhost:5433
postgresql://localhost/mydb
postgresql://user@localhost
postgresql://user:secret@localhost
postgresql://other@localhost/otherdb?connect_timeout=10&amp;application_name=myapp
postgresql://host1:123,host2:456/somedb?target_session_attrs=any&amp;application_name=myapp
</programlisting>
    Components of the hierarchical part of the <acronym>URI</acronym> can also
    be given as parameters.  For example:
<programlisting>
postgresql:///mydb?host=localhost&amp;port=5433
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    <acronym>URI</acronym>模式标志符可以是<literal>postgresql://</literal>或<literal>postgres://</literal>。每一个<acronym>URI</acronym>部分都是可选的。下列例子展示了合法的<acronym>URI</acronym>语法：
<programlisting>
postgresql://
postgresql://localhost
postgresql://localhost:5433
postgresql://localhost/mydb
postgresql://user@localhost
postgresql://user:secret@localhost
postgresql://other@localhost/otherdb?connect_timeout=10&amp;application_name=myapp
postgresql://host1:123,host2:456/somedb?target_session_attrs=any&amp;application_name=myapp
</programlisting>
    <acronym>URI</acronym>的层次部分的组件可以作为参数给出。例如：
<programlisting>
postgresql:///mydb?host=localhost&amp;port=5433
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    Percent-encoding may be used to include symbols with special meaning in any
    of the <acronym>URI</acronym> parts, e.g. replace <literal>=</> with
    <literal>%3D</>.

   </para>
____________________________________________________________________________-->
   <para>
    在任意<acronym>URI</acronym>部分中可以使用百分号编码来包括有特殊含义的符号，
	例如使用<literal>%3D</>替换<literal>=</>。
    .
   </para>

<!--==========================orignal english content==========================
   <para>
    Any connection parameters not corresponding to key words listed in <xref
    linkend="libpq-paramkeywords"> are ignored and a warning message about them
    is sent to <filename>stderr</filename>.
   </para>
____________________________________________________________________________-->
   <para>
    任何不对应<xref linkend="libpq-paramkeywords">中列出的关键词的连接参数将被忽略并且关于它们的警告消息会被发送到<filename>stderr</filename>。
   </para>

<!--==========================orignal english content==========================
   <para>
    For improved compatibility with JDBC connection <acronym>URI</acronym>s,
    instances of parameter <literal>ssl=true</literal> are translated into
    <literal>sslmode=require</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    为了提高和 JDBC 连接<acronym>URI</acronym>的兼容性，参数<literal>ssl=true</literal>的实例会被翻译成<literal>sslmode=require</literal>。
   </para>

<!--==========================orignal english content==========================
   <para>
    The host part may be either host name or an IP address.  To specify an
    IPv6 host address, enclose it in square brackets:
<synopsis>
postgresql://[2001:db8::1234]/database
</synopsis>
   </para>
____________________________________________________________________________-->
   <para>
    主机部分可能是主机名或一个 IP 地址。要指定一个 IPv6 主机地址，将它封闭在方括号中：
<synopsis>
postgresql://[2001:db8::1234]/database
</synopsis>
   </para>

<!--==========================orignal english content==========================
   <para>
    The host component is interpreted as described for the parameter <xref
    linkend="libpq-connect-host">.  In particular, a Unix-domain socket
    connection is chosen if the host part is either empty or starts with a
    slash, otherwise a TCP/IP connection is initiated.  Note, however, that the
    slash is a reserved character in the hierarchical part of the URI.  So, to
    specify a non-standard Unix-domain socket directory, either omit the host
    specification in the URI and specify the host as a parameter, or
    percent-encode the path in the host component of the URI:
<programlisting>
postgresql:///dbname?host=/var/lib/postgresql
postgresql://%2Fvar%2Flib%2Fpostgresql/dbname
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    主机组件会被按照参数<xref linkend="libpq-connect-host">对应的描述来解释。特别地，如果主机部分是空或开始于一个斜线，将使用一个 Unix 域套接字连接，否则将启动一个 TCP/IP 连接。不过要注意，斜线是 URI 层次部分中的一个保留字符。因此，要指定一个非标准的 Unix 域套接字目录，要么忽略 URI 中的主机说明并且指定该主机为一个参数，要么在 URI 的主机部分用百分号编码路径：
<programlisting>
postgresql:///dbname?host=/var/lib/postgresql
postgresql://%2Fvar%2Flib%2Fpostgresql/dbname
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    It is possible to specify multiple host components, each with an optional
    port component, in a single URI.  A URI of the form
    <literal>postgresql://host1:port1,host2:port2,host3:port3/</literal>
    is equivalent to a connection string of the form
    <literal>host=host1,host2,host3 port=port1,port2,port3</literal>.  Each
    host will be tried in turn until a connection is successfully established.
   </para>
____________________________________________________________________________-->
   <para>
    可以在一个URI中指定多个主机组件，每个主机组件都有一个可选的端口组件。
	一个格式为<literal>postgresql://host1:port1,host2:port2,host3:port3/</literal>
	的URI相当于一个连接字符串，格式为<literal>host=host1,host2,host3 port=port1,port2,port3</literal>。
	每个主机将依次尝试，直到连接成功建立。
   </para>
   </sect3>

   <sect3 id="libpq-multiple-hosts">
<!--==========================orignal english content==========================
     <title>Specifying Multiple Hosts</title>
____________________________________________________________________________-->
     <title>指定多个主机</title>

<!--==========================orignal english content==========================
     <para>
       It is possible to specify multiple hosts to connect to, so that they are
       tried in the given order. In the Keyword/Value format, the <literal>host</>,
       <literal>hostaddr</>, and <literal>port</> options accept a comma-separated
       list of values. The same number of elements must be given in each option, such
       that e.g. the first <literal>hostaddr</> corresponds to the first host name,
       the second <literal>hostaddr</> corresponds to the second host name, and so
       forth. As an exception, if only one <literal>port</literal> is specified, it
       applies to all the hosts.
     </para>
____________________________________________________________________________-->
     <para>
       可以指定多个要连接的主机，以便按给定顺序尝试它们。在关键字/值格式中，
	   <literal>host</>、<literal>hostaddr</>和<literal>port</>选项接受逗号分隔的值列表。
	   在每个选项中必须给出相同数量的元素，例如，第一个<literal>hostaddr</>
	   对应于第一个主机名称，第二个<literal>hostaddr</>对应于第二个主机名称，等等。
	   作为例外，如果只指定了一个<literal>port</literal>，它将应用于所有主机。
     </para>

<!--==========================orignal english content==========================
     <para>
       In the connection URI format, you can list multiple <literal>host:port</> pairs
       separated by commas, in the <literal>host</> component of the URI. In either
       format, a single hostname can also translate to multiple network addresses. A
       common example of this is a host that has both an IPv4 and an IPv6 address.
     </para>
____________________________________________________________________________-->
     <para>
       在连接URI格式中，您可以在URI的<literal>host</>组件中列出多个由逗号分隔的
	   <literal>host:port</>对。无论哪种格式，单个主机名也可以转换为多个网络地址。
	   这种情况的一个常见示例是同时拥有IPv4和IPv6地址的主机。	   
     </para>

<!--==========================orignal english content==========================
     <para>
       When multiple hosts are specified, or when a single hostname is
       translated to multiple addresses,  all the hosts and addresses will be
       tried in order, until one succeeds. If none of the hosts can be reached,
       the connection fails. If a connection is established successfully, but
       authentication fails, the remaining hosts in the list are not tried.
     </para>
____________________________________________________________________________-->
     <para>
       当指定多个主机时，或者将单个主机名转换为多个地址时，
	   将按顺序尝试所有主机和地址，直到成功为止。如果没有主机可以到达，
	   则连接失败。如果连接成功建立，但验证失败，则不尝试列表中剩余的主机。
     </para>

<!--==========================orignal english content==========================
     <para>
       If a password file is used, you can have different passwords for
       different hosts. All the other connection options are the same for every
       host, it is not possible to e.g. specify a different username for
       different hosts.
     </para>
____________________________________________________________________________-->
     <para>
       如果使用密码文件，则可以为不同的主机设置不同的密码。
	   所有其他连接选项对于每个主机都是相同的，
	   因此不可能例如为不同的主机指定不同的用户名。
     </para>
   </sect3>
   </sect2>

  <sect2 id="libpq-paramkeywords">
<!--==========================orignal english content==========================
   <title>Parameter Key Words</title>
____________________________________________________________________________-->
   <title>参数关键词</title>

<!--==========================orignal english content==========================
   <para>
    The currently recognized parameter key words are:

    <variablelist>
     <varlistentry id="libpq-connect-host" xreflabel="host">
      <term><literal>host</literal></term>
      <listitem>
       <para>
        Name of host to connect to.<indexterm><primary>host name</></>
        If a host name begins with a slash, it specifies Unix-domain
        communication rather than TCP/IP communication; the value is the
        name of the directory in which the socket file is stored.  If
        multiple host names are specified, each will be tried in turn in
        the order given.  The default behavior when <literal>host</literal> is
        not specified is to connect to a Unix-domain
        socket<indexterm><primary>Unix domain socket</></> in
        <filename>/tmp</filename> (or whatever socket directory was specified
        when <productname>PostgreSQL</> was built). On machines without
        Unix-domain sockets, the default is to connect to <literal>localhost</>.
       </para>
       <para>
        A comma-separated list of host names is also accepted, in which case
        each host name in the list is tried in order. See
        <xref linkend="libpq-multiple-hosts"> for details.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-hostaddr" xreflabel="hostaddr">
      <term><literal>hostaddr</literal></term>
      <listitem>
       <para>
        Numeric IP address of host to connect to.  This should be in the
        standard IPv4 address format, e.g., <literal>172.28.40.9</>.  If
        your machine supports IPv6, you can also use those addresses.
        TCP/IP communication is
        always used when a nonempty string is specified for this parameter.
       </para>

       <para>
        Using <literal>hostaddr</> instead of <literal>host</> allows the
        application to avoid a host name look-up, which might be important
        in applications with time constraints. However, a host name is
        required for GSSAPI or SSPI authentication
        methods, as well as for <literal>verify-full</> SSL
        certificate verification.  The following rules are used:
        <itemizedlist>
         <listitem>
          <para>
           If <literal>host</> is specified without <literal>hostaddr</>,
           a host name lookup occurs.
          </para>
         </listitem>
         <listitem>
          <para>
           If <literal>hostaddr</> is specified without <literal>host</>,
           the value for <literal>hostaddr</> gives the server network address.
           The connection attempt will fail if the authentication
           method requires a host name.
          </para>
         </listitem>
         <listitem>
          <para>
           If both <literal>host</> and <literal>hostaddr</> are specified,
           the value for <literal>hostaddr</> gives the server network address.
           The value for <literal>host</> is ignored unless the
           authentication method requires it, in which case it will be
           used as the host name.
          </para>
         </listitem>
        </itemizedlist>
        Note that authentication is likely to fail if <literal>host</>
        is not the name of the server at network address <literal>hostaddr</>.
        Also, note that <literal>host</> rather than <literal>hostaddr</>
        is used to identify the connection in a password file (see
        <xref linkend="libpq-pgpass">).
       </para>

       <para>
        A comma-separated list of <literal>hostaddrs</> is also accepted, in
        which case each host in the list is tried in order. See
        <xref linkend="libpq-multiple-hosts"> for details.
       </para>
       <para>
        Without either a host name or host address,
        <application>libpq</application> will connect using a
        local Unix-domain socket; or on machines without Unix-domain
        sockets, it will attempt to connect to <literal>localhost</>.
       </para>
       </listitem>
      </varlistentry>

      <varlistentry id="libpq-connect-port" xreflabel="port">
       <term><literal>port</literal></term>
       <listitem>
       <para>
        Port number to connect to at the server host, or socket file
        name extension for Unix-domain
        connections.<indexterm><primary>port</></>
        If multiple hosts were given in the <literal>host</literal> or
        <literal>hostaddr</> parameters, this parameter may specify a list
        of ports of equal length, or it may specify a single port number to
        be used for all hosts.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-dbname" xreflabel="dbname">
      <term><literal>dbname</literal></term>
      <listitem>
      <para>
       The database name.  Defaults to be the same as the user name.
       In certain contexts, the value is checked for extended
       formats; see <xref linkend="libpq-connstring"> for more details on
       those.
      </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-user" xreflabel="user">
      <term><literal>user</literal></term>
      <listitem>
      <para>
       <productname>PostgreSQL</productname> user name to connect as.
       Defaults to be the same as the operating system name of the user
       running the application.
      </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-password" xreflabel="password">
      <term><literal>password</literal></term>
      <listitem>
      <para>
       Password to be used if the server demands password authentication.
      </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-passfile" xreflabel="passfile">
      <term><literal>passfile</literal></term>
      <listitem>
      <para>
       Specifies the name of the file used to store passwords
       (see <xref linkend="libpq-pgpass">).
       Defaults to <filename>~/.pgpass</filename>, or
       <filename>%APPDATA%\postgresql\pgpass.conf</> on Microsoft Windows.
       (No error is reported if this file does not exist.)
      </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-connect-timeout" xreflabel="connect_timeout">
      <term><literal>connect_timeout</literal></term>
      <listitem>
      <para>
       Maximum wait for connection, in seconds (write as a decimal integer
       string). Zero or not specified means wait indefinitely.  It is not
       recommended to use a timeout of less than 2 seconds.
       This timeout applies separately to each connection attempt.
       For example, if you specify two hosts and <literal>connect_timeout</>
       is 5, each host will time out if no connection is made within 5
       seconds, so the total time spent waiting for a connection might be
       up to 10 seconds.
      </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-client-encoding" xreflabel="client_encoding">
      <term><literal>client_encoding</literal></term>
      <listitem>
      <para>
       This sets the <varname>client_encoding</varname>
       configuration parameter for this connection.  In addition to
       the values accepted by the corresponding server option, you
       can use <literal>auto</literal> to determine the right
       encoding from the current locale in the client
       (<envar>LC_CTYPE</envar> environment variable on Unix
       systems).
      </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-options" xreflabel="options">
      <term><literal>options</literal></term>
      <listitem>
       <para>
        Specifies command-line options to send to the server at connection
        start.  For example, setting this to <literal>-c geqo=off</> sets the
        session's value of the <varname>geqo</> parameter to
        <literal>off</>.  Spaces within this string are considered to
        separate command-line arguments, unless escaped with a backslash
        (<literal>\</>); write <literal>\\</> to represent a literal
        backslash.  For a detailed discussion of the available
        options, consult <xref linkend="runtime-config">.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-application-name" xreflabel="application_name">
      <term><literal>application_name</literal></term>
      <listitem>
       <para>
        Specifies a value for the <xref linkend="guc-application-name">
        configuration parameter.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-fallback-application-name" xreflabel="fallback_application_name">
      <term><literal>fallback_application_name</literal></term>
      <listitem>
       <para>
        Specifies a fallback value for the <xref
        linkend="guc-application-name"> configuration parameter.
        This value will be used if no value has been given for
        <literal>application_name</> via a connection parameter or the
        <envar>PGAPPNAME</envar> environment variable.  Specifying
        a fallback name is useful in generic utility programs that
        wish to set a default application name but allow it to be
        overridden by the user.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-keepalives" xreflabel="keepalives">
      <term><literal>keepalives</literal></term>
      <listitem>
       <para>
        Controls whether client-side TCP keepalives are used. The default
        value is 1, meaning on, but you can change this to 0, meaning off,
        if keepalives are not wanted.  This parameter is ignored for
        connections made via a Unix-domain socket.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-keepalives-idle" xreflabel="keepalives_idle">
      <term><literal>keepalives_idle</literal></term>
      <listitem>
       <para>
        Controls the number of seconds of inactivity after which TCP should
        send a keepalive message to the server.  A value of zero uses the
        system default. This parameter is ignored for connections made via a
        Unix-domain socket, or if keepalives are disabled.
        It is only supported on systems where <symbol>TCP_KEEPIDLE</> or
        an equivalent socket option is available, and on Windows; on other
        systems, it has no effect.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-keepalives-interval" xreflabel="keepalives_interval">
      <term><literal>keepalives_interval</literal></term>
      <listitem>
       <para>
        Controls the number of seconds after which a TCP keepalive message
        that is not acknowledged by the server should be retransmitted.  A
        value of zero uses the system default. This parameter is ignored for
        connections made via a Unix-domain socket, or if keepalives are disabled.
        It is only supported on systems where <symbol>TCP_KEEPINTVL</> or
        an equivalent socket option is available, and on Windows; on other
        systems, it has no effect.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-keepalives-count" xreflabel="keepalives_count">
      <term><literal>keepalives_count</literal></term>
      <listitem>
       <para>
        Controls the number of TCP keepalives that can be lost before the
        client's connection to the server is considered dead.  A value of
        zero uses the system default. This parameter is ignored for
        connections made via a Unix-domain socket, or if keepalives are disabled.
        It is only supported on systems where <symbol>TCP_KEEPCNT</> or
        an equivalent socket option is available; on other systems, it has no
        effect.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-tty" xreflabel="tty">
      <term><literal>tty</literal></term>
      <listitem>
      <para>
       Ignored (formerly, this specified where to send server debug output).
      </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslmode" xreflabel="sslmode">
      <term><literal>sslmode</literal></term>
      <listitem>
       <para>
        This option determines whether or with what priority a secure
        <acronym>SSL</> TCP/IP connection will be negotiated with the
        server. There are six modes:

        <variablelist>
         <varlistentry>
          <term><literal>disable</literal></term>
          <listitem>
           <para>
            only try a non-<acronym>SSL</> connection
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>allow</literal></term>
          <listitem>
           <para>
            first try a non-<acronym>SSL</> connection; if that
            fails, try an <acronym>SSL</> connection
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>prefer</literal> (default)</term>
          <listitem>
           <para>
            first try an <acronym>SSL</> connection; if that fails,
            try a non-<acronym>SSL</> connection
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>require</literal></term>
          <listitem>
           <para>
            only try an <acronym>SSL</> connection. If a root CA
            file is present, verify the certificate in the same way as
            if <literal>verify-ca</literal> was specified
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>verify-ca</literal></term>
          <listitem>
           <para>
            only try an <acronym>SSL</> connection, and verify that
            the server certificate is issued by a trusted
            certificate authority (<acronym>CA</>)
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>verify-full</literal></term>
          <listitem>
           <para>
            only try an <acronym>SSL</> connection, verify that the
            server certificate is issued by a
            trusted <acronym>CA</> and that the requested server host name
            matches that in the certificate
           </para>
          </listitem>
         </varlistentry>
        </variablelist>

        See <xref linkend="libpq-ssl"> for a detailed description of how
        these options work.
       </para>

       <para>
        <literal>sslmode</> is ignored for Unix domain socket
        communication.
        If <productname>PostgreSQL</> is compiled without SSL support,
        using options <literal>require</>, <literal>verify-ca</>, or
        <literal>verify-full</> will cause an error, while
        options <literal>allow</> and <literal>prefer</> will be
        accepted but <application>libpq</> will not actually attempt
        an <acronym>SSL</>
        connection.<indexterm><primary>SSL</><secondary
        sortas="libpq">with libpq</></indexterm>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-requiressl" xreflabel="requiressl">
      <term><literal>requiressl</literal></term>
      <listitem>
       <para>
        This option is deprecated in favor of the <literal>sslmode</>
        setting.
       </para>

       <para>
        If set to 1, an <acronym>SSL</acronym> connection to the server
        is required (this is equivalent to <literal>sslmode</>
        <literal>require</>).  <application>libpq</> will then refuse
        to connect if the server does not accept an
        <acronym>SSL</acronym> connection.  If set to 0 (default),
        <application>libpq</> will negotiate the connection type with
        the server (equivalent to <literal>sslmode</>
        <literal>prefer</>).  This option is only available if
        <productname>PostgreSQL</> is compiled with SSL support.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslcompression" xreflabel="sslcompression">
      <term><literal>sslcompression</literal></term>
      <listitem>
       <para>
        If set to 1 (default), data sent over SSL connections will be
        compressed.
        If set to 0, compression will be disabled (this requires
        <productname>OpenSSL</> 1.0.0 or later).
        This parameter is ignored if a connection without SSL is made,
        or if the version of <productname>OpenSSL</> used does not support
        it.
       </para>
       <para>
        Compression uses CPU time, but can improve throughput if
        the network is the bottleneck.
        Disabling compression can improve response time and throughput
        if CPU performance is the limiting factor.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslcert" xreflabel="sslcert">
      <term><literal>sslcert</literal></term>
      <listitem>
       <para>
        This parameter specifies the file name of the client SSL
        certificate, replacing the default
        <filename>~/.postgresql/postgresql.crt</>.
        This parameter is ignored if an SSL connection is not made.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslkey" xreflabel="sslkey">
      <term><literal>sslkey</literal></term>
      <listitem>
       <para>
        This parameter specifies the location for the secret key used for
        the client certificate. It can either specify a file name that will
        be used instead of the default
        <filename>~/.postgresql/postgresql.key</>, or it can specify a key
        obtained from an external <quote>engine</> (engines are
        <productname>OpenSSL</> loadable modules).  An external engine
        specification should consist of a colon-separated engine name and
        an engine-specific key identifier.  This parameter is ignored if an
        SSL connection is not made.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslrootcert" xreflabel="sslrootcert">
      <term><literal>sslrootcert</literal></term>
      <listitem>
       <para>
        This parameter specifies the name of a file containing SSL
        certificate authority (<acronym>CA</>) certificate(s).
        If the file exists, the server's certificate will be verified
        to be signed by one of these authorities.  The default is
        <filename>~/.postgresql/root.crt</>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslcrl" xreflabel="sslcrl">
      <term><literal>sslcrl</literal></term>
      <listitem>
       <para>
        This parameter specifies the file name of the SSL certificate
        revocation list (CRL).  Certificates listed in this file, if it
        exists, will be rejected while attempting to authenticate the
        server's certificate.  The default is
        <filename>~/.postgresql/root.crl</>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-requirepeer" xreflabel="requirepeer">
      <term><literal>requirepeer</literal></term>
      <listitem>
       <para>
        This parameter specifies the operating-system user name of the
        server, for example <literal>requirepeer=postgres</literal>.
        When making a Unix-domain socket connection, if this
        parameter is set, the client checks at the beginning of the
        connection that the server process is running under the specified
        user name; if it is not, the connection is aborted with an error.
        This parameter can be used to provide server authentication similar
        to that available with SSL certificates on TCP/IP connections.
        (Note that if the Unix-domain socket is in
        <filename>/tmp</filename> or another publicly writable location,
        any user could start a server listening there.  Use this parameter
        to ensure that you are connected to a server run by a trusted user.)
        This option is only supported on platforms for which the
        <literal>peer</> authentication method is implemented; see
        <xref linkend="auth-peer">.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-krbsrvname" xreflabel="krbsrvname">
      <term><literal>krbsrvname</literal></term>
      <listitem>
       <para>
        Kerberos service name to use when authenticating with GSSAPI.
        This must match the service name specified in the server
        configuration for Kerberos authentication to succeed. (See also
        <xref linkend="gssapi-auth">.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-gsslib" xreflabel="gsslib">
      <term><literal>gsslib</literal></term>
      <listitem>
       <para>
        GSS library to use for GSSAPI authentication. Only used on Windows.
        Set to <literal>gssapi</literal> to force libpq to use the GSSAPI
        library for authentication instead of the default SSPI.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-service" xreflabel="service">
      <term><literal>service</literal></term>
      <listitem>
       <para>
        Service name to use for additional parameters.  It specifies a service
        name in <filename>pg_service.conf</filename> that holds additional connection parameters.
        This allows applications to specify only a service name so connection parameters
        can be centrally maintained. See <xref linkend="libpq-pgservice">.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-target-session-attrs" xreflabel="target_session_attrs">
      <term><literal>target_session_attrs</literal></term>
      <listitem>
       <para>
        If this parameter is set to <literal>read-write</literal>, only a
        connection in which read-write transactions are accepted by default
        is considered acceptable.  The query
        <literal>SHOW transaction_read_only</literal> will be sent upon any
        successful connection; if it returns <literal>on</>, the connection
        will be closed.  If multiple hosts were specified in the connection
        string, any remaining servers will be tried just as if the connection
        attempt had failed.  The default value of this parameter,
        <literal>any</>, regards all connections as acceptable.
      </para>
      </listitem>
    </varlistentry>
    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    当前被识别的参数关键词是：

    <variablelist>
     <varlistentry id="libpq-connect-host" xreflabel="host">
      <term><literal>host</literal></term>
      <listitem>
       <para>
        要连接的主机名。<indexterm><primary>host name</></>如果主机名以一个斜线开始，则表示一个 Unix 域通信而不是 TCP/IP 通信，其值是存储套接字文件的目录名。
		如果指定了多个主机名，则将以给出的顺序依次尝试每个主机名。
		当<literal>host</literal>没有指定时的默认行为是连接到一个<filename>/tmp</filename>（或者<productname>PostgreSQL</>编译时指定的任何套接字目录）中的 Unix 域套接字<indexterm><primary>Unix 域套接字</></>。在没有 Unix 域套接字的机器上，默认是连接到<literal>localhost</>。
       </para>
       <para>
        还接受以逗号分隔的主机名列表，在这种情况下，列表中的每个主机名均按顺序尝试。
		有关详细信息，请参见<xref linkend="libpq-multiple-hosts"> 。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-hostaddr" xreflabel="hostaddr">
      <term><literal>hostaddr</literal></term>
      <listitem>
       <para>
        要连接的主机的数字 IP 地址。它应该是标准的 IPv4 地址格式，例如<literal>172.28.40.9</>。如果你的机器支持 IPv6，你也可以使用那些地址。当为这个参数指定一个非空字符串时，总是会使用 TCP/IP 通信。
       </para>

       <para>
        使用<literal>hostaddr</>代替<literal>host</>允许应用能避免一次主机名查找，这对于具有时间约束的应用可能非常重要。不过，GSSAPI 或 SSPI 认证方法以及<literal>verify-full</> SSL 证书验证还是要求一个主机名。使用的是下列规则：
        <itemizedlist>
         <listitem>
          <para>
           如果<literal>host</>被指定且没有<literal>hostaddr</>，将发生一次主机名查找。
          </para>
         </listitem>
         <listitem>
          <para>
           如果<literal>hostaddr</>被指定且没有<literal>host</>，<literal>hostaddr</>的值给出了服务器的网络地址。如果认证方法要求一个主机名则连接尝试将会失败。
          </para>
         </listitem>
         <listitem>
          <para>
           如果<literal>host</>和<literal>hostaddr</>都被指定，<literal>hostaddr</>的值给出服务器的网络地址。<literal>host</>的值将被忽略，除非认证方法要求它，在那种情况下它将被用作主机名。
          </para>
         </listitem>
        </itemizedlist>
        注意如果<literal>host</>不是网络地址<literal>hostaddr</>上的服务器名，认证很可能会失败。还有，注意<literal>host</>而不是<literal>hostaddr</>被用来标识口令文件中的连接（见<xref linkend="libpq-pgpass">）。
       </para>
       <para>
        还接受以逗号分隔的<literal>hostaddrs</>列表，在这种情况下，
		列表中的每个主机名均按顺序尝试。有关详细信息，
		请参见<xref linkend="libpq-multiple-hosts">。
       </para>
       <para>
        如果没有一个主机名或主机地址，<application>libpq</application>将尝试使用一个本地 Unix 域套接字连接，或者在没有 Unix 域套接字的机器上尝试连接到<literal>localhost</>。
       </para>
       </listitem>
      </varlistentry>

      <varlistentry id="libpq-connect-port" xreflabel="port">
       <term><literal>port</literal></term>
       <listitem>
       <para>
        在服务器主机上要连接的端口号，或者用于 Unix 域连接的套接字文件名扩展<indexterm><primary>port</></>。
		如果在<literal>host</literal>或<literal>hostaddr</>参数中给出了多个主机名，
		那么这个参数可以指定等长的端口列表，或者它可以指定单个端口号用于所有主机。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-dbname" xreflabel="dbname">
      <term><literal>dbname</literal></term>
      <listitem>
      <para>
       数据库名。默认和用户名相同。在一般的环境下，会为扩展格式检查该值，详见<xref linkend="libpq-connstring">。
      </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-user" xreflabel="user">
      <term><literal>user</literal></term>
      <listitem>
      <para>
       <productname>PostgreSQL</productname> 要作为哪个用户连接。默认与运行着该应用的用户的操作系统名相同。
      </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-password" xreflabel="password">
      <term><literal>password</literal></term>
      <listitem>
      <para>
       服务器要求口令认证时要使用的口令。
      </para>
      </listitem>
     </varlistentry>
     <varlistentry id="libpq-connect-passfile" xreflabel="passfile">
      <term><literal>passfile</literal></term>
      <listitem>
      <para>
       声明要用于存储口令的文件的名称(参阅<xref linkend="libpq-pgpass">)。
       默认是<filename>~/.pgpass</filename>，或者微软Windows上是
       <filename>%APPDATA%\postgresql\pgpass.conf</>。
       (如果此文件不存在，则不报告错误。)
      </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-connect-timeout" xreflabel="connect_timeout">
      <term><literal>connect_timeout</literal></term>
      <listitem>
      <para>
       连接超时时间，以秒计（写成一个十进制整数字符串）。0 或未指定表示无限等待。
	   我们不推荐使用低于 2 秒的超时时间。
	   此超时单独适用于每个连接尝试。例如，如果指定了两台主机并且
	   <literal>connect_timeout</>为5，如果没有主机在5秒内建立连接，
	   则每台主机都将超时，因此等待连接所花费的总时间可能高达10秒。	   
      </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-client-encoding" xreflabel="client_encoding">
      <term><literal>client_encoding</literal></term>
      <listitem>
      <para>
       为连接设置<varname>client_encoding</varname>配置参数。除了被相应服务器选项所接受的值，你还能使用<literal>auto</literal>从客户端的当前区域（Unix 系统上的<envar>LC_CTYPE</envar>环境变量）决定正确的编码。
      </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-options" xreflabel="options">
      <term><literal>options</literal></term>
      <listitem>
       <para>
        声明在连接开始时发送给服务器的命令行选项。例如，设置这个参数为
        <literal>-c geqo=off</>会把会话的<varname>geqo</>参数值设置为
        <literal>off</>。此字符串中的空格被视为分隔命令行参数，
        除非使用反斜杠(<literal>\</>)进行转义；写<literal>\\</>
        来表示文字反斜杠。可用选项的详细讨论请参考
        <xref linkend="runtime-config">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-application-name" xreflabel="application_name">
      <term><literal>application_name</literal></term>
      <listitem>
       <para>
        为<xref linkend="guc-application-name">配置参数指定一个值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-fallback-application-name" xreflabel="fallback_application_name">
      <term><literal>fallback_application_name</literal></term>
      <listitem>
       <para>
        为<xref linkend="guc-application-name">配置参数指定一个后补值。如果通过一个连接参数或<envar>PGAPPNAME</envar>环境变量没有为<literal>application_name</>给定一个值，将使用这个值。在希望设置一个默认应用名但不希望它被用户覆盖的一般工具程序中指定一个后补值很有用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-keepalives" xreflabel="keepalives">
      <term><literal>keepalives</literal></term>
      <listitem>
       <para>
        控制是否使用客户端的 TCP 保持存活机制。默认值是 1，表示打开。但是如果不想要保持存活机制，你可以改成 0 表示关闭。对于通过一个 Unix 域套接字建立的连接会忽略这个参数。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-keepalives-idle" xreflabel="keepalives_idle">
      <term><literal>keepalives_idle</literal></term>
      <listitem>
       <para>
        控制非活动多少秒之后 TCP 应该向服务器发送一个存活消息。零值表示使用系统默认值。对于一个通过 Unix 域套接字建立的连接将忽略这个参数，如果保持存活机制被禁用也将忽略这个参数。它只被<symbol>TCP_KEEPIDLE</>或等效的套接字选项可用的系统以及 Windows支持，在其他系统上，它没有效果。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-keepalives-interval" xreflabel="keepalives_interval">
      <term><literal>keepalives_interval</literal></term>
      <listitem>
       <para>
        控制一个 TCP 存活消息没有被服务器认可多少秒之后应该被重传。零值表示使用系统默认值。对于一个通过 Unix 域套接字建立的连接将忽略这个参数，如果保持存活机制被禁用也将忽略这个参数。它只被<symbol>TCP_KEEPINTVL</>或等效的套接字选项可用的系统以及 Windows支持，在其他系统上，它没有效果。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-keepalives-count" xreflabel="keepalives_count">
      <term><literal>keepalives_count</literal></term>
      <listitem>
       <para>
        控制该客户端到服务器的连接被认为死亡之前可以丢失的 TCP 保活消息数量。零值表示使用系统默认值。对于一个通过 Unix 域套接字建立的连接将忽略这个参数，如果保持存活机制被禁用也将忽略这个参数。它只被<symbol>TCP_KEEPCNT</>或等效的套接字选项可用的系统以及 Windows支持，在其他系统上，它没有效果。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-tty" xreflabel="tty">
      <term><literal>tty</literal></term>
      <listitem>
      <para>
       被忽略（之前，这指定向哪里发送服务器调试输出）。
      </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslmode" xreflabel="sslmode">
      <term><literal>sslmode</literal></term>
      <listitem>
       <para>
        这个选项决定一个<acronym>SSL</> TCP/IP连接是否将与服务器协商，或者决定以何种优先级协商。有六种模式：

        <variablelist>
         <varlistentry>
          <term><literal>disable</literal></term>
          <listitem>
           <para>
            只尝试非<acronym>SSL</>连接
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>allow</literal></term>
          <listitem>
           <para>
            首先尝试非<acronym>SSL</>连接，如果失败再尝试<acronym>SSL</>连接
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>prefer</literal>（默认）</term>
          <listitem>
           <para>
            首先尝试<acronym>SSL</>连接，如果失败再尝试非<acronym>SSL</>连接
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>require</literal></term>
          <listitem>
           <para>
            只尝试<acronym>SSL</>连接。如果存在一个根 CA 文件，以<literal>verify-ca</literal>被指定的相同方式验证该证书
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>verify-ca</literal></term>
          <listitem>
           <para>
            只尝试<acronym>SSL</>连接，并且验证服务器证书是由一个可信的证书机构颁发的（<acronym>CA</>）
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>verify-full</literal></term>
          <listitem>
           <para>
            只尝试<acronym>SSL</>连接，验证服务器证书是由一个可信的
            <acronym>CA</>颁发并且请求的服务器主机名匹配证书中的主机名
           </para>
          </listitem>
         </varlistentry>
        </variablelist>

        这些选项如何工作的详细描述见<xref linkend="libpq-ssl">。
       </para>

       <para>
        对于 Unix 域套接字通信，<literal>sslmode</>会被忽略。如果<productname>PostgreSQL</>被编译为不带 SSL 支持，使用选项<literal>require</>、<literal>verify-ca</>或<literal>verify-full</>将导致错误，而选项<literal>allow</>和<literal>prefer</>将会被接受但是<application>libpq</>将不会真正尝试<acronym>SSL</>连接。<indexterm><primary>SSL</><secondary
        sortas="libpq">with libpq</></indexterm>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-requiressl" xreflabel="requiressl">
      <term><literal>requiressl</literal></term>
      <listitem>
       <para>
        为了支持<literal>sslmode</>模式，这个选项已被废弃。
       </para>

       <para>
        如果设置为 1，则要求一个到服务器的<acronym>SSL</acronym>连接（这等效于<literal>sslmode</> <literal>require</>）。如果服务器不接受<acronym>SSL</acronym>连接，<application>libpq</>则将拒绝连接。如果设置为 0（默认），<application>libpq</>将与该服务器协商连接类型（等效于<literal>sslmode</> <literal>prefer</>）。只有<productname>PostgreSQL</>被编译为带有 SSL 支持，这个选项才可用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslcompression" xreflabel="sslcompression">
      <term><literal>sslcompression</literal></term>
      <listitem>
       <para>
        如果设置为 1（默认），SSL 连接之上传送的数据将被压缩。如果设置为 0，压缩将被禁用（这要求<productname>OpenSSL</> 1.0.0 或更高）。如果建立的是一个没有 SSL 的连接，这个参数会被忽略。如果使用的<productname>OpenSSL</>版本不支持该参数，它也会被忽略。
       </para>
       <para>
        压缩会占用 CUP 时间，但是当瓶颈为网络时可以提高吞吐量。如果 CPU 性能是限制因素，禁用压缩能够改进响应时间和吞吐量。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslcert" xreflabel="sslcert">
      <term><literal>sslcert</literal></term>
      <listitem>
       <para>
        这个参数指定客户端 SSL 证书的文件名，它替换默认的<filename>~/.postgresql/postgresql.crt</>。如果没有建立 SSL 连接，这个参数会被忽略。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslkey" xreflabel="sslkey">
      <term><literal>sslkey</literal></term>
      <listitem>
       <para>
        这个参数指定用于客户端证书的密钥位置。它能指定一个会被用来替代默认的<filename>~/.postgresql/postgresql.key</>的文件名，或者它能够指定一个从外部<quote>引擎</>（引擎是<productname>OpenSSL</>的可载入模块）得到的密钥。一个外部引擎说明应该由一个冒号分隔的引擎名称以及一个引擎相关的关键标识符组成。如果没有建立 SSL 连接，这个参数会被忽略。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslrootcert" xreflabel="sslrootcert">
      <term><literal>sslrootcert</literal></term>
      <listitem>
       <para>
        这个参数指定一个包含 SSL 证书机构（<acronym>CA</>）证书的文件名称。如果该文件存在，服务器的证书将被验证是由这些机构之一签发。默认值是<filename>~/.postgresql/root.crt</>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslcrl" xreflabel="sslcrl">
      <term><literal>sslcrl</literal></term>
      <listitem>
       <para>
        这个参数指定 SSL 证书撤销列表（CRL）的文件名。列在这个文件中的证书如果存在，在尝试认证该服务器证书时会被拒绝。默认值是<filename>~/.postgresql/root.crl</>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-requirepeer" xreflabel="requirepeer">
      <term><literal>requirepeer</literal></term>
      <listitem>
       <para>
        这个参数指定服务器的操作系统用户，例如<literal>requirepeer=postgres</literal>。当建立一个 Unix 域套接字连接时，如果设置了这个参数，客户端在连接开始时检查服务器进程是否运行在指定的用户名之下。如果发现不是，该连接会被一个错误中断。这个参数能被用来提供与 TCP/IP 连接上 SSL 证书相似的服务器认证（注意，如果 Unix 域套接字在<filename>/tmp</filename>或另一个公共可写的位置，任何用户能启动一个在那里监听的服务器。使用这个参数来保证你连接的是一个由可信用户运行的服务器）。这个选项只在实现了<literal>peer</>认证方法的平台上受支持，见<xref linkend="auth-peer">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-krbsrvname" xreflabel="krbsrvname">
      <term><literal>krbsrvname</literal></term>
      <listitem>
       <para>
        当用 GSSAPI 认证时，要使用的 Kerberos 服务名。为了让 Kerberos 认证成功，这必须匹配在服务器配置中指定的服务名（另见<xref linkend="gssapi-auth">）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-gsslib" xreflabel="gsslib">
      <term><literal>gsslib</literal></term>
      <listitem>
       <para>
        用于 GSSAPI 认证的 GSS 库。只用在 Windows 上。设置为<literal>gssapi</literal>可强制 libpq 用 GSSAPI 库来代替默认的 SSPI 进行认证。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-service" xreflabel="service">
      <term><literal>service</literal></term>
      <listitem>
       <para>
        用于附加参数的服务名。它指定保持附加连接参数的<filename>pg_service.conf</filename>中的一个服务名。这允许应用只指定一个服务名，这样连接参数能被集中维护。见<xref linkend="libpq-pgservice">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-target-session-attrs" xreflabel="target_session_attrs">
      <term><literal>target_session_attrs</literal></term>
      <listitem>
       <para>
        如果这个参数设置为<literal>read-write</literal>，
		则只有默认接受读写事务的连接才被认为是可接受的。查询
		<literal>SHOW transaction_read_only</literal>将在任何成功连接上发送；
		如果它返回<literal>on</>，则将关闭连接。如果在连接字符串中指定了多个主机，
		则将尝试任何剩余的服务器，就像连接尝试失败了一样。该参数的默认值<literal>any</>，
		将所有连接看做是可接受的。
      </para>
      </listitem>
    </varlistentry>  
  </variablelist>
   </para>
  </sect2>
 </sect1>

 <sect1 id="libpq-status">
<!--==========================orignal english content==========================
  <title>Connection Status Functions</title>
____________________________________________________________________________-->
  <title>连接状态函数</title>

<!--==========================orignal english content==========================
  <para>
   These functions can be used to interrogate the status
   of an existing database connection object.
  </para>
____________________________________________________________________________-->
  <para>
   这些函数可以被用来询问一个已有数据库连接对象的状态。
  </para>

  <tip>
<!--==========================orignal english content==========================
   <para>
    <indexterm><primary>libpq-fe.h</></>
    <indexterm><primary>libpq-int.h</></>
    <application>libpq</application> application programmers should be careful to
    maintain the <structname>PGconn</structname> abstraction.  Use the accessor
    functions described below to get at the contents of <structname>PGconn</structname>.
    Reference to internal <structname>PGconn</structname> fields using
    <filename>libpq-int.h</> is not recommended because they are subject to change
    in the future.
   </para>
____________________________________________________________________________-->
   <para>
    <indexterm><primary>libpq-fe.h</></>
    <indexterm><primary>libpq-int.h</></>
    <application>libpq</application>应用程序员应该小心地维护<structname>PGconn</structname>抽象。使用下面描述的访问函数来理解<structname>PGconn</structname>的内容。我们不推荐使用<filename>libpq-int.h</>引用内部的<structname>PGconn</structname>域，因为它们可能在未来改变。
   </para>
  </tip>

<!--==========================orignal english content==========================
  <para>
   The following functions return parameter values established at connection.
   These values are fixed for the life of the connection.  If a multi-host
   connection string is used, the values of <function>PQhost</>,
   <function>PQport</>, and <function>PQpass</> can change if a new connection
   is established using the same <structname>PGconn</> object.  Other values
   are fixed for the lifetime of the <structname>PGconn</> object.

   <variablelist>
    <varlistentry id="libpq-pqdb">
     <term>
      <function>PQdb</function>
      <indexterm>
       <primary>PQdb</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       Returns the database name of the connection.
<synopsis>
char *PQdb(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pquser">
     <term>
      <function>PQuser</function>
      <indexterm>
       <primary>PQuser</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       Returns the user name of the connection.
<synopsis>
char *PQuser(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqpass">
     <term>
      <function>PQpass</function>
      <indexterm>
       <primary>PQpass</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       Returns the password of the connection.
<synopsis>
char *PQpass(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqhost">
     <term>
      <function>PQhost</function>
      <indexterm>
       <primary>PQhost</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       Returns the server host name of the connection.
       This can be a host name, an IP address, or a directory path if the
       connection is via Unix socket.  (The path case can be distinguished
       because it will always be an absolute path, beginning
       with <literal>/</>.)
<synopsis>
char *PQhost(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqport">
     <term>
      <function>PQport</function>
      <indexterm>
       <primary>PQport</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       Returns the port of the connection.

<synopsis>
char *PQport(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqtty">
     <term>
      <function>PQtty</function>
      <indexterm>
       <primary>PQtty</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       Returns the debug <acronym>TTY</acronym> of the connection.
       (This is obsolete, since the server no longer pays attention
       to the <acronym>TTY</acronym> setting, but the function remains
       for backward compatibility.)

<synopsis>
char *PQtty(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqoptions">
     <term>
      <function>PQoptions</function>
      <indexterm>
       <primary>PQoptions</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       Returns the command-line options passed in the connection request.
<synopsis>
char *PQoptions(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   下列函数返回一个连接所建立的参数值。
   这些值在连接的生命期中是固定的。如果使用了多个主机连接字符串，
   则如果使用同一个<structname>PGconn</>对象建立了一个新的连接，
   <function>PQhost</>、<function>PQport</>和<function>PQpass</>的值可以改变。
   其他值在<structname>PGconn</>对象的生命期中是固定的。

   <variablelist>
    <varlistentry id="libpq-pqdb">
     <term>
      <function>PQdb</function>
      <indexterm>
       <primary>PQdb</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回该连接的数据库名。
<synopsis>
char *PQdb(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pquser">
     <term>
      <function>PQuser</function>
      <indexterm>
       <primary>PQuser</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回该连接的用户名。
<synopsis>
char *PQuser(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqpass">
     <term>
      <function>PQpass</function>
      <indexterm>
       <primary>PQpass</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回该连接的口令。
<synopsis>
char *PQpass(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqhost">
     <term>
      <function>PQhost</function>
      <indexterm>
       <primary>PQhost</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回该连接的服务器主机名。
<synopsis>
char *PQhost(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqport">
     <term>
      <function>PQport</function>
      <indexterm>
       <primary>PQport</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回该连接的端口。

<synopsis>
char *PQport(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqtty">
     <term>
      <function>PQtty</function>
      <indexterm>
       <primary>PQtty</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回该连接的调试<acronym>TTY</acronym>（这已被废弃，因为服务器不再关心<acronym>TTY</acronym>设置，但这个函数保持了向后兼容）。

<synopsis>
char *PQtty(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqoptions">
     <term>
      <function>PQoptions</function>
      <indexterm>
       <primary>PQoptions</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回被传递给连接请求的命令行选项。
<synopsis>
char *PQoptions(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

<!--==========================orignal english content==========================
  <para>
   The following functions return status data that can change as operations
   are executed on the <structname>PGconn</> object.

   <variablelist>
    <varlistentry id="libpq-pqstatus">
     <term>
      <function>PQstatus</function>
      <indexterm>
       <primary>PQstatus</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       Returns the status of the connection.
<synopsis>
ConnStatusType PQstatus(const PGconn *conn);
</synopsis>
      </para>

      <para>
       The status can be one of a number of values.  However, only two of
       these are seen outside of an asynchronous connection procedure:
       <literal>CONNECTION_OK</literal> and
       <literal>CONNECTION_BAD</literal>. A good connection to the database
       has the status <literal>CONNECTION_OK</literal>.  A failed
       connection attempt is signaled by status
       <literal>CONNECTION_BAD</literal>.  Ordinarily, an OK status will
       remain so until <function>PQfinish</function>, but a communications
       failure might result in the status changing to
       <literal>CONNECTION_BAD</literal> prematurely.  In that case the
       application could try to recover by calling
       <function>PQreset</function>.
      </para>

      <para>
       See the entry for <function>PQconnectStartParams</>, <function>PQconnectStart</>
       and <function>PQconnectPoll</> with regards to other status codes that
       might be returned.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqtransactionstatus">
     <term>
      <function>PQtransactionStatus</function>
      <indexterm>
       <primary>PQtransactionStatus</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       Returns the current in-transaction status of the server.

<synopsis>
PGTransactionStatusType PQtransactionStatus(const PGconn *conn);
</synopsis>

       The status can be <literal>PQTRANS_IDLE</literal> (currently idle),
       <literal>PQTRANS_ACTIVE</literal> (a command is in progress),
       <literal>PQTRANS_INTRANS</literal> (idle, in a valid transaction block),
       or <literal>PQTRANS_INERROR</literal> (idle, in a failed transaction block).
       <literal>PQTRANS_UNKNOWN</literal> is reported if the connection is bad.
       <literal>PQTRANS_ACTIVE</literal> is reported only when a query
       has been sent to the server and not yet completed.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqparameterstatus">
     <term>
      <function>PQparameterStatus</function>
      <indexterm>
       <primary>PQparameterStatus</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       Looks up a current parameter setting of the server.

<synopsis>
const char *PQparameterStatus(const PGconn *conn, const char *paramName);
</synopsis>

       Certain parameter values are reported by the server automatically at
       connection startup or whenever their values change.
       <function>PQparameterStatus</> can be used to interrogate these settings.
       It returns the current value of a parameter if known, or <symbol>NULL</symbol>
       if the parameter is not known.
      </para>

      <para>
       Parameters reported as of the current release include
       <varname>server_version</>,
       <varname>server_encoding</>,
       <varname>client_encoding</>,
       <varname>application_name</>,
       <varname>is_superuser</>,
       <varname>session_authorization</>,
       <varname>DateStyle</>,
       <varname>IntervalStyle</>,
       <varname>TimeZone</>,
       <varname>integer_datetimes</>, and
       <varname>standard_conforming_strings</>.
       (<varname>server_encoding</>, <varname>TimeZone</>, and
       <varname>integer_datetimes</> were not reported by releases before 8.0;
       <varname>standard_conforming_strings</> was not reported by releases
       before 8.1;
       <varname>IntervalStyle</> was not reported by releases before 8.4;
       <varname>application_name</> was not reported by releases before 9.0.)
       Note that
       <varname>server_version</>,
       <varname>server_encoding</> and
       <varname>integer_datetimes</>
       cannot change after startup.
      </para>

      <para>
       Pre-3.0-protocol servers do not report parameter settings, but
       <application>libpq</> includes logic to obtain values for
       <varname>server_version</> and <varname>client_encoding</> anyway.
       Applications are encouraged to use <function>PQparameterStatus</>
       rather than <foreignphrase>ad hoc</> code to determine these values.
       (Beware however that on a pre-3.0 connection, changing
       <varname>client_encoding</> via <command>SET</> after connection
       startup will not be reflected by <function>PQparameterStatus</>.)
       For <varname>server_version</>, see also
       <function>PQserverVersion</>, which returns the information in a
       numeric form that is much easier to compare against.
      </para>

      <para>
       If no value for <varname>standard_conforming_strings</> is reported,
       applications can assume it is <literal>off</>, that is, backslashes
       are treated as escapes in string literals.  Also, the presence of
       this parameter can be taken as an indication that the escape string
       syntax (<literal>E'...'</>) is accepted.
      </para>

      <para>
       Although the returned pointer is declared <literal>const</>, it in fact
       points to mutable storage associated with the <literal>PGconn</> structure.
       It is unwise to assume the pointer will remain valid across queries.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqprotocolversion">
     <term>
      <function>PQprotocolVersion</function>
      <indexterm>
       <primary>PQprotocolVersion</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       Interrogates the frontend/backend protocol being used.
<synopsis>
int PQprotocolVersion(const PGconn *conn);
</synopsis>
       Applications might wish to use this function to determine whether certain
       features are supported.  Currently, the possible values are 2 (2.0
       protocol), 3 (3.0 protocol), or zero (connection bad).  The
       protocol version will
       not change after connection startup is complete, but it could
       theoretically change during a connection reset.  The 3.0 protocol
       will normally be used when communicating with
       <productname>PostgreSQL</> 7.4 or later servers; pre-7.4 servers
       support only protocol 2.0.  (Protocol 1.0 is obsolete and not
       supported by <application>libpq</application>.)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqserverversion">
     <term>
      <function>PQserverVersion</function>
      <indexterm>
       <primary>PQserverVersion</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       Returns an integer representing the server version.
<synopsis>
int PQserverVersion(const PGconn *conn);
</synopsis>
      </para>

      <para>
       Applications might use this function to determine the version of the
       database server they are connected to.  The result is formed by
       multiplying the server's major version number by 10000 and adding
       the minor version number.  For example, version 10.1 will be
       returned as 100001, and version 11.0 will be returned as 110000.
       Zero is returned if the connection is bad.
      </para>

      <para>
       Prior to major version 10, <productname>PostgreSQL</> used
       three-part version numbers in which the first two parts together
       represented the major version.  For those
       versions, <function>PQserverVersion</> uses two digits for each
       part; for example version 9.1.5 will be returned as 90105, and
       version 9.2.0 will be returned as 90200.
      </para>

      <para>
       Therefore, for purposes of determining feature compatibility,
       applications should divide the result of <function>PQserverVersion</>
       by 100 not 10000 to determine a logical major version number.
       In all release series, only the last two digits differ between
       minor releases (bug-fix releases).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqerrormessage">
     <term>
      <function>PQerrorMessage</function>
      <indexterm>
       <primary>PQerrorMessage</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       <indexterm><primary>error message</></> Returns the error message
       most recently generated by an operation on the connection.

<synopsis>
char *PQerrorMessage(const PGconn *conn);
</synopsis>

      </para>

      <para>
       Nearly all <application>libpq</> functions will set a message for
       <function>PQerrorMessage</function> if they fail.  Note that by
       <application>libpq</application> convention, a nonempty
       <function>PQerrorMessage</function> result can consist of multiple lines,
       and will include a trailing newline. The caller should not free
       the result directly. It will be freed when the associated
       <structname>PGconn</> handle is passed to
       <function>PQfinish</function>.  The result string should not be
       expected to remain the same across operations on the
       <literal>PGconn</> structure.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsocket">
     <term><function>PQsocket</function><indexterm><primary>PQsocket</></></term>
     <listitem>
      <para>
       Obtains the file descriptor number of the connection socket to
       the server.  A valid descriptor will be greater than or equal
       to 0; a result of -1 indicates that no server connection is
       currently open.  (This will not change during normal operation,
       but could change during connection setup or reset.)

<synopsis>
int PQsocket(const PGconn *conn);
</synopsis>

      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqbackendpid">
     <term><function>PQbackendPID</function><indexterm><primary>PQbackendPID</></></term>
     <listitem>
      <para>
       Returns the process <acronym>ID</acronym> (PID)<indexterm>
        <primary>PID</>
        <secondary>determining PID of server process</>
        <tertiary>in libpq</>
       </indexterm>
       of the backend process handling this connection.

<synopsis>
int PQbackendPID(const PGconn *conn);
</synopsis>
      </para>

      <para>
       The backend <acronym>PID</acronym> is useful for debugging
       purposes and for comparison to <command>NOTIFY</command>
       messages (which include the <acronym>PID</acronym> of the
       notifying backend process).  Note that the
       <acronym>PID</acronym> belongs to a process executing on the
       database server host, not the local host!
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconnectionneedspassword">
     <term><function>PQconnectionNeedsPassword</function><indexterm><primary>PQconnectionNeedsPassword</></></term>
     <listitem>
      <para>
       Returns true (1) if the connection authentication method
       required a password, but none was available.
       Returns false (0) if not.

<synopsis>
int PQconnectionNeedsPassword(const PGconn *conn);
</synopsis>
      </para>

      <para>
       This function can be applied after a failed connection attempt
       to decide whether to prompt the user for a password.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconnectionusedpassword">
     <term><function>PQconnectionUsedPassword</function><indexterm><primary>PQconnectionUsedPassword</></></term>
     <listitem>
      <para>
       Returns true (1) if the connection authentication method
       used a password. Returns false (0) if not.

<synopsis>
int PQconnectionUsedPassword(const PGconn *conn);
</synopsis>
      </para>

      <para>
       This function can be applied after either a failed or successful
       connection attempt to detect whether the server demanded a password.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   下列函数返回会随着在<structname>PGconn</>对象上执行的操作改变的状态数据。

   <variablelist>
    <varlistentry id="libpq-pqstatus">
     <term>
      <function>PQstatus</function>
      <indexterm>
       <primary>PQstatus</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回该连接的状态。
<synopsis>
ConnStatusType PQstatus(const PGconn *conn);
</synopsis>
      </para>

      <para>
       该状态可以是一系列值之一。不过，其中只有两个在一个异步连接过程之外可见：<literal>CONNECTION_OK</literal>和<literal>CONNECTION_BAD</literal>。一个到数据库的完好连接的状态为<literal>CONNECTION_OK</literal>。一个失败的连接尝试则由状态<literal>CONNECTION_BAD</literal>表示。通常，一个 OK 状态将一直保持到<function>PQfinish</function>，但是一次通信失败可能导致该状态过早地改变为<literal>CONNECTION_BAD</literal>。在那种情况下，该应用可以通过调用<function>PQreset</function>尝试恢复。
      </para>

      <para>
       关于其他可能会被返回的状态代码，请见<function>PQconnectStartParams</>、<function>PQconnectStart</>和<function>PQconnectPoll</>的条目。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqtransactionstatus">
     <term>
      <function>PQtransactionStatus</function>
      <indexterm>
       <primary>PQtransactionStatus</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回服务器的当前事务内状态。

<synopsis>
PGTransactionStatusType PQtransactionStatus(const PGconn *conn);
</synopsis>

       该状态可能是<literal>PQTRANS_IDLE</literal>（当前空闲）、
       <literal>PQTRANS_ACTIVE</literal>（一个命令运行中）、
       <literal>PQTRANS_INTRANS</literal>（空闲，处于一个合法的事务块中）
       或者<literal>PQTRANS_INERROR</literal>（空闲，处于一个失败的事务块中）。
       如果该连接损坏，将会报告<literal>PQTRANS_UNKNOWN</literal>。
       只有当一个查询已经被发送给服务器并且还没有完成时，才会报告<literal>PQTRANS_ACTIVE</literal>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqparameterstatus">
     <term>
      <function>PQparameterStatus</function>
      <indexterm>
       <primary>PQparameterStatus</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       查找服务器的一个当前参数设置。

<synopsis>
const char *PQparameterStatus(const PGconn *conn, const char *paramName);
</synopsis>

       某一参数值会被服务器在连接开始或值改变时自动报告。<function>PQparameterStatus</>可以被用来询问这些设置。它为已知的参数返回当前值，为未知的参数返回<symbol>NULL</symbol>。
      </para>

      <para>
       自当前发布开始会被报告的参数包括
       <varname>server_version</>、
       <varname>server_encoding</>、
       <varname>client_encoding</>、
       <varname>application_name</>、
       <varname>is_superuser</>、
       <varname>session_authorization</>、
       <varname>DateStyle</>、
       <varname>IntervalStyle</>、
       <varname>TimeZone</>、
       <varname>integer_datetimes</>以及
       <varname>standard_conforming_strings</>（
       <varname>server_encoding</>、<varname>TimeZone</>以及<varname>integer_datetimes</>在 8.0 以前的发布中不被报告；<varname>standard_conforming_strings</>在 8.1 以前的发布中不被报告；<varname>IntervalStyle</>在 8.4 以前的发布中不被报告；<varname>application_name</>在 9.0 以前的发布中不被报告）。注意
       <varname>server_version</>、
       <varname>server_encoding</>以及
       <varname>integer_datetimes</>在启动之后无法改变。
      </para>

      <para>
       3.0 之前协议的服务器不报告参数设置，但是<application>libpq</>包括获得<varname>server_version</>以及<varname>client_encoding</>值的逻辑。我们鼓励应用使用<function>PQparameterStatus</>而不是<foreignphrase>ad hoc</>代码来确定这些值（不过注意在一个 3.0 之前的连接上，连接开始后通过<command>SET</>改变<varname>client_encoding</>不会被<function>PQparameterStatus</>反映）。对于<varname>server_version</>（另见<function>PQserverVersion</>），它以一种数字形式返回信息，这样更容易进行比较。
      </para>

      <para>
       如果没有为<varname>standard_conforming_strings</>报告值，应用能假设它是<literal>off</>，也就是说反斜线会被视为字符串中的转义。还有，这个参数的存在可以被作为转义字符串语法（<literal>E'...'</>）被接受的指示。
      </para>

      <para>
       尽管被返回的指针被声明成<literal>const</>，它事实上指向与<literal>PGconn</>结构相关的可变存储。假定该指针在查询之间保持有效是不明智的。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqprotocolversion">
     <term>
      <function>PQprotocolVersion</function>
      <indexterm>
       <primary>PQprotocolVersion</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       询问所使用的 前端/后端协议。
<synopsis>
int PQprotocolVersion(const PGconn *conn);
</synopsis>
       应用可能希望用这个函数来确定某些特性是否被支持。当前，可能值是 2（2.0 协议）、3（3.0 协议）或零（连接损坏）。协议版本在连接启动完成后将不会改变，但是理论上在连接重置期间是可以改变的。当与<productname>PostgreSQL</> 7.4 或以后的服务器通信时通常使用 3.0 协议，7.4 之前的服务器只支持协议 2.0（协议 1.0 已被废弃并且不再被<application>libpq</application>支持）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqserverversion">
     <term>
      <function>PQserverVersion</function>
      <indexterm>
       <primary>PQserverVersion</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回一个表示服务器版本的整数。
<synopsis>
int PQserverVersion(const PGconn *conn);
</synopsis>
      </para>

      <para>
       应用可能会使用这个函数来决定它们连接到的数据库服务器的版本。
	   结果是通过将服务器的主要版本号乘以10000并添加次要版本号形成的。
	   例如，版本10.1将返回100001，版本11.0将返回110000。如果连接不正确，则返回零。
      </para>

      <para>
       在主版本10之前，<productname>PostgreSQL</>使用三部分版本号，
	   前两部分代表主要版本。对于这些版本，<function>PQserverVersion</>
	   对每个部分使用两个数字；例如版本9.1.5将返回90105，版本9.2.0将返回90200。
      </para>

      <para>
       因此，为确定功能兼容性，应用程序应将<function>PQserverVersion</>
	   的结果除以100而不是10000，以确定逻辑主要版本号。在所有发行版系列中，
	   只有最后两位数字在次版本（错误修复版本）之间有所不同。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqerrormessage">
     <term>
      <function>PQerrorMessage</function>
      <indexterm>
       <primary>PQerrorMessage</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       <indexterm><primary>错误消息</></>返回连接上的一个操作最近产生的错误消息。

<synopsis>
char *PQerrorMessage(const PGconn *conn);
</synopsis>

      </para>

      <para>
       几乎所有的<application>libpq</>在失败时都会为<function>PQerrorMessage</function>设置一个消息。注意按照<application>libpq</application>习惯，一个非空<function>PQerrorMessage</function>结果由多行构成，并且将包括一个尾部新行。调用者不应该直接释放结果。当相关的<structname>PGconn</>句柄被传递给<function>PQfinish</function>时，它将被释放。在<literal>PGconn</>结构上的多个操作之间，不能指望结果字符串会保持不变。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsocket">
     <term><function>PQsocket</function><indexterm><primary>PQsocket</></></term>
     <listitem>
      <para>
       获得到服务器连接套接字的文件描述符号。一个合法的描述符将会大于等于零。结果为 -1 表示当前没有打开服务器连接（在普通操作期间这将不会改变，但是在连接设置或重置期间可能改变）。

<synopsis>
int PQsocket(const PGconn *conn);
</synopsis>

      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqbackendpid">
     <term><function>PQbackendPID</function><indexterm><primary>PQbackendPID</></></term>
     <listitem>
      <para>
       返回处理这个连接的后端进程的进程<acronym>ID</acronym>（PID）。<indexterm>
        <primary>PID</>
        <secondary>确定服务器进程的 PID</>
        <tertiary>in libpq</>
       </indexterm>

<synopsis>
int PQbackendPID(const PGconn *conn);
</synopsis>
      </para>

      <para>
       后端<acronym>PID</acronym>有助于调试目的并且可用于与<command>NOTIFY</command>消息（它包括发出提示的后端进程的<acronym>PID</acronym>）进行比较。注意<acronym>PID</acronym>属于一个在数据库服务器主机上执行的进程，而不是本地主机进程！
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconnectionneedspassword">
     <term><function>PQconnectionNeedsPassword</function><indexterm><primary>PQconnectionNeedsPassword</></></term>
     <listitem>
      <para>
       如果连接认证方法要求一个口令但没有可用的口令，返回真（1）。否则返回假（0）。

<synopsis>
int PQconnectionNeedsPassword(const PGconn *conn);
</synopsis>
      </para>

      <para>
       这个函数可以在连接尝试失败后被应用于决定是否向用户提示要求一个口令。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconnectionusedpassword">
     <term><function>PQconnectionUsedPassword</function><indexterm><primary>PQconnectionUsedPassword</></></term>
     <listitem>
      <para>
       如果连接认证方法使用一个口令，返回真（1）。否则返回假（0）。

<synopsis>
int PQconnectionUsedPassword(const PGconn *conn);
</synopsis>
      </para>

      <para>
       这个函数能在一次连接尝试失败或成功后用于检测该服务器是否要求一个口令。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
  
<!--==========================orignal english content==========================
  <para>
    The following functions return information related to SSL. This information
    usually doesn't change after a connection is established.

    <variablelist>
    <varlistentry id="libpq-pqsslinuse">
     <term><function>PQsslInUse</function><indexterm><primary>PQsslInUse</></></term>
     <listitem>
      <para>
        Returns true (1) if the connection uses SSL, false (0) if not.

<synopsis>
int PQsslInUse(const PGconn *conn);
</synopsis>
      </para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsslattribute">
     <term><function>PQsslAttribute</function><indexterm><primary>PQsslAttribute</></></term>
     <listitem>
      <para>
        Returns SSL-related information about the connection.

<synopsis>
const char *PQsslAttribute(const PGconn *conn, const char *attribute_name);
</synopsis>
      </para>

      <para>
       The list of available attributes varies depending on the SSL library
       being used, and the type of connection. If an attribute is not
       available, returns NULL.
      </para>

      <para>
       The following attributes are commonly available:
       <variablelist>
        <varlistentry>
         <term><literal>library</literal></term>
          <listitem>
           <para>
            Name of the SSL implementation in use. (Currently, only
            <literal>"OpenSSL"</literal> is implemented)
           </para>
          </listitem>
         </varlistentry>
        <varlistentry>
         <term><literal>protocol</literal></term>
          <listitem>
           <para>
             SSL/TLS version in use. Common values
             are <literal>"TLSv1"</literal>, <literal>"TLSv1.1"</literal>
             and <literal>"TLSv1.2"</literal>, but an implementation may
             return other strings if some other protocol is used.
           </para>
          </listitem>
         </varlistentry>
        <varlistentry>
         <term><literal>key_bits</literal></term>
          <listitem>
           <para>
            Number of key bits used by the encryption algorithm.
           </para>
          </listitem>
         </varlistentry>
        <varlistentry>
         <term><literal>cipher</literal></term>
          <listitem>
           <para>
            A short name of the ciphersuite used, e.g.
            <literal>"DHE-RSA-DES-CBC3-SHA"</literal>. The names are specific
            to each SSL implementation.
           </para>
          </listitem>
         </varlistentry>
        <varlistentry>
         <term><literal>compression</literal></term>
          <listitem>
           <para>
            If SSL compression is in use, returns the name of the compression
            algorithm, or "on" if compression is used but the algorithm is
            not known. If compression is not in use, returns "off".
           </para>
          </listitem>
         </varlistentry>
       </variablelist>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsslattributenames">
     <term><function>PQsslAttributeNames</function><indexterm><primary>PQsslAttributeNames</></></term>
     <listitem>
      <para>
       Return an array of SSL attribute names available. The array is terminated by a NULL pointer.
<synopsis>
const char * const * PQsslAttributeNames(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsslstruct">
     <term><function>PQsslStruct</function><indexterm><primary>PQsslStruct</></></term>
     <listitem>
      <para>
       Return a pointer to an SSL-implementation-specific object describing
       the connection.
<synopsis>
void *PQsslStruct(const PGconn *conn, const char *struct_name);
</synopsis>
      </para>
      <para>
       The struct(s) available depend on the SSL implementation in use.
       For OpenSSL, there is one struct, available under the name "OpenSSL",
       and it returns a pointer to the OpenSSL <literal>SSL</literal> struct.
       To use this function, code along the following lines could be used:
<programlisting><![CDATA[
#include <libpq-fe.h>
#include <openssl/ssl.h>

...

    SSL *ssl;

    dbconn = PQconnectdb(...);
    ...

    ssl = PQsslStruct(dbconn, "OpenSSL");
    if (ssl)
    {
        /* use OpenSSL functions to access ssl */
    }
]]></programlisting>
      </para>
      <para>
       This structure can be used to verify encryption levels, check server
       certificates, and more. Refer to the <productname>OpenSSL</>
       documentation for information about this structure.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqgetssl">
     <term><function>PQgetssl</function><indexterm><primary>PQgetssl</></></term>
     <listitem>
      <para>
       <indexterm><primary>SSL</><secondary sortas="libpq">in libpq</secondary></indexterm>
       Returns the SSL structure used in the connection, or null
       if SSL is not in use.

<synopsis>
void *PQgetssl(const PGconn *conn);
</synopsis>
      </para>

      <para>
       This function is equivalent to <literal>PQsslStruct(conn, "OpenSSL")</literal>. It should
       not be used in new applications, because the returned struct is
       specific to OpenSSL and will not be available if another SSL
       implementation is used. To check if a connection uses SSL, call
       <function>PQsslInUse</> instead, and for more details about the
       connection, use <function>PQsslAttribute</>.
      </para>
     </listitem>
    </varlistentry>

   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
    以下函数返回与SSL相关的信息。此信息通常在连接建立后不会更改。

    <variablelist>
    <varlistentry id="libpq-pqsslinuse">
     <term><function>PQsslInUse</function><indexterm><primary>PQsslInUse</></></term>
     <listitem>
      <para>
        如果连接使用SSL，则返回true（1），否则返回false（0）。
<synopsis>
int PQsslInUse(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsslattribute">
     <term><function>PQsslAttribute</function><indexterm><primary>PQsslAttribute</></></term>
     <listitem>
      <para>
        返回关于连接的SSL相关的信息。

<synopsis>
const char *PQsslAttribute(const PGconn *conn, const char *attribute_name);
</synopsis>
      </para>
      
      <para>
       可用属性的列表因使用的SSL库和连接类型而异。如果某个属性不可用，则返回NULL。
      </para>

      <para>
       以下属性通常可用：
       <variablelist>
        <varlistentry>
         <term><literal>library</literal></term>
          <listitem>
           <para>
            正在使用的SSL实现的名称。(目前，只实现了<literal>"OpenSSL"</literal>)
           </para>
          </listitem>
         </varlistentry>
        <varlistentry>
         <term><literal>protocol</literal></term>
          <listitem>
           <para>
             正在使用的SSL/TLS版本。常见值为<literal>"TLSv1"</literal>、
             <literal>"TLSv1.1"</literal>和<literal>"TLSv1.2"</literal>，
             但如果使用某些其他协议，实现可能返回其他字符串。
           </para>
          </listitem>
         </varlistentry>
        <varlistentry>
         <term><literal>key_bits</literal></term>
          <listitem>
           <para>
            加密算法使用的密钥位数。
           </para>
          </listitem>
         </varlistentry>
        <varlistentry>
         <term><literal>cipher</literal></term>
          <listitem>
           <para>
            使用的密码组的短名称，例如<literal>"DHE-RSA-DES-CBC3-SHA"</literal>。
            这些名称特定于每个SSL实现的。
           </para>
          </listitem>
         </varlistentry>
        <varlistentry>
         <term><literal>compression</literal></term>
          <listitem>
           <para>
            如果正在使用SSL压缩，则返回压缩算法的名称，如果使用了压缩但不知道算法，
            则为“on”。如果不使用压缩，则返回“off”。
           </para>
          </listitem>
         </varlistentry>
       </variablelist>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsslattributenames">
     <term><function>PQsslAttributeNames</function><indexterm><primary>PQsslAttributeNames</></></term>
     <listitem>
      <para>
       返回可用的SSL属性名称数组。该数组由NULL指针终止。
<synopsis>
const char * const * PQsslAttributeNames(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsslstruct">
     <term><function>PQsslStruct</function><indexterm><primary>PQsslStruct</></></term>
     <listitem>
      <para>
       返回指向描述连接的特定于SSL实现的对象的指针。
<synopsis>
void *PQsslStruct(const PGconn *conn, const char *struct_name);
</synopsis>
      </para>
      <para>
       可用的结构取决于正在使用的SSL实现。对于OpenSSL，有一个结构，
       可用名称为“OpenSSL”，它返回一个指向OpenSSL <literal>SSL</literal>结构的指针。
       要使用这个函数，可以使用下列代码：

<programlisting><![CDATA[
#include <libpq-fe.h>
#include <openssl/ssl.h>

...

    SSL *ssl;

    dbconn = PQconnectdb(...);
    ...

    ssl = PQsslStruct(dbconn, "OpenSSL");
    if (ssl)
    {
        /* use OpenSSL functions to access ssl */
    }
]]></programlisting>
      </para>
      <para>
       这个结构可以被用来验证加密级别、检查服务器证书等等。
       关于这个结构可参考<productname>OpenSSL</>文档。
      </para>
     </listitem>
    </varlistentry>
    
    <varlistentry id="libpq-pqgetssl">
     <term><function>PQgetssl</function><indexterm><primary>PQgetssl</></></term>
     <listitem>
      <para>
       <indexterm><primary>SSL</><secondary sortas="libpq">in libpq</secondary></indexterm>
       返回在连接中使用的 SSL 结构，如果没有使用 SSL 则返回空。

<synopsis>
void *PQgetssl(const PGconn *conn);
</synopsis>
      </para>

      <para>
       此函数等效于<literal>PQsslStruct(conn, "OpenSSL")</literal>。
       它不应该在新的应用程序中使用，因为返回的结构是特定于OpenSSL的，
       并且如果使用了另一个SSL实现则返回的结构将不可用。要检查一个连接是否使用了SSL，
       请调用<function>PQsslInUse</>，有关连接的更多详细信息，
       请使用<function>PQsslAttribute</>。
      </para>
     </listitem>
    </varlistentry>

   </variablelist>
  </para>

 </sect1>

 <sect1 id="libpq-exec">
<!--==========================orignal english content==========================
  <title>Command Execution Functions</title>
____________________________________________________________________________-->
  <title>命令执行函数</title>

<!--==========================orignal english content==========================
  <para>
   Once a connection to a database server has been successfully
   established, the functions described here are used to perform
   SQL queries and commands.
  </para>
____________________________________________________________________________-->
  <para>
   一旦到一个数据库服务器的连接被成功建立，这里描述的函数可以被用来执行 SQL 查询和命令。
  </para>

  <sect2 id="libpq-exec-main">
<!--==========================orignal english content==========================
   <title>Main Functions</title>
____________________________________________________________________________-->
   <title>主要函数</title>

<!--==========================orignal english content==========================
   <para>
    <variablelist>
     <varlistentry id="libpq-pqexec">
      <term>
       <function>PQexec</function>
       <indexterm>
        <primary>PQexec</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
        Submits a command to the server and waits for the result.

<synopsis>
PGresult *PQexec(PGconn *conn, const char *command);
</synopsis>
       </para>

       <para>
        Returns a <structname>PGresult</structname> pointer or possibly a null
        pointer.  A non-null pointer will generally be returned except in
        out-of-memory conditions or serious errors such as inability to send
        the command to the server.  The <function>PQresultStatus</> function
        should be called to check the return value for any errors (including
        the value of a null pointer, in which case it will return
        <symbol>PGRES_FATAL_ERROR</symbol>).  Use
        <function>PQerrorMessage</function> to get more information about such
        errors.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    The command string can include multiple SQL commands
    (separated by semicolons).  Multiple queries sent in a single
    <function>PQexec</> call are processed in a single transaction, unless
    there are explicit <command>BEGIN</command>/<command>COMMIT</command>
    commands included in the query string to divide it into multiple
    transactions.  Note however that the returned
    <structname>PGresult</structname> structure describes only the result
    of the last command executed from the string.  Should one of the
    commands fail, processing of the string stops with it and the returned
    <structname>PGresult</structname> describes the error condition.
   </para>
____________________________________________________________________________-->
   <para>
    <variablelist>
     <varlistentry id="libpq-pqexec">
      <term>
       <function>PQexec</function>
       <indexterm>
        <primary>PQexec</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
        提交一个命令给服务器并且等待结果。

<synopsis>
PGresult *PQexec(PGconn *conn, const char *command);
</synopsis>
       </para>

       <para>
        返回一个<structname>PGresult</structname>指针或者可能是一个空指针。除了内存不足的情况或者由于严重错误无法将命令发送给服务器之外，一般都会返回一个非空指针。<function>PQresultStatus</>函数应当被调用来检查返回值是否代表错误（包括空指针的值，它会返回<symbol>PGRES_FATAL_ERROR</symbol>）。用<function>PQerrorMessage</function>可得到关于那些错误的详细信息。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    命令字符串可以包括多个 SQL 命令（用分号分隔）。在一次<function>PQexec</>调用中被发送的多个查询会在一个事务中处理，除非其中有显式的<command>BEGIN</command>/<command>COMMIT</command>命令将该查询字符串划分成多个事务。但是注意，返回的<structname>PGresult</structname>结构只描述该字符串中被执行的最后一个命令的结果。如果一个命令失败，该字符串的处理会在它那里停止并且返回的<structname>PGresult</structname>会描述错误情况。
   </para>

<!--==========================orignal english content==========================
   <para>
    <variablelist>
     <varlistentry id="libpq-pqexecparams">
      <term>
       <function>PQexecParams</function>
       <indexterm>
        <primary>PQexecParams</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
        Submits a command to the server and waits for the result,
        with the ability to pass parameters separately from the SQL
        command text.

<synopsis>
PGresult *PQexecParams(PGconn *conn,
                       const char *command,
                       int nParams,
                       const Oid *paramTypes,
                       const char * const *paramValues,
                       const int *paramLengths,
                       const int *paramFormats,
                       int resultFormat);
</synopsis>
       </para>

       <para>
        <function>PQexecParams</> is like <function>PQexec</>, but offers additional
        functionality: parameter values can be specified separately from the command
        string proper, and query results can be requested in either text or binary
        format.  <function>PQexecParams</> is supported only in protocol 3.0 and later
        connections; it will fail when using protocol 2.0.
       </para>

       <para>
        The function arguments are:

        <variablelist>
         <varlistentry>
          <term><parameter>conn</parameter></term>

          <listitem>
           <para>
            The connection object to send the command through.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>command</parameter></term>
          <listitem>
           <para>
            The SQL command string to be executed. If parameters are used,
            they are referred to in the command string as <literal>$1</>,
            <literal>$2</>, etc.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>nParams</parameter></term>
          <listitem>
           <para>
            The number of parameters supplied; it is the length of the arrays
            <parameter>paramTypes[]</>, <parameter>paramValues[]</>,
            <parameter>paramLengths[]</>, and <parameter>paramFormats[]</>. (The
            array pointers can be <symbol>NULL</symbol> when <parameter>nParams</>
            is zero.)
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>paramTypes[]</parameter></term>
          <listitem>
           <para>
            Specifies, by OID, the data types to be assigned to the
            parameter symbols.  If <parameter>paramTypes</> is
            <symbol>NULL</symbol>, or any particular element in the array
            is zero, the server infers a data type for the parameter symbol
            in the same way it would do for an untyped literal string.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>paramValues[]</parameter></term>
          <listitem>
           <para>
            Specifies the actual values of the parameters.  A null pointer
            in this array means the corresponding parameter is null;
            otherwise the pointer points to a zero-terminated text string
            (for text format) or binary data in the format expected by the
            server (for binary format).
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>paramLengths[]</parameter></term>
          <listitem>
           <para>
            Specifies the actual data lengths of binary-format parameters.
            It is ignored for null parameters and text-format parameters.
            The array pointer can be null when there are no binary parameters.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>paramFormats[]</parameter></term>
          <listitem>
           <para>
            Specifies whether parameters are text (put a zero in the
            array entry for the corresponding parameter) or binary (put
            a one in the array entry for the corresponding parameter).
            If the array pointer is null then all parameters are presumed
            to be text strings.
           </para>
           <para>
            Values passed in binary format require knowledge of
            the internal representation expected by the backend.
            For example, integers must be passed in network byte
            order.  Passing <type>numeric</> values requires
            knowledge of the server storage format, as implemented
            in
            <filename>src/backend/utils/adt/numeric.c::numeric_send()</> and
            <filename>src/backend/utils/adt/numeric.c::numeric_recv()</>.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>resultFormat</parameter></term>
          <listitem>
           <para>
            Specify zero to obtain results in text format, or one to obtain
            results in binary format.  (There is not currently a provision
            to obtain different result columns in different formats,
            although that is possible in the underlying protocol.)
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    <variablelist>
     <varlistentry id="libpq-pqexecparams">
      <term>
       <function>PQexecParams</function>
       <indexterm>
        <primary>PQexecParams</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
        提交一个命令给服务器并且等待结果，它可以在 SQL 命令文本之外独立地传递参数。

<synopsis>
PGresult *PQexecParams(PGconn *conn,
                       const char *command,
                       int nParams,
                       const Oid *paramTypes,
                       const char * const *paramValues,
                       const int *paramLengths,
                       const int *paramFormats,
                       int resultFormat);
</synopsis>
       </para>

       <para>
        <function>PQexecParams</>与<function>PQexec</>相似，但是提供了额外的功能：参数值可以与命令字符串分开指定，并且可以以文本或二进制格式请求查询结果。<function>PQexecParams</>只在 3.0 协议及其后的连接中被支持，当使用 2.0 协议时它会失败。
       </para>

       <para>
        该函数的参数是：

        <variablelist>
         <varlistentry>
          <term><parameter>conn</parameter></term>

          <listitem>
           <para>
            要在其中发送命令的连接对象。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>command</parameter></term>
          <listitem>
           <para>
            要执行的 SQL 命令字符串。如果使用了参数，它们在该命令字符串中被引用为<literal>$1</>、<literal>$2</>等。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>nParams</parameter></term>
          <listitem>
           <para>
            提供的参数数量。它是数组<parameter>paramTypes[]</>、<parameter>paramValues[]</>、<parameter>paramLengths[]</>和<parameter>paramFormats[]</>的长度（当<parameter>nParams</>为零时，数组指针可以是<symbol>NULL</symbol>）。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>paramTypes[]</parameter></term>
          <listitem>
           <para>
            通过 OID 指定要赋予给参数符号的数据类型。如果<parameter>paramTypes</>为<symbol>NULL</symbol>或者该数组中任何特定元素为零，服务器会用对待未知类型文字串的方式为参数符号推测一种数据类型。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>paramValues[]</parameter></term>
          <listitem>
           <para>
            指定参数的实际值。这个数组中的一个空指针表示对应的参数为空，否则该指针指向一个以零终止的文本字符串（用于文本格式）或者以服务器所期待格式的二进制数据（用于二进制格式）。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>paramLengths[]</parameter></term>
          <listitem>
           <para>
            指定二进制格式参数的实际数据长度。它对空参数和文本格式参数被忽略。当没有二进制参数时，该数组指针可以为空。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>paramFormats[]</parameter></term>
          <listitem>
           <para>
            指定参数是否为文本（在参数相应的数组项中放一个零）或二进制（在参数相应的数组项中放一个一）。如果该数组指针为空，那么所有参数都会被假定为文本串。
           </para>
           <para>
            以二进制格式传递的值要求后端所期待的内部表示形式的知识。例如，整数必须以网络字节序被传递。传递<type>numeric</>值要求关于服务器存储格式的知识，正如<filename>src/backend/utils/adt/numeric.c::numeric_send()</>以及<filename>src/backend/utils/adt/numeric.c::numeric_recv()</>中所实现的。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>resultFormat</parameter></term>
          <listitem>
           <para>
            指定零来得到文本格式的结果，或者指定一来得到二进制格式的结果（目前没有规定要求以不同格式得到不同的结果列，尽管在底层协议中这是可以实现的）。
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

<!--==========================orignal english content==========================
   <para>
    The primary advantage of <function>PQexecParams</> over
    <function>PQexec</> is that parameter values can be separated from the
    command string, thus avoiding the need for tedious and error-prone
    quoting and escaping.
   </para>
____________________________________________________________________________-->
   <para>
    <function>PQexecParams</>相对于<function>PQexec</>的主要优点是参数值可以从命令串中分离，因此避免了冗长的书写、容易发生错误的引用以及转义。
   </para>

<!--==========================orignal english content==========================
   <para>
    Unlike <function>PQexec</>, <function>PQexecParams</> allows at most
    one SQL command in the given string.  (There can be semicolons in it,
    but not more than one nonempty command.)  This is a limitation of the
    underlying protocol, but has some usefulness as an extra defense against
    SQL-injection attacks.
   </para>
____________________________________________________________________________-->
   <para>
    和<function>PQexec</>不同，<function>PQexecParams</>至多允许在给定串中出现一个 SQL 命令（其中可以有分号，但是不能有超过一个非空命令）。这是底层协议的一个限制，但是有助于抵抗 SQL 注入攻击。
   </para>

   <tip>
<!--==========================orignal english content==========================
    <para>
     Specifying parameter types via OIDs is tedious, particularly if you prefer
     not to hard-wire particular OID values into your program.  However, you can
     avoid doing so even in cases where the server by itself cannot determine the
     type of the parameter, or chooses a different type than you want.  In the
     SQL command text, attach an explicit cast to the parameter symbol to show what
     data type you will send.  For example:
<programlisting>
SELECT * FROM mytable WHERE x = $1::bigint;
</programlisting>
     This forces parameter <literal>$1</> to be treated as <type>bigint</>, whereas
     by default it would be assigned the same type as <literal>x</>.  Forcing the
     parameter type decision, either this way or by specifying a numeric type OID,
     is strongly recommended when sending parameter values in binary format, because
     binary format has less redundancy than text format and so there is less chance
     that the server will detect a type mismatch mistake for you.
    </para>
____________________________________________________________________________-->
    <para>
     通过 OID 指定参数类型很罗嗦，特别是如果你不愿意将特定的 OID 值硬编码到你的程序中时。不过，即使服务器本身也无法确定参数的类型，你可以避免这样做，或者选择一种与你想要的不同的类型。在 SQL 命令文本中，附加一个显式造型给参数符号来表示你将发送什么样的数据类型。例如：
<programlisting>
SELECT * FROM mytable WHERE x = $1::bigint;
</programlisting>
     这强制参数<literal>$1</>被当作<type>bigint</>，而默认情况下它将被赋予与<literal>x</>相同的类型。当以二进制格式发送参数值时，我们强烈推荐以这种方式或通过指定一个数字类型的 OID 来强制参数类型决定。因为二进制格式比文本格式具有更少的冗余，并且因此服务器将不会有更多机会为你检测一个类型匹配错误。
    </para>
   </tip>

<!--==========================orignal english content==========================
   <para>
    <variablelist>
     <varlistentry id="libpq-pqprepare">
      <term><function>PQprepare</function>
       <indexterm>
        <primary>PQprepare</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
        Submits a request to create a prepared statement with the
        given parameters, and waits for completion.
<synopsis>
PGresult *PQprepare(PGconn *conn,
                    const char *stmtName,
                    const char *query,
                    int nParams,
                    const Oid *paramTypes);
</synopsis>
       </para>

       <para>
        <function>PQprepare</> creates a prepared statement for later
        execution with <function>PQexecPrepared</>.  This feature allows
        commands to be executed repeatedly without being parsed and
        planned each time;  see <xref linkend="SQL-PREPARE"> for details.
        <function>PQprepare</> is supported only in protocol 3.0 and later
        connections; it will fail when using protocol 2.0.
       </para>

       <para>
        The function creates a prepared statement named
        <parameter>stmtName</> from the <parameter>query</> string, which
        must contain a single SQL command.  <parameter>stmtName</> can be
        <literal>""</> to create an unnamed statement, in which case any
        pre-existing unnamed statement is automatically replaced; otherwise
        it is an error if the statement name is already defined in the
        current session.  If any parameters are used, they are referred
        to in the query as <literal>$1</>, <literal>$2</>, etc.
        <parameter>nParams</> is the number of parameters for which types
        are pre-specified in the array <parameter>paramTypes[]</>.  (The
        array pointer can be <symbol>NULL</symbol> when
        <parameter>nParams</> is zero.) <parameter>paramTypes[]</>
        specifies, by OID, the data types to be assigned to the parameter
        symbols.  If <parameter>paramTypes</> is <symbol>NULL</symbol>,
        or any particular element in the array is zero, the server assigns
        a data type to the parameter symbol in the same way it would do
        for an untyped literal string.  Also, the query can use parameter
        symbols with numbers higher than <parameter>nParams</>; data types
        will be inferred for these symbols as well.  (See
        <function>PQdescribePrepared</function> for a means to find out
        what data types were inferred.)
       </para>

       <para>
        As with <function>PQexec</>, the result is normally a
        <structname>PGresult</structname> object whose contents indicate
        server-side success or failure.  A null result indicates
        out-of-memory or inability to send the command at all.  Use
        <function>PQerrorMessage</function> to get more information about
        such errors.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    Prepared statements for use with <function>PQexecPrepared</> can also
    be created by executing SQL <xref linkend="sql-prepare">
    statements.  Also, although there is no <application>libpq</>
    function for deleting a prepared statement, the SQL <xref
    linkend="sql-deallocate"> statement
    can be used for that purpose.
   </para>
____________________________________________________________________________-->
   <para>
    <variablelist>
     <varlistentry id="libpq-pqprepare">
      <term><function>PQprepare</function>
       <indexterm>
        <primary>PQprepare</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
        提交一个请求用给定参数创建一个预备语句并且等待完成。
<synopsis>
PGresult *PQprepare(PGconn *conn,
                    const char *stmtName,
                    const char *query,
                    int nParams,
                    const Oid *paramTypes);
</synopsis>
       </para>

       <para>
        <function>PQprepare</>创建一个后面会由<function>PQexecPrepared</>执行的预备语句。这种特性允许将被反复执行的命令只被解析和规划一次，而不是在每次被执行时都解析和规划。<function>PQprepare</>只在协议 3.0 及之后的连接中被支持，当使用协议 2.0 时它将失败。
       </para>

       <para>
        该函数从<parameter>query</>串创建一个名为<parameter>stmtName</>的预备语句，该串必须包含一个单一 SQL 命令。<parameter>stmtName</>可以是<literal>""</>来创建一个未命名语句，在这种情况下任何已存在未命名语句将被自动替换。如果语句名称已经在当前会话中被定义，则是一种错误。如果使用了任何参数，它们在查询中以<literal>$1</>、<literal>$2</>等引用。<parameter>nParams</>是参数的个数，其类型在数组<parameter>paramTypes[]</>中被预先指定（当<parameter>nParams</>为零时，该数组指针可以是<symbol>NULL</symbol>）。<parameter>paramTypes[]</>通过 OID 指定要赋予给参数符号的数据类型。如果<parameter>paramTypes</>是<symbol>NULL</symbol>或者该数组中任何特定元素为零，服务器会用对待未知类型文字串的方式为参数符号推测一种数据类型。还有，查询能够使用编号高于<parameter>nParams</>的参数符号，它们的数据类型也会被自动推测（找出推测出的数据类型的方法见<function>PQdescribePrepared</function>）。
       </para>

       <para>
        正如<function>PQexec</>一样，结果通常是一个<structname>PGresult</structname>对象，其内容代表服务器端成功或失败。一个空结果表示内存不足或者根本无法发送命令。关于错误的更多信息请见<function>PQerrorMessage</function>。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    用于<function>PQexecPrepared</>的预备语句也能通过执行 SQL <xref linkend="sql-prepare">语句来创建。还有，尽管没有<application>libpq</>函数来删除一个预备语句，SQL <xref linkend="sql-deallocate">语句可被用于此目的。
   </para>

<!--==========================orignal english content==========================
   <para>
    <variablelist>
     <varlistentry id="libpq-pqexecprepared">
      <term>
       <function>PQexecPrepared</function>
       <indexterm>
        <primary>PQexecPrepared</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
        Sends a request to execute a prepared statement with given
        parameters, and waits for the result.
<synopsis>
PGresult *PQexecPrepared(PGconn *conn,
                         const char *stmtName,
                         int nParams,
                         const char * const *paramValues,
                         const int *paramLengths,
                         const int *paramFormats,
                         int resultFormat);
</synopsis>
       </para>

       <para>
        <function>PQexecPrepared</> is like <function>PQexecParams</>,
        but the command to be executed is specified by naming a
        previously-prepared statement, instead of giving a query string.
        This feature allows commands that will be used repeatedly to be
        parsed and planned just once, rather than each time they are
        executed.  The statement must have been prepared previously in
        the current session.  <function>PQexecPrepared</> is supported
        only in protocol 3.0 and later connections; it will fail when
        using protocol 2.0.
       </para>

       <para>
        The parameters are identical to <function>PQexecParams</>, except that the
        name of a prepared statement is given instead of a query string, and the
        <parameter>paramTypes[]</> parameter is not present (it is not needed since
        the prepared statement's parameter types were determined when it was created).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqdescribeprepared">
      <term>
       <function>PQdescribePrepared</function>
       <indexterm>
        <primary>PQdescribePrepared</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
        Submits a request to obtain information about the specified
        prepared statement, and waits for completion.
<synopsis>
PGresult *PQdescribePrepared(PGconn *conn, const char *stmtName);
</synopsis>
       </para>

       <para>
        <function>PQdescribePrepared</> allows an application to obtain
        information about a previously prepared statement.
        <function>PQdescribePrepared</> is supported only in protocol 3.0
        and later connections; it will fail when using protocol 2.0.
       </para>

       <para>
        <parameter>stmtName</> can be <literal>""</> or <symbol>NULL</> to reference
        the unnamed statement, otherwise it must be the name of an existing
        prepared statement.  On success, a <structname>PGresult</> with
        status <literal>PGRES_COMMAND_OK</literal> is returned.  The
        functions <function>PQnparams</function> and
        <function>PQparamtype</function> can be applied to this
        <structname>PGresult</> to obtain information about the parameters
        of the prepared statement, and the functions
        <function>PQnfields</function>, <function>PQfname</function>,
        <function>PQftype</function>, etc provide information about the
        result columns (if any) of the statement.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqdescribeportal">
      <term>
       <function>PQdescribePortal</function>
       <indexterm>
        <primary>PQdescribePortal</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
        Submits a request to obtain information about the specified
        portal, and waits for completion.
<synopsis>
PGresult *PQdescribePortal(PGconn *conn, const char *portalName);
</synopsis>
       </para>

       <para>
        <function>PQdescribePortal</> allows an application to obtain
        information about a previously created portal.
        (<application>libpq</> does not provide any direct access to
        portals, but you can use this function to inspect the properties
        of a cursor created with a <command>DECLARE CURSOR</> SQL command.)
        <function>PQdescribePortal</> is supported only in protocol 3.0
        and later connections; it will fail when using protocol 2.0.
       </para>

       <para>
        <parameter>portalName</> can be <literal>""</> or <symbol>NULL</> to reference
        the unnamed portal, otherwise it must be the name of an existing
        portal.  On success, a <structname>PGresult</> with status
        <literal>PGRES_COMMAND_OK</literal> is returned.  The functions
        <function>PQnfields</function>, <function>PQfname</function>,
        <function>PQftype</function>, etc can be applied to the
        <structname>PGresult</> to obtain information about the result
        columns (if any) of the portal.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    <variablelist>
     <varlistentry id="libpq-pqexecprepared">
      <term>
       <function>PQexecPrepared</function>
       <indexterm>
        <primary>PQexecPrepared</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
        发送一个请求来用给定参数执行一个预备语句，并且等待结果。
<synopsis>
PGresult *PQexecPrepared(PGconn *conn,
                         const char *stmtName,
                         int nParams,
                         const char * const *paramValues,
                         const int *paramLengths,
                         const int *paramFormats,
                         int resultFormat);
</synopsis>
       </para>

       <para>
        <function>PQexecPrepared</>像<function>PQexecParams</>，但是要被执行的命令是用之前准备的语句的名字指定，而不是指定一个查询串。这个特性允许将被重复使用的命令只被解析和规划一次，而不是在每次被执行时都被解析和规划。这个语句必须之前在当前会话中已经被准备好。<function>PQexecPrepared</>仅被协议 3.0 及之后的连接支持，当使用协议 2.0 时它会失败。
       </para>

       <para>
        参数和<function>PQexecParams</>相同，除了给定的是一个预备语句的名称而不是一个查询语句，以及不存在<parameter>paramTypes[]</>参数（因为预备语句的参数类型已经在它被创建时决定好了）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqdescribeprepared">
      <term>
       <function>PQdescribePrepared</function>
       <indexterm>
        <primary>PQdescribePrepared</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
        提交一个请求来获得有关指定预备语句的信息，并且等待完成。
<synopsis>
PGresult *PQdescribePrepared(PGconn *conn, const char *stmtName);
</synopsis>
       </para>

       <para>
        <function>PQdescribePrepared</>允许一个应用获得有关一个之前预备好的语句的信息。<function>PQdescribePrepared</>仅被协议 3.0 及之后的连接支持，当使用协议 2.0 时它会失败。
       </para>

       <para>
        <parameter>stmtName</>可以用<literal>""</>或者<symbol>NULL</>来引用未命名语句，否则它必须是一个现有预备语句的名字。如果成功，一个<structname>PGresult</>以及状态<literal>PGRES_COMMAND_OK</literal>会被返回。函数<function>PQnparams</function>和<function>PQparamtype</function>可以被应用到这个<structname>PGresult</>来得到关于该预备语句参数的额外信息，而函数<function>PQnfields</function>、<function>PQfname</function>、<function>PQftype</function>等提供该语句结果列（如果有）的信息。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqdescribeportal">
      <term>
       <function>PQdescribePortal</function>
       <indexterm>
        <primary>PQdescribePortal</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
        提交一个请求来得到有关指定入口的信息，并且等待完成。
<synopsis>
PGresult *PQdescribePortal(PGconn *conn, const char *portalName);
</synopsis>
       </para>

       <para>
        <function>PQdescribePortal</>允许一个应用获得有关一个之前被创建的入口的信息（<application>libpq</>不提供对入口任何直接的访问，但是你可以使用这个函数来观察一个通过<command>DECLARE CURSOR</> SQL 命令创建的游标的属性）。<function>PQdescribePortal</>仅被协议 3.0 及之后的连接支持，当使用协议 2.0 时它会失败。
       </para>

       <para>
        <parameter>portalName</>可以用<literal>""</>或者<symbol>NULL</>来引用未命名入口，否则它必须是一个现有入口的名字。如果成功，一个<structname>PGresult</>和状态<literal>PGRES_COMMAND_OK</literal>会被返回。函数<function>PQnfields</function>、<function>PQfname</function>、<function>PQftype</function>等可以被应用到<structname>PGresult</>来获得有关该入口结果列（如果有）的信息。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

<!--==========================orignal english content==========================
   <para>
    The <structname>PGresult</structname><indexterm><primary>PGresult</></>
    structure encapsulates the result returned by the server.
    <application>libpq</application> application programmers should be
    careful to maintain the <structname>PGresult</structname> abstraction.
    Use the accessor functions below to get at the contents of
    <structname>PGresult</structname>.  Avoid directly referencing the
    fields of the <structname>PGresult</structname> structure because they
    are subject to change in the future.

    <variablelist>
     <varlistentry id="libpq-pqresultstatus">
      <term>
       <function>PQresultStatus</function>
       <indexterm>
        <primary>PQresultStatus</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
        Returns the result status of the command.
<synopsis>
ExecStatusType PQresultStatus(const PGresult *res);
</synopsis>
       </para>

       <para>
        <function>PQresultStatus</function> can return one of the following values:

        <variablelist>
         <varlistentry id="libpq-pgres-empty-query">
          <term><literal>PGRES_EMPTY_QUERY</literal></term>
          <listitem>
           <para>
            The string sent to the server was empty.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-command-ok">
          <term><literal>PGRES_COMMAND_OK</literal></term>
          <listitem>
           <para>
            Successful completion of a command returning no data.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-tuples-ok">
          <term><literal>PGRES_TUPLES_OK</literal></term>
          <listitem>
           <para>
            Successful completion of a command returning data (such as
            a <command>SELECT</> or <command>SHOW</>).
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-copy-out">
          <term><literal>PGRES_COPY_OUT</literal></term>
          <listitem>
           <para>
            Copy Out (from server) data transfer started.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-copy-in">
          <term><literal>PGRES_COPY_IN</literal></term>
          <listitem>
           <para>
            Copy In (to server) data transfer started.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-bad-response">
          <term><literal>PGRES_BAD_RESPONSE</literal></term>
          <listitem>
           <para>
            The server's response was not understood.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-nonfatal-error">
          <term><literal>PGRES_NONFATAL_ERROR</literal></term>
          <listitem>
           <para>
            A nonfatal error (a notice or warning) occurred.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-fatal-error">
          <term><literal>PGRES_FATAL_ERROR</literal></term>
          <listitem>
           <para>
            A fatal error occurred.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-copy-both">
          <term><literal>PGRES_COPY_BOTH</literal></term>
          <listitem>
           <para>
            Copy In/Out (to and from server) data transfer started.  This
            feature is currently used only for streaming replication,
            so this status should not occur in ordinary applications.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-single-tuple">
          <term><literal>PGRES_SINGLE_TUPLE</literal></term>
          <listitem>
           <para>
            The <structname>PGresult</> contains a single result tuple
            from the current command.  This status occurs only when
            single-row mode has been selected for the query
            (see <xref linkend="libpq-single-row-mode">).
           </para>
          </listitem>
         </varlistentry>
        </variablelist>

        If the result status is <literal>PGRES_TUPLES_OK</literal> or
        <literal>PGRES_SINGLE_TUPLE</literal>, then
        the functions described below can be used to retrieve the rows
        returned by the query.  Note that a <command>SELECT</command>
        command that happens to retrieve zero rows still shows
        <literal>PGRES_TUPLES_OK</literal>.
        <literal>PGRES_COMMAND_OK</literal> is for commands that can never
        return rows (<command>INSERT</command> or <command>UPDATE</command>
        without a <literal>RETURNING</literal> clause,
        etc.). A response of <literal>PGRES_EMPTY_QUERY</literal> might
        indicate a bug in the client software.
       </para>

       <para>
        A result of status <symbol>PGRES_NONFATAL_ERROR</symbol> will
        never be returned directly by <function>PQexec</function> or other
        query execution functions; results of this kind are instead passed
        to the notice processor (see <xref
        linkend="libpq-notice-processing">).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqresstatus">
      <term>
       <function>PQresStatus</function>
       <indexterm>
        <primary>PQresStatus</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
        Converts the enumerated type returned by
        <function>PQresultStatus</> into a string constant describing the
        status code. The caller should not free the result.

<synopsis>
char *PQresStatus(ExecStatusType status);
</synopsis>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqresulterrormessage">
      <term>
       <function>PQresultErrorMessage</function>
       <indexterm>
        <primary>PQresultErrorMessage</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
        Returns the error message associated with the command, or an empty string
        if there was no error.
<synopsis>
char *PQresultErrorMessage(const PGresult *res);
</synopsis>
        If there was an error, the returned string will include a trailing
        newline.  The caller should not free the result directly. It will
        be freed when the associated <structname>PGresult</> handle is
        passed to <function>PQclear</function>.
       </para>

       <para>
        Immediately following a <function>PQexec</function> or
        <function>PQgetResult</function> call,
        <function>PQerrorMessage</function> (on the connection) will return
        the same string as <function>PQresultErrorMessage</function> (on
        the result).  However, a <structname>PGresult</structname> will
        retain its error message until destroyed, whereas the connection's
        error message will change when subsequent operations are done.
        Use <function>PQresultErrorMessage</function> when you want to
        know the status associated with a particular
        <structname>PGresult</structname>; use
        <function>PQerrorMessage</function> when you want to know the
        status from the latest operation on the connection.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqresultverboseerrormessage">
      <term>
       <function>PQresultVerboseErrorMessage</function>
       <indexterm>
        <primary>PQresultVerboseErrorMessage</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
        Returns a reformatted version of the error message associated with
        a <structname>PGresult</> object.
<synopsis>
char *PQresultVerboseErrorMessage(const PGresult *res,
                                  PGVerbosity verbosity,
                                  PGContextVisibility show_context);
</synopsis>
        In some situations a client might wish to obtain a more detailed
        version of a previously-reported error.
        <function>PQresultVerboseErrorMessage</function> addresses this need
        by computing the message that would have been produced
        by <function>PQresultErrorMessage</function> if the specified
        verbosity settings had been in effect for the connection when the
        given <structname>PGresult</> was generated.  If
        the <structname>PGresult</> is not an error result,
        <quote>PGresult is not an error result</> is reported instead.
        The returned string includes a trailing newline.
       </para>

       <para>
        Unlike most other functions for extracting data from
        a <structname>PGresult</>, the result of this function is a freshly
        allocated string.  The caller must free it
        using <function>PQfreemem()</> when the string is no longer needed.
       </para>

       <para>
        A NULL return is possible if there is insufficient memory.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqresulterrorfield">
      <term><function>PQresultErrorField</function><indexterm><primary>PQresultErrorField</></></term>
      <listitem>
       <para>
        Returns an individual field of an error report.
<synopsis>
char *PQresultErrorField(const PGresult *res, int fieldcode);
</synopsis>
        <parameter>fieldcode</> is an error field identifier; see the symbols
        listed below.  <symbol>NULL</symbol> is returned if the
        <structname>PGresult</structname> is not an error or warning result,
        or does not include the specified field.  Field values will normally
        not include a trailing newline. The caller should not free the
        result directly. It will be freed when the
        associated <structname>PGresult</> handle is passed to
        <function>PQclear</function>.
       </para>

       <para>
        The following field codes are available:
        <variablelist>
         <varlistentry id="libpq-pg-diag-severity">
          <term><symbol>PG_DIAG_SEVERITY</></term>
          <listitem>
           <para>
            The severity; the field contents are <literal>ERROR</>,
            <literal>FATAL</>, or <literal>PANIC</> (in an error message),
            or <literal>WARNING</>, <literal>NOTICE</>, <literal>DEBUG</>,
            <literal>INFO</>, or <literal>LOG</> (in a notice message), or
            a localized translation of one of these.  Always present.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-severity-nonlocalized">
          <term><symbol>PG_DIAG_SEVERITY_NONLOCALIZED</></term>
          <listitem>
           <para>
            The severity; the field contents are <literal>ERROR</>,
            <literal>FATAL</>, or <literal>PANIC</> (in an error message),
            or <literal>WARNING</>, <literal>NOTICE</>, <literal>DEBUG</>,
            <literal>INFO</>, or <literal>LOG</> (in a notice message).
            This is identical to the <symbol>PG_DIAG_SEVERITY</> field except
            that the contents are never localized.  This is present only in
            reports generated by <productname>PostgreSQL</> versions 9.6
            and later.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-sqlstate">
          <term>
           <symbol>PG_DIAG_SQLSTATE</>
          <indexterm>
           <primary>error codes</primary>
           <secondary>libpq</secondary>
          </indexterm>
          </term>
          <listitem>
           <para>
            The SQLSTATE code for the error. The SQLSTATE code identifies
            the type of error that has occurred; it can be used by
            front-end applications to perform specific operations (such
            as error handling) in response to a particular database error.
            For a list of the possible SQLSTATE codes, see <xref
            linkend="errcodes-appendix">. This field is not localizable,
            and is always present.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-message-primary">
          <term><symbol>PG_DIAG_MESSAGE_PRIMARY</></term>
          <listitem>
           <para>
            The primary human-readable error message (typically one line).
            Always present.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-message-detail">
          <term><symbol>PG_DIAG_MESSAGE_DETAIL</></term>
          <listitem>
           <para>
            Detail: an optional secondary error message carrying more
            detail about the problem.  Might run to multiple lines.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-message-hint">
          <term><symbol>PG_DIAG_MESSAGE_HINT</></term>
          <listitem>
           <para>
            Hint: an optional suggestion what to do about the problem.
            This is intended to differ from detail in that it offers advice
            (potentially inappropriate) rather than hard facts.  Might
            run to multiple lines.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-statement-position">
          <term><symbol>PG_DIAG_STATEMENT_POSITION</></term>
          <listitem>
           <para>
            A string containing a decimal integer indicating an error cursor
            position as an index into the original statement string.  The
            first character has index 1, and positions are measured in
            characters not bytes.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-internal-position">
          <term><symbol>PG_DIAG_INTERNAL_POSITION</></term>
          <listitem>
           <para>
            This is defined the same as the
            <symbol>PG_DIAG_STATEMENT_POSITION</> field, but it is used
            when the cursor position refers to an internally generated
            command rather than the one submitted by the client.  The
            <symbol>PG_DIAG_INTERNAL_QUERY</> field will always appear when
            this field appears.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-internal-query">
          <term><symbol>PG_DIAG_INTERNAL_QUERY</></term>
          <listitem>
           <para>
            The text of a failed internally-generated command.  This could
            be, for example, a SQL query issued by a PL/pgSQL function.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-context">
          <term><symbol>PG_DIAG_CONTEXT</></term>
          <listitem>
           <para>
            An indication of the context in which the error occurred.
            Presently this includes a call stack traceback of active
            procedural language functions and internally-generated queries.
            The trace is one entry per line, most recent first.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-schema-name">
          <term><symbol>PG_DIAG_SCHEMA_NAME</></term>
          <listitem>
           <para>
            If the error was associated with a specific database object,
            the name of the schema containing that object, if any.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-table-name">
          <term><symbol>PG_DIAG_TABLE_NAME</></term>
          <listitem>
           <para>
            If the error was associated with a specific table, the name of the
            table.  (Refer to the schema name field for the name of the
            table's schema.)
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-column-name">
          <term><symbol>PG_DIAG_COLUMN_NAME</></term>
          <listitem>
           <para>
            If the error was associated with a specific table column, the name
            of the column.  (Refer to the schema and table name fields to
            identify the table.)
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-datatype-name">
          <term><symbol>PG_DIAG_DATATYPE_NAME</></term>
          <listitem>
           <para>
            If the error was associated with a specific data type, the name of
            the data type.  (Refer to the schema name field for the name of
            the data type's schema.)
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-constraint-name">
          <term><symbol>PG_DIAG_CONSTRAINT_NAME</></term>
          <listitem>
           <para>
            If the error was associated with a specific constraint, the name
            of the constraint.  Refer to fields listed above for the
            associated table or domain.  (For this purpose, indexes are
            treated as constraints, even if they weren't created with
            constraint syntax.)
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-source-file">
          <term><symbol>PG_DIAG_SOURCE_FILE</></term>
          <listitem>
           <para>
            The file name of the source-code location where the error was
            reported.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-source-line">
          <term><symbol>PG_DIAG_SOURCE_LINE</></term>
          <listitem>
           <para>
            The line number of the source-code location where the error
            was reported.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-source-function">
          <term><symbol>PG_DIAG_SOURCE_FUNCTION</></term>
          <listitem>
           <para>
            The name of the source-code function reporting the error.
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>

       <note>
        <para>
         The fields for schema name, table name, column name, data type name,
         and constraint name are supplied only for a limited number of error
         types; see <xref linkend="errcodes-appendix">.  Do not assume that
         the presence of any of these fields guarantees the presence of
         another field.  Core error sources observe the interrelationships
         noted above, but user-defined functions may use these fields in other
         ways.  In the same vein, do not assume that these fields denote
         contemporary objects in the current database.
        </para>
       </note>

       <para>
        The client is responsible for formatting displayed information to meet
        its needs; in particular it should break long lines as needed.
        Newline characters appearing in the error message fields should be
        treated as paragraph breaks, not line breaks.
       </para>

       <para>
        Errors generated internally by <application>libpq</application> will
        have severity and primary message, but typically no other fields.
        Errors returned by a pre-3.0-protocol server will include severity and
        primary message, and sometimes a detail message, but no other fields.
       </para>

       <para>
        Note that error fields are only available from
        <structname>PGresult</structname> objects, not
        <structname>PGconn</structname> objects; there is no
        <function>PQerrorField</function> function.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqclear">
      <term><function>PQclear</function><indexterm><primary>PQclear</></></term>
      <listitem>
       <para>
        Frees  the  storage  associated with a
        <structname>PGresult</structname>.  Every command result should be
        freed via <function>PQclear</function> when it  is  no  longer
        needed.

<synopsis>
void PQclear(PGresult *res);
</synopsis>
       </para>

       <para>
        You can keep a <structname>PGresult</structname> object around for
        as long as you need it; it does not go away when you issue a new
        command, nor even if you close the connection.  To get rid of it,
        you must call <function>PQclear</function>.  Failure to do this
        will result in memory leaks in your application.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    <structname>PGresult</structname><indexterm><primary>PGresult</></>结构封装了由服务器返回的结果。<application>libpq</application>应用程序员应该小心地维护<structname>PGresult</structname>的抽象。使用下面的存储器函数来得到<structname>PGresult</structname>的内容。避免直接引用<structname>PGresult</structname>结构的域，因为它们可能在未来更改。

    <variablelist>
     <varlistentry id="libpq-pqresultstatus">
      <term>
       <function>PQresultStatus</function>
       <indexterm>
        <primary>PQresultStatus</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
        返回该命令的结果状态。
<synopsis>
ExecStatusType PQresultStatus(const PGresult *res);
</synopsis>
       </para>

       <para>
        <function>PQresultStatus</function>能返回下列值之一：

        <variablelist>
         <varlistentry id="libpq-pgres-empty-query">
          <term><literal>PGRES_EMPTY_QUERY</literal></term>
          <listitem>
           <para>
            发送给服务器的字符串为空。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-command-ok">
          <term><literal>PGRES_COMMAND_OK</literal></term>
          <listitem>
           <para>
            一个不返回数据的命令成功完成。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-tuples-ok">
          <term><literal>PGRES_TUPLES_OK</literal></term>
          <listitem>
           <para>
            一个返回数据的命令（例如<command>SELECT</>或者<command>SHOW</>）成功完成。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-copy-out">
          <term><literal>PGRES_COPY_OUT</literal></term>
          <listitem>
           <para>
            从服务器复制出数据的传输开始。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-copy-in">
          <term><literal>PGRES_COPY_IN</literal></term>
          <listitem>
           <para>
            复制数据到服务器的传输开始。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-bad-response">
          <term><literal>PGRES_BAD_RESPONSE</literal></term>
          <listitem>
           <para>
            无法理解服务器的响应。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-nonfatal-error">
          <term><literal>PGRES_NONFATAL_ERROR</literal></term>
          <listitem>
           <para>
            发生了一次非致命错误（一个提示或警告）。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-fatal-error">
          <term><literal>PGRES_FATAL_ERROR</literal></term>
          <listitem>
           <para>
            发生了一次致命错误。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-copy-both">
          <term><literal>PGRES_COPY_BOTH</literal></term>
          <listitem>
           <para>
            向服务器复制数据/从服务器复制数据的传输开始。这个特性当前只被用于流复制，因此这个状态应该不会在普通应用中出现。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-single-tuple">
          <term><literal>PGRES_SINGLE_TUPLE</literal></term>
          <listitem>
           <para>
            <structname>PGresult</>包含来自于当前命令的一个单一结果元组。这个状态只在查询选择了单一行模式时发生（见<xref linkend="libpq-single-row-mode">）。
           </para>
          </listitem>
         </varlistentry>
        </variablelist>

        如果结果状态是<literal>PGRES_TUPLES_OK</literal>或者<literal>PGRES_SINGLE_TUPLE</literal>，那么下面所描述的函数能被用来检索该查询所返回的行。注意，一个恰好检索零行的<command>SELECT</command>命令仍然会显示<literal>PGRES_TUPLES_OK</literal>。<literal>PGRES_COMMAND_OK</literal>用于从不返回行的命令（不带<literal>RETURNING</literal>子句的<command>INSERT</command>或者<command>UPDATE</command>等）。一个<literal>PGRES_EMPTY_QUERY</literal>可能表示客户端软件中的一个缺陷。
       </para>

       <para>
        一个状态为<symbol>PGRES_NONFATAL_ERROR</symbol>的结果将不会被<function>PQexec</function>或者其他查询执行函数直接返回，这类结果将被传递给提示处理器（见 <xref linkend="libpq-notice-processing">）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqresstatus">
      <term>
       <function>PQresStatus</function>
       <indexterm>
        <primary>PQresStatus</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
        将<function>PQresultStatus</>返回的枚举转换成描述状态编码的字符串常量。调用者不应该释放结果。

<synopsis>
char *PQresStatus(ExecStatusType status);
</synopsis>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqresulterrormessage">
      <term>
       <function>PQresultErrorMessage</function>
       <indexterm>
        <primary>PQresultErrorMessage</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
        返回与该命令相关的错误消息，如果有错误则会返回一个空字符串。
<synopsis>
char *PQresultErrorMessage(const PGresult *res);
</synopsis>
        如果有一个错误，被返回的字符串将包含一个收尾的新行。调用者不应该直接释放结果。它将在相关的<structname>PGresult</>句柄被传递给<function>PQclear</function>之后被释放。
       </para>

       <para>
        紧跟着一个<function>PQexec</function>或<function>PQgetResult</function>调用，<function>PQerrorMessage</function>（在连接上）将返回与<function>PQresultErrorMessage</function>相同的字符串（在结果上）。不过，一个<structname>PGresult</structname>将保持它的错误消息直到被销毁，而连接的错误消息将在后续操作被执行时被更改。当你想要知道与一个特定<structname>PGresult</structname>相关的状态，使用<function>PQresultErrorMessage</function>。而当你想要知道连接上最后一个操作的状态，使用<function>PQerrorMessage</function>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqresultverboseerrormessage">
      <term>
       <function>PQresultVerboseErrorMessage</function>
       <indexterm>
        <primary>PQresultVerboseErrorMessage</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
        返回与<structname>PGresult</>对象相关的错误消息的重新格式化的版本。
<synopsis>
char *PQresultVerboseErrorMessage(const PGresult *res,
                                  PGVerbosity verbosity,
                                  PGContextVisibility show_context);
</synopsis>
        在有些情况下，客户端可能希望得到之前报告过的错误的更加详尽的版本。
        如果在产生给定<structname>PGresult</>的连接上 verbosity 设置有效，
        <function>PQresultVerboseErrorMessage</function>会通过计算已经被
        <function>PQresultErrorMessage</function>产生过的消息来满足这种需求。
        如果<structname>PGresult</>不是一个错误结果，则会报告
        <quote>PGresult is not an error result</>。
        返回的字符串包括一个新行作为结尾。
       </para>

       <para>
        和大部分从<structname>PGresult</>中提取数据的其他函数不同，
        这个函数的结果是一个全新分配的字符串。调用者在不需要这个字符串以后，
        必须使用<function>PQfreemem()</>释放它。
       </para>

       <para>
        如果内存不足，可能会返回 NULL。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry id="libpq-pqresulterrorfield">
      <term><function>PQresultErrorField</function><indexterm><primary>PQresultErrorField</></></term>
      <listitem>
       <para>
        返回一个错误报告的一个域。
<synopsis>
char *PQresultErrorField(const PGresult *res, int fieldcode);
</synopsis>
        <parameter>fieldcode</>是一个错误域标识符，见下列符号。如果<structname>PGresult</structname>不是一个错误或者警告结果或者不包括指定域，会返回<symbol>NULL</symbol>。域通常不包括一个收尾的新行。调用者不应该直接释放结果。它将在相关的<structname>PGresult</>句柄被传递给<function>PQclear</function>之后被释放。
       </para>

       <para>
        下列域代码可用：
        <variablelist>
         <varlistentry id="libpq-pg-diag-severity">
          <term><symbol>PG_DIAG_SEVERITY</></term>
          <listitem>
           <para>
            严重。域的内容是<literal>ERROR</>、<literal>FATAL</>或<literal>PANIC</>（在一个错误消息中）。或者是<literal>WARNING</>、<literal>NOTICE</>、<literal>DEBUG</>、<literal>INFO</>或<literal>LOG</>（在一个提示消息中）。或者是其中之一的一个本地化翻译。总是存在。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-severity-nonlocalized">
          <term><symbol>PG_DIAG_SEVERITY_NONLOCALIZED</></term>
          <listitem>
           <para>
            严重。域的内容是<literal>ERROR</>、<literal>FATAL</>或<literal>PANIC</>
            （在一个错误消息中）。或者是<literal>WARNING</>、<literal>NOTICE</>、
            <literal>DEBUG</>、<literal>INFO</>或<literal>LOG</>（在一个提示消息中）。
            这和<symbol>PG_DIAG_SEVERITY</>域相同，不过内容不会被本地化。
            只存在于<productname>PostgreSQL</> 9.6 及以后版本产生的报告中。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-sqlstate">
          <term><symbol>PG_DIAG_SQLSTATE</>
          <indexterm>
           <primary>error codes</primary>
           <secondary>libpq</secondary>
          </indexterm></term>
          <listitem>
           <para>
            用于错误的 SQLSTATE 代码。SQLSTATE 代码标识了已经发生的错误的类型，它可以被前端应用用来执行特定操作（例如错误处理）来响应一个特定数据库错误。一个可能的 SQLSTATE 代码列表可见<xref linkend="errcodes-appendix">。这个域无法被本地化，并且总是存在。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-message-primary">
          <term><symbol>PG_DIAG_MESSAGE_PRIMARY</></term>
          <listitem>
           <para>
            主要的人类可读的错误消息（通常是一行）。总是存在。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-message-detail">
          <term><symbol>PG_DIAG_MESSAGE_DETAIL</></term>
          <listitem>
           <para>
            细节：一个可选的次级错误消息，它携带了关于问题的更多细节。可能有多行。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-message-hint">
          <term><symbol>PG_DIAG_MESSAGE_HINT</></term>
          <listitem>
           <para>
            提示：一个关于如何处理该问题的可选建议。它与细节的区别在于它提供了建议（可能不合适）而不是铁的事实。可能有多行。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-statement-position">
          <term><symbol>PG_DIAG_STATEMENT_POSITION</></term>
          <listitem>
           <para>
            包含一个十进制整数的字符串，它表示一个错误游标位置，
            该位置是原始语句字符串的索引。第一个字符的索引是 1，
            位置以字符计算而不是以及字节计算。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-internal-position">
          <term><symbol>PG_DIAG_INTERNAL_POSITION</></term>
          <listitem>
           <para>
            这被定义为与<symbol>PG_DIAG_STATEMENT_POSITION</>域相同，但是它被用在游标位置引用一个内部产生的命令而不是客户端提交的命令时。当这个域出现时，<symbol>PG_DIAG_INTERNAL_QUERY</>域将总是出现。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-internal-query">
          <term><symbol>PG_DIAG_INTERNAL_QUERY</></term>
          <listitem>
           <para>
            一个失败的内部产生的命令的文本。例如，这可能是由一个 PL/pgSQL 函数发出的 SQL 查询。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-context">
          <term><symbol>PG_DIAG_CONTEXT</></term>
          <listitem>
           <para>
            指示错误发生的环境。当前这包括活动过程语言函数的调用栈追踪以及内部生成的查询。追踪是每行一项，最近的排在最前面。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-schema-name">
          <term><symbol>PG_DIAG_SCHEMA_NAME</></term>
          <listitem>
           <para>
            如果错误与某个特定的数据库对象相关，这里是包含该对象的模式名（如果有）。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-table-name">
          <term><symbol>PG_DIAG_TABLE_NAME</></term>
          <listitem>
           <para>
            如果错误与某个特定表相关，这里是该表的名字（该表的模式参考模式名域）。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-column-name">
          <term><symbol>PG_DIAG_COLUMN_NAME</></term>
          <listitem>
           <para>
            如果错误与一个特定表列相关，这里是该表列的名字（参考模式和表名域来标识该表）。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-datatype-name">
          <term><symbol>PG_DIAG_DATATYPE_NAME</></term>
          <listitem>
           <para>
            如果错误与一个特定数据类型相关，这里是该数据类型的名字（该数据类型的模式名参考模式名域）。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-constraint-name">
          <term><symbol>PG_DIAG_CONSTRAINT_NAME</></term>
          <listitem>
           <para>
            如果错误与一个特定约束相关，这里是该约束的名字。相关的表或域参考上面列出的域（为了这个目的，索引也被视作约束，即使它们不是用约束语法创建的）。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-source-file">
          <term><symbol>PG_DIAG_SOURCE_FILE</></term>
          <listitem>
           <para>
            报告错误的源代码所在的文件名。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-source-line">
          <term><symbol>PG_DIAG_SOURCE_LINE</></term>
          <listitem>
           <para>
            报告错误的源代码行号。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-source-function">
          <term><symbol>PG_DIAG_SOURCE_FUNCTION</></term>
          <listitem>
           <para>
            报告错误的源代码函数的名字。
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>

       <note>
        <para>
         用于模式名、表明、列名、数据类型名和约束名的域只提供给有限的错误类型，见<xref linkend="errcodes-appendix">。不要假定任何这些域的存在保证另一个域的存在。核心错误源会遵守上面提到的内在联系，但是用户定义的函数可能以其他方式使用这些域。同样地，不要假定这些域代表当前数据库中同类的对象。
        </para>
       </note>

       <para>
        客户端负责格式化显示信息来迎合它的需要，特别是根据需要打断长的行。出现在错误消息域中的新行字符应该被当作分段而不是换行。
       </para>

       <para>
        <application>libpq</application>内部产生的错误将有严重和主要消息，但是通常没有其他域。3.0 协议之前的服务器返回的错误将包括严重和主要消息，并且有时候还有细节消息，但是没有其他域。
       </para>

       <para>
        注意错误域只对<structname>PGresult</structname>对象中有效，对<structname>PGconn</structname>对象无效。没有<function>PQerrorField</function>函数。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqclear">
      <term><function>PQclear</function><indexterm><primary>PQclear</></></term>
      <listitem>
       <para>
        Frees  the  storage  associated with a
        释放与一个<structname>PGresult</structname>相关的存储。每一个命令结果不再需要时应该用<function>PQclear</function>释放。

<synopsis>
void PQclear(PGresult *res);
</synopsis>
       </para>

       <para>
        你可以按照需要保留<structname>PGresult</structname>对象，当你发出一个新命令时它也不会消失，甚至关闭连接时也不会消失。要去掉它，你必须调用<function>PQclear</function>。没有这样做将会导致在应用中的内存泄露。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="libpq-exec-select-info">
<!--==========================orignal english content==========================
   <title>Retrieving Query Result Information</title>
____________________________________________________________________________-->
   <title>检索查询结果信息</title>

<!--==========================orignal english content==========================
   <para>
    These functions are used to extract information from a
    <structname>PGresult</structname> object that represents a successful
    query result (that is, one that has status
    <literal>PGRES_TUPLES_OK</literal> or <literal>PGRES_SINGLE_TUPLE</>).
    They can also be used to extract
    information from a successful Describe operation: a Describe's result
    has all the same column information that actual execution of the query
    would provide, but it has zero rows.  For objects with other status values,
    these functions will act as though the result has zero rows and zero columns.
   </para>
____________________________________________________________________________-->
   <para>
    这些函数被用来从一个代表成功查询结果（也就是状态为<literal>PGRES_TUPLES_OK</literal>或者<literal>PGRES_SINGLE_TUPLE</>）的<structname>PGresult</structname>对象中抽取信息。它们也可以被用来从一个成功的 Describe 操作中抽取信息：一个 Describe 的结果具有和该查询被实际执行所提供的完全相同的列信息，但是它没有行。对于其他状态值的对象，这些函数会认为结果具有零行和零列。
   </para>

   <variablelist>
    <varlistentry id="libpq-pqntuples">
<!--==========================orignal english content==========================
     <term>
      <function>PQntuples</function>
      <indexterm>
       <primary>PQntuples</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQntuples</function>
      <indexterm>
       <primary>PQntuples</primary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       Returns the number of rows (tuples) in the query result.
       (Note that <structname>PGresult</> objects are limited to no more
       than <literal>INT_MAX</> rows, so an <type>int</> result is
       sufficient.)

<synopsis>
int PQntuples(const PGresult *res);
</synopsis>

      </para>
____________________________________________________________________________-->
      <para>
       返回查询结果中的行（元组）数。
	   (请注意，<structname>PGresult</>对象限制为不超过<literal>INT_MAX</>行，
	   所以<type>int</>结果是足够的。)

<synopsis>
int PQntuples(const PGresult *res);
</synopsis>

      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqnfields">
<!--==========================orignal english content==========================
     <term>
      <function>PQnfields</function>
      <indexterm>
       <primary>PQnfields</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQnfields</function>
      <indexterm>
       <primary>PQnfields</primary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       Returns the number of columns (fields) in each row of the query
       result.

<synopsis>
int PQnfields(const PGresult *res);
</synopsis>
      </para>
____________________________________________________________________________-->
      <para>
       返回查询结果中每一行的列（域）数。

<synopsis>
int PQnfields(const PGresult *res);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfname">
<!--==========================orignal english content==========================
     <term>
      <function>PQfname</function>
      <indexterm>
       <primary>PQfname</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQfname</function>
      <indexterm>
       <primary>PQfname</primary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       Returns the column name associated with the given column number.
       Column numbers start at 0. The caller should not free the result
       directly. It will be freed when the associated
       <structname>PGresult</> handle is passed to
       <function>PQclear</function>.
<synopsis>
char *PQfname(const PGresult *res,
              int column_number);
</synopsis>
      </para>
____________________________________________________________________________-->
      <para>
       返回与给定列号相关联的列名。列号从 0 开始。调用者不应该直接释放该结果。它将在相关的<structname>PGresult</>句柄被传递给<function>PQclear</function>之后被释放。
<synopsis>
char *PQfname(const PGresult *res,
              int column_number);
</synopsis>
      </para>

<!--==========================orignal english content==========================
      <para>
       <symbol>NULL</symbol> is returned if the column number is out of range.
      </para>
____________________________________________________________________________-->
      <para>
       如果列号超出范围，将返回<symbol>NULL</symbol>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfnumber">
<!--==========================orignal english content==========================
     <term>
      <function>PQfnumber</function>
      <indexterm>
       <primary>PQfnumber</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQfnumber</function>
      <indexterm>
       <primary>PQfnumber</primary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       Returns the column number associated with the given column name.
<synopsis>
int PQfnumber(const PGresult *res,
              const char *column_name);
</synopsis>
      </para>
____________________________________________________________________________-->
      <para>
       返回与给定列名相关联的列号。
<synopsis>
int PQfnumber(const PGresult *res,
              const char *column_name);
</synopsis>
      </para>

<!--==========================orignal english content==========================
      <para>
       -1 is returned if the given name does not match any column.
      </para>
____________________________________________________________________________-->
      <para>
       如果给定的名字不匹配任何列，将返回 -1。
      </para>

<!--==========================orignal english content==========================
      <para>
       The given name is treated like an identifier in an SQL command,
       that is, it is downcased unless double-quoted.  For example, given
       a query result generated from the SQL command:
<programlisting>
SELECT 1 AS FOO, 2 AS "BAR";
</programlisting>
       we would have the results:
<programlisting>
PQfname(res, 0)              <lineannotation>foo</lineannotation>
PQfname(res, 1)              <lineannotation>BAR</lineannotation>
PQfnumber(res, "FOO")        <lineannotation>0</lineannotation>
PQfnumber(res, "foo")        <lineannotation>0</lineannotation>
PQfnumber(res, "BAR")        <lineannotation>-1</lineannotation>
PQfnumber(res, "\"BAR\"")    <lineannotation>1</lineannotation>
</programlisting>
      </para>
____________________________________________________________________________-->
      <para>
       给定的名称被视作一个 SQL 命令中的一个标识符，也就是说，除非被双引号引用，它是小写形式的。例如，给定一个 SQL 命令：
<programlisting>
SELECT 1 AS FOO, 2 AS "BAR";
</programlisting>
       我们将得到结果：
<programlisting>
PQfname(res, 0)              <lineannotation>foo</lineannotation>
PQfname(res, 1)              <lineannotation>BAR</lineannotation>
PQfnumber(res, "FOO")        <lineannotation>0</lineannotation>
PQfnumber(res, "foo")        <lineannotation>0</lineannotation>
PQfnumber(res, "BAR")        <lineannotation>-1</lineannotation>
PQfnumber(res, "\"BAR\"")    <lineannotation>1</lineannotation>
</programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqftable">
<!--==========================orignal english content==========================
     <term>
      <function>PQftable</function>
      <indexterm>
       <primary>PQftable</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQftable</function>
      <indexterm>
       <primary>PQftable</primary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       Returns the OID of the table from which the given column was
       fetched.  Column numbers start at 0.
<synopsis>
Oid PQftable(const PGresult *res,
             int column_number);
</synopsis>
      </para>
____________________________________________________________________________-->
      <para>
       返回取出给定列的表的 OID。列号从 0 开始。
<synopsis>
Oid PQftable(const PGresult *res,
             int column_number);
</synopsis>
      </para>

<!--==========================orignal english content==========================
      <para>
       <literal>InvalidOid</> is returned if the column number is out of range,
       or if the specified column is not a simple reference to a table column,
       or when using pre-3.0 protocol.
       You can query the system table <literal>pg_class</literal> to determine
       exactly which table is referenced.
      </para>
____________________________________________________________________________-->
      <para>
       如果列号超出范围或者指定的列不是对一个表列的简单引用或者在使用 3.0 协议时，返回<literal>InvalidOid</>。你可以查询系统表<literal>pg_class</literal>来确定究竟是哪个表被引用。
      </para>

<!--==========================orignal english content==========================
      <para>
       The type <type>Oid</type> and the constant
       <literal>InvalidOid</literal> will be defined when you include
       the <application>libpq</application> header file. They will both
       be some integer type.
      </para>
____________________________________________________________________________-->
      <para>
       当你包括<application>libpq</application>头文件，类型<type>Oid</type>以及常数<literal>InvalidOid</literal>将被定义。它们将都是某种整数类型。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqftablecol">
<!--==========================orignal english content==========================
     <term>
      <function>PQftablecol</function>
      <indexterm>
       <primary>PQftablecol</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQftablecol</function>
      <indexterm>
       <primary>PQftablecol</primary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       Returns the column number (within its table) of the column making
       up the specified query result column.  Query-result column numbers
       start at 0, but table columns have nonzero numbers.
<synopsis>
int PQftablecol(const PGresult *res,
                int column_number);
</synopsis>
      </para>
____________________________________________________________________________-->
      <para>
       返回构成指定查询结果列的列（在其表中）的列号。查询结果列号从 0 开始，但是表列具有非零编号。
<synopsis>
int PQftablecol(const PGresult *res,
                int column_number);
</synopsis>
      </para>

<!--==========================orignal english content==========================
      <para>
       Zero is returned if the column number is out of range, or if the
       specified column is not a simple reference to a table column, or
       when using pre-3.0 protocol.
      </para>
____________________________________________________________________________-->
      <para>
       如果列号超出范围或者指定的列不是对一个表列的简单引用或者在使用 3.0 协议时，返回零。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfformat">
<!--==========================orignal english content==========================
     <term>
      <function>PQfformat</function>
      <indexterm>
       <primary>PQfformat</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQfformat</function>
      <indexterm>
       <primary>PQfformat</primary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       Returns the format code indicating the format of the given
       column.  Column numbers start at 0.
<synopsis>
int PQfformat(const PGresult *res,
              int column_number);
</synopsis>
      </para>
____________________________________________________________________________-->
      <para>
       返回指示给定列格式的格式编码。列号从 0 开始。
<synopsis>
int PQfformat(const PGresult *res,
              int column_number);
</synopsis>
      </para>

<!--==========================orignal english content==========================
      <para>
       Format code zero indicates textual data representation, while format
       code one indicates binary representation.  (Other codes are reserved
       for future definition.)
      </para>
____________________________________________________________________________-->
      <para>
       格式代码零指示文本数据表示，而格式代码一表示二进制表示（其他代码被保留用于未来的定义）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqftype">
<!--==========================orignal english content==========================
     <term>
      <function>PQftype</function>
      <indexterm>
       <primary>PQftype</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQftype</function>
      <indexterm>
       <primary>PQftype</primary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       Returns the data type associated with the given  column number.
       The  integer  returned is the internal OID number of the type.
       Column numbers start at 0.
<synopsis>
Oid PQftype(const PGresult *res,
            int column_number);
</synopsis>
      </para>
____________________________________________________________________________-->
      <para>
       返回与给定列号相关联的数据类型。被返回的整数是该类型的内部 OID 号。列号从 0 开始。
<synopsis>
Oid PQftype(const PGresult *res,
            int column_number);
</synopsis>
      </para>

<!--==========================orignal english content==========================
      <para>
       You can query the system table <literal>pg_type</literal> to
       obtain the names and properties of the various data types. The
       <acronym>OID</acronym>s of the built-in data types are defined
       in the file <filename>src/include/catalog/pg_type.h</filename>
       in the source tree.
      </para>
____________________________________________________________________________-->
      <para>
       你可以查询系统表<literal>pg_type</literal>来得到多个数据类型的名字和属性。内建数据类型的<acronym>OID</acronym>被定义在源代码树中的文件<filename>src/include/catalog/pg_type.h</filename>中。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfmod">
<!--==========================orignal english content==========================
     <term>
      <function>PQfmod</function>
      <indexterm>
       <primary>PQfmod</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQfmod</function>
      <indexterm>
       <primary>PQfmod</primary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       Returns  the type modifier of the column associated with the
       given column number.  Column numbers start at 0.
<synopsis>
int PQfmod(const PGresult *res,
           int column_number);
</synopsis>
      </para>
____________________________________________________________________________-->
      <para>
       返回与给定列号相关联的列的修饰符类型。列号从 0 开始。
<synopsis>
int PQfmod(const PGresult *res,
           int column_number);
</synopsis>
      </para>

<!--==========================orignal english content==========================
      <para>
       The interpretation of modifier values is type-specific; they
       typically indicate precision or size limits.  The value -1 is
       used to indicate <quote>no information available</>.  Most data
       types do not use modifiers, in which case the value is always
       -1.
      </para>
____________________________________________________________________________-->
      <para>
       修饰符值的解释是与类型相关的，它们通常指示精度或尺寸限制。值 -1 被用来指示<quote>没有信息可用</>。大部分的数据类型不适用修饰符，在那种情况中值总是 -1。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfsize">
<!--==========================orignal english content==========================
     <term>
      <function>PQfsize</function>
      <indexterm>
       <primary>PQfsize</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQfsize</function>
      <indexterm>
       <primary>PQfsize</primary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       Returns  the  size  in bytes of the column associated with the
       given column number.  Column numbers start at 0.
<synopsis>
int PQfsize(const PGresult *res,
            int column_number);
</synopsis>
      </para>
____________________________________________________________________________-->
      <para>
       返回与给定列号相关的列的尺寸（以字节计）。列号从 0 开始。
<synopsis>
int PQfsize(const PGresult *res,
            int column_number);
</synopsis>
      </para>

<!--==========================orignal english content==========================
      <para>
       <function>PQfsize</> returns the space allocated for this column
       in a database row, in other words the size of the server's
       internal representation of the data type.  (Accordingly, it is
       not really very useful to clients.) A negative value indicates
       the data type is variable-length.
      </para>
____________________________________________________________________________-->
      <para>
       <function>PQfsize</>返回在一个数据库行中为这个列分配的空间，换句话说是服务器对该数据类型的内部表示的尺寸（因此，它对客户端并不是真地非常有用）。一个负值指示该数据类型是变长的。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqbinarytuples">
<!--==========================orignal english content==========================
     <term>
      <function>PQbinaryTuples</function>
      <indexterm>
       <primary>PQbinaryTuples</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQbinaryTuples</function>
      <indexterm>
       <primary>PQbinaryTuples</primary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       Returns 1 if the <structname>PGresult</> contains binary data
       and 0 if it contains text data.
<synopsis>
int PQbinaryTuples(const PGresult *res);
</synopsis>
      </para>
____________________________________________________________________________-->
      <para>
       如果<structname>PGresult</>包含二进制数据，返回 1。如果包含的是文本数据，返回 0。
<synopsis>
int PQbinaryTuples(const PGresult *res);
</synopsis>
      </para>

<!--==========================orignal english content==========================
      <para>
       This function is deprecated (except for its use in connection with
       <command>COPY</>), because it is possible for a single
       <structname>PGresult</> to contain text data in some columns and
       binary data in others.  <function>PQfformat</> is preferred.
       <function>PQbinaryTuples</> returns 1 only if all columns of the
       result are binary (format 1).
      </para>
____________________________________________________________________________-->
      <para>
       这个函数已经被废弃（除了与<command>COPY</>一起使用），因为一个单一<structname>PGresult</>可以在某些列中包含文本数据而且在另一些列中包含二进制数据。<function>PQfformat</>要更好。只有结果的所有列是二进制（格式 1）时<function>PQbinaryTuples</>才返回 1。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqgetvalue">
<!--==========================orignal english content==========================
     <term>
      <function>PQgetvalue</function>
       <indexterm>
        <primary>PQgetvalue</primary>
       </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQgetvalue</function>
       <indexterm>
        <primary>PQgetvalue</primary>
       </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       Returns a single field value of one row of a
       <structname>PGresult</structname>.  Row and column numbers start
       at 0.  The caller should not free the result directly.  It will
       be freed when the associated <structname>PGresult</> handle is
       passed to <function>PQclear</function>.
<synopsis>
char *PQgetvalue(const PGresult *res,
                 int row_number,
                 int column_number);
</synopsis>
      </para>
____________________________________________________________________________-->
      <para>
       返回一个<structname>PGresult</structname>的一行的单一域值。行和列号从 0 开始。调用者不应该直接释放该结果。它将在相关的<structname>PGresult</>句柄被传递给<function>PQclear</function>之后被释放。
<synopsis>
char *PQgetvalue(const PGresult *res,
                 int row_number,
                 int column_number);
</synopsis>
      </para>

<!--==========================orignal english content==========================
      <para>
       For data in text format, the value returned by
       <function>PQgetvalue</function> is a null-terminated character
       string  representation of the field value.  For data in binary
       format, the value is in the binary representation determined by
       the data type's <function>typsend</> and <function>typreceive</>
       functions.  (The value is actually followed by a zero byte in
       this case too, but that is not ordinarily useful, since the
       value is likely to contain embedded nulls.)
      </para>
____________________________________________________________________________-->
      <para>
       对于文本格式的数据，<function>PQgetvalue</function>返回的值是该域值的一种空值结束的字符串表示。对于二进制格式的数据，该值是由该数据类型的<function>typsend</>和<function>typreceive</>函数决定的二进制表示（在这种情况下该值实际上也跟随着一个零字节，但是这通常没有用处，因为该值很可能包含嵌入的空）。
      </para>

<!--==========================orignal english content==========================
      <para>
       An empty string is returned if the field value is null.  See
       <function>PQgetisnull</> to distinguish null values from
       empty-string values.
      </para>
____________________________________________________________________________-->
      <para>
       如果该域值为空，则返回一个空串。关于区分空值和空字符串值请见<function>PQgetisnull</>。
      </para>

<!--==========================orignal english content==========================
      <para>
       The pointer returned  by  <function>PQgetvalue</function> points
       to storage that is part of the <structname>PGresult</structname>
       structure.  One should not modify the data it points to, and one
       must explicitly copy the data into other storage if it is to be
       used past the lifetime of the  <structname>PGresult</structname>
       structure itself.
      </para>
____________________________________________________________________________-->
      <para>
       <function>PQgetvalue</function>返回的指针指向作为<structname>PGresult</structname>结构一部分的存储。我们不应该修改它指向的数据，并且如果要在超过<structname>PGresult</structname>结构本身的生命期之外使用它，我们必须显式地把该数据拷贝到其他存储中。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqgetisnull">
<!--==========================orignal english content==========================
     <term>
      <function>PQgetisnull</function>
      <indexterm>
       <primary>PQgetisnull</primary>
      </indexterm>
      <indexterm>
       <primary>null value</primary>
       <secondary sortas="libpq">in libpq</secondary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQgetisnull</function>
      <indexterm>
       <primary>PQgetisnull</primary>
      </indexterm>
      <indexterm>
       <primary>null value</primary>
       <secondary sortas="libpq">in libpq</secondary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       Tests a field for a null value.  Row and column numbers start
       at 0.
<synopsis>
int PQgetisnull(const PGresult *res,
                int row_number,
                int column_number);
</synopsis>
      </para>
____________________________________________________________________________-->
      <para>
       测试一个域是否为空值。行号和列号从 0 开始。
<synopsis>
int PQgetisnull(const PGresult *res,
                int row_number,
                int column_number);
</synopsis>
      </para>

<!--==========================orignal english content==========================
      <para>
       This function returns  1 if the field is null and 0 if it
       contains a non-null value.  (Note that
       <function>PQgetvalue</function> will return an empty string,
       not a null pointer, for a null field.)
      </para>
____________________________________________________________________________-->
      <para>
       如果该域是空，这个函数返回 1。如果它包含一个非空值，则返回 0（注意<function>PQgetvalue</function>将为一个空域返回一个空串，不是一个空指针）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqgetlength">
<!--==========================orignal english content==========================
     <term>
     <function>PQgetlength</function>
     <indexterm>
      <primary>PQgetlength</primary>
     </indexterm></term>
____________________________________________________________________________-->
     <term>
     <function>PQgetlength</function>
     <indexterm>
      <primary>PQgetlength</primary>
     </indexterm></term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       Returns the actual length of a field value in bytes.  Row and
       column numbers start at 0.
<synopsis>
int PQgetlength(const PGresult *res,
                int row_number,
                int column_number);
</synopsis>
      </para>
____________________________________________________________________________-->
      <para>
       返回一个域值的真实长度，以字节计。行号和列号从 0 开始。
<synopsis>
int PQgetlength(const PGresult *res,
                int row_number,
                int column_number);
</synopsis>
      </para>

<!--==========================orignal english content==========================
      <para>
       This is the actual data length for the particular data value,
       that is, the size of the object pointed to by
       <function>PQgetvalue</function>.  For text data format this is
       the same as <function>strlen()</>.  For binary format this is
       essential information.  Note that one should <emphasis>not</>
       rely on <function>PQfsize</function> to obtain the actual data
       length.
      </para>
____________________________________________________________________________-->
      <para>
       这是特定数据值的真实数据长度，也就是<function>PQgetvalue</function>指向的对象的尺寸。对于文本数据格式，这和<function>strlen()</>相同。对于二进制格式这是基本信息。注意我们<emphasis>不</>应该依赖于<function>PQfsize</function>来得到真实的数据长度。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqnparams">
<!--==========================orignal english content==========================
     <term>
      <function>PQnparams</function>
      <indexterm>
       <primary>PQnparams</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQnparams</function>
      <indexterm>
       <primary>PQnparams</primary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       Returns the number of parameters of a prepared statement.
<synopsis>
int PQnparams(const PGresult *res);
</synopsis>
      </para>
____________________________________________________________________________-->
      <para>
       返回一个预备语句的参数数量。
<synopsis>
int PQnparams(const PGresult *res);
</synopsis>
      </para>

<!--==========================orignal english content==========================
      <para>
       This function is only useful when inspecting the result of
       <function>PQdescribePrepared</>.  For other types of queries it
       will return zero.
      </para>
____________________________________________________________________________-->
      <para>
       只有在查看<function>PQdescribePrepared</>的结果时，这个函数才有用。对于其他类型的查询，它将返回零。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqparamtype">
<!--==========================orignal english content==========================
     <term>
      <function>PQparamtype</function>
      <indexterm>
       <primary>PQparamtype</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQparamtype</function>
      <indexterm>
       <primary>PQparamtype</primary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       Returns the data type of the indicated statement parameter.
       Parameter numbers start at 0.
<synopsis>
Oid PQparamtype(const PGresult *res, int param_number);
</synopsis>
      </para>
____________________________________________________________________________-->
      <para>
       返回所指示的语句参数的数据类型。参数号从 0 开始。
<synopsis>
Oid PQparamtype(const PGresult *res, int param_number);
</synopsis>
      </para>

<!--==========================orignal english content==========================
      <para>
       This function is only useful when inspecting the result of
       <function>PQdescribePrepared</>.  For other types of queries it
       will return zero.
      </para>
____________________________________________________________________________-->
      <para>
       只有在查看<function>PQdescribePrepared</>的结果时，这个函数才有用。对于其他类型的查询，它将返回零。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqprint">
<!--==========================orignal english content==========================
     <term>
      <function>PQprint</function>
      <indexterm>
       <primary>PQprint</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQprint</function>
      <indexterm>
       <primary>PQprint</primary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       Prints out all the rows and,  optionally,  the column names  to
       the specified output stream.
<synopsis>
void PQprint(FILE *fout,      /* output stream */
             const PGresult *res,
             const PQprintOpt *po);
typedef struct
{
    pqbool  header;      /* print output field headings and row count */
    pqbool  align;       /* fill align the fields */
    pqbool  standard;    /* old brain dead format */
    pqbool  html3;       /* output HTML tables */
    pqbool  expanded;    /* expand tables */
    pqbool  pager;       /* use pager for output if needed */
    char    *fieldSep;   /* field separator */
    char    *tableOpt;   /* attributes for HTML table element */
    char    *caption;    /* HTML table caption */
    char    **fieldName; /* null-terminated array of replacement field names */
} PQprintOpt;
</synopsis>
      </para>
____________________________________________________________________________-->
      <para>
       将所有的行打印到指定的输出流，以及有选择地将列名打印到指定的输出流。
<synopsis>
void PQprint(FILE *fout,      /* 输出流 */
             const PGresult *res,
             const PQprintOpt *po);
typedef struct
{
    pqbool  header;      /* 打印输出域标题和行计数 */
    pqbool  align;       /* 填充对齐域 */
    pqbool  standard;    /* 旧的格式 */
    pqbool  html3;       /* 输出 HTML 表格 */
    pqbool  expanded;    /* 扩展表格 */
    pqbool  pager;       /* 如果必要为输出使用页 */
    char    *fieldSep;   /* 域分隔符 */
    char    *tableOpt;   /* 用于 HTML 表格元素的属性 */
    char    *caption;    /* HTML 表格标题 */
    char    **fieldName; /* 替换域名称的空终止数组 */
} PQprintOpt;
</synopsis>
      </para>

<!--==========================orignal english content==========================
      <para>
       This function was formerly used by <application>psql</application>
       to print query results, but this is no longer the case.  Note
       that it assumes all the data is in text format.
      </para>
____________________________________________________________________________-->
      <para>
       这个函数以前被<application>psql</application>用来打印查询结果，但是现在不是这样了。注意它假定所有的数据都是文本格式。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 id="libpq-exec-nonselect">
<!--==========================orignal english content==========================
   <title>Retrieving Other Result Information</title>
____________________________________________________________________________-->
   <title>检索其他结果信息</title>

<!--==========================orignal english content==========================
   <para>
    These functions are used to extract other information from
    <structname>PGresult</structname> objects.
   </para>
____________________________________________________________________________-->
   <para>
    这些函数被用来从<structname>PGresult</structname>对象中抽取其他信息。
   </para>

   <variablelist>
    <varlistentry id="libpq-pqcmdstatus">
<!--==========================orignal english content==========================
     <term>
      <function>PQcmdStatus</function>
      <indexterm>
       <primary>PQcmdStatus</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQcmdStatus</function>
      <indexterm>
       <primary>PQcmdStatus</primary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       Returns the command status tag from the SQL command that generated
       the <structname>PGresult</structname>.
<synopsis>
char *PQcmdStatus(PGresult *res);
</synopsis>
      </para>
____________________________________________________________________________-->
      <para>
       返回来自于产生<structname>PGresult</structname>的 SQL 命令的命令状态标签。
<synopsis>
char *PQcmdStatus(PGresult *res);
</synopsis>
      </para>

<!--==========================orignal english content==========================
      <para>
       Commonly this is just the name of the command, but it might include
       additional data such as the number of rows processed. The caller
       should not free the result directly. It will be freed when the
       associated <structname>PGresult</> handle is passed to
       <function>PQclear</function>.
      </para>
____________________________________________________________________________-->
      <para>
       通常这就是该命令的名称，但是它可能包括额外数据，例如已被处理的行数。调用者不应该直接释放该结果。它将在相关的<structname>PGresult</>句柄被传递给<function>PQclear</function>之后被释放。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqcmdtuples">
<!--==========================orignal english content==========================
     <term>
      <function>PQcmdTuples</function>
      <indexterm>
       <primary>PQcmdTuples</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQcmdTuples</function>
      <indexterm>
       <primary>PQcmdTuples</primary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       Returns the number of rows affected by the SQL command.
<synopsis>
char *PQcmdTuples(PGresult *res);
</synopsis>
      </para>
____________________________________________________________________________-->
      <para>
       返回受该 SQL 命令影响的行数。
<synopsis>
char *PQcmdTuples(PGresult *res);
</synopsis>
      </para>

<!--==========================orignal english content==========================
      <para>
       This function returns a string containing the number of rows
       affected by the <acronym>SQL</> statement that generated the
       <structname>PGresult</>. This function can only be used following
       the execution of a <command>SELECT</>, <command>CREATE TABLE AS</>,
       <command>INSERT</>, <command>UPDATE</>, <command>DELETE</>,
       <command>MOVE</>, <command>FETCH</>, or <command>COPY</> statement,
       or an <command>EXECUTE</> of a prepared query that contains an
       <command>INSERT</>, <command>UPDATE</>, or <command>DELETE</> statement.
       If the command that generated the <structname>PGresult</> was anything
       else, <function>PQcmdTuples</> returns an empty string. The caller
       should not free the return value directly. It will be freed when
       the associated <structname>PGresult</> handle is passed to
       <function>PQclear</function>.
      </para>
____________________________________________________________________________-->
      <para>
       这个函数返回一个字符串，其中包含着产生<structname>PGresult</>的<acronym>SQL</>语句影响的行数。这个只能被用于下列情况：执行一个<command>SELECT</>、<command>CREATE TABLE AS</>、<command>INSERT</>、<command>UPDATE</>、<command>DELETE</>、<command>MOVE</>、<command>FETCH</>或<command>COPY</>语句，或者一个包含<command>INSERT</>、<command>UPDATE</>或<command>DELETE</>语句的预备查询的<command>EXECUTE</>。如果产生<structname>PGresult</>的命令是其他什么东西，<function>PQcmdTuples</>会返回一个空串。调用者不应该直接释放该结果。它将在相关的<structname>PGresult</>句柄被传递给<function>PQclear</function>之后被释放。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqoidvalue">
<!--==========================orignal english content==========================
     <term>
      <function>PQoidValue</function>
      <indexterm>
       <primary>PQoidValue</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQoidValue</function>
      <indexterm>
       <primary>PQoidValue</primary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       Returns the OID<indexterm><primary>OID</><secondary>in libpq</></>
       of the inserted row, if the <acronym>SQL</> command was an
       <command>INSERT</> that inserted exactly one row into a table that
       has OIDs, or a <command>EXECUTE</> of a prepared query containing
       a suitable <command>INSERT</> statement.  Otherwise, this function
       returns <literal>InvalidOid</literal>. This function will also
       return <literal>InvalidOid</literal> if the table affected by the
       <command>INSERT</> statement does not contain OIDs.
<synopsis>
Oid PQoidValue(const PGresult *res);
</synopsis>
      </para>
____________________________________________________________________________-->
      <para>
       如果该<acronym>SQL</>命令是一个正好将一行插入到具有 OID 的表的<command>INSERT</>，或者是一个包含合适<command>INSERT</>语句的预备查询的<command>EXECUTE</>，这个函数返回被插入行的 OID<indexterm><primary>OID</><secondary>in libpq</></>。否则，这个函数返回<literal>InvalidOid</literal>。如果被<command>INSERT</>语句影响的表不包含 OID，这个函数也将返回<literal>InvalidOid</literal>。
<synopsis>
Oid PQoidValue(const PGresult *res);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqoidstatus">
<!--==========================orignal english content==========================
     <term>
      <function>PQoidStatus</function>
      <indexterm>
       <primary>PQoidStatus</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQoidStatus</function>
      <indexterm>
       <primary>PQoidStatus</primary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       This function is deprecated in favor of
       <function>PQoidValue</function> and is not thread-safe.
       It returns a string with the OID of the inserted row, while
       <function>PQoidValue</function> returns the OID value.
<synopsis>
char *PQoidStatus(const PGresult *res);
</synopsis>
      </para>
____________________________________________________________________________-->
      <para>
       由于支持<function>PQoidValue</function>以及不是线程安全的，这个函数已经被废弃。它返回包含被插入行的 OID 的一个字符串，而<function>PQoidValue</function>返回 OID 值。
<synopsis>
char *PQoidStatus(const PGresult *res);
</synopsis>
      </para>

     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>

  <sect2 id="libpq-exec-escape-string">
<!--==========================orignal english content==========================
   <title>Escaping Strings for Inclusion in SQL Commands</title>
____________________________________________________________________________-->
   <title>用于包含在 SQL 命令中的转移字符串</title>

<!--==========================orignal english content==========================
   <indexterm zone="libpq-exec-escape-string">
    <primary>escaping strings</primary>
    <secondary>in libpq</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="libpq-exec-escape-string">
    <primary>escaping strings</primary>
    <secondary>in libpq</secondary>
   </indexterm>

   <variablelist>
    <varlistentry id="libpq-pqescapeliteral">
<!--==========================orignal english content==========================
     <term>
      <function>PQescapeLiteral</function>
      <indexterm>
       <primary>PQescapeLiteral</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQescapeLiteral</function>
      <indexterm>
       <primary>PQescapeLiteral</primary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
     <para>
<synopsis>
char *PQescapeLiteral(PGconn *conn, const char *str, size_t length);
</synopsis>
     </para>
____________________________________________________________________________-->
     <para>
<synopsis>
char *PQescapeLiteral(PGconn *conn, const char *str, size_t length);
</synopsis>
     </para>

<!--==========================orignal english content==========================
     <para>
      <function>PQescapeLiteral</function> escapes a string for
      use within an SQL command.  This is useful when inserting data
      values as literal constants in SQL commands.  Certain characters
      (such as quotes and backslashes) must be escaped to prevent them
      from being interpreted specially by the SQL parser.
      <function>PQescapeLiteral</> performs this operation.
     </para>
____________________________________________________________________________-->
     <para>
      为了让一个串能用在 SQL 命令中，<function>PQescapeLiteral</function>可对它进行转义。当在 SQL 命令中插入一个数据值作为文字常量时，这个函数很有用。一些字符（例如引号和反斜线）必须被转义以防止它们被 SQL 解析器解释成特殊的意思。<function>PQescapeLiteral</>执行这种操作。
     </para>

<!--==========================orignal english content==========================
     <para>
      <function>PQescapeLiteral</> returns an escaped version of the
      <parameter>str</parameter> parameter in memory allocated with
      <function>malloc()</>.  This memory should be freed using
      <function>PQfreemem()</> when the result is no longer needed.
      A terminating zero byte is not required, and should not be
      counted in <parameter>length</>.  (If a terminating zero byte is found
      before <parameter>length</> bytes are processed,
      <function>PQescapeLiteral</> stops at the zero; the behavior is
      thus rather like <function>strncpy</>.) The
      return string has all special characters replaced so that they can
      be properly processed by the <productname>PostgreSQL</productname>
      string literal parser.  A terminating zero byte is also added.  The
      single quotes that must surround <productname>PostgreSQL</productname>
      string literals are included in the result string.
     </para>
____________________________________________________________________________-->
     <para>
      <function>PQescapeLiteral</>返回一个<parameter>str</parameter>参数的已被转义版本，该版本被放在用<function>malloc()</>分配的内存中。当该结果不再被需要时，这个内存应该用<function>PQfreemem()</>释放。一个终止的零字节不是必须的，并且不应该被计入<parameter>length</>（如果在<parameter>length</>字节被处理之前找到一个终止字节，<function>PQescapeLiteral</>会停止在零，该行为更像<function>strncpy</>）。返回串中的所有特殊字符都被替换掉，这样它们能被<productname>PostgreSQL</productname>字符串解析器正确地处理。还会加上一个终止零字节。包括在结果串中的<productname>PostgreSQL</productname>字符串必须用单引号包围。
     </para>

<!--==========================orignal english content==========================
     <para>
      On error, <function>PQescapeLiteral</> returns <symbol>NULL</> and a suitable
      message is stored in the <parameter>conn</> object.
     </para>
____________________________________________________________________________-->
     <para>
      发生错误时，<function>PQescapeLiteral</>返回<symbol>NULL</>并且一个合适的消息会被存储在<parameter>conn</>对象中。
     </para>

     <tip>
<!--==========================orignal english content==========================
      <para>
       It is especially important to do proper escaping when handling
       strings that were received from an untrustworthy source.
       Otherwise there is a security risk: you are vulnerable to
       <quote>SQL injection</> attacks wherein unwanted SQL commands are
       fed to your database.
      </para>
____________________________________________________________________________-->
      <para>
       在处理从一个非可信源接收到的串时，做正确的转义特别重要。否则就会有安全性风险：你容易受到<quote>SQL 注入</>攻击，其中可能会有预期之外的 SQL 语句会被喂给你的数据库。
      </para>
     </tip>

<!--==========================orignal english content==========================
     <para>
      Note that it is not necessary nor correct to do escaping when a data
      value is passed as a separate parameter in <function>PQexecParams</> or
      its sibling routines.
     </para>
____________________________________________________________________________-->
     <para>
      注意，当一个数据值被作为<function>PQexecParams</>或其兄弟例程中的一个独立参数传递时，没有必要做转义而且做转义也不正确。
     </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqescapeidentifier">
<!--==========================orignal english content==========================
     <term>
      <function>PQescapeIdentifier</function>
      <indexterm>
       <primary>PQescapeIdentifier</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQescapeIdentifier</function>
      <indexterm>
       <primary>PQescapeIdentifier</primary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
     <para>
<synopsis>
char *PQescapeIdentifier(PGconn *conn, const char *str, size_t length);
</synopsis>
     </para>
____________________________________________________________________________-->
     <para>
<synopsis>
char *PQescapeIdentifier(PGconn *conn, const char *str, size_t length);
</synopsis>
     </para>

<!--==========================orignal english content==========================
     <para>
      <function>PQescapeIdentifier</function> escapes a string for
      use as an SQL identifier, such as a table, column, or function name.
      This is useful when a user-supplied identifier might contain
      special characters that would otherwise not be interpreted as part
      of the identifier by the SQL parser, or when the identifier might
      contain upper case characters whose case should be preserved.
     </para>
____________________________________________________________________________-->
     <para>
      <function>PQescapeIdentifier</function>转义一个要用作 SQL 标识符的字符串，例如表名、列名或函数名。当一个用户提供的标识符可能包含被 SQL 解析器解释为标识符一部分的特殊字符时，或者当该标识符可能包含大小写形式应该被保留的大写字符时，这个函数很有用。
     </para>

<!--==========================orignal english content==========================
     <para>
      <function>PQescapeIdentifier</> returns a version of the
      <parameter>str</parameter> parameter escaped as an SQL identifier
      in memory allocated with <function>malloc()</>.  This memory must be
      freed using <function>PQfreemem()</> when the result is no longer
      needed.  A terminating zero byte is not required, and should not be
      counted in <parameter>length</>.  (If a terminating zero byte is found
      before <parameter>length</> bytes are processed,
      <function>PQescapeIdentifier</> stops at the zero; the behavior is
      thus rather like <function>strncpy</>.) The
      return string has all special characters replaced so that it
      will be properly processed as an SQL identifier.  A terminating zero byte
      is also added.  The return string will also be surrounded by double
      quotes.
     </para>
____________________________________________________________________________-->
     <para>
      <function>PQescapeIdentifier</>返回一个<parameter>str</parameter>参数的已被转义为 SQL 标识符的版本，该版本被放在用<function>malloc()</>分配的内存中。当该结果不再被需要时，这个内存应该用<function>PQfreemem()</>释放。一个终止的零字节不是必须的，并且不应该被计入<parameter>length</>（如果在<parameter>length</>字节被处理之前找到一个终止字节，<function>PQescapeIdentifier</>会停止在零，该行为更像<function>strncpy</>）。返回串中的所有特殊字符都被替换掉，这样它们能被作为一个 SQL 标识符正确地处理。还会加上一个终止零字节。返回串也将被双引号包围。
     </para>

<!--==========================orignal english content==========================
     <para>
      On error, <function>PQescapeIdentifier</> returns <symbol>NULL</> and a suitable
      message is stored in the <parameter>conn</> object.
     </para>
____________________________________________________________________________-->
     <para>
      发生错误时，<function>PQescapeIdentifier</>返回<symbol>NULL</>并且一个合适的消息会被存储在<parameter>conn</>对象中。
     </para>

     <tip>
<!--==========================orignal english content==========================
      <para>
       As with string literals, to prevent SQL injection attacks,
       SQL identifiers must be escaped when they are received from an
       untrustworthy source.
      </para>
____________________________________________________________________________-->
      <para>
       与字符串一样，要阻止 SQL 注入攻击，当从一个不可信的来源接收到 SQL 标识符时，它们必须被转义。
      </para>
     </tip>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqescapestringconn">
<!--==========================orignal english content==========================
     <term>
      <function>PQescapeStringConn</function>
      <indexterm>
       <primary>PQescapeStringConn</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQescapeStringConn</function>
      <indexterm>
       <primary>PQescapeStringConn</primary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
     <para>
<synopsis>
size_t PQescapeStringConn(PGconn *conn,
                          char *to, const char *from, size_t length,
                          int *error);
</synopsis>
     </para>
____________________________________________________________________________-->
     <para>
<synopsis>
size_t PQescapeStringConn(PGconn *conn,
                          char *to, const char *from, size_t length,
                          int *error);
</synopsis>
     </para>

<!--==========================orignal english content==========================
     <para>
      <function>PQescapeStringConn</> escapes string literals, much like
      <function>PQescapeLiteral</>.  Unlike <function>PQescapeLiteral</>,
      the caller is responsible for providing an appropriately sized buffer.
      Furthermore, <function>PQescapeStringConn</> does not generate the
      single quotes that must surround <productname>PostgreSQL</> string
      literals; they should be provided in the SQL command that the
      result is inserted into.  The parameter <parameter>from</> points to
      the first character of the string that is to be escaped, and the
      <parameter>length</> parameter gives the number of bytes in this
      string.  A terminating zero byte is not required, and should not be
      counted in <parameter>length</>.  (If a terminating zero byte is found
      before <parameter>length</> bytes are processed,
      <function>PQescapeStringConn</> stops at the zero; the behavior is
      thus rather like <function>strncpy</>.) <parameter>to</> shall point
      to a buffer that is able to hold at least one more byte than twice
      the value of <parameter>length</>, otherwise the behavior is undefined.
      Behavior is likewise undefined if the <parameter>to</> and
      <parameter>from</> strings overlap.
     </para>
____________________________________________________________________________-->
     <para>
      <function>PQescapeStringConn</>转义字符串，它很像<function>PQescapeLiteral</>。与<function>PQescapeLiteral</>不一样的是，调用者负责提供一个合适尺寸的缓冲区。此外，<function>PQescapeStringConn</>不产生必须包围<productname>PostgreSQL</>字符串的单引号。它们应该在结果要插入的 SQL 命令中提供。参数<parameter>from</>指向要被转义的串的第一个字符，并且<parameter>length</>参数给出了这个串中的字节数。一个终止的零字节不是必须的，并且不应该被计入<parameter>length</>（如果在<parameter>length</>字节被处理之前找到一个终止字节，<function>PQescapeStringConn</>会停止在零，该行为更像<function>strncpy</>）。 <parameter>to</>应当指向一个缓冲区，它能够保持至少比<parameter>length</>值的两倍还要多至少一个字节，否则该行为是未被定义的。如果<parameter>to</>和<parameter>from</>串重叠，行为也是未被定义的。
     </para>

<!--==========================orignal english content==========================
     <para>
      If the <parameter>error</> parameter is not <symbol>NULL</>, then
      <literal>*error</> is set to zero on success, nonzero on error.
      Presently the only possible error conditions involve invalid multibyte
      encoding in the source string.  The output string is still generated
      on error, but it can be expected that the server will reject it as
      malformed.  On error, a suitable message is stored in the
      <parameter>conn</> object, whether or not <parameter>error</> is <symbol>NULL</>.
     </para>
____________________________________________________________________________-->
     <para>
      如果<parameter>error</>参数不是<symbol>NULL</>，那么成功时<literal>*error</>被设置为零，错误时设置为非零。当前唯一可能的错误情况涉及源串中非法的多字节编码。错误时仍然会产生输出串，但是可以预期服务器将认为它是畸形的并且拒绝它。在发生错误时，一个合适的消息被存储在<parameter>conn</>对象中，不管<parameter>error</>是不是<symbol>NULL</>。
     </para>

<!--==========================orignal english content==========================
     <para>
      <function>PQescapeStringConn</> returns the number of bytes written
      to <parameter>to</>, not including the terminating zero byte.
     </para>
____________________________________________________________________________-->
     <para>
      <function>PQescapeStringConn</>返回写到<parameter>to</>的字节数，不包括终止的零字节。
     </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqescapestring">
<!--==========================orignal english content==========================
     <term>
      <function>PQescapeString</function>
      <indexterm>
       <primary>PQescapeString</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQescapeString</function>
      <indexterm>
       <primary>PQescapeString</primary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
     <para>
       <function>PQescapeString</> is an older, deprecated version of
       <function>PQescapeStringConn</>.
<synopsis>
size_t PQescapeString (char *to, const char *from, size_t length);
</synopsis>
     </para>
____________________________________________________________________________-->
     <para>
       <function>PQescapeString</>是一个更老的被废弃的<function>PQescapeStringConn</>版本。
<synopsis>
size_t PQescapeString (char *to, const char *from, size_t length);
</synopsis>
     </para>

<!--==========================orignal english content==========================
     <para>
      The only difference from <function>PQescapeStringConn</> is that
      <function>PQescapeString</> does not take <structname>PGconn</>
      or <parameter>error</> parameters.
      Because of this, it cannot adjust its behavior depending on the
      connection properties (such as character encoding) and therefore
      <emphasis>it might give the wrong results</>.  Also, it has no way
      to report error conditions.
     </para>
____________________________________________________________________________-->
     <para>
      <function>PQescapeStringConn</>和<function>PQescapeString</>之间的唯一区别是不需要<structname>PGconn</>或<parameter>error</>参数。正因为如此，它不能基于连接属性（例如字符编码）调整它的行为并且因此<emphasis>它可能给出错误的结果</>。还有，它没有方法报告错误情况。
     </para>

<!--==========================orignal english content==========================
     <para>
      <function>PQescapeString</> can be used safely in
      client programs that work with only one <productname>PostgreSQL</>
      connection at a time (in this case it can find out what it needs to
      know <quote>behind the scenes</>).  In other contexts it is a security
      hazard and should be avoided in favor of
      <function>PQescapeStringConn</>.
     </para>
____________________________________________________________________________-->
     <para>
      <function>PQescapeString</>可以在一次只使用一个<productname>PostgreSQL</>连接的客户端程序中安全地使用（在这种情况下它可以<quote>在现象后面</>找出它需要知道的东西）。在其他环境中它是一个安全性灾难并且应该用<function>PQescapeStringConn</>来避免。
     </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqescapebyteaconn">
<!--==========================orignal english content==========================
     <term>
      <function>PQescapeByteaConn</function>
      <indexterm>
       <primary>PQescapeByteaConn</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQescapeByteaConn</function>
      <indexterm>
       <primary>PQescapeByteaConn</primary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
     <para>
       Escapes binary data for use within an SQL command with the type
       <type>bytea</type>.  As with <function>PQescapeStringConn</function>,
       this is only used when inserting data directly into an SQL command string.
<synopsis>
unsigned char *PQescapeByteaConn(PGconn *conn,
                                 const unsigned char *from,
                                 size_t from_length,
                                 size_t *to_length);
</synopsis>
      </para>
____________________________________________________________________________-->
     <para>
       把要用于一个 SQL 命令的二进制数据用类型<type>bytea</type>转义。和<function>PQescapeStringConn</function>一样，只有在将数据直接插入到一个 SQL 命令串时才使用它。
<synopsis>
unsigned char *PQescapeByteaConn(PGconn *conn,
                                 const unsigned char *from,
                                 size_t from_length,
                                 size_t *to_length);
</synopsis>
      </para>

<!--==========================orignal english content==========================
      <para>
       Certain byte values must be escaped when used as part of a
       <type>bytea</type> literal in an <acronym>SQL</acronym> statement.
       <function>PQescapeByteaConn</function> escapes bytes using
       either hex encoding or backslash escaping.  See <xref
       linkend="datatype-binary"> for more information.
      </para>
____________________________________________________________________________-->
      <para>
       当某些字节值被用作一个<acronym>SQL</acronym>语句中的<type>bytea</type>文字的一部分时，它们必须被转义。<function>PQescapeByteaConn</function>转义使用十六进制编码或反斜线转义的字节。详见<xref linkend="datatype-binary">。
      </para>

<!--==========================orignal english content==========================
      <para>
       The <parameter>from</parameter> parameter points to the first
       byte of the string that is to be escaped, and the
       <parameter>from_length</parameter> parameter gives the number of
       bytes in this binary string.  (A terminating zero byte is
       neither necessary nor counted.)  The <parameter>to_length</parameter>
       parameter points to a variable that will hold the resultant
       escaped string length. This result string length includes the terminating
       zero byte of the result.
      </para>
____________________________________________________________________________-->
      <para>
       <parameter>from</parameter>参数指向要被转义的串的第一个字节，并且<parameter>from_length</parameter>参数给出这个二进制串中的字节数（一个终止的零字节是不需要的也是不被计算的）。<parameter>to_length</parameter>参数指向一个将保持生成的已转义串长度的变量。这个结果串长度包括结果的终止零字节。
      </para>

<!--==========================orignal english content==========================
      <para>
       <function>PQescapeByteaConn</> returns an escaped version of the
       <parameter>from</parameter> parameter binary string in memory
       allocated with <function>malloc()</>.  This memory should be freed using
       <function>PQfreemem()</> when the result is no longer needed.  The
       return string has all special characters replaced so that they can
       be properly processed by the <productname>PostgreSQL</productname>
       string literal parser, and the <type>bytea</type> input function. A
       terminating zero byte is also added.  The single quotes that must
       surround <productname>PostgreSQL</productname> string literals are
       not part of the result string.
      </para>
____________________________________________________________________________-->
      <para>
       <function>PQescapeByteaConn</>返回一个<parameter>from</parameter>参数的已被转义为二进制串的版本，该版本被放在用<function>malloc()</>分配的内存中。当该结果不再被需要时，这个内存应该用<function>PQfreemem()</>释放。返回串中的所有特殊字符都被替换掉，这样它们能被<productname>PostgreSQL</productname>的字符串解析器以及<type>bytea</type>输入函数正确地处理。还会加上一个终止零字节。不是结果串一部分的<productname>PostgreSQL</productname>字符串必须被单引号包围。
      </para>

<!--==========================orignal english content==========================
      <para>
       On error, a null pointer is returned, and a suitable error message
       is stored in the <parameter>conn</> object.  Currently, the only
       possible error is insufficient memory for the result string.
      </para>
____________________________________________________________________________-->
      <para>
       在发生错误时，将返回一个空指针，并且一个合适的错误消息被存储在<parameter>conn</>对象中。当前，唯一可能的错误是没有足够的内存用于结果串。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqescapebytea">
<!--==========================orignal english content==========================
     <term>
      <function>PQescapeBytea</function>
      <indexterm>
       <primary>PQescapeBytea</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQescapeBytea</function>
      <indexterm>
       <primary>PQescapeBytea</primary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       <function>PQescapeBytea</> is an older, deprecated version of
       <function>PQescapeByteaConn</>.
<synopsis>
unsigned char *PQescapeBytea(const unsigned char *from,
                             size_t from_length,
                             size_t *to_length);
</synopsis>
      </para>
____________________________________________________________________________-->
      <para>
       <function>PQescapeBytea</>是一个更老的被废弃的<function>PQescapeByteaConn</>版本。
<synopsis>
unsigned char *PQescapeBytea(const unsigned char *from,
                             size_t from_length,
                             size_t *to_length);
</synopsis>
      </para>

<!--==========================orignal english content==========================
      <para>
       The only difference from <function>PQescapeByteaConn</> is that
       <function>PQescapeBytea</> does not take a <structname>PGconn</>
       parameter.  Because of this, <function>PQescapeBytea</> can
       only be used safely in client programs that use a single
       <productname>PostgreSQL</> connection at a time (in this case
       it can find out what it needs to know <quote>behind the
       scenes</>).  It <emphasis>might give the wrong results</> if
       used in programs that use multiple database connections (use
       <function>PQescapeByteaConn</> in such cases).
      </para>
____________________________________________________________________________-->
      <para>
       与<function>PQescapeByteaConn</>的唯一区别是<function>PQescapeBytea</>不用一个<structname>PGconn</>参数。正因为这样，<function>PQescapeBytea</>只能在一次只使用一个<productname>PostgreSQL</>连接的客户端程序中安全地使用（在这种情况下它可以<quote>在现象后面</>找出它需要知道的东西）。如果在有多个数据库连接的程序中使用，它<emphasis>可能给出错误的结果</>（在那种情况下使用<function>PQescapeByteaConn</>）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqunescapebytea">
<!--==========================orignal english content==========================
     <term>
      <function>PQunescapeBytea</function>
      <indexterm>
       <primary>PQunescapeBytea</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQunescapeBytea</function>
      <indexterm>
       <primary>PQunescapeBytea</primary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       Converts a string representation of binary data into binary data
       &mdash; the reverse of <function>PQescapeBytea</function>.  This
       is needed when retrieving <type>bytea</type> data in text format,
       but not when retrieving it in binary format.

<synopsis>
unsigned char *PQunescapeBytea(const unsigned char *from, size_t *to_length);
</synopsis>
      </para>
____________________________________________________________________________-->
      <para>
       将二进制数据的一个字符串表示转换成二进制数据 &mdash; 它是<function>PQescapeBytea</function>的逆向函数。当检索文本格式的<type>bytea</type>数据时，需要这个函数，但检索二进制个事时则不需要它。

<synopsis>
unsigned char *PQunescapeBytea(const unsigned char *from, size_t *to_length);
</synopsis>
      </para>

<!--==========================orignal english content==========================
      <para>
       The <parameter>from</parameter> parameter points to a string
       such as might be returned by <function>PQgetvalue</function> when applied
       to a <type>bytea</type> column. <function>PQunescapeBytea</function>
       converts this string representation into its binary representation.
       It returns a pointer to a buffer allocated with
       <function>malloc()</function>, or <symbol>NULL</> on error, and puts the size of
       the buffer in <parameter>to_length</parameter>. The result must be
       freed using <function>PQfreemem</> when it is no longer needed.
      </para>
____________________________________________________________________________-->
      <para>
       <parameter>from</parameter>参数指向一个字符串，例如<function>PQgetvalue</function>被应用到一个<type>bytea</type>列上所返回的。<function>PQunescapeBytea</function>把这个串表示转换成它的二进制表示。它返回一个指向用<function>malloc()</function>分配的缓冲区的指针，在错误时返回<symbol>NULL</>，并且把缓冲区的尺寸放在<parameter>to_length</parameter>中。当结果不再需要时，它必须使用<function>PQfreemem</>释放。
      </para>

<!--==========================orignal english content==========================
      <para>
       This conversion is not exactly the inverse of
       <function>PQescapeBytea</function>, because the string is not expected
       to be <quote>escaped</> when received from <function>PQgetvalue</function>.
       In particular this means there is no need for string quoting considerations,
       and so no need for a <structname>PGconn</> parameter.
      </para>
____________________________________________________________________________-->
      <para>
       这种转换并不完全是<function>PQescapeBytea</function>的逆函数，因为当从<function>PQgetvalue</function>接收到字符串时，我们并不能期待它被<quote>转义</>。特别地这意味着不需要考虑字符串引用，并且因此也不需要一个参数。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>

 </sect1>

 <sect1 id="libpq-async">
<!--==========================orignal english content==========================
  <title>Asynchronous Command Processing</title>
____________________________________________________________________________-->
  <title>异步命令处理</title>

<!--==========================orignal english content==========================
  <indexterm zone="libpq-async">
   <primary>nonblocking connection</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="libpq-async">
   <primary>非阻塞连接</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The <function>PQexec</function> function is adequate for submitting
   commands in normal, synchronous applications.  It has a few
   deficiencies, however, that can be of importance to some users:

   <itemizedlist>
    <listitem>
     <para>
      <function>PQexec</function> waits for the command to be completed.
      The application might have other work to do (such as maintaining a
      user interface), in which case it won't want to block waiting for
      the response.
     </para>
    </listitem>

    <listitem>
     <para>
      Since the execution of the client application is suspended while it
      waits for the result, it is hard for the application to decide that
      it would like to try to cancel the ongoing command.  (It can be done
      from a signal handler, but not otherwise.)
     </para>
    </listitem>

    <listitem>
     <para>
      <function>PQexec</function> can return only one
      <structname>PGresult</structname> structure.  If the submitted command
      string contains multiple <acronym>SQL</acronym> commands, all but
      the last <structname>PGresult</structname> are discarded by
      <function>PQexec</function>.
     </para>
    </listitem>

    <listitem>
     <para>
      <function>PQexec</function> always collects the command's entire result,
      buffering it in a single <structname>PGresult</structname>.  While
      this simplifies error-handling logic for the application, it can be
      impractical for results containing many rows.
     </para>
    </listitem>
   </itemizedlist>
  </para>
____________________________________________________________________________-->
  <para>
   <function>PQexec</function>函数对于在普通的同步应用中提交命令是足以胜任的。不过，它的一些缺点可能对某些用户很重要： 

   <itemizedlist>
    <listitem>
     <para>
      <function>PQexec</function>会等待命令完成。该应用可能有其他的工作要做（例如维护用户界面），这时它将不希望阻塞等待回应。
     </para>
    </listitem>

    <listitem>
     <para>
      因为客户端应用的执行在它等待结果时会被挂起，对于应用来说很难决定要不要尝试取消正在进行的命令（这可以在一个信号处理器中完成，但别无他法）。
     </para>
    </listitem>

    <listitem>
     <para>
      <function>PQexec</function>只能返回一个<structname>PGresult</structname>结构。如果提交的命令串包含多个<acronym>SQL</acronym>命令， 除了最后一个<structname>PGresult</structname>之外都会被<function>PQexec</function>丢弃。
     </para>
    </listitem>

    <listitem>
     <para>
      <function>PQexec</function>总是收集命令的整个结果，把它缓存在一个单一的<structname>PGresult</structname>中。虽然这简化了应用的错误处理逻辑，它对于包含很多行的结果并不现实。
     </para>
    </listitem>
   </itemizedlist>
  </para>

<!--==========================orignal english content==========================
  <para>
   Applications that do not like these limitations can instead use the
   underlying functions that <function>PQexec</function> is built from:
   <function>PQsendQuery</function> and <function>PQgetResult</function>.
   There are also
   <function>PQsendQueryParams</function>,
   <function>PQsendPrepare</function>,
   <function>PQsendQueryPrepared</function>,
   <function>PQsendDescribePrepared</function>, and
   <function>PQsendDescribePortal</function>,
   which can be used with <function>PQgetResult</function> to duplicate
   the functionality of
   <function>PQexecParams</function>,
   <function>PQprepare</function>,
   <function>PQexecPrepared</function>,
   <function>PQdescribePrepared</function>, and
   <function>PQdescribePortal</function>
   respectively.

   <variablelist>
    <varlistentry id="libpq-pqsendquery">
     <term>
      <function>PQsendQuery</function>
      <indexterm>
       <primary>PQsendQuery</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       Submits a command to the server without waiting for the result(s).
       1 is returned if the command was successfully dispatched and 0 if
       not (in which case, use <function>PQerrorMessage</> to get more
       information about the failure).
<synopsis>
int PQsendQuery(PGconn *conn, const char *command);
</synopsis>

       After successfully calling <function>PQsendQuery</function>, call
       <function>PQgetResult</function> one or more times to obtain the
       results.  <function>PQsendQuery</function> cannot be called again
       (on the same connection) until <function>PQgetResult</function>
       has returned a null pointer, indicating that the command is done.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsendqueryparams">
     <term>
      <function>PQsendQueryParams</function>
      <indexterm>
       <primary>PQsendQueryParams</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       Submits a command and separate parameters to the server without
       waiting for the result(s).
<synopsis>
int PQsendQueryParams(PGconn *conn,
                      const char *command,
                      int nParams,
                      const Oid *paramTypes,
                      const char * const *paramValues,
                      const int *paramLengths,
                      const int *paramFormats,
                      int resultFormat);
</synopsis>

       This is equivalent to <function>PQsendQuery</function> except that
       query parameters can be specified separately from the query string.
       The function's parameters are handled identically to
       <function>PQexecParams</function>.  Like
       <function>PQexecParams</function>, it will not work on 2.0-protocol
       connections, and it allows only one command in the query string.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsendprepare">
     <term>
      <function>PQsendPrepare</>
      <indexterm>
       <primary>PQsendPrepare</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       Sends a request to create a prepared statement with the given
       parameters, without waiting for completion.
<synopsis>
int PQsendPrepare(PGconn *conn,
                  const char *stmtName,
                  const char *query,
                  int nParams,
                  const Oid *paramTypes);
</synopsis>

       This is an asynchronous version of <function>PQprepare</>: it
       returns 1 if it was able to dispatch the request, and 0 if not.
       After a successful call, call <function>PQgetResult</function> to
       determine whether the server successfully created the prepared
       statement.  The function's parameters are handled identically to
       <function>PQprepare</function>.  Like
       <function>PQprepare</function>, it will not work on 2.0-protocol
       connections.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsendqueryprepared">
     <term>
      <function>PQsendQueryPrepared</function>
      <indexterm>
       <primary>PQsendQueryPrepared</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       Sends a request to execute a prepared statement with given
       parameters, without waiting for the result(s).
<synopsis>
int PQsendQueryPrepared(PGconn *conn,
                        const char *stmtName,
                        int nParams,
                        const char * const *paramValues,
                        const int *paramLengths,
                        const int *paramFormats,
                        int resultFormat);
</synopsis>

       This is similar to <function>PQsendQueryParams</function>, but
       the command to be executed is specified by naming a
       previously-prepared statement, instead of giving a query string.
       The function's parameters are handled identically to
       <function>PQexecPrepared</function>.  Like
       <function>PQexecPrepared</function>, it will not work on
       2.0-protocol connections.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsenddescribeprepared">
     <term>
      <function>PQsendDescribePrepared</>
      <indexterm>
       <primary>PQsendDescribePrepared</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       Submits a request to obtain information about the specified
       prepared statement, without waiting for completion.
<synopsis>
int PQsendDescribePrepared(PGconn *conn, const char *stmtName);
</synopsis>

       This is an asynchronous version of <function>PQdescribePrepared</>:
       it returns 1 if it was able to dispatch the request, and 0 if not.
       After a successful call, call <function>PQgetResult</function> to
       obtain the results.  The function's parameters are handled
       identically to <function>PQdescribePrepared</function>.  Like
       <function>PQdescribePrepared</function>, it will not work on
       2.0-protocol connections.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsenddescribeportal">
     <term>
      <function>PQsendDescribePortal</>
      <indexterm>
       <primary>PQsendDescribePortal</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       Submits a request to obtain information about the specified
       portal, without waiting for completion.
<synopsis>
int PQsendDescribePortal(PGconn *conn, const char *portalName);
</synopsis>

       This is an asynchronous version of <function>PQdescribePortal</>:
       it returns 1 if it was able to dispatch the request, and 0 if not.
       After a successful call, call <function>PQgetResult</function> to
       obtain the results.  The function's parameters are handled
       identically to <function>PQdescribePortal</function>.  Like
       <function>PQdescribePortal</function>, it will not work on
       2.0-protocol connections.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqgetresult">
     <term>
      <function>PQgetResult</function>
      <indexterm>
       <primary>PQgetResult</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       Waits for the next result from a prior
       <function>PQsendQuery</function>,
       <function>PQsendQueryParams</function>,
       <function>PQsendPrepare</function>,
       <function>PQsendQueryPrepared</function>,
       <function>PQsendDescribePrepared</function>, or
       <function>PQsendDescribePortal</function>
       call, and returns it.
       A null pointer is returned when the command is complete and there
       will be no more results.
<synopsis>
PGresult *PQgetResult(PGconn *conn);
</synopsis>
      </para>

      <para>
       <function>PQgetResult</function> must be called repeatedly until
       it returns a null pointer, indicating that the command is done.
       (If called when no command is active,
       <function>PQgetResult</function> will just return a null pointer
       at once.) Each non-null result from
       <function>PQgetResult</function> should be processed using the
       same <structname>PGresult</> accessor functions previously
       described.  Don't forget to free each result object with
       <function>PQclear</function> when done with it.  Note that
       <function>PQgetResult</function> will block only if a command is
       active and the necessary response data has not yet been read by
       <function>PQconsumeInput</function>.
      </para>

      <note>
       <para>
        Even when <function>PQresultStatus</function> indicates a fatal
        error, <function>PQgetResult</function> should be called until it
        returns a null pointer, to allow <application>libpq</> to
        process the error information completely.
       </para>
      </note>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   不想受到这些限制的应用可以改用构建<function>PQexec</function>的底层函数：<function>PQsendQuery</function>以及<function>PQgetResult</function>。还有
   <function>PQsendQueryParams</function>、
   <function>PQsendPrepare</function>、
   <function>PQsendQueryPrepared</function>、
   <function>PQsendDescribePrepared</function>以及
   <function>PQsendDescribePortal</function>，
   它们可以与<function>PQgetResult</function>一起使用来分别复制<function>PQexecParams</function>、
   <function>PQprepare</function>、
   <function>PQexecPrepared</function>、
   <function>PQdescribePrepared</function>和
   <function>PQdescribePortal</function>的功能。

   <variablelist>
    <varlistentry id="libpq-pqsendquery">
     <term>
      <function>PQsendQuery</function>
      <indexterm>
       <primary>PQsendQuery</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       向服务器提交一个命令而不等待结果。如果该命令被成功发送则返回 1，否则返回 0（此时，可以用<function>PQerrorMessage</>获取关于失败的信息）。
<synopsis>
int PQsendQuery(PGconn *conn, const char *command);
</synopsis>

       在成功调用<function>PQsendQuery</function>后，调用<function>PQgetResult</function>一次或者多次来获取结果。在<function>PQgetResult</function>返回一个空指针之前，都不能再次调用<function>PQsendQuery</function>，返回的空指针指示该命令已经完成。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsendqueryparams">
     <term>
      <function>PQsendQueryParams</function>
      <indexterm>
       <primary>PQsendQueryParams</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       向服务器提交一个命令和单独的参数，而不等待结果。
<synopsis>
int PQsendQueryParams(PGconn *conn,
                      const char *command,
                      int nParams,
                      const Oid *paramTypes,
                      const char * const *paramValues,
                      const int *paramLengths,
                      const int *paramFormats,
                      int resultFormat);
</synopsis>

       这个函数等效于<function>PQsendQuery</function>，不过查询参数可以独立于查询字符串分开指定。该函数的参数处理和<function>PQexecParams</function>一样。和<function>PQexecParams</function>类似，它不能在 2.0 协议的连接上工作，并且它只允许在查询字符串中有一条命令。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsendprepare">
     <term>
      <function>PQsendPrepare</>
      <indexterm>
       <primary>PQsendPrepare</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       发送一个请求用给定参数创建一个预备语句，而不等待完成。
<synopsis>
int PQsendPrepare(PGconn *conn,
                  const char *stmtName,
                  const char *query,
                  int nParams,
                  const Oid *paramTypes);
</synopsis>

       这个函数是<function>PQprepare</>的异步版本：如果它能发送这个请求，则返回 1；如果不能，则返回 0。在成功调用之后，调用<function>PQgetResult</function>判断服务器是否成功创建了预备语句。这个函数的参数的处理和<function>PQprepare</function>一样。和<function>PQprepare</function>类似，它不能在 2.0 协议的连接上工作。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsendqueryprepared">
     <term>
      <function>PQsendQueryPrepared</function>
      <indexterm>
       <primary>PQsendQueryPrepared</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       发送一个请求用给定参数执行一个预备语句，而不等待结果。
<synopsis>
int PQsendQueryPrepared(PGconn *conn,
                        const char *stmtName,
                        int nParams,
                        const char * const *paramValues,
                        const int *paramLengths,
                        const int *paramFormats,
                        int resultFormat);
</synopsis>

       这个函数与<function>PQsendQueryParams</function>类似，但是要执行的命令是通过一个之前已经命名的预备语句指定， 而不是一个给出的查询字符串。该函数的参数处理和<function>PQexecPrepared</function>一样。和<function>PQexecPrepared</function>类似，它不能在 2.0 协议的连接上工作。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsenddescribeprepared">
     <term>
      <function>PQsendDescribePrepared</>
      <indexterm>
       <primary>PQsendDescribePrepared</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       发送一个请求获得指定的预备语句的信息，但不等待完成。
<synopsis>
int PQsendDescribePrepared(PGconn *conn, const char *stmtName);
</synopsis>

       这个函数是<function>PQdescribePrepared</>的一个异步版本：如果它能够发送请求，则返回 1；否则，返回 0。在一次成功的调用后，调用<function>PQgetResult</function>来得到结果。该函数的参数处理和<function>PQdescribePrepared</function>一样。和<function>PQdescribePrepared</function>类似，它不能在 2.0 协议的连接上工作。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsenddescribeportal">
     <term>
      <function>PQsendDescribePortal</>
      <indexterm>
       <primary>PQsendDescribePortal</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       提交一个请求来获得关于指定入口的信息，但不等待完成。
<synopsis>
int PQsendDescribePortal(PGconn *conn, const char *portalName);
</synopsis>

       这个函数是<function>PQdescribePortal</>的一个异步版本：如果它能够发送请求，则返回 1；否则，返回 0。在一次成功的调用后，调用<function>PQgetResult</function>来得到结果。该函数的参数处理和<function>PQdescribePortal</function>一样。和<function>PQdescribePortal</function>类似，它不能在 2.0 协议的连接上工作。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqgetresult">
     <term>
      <function>PQgetResult</function>
      <indexterm>
       <primary>PQgetResult</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       等待来自于一个之前的
       <function>PQsendQuery</function>、
       <function>PQsendQueryParams</function>、
       <function>PQsendPrepare</function>、
       <function>PQsendQueryPrepared</function>、
       <function>PQsendDescribePrepared</function>或
       <function>PQsendDescribePortal</function>调用的结果，并且返回它。当该命令完成并且没有更多结果时，将返回一个空指针。
<synopsis>
PGresult *PQgetResult(PGconn *conn);
</synopsis>
      </para>

      <para>
       <function>PQgetResult</function>必须被反复调用直到它返回一个空指针，空指针表示该命令完成（如果在没有命令活动时被调用，<function>PQgetResult</function>将立即返回一个空指针）。每一个来自<function>PQgetResult</function>的非空结果应该使用之前描述的同一个<structname>PGresult</>访问器处理。不要忘记在处理完之后释放每一个结果对象。注意，只有一个命令是活动的并且<function>PQconsumeInput</function>还没有读取必要的响应数据时， <function>PQgetResult</function>将会阻塞。
      </para>

      <note>
       <para>
        即使当<function>PQresultStatus</function>指出一个致命错误时，<function>PQgetResult</function>也应当被调用直到它返回一个空指针，以允许<application>libpq</>完全处理该错误信息。
       </para>
      </note>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

<!--==========================orignal english content==========================
  <para>
   Using <function>PQsendQuery</function> and
   <function>PQgetResult</function> solves one of
   <function>PQexec</function>'s problems:  If a command string contains
   multiple <acronym>SQL</acronym> commands, the results of those commands
   can be obtained individually.  (This allows a simple form of overlapped
   processing, by the way: the client can be handling the results of one
   command while the server is still working on later queries in the same
   command string.)
  </para>
____________________________________________________________________________-->
  <para>
   使用<function>PQsendQuery</function>和<function>PQgetResult</function>解决了<function>PQexec</function>的一个问题：如果一个命令字符串包含多个<acronym>SQL</acronym>命令，这些命令的结果可以被个别地获得（顺便说一句：这样就允许一种简单的重叠处理形式， 客户端可以处理一个命令的结果，而同时服务器可以继续处理同一命令字符串中后面的查询）。
  </para>

<!--==========================orignal english content==========================
  <para>
   Another frequently-desired feature that can be obtained with
   <function>PQsendQuery</function> and <function>PQgetResult</function>
   is retrieving large query results a row at a time.  This is discussed
   in <xref linkend="libpq-single-row-mode">.
  </para>
____________________________________________________________________________-->
  <para>
   可以被<function>PQsendQuery</function>和<function>PQgetResult</function>获得的另一种常常想要的特性是一次从大型结果中检索一行。这会在<xref linkend="libpq-single-row-mode">中讨论。
  </para>

<!--==========================orignal english content==========================
  <para>
   By itself, calling <function>PQgetResult</function>
   will still cause the client to block until the server completes the
   next <acronym>SQL</acronym> command.  This can be avoided by proper
   use of two more functions:

   <variablelist>
    <varlistentry id="libpq-pqconsumeinput">
     <term>
      <function>PQconsumeInput</function>
      <indexterm>
       <primary>PQconsumeInput</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       If input is available from the server, consume it.
<synopsis>
int PQconsumeInput(PGconn *conn);
</synopsis>
      </para>

      <para>
       <function>PQconsumeInput</function> normally returns 1 indicating
       <quote>no error</quote>, but returns 0 if there was some kind of
       trouble (in which case <function>PQerrorMessage</function> can be
       consulted).  Note that the result does not say whether any input
       data was actually collected. After calling
       <function>PQconsumeInput</function>, the application can check
       <function>PQisBusy</function> and/or
       <function>PQnotifies</function> to see if their state has changed.
      </para>

      <para>
       <function>PQconsumeInput</function> can be called even if the
       application is not prepared to deal with a result or notification
       just yet.  The function will read available data and save it in
       a buffer, thereby causing a <function>select()</function>
       read-ready indication to go away.  The application can thus use
       <function>PQconsumeInput</function> to clear the
       <function>select()</function> condition immediately, and then
       examine the results at leisure.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqisbusy">
     <term>
      <function>PQisBusy</function>
      <indexterm>
       <primary>PQisBusy</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       Returns 1 if a command is busy, that is,
       <function>PQgetResult</function> would block waiting for input.
       A 0 return indicates that <function>PQgetResult</function> can be
       called with assurance of not blocking.
<synopsis>
int PQisBusy(PGconn *conn);
</synopsis>
      </para>

      <para>
       <function>PQisBusy</function> will not itself attempt to read data
       from the server; therefore <function>PQconsumeInput</function>
       must be invoked first, or the busy state will never end.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   如果只调用<function>PQgetResult</function>（不调用<function>PQsendQuery</function>等）将仍会导致客户端阻塞直到服务器完成下一个<acronym>SQL</acronym>命令。用两个函数的正确使用可以避免这种情况：

   <variablelist>
    <varlistentry id="libpq-pqconsumeinput">
     <term>
      <function>PQconsumeInput</function>
      <indexterm>
       <primary>PQconsumeInput</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       如果有来自服务器的输入可用，则使用之。
<synopsis>
int PQconsumeInput(PGconn *conn);
</synopsis>
      </para>

      <para>
       <function>PQconsumeInput</function>通常返回 1 表明<quote>没有错误</quote>，而返回 0 表明有某种麻烦发生（此时可以用<function>PQerrorMessage</function>）。注意该结果并不表明是否真正收集了任何输入数据。在调用<function>PQconsumeInput</function>之后，应用可以检查<function>PQisBusy</function>和/或<function>PQnotifies</function>来看看它们的状态是否改变。
      </para>

      <para>
       即使应用还不准备处理一个结果或通知，<function>PQconsumeInput</function>也可以被调用。这个函数将读取可用的数 据并且把它保存在一个缓冲区中，从而导致一个<function>select()</function>的读准备好指示消失。因此应用可以使用<function>PQconsumeInput</function>立即清除<function>select()</function>条件，并且在空闲时再检查结果。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqisbusy">
     <term>
      <function>PQisBusy</function>
      <indexterm>
       <primary>PQisBusy</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       如果一个命令繁忙则返回 1，也就是说<function>PQgetResult</function>会阻塞等待输入。返回 0 表示可以调用<function>PQgetResult</function>而不用担心阻塞。
<synopsis>
int PQisBusy(PGconn *conn);
</synopsis>
      </para>

      <para>
       <function>PQisBusy</function>本身将不会尝试从服务器读取数据，因此必须先调用<function>PQconsumeInput</function>，否则繁忙状态将永远不会结束。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

<!--==========================orignal english content==========================
  <para>
   A typical application using these functions will have a main loop that
   uses <function>select()</function> or <function>poll()</> to wait for
   all the conditions that it must respond to.  One of the conditions
   will be input available from the server, which in terms of
   <function>select()</function> means readable data on the file
   descriptor identified by <function>PQsocket</function>.  When the main
   loop detects input ready, it should call
   <function>PQconsumeInput</function> to read the input.  It can then
   call <function>PQisBusy</function>, followed by
   <function>PQgetResult</function> if <function>PQisBusy</function>
   returns false (0).  It can also call <function>PQnotifies</function>
   to detect <command>NOTIFY</> messages (see <xref
   linkend="libpq-notify">).
  </para>
____________________________________________________________________________-->
  <para>
   一个使用这些函数的典型应用将有一个主循环，在主循环中会使用<function>select()</function>或<function>poll()</>等待所有它必须响应的情况。其中之一将是来自服务器的输入可用，对<function>select()</function>来说意味着<function>PQsocket</function>标识的文件描述符上有可读的数据。当主循环检测到输入准备好时，它将调用<function>PQconsumeInput</function>读取输入。然后它可以调用<function>PQisBusy</function>，如果<function>PQisBusy</function>返回假（0）则接着调用<function>PQgetResult</function>。它还可以调用<function>PQnotifies</function>检测<command>NOTIFY</>消息（见<xref linkend="libpq-notify">）。
  </para>

<!--==========================orignal english content==========================
  <para>
   A client that uses
   <function>PQsendQuery</function>/<function>PQgetResult</function>
   can also attempt to cancel a command that is still being processed
   by the server; see <xref linkend="libpq-cancel">.  But regardless of
   the return value of <function>PQcancel</function>, the application
   must continue with the normal result-reading sequence using
   <function>PQgetResult</function>.  A successful cancellation will
   simply cause the command to terminate sooner than it would have
   otherwise.
  </para>
____________________________________________________________________________-->
  <para>
   一个使用<function>PQsendQuery</function>/<function>PQgetResult</function>的客户端也可以尝试取消一个正在被服务器处理的命令，见<xref linkend="libpq-cancel">。但是，不管<function>PQcancel</function>的返回值是什么，应用都必须继续使用<function>PQgetResult</function>进行正常的结果读取序列。一次成功的取消只会导致命令比不取消时更快终止。
  </para>

<!--==========================orignal english content==========================
  <para>
   By using the functions described above, it is possible to avoid
   blocking while waiting for input from the database server.  However,
   it is still possible that the application will block waiting to send
   output to the server.  This is relatively uncommon but can happen if
   very long SQL commands or data values are sent.  (It is much more
   probable if the application sends data via <command>COPY IN</command>,
   however.)  To prevent this possibility and achieve completely
   nonblocking database operation, the following additional functions
   can be used.

   <variablelist>
    <varlistentry id="libpq-pqsetnonblocking">
     <term>
      <function>PQsetnonblocking</function>
      <indexterm>
       <primary>PQsetnonblocking</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       Sets the nonblocking status of the connection.
<synopsis>
int PQsetnonblocking(PGconn *conn, int arg);
</synopsis>
      </para>

      <para>
       Sets the state of the connection to nonblocking if
       <parameter>arg</parameter> is 1, or blocking if
       <parameter>arg</parameter> is 0.  Returns 0 if OK, -1 if error.
      </para>

      <para>
       In the nonblocking state, calls to
       <function>PQsendQuery</function>, <function>PQputline</function>,
       <function>PQputnbytes</function>, <function>PQputCopyData</function>,
       and <function>PQendcopy</function> will not block but instead return
       an error if they need to be called again.
      </para>

      <para>
       Note that <function>PQexec</function> does not honor nonblocking
       mode; if it is called, it will act in blocking fashion anyway.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqisnonblocking">
     <term>
      <function>PQisnonblocking</function>
      <indexterm>
       <primary>PQisnonblocking</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       Returns the blocking status of the database connection.
<synopsis>
int PQisnonblocking(const PGconn *conn);
</synopsis>
      </para>

      <para>
       Returns 1 if the connection is set to nonblocking mode and 0 if
       blocking.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqflush">
     <term>
      <function>PQflush</function>
       <indexterm>
        <primary>PQflush</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
       Attempts to flush any queued output data to the server.  Returns
       0 if successful (or if the send queue is empty), -1 if it failed
       for some reason, or 1 if it was unable to send all the data in
       the send queue yet (this case can only occur if the connection
       is nonblocking).
<synopsis>
int PQflush(PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   通过使用上述函数，我们可以避免在等待来自数据库服务器的输入时被阻塞。不过，在应用发送输出给服务器时还是可能出现阻塞。这种情况比较少见，但是如果发送非常长的 SQL 命令或者数据值时确实可能发生（不过，最有可能是在应用通过<command>COPY IN</command>发送数据时）。为了避免这种可能性并且实现完全地非阻塞数据库操作，可以使用下列附加函数。

   <variablelist>
    <varlistentry id="libpq-pqsetnonblocking">
     <term>
      <function>PQsetnonblocking</function>
      <indexterm>
       <primary>PQsetnonblocking</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       把连接的状态设置为非阻塞。
<synopsis>
int PQsetnonblocking(PGconn *conn, int arg);
</synopsis>
      </para>

      <para>
       如果<parameter>arg</parameter>为 1，把连接状态设置为非阻塞；如果<parameter>arg</parameter>为 0，把连接状态设置为阻塞。如果 OK 返回 0，如果错误返回 -1。
      </para>

      <para>
       在非阻塞状态，调用
       <function>PQsendQuery</function>、<function>PQputline</function>、
       <function>PQputnbytes</function>、<function>PQputCopyData</function>和
       <function>PQendcopy</function>将不会阻塞，但是如果它们需要被再次调用则会返回一个错误。
      </para>

      <para>
       注意<function>PQexec</function>不会遵循任何非阻塞模式；如果调用<function>PQexec</function>，那么它的行为总是阻塞的。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqisnonblocking">
     <term>
      <function>PQisnonblocking</function>
      <indexterm>
       <primary>PQisnonblocking</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回数据库连接的阻塞状态。
<synopsis>
int PQisnonblocking(const PGconn *conn);
</synopsis>
      </para>

      <para>
       如果连接被设置为非阻塞状态，返回 1，如果是阻塞状态返回 0。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqflush">
     <term>
      <function>PQflush</function>
       <indexterm>
        <primary>PQflush</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
       尝试把任何正在排队的输出数据刷到服务器。如果成功（或者发送队列为空）返回 0， 如果因某种原因失败则返回 -1，或者如果还无法把发送队列中的所有数据都发送出去，则返回 1（这种情况只在连接为非阻塞时候才会发生）。
<synopsis>
int PQflush(PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
  
<!--==========================orignal english content==========================
  <para>
   After sending any command or data on a nonblocking connection, call
   <function>PQflush</function>.  If it returns 1, wait for the socket
   to become read- or write-ready.  If it becomes write-ready, call
   <function>PQflush</function> again.  If it becomes read-ready, call
   <function>PQconsumeInput</function>, then call
   <function>PQflush</function> again.  Repeat until
   <function>PQflush</function> returns 0.  (It is necessary to check for
   read-ready and drain the input with <function>PQconsumeInput</function>,
   because the server can block trying to send us data, e.g. NOTICE
   messages, and won't read our data until we read its.)  Once
   <function>PQflush</function> returns 0, wait for the socket to be
   read-ready and then read the response as described above.
  </para>
____________________________________________________________________________-->
  <para>
   在一个非阻塞连接上发送任何命令或者数据之后，要调用<function>PQflush</function>。
   如果它返回 1，就要等待套接字变成读准备好或写准备好。如果它变为写准备好，应再次调用
   <function>PQflush</function>。如果它变为读准备好，则应先调用
   <function>PQconsumeInput</function>，然后再调用<function>PQflush</function>。
   一直重复直到<function>PQflush</function>返回 0（有必要检查读准备好并且用
   <function>PQconsumeInput</function>耗尽输入，因为服务器可能阻塞给我们发送数据
   的尝试，例如 NOTICE 消息，并且在我们读它的数据之前它都不会读我们的数据）。一旦
   <function>PQflush</function>返回 0，应等待套接字变成读准备好并且接着按照上文所述
   读取响应。
  </para>


 </sect1>

 <sect1 id="libpq-single-row-mode">
<!--==========================orignal english content==========================
  <title>Retrieving Query Results Row-By-Row</title>
____________________________________________________________________________-->
  <title>一行一行地检索查询结果</title>

<!--==========================orignal english content==========================
  <indexterm zone="libpq-single-row-mode">
   <primary>libpq</primary>
   <secondary>single-row mode</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="libpq-single-row-mode">
   <primary>libpq</primary>
   <secondary>single-row mode</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   Ordinarily, <application>libpq</> collects a SQL command's
   entire result and returns it to the application as a single
   <structname>PGresult</structname>.  This can be unworkable for commands
   that return a large number of rows.  For such cases, applications can use
   <function>PQsendQuery</function> and <function>PQgetResult</function> in
   <firstterm>single-row mode</>.  In this mode, the result row(s) are
   returned to the application one at a time, as they are received from the
   server.
  </para>
____________________________________________________________________________-->
  <para>
   通常，<application>libpq</>会收集一个 SQL 命令的整个结果并且把它作为单个<structname>PGresult</structname>返回给应用。这对于返回大量行的命令是行不通的。对于这类情况，应用可以使用<function>PQsendQuery</function>和<function>PQgetResult</function>的<firstterm>单行模式</>。在这种模式中，结果行以一次一行的方式被返回给应用。
  </para>

<!--==========================orignal english content==========================
  <para>
   To enter single-row mode, call <function>PQsetSingleRowMode</function>
   immediately after a successful call of <function>PQsendQuery</function>
   (or a sibling function).  This mode selection is effective only for the
   currently executing query.  Then call <function>PQgetResult</function>
   repeatedly, until it returns null, as documented in <xref
   linkend="libpq-async">.  If the query returns any rows, they are returned
   as individual <structname>PGresult</structname> objects, which look like
   normal query results except for having status code
   <literal>PGRES_SINGLE_TUPLE</literal> instead of
   <literal>PGRES_TUPLES_OK</literal>.  After the last row, or immediately if
   the query returns zero rows, a zero-row object with status
   <literal>PGRES_TUPLES_OK</literal> is returned; this is the signal that no
   more rows will arrive.  (But note that it is still necessary to continue
   calling <function>PQgetResult</function> until it returns null.)  All of
   these <structname>PGresult</structname> objects will contain the same row
   description data (column names, types, etc) that an ordinary
   <structname>PGresult</structname> object for the query would have.
   Each object should be freed with <function>PQclear</function> as usual.
  </para>
____________________________________________________________________________-->
  <para>
   要进入到单行模式，在一次成功的<function>PQsendQuery</function>（或者其他兄弟函数）调用后立即调用<function>PQsetSingleRowMode</function>。这种模式选择只对当前正在执行的查询有效。然后反复调用<function>PQgetResult</function>，直到它返回空，如<xref linkend="libpq-async">中所示。如果该查询返回行，它们会作为单个的<structname>PGresult</structname>对象返回，它们看起来都像普通的查询结果，只不过其状态代码是<literal>PGRES_SINGLE_TUPLE</literal>而非<literal>PGRES_TUPLES_OK</literal>。在最后一行之后或者紧接着该查询返回零行之后，一个状态为<literal>PGRES_TUPLES_OK</literal>的零行对象会被返回，这就是代表不会有更多行的信号（但是注意仍然有必要继续调用<function>PQgetResult</function>直到它返回空）。所有这些<structname>PGresult</structname>对象将包含相同的行描述数据（列名、类型等等），这些数据和通常一个查询的<structname>PGresult</structname>对象的相同。每一个对象都应该按常规用<function>PQclear</function>释放。
  </para>

<!--==========================orignal english content==========================
  <para>
   <variablelist>
    <varlistentry id="libpq-pqsetsinglerowmode">
     <term>
      <function>PQsetSingleRowMode</function>
      <indexterm>
       <primary>PQsetSingleRowMode</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       Select single-row mode for the currently-executing query.

<synopsis>
int PQsetSingleRowMode(PGconn *conn);
</synopsis>
      </para>

      <para>
       This function can only be called immediately after
       <function>PQsendQuery</function> or one of its sibling functions,
       before any other operation on the connection such as
       <function>PQconsumeInput</function> or
       <function>PQgetResult</function>.  If called at the correct time,
       the function activates single-row mode for the current query and
       returns 1.  Otherwise the mode stays unchanged and the function
       returns 0.  In any case, the mode reverts to normal after
       completion of the current query.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   <variablelist>
    <varlistentry id="libpq-pqsetsinglerowmode">
     <term>
      <function>PQsetSingleRowMode</function>
      <indexterm>
       <primary>PQsetSingleRowMode</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       为当前正在执行的查询选择单行模式。

<synopsis>
int PQsetSingleRowMode(PGconn *conn);
</synopsis>
      </para>

      <para>
       这个函数只能在调用<function>PQsendQuery</function>或一个其兄弟函数之后立刻调用，并且要在任何连接上的其他操作之前调用，例如<function>PQconsumeInput</function>或<function>PQgetResult</function>。如果在正确的时间被调用，该函数会为当前查询激活单行模式并且返回 1。否则模式会保持不变并且该函数返回 0。在任何情况下，当前查询结束之后模式都会恢复到正常。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <caution>
<!--==========================orignal english content==========================
   <para>
    While processing a query, the server may return some rows and then
    encounter an error, causing the query to be aborted.  Ordinarily,
    <application>libpq</> discards any such rows and reports only the
    error.  But in single-row mode, those rows will have already been
    returned to the application.  Hence, the application will see some
    <literal>PGRES_SINGLE_TUPLE</literal> <structname>PGresult</structname>
    objects followed by a <literal>PGRES_FATAL_ERROR</literal> object.  For
    proper transactional behavior, the application must be designed to
    discard or undo whatever has been done with the previously-processed
    rows, if the query ultimately fails.
   </para>
____________________________________________________________________________-->
   <para>
    在处理一个查询时，服务器可能返回一些行并且接着遇到一个错误导致查询被中断。通常，<application>libpq</>会丢弃掉这样的行并且至报告错误。但是在单行模式中，那些行（错误之前返回的行）已经被返回给应用。因此，应用将看到一些<literal>PGRES_SINGLE_TUPLE</literal> <structname>PGresult</structname>对象并且然后看到一个<literal>PGRES_FATAL_ERROR</literal>对象。为了得到正确的事务行为，如果查询最终失败，应用必须被设计为丢弃或者撤销使用之前处理的行完成的事情。
   </para>
  </caution>

 </sect1>

 <sect1 id="libpq-cancel">
<!--==========================orignal english content==========================
  <title>Canceling Queries in Progress</title>
____________________________________________________________________________-->
  <title>取消进行中的查询</title>

<!--==========================orignal english content==========================
  <indexterm zone="libpq-cancel">
   <primary>canceling</primary>
   <secondary>SQL command</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="libpq-cancel">
   <primary>canceling</primary>
   <secondary>SQL command</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   A client application can request cancellation of a command that is
   still being processed by the server, using the functions described in
   this section.

   <variablelist>
    <varlistentry id="libpq-pqgetcancel">
     <term>
      <function>PQgetCancel</function>
      <indexterm>
       <primary>PQgetCancel</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       Creates a data structure containing the information needed to cancel
       a command issued through a particular database connection.
<synopsis>
PGcancel *PQgetCancel(PGconn *conn);
</synopsis>
      </para>

      <para>
       <function>PQgetCancel</function> creates a
       <structname>PGcancel</><indexterm><primary>PGcancel</></> object
       given a <structname>PGconn</> connection object.  It will return
       <symbol>NULL</> if the given <parameter>conn</> is <symbol>NULL</> or an invalid
       connection.  The <structname>PGcancel</> object is an opaque
       structure that is not meant to be accessed directly by the
       application; it can only be passed to <function>PQcancel</function>
       or <function>PQfreeCancel</function>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfreecancel">
     <term>
      <function>PQfreeCancel</function>
      <indexterm>
       <primary>PQfreeCancel</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       Frees a data structure created by <function>PQgetCancel</function>.
<synopsis>
void PQfreeCancel(PGcancel *cancel);
</synopsis>
      </para>

      <para>
       <function>PQfreeCancel</function> frees a data object previously created
       by <function>PQgetCancel</function>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqcancel">
     <term>
      <function>PQcancel</function>
      <indexterm>
       <primary>PQcancel</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       Requests that the server abandon processing of the current command.
<synopsis>
int PQcancel(PGcancel *cancel, char *errbuf, int errbufsize);
</synopsis>
      </para>

      <para>
       The return value is 1 if the cancel request was successfully
       dispatched and 0 if not.  If not, <parameter>errbuf</> is filled
       with an explanatory error message.  <parameter>errbuf</>
       must be a char array of size <parameter>errbufsize</> (the
       recommended size is 256 bytes).
      </para>

      <para>
       Successful dispatch is no guarantee that the request will have
       any effect, however.  If the cancellation is effective, the current
       command will terminate early and return an error result.  If the
       cancellation fails (say, because the server was already done
       processing the command), then there will be no visible result at
       all.
      </para>

      <para>
       <function>PQcancel</function> can safely be invoked from a signal
       handler, if the <parameter>errbuf</> is a local variable in the
       signal handler.  The <structname>PGcancel</> object is read-only
       as far as <function>PQcancel</function> is concerned, so it can
       also be invoked from a thread that is separate from the one
       manipulating the <structname>PGconn</> object.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   <variablelist>
    <varlistentry id="libpq-pqrequestcancel">
     <term>
      <function>PQrequestCancel</function>
      <indexterm>
       <primary>PQrequestCancel</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       <function>PQrequestCancel</function> is a deprecated variant of
       <function>PQcancel</function>.
<synopsis>
int PQrequestCancel(PGconn *conn);
</synopsis>
      </para>

      <para>
       Requests that the server abandon processing of the current
       command.  It operates directly on the
       <structname>PGconn</> object, and in case of failure stores the
       error message in the <structname>PGconn</> object (whence it can
       be retrieved by <function>PQerrorMessage</function>).  Although
       the functionality is the same, this approach creates hazards for
       multiple-thread programs and signal handlers, since it is possible
       that overwriting the <structname>PGconn</>'s error message will
       mess up the operation currently in progress on the connection.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   一个客户端应用可以使用本节描述的函数请求取消一个仍在被服务器处理的命令。

   <variablelist>
    <varlistentry id="libpq-pqgetcancel">
     <term>
      <function>PQgetCancel</function>
      <indexterm>
       <primary>PQgetCancel</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       创建一个数据结构，这个数据结构包含取消一个通过特定数据库连接发出的命令所需要的信息。
<synopsis>
PGcancel *PQgetCancel(PGconn *conn);
</synopsis>
      </para>

      <para>
       给出一个PQgetCancel连接对象，PQgetCancel创建一个 PGcancel对象。如果给出 的conn是NULL或者是一个无效的连接，那么它将返回NULL。PGcancel对象是一个不透明的结构， 不应该为应用所直接访问；我们只能把它传递给PQcancel或者PQfreeCancel。
       给定一个<structname>PGconn</>连接对象，<function>PQgetCancel</function>创建一个<structname>PGcancel</><indexterm><primary>PGcancel</></>对象。如果给定的<parameter>conn</>为<symbol>NULL</>或者一个不合法的连接，它将返回<symbol>NULL</>。<structname>PGcancel</>对象是一个透明的结构，它不能直接被应用访问。它只能被传递给<function>PQcancel</function>或<function>PQfreeCancel</function>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfreecancel">
     <term>
      <function>PQfreeCancel</function>
      <indexterm>
       <primary>PQfreeCancel</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       释放一个由<function>PQgetCancel</function>创建的数据结构。
<synopsis>
void PQfreeCancel(PGcancel *cancel);
</synopsis>
      </para>

      <para>
       PQfreeCancel释放一个由前面的PQgetCancel创建的数据对象。
       <function>PQfreeCancel</function>释放一个之前由<function>PQgetCancel</function>创建的数据对象。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqcancel">
     <term>
      <function>PQcancel</function>
      <indexterm>
       <primary>PQcancel</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       要求服务器放弃当前命令的处理。
<synopsis>
int PQcancel(PGcancel *cancel, char *errbuf, int errbufsize);
</synopsis>
      </para>

      <para>
       如果取消请求成功发送，则返回值为 1，否则为 0。如果不成功，则<parameter>errbuf</>会被填充一个解释性的错误消息。<parameter>errbuf</>必须是一个尺寸为<parameter>errbufsize</>的字符数组（推荐尺寸为 256 字节）。，解释为何不成功。errbuf必须是 一个大小为errbufsize的 char 数组（建议大小为 256 字节）。
      </para>

      <para>
       不过，成功的发送并不保证请求会有任何效果。如果取消有效，那么当前的命令将提前终止并且返回一个错误结果。如果取消失败（也就是说， 因为服务器已经完成命令的处理），那么就根本不会有可见的结果。
      </para>

      <para>
       如果PQcancel是信号句柄里的一个局部变量，那么PQcancel可以在一个信号 句柄里安全地调用。在PQcancel涉及的范围里，PQcancel对象都是只读的， 因此我们也可以从一个与处理PGconn对象的线程分离的线程里处理它。
       如果<parameter>errbuf</>是信号处理器中的一个局部变量，<function>PQcancel</function>可以从一个信号处理器中安全地调用。在<structname>PGcancel</>有关的范围内，<function>PQcancel</function>都是只读的，因此也可以在一个从操纵<structname>PGconn</>对象的线程中独立出来的线程中调用它。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   <variablelist>
    <varlistentry id="libpq-pqrequestcancel">
     <term>
      <function>PQrequestCancel</function>
      <indexterm>
       <primary>PQrequestCancel</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       <function>PQrequestCancel</function>是<function>PQcancel</function>的一个被废弃的变体。
<synopsis>
int PQrequestCancel(PGconn *conn);
</synopsis>
      </para>

      <para>
       要求服务器放弃当前命令的处理。它直接在<structname>PGconn</>对象上进行操作， 并且如果失败，就会在<structname>PGconn</>对象里存储错误消息（因此可以用<function>PQerrorMessage</function>检索出来）。 尽管功能相同，这个方法在多线程程序里和信号处理器里会带来危险，因为它可能 覆盖<structname>PGconn</>的错误消息，进而将当前连接上正在处理的操作搞乱。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

 </sect1>

 <sect1 id="libpq-fastpath">
<!--==========================orignal english content==========================
  <title>The Fast-Path Interface</title>
____________________________________________________________________________-->
  <title>快速路径接口</title>

<!--==========================orignal english content==========================
  <indexterm zone="libpq-fastpath">
   <primary>fast path</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="libpq-fastpath">
   <primary>fast path</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname> provides a fast-path interface
   to send simple function calls to the server.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>提供一种快速路径接口来向服务器发送简单的函数调用。
  </para>

  <tip>
<!--==========================orignal english content==========================
   <para>
    This interface is somewhat obsolete, as one can achieve similar
    performance and greater functionality by setting up a prepared
    statement to define the function call.  Then, executing the statement
    with binary transmission of parameters and results substitutes for a
    fast-path function call.
   </para>
____________________________________________________________________________-->
   <para>
    这个接口在某种程度上已被废弃，因为我们可以通过创建一个定义该函数调用的预备语句来达到类似或者更强大的功能。然后，用参数和结果的二进制传输执行该语句，从而取代快速函数调用。 
   </para>
  </tip>

<!--==========================orignal english content==========================
  <para>
   The function <function>PQfn</function><indexterm><primary>PQfn</></>
   requests execution of a server function via the fast-path interface:
<synopsis>
PGresult *PQfn(PGconn *conn,
               int fnid,
               int *result_buf,
               int *result_len,
               int result_is_int,
               const PQArgBlock *args,
               int nargs);

typedef struct
{
    int len;
    int isint;
    union
    {
        int *ptr;
        int integer;
    } u;
} PQArgBlock;
</synopsis>
  </para>
____________________________________________________________________________-->
  <para>
   函数<function>PQfn</function><indexterm><primary>PQfn</></>请求通过快速路径接口执行服务器函数。
<synopsis>
PGresult *PQfn(PGconn *conn,
               int fnid,
               int *result_buf,
               int *result_len,
               int result_is_int,
               const PQArgBlock *args,
               int nargs);

typedef struct
{
    int len;
    int isint;
    union
    {
        int *ptr;
        int integer;
    } u;
} PQArgBlock;
</synopsis>
  </para>

<!--==========================orignal english content==========================
  <para>
   The <parameter>fnid</> argument is the OID of the function to be
   executed.  <parameter>args</> and <parameter>nargs</> define the
   parameters to be passed to the function; they must match the declared
   function argument list.  When the <parameter>isint</> field of a
   parameter structure is true, the <parameter>u.integer</> value is sent
   to the server as an integer of the indicated length (this must be
   2 or 4 bytes); proper byte-swapping occurs.  When <parameter>isint</>
   is false, the indicated number of bytes at <parameter>*u.ptr</> are
   sent with no processing; the data must be in the format expected by
   the server for binary transmission of the function's argument data
   type.  (The declaration of <parameter>u.ptr</> as being of
   type <type>int *</> is historical; it would be better to consider
   it <type>void *</>.)
   <parameter>result_buf</parameter> points to the buffer in which to place
   the function's return value.  The caller must have allocated sufficient
   space to store the return value.  (There is no check!) The actual result
   length in bytes will be returned in the integer pointed to by
   <parameter>result_len</parameter>.  If a 2- or 4-byte integer result
   is expected, set <parameter>result_is_int</parameter> to 1, otherwise
   set it to 0.  Setting <parameter>result_is_int</parameter> to 1 causes
   <application>libpq</> to byte-swap the value if necessary, so that it
   is delivered as a proper <type>int</type> value for the client machine;
   note that a 4-byte integer is delivered into <parameter>*result_buf</>
   for either allowed result size.
   When <parameter>result_is_int</> is 0, the binary-format byte string
   sent by the server is returned unmodified. (In this case it's better
   to consider <parameter>result_buf</parameter> as being of
   type <type>void *</>.)
  </para>
____________________________________________________________________________-->
  <para>
   <parameter>fnid</>参数是要被执行的函数的 OID。<parameter>args</>和
   <parameter>nargs</>定义了要传递给函数的参数；它们必须匹配已声明的函数
   参数列表。当一个参数结构的<parameter>isint</>域为真时，
   <parameter>u.integer</>值被以指定长度（必须是 2 或者 4 字节）整数的
   形式发送给服务器；这时候会发生恰当的字节交换。当<parameter>isint</>为
   假时，<parameter>*u.ptr</>中指定数量的字节将不做任何处理被发送出去；
   这些数据必须是服务器 预期的用于该函数参数数据类型的二进制传输的格式（由于
   历史原因<parameter>u.ptr</>被声明为类型<type>int *</>，其实把它考虑成
   <type>void *</>会更好）。<parameter>result_buf</parameter>是放置该函
   数返回值的缓冲区。调用者必须已经分配了足够的空间来存储返回值（这里没有检
   查！）。实际的结果长度将被放在<parameter>result_len</parameter>指向的
   整数中返回。如果预期结果是 2 或 4 字节整数，把
   <parameter>result_is_int</parameter>设为 1；否则设为 0。把
   <parameter>result_is_int</parameter>设为 1 导致<application>libpq</>
   在必要时对值进行交换字节，这样它就作为对客户端机器正确的<type>int</type>
   值被传输，注意对任一种允许的结果大小都会传递一个 4 字节到
   <parameter>*result_buf</>。当<parameter>result_is_int</>是 0 时，服务
   器发送的二进制格式字节将不做修改直接返回（在这种情况下，把
   <parameter>result_buf</parameter>考虑为类型<type>void *</>更好）。
  </para>

<!--==========================orignal english content==========================
  <para>
   <function>PQfn</function> always returns a valid
   <structname>PGresult</structname> pointer. The result status should be
   checked before the result is used.   The caller is responsible for
   freeing  the  <structname>PGresult</structname>  with
   <function>PQclear</function> when it is no longer needed.
  </para>
____________________________________________________________________________-->
  <para>
   <function>PQfn</function>总是返回一个有效的<structname>PGresult</structname>指针。在使用结果之前应该检查结果状态。当结果不再使用后，调用者有义务使用<function>PQclear</function>释放<structname>PGresult</structname>。
  </para>

<!--==========================orignal english content==========================
  <para>
   Note that it is not possible to handle null arguments, null results,
   nor set-valued results when using this interface.
  </para>
____________________________________________________________________________-->
  <para>
   注意我们没办法处理空参数、空结果，也没办法在使用这个接口时处理集值结果。
  </para>

 </sect1>

 <sect1 id="libpq-notify">
<!--==========================orignal english content==========================
  <title>Asynchronous Notification</title>
____________________________________________________________________________-->
  <title>异步提示</title>

<!--==========================orignal english content==========================
  <indexterm zone="libpq-notify">
   <primary>NOTIFY</primary>
   <secondary>in libpq</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="libpq-notify">
   <primary>NOTIFY</primary>
   <secondary>in libpq</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname> offers asynchronous notification
   via the <command>LISTEN</command> and <command>NOTIFY</command>
   commands.  A client session registers its interest in a particular
   notification channel with the <command>LISTEN</command> command (and
   can stop listening with the <command>UNLISTEN</command> command).  All
   sessions listening on a particular channel will be notified
   asynchronously when a <command>NOTIFY</command> command with that
   channel name is executed by any session. A <quote>payload</> string can
   be passed to communicate additional data to the listeners.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>通过<command>LISTEN</command>和<command>NOTIFY</command>命令提供了异步通知。一个客户端会话用<command>LISTEN</command>命令在一个特定的通知频道中注册它感兴趣的通知（也可以用<command>UNLISTEN</command>命令停止监听）。当任何会话执行一个带有特定频道名的<command>NOTIFY</command>命令时，所有正在监听该频道的会话会被异步通知。可以传递一个<quote>载荷</>字符串来与监听者沟通附加的数据。
  </para>

<!--==========================orignal english content==========================
  <para>
   <application>libpq</application> applications submit
   <command>LISTEN</command>, <command>UNLISTEN</command>,
   and <command>NOTIFY</command> commands as
   ordinary SQL commands.  The arrival of <command>NOTIFY</command>
   messages can subsequently be detected by calling
   <function>PQnotifies</function>.<indexterm><primary>PQnotifies</></>
  </para>
____________________________________________________________________________-->
  <para>
   <application>libpq</application>应用把<command>LISTEN</command>、<command>UNLISTEN</command>和<command>NOTIFY</command>命令作为通常的 SQL 命令提交。 随后通过调用<function>PQnotifies</function><indexterm><primary>PQnotifies</></>来检测<command>NOTIFY</command>消息的到达。
  </para>

<!--==========================orignal english content==========================
  <para>
   The function <function>PQnotifies</function> returns the next notification
   from a list of unhandled notification messages received from the server.
   It returns a null pointer if there are no pending notifications.  Once a
   notification is returned from <function>PQnotifies</>, it is considered
   handled and will be removed from the list of notifications.

<synopsis>
PGnotify *PQnotifies(PGconn *conn);

typedef struct pgNotify
{
    char *relname;              /* notification channel name */
    int  be_pid;                /* process ID of notifying server process */
    char *extra;                /* notification payload string */
} PGnotify;
</synopsis>

   After processing a <structname>PGnotify</structname> object returned
   by <function>PQnotifies</function>, be sure to free it with
   <function>PQfreemem</function>.  It is sufficient to free the
   <structname>PGnotify</structname> pointer; the
   <structfield>relname</structfield> and <structfield>extra</structfield>
   fields do not represent separate allocations.  (The names of these fields
   are historical; in particular, channel names need not have anything to
   do with relation names.)
  </para>
____________________________________________________________________________-->
  <para>
   函数<function>PQnotifies</function>从来自服务器的未处理通知消息列表中返回下一个通知。如果没有待处理的信息则返回一个空指针。一旦<function>PQnotifies</>返回一个通知，该通知会被认为已处理并且将被从通知列表中删除。

<synopsis>
PGnotify *PQnotifies(PGconn *conn);

typedef struct pgNotify
{
    char *relname;              /* notification channel name */
    int  be_pid;                /* process ID of notifying server process */
    char *extra;                /* notification payload string */
} PGnotify;
</synopsis>

   在处理完<function>PQnotifies</function>返回的<structname>PGnotify</structname>对象后，别忘了用<function>PQfreemem</function>把它释放。释放<structname>PGnotify</structname>指针就足够了；<structfield>relname</structfield>和<structfield>extra</structfield>域并不代表独立分配的内存（这些域的名称是历史性的，尤其是频道名称与关系名称没有什么联系）。
  </para>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="libpq-example-2"> gives a sample program that illustrates
   the use of asynchronous notification.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="libpq-example-2">给出了一个例子程序展示异步通知的使用。
  </para>

<!--==========================orignal english content==========================
  <para>
   <function>PQnotifies</function> does not actually read data from the
   server; it just returns messages previously absorbed by another
   <application>libpq</application> function.  In prior releases of
   <application>libpq</application>, the only way to ensure timely receipt
   of <command>NOTIFY</> messages was to constantly submit commands, even
   empty ones, and then check <function>PQnotifies</function> after each
   <function>PQexec</function>.  While this still works, it is deprecated
   as a waste of processing power.
  </para>
____________________________________________________________________________-->
  <para>
   <function>PQnotifies</function>实际上并不从服务器读取数据；它只是返回被另一个<application>libpq</application>函数之前吸收的消息。在以前的<application>libpq</application>版本中，及时收到<command>NOTIFY</>消息的唯一方法是持续地提交命令，即使是空命令也可以，并且在每次<function>PQexec</function>后检查<function>PQnotifies</function>。 虽然这个方法还能用，但是由于太过浪费处理能力已被废弃。
  </para>

<!--==========================orignal english content==========================
  <para>
   A better way to check for <command>NOTIFY</> messages when you have no
   useful commands to execute is to call
   <function>PQconsumeInput</function>, then check
   <function>PQnotifies</function>.  You can use
   <function>select()</function> to wait for data to arrive from the
   server, thereby using no <acronym>CPU</acronym> power unless there is
   something to do.  (See <function>PQsocket</function> to obtain the file
   descriptor number to use with <function>select()</function>.) Note that
   this will work OK whether you submit commands with
   <function>PQsendQuery</function>/<function>PQgetResult</function> or
   simply use <function>PQexec</function>.  You should, however, remember
   to check <function>PQnotifies</function> after each
   <function>PQgetResult</function> or <function>PQexec</function>, to
   see if any notifications came in during the processing of the command.
  </para>
____________________________________________________________________________-->
  <para>
   当你没有可用的命令提交时，一种更好的检查<command>NOTIFY</>消息的方法是调用<function>PQconsumeInput</function>，然后检查<function>PQnotifies</function>。你可以使用<function>select()</function>来等待服务器数据到达，这样在无事可做时可以不浪费<acronym>CPU</acronym>能力（参考<function>PQsocket</function>来获得用于<function>select()</function>的文件描述符）。注意不管是用<function>PQsendQuery</function>/<function>PQgetResult</function>提交命令还是简单地使用<function>PQexec</function>，这种方法都能正常工作。不过，你应该记住在每次<function>PQgetResult</function>或<function>PQexec</function>之后检查<function>PQnotifies</function>，看看在命令的处理过程中是否有通知到达。
  </para>

 </sect1>

 <sect1 id="libpq-copy">
<!--==========================orignal english content==========================
  <title>Functions Associated with the <command>COPY</command> Command</title>
____________________________________________________________________________-->
  <title><command>COPY</command>命令相关的函数</title>

<!--==========================orignal english content==========================
  <indexterm zone="libpq-copy">
   <primary>COPY</primary>
   <secondary>with libpq</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="libpq-copy">
   <primary>COPY</primary>
   <secondary>with libpq</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The <command>COPY</command> command in
   <productname>PostgreSQL</productname> has options to read from or write
   to the network connection used by <application>libpq</application>.
   The functions described in this section allow applications to take
   advantage of this capability by supplying or consuming copied data.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>中的<command>COPY</command>命令有用于<application>libpq</application>的对网络连接读出或者写入的选项。这一节描述的函数允许应用通过提供或者消耗已拷贝的数据来充分利用这个功能。
  </para>

<!--==========================orignal english content==========================
  <para>
   The overall process is that the application first issues the SQL
   <command>COPY</command> command via <function>PQexec</function> or one
   of the equivalent functions.  The response to this (if there is no
   error in the command) will be a <structname>PGresult</> object bearing
   a status code of <literal>PGRES_COPY_OUT</literal> or
   <literal>PGRES_COPY_IN</literal> (depending on the specified copy
   direction).  The application should then use the functions of this
   section to receive or transmit data rows.  When the data transfer is
   complete, another <structname>PGresult</> object is returned to indicate
   success or failure of the transfer.  Its status will be
   <literal>PGRES_COMMAND_OK</literal> for success or
   <literal>PGRES_FATAL_ERROR</literal> if some problem was encountered.
   At this point further SQL commands can be issued via
   <function>PQexec</function>.  (It is not possible to execute other SQL
   commands using the same connection while the <command>COPY</command>
   operation is in progress.)
  </para>
____________________________________________________________________________-->
  <para>
   整个处理是应用首先通过<function>PQexec</function>或者一个等效的函数发出 SQL <command>COPY</command>命令。对这个命令的响应（如果命令无误）将是一个状态代码是<literal>PGRES_COPY_OUT</literal>或 者<literal>PGRES_COPY_IN</literal>（取决于指定的拷贝方向）的<structname>PGresult</>对象。应用然后就应该使用这一节的函数接收或者传送数据行。在数据传输结束之后，另外一个<structname>PGresult</>对象会被返回以表明传输的成功或者失败。它的状态将是：<literal>PGRES_COMMAND_OK</literal>表示成功，<literal>PGRES_FATAL_ERROR</literal>表示发生了一些问题。此时我们可以通过<function>PQexec</function>发出进一步的 SQL 命令（在<command>COPY</command>操作的处理过程中，不能用同一个连接执行其它 SQL 命令）。
  </para>

<!--==========================orignal english content==========================
  <para>
   If a <command>COPY</command> command is issued via
   <function>PQexec</function> in a string that could contain additional
   commands, the application must continue fetching results via
   <function>PQgetResult</> after completing the <command>COPY</command>
   sequence.  Only when <function>PQgetResult</> returns
   <symbol>NULL</symbol> is it certain that the <function>PQexec</function>
   command string is done and it is safe to issue more commands.
  </para>
____________________________________________________________________________-->
  <para>
   如果一个<command>COPY</command>命令是通过<function>PQexec</function>在一个可能包含额外命令的字符串中发出的，那么应用在完成<command>COPY</command>序列之后必须继续用<function>PQgetResult</>取得结果。只有在<function>PQgetResult</>返回<symbol>NULL</symbol>时，我们才能确信<function>PQexec</function>的命令字符串已经处理完毕， 并且可以安全地发出更多命令。 
  </para>

<!--==========================orignal english content==========================
  <para>
   The functions of this section should be executed only after obtaining
   a result status of <literal>PGRES_COPY_OUT</literal> or
   <literal>PGRES_COPY_IN</literal> from <function>PQexec</function> or
   <function>PQgetResult</function>.
  </para>
____________________________________________________________________________-->
  <para>
   这一节的函数应该只在从<function>PQexec</function>或<function>PQgetResult</function>获得了<literal>PGRES_COPY_OUT</literal>或<literal>PGRES_COPY_IN</literal>结果状态的后执行。
  </para>

<!--==========================orignal english content==========================
  <para>
   A <structname>PGresult</> object bearing one of these status values
   carries some additional data about the <command>COPY</command> operation
   that is starting.  This additional data is available using functions
   that are also used in connection with query results:

   <variablelist>
    <varlistentry id="libpq-pqnfields-1">
     <term>
      <function>PQnfields</function>
      <indexterm>
       <primary>PQnfields</primary>
       <secondary>with COPY</secondary>
      </indexterm>
     </term>

     <listitem>
      <para>
       Returns the number of columns (fields) to be copied.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqbinarytuples-1">
     <term>
      <function>PQbinaryTuples</function>
      <indexterm>
       <primary>PQbinaryTuples</primary>
       <secondary>with COPY</secondary>
      </indexterm>
     </term>

     <listitem>
      <para>
       0 indicates the overall copy format is textual (rows separated by
       newlines, columns separated by separator characters, etc).  1
       indicates the overall copy format is binary.  See <xref
       linkend="sql-copy"> for more information.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfformat-1">
     <term>
      <function>PQfformat</function>
      <indexterm>
       <primary>PQfformat</primary>
       <secondary>with COPY</secondary>
      </indexterm>
     </term>

     <listitem>
      <para>
       Returns the format code (0 for text, 1 for binary) associated with
       each column of the copy operation.  The per-column format codes
       will always be zero when the overall copy format is textual, but
       the binary format can support both text and binary columns.
       (However, as of the current implementation of <command>COPY</>,
       only binary columns appear in a binary copy; so the per-column
       formats always match the overall format at present.)
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   一个承载了这些状态值之一的<structname>PGresult</>对象携带了正在开始的<command>COPY</command>操作的一些额外数据。这些额外的数据可以用于那些与带查询结果的连接一起使用的函数：

   <variablelist>
    <varlistentry id="libpq-pqnfields-1">
     <term>
      <function>PQnfields</function>
      <indexterm>
       <primary>PQnfields</primary>
       <secondary>with COPY</secondary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回要拷贝的列（域）的个数。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqbinarytuples-1">
     <term>
      <function>PQbinaryTuples</function>
      <indexterm>
       <primary>PQbinaryTuples</primary>
       <secondary>with COPY</secondary>
      </indexterm>
     </term>

     <listitem>
      <para>
       0 表示整体拷贝格式都是文本（行用新行分隔，列用分隔字符分隔等等）。1 表示整体拷贝格式都是二进制。详见<xref linkend="sql-copy">。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfformat-1">
     <term>
      <function>PQfformat</function>
      <indexterm>
       <primary>PQfformat</primary>
       <secondary>with COPY</secondary>
      </indexterm>
     </term>

     <listitem>
      <para>
       返回与拷贝操的每列相关的格式代码（0 是文本，1 是二进制）。当整体拷贝格式是文本时，那么每列的格式代码将总是零，但是二进制格式可以同时支持文本和二进制列（不过，就目前的<command>COPY</>实现而言，二进制拷贝中只会出现二进制列；所以目前每列的格式总是匹配总体格式）。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    These additional data values are only available when using protocol
    3.0.  When using protocol 2.0, all these functions will return 0.
   </para>
____________________________________________________________________________-->
   <para>
    这些额外的数据值只在使用协议 3.0 时可用。在使用协议 2.0 时，所有这些函数都返回 0。
   </para>
  </note>

  <sect2 id="libpq-copy-send">
<!--==========================orignal english content==========================
   <title>Functions for Sending <command>COPY</command> Data</title>
____________________________________________________________________________-->
   <title>用于发送<command>COPY</command>数据的函数</title>

<!--==========================orignal english content==========================
   <para>
    These functions are used to send data during <literal>COPY FROM
    STDIN</>.  They will fail if called when the connection is not in
    <literal>COPY_IN</> state.
   </para>
____________________________________________________________________________-->
   <para>
    这些函数用于在<literal>COPY FROM STDIN</>期间发送数据。如果在连接不是<literal>COPY_IN</>状态，调用它们会失败。
   </para>

   <variablelist>
    <varlistentry id="libpq-pqputcopydata">
<!--==========================orignal english content==========================
     <term>
      <function>PQputCopyData</function>
      <indexterm>
       <primary>PQputCopyData</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQputCopyData</function>
      <indexterm>
       <primary>PQputCopyData</primary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       Sends data to the server during <literal>COPY_IN</> state.
<synopsis>
int PQputCopyData(PGconn *conn,
                  const char *buffer,
                  int nbytes);
</synopsis>
      </para>
____________________________________________________________________________-->
      <para>
       在<literal>COPY_IN</>状态中向服务器发送数据。
<synopsis>
int PQputCopyData(PGconn *conn,
                  const char *buffer,
                  int nbytes);
</synopsis>
      </para>

<!--==========================orignal english content==========================
      <para>
       Transmits the <command>COPY</command> data in the specified
       <parameter>buffer</>, of length <parameter>nbytes</>, to the server.
       The result is 1 if the data was queued, zero if it was not queued
       because of full buffers (this will only happen in nonblocking mode),
       or -1 if an error occurred.
       (Use <function>PQerrorMessage</function> to retrieve details if
       the return value is -1.  If the value is zero, wait for write-ready
       and try again.)
      </para>
____________________________________________________________________________-->
      <para>
       传输指定<parameter>buffer</>中长度为<parameter>nbytes</>的
       <command>COPY</command>数据到服务器。如果数据排队，结果为1，
       如果由于填满缓冲区而未排队（这只会发生在非阻塞模式），则结果为零，
       如果发生错误，则结果为-1。（如果返回值为 -1，那么使用
       <function>PQerrorMessage</function>检索细节。如果值是零，
       那么等待写准备好然后重试）。
      </para>

<!--==========================orignal english content==========================
      <para>
       The application can divide the <command>COPY</command> data stream
       into buffer loads of any convenient size.  Buffer-load boundaries
       have no semantic significance when sending.  The contents of the
       data stream must match the data format expected by the
       <command>COPY</> command; see <xref linkend="sql-copy"> for details.
      </para>
____________________________________________________________________________-->
      <para>
       应用可以把<command>COPY</command>数据流划分成任意方便的大小放到缓冲区中。在发送时，缓冲区载荷的边界没有什么语意。数据流的内容必须匹配<command>COPY</>命令预期的数据格式；详见<xref linkend="sql-copy">。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqputcopyend">
<!--==========================orignal english content==========================
     <term>
      <function>PQputCopyEnd</function>
      <indexterm>
       <primary>PQputCopyEnd</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQputCopyEnd</function>
      <indexterm>
       <primary>PQputCopyEnd</primary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       Sends end-of-data indication to the server during <literal>COPY_IN</> state.
<synopsis>
int PQputCopyEnd(PGconn *conn,
                 const char *errormsg);
</synopsis>
      </para>
____________________________________________________________________________-->
      <para>
       在<literal>COPY_IN</>状态中向服务器发送数据结束的指示。
<synopsis>
int PQputCopyEnd(PGconn *conn,
                 const char *errormsg);
</synopsis>
      </para>

<!--==========================orignal english content==========================
      <para>
       Ends the <literal>COPY_IN</> operation successfully if
       <parameter>errormsg</> is <symbol>NULL</symbol>.  If
       <parameter>errormsg</> is not <symbol>NULL</symbol> then the
       <command>COPY</> is forced to fail, with the string pointed to by
       <parameter>errormsg</> used as the error message.  (One should not
       assume that this exact error message will come back from the server,
       however, as the server might have already failed the
       <command>COPY</> for its own reasons.  Also note that the option
       to force failure does not work when using pre-3.0-protocol
       connections.)
      </para>
____________________________________________________________________________-->
      <para>
       如果<parameter>errormsg</>是<symbol>NULL</symbol>，则成功结束<literal>COPY_IN</>操作。如果<parameter>errormsg</>不是<symbol>NULL</symbol>则<command>COPY</>被强制失败，<parameter>errormsg</>指向的字符串是错误消息（不过，我们不应假定这个准确的错误信息将会从服务器传回，因为服务器可能已经因为其自身原因导致<command>COPY</>失败。还要注意的是在使用 3.0 协议之前的连接时，强制失败的选项是不能用的）。
      </para>

<!--==========================orignal english content==========================
      <para>
       The result is 1 if the termination message was sent; or in
       nonblocking mode, this may only indicate that the termination
       message was successfully queued.  (In nonblocking mode, to be
       certain that the data has been sent, you should next wait for
       write-ready and call <function>PQflush</>, repeating until it
       returns zero.)  Zero indicates that the function could not queue
       the termination message because of full buffers; this will only
       happen in nonblocking mode.  (In this case, wait for
       write-ready and try the <function>PQputCopyEnd</> call
       again.)  If a hard error occurs, -1 is returned; you can use
       <function>PQerrorMessage</function> to retrieve details.
      </para>
____________________________________________________________________________-->
      <para>
       如果发送了终止消息，结果为1；或者在非阻塞模式中，
       这可能仅指示终止消息已成功排队。（在非阻塞模式下，为了确保数据已经发送，
       你应该等待写准备好并调用<function>PQflush</>，重复直到它返回零。）
       零表示该函数由于填满缓冲而无法对终止消息进行排队；这只会发生在非阻塞模式。
       （在这种情况下，等待写准备好并再次尝试<function>PQputCopyEnd</>调用。）
       如果发生硬错误，则返回-1; 您可以使用<function>PQerrorMessage</function>
       检索详细信息。
      </para>

<!--==========================orignal english content==========================
      <para>
       After successfully calling <function>PQputCopyEnd</>, call
       <function>PQgetResult</> to obtain the final result status of the
       <command>COPY</> command.  One can wait for this result to be
       available in the usual way.  Then return to normal operation.
      </para>
____________________________________________________________________________-->
      <para>
       在成功调用<function>PQputCopyEnd</>之后，调用<function>PQgetResult</>获取<command>COPY</>命令的最终结果状态。我们可以用平常的方法来等待这个结果可用。然后返回到正常的操作。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>

  <sect2 id="libpq-copy-receive">
<!--==========================orignal english content==========================
   <title>Functions for Receiving <command>COPY</command> Data</title>
____________________________________________________________________________-->
   <title>用于接收<command>COPY</command>数据的函数</title>

<!--==========================orignal english content==========================
   <para>
    These functions are used to receive data during <literal>COPY TO
    STDOUT</>.  They will fail if called when the connection is not in
    <literal>COPY_OUT</> state.
   </para>
____________________________________________________________________________-->
   <para>
    这些函数用于在<literal>COPY TO STDOUT</>的过程中接收数据。如果连接不在<literal>COPY_OUT</>状态，那么调用它们将会失败。
   </para>

   <variablelist>
    <varlistentry id="libpq-pqgetcopydata">
<!--==========================orignal english content==========================
     <term>
      <function>PQgetCopyData</function>
      <indexterm>
       <primary>PQgetCopyData</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQgetCopyData</function>
      <indexterm>
       <primary>PQgetCopyData</primary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       Receives data from the server during <literal>COPY_OUT</> state.
<synopsis>
int PQgetCopyData(PGconn *conn,
                  char **buffer,
                  int async);
</synopsis>
      </para>
____________________________________________________________________________-->
      <para>
       在<literal>COPY_OUT</>状态下从服务器接收数据。
<synopsis>
int PQgetCopyData(PGconn *conn,
                  char **buffer,
                  int async);
</synopsis>
      </para>

<!--==========================orignal english content==========================
      <para>
       Attempts to obtain another row of data from the server during a
       <command>COPY</command>.  Data is always returned one data row at
       a time; if only a partial row is available, it is not returned.
       Successful return of a data row involves allocating a chunk of
       memory to hold the data.  The <parameter>buffer</> parameter must
       be non-<symbol>NULL</symbol>.  <parameter>*buffer</> is set to
       point to the allocated memory, or to <symbol>NULL</symbol> in cases
       where no buffer is returned.  A non-<symbol>NULL</symbol> result
       buffer should be freed using <function>PQfreemem</> when no longer
       needed.
      </para>
____________________________________________________________________________-->
      <para>
       在一个<command>COPY</command>期间尝试从服务器获取另外一行数据。数据总是以每次一个数据行的方式被返回；如果只有一个部分行可用，那么它不会被返回。成功返回一个数据行涉及到分配一块内存来保存该数据。<parameter>buffer</>参数必须为非<symbol>NULL</symbol>。<parameter>*buffer</>被设置为指向分配到的内存的指针，或者是在没有返回缓冲区的情况下指向<symbol>NULL</symbol>。一个非<symbol>NULL</symbol>的结果缓冲区在不需要时必须用<function>PQfreemem</>释放。
      </para>

<!--==========================orignal english content==========================
      <para>
       When a row is successfully returned, the return value is the number
       of data bytes in the row (this will always be greater than zero).
       The returned string is always null-terminated, though this is
       probably only useful for textual <command>COPY</command>.  A result
       of zero indicates that the <command>COPY</command> is still in
       progress, but no row is yet available (this is only possible when
       <parameter>async</> is true).  A result of -1 indicates that the
       <command>COPY</command> is done.  A result of -2 indicates that an
       error occurred (consult <function>PQerrorMessage</> for the reason).
      </para>
____________________________________________________________________________-->
      <para>
       在成功返回一行之后，返回的值就是该数据行里数据的字节数（将是大于零）。被返回的字符串总是空终止的，虽然这可能只是对文本<command>COPY</command>有用。 一个零结果表示该<command>COPY</command>仍然在处理中，但是还没有可用的行（只在<parameter>async</>为真时才可能）。一个 -1 结果表示<command>COPY</command>已经完成。-2 结果表示发生了错误（参考<function>PQerrorMessage</>获取原因）。
      </para>

<!--==========================orignal english content==========================
      <para>
       When <parameter>async</> is true (not zero),
       <function>PQgetCopyData</> will not block waiting for input; it
       will return zero if the <command>COPY</command> is still in progress
       but no complete row is available.  (In this case wait for read-ready
       and then call <function>PQconsumeInput</> before calling
       <function>PQgetCopyData</> again.)  When <parameter>async</> is
       false (zero), <function>PQgetCopyData</> will block until data is
       available or the operation completes.
      </para>
____________________________________________________________________________-->
      <para>
       当<parameter>async</>为真时（非零），<function>PQgetCopyData</>将不会阻塞等待输入；如果<command>COPY</command>仍在处理过程中并且没有可用的完整行，那么它将返回零（在这种情况下等待读准备好，然后在再次调用<function>PQgetCopyData</>之前，调用<function>PQconsumeInput</>）。当<parameter>async</>为假（零）时，<function>PQgetCopyData</>将阻塞，直到数据可用或者操作完成。
      </para>

<!--==========================orignal english content==========================
      <para>
       After <function>PQgetCopyData</> returns -1, call
       <function>PQgetResult</> to obtain the final result status of the
       <command>COPY</> command.  One can wait for this result to be
       available in the usual way.  Then return to normal operation.
      </para>
____________________________________________________________________________-->
      <para>
       在<function>PQgetCopyData</>返回 -1 之后，调用<function>PQgetResult</>获取<command>COPY</>命令的最后结果状态。我们可以用平常的方法来等待这个结果可用。然后返回到正常的操作。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>

  <sect2 id="libpq-copy-deprecated">
<!--==========================orignal english content==========================
   <title>Obsolete Functions for <command>COPY</command></title>
____________________________________________________________________________-->
   <title>用于<command>COPY</command>的废弃函数</title>

<!--==========================orignal english content==========================
   <para>
    These functions represent older methods of handling <command>COPY</>.
    Although they still work, they are deprecated due to poor error handling,
    inconvenient methods of detecting end-of-data, and lack of support for binary
    or nonblocking transfers.
   </para>
____________________________________________________________________________-->
   <para>
    这些函数代表了以前的处理<command>COPY</>的方法。尽管它们还能用，但是现在已经被废弃，因为它们的错误处理很糟糕、检测结束数据的方法也不方便，并且缺少对二进制或非阻塞传输的支持。
   </para>

   <variablelist>
    <varlistentry id="libpq-pqgetline">
<!--==========================orignal english content==========================
     <term>
      <function>PQgetline</function>
      <indexterm>
       <primary>PQgetline</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQgetline</function>
      <indexterm>
       <primary>PQgetline</primary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       Reads  a  newline-terminated  line  of  characters (transmitted
       by the server) into a buffer string of size <parameter>length</>.
<synopsis>
int PQgetline(PGconn *conn,
              char *buffer,
              int length);
</synopsis>
      </para>
____________________________________________________________________________-->
      <para>
       读取一个以新行终止的字符行到（由服务器传输） 到一个长度为<parameter>length</>的字符串缓冲区。
<synopsis>
int PQgetline(PGconn *conn,
              char *buffer,
              int length);
</synopsis>
      </para>

<!--==========================orignal english content==========================
      <para>
       This function copies up to <parameter>length</>-1 characters into
       the buffer and converts the terminating newline into a zero byte.
       <function>PQgetline</function> returns <symbol>EOF</symbol> at the
       end of input, 0 if the entire line has been read, and 1 if the
       buffer is full but the terminating newline has not yet been read.
       </para>
____________________________________________________________________________-->
      <para>
       这个函数拷贝最多<parameter>length</>-1 个字符到该缓冲区中，并且把终止的新行转换成一个零字节。<function>PQgetline</function>在输入结束时返回<symbol>EOF</symbol>，如果整行都被读取则返回 0，如果缓冲区填满了而还没有遇到结束的新行则返回  1。
       </para>
<!--==========================orignal english content==========================
       <para>
       Note that the application must check to see if a new line consists
       of  the  two characters  <literal>\.</literal>, which  indicates
       that the server has finished sending the results  of  the
       <command>COPY</command> command.  If  the  application might receive
       lines that are more than <parameter>length</>-1  characters  long,
       care is needed to be sure it recognizes the <literal>\.</literal>
       line correctly (and does not, for example, mistake the end of a
       long data line for a terminator line).
      </para>
____________________________________________________________________________-->
       <para>
       注意，应用必须检查是否一个新行包含两个字符<literal>\.</literal>，这表明服务器 已经完成了<command>COPY</command>命令的结果发送。如果应用可能收到超过<parameter>length</>-1 字符长的行， 我们就应该确保正确识别<literal>\.</literal>行（例如，不要把一个长数据行的结束当作一个终止行）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqgetlineasync">
<!--==========================orignal english content==========================
     <term>
      <function>PQgetlineAsync</function>
      <indexterm>
       <primary>PQgetlineAsync</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQgetlineAsync</function>
      <indexterm>
       <primary>PQgetlineAsync</primary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       Reads a row of <command>COPY</command> data (transmitted  by the
       server) into a buffer without blocking.
<synopsis>
int PQgetlineAsync(PGconn *conn,
                   char *buffer,
                   int bufsize);
</synopsis>
      </para>
____________________________________________________________________________-->
      <para>
       不阻塞地读取一行<command>COPY</command>数据（由服务器传输）到一个缓冲区中。
<synopsis>
int PQgetlineAsync(PGconn *conn,
                   char *buffer,
                   int bufsize);
</synopsis>
      </para>

<!--==========================orignal english content==========================
      <para>
       This function is similar to <function>PQgetline</function>, but it can be used
       by applications
       that must read <command>COPY</command> data asynchronously, that is, without blocking.
       Having issued the <command>COPY</command> command and gotten a <literal>PGRES_COPY_OUT</literal>
       response, the
       application should call <function>PQconsumeInput</function> and
       <function>PQgetlineAsync</function> until the
       end-of-data signal is detected.
       </para>
____________________________________________________________________________-->
      <para>
       这个函数类似于<function>PQgetline</function>，但是可以被用于那些必须异步读取<command>COPY</command>数据的应用， 也就是不阻塞的应用。在发出了<command>COPY</command>命令并得到了<literal>PGRES_COPY_OUT</literal>响应之后，应用应该调用<function>PQconsumeInput</function>和<function>PQgetlineAsync</function>直到检测到结束数据的信号。
       </para>
<!--==========================orignal english content==========================
       <para>
       Unlike <function>PQgetline</function>, this function takes
       responsibility for detecting end-of-data.
      </para>
____________________________________________________________________________-->
       <para>
       不像<function>PQgetline</function>，这个函数负责检测结束数据。
      </para>

<!--==========================orignal english content==========================
      <para>
       On each call, <function>PQgetlineAsync</function> will return data if a
       complete data row is available in <application>libpq</>'s input buffer.
       Otherwise, no data is returned until the rest of the row arrives.
       The function returns -1 if the end-of-copy-data marker has been recognized,
       or 0 if no data is available, or a positive number giving the number of
       bytes of data returned.  If -1 is returned, the caller must next call
       <function>PQendcopy</function>, and then return to normal processing.
      </para>
____________________________________________________________________________-->
      <para>
       在每次调用时，如果<application>libpq</>的输入缓冲区中有一个完整的数据行可用，<function>PQgetlineAsync</function>都将返回数据。否则，在剩余行到达之前不会返回数据。如果识别到拷贝数据结束的标志，此函数返回 -1；如果没有可用数据则返回 0； 或者是给出一个正数给出被返回的字节数。如果返回 -1，调用者下一步必须调用<function>PQendcopy</function>，然后回到正常处理。
      </para>

<!--==========================orignal english content==========================
      <para>
       The data returned will not extend beyond a data-row boundary.  If possible
       a whole row will be returned at one time.  But if the buffer offered by
       the caller is too small to hold a row sent by the server, then a partial
       data row will be returned.  With textual data this can be detected by testing
       whether the last returned byte is <literal>\n</literal> or not.  (In a binary
       <command>COPY</>, actual parsing of the <command>COPY</> data format will be needed to make the
       equivalent determination.)
       The returned string is not null-terminated.  (If you want to add a
       terminating null, be sure to pass a <parameter>bufsize</parameter> one smaller
       than the room actually available.)
      </para>
____________________________________________________________________________-->
      <para>
       返回的数据将不超过一个数据行的范围。如果可能，每次将返回一个完整行。但如果调用者提供的缓冲区太小不足以容下服务器发送的行，那么将返回部分行。对于文本数据，这可以通过测试返回的最后一个字节是否<literal>\n</literal>来检测（在二进制<command>COPY</>中， 需要对<command>COPY</>数据格式进行实际的分析，以便做相同的判断）。被返回的字符串不是空结尾的（如果你想增加一个终止空，确保传递一个比实际可用空间少一字节的<parameter>bufsize</parameter>）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqputline">
<!--==========================orignal english content==========================
     <term>
      <function>PQputline</function>
      <indexterm>
       <primary>PQputline</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQputline</function>
      <indexterm>
       <primary>PQputline</primary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       Sends  a  null-terminated  string  to  the server.  Returns 0 if
       OK and <symbol>EOF</symbol> if unable to send the string.
<synopsis>
int PQputline(PGconn *conn,
              const char *string);
</synopsis>
      </para>
____________________________________________________________________________-->
      <para>
       向服务器发送一个空终止的字符串。如果 OK 则返回 0；如果不能发送字符串则返回<symbol>EOF</symbol>。
<synopsis>
int PQputline(PGconn *conn,
              const char *string);
</synopsis>
      </para>

<!--==========================orignal english content==========================
      <para>
       The <command>COPY</command> data stream sent by a series of calls
       to <function>PQputline</function> has the same format as that
       returned by <function>PQgetlineAsync</function>, except that
       applications are not obliged to send exactly one data row per
       <function>PQputline</function> call; it is okay to send a partial
       line or multiple lines per call.
      </para>
____________________________________________________________________________-->
      <para>
       一系列<function>PQputline</function>调用发送的<command>COPY</command>数据流和<function>PQgetlineAsync</function>返回的数据具有相同的格式， 只是应用不需要每次<function>PQputline</function>调用中发送刚好一个数据行；在每次调用中发送多行或者部分行都是可以的。
      </para>

      <note>
<!--==========================orignal english content==========================
       <para>
        Before <productname>PostgreSQL</productname> protocol 3.0, it was necessary
        for the application to explicitly send the two characters
        <literal>\.</literal> as a final line to indicate to the server that it had
        finished sending <command>COPY</> data.  While this still works, it is deprecated and the
        special meaning of <literal>\.</literal> can be expected to be removed in a
        future release.  It is sufficient to call <function>PQendcopy</function> after
        having sent the actual data.
       </para>
____________________________________________________________________________-->
       <para>
        在<productname>PostgreSQL</productname>协议 3.0 之前，应用必须显式地发送两个字符<literal>\.</literal>作为最后一行来指示服务器已经完成发送<command>COPY</>数据。虽然这么做仍然有效，但是它已经被废弃并且<literal>\.</literal>的特殊含义可能在将来的版本中删除。在发送完实际数据之后， 调用<function>PQendcopy</function>就足够了。
       </para>
      </note>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqputnbytes">
<!--==========================orignal english content==========================
     <term>
      <function>PQputnbytes</function>
      <indexterm>
       <primary>PQputnbytes</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQputnbytes</function>
      <indexterm>
       <primary>PQputnbytes</primary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       Sends  a  non-null-terminated  string  to  the server.  Returns
       0 if OK and <symbol>EOF</symbol> if unable to send the string.
<synopsis>
int PQputnbytes(PGconn *conn,
                const char *buffer,
                int nbytes);
</synopsis>
      </para>
____________________________________________________________________________-->
      <para>
       向服务器发送一个非空终止的字符串。如果 OK 则返回 0，如果不能发送字符串则返回<symbol>EOF</symbol>。
<synopsis>
int PQputnbytes(PGconn *conn,
                const char *buffer,
                int nbytes);
</synopsis>
      </para>

<!--==========================orignal english content==========================
      <para>
       This is exactly like <function>PQputline</function>, except that the data
       buffer need not be null-terminated since the number of bytes to send is
       specified directly.  Use this procedure when sending binary data.
      </para>
____________________________________________________________________________-->
      <para>
       这个函数类似<function>PQputline</function>，除了数据缓冲区不需要是空终止，因为要发送的字节数是直接指定的。在发送二进制数据时使用这个过程。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqendcopy">
<!--==========================orignal english content==========================
     <term>
      <function>PQendcopy</function>
      <indexterm>
       <primary>PQendcopy</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQendcopy</function>
      <indexterm>
       <primary>PQendcopy</primary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       Synchronizes with the server.
<synopsis>
int PQendcopy(PGconn *conn);
</synopsis>
       This function waits until the  server  has  finished  the copying.
       It should either be issued when the  last  string  has  been sent
       to  the  server using <function>PQputline</function> or when the
       last string has been  received  from  the  server using
       <function>PGgetline</function>.  It must be issued or the server
       will get <quote>out of sync</quote> with  the client.   Upon return
       from this function, the server is ready to receive the next SQL
       command.  The return value is 0  on  successful  completion,
       nonzero otherwise.  (Use <function>PQerrorMessage</function> to
       retrieve details if the return value is nonzero.)
      </para>
____________________________________________________________________________-->
      <para>
       与服务器同步。
<synopsis>
int PQendcopy(PGconn *conn);
</synopsis>
       这个函数等待服务器完成拷贝。当最后一个字符串已经用<function>PQputline</function>发送给服务器时或者当最后一个字符串已经用<function>PGgetline</function>从服务器接收到时，就会发出这个函数。这个函数必须被发出，否则服务器将会和客户端<quote>不同步</quote>。从这个函数返回后，服务器就已经准备好接收下一个 SQL 命令了。函数成功完成时返回值为 0，否则返回非零值（如果返回值为非零值，用<function>PQerrorMessage</function>检索详情）。
      </para>

<!--==========================orignal english content==========================
      <para>
       When using <function>PQgetResult</function>, the application should
       respond to a <literal>PGRES_COPY_OUT</literal> result by executing
       <function>PQgetline</function> repeatedly, followed by
       <function>PQendcopy</function> after the terminator line is seen.
       It should then return to the <function>PQgetResult</function> loop
       until <function>PQgetResult</function> returns a null pointer.
       Similarly a <literal>PGRES_COPY_IN</literal> result is processed
       by a series of <function>PQputline</function> calls followed by
       <function>PQendcopy</function>, then return to the
       <function>PQgetResult</function> loop.  This arrangement will
       ensure that a <command>COPY</command> command embedded in a series
       of <acronym>SQL</acronym> commands will be executed correctly.
      </para>
____________________________________________________________________________-->
      <para>
       在使用<function>PQgetResult</function>时，应用应该通过反复调用<function>PQgetline</function>并且在看到终止行后调用<function>PQendcopy</function>来响应<literal>PGRES_COPY_OUT</literal>结果。然后它应该返回到<function>PQgetResult</function>循环直到<function>PQgetResult</function>返回一个空指针。类似地，<literal>PGRES_COPY_IN</literal>结果会用一系列<function>PQputline</function>加上之后的<function>PQendcopy</function>来处理，然后返 回到<function>PQgetResult</function>循环。这样的安排将保证嵌入到一系列<acronym>SQL</acronym>命令中的<command>COPY</command>命令将被正确执行。
      </para>

<!--==========================orignal english content==========================
      <para>
       Older applications are likely to submit a <command>COPY</command>
       via <function>PQexec</function> and assume that the transaction
       is done after <function>PQendcopy</function>.  This will work
       correctly only if the <command>COPY</command> is the only
       <acronym>SQL</acronym> command in the command string.
      </para>
____________________________________________________________________________-->
      <para>
       旧的应用很可能会通过<function>PQexec</function>提交一个<command>COPY</command>命令并且假定事务在<function>PQendcopy</function>之后完成。只有在<command>COPY</command>是命令字符串中唯一的<acronym>SQL</acronym>命令时才能正确工作。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>

 </sect1>

 <sect1 id="libpq-control">
<!--==========================orignal english content==========================
  <title>Control Functions</title>
____________________________________________________________________________-->
  <title>控制函数</title>

<!--==========================orignal english content==========================
  <para>
   These functions control miscellaneous details of <application>libpq</>'s
   behavior.
  </para>
____________________________________________________________________________-->
  <para>
   这些函数控制<application>libpq</>行为各种各样的细节。
  </para>

  <variablelist>
   <varlistentry id="libpq-pqclientencoding">
<!--==========================orignal english content==========================
    <term>
     <function>PQclientEncoding</function>
     <indexterm>
      <primary>PQclientEncoding</primary>
     </indexterm>
    </term>
____________________________________________________________________________-->
    <term>
     <function>PQclientEncoding</function>
     <indexterm>
      <primary>PQclientEncoding</primary>
     </indexterm>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Returns the client encoding.
<synopsis>
int PQclientEncoding(const PGconn *<replaceable>conn</replaceable>);
</synopsis>

      Note that it returns the encoding ID, not a symbolic string
      such as <literal>EUC_JP</literal>. If unsuccessful, it returns -1.
      To convert an encoding ID to an encoding name, you
      can use:

<synopsis>
char *pg_encoding_to_char(int <replaceable>encoding_id</replaceable>);
</synopsis>
     </para>
____________________________________________________________________________-->
     <para>
      返回客户端编码。
<synopsis>
int PQclientEncoding(const PGconn *<replaceable>conn</replaceable>);
</synopsis>

      请注意，它返回的是编码 ID，而不是一个符号串字符串，如<literal>EUC_JP</literal>。
      如果不成功，它会返回 -1。要把一个编码 ID 转换为为一个编码名称，可以用：

<synopsis>
char *pg_encoding_to_char(int <replaceable>encoding_id</replaceable>);
</synopsis>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqsetclientencoding">
<!--==========================orignal english content==========================
    <term>
     <function>PQsetClientEncoding</function>
     <indexterm>
      <primary>PQsetClientEncoding</primary>
     </indexterm>
    </term>
____________________________________________________________________________-->
    <term>
     <function>PQsetClientEncoding</function>
     <indexterm>
      <primary>PQsetClientEncoding</primary>
     </indexterm>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Sets the client encoding.
<synopsis>
int PQsetClientEncoding(PGconn *<replaceable>conn</replaceable>, const char *<replaceable>encoding</replaceable>);
</synopsis>

      <replaceable>conn</replaceable> is a connection to the server,
      and <replaceable>encoding</replaceable> is the encoding you want to
      use. If the function successfully sets the encoding, it returns 0,
      otherwise -1. The current encoding for this connection can be
      determined by using <function>PQclientEncoding</>.
     </para>
____________________________________________________________________________-->
     <para>
      设置客户端编码。
<synopsis>
int PQsetClientEncoding(PGconn *<replaceable>conn</replaceable>, const char *<replaceable>encoding</replaceable>);
</synopsis>

      <replaceable>conn</replaceable>是一个到服务器的连接，而<replaceable>encoding</replaceable>是你想使用的编码。如果函数成功地设置编码，则返回 0，否则返回 -1。这个连接的当前编码可以使用<function>PQclientEncoding</>确定。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqseterrorverbosity">
<!--==========================orignal english content==========================
    <term>
     <function>PQsetErrorVerbosity</function>
     <indexterm>
      <primary>PQsetErrorVerbosity</primary>
     </indexterm>
    </term>
____________________________________________________________________________-->
    <term>
     <function>PQsetErrorVerbosity</function>
     <indexterm>
      <primary>PQsetErrorVerbosity</primary>
     </indexterm>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Determines the verbosity of messages returned by
      <function>PQerrorMessage</> and <function>PQresultErrorMessage</>.
<synopsis>
typedef enum
{
    PQERRORS_TERSE,
    PQERRORS_DEFAULT,
    PQERRORS_VERBOSE
} PGVerbosity;

PGVerbosity PQsetErrorVerbosity(PGconn *conn, PGVerbosity verbosity);
</synopsis>

      <function>PQsetErrorVerbosity</> sets the verbosity mode, returning
      the connection's previous setting.  In <firstterm>TERSE</> mode,
      returned messages include severity, primary text, and position only;
      this will normally fit on a single line.  The default mode produces
      messages that include the above plus any detail, hint, or context
      fields (these might span multiple lines).  The <firstterm>VERBOSE</>
      mode includes all available fields.  Changing the verbosity does not
      affect the messages available from already-existing
      <structname>PGresult</> objects, only subsequently-created ones.
      (But see <function>PQresultVerboseErrorMessage</function> if you
      want to print a previous error with a different verbosity.)
     </para>
____________________________________________________________________________-->
     <para>
      决定<function>PQerrorMessage</>和<function>PQresultErrorMessage</>返回的消息的细节程度。
<synopsis>
typedef enum
{
    PQERRORS_TERSE,
    PQERRORS_DEFAULT,
    PQERRORS_VERBOSE
} PGVerbosity;

PGVerbosity PQsetErrorVerbosity(PGconn *conn, PGVerbosity verbosity);
</synopsis>

      <function>PQsetErrorVerbosity</>设置细节模式，并返回该连接的前一个设置。在<firstterm>TERSE</>模式下，返回的消息只包括严重性、主要文本以及位置；这些东西通常放在一个单一行中。缺省模式生成的消息包括上面的信息加上任何细节、提示或者上下文域（这些可能跨越多行）。<firstterm>VERBOSE</>模式包括所有可以可用的域。修改细节模式不会影响来自已有<structname>PGresult</>对象中的可用消息。只有随后创建的<structname>PGresult</>对象才受到影响。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqseterrorcontextvisibility">
<!--==========================orignal english content==========================
    <term>
     <function>PQsetErrorContextVisibility</function>
     <indexterm>
      <primary>PQsetErrorContextVisibility</primary>
     </indexterm>
    </term>
____________________________________________________________________________-->
    <term>
     <function>PQsetErrorContextVisibility</function>
     <indexterm>
      <primary>PQsetErrorContextVisibility</primary>
     </indexterm>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Determines the handling of <literal>CONTEXT</> fields in messages
      returned by <function>PQerrorMessage</>
      and <function>PQresultErrorMessage</>.
<synopsis>
typedef enum
{
    PQSHOW_CONTEXT_NEVER,
    PQSHOW_CONTEXT_ERRORS,
    PQSHOW_CONTEXT_ALWAYS
} PGContextVisibility;

PGContextVisibility PQsetErrorContextVisibility(PGconn *conn, PGContextVisibility show_context);
</synopsis>

      <function>PQsetErrorContextVisibility</> sets the context display mode,
      returning the connection's previous setting.  This mode controls
      whether the <literal>CONTEXT</literal> field is included in messages
      (unless the verbosity setting is <firstterm>TERSE</>, in which
      case <literal>CONTEXT</> is never shown).  The <firstterm>NEVER</> mode
      never includes <literal>CONTEXT</>, while <firstterm>ALWAYS</> always
      includes it if available.  In <firstterm>ERRORS</> mode (the
      default), <literal>CONTEXT</> fields are included only for error
      messages, not for notices and warnings.  Changing this mode does not
      affect the messages available from
      already-existing <structname>PGresult</> objects, only
      subsequently-created ones.
      (But see <function>PQresultVerboseErrorMessage</function> if you
      want to print a previous error with a different display mode.)
     </para>
____________________________________________________________________________-->
     <para>
      决定如何处理<function>PQerrorMessage</>和<function>PQresultErrorMessage</>
      返回的消息中的<literal>CONTEXT</>域。
<synopsis>
typedef enum
{
    PQSHOW_CONTEXT_NEVER,
    PQSHOW_CONTEXT_ERRORS,
    PQSHOW_CONTEXT_ALWAYS
} PGContextVisibility;

PGContextVisibility PQsetErrorContextVisibility(PGconn *conn, PGContextVisibility show_context);
</synopsis>

      <function>PQsetErrorContextVisibility</>设置上下文显示模式，
      返回该连接上之前的设置。这个模式控制消息中是否包括<literal>CONTEXT</literal>域
      （除非 verbosity 设置是<firstterm>TERSE</>，那种情况下<literal>CONTEXT</>
      不会被显示）。<firstterm>NEVER</>模式不会包括<literal>CONTEXT</>，
      而<firstterm>ALWAYS</>则尽可能地包括这个域。在<firstterm>ERRORS</>模式（默认）中，
      只在错误消息中包括<literal>CONTEXT</>域，而在通知和警告消息中不会包括。
      更改这个模式不会影响从已经存在的<structname>PGresult</>对象项中得到的消息，
      只会影响后续创建的<structname>PGresult</>对象
      （如果想要用不同的显示模式打印之前的错误，
      请见<function>PQresultVerboseErrorMessage</function>）。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqtrace">
<!--==========================orignal english content==========================
    <term>
     <function>PQtrace</function>
     <indexterm>
      <primary>PQtrace</primary>
     </indexterm>
    </term>
____________________________________________________________________________-->
    <term>
     <function>PQtrace</function>
     <indexterm>
      <primary>PQtrace</primary>
     </indexterm>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Enables  tracing of the client/server communication to a debugging file stream.
<synopsis>
void PQtrace(PGconn *conn, FILE *stream);
</synopsis>
     </para>
____________________________________________________________________________-->
     <para>
      启用对客户端/服务器通讯的跟踪，把跟踪信息输出到一个调试文件流中。
<synopsis>
void PQtrace(PGconn *conn, FILE *stream);
</synopsis>
     </para>

     <note>
<!--==========================orignal english content==========================
      <para>
       On Windows, if the <application>libpq</> library and an application are
       compiled with different flags, this function call will crash the
       application because the internal representation of the <literal>FILE</>
       pointers differ.  Specifically, multithreaded/single-threaded,
       release/debug, and static/dynamic flags should be the same for the
       library and all applications using that library.
      </para>
____________________________________________________________________________-->
      <para>
       在 Windows 商，如果<application>libpq</>库和应用使用了不同的标志编译，那么这个函数调用会导致应用崩溃，因为<literal>FILE</>指针的内部表达是不一样的。特别是多线程/单线程、发布/调试 以及静态/动态标志应该是库和所有使用库的应用都一致。
      </para>
     </note>

    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pquntrace">
<!--==========================orignal english content==========================
    <term>
     <function>PQuntrace</function>
     <indexterm>
      <primary>PQuntrace</primary>
     </indexterm>
    </term>
____________________________________________________________________________-->
    <term>
     <function>PQuntrace</function>
     <indexterm>
      <primary>PQuntrace</primary>
     </indexterm>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Disables tracing started by <function>PQtrace</function>.
<synopsis>
void PQuntrace(PGconn *conn);
</synopsis>
     </para>
____________________________________________________________________________-->
     <para>
      禁用<function>PQtrace</function>打开的跟踪。
<synopsis>
void PQuntrace(PGconn *conn);
</synopsis>
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

 </sect1>

 <sect1 id="libpq-misc">
<!--==========================orignal english content==========================
  <title>Miscellaneous Functions</title>
____________________________________________________________________________-->
  <title>杂项函数</title>

<!--==========================orignal english content==========================
  <para>
   As always, there are some functions that just don't fit anywhere.
  </para>
____________________________________________________________________________-->
  <para>
   一如往常，总有一些函数不适合放在任何其他地方。
  </para>

  <variablelist>
   <varlistentry id="libpq-pqfreemem">
<!--==========================orignal english content==========================
    <term>
     <function>PQfreemem</function>
     <indexterm>
      <primary>PQfreemem</primary>
     </indexterm>
    </term>
____________________________________________________________________________-->
    <term>
     <function>PQfreemem</function>
     <indexterm>
      <primary>PQfreemem</primary>
     </indexterm>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Frees memory allocated by <application>libpq</>.
<synopsis>
void PQfreemem(void *ptr);
</synopsis>
     </para>
____________________________________________________________________________-->
     <para>
      释放<application>libpq</>分配的内存。
<synopsis>
void PQfreemem(void *ptr);
</synopsis>
     </para>

<!--==========================orignal english content==========================
     <para>
      Frees memory allocated by <application>libpq</>, particularly
      <function>PQescapeByteaConn</function>,
      <function>PQescapeBytea</function>,
      <function>PQunescapeBytea</function>,
      and <function>PQnotifies</function>.
      It is particularly important that this function, rather than
      <function>free()</>, be used on Microsoft Windows.  This is because
      allocating memory in a DLL and releasing it in the application works
      only if multithreaded/single-threaded, release/debug, and static/dynamic
      flags are the same for the DLL and the application.  On non-Microsoft
      Windows platforms, this function is the same as the standard library
      function <function>free()</>.
     </para>
____________________________________________________________________________-->
     <para>
      释放<application>libpq</>分配的内存，尤其是<function>PQescapeByteaConn</function>、<function>PQescapeBytea</function>、<function>PQunescapeBytea</function>和<function>PQnotifies</function>分配的内存。特别重要的是，在微软 Windows 上使用这个函数，而不是<function>free()</>。这是因为只有 DLL 和应用的当多线程/单线程、发布/调试以及静态/动态标志相同时，才能在一个 DLL 中分配内存并且在应用中释放它。在非微软 Windows 平台上，这个函数与标准库函数<function>free()</>相同。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqconninfofree">
<!--==========================orignal english content==========================
    <term>
     <function>PQconninfoFree</function>
     <indexterm>
      <primary>PQconninfoFree</primary>
     </indexterm>
    </term>
____________________________________________________________________________-->
    <term>
     <function>PQconninfoFree</function>
     <indexterm>
      <primary>PQconninfoFree</primary>
     </indexterm>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Frees the data structures allocated by
      <function>PQconndefaults</> or <function>PQconninfoParse</>.
<synopsis>
void PQconninfoFree(PQconninfoOption *connOptions);
</synopsis>
     </para>
____________________________________________________________________________-->
     <para>
      释放<function>PQconndefaults</>或<function>PQconninfoParse</>分配的数据结构。
<synopsis>
void PQconninfoFree(PQconninfoOption *connOptions);
</synopsis>
     </para>

<!--==========================orignal english content==========================
     <para>
      A simple <function>PQfreemem</function> will not do for this, since
      the array contains references to subsidiary strings.
     </para>
____________________________________________________________________________-->
     <para>
      一个简单的<function>PQfreemem</function>不会做这些，因为数组包含对子字符串的引用。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqencryptpasswordconn">
<!--==========================orignal english content==========================
    <term>
     <function>PQencryptPasswordConn</function>
     <indexterm>
      <primary>PQencryptPasswordConn</primary>
     </indexterm>
    </term>
____________________________________________________________________________-->
    <term>
     <function>PQencryptPasswordConn</function>
     <indexterm>
      <primary>PQencryptPasswordConn</primary>
     </indexterm>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Prepares the encrypted form of a <productname>PostgreSQL</> password.
<synopsis>
char *PQencryptPasswordConn(PGconn *conn, const char *passwd, const char *user, const char *algorithm);
</synopsis>
      This function is intended to be used by client applications that
      wish to send commands like <literal>ALTER USER joe PASSWORD
      'pwd'</>.  It is good practice not to send the original cleartext
      password in such a command, because it might be exposed in command
      logs, activity displays, and so on.  Instead, use this function to
      convert the password to encrypted form before it is sent.
     </para>
____________________________________________________________________________-->
     <para>
      准备一个<productname>PostgreSQL</>口令的加密形式。
<synopsis>
char *PQencryptPasswordConn(PGconn *conn, const char *passwd, const char *user, const char *algorithm);
</synopsis>
      这个函数旨在用于那些希望发送类似于<literal>ALTER USER joe PASSWORD 'pwd'</>命令的客户端应用。不在这样一个命令中发送原始的明文密码是一个好习惯，因为它可能被暴露在命令日志、活动显示等等中。相反，在发送之前使用这个函数可以将口令转换为加密的形式。
     </para>

<!--==========================orignal english content==========================
     <para>
      The <parameter>passwd</> and <parameter>user</> arguments
      are the cleartext password, and the SQL name of the user it is for.
      <parameter>algorithm</> specifies the encryption algorithm
      to use to encrypt the password. Currently supported algorithms are
      <literal>md5</> and <literal>scram-sha-256</> (<literal>on</> and
      <literal>off</> are also accepted as aliases for <literal>md5</>, for
      compatibility with older server versions). Note that support for
      <literal>scram-sha-256</> was introduced in <productname>PostgreSQL</>
      version 10, and will not work correctly with older server versions. If
      <parameter>algorithm</> is <symbol>NULL</>, this function will query
      the server for the current value of the
      <xref linkend="guc-password-encryption"> setting. That can block, and
      will fail if the current transaction is aborted, or if the connection
      is busy executing another query. If you wish to use the default
      algorithm for the server but want to avoid blocking, query
      <varname>password_encryption</> yourself before calling
      <function>PQencryptPasswordConn</>, and pass that value as the
      <parameter>algorithm</>.
     </para>
____________________________________________________________________________-->
     <para>	  
	  <parameter>algorithm</>指定用于加密口令的加密算法。目前支持的算法是
	  <literal>md5</>和<literal>scram-sha-256</>，（<literal>on</>和<literal>off</>
	  也被接受为<literal>md5</>的别名，以与旧版服务器版本兼容）。
	  请注意，在<productname>PostgreSQL</>版本10中引入了对<literal>scram-sha-256</>
	  的支持，并且在旧版服务器版本中无法正常工作。如果<parameter>algorithm</>
	  是<symbol>NULL</>，则此函数将向服务器查询<xref linkend="guc-password-encryption">
	  设置的当前值。如果当前事务中止，或者连接忙于执行另一个查询，则可能会阻塞，
	  并会失败。如果您希望服务器使用默认算法，但希望避免阻塞，
	  请在调用<function>PQencryptPasswordConn</>之前亲自查询
	  <varname>password_encryption</>，并将该值作为<parameter>algorithm</>传递。
     </para>

<!--==========================orignal english content==========================
     <para>
      The return value is a string allocated by <function>malloc</>.
      The caller can assume the string doesn't contain any special characters
      that would require escaping.  Use <function>PQfreemem</> to free the
      result when done with it. On error, returns <symbol>NULL</>, and
      a suitable message is stored in the connection object.
     </para>
____________________________________________________________________________-->
     <para>
      返回值是<function>malloc</function>分配的一个字符串。
	  调用者可以假定该字符串中不包含任何需要转义的特殊字符。当使用结束之后，
	  用<function>PQfreemem</>释放结果。错误时，返回<symbol>NULL</>，
	  并且一个合适的消息被存储在连接对象中。	  
     </para>
    </listitem>
   </varlistentry>
   <varlistentry id="libpq-pqencryptpassword">
<!--==========================orignal english content==========================
    <term>
     <function>PQencryptPassword</function>
     <indexterm>
      <primary>PQencryptPassword</primary>
     </indexterm>
    </term>
____________________________________________________________________________-->
    <term>
     <function>PQencryptPassword</function>
     <indexterm>
      <primary>PQencryptPassword</primary>
     </indexterm>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Prepares the md5-encrypted form of a <productname>PostgreSQL</> password.
<synopsis>
char *PQencryptPassword(const char *passwd, const char *user);
</synopsis>
      <function>PQencryptPassword</> is an older, deprecated version of
      <function>PQencryptPasswodConn</>. The difference is that
      <function>PQencryptPassword</> does not
      require a connection object, and <literal>md5</> is always used as the
      encryption algorithm.
     </para>
____________________________________________________________________________-->
     <para>
      准备一个<productname>PostgreSQL</>口令的md5加密形式。
<synopsis>
char *PQencryptPassword(const char *passwd, const char *user);
</synopsis>
      <function>PQencryptPassword</>是<function>PQencryptPasswodConn</>
	  的一个较旧的，废弃的版本。区别在于<function>PQencryptPassword</>
	  不需要连接对象，并且始终使用<literal>md5</>作为加密算法。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry id="libpq-pqmakeemptypgresult">
<!--==========================orignal english content==========================
    <term>
     <function>PQmakeEmptyPGresult</function>
     <indexterm>
      <primary>PQmakeEmptyPGresult</primary>
     </indexterm>
    </term>
____________________________________________________________________________-->
    <term>
     <function>PQmakeEmptyPGresult</function>
     <indexterm>
      <primary>PQmakeEmptyPGresult</primary>
     </indexterm>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Constructs an empty <structname>PGresult</structname> object with the given status.
<synopsis>
PGresult *PQmakeEmptyPGresult(PGconn *conn, ExecStatusType status);
</synopsis>
     </para>
____________________________________________________________________________-->
     <para>
      用给定的状态，构造一个空<structname>PGresult</structname>对象。
<synopsis>
PGresult *PQmakeEmptyPGresult(PGconn *conn, ExecStatusType status);
</synopsis>
     </para>

<!--==========================orignal english content==========================
     <para>
      This is <application>libpq</>'s internal function to allocate and
      initialize an empty <structname>PGresult</structname> object.  This
      function returns <symbol>NULL</> if memory could not be allocated. It is
      exported because some applications find it useful to generate result
      objects (particularly objects with error status) themselves.  If
      <parameter>conn</parameter> is not null and <parameter>status</>
      indicates an error, the current error message of the specified
      connection is copied into the <structname>PGresult</structname>.
      Also, if <parameter>conn</parameter> is not null, any event procedures
      registered in the connection are copied into the
      <structname>PGresult</structname>.  (They do not get
      <literal>PGEVT_RESULTCREATE</> calls, but see
      <function>PQfireResultCreateEvents</function>.)
      Note that <function>PQclear</function> should eventually be called
      on the object, just as with a <structname>PGresult</structname>
      returned by <application>libpq</application> itself.
     </para>
____________________________________________________________________________-->
     <para>
      这是<application>libpq</>内部用于分配并初始化一个空<structname>PGresult</structname>对象的函数。如果不能分配内存，那么这个函数返回<symbol>NULL</>。它也是可以对外使用的，因为一些应用认为它可以用于产生结果对象（特别是带有错误状态的对象）本身。如果<parameter>conn</parameter>非空，并且<parameter>status</>表示一个错误，那么指定连接的当前错误消息会被复制到<structname>PGresult</structname>中。如果<parameter>conn</parameter>非空，那么连接中的任何已注册事件过程也会被复制到<structname>PGresult</structname>中（它们不会获得<literal>PGEVT_RESULTCREATE</>调用，但会看到<function>PQfireResultCreateEvents</function>）。注意在该对象上最终应该调用<function>PQclear</function>，正如对<application>libpq</application>本身返回的<structname>PGresult</structname>对象所作的那样。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqfireresultcreateevents">
<!--==========================orignal english content==========================
    <term>
     <function>PQfireResultCreateEvents</function>
     <indexterm>
      <primary>PQfireResultCreateEvents</primary>
     </indexterm>
    </term>
____________________________________________________________________________-->
    <term>
     <function>PQfireResultCreateEvents</function>
     <indexterm>
      <primary>PQfireResultCreateEvents</primary>
     </indexterm>
    </term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Fires a <literal>PGEVT_RESULTCREATE</literal> event (see <xref
      linkend="libpq-events">) for each event procedure registered in the
      <structname>PGresult</structname> object.  Returns non-zero for success,
      zero if any event procedure fails.

<synopsis>
int PQfireResultCreateEvents(PGconn *conn, PGresult *res);
</synopsis>
     </para>
____________________________________________________________________________-->
     <para>
      为每一个在<structname>PGresult</structname>对象中注册的事件过程触发一个<literal>PGEVT_RESULTCREATE</literal>事件（见<xref linkend="libpq-events">）。成功时返回非 0，如果任何事件过程失败则返回 0。

<synopsis>
int PQfireResultCreateEvents(PGconn *conn, PGresult *res);
</synopsis>
     </para>

<!--==========================orignal english content==========================
     <para>
      The <literal>conn</> argument is passed through to event procedures
      but not used directly.  It can be <symbol>NULL</> if the event
      procedures won't use it.
     </para>
____________________________________________________________________________-->
     <para>
      <literal>conn</>参数被传送给事件过程，但不会被直接使用。如果事件过程不使用它，则会返回<symbol>NULL</>。
     </para>

<!--==========================orignal english content==========================
     <para>
      Event procedures that have already received a
      <literal>PGEVT_RESULTCREATE</> or <literal>PGEVT_RESULTCOPY</> event
      for this object are not fired again.
     </para>
____________________________________________________________________________-->
     <para>
      已经接收到这个对象的<literal>PGEVT_RESULTCREATE</>或<literal>PGEVT_RESULTCOPY</>事件的事件过程不会被再次触发。
     </para>

<!--==========================orignal english content==========================
     <para>
      The main reason that this function is separate from
      <function>PQmakeEmptyPGresult</function> is that it is often appropriate
      to create a <structname>PGresult</structname> and fill it with data
      before invoking the event procedures.
     </para>
____________________________________________________________________________-->
     <para>
      这个函数与<function>PQmakeEmptyPGresult</function>分开的主要原因是在调用事件过程之前创建一个<structname>PGresult</structname>并且填充它常常是合适的。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqcopyresult">
<!--==========================orignal english content==========================
    <term>
     <function>PQcopyResult</function>
     <indexterm>
      <primary>PQcopyResult</primary>
     </indexterm>
    </term>
____________________________________________________________________________-->
    <term>
     <function>PQcopyResult</function>
     <indexterm>
      <primary>PQcopyResult</primary>
     </indexterm>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Makes a copy of a <structname>PGresult</structname> object.  The copy is
      not linked to the source result in any way and
      <function>PQclear</function> must be called when the copy is no longer
      needed.  If the function fails, <symbol>NULL</> is returned.

<synopsis>
PGresult *PQcopyResult(const PGresult *src, int flags);
</synopsis>
     </para>
____________________________________________________________________________-->
     <para>
      为一个<structname>PGresult</structname>对象创建一个拷贝。这个拷贝不会以任何方式链接到源结果，并且当该拷贝不再需要时，必须调用<function>PQclear</function>进行清理。如果函数失败，返回<symbol>NULL</>。

<synopsis>
PGresult *PQcopyResult(const PGresult *src, int flags);
</synopsis>
     </para>

<!--==========================orignal english content==========================
     <para>
      This is not intended to make an exact copy.  The returned result is
      always put into <literal>PGRES_TUPLES_OK</literal> status, and does not
      copy any error message in the source.  (It does copy the command status
      string, however.)  The <parameter>flags</parameter> argument determines
      what else is copied.  It is a bitwise OR of several flags.
      <literal>PG_COPYRES_ATTRS</literal> specifies copying the source
      result's attributes (column definitions).
      <literal>PG_COPYRES_TUPLES</literal> specifies copying the source
      result's tuples.  (This implies copying the attributes, too.)
      <literal>PG_COPYRES_NOTICEHOOKS</literal> specifies
      copying the source result's notify hooks.
      <literal>PG_COPYRES_EVENTS</literal> specifies copying the source
      result's events.  (But any instance data associated with the source
      is not copied.)
     </para>
____________________________________________________________________________-->
     <para>
      这个函数的意图并非是制作一个准确的拷贝。返回的结果总是会被放入<literal>PGRES_TUPLES_OK</literal>状态，并且不会拷贝来源中的任何错误消息（不过它确实会拷贝命令状态字符串）。<parameter>flags</parameter>参数决定还要拷贝些什么。它通常是几个标志的按位 OR。<literal>PG_COPYRES_ATTRS</literal>指定复制源结果的属性（列定义）。<literal>PG_COPYRES_TUPLES</literal>指定复制源结果的元组（这也意味着复制属性）。<literal>PG_COPYRES_NOTICEHOOKS</literal>指定复制源结果的提醒钩子。<literal>PG_COPYRES_EVENTS</literal>指定复制源结果的事件（但是不会复制与源结果相关的实例数据）。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqsetresultattrs">
<!--==========================orignal english content==========================
    <term>
     <function>PQsetResultAttrs</function>
     <indexterm>
      <primary>PQsetResultAttrs</primary>
     </indexterm>
    </term>
____________________________________________________________________________-->
    <term>
     <function>PQsetResultAttrs</function>
     <indexterm>
      <primary>PQsetResultAttrs</primary>
     </indexterm>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Sets the attributes of a <structname>PGresult</structname> object.
<synopsis>
int PQsetResultAttrs(PGresult *res, int numAttributes, PGresAttDesc *attDescs);
</synopsis>
     </para>
____________________________________________________________________________-->
     <para>
      设置<structname>PGresult</structname>对象的属性。
<synopsis>
int PQsetResultAttrs(PGresult *res, int numAttributes, PGresAttDesc *attDescs);
</synopsis>
     </para>

<!--==========================orignal english content==========================
     <para>
      The provided <parameter>attDescs</parameter> are copied into the result.
      If the <parameter>attDescs</parameter> pointer is <symbol>NULL</> or
      <parameter>numAttributes</parameter> is less than one, the request is
      ignored and the function succeeds.  If <parameter>res</parameter>
      already contains attributes, the function will fail.  If the function
      fails, the return value is zero.  If the function succeeds, the return
      value is non-zero.
     </para>
____________________________________________________________________________-->
     <para>
      提供的<parameter>attDescs</parameter>被复制到结果中。如果<parameter>attDescs</parameter>指针为<symbol>NULL</>或<parameter>numAttributes</parameter>小于1，那么请求将被忽略并且函数成功。如果<parameter>res</parameter>已经包含属性，那么函数会失败。如果函数失败，返回值是 0。如果函数成功，返回值是非 0。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqsetvalue">
<!--==========================orignal english content==========================
    <term>
     <function>PQsetvalue</function>
     <indexterm>
      <primary>PQsetvalue</primary>
     </indexterm>
    </term>
____________________________________________________________________________-->
    <term>
     <function>PQsetvalue</function>
     <indexterm>
      <primary>PQsetvalue</primary>
     </indexterm>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Sets a tuple field value of a <structname>PGresult</structname> object.
<synopsis>
int PQsetvalue(PGresult *res, int tup_num, int field_num, char *value, int len);
</synopsis>
     </para>
____________________________________________________________________________-->
     <para>
      设置一个<structname>PGresult</structname>对象的一个元组域值。
<synopsis>
int PQsetvalue(PGresult *res, int tup_num, int field_num, char *value, int len);
</synopsis>
     </para>

<!--==========================orignal english content==========================
     <para>
      The function will automatically grow the result's internal tuples array
      as needed.  However, the <parameter>tup_num</parameter> argument must be
      less than or equal to <function>PQntuples</function>, meaning this
      function can only grow the tuples array one tuple at a time.  But any
      field of any existing tuple can be modified in any order.  If a value at
      <parameter>field_num</parameter> already exists, it will be overwritten.
      If <parameter>len</parameter> is -1 or
      <parameter>value</parameter> is <symbol>NULL</>, the field value
      will be set to an SQL null value.  The
      <parameter>value</parameter> is copied into the result's private storage,
      thus is no longer needed after the function
      returns.  If the function fails, the return value is zero.  If the
      function succeeds, the return value is non-zero.
     </para>
____________________________________________________________________________-->
     <para>
      这个函数将自动按需增加结果的内置元组数组。但是，<parameter>tup_num</parameter>参数必须小于等于<function>PQntuples</function>，意味着这个函数对元组数组一次只能增加一个元组。但已存在的任意元组中的任意域可以以任意顺序进行调整。如果<parameter>field_num</parameter>的一个值已经存在，它会被覆盖。如果<parameter>len</parameter>是 -1，或<parameter>value</parameter>是<symbol>NULL</>， 该域值会被设置为一个 SQL 空值。<parameter>value</parameter>会被复制到结果的私有存储中，因此函数返回后就不再需要了。如果函数失败，返回值是 0。如果函数成功，返回值会是非 0。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqresultalloc">
<!--==========================orignal english content==========================
    <term>
     <function>PQresultAlloc</function>
     <indexterm>
      <primary>PQresultAlloc</primary>
     </indexterm>
    </term>
____________________________________________________________________________-->
    <term>
     <function>PQresultAlloc</function>
     <indexterm>
      <primary>PQresultAlloc</primary>
     </indexterm>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Allocate subsidiary storage for a <structname>PGresult</structname> object.
<synopsis>
void *PQresultAlloc(PGresult *res, size_t nBytes);
</synopsis>
     </para>
____________________________________________________________________________-->
     <para>
      为一个<structname>PGresult</structname>对象分配附属存储。
<synopsis>
void *PQresultAlloc(PGresult *res, size_t nBytes);
</synopsis>
     </para>

<!--==========================orignal english content==========================
     <para>
      Any memory allocated with this function will be freed when
      <parameter>res</parameter> is cleared.  If the function fails,
      the return value is <symbol>NULL</>.  The result is
      guaranteed to be adequately aligned for any type of data,
      just as for <function>malloc</>.
     </para>
____________________________________________________________________________-->
     <para>
      当<parameter>res</parameter>被清除时，这个函数分配的内存也会被释放掉。如果函数失败，返回值是<symbol>NULL</>。结果被保证为按照数据的任意类型充分地对齐，正如<function>malloc</>所作的。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqlibversion">
<!--==========================orignal english content==========================
    <term>
     <function>PQlibVersion</function>
     <indexterm>
      <primary>PQlibVersion</primary>
      <seealso>PQserverVersion</seealso>
     </indexterm>
    </term>
____________________________________________________________________________-->
    <term>
     <function>PQlibVersion</function>
     <indexterm>
      <primary>PQlibVersion</primary>
      <seealso>PQserverVersion</seealso>
     </indexterm>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Return the version of <productname>libpq</> that is being used.
<synopsis>
int PQlibVersion(void);
</synopsis>
     </para>
____________________________________________________________________________-->
     <para>
      返回所使用的<productname>libpq</>版本。
<synopsis>
int PQlibVersion(void);
</synopsis>
     </para>

<!--==========================orignal english content==========================
     <para>
      The result of this function can be used to determine, at
      run time, whether specific functionality is available in the currently
      loaded version of libpq. The function can be used, for example,
      to determine which connection options are available in
      <function>PQconnectdb</>.
     </para>
____________________________________________________________________________-->
     <para>
      在运行时，这个函数的结果可以被用来决定在当前已载入的 libpq 版本中特定的功能是否可用。
	  例如，这个函数可以被用来决定哪些选项可以被用于<function>PQconnectdb</>。
     </para>

<!--==========================orignal english content==========================
     <para>
      The result is formed by multiplying the library's major version
      number by 10000 and adding the minor version number.  For example,
      version 10.1 will be returned as 100001, and version 11.0 will be
      returned as 110000.
     </para>
____________________________________________________________________________-->
     <para>
      结果是通过将库的主要版本号乘以10000并添加次要版本号形成的。
	  例如，版本10.1将返回100001，版本11.0将返回110000。如果连接不正确，则返回零。
     </para>
<!--==========================orignal english content==========================
      <para>
      Prior to major version 10, <productname>PostgreSQL</> used
      three-part version numbers in which the first two parts together
      represented the major version.  For those
      versions, <function>PQlibVersion</> uses two digits for each
      part; for example version 9.1.5 will be returned as 90105, and
      version 9.2.0 will be returned as 90200.
     </para>
____________________________________________________________________________-->
      <para>
       在主版本10之前，<productname>PostgreSQL</>使用三部分版本号，
	   前两部分代表主要版本。对于这些版本，<function>PQserverVersion</>
	   对每个部分使用两个数字；例如版本9.1.5将返回90105，版本9.2.0将返回90200。
      </para>

<!--==========================orignal english content==========================
      <para>
      Therefore, for purposes of determining feature compatibility,
      applications should divide the result of <function>PQlibVersion</>
      by 100 not 10000 to determine a logical major version number.
      In all release series, only the last two digits differ between
      minor releases (bug-fix releases).
     </para>
____________________________________________________________________________-->
      <para>
       因此，为确定功能兼容性，应用程序应将<function>PQserverVersion</>
	   的结果除以100而不是10000，以确定逻辑主要版本号。在所有发行版系列中，
	   只有最后两位数字在次版本（错误修复版本）之间有所不同。
      </para>
     <note>
<!--==========================orignal english content==========================
      <para>
       This function appeared in <productname>PostgreSQL</> version 9.1, so
       it cannot be used to detect required functionality in earlier
       versions, since calling it will create a link dependency
       on version 9.1 or later.
      </para>
____________________________________________________________________________-->
      <para>
       这个函数出现于<productname>PostgreSQL</>版本 9.1，因此它不能被用来在早期的版本中检测所需的功能，因为调用它将会创建一个对版本 9.1 或更高版本的链接依赖。
      </para>
     </note>
    </listitem>
   </varlistentry>

  </variablelist>

 </sect1>

 <sect1 id="libpq-notice-processing">
<!--==========================orignal english content==========================
  <title>Notice Processing</title>
____________________________________________________________________________-->
  <title>通知处理</title>

<!--==========================orignal english content==========================
  <indexterm zone="libpq-notice-processing">
   <primary>notice processing</primary>
   <secondary>in libpq</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="libpq-notice-processing">
   <primary>notice processing</primary>
   <secondary>in libpq</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   Notice and warning messages generated by the server are not returned
   by the query execution functions, since they do not imply failure of
   the query.  Instead they are passed to a notice handling function, and
   execution continues normally after the handler returns.  The default
   notice handling function prints the message on
   <filename>stderr</filename>, but the application can override this
   behavior by supplying its own handling function.
  </para>
____________________________________________________________________________-->
  <para>
   服务器产生的通知和警告消息不会被查询执行函数返回，因为它们不代表查询失败。它们可以被传递给一个通知处理函数，并且在处理者返回后执行会继续正常进行。默认的处理函数会把消息打印在<filename>stderr</filename>上，但是应用可以通过提供它自己的处理函数来重载这种行为。
  </para>

<!--==========================orignal english content==========================
  <para>
   For historical reasons, there are two levels of notice handling, called
   the notice receiver and notice processor.  The default behavior is for
   the notice receiver to format the notice and pass a string to the notice
   processor for printing.  However, an application that chooses to provide
   its own notice receiver will typically ignore the notice processor
   layer and just do all the work in the notice receiver.
  </para>
____________________________________________________________________________-->
  <para>
   由于历史原因，通知处理有两个级别，称为通知接收器和通知处理器。通知接收器的默认行为是格式化通知并且将一个字符串传递给通知处理器来打印。不过，如果一个应用选择提供自己的通知接收器，它通常会忽略通知处理器层并且在通知接收器中完成所有工作。
  </para>

<!--==========================orignal english content==========================
  <para>
   The function <function>PQsetNoticeReceiver</function>
   <indexterm><primary>notice receiver</></>
   <indexterm><primary>PQsetNoticeReceiver</></> sets or
   examines the current notice receiver for a connection object.
   Similarly, <function>PQsetNoticeProcessor</function>
   <indexterm><primary>notice processor</></>
   <indexterm><primary>PQsetNoticeProcessor</></> sets or
   examines the current notice processor.

<synopsis>
typedef void (*PQnoticeReceiver) (void *arg, const PGresult *res);

PQnoticeReceiver
PQsetNoticeReceiver(PGconn *conn,
                    PQnoticeReceiver proc,
                    void *arg);

typedef void (*PQnoticeProcessor) (void *arg, const char *message);

PQnoticeProcessor
PQsetNoticeProcessor(PGconn *conn,
                     PQnoticeProcessor proc,
                     void *arg);
</synopsis>

   Each of these functions returns the previous notice receiver or
   processor function pointer, and sets the new value.  If you supply a
   null function pointer, no action is taken, but the current pointer is
   returned.
  </para>
____________________________________________________________________________-->
  <para>
   函数<function>PQsetNoticeReceiver</function>
   <indexterm><primary>notice receiver</></>
   <indexterm><primary>PQsetNoticeReceiver</></>为一个连接对象设置或者检查当前的通知接收器。相似地，
   <function>PQsetNoticeProcessor</function>
   <indexterm><primary>notice processor</></>
   <indexterm><primary>PQsetNoticeProcessor</></>设置或检查当前的通知处理器。

<synopsis>
typedef void (*PQnoticeReceiver) (void *arg, const PGresult *res);

PQnoticeReceiver
PQsetNoticeReceiver(PGconn *conn,
                    PQnoticeReceiver proc,
                    void *arg);

typedef void (*PQnoticeProcessor) (void *arg, const char *message);

PQnoticeProcessor
PQsetNoticeProcessor(PGconn *conn,
                     PQnoticeProcessor proc,
                     void *arg);
</synopsis>

   这些函数中的每一个会返回之前的通知接收器或处理器函数指针，并且设置新值。如果你提供了一个空函数指针，将不会采取任何动作，只会返回当前指针。
  </para>

<!--==========================orignal english content==========================
  <para>
   When a notice or warning message is received from the server, or
   generated internally by <application>libpq</application>, the notice
   receiver function is called.  It is passed the message in the form of
   a <symbol>PGRES_NONFATAL_ERROR</symbol>
   <structname>PGresult</structname>.  (This allows the receiver to extract
   individual fields using <function>PQresultErrorField</>, or obtain a
   complete preformatted message using <function>PQresultErrorMessage</>
   or <function>PQresultVerboseErrorMessage</>.)  The same
   void pointer passed to <function>PQsetNoticeReceiver</function> is also
   passed.  (This pointer can be used to access application-specific state
   if needed.)
  </para>
____________________________________________________________________________-->
  <para>
   当接收到一个服务器产生的或者<application>libpq</application>内部产生的通知或警告消息，通知接收器函数会被调用。它会以一种<symbol>PGRES_NONFATAL_ERROR</symbol> <structname>PGresult</structname>的形式传递该消息（这允许接收器使用<function>PQresultErrorField</>抽取个别的域，或者使用<function>PQresultErrorMessage</>完成预格式化的消息）。被传递给<function>PQsetNoticeReceiver</function>的同一个空指针也被传递（必要时，这个指针可以被用来访问应用相关的状态）。
  </para>

<!--==========================orignal english content==========================
  <para>
   The default notice receiver simply extracts the message (using
   <function>PQresultErrorMessage</>) and passes it to the notice
   processor.
  </para>
____________________________________________________________________________-->
  <para>
   默认的通知接收器会简单地抽取消息（使用<function>PQresultErrorMessage</>）并且将它传递给通知处理器。
  </para>

<!--==========================orignal english content==========================
  <para>
   The notice processor is responsible for handling a notice or warning
   message given in text form.  It is passed the string text of the message
   (including a trailing newline), plus a void pointer that is the same
   one passed to <function>PQsetNoticeProcessor</function>.  (This pointer
   can be used to access application-specific state if needed.)
  </para>
____________________________________________________________________________-->
  <para>
   通知处理器负责处理一个以文本形式给出的通知或警告消息。该消息的字符串文本（包括一个收尾的新行）被传递给通知处理器，外加一个同时被传递给<function>PQsetNoticeProcessor</function>的空指针（必要时，这个指针可以被用来访问应用相关的状态）。
  </para>

<!--==========================orignal english content==========================
  <para>
   The default notice processor is simply:
<programlisting>
static void
defaultNoticeProcessor(void *arg, const char *message)
{
    fprintf(stderr, "%s", message);
}
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   默认的通知处理器很简单：
<programlisting>
static void
defaultNoticeProcessor(void *arg, const char *message)
{
    fprintf(stderr, "%s", message);
}
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Once you have set a notice receiver or processor, you should expect
   that that function could be called as long as either the
   <structname>PGconn</> object or <structname>PGresult</> objects made
   from it exist.  At creation of a <structname>PGresult</>, the
   <structname>PGconn</>'s current notice handling pointers are copied
   into the <structname>PGresult</> for possible use by functions like
   <function>PQgetvalue</function>.
  </para>
____________________________________________________________________________-->
  <para>
   一旦你设定了一个通知接收器或处理器，你应该期待只要<structname>PGconn</>对象或者从它构造出的<structname>PGresult</>对象存在，该函数就应该能被调用。在一个<structname>PGresult</>创建时，<structname>PGconn</>的当前通知处理指针被复制到<structname>PGresult</>中，以备类似<function>PQgetvalue</function>的函数使用。
  </para>

 </sect1>

 <sect1 id="libpq-events">
<!--==========================orignal english content==========================
  <title>Event System</title>
____________________________________________________________________________-->
  <title>事件系统</title>

<!--==========================orignal english content==========================
  <para>
   <application>libpq</application>'s event system is designed to notify
   registered event handlers about interesting
   <application>libpq</application> events, such as the creation or
   destruction of <structname>PGconn</structname> and
   <structname>PGresult</structname> objects.  A principal use case is that
   this allows applications to associate their own data with a
   <structname>PGconn</structname> or <structname>PGresult</structname>
   and ensure that that data is freed at an appropriate time.
  </para>
____________________________________________________________________________-->
  <para>
   <application>libpq</application>的事件系统被设计为通知已注册的事件处理器它感兴趣的<application>libpq</application>事件，例如<structname>PGconn</structname>以及<structname>PGresult</structname>对象的创建和毁灭。一种主要的使用情况是这允许应用将自己的数据与一个<structname>PGconn</structname>或者<structname>PGresult</structname>关联在一起，并且确保那些数据在适当的时候被释放。
  </para>

<!--==========================orignal english content==========================
  <para>
   Each registered event handler is associated with two pieces of data,
   known to <application>libpq</application> only as opaque <literal>void *</>
   pointers.  There is a <firstterm>passthrough</> pointer that is provided
   by the application when the event handler is registered with a
   <structname>PGconn</>.  The passthrough pointer never changes for the
   life of the <structname>PGconn</> and all <structname>PGresult</>s
   generated from it; so if used, it must point to long-lived data.
   In addition there is an <firstterm>instance data</> pointer, which starts
   out <symbol>NULL</> in every <structname>PGconn</> and <structname>PGresult</>.
   This pointer can be manipulated using the
   <function>PQinstanceData</function>,
   <function>PQsetInstanceData</function>,
   <function>PQresultInstanceData</function> and
   <function>PQsetResultInstanceData</function> functions.  Note that
   unlike the passthrough pointer, instance data of a <structname>PGconn</>
   is not automatically inherited by <structname>PGresult</>s created from
   it.  <application>libpq</application> does not know what passthrough
   and instance data pointers point to (if anything) and will never attempt
   to free them &mdash; that is the responsibility of the event handler.
  </para>
____________________________________________________________________________-->
  <para>
   每一个已注册的事件处理器与两部分数据相关，对于<application>libpq</application>它们只是透明的<literal>void *</>指针。当事件处理器被注册到一个<structname>PGconn</>时，会有一个应用提供的<firstterm>转移</>指针。该转移指针在<structname>PGconn</>及其产生的所有<structname>PGresult</>的生命期内都不会改变。因此，如果使用它，它必须指向长期存在的数据。此外，还有一个<firstterm>instance data</>指针，它在每一个<structname>PGconn</>和<structname>PGresult</>中都开始于<symbol>NULL</>。这个指针可以使用
   <function>PQinstanceData</function>、
   <function>PQsetInstanceData</function>、
   <function>PQresultInstanceData</function>和
   <function>PQsetResultInstanceData</function>函数操纵。注意和转移指针不同，一个<structname>PGconn</>的实例数据不会被从它创建的<structname>PGresult</>自动继承。<application>libpq</application>不知道转移和实例数据指针指向的是什么（如果有），并且将不会尝试释放它们 &mdash; 那是事件处理器的责任。
  </para>

  <sect2 id="libpq-events-types">
<!--==========================orignal english content==========================
   <title>Event Types</title>
____________________________________________________________________________-->
   <title>事件类型</title>

<!--==========================orignal english content==========================
   <para>
    The enum <literal>PGEventId</> names the types of events handled by
    the event system.  All its values have names beginning with
    <literal>PGEVT</literal>.  For each event type, there is a corresponding
    event info structure that carries the parameters passed to the event
    handlers.  The event types are:
   </para>
____________________________________________________________________________-->
   <para>
    枚举<literal>PGEventId</>命名了事件系统处理的事件类型。它的所有值的名称都以<literal>PGEVT</literal>开始。对于每一种事件类型，都有一个相应的事件信息结构用来承载传递给事件处理器的参数。事件类型是：
   </para>

   <variablelist>
    <varlistentry id="libpq-pgevt-register">
<!--==========================orignal english content==========================
     <term><literal>PGEVT_REGISTER</literal></term>
____________________________________________________________________________-->
     <term><literal>PGEVT_REGISTER</literal></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       The register event occurs when <function>PQregisterEventProc</function>
       is called.  It is the ideal time to initialize any
       <literal>instanceData</literal> an event procedure may need.  Only one
       register event will be fired per event handler per connection.  If the
       event procedure fails, the registration is aborted.

<synopsis>
typedef struct
{
    PGconn *conn;
} PGEventRegister;
</synopsis>

       When a <literal>PGEVT_REGISTER</literal> event is received, the
       <parameter>evtInfo</parameter> pointer should be cast to a
       <structname>PGEventRegister *</structname>.  This structure contains a
       <structname>PGconn</structname> that should be in the
       <literal>CONNECTION_OK</literal> status; guaranteed if one calls
       <function>PQregisterEventProc</function> right after obtaining a good
       <structname>PGconn</structname>.  When returning a failure code, all
       cleanup must be performed as no <literal>PGEVT_CONNDESTROY</literal>
       event will be sent.
      </para>
____________________________________________________________________________-->
      <para>
       当<function>PQregisterEventProc</function>被调用时，注册事件会发生。这是一个初始化每一个事件过程都可能需要的<literal>instanceData</literal>的最佳时机。每个连接的每个事件处理器只会触发一个注册事件。如果该事件过程失败，注册会被中止。

<synopsis>
typedef struct
{
    PGconn *conn;
} PGEventRegister;
</synopsis>

       当收到一个<literal>PGEVT_REGISTER</literal>事件时，<parameter>evtInfo</parameter>指针应该被造型为<structname>PGEventRegister *</structname>。这个结构包含一个状态应该为<literal>CONNECTION_OK</literal>的<structname>PGconn</structname>，保证在得到一个良好的<structname>PGconn</structname>之后能马上调用<function>PQregisterEventProc</function>。当返回一个失败代码时，所有的清理都必须被执行而不会发送<literal>PGEVT_CONNDESTROY</literal>事件。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pgevt-connreset">
<!--==========================orignal english content==========================
     <term><literal>PGEVT_CONNRESET</literal></term>
____________________________________________________________________________-->
     <term><literal>PGEVT_CONNRESET</literal></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       The connection reset event is fired on completion of
       <function>PQreset</function> or <function>PQresetPoll</function>.  In
       both cases, the event is only fired if the reset was successful.  If
       the event procedure fails, the entire connection reset will fail; the
       <structname>PGconn</structname> is put into
       <literal>CONNECTION_BAD</literal> status and
       <function>PQresetPoll</function> will return
       <literal>PGRES_POLLING_FAILED</literal>.

<synopsis>
typedef struct
{
    PGconn *conn;
} PGEventConnReset;
</synopsis>

       When a <literal>PGEVT_CONNRESET</literal> event is received, the
       <parameter>evtInfo</parameter> pointer should be cast to a
       <structname>PGEventConnReset *</structname>.  Although the contained
       <structname>PGconn</structname> was just reset, all event data remains
       unchanged.  This event should be used to reset/reload/requery any
       associated <literal>instanceData</literal>.  Note that even if the
       event procedure fails to process <literal>PGEVT_CONNRESET</>, it will
       still receive a <literal>PGEVT_CONNDESTROY</> event when the connection
       is closed.
      </para>
____________________________________________________________________________-->
      <para>
       连接重置事件在<function>PQreset</function>或<function>PQresetPoll</function>完成时被触发。在两种情况中，只有重置成功才会触发该事件。如果事件过程失败，整个连接重置将失败，<structname>PGconn</structname>会被置为<literal>CONNECTION_BAD</literal>状态并且<function>PQresetPoll</function>将返回<literal>PGRES_POLLING_FAILED</literal>。

<synopsis>
typedef struct
{
    PGconn *conn;
} PGEventConnReset;
</synopsis>

       当收到一个<literal>PGEVT_CONNRESET</literal>事件时，<parameter>evtInfo</parameter>指针应该被造型为<structname>PGEventConnReset *</structname>。尽管所包含的<structname>PGconn</structname>刚被重置，所有的事件数据还是保持不变。这个事件应该被用来重置/重载/重新查询任何相关的<literal>instanceData</literal>。注意即使事件过程无法处理<literal>PGEVT_CONNRESET</>，它仍将在连接被关闭时接收到一个<literal>PGEVT_CONNDESTROY</>事件。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pgevt-conndestroy">
<!--==========================orignal english content==========================
     <term><literal>PGEVT_CONNDESTROY</literal></term>
____________________________________________________________________________-->
     <term><literal>PGEVT_CONNDESTROY</literal></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       The connection destroy event is fired in response to
       <function>PQfinish</function>.  It is the event procedure's
       responsibility to properly clean up its event data as libpq has no
       ability to manage this memory.  Failure to clean up will lead
       to memory leaks.

<synopsis>
typedef struct
{
    PGconn *conn;
} PGEventConnDestroy;
</synopsis>

       When a <literal>PGEVT_CONNDESTROY</literal> event is received, the
       <parameter>evtInfo</parameter> pointer should be cast to a
       <structname>PGEventConnDestroy *</structname>.  This event is fired
       prior to <function>PQfinish</function> performing any other cleanup.
       The return value of the event procedure is ignored since there is no
       way of indicating a failure from <function>PQfinish</function>.  Also,
       an event procedure failure should not abort the process of cleaning up
       unwanted memory.
      </para>
____________________________________________________________________________-->
      <para>
       为了响应<function>PQfinish</function>，连接销毁事件会被触发。由于 libpq 没有能力管理事件数据，事件过程有责任正确地清理它的事件数据。清理失败将会导致内存泄露。

<synopsis>
typedef struct
{
    PGconn *conn;
} PGEventConnDestroy;
</synopsis>

       当接收到一个<literal>PGEVT_CONNDESTROY</literal>事件时，<parameter>evtInfo</parameter>指针应该被造型为<structname>PGEventConnDestroy *</structname>。这个事件在<function>PQfinish</function>执行任何其他清理之前被触发。该事件过程的返回值被忽略，因为没有办法指示一个来自<function>PQfinish</function>的失败。还有，一个事件过程失败不该中断对不需要的内存的清理。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pgevt-resultcreate">
<!--==========================orignal english content==========================
     <term><literal>PGEVT_RESULTCREATE</literal></term>
____________________________________________________________________________-->
     <term><literal>PGEVT_RESULTCREATE</literal></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       The result creation event is fired in response to any query execution
       function that generates a result, including
       <function>PQgetResult</function>.  This event will only be fired after
       the result has been created successfully.

<synopsis>
typedef struct
{
    PGconn *conn;
    PGresult *result;
} PGEventResultCreate;
</synopsis>

       When a <literal>PGEVT_RESULTCREATE</literal> event is received, the
       <parameter>evtInfo</parameter> pointer should be cast to a
       <structname>PGEventResultCreate *</structname>.  The
       <parameter>conn</parameter> is the connection used to generate the
       result.  This is the ideal place to initialize any
       <literal>instanceData</literal> that needs to be associated with the
       result.  If the event procedure fails, the result will be cleared and
       the failure will be propagated.  The event procedure must not try to
       <function>PQclear</> the result object for itself.  When returning a
       failure code, all cleanup must be performed as no
       <literal>PGEVT_RESULTDESTROY</literal> event will be sent.
      </para>
____________________________________________________________________________-->
      <para>
       为了响应任何生成一个结果的查询执行函数，结果创建事件会被触发。这些函数包括<function>PQgetResult</function>。这个事件只有在结果被成功地创建之后才会被触发。

<synopsis>
typedef struct
{
    PGconn *conn;
    PGresult *result;
} PGEventResultCreate;
</synopsis>

       当接收到一个<literal>PGEVT_RESULTCREATE</literal>事件时，<parameter>evtInfo</parameter>指针应该被造型为<structname>PGEventResultCreate *</structname>。<parameter>conn</parameter>是用来产生结果的连接。这是初始化任何需要与结果关联的<literal>instanceData</literal>的理想位置。如果该事件过程失败，结果将被清除并且失败将会被传播。该事件过程不能尝试自己<function>PQclear</>结果对象。当返回一个失败代码时，所有清理必须被执行而不会发送<literal>PGEVT_RESULTDESTROY</literal>事件。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pgevt-resultcopy">
<!--==========================orignal english content==========================
     <term><literal>PGEVT_RESULTCOPY</literal></term>
____________________________________________________________________________-->
     <term><literal>PGEVT_RESULTCOPY</literal></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       The result copy event is fired in response to
       <function>PQcopyResult</function>.  This event will only be fired after
       the copy is complete.  Only event procedures that have
       successfully handled the <literal>PGEVT_RESULTCREATE</literal>
       or <literal>PGEVT_RESULTCOPY</literal> event for the source result
       will receive <literal>PGEVT_RESULTCOPY</literal> events.

<synopsis>
typedef struct
{
    const PGresult *src;
    PGresult *dest;
} PGEventResultCopy;
</synopsis>

       When a <literal>PGEVT_RESULTCOPY</literal> event is received, the
       <parameter>evtInfo</parameter> pointer should be cast to a
       <structname>PGEventResultCopy *</structname>.  The
       <parameter>src</parameter> result is what was copied while the
       <parameter>dest</parameter> result is the copy destination.  This event
       can be used to provide a deep copy of <literal>instanceData</literal>,
       since <literal>PQcopyResult</literal> cannot do that.  If the event
       procedure fails, the entire copy operation will fail and the
       <parameter>dest</parameter> result will be cleared.   When returning a
       failure code, all cleanup must be performed as no
       <literal>PGEVT_RESULTDESTROY</literal> event will be sent for the
       destination result.
      </para>
____________________________________________________________________________-->
      <para>
       为了响应<function>PQcopyResult</function>，结果复制事件会被触发。这个事件只会在复制完成后才被触发。只有成功地处理了<literal>PGEVT_RESULTCREATE</literal>和<literal>PGEVT_RESULTCOPY</literal>事件的事件过程才将会收到<literal>PGEVT_RESULTCOPY</literal>事件。

<synopsis>
typedef struct
{
    const PGresult *src;
    PGresult *dest;
} PGEventResultCopy;
</synopsis>

       当收到一个<literal>PGEVT_RESULTCOPY</literal>事件时，<parameter>evtInfo</parameter>指针应该被造型为<structname>PGEventResultCopy *</structname>。<parameter>src</parameter>结果是要被复制的，而<parameter>dest</parameter>结果则是复制的目的地。这个事件可以被用来提供<literal>instanceData</literal>的一份深度副本，因为<literal>PQcopyResult</literal>没法这样做。如果该事件过程失败，整个复制操作将失败并且<parameter>dest</parameter>结果将被清除。当返回一个失败代码时，所有清理必须被执行而不会为目标结果发送<literal>PGEVT_RESULTDESTROY</literal>事件。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pgevt-resultdestroy">
<!--==========================orignal english content==========================
     <term><literal>PGEVT_RESULTDESTROY</literal></term>
____________________________________________________________________________-->
     <term><literal>PGEVT_RESULTDESTROY</literal></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       The result destroy event is fired in response to a
       <function>PQclear</function>.  It is the event procedure's
       responsibility to properly clean up its event data as libpq has no
       ability to manage this memory.  Failure to clean up will lead
       to memory leaks.

<synopsis>
typedef struct
{
    PGresult *result;
} PGEventResultDestroy;
</synopsis>

       When a <literal>PGEVT_RESULTDESTROY</literal> event is received, the
       <parameter>evtInfo</parameter> pointer should be cast to a
       <structname>PGEventResultDestroy *</structname>.  This event is fired
       prior to <function>PQclear</function> performing any other cleanup.
       The return value of the event procedure is ignored since there is no
       way of indicating a failure from <function>PQclear</function>.  Also,
       an event procedure failure should not abort the process of cleaning up
       unwanted memory.
      </para>
____________________________________________________________________________-->
      <para>
       为了响应<function>PQclear</function>，结果销毁事件会被触发。由于 libpq 没有能力管理事件数据，事件过程有责任正确地清理它的事件数据。清理失败将会导致内存泄露。

<synopsis>
typedef struct
{
    PGresult *result;
} PGEventResultDestroy;
</synopsis>

       当接收到一个<literal>PGEVT_RESULTDESTROY</literal>事件时，<parameter>evtInfo</parameter>指针应该被造型为<structname>PGEventResultDestroy *</structname>。这个事件在<function>PQclear</function>执行任何其他清理之前被触发。该事件过程的返回值被忽略，因为没有办法指示来自<function>PQclear</function>的失败。还有，一个事件过程失败不该中断不需要的内存的清理过程。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 id="libpq-events-proc">
<!--==========================orignal english content==========================
   <title>Event Callback Procedure</title>
____________________________________________________________________________-->
   <title>事件回调函数</title>

   <variablelist>
    <varlistentry id="libpq-pgeventproc">
<!--==========================orignal english content==========================
     <term>
      <literal>PGEventProc</literal>
      <indexterm>
       <primary>PGEventProc</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <literal>PGEventProc</literal>
      <indexterm>
       <primary>PGEventProc</primary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       <literal>PGEventProc</literal> is a typedef for a pointer to an
       event procedure, that is, the user callback function that receives
       events from libpq.  The signature of an event procedure must be

<synopsis>
int eventproc(PGEventId evtId, void *evtInfo, void *passThrough)
</synopsis>

       The <parameter>evtId</parameter> parameter indicates which
       <literal>PGEVT</literal> event occurred.  The
       <parameter>evtInfo</parameter> pointer must be cast to the appropriate
       structure type to obtain further information about the event.
       The <parameter>passThrough</parameter> parameter is the pointer
       provided to <function>PQregisterEventProc</function> when the event
       procedure was registered.  The function should return a non-zero value
       if it succeeds and zero if it fails.
      </para>
____________________________________________________________________________-->
      <para>
       <literal>PGEventProc</literal>是到一个事件过程的指针的 typedef，也就是从 libpq 接收事件的用户回调函数。一个事件过程的原型必须是

<synopsis>
int eventproc(PGEventId evtId, void *evtInfo, void *passThrough)
</synopsis>

       <parameter>evtId</parameter>指示发生了哪一个<literal>PGEVT</literal>事件。<parameter>evtInfo</parameter>指针必须被造型为合适的结构类型才能获得关于事件的进一步信息。当事件过程已被注册时，<parameter>passThrough</parameter>参数是提供给<function>PQregisterEventProc</function>的指针。如果成功，该函数应该返回非零值，失败则返回零。
      </para>

<!--==========================orignal english content==========================
      <para>
       A particular event procedure can be registered only once in any
       <structname>PGconn</>.  This is because the address of the procedure
       is used as a lookup key to identify the associated instance data.
      </para>
____________________________________________________________________________-->
      <para>
       在任何一个<structname>PGconn</>中，一个特定事件过程只能被注册一次。这是因为该过程的地址被用作查找键来标识相关的实例数据。
      </para>

      <caution>
<!--==========================orignal english content==========================
       <para>
        On Windows, functions can have two different addresses: one visible
        from outside a DLL and another visible from inside the DLL.  One
        should be careful that only one of these addresses is used with
        <application>libpq</>'s event-procedure functions, else confusion will
        result.  The simplest rule for writing code that will work is to
        ensure that event procedures are declared <literal>static</>.  If the
        procedure's address must be available outside its own source file,
        expose a separate function to return the address.
       </para>
____________________________________________________________________________-->
       <para>
        在 Windows 上，函数能够有两个不同的地址：一个对 DLL 之外可见而另一个对 DLL 之内可见。我们应当小心只有其中之一会被用于<application>libpq</>的事件过程函数，否则将会产生混淆。编写代码的最简单规则是将所有的事件过程声明为<literal>static</>。如果过程的地址必须对它自己的源代码文件之外可见，提供一个单独的函数来返回该地址。
       </para>
      </caution>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 id="libpq-events-funcs">
<!--==========================orignal english content==========================
   <title>Event Support Functions</title>
____________________________________________________________________________-->
   <title>事件支持函数</title>

    <variablelist>
    <varlistentry id="libpq-pqregistereventproc">
<!--==========================orignal english content==========================
     <term>
      <function>PQregisterEventProc</function>
      <indexterm>
       <primary>PQregisterEventProc</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQregisterEventProc</function>
      <indexterm>
       <primary>PQregisterEventProc</primary>
      </indexterm>
     </term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       Registers an event callback procedure with libpq.

<synopsis>
int PQregisterEventProc(PGconn *conn, PGEventProc proc,
                        const char *name, void *passThrough);
</synopsis>
      </para>
____________________________________________________________________________-->
      <para>
       为 libpq 注册一个事件回调过程。

<synopsis>
int PQregisterEventProc(PGconn *conn, PGEventProc proc,
                        const char *name, void *passThrough);
</synopsis>
      </para>

<!--==========================orignal english content==========================
      <para>
       An event procedure must be registered once on each
       <structname>PGconn</> you want to receive events about.  There is no
       limit, other than memory, on the number of event procedures that
       can be registered with a connection.  The function returns a non-zero
       value if it succeeds and zero if it fails.
      </para>
____________________________________________________________________________-->
      <para>
       在每一个你想要接收事件的<structname>PGconn</>上必须注册一个事件过程。和内存不同，没有限制说一个连接上能注册多少个事件过程。如果该函数成功，它会返回一个非零值。如果它失败，则会返回零。
      </para>

<!--==========================orignal english content==========================
      <para>
       The <parameter>proc</parameter> argument will be called when a libpq
       event is fired.  Its memory address is also used to lookup
       <literal>instanceData</literal>.  The <parameter>name</parameter>
       argument is used to refer to the event procedure in error messages.
       This value cannot be <symbol>NULL</> or a zero-length string.  The name string is
       copied into the <structname>PGconn</>, so what is passed need not be
       long-lived.  The <parameter>passThrough</parameter> pointer is passed
       to the <parameter>proc</parameter> whenever an event occurs. This
       argument can be <symbol>NULL</>.
      </para>
____________________________________________________________________________-->
      <para>
       当一个 libpq 事件被触发时，<parameter>proc</parameter>参数将被调用。它的内存地址也被用来查找<literal>instanceData</literal>。<parameter>name</parameter>参数被用来在错误消息中引用该事件过程。这个值不能是<symbol>NULL</>或一个零长度串。名字串被复制到<structname>PGconn</>中，因此传递进来的东西不需要长期存在。当一个事件发生时，<parameter>passThrough</parameter>指针被传递给<parameter>proc</parameter>。这个参数可以是<symbol>NULL</>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsetinstancedata">
<!--==========================orignal english content==========================
     <term>
      <function>PQsetInstanceData</function>
      <indexterm>
       <primary>PQsetInstanceData</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQsetInstanceData</function>
      <indexterm>
       <primary>PQsetInstanceData</primary>
      </indexterm>
     </term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       Sets the connection <parameter>conn</>'s <literal>instanceData</>
       for procedure <parameter>proc</> to <parameter>data</>.  This
       returns non-zero for success and zero for failure.  (Failure is
       only possible if <parameter>proc</> has not been properly
       registered in <parameter>conn</>.)

<synopsis>
int PQsetInstanceData(PGconn *conn, PGEventProc proc, void *data);
</synopsis>
      </para>
____________________________________________________________________________-->
      <para>
       设置连接<parameter>conn</>的用于过程<parameter>proc</>的<literal>instanceData</>为<parameter>data</>。它在成功时返回非零值，失败时返回零（只有<parameter>proc</>没有被正确地注册在<parameter>conn</>中，才可能会失败）。

<synopsis>
int PQsetInstanceData(PGconn *conn, PGEventProc proc, void *data);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqinstancedata">
<!--==========================orignal english content==========================
     <term>
      <function>PQinstanceData</function>
      <indexterm>
       <primary>PQinstanceData</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQinstanceData</function>
      <indexterm>
       <primary>PQinstanceData</primary>
      </indexterm>
     </term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       Returns the
       connection <parameter>conn</>'s <literal>instanceData</literal>
       associated with procedure <parameter>proc</>,
       or <symbol>NULL</symbol> if there is none.

<synopsis>
void *PQinstanceData(const PGconn *conn, PGEventProc proc);
</synopsis>
      </para>
____________________________________________________________________________-->
      <para>
       返回连接<parameter>conn</>的与过程<parameter>proc</>相关的<literal>instanceData</literal>，如果没有则返回<symbol>NULL</symbol>。

<synopsis>
void *PQinstanceData(const PGconn *conn, PGEventProc proc);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqresultsetinstancedata">
<!--==========================orignal english content==========================
     <term>
      <function>PQresultSetInstanceData</function>
      <indexterm>
       <primary>PQresultSetInstanceData</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQresultSetInstanceData</function>
      <indexterm>
       <primary>PQresultSetInstanceData</primary>
      </indexterm>
     </term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       Sets the result's <literal>instanceData</>
       for <parameter>proc</> to <parameter>data</>.  This returns
       non-zero for success and zero for failure.  (Failure is only
       possible if <parameter>proc</> has not been properly registered
       in the result.)

<synopsis>
int PQresultSetInstanceData(PGresult *res, PGEventProc proc, void *data);
</synopsis>
      </para>
____________________________________________________________________________-->
      <para>
       把结果的用于<parameter>proc</>的<literal>instanceData</>设置为<parameter>data</>。成功返回非零，失败返回零（只有<parameter>proc</>没有被正确地注册在<parameter>conn</>中，才可能会失败）。

<synopsis>
int PQresultSetInstanceData(PGresult *res, PGEventProc proc, void *data);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqresultinstancedata">
<!--==========================orignal english content==========================
     <term>
      <function>PQresultInstanceData</function>
      <indexterm>
       <primary>PQresultInstanceData</primary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <function>PQresultInstanceData</function>
      <indexterm>
       <primary>PQresultInstanceData</primary>
      </indexterm>
     </term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       Returns the result's <literal>instanceData</> associated with <parameter>proc</>, or <symbol>NULL</>
       if there is none.

<synopsis>
void *PQresultInstanceData(const PGresult *res, PGEventProc proc);
</synopsis>
      </para>
____________________________________________________________________________-->
      <para>
       返回结果的与过程<parameter>proc</>相关的<literal>instanceData</literal>，如果没有则返回<symbol>NULL</symbol>。

<synopsis>
void *PQresultInstanceData(const PGresult *res, PGEventProc proc);
</synopsis>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 id="libpq-events-example">
<!--==========================orignal english content==========================
   <title>Event Example</title>
____________________________________________________________________________-->
   <title>事件实例</title>

<!--==========================orignal english content==========================
   <para>
    Here is a skeleton example of managing private data associated with
    libpq connections and results.
   </para>
____________________________________________________________________________-->
   <para>
    这里是一个管理与 libpq 连接和结果相关的私有数据的例子的框架。
   </para>

<!--==========================orignal english content==========================
<programlisting>
<![CDATA[
/* required header for libpq events (note: includes libpq-fe.h) */
#include <libpq-events.h>

/* The instanceData */
typedef struct
{
    int n;
    char *str;
} mydata;

/* PGEventProc */
static int myEventProc(PGEventId evtId, void *evtInfo, void *passThrough);

int
main(void)
{
    mydata *data;
    PGresult *res;
    PGconn *conn = PQconnectdb("dbname = postgres");

    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        PQfinish(conn);
        return 1;
    }

    /* called once on any connection that should receive events.
     * Sends a PGEVT_REGISTER to myEventProc.
     */
    if (!PQregisterEventProc(conn, myEventProc, "mydata_proc", NULL))
    {
        fprintf(stderr, "Cannot register PGEventProc\n");
        PQfinish(conn);
        return 1;
    }

    /* conn instanceData is available */
    data = PQinstanceData(conn, myEventProc);

    /* Sends a PGEVT_RESULTCREATE to myEventProc */
    res = PQexec(conn, "SELECT 1 + 1");

    /* result instanceData is available */
    data = PQresultInstanceData(res, myEventProc);

    /* If PG_COPYRES_EVENTS is used, sends a PGEVT_RESULTCOPY to myEventProc */
    res_copy = PQcopyResult(res, PG_COPYRES_TUPLES | PG_COPYRES_EVENTS);

    /* result instanceData is available if PG_COPYRES_EVENTS was
     * used during the PQcopyResult call.
     */
    data = PQresultInstanceData(res_copy, myEventProc);

    /* Both clears send a PGEVT_RESULTDESTROY to myEventProc */
    PQclear(res);
    PQclear(res_copy);

    /* Sends a PGEVT_CONNDESTROY to myEventProc */
    PQfinish(conn);

    return 0;
}

static int
myEventProc(PGEventId evtId, void *evtInfo, void *passThrough)
{
    switch (evtId)
    {
        case PGEVT_REGISTER:
        {
            PGEventRegister *e = (PGEventRegister *)evtInfo;
            mydata *data = get_mydata(e->conn);

            /* associate app specific data with connection */
            PQsetInstanceData(e->conn, myEventProc, data);
            break;
        }

        case PGEVT_CONNRESET:
        {
            PGEventConnReset *e = (PGEventConnReset *)evtInfo;
            mydata *data = PQinstanceData(e->conn, myEventProc);

            if (data)
              memset(data, 0, sizeof(mydata));
            break;
        }

        case PGEVT_CONNDESTROY:
        {
            PGEventConnDestroy *e = (PGEventConnDestroy *)evtInfo;
            mydata *data = PQinstanceData(e->conn, myEventProc);

            /* free instance data because the conn is being destroyed */
            if (data)
              free_mydata(data);
            break;
        }

        case PGEVT_RESULTCREATE:
        {
            PGEventResultCreate *e = (PGEventResultCreate *)evtInfo;
            mydata *conn_data = PQinstanceData(e->conn, myEventProc);
            mydata *res_data = dup_mydata(conn_data);

            /* associate app specific data with result (copy it from conn) */
            PQsetResultInstanceData(e->result, myEventProc, res_data);
            break;
        }

        case PGEVT_RESULTCOPY:
        {
            PGEventResultCopy *e = (PGEventResultCopy *)evtInfo;
            mydata *src_data = PQresultInstanceData(e->src, myEventProc);
            mydata *dest_data = dup_mydata(src_data);

            /* associate app specific data with result (copy it from a result) */
            PQsetResultInstanceData(e->dest, myEventProc, dest_data);
            break;
        }

        case PGEVT_RESULTDESTROY:
        {
            PGEventResultDestroy *e = (PGEventResultDestroy *)evtInfo;
            mydata *data = PQresultInstanceData(e->result, myEventProc);

            /* free instance data because the result is being destroyed */
            if (data)
              free_mydata(data);
            break;
        }

        /* unknown event ID, just return TRUE. */
        default:
            break;
    }

    return TRUE; /* event processing succeeded */
}
]]>
</programlisting>
____________________________________________________________________________-->
<programlisting>
<![CDATA[
/* 要求 libpq 事件的头文件（注意：包括 libpq-fe.h） */
#include <libpq-events.h>

/* The instanceData */
typedef struct
{
    int n;
    char *str;
} mydata;

/* PGEventProc */
static int myEventProc(PGEventId evtId, void *evtInfo, void *passThrough);

int
main(void)
{
    mydata *data;
    PGresult *res;
    PGconn *conn = PQconnectdb("dbname = postgres");

    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        PQfinish(conn);
        return 1;
    }

    /* 在任何应该接收事件的连接上调用一次。
     * 发送一个 PGEVT_REGISTER 给 myEventProc。
     */
    if (!PQregisterEventProc(conn, myEventProc, "mydata_proc", NULL))
    {
        fprintf(stderr, "Cannot register PGEventProc\n");
        PQfinish(conn);
        return 1;
    }

    /* conn 的 instanceData 可用 */
    data = PQinstanceData(conn, myEventProc);

    /* 发送一个 PGEVT_RESULTCREATE 给 myEventProc */
    res = PQexec(conn, "SELECT 1 + 1");

    /* 结果的 instanceData 可用 */
    data = PQresultInstanceData(res, myEventProc);

    /* 如果使用了 PG_COPYRES_EVENTS，发送一个 PGEVT_RESULTCOPY 给 myEventProc */
    res_copy = PQcopyResult(res, PG_COPYRES_TUPLES | PG_COPYRES_EVENTS);

    /* 如果在 PQcopyResult 调用时使用了 PG_COPYRES_EVENTS，结果的 instanceData 可用。*/
    data = PQresultInstanceData(res_copy, myEventProc);

    /* 两个清除都发送一个 PGEVT_RESULTDESTROY 给 myEventProc */
    PQclear(res);
    PQclear(res_copy);

    /* 发送一个 PGEVT_CONNDESTROY 给 myEventProc */
    PQfinish(conn);

    return 0;
}

static int
myEventProc(PGEventId evtId, void *evtInfo, void *passThrough)
{
    switch (evtId)
    {
        case PGEVT_REGISTER:
        {
            PGEventRegister *e = (PGEventRegister *)evtInfo;
            mydata *data = get_mydata(e->conn);

            /* 将应用相关的数据与连接关联起来 */
            PQsetInstanceData(e->conn, myEventProc, data);
            break;
        }

        case PGEVT_CONNRESET:
        {
            PGEventConnReset *e = (PGEventConnReset *)evtInfo;
            mydata *data = PQinstanceData(e->conn, myEventProc);

            if (data)
              memset(data, 0, sizeof(mydata));
            break;
        }

        case PGEVT_CONNDESTROY:
        {
            PGEventConnDestroy *e = (PGEventConnDestroy *)evtInfo;
            mydata *data = PQinstanceData(e->conn, myEventProc);

            /* 因为连接正在被销毁，释放示例数据 */
            if (data)
              free_mydata(data);
            break;
        }

        case PGEVT_RESULTCREATE:
        {
            PGEventResultCreate *e = (PGEventResultCreate *)evtInfo;
            mydata *conn_data = PQinstanceData(e->conn, myEventProc);
            mydata *res_data = dup_mydata(conn_data);

            /* 把应用相关的数据与结果（从 conn 复制过来）关联起来 */
            PQsetResultInstanceData(e->result, myEventProc, res_data);
            break;
        }

        case PGEVT_RESULTCOPY:
        {
            PGEventResultCopy *e = (PGEventResultCopy *)evtInfo;
            mydata *src_data = PQresultInstanceData(e->src, myEventProc);
            mydata *dest_data = dup_mydata(src_data);

            /* 把应用相关的数据与结果（从一个结果复制过来）关联起来 */
            PQsetResultInstanceData(e->dest, myEventProc, dest_data);
            break;
        }

        case PGEVT_RESULTDESTROY:
        {
            PGEventResultDestroy *e = (PGEventResultDestroy *)evtInfo;
            mydata *data = PQresultInstanceData(e->result, myEventProc);

            /* 因为结果正在被销毁，释放实例数据 */
            if (data)
              free_mydata(data);
            break;
        }

        /* 未知事件 ID，只返回 TRUE。 */
        default:
            break;
    }

    return TRUE; /* 事件处理成功 */
}
]]>
</programlisting>
  </sect2>
 </sect1>

 <sect1 id="libpq-envars">
<!--==========================orignal english content==========================
  <title>Environment Variables</title>
____________________________________________________________________________-->
  <title>环境变量</title>

<!--==========================orignal english content==========================
  <indexterm zone="libpq-envars">
   <primary>environment variable</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="libpq-envars">
   <primary>环境变量</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The following environment variables can be used to select default
   connection parameter values, which will be used by
   <function>PQconnectdb</>, <function>PQsetdbLogin</> and
   <function>PQsetdb</> if no value is directly specified by the calling
   code.  These are useful to avoid hard-coding database connection
   information into simple client applications, for example.

   <itemizedlist>
    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGHOST</envar></primary>
      </indexterm>
      <envar>PGHOST</envar> behaves the same as the <xref
      linkend="libpq-connect-host"> connection parameter.
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGHOSTADDR</envar></primary>
      </indexterm>
      <envar>PGHOSTADDR</envar> behaves the same as the <xref
      linkend="libpq-connect-hostaddr"> connection parameter.
      This can be set instead of or in addition to <envar>PGHOST</envar>
      to avoid DNS lookup overhead.
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGPORT</envar></primary>
      </indexterm>
      <envar>PGPORT</envar> behaves the same as the <xref
      linkend="libpq-connect-port"> connection parameter.
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGDATABASE</envar></primary>
      </indexterm>
      <envar>PGDATABASE</envar> behaves the same as the <xref
      linkend="libpq-connect-dbname"> connection parameter.
      </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGUSER</envar></primary>
      </indexterm>
      <envar>PGUSER</envar> behaves the same as the <xref
      linkend="libpq-connect-user"> connection parameter.
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGPASSWORD</envar></primary>
      </indexterm>
      <envar>PGPASSWORD</envar> behaves the same as the <xref
      linkend="libpq-connect-password"> connection parameter.
      Use of this environment variable
      is not recommended for security reasons, as some operating systems
      allow non-root users to see process environment variables via
      <application>ps</>; instead consider using a password file
      (see <xref linkend="libpq-pgpass">).
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGPASSFILE</envar></primary>
      </indexterm>
      <envar>PGPASSFILE</envar> behaves the same as the <xref
      linkend="libpq-connect-passfile"> connection parameter.
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSERVICE</envar></primary>
      </indexterm>
      <envar>PGSERVICE</envar> behaves the same as the <xref
      linkend="libpq-connect-service"> connection parameter.
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSERVICEFILE</envar></primary>
      </indexterm>
      <envar>PGSERVICEFILE</envar> specifies the name of the per-user
      connection service file.  If not set, it defaults
      to <filename>~/.pg_service.conf</>
      (see <xref linkend="libpq-pgservice">).
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGOPTIONS</envar></primary>
      </indexterm>
      <envar>PGOPTIONS</envar> behaves the same as the <xref
      linkend="libpq-connect-options"> connection parameter.
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGAPPNAME</envar></primary>
      </indexterm>
      <envar>PGAPPNAME</envar> behaves the same as the <xref
      linkend="libpq-connect-application-name"> connection parameter.
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSSLMODE</envar></primary>
      </indexterm>
      <envar>PGSSLMODE</envar> behaves the same as the <xref
      linkend="libpq-connect-sslmode"> connection parameter.
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGREQUIRESSL</envar></primary>
      </indexterm>
      <envar>PGREQUIRESSL</envar> behaves the same as the <xref
      linkend="libpq-connect-requiressl"> connection parameter.
      This environment variable is deprecated in favor of the
      <envar>PGSSLMODE</envar> variable; setting both variables suppresses the
      effect of this one.
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSSLCOMPRESSION</envar></primary>
      </indexterm>
      <envar>PGSSLCOMPRESSION</envar> behaves the same as the <xref
      linkend="libpq-connect-sslcompression"> connection parameter.
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSSLCERT</envar></primary>
      </indexterm>
      <envar>PGSSLCERT</envar> behaves the same as the <xref
      linkend="libpq-connect-sslcert"> connection parameter.
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSSLKEY</envar></primary>
      </indexterm>
      <envar>PGSSLKEY</envar> behaves the same as the <xref
      linkend="libpq-connect-sslkey"> connection parameter.
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSSLROOTCERT</envar></primary>
      </indexterm>
      <envar>PGSSLROOTCERT</envar>  behaves the same as the <xref
      linkend="libpq-connect-sslrootcert"> connection parameter.
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSSLCRL</envar></primary>
      </indexterm>
      <envar>PGSSLCRL</envar>  behaves the same as the <xref
      linkend="libpq-connect-sslcrl"> connection parameter.
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGREQUIREPEER</envar></primary>
      </indexterm>
      <envar>PGREQUIREPEER</envar> behaves the same as the <xref
      linkend="libpq-connect-requirepeer"> connection parameter.
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGKRBSRVNAME</envar></primary>
      </indexterm>
      <envar>PGKRBSRVNAME</envar>  behaves the same as the <xref
      linkend="libpq-connect-krbsrvname"> connection parameter.
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGGSSLIB</envar></primary>
      </indexterm>
      <envar>PGGSSLIB</envar> behaves the same as the <xref
      linkend="libpq-connect-gsslib"> connection parameter.
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGCONNECT_TIMEOUT</envar></primary>
      </indexterm>
      <envar>PGCONNECT_TIMEOUT</envar>  behaves the same as the <xref
      linkend="libpq-connect-connect-timeout"> connection parameter.
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGCLIENTENCODING</envar></primary>
      </indexterm>
      <envar>PGCLIENTENCODING</envar> behaves the same as the <xref
      linkend="libpq-connect-client-encoding"> connection parameter.
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGTARGETSESSIONATTRS</envar></primary>
      </indexterm>
      <envar>PGTARGETSESSIONATTRS</envar> behaves the same as the <xref
      linkend="libpq-connect-target-session-attrs"> connection parameter.
     </para>
    </listitem>
   </itemizedlist>
  </para>
____________________________________________________________________________-->
  <para>
   下列环境变量能被用于选择默认的连接参数值，如果调用代码没有直接指定值，它们将被用于<function>PQconnectdb</>、<function>PQsetdbLogin</>和<function>PQsetdb</>。例如，这些有助于防止数据库连接信息被硬编码到简单的客户端应用中。

   <itemizedlist>
    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGHOST</envar></primary>
      </indexterm>
      <envar>PGHOST</envar>的行为和<xref linkend="libpq-connect-host">连接参数相同。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGHOSTADDR</envar></primary>
      </indexterm>
      <envar>PGHOSTADDR</envar>的行为和<xref linkend="libpq-connect-hostaddr">连接参数相同。可以设置它来替代或者作为<envar>PGHOST</envar>的补充来防止 DNS 查找负担。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGPORT</envar></primary>
      </indexterm>
      <envar>PGPORT</envar>的行为和<xref linkend="libpq-connect-port">连接参数相同。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGDATABASE</envar></primary>
      </indexterm>
      <envar>PGDATABASE</envar>的行为和<xref linkend="libpq-connect-dbname">连接参数相同。
      </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGUSER</envar></primary>
      </indexterm>
      <envar>PGUSER</envar>的行为和<xref linkend="libpq-connect-user">连接参数相同。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGPASSWORD</envar></primary>
      </indexterm>
      <envar>PGPASSWORD</envar>的行为和<xref linkend="libpq-connect-password">连接参数相同。出于安全原因，我们不推荐使用这个环境变量，因为某些操作系统允许非根用户通过<application>ps</>看到进程的环境变量。可以考虑使用口令文件（见<xref linkend="libpq-pgpass">）。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGPASSFILE</envar></primary>
      </indexterm>
      <envar>PGPASSFILE</envar>和<xref
      linkend="libpq-connect-passfile">连接参数的行为相同。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSERVICE</envar></primary>
      </indexterm>
      <envar>PGSERVICE</envar>的行为和<xref linkend="libpq-connect-service">连接参数相同。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSERVICEFILE</envar></primary>
      </indexterm>
      <envar>PGSERVICEFILE</envar>指定针对每个用户的连接服务文件名。如果没有设置，默认为<filename>~/.pg_service.conf</>（见<xref linkend="libpq-pgservice">）。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGOPTIONS</envar></primary>
      </indexterm>
      <envar>PGOPTIONS</envar>的行为和<xref linkend="libpq-connect-options">连接参数相同。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGAPPNAME</envar></primary>
      </indexterm>
      <envar>PGAPPNAME</envar>的行为和<xref linkend="libpq-connect-application-name">连接参数相同。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSSLMODE</envar></primary>
      </indexterm>
      <envar>PGSSLMODE</envar>的行为和<xref linkend="libpq-connect-sslmode">连接参数相同。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGREQUIRESSL</envar></primary>
      </indexterm>
      <envar>PGREQUIRESSL</envar>的行为和<xref linkend="libpq-connect-requiressl">连接参数相同。
	  为了支持<envar>PGSSLMODE</envar>变量，废弃了这个环境变量；
	  同时设置这两个变量会抑制这个变量的效果。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSSLCOMPRESSION</envar></primary>
      </indexterm>
      <envar>PGSSLCOMPRESSION</envar>的行为和<xref linkend="libpq-connect-sslcompression">连接参数相同。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSSLCERT</envar></primary>
      </indexterm>
      <envar>PGSSLCERT</envar>的行为和<xref linkend="libpq-connect-sslcert">连接参数相同。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSSLKEY</envar></primary>
      </indexterm>
      <envar>PGSSLKEY</envar>的行为和<xref linkend="libpq-connect-sslkey">连接参数相同。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSSLROOTCERT</envar></primary>
      </indexterm>
      <envar>PGSSLROOTCERT</envar>的行为和<xref linkend="libpq-connect-sslrootcert">连接参数相同。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSSLCRL</envar></primary>
      </indexterm>
      <envar>PGSSLCRL</envar>的行为和<xref linkend="libpq-connect-sslcrl">连接参数相同。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGREQUIREPEER</envar></primary>
      </indexterm>
      <envar>PGREQUIREPEER</envar>的行为和<xref linkend="libpq-connect-requirepeer">连接参数相同。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGKRBSRVNAME</envar></primary>
      </indexterm>
      <envar>PGKRBSRVNAME</envar>的行为和<xref linkend="libpq-connect-krbsrvname">连接参数相同。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGGSSLIB</envar></primary>
      </indexterm>
      <envar>PGGSSLIB</envar>的行为和<xref linkend="libpq-connect-gsslib">连接参数相同。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGCONNECT_TIMEOUT</envar></primary>
      </indexterm>
      <envar>PGCONNECT_TIMEOUT</envar>的行为和<xref linkend="libpq-connect-connect-timeout">连接参数相同。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGCLIENTENCODING</envar></primary>
      </indexterm>
      <envar>PGCLIENTENCODING</envar>的行为和<xref linkend="libpq-connect-client-encoding">连接参数相同。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGTARGETSESSIONATTRS</envar></primary>
      </indexterm>
      <envar>PGTARGETSESSIONATTRS</envar>的行为和<xref
      linkend="libpq-connect-target-session-attrs">连接参数相同。
     </para>
    </listitem>
	</itemizedlist>
  </para>

<!--==========================orignal english content==========================
  <para>
   The following environment variables can be used to specify default
   behavior for each <productname>PostgreSQL</productname> session.  (See
   also the <xref linkend="sql-alterrole">
   and <xref linkend="sql-alterdatabase">
   commands for ways to set default behavior on a per-user or per-database
   basis.)

   <itemizedlist>
    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGDATESTYLE</envar></primary>
      </indexterm>
      <envar>PGDATESTYLE</envar> sets the default style of date/time
      representation.  (Equivalent to <literal>SET datestyle TO
      ...</literal>.)
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGTZ</envar></primary>
      </indexterm>
      <envar>PGTZ</envar> sets the default time zone.  (Equivalent to
      <literal>SET timezone TO ...</literal>.)
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGGEQO</envar></primary>
      </indexterm>
      <envar>PGGEQO</envar> sets the default mode for the genetic query
      optimizer.  (Equivalent to <literal>SET geqo TO ...</literal>.)
     </para>
    </listitem>
   </itemizedlist>

   Refer to the <acronym>SQL</acronym> command <xref linkend="sql-set">
   for information on correct values for these
   environment variables.
  </para>
____________________________________________________________________________-->
  <para>
   下面的环境变量可用来为每一个<productname>PostgreSQL</productname>会话指定默认行为（为每一个用户或每一个数据库设置默认行为的方法还可见<xref linkend="sql-alterrole">和<xref linkend="sql-alterdatabase">命令）。

   <itemizedlist>
    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGDATESTYLE</envar></primary>
      </indexterm>
      <envar>PGDATESTYLE</envar>设置日期/时间表示的默认风格（等同于<literal>SET datestyle TO ...</literal>）。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGTZ</envar></primary>
      </indexterm>
      <envar>PGTZ</envar>设置默认的时区（等同于<literal>SET timezone TO ...</literal>）。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGGEQO</envar></primary>
      </indexterm>
      <envar>PGGEQO</envar>为遗传查询优化器设置默认模式（等同于<literal>SET geqo TO ...</literal>）。
     </para>
    </listitem>
   </itemizedlist>

   这些环境变量的正确值可参考<acronym>SQL</acronym> 命令 <xref linkend="sql-set">。
  </para>

<!--==========================orignal english content==========================
  <para>
   The following environment variables determine internal behavior of
   <application>libpq</application>; they override compiled-in defaults.

   <itemizedlist>
    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSYSCONFDIR</envar></primary>
      </indexterm>
      <envar>PGSYSCONFDIR</envar> sets the directory containing the
      <filename>pg_service.conf</> file and in a future version
      possibly other system-wide configuration files.
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGLOCALEDIR</envar></primary>
      </indexterm>
      <envar>PGLOCALEDIR</envar> sets the directory containing the
      <literal>locale</> files for message localization.
     </para>
    </listitem>
   </itemizedlist>
  </para>
____________________________________________________________________________-->
  <para>
   下面的环境变量决定<application>libpq</application>的内部行为，它们会覆盖编译在程序中的默认值。

   <itemizedlist>
    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSYSCONFDIR</envar></primary>
      </indexterm>
      <envar>PGSYSCONFDIR</envar>设置包含<filename>pg_service.conf</>文件以及未来版本中可能出现的其他系统范围配置文件的目录。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGLOCALEDIR</envar></primary>
      </indexterm>
      <envar>PGLOCALEDIR</envar>设置包含用于消息本地化的<literal>locale</>文件的目录。
     </para>
    </listitem>
   </itemizedlist>
  </para>

 </sect1>


 <sect1 id="libpq-pgpass">
<!--==========================orignal english content==========================
  <title>The Password File</title>
____________________________________________________________________________-->
  <title>口令文件</title>

<!--==========================orignal english content==========================
  <indexterm zone="libpq-pgpass">
   <primary>password file</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="libpq-pgpass">
   <primary>口令文件</primary>
  </indexterm>
<!--==========================orignal english content==========================
  <indexterm zone="libpq-pgpass">
   <primary>.pgpass</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="libpq-pgpass">
   <primary>.pgpass</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The file <filename>.pgpass</filename> in a user's home directory can
   contain passwords to
   be used if the connection requires a password (and no password has been
   specified  otherwise). On Microsoft Windows the file is named
   <filename>%APPDATA%\postgresql\pgpass.conf</> (where
   <filename>%APPDATA%</> refers to the Application Data subdirectory in
   the user's profile).
   Alternatively, a password file can be specified
   using the connection parameter <xref linkend="libpq-connect-passfile">
   or the environment variable <envar>PGPASSFILE</envar>.
  </para>
____________________________________________________________________________-->
  <para>
   一个用户主目录中的<filename>.pgpass</filename>文件可能包含在连接需要时使用的口令（并且其他情况不会指定口令）。在微软的 Windows 上该文件被命名为<filename>%APPDATA%\postgresql\pgpass.conf</>（其中<filename>%APPDATA%</>指的是用户配置中的应用数据子目录）。
   或者，可以使用连接参数<xref linkend="libpq-connect-passfile">或环境变量
   <envar>PGPASSFILE</envar>指定口令文件。
  </para>

<!--==========================orignal english content==========================
  <para>
   This file should contain lines of the following format:
<synopsis>
<replaceable>hostname</replaceable>:<replaceable>port</replaceable>:<replaceable>database</replaceable>:<replaceable>username</replaceable>:<replaceable>password</replaceable>
</synopsis>
   (You can add a reminder comment to the file by copying the line above and
   preceding it with <literal>#</>.)
   Each of the first four fields can be a literal value, or
   <literal>*</literal>, which matches anything.  The password field from
   the first line that matches the current connection parameters will be
   used.  (Therefore, put more-specific entries first when you are using
   wildcards.) If an entry needs to contain <literal>:</literal> or
   <literal>\</literal>, escape this character with <literal>\</literal>.
   A host name of <literal>localhost</> matches both TCP (host name
   <literal>localhost</>) and Unix domain socket (<literal>pghost</> empty
   or the default socket directory) connections coming from the local
   machine. In a standby server, a database name of <literal>replication</>
   matches streaming replication connections made to the master server.
   The <literal>database</> field is of limited usefulness because
   users have the same password for all databases in the same cluster.
  </para>
____________________________________________________________________________-->
  <para>
   这个文件应该包含下列格式的行：
<synopsis>
<replaceable>hostname</replaceable>:<replaceable>port</replaceable>:<replaceable>database</replaceable>:<replaceable>username</replaceable>:<replaceable>password</replaceable>
</synopsis>
   （你可以向该文件增加一个提醒：把上面的行复制到该文件并且在前面加上<literal>#</>）。前四个域的每一个都可以是文字值或者匹配任何东西的<literal>*</literal>。第一个匹配当前连接参数的行中的口令域将被使用（因此，在使用通配符时把更特殊的项放在前面）。如果一个条目需要包含<literal>:</literal>或者<literal>\</literal>，用<literal>\</literal>对该字符转义。一个<literal>localhost</>主机名匹配来自本地机器的 TCP （主机名<literal>localhost</>）和 Unix 域套接字（<literal>pghost</>为空或者默认套接字目录）连接。在一台后备服务器上，一个名为<literal>replication</>的数据库名匹配到主控服务器的流复制连接。<literal>database</>域的用途有限，因为用户对同一个集簇中所有数据库都有相同的口令。
  </para>

<!--==========================orignal english content==========================
  <para>
   On Unix systems, the permissions on a password file must
   disallow any access to world or group; achieve this by a command such as
   <command>chmod 0600 ~/.pgpass</command>.  If the permissions are less
   strict than this, the file will be ignored.  On Microsoft Windows, it
   is assumed that the file is stored in a directory that is secure, so
   no special permissions check is made.
  </para>
____________________________________________________________________________-->
  <para>
   在 Unix 系统上，口令文件上的权限必须不允许所有人或组内访问，可以用命令比如<command>chmod 0600 ~/.pgpass</command>实现。如果权限没有这么严格，该文件将被忽略。在微软 Windows 上，该文件被假定存储在一个安全的目录中，因此不会进行特别的权限检查。
  </para>
 </sect1>


 <sect1 id="libpq-pgservice">
<!--==========================orignal english content==========================
  <title>The Connection Service File</title>
____________________________________________________________________________-->
  <title>连接服务文件</title>

<!--==========================orignal english content==========================
  <indexterm zone="libpq-pgservice">
   <primary>connection service file</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="libpq-pgservice">
   <primary>连接服务文件</primary>
  </indexterm>
<!--==========================orignal english content==========================
  <indexterm zone="libpq-pgservice">
   <primary>pg_service.conf</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="libpq-pgservice">
   <primary>pg_service.conf</primary>
  </indexterm>
<!--==========================orignal english content==========================
  <indexterm zone="libpq-pgservice">
   <primary>.pg_service.conf</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="libpq-pgservice">
   <primary>.pg_service.conf</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The connection service file allows libpq connection parameters to be
   associated with a single service name. That service name can then be
   specified by a libpq connection, and the associated settings will be
   used. This allows connection parameters to be modified without requiring
   a recompile of the libpq application. The service name can also be
   specified using the <envar>PGSERVICE</envar> environment variable.
  </para>
____________________________________________________________________________-->
  <para>
   连接服务文件允许 libpq 连接参数与一个单一服务名称关联。那个服务名称可以被一个 libpq 连接指定，与其相关的设置将被使用。这允许在不重新编译 libpq 应用的前提下修改连接参数。服务名称也可以被使用<envar>PGSERVICE</envar>环境变量来指定。
  </para>

<!--==========================orignal english content==========================
  <para>
   The connection service file can be a per-user service file
   at <filename>~/.pg_service.conf</filename> or the location
   specified by the environment variable <envar>PGSERVICEFILE</envar>,
   or it can be a system-wide file
   at <filename>`pg_config -&minus;sysconfdir`/pg_service.conf</filename> or in the directory
   specified by the environment variable
   <envar>PGSYSCONFDIR</envar>.  If service definitions with the same
   name exist in the user and the system file, the user file takes
   precedence.
  </para>
____________________________________________________________________________-->
  <para>
   连接服务文件可以是每个用户都有一个的服务文件，它位于<filename>~/.pg_service.conf</filename>或者环境变量<envar>PGSERVICEFILE</envar>指定的位置。它也可以是一个系统范围的文件，位于<filename>`pg_config --sysconfdir`/pg_service.conf</filename>的或者环境变量<envar>PGSYSCONFDIR</envar>指定的目录。如果相同名称的服务定义存在于用户和系统文件中，用户文件将优先考虑。
  </para>

<!--==========================orignal english content==========================
  <para>
   The file uses an <quote>INI file</quote> format where the section
   name is the service name and the parameters are connection
   parameters; see <xref linkend="libpq-paramkeywords"> for a list.  For
   example:
<programlisting>
# comment
[mydb]
host=somehost
port=5433
user=admin
</programlisting>
   An example file is provided at
   <filename>share/pg_service.conf.sample</filename>.
  </para>
____________________________________________________________________________-->
  <para>
   该文件使用一种<quote>INI 文件</quote>格式，其中小节名是服务名并且参数是连接参数。列表见<xref linkend="libpq-paramkeywords">。例如：
<programlisting>
# comment
[mydb]
host=somehost
port=5433
user=admin
</programlisting>
   <filename>share/pg_service.conf.sample</filename>中提供了一个例子文件。
  </para>
 </sect1>


 <sect1 id="libpq-ldap">
<!--==========================orignal english content==========================
  <title>LDAP Lookup of Connection Parameters</title>
____________________________________________________________________________-->
  <title>连接参数的 LDAP 查找</title>

<!--==========================orignal english content==========================
  <indexterm zone="libpq-ldap">
   <primary>LDAP connection parameter lookup</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="libpq-ldap">
   <primary>LDAP 连接参数查找</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   If <application>libpq</application> has been compiled with LDAP support (option
   <literal><option>-&minus;with-ldap</option></literal> for <command>configure</command>)
   it is possible to retrieve connection options like <literal>host</literal>
   or <literal>dbname</literal> via LDAP from a central server.
   The advantage is that if the connection parameters for a database change,
   the connection information doesn't have to be updated on all client machines.
  </para>
____________________________________________________________________________-->
  <para>
   如果<application>libpq</application>已经在编译时打开了 LDAP 支持（<command>configure</command>的选项<literal><option>--with-ldap</option></literal>），就可以通过 LDAP 从一个中央服务器检索<literal>host</literal>或<literal>dbname</literal>之类的连接参数。这样做的好处是如果一个数据库的连接参数改变，不需要在所有的客户端机器上更新连接信息。
  </para>

<!--==========================orignal english content==========================
  <para>
   LDAP connection parameter lookup uses the connection service file
   <filename>pg_service.conf</filename> (see <xref
   linkend="libpq-pgservice">).  A line in a
   <filename>pg_service.conf</filename> stanza that starts with
   <literal>ldap://</literal> will be recognized as an LDAP URL and an
   LDAP query will be performed. The result must be a list of
   <literal>keyword = value</literal> pairs which will be used to set
   connection options.  The URL must conform to RFC 1959 and be of the
   form
<synopsis>
ldap://[<replaceable>hostname</replaceable>[:<replaceable>port</replaceable>]]/<replaceable>search_base</replaceable>?<replaceable>attribute</replaceable>?<replaceable>search_scope</replaceable>?<replaceable>filter</replaceable>
</synopsis>
   where <replaceable>hostname</replaceable> defaults to
   <literal>localhost</literal> and <replaceable>port</replaceable>
   defaults to 389.
  </para>
____________________________________________________________________________-->
  <para>
   LDAP 连接参数查找使用连接服务文件<filename>pg_service.conf</filename>（见<xref linkend="libpq-pgservice">）。<filename>pg_service.conf</filename>中一个以<literal>ldap://</literal>开始的行将被识别为一个 LDAP URL 并且将执行一个 LDAP 查询。结果必须是一个<literal>keyword = value</literal>对列表，它将被用来设置连接选项。URL 必须遵循 RFC 1959 并且是形式
<synopsis>
ldap://[<replaceable>hostname</replaceable>[:<replaceable>port</replaceable>]]/<replaceable>search_base</replaceable>?<replaceable>attribute</replaceable>?<replaceable>search_scope</replaceable>?<replaceable>filter</replaceable>
</synopsis>
   其中<replaceable>hostname</replaceable>默认为<literal>localhost</literal>并且<replaceable>port</replaceable>默认为 389。
  </para>

<!--==========================orignal english content==========================
  <para>
   Processing of <filename>pg_service.conf</filename> is terminated after
   a successful LDAP lookup, but is continued if the LDAP server cannot
   be contacted.  This is to provide a fallback with further LDAP URL
   lines that point to different LDAP servers, classical <literal>keyword
   = value</literal> pairs, or default connection options.  If you would
   rather get an error message in this case, add a syntactically incorrect
   line after the LDAP URL.
  </para>
____________________________________________________________________________-->
  <para>
   一次成功的 LDAP 查找后，<filename>pg_service.conf</filename>的处理被终止。但是如果联系不上 LDAP 则会继续处理<filename>pg_service.conf</filename>。这就提供了后手，可以加入更多指向不同 LDAP 服务器的 LDAP URL 行、经典的<literal>keyword = value</literal>对或者默认连接选项。如果你宁愿在这种情况下得到一个错误消息，在该 LDAP URL 之后增加一个语法错误的行。
  </para>

<!--==========================orignal english content==========================
  <para>
   A sample LDAP entry that has been created with the LDIF file
<programlisting>
version:1
dn:cn=mydatabase,dc=mycompany,dc=com
changetype:add
objectclass:top
objectclass:device
cn:mydatabase
description:host=dbserver.mycompany.com
description:port=5439
description:dbname=mydb
description:user=mydb_user
description:sslmode=require
</programlisting>
   might be queried with the following LDAP URL:
<programlisting>
ldap://ldap.mycompany.com/dc=mycompany,dc=com?description?one?(cn=mydatabase)
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   一个和 LDIF 文件一起创建的 LDAP 条目实例
<programlisting>
version:1
dn:cn=mydatabase,dc=mycompany,dc=com
changetype:add
objectclass:top
objectclass:device
cn:mydatabase
description:host=dbserver.mycompany.com
description:port=5439
description:dbname=mydb
description:user=mydb_user
description:sslmode=require
</programlisting>
   可以用下面的 LDAP URL 查询到：
<programlisting>
ldap://ldap.mycompany.com/dc=mycompany,dc=com?description?one?(cn=mydatabase)
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   You can also mix regular service file entries with LDAP lookups.
   A complete example for a stanza in <filename>pg_service.conf</filename>
   would be:
<programlisting>
# only host and port are stored in LDAP, specify dbname and user explicitly
[customerdb]
dbname=customer
user=appuser
ldap://ldap.acme.com/cn=dbserver,cn=hosts?pgconnectinfo?base?(objectclass=*)
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   您还可以将常规服务文件条目与LDAP查找相混合。<filename>pg_service.conf</filename>
   中的节的完整示例将是：
<programlisting>
# 只有主机和端口存储在LDAP中，明确指定dbname和user
[customerdb]
dbname=customer
user=appuser
ldap://ldap.acme.com/cn=dbserver,cn=hosts?pgconnectinfo?base?(objectclass=*)
</programlisting>
  </para>
 </sect1>


 <sect1 id="libpq-ssl">
<!--==========================orignal english content==========================
  <title>SSL Support</title>
____________________________________________________________________________-->
  <title>SSL 支持</title>

<!--==========================orignal english content==========================
  <indexterm zone="libpq-ssl">
   <primary>SSL</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="libpq-ssl">
   <primary>SSL</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</> has native support for using <acronym>SSL</>
   connections to encrypt client/server communications for increased
   security. See <xref linkend="ssl-tcp"> for details about the server-side
   <acronym>SSL</> functionality.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</>本地支持使用<acronym>SSL</>
   连接加密客户端/服务器通信以提高安全性。关于服务器端的<acronym>SSL</>
   功能详见<xref linkend="ssl-tcp">。
  </para>

<!--==========================orignal english content==========================
  <para>
   <application>libpq</application> reads the system-wide
   <productname>OpenSSL</productname> configuration file. By default, this
   file is named <filename>openssl.cnf</filename> and is located in the
   directory reported by <literal>openssl version -d</>.  This default
   can be overridden by setting environment variable
   <envar>OPENSSL_CONF</envar> to the name of the desired configuration
   file.
  </para>
____________________________________________________________________________-->
  <para>
   <application>libpq</application>读取系统范围的<productname>OpenSSL</productname>
   配置文件。默认情况下，这个文件被命名为<filename>openssl.cnf</filename>并且存放在
   <literal>openssl version -d</>报告的目录中。可以通过设置环境变量
   <envar>OPENSSL_CONF</envar>把这个默认值覆盖为想要的配置文件的名称。
  </para>

 <sect2 id="libq-ssl-certificates">
<!--==========================orignal english content==========================
  <title>Client Verification of Server Certificates</title>
____________________________________________________________________________-->
  <title>服务器证书的客户端验证</title>

<!--==========================orignal english content==========================
  <para>
   By default, <productname>PostgreSQL</> will not perform any verification of
   the server certificate. This means that it is possible to spoof the server
   identity (for example by modifying a DNS record or by taking over the server
   IP address) without the client knowing. In order to prevent spoofing,
   <acronym>SSL</> certificate verification must be used.
  </para>
____________________________________________________________________________-->
  <para>
   默认情况下，<productname>PostgreSQL</>将不会执行服务器证书的任何验证。
   这意味着可以在不被客户端知晓的情况下伪造服务器身份
   （例如通过修改一个 DNS 记录或者接管服务器的 IP 地址）。为了阻止哄骗，
   必须使用<acronym>SSL</>证书验证。
  </para>

<!--==========================orignal english content==========================
  <para>
   If the parameter <literal>sslmode</> is set to <literal>verify-ca</>,
   libpq will verify that the server is trustworthy by checking the
   certificate chain up to a trusted certificate authority
   (<acronym>CA</>). If <literal>sslmode</> is set to <literal>verify-full</>,
   libpq will <emphasis>also</> verify that the server host name matches its
   certificate. The SSL connection will fail if the server certificate cannot
   be verified. <literal>verify-full</> is recommended in most
   security-sensitive environments.
  </para>
____________________________________________________________________________-->
  <para>
   如果参数<literal>sslmode</>被设置为<literal>verify-ca</>，
   libpq 将通过检查证书链一直到一个可信的证书机构（<acronym>CA</>）
   来验证服务器是可信的。如果<literal>sslmode</>被设置为<literal>verify-full</>，
   libpq 将<emphasis>还会</>验证服务器主机名是否匹配它的证书。
   如果服务器证书不能被验证，SSL 连接将失败。在大部分对安全敏感的环境中，
   建议使用<literal>verify-full</>。
  </para>

<!--==========================orignal english content==========================
  <para>
   In <literal>verify-full</> mode, the host name is matched against the
   certificate's Subject Alternative Name attribute(s), or against the
   Common Name attribute if no Subject Alternative Name of type <literal>dNSName</literal> is
   present.  If the certificate's name attribute starts with an asterisk
   (<literal>*</>), the asterisk will be treated as
   a wildcard, which will match all characters <emphasis>except</> a dot
   (<literal>.</>). This means the certificate will not match subdomains.
   If the connection is made using an IP address instead of a host name, the
   IP address will be matched (without doing any DNS lookups).
  </para>
____________________________________________________________________________-->
  <para>
   在<literal>verify-full</>模式下，主机名与证书的Subject Alternative Name
   （主题备用名称)属性进行匹配，
   或者如果没有类型为dNSName的主题备用名称，则与Common Name（公用名称）属性进行匹配。
   如果证书的名称属性以星号（<literal> * </>）开头，则星号将被视为通配符，
   其将匹配<emphasis>除了</>点(<literal>.</>)之外的所有字符。这意味着证书将不会匹配子域。
   如果使用IP地址而不是主机名进行连接，则将匹配IP地址（不进行任何DNS查找）。  
  </para>

<!--==========================orignal english content==========================
  <para>
   To allow server certificate verification, the certificate(s) of one or more
   trusted <acronym>CA</>s must be
   placed in the file <filename>~/.postgresql/root.crt</> in the user's home
   directory. If intermediate <acronym>CA</>s appear in
   <filename>root.crt</filename>, the file must also contain certificate
   chains to their root <acronym>CA</>s. (On Microsoft Windows the file is named
   <filename>%APPDATA%\postgresql\root.crt</filename>.)
  </para>
____________________________________________________________________________-->
  <para>
   要允许服务器证书验证，一个或多个可信的<acronym>CA</>必须被放置在用户home目录下的文件
   <filename>~/.postgresql/root.crt</>中。如果中间<acronym>CA</>出现在
   <filename>root.crt</filename>中，该文件必须也包含到它们的根<acronym>CA</>的证书链
   （在微软 Windows 上该文件被命名为<filename>%APPDATA%\postgresql\root.crt</filename>）。
  </para>

<!--==========================orignal english content==========================
  <para>
   Certificate Revocation List (CRL) entries are also checked
   if the file <filename>~/.postgresql/root.crl</filename> exists
   (<filename>%APPDATA%\postgresql\root.crl</filename> on Microsoft
   Windows).
  </para>
____________________________________________________________________________-->
  <para>
   如果文件<filename>~/.postgresql/root.crl</filename>存在
   （微软 Windows 上的<filename>%APPDATA%\postgresql\root.crl</filename>），
   也会检查证书撤销列表（CRL）项。
  </para>

<!--==========================orignal english content==========================
  <para>
   The location of the root certificate file and the CRL can be changed by
   setting
   the connection parameters <literal>sslrootcert</> and <literal>sslcrl</>
   or the environment variables <envar>PGSSLROOTCERT</> and <envar>PGSSLCRL</>.
  </para>
____________________________________________________________________________-->
  <para>
   根证书文件和 CRL 的位置可以通过设置连接参数<literal>sslrootcert</>和
   <literal>sslcrl</>或环境变量<envar>PGSSLROOTCERT</>和<envar>PGSSLCRL</>改变。
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    For backwards compatibility with earlier versions of PostgreSQL, if a
    root CA file exists, the behavior of
    <literal>sslmode</literal>=<literal>require</literal> will be the same
    as that of <literal>verify-ca</literal>, meaning the server certificate
    is validated against the CA. Relying on this behavior is discouraged,
    and applications that need certificate validation should always use
    <literal>verify-ca</literal> or <literal>verify-full</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    为了与 PostgreSQL 的早期版本达到向后兼容，如果存在一个根 CA 文件，
    <literal>sslmode</literal>=<literal>require</literal>的行为将与
    <literal>verify-ca</literal>相同，意味着服务器证书根据 CA 验证。
    不鼓励依赖这种行为，并且需要证书验证的应用程序应该总是使用
    <literal>verify-ca</literal>或者<literal>verify-full</literal>。
   </para>
  </note>
 </sect2>

 <sect2 id="libpq-ssl-clientcert">
<!--==========================orignal english content==========================
  <title>Client Certificates</title>
____________________________________________________________________________-->
  <title>客户端证书</title>

<!--==========================orignal english content==========================
  <para>
   If the server requests a trusted client certificate,
   <application>libpq</application> will send the certificate stored in
   file <filename>~/.postgresql/postgresql.crt</> in the user's home
   directory.  The certificate must be signed by one of the certificate
   authorities (<acronym>CA</acronym>) trusted by the server.  A matching
   private key file <filename>~/.postgresql/postgresql.key</> must also
   be present. The private
   key file must not allow any access to world or group; achieve this by the
   command <command>chmod 0600 ~/.postgresql/postgresql.key</command>.
   On Microsoft Windows these files are named
   <filename>%APPDATA%\postgresql\postgresql.crt</filename> and
   <filename>%APPDATA%\postgresql\postgresql.key</filename>, and there
   is no special permissions check since the directory is presumed secure.
   The location of the certificate and key files can be overridden by the
   connection parameters <literal>sslcert</> and <literal>sslkey</> or the
   environment variables <envar>PGSSLCERT</> and <envar>PGSSLKEY</>.
  </para>
____________________________________________________________________________-->
  <para>
   如果服务器要求一个可信的客户端证书，<application>libpq</application>
   将发送用户主目录中<filename>~/.postgresql/postgresql.crt</>文件存储的证书。
   该证书必须由一个受服务器信任的证书机构（<acronym>CA</acronym>）签发。
   也必须存在一个匹配的私钥文件<filename>~/.postgresql/postgresql.key</>。
   该私钥文件不允许全局或组用户的任何访问，可以通过命令
   <command>chmod 0600 ~/.postgresql/postgresql.key</command>实现。
   在微软 Windows 上这些文件被命名为<filename>%APPDATA%\postgresql\postgresql.crt</filename>
   和<filename>%APPDATA%\postgresql\postgresql.key</filename>，不会有特别的权限检查，
   因为该目录被假定为安全。证书和密钥文件的位置可以使用连接参数<literal>sslcert</>
   和<literal>sslkey</>或者环境变量<envar>PGSSLCERT</>和<envar>PGSSLKEY</>覆盖。
  </para>

<!--==========================orignal english content==========================
  <para>
   In some cases, the client certificate might be signed by an
   <quote>intermediate</> certificate authority, rather than one that is
   directly trusted by the server.  To use such a certificate, append the
   certificate of the signing authority to the <filename>postgresql.crt</>
   file, then its parent authority's certificate, and so on up to a certificate
   authority, <quote>root</> or <quote>intermediate</>, that is trusted by
   the server, i.e. signed by a certificate in the server's
   <filename>root.crt</filename> file.
  </para>
____________________________________________________________________________-->
  <para>
   在一些情况下，客户端证书可以由<quote>中间</>证书机构签名，
   而不是由服务器直接信任的证书机构。
   要使用这样一个证书，将签发机构的证书加入到<filename>postgresql.crt</>文件，
   然后是它的上级机构的证书，并且一直到一个受服务器信任的证书机构（
   <quote>根</>机构或者<quote>中间</>机构），即由该服务器的
   <filename>root.crt</filename>文件中的一个证书签发。
  </para>

<!--==========================orignal english content==========================
  <para>
   Note that the client's <filename>~/.postgresql/root.crt</> lists the top-level CAs
   that are considered trusted for signing server certificates.  In principle it need
   not list the CA that signed the client's certificate, though in most cases
   that CA would also be trusted for server certificates.
  </para>
____________________________________________________________________________-->
  <para>
   注意客户端的<filename>~/.postgresql/root.crt</>
   列出了被认为可信的能用于签发服务器证书的顶层 CA。
   原则上不需要列出签发客户端证书的 CA，
   大部分情况下这些 CA 也被信任可以用于服务器证书。
  </para>

 </sect2>

 <sect2 id="libpq-ssl-protection">
<!--==========================orignal english content==========================
  <title>Protection Provided in Different Modes</title>
____________________________________________________________________________-->
  <title>不同模式中提供的保护</title>

<!--==========================orignal english content==========================
  <para>
   The different values for the <literal>sslmode</> parameter provide different
   levels of protection. SSL can provide
   protection against three types of attacks:

   <variablelist>
    <varlistentry>
     <term>Eavesdropping</term>
     <listitem>
      <para>If a third party can examine the network traffic between the
       client and the server, it can read both connection information (including
       the user name and password) and the data that is passed. <acronym>SSL</>
       uses encryption to prevent this.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Man in the middle (<acronym>MITM</>)</term>
     <listitem>
      <para>If a third party can modify the data while passing between the
       client and server, it can pretend to be the server and therefore see and
       modify data <emphasis>even if it is encrypted</>. The third party can then
       forward the connection information and data to the original server,
       making it impossible to detect this attack. Common vectors to do this
       include DNS poisoning and address hijacking, whereby the client is directed
       to a different server than intended. There are also several other
       attack methods that can accomplish this. <acronym>SSL</> uses certificate
       verification to prevent this, by authenticating the server to the client.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Impersonation</term>
     <listitem>
      <para>If a third party can pretend to be an authorized client, it can
       simply access data it should not have access to. Typically this can
       happen through insecure password management. <acronym>SSL</> uses
       client certificates to prevent this, by making sure that only holders
       of valid certificates can access the server.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   <literal>sslmode</>参数的不同值提供了不同级别的保护。
   SSL 能够针对三类攻击提供保护：

   <variablelist>
    <varlistentry>
     <term>窃听</term>
     <listitem>
      <para>如果一个第三方能够检查客户端和服务器之间的网络流量，
      它能读取连接信息（包括用户名和口令）以及被传递的数据。
      <acronym>SSL</>使用加密来阻止这种攻击。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>中间人（<acronym>MITM</>）</term>
     <listitem>
      <para>如果一个第三方能对客户端和服务器之间传送的数据进行修改，
      它就能假装是服务器并且因此能看见并且修改数据，<emphasis>即使这些数据已被加密</>。
      然后第三方可以将连接信息和数据传送给原来的服务器，使得它不可能检测到攻击。
      这样做的常用载体包括 DNS 中毒和地址劫持，借此客户端被定向到预期之外的不同的服务器。
      还有几种其他的攻击方式能够完成这种攻击。<acronym>SSL</>
      使用证书验证让客户端认证服务器，就可以阻止这种攻击。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>模仿</term>
     <listitem>
      <para>如果第三方可以伪装成一个授权的客户端，
      那么它能够轻松访问它本不能访问的数据。通常这可以由不安全的口令管理所致。
      <acronym>SSL</>使用客户端证书来阻止这种情况，
      即确保只有持有合法证书的客户才能访问服务器。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

<!--==========================orignal english content==========================
  <para>
   For a connection to be known secure, SSL usage must be configured
   on <emphasis>both the client and the server</> before the connection
   is made. If it is only configured on the server, the client may end up
   sending sensitive information (e.g. passwords) before
   it knows that the server requires high security. In libpq, secure
   connections can be ensured
   by setting the <literal>sslmode</> parameter to <literal>verify-full</> or
   <literal>verify-ca</>, and providing the system with a root certificate to
   verify against. This is analogous to using an <literal>https</>
   <acronym>URL</> for encrypted web browsing.
  </para>
____________________________________________________________________________-->
  <para>
   对于一个已知安全的连接，在连接被建立之前，必须在
   <emphasis>客户端和服务器端</>都进行SSL配置。如果只在服务器上配置，
   客户端在知道服务器要求高安全性之前可能会结束发送敏感信息（例如口令）。
   在 libpq 中，可以通过将<literal>sslmode</>参数设置为<literal>verify-full</>或
   <literal>verify-ca</>来确保安全连接，并且为系统提供一个根证书用来验证。
   这类似于使用<literal>https</> <acronym>URL</>进行加密网页浏览。
  </para>

<!--==========================orignal english content==========================
  <para>
   Once the server has been authenticated, the client can pass sensitive data.
   This means that up until this point, the client does not need to know if
   certificates will be used for authentication, making it safe to specify that
   only in the server configuration.
  </para>
____________________________________________________________________________-->
  <para>
   一旦服务器已经被认证，客户端可以传递敏感数据。这意味着直到这一点，
   客户端都不需要知道是否证书将被用于认证，这样只需要在服务器配置中指定就比较安全。
  </para>

<!--==========================orignal english content==========================
  <para>
   All <acronym>SSL</> options carry overhead in the form of encryption and
   key-exchange, so there is a trade-off that has to be made between performance
   and security. <xref linkend="libpq-ssl-sslmode-statements">
   illustrates the risks the different <literal>sslmode</> values
   protect against, and what statement they make about security and overhead.
  </para>
____________________________________________________________________________-->
  <para>
   所有<acronym>SSL</>选项都带来了加密和密钥交换的开销，
   因此必须在性能和安全性之间做出平衡。<xref linkend="libpq-ssl-sslmode-statements">
   说明不同<literal>sslmode</>值所保护的风险，以及关于安全和开销所做出的声明。
  </para>

  <table id="libpq-ssl-sslmode-statements">
<!--==========================orignal english content==========================
   <title>SSL Mode Descriptions</title>
____________________________________________________________________________-->
   <title>SSL 模式描述</title>
   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>sslmode</></entry>
      <entry>Eavesdropping protection</entry>
      <entry><acronym>MITM</> protection</entry>
      <entry>Statement</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>sslmode</></entry>
      <entry>窃听保护</entry>
      <entry><acronym>MITM</>保护</entry>
      <entry>声明</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>disable</></entry>
      <entry>No</entry>
      <entry>No</entry>
      <entry>I don't care about security, and I don't want to pay the overhead
       of encryption.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>disable</></entry>
      <entry>否</entry>
      <entry>否</entry>
      <entry>我不关心安全性，并且我不想承担加密的开销。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>allow</></entry>
      <entry>Maybe</entry>
      <entry>No</entry>
      <entry>I don't care about security, but I will pay the overhead of
       encryption if the server insists on it.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>allow</></entry>
      <entry>可能</entry>
      <entry>否</entry>
      <entry>我不关心安全性，但如果服务器坚持，我会承担加密开销 。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>prefer</></entry>
      <entry>Maybe</entry>
      <entry>No</entry>
      <entry>I don't care about encryption, but I wish to pay the overhead of
       encryption if the server supports it.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>prefer</></entry>
      <entry>可能</entry>
      <entry>否</entry>
      <entry>我不关心加密，但如果服务器支持，我希望承担加密开销。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>require</></entry>
      <entry>Yes</entry>
      <entry>No</entry>
      <entry>I want my data to be encrypted, and I accept the overhead. I trust
       that the network will make sure I always connect to the server I want.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>require</></entry>
      <entry>是</entry>
      <entry>否</entry>
      <entry>我希望我的数据加密，我接受开销。
      我相信该网络将确保我始终连接到想要连接的服务器。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>verify-ca</></entry>
      <entry>Yes</entry>
      <entry><literal>Depends on CA</>-policy</entry>
      <entry>I want my data encrypted, and I accept the overhead. I want to be
       sure that I connect to a server that I trust.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>verify-ca</></entry>
      <entry>是</entry>
      <entry><literal>取决于 CA</>-策略</entry>
      <entry>我希望我的数据加密，我接受开销。
      我想要确保我连接到的是我信任的服务器。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>verify-full</></entry>
       <entry>Yes</entry>
       <entry>Yes</entry>
       <entry>I want my data encrypted, and I accept the overhead. I want to be
        sure that I connect to a server I trust, and that it's the one I
        specify.
       </entry>
      </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>verify-full</></entry>
       <entry>是</entry>
       <entry>是</entry>
       <entry>我希望我的数据加密，我接受开销。
       我想要确保我连接到的是我信任的服务器，并且就是我指定的那一个。
       </entry>
      </row>

    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   The difference between <literal>verify-ca</> and <literal>verify-full</>
   depends on the policy of the root <acronym>CA</>. If a public
   <acronym>CA</> is used, <literal>verify-ca</> allows connections to a server
   that <emphasis>somebody else</> may have registered with the <acronym>CA</>.
   In this case, <literal>verify-full</> should always be used. If
   a local <acronym>CA</> is used, or even a self-signed certificate, using
   <literal>verify-ca</> often provides enough protection.
  </para>
____________________________________________________________________________-->
  <para>
   <literal>verify-ca</>和<literal>verify-full</>之间的区别取决于根<acronym>CA</>的策略。
   如果使用了一个公共<acronym>CA</>，<literal>verify-ca</>允许连接到那些可能已经被
   <emphasis>其他人</>注册到该<acronym>CA</>的服务器。在这种情况下，总是应该使用
   <literal>verify-full</>。如果使用了一个本地<acronym>CA</>或者甚至是一个自签名的证书，
   使用<literal>verify-ca</>通常就可以提供足够的保护。
  </para>

<!--==========================orignal english content==========================
  <para>
   The default value for <literal>sslmode</> is <literal>prefer</>. As is shown
   in the table, this makes no sense from a security point of view, and it only
   promises performance overhead if possible. It is only provided as the default
   for backward compatibility, and is not recommended in secure deployments.
  </para>
____________________________________________________________________________-->
  <para>
   <literal>sslmode</>的默认值是<literal>prefer</>。如表中所示，
   从安全角度来看这样做是没有意义的，并且它只承诺可能的性能开销。
   提供它作为默认值只是为了向后兼容，在安全部署中不建议使用。
  </para>

 </sect2>

 <sect2 id="libpq-ssl-fileusage">
<!--==========================orignal english content==========================
  <title>SSL Client File Usage</title>
____________________________________________________________________________-->
  <title>SSL 客户端文件使用</title>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="libpq-ssl-file-usage"> summarizes the files that are
   relevant to the SSL setup on the client.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="libpq-ssl-file-usage">总结了与客户端 SSL 设置相关的文件。
  </para>

  <table id="libpq-ssl-file-usage">
<!--==========================orignal english content==========================
   <title>Libpq/Client SSL File Usage</title>
____________________________________________________________________________-->
   <title>Libpq/客户端 SSL 文件用法</title>
   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>File</entry>
      <entry>Contents</entry>
      <entry>Effect</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>文件</entry>
      <entry>内容</entry>
      <entry>影响</entry>
     </row>
    </thead>

    <tbody>

<!--==========================orignal english content==========================
     <row>
      <entry><filename>~/.postgresql/postgresql.crt</></entry>
      <entry>client certificate</entry>
      <entry>requested by server</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><filename>~/.postgresql/postgresql.crt</></entry>
      <entry>客户端证书</entry>
      <entry>由服务器要求</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><filename>~/.postgresql/postgresql.key</></entry>
      <entry>client private key</entry>
      <entry>proves client certificate sent by owner; does not indicate
      certificate owner is trustworthy</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><filename>~/.postgresql/postgresql.key</></entry>
      <entry>客户端私钥</entry>
      <entry>证明由所有者发送客户端证书，并不表示证书所有者是可信的</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><filename>~/.postgresql/root.crt</></entry>
      <entry>trusted certificate authorities</entry>
      <entry>checks that server certificate is signed by a trusted certificate
      authority</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><filename>~/.postgresql/root.crt</></entry>
      <entry>受信任的证书颁发机构</entry>
      <entry>检查服务器证书是由一个可信的证书机构签发</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><filename>~/.postgresql/root.crl</></entry>
      <entry>certificates revoked by certificate authorities</entry>
      <entry>server certificate must not be on this list</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><filename>~/.postgresql/root.crl</></entry>
      <entry>被证书颁发机构撤销的证书</entry>
      <entry>服务器证书必须不在这个列表中</entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect2>

 <sect2 id="libpq-ssl-initialize">
<!--==========================orignal english content==========================
  <title>SSL Library Initialization</title>
____________________________________________________________________________-->
  <title>SSL 库初始化</title>

<!--==========================orignal english content==========================
  <para>
   If your application initializes <literal>libssl</> and/or
   <literal>libcrypto</> libraries and <application>libpq</application>
   is built with <acronym>SSL</> support, you should call
   <function>PQinitOpenSSL</> to tell <application>libpq</application>
   that the <literal>libssl</> and/or <literal>libcrypto</> libraries
   have been initialized by your application, so that
   <application>libpq</application> will not also initialize those libraries.
   <!-&minus; If this URL changes replace it with a URL to www.archive.org. -&minus;>
   See <ulink
   url="http://h71000.www7.hp.com/doc/83final/ba554_90007/ch04.html"></ulink>
   for details on the SSL API.
  </para>
____________________________________________________________________________-->
  <para>
   如果你的应用初始化<literal>libssl</>或<literal>libcrypto</>库以及
   <application>libpq</application>编译为支持<acronym>SSL</>，你应该调用
   <function>PQinitOpenSSL</>来告诉<application>libpq</application>：<literal>libssl</>
   或<literal>libcrypto</>库已经被你的应用初始化，这样<application>libpq</application>
   将不会再初始化这些库。
   <!-- If this URL changes replace it with a URL to www.archive.org. -->
   关于 SSL API 详见<ulink
   url="http://h71000.www7.hp.com/doc/83final/ba554_90007/ch04.html"></ulink>。
  </para>

<!--==========================orignal english content==========================
  <para>
   <variablelist>
    <varlistentry id="libpq-pqinitopenssl">
     <term>
      <function>PQinitOpenSSL</function>
      <indexterm>
       <primary>PQinitOpenSSL</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       Allows applications to select which security libraries to initialize.
<synopsis>
void PQinitOpenSSL(int do_ssl, int do_crypto);
</synopsis>
      </para>

      <para>
       When <parameter>do_ssl</> is non-zero, <application>libpq</application>
       will initialize the <application>OpenSSL</> library before first
       opening a database connection.  When <parameter>do_crypto</> is
       non-zero, the <literal>libcrypto</> library will be initialized.  By
       default (if <function>PQinitOpenSSL</> is not called), both libraries
       are initialized.  When SSL support is not compiled in, this function is
       present but does nothing.
      </para>

      <para>
       If your application uses and initializes either <application>OpenSSL</>
       or its underlying <literal>libcrypto</> library, you <emphasis>must</>
       call this function with zeroes for the appropriate parameter(s)
       before first opening a database connection.  Also be sure that you
       have done that initialization before opening a database connection.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqinitssl">
     <term>
      <function>PQinitSSL</function>
      <indexterm>
       <primary>PQinitSSL</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       Allows applications to select which security libraries to initialize.
<synopsis>
void PQinitSSL(int do_ssl);
</synopsis>
      </para>

      <para>
       This function is equivalent to
       <literal>PQinitOpenSSL(do_ssl, do_ssl)</>.
       It is sufficient for applications that initialize both or neither
       of <application>OpenSSL</> and <literal>libcrypto</>.
      </para>

      <para>
       <function>PQinitSSL</> has been present since
       <productname>PostgreSQL</> 8.0, while <function>PQinitOpenSSL</>
       was added in <productname>PostgreSQL</> 8.4, so <function>PQinitSSL</>
       might be preferable for applications that need to work with older
       versions of <application>libpq</application>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   <variablelist>
    <varlistentry id="libpq-pqinitopenssl">
     <term>
      <function>PQinitOpenSSL</function>
      <indexterm>
       <primary>PQinitOpenSSL</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       允许应用选择要初始化哪个安全库。
<synopsis>
void PQinitOpenSSL(int do_ssl, int do_crypto);
</synopsis>
      </para>

      <para>
       当<parameter>do_ssl</>是非零时，<application>libpq</application>
       将在第一次打开数据库连接前初始化<application>OpenSSL</>库。
       当<parameter>do_crypto</>是非零时，<literal>libcrypto</>库将被初始化。
       默认情况下（如果没有调用<function>PQinitOpenSSL</>），两个库都会被初始化。
       当 SSL 支持没有被编译时，这个函数也存在但是什么也不做。
      </para>

      <para>
       如果你的应用使用并且初始化<application>OpenSSL</>或者它的底层<literal>libcrypto</>库，
       你<emphasis>必须</>在第一次打开数据库连接前以合适的非零参数调用这个函数。
       同时要确保在打开一个数据库连接前已经完成了初始化。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqinitssl">
     <term>
      <function>PQinitSSL</function>
      <indexterm>
       <primary>PQinitSSL</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
       允许应用选择要初始化哪个安全库。
<synopsis>
void PQinitSSL(int do_ssl);
</synopsis>
      </para>

      <para>
       这个函数等效于<literal>PQinitOpenSSL(do_ssl, do_ssl)</>。
       这对于要么初始化<application>OpenSSL</>以及<literal>libcrypto</>
       要么都不初始化的应用足够用了。
      </para>

      <para>
       <function>PQinitSSL</>从<productname>PostgreSQL</> 8.0 就存在了，
       而<function>PQinitOpenSSL</>直到<productname>PostgreSQL</> 8.4 才被加入，
       因此<function>PQinitSSL</>可能对那些需要与旧版本
       <application>libpq</application>一起工作的应用来说更合适。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </sect2>

 </sect1>


 <sect1 id="libpq-threading">
<!--==========================orignal english content==========================
  <title>Behavior in Threaded Programs</title>
____________________________________________________________________________-->
  <title>在线程化程序中的行为</title>

<!--==========================orignal english content==========================
  <indexterm zone="libpq-threading">
   <primary>threads</primary>
   <secondary>with libpq</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="libpq-threading">
   <primary>threads</primary>
   <secondary>with libpq</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   <application>libpq</application> is reentrant and thread-safe by default.
   You might need to use special compiler command-line
   options when you compile your application code.  Refer to your
   system's documentation for information about how to build
   thread-enabled applications, or look in
   <filename>src/Makefile.global</filename> for <literal>PTHREAD_CFLAGS</>
   and <literal>PTHREAD_LIBS</>.  This function allows the querying of
   <application>libpq</application>'s thread-safe status:
  </para>
____________________________________________________________________________-->
  <para>
   <application>libpq</application>默认是可再入的并且是线程安全的。你可能需要使用特殊的编译器命令行选项来编译你的应用代码。参考你的系统文档来了解如何编译启用线程的应用，或者在<filename>src/Makefile.global</filename>中查找<literal>PTHREAD_CFLAGS</>和<literal>PTHREAD_LIBS</>。这个函数允许查询<application>libpq</application>的线程安全状态：
  </para>

  <variablelist>
   <varlistentry id="libpq-pqisthreadsafe">
<!--==========================orignal english content==========================
    <term>
     <function>PQisthreadsafe</function>
     <indexterm>
      <primary>PQisthreadsafe</primary>
     </indexterm>
    </term>
____________________________________________________________________________-->
    <term>
     <function>PQisthreadsafe</function>
     <indexterm>
      <primary>PQisthreadsafe</primary>
     </indexterm>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Returns the thread safety status of the
      <application>libpq</application> library.
<synopsis>
int PQisthreadsafe();
</synopsis>
     </para>
____________________________________________________________________________-->
     <para>
      返回<application>libpq</application>库的线程安全状态。
<synopsis>
int PQisthreadsafe();
</synopsis>
     </para>

<!--==========================orignal english content==========================
     <para>
      Returns 1 if the <application>libpq</application> is thread-safe
      and 0 if it is not.
     </para>
____________________________________________________________________________-->
     <para>
      如果<application>libpq</application>是线程安全的则返回 1，否则返回 0。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

<!--==========================orignal english content==========================
  <para>
   One thread restriction is that no two threads attempt to manipulate
   the same <structname>PGconn</> object at the same time. In particular,
   you cannot issue concurrent commands from different threads through
   the same connection object. (If you need to run concurrent commands,
   use multiple connections.)
  </para>
____________________________________________________________________________-->
  <para>
   一个线程限制是不允许两个线程同时尝试操纵同一个<structname>PGconn</>对象。特别是你不能从不同的线程通过同一个连接对象发出并发的命令（如果你需要运行并发命令，请使用多个连接）。
  </para>

<!--==========================orignal english content==========================
  <para>
   <structname>PGresult</> objects are normally read-only after creation,
   and so can be passed around freely between threads.  However, if you use
   any of the <structname>PGresult</>-modifying functions described in
   <xref linkend="libpq-misc"> or <xref linkend="libpq-events">, it's up
   to you to avoid concurrent operations on the same <structname>PGresult</>,
   too.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>PGresult</>对象在创建后通常是只读的，并且因此可以在线程之间自由地被传递。但是，如果你使用任何<xref linkend="libpq-misc">或<xref linkend="libpq-events">中描述的<structname>PGresult</>修改函数，你需要负责避免在同一个<structname>PGresult</>上的并发操作。
  </para>

<!--==========================orignal english content==========================
  <para>
   The deprecated functions <function>PQrequestCancel</function> and
   <function>PQoidStatus</function> are not thread-safe and should not be
   used in multithread programs.  <function>PQrequestCancel</function>
   can be replaced by <function>PQcancel</function>.
   <function>PQoidStatus</function> can be replaced by
   <function>PQoidValue</function>.
  </para>
____________________________________________________________________________-->
  <para>
   被废弃的函数<function>PQrequestCancel</function>以及<function>PQoidStatus</function>不时线程安全的并且不应当在多线程程序中使用。<function>PQrequestCancel</function>可以被替换为<function>PQcancel</function>。<function>PQoidStatus</function>可以被替换为<function>PQoidValue</function>。
  </para>

<!--==========================orignal english content==========================
  <para>
   If you are using Kerberos inside your application (in addition to inside
   <application>libpq</application>), you will need to do locking around
   Kerberos calls because Kerberos functions are not thread-safe.  See
   function <function>PQregisterThreadLock</> in the
   <application>libpq</application> source code for a way to do cooperative
   locking between <application>libpq</application> and your application.
  </para>
____________________________________________________________________________-->
  <para>
   如果你在应用中使用 Kerberos (除了在<application>libpq</application>中之外），你将需要对 Kerberos 调用加锁，因为 Kerberos 函数不是线程安全的。参考<application>libpq</application>源代码中的<function>PQregisterThreadLock</>函数，那里有在<application>libpq</application>和应用之间做合作锁定的方法。
  </para>

<!--==========================orignal english content==========================
  <para>
   If you experience problems with threaded applications, run the program
   in <filename>src/tools/thread</> to see if your platform has
   thread-unsafe functions.  This program is run by
   <filename>configure</filename>, but for binary distributions your
   library might not match the library used to build the binaries.
  </para>
____________________________________________________________________________-->
  <para>
   如果你在线程化应用中碰到问题，将该程序运行在<filename>src/tools/thread</>来查看是否你的平台有线程不安全的函数。这个程序会被<filename>configure</filename>运行，但是对于二进制发布，你的库可能不匹配用来编译二进制的库。
  </para>
 </sect1>


 <sect1 id="libpq-build">
<!--==========================orignal english content==========================
  <title>Building <application>libpq</application> Programs</title>
____________________________________________________________________________-->
  <title>编译 <application>libpq</application> 程序</title>

<!--==========================orignal english content==========================
  <indexterm zone="libpq-build">
   <primary>compiling</primary>
   <secondary>libpq applications</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="libpq-build">
   <primary>编译</primary>
   <secondary>libpq 应用</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   To build (i.e., compile and link) a program using
   <application>libpq</application> you need to do all of the following
   things:

   <itemizedlist>
    <listitem>
     <para>
      Include the <filename>libpq-fe.h</filename> header file:
<programlisting>
#include &lt;libpq-fe.h&gt;
</programlisting>
      If you failed to do that then you will normally get error messages
      from your compiler similar to:
<screen>
foo.c: In function `main':
foo.c:34: `PGconn' undeclared (first use in this function)
foo.c:35: `PGresult' undeclared (first use in this function)
foo.c:54: `CONNECTION_BAD' undeclared (first use in this function)
foo.c:68: `PGRES_COMMAND_OK' undeclared (first use in this function)
foo.c:95: `PGRES_TUPLES_OK' undeclared (first use in this function)
</screen>
     </para>
    </listitem>

    <listitem>
     <para>
      Point your compiler to the directory where the <productname>PostgreSQL</> header
      files were installed, by supplying the
      <literal>-I<replaceable>directory</replaceable></literal> option
      to your compiler.  (In some cases the compiler will look into
      the directory in question by default, so you can omit this
      option.)  For instance, your compile command line could look
      like:
<programlisting>
cc -c -I/usr/local/pgsql/include testprog.c
</programlisting>
      If you are using makefiles then add the option to the
      <varname>CPPFLAGS</varname> variable:
<programlisting>
CPPFLAGS += -I/usr/local/pgsql/include
</programlisting>
     </para>

     <para>
      If there is any chance that your program might be compiled by
      other users then you should not hardcode the directory location
      like that.  Instead, you can run the utility
      <command>pg_config</command><indexterm><primary>pg_config</><secondary
      sortas="libpq">with libpq</></> to find out where the header
      files are on the local system:
<screen>
<prompt>$</prompt> pg_config -&minus;includedir
<computeroutput>/usr/local/include</computeroutput>
</screen>
     </para>

     <para>
      If you
      have <command>pkg-config</command><indexterm><primary>pkg-config</primary><secondary sortas="libpq">with
      libpq</secondary></indexterm> installed, you can run instead:
<screen>
<prompt>$</prompt> pkg-config -&minus;cflags libpq
<computeroutput>-I/usr/local/include</computeroutput>
</screen>
      Note that this will already include the <option>-I</option> in front of
      the path.
     </para>

     <para>
      Failure to specify the correct option to the compiler will
      result in an error message such as:
<screen>
testlibpq.c:8:22: libpq-fe.h: No such file or directory
</screen>
     </para>
    </listitem>

    <listitem>
     <para>
      When linking the final program, specify the option
      <literal>-lpq</literal> so that the <application>libpq</application>
      library gets pulled in, as well as the option
      <literal>-L<replaceable>directory</replaceable></literal> to point
      the compiler to the directory where the
      <application>libpq</application> library resides.  (Again, the
      compiler will search some directories by default.)  For maximum
      portability, put the <option>-L</option> option before the
      <option>-lpq</option> option.  For example:
<programlisting>
cc -o testprog testprog1.o testprog2.o -L/usr/local/pgsql/lib -lpq
</programlisting>
     </para>

     <para>
      You can find out the library directory using
      <command>pg_config</command> as well:
<screen>
<prompt>$</prompt> pg_config -&minus;libdir
<computeroutput>/usr/local/pgsql/lib</computeroutput>
</screen>
     </para>

     <para>
      Or again use <command>pkg-config</command>:
<screen>
<prompt>$</prompt> pkg-config -&minus;libs libpq
<computeroutput>-L/usr/local/pgsql/lib -lpq</computeroutput>
</screen>
      Note again that this prints the full options, not only the path.
     </para>

     <para>
      Error messages that point to problems in this area could look like
      the following:
<screen>
testlibpq.o: In function `main':
testlibpq.o(.text+0x60): undefined reference to `PQsetdbLogin'
testlibpq.o(.text+0x71): undefined reference to `PQstatus'
testlibpq.o(.text+0xa4): undefined reference to `PQerrorMessage'
</screen>
      This means you forgot <option>-lpq</option>.
<screen>
/usr/bin/ld: cannot find -lpq
</screen>
      This means you forgot the <option>-L</option> option or did not
      specify the right directory.
     </para>
    </listitem>
   </itemizedlist>
  </para>
____________________________________________________________________________-->
  <para>
   要编译（即编译并且链接）一个使用<application>libpq</application>的程序，你需要做下列所有的事情：

   <itemizedlist>
    <listitem>
     <para>
      包括<filename>libpq-fe.h</filename>头文件：
<programlisting>
#include &lt;libpq-fe.h&gt;
</programlisting>
      如果你无法这样做，那么你通常会从你的编译器得到像这样的错误消息：
<screen>
foo.c: In function `main':
foo.c:34: `PGconn' undeclared (first use in this function)
foo.c:35: `PGresult' undeclared (first use in this function)
foo.c:54: `CONNECTION_BAD' undeclared (first use in this function)
foo.c:68: `PGRES_COMMAND_OK' undeclared (first use in this function)
foo.c:95: `PGRES_TUPLES_OK' undeclared (first use in this function)
</screen>
     </para>
    </listitem>

    <listitem>
     <para>
      通过为你的编译器提供<literal>-I<replaceable>directory</replaceable></literal>选项，向你的编译器指出<productname>PostgreSQL</>头文件安装在哪里（在某些情况下编译器默认将查看该目录，因此你可以忽略这个选项）。例如你的编译命令行可能看起来像：
<programlisting>
cc -c -I/usr/local/pgsql/include testprog.c
</programlisting>
      如果你在使用 makefile，那么把该选项加到<varname>CPPFLAGS</varname>变量中：
<programlisting>
CPPFLAGS += -I/usr/local/pgsql/include
</programlisting>
     </para>

     <para>
      如果你的程序可能由其他用户编译，那么你不应该像那样硬编码目录位置。你可以运行工具<command>pg_config</command><indexterm><primary>pg_config</><secondary
      sortas="libpq">with libpq</></>在本地系统上找出头文件在哪里：
<screen>
<prompt>$</prompt> pg_config --includedir
<computeroutput>/usr/local/include</computeroutput>
</screen>
     </para>

     <para>
      如果你安装了<command>pkg-config</command><indexterm><primary>pkg-config</primary><secondary sortas="libpq">with
      libpq</secondary></indexterm>，你可以运行：
<screen>
<prompt>$</prompt> pkg-config --cflags libpq
<computeroutput>-I/usr/local/include</computeroutput>
</screen>
      注意这将在路径前面包括<option>-I</option>。
     </para>

     <para>
      无法为编译器指定正确的选项将导致一个错误消息，例如：
<screen>
testlibpq.c:8:22: libpq-fe.h: No such file or directory
</screen>
     </para>
    </listitem>

    <listitem>
     <para>
      当链接最终的程序时，指定选项<literal>-lpq</literal>，这样<application>libpq</application>库会被编译进去，也可以用选项<literal>-L<replaceable>directory</replaceable></literal>向编译器指出<application>libpq</application>库所在的位置（再次，编译器将默认搜索某些目录）。为了最大的可移植性，将<option>-L</option>选项放在<option>-lpq</option>选项前面。例如：
<programlisting>
cc -o testprog testprog1.o testprog2.o -L/usr/local/pgsql/lib -lpq
</programlisting>
     </para>

     <para>
      你也可以使用<command>pg_config</command>找出库目录：
<screen>
<prompt>$</prompt> pg_config --libdir
<computeroutput>/usr/local/pgsql/lib</computeroutput>
</screen>
     </para>

     <para>
      或者再次使用<command>pkg-config</command>：
<screen>
<prompt>$</prompt> pkg-config --libs libpq
<computeroutput>-L/usr/local/pgsql/lib -lpq</computeroutput>
</screen>
      再次提示这会打印出全部的选项，而不仅仅是路径。
     </para>

     <para>
      指出这一部分问题的错误消息可能看起来像：
<screen>
testlibpq.o: In function `main':
testlibpq.o(.text+0x60): undefined reference to `PQsetdbLogin'
testlibpq.o(.text+0x71): undefined reference to `PQstatus'
testlibpq.o(.text+0xa4): undefined reference to `PQerrorMessage'
</screen>
      This means you forgot <option>-lpq</option>.
<screen>
/usr/bin/ld: cannot find -lpq
</screen>
      这意味着你忘记了<option>-L</option>选项或者没有指定正确的目录。
     </para>
    </listitem>
   </itemizedlist>
  </para>

 </sect1>


 <sect1 id="libpq-example">
<!--==========================orignal english content==========================
  <title>Example Programs</title>
____________________________________________________________________________-->
  <title>例子程序</title>

<!--==========================orignal english content==========================
  <para>
   These examples and others can be found in the
   directory <filename>src/test/examples</filename> in the source code
   distribution.
  </para>
____________________________________________________________________________-->
  <para>
   这些例子和其他例子可以在源代码发布的<filename>src/test/examples</filename>目录中找到。
  </para>

  <example id="libpq-example-1">
<!--==========================orignal english content==========================
   <title><application>libpq</application> Example Program 1</title>
____________________________________________________________________________-->
   <title><application>libpq</application> 例子程序 1</title>

<!--==========================orignal english content==========================
<programlisting>
<![CDATA[
/*
 * testlibpq.c
 *
 *      Test the C version of libpq, the PostgreSQL frontend library.
 */
#include <stdio.h>
#include <stdlib.h>
#include <libpq-fe.h>

static void
exit_nicely(PGconn *conn)
{
    PQfinish(conn);
    exit(1);
}

int
main(int argc, char **argv)
{
    const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    int         nFields;
    int         i,
                j;

    /*
     * If the user supplies a parameter on the command line, use it as the
     * conninfo string; otherwise default to setting dbname=postgres and using
     * environment variables or defaults for all other connection parameters.
     */
    if (argc > 1)
        conninfo = argv[1];
    else
        conninfo = "dbname = postgres";

    /* Make a connection to the database */
    conn = PQconnectdb(conninfo);

    /* Check to see that the backend connection was successfully made */
    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        exit_nicely(conn);
    }

    /*
     * Our test case here involves using a cursor, for which we must be inside
     * a transaction block.  We could do the whole thing with a single
     * PQexec() of "select * from pg_database", but that's too trivial to make
     * a good example.
     */

    /* Start a transaction block */
    res = PQexec(conn, "BEGIN");
    if (PQresultStatus(res) != PGRES_COMMAND_OK)
    {
        fprintf(stderr, "BEGIN command failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    /*
     * Should PQclear PGresult whenever it is no longer needed to avoid memory
     * leaks
     */
    PQclear(res);

    /*
     * Fetch rows from pg_database, the system catalog of databases
     */
    res = PQexec(conn, "DECLARE myportal CURSOR FOR select * from pg_database");
    if (PQresultStatus(res) != PGRES_COMMAND_OK)
    {
        fprintf(stderr, "DECLARE CURSOR failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }
    PQclear(res);

    res = PQexec(conn, "FETCH ALL in myportal");
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        fprintf(stderr, "FETCH ALL failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    /* first, print out the attribute names */
    nFields = PQnfields(res);
    for (i = 0; i < nFields; i++)
        printf("%-15s", PQfname(res, i));
    printf("\n\n");

    /* next, print out the rows */
    for (i = 0; i < PQntuples(res); i++)
    {
        for (j = 0; j < nFields; j++)
            printf("%-15s", PQgetvalue(res, i, j));
        printf("\n");
    }

    PQclear(res);

    /* close the portal ... we don't bother to check for errors ... */
    res = PQexec(conn, "CLOSE myportal");
    PQclear(res);

    /* end the transaction */
    res = PQexec(conn, "END");
    PQclear(res);

    /* close the connection to the database and cleanup */
    PQfinish(conn);

    return 0;
}
]]>
</programlisting>
____________________________________________________________________________-->
<programlisting>
<![CDATA[
/*
 * testlibpq.c
 *
 *      测试 libpq（PostgreSQL 前端库） 的 C 版本。
 */
#include <stdio.h>
#include <stdlib.h>
#include <libpq-fe.h>

static void
exit_nicely(PGconn *conn)
{
    PQfinish(conn);
    exit(1);
}

int
main(int argc, char **argv)
{
    const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    int         nFields;
    int         i,
                j;

    /*
     * 如果用户在命令行上提供了一个参数，将它用作连接信息串。
     * 否则默认用设置 dbname=postgres 并且为所有其他链接参数使用环境变量或默认值。
     */
    if (argc > 1)
        conninfo = argv[1];
    else
        conninfo = "dbname = postgres";

    /* 建立到数据库的一个连接 */
    conn = PQconnectdb(conninfo);

    /* 检查看后端连接是否成功建立 */
    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        exit_nicely(conn);
    }

    /*
     * 我们的测试案例这里涉及使用一个游标，对它我们必须用在一个事务块内。
     * 我们可以在一个单一的 "select * from pg_database" 的 PQexec() 中做整个事情，
     * 但是作为一个好的例子它太琐碎。
     */

    /* 开始一个事务块 */
    res = PQexec(conn, "BEGIN");
    if (PQresultStatus(res) != PGRES_COMMAND_OK)
    {
        fprintf(stderr, "BEGIN command failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    /*
     * 任何时候不再需要 PGresult 时，应该 PQclear 它来避免内存泄露
     */
    PQclear(res);

    /*
     * 从 pg_database 取得行，它是数据库的系统目录
     */
    res = PQexec(conn, "DECLARE myportal CURSOR FOR select * from pg_database");
    if (PQresultStatus(res) != PGRES_COMMAND_OK)
    {
        fprintf(stderr, "DECLARE CURSOR failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }
    PQclear(res);

    res = PQexec(conn, "FETCH ALL in myportal");
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        fprintf(stderr, "FETCH ALL failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    /* 首先，打印出属性名 */
    nFields = PQnfields(res);
    for (i = 0; i < nFields; i++)
        printf("%-15s", PQfname(res, i));
    printf("\n\n");

    /* 接下来，打印出行 */
    for (i = 0; i < PQntuples(res); i++)
    {
        for (j = 0; j < nFields; j++)
            printf("%-15s", PQgetvalue(res, i, j));
        printf("\n");
    }

    PQclear(res);

    /* 关闭入口，我们不需要考虑检查错误 */
    res = PQexec(conn, "CLOSE myportal");
    PQclear(res);

    /* 结束事务 */
    res = PQexec(conn, "END");
    PQclear(res);

    /* 关闭到数据库的连接并且清理 */
    PQfinish(conn);

    return 0;
}
]]>
</programlisting>
  </example>

  <example id="libpq-example-2">
<!--==========================orignal english content==========================
   <title><application>libpq</application> Example Program 2</title>
____________________________________________________________________________-->
   <title><application>libpq</application>例子程序 2</title>

<!--==========================orignal english content==========================
<programlisting>
<![CDATA[
/*
 * testlibpq2.c
 *      Test of the asynchronous notification interface
 *
 * Start this program, then from psql in another window do
 *   NOTIFY TBL2;
 * Repeat four times to get this program to exit.
 *
 * Or, if you want to get fancy, try this:
 * populate a database with the following commands
 * (provided in src/test/examples/testlibpq2.sql):
 *
 *   CREATE TABLE TBL1 (i int4);
 *
 *   CREATE TABLE TBL2 (i int4);
 *
 *   CREATE RULE r1 AS ON INSERT TO TBL1 DO
 *     (INSERT INTO TBL2 VALUES (new.i); NOTIFY TBL2);
 *
 * and do this four times:
 *
 *   INSERT INTO TBL1 VALUES (10);
 */

#ifdef WIN32
#include <windows.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/time.h>
#include <sys/types.h>
#include "libpq-fe.h"

static void
exit_nicely(PGconn *conn)
{
    PQfinish(conn);
    exit(1);
}

int
main(int argc, char **argv)
{
    const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    PGnotify   *notify;
    int         nnotifies;

    /*
     * If the user supplies a parameter on the command line, use it as the
     * conninfo string; otherwise default to setting dbname=postgres and using
     * environment variables or defaults for all other connection parameters.
     */
    if (argc > 1)
        conninfo = argv[1];
    else
        conninfo = "dbname = postgres";

    /* Make a connection to the database */
    conn = PQconnectdb(conninfo);

    /* Check to see that the backend connection was successfully made */
    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        exit_nicely(conn);
    }

    /*
     * Issue LISTEN command to enable notifications from the rule's NOTIFY.
     */
    res = PQexec(conn, "LISTEN TBL2");
    if (PQresultStatus(res) != PGRES_COMMAND_OK)
    {
        fprintf(stderr, "LISTEN command failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    /*
     * should PQclear PGresult whenever it is no longer needed to avoid memory
     * leaks
     */
    PQclear(res);

    /* Quit after four notifies are received. */
    nnotifies = 0;
    while (nnotifies < 4)
    {
        /*
         * Sleep until something happens on the connection.  We use select(2)
         * to wait for input, but you could also use poll() or similar
         * facilities.
         */
        int         sock;
        fd_set      input_mask;

        sock = PQsocket(conn);

        if (sock < 0)
            break;              /* shouldn't happen */

        FD_ZERO(&input_mask);
        FD_SET(sock, &input_mask);

        if (select(sock + 1, &input_mask, NULL, NULL, NULL) < 0)
        {
            fprintf(stderr, "select() failed: %s\n", strerror(errno));
            exit_nicely(conn);
        }

        /* Now check for input */
        PQconsumeInput(conn);
        while ((notify = PQnotifies(conn)) != NULL)
        {
            fprintf(stderr,
                    "ASYNC NOTIFY of '%s' received from backend PID %d\n",
                    notify->relname, notify->be_pid);
            PQfreemem(notify);
            nnotifies++;
        }
    }

    fprintf(stderr, "Done.\n");

    /* close the connection to the database and cleanup */
    PQfinish(conn);

    return 0;
}
]]>
</programlisting>
____________________________________________________________________________-->
<programlisting>
<![CDATA[
/*
 * testlibpq2.c
 *      测试异步通知接口
 *
 * 开始这个程序，然后在另一个窗口的 psql 中做
 *   NOTIFY TBL2;
 * 重复四次来让这个程序退出。
 *
 * 或者，如果你想要得到奇妙的事情，尝试：
 * 用下列命令填充一个数据库
 * （在 src/test/examples/testlibpq2.sql 中提供）
 *
 *   CREATE TABLE TBL1 (i int4);
 *
 *   CREATE TABLE TBL2 (i int4);
 *
 *   CREATE RULE r1 AS ON INSERT TO TBL1 DO
 *     (INSERT INTO TBL2 VALUES (new.i); NOTIFY TBL2);
 *
 * 并且把这个做四次：
 *
 *   INSERT INTO TBL1 VALUES (10);
 */
#ifdef WIN32
#include <windows.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/time.h>
#include <sys/types.h>
#include "libpq-fe.h"

static void
exit_nicely(PGconn *conn)
{
    PQfinish(conn);
    exit(1);
}

int
main(int argc, char **argv)
{
    const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    PGnotify   *notify;
    int         nnotifies;

    /*
     * 用过用户在命令行上提供了一个参数，将它用作连接信息串。
     * 否则默认用设置 dbname=postgres 并且为所有其他链接参数使用环境变量或默认值。
     */
    if (argc > 1)
        conninfo = argv[1];
    else
        conninfo = "dbname = postgres";

    /* 建立一个到数据库的连接 */
    conn = PQconnectdb(conninfo);

    /* 检查后端连接是否成功建立 */
    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        exit_nicely(conn);
    }

    /*
     * 发出 LISTEN 命令启用来自规则的 NOTIFY 的通知。
     */
    res = PQexec(conn, "LISTEN TBL2");
    if (PQresultStatus(res) != PGRES_COMMAND_OK)
    {
        fprintf(stderr, "LISTEN command failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    /*
     * 任何时候不再需要 PGresult 时，应该 PQclear 它来避免内存泄露
     */
    PQclear(res);

    /* 在接收到四个通知后退出。 */
    nnotifies = 0;
    while (nnotifies < 4)
    {
        /*
         * 休眠到在连接上发生某些事情。我们使用 select(2) 来等待输入，但是你也可以使用 poll() 或相似的设施。
         */
        int         sock;
        fd_set      input_mask;

        sock = PQsocket(conn);

        if (sock < 0)
            break;              /* 不应该发生 */

        FD_ZERO(&input_mask);
        FD_SET(sock, &input_mask);

        if (select(sock + 1, &input_mask, NULL, NULL, NULL) < 0)
        {
            fprintf(stderr, "select() failed: %s\n", strerror(errno));
            exit_nicely(conn);
        }

        /* 现在检查输入 */
        PQconsumeInput(conn);
        while ((notify = PQnotifies(conn)) != NULL)
        {
            fprintf(stderr,
                    "ASYNC NOTIFY of '%s' received from backend PID %d\n",
                    notify->relname, notify->be_pid);
            PQfreemem(notify);
            nnotifies++;
        }
    }

    fprintf(stderr, "Done.\n");

    /* 关闭到数据库的连接并且清理 */
    PQfinish(conn);

    return 0;
}
]]>
</programlisting>
  </example>

  <example id="libpq-example-3">
<!--==========================orignal english content==========================
   <title><application>libpq</application> Example Program 3</title>
____________________________________________________________________________-->
   <title><application>libpq</application>例子程序 3</title>

<!--==========================orignal english content==========================
<programlisting>
<![CDATA[
/*
 * testlibpq3.c
 *      Test out-of-line parameters and binary I/O.
 *
 * Before running this, populate a database with the following commands
 * (provided in src/test/examples/testlibpq3.sql):
 *
 * CREATE TABLE test1 (i int4, t text, b bytea);
 *
 * INSERT INTO test1 values (1, 'joe''s place', '\\000\\001\\002\\003\\004');
 * INSERT INTO test1 values (2, 'ho there', '\\004\\003\\002\\001\\000');
 *
 * The expected output is:
 *
 * tuple 0: got
 *  i = (4 bytes) 1
 *  t = (11 bytes) 'joe's place'
 *  b = (5 bytes) \000\001\002\003\004
 *
 * tuple 0: got
 *  i = (4 bytes) 2
 *  t = (8 bytes) 'ho there'
 *  b = (5 bytes) \004\003\002\001\000
 */

#ifdef WIN32
#include <windows.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <sys/types.h>
#include "libpq-fe.h"

/* for ntohl/htonl */
#include <netinet/in.h>
#include <arpa/inet.h>


static void
exit_nicely(PGconn *conn)
{
    PQfinish(conn);
    exit(1);
}

/*
 * This function prints a query result that is a binary-format fetch from
 * a table defined as in the comment above.  We split it out because the
 * main() function uses it twice.
 */
static void
show_binary_results(PGresult *res)
{
    int         i,
                j;
    int         i_fnum,
                t_fnum,
                b_fnum;

    /* Use PQfnumber to avoid assumptions about field order in result */
    i_fnum = PQfnumber(res, "i");
    t_fnum = PQfnumber(res, "t");
    b_fnum = PQfnumber(res, "b");

    for (i = 0; i < PQntuples(res); i++)
    {
        char       *iptr;
        char       *tptr;
        char       *bptr;
        int         blen;
        int         ival;

        /* Get the field values (we ignore possibility they are null!) */
        iptr = PQgetvalue(res, i, i_fnum);
        tptr = PQgetvalue(res, i, t_fnum);
        bptr = PQgetvalue(res, i, b_fnum);

        /*
         * The binary representation of INT4 is in network byte order, which
         * we'd better coerce to the local byte order.
         */
        ival = ntohl(*((uint32_t *) iptr));

        /*
         * The binary representation of TEXT is, well, text, and since libpq
         * was nice enough to append a zero byte to it, it'll work just fine
         * as a C string.
         *
         * The binary representation of BYTEA is a bunch of bytes, which could
         * include embedded nulls so we have to pay attention to field length.
         */
        blen = PQgetlength(res, i, b_fnum);

        printf("tuple %d: got\n", i);
        printf(" i = (%d bytes) %d\n",
               PQgetlength(res, i, i_fnum), ival);
        printf(" t = (%d bytes) '%s'\n",
               PQgetlength(res, i, t_fnum), tptr);
        printf(" b = (%d bytes) ", blen);
        for (j = 0; j < blen; j++)
            printf("\\%03o", bptr[j]);
        printf("\n\n");
    }
}

int
main(int argc, char **argv)
{
    const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    const char *paramValues[1];
    int         paramLengths[1];
    int         paramFormats[1];
    uint32_t    binaryIntVal;

    /*
     * If the user supplies a parameter on the command line, use it as the
     * conninfo string; otherwise default to setting dbname=postgres and using
     * environment variables or defaults for all other connection parameters.
     */
    if (argc > 1)
        conninfo = argv[1];
    else
        conninfo = "dbname = postgres";

    /* Make a connection to the database */
    conn = PQconnectdb(conninfo);

    /* Check to see that the backend connection was successfully made */
    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        exit_nicely(conn);
    }

    /*
     * The point of this program is to illustrate use of PQexecParams() with
     * out-of-line parameters, as well as binary transmission of data.
     *
     * This first example transmits the parameters as text, but receives the
     * results in binary format.  By using out-of-line parameters we can avoid
     * a lot of tedious mucking about with quoting and escaping, even though
     * the data is text.  Notice how we don't have to do anything special with
     * the quote mark in the parameter value.
     */

    /* Here is our out-of-line parameter value */
    paramValues[0] = "joe's place";

    res = PQexecParams(conn,
                       "SELECT * FROM test1 WHERE t = $1",
                       1,       /* one param */
                       NULL,    /* let the backend deduce param type */
                       paramValues,
                       NULL,    /* don't need param lengths since text */
                       NULL,    /* default to all text params */
                       1);      /* ask for binary results */

    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        fprintf(stderr, "SELECT failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    show_binary_results(res);

    PQclear(res);

    /*
     * In this second example we transmit an integer parameter in binary form,
     * and again retrieve the results in binary form.
     *
     * Although we tell PQexecParams we are letting the backend deduce
     * parameter type, we really force the decision by casting the parameter
     * symbol in the query text.  This is a good safety measure when sending
     * binary parameters.
     */

    /* Convert integer value "2" to network byte order */
    binaryIntVal = htonl((uint32_t) 2);

    /* Set up parameter arrays for PQexecParams */
    paramValues[0] = (char *) &binaryIntVal;
    paramLengths[0] = sizeof(binaryIntVal);
    paramFormats[0] = 1;        /* binary */

    res = PQexecParams(conn,
                       "SELECT * FROM test1 WHERE i = $1::int4",
                       1,       /* one param */
                       NULL,    /* let the backend deduce param type */
                       paramValues,
                       paramLengths,
                       paramFormats,
                       1);      /* ask for binary results */

    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        fprintf(stderr, "SELECT failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    show_binary_results(res);

    PQclear(res);

    /* close the connection to the database and cleanup */
    PQfinish(conn);

    return 0;
}
]]>
</programlisting>
____________________________________________________________________________-->
<programlisting>
<![CDATA[
/*
 * testlibpq3.c
 *      测试线外参数和二进制 I/O。
 *
 * 在运行之前，使用下列命令填充一个数据库（在 src/test/examples/testlibpq3.sql 中提供）
 *
 * CREATE TABLE test1 (i int4, t text, b bytea);
 *
 * INSERT INTO test1 values (1, 'joe''s place', '\\000\\001\\002\\003\\004');
 * INSERT INTO test1 values (2, 'ho there', '\\004\\003\\002\\001\\000');
 *
 * 期待的输出是：
 *
 * tuple 0: got
 *  i = (4 bytes) 1
 *  t = (11 bytes) 'joe's place'
 *  b = (5 bytes) \000\001\002\003\004
 *
 * tuple 0: got
 *  i = (4 bytes) 2
 *  t = (8 bytes) 'ho there'
 *  b = (5 bytes) \004\003\002\001\000
 */
#ifdef WIN32
#include <windows.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <sys/types.h>
#include "libpq-fe.h"

/* for ntohl/htonl */
#include <netinet/in.h>
#include <arpa/inet.h>


static void
exit_nicely(PGconn *conn)
{
    PQfinish(conn);
    exit(1);
}

/*
 * 这个函数打印一个查询结果，该结果以二进制格式从上面的注释中定义的表中取得。
 * 我们把它分离出来是因为 main() 函数需要使用它两次。
 */
static void
show_binary_results(PGresult *res)
{
    int         i,
                j;
    int         i_fnum,
                t_fnum,
                b_fnum;

    /* 使用 PQfnumber 来避免假定结果中域的顺序 */
    i_fnum = PQfnumber(res, "i");
    t_fnum = PQfnumber(res, "t");
    b_fnum = PQfnumber(res, "b");

    for (i = 0; i < PQntuples(res); i++)
    {
        char       *iptr;
        char       *tptr;
        char       *bptr;
        int         blen;
        int         ival;

        /* 得到域值（我们忽略它们为空值的可能性！） */
        iptr = PQgetvalue(res, i, i_fnum);
        tptr = PQgetvalue(res, i, t_fnum);
        bptr = PQgetvalue(res, i, b_fnum);

        /*
         * INT4 的二进制表示是按照网络字节序的，我们最好强制为本地字节序。
         */
        ival = ntohl(*((uint32_t *) iptr));

        /*
         * TEXT 的二进制表示是文本，并且因为 libpq 会为它追加一个零字节，它将工作得和 C 字符串一样好。
         *
         * BYTEA 的二进制表示是一堆字节，其中可能包含嵌入的空值，因此我们必须注意域长度。
         */
        blen = PQgetlength(res, i, b_fnum);

        printf("tuple %d: got\n", i);
        printf(" i = (%d bytes) %d\n",
               PQgetlength(res, i, i_fnum), ival);
        printf(" t = (%d bytes) '%s'\n",
               PQgetlength(res, i, t_fnum), tptr);
        printf(" b = (%d bytes) ", blen);
        for (j = 0; j < blen; j++)
            printf("\\%03o", bptr[j]);
        printf("\n\n");
    }
}

int
main(int argc, char **argv)
{
    const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    const char *paramValues[1];
    int         paramLengths[1];
    int         paramFormats[1];
    uint32_t    binaryIntVal;

    /*
     * 如果用户在命令行上提供了一个参数，将它用作连接信息串。
     * 否则默认用设置 dbname=postgres 并且为所有其他链接参数使用环境变量或默认值。
     */
    if (argc > 1)
        conninfo = argv[1];
    else
        conninfo = "dbname = postgres";

    /* 建立一个到数据库的连接 */
    conn = PQconnectdb(conninfo);

    /* 检查看后端连接是否成功被建立 */
    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        exit_nicely(conn);
    }

    /*
     * 这个程序的要点在于用线外参数展示 PQexecParams() 的使用，以及数据的二进制传输。
     *
     * 第一个例子将参数作为文本传输，但是以二进制格式接收结果。
     * 通过使用线外参数，我们能够避免使用繁杂的引用和转义，即便数据是文本。
     * 注意我们怎么才能对参数值中的引号不做任何事情。
     */

    /* 这里是我们的线外参数值 */
    paramValues[0] = "joe's place";

    res = PQexecParams(conn,
                       "SELECT * FROM test1 WHERE t = $1",
                       1,       /* 一个参数 */
                       NULL,    /* 让后端推导参数类型 */
                       paramValues,
                       NULL,    /* 因为文本不需要参数长度 */
                       NULL,    /* 对所有文本参数的默认值 */
                       1);      /* 要求二进制结果 */

    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        fprintf(stderr, "SELECT failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    show_binary_results(res);

    PQclear(res);

    /*
     * 在第二个例子中，我们以二进制形式传输一个整数参数，并且再次以二进制形式接收结果。
     *
     * 尽管我们告诉 PQexecParams 我们让后端推导参数类型，我们实际上通过在查询文本中造型参数符号来强制该决定。
     * 在发送二进制参数时，这是一种好的安全测度。
     */

    /* 将整数值 "2" 转换为网络字节序 */
    binaryIntVal = htonl((uint32_t) 2);

    /* 为 PQexecParams 设置参数数组 */
    paramValues[0] = (char *) &binaryIntVal;
    paramLengths[0] = sizeof(binaryIntVal);
    paramFormats[0] = 1;        /* binary */

    res = PQexecParams(conn,
                       "SELECT * FROM test1 WHERE i = $1::int4",
                       1,       /* 一个参数 */
                       NULL,    /* 让后端推导参数类型 */
                       paramValues,
                       paramLengths,
                       paramFormats,
                       1);      /* 要求二进制结果 */

    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        fprintf(stderr, "SELECT failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    show_binary_results(res);

    PQclear(res);

    /* 关闭到数据库的连接并清理 */
    PQfinish(conn);

    return 0;
}
]]>
</programlisting>
  </example>

 </sect1>
</chapter>
