<!-- doc/src/sgml/logicaldecoding.sgml -->
 <chapter id="logicaldecoding">
<<<<<<< HEAD
  <!--
  <title>Logical Decoding</title>
  -->
  <title>逻辑解码</title>
  <indexterm zone="logicaldecoding">
   <!--
   <primary>Logical Decoding</primary>
   -->
   <primary>逻辑解码</primary>
  </indexterm>
  <!--
<para>
   PostgreSQL provides infrastructure to stream the modifications performed
   via SQL to external consumers.  This functionality can be used to for a
   variety of purposes, including replication solutions and auditing.
  </para>
-->
<para>
PostgreSQL为SQL执行的修改流动到外部消耗者提供了基础设施。这个功能可以用于各种目的，
包括复制解决方案和审计。
</para>

  <!--
<para>
   Changes are sent out in streams identified by logical replication slots.
   Each stream outputs each change exactly once.
  </para>
-->
<para>
修改以流的形式发送，通过逻辑复制槽识别。每个流准确输出每个修改一次。
</para>

  <!--
<para>
   The format in which those changes are streamed is determined by the output
   plugin used.  An example plugin is provided in the PostgreSQL distribution.
   Additional plugins can be
   written to extend the choice of available formats without modifying any
   core code.
   Every output plugin has access to each individual new row produced
   by <command>INSERT</command> and the new row version created
   by <command>UPDATE</command>.  Availability of old row versions for
   <command>UPDATE</command> and <command>DELETE</command> depends on
   the configured replica identity (see <xref linkend="SQL-CREATETABLE-REPLICA-IDENTITY">).
  </para>
-->
<para>
这些修改的流形式是由使用的输出插件决定的。在PostgreSQL发布中提供了一个示例插件。
可以书写额外的插件扩展可用格式的选择，而不必修改任何内核代码。
每个输出插件可以访问<command>INSERT</command>产生的每个独立的新行和<command>UPDATE</command>
创建的新行版本。老的行版本的可用性对于<command>UPDATE</command>和<command>DELETE</command>来说，
取决于配置的复制身份（参阅<xref linkend="SQL-CREATETABLE-REPLICA-IDENTITY">）。
</para>

  <!--
<para>
   Changes can be consumed either using the streaming replication protocol
   (see <xref linkend="protocol-replication"> and
   <xref linkend="logicaldecoding-walsender">), or by calling functions
   via SQL (see <xref linkend="logicaldecoding-sql">). It is also possible
   to write additional methods of consuming the output of a replication slot
   without modifying core code
   (see <xref linkend="logicaldecoding-writer">).
  </para>
-->
<para>
修改可以使用流复制协议（参阅<xref linkend="protocol-replication">和
<xref linkend="logicaldecoding-walsender">），或者通过SQL调用函数
（<xref linkend="logicaldecoding-sql">）消耗。不修改内核代码，
书写额外的消耗复制槽的输出的方法也是可能的
（参阅<xref linkend="logicaldecoding-writer">）。
</para>

  <sect1 id="logicaldecoding-example">
   <!--
   <title>Logical Decoding Examples</title>
   -->
   <title>逻辑解码示例</title>

   <!--
<para>
    The following example demonstrates controlling logical decoding using the
    SQL interface.
   </para>
-->
<para>
下面的示例演示了使用SQL接口控制逻辑解码。
</para>

   <!--
<para>
    Before you can use logical decoding, you must set
    <xref linkend="guc-wal-level"> to <literal>logical</literal> and
    <xref linkend="guc-max-replication-slots"> to at least 1.  Then, you
    should connect to the target database (in the example
    below, <literal>postgres</literal>) as a superuser.
   </para>
-->
<para>
在你可以使用逻辑解码之前，必须将<xref linkend="guc-wal-level">设置为
<literal>logical</literal>，将<xref linkend="guc-max-replication-slots">
设置为至少为1。然后，以超级用户的身份连接到目标数据库
（在下面的示例中，是<literal>postgres</literal>）。
</para>

<programlisting>
postgres=# -- Create a slot named 'regression_slot' using the output plugin 'test_decoding'
=======
  <title>逻辑解码</title>
  <indexterm zone="logicaldecoding">
   <primary>逻辑解码</primary>
  </indexterm>
  <para>
   PostgreSQL 提供了方法将所执行的修改通过 SQL 以流的方式传送给外部消费者。
   这种功能可以被用于多种目的，包括复制方案以及审计。
  </para>

  <para>
   在流中被送出的更改通过逻辑复制槽标识。每个流正好把每一个更改输出一次。
  </para>

  <para>
   流式传输这些更改的格式由使用的输出插件决定。PostgreSQL 发布中包括了
   一个例子插件。可以编写额外的插件来扩展可用的格式选择，而无需修改任何
   核心代码。每一个输出插件都能访问每一个由
   <command>INSERT</command>产生的新行以及每一个由
   <command>UPDATE</command>创建的新行版本。
   <command>UPDATE</command>和<command>DELETE</command>
   的旧行版本的可用性取决于配置的复制标识（见
   <xref linkend="SQL-CREATETABLE-REPLICA-IDENTITY">）。
  </para>

  <para>
   可以通过流复制协议（见<xref linkend="protocol-replication">和
   <xref linkend="logicaldecoding-walsender">）或者通过 SQL 调用函数（
   <xref linkend="logicaldecoding-sql">）来接收流式传送的更改。也可以编写额外的
   接收复制槽输出的模块而无需修改核心代码（
   <xref linkend="logicaldecoding-writer">）。
  </para>

  <sect1 id="logicaldecoding-example">
   <title>逻辑解码的例子</title>

   <para>
    下面的例子演示了使用 SQL 接口控制逻辑解码。
   </para>

   <para>
    在你能使用逻辑解码之前，你必须设置<xref linkend="guc-wal-level">为
    <literal>logical</literal>，并且<xref linkend="guc-max-replication-slots">
    必须至少被设置为 1。然后，你应该作为一个超级用户连接到目标数据库（在下面
    的例子中是<literal>postgres</literal>）。
   </para>

<programlisting>
postgres=# -- 使用输出插件'test_decoding'创建一个名为'regression_slot'的槽
>>>>>>> upstream/master
postgres=# SELECT * FROM pg_create_logical_replication_slot('regression_slot', 'test_decoding');
    slot_name    | xlog_position
-----------------+---------------
 regression_slot | 0/16B1970
(1 row)

postgres=# SELECT * FROM pg_replication_slots;
    slot_name    |    plugin     | slot_type | datoid | database | active |  xmin  | catalog_xmin | restart_lsn
-----------------+---------------+-----------+--------+----------+--------+--------+--------------+-------------
 regression_slot | test_decoding | logical   |  12052 | postgres | f      |        |          684 | 0/16A4408
(1 row)

<<<<<<< HEAD
postgres=# -- There are no changes to see yet
=======
postgres=# -- 目前还看不到更改
>>>>>>> upstream/master
postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);
 location | xid | data
----------+-----+------
(0 rows)

postgres=# CREATE TABLE data(id serial primary key, data text);
CREATE TABLE

<<<<<<< HEAD
postgres=# -- DDL isn't replicated, so all you'll see is the transaction
=======
postgres=# -- DDL 没有被复制，因此你将看到的东西只有事务
>>>>>>> upstream/master
postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);
 location  | xid |    data
-----------+-----+------------
 0/16D5D48 | 688 | BEGIN 688
 0/16E0380 | 688 | COMMIT 688
(2 rows)

<<<<<<< HEAD
postgres=# -- Once changes are read, they're consumed and not emitted
postgres=# -- in a subsequent call:
=======
postgres=# -- 一单读到更改，它们会被消费掉并且不会在一个后续调用中被发出：
>>>>>>> upstream/master
postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);
 location | xid | data
----------+-----+------
(0 rows)

postgres=# BEGIN;
postgres=# INSERT INTO data(data) VALUES('1');
postgres=# INSERT INTO data(data) VALUES('2');
postgres=# COMMIT;

postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);
 location  | xid |                     data
-----------+-----+-----------------------------------------------
 0/16E0478 | 689 | BEGIN 689
 0/16E0478 | 689 | table public.data: INSERT: id[integer]:1 data[text]:'1'
 0/16E0580 | 689 | table public.data: INSERT: id[integer]:2 data[text]:'2'
 0/16E0650 | 689 | COMMIT 689
(4 rows)

postgres=# INSERT INTO data(data) VALUES('3');

<<<<<<< HEAD
postgres=# -- You can also peek ahead in the change stream without consuming changes
=======
postgres=# -- 你也可以不消费更改而在更改流中先看一看
>>>>>>> upstream/master
postgres=# SELECT * FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL);
 location  | xid |                     data
-----------+-----+-----------------------------------------------
 0/16E09C0 | 690 | BEGIN 690
 0/16E09C0 | 690 | table public.data: INSERT: id[integer]:3 data[text]:'3'
 0/16E0B90 | 690 | COMMIT 690
(3 rows)

<<<<<<< HEAD
postgres=# -- The next call to pg_logical_slot_peek_changes() returns the same changes again
=======
postgres=# -- 接下来对 pg_logical_slot_peek_changes() 的调用再次返回相同的更改
>>>>>>> upstream/master
postgres=# SELECT * FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL);
 location  | xid |                     data
-----------+-----+-----------------------------------------------
 0/16E09C0 | 690 | BEGIN 690
 0/16E09C0 | 690 | table public.data: INSERT: id[integer]:3 data[text]:'3'
 0/16E0B90 | 690 | COMMIT 690
(3 rows)

<<<<<<< HEAD
postgres=# -- options can be passed to output plugin, to influence the formatting
=======
postgres=# -- 可以向输出插件传递选项来影响格式化
>>>>>>> upstream/master
postgres=# SELECT * FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'include-timestamp', 'on');
 location  | xid |                     data
-----------+-----+-----------------------------------------------
 0/16E09C0 | 690 | BEGIN 690
 0/16E09C0 | 690 | table public.data: INSERT: id[integer]:3 data[text]:'3'
 0/16E0B90 | 690 | COMMIT 690 (at 2014-02-27 16:41:51.863092+01)
(3 rows)

<<<<<<< HEAD
postgres=# -- Remember to destroy a slot you no longer need to stop it consuming
postgres=# -- server resources:
=======
postgres=# -- 当不再需要一个槽后记住销毁它以停止消耗服务器资源：
>>>>>>> upstream/master
postgres=# SELECT pg_drop_replication_slot('regression_slot');
 pg_drop_replication_slot
-----------------------

(1 row)
</programlisting>

<<<<<<< HEAD
   <!--
<para>
    The following example shows how logical decoding is controlled over the
    streaming replication protocol, using the
    program <xref linkend="app-pgrecvlogical"> included in the PostgreSQL
    distribution.  This requires that client authentication is set up to allow
    replication connections
    (see <xref linkend="streaming-replication-authentication">) and
    that <varname>max_wal_senders</varname> is set sufficiently high to an
    additional connection.
   </para>
-->
<para>
下面的示例显示了流复制协议是如何控制逻辑解码的，使用PostgreSQL发布中包含的程序
<xref linkend="app-pgrecvlogical">。这要求客户端认证设置为允许复制连接
（参阅<xref linkend="streaming-replication-authentication">），
并且<varname>max_wal_senders</varname>的设置对于额外连接来说足够大。
</para>
=======
   <para>
    下面的例子展示了如何在流复制协议上使用 PostgreSQL 发布所包括的程序
    <xref linkend="app-pgrecvlogical">来控制逻辑解码。这要求设置客户端
    认证以允许复制连接（见<xref linkend="streaming-replication-authentication">），
    并且把<varname>max_wal_senders</varname>设置成足够高以允许一个
    额外的连接。
   </para>
>>>>>>> upstream/master
<programlisting>
$ pg_recvlogical -d postgres --slot test --create-slot
$ pg_recvlogical -d postgres --slot test --start -f -
<keycombo action="simul"><keycap>Control</><keycap>Z</></>
$ psql -d postgres -c "INSERT INTO data(data) VALUES('4');"
$ fg
BEGIN 693
table public.data: INSERT: id[integer]:4 data[text]:'4'
COMMIT 693
<keycombo action="simul"><keycap>Control</><keycap>C</></>
$ pg_recvlogical -d postgres --slot test --drop-slot
</programlisting>
  </sect1>

  <sect1 id="logicaldecoding-explanation">
<<<<<<< HEAD
   <!--
   <title>Logical Decoding Concepts</title>
   -->
   <title>逻辑解码的概念</title>
   <sect2>
    <!--
	<title>Logical Decoding</title>
	-->
	<title>逻辑解码</title>

    <indexterm>
     <!--
	 <primary>Logical Decoding</primary>
	 -->
	 <primary>逻辑解码</primary>
    </indexterm>

    <!--
<para>
     Logical decoding is the process of extracting all persistent changes
     to a database's tables into a coherent, easy to understand format which
     can be interpreted without detailed knowledge of the database's internal
     state.
    </para>
-->
<para>
逻辑解码是提取数据库表的所有永久修改到一个连贯的、容易理解的格式
（不需要详细的数据库内部状态知识就可以解读）的过程。
</para>

    <!--
<para>
     In <productname>PostgreSQL</productname>, logical decoding is implemented
     by decoding the contents of the <link linkend="wal">write-ahead
     log</link>, which describe changes on a storage level, into an
     application-specific form such as a stream of tuples or SQL statements.
    </para>
-->
<para>
在<productname>PostgreSQL</productname>中，逻辑解码是通过解码<link linkend="wal">预写日志</link>
的内容实现的，预写日志描述了存储级别的修改，解码成一种应用特定的格式，
比如一连串的数组或SQL状态。
</para>
   </sect2>

   <sect2>
    <!--
	<title>Replication Slots</title>
	-->
	<title>复制槽</title>

    <indexterm>
     <!--
	 <primary>replication slot</primary>
     <secondary>logical replication</secondary>
	 -->
	 <primary>复制槽</primary>
     <secondary>逻辑复制</secondary>
    </indexterm>

    <!--
<para>
     In the context of logical replication, a slot represents a stream of
     changes that can be replayed to a client in the order they were made on
     the origin server. Each slot streams a sequence of changes from a single
     database, sending each change exactly once (except when peeking forward
     in the stream).
    </para>
-->
<para>
在逻辑复制的概念中，一个槽代表一连串的修改，这些修改可以以它们在原始服务器上制作的顺序在客户端上重放。
每个槽从一个数据库中流一系列的修改，准确发送每个修改一次（除了在流中向前窥视）。
</para>

    <note>
     <!--
<para><productname>PostgreSQL</productname> also has streaming replication slots
     (see <xref linkend="streaming-replication">), but they are used somewhat
     differently there.
     </para>
-->
<para>
<productname>PostgreSQL</productname>也有流复制槽（参阅<xref linkend="streaming-replication">），
但是它们的用法稍有不同。
</para>
    </note>

    <!--
<para>
     A replication slot has an identifier that is unique across all databases
     in a <productname>PostgreSQL</productname> cluster. Slots persist
     independently of the connection using them and are crash-safe.
    </para>
-->
<para>
一个复制槽有一个在<productname>PostgreSQL</productname> cluster的所有数据库中唯一的标识符。
槽是持久的，这独立于使用它们的连接，并且是崩溃安全的。
</para>

    <!--
<para>
     Multiple independent slots may exist for a single database. Each slot has
     its own state, allowing different consumers to receive changes from
     different points in the database change stream. For most applications, a
     separate slot will be required for each consumer.
    </para>
-->
<para>
单个数据库中可能存在多个独立的槽。每个槽都有其自己的状态，
允许不同的消耗者从数据库修改流的不同的点接收更改。对于大多数应用来说，
每个消耗者都将需要一个单独的槽。
</para>

    <!--
<para>
     A logical replication slot knows nothing about the state of the
     receiver(s).  It's even possible to have multiple different receivers using
     the same slot at different times; they'll just get the changes following
     on from when the last receiver stopped consuming them. Only one receiver
     may consume changes from a slot at any given time.
    </para>
-->
<para>
逻辑复制槽不知道接收者的状态。甚至可能有多个不同的接收者在不同的时间使用同一个槽；
他们将只能得到最后一个接收者停止消耗之后的修改。在任意给定的时间，
只能有一个接收者消耗槽中的修改。
</para>

    <note>
     <!--
<para>
      Replication slots persist across crashes and know nothing about the state
      of their consumer(s). They will prevent removal of required resources
      even when there is no connection using them. This consumes storage
      because neither required WAL nor required rows from the system catalogs
      can be removed by <command>VACUUM</command> as long as they are required by a replication
      slot.  So if a slot is no longer required it should be dropped.
     </para>
-->
<para>
复制槽在崩溃之后仍然存在，并且不知道它们的消耗者的状态。它们将阻止删除需要的资源，
即使没有连接使用它们了也是一样的。这会消耗存储，因为只要复制槽需要，
<command>VACUUM</command>就不能从系统目录中删除不再需要的WAL或者行。
所以，如果不再需要一个槽了，就应该删除它。
</para>
=======
   <title>逻辑解码概念</title>
   <sect2>
    <title>逻辑解码</title>

    <indexterm>
     <primary>逻辑解码</primary>
    </indexterm>

    <para>
     逻辑解码是一种将对数据库表的所有持久更改抽取到一种清晰、易于理解的格式
     的处理，这种技术允许在不了解数据库内部状态的详细知识的前提下解释该格式。
    </para>

    <para>
     在<productname>PostgreSQL</productname>中，逻辑解码通过解码
     <link linkend="wal">预写式日志</link>的内容来实现，预写式日志描述了存储
     层面上的更改，而逻辑解码则会把更改解码成一种应用相关的形式，例如一个元组
     流或者 SQL 语句流。
    </para>
   </sect2>

   <sect2>
    <title>复制槽</title>

    <indexterm>
     <primary>复制槽</primary>
     <secondary>逻辑复制</secondary>
    </indexterm>

    <para>
     在逻辑复制的环境下，一个槽表示一个更改流，这些更改可以在客户机上以它们
     在原服务器上产生的顺序被重播。每一个流从一个单一数据库中流式传送更改序
     列，每一个更改只发送一次（除非在流中向前预览）。
    </para>

    <note>
     <para><productname>PostgreSQL</productname>也有流复制槽（
     见<xref linkend="streaming-replication">），但是它们的使用有所不同。
     </para>
    </note>

    <para>
     一个复制槽在一个<productname>PostgreSQL</productname>集簇的所
     有数据库之间具有一个唯一的标识符。槽在使用它们的连接之间保持独立并且
     对于崩溃是安全的。
    </para>

    <para>
     对于同一个数据库可能会存在多个独立的槽。每一个槽有自己的状态，允许不
     同的消费者从该数据库的更改流中的不同点开始接收更改。对于大多数应用，
     每一个消费者都将要求一个单独的槽。
    </para>

    <para>
     逻辑复制槽完全不知道接收者的状态。甚至可能会有多个不同的接收者在不同
     时间使用同一个槽，它们将只是从上一个接收者停止消费更改的地方开始得到
     更改。但在任一给定时刻，只有一个接收者可以从一个槽中消费更改。
    </para>

    <note>
     <para>
      复制槽可以在崩溃时保持，并且不知道其消费者的状态。即便没有连接使用它们，
      它们也将阻止移除所需的资源。这会消耗存储，因为只要还有一个复制槽需要，
      WAL 和来自于系统目录的行就不能被<command>VACUUM</command>移除。
      因此如果不再需要一个槽，那就应该删除它。
     </para>
>>>>>>> upstream/master
    </note>
   </sect2>

   <sect2>
<<<<<<< HEAD
    <!--
	<title>Output Plugins</title>
	-->
	<title>输出插件</title>
    <!--
<para>
     Output plugins transform the data from the write-ahead log's internal
     representation into the format the consumer of a replication slot desires.
    </para>
-->
<para>
输出插件将数据从预写式日志的内部表示转换到复制槽想要的消耗者的格式。
</para>
   </sect2>

   <sect2>
    <!--
	<title>Exported Snapshots</title>
	-->
	<title>导出的快照</title>
    <!--
<para>
     When a new replication slot is created using the streaming replication interface,
     a snapshot is exported
     (see <xref linkend="functions-snapshot-synchronization">), which will show
     exactly the state of the database after which all changes will be
     included in the change stream. This can be used to create a new replica by
     using <link linkend="sql-set-transaction"><literal>SET TRANSACTION
     SNAPSHOT</literal></link> to read the state of the database at the moment
     the slot was created. This transaction can then be used to dump the
     database's state at that point in time, which afterwards can be updated
     using the slot's contents without losing any changes.
    </para>
-->
<para>
当用流复制接口创建了一个新的复制槽时，导出一个快照（参阅<xref linkend="functions-snapshot-synchronization">），
该快照将准确的显示数据库的状态，之后所有的修改都将包含在修改流中。这可以用来创建一个新的复制品，
可以通过使用<link linkend="sql-set-transaction"><literal>SET TRANSACTION SNAPSHOT</literal></link>
读取槽创建瞬间数据库的状态。这个事务稍后可以用来转储在那个时间点的数据库状态，
之后可以使用槽的内容更新该数据库而不丢失任何修改。
</para>
=======
    <title>输出插件</title>
    <para>
     输出插件将数据从预写式日志的内部表示转换成复制槽的消费者所需的格式。
    </para>
   </sect2>

   <sect2>
    <title>导出快照</title>
    <para>
     当使用流复制接口创建一个新的复制槽时，一个快照将被导出（见
     <xref linkend="functions-snapshot-synchronization">），在它所显示的
     数据库状态之后所有的更改都将被包括在更改流中。通过使用
     <link linkend="sql-set-transaction"><literal>SET TRANSACTION
     SNAPSHOT</literal></link>读取槽被创建时的数据库状态，这可以用来创建
     一个新的复制。然后这个事务可以被用来及时转储那一点的数据库状态，它后来
     可以被槽的内容更新而不丢失任何更改。
    </para>
>>>>>>> upstream/master
   </sect2>
  </sect1>

  <sect1 id="logicaldecoding-walsender">
<<<<<<< HEAD
   <!--
   <title>Streaming Replication Protocol Interface</title>
   -->
   <title>流复制协议接口</title>

   
<para>
    <!--
	The commands
	-->
	命令
=======
   <title>流复制协议接口</title>

   <para>
    命令
>>>>>>> upstream/master
    <itemizedlist>
     <listitem>
      <para><literal>CREATE_REPLICATION_SLOT <replaceable>slot_name</replaceable> LOGICAL <replaceable>options</replaceable></literal></para>
     </listitem>

     <listitem>
<<<<<<< HEAD
<para><literal>DROP_REPLICATION_SLOT <replaceable>slot_name</replaceable></literal></para>
     </listitem>

     <listitem>
<para><literal>START_REPLICATION SLOT <replaceable>slot_name</replaceable> LOGICAL <replaceable>options</replaceable></literal></para>
     </listitem>
    </itemizedlist>
<!-- 
    are used to create, drop, and stream changes from a replication
    slot, respectively. These commands are only available over a replication
    connection; they cannot be used via SQL.
    See <xref linkend="protocol-replication"> for details on these commands.
-->
分别用于从复制槽创建、删除和流修改。这些命令仅在复制连接上可用；
它们不能通过SQL使用。参阅<xref linkend="protocol-replication">获取关于这些命令的详细信息。
   </para>

   <!--
<para>
    The command <xref linkend="app-pgrecvlogical"> can be used to control
    logical decoding over a streaming replication connection.  (It uses
    these commands internally.)
   </para>
-->
<para>
命令<xref linkend="app-pgrecvlogical">可以用来在流复制连接上控制逻辑解码。
（内部的使用这些命令。）
</para>
  </sect1>

  <sect1 id="logicaldecoding-sql">
   <!--
   <title>Logical Decoding <acronym>SQL</acronym> Interface</title>
   -->
   <title>逻辑解码<acronym>SQL</acronym>接口</title>

   <!--
<para>
     See <xref linkend="functions-replication"> for detailed documentation on
     the SQL-level API for interacting with logical decoding.
   </para>
-->
<para>
参阅<xref linkend="functions-replication">获取SQL级别API与逻辑解码互动的详细文档。
</para>

   <!--
<para>
    Synchronous replication (see <xref linkend="synchronous-replication">) is
    only supported on replication slots used over the streaming replication interface. The
    function interface and additional, non-core interfaces do not support
    synchronous replication.
   </para>
-->
<para>
同步复制（参阅<xref linkend="synchronous-replication">）只支持使用流复制接口的复制槽。
函数接口和额外的、非核心接口不支持同步复制。
</para>
  </sect1>

  <sect1 id="logicaldecoding-catalogs">
   <!-- 
   <title>System Catalogs Related to Logical Decoding</title>
   -->
   <title>与逻辑解码相关的系统目录</title>

   <!--
<para>
    The <link linkend="catalog-pg-replication-slots"><structname>pg_replication_slots</structname></link>
    view and the
    <link linkend="monitoring-stats-views-table"><structname>pg_stat_replication</structname></link>
    view provide information about the current state of replication slots and
    streaming replication connections respectively. These views apply to both physical and
    logical replication.
   </para>
-->
<para>
<link linkend="catalog-pg-replication-slots"><structname>pg_replication_slots</structname></link>视图和
<link linkend="monitoring-stats-views-table"><structname>pg_stat_replication</structname></link>
视图分别提供关于复制槽的当前状态和流复制连接的信息。这些视图适用于物理和逻辑复制。
</para>
  </sect1>

  <sect1 id="logicaldecoding-output-plugin">
   <!--
   <title>Logical Decoding Output Plugins</title>
   -->
   <title>逻辑解码输出插件</title>
<!--   
<para>
    An example output plugin can be found in the
    <link linkend="test-decoding">
     <filename>contrib/test_decoding</filename>
    </link>
    subdirectory of the PostgreSQL source tree.
   </para>
-->
<para>
一个示例输出插件可以在PostgreSQL源码树的
<link linkend="test-decoding">
     <filename>contrib/test_decoding</filename>
</link>
子目录中找到。
</para>
   <sect2 id="logicaldecoding-output-init">
    <!--
	<title>Initialization Function</title>
	-->
	<title>初始化函数</title>
    <indexterm zone="logicaldecoding">
     <primary>_PG_output_plugin_init</primary>
    </indexterm>

<para>
<!-- 
     An output plugin is loaded by dynamically loading a shared library with
     the output plugin's name as the library base name. The normal library
     search path is used to locate the library. To provide the required output
     plugin callbacks and to indicate that the library is actually an output
     plugin it needs to provide a function named
     <function>_PG_output_plugin_init</function>. This function is passed a
     struct that needs to be filled with the callback function pointers for
     individual actions. 
-->
输出插件是通过使用输出插件的名字作为库基本名字动态加载共享库加载的。
使用普通库搜索路径定位该库。为了提供需要的输出插件回调函数，和表明该库就是它需要的输出插件，
提供一个名为<function>_PG_output_plugin_init</function>的函数。
这个函数传递一个需要用回调函数指针填充的结构，以单独动作。
=======
      <para><literal>DROP_REPLICATION_SLOT <replaceable>slot_name</replaceable></literal></para>
     </listitem>

     <listitem>
      <para><literal>START_REPLICATION SLOT <replaceable>slot_name</replaceable> LOGICAL <replaceable>options</replaceable></literal></para>
     </listitem>
    </itemizedlist>
    被用来创建、删除以及流式传送一个复制槽。这些命令只能在一个复制连接上使用。
    它们不同通过 SQL 使用。这些命令的详情请见
    <xref linkend="protocol-replication">。
   </para>

   <para>
    命令<xref linkend="app-pgrecvlogical">可以被用来控制一个流复制连接上的逻辑
    解码（它在内部使用上述命令）。
   </para>
  </sect1>

  <sect1 id="logicaldecoding-sql">
   <title>逻辑解码的 <acronym>SQL</acronym> 接口</title>

   <para>
     与逻辑解码互动的 SQL 层 API 详见<xref linkend="functions-replication">。
   </para>

   <para>
    同步复制（见<xref linkend="synchronous-replication">）只在使用流复制接口的复制槽上
    支持。函数接口以及额外的、非核心的接口不支持同步复制。
   </para>
  </sect1>

  <sect1 id="logicaldecoding-catalogs">
   <title>与逻辑解码相关的系统目录</title>

   <para>
    <link linkend="catalog-pg-replication-slots"><structname>pg_replication_slots</structname></link>
    视图和
    <link linkend="monitoring-stats-views-table"><structname>pg_stat_replication</structname></link>
    视图分别提供了有关复制槽和流复制连接的当前状态的信息。这些视图适用于物理和逻辑复制。
   </para>
  </sect1>

  <sect1 id="logicaldecoding-output-plugin">
   <title>逻辑解码输出插件</title>
   <para>
    可以在 PostgreSQL 源码树的
    <link linkend="test-decoding">
     <filename>contrib/test_decoding</filename>
    </link>子目录中找到一个输出插件的例子。
   </para>
   <sect2 id="logicaldecoding-output-init">
    <title>初始化函数</title>
    <indexterm zone="logicaldecoding">
     <primary>_PG_output_plugin_init</primary>
    </indexterm>
    <para>
     一个输出插件是通过动态载入一个以输出插件名称作为基础名称的共享库来载入的。
     将使用普通的库搜索路径来定位该库。为了提供所要求的输出插件回调并且指示该
     库确实是一个输出插件，需要提供一个名为
     <function>_PG_output_plugin_init</function>的函数。这个函数会被传入一个
     结构，其中被填充了各个动作的回调函数指针。
>>>>>>> upstream/master
<programlisting>
typedef struct OutputPluginCallbacks
{
    LogicalDecodeStartupCB startup_cb;
    LogicalDecodeBeginCB begin_cb;
    LogicalDecodeChangeCB change_cb;
    LogicalDecodeCommitCB commit_cb;
    LogicalDecodeShutdownCB shutdown_cb;
} OutputPluginCallbacks;

typedef void (*LogicalOutputPluginInit)(struct OutputPluginCallbacks *cb);
</programlisting>
<<<<<<< HEAD
<!-- 
     The <function>begin_cb</function>, <function>change_cb</function>
     and <function>commit_cb</function> callbacks are required,
     while <function>startup_cb</function>
     and <function>shutdown_cb</function> are optional.
-->
<function>begin_cb</function>、<function>change_cb</function>和
<function>commit_cb</function> 回调函数是必需的，<function>startup_cb</function>
和<function>shutdown_cb</function>是可选的。
=======
     回调函数<function>begin_cb</function>、<function>change_cb</function>
     以及<function>commit_cb</function>是必需的，而
     <function>startup_cb</function>和<function>shutdown_cb</function>是可选的。
>>>>>>> upstream/master
    </para>
   </sect2>

   <sect2 id="logicaldecoding-capabilities">
<<<<<<< HEAD
    <!--
	<title>Capabilities</title>
	-->
	<title>功能</title>
   
<para>
<!--
     To decode, format and output changes, output plugins can use most of the
     backend's normal infrastructure, including calling output functions. Read
     only access to relations is permitted as long as only relations are
     accessed that either have been created by <command>initdb</command> in
     the <literal>pg_catalog</literal> schema, or have been marked as user
     provided catalog tables using
-->
要解码、格式化和输出修改，输出插件可以使用大多数的后端普通框架，包括调用输出函数。
只要只是访问<command>initdb</command>在<literal>pg_catalog</literal>模式中创建的关系，
或是使用下列代码标记为用户提供的目录表，那么只读访问关系就是允许的。
=======
    <title>能力</title>

    <para>
     要解码、格式化并且输出更改，输出插件可以使用大部分后端的标准功能，包括调用
     输出函数。只要访问的关系是<command>initdb</command>在
     <literal>pg_catalog</literal>模式中创建的或者被使用
>>>>>>> upstream/master
<programlisting>
ALTER TABLE user_catalog_table SET (user_catalog_table = true);
CREATE TABLE another_catalog_table(data text) WITH (user_catalog_table = true);
</programlisting>
<<<<<<< HEAD
<!-- 
     Any actions leading to transaction ID assignment are prohibited. That, among others,
     includes writing to tables, performing DDL changes, and
     calling <literal>txid_current()</literal>.
-->
任何导致事务ID分配的动作都是禁止的。其中包括写入表、执行DDL修改和调用<literal>txid_current()</literal>。
=======
     标记为用户提供的系统表，就允许对关系的只读访问。任何导致事务 ID 分配的动作
     都被禁止。其中包括写表、执行 DDL 更改以及调用<literal>txid_current()</literal>。
>>>>>>> upstream/master
    </para>
   </sect2>

   <sect2 id="logicaldecoding-output-mode">
<<<<<<< HEAD
    <!--
	<title>Output Modes</title>
	-->
	<title>输出模式</title>

    <!--
<para>
     Output plugin callbacks can pass data to the consumer in nearly arbitrary
     formats. For some use cases, like viewing the changes via SQL, returning
     data in a data type that can contain arbitrary data (e.g., <type>bytea</type>) is
     cumbersome. If the output plugin only outputs textual data in the
     server's encoding, it can declare that by
     setting <literal>OutputPluginOptions.output_mode</>
     to <literal>OUTPUT_PLUGIN_TEXTUAL_OUTPUT</> instead
     of <literal>OUTPUT_PLUGIN_BINARY_OUTPUT</> in
     the <link linkend="logicaldecoding-output-plugin-startup">startup
     callback</>. In that case, all the data has to be in the server's encoding
     so that a <type>text</> datum can contain it. This is checked in assertion-enabled
     builds.
    </para>
-->
<para>
输出插件回调可以以最近任意的格式传递数据给消耗者。对于一些使用情况，像通过SQL查看修改，
以一种可以包含任意数据的数据类型（比如<type>bytea</type>）返回数据是麻烦的。
如果输出插件只以服务器的编码输出文本数据，可以在通过在
<link linkend="logicaldecoding-output-plugin-startup">启动回调</>中设置
<literal>OutputPluginOptions.output_mode</>为<literal>OUTPUT_PLUGIN_TEXTUAL_OUTPUT</>
而不是<literal>OUTPUT_PLUGIN_BINARY_OUTPUT</>来声明。在这种情况下，
所有数据必须是服务器的编码，所以一个<type>text</>数据就可以包含它。
这是以启用断言的编译检查的。
</para>
   </sect2>

   <sect2 id="logicaldecoding-output-plugin-callbacks">
    <!--
	<title>Output Plugin Callbacks</title>
	-->
	<title>输出插件回调</title>

    <!--
<para>
     An output plugin gets notified about changes that are happening via
     various callbacks it needs to provide.
    </para>
-->
<para>
输出插件获取关于它需要提供的各种回调中发生的修改的通知。
</para>

    <!--
<para>
     Concurrent transactions are decoded in commit order, and only changes
     belonging to a specific transaction are decoded between
     the <literal>begin</literal> and <literal>commit</literal>
     callbacks. Transactions that were rolled back explicitly or implicitly
     never get
     decoded. Successful savepoints are
     folded into the transaction containing them in the order they were
     executed within that transaction.
    </para>
-->
<para>
并发事务以提交的顺序解码，只有属于指定事务的修改在<literal>begin</literal>
和<literal>commit</literal>之间解码。显式或隐式回滚的事务用不解码。
成功的保存点折叠到包含它们的事务中，以它们在该事务中执行的顺序。
</para>

    <note>
     <!--
<para>
      Only transactions that have already safely been flushed to disk will be
      decoded. That can lead to a <command>COMMIT</command> not immediately being decoded in a
      directly following <literal>pg_logical_slot_get_changes()</literal>
      when <varname>synchronous_commit</varname> is set
      to <literal>off</literal>.
     </para>
-->
<para>
只有已经安全冲刷到磁盘的事务将被解码。这会导致在<varname>synchronous_commit</varname>
设置为<literal>off</literal>时，直接跟着<literal>pg_logical_slot_get_changes()</literal>
的<command>COMMIT</command>不会立即解码。
</para>
    </note>

    <sect3 id="logicaldecoding-output-plugin-startup">
     <!--
	 <title>Startup Callback</title>
	 -->
	 <title>启动回调</title>
<para>
<!-- 
      The optional <function>startup_cb</function> callback is called whenever
      a replication slot is created or asked to stream changes, independent
      of the number of changes that are ready to be put out.
-->
可选的<function>startup_cb</function>回调在创建复制槽和请求流修改时调用，
独立于准备推出的修改的数量。
=======
    <title>输出模式</title>

    <para>
     输出插件回调可以以近乎任意格式向消费者传递数据。对于某些用例，例如通过 SQL 
     查看更改，以可能包含任何数据的数据类型（例如<type>bytea</type>）返回数据
     可能会很麻烦。如果输出插件只输出服务器编码的文本数据，它可以在
     <link linkend="logicaldecoding-output-plugin-startup">启动回调</>中通过设
     置为<literal>OUTPUT_PLUGIN_TEXTUAL_OUTPUT</>替代
     <literal>OUTPUT_PLUGIN_BINARY_OUTPUT</>来声明这一点。在这种情况下，
     所有的数据必须是属于服务器的编码，这样一个<type>text</>数据就能包含它。在
     启用了断言的编译中会检查这一点。
    </para>
   </sect2>

   <sect2 id="logicaldecoding-output-plugin-callbacks">
    <title>输出插件回调</title>

    <para>
     一个输出插件需要提供一些回调，它通过它们得到有关更改发生的通知。
    </para>

    <para>
     并发事务以提交顺序被解码，并且只有属于特定事务的更改会在
     <literal>begin</literal>和<literal>commit</literal>回调之间被解码。被显式
     或隐式回滚的事务不会被解码。成功的检查点被折叠到包含它们的事务中，并且
     保持它们在该事务中被执行的顺序。
    </para>

    <note>
     <para>
      只有已经被安全地刷入磁盘的事务将会被解码。当
      <varname>synchronous_commit</varname>被设置为<literal>off</literal>
      时，这会导致一个<command>COMMIT</command>在随后的
      <literal>pg_logical_slot_get_changes()</literal>中不会立即被解码。
     </para>
    </note>

    <sect3 id="logicaldecoding-output-plugin-startup">
     <title>启动回调</title>
     <para>
      只要一个复制槽被创建或者被要求流式传送更改，可选的
      <function>startup_cb</function>回调就会被调用，不管有多少更改准备输出。
>>>>>>> upstream/master
<programlisting>
typedef void (*LogicalDecodeStartupCB) (
    struct LogicalDecodingContext *ctx,
    OutputPluginOptions *options,
    bool is_init
);
</programlisting>
<<<<<<< HEAD
<!-- 
      The <literal>is_init</literal> parameter will be true when the
      replication slot is being created and false
      otherwise. <parameter>options</parameter> points to a struct of options
      that output plugins can set:
-->
<literal>is_init</literal>参数在创建复制槽时为真，其他时候为假。
<parameter>options</parameter>指向一个选项结构，输出插件可以设置为：
=======
      当复制槽被创建时，<literal>is_init</literal>参数将为真，否则为假。
      <parameter>options</parameter>指向一个输出插件可以设置的选项
      的结构：
>>>>>>> upstream/master
<programlisting>
typedef struct OutputPluginOptions
{
    OutputPluginOutputType output_type;
} OutputPluginOptions;
</programlisting>
<<<<<<< HEAD
<!-- 
      <literal>output_type</literal> has to either be set to
      <literal>OUTPUT_PLUGIN_TEXTUAL_OUTPUT</literal>
      or <literal>OUTPUT_PLUGIN_BINARY_OUTPUT</literal>. See also
      <xref linkend="logicaldecoding-output-mode">. 
-->
<literal>output_type</literal>必须设置为<literal>OUTPUT_PLUGIN_TEXTUAL_OUTPUT</literal>
或<literal>OUTPUT_PLUGIN_BINARY_OUTPUT</literal>。又见<xref linkend="logicaldecoding-output-mode">。
     </para>

     <!--
<para>
      The startup callback should validate the options present in
      <literal>ctx-&gt;output_plugin_options</literal>. If the output plugin
      needs to have a state, it can
      use <literal>ctx-&gt;output_plugin_private</literal> to store it.
     </para>
-->
<para>
启动回调应该验证<literal>ctx-&gt;output_plugin_options</literal>中的选项。
如果输出插件需要有一个状态，它可以使用<literal>ctx-&gt;output_plugin_private</literal>存储它。
</para>
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-shutdown">
     <!--
	 <title>Shutdown Callback</title>
	 -->
	 <title>关闭回调</title>

     <!--
<para>
      The optional <function>shutdown_cb</function> callback is called
      whenever a formerly active replication slot is not used anymore and can
      be used to deallocate resources private to the output plugin. The slot
      isn't necessarily being dropped, streaming is just being stopped.
=======
      <literal>output_type</literal>必须被设置为
      <literal>OUTPUT_PLUGIN_TEXTUAL_OUTPUT</literal>
      或者<literal>OUTPUT_PLUGIN_BINARY_OUTPUT</literal>。另见
      <xref linkend="logicaldecoding-output-mode">.
     </para>

     <para>
      启动回调应该验证出现在
      <literal>ctx-&gt;output_plugin_options</literal>中的选项。如果输出插件
      需要有一个状态，它可以使用
      <literal>ctx-&gt;output_plugin_private</literal>来存储之。
     </para>
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-shutdown">
     <title>关闭回调</title>

     <para>
      只要一个之前活跃的复制槽不再使用，就会调用可选的
      <function>shutdown_cb</function>回调，它可以被用来释放输出插件
      私有的资源。该槽并不一定需要被删除，只要其中的流被停止即可。
>>>>>>> upstream/master
<programlisting>
typedef void (*LogicalDecodeShutdownCB) (
    struct LogicalDecodingContext *ctx
);
</programlisting>
     </para>
<<<<<<< HEAD
-->
<para>
当前一个活动的复制槽不再使用，并且可以用来释放输出插件私有的资源时，
调用可选的<function>shutdown_cb</function>回调。没有必要删除该槽，只是停止了流。
<programlisting>
typedef void (*LogicalDecodeShutdownCB) (
    struct LogicalDecodingContext *ctx
);
</programlisting>
</para>
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-begin">
     <!--
	 <title>Transaction Begin Callback</title>
	 -->
	 <title>事务开始回调</title>

     <!--
<para>
      The required <function>begin_cb</function> callback is called whenever a
      start of a committed transaction has been decoded. Aborted transactions
      and their contents never get decoded.
=======
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-begin">
     <title>事务开始回调</title>

     <para>
      只要一个已提交事务的开始动作被解码，就会调用必须提供的
      <function>begin_cb</function>回调。被中止的事务及其内容不会被解码。
>>>>>>> upstream/master
<programlisting>
typedef void (*LogicalDecodeBeginCB) (
    struct LogicalDecodingContext *,
    ReorderBufferTXN *txn
);
</programlisting>
<<<<<<< HEAD
      The <parameter>txn</parameter> parameter contains meta information about
      the transaction, like the time stamp at which it has been committed and
      its XID.
     </para>
-->
<para>
在已提交事务开始被解码时，调用需要的<function>begin_cb</function>回调。
中止的事务和它们的内容永远得不到解码。
<programlisting>
typedef void (*LogicalDecodeBeginCB) (
    struct LogicalDecodingContext *,
    ReorderBufferTXN *txn
);
</programlisting>
<parameter>txn</parameter>参数包含关于该事务的元信息，比如它提交的时间戳和它的XID。
</para>
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-commit">
     <!-- 
	 <title>Transaction End Callback</title>
	 -->
	 <title>事务结束回调</title>

     <!--
<para>
      The required <function>commit_cb</function> callback is called whenever
      a transaction commit has been
      decoded. The <function>change_cb</function> callbacks for all modified
      rows will have been called before this, if there have been any modified
      rows.
=======
      <parameter>txn</parameter>参数包含有关该事务的元信息，例如该
      事务被提交的时间戳以及该事务的 XID。
     </para>
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-commit">
     <title>事务结束回调</title>

     <para>
      只要一个已提交事务的提交动作被解码，就会调用必须提供的
      <function>commit_cb</function>回调。在此之前，如果有任何被修改
      的行，将为所有被修改的行调用<function>change_cb</function>回调。
>>>>>>> upstream/master
<programlisting>
typedef void (*LogicalDecodeCommitCB) (
    struct LogicalDecodingContext *,
    ReorderBufferTXN *txn
);
</programlisting>
     </para>
<<<<<<< HEAD
-->
<para>
当事务提交被解码时，调用需要的<function>commit_cb</function>回调。
如果已经有任何已经修改了的行，那么用于所有已修改行的<function>change_cb</function>
回调将在此之前调用。
<programlisting>
typedef void (*LogicalDecodeCommitCB) (
    struct LogicalDecodingContext *,
    ReorderBufferTXN *txn
);
</programlisting>
</para>
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-change">
     <!--
	 <title>Change Callback</title>
	 -->
	 <title>修改回调</title>
     
<para>
<!--
      The required <function>change_cb</function> callback is called for every
      individual row modification inside a transaction, may it be
      an <command>INSERT</command>, <command>UPDATE</command>,
      or <command>DELETE</command>. Even if the original command modified
      several rows at once the callback will be called individually for each
      row.
-->
为事务内部每个单独行的修改调用需要的<function>change_cb</function>回调，
它可能是一个<command>INSERT</command>、<command>UPDATE</command>
或<command>DELETE</command>。即使原始命令一次修改了几行，该回调也将为每一行单独调用。
=======
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-change">
     <title>更改回调</title>

     <para>
      对于一个事务中的每一个行修改，都将调用必须提供的
      <function>change_cb</function>回调，这种修改可能是一个
      <command>INSERT</command>、<command>UPDATE</command>或者
      <command>DELETE</command>。即使原始命令一次修改了多行，该回调也会
      为其中的每一行调用一次。
>>>>>>> upstream/master
<programlisting>
typedef void (*LogicalDecodeChangeCB) (
    struct LogicalDecodingContext *ctx,
    ReorderBufferTXN *txn,
    Relation relation,
    ReorderBufferChange *change
);
</programlisting>
<<<<<<< HEAD
<!-- 
      The <parameter>ctx</parameter> and <parameter>txn</parameter> parameters
      have the same contents as for the <function>begin_cb</function>
      and <function>commit_cb</function> callbacks, but additionally the
      relation descriptor <parameter>relation</parameter> points to the
      relation the row belongs to and a struct
      <parameter>change</parameter> describing the row modification are passed
      in. 
-->
<parameter>ctx</parameter>和<parameter>txn</parameter>参数与<function>begin_cb</function>
和<function>commit_cb</function>回调的内容相同，但是加上了关系描述符
<parameter>relation</parameter>指向该行的所属关系和一个结构<parameter>change</parameter>
描述传递进来的行修改。
     </para>

     <note>
      <!--
<para>
       Only changes in user defined tables that are not unlogged
       (see <xref linkend="SQL-CREATETABLE-UNLOGGED">) and not temporary
       (see <xref linkend="SQL-CREATETABLE-TEMPORARY">) can be extracted using
       logical decoding.
      </para>
-->
<para>
只用用户定义表中的修改是非日志的（参阅<xref linkend="SQL-CREATETABLE-UNLOGGED">），
并且不是临时（参阅<xref linkend="SQL-CREATETABLE-TEMPORARY">）可以使用逻辑解码提取的。
</para>
=======
      <parameter>ctx</parameter>和<parameter>txn</parameter>参数与
      <function>begin_cb</function>和<function>commit_cb</function>
      回调具有相同的内容，但是额外多出一个关系描述符
      <parameter>relation</parameter>指向该行所属的关系以及一个结构
      <parameter>change</parameter>描述被传入的行修改。
     </para>

     <note>
      <para>
       只有没有被标记为“不做日志”（见
       <xref linkend="SQL-CREATETABLE-UNLOGGED">）并且非临时（见
       <xref linkend="SQL-CREATETABLE-TEMPORARY">）的用户定义表中的
       更改才能用逻辑解码抽取。
      </para>
>>>>>>> upstream/master
     </note>
    </sect3>
   </sect2>

   <sect2 id="logicaldecoding-output-plugin-output">
<<<<<<< HEAD
    <!--
	<title>Functions for Producing Output</title>
	-->
	<title>产生输出的函数</title>

    <!--
<para>
     To actually produce output, output plugins can write data to
     the <literal>StringInfo</literal> output buffer
     in <literal>ctx-&gt;out</literal> when inside
     the <function>begin_cb</function>, <function>commit_cb</function>,
     or <function>change_cb</function> callbacks. Before writing to the output
     buffer, <function>OutputPluginPrepareWrite(ctx, last_write)</function> has
     to be called, and after finishing writing to the
     buffer, <function>OutputPluginWrite(ctx, last_write)</function> has to be
     called to perform the write. The <parameter>last_write</parameter>
     indicates whether a particular write was the callback's last write.
    </para>
-->
<para>
要实际产生输出，输出插件在<function>begin_cb</function>、<function>commit_cb</function>
或<function>change_cb</function>回调内部时，可以在<literal>ctx-&gt;out</literal>
中写数据到<literal>StringInfo</literal>输出缓冲区中。在写入输出缓冲区之前，
必须先调用<function>OutputPluginPrepareWrite(ctx, last_write)</function>，
然后完成到缓冲区的写入，必须调用<function>OutputPluginWrite(ctx, last_write)</function>
执行该写入。<parameter>last_write</parameter>指示一个特殊的写入是否是该回调的最后写入。
</para>

    <!--
<para>
     The following example shows how to output data to the consumer of an
     output plugin:
=======
    <title>用于产生输出的函数</title>

    <para>
     在<function>begin_cb</function>、<function>commit_cb</function>或者
      <function>change_cb</function>回调中，为了实际产生输出，
      输出插件可以把数据写入到<literal>ctx-&gt;out</literal>中的
      <literal>StringInfo</literal>输出缓冲区中。在写出到输出缓冲区之前，必须先
      调用<function>OutputPluginPrepareWrite(ctx, last_write)</function>，在完
      成写入到缓冲区后，必须调用
      <function>OutputPluginWrite(ctx, last_write)</function>来执行写出。
      <parameter>last_write</parameter>指出一次特定的写出是否为该回调的最后
      一次写出。
    </para>

    <para>
     下面的例子展示了如何把数据输出给一个输出插件的消费者：
>>>>>>> upstream/master
<programlisting>
OutputPluginPrepareWrite(ctx, true);
appendStringInfo(ctx->out, "BEGIN %u", txn->xid);
OutputPluginWrite(ctx, true);
</programlisting>
    </para>
<<<<<<< HEAD
-->
<para>
下面的示例显示了如何输出数据到输出插件的消耗者：
<programlisting>
OutputPluginPrepareWrite(ctx, true);
appendStringInfo(ctx->out, "BEGIN %u", txn->xid);
OutputPluginWrite(ctx, true);
</programlisting>
</para>
=======
>>>>>>> upstream/master
   </sect2>
  </sect1>

  <sect1 id="logicaldecoding-writer">
<<<<<<< HEAD
   <!--
   <title>Logical Decoding Output Writers</title>
   -->
   <title>逻辑解码输出写入程序</title>

   <!--
<para>
    It is possible to add more output methods for logical decoding.
    For details, see
    <filename>src/backend/replication/logical/logicalfuncs.c</filename>.
    Essentially, three functions need to be provided: one to read WAL, one to
    prepare writing output, and one to write the output
    (see <xref linkend="logicaldecoding-output-plugin-output">).
   </para>
-->
<para>
为逻辑解码添加更多的输出方法是可能的。详细信息请参阅
<filename>src/backend/replication/logical/logicalfuncs.c</filename>。
基本上，需要提供三个函数：一个读取WAL、一个预备写输出、一个写输出
(参阅<xref linkend="logicaldecoding-output-plugin-output">)。
</para>
  </sect1>

  <sect1 id="logicaldecoding-synchronous">
   <!--
   <title>Synchronous Replication Support for Logical Decoding</title>
   -->
   <title>同步复制支持逻辑解码</title>

   <!--
<para>
    Logical decoding can be used to to build
    <link linkend="synchronous-replication">synchronous
    replication</link> solutions with the same user interface as synchronous
    replication for <link linkend="streaming-replication">streaming
    replication</link>.  To do this, the streaming replication interface
    (see <xref linkend="logicaldecoding-walsender">) must be used to stream out
    data. Clients have to send <literal>Standby status update (F)</literal>
    (see <xref linkend="protocol-replication">) messages, just like streaming
    replication clients do.
   </para>
-->
<para>
逻辑解码可以用来建立<link linkend="synchronous-replication">同步复制</link>解决方案，
使用相同的用户接口作为对<link linkend="streaming-replication">流复制</link>
的同步复制。要做到这一点，流复制接口（参阅<xref linkend="logicaldecoding-walsender">）
必须用来流出数据。客户端必须发送<literal>Standby status update (F)</literal>
(参阅<xref linkend="protocol-replication">)消息，就像流复制客户端那样。
</para>

   <note>
    <!--
<para>
     A synchronous replica receiving changes via logical decoding will work in
     the scope of a single database. Since, in contrast to
     that, <parameter>synchronous_standby_names</parameter> currently is
     server wide, this means this technique will not work properly if more
     than one database is actively used.
     </para>
-->
<para>
通过逻辑解码接收修改的同步复制将在单数据库的范围内工作。因为，与之比较，
<parameter>synchronous_standby_names</parameter>目前是服务器范围的，
这意味着如果使用了多个数据库，那么这个技术将不会正确的工作。
</para>
=======
   <title>逻辑解码输出写入器</title>

   <para>
    可以为逻辑解码增加更多输出方法。详情可见
    <filename>src/backend/replication/logical/logicalfuncs.c</filename>。
    本质上，需要提供三个函数：一个读取 WAL，一个准备写输出，另一个写输出（
    见<xref linkend="logicaldecoding-output-plugin-output">）。
   </para>
  </sect1>

  <sect1 id="logicaldecoding-synchronous">
   <title>逻辑解码的同步复制支持</title>

   <para>
    逻辑解码可以被用来构建
    <link linkend="synchronous-replication">同步复制</link>方案，该方案
    具有和<link linkend="streaming-replication">流复制</link>的同步复制
    相同的用户接口。要这样做，流复制接口（见
    <xref linkend="logicaldecoding-walsender">）必须被用来流式传出数据。
    正如流复制客户端所作的一样，逻辑解码的客户端必须发出
    <literal>后备机状态更新 (F)</literal>
    （见<xref linkend="protocol-replication">）消息。
   </para>

   <note>
    <para>
     一个通过逻辑解码接收更改的同步复制机将工作在一个单一数据库的范围内。
     因为与之相反，<parameter>synchronous_standby_names</parameter>
     当前是服务器范围的，这意味着如果有多于一个数据库被活跃地使用，这种技术将
     无法正常工作。
     </para>
>>>>>>> upstream/master
   </note>
  </sect1>
 </chapter>
