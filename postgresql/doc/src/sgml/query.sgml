<!-- doc/src/sgml/query.sgml -->

 <chapter id="tutorial-sql">
  <title><acronym>SQL</acronym>语言</title>

  <sect1 id="tutorial-sql-intro">
   <title>引言</title>

   <para>
    本章提供一个如何使用<acronym>SQL</acronym>执行简单操作的概述。本教程的目的只是给你一个介绍，并非完整的<acronym>SQL</acronym>教程。有许多关于<acronym>SQL</acronym>的书籍，包括<xref linkend="MELT93">和<xref linkend="DATE97">。你还要知道有些<productname>PostgreSQL</productname>语言特性是对标准的扩展。
   </para>

   <para>
    在随后的例子里，我们假设你已经创建了名为<literal>mydb</literal>的数据库，就象在前面的章里面介绍的一样，并且已经能够启动<application>psql</application>。
   </para>

   <para>
    本手册的例子也可以在<productname>PostgreSQL</productname>源代码的目录<filename>src/tutorial/</filename>中找到（二进制<productname>PostgreSQL</productname>发布中可能没有编译这些文件）。要使用这些文件，首先进入该目录然后运行<application>make</>：

<screen>
<prompt>$</prompt> <userinput>cd <replaceable>....</replaceable>/src/tutorial</userinput>
<prompt>$</prompt> <userinput>make</userinput>
</screen>

    这样就创建了那些脚本并编译了包含用户定义函数和类型的 C 文件。接下来，要开始本教程，按照下面说的做：

<screen>
<prompt>$</prompt> <userinput>cd <replaceable>....</replaceable>/tutorial</userinput>
<prompt>$</prompt> <userinput>psql -s mydb</userinput>
<computeroutput>
...
</computeroutput>

<prompt>mydb=&gt;</prompt> <userinput>\i basics.sql</userinput>
</screen>

    <literal>\i</literal>命令从指定的文件中读取命令。<command>psql</command>的<literal>-s</>选项把你置于单步模式，它在向服务器发送每个语句之前暂停。 在本节使用的命令都在文件<filename>basics.sql</filename>中。
   </para>
  </sect1>


  <sect1 id="tutorial-concepts">
   <title>概念</title>

   <para>
    <indexterm><primary>关系数据库</primary></indexterm>
    <indexterm><primary>层次数据库</primary></indexterm>
    <indexterm><primary>面向对象数据库</primary></indexterm>
    <indexterm><primary>关系</primary></indexterm>
    <indexterm><primary>表</primary></indexterm>

    <productname>PostgreSQL</productname>是一种<firstterm>关系型数据库管理系统</firstterm> （<acronym>RDBMS</acronym>）。这意味着它是一种用于管理存储在<firstterm>关系</firstterm>中的数据的系统。关系实际上是<firstterm>表</firstterm>的数学术语。 今天，把数据存储在表里的概念已经快成了固有的常识了， 但是还有其它的一些方法用于组织数据库。在类 Unix 操作系统上的文件和目录就形成了一种层次数据库的例子。 更现代的发展是面向对象数据库。
   </para>

   <para>
    <indexterm><primary>行</primary></indexterm>
    <indexterm><primary>列</primary></indexterm>

    每个表都是一个命名的<firstterm>行</firstterm>集合。一个给定表的每一行由同一组的命名<firstterm>列</firstterm>组成，而且每一列都有一个特定的数据类型。虽然列在每行里的顺序是固定的， 但一定要记住 SQL 并不对行在表中的顺序做任何保证（但你可以为了显示的目的对它们进行显式地排序）。
   </para>

   <para>
    <indexterm><primary>数据库集簇</primary></indexterm>
    <indexterm><primary>集簇</primary><secondary>数据库</secondary><see>数据库集簇</see></indexterm>

    表被分组成数据库，一个由单个<productname>PostgreSQL</productname>服务器实例管理的数据库集合组成一个数据库<firstterm>集簇</firstterm>。
   </para>
  </sect1>


  <sect1 id="tutorial-table">
   <title>创建一个新表</title>

   <indexterm zone="tutorial-table">
    <primary>CREATE TABLE</primary>
   </indexterm>

   <para>
    你可以通过指定表的名字和所有列的名字及其类型来创建表∶

<programlisting>
CREATE TABLE weather (
    city            varchar(80),
    temp_lo         int,           -- 最低温度
    temp_hi         int,           -- 最高温度
    prcp            real,          -- 湿度
    date            date
);
</programlisting>

    你可以在<command>psql</command>输入这些命令以及换行符。<command>psql</command>可以识别该命令直到分号才结束。
   </para>

   <para>
    你可以在 SQL 命令中自由使用空白（即空格、制表符和换行符）。 这就意味着你可以用和上面不同的对齐方式键入命令，或者将命令全部放在一行中。两个划线（<quote><literal>--</literal></quote>）引入注释。 任何跟在它后面直到行尾的东西都会被忽略。SQL 是对关键字和标识符大小写不敏感的语言，只有在标识符用双引号包围时才能保留它们的大小写（上例没有这么做）。
   </para>

   <para>
    <type>varchar(80)</type>指定了一个可以存储最长 80 个字符的任意字符串的数据类型。<type>int</type>是普通的整数类型。<type>real</type>是一种用于存储单精度浮点数的类型。<type>date</type>类型应该可以自解释（没错，类型为<type>date</type>的列名字也是<structfield>date</structfield>。 这么做可能比较方便或者容易让人混淆 &mdash; 你自己选择）。
   </para>

   <para>
    <productname>PostgreSQL</productname>支持标准的<acronym>SQL</acronym>类型<type>int</type>、<type>smallint</type>、<type>real</type>、<type>double precision</type>、<type>char(<replaceable>N</>)</type>、<type>varchar(<replaceable>N</>)</type>、<type>date</type>、<type>time</type>、<type>timestamp</type>和<type>interval</type>，还支持其他的通用功能的类型和丰富的几何类型。<productname>PostgreSQL</productname>中可以定制任意数量的用户定义数据类型。因而类型名并不是语法关键字，除了<acronym>SQL</acronym>标准要求支持的特例外。
   </para>

   <para>
    第二个例子将保存城市和它们相关的地理位置：
<programlisting>
CREATE TABLE cities (
    name            varchar(80),
    location        point
);
</programlisting>
    类型<type>point</type>就是一种<productname>PostgreSQL</productname>特有数据类型的例子。
   </para>

   <para>
    <indexterm>
     <primary>DROP TABLE</primary>
    </indexterm>

    最后，我们还要提到如果你不再需要某个表，或者你想以不同的形式重建它，那么你可以用下面的命令删除它：
<synopsis>
DROP TABLE <replaceable>tablename</replaceable>;
</synopsis>
   </para>
  </sect1>


  <sect1 id="tutorial-populate">
   <title>在表中增加行</title>

   <indexterm zone="tutorial-populate">
    <primary>INSERT</primary>
   </indexterm>

   <para>
    <command>INSERT</command>语句用于向表中添加行：

<programlisting>
INSERT INTO weather VALUES ('San Francisco', 46, 50, 0.25, '1994-11-27');
</programlisting>

    请注意所有数据类型都使用了相当明了的输入格式。那些不是简单数字值的常量通常必需用单引号（<literal>'</>）包围，就象在例子里一样。<type>date</type>类型实际上对可接收的格式相当灵活，不过在本教程里，我们应该坚持使用这种清晰的格式。
   </para>

   <para>
    <type>point</type>类型要求一个座标对作为输入，如下：
<programlisting>
INSERT INTO cities VALUES ('San Francisco', '(-194.0, 53.0)');
</programlisting>
   </para>

   <para>
    到目前为止使用的语法要求你记住列的顺序。一个可选的语法允许你明确地列出列：
<programlisting>
INSERT INTO weather (city, temp_lo, temp_hi, prcp, date)
    VALUES ('San Francisco', 43, 57, 0.0, '1994-11-29');
</programlisting>
    如果你需要，你可以用另外一个顺序列出列或者是忽略某些列， 比如说，我们不知道降水量：
<programlisting>
INSERT INTO weather (date, city, temp_hi, temp_lo)
    VALUES ('1994-11-29', 'Hayward', 54, 37);
</programlisting>
    许多开发人员认为明确列出列要比依赖隐含的顺序是更好的风格。
   </para>

   <para>
    请输入上面显示的所有命令，这样你在随后的各节中才有可用的数据。
   </para>

   <para>
    <indexterm>
     <primary>COPY</primary>
    </indexterm>

    你还可以使用<command>COPY</command>从文本文件中装载大量数据。这种方式通常更快，因为<command>COPY</command>命令就是为这类应用优化的， 只是比 <command>INSERT</command>少一些灵活性。比如：

<programlisting>
COPY weather FROM '/home/user/weather.txt';
</programlisting>

    这里源文件的文件名必须在运行后端进程的机器上是可用的， 而不是在客户端上，因为后端进程将直接读取该文件。你可以在<xref linkend="sql-copy">中读到更多有关<command>COPY</command>命令的信息。
   </para>
  </sect1>


  <sect1 id="tutorial-select">
   <title>查询一个表</title>

   <para>
    <indexterm><primary>查询</primary></indexterm>
    <indexterm><primary>SELECT</primary></indexterm>

    要从一个表中检索数据就是<firstterm>查询</firstterm>这个表。<acronym>SQL</acronym>的<command>SELECT</command>语句就是做这个用途的。 该语句分为选择列表（列出要返回的列）、表列表（列出从中检索数据的表）以及可选的条件（指定任意的限制）。比如，要检索表<structname>weather</structname>的所有行，键入：
<programlisting>
SELECT * FROM weather;
</programlisting>
    这里<literal>*</literal>是<quote>所有列</quote>的缩写。
     <footnote>
      <para>
       虽然<literal>SELECT *</literal>对于即席查询很有用，但我们普遍认为在生产代码中这是很糟糕的风格，因为给表增加一个列就改变了结果。
      </para>
     </footnote>
    因此相同的结果应该这样获得：
<programlisting>
SELECT city, temp_lo, temp_hi, prcp, date FROM weather;
</programlisting>

    而输出应该是：

<screen>
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
 San Francisco |      43 |      57 |    0 | 1994-11-29
 Hayward       |      37 |      54 |      | 1994-11-29
(3 rows)
</screen>
   </para>

   <para>
    你可以在选择列表中写任意表达式，而不仅仅是列的列表。比如，你可以：
<programlisting>
SELECT city, (temp_hi+temp_lo)/2 AS temp_avg, date FROM weather;
</programlisting>
    这样应该得到：
<screen>
     city      | temp_avg |    date
---------------+----------+------------
 San Francisco |       48 | 1994-11-27
 San Francisco |       50 | 1994-11-29
 Hayward       |       45 | 1994-11-29
(3 rows)
</screen>
    请注意这里的<literal>AS</literal>子句是如何给输出列重新命名的（<literal>AS</literal>子句是可选的）。
   </para>

   <para>
    一个查询可以使用<literal>WHERE</>子句<quote>修饰</>，它指定需要哪些行。<literal>WHERE</>子句包含一个布尔（真值）表达式，只有那些使布尔表达式为真的行才会被返回。在条件中可以使用常用的布尔操作符（<literal>AND</literal>、<literal>OR</literal>和<literal>NOT</literal>）。 比如，下面的查询检索旧金山的下雨天的天气：

<programlisting>
SELECT * FROM weather
    WHERE city = 'San Francisco' AND prcp &gt; 0.0;
</programlisting>
    结果：
<screen>
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
(1 row)
</screen>
   </para>

   <para>
    <indexterm><primary>ORDER BY</primary></indexterm>

    你可以要求返回的查询结果是排好序的：

<programlisting>
SELECT * FROM weather
    ORDER BY city;
</programlisting>

<screen>
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 Hayward       |      37 |      54 |      | 1994-11-29
 San Francisco |      43 |      57 |    0 | 1994-11-29
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
</screen>

    在这个例子里，排序的顺序并未完全被指定，因此你可能看到属于旧金山的行被随机地排序。但是如果你使用下面的语句，那么就总是会得到上面的结果：

<programlisting>
SELECT * FROM weather
    ORDER BY city, temp_lo;
</programlisting>
   </para>

   <para>
    <indexterm><primary>DISTINCT</primary></indexterm>
    <indexterm><primary>重复</primary></indexterm>

    你可以要求在查询的结果中消除重复的行：

<programlisting>
SELECT DISTINCT city
    FROM weather;
</programlisting>

<screen>
     city
---------------
 Hayward
 San Francisco
(2 rows)
</screen>

    再次声明，结果行的顺序可能变化。你可以组合使用<literal>DISTINCT</literal>和<literal>ORDER BY</literal>来保证获取一致的结果：
     <footnote>
      <para>
       在一些数据库系统里，包括老版本的<productname>PostgreSQL</productname>，<literal>DISTINCT</literal>的实现自动对行进行排序，因此<literal>ORDER BY</literal>是多余的。但是这一点并不是 SQL 标准的要求，并且目前的<productname>PostgreSQL</productname>并不保证<literal>DISTINCT</literal>会导致行被排序。
      </para>
     </footnote>

<programlisting>
SELECT DISTINCT city
    FROM weather
    ORDER BY city;
</programlisting>
   </para>
  </sect1>


  <sect1 id="tutorial-join">
   <title>在表之间连接</title>

   <indexterm zone="tutorial-join">
    <primary>连接</primary>
   </indexterm>

   <para>
    到目前为止，我们的查询一次只访问一个表。查询可以一次访问多个表，或者用这种方式访问一个表而同时处理该表的多个行。 一个同时访问同一个或者不同表的多个行的查询叫<firstterm>连接</firstterm>查询。举例来说，比如你想列出所有天气记录以及相关的城市位置。要实现这个目标，我们需要拿 <structname>weather</>表每行的<structfield>city</>列和<structname>cities</>表所有行的<structfield>name</>列进行比较， 并选取那些在该值上相匹配的行对。
    <note>
     <para>
      这里只是一个概念上的模型。连接通常以比实际比较每个可能的行对更高效的方式执行， 但这些是用户看不到的。
     </para>
    </note>
    这个任务可以用下面的查询来实现：

<programlisting>
SELECT *
    FROM weather, cities
    WHERE city = name;
</programlisting>

<screen>
     city      | temp_lo | temp_hi | prcp |    date    |     name      | location
---------------+---------+---------+------+------------+---------------+-----------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)
 San Francisco |      43 |      57 |    0 | 1994-11-29 | San Francisco | (-194,53)
(2 rows)
</screen>

   </para>

   <para>
    观察结果集的两个方面：
    <itemizedlist>
     <listitem>
      <para>
       没有城市Hayward的结果行。这是因为在<structname>cities</structname>表里面没有Hayward的匹配行，所以连接忽略 <structname>weather</>表里的不匹配行。我们稍后将看到如何修补它。
      </para>
     </listitem>

     <listitem>
      <para>
       有两个列包含城市名字。这是正确的， 因为<structname>weather</structname>和<structname>cities</structname>表的列被串接在一起。不过，实际上我们不想要这些， 因此你将可能希望明确列出输出列而不是使用<literal>*</literal>：
<programlisting>
SELECT city, temp_lo, temp_hi, prcp, date, location
    FROM weather, cities
    WHERE city = name;
</programlisting>
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <formalpara>
    <title>练习：</title>

    <para>
     看看这个查询省略<literal>WHERE</literal>子句的语义是什么
    </para>
   </formalpara>

   <para>
    因为这些列的名字都不一样，所以规划器自动地找出它们属于哪个表。如果在两个表里有重名的列，你需要<firstterm>限定</>列名来说明你究竟想要哪一个，如：

<programlisting>
SELECT weather.city, weather.temp_lo, weather.temp_hi,
       weather.prcp, weather.date, cities.location
    FROM weather, cities
    WHERE cities.name = weather.city;
</programlisting>

    人们广泛认为在一个连接查询中限定所有列名是一种好的风格，这样即使未来向其中一个表里添加重名列也不会导致查询失败。
   </para>

   <para>
    到目前为止，这种类型的连接查询也可以用下面这样的形式写出来：

<programlisting>
SELECT *
    FROM weather INNER JOIN cities ON (weather.city = cities.name);
</programlisting>

    这个语法并不象上文的那个那么常用，我们在这里写出来是为了让你更容易了解后面的主题。
   </para>

   <para>
    <indexterm><primary>连接</primary><secondary>外</secondary></indexterm>

    现在我们将看看如何能把Hayward记录找回来。我们想让查询干的事是扫描<structname>weather</structname>表， 并且对每一行都找出匹配的<structname>cities</structname>表行。如果我们没有找到匹配的行，那么我们需要一些<quote>空值</quote>代替cities表的列。 这种类型的查询叫<firstterm>外连接</firstterm> （我们在此之前看到的连接都是内连接）。这样的命令看起来象这样：

<programlisting>
SELECT *
    FROM weather LEFT OUTER JOIN cities ON (weather.city = cities.name);

     city      | temp_lo | temp_hi | prcp |    date    |     name      | location
---------------+---------+---------+------+------------+---------------+-----------
 Hayward       |      37 |      54 |      | 1994-11-29 |               |
 San Francisco |      46 |      50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)
 San Francisco |      43 |      57 |    0 | 1994-11-29 | San Francisco | (-194,53)
(3 rows)
</programlisting>

    这个查询是一个<firstterm>左外连接</firstterm>， 因为在连接操作符左部的表中的行在输出中至少要出现一次， 而在右部的表的行只有在能找到匹配的左部表行是才被输出。 如果输出的左部表的行没有对应匹配的右部表的行，那么右部表行的列将填充空值（null）。
   </para>

   <formalpara>
    <title>练习：</title>

    <para>
      还有右外连接和全外连接。试着找出来它们能干什么。
    </para>
   </formalpara>

   <para>
    <indexterm><primary>join</primary><secondary>self</secondary></indexterm>
    <indexterm><primary>alias</primary><secondary>for table name in query</secondary></indexterm>

    我们也可以把一个表和自己连接起来。这叫做<firstterm>自连接</firstterm>。 比如，假设我们想找出那些在其它天气记录的温度范围之外的天气记录。这样我们就需要拿 <structname>weather</structname>表里每行的<structfield>temp_lo</>和<structfield>temp_hi</>列与<structname>weather</structname>表里其它行的<structfield>temp_lo</>和<structfield>temp_hi</>列进行比较。我们可以用下面的查询实现这个目标：

<programlisting>
SELECT W1.city, W1.temp_lo AS low, W1.temp_hi AS high,
    W2.city, W2.temp_lo AS low, W2.temp_hi AS high
    FROM weather W1, weather W2
    WHERE W1.temp_lo &lt; W2.temp_lo
    AND W1.temp_hi &gt; W2.temp_hi;

     city      | low | high |     city      | low | high
---------------+-----+------+---------------+-----+------
 San Francisco |  43 |   57 | San Francisco |  46 |   50
 Hayward       |  37 |   54 | San Francisco |  46 |   50
(2 rows)
</programlisting>

    在这里我们把weather表重新标记为<literal>W1</>和<literal>W2</>以区分连接的左部和右部。你还可以用这样的别名在其它查询里节约一些敲键，比如：
<programlisting>
SELECT *
    FROM weather w, cities c
    WHERE w.city = c.name;
</programlisting>
    你以后会经常碰到这样的缩写的。
   </para>
  </sect1>


  <sect1 id="tutorial-agg">
   <title>聚集函数</title>

   <indexterm zone="tutorial-agg">
    <primary>聚集函数</primary>
   </indexterm>

   <para>
    和大多数其它关系数据库产品一样，<productname>PostgreSQL</productname>支持<firstterm>聚集函数</>。 一个聚集函数从多个输入行中计算出一个结果。 比如，我们有在一个行集合上计算<function>count</function>（计数）、<function>sum</function>（和）、<function>avg</function>（均值）、<function>max</function>（最大值）和<function>min</function>（最小值）的函数。
   </para>

   <para>
    比如，我们可以用下面的语句找出所有记录中最低温度中的最高温度：

<programlisting>
SELECT max(temp_lo) FROM weather;
</programlisting>

<screen>
 max
-----
  46
(1 row)
</screen>
   </para>

   <para>
    <indexterm><primary>子查询</primary></indexterm>

    如果我们想知道该读数发生在哪个城市，我们可以用：

<programlisting>
SELECT city FROM weather WHERE temp_lo = max(temp_lo);     <lineannotation>错误</lineannotation>
</programlisting>

    不过这个方法不能运转，因为聚集<function>max</function>不能被用于<literal>WHERE</literal>子句中（存在这个限制是因为<literal>WHERE</literal>子句决定哪些行可以被聚集计算包括；因此显然它必需在聚集函数之前被计算）。 不过，我们通常都可以用其它方法实现我们的目的；这里我们就可以使用<firstterm>子查询</firstterm>：

<programlisting>
SELECT city FROM weather
    WHERE temp_lo = (SELECT max(temp_lo) FROM weather);
</programlisting>

<screen>
     city
---------------
 San Francisco
(1 row)
</screen>

    这样做是 OK 的，因为子查询是一次独立的计算，它独立于外层的查询计算出自己的聚集。
   </para>

   <para>
    <indexterm><primary>GROUP BY</primary></indexterm>
    <indexterm><primary>HAVING</primary></indexterm>

    聚集同样也常用于和<literal>GROUP BY</literal>子句组合。比如，我们可以获取每个城市观测到的最低温度的最高值：

<programlisting>
SELECT city, max(temp_lo)
    FROM weather
    GROUP BY city;
</programlisting>

<screen>
     city      | max
---------------+-----
 Hayward       |  37
 San Francisco |  46
(2 rows)
</screen>

    这样给我们每个城市一个输出。每个聚集结果都是在匹配该城市的表行上面计算的。我们可以用<literal>HAVING</literal> 过滤这些被分组的行：

<programlisting>
SELECT city, max(temp_lo)
    FROM weather
    GROUP BY city
    HAVING max(temp_lo) &lt; 40;
</programlisting>

<screen>
  city   | max
---------+-----
 Hayward |  37
(1 row)
</screen>

    这样就只给出那些所有<structfield>temp_lo</>值曾都低于 40的城市。最后，如果我们只关心那些名字以<quote><literal>S</literal></quote>开头的城市，我们可以用：

<programlisting>
SELECT city, max(temp_lo)
    FROM weather
    WHERE city LIKE 'S%'<co id="co.tutorial-agg-like">
    GROUP BY city
    HAVING max(temp_lo) &lt; 40;
</programlisting>
   <calloutlist>
    <callout arearefs="co.tutorial-agg-like">
     <para>
      <literal>LIKE</literal>操作符进行模式匹配，在<xref linkend="functions-matching">里有解释。
     </para>
    </callout>
   </calloutlist>
   </para>

   <para>
    理解聚集和<acronym>SQL</acronym>的<literal>WHERE</literal>以及<literal>HAVING</literal>子句之间的关系对我们非常重要。<literal>WHERE</literal>和<literal>HAVING</literal>的基本区别如下：<literal>WHERE</literal>在分组和聚集计算之前选取输入行（因此，它控制哪些行进入聚集计算）， 而<literal>HAVING</literal>在分组和聚集之后选取分组行。因此，<literal>WHERE</literal>子句不能包含聚集函数； 因为试图用聚集函数判断哪些行应输入给聚集运算是没有意义的。相反，<literal>HAVING</literal>子句总是包含聚集函数（严格说来，你可以写不使用聚集的<literal>HAVING</literal>子句， 但这样做很少有用。同样的条件用在<literal>WHERE</literal>阶段会更有效）。
   </para>

   <para>
    在前面的例子里，我们可以在<literal>WHERE</literal>里应用城市名称限制，因为它不需要聚集。这样比放在<literal>HAVING</literal>里更加高效，因为可以避免那些未通过 <literal>WHERE</literal>检查的行参与到分组和聚集计算中。
   </para>
  </sect1>


  <sect1 id="tutorial-update">
   <title>更新</title>

   <indexterm zone="tutorial-update">
    <primary>UPDATE</primary>
   </indexterm>

   <para>
    你可以用<command>UPDATE</command>命令更新现有的行。假设你发现所有 11 月 28 日以后的温度读数都低了两度，那么你就可以用下面的方式改正数据：

<programlisting>
UPDATE weather
    SET temp_hi = temp_hi - 2,  temp_lo = temp_lo - 2
    WHERE date &gt; '1994-11-28';
</programlisting>
   </para>

   <para>
    看看数据的新状态：
<programlisting>
SELECT * FROM weather;

     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
 San Francisco |      41 |      55 |    0 | 1994-11-29
 Hayward       |      35 |      52 |      | 1994-11-29
(3 rows)
</programlisting>
   </para>
  </sect1>

  <sect1 id="tutorial-delete">
   <title>删除</title>

   <indexterm zone="tutorial-delete">
    <primary>DELETE</primary>
   </indexterm>

   <para>
    数据行可以用<command>DELETE</command>命令从表中删除。假设你对Hayward的天气不再感兴趣，那么你可以用下面的方法把那些行从表中删除：
<programlisting>
DELETE FROM weather WHERE city = 'Hayward';
</programlisting>

    所有属于Hayward的天气记录都被删除。

<programlisting>
SELECT * FROM weather;
</programlisting>

<screen>
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
 San Francisco |      41 |      55 |    0 | 1994-11-29
(2 rows)
</screen>
   </para>

   <para>
    我们用下面形式的语句的时候一定要小心
<synopsis>
DELETE FROM <replaceable>tablename</replaceable>;
</synopsis>

    如果没有一个限制，<command>DELETE</command>将从指定表中删除所有行，把它清空。做这些之前系统不会请求你确认！
   </para>
  </sect1>

 </chapter>
