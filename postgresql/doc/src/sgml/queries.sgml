<!-- doc/src/sgml/queries.sgml -->

<chapter id="queries">
<!--==========================orignal english content==========================
 <title>Queries</title>
____________________________________________________________________________-->
 <title>查询</title>

<!--==========================orignal english content==========================
 <indexterm zone="queries">
  <primary>query</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="queries">
  <primary>查询</primary>
 </indexterm>

<!--==========================orignal english content==========================
 <indexterm zone="queries">
  <primary>SELECT</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="queries">
  <primary>SELECT</primary>
 </indexterm>

<!--==========================orignal english content==========================
 <para>
  The previous chapters explained how to create tables, how to fill
  them with data, and how to manipulate that data.  Now we finally
  discuss how to retrieve the data from the database.
 </para>
____________________________________________________________________________-->
 <para>
  前面的章节解释了如何创建表、如何用数据填充它们 以及如何操纵那些数据。现在我们终于可以讨论如何从数据库中检索数据了。
 </para>


 <sect1 id="queries-overview">
<!--==========================orignal english content==========================
  <title>Overview</title>
____________________________________________________________________________-->
  <title>概述</title>

<!--==========================orignal english content==========================
  <para>
   The process of retrieving or the command to retrieve data from a
   database is called a <firstterm>query</firstterm>.  In SQL the
   <xref linkend="sql-select"/> command is
   used to specify queries.  The general syntax of the
   <command>SELECT</command> command is
<synopsis>
<optional>WITH <replaceable>with_queries</replaceable></optional> SELECT <replaceable>select_list</replaceable> FROM <replaceable>table_expression</replaceable> <optional><replaceable>sort_specification</replaceable></optional>
</synopsis>
   The following sections describe the details of the select list, the
   table expression, and the sort specification.  <literal>WITH</literal>
   queries are treated last since they are an advanced feature.
  </para>
____________________________________________________________________________-->
  <para>
   从数据库中检索数据的过程或命令叫做<firstterm>查询</firstterm>。在 SQL 里<xref linkend="sql-select"/>命令用于指定查询。 <command>SELECT</command>命令的一般语法是
<synopsis>
<optional>WITH <replaceable>with_queries</replaceable></optional> SELECT <replaceable>select_list</replaceable> FROM <replaceable>table_expression</replaceable> <optional><replaceable>sort_specification</replaceable></optional>
</synopsis>
   下面几个小节描述选择列表、表表达式和排序声明的细节。<literal>WITH</literal>查询等高级特性将在最后讨论。
  </para>

<!--==========================orignal english content==========================
  <para>
   A simple kind of query has the form:
<programlisting>
SELECT * FROM table1;
</programlisting>
  Assuming that there is a table called <literal>table1</literal>,
  this command would retrieve all rows and all user-defined columns from
  <literal>table1</literal>.  (The method of retrieval depends on the
  client application.  For example, the
  <application>psql</application> program will display an ASCII-art
  table on the screen, while client libraries will offer functions to
  extract individual values from the query result.)  The select list
  specification <literal>*</literal> means all columns that the table
  expression happens to provide.  A select list can also select a
  subset of the available columns or make calculations using the
  columns.  For example, if
  <literal>table1</literal> has columns named <literal>a</literal>,
  <literal>b</literal>, and <literal>c</literal> (and perhaps others) you can make
  the following query:
<programlisting>
SELECT a, b + c FROM table1;
</programlisting>
  (assuming that <literal>b</literal> and <literal>c</literal> are of a numerical
  data type).
  See <xref linkend="queries-select-lists"/> for more details.
 </para>
____________________________________________________________________________-->
  <para>
   一个简单类型的查询的形式：
<programlisting>
SELECT * FROM table1;
</programlisting>
  假设有一个表叫做<literal>table1</literal>，这条命令将<literal>table1</literal>中检索所有行和所有用户定义的列（检索的方法取决于客户端应用。例如，<application>psql</application>程序将在屏幕上显示一个 ASCII 形式的表格， 而客户端库将提供函数来从检索结果中抽取单个值）。 选择列表声明<literal>*</literal>意味着所有表表达式提供的列。 一个选择列表也可以选择可用列的一个子集或者在使用它们之前对列进行计算。例如，如果<literal>table1</literal>有叫做<literal>a</literal>、<literal>b</literal>和<literal>c</literal>的列（可能还有其他），那么你可以用下面的查询：
<programlisting>
SELECT a, b + c FROM table1;
</programlisting>
  （假设<literal>b</literal>和<literal>c</literal>都是数字数据类型）。 参阅<xref linkend="queries-select-lists"/>获取更多细节。
 </para>

<!--==========================orignal english content==========================
 <para>
  <literal>FROM table1</literal> is a simple kind of
  table expression: it reads just one table.  In general, table
  expressions can be complex constructs of base tables, joins, and
  subqueries.  But you can also omit the table expression entirely and
  use the <command>SELECT</command> command as a calculator:
<programlisting>
SELECT 3 * 4;
</programlisting>
  This is more useful if the expressions in the select list return
  varying results.  For example, you could call a function this way:
<programlisting>
SELECT random();
</programlisting>
  </para>
____________________________________________________________________________-->
 <para>
  <literal>FROM table1</literal>是一种非常简单的表表达式：它只读取了一个表。通常，表表达式可以是基本表、连接和子查询组成的复杂结构。 但你也可以省略整个表表达式而把<command>SELECT</command>命令当做一个计算器：
<programlisting>
SELECT 3 * 4;
</programlisting>
  如果选择列表里的表达式返回变化的结果，那么这就更有用了。例如，你可以用这种方法调用函数：
<programlisting>
SELECT random();
</programlisting>
  </para>
 </sect1>


 <sect1 id="queries-table-expressions">
<!--==========================orignal english content==========================
  <title>Table Expressions</title>
____________________________________________________________________________-->
  <title>表表达式</title>

<!--==========================orignal english content==========================
  <indexterm zone="queries-table-expressions">
   <primary>table expression</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="queries-table-expressions">
   <primary>表表达式</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   A <firstterm>table expression</firstterm> computes a table.  The
   table expression contains a <literal>FROM</literal> clause that is
   optionally followed by <literal>WHERE</literal>, <literal>GROUP BY</literal>, and
   <literal>HAVING</literal> clauses.  Trivial table expressions simply refer
   to a table on disk, a so-called base table, but more complex
   expressions can be used to modify or combine base tables in various
   ways.
  </para>
____________________________________________________________________________-->
  <para>
   <firstterm>表表达式</firstterm>计算一个表。该表表达式包含一个<literal>FROM</literal>子句，该子句后面可以根据需要选用<literal>WHERE</literal>、<literal>GROUP BY</literal>和<literal>HAVING</literal>子句。最简单的表表达式只是引用磁盘上的一个表，一个所谓的基本表，但是我们可以用更复杂的表表达式以多种方法修改或组合基本表。
  </para>

<!--==========================orignal english content==========================
  <para>
   The optional <literal>WHERE</literal>, <literal>GROUP BY</literal>, and
   <literal>HAVING</literal> clauses in the table expression specify a
   pipeline of successive transformations performed on the table
   derived in the <literal>FROM</literal> clause.  All these transformations
   produce a virtual table that provides the rows that are passed to
   the select list to compute the output rows of the query.
  </para>
____________________________________________________________________________-->
  <para>
   表表达式里可选的<literal>WHERE</literal>、<literal>GROUP BY</literal>和<literal>HAVING</literal>子句指定一系列对源自<literal>FROM</literal>子句的表的转换操作。所有这些转换最后生成一个虚拟表，它提供行传递给选择列表计算查询的输出行。
  </para>

  <sect2 id="queries-from">
<!--==========================orignal english content==========================
   <title>The <literal>FROM</literal> Clause</title>
____________________________________________________________________________-->
   <title><literal>FROM</literal>子句</title>

<!--==========================orignal english content==========================
   <para>
    The <xref linkend="sql-from" endterm="sql-from-title"/> derives a
    table from one or more other tables given in a comma-separated
    table reference list.
<synopsis>
FROM <replaceable>table_reference</replaceable> <optional>, <replaceable>table_reference</replaceable> <optional>, ...</optional></optional>
</synopsis>

    A table reference can be a table name (possibly schema-qualified),
    or a derived table such as a subquery, a <literal>JOIN</literal> construct, or
    complex combinations of these.  If more than one table reference is
    listed in the <literal>FROM</literal> clause, the tables are cross-joined
    (that is, the Cartesian product of their rows is formed; see below).
    The result of the <literal>FROM</literal> list is an intermediate virtual
    table that can then be subject to
    transformations by the <literal>WHERE</literal>, <literal>GROUP BY</literal>,
    and <literal>HAVING</literal> clauses and is finally the result of the
    overall table expression.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="sql-from" endterm="sql-from-title"/>从一个用逗号分隔的表引用列表中的一个或更多个其它表中生成一个表。
<synopsis>
FROM <replaceable>table_reference</replaceable> <optional>, <replaceable>table_reference</replaceable> <optional>, ...</optional></optional>
</synopsis>

    表引用可以是一个表名字（可能有模式限定）或者是一个生成的表， 例如子查询、一个<literal>JOIN</literal>结构或者这些东西的复杂组合。如果在<literal>FROM</literal>子句中引用了多于一个表， 那么它们被交叉连接（即构造它们的行的笛卡尔积，见下文）。<literal>FROM</literal>列表的结果是一个中间的虚拟表，该表可以进行由<literal>WHERE</literal>、<literal>GROUP BY</literal>和<literal>HAVING</literal>子句指定的转换，并最后生成全局的表表达式结果。
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>ONLY</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>ONLY</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    When a table reference names a table that is the parent of a
    table inheritance hierarchy, the table reference produces rows of
    not only that table but all of its descendant tables, unless the
    key word <literal>ONLY</literal> precedes the table name.  However, the
    reference produces only the columns that appear in the named table
    &mdash; any columns added in subtables are ignored.
   </para>
____________________________________________________________________________-->
   <para>
    如果一个表引用是一个简单的表名字并且它是表继承层次中的父表，那么该表引用将产生该表和它的后代表中的行，除非你在该表名字前面放上<literal>ONLY</literal>关键字。但是，这种引用只会产生出现在该命名表中的列 &mdash; 在子表中增加的列都会被忽略。
   </para>

<!--==========================orignal english content==========================
   <para>
    Instead of writing <literal>ONLY</literal> before the table name, you can write
    <literal>*</literal> after the table name to explicitly specify that descendant
    tables are included.  There is no real reason to use this syntax any more,
    because searching descendant tables is now always the default behavior.
    However, it is supported for compatibility with older releases.
   </para>
____________________________________________________________________________-->
   <para>
    除了在表名前写<literal>ONLY</literal>，你可以在表名后面写上<literal>*</literal>来显式地指定要包括所有的后代表。没有实际的理由再继续使用这种语法，因为搜索后代表现在总是默认行为。不过，为了保持与旧版本的兼容性，仍然支持这种语法。
   </para>

   <sect3 id="queries-join">
<!--==========================orignal english content==========================
    <title>Joined Tables</title>
____________________________________________________________________________-->
    <title>连接表</title>

<!--==========================orignal english content==========================
    <indexterm zone="queries-join">
     <primary>join</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm zone="queries-join">
     <primary>连接</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     A joined table is a table derived from two other (real or
     derived) tables according to the rules of the particular join
     type.  Inner, outer, and cross-joins are available.
     The general syntax of a joined table is
<synopsis>
<replaceable>T1</replaceable> <replaceable>join_type</replaceable> <replaceable>T2</replaceable> <optional> <replaceable>join_condition</replaceable> </optional>
</synopsis>
     Joins of all types can be chained together, or nested: either or
     both <replaceable>T1</replaceable> and
     <replaceable>T2</replaceable> can be joined tables.  Parentheses
     can be used around <literal>JOIN</literal> clauses to control the join
     order.  In the absence of parentheses, <literal>JOIN</literal> clauses
     nest left-to-right.
    </para>
____________________________________________________________________________-->
    <para>
     一个连接表是根据特定的连接类型的规则从两个其它表（真实表或生成表）中派生的表。目前支持内连接、外连接和交叉连接。一个连接表的一般语法是：
<synopsis>
<replaceable>T1</replaceable> <replaceable>join_type</replaceable> <replaceable>T2</replaceable> <optional> <replaceable>join_condition</replaceable> </optional>
</synopsis>
     所有类型的连接都可以被链在一起或者嵌套：<replaceable>T1</replaceable>和<replaceable>T2</replaceable>都可以是连接表。在<literal>JOIN</literal>子句周围可以使用圆括号来控制连接顺序。如果不使用圆括号，<literal>JOIN</literal>子句会从左至右嵌套。
    </para>

    <variablelist>
<!--==========================orignal english content==========================
     <title>Join Types</title>
____________________________________________________________________________-->
     <title>连接类型</title>

     <varlistentry>
<!--==========================orignal english content==========================
      <term>Cross join
      <indexterm>
       <primary>join</primary>
       <secondary>cross</secondary>
      </indexterm>

      <indexterm>
       <primary>cross join</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term>交叉连接

      <indexterm>
       <primary>连接</primary>
       <secondary>交叉</secondary>
      </indexterm>

      <indexterm>
       <primary>交叉连接</primary>
      </indexterm>
      </term>

      <listitem>
<!--==========================orignal english content==========================
<synopsis>
<replaceable>T1</replaceable> CROSS JOIN <replaceable>T2</replaceable>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>T1</replaceable> CROSS JOIN <replaceable>T2</replaceable>
</synopsis>

<!--==========================orignal english content==========================
       <para>
        For every possible combination of rows from
        <replaceable>T1</replaceable> and
        <replaceable>T2</replaceable> (i.e., a Cartesian product),
        the joined table will contain a
        row consisting of all columns in <replaceable>T1</replaceable>
        followed by all columns in <replaceable>T2</replaceable>.  If
        the tables have N and M rows respectively, the joined
        table will have N * M rows.
       </para>
____________________________________________________________________________-->
       <para>
        对来自于<replaceable>T1</replaceable>和<replaceable>T2</replaceable>的行的每一种可能的组合（即笛卡尔积），连接表将包含这样一行：它由所有<replaceable>T1</replaceable>里面的列后面跟着所有<replaceable>T2</replaceable>里面的列构成。如果两个表分别有 N 和 M 行，连接表将有 N * M 行。
       </para>

<!--==========================orignal english content==========================
       <para>
        <literal>FROM <replaceable>T1</replaceable> CROSS JOIN
        <replaceable>T2</replaceable></literal> is equivalent to
        <literal>FROM <replaceable>T1</replaceable> INNER JOIN
        <replaceable>T2</replaceable> ON TRUE</literal> (see below).
        It is also equivalent to
        <literal>FROM <replaceable>T1</replaceable>,
        <replaceable>T2</replaceable></literal>.
        <note>
        <para>
         This latter equivalence does not hold exactly when more than two
         tables appear, because <literal>JOIN</literal> binds more tightly than
         comma.  For example
         <literal>FROM <replaceable>T1</replaceable> CROSS JOIN
         <replaceable>T2</replaceable> INNER JOIN <replaceable>T3</replaceable>
         ON <replaceable>condition</replaceable></literal>
         is not the same as
         <literal>FROM <replaceable>T1</replaceable>,
         <replaceable>T2</replaceable> INNER JOIN <replaceable>T3</replaceable>
         ON <replaceable>condition</replaceable></literal>
         because the <replaceable>condition</replaceable> can
         reference <replaceable>T1</replaceable> in the first case but not
         the second.
        </para>
        </note>
       </para>
____________________________________________________________________________-->
       <para>
        <literal>FROM <replaceable>T1</replaceable> CROSS JOIN <replaceable>T2</replaceable></literal>等效于<literal>FROM <replaceable>T1</replaceable> INNER JOIN <replaceable>T2</replaceable> ON TRUE</literal>（见下文）。它也等效于<literal>FROM <replaceable>T1</replaceable>,<replaceable>T2</replaceable></literal>。
        <note>
        <para>
         当多于两个表出现时，后一种等效并不严格成立，因为<literal>JOIN</literal>比逗号绑得更紧。例如<literal>FROM <replaceable>T1</replaceable> CROSS JOIN <replaceable>T2</replaceable> INNER JOIN <replaceable>T3</replaceable> ON <replaceable>condition</replaceable></literal>和<literal>FROM <replaceable>T1</replaceable>,<replaceable>T2</replaceable> INNER JOIN <replaceable>T3</replaceable> ON <replaceable>condition</replaceable></literal>并不完全相同，因为第一种情况中的<replaceable>condition</replaceable>可以引用<replaceable>T1</replaceable>，但在第二种情况中却不行。
        </para>
        </note>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term>Qualified joins
      <indexterm>
       <primary>join</primary>
       <secondary>outer</secondary>
      </indexterm>

      <indexterm>
       <primary>outer join</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term>条件连接

      <indexterm>
       <primary>join</primary>
       <secondary>outer</secondary>
      </indexterm>

      <indexterm>
       <primary>外连接</primary>
      </indexterm>
      </term>

      <listitem>
<!--==========================orignal english content==========================
<synopsis>
<replaceable>T1</replaceable> { <optional>INNER</optional> | { LEFT | RIGHT | FULL } <optional>OUTER</optional> } JOIN <replaceable>T2</replaceable> ON <replaceable>boolean_expression</replaceable>
<replaceable>T1</replaceable> { <optional>INNER</optional> | { LEFT | RIGHT | FULL } <optional>OUTER</optional> } JOIN <replaceable>T2</replaceable> USING ( <replaceable>join column list</replaceable> )
<replaceable>T1</replaceable> NATURAL { <optional>INNER</optional> | { LEFT | RIGHT | FULL } <optional>OUTER</optional> } JOIN <replaceable>T2</replaceable>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>T1</replaceable> { <optional>INNER</optional> | { LEFT | RIGHT | FULL } <optional>OUTER</optional> } JOIN <replaceable>T2</replaceable> ON <replaceable>boolean_expression</replaceable>
<replaceable>T1</replaceable> { <optional>INNER</optional> | { LEFT | RIGHT | FULL } <optional>OUTER</optional> } JOIN <replaceable>T2</replaceable> USING ( <replaceable>join column list</replaceable> )
<replaceable>T1</replaceable> NATURAL { <optional>INNER</optional> | { LEFT | RIGHT | FULL } <optional>OUTER</optional> } JOIN <replaceable>T2</replaceable>
</synopsis>

<!--==========================orignal english content==========================
       <para>
        The words <literal>INNER</literal> and
        <literal>OUTER</literal> are optional in all forms.
        <literal>INNER</literal> is the default;
        <literal>LEFT</literal>, <literal>RIGHT</literal>, and
        <literal>FULL</literal> imply an outer join.
       </para>
____________________________________________________________________________-->
       <para>
        <literal>INNER</literal>和<literal>OUTER</literal>对所有连接形式都是可选的。<literal>INNER</literal>是缺省；<literal>LEFT</literal>、<literal>RIGHT</literal>和<literal>FULL</literal>指示一个外连接。
       </para>

<!--==========================orignal english content==========================
       <para>
        The <firstterm>join condition</firstterm> is specified in the
        <literal>ON</literal> or <literal>USING</literal> clause, or implicitly by
        the word <literal>NATURAL</literal>.  The join condition determines
        which rows from the two source tables are considered to
        <quote>match</quote>, as explained in detail below.
       </para>
____________________________________________________________________________-->
       <para>
        <firstterm>连接条件</firstterm>在<literal>ON</literal>或<literal>USING</literal>子句中指定， 或者用关键字<literal>NATURAL</literal>隐含地指定。连接条件决定来自两个源表中的哪些行是<quote>匹配</quote>的，这些我们将在后文详细解释。
       </para>

<!--==========================orignal english content==========================
       <para>
        The possible types of qualified join are:

       <variablelist>
        <varlistentry>
         <term><literal>INNER JOIN</literal></term>

         <listitem>
          <para>
           For each row R1 of T1, the joined table has a row for each
           row in T2 that satisfies the join condition with R1.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>LEFT OUTER JOIN</literal>
         <indexterm>
          <primary>join</primary>
          <secondary>left</secondary>
         </indexterm>

         <indexterm>
          <primary>left join</primary>
         </indexterm>
         </term>

         <listitem>
          <para>
           First, an inner join is performed.  Then, for each row in
           T1 that does not satisfy the join condition with any row in
           T2, a joined row is added with null values in columns of
           T2.  Thus, the joined table always has at least
           one row for each row in T1.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>RIGHT OUTER JOIN</literal>
         <indexterm>
          <primary>join</primary>
          <secondary>right</secondary>
         </indexterm>

         <indexterm>
          <primary>right join</primary>
         </indexterm>
         </term>

         <listitem>
          <para>
           First, an inner join is performed.  Then, for each row in
           T2 that does not satisfy the join condition with any row in
           T1, a joined row is added with null values in columns of
           T1.  This is the converse of a left join: the result table
           will always have a row for each row in T2.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>FULL OUTER JOIN</literal></term>

         <listitem>
          <para>
           First, an inner join is performed.  Then, for each row in
           T1 that does not satisfy the join condition with any row in
           T2, a joined row is added with null values in columns of
           T2.  Also, for each row of T2 that does not satisfy the
           join condition with any row in T1, a joined row with null
           values in the columns of T1 is added.
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
       </para>
____________________________________________________________________________-->
       <para>
        可能的条件连接类型是：

       <variablelist>
        <varlistentry>
         <term><literal>INNER JOIN</literal></term>

         <listitem>
          <para>
           对于 T1 的每一行 R1，生成的连接表都有一行对应 T2 中的每一个满足和 R1 的连接条件的行。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>LEFT OUTER JOIN</literal>
         <indexterm>
          <primary>连接</primary>
          <secondary>左</secondary>
         </indexterm>

         <indexterm>
          <primary>左连接</primary>
         </indexterm>
         </term>

         <listitem>
          <para>
           首先，执行一次内连接。然后，为 T1 中每一个无法在连接条件上匹配 T2 里任何一行的行返回一个连接行，该连接行中 T2 的列用空值补齐。因此，生成的连接表里为来自 T1 的每一行都至少包含一行。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>RIGHT OUTER JOIN</literal>
         <indexterm>
          <primary>连接</primary>
          <secondary>右</secondary>
         </indexterm>

         <indexterm>
          <primary>右连接</primary>
         </indexterm>
         </term>

         <listitem>
          <para>
           首先，执行一次内连接。然后，为 T2 中每一个无法在连接条件上匹配 T1 里任何一行的行返回一个连接行，该连接行中 T1 的列用空值补齐。因此，生成的连接表里为来自 T2 的每一行都至少包含一行。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>FULL OUTER JOIN</literal></term>

         <listitem>
          <para>
           首先，执行一次内连接。然后，为 T1 中每一个无法在连接条件上匹配 T2 里任何一行的行返回一个连接行，该连接行中 T2 的列用空值补齐。同样，为 T2 中每一个无法在连接条件上匹配 T1 里任何一行的行返回一个连接行，该连接行中 T1 的列用空值补齐。
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
       </para>

<!--==========================orignal english content==========================
       <para>
        The <literal>ON</literal> clause is the most general kind of join
        condition: it takes a Boolean value expression of the same
        kind as is used in a <literal>WHERE</literal> clause.  A pair of rows
        from <replaceable>T1</replaceable> and <replaceable>T2</replaceable> match if the
        <literal>ON</literal> expression evaluates to true.
       </para>
____________________________________________________________________________-->
       <para>
       <literal>ON</literal>子句是最常见的连接条件的形式：它接收一个和<literal>WHERE</literal>子句里用的一样的布尔值表达式。 如果两个分别来自<replaceable>T1</replaceable>和<replaceable>T2</replaceable>的行在<literal>ON</literal>表达式上运算的结果为真，那么它们就算是匹配的行。
       </para>

<!--==========================orignal english content==========================
       <para>
        The <literal>USING</literal> clause is a shorthand that allows you to take
        advantage of the specific situation where both sides of the join use
        the same name for the joining column(s).  It takes a
        comma-separated list of the shared column names
        and forms a join condition that includes an equality comparison
        for each one.  For example, joining <replaceable>T1</replaceable>
        and <replaceable>T2</replaceable> with <literal>USING (a, b)</literal> produces
        the join condition <literal>ON <replaceable>T1</replaceable>.a
        = <replaceable>T2</replaceable>.a AND <replaceable>T1</replaceable>.b
        = <replaceable>T2</replaceable>.b</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        <literal>USING</literal>是个缩写符号，它允许你利用特殊的情况：连接的两端都具有相同的连接列名。它接受共享列名的一个逗号分隔列表，并且为其中每一个共享列构造一个包含等值比较的连接条件。例如用<literal>USING (a, b)</literal>连接<replaceable>T1</replaceable>和<replaceable>T2</replaceable>会产生连接条件<literal>ON <replaceable>T1</replaceable>.a = <replaceable>T2</replaceable>.a AND <replaceable>T1</replaceable>.b = <replaceable>T2</replaceable>.b</literal>。
       </para>

<!--==========================orignal english content==========================
       <para>
        Furthermore, the output of <literal>JOIN USING</literal> suppresses
        redundant columns: there is no need to print both of the matched
        columns, since they must have equal values.  While <literal>JOIN
        ON</literal> produces all columns from <replaceable>T1</replaceable> followed by all
        columns from <replaceable>T2</replaceable>, <literal>JOIN USING</literal> produces one
        output column for each of the listed column pairs (in the listed
        order), followed by any remaining columns from <replaceable>T1</replaceable>,
        followed by any remaining columns from <replaceable>T2</replaceable>.
       </para>
____________________________________________________________________________-->
       <para>
        更进一步，<literal>JOIN USING</literal>的输出会废除冗余列：不需要把匹配上的列都打印出来，因为它们必须具有相等的值。不过<literal>JOIN ON</literal>会先产生来自<replaceable>T1</replaceable>的所有列，后面跟上所有来自<replaceable>T2</replaceable>的列；而<literal>JOIN USING</literal>会先为列出的每一个列对产生一个输出列，然后先跟上来自<replaceable>T1</replaceable>的剩余列，最后跟上来自<replaceable>T2</replaceable>的剩余列。
       </para>

<!--==========================orignal english content==========================
       <para>
        <indexterm>
         <primary>join</primary>
         <secondary>natural</secondary>
        </indexterm>
        <indexterm>
         <primary>natural join</primary>
        </indexterm>
        Finally, <literal>NATURAL</literal> is a shorthand form of
        <literal>USING</literal>: it forms a <literal>USING</literal> list
        consisting of all column names that appear in both
        input tables.  As with <literal>USING</literal>, these columns appear
        only once in the output table.  If there are no common
        column names, <literal>NATURAL JOIN</literal> behaves like
        <literal>JOIN ... ON TRUE</literal>, producing a cross-product join.
       </para>
____________________________________________________________________________-->
       <para>
        <indexterm>
         <primary>连接</primary>
         <secondary>自然</secondary>
        </indexterm>
        <indexterm>
         <primary>自然连接</primary>
        </indexterm>
        最后，<literal>NATURAL</literal>是<literal>USING</literal>的缩写形式：它形成一个<literal>USING</literal>列表， 该列表由那些在两个表里都出现了的列名组成。和<literal>USING</literal>一样，这些列只在输出表里出现一次。如果不存在公共列，<literal>NATURAL JOIN</literal>的行为将和<literal>JOIN ... ON TRUE</literal>一样产生交叉集连接。
       </para>

       <note>
<!--==========================orignal english content==========================
        <para>
         <literal>USING</literal> is reasonably safe from column changes
         in the joined relations since only the listed columns
         are combined.  <literal>NATURAL</literal> is considerably more risky since
         any schema changes to either relation that cause a new matching
         column name to be present will cause the join to combine that new
         column as well.
        </para>
____________________________________________________________________________-->
        <para>
         <literal>USING</literal>对于连接关系中的列改变是相当安全的，因为只有被列出的列会被组合成连接条件。<literal>NATURAL</literal>的风险更大，因为如果其中一个关系的模式改变会导致出现一个新的匹配列名，就会导致连接将新列也组合成连接条件。
        </para>
       </note>
      </listitem>
     </varlistentry>
    </variablelist>

<!--==========================orignal english content==========================
    <para>
     To put this together, assume we have tables <literal>t1</literal>:
<programlisting>
 num | name
-&minus;-&minus;-+-&minus;-&minus;-&minus;
   1 | a
   2 | b
   3 | c
</programlisting>
     and <literal>t2</literal>:
<programlisting>
 num | value
-&minus;-&minus;-+-&minus;-&minus;-&minus;-
   1 | xxx
   3 | yyy
   5 | zzz
</programlisting>
     then we get the following results for the various joins:
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 CROSS JOIN t2;</userinput>
 num | name | num | value
-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-+-&minus;-&minus;-&minus;-
   1 | a    |   1 | xxx
   1 | a    |   3 | yyy
   1 | a    |   5 | zzz
   2 | b    |   1 | xxx
   2 | b    |   3 | yyy
   2 | b    |   5 | zzz
   3 | c    |   1 | xxx
   3 | c    |   3 | yyy
   3 | c    |   5 | zzz
(9 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 INNER JOIN t2 ON t1.num = t2.num;</userinput>
 num | name | num | value
-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-+-&minus;-&minus;-&minus;-
   1 | a    |   1 | xxx
   3 | c    |   3 | yyy
(2 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 INNER JOIN t2 USING (num);</userinput>
 num | name | value
-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-
   1 | a    | xxx
   3 | c    | yyy
(2 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 NATURAL INNER JOIN t2;</userinput>
 num | name | value
-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-
   1 | a    | xxx
   3 | c    | yyy
(2 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num;</userinput>
 num | name | num | value
-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-+-&minus;-&minus;-&minus;-
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |   3 | yyy
(3 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 USING (num);</userinput>
 num | name | value
-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-
   1 | a    | xxx
   2 | b    |
   3 | c    | yyy
(3 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 RIGHT JOIN t2 ON t1.num = t2.num;</userinput>
 num | name | num | value
-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-+-&minus;-&minus;-&minus;-
   1 | a    |   1 | xxx
   3 | c    |   3 | yyy
     |      |   5 | zzz
(3 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 FULL JOIN t2 ON t1.num = t2.num;</userinput>
 num | name | num | value
-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-+-&minus;-&minus;-&minus;-
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |   3 | yyy
     |      |   5 | zzz
(4 rows)
</screen>
    </para>
____________________________________________________________________________-->
    <para>
     为了解释这些问题，假设我们有一个表<literal>t1</literal>：
<programlisting>
 num | name
-----+------
   1 | a
   2 | b
   3 | c
</programlisting>
     和<literal>t2</literal>：
<programlisting>
 num | value
-----+-------
   1 | xxx
   3 | yyy
   5 | zzz
</programlisting>
     然后我们用不同的连接方式可以获得各种结果：
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 CROSS JOIN t2;</userinput>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   1 | a    |   3 | yyy
   1 | a    |   5 | zzz
   2 | b    |   1 | xxx
   2 | b    |   3 | yyy
   2 | b    |   5 | zzz
   3 | c    |   1 | xxx
   3 | c    |   3 | yyy
   3 | c    |   5 | zzz
(9 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 INNER JOIN t2 ON t1.num = t2.num;</userinput>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   3 | c    |   3 | yyy
(2 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 INNER JOIN t2 USING (num);</userinput>
 num | name | value
-----+------+-------
   1 | a    | xxx
   3 | c    | yyy
(2 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 NATURAL INNER JOIN t2;</userinput>
 num | name | value
-----+------+-------
   1 | a    | xxx
   3 | c    | yyy
(2 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num;</userinput>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |   3 | yyy
(3 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 USING (num);</userinput>
 num | name | value
-----+------+-------
   1 | a    | xxx
   2 | b    |
   3 | c    | yyy
(3 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 RIGHT JOIN t2 ON t1.num = t2.num;</userinput>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   3 | c    |   3 | yyy
     |      |   5 | zzz
(3 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 FULL JOIN t2 ON t1.num = t2.num;</userinput>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |   3 | yyy
     |      |   5 | zzz
(4 rows)
</screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     The join condition specified with <literal>ON</literal> can also contain
     conditions that do not relate directly to the join.  This can
     prove useful for some queries but needs to be thought out
     carefully.  For example:
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num AND t2.value = 'xxx';</userinput>
 num | name | num | value
-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-+-&minus;-&minus;-&minus;-
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |     |
(3 rows)
</screen>
     Notice that placing the restriction in the <literal>WHERE</literal> clause
     produces a different result:
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num WHERE t2.value = 'xxx';</userinput>
 num | name | num | value
-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-+-&minus;-&minus;-&minus;-
   1 | a    |   1 | xxx
(1 row)
</screen>
     This is because a restriction placed in the <literal>ON</literal>
     clause is processed <emphasis>before</emphasis> the join, while
     a restriction placed in the <literal>WHERE</literal> clause is processed
     <emphasis>after</emphasis> the join.
     That does not matter with inner joins, but it matters a lot with outer
     joins.
    </para>
____________________________________________________________________________-->
    <para>
     用<literal>ON</literal>指定的连接条件也可以包含与连接不直接相关的条件。这种功能可能对某些查询很有用，但是需要我们仔细想清楚。例如：
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num AND t2.value = 'xxx';</userinput>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |     |
(3 rows)
</screen>
     注意把限制放在<literal>WHERE</literal>子句中会产生不同的结果：
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num WHERE t2.value = 'xxx';</userinput>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
(1 row)
</screen>
     这是因为放在<literal>ON</literal>子句中的一个约束在连接<emphasis>之前</emphasis>被处理，而放在<literal>WHERE</literal>子句中的一个约束是在连接<emphasis>之后</emphasis>被处理。这对内连接没有关系，但是对于外连接会带来麻烦。
    </para>
   </sect3>

   <sect3 id="queries-table-aliases">
<!--==========================orignal english content==========================
    <title>Table and Column Aliases</title>
____________________________________________________________________________-->
    <title>表和列别名</title>

<!--==========================orignal english content==========================
    <indexterm zone="queries-table-aliases">
     <primary>alias</primary>
     <secondary>in the FROM clause</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm zone="queries-table-aliases">
     <primary>别名</primary>
     <secondary>在FROM子句中</secondary>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>label</primary>
     <see>alias</see>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>标签</primary>
     <see>别名</see>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     A temporary name can be given to tables and complex table
     references to be used for references to the derived table in
     the rest of the query.  This is called a <firstterm>table
     alias</firstterm>.
    </para>
____________________________________________________________________________-->
    <para>
     你可以给一个表或复杂的表引用指定一个临时的名字，用于剩下的查询中引用那些派生的表。这被叫做<firstterm>表别名</firstterm>。
    </para>

<!--==========================orignal english content==========================
    <para>
     To create a table alias, write
<synopsis>
FROM <replaceable>table_reference</replaceable> AS <replaceable>alias</replaceable>
</synopsis>
     or
<synopsis>
FROM <replaceable>table_reference</replaceable> <replaceable>alias</replaceable>
</synopsis>
     The <literal>AS</literal> key word is optional noise.
     <replaceable>alias</replaceable> can be any identifier.
    </para>
____________________________________________________________________________-->
    <para>
     要创建一个表别名，我们可以写：
<synopsis>
FROM <replaceable>table_reference</replaceable> AS <replaceable>alias</replaceable>
</synopsis>
     或者
<synopsis>
FROM <replaceable>table_reference</replaceable> <replaceable>alias</replaceable>
</synopsis>
     <literal>AS</literal>关键字是可选的。<replaceable>别名</replaceable>可以是任意标识符。
    </para>

<!--==========================orignal english content==========================
    <para>
     A typical application of table aliases is to assign short
     identifiers to long table names to keep the join clauses
     readable.  For example:
<programlisting>
SELECT * FROM some_very_long_table_name s JOIN another_fairly_long_name a ON s.id = a.num;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     表别名的典型应用是给长表名赋予比较短的标识符， 好让连接子句更易读。例如：
<programlisting>
SELECT * FROM some_very_long_table_name s JOIN another_fairly_long_name a ON s.id = a.num;
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     The alias becomes the new name of the table reference so far as the
     current query is concerned &mdash; it is not allowed to refer to the
     table by the original name elsewhere in the query.  Thus, this is not
     valid:
<programlisting>
SELECT * FROM my_table AS m WHERE my_table.a &gt; 5;    -&minus; wrong
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     到这里，别名成为当前查询的表引用的新名称 &mdash; 我们不再能够用该表最初的名字引用它了。因此，下面的用法是不合法的：
<programlisting>
SELECT * FROM my_table AS m WHERE my_table.a &gt; 5;    -- 错误
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     Table aliases are mainly for notational convenience, but it is
     necessary to use them when joining a table to itself, e.g.:
<programlisting>
SELECT * FROM people AS mother JOIN people AS child ON mother.id = child.mother_id;
</programlisting>
     Additionally, an alias is required if the table reference is a
     subquery (see <xref linkend="queries-subqueries"/>).
    </para>
____________________________________________________________________________-->
    <para>
     表别名主要用于简化符号，但是当把一个表连接到它自身时必须使用别名，例如：
<programlisting>
SELECT * FROM people AS mother JOIN people AS child ON mother.id = child.mother_id;
</programlisting>
     此外，如果一个表引用是一个子查询，则必须要使用一个别名（见<xref linkend="queries-subqueries"/>）。
    </para>

<!--==========================orignal english content==========================
    <para>
     Parentheses are used to resolve ambiguities.  In the following example,
     the first statement assigns the alias <literal>b</literal> to the second
     instance of <literal>my_table</literal>, but the second statement assigns the
     alias to the result of the join:
<programlisting>
SELECT * FROM my_table AS a CROSS JOIN my_table AS b ...
SELECT * FROM (my_table AS a CROSS JOIN my_table) AS b ...
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     圆括弧用于解决歧义。在下面的例子中，第一个语句将把别名<literal>b</literal>赋给<literal>my_table</literal>的第二个实例，但是第二个语句把别名赋给连接的结果：
<programlisting>
SELECT * FROM my_table AS a CROSS JOIN my_table AS b ...
SELECT * FROM (my_table AS a CROSS JOIN my_table) AS b ...
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     Another form of table aliasing gives temporary names to the columns of
     the table, as well as the table itself:
<synopsis>
FROM <replaceable>table_reference</replaceable> <optional>AS</optional> <replaceable>alias</replaceable> ( <replaceable>column1</replaceable> <optional>, <replaceable>column2</replaceable> <optional>, ...</optional></optional> )
</synopsis>
     If fewer column aliases are specified than the actual table has
     columns, the remaining columns are not renamed.  This syntax is
     especially useful for self-joins or subqueries.
    </para>
____________________________________________________________________________-->
    <para>
     另外一种给表指定别名的形式是给表的列赋予临时名字，就像给表本身指定别名一样：
<synopsis>
FROM <replaceable>table_reference</replaceable> <optional>AS</optional> <replaceable>alias</replaceable> ( <replaceable>column1</replaceable> <optional>, <replaceable>column2</replaceable> <optional>, ...</optional></optional> )
</synopsis>
     如果指定的列别名比表里实际的列少，那么剩下的列就没有被重命名。这种语法对于自连接或子查询特别有用。
    </para>

<!--==========================orignal english content==========================
    <para>
     When an alias is applied to the output of a <literal>JOIN</literal>
     clause, the alias hides the original
     name(s) within the <literal>JOIN</literal>.  For example:
<programlisting>
SELECT a.* FROM my_table AS a JOIN your_table AS b ON ...
</programlisting>
     is valid SQL, but:
<programlisting>
SELECT a.* FROM (my_table AS a JOIN your_table AS b ON ...) AS c
</programlisting>
     is not valid; the table alias <literal>a</literal> is not visible
     outside the alias <literal>c</literal>.
    </para>
____________________________________________________________________________-->
    <para>
     如果用这些形式中的任何一种给一个<literal>JOIN</literal>子句的输出附加了一个别名， 那么该别名就在<literal>JOIN</literal>的作用下隐去了其原始的名字。例如：
<programlisting>
SELECT a.* FROM my_table AS a JOIN your_table AS b ON ...
</programlisting>
     是合法 SQL，但是：
<programlisting>
SELECT a.* FROM (my_table AS a JOIN your_table AS b ON ...) AS c
</programlisting>
     是不合法的：表别名<literal>a</literal>在别名<literal>c</literal>外面是看不到的。
    </para>
   </sect3>

   <sect3 id="queries-subqueries">
<!--==========================orignal english content==========================
    <title>Subqueries</title>
____________________________________________________________________________-->
    <title>子查询</title>

<!--==========================orignal english content==========================
    <indexterm zone="queries-subqueries">
     <primary>subquery</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm zone="queries-subqueries">
     <primary>子查询</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     Subqueries specifying a derived table must be enclosed in
     parentheses and <emphasis>must</emphasis> be assigned a table
     alias name (as in <xref linkend="queries-table-aliases"/>).  For
     example:
<programlisting>
FROM (SELECT * FROM table1) AS alias_name
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     子查询指定了一个派生表，它必须被包围在圆括弧里并且<emphasis>必须</emphasis>被赋予一个表别名（参阅<xref linkend="queries-table-aliases"/>）。例如：
<programlisting>
FROM (SELECT * FROM table1) AS alias_name
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     This example is equivalent to <literal>FROM table1 AS
     alias_name</literal>.  More interesting cases, which cannot be
     reduced to a plain join, arise when the subquery involves
     grouping or aggregation.
    </para>
____________________________________________________________________________-->
    <para>
     这个例子等效于<literal>FROM table1 AS alias_name</literal>。更有趣的情况是在子查询里面有分组或聚集的时候， 子查询不能被简化为一个简单的连接。
    </para>

<!--==========================orignal english content==========================
    <para>
     A subquery can also be a <command>VALUES</command> list:
<programlisting>
FROM (VALUES ('anne', 'smith'), ('bob', 'jones'), ('joe', 'blow'))
     AS names(first, last)
</programlisting>
     Again, a table alias is required.  Assigning alias names to the columns
     of the <command>VALUES</command> list is optional, but is good practice.
     For more information see <xref linkend="queries-values"/>.
    </para>
____________________________________________________________________________-->
    <para>
     一个子查询也可以是一个<command>VALUES</command>列表：
<programlisting>
FROM (VALUES ('anne', 'smith'), ('bob', 'jones'), ('joe', 'blow'))
     AS names(first, last)
</programlisting>
     再次的，这里要求一个表别名。为<command>VALUES</command>列表中的列分配别名是可选的，但是选择这样做是一个好习惯。更多信息可参见<xref linkend="queries-values"/>。
    </para>
   </sect3>

   <sect3 id="queries-tablefunctions">
<!--==========================orignal english content==========================
    <title>Table Functions</title>
____________________________________________________________________________-->
    <title>表函数</title>

<!--==========================orignal english content==========================
    <indexterm zone="queries-tablefunctions"><primary>table function</primary></indexterm>
____________________________________________________________________________-->
    <indexterm zone="queries-tablefunctions"><primary>表函数</primary></indexterm>

<!--==========================orignal english content==========================
    <indexterm zone="queries-tablefunctions">
     <primary>function</primary>
     <secondary>in the FROM clause</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm zone="queries-tablefunctions">
     <primary>函数</primary>
     <secondary>在FROM子句中</secondary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     Table functions are functions that produce a set of rows, made up
     of either base data types (scalar types) or composite data types
     (table rows).  They are used like a table, view, or subquery in
     the <literal>FROM</literal> clause of a query. Columns returned by table
     functions can be included in <literal>SELECT</literal>,
     <literal>JOIN</literal>, or <literal>WHERE</literal> clauses in the same manner
     as columns of a table, view, or subquery.
    </para>
____________________________________________________________________________-->
    <para>
     表函数是那些生成一个行集合的函数，这个集合可以是由基本数据类型（标量类型）组成， 也可以是由复合数据类型（表行）组成。它们的用法类似一个表、视图或者在查询的<literal>FROM</literal>子句里的子查询。表函数返回的列可以像一个表列、视图或者子查询那样被包含在<literal>SELECT</literal>、<literal>JOIN</literal>或<literal>WHERE</literal>子句里。
    </para>

<!--==========================orignal english content==========================
    <para>
     Table functions may also be combined using the <literal>ROWS FROM</literal>
     syntax, with the results returned in parallel columns; the number of
     result rows in this case is that of the largest function result, with
     smaller results padded with null values to match.
    </para>
____________________________________________________________________________-->
    <para>
     也可以使用<literal>ROWS FROM</literal>语法将平行列返回的结果组合成表函数；
     这种情况下结果行的数量是最大一个函数结果的数量，较小的结果会用空值来填充。
    </para>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>function_call</replaceable> <optional>WITH ORDINALITY</optional> <optional><optional>AS</optional> <replaceable>table_alias</replaceable> <optional>(<replaceable>column_alias</replaceable> <optional>, ... </optional>)</optional></optional>
ROWS FROM( <replaceable>function_call</replaceable> <optional>, ... </optional> ) <optional>WITH ORDINALITY</optional> <optional><optional>AS</optional> <replaceable>table_alias</replaceable> <optional>(<replaceable>column_alias</replaceable> <optional>, ... </optional>)</optional></optional>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>function_call</replaceable> <optional>WITH ORDINALITY</optional> <optional><optional>AS</optional> <replaceable>table_alias</replaceable> <optional>(<replaceable>column_alias</replaceable> <optional>, ... </optional>)</optional></optional>
ROWS FROM( <replaceable>function_call</replaceable> <optional>, ... </optional> ) <optional>WITH ORDINALITY</optional> <optional><optional>AS</optional> <replaceable>table_alias</replaceable> <optional>(<replaceable>column_alias</replaceable> <optional>, ... </optional>)</optional></optional>
</synopsis>

<!--==========================orignal english content==========================
    <para>
     If the <literal>WITH ORDINALITY</literal> clause is specified, an
     additional column of type <type>bigint</type> will be added to the
     function result columns.  This column numbers the rows of the function
     result set, starting from 1. (This is a generalization of the
     SQL-standard syntax for <literal>UNNEST ... WITH ORDINALITY</literal>.)
     By default, the ordinal column is called <literal>ordinality</literal>, but
     a different column name can be assigned to it using
     an <literal>AS</literal> clause.
    </para>
____________________________________________________________________________-->
    <para>
     如果指定了<literal>WITH ORDINALITY</literal>子句，一个额外的
     <type>bigint</type>类型的列将会被增加到函数的结果列中。这个列对
     函数结果集的行进行编号，编号从 1 开始（这是对 SQL 标准语法
     <literal>UNNEST ... WITH ORDINALITY</literal>的一般化）。默认情
     况下，序数列被称为<literal>ordinality</literal>，但也可以通过使用一个
     <literal>AS</literal>子句给它分配一个不同的列名。
    </para>

<!--==========================orignal english content==========================
    <para>
     The special table function <literal>UNNEST</literal> may be called with
     any number of array parameters, and it returns a corresponding number of
     columns, as if <literal>UNNEST</literal>
     (<xref linkend="functions-array"/>) had been called on each parameter
     separately and combined using the <literal>ROWS FROM</literal> construct.
    </para>
____________________________________________________________________________-->
    <para>
     调用特殊的表函数<literal>UNNEST</literal>可以使用任意数量的数组参数，
     它会返回对应的列数，就好像在每一个参数上单独调用
     <literal>UNNEST</literal>（<xref linkend="functions-array"/>）并且使用
     <literal>ROWS FROM</literal>结构把它们组合起来。
    </para>

<!--==========================orignal english content==========================
<synopsis>
UNNEST( <replaceable>array_expression</replaceable> <optional>, ... </optional> ) <optional>WITH ORDINALITY</optional> <optional><optional>AS</optional> <replaceable>table_alias</replaceable> <optional>(<replaceable>column_alias</replaceable> <optional>, ... </optional>)</optional></optional>
</synopsis>
____________________________________________________________________________-->
<synopsis>
UNNEST( <replaceable>array_expression</replaceable> <optional>, ... </optional> ) <optional>WITH ORDINALITY</optional> <optional><optional>AS</optional> <replaceable>table_alias</replaceable> <optional>(<replaceable>column_alias</replaceable> <optional>, ... </optional>)</optional></optional>
</synopsis>

<!--==========================orignal english content==========================
    <para>
     If no <replaceable>table_alias</replaceable> is specified, the function
     name is used as the table name; in the case of a <literal>ROWS FROM()</literal>
     construct, the first function's name is used.
    </para>
____________________________________________________________________________-->
    <para>
     如果没有指定<replaceable>table_alias</replaceable>，该函数名将被用作
     表名。在<literal>ROWS FROM()</literal>结构的情况中，会使用第一个函数名。
    </para>

<!--==========================orignal english content==========================
    <para>
     If column aliases are not supplied, then for a function returning a base
     data type, the column name is also the same as the function name.  For a
     function returning a composite type, the result columns get the names
     of the individual attributes of the type.
    </para>
____________________________________________________________________________-->
    <para>
     如果没有提供列的别名，那么对于一个返回基数据类型的函数，列名也与该函数
     名相同。对于一个返回组合类型的函数，结果列会从该类型的属性得到名称。
    </para>

<!--==========================orignal english content==========================
    <para>
     Some examples:
<programlisting>
CREATE TABLE foo (fooid int, foosubid int, fooname text);

CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS $$
    SELECT * FROM foo WHERE fooid = $1;
$$ LANGUAGE SQL;

SELECT * FROM getfoo(1) AS t1;

SELECT * FROM foo
    WHERE foosubid IN (
                        SELECT foosubid
                        FROM getfoo(foo.fooid) z
                        WHERE z.fooid = foo.fooid
                      );

CREATE VIEW vw_getfoo AS SELECT * FROM getfoo(1);

SELECT * FROM vw_getfoo;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     例子：
<programlisting>
CREATE TABLE foo (fooid int, foosubid int, fooname text);

CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS $$
    SELECT * FROM foo WHERE fooid = $1;
$$ LANGUAGE SQL;

SELECT * FROM getfoo(1) AS t1;

SELECT * FROM foo
    WHERE foosubid IN (
                        SELECT foosubid
                        FROM getfoo(foo.fooid) z
                        WHERE z.fooid = foo.fooid
                      );

CREATE VIEW vw_getfoo AS SELECT * FROM getfoo(1);

SELECT * FROM vw_getfoo;
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     In some cases it is useful to define table functions that can
     return different column sets depending on how they are invoked.
     To support this, the table function can be declared as returning
     the pseudo-type <type>record</type>.  When such a function is used in
     a query, the expected row structure must be specified in the
     query itself, so that the system can know how to parse and plan
     the query.  This syntax looks like:
    </para>
____________________________________________________________________________-->
    <para>
     有时侯，定义一个能够根据它们被调用方式返回不同列集合的表函数是很有用的。为了支持这些，表函数可以被声明为返回伪类型<type>record</type>。 如果在查询里使用这样的函数，那么我们必须在查询中指定所预期的行结构，这样系统才知道如何分析和规划该查询。这种语法是这样的：
     </para>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>function_call</replaceable> <optional>AS</optional> <replaceable>alias</replaceable> (<replaceable>column_definition</replaceable> <optional>, ... </optional>)
<replaceable>function_call</replaceable> AS <optional><replaceable>alias</replaceable></optional> (<replaceable>column_definition</replaceable> <optional>, ... </optional>)
ROWS FROM( ... <replaceable>function_call</replaceable> AS (<replaceable>column_definition</replaceable> <optional>, ... </optional>) <optional>, ... </optional> )
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>function_call</replaceable> <optional>AS</optional> <replaceable>alias</replaceable> (<replaceable>column_definition</replaceable> <optional>, ... </optional>)
<replaceable>function_call</replaceable> AS <optional><replaceable>alias</replaceable></optional> (<replaceable>column_definition</replaceable> <optional>, ... </optional>)
ROWS FROM( ... <replaceable>function_call</replaceable> AS (<replaceable>column_definition</replaceable> <optional>, ... </optional>) <optional>, ... </optional> )
</synopsis>

<!--==========================orignal english content==========================
    <para>
     When not using the <literal>ROWS FROM()</literal> syntax,
     the <replaceable>column_definition</replaceable> list replaces the column
     alias list that could otherwise be attached to the <literal>FROM</literal>
     item; the names in the column definitions serve as column aliases.
     When using the <literal>ROWS FROM()</literal> syntax,
     a <replaceable>column_definition</replaceable> list can be attached to
     each member function separately; or if there is only one member function
     and no <literal>WITH ORDINALITY</literal> clause,
     a <replaceable>column_definition</replaceable> list can be written in
     place of a column alias list following <literal>ROWS FROM()</literal>.
    </para>
____________________________________________________________________________-->
    <para>
     在没有使用<literal>ROWS FROM()</literal>语法时，
     <replaceable>column_definition</replaceable>列表会取代无法附着在
     <literal>FROM</literal>项上的列别名列表，列定义中的名称就起到列别名的作用。
     在使用<literal>ROWS FROM()</literal>语法时，
     可以为每一个成员函数单独附着一个
     <replaceable>column_definition</replaceable>列表；或者在只有一个成员
     函数并且没有<literal>WITH ORDINALITY</literal>子句的情况下，可以在
     <literal>ROWS FROM()</literal>后面写一个
     <replaceable>column_definition</replaceable>列表来取代一个列别名列表。
    </para>

<!--==========================orignal english content==========================
    <para>
     Consider this example:
<programlisting>
SELECT *
    FROM dblink('dbname=mydb', 'SELECT proname, prosrc FROM pg_proc')
      AS t1(proname name, prosrc text)
    WHERE proname LIKE 'bytea%';
</programlisting>
     The <xref linkend="contrib-dblink-function"/> function
     (part of the <xref linkend="dblink"/> module) executes
     a remote query.  It is declared to return
     <type>record</type> since it might be used for any kind of query.
     The actual column set must be specified in the calling query so
     that the parser knows, for example, what <literal>*</literal> should
     expand to.
    </para>
____________________________________________________________________________-->
    <para>
     考虑下面的例子：
<programlisting>
SELECT *
    FROM dblink('dbname=mydb', 'SELECT proname, prosrc FROM pg_proc')
      AS t1(proname name, prosrc text)
    WHERE proname LIKE 'bytea%';
</programlisting>
     <xref linkend="contrib-dblink-function"/>函数（<xref linkend="dblink"/>模块的一部分）执行一个远程的查询。它被声明为返回<type>record</type>，因为它可能会被用于任何类型的查询。 实际的列集必须在调用它的查询中指定，这样分析器才知道类似<literal>*</literal>这样的东西应该扩展成什么样子。
    </para>
   </sect3>

   <sect3 id="queries-lateral">
<!--==========================orignal english content==========================
    <title><literal>LATERAL</literal> Subqueries</title>
____________________________________________________________________________-->
    <title><literal>LATERAL</literal>子查询</title>

<!--==========================orignal english content==========================
    <indexterm zone="queries-lateral">
     <primary>LATERAL</primary>
     <secondary>in the FROM clause</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm zone="queries-lateral">
     <primary>LATERAL</primary>
     <secondary>在FROM子句中</secondary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     Subqueries appearing in <literal>FROM</literal> can be
     preceded by the key word <literal>LATERAL</literal>.  This allows them to
     reference columns provided by preceding <literal>FROM</literal> items.
     (Without <literal>LATERAL</literal>, each subquery is
     evaluated independently and so cannot cross-reference any other
     <literal>FROM</literal> item.)
    </para>
____________________________________________________________________________-->
    <para>
     可以在出现于<literal>FROM</literal>中的子查询前放置关键词<literal>LATERAL</literal>。这允许它们引用前面的<literal>FROM</literal>项提供的列（如果没有<literal>LATERAL</literal>，每一个子查询将被独立计算，并且因此不能被其他<literal>FROM</literal>项交叉引用）。
    </para>

<!--==========================orignal english content==========================
    <para>
     Table functions appearing in <literal>FROM</literal> can also be
     preceded by the key word <literal>LATERAL</literal>, but for functions the
     key word is optional; the function's arguments can contain references
     to columns provided by preceding <literal>FROM</literal> items in any case.
    </para>
____________________________________________________________________________-->
    <para>
     出现在<literal>FROM</literal>中的表函数的前面也可以被放上关键词<literal>LATERAL</literal>，但对于函数该关键词是可选的，在任何情况下函数的参数都可以包含对前面的<literal>FROM</literal>项提供的列的引用。
    </para>

<!--==========================orignal english content==========================
    <para>
     A <literal>LATERAL</literal> item can appear at top level in the
     <literal>FROM</literal> list, or within a <literal>JOIN</literal> tree.  In the latter
     case it can also refer to any items that are on the left-hand side of a
     <literal>JOIN</literal> that it is on the right-hand side of.
    </para>
____________________________________________________________________________-->
    <para>
     一个<literal>LATERAL</literal>项可以出现在<literal>FROM</literal>列表顶层，或者出现在一个<literal>JOIN</literal>树中。在后一种情况下，如果它出现在<literal>JOIN</literal>的右部，那么它也可以引用 在<literal>JOIN</literal>左部的任何项。
    </para>

<!--==========================orignal english content==========================
    <para>
     When a <literal>FROM</literal> item contains <literal>LATERAL</literal>
     cross-references, evaluation proceeds as follows: for each row of the
     <literal>FROM</literal> item providing the cross-referenced column(s), or
     set of rows of multiple <literal>FROM</literal> items providing the
     columns, the <literal>LATERAL</literal> item is evaluated using that
     row or row set's values of the columns.  The resulting row(s) are
     joined as usual with the rows they were computed from.  This is
     repeated for each row or set of rows from the column source table(s).
    </para>
____________________________________________________________________________-->
    <para>
     如果一个<literal>FROM</literal>项包含<literal>LATERAL</literal>交叉引用，计算过程如下：对于提供交叉引用列的<literal>FROM</literal>项的每一行，或者多个提供这些列的多个<literal>FROM</literal>项的行集合，<literal>LATERAL</literal>项将被使用该行或者行集中的列值进行计算。得到的结果行将和它们被计算出来的行进行正常的连接。对于来自这些列的源表的每一行或行集，该过程将重复。
    </para>

<!--==========================orignal english content==========================
    <para>
     A trivial example of <literal>LATERAL</literal> is
<programlisting>
SELECT * FROM foo, LATERAL (SELECT * FROM bar WHERE bar.id = foo.bar_id) ss;
</programlisting>
     This is not especially useful since it has exactly the same result as
     the more conventional
<programlisting>
SELECT * FROM foo, bar WHERE bar.id = foo.bar_id;
</programlisting>
     <literal>LATERAL</literal> is primarily useful when the cross-referenced
     column is necessary for computing the row(s) to be joined.  A common
     application is providing an argument value for a set-returning function.
     For example, supposing that <function>vertices(polygon)</function> returns the
     set of vertices of a polygon, we could identify close-together vertices
     of polygons stored in a table with:
<programlisting>
SELECT p1.id, p2.id, v1, v2
FROM polygons p1, polygons p2,
     LATERAL vertices(p1.poly) v1,
     LATERAL vertices(p2.poly) v2
WHERE (v1 &lt;-&gt; v2) &lt; 10 AND p1.id != p2.id;
</programlisting>
     This query could also be written
<programlisting>
SELECT p1.id, p2.id, v1, v2
FROM polygons p1 CROSS JOIN LATERAL vertices(p1.poly) v1,
     polygons p2 CROSS JOIN LATERAL vertices(p2.poly) v2
WHERE (v1 &lt;-&gt; v2) &lt; 10 AND p1.id != p2.id;
</programlisting>
     or in several other equivalent formulations.  (As already mentioned,
     the <literal>LATERAL</literal> key word is unnecessary in this example, but
     we use it for clarity.)
    </para>
____________________________________________________________________________-->
    <para>
     <literal>LATERAL</literal>的一个简单例子：
<programlisting>
SELECT * FROM foo, LATERAL (SELECT * FROM bar WHERE bar.id = foo.bar_id) ss;
</programlisting>
     这不是非常有用，因为它和一种更简单的形式得到的结果完全一样：
<programlisting>
SELECT * FROM foo, bar WHERE bar.id = foo.bar_id;
</programlisting>
     在必须要使用交叉引用列来计算那些即将要被连接的行时，<literal>LATERAL</literal>是最有用的。一种常用的应用是为一个返回集合的函数提供一个参数值。例如，假设<function>vertices(polygon)</function>返回一个多边形的顶点集合，我们可以这样标识存储在一个表中的多边形中靠近的顶点：
<programlisting>
SELECT p1.id, p2.id, v1, v2
FROM polygons p1, polygons p2,
     LATERAL vertices(p1.poly) v1,
     LATERAL vertices(p2.poly) v2
WHERE (v1 &lt;-&gt; v2) &lt; 10 AND p1.id != p2.id;
</programlisting>
     这个查询也可以被写成：
<programlisting>
SELECT p1.id, p2.id, v1, v2
FROM polygons p1 CROSS JOIN LATERAL vertices(p1.poly) v1,
     polygons p2 CROSS JOIN LATERAL vertices(p2.poly) v2
WHERE (v1 &lt;-&gt; v2) &lt; 10 AND p1.id != p2.id;
</programlisting>
     或者写成其他几种等价的公式（正如以上提到的，<literal>LATERAL</literal>关键词在这个例子中并不是必不可少的，但是我们在这里使用它是为了使表述更清晰）。
    </para>

<!--==========================orignal english content==========================
    <para>
     It is often particularly handy to <literal>LEFT JOIN</literal> to a
     <literal>LATERAL</literal> subquery, so that source rows will appear in
     the result even if the <literal>LATERAL</literal> subquery produces no
     rows for them.  For example, if <function>get_product_names()</function> returns
     the names of products made by a manufacturer, but some manufacturers in
     our table currently produce no products, we could find out which ones
     those are like this:
<programlisting>
SELECT m.name
FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true
WHERE pname IS NULL;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     有时候也会很特别地把<literal>LEFT JOIN</literal>放在一个<literal>LATERAL</literal>子查询的前面，这样即使<literal>LATERAL</literal>子查询对源行不产生行，源行也会出现在结果中。例如，如果<function>get_product_names()</function>返回一个制造商制造的产品的名字，但是某些制造商在我们的表中目前没有制造产品，我们可以找出哪些制造商是这样：
<programlisting>
SELECT m.name
FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true
WHERE pname IS NULL;
</programlisting>
    </para>
   </sect3>
  </sect2>

  <sect2 id="queries-where">
<!--==========================orignal english content==========================
   <title>The <literal>WHERE</literal> Clause</title>
____________________________________________________________________________-->
   <title><literal>WHERE</literal>子句</title>

<!--==========================orignal english content==========================
   <indexterm zone="queries-where">
    <primary>WHERE</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="queries-where">
    <primary>WHERE</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The syntax of the <xref linkend="sql-where"
    endterm="sql-where-title"/> is
<synopsis>
WHERE <replaceable>search_condition</replaceable>
</synopsis>
    where <replaceable>search_condition</replaceable> is any value
    expression (see <xref linkend="sql-expressions"/>) that
    returns a value of type <type>boolean</type>.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="sql-where" endterm="sql-where-title"/>的语法是
<synopsis>
WHERE <replaceable>search_condition</replaceable>
</synopsis>
    这里的<replaceable>search_condition</replaceable>是任意返回一个<type>boolean</type>类型值的值表达式（参阅<xref linkend="sql-expressions"/>）。
   </para>

<!--==========================orignal english content==========================
   <para>
    After the processing of the <literal>FROM</literal> clause is done, each
    row of the derived virtual table is checked against the search
    condition.  If the result of the condition is true, the row is
    kept in the output table, otherwise (i.e., if the result is
    false or null) it is discarded.  The search condition typically
    references at least one column of the table generated in the
    <literal>FROM</literal> clause; this is not required, but otherwise the
    <literal>WHERE</literal> clause will be fairly useless.
   </para>
____________________________________________________________________________-->
   <para>
    在完成对<literal>FROM</literal>子句的处理之后，生成的虚拟表的每一行都会对根据搜索条件进行检查。 如果该条件的结果是真，那么该行被保留在输出表中；否则（也就是说，如果结果是假或空）就把它抛弃。搜索条件通常至少要引用一些在<literal>FROM</literal>子句里生成的列；虽然这不是必须的，但如果不引用这些列，那么<literal>WHERE</literal>子句就没什么用了。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     The join condition of an inner join can be written either in
     the <literal>WHERE</literal> clause or in the <literal>JOIN</literal> clause.
     For example, these table expressions are equivalent:
<programlisting>
FROM a, b WHERE a.id = b.id AND b.val &gt; 5
</programlisting>
     and:
<programlisting>
FROM a INNER JOIN b ON (a.id = b.id) WHERE b.val &gt; 5
</programlisting>
     or perhaps even:
<programlisting>
FROM a NATURAL JOIN b WHERE b.val &gt; 5
</programlisting>
     Which one of these you use is mainly a matter of style.  The
     <literal>JOIN</literal> syntax in the <literal>FROM</literal> clause is
     probably not as portable to other SQL database management systems,
     even though it is in the SQL standard.  For
     outer joins there is no choice:  they must be done in
     the <literal>FROM</literal> clause.  The <literal>ON</literal> or <literal>USING</literal>
     clause of an outer join is <emphasis>not</emphasis> equivalent to a
     <literal>WHERE</literal> condition, because it results in the addition
     of rows (for unmatched input rows) as well as the removal of rows
     in the final result.
    </para>
____________________________________________________________________________-->
    <para>
     内连接的连接条件既可以写在<literal>WHERE</literal>子句也可以写在<literal>JOIN</literal>子句里。例如，这些表表达式是等效的：
<programlisting>
FROM a, b WHERE a.id = b.id AND b.val &gt; 5
</programlisting>
     和：
<programlisting>
FROM a INNER JOIN b ON (a.id = b.id) WHERE b.val &gt; 5
</programlisting>
     或者可能还有：
<programlisting>
FROM a NATURAL JOIN b WHERE b.val &gt; 5
</programlisting>
     你想用哪个只是一个风格问题。<literal>FROM</literal>子句里的<literal>JOIN</literal>语法可能不那么容易移植到其它SQL数据库管理系统中。 对于外部连接而言没有选择：它们必须在<literal>FROM</literal>子句中完成。 外部连接的<literal>ON</literal>或<literal>USING</literal>子句<emphasis>不</emphasis>等于<literal>WHERE</literal>条件，因为它导致最终结果中行的增加（对那些不匹配的输入行）和减少。
    </para>
   </note>

<!--==========================orignal english content==========================
   <para>
    Here are some examples of <literal>WHERE</literal> clauses:
<programlisting>
SELECT ... FROM fdt WHERE c1 &gt; 5

SELECT ... FROM fdt WHERE c1 IN (1, 2, 3)

SELECT ... FROM fdt WHERE c1 IN (SELECT c1 FROM t2)

SELECT ... FROM fdt WHERE c1 IN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10)

SELECT ... FROM fdt WHERE c1 BETWEEN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10) AND 100

SELECT ... FROM fdt WHERE EXISTS (SELECT c1 FROM t2 WHERE c2 &gt; fdt.c1)
</programlisting>
    <literal>fdt</literal> is the table derived in the
    <literal>FROM</literal> clause. Rows that do not meet the search
    condition of the <literal>WHERE</literal> clause are eliminated from
    <literal>fdt</literal>. Notice the use of scalar subqueries as
    value expressions.  Just like any other query, the subqueries can
    employ complex table expressions.  Notice also how
    <literal>fdt</literal> is referenced in the subqueries.
    Qualifying <literal>c1</literal> as <literal>fdt.c1</literal> is only necessary
    if <literal>c1</literal> is also the name of a column in the derived
    input table of the subquery.  But qualifying the column name adds
    clarity even when it is not needed.  This example shows how the column
    naming scope of an outer query extends into its inner queries.
   </para>
____________________________________________________________________________-->
   <para>
    这里是一些<literal>WHERE</literal>子句的例子：
<programlisting>
SELECT ... FROM fdt WHERE c1 &gt; 5

SELECT ... FROM fdt WHERE c1 IN (1, 2, 3)

SELECT ... FROM fdt WHERE c1 IN (SELECT c1 FROM t2)

SELECT ... FROM fdt WHERE c1 IN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10)

SELECT ... FROM fdt WHERE c1 BETWEEN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10) AND 100

SELECT ... FROM fdt WHERE EXISTS (SELECT c1 FROM t2 WHERE c2 &gt; fdt.c1)
</programlisting>
    在上面的例子里，<literal>fdt</literal>是从FROM子句中派生的表。 那些不符合<literal>WHERE</literal>子句的搜索条件的行会被从<literal>fdt</literal>中删除。请注意我们把标量子查询当做一个值表达式来用。 和任何其它查询一样，子查询里可以使用复杂的表表达式。同时还请注意<literal>fdt</literal>在子查询中也被引用。只有在<literal>c1</literal>也是作为子查询输入表的生成表的列时，才必须把<literal>c1</literal>限定成<literal>fdt.c1</literal>。但限定列名字可以增加语句的清晰度，即使有时候不是必须的。这个例子展示了一个外层查询的列名范围如何扩展到它的内层查询。
   </para>
  </sect2>


  <sect2 id="queries-group">
<!--==========================orignal english content==========================
   <title>The <literal>GROUP BY</literal> and <literal>HAVING</literal> Clauses</title>
____________________________________________________________________________-->
   <title><literal>GROUP BY</literal>和<literal>HAVING</literal>子句</title>

<!--==========================orignal english content==========================
   <indexterm zone="queries-group">
    <primary>GROUP BY</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="queries-group">
    <primary>GROUP BY</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="queries-group">
    <primary>grouping</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="queries-group">
    <primary>分组</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    After passing the <literal>WHERE</literal> filter, the derived input
    table might be subject to grouping, using the <literal>GROUP BY</literal>
    clause, and elimination of group rows using the <literal>HAVING</literal>
    clause.
   </para>
____________________________________________________________________________-->
   <para>
    在通过了<literal>WHERE</literal>过滤器之后，生成的输入表可以使用<literal>GROUP BY</literal>子句进行分组，然后用<literal>HAVING</literal>子句删除一些分组行。
   </para>

<!--==========================orignal english content==========================
<synopsis>
SELECT <replaceable>select_list</replaceable>
    FROM ...
    <optional>WHERE ...</optional>
    GROUP BY <replaceable>grouping_column_reference</replaceable> <optional>, <replaceable>grouping_column_reference</replaceable></optional>...
</synopsis>
____________________________________________________________________________-->
<synopsis>
SELECT <replaceable>select_list</replaceable>
    FROM ...
    <optional>WHERE ...</optional>
    GROUP BY <replaceable>grouping_column_reference</replaceable> <optional>, <replaceable>grouping_column_reference</replaceable></optional>...
</synopsis>

<!--==========================orignal english content==========================
   <para>
    The <xref linkend="sql-groupby" endterm="sql-groupby-title"/> is
    used to group together those rows in a table that have the same
    values in all the columns listed. The order in which the columns
    are listed does not matter.  The effect is to combine each set
    of rows having common values into one group row that
    represents all rows in the group.  This is done to
    eliminate redundancy in the output and/or compute aggregates that
    apply to these groups.  For instance:
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM test1;</userinput>
 x | y
-&minus;-+-&minus;-
 a | 3
 c | 2
 b | 5
 a | 1
(4 rows)

<prompt>=&gt;</prompt> <userinput>SELECT x FROM test1 GROUP BY x;</userinput>
 x
-&minus;-
 a
 b
 c
(3 rows)
</screen>
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="sql-groupby" endterm="sql-groupby-title"/>被用来把表中在所列出的列上具有相同值的行分组在一起。 这些列的列出顺序并没有什么关系。其效果是把每组具有相同值的行组合为一个组行，它代表该组里的所有行。 这样就可以删除输出里的重复和/或计算应用于这些组的聚集。例如：
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM test1;</userinput>
 x | y
---+---
 a | 3
 c | 2
 b | 5
 a | 1
(4 rows)

<prompt>=&gt;</prompt> <userinput>SELECT x FROM test1 GROUP BY x;</userinput>
 x
---
 a
 b
 c
(3 rows)
</screen>
   </para>

<!--==========================orignal english content==========================
   <para>
    In the second query, we could not have written <literal>SELECT *
    FROM test1 GROUP BY x</literal>, because there is no single value
    for the column <literal>y</literal> that could be associated with each
    group.  The grouped-by columns can be referenced in the select list since
    they have a single value in each group.
   </para>
____________________________________________________________________________-->
   <para>
    在第二个查询里，我们不能写成<literal>SELECT * FROM test1 GROUP BY x</literal>， 因为列<literal>y</literal>里没有哪个值可以和每个组相关联起来。被分组的列可以在选择列表中引用是因为它们在每个组都有单一的值。
   </para>

<!--==========================orignal english content==========================
   <para>
    In general, if a table is grouped, columns that are not
    listed in <literal>GROUP BY</literal> cannot be referenced except in aggregate
    expressions.  An example with aggregate expressions is:
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x;</userinput>
 x | sum
-&minus;-+-&minus;-&minus;-
 a |   4
 b |   5
 c |   2
(3 rows)
</screen>
    Here <literal>sum</literal> is an aggregate function that
    computes a single value over the entire group.  More information
    about the available aggregate functions can be found in <xref
    linkend="functions-aggregate"/>.
   </para>
____________________________________________________________________________-->
   <para>
    通常，如果一个表被分了组，那么没有在<literal>GROUP BY</literal>中列出的列都不能被引用，除非在聚集表达式中被引用。 一个用聚集表达式的例子是：
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x;</userinput>
 x | sum
---+-----
 a |   4
 b |   5
 c |   2
(3 rows)
</screen>
    这里的<literal>sum</literal>是一个聚集函数，它在整个组上计算出一个单一值。有关可用的聚集函数的更多信息可以在<xref linkend="functions-aggregate"/>。
   </para>

   <tip>
<!--==========================orignal english content==========================
    <para>
     Grouping without aggregate expressions effectively calculates the
     set of distinct values in a column.  This can also be achieved
     using the <literal>DISTINCT</literal> clause (see <xref
     linkend="queries-distinct"/>).
    </para>
____________________________________________________________________________-->
    <para>
     没有聚集表达式的分组实际上计算了一个列中可区分值的集合。我们也可以用<literal>DISTINCT</literal>子句实现（参阅<xref linkend="queries-distinct"/>）。
    </para>
   </tip>

<!--==========================orignal english content==========================
   <para>
    Here is another example:  it calculates the total sales for each
    product (rather than the total sales of all products):
<programlisting>
SELECT product_id, p.name, (sum(s.units) * p.price) AS sales
    FROM products p LEFT JOIN sales s USING (product_id)
    GROUP BY product_id, p.name, p.price;
</programlisting>
    In this example, the columns <literal>product_id</literal>,
    <literal>p.name</literal>, and <literal>p.price</literal> must be
    in the <literal>GROUP BY</literal> clause since they are referenced in
    the query select list (but see below).  The column
    <literal>s.units</literal> does not have to be in the <literal>GROUP
    BY</literal> list since it is only used in an aggregate expression
    (<literal>sum(...)</literal>), which represents the sales
    of a product.  For each product, the query returns a summary row about
    all sales of the product.
   </para>
____________________________________________________________________________-->
   <para>
    这里是另外一个例子：它计算每种产品的总销售额（而不是所有产品的总销售额）：
<programlisting>
SELECT product_id, p.name, (sum(s.units) * p.price) AS sales
    FROM products p LEFT JOIN sales s USING (product_id)
    GROUP BY product_id, p.name, p.price;
</programlisting>
    在这个例子里，列<literal>product_id</literal>、<literal>p.name</literal>和<literal>p.price</literal>必须在<literal>GROUP BY</literal>子句里， 因为它们都在查询的选择列表里被引用到（但见下文）。列<literal>s.units</literal>不必在<literal>GROUP BY</literal>列表里，因为它只是在一个聚集表达式（<literal>sum(...)</literal>）里使用，它代表一组产品的销售额。对于每种产品，这个查询都返回一个该产品的所有销售额的总和行。
   </para>

<!--==========================orignal english content==========================
   <indexterm><primary>functional dependency</primary></indexterm>
____________________________________________________________________________-->
   <indexterm><primary>函数依赖</primary></indexterm>

<!--==========================orignal english content==========================
   <para>
    If the products table is set up so that, say,
    <literal>product_id</literal> is the primary key, then it would be
    enough to group by <literal>product_id</literal> in the above example,
    since name and price would be <firstterm>functionally
    dependent</firstterm> on the product ID, and so there would be no
    ambiguity about which name and price value to return for each product
    ID group.
   </para>
____________________________________________________________________________-->
   <para>
    如果产品表被建立起来，例如<literal>product_id</literal>是主键，那么在上面的例子中用<literal>product_id</literal>来分组就够了，因为名称和价格都是<firstterm>函数依赖</firstterm>于产品ID，并且关于为每个产品ID分组返回哪个名称和价格值就不会有歧义。
   </para>

<!--==========================orignal english content==========================
   <para>
    In strict SQL, <literal>GROUP BY</literal> can only group by columns of
    the source table but <productname>PostgreSQL</productname> extends
    this to also allow <literal>GROUP BY</literal> to group by columns in the
    select list.  Grouping by value expressions instead of simple
    column names is also allowed.
   </para>
____________________________________________________________________________-->
   <para>
    在严格的 SQL 里，<literal>GROUP BY</literal>只能对源表的列进行分组，但<productname>PostgreSQL</productname>把这个扩展为也允许<literal>GROUP BY</literal>去根据选择列表中的列分组。也允许对值表达式进行分组，而不仅是简单的列名。
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>HAVING</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>HAVING</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    If a table has been grouped using <literal>GROUP BY</literal>,
    but only certain groups are of interest, the
    <literal>HAVING</literal> clause can be used, much like a
    <literal>WHERE</literal> clause, to eliminate groups from the result.
    The syntax is:
<synopsis>
SELECT <replaceable>select_list</replaceable> FROM ... <optional>WHERE ...</optional> GROUP BY ... HAVING <replaceable>boolean_expression</replaceable>
</synopsis>
    Expressions in the <literal>HAVING</literal> clause can refer both to
    grouped expressions and to ungrouped expressions (which necessarily
    involve an aggregate function).
   </para>
____________________________________________________________________________-->
   <para>
    如果一个表已经用<literal>GROUP BY</literal>子句分了组，然后你又只对其中的某些组感兴趣， 那么就可以用<literal>HAVING</literal>子句，它很象<literal>WHERE</literal>子句，用于从结果中删除一些组。其语法是：
<synopsis>
SELECT <replaceable>select_list</replaceable> FROM ... <optional>WHERE ...</optional> GROUP BY ... HAVING <replaceable>boolean_expression</replaceable>
</synopsis>
    在<literal>HAVING</literal>子句中的表达式可以引用分组的表达式和未分组的表达式（后者必须涉及一个聚集函数）。
   </para>

<!--==========================orignal english content==========================
   <para>
    Example:
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x HAVING sum(y) &gt; 3;</userinput>
 x | sum
-&minus;-+-&minus;-&minus;-
 a |   4
 b |   5
(2 rows)

<prompt>=&gt;</prompt> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x HAVING x &lt; 'c';</userinput>
 x | sum
-&minus;-+-&minus;-&minus;-
 a |   4
 b |   5
(2 rows)
</screen>
   </para>
____________________________________________________________________________-->
   <para>
    例子：
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x HAVING sum(y) &gt; 3;</userinput>
 x | sum
---+-----
 a |   4
 b |   5
(2 rows)

<prompt>=&gt;</prompt> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x HAVING x &lt; 'c';</userinput>
 x | sum
---+-----
 a |   4
 b |   5
(2 rows)
</screen>
   </para>

<!--==========================orignal english content==========================
   <para>
    Again, a more realistic example:
<programlisting>
SELECT product_id, p.name, (sum(s.units) * (p.price - p.cost)) AS profit
    FROM products p LEFT JOIN sales s USING (product_id)
    WHERE s.date &gt; CURRENT_DATE - INTERVAL '4 weeks'
    GROUP BY product_id, p.name, p.price, p.cost
    HAVING sum(p.price * s.units) &gt; 5000;
</programlisting>
    In the example above, the <literal>WHERE</literal> clause is selecting
    rows by a column that is not grouped (the expression is only true for
    sales during the last four weeks), while the <literal>HAVING</literal>
    clause restricts the output to groups with total gross sales over
    5000.  Note that the aggregate expressions do not necessarily need
    to be the same in all parts of the query.
   </para>
____________________________________________________________________________-->
   <para>
    再次，一个更现实的例子：
<programlisting>
SELECT product_id, p.name, (sum(s.units) * (p.price - p.cost)) AS profit
    FROM products p LEFT JOIN sales s USING (product_id)
    WHERE s.date &gt; CURRENT_DATE - INTERVAL '4 weeks'
    GROUP BY product_id, p.name, p.price, p.cost
    HAVING sum(p.price * s.units) &gt; 5000;
</programlisting>
    在上面的例子里，<literal>WHERE</literal>子句用那些非分组的列选择数据行（表达式只是对那些最近四周发生的销售为真）。 而<literal>HAVING</literal>子句限制输出为总销售收入超过 5000 的组。请注意聚集表达式不需要在查询中的所有地方都一样。
   </para>

<!--==========================orignal english content==========================
   <para>
    If a query contains aggregate function calls, but no <literal>GROUP BY</literal>
    clause, grouping still occurs: the result is a single group row (or
    perhaps no rows at all, if the single row is then eliminated by
    <literal>HAVING</literal>).
    The same is true if it contains a <literal>HAVING</literal> clause, even
    without any aggregate function calls or <literal>GROUP BY</literal> clause.
   </para>
____________________________________________________________________________-->
   <para>
    如果一个查询包含聚集函数调用，但是没有<literal>GROUP BY</literal>子句，分组仍然会发生：结果是一个单一行（或者根本就没有行，如果该单一行被<literal>HAVING</literal>所消除）。它包含一个<literal>HAVING</literal>子句时也是这样，即使没有任何聚集函数调用或者<literal>GROUP BY</literal>子句。
   </para>
  </sect2>

  <sect2 id="queries-grouping-sets">
<!--==========================orignal english content==========================
   <title><literal>GROUPING SETS</literal>, <literal>CUBE</literal>, and <literal>ROLLUP</literal></title>
____________________________________________________________________________-->
   <title><literal>GROUPING SETS</literal>、<literal>CUBE</literal>和<literal>ROLLUP</literal></title>

<!--==========================orignal english content==========================
   <indexterm zone="queries-grouping-sets">
    <primary>GROUPING SETS</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="queries-grouping-sets">
    <primary>GROUPING SETS</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm zone="queries-grouping-sets">
    <primary>CUBE</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="queries-grouping-sets">
    <primary>CUBE</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm zone="queries-grouping-sets">
    <primary>ROLLUP</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="queries-grouping-sets">
    <primary>ROLLUP</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    More complex grouping operations than those described above are possible
    using the concept of <firstterm>grouping sets</firstterm>.  The data selected by
    the <literal>FROM</literal> and <literal>WHERE</literal> clauses is grouped separately
    by each specified grouping set, aggregates computed for each group just as
    for simple <literal>GROUP BY</literal> clauses, and then the results returned.
    For example:
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM items_sold;</userinput>
 brand | size | sales
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-
 Foo   | L    |  10
 Foo   | M    |  20
 Bar   | M    |  15
 Bar   | L    |  5
(4 rows)

<prompt>=&gt;</prompt> <userinput>SELECT brand, size, sum(sales) FROM items_sold GROUP BY GROUPING SETS ((brand), (size), ());</userinput>
 brand | size | sum
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-
 Foo   |      |  30
 Bar   |      |  20
       | L    |  15
       | M    |  35
       |      |  50
(5 rows)
</screen>
   </para>
____________________________________________________________________________-->
   <para>
    使用<firstterm>分组集</firstterm>的概念可以实现比上述更加复杂的分组操作。由
    <literal>FROM</literal>和<literal>WHERE</literal>子句选出的数据被按照每一个指定
    的分组集单独分组，按照简单<literal>GROUP BY</literal>子句对每一个分组计算
    聚集，然后返回结果。例如：
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM items_sold;</userinput>
 brand | size | sales
-------+------+-------
 Foo   | L    |  10
 Foo   | M    |  20
 Bar   | M    |  15
 Bar   | L    |  5
(4 rows)

<prompt>=&gt;</prompt> <userinput>SELECT brand, size, sum(sales) FROM items_sold GROUP BY GROUPING SETS ((brand), (size), ());</userinput>
 brand | size | sum
-------+------+-----
 Foo   |      |  30
 Bar   |      |  20
       | L    |  15
       | M    |  35
       |      |  50
(5 rows)
</screen>
   </para>

<!--==========================orignal english content==========================
   <para>
    Each sublist of <literal>GROUPING SETS</literal> may specify zero or more columns
    or expressions and is interpreted the same way as though it were directly
    in the <literal>GROUP BY</literal> clause.  An empty grouping set means that all
    rows are aggregated down to a single group (which is output even if no
    input rows were present), as described above for the case of aggregate
    functions with no <literal>GROUP BY</literal> clause.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>GROUPING SETS</literal>的每一个子列表可以指定一个或者多个列或者表达式，
    它们将按照直接出现在<literal>GROUP BY</literal>子句中同样的方式被解释。一个空的
    分组集表示所有的行都要被聚集到一个单一分组（即使没有输入行存在也会被输出）
    中，这就像前面所说的没有<literal>GROUP BY</literal>子句的聚集函数的情况一样。
   </para>

<!--==========================orignal english content==========================
   <para>
    References to the grouping columns or expressions are replaced
    by null values in result rows for grouping sets in which those
    columns do not appear.  To distinguish which grouping a particular output
    row resulted from, see <xref linkend="functions-grouping-table"/>.
   </para>
____________________________________________________________________________-->
   <para>
    对于分组列或表达式没有出现在其中的分组集的结果行，对分组列或表达式的引用会
    被空值所替代。要区分一个特定的输出行来自于哪个分组，请见
    <xref linkend="functions-grouping-table"/>。
   </para>

<!--==========================orignal english content==========================
   <para>
    A shorthand notation is provided for specifying two common types of grouping set.
    A clause of the form
<programlisting>
ROLLUP ( <replaceable>e1</replaceable>, <replaceable>e2</replaceable>, <replaceable>e3</replaceable>, ... )
</programlisting>
    represents the given list of expressions and all prefixes of the list including
    the empty list; thus it is equivalent to
<programlisting>
GROUPING SETS (
    ( <replaceable>e1</replaceable>, <replaceable>e2</replaceable>, <replaceable>e3</replaceable>, ... ),
    ...
    ( <replaceable>e1</replaceable>, <replaceable>e2</replaceable> ),
    ( <replaceable>e1</replaceable> ),
    ( )
)
</programlisting>
    This is commonly used for analysis over hierarchical data; e.g. total
    salary by department, division, and company-wide total.
   </para>
____________________________________________________________________________-->
   <para>
    PostgreSQL 中提供了一种简化方法来指定两种常用类型的分组集。下面形式的子句
<programlisting>
ROLLUP ( <replaceable>e1</replaceable>, <replaceable>e2</replaceable>, <replaceable>e3</replaceable>, ... )
</programlisting>
    表示给定的表达式列表及其所有前缀（包括空列表），因此它等效于
<programlisting>
GROUPING SETS (
    ( <replaceable>e1</replaceable>, <replaceable>e2</replaceable>, <replaceable>e3</replaceable>, ... ),
    ...
    ( <replaceable>e1</replaceable>, <replaceable>e2</replaceable> ),
    ( <replaceable>e1</replaceable> ),
    ( )
)
</programlisting>
    这通常被用来分析历史数据，例如按部门、区和公司范围计算的总薪水。
   </para>

<!--==========================orignal english content==========================
   <para>
    A clause of the form
<programlisting>
CUBE ( <replaceable>e1</replaceable>, <replaceable>e2</replaceable>, ... )
</programlisting>
    represents the given list and all of its possible subsets (i.e. the power
    set).  Thus
<programlisting>
CUBE ( a, b, c )
</programlisting>
    is equivalent to
<programlisting>
GROUPING SETS (
    ( a, b, c ),
    ( a, b    ),
    ( a,    c ),
    ( a       ),
    (    b, c ),
    (    b    ),
    (       c ),
    (         )
)
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    下面形式的子句
<programlisting>
CUBE ( <replaceable>e1</replaceable>, <replaceable>e2</replaceable>, ... )
</programlisting>
    表示给定的列表及其可能的子集（即幂集）。因此
<programlisting>
CUBE ( a, b, c )
</programlisting>
    等效于
<programlisting>
GROUPING SETS (
    ( a, b, c ),
    ( a, b    ),
    ( a,    c ),
    ( a       ),
    (    b, c ),
    (    b    ),
    (       c ),
    (         )
)
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    The individual elements of a <literal>CUBE</literal> or <literal>ROLLUP</literal>
    clause may be either individual expressions, or sublists of elements in
    parentheses.  In the latter case, the sublists are treated as single
    units for the purposes of generating the individual grouping sets.
    For example:
<programlisting>
CUBE ( (a, b), (c, d) )
</programlisting>
    is equivalent to
<programlisting>
GROUPING SETS (
    ( a, b, c, d ),
    ( a, b       ),
    (       c, d ),
    (            )
)
</programlisting>
    and
<programlisting>
ROLLUP ( a, (b, c), d )
</programlisting>
    is equivalent to
<programlisting>
GROUPING SETS (
    ( a, b, c, d ),
    ( a, b, c    ),
    ( a          ),
    (            )
)
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    <literal>CUBE</literal>或<literal>ROLLUP</literal>子句中的元素可以是表达式或者
    圆括号中的元素子列表。在后一种情况中，对于生成分组集的目的来说，子列
    表被当做单一单元来对待。例如：
<programlisting>
CUBE ( (a, b), (c, d) )
</programlisting>
    等效于
<programlisting>
GROUPING SETS (
    ( a, b, c, d ),
    ( a, b       ),
    (       c, d ),
    (            )
)
</programlisting>
    并且
<programlisting>
ROLLUP ( a, (b, c), d )
</programlisting>
    等效于
<programlisting>
GROUPING SETS (
    ( a, b, c, d ),
    ( a, b, c    ),
    ( a          ),
    (            )
)
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    The <literal>CUBE</literal> and <literal>ROLLUP</literal> constructs can be used either
    directly in the <literal>GROUP BY</literal> clause, or nested inside a
    <literal>GROUPING SETS</literal> clause.  If one <literal>GROUPING SETS</literal> clause
    is nested inside another, the effect is the same as if all the elements of
    the inner clause had been written directly in the outer clause.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>CUBE</literal>和<literal>ROLLUP</literal>可以被直接用在
    <literal>GROUP BY</literal>子句中，也可以被嵌套在一个
    <literal>GROUPING SETS</literal>子句中。如果一个
    <literal>GROUPING SETS</literal>子句被嵌套在另一个同类子句中，
    效果和把内层子句的所有元素直接写在外层子句中一样。
   </para>

<!--==========================orignal english content==========================
   <para>
    If multiple grouping items are specified in a single <literal>GROUP BY</literal>
    clause, then the final list of grouping sets is the cross product of the
    individual items.  For example:
<programlisting>
GROUP BY a, CUBE (b, c), GROUPING SETS ((d), (e))
</programlisting>
    is equivalent to
<programlisting>
GROUP BY GROUPING SETS (
    (a, b, c, d), (a, b, c, e),
    (a, b, d),    (a, b, e),
    (a, c, d),    (a, c, e),
    (a, d),       (a, e)
)
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    如果在一个<literal>GROUP BY</literal>子句中指定了多个分组项，那么最终的
    分组集列表是这些项的叉积。例如：
<programlisting>
GROUP BY a, CUBE (b, c), GROUPING SETS ((d), (e))
</programlisting>
    等效于
<programlisting>
GROUP BY GROUPING SETS (
    (a, b, c, d), (a, b, c, e),
    (a, b, d),    (a, b, e),
    (a, c, d),    (a, c, e),
    (a, d),       (a, e)
)
</programlisting>
   </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    The construct <literal>(a, b)</literal> is normally recognized in expressions as
    a <link linkend="sql-syntax-row-constructors">row constructor</link>.
    Within the <literal>GROUP BY</literal> clause, this does not apply at the top
    levels of expressions, and <literal>(a, b)</literal> is parsed as a list of
    expressions as described above.  If for some reason you <emphasis>need</emphasis>
    a row constructor in a grouping expression, use <literal>ROW(a, b)</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    在表达式中，结构<literal>(a, b)</literal>通常被识别为一个
    a <link linkend="sql-syntax-row-constructors">行构造器</link>。在
    <literal>GROUP BY</literal>子句中，这不会在表达式的顶层应用，并且
    <literal>(a, b)</literal>会按照上面所说的被解析为一个表达式的列表。如果出于
    某种原因你在分组表达式中<emphasis>需要</emphasis>一个行构造器，请使用
    <literal>ROW(a, b)</literal>。
   </para>
  </note>
  </sect2>

  <sect2 id="queries-window">
<!--==========================orignal english content==========================
   <title>Window Function Processing</title>
____________________________________________________________________________-->
   <title>窗口函数处理</title>

<!--==========================orignal english content==========================
   <indexterm zone="queries-window">
    <primary>window function</primary>
    <secondary>order of execution</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="queries-window">
    <primary>窗口函数</primary>
    <secondary>执行顺序</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    If the query contains any window functions (see
    <xref linkend="tutorial-window"/>,
    <xref linkend="functions-window"/> and
    <xref linkend="syntax-window-functions"/>), these functions are evaluated
    after any grouping, aggregation, and <literal>HAVING</literal> filtering is
    performed.  That is, if the query uses any aggregates, <literal>GROUP
    BY</literal>, or <literal>HAVING</literal>, then the rows seen by the window functions
    are the group rows instead of the original table rows from
    <literal>FROM</literal>/<literal>WHERE</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    如果查询包含任何窗口函数（见<xref linkend="tutorial-window"/>、<xref linkend="functions-window"/>和<xref linkend="syntax-window-functions"/>），这些函数将在任何分组、聚集和<literal>HAVING</literal>过滤被执行之后被计算。也就是说如果查询使用了任何聚集、<literal>GROUP BY</literal>或<literal>HAVING</literal>，则窗口函数看到的行是分组行而不是来自于<literal>FROM</literal>/<literal>WHERE</literal>的原始表行。
   </para>

<!--==========================orignal english content==========================
   <para>
    When multiple window functions are used, all the window functions having
    syntactically equivalent <literal>PARTITION BY</literal> and <literal>ORDER BY</literal>
    clauses in their window definitions are guaranteed to be evaluated in a
    single pass over the data. Therefore they will see the same sort ordering,
    even if the <literal>ORDER BY</literal> does not uniquely determine an ordering.
    However, no guarantees are made about the evaluation of functions having
    different <literal>PARTITION BY</literal> or <literal>ORDER BY</literal> specifications.
    (In such cases a sort step is typically required between the passes of
    window function evaluations, and the sort is not guaranteed to preserve
    ordering of rows that its <literal>ORDER BY</literal> sees as equivalent.)
   </para>
____________________________________________________________________________-->
   <para>
    当多个窗口函数被使用，所有在窗口定义中有句法上等效的<literal>PARTITION BY</literal>和<literal>ORDER BY</literal>子句的窗口函数被保证在数据上的同一趟扫描中计算。因此它们将会看到相同的排序顺序，即使<literal>ORDER BY</literal>没有唯一地决定一个顺序。但是，对于具有不同<literal>PARTITION BY</literal>或<literal>ORDER BY</literal>定义的函数的计算没有这种保证（在这种情况中，在多个窗口函数计算之间通常要求一个排序步骤，并且并不保证保留行的顺序，即使它的<literal>ORDER BY</literal>把这些行视为等效的）。
   </para>

<!--==========================orignal english content==========================
   <para>
    Currently, window functions always require presorted data, and so the
    query output will be ordered according to one or another of the window
    functions' <literal>PARTITION BY</literal>/<literal>ORDER BY</literal> clauses.
    It is not recommended to rely on this, however.  Use an explicit
    top-level <literal>ORDER BY</literal> clause if you want to be sure the
    results are sorted in a particular way.
   </para>
____________________________________________________________________________-->
   <para>
    目前，窗口函数总是要求排序好的数据，并且这样查询的输出总是被根据窗口函数的<literal>PARTITION BY</literal>/<literal>ORDER BY</literal>子句的一个或者另一个排序。但是，我们不推荐依赖于此。如果你希望确保结果以特定的方式排序，请显式使用顶层的<literal>ORDER BY</literal>子句。
   </para>
  </sect2>
 </sect1>


 <sect1 id="queries-select-lists">
<!--==========================orignal english content==========================
  <title>Select Lists</title>
____________________________________________________________________________-->
  <title>选择列表</title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>SELECT</primary>
   <secondary>select list</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>SELECT</primary>
   <secondary>选择列表</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   As shown in the previous section,
   the table expression in the <command>SELECT</command> command
   constructs an intermediate virtual table by possibly combining
   tables, views, eliminating rows, grouping, etc.  This table is
   finally passed on to processing by the <firstterm>select list</firstterm>.  The select
   list determines which <emphasis>columns</emphasis> of the
   intermediate table are actually output.
  </para>
____________________________________________________________________________-->
  <para>
   如前面的小节说明的那样， 在<command>SELECT</command>命令里的表表达式构造了一个中间的虚拟表， 方法可能有组合表、视图、消除行、分组等等。这个表最后被<firstterm>选择列表</firstterm>传递下去处理。选择列表判断中间表的哪个<emphasis>列</emphasis>是实际输出。
  </para>

  <sect2 id="queries-select-list-items">
<!--==========================orignal english content==========================
   <title>Select-List Items</title>
____________________________________________________________________________-->
   <title>选择列表项</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>*</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>*</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The simplest kind of select list is <literal>*</literal> which
    emits all columns that the table expression produces.  Otherwise,
    a select list is a comma-separated list of value expressions (as
    defined in <xref linkend="sql-expressions"/>).  For instance, it
    could be a list of column names:
<programlisting>
SELECT a, b, c FROM ...
</programlisting>
     The columns names <literal>a</literal>, <literal>b</literal>, and <literal>c</literal>
     are either the actual names of the columns of tables referenced
     in the <literal>FROM</literal> clause, or the aliases given to them as
     explained in <xref linkend="queries-table-aliases"/>.  The name
     space available in the select list is the same as in the
     <literal>WHERE</literal> clause, unless grouping is used, in which case
     it is the same as in the <literal>HAVING</literal> clause.
   </para>
____________________________________________________________________________-->
   <para>
    最简单的选择列表类型是<literal>*</literal>，它发出表表达式生成的所有列。否则，一个选择列表是一个逗号分隔的值表达式的列表（和在<xref linkend="sql-expressions"/>里定义的一样）。 例如，它可能是一个列名的列表：
<programlisting>
SELECT a, b, c FROM ...
</programlisting>
     列名字<literal>a</literal>、<literal>b</literal>和<literal>c</literal>要么是在<literal>FROM</literal>子句里引用的表中列的实际名字，要么是像<xref linkend="queries-table-aliases"/>里解释的那样的别名。在选择列表里可用的名字空间和在<literal>WHERE</literal>子句里的一样， 除非你使用了分组，这时候它和<literal>HAVING</literal>子句一样。
   </para>

<!--==========================orignal english content==========================
   <para>
    If more than one table has a column of the same name, the table
    name must also be given, as in:
<programlisting>
SELECT tbl1.a, tbl2.a, tbl1.b FROM ...
</programlisting>
    When working with multiple tables, it can also be useful to ask for
    all the columns of a particular table:
<programlisting>
SELECT tbl1.*, tbl2.a FROM ...
</programlisting>
    See <xref linkend="rowtypes-usage"/> for more about
    the <replaceable>table_name</replaceable><literal>.*</literal> notation.
   </para>
____________________________________________________________________________-->
   <para>
    如果超过一个表有同样的列名，那么你还必须给出表名字，如：
<programlisting>
SELECT tbl1.a, tbl2.a, tbl1.b FROM ...
</programlisting>
    在使用多个表时，要求一个特定表的所有列也是有用的：
<programlisting>
SELECT tbl1.*, tbl2.a FROM ...
</programlisting>
    更多有关<replaceable>table_name</replaceable><literal>.*</literal>记号的内容请参考<xref linkend="rowtypes-usage"/>。
   </para>

<!--==========================orignal english content==========================
   <para>
    If an arbitrary value expression is used in the select list, it
    conceptually adds a new virtual column to the returned table.  The
    value expression is evaluated once for each result row, with
    the row's values substituted for any column references.  But the
    expressions in the select list do not have to reference any
    columns in the table expression of the <literal>FROM</literal> clause;
    they can be constant arithmetic expressions, for instance.
   </para>
____________________________________________________________________________-->
   <para>
    如果将任意值表达式用于选择列表，那么它在概念上向返回的表中增加了一个新的虚拟列。 值表达式为结果的每一行进行一次计算，对任何列引用替换行的值。 不过选择列表中的这个表达式并非一定要引用来自<literal>FROM</literal>子句中表表达式里面的列，例如它也可以是任意常量算术表达式。
   </para>
  </sect2>

  <sect2 id="queries-column-labels">
<!--==========================orignal english content==========================
   <title>Column Labels</title>
____________________________________________________________________________-->
   <title>列标签</title>

<!--==========================orignal english content==========================
   <indexterm zone="queries-column-labels">
    <primary>alias</primary>
    <secondary>in the select list</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="queries-column-labels">
    <primary>别名</primary>
    <secondary>在选择列表中</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The entries in the select list can be assigned names for subsequent
    processing, such as for use in an <literal>ORDER BY</literal> clause
    or for display by the client application.  For example:
<programlisting>
SELECT a AS value, b + c AS sum FROM ...
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    选择列表中的项可以被赋予名字，用于进一步的处理。 例如为了在一个<literal>ORDER BY</literal>子句中使用或者为了客户端应用显示。例如：
<programlisting>
SELECT a AS value, b + c AS sum FROM ...
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    If no output column name is specified using <literal>AS</literal>,
    the system assigns a default column name.  For simple column references,
    this is the name of the referenced column.  For function
    calls, this is the name of the function.  For complex expressions,
    the system will generate a generic name.
   </para>
____________________________________________________________________________-->
   <para>
    如果没有使用<literal>AS</literal>指定输出列名，那么系统会分配一个缺省的列名。对于简单的列引用， 它是被引用列的名字。对于函数调用，它是函数的名字。对于复杂表达式，系统会生成一个通用的名字。
   </para>

<!--==========================orignal english content==========================
   <para>
    The <literal>AS</literal> keyword is optional, but only if the new column
    name does not match any
    <productname>PostgreSQL</productname> keyword (see <xref
    linkend="sql-keywords-appendix"/>).  To avoid an accidental match to
    a keyword, you can double-quote the column name.  For example,
    <literal>VALUE</literal> is a keyword, so this does not work:
<programlisting>
SELECT a value, b + c AS sum FROM ...
</programlisting>
    but this does:
<programlisting>
SELECT a "value", b + c AS sum FROM ...
</programlisting>
    For protection against possible
    future keyword additions, it is recommended that you always either
    write <literal>AS</literal> or double-quote the output column name.
   </para>
____________________________________________________________________________-->
   <para>
    只有在新列无法匹配任何<productname>PostgreSQL</productname>关键词（见<xref linkend="sql-keywords-appendix"/>）时，<literal>AS</literal>关键词是可选的。为了避免一个关键字的意外匹配，你可以使用双引号来修饰列名。例如，<literal>VALUE</literal>是一个关键字，所以下面的语句不会工作：
<programlisting>
SELECT a value, b + c AS sum FROM ...
</programlisting>
    但是这个可以：
<programlisting>
SELECT a "value", b + c AS sum FROM ...
</programlisting>
    为了防止未来可能的关键词增加，我们推荐总是写<literal>AS</literal>或者用双引号修饰输出列名。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     The naming of output columns here is different from that done in
     the <literal>FROM</literal> clause (see <xref
     linkend="queries-table-aliases"/>).  It is possible
     to rename the same column twice, but the name assigned in
     the select list is the one that will be passed on.
    </para>
____________________________________________________________________________-->
    <para>
     输出列的命名和在<literal>FROM</literal>子句里的命名是不一样的 （参阅<xref linkend="queries-table-aliases"/>）。 它实际上允许你对同一个列命名两次，但是在选择列表中分配的名字是要传递下去的名字。
    </para>
   </note>
  </sect2>

  <sect2 id="queries-distinct">
<!--==========================orignal english content==========================
   <title><literal>DISTINCT</literal></title>
____________________________________________________________________________-->
   <title><literal>DISTINCT</literal></title>

<!--==========================orignal english content==========================
   <indexterm zone="queries-distinct">
    <primary>DISTINCT</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="queries-distinct">
    <primary>DISTINCT</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="queries-distinct">
    <primary>duplicates</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="queries-distinct">
    <primary>重复</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    After the select list has been processed, the result table can
    optionally be subject to the elimination of duplicate rows.  The
    <literal>DISTINCT</literal> key word is written directly after
    <literal>SELECT</literal> to specify this:
<synopsis>
SELECT DISTINCT <replaceable>select_list</replaceable> ...
</synopsis>
    (Instead of <literal>DISTINCT</literal> the key word <literal>ALL</literal>
    can be used to specify the default behavior of retaining all rows.)
   </para>
____________________________________________________________________________-->
   <para>
    在处理完选择列表之后，结果表可以可选的删除重复行。我们可以直接在<literal>SELECT</literal>后面写上<literal>DISTINCT</literal>关键字来指定：
<synopsis>
SELECT DISTINCT <replaceable>select_list</replaceable> ...
</synopsis>
    （如果不用<literal>DISTINCT</literal>你可以用<literal>ALL</literal>关键词来指定获得的所有行的缺省行为）。
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>null value</primary>
    <secondary sortas="DISTINCT">in DISTINCT</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>空值</primary>
    <secondary sortas="DISTINCT">in DISTINCT</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    Obviously, two rows are considered distinct if they differ in at
    least one column value.  Null values are considered equal in this
    comparison.
   </para>
____________________________________________________________________________-->
   <para>
    显然，如果两行里至少有一个列有不同的值，那么我们认为它是可区分的。空值在这种比较中被认为是相同的。
   </para>

<!--==========================orignal english content==========================
   <para>
    Alternatively, an arbitrary expression can determine what rows are
    to be considered distinct:
<synopsis>
SELECT DISTINCT ON (<replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ...</optional>) <replaceable>select_list</replaceable> ...
</synopsis>
    Here <replaceable>expression</replaceable> is an arbitrary value
    expression that is evaluated for all rows.  A set of rows for
    which all the expressions are equal are considered duplicates, and
    only the first row of the set is kept in the output.  Note that
    the <quote>first row</quote> of a set is unpredictable unless the
    query is sorted on enough columns to guarantee a unique ordering
    of the rows arriving at the <literal>DISTINCT</literal> filter.
    (<literal>DISTINCT ON</literal> processing occurs after <literal>ORDER
    BY</literal> sorting.)
   </para>
____________________________________________________________________________-->
   <para>
    另外，我们还可以用任意表达式来判断什么行可以被认为是可区分的：
<synopsis>
SELECT DISTINCT ON (<replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ...</optional>) <replaceable>select_list</replaceable> ...
</synopsis>
    这里<replaceable>expression</replaceable>是任意值表达式，它为所有行计算。如果一个行集合里所有表达式的值是一样的， 那么我们认为它们是重复的并且因此只有第一行保留在输出中。请注意这里的一个集合的<quote>第一行</quote>是不可预料的， 除非你在足够多的列上对该查询排了序，保证到达<literal>DISTINCT</literal>过滤器的行的顺序是唯一的（<literal>DISTINCT ON</literal>处理是发生在<literal>ORDER BY</literal>排序后面的）。
   </para>

<!--==========================orignal english content==========================
   <para>
    The <literal>DISTINCT ON</literal> clause is not part of the SQL standard
    and is sometimes considered bad style because of the potentially
    indeterminate nature of its results.  With judicious use of
    <literal>GROUP BY</literal> and subqueries in <literal>FROM</literal>, this
    construct can be avoided, but it is often the most convenient
    alternative.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>DISTINCT ON</literal>子句不是 SQL 标准的一部分， 有时候有人认为它是一个糟糕的风格，因为它的结果是不可判定的。 如果有选择的使用<literal>GROUP BY</literal>和在<literal>FROM</literal>中的子查询，那么我们可以避免使用这个构造， 但是通常它是更方便的候选方法。
   </para>
  </sect2>
 </sect1>


 <sect1 id="queries-union">
<!--==========================orignal english content==========================
  <title>Combining Queries</title>
____________________________________________________________________________-->
  <title>组合查询</title>

<!--==========================orignal english content==========================
  <indexterm zone="queries-union">
   <primary>UNION</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="queries-union">
   <primary>UNION</primary>
  </indexterm>
<!--==========================orignal english content==========================
  <indexterm zone="queries-union">
   <primary>INTERSECT</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="queries-union">
   <primary>INTERSECT</primary>
  </indexterm>
<!--==========================orignal english content==========================
  <indexterm zone="queries-union">
   <primary>EXCEPT</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="queries-union">
   <primary>EXCEPT</primary>
  </indexterm>
<!--==========================orignal english content==========================
  <indexterm zone="queries-union">
   <primary>set union</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="queries-union">
   <primary>集合并</primary>
  </indexterm>
<!--==========================orignal english content==========================
  <indexterm zone="queries-union">
   <primary>set intersection</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="queries-union">
   <primary>集合交</primary>
  </indexterm>
<!--==========================orignal english content==========================
  <indexterm zone="queries-union">
   <primary>set difference</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="queries-union">
   <primary>集合差</primary>
  </indexterm>
<!--==========================orignal english content==========================
  <indexterm zone="queries-union">
   <primary>set operation</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="queries-union">
   <primary>集合操作</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The results of two queries can be combined using the set operations
   union, intersection, and difference.  The syntax is
<synopsis>
<replaceable>query1</replaceable> UNION <optional>ALL</optional> <replaceable>query2</replaceable>
<replaceable>query1</replaceable> INTERSECT <optional>ALL</optional> <replaceable>query2</replaceable>
<replaceable>query1</replaceable> EXCEPT <optional>ALL</optional> <replaceable>query2</replaceable>
</synopsis>
   <replaceable>query1</replaceable> and
   <replaceable>query2</replaceable> are queries that can use any of
   the features discussed up to this point.  Set operations can also
   be nested and chained, for example
<synopsis>
<replaceable>query1</replaceable> UNION <replaceable>query2</replaceable> UNION <replaceable>query3</replaceable>
</synopsis>
   which is executed as:
<synopsis>
(<replaceable>query1</replaceable> UNION <replaceable>query2</replaceable>) UNION <replaceable>query3</replaceable>
</synopsis>
  </para>
____________________________________________________________________________-->
  <para>
   两个查询的结果可以用集合操作并、交、差进行组合。语法是
<synopsis>
<replaceable>query1</replaceable> UNION <optional>ALL</optional> <replaceable>query2</replaceable>
<replaceable>query1</replaceable> INTERSECT <optional>ALL</optional> <replaceable>query2</replaceable>
<replaceable>query1</replaceable> EXCEPT <optional>ALL</optional> <replaceable>query2</replaceable>
</synopsis>
   <replaceable>query1</replaceable>和<replaceable>query2</replaceable>都是可以使用以上所有特性的查询。集合操作也可以嵌套和级连，例如
<synopsis>
<replaceable>query1</replaceable> UNION <replaceable>query2</replaceable> UNION <replaceable>query3</replaceable>
</synopsis>
   实际执行的是：
<synopsis>
(<replaceable>query1</replaceable> UNION <replaceable>query2</replaceable>) UNION <replaceable>query3</replaceable>
</synopsis>
  </para>

<!--==========================orignal english content==========================
  <para>
   <literal>UNION</literal> effectively appends the result of
   <replaceable>query2</replaceable> to the result of
   <replaceable>query1</replaceable> (although there is no guarantee
   that this is the order in which the rows are actually returned).
   Furthermore, it eliminates duplicate rows from its result, in the same
   way as <literal>DISTINCT</literal>, unless <literal>UNION ALL</literal> is used.
  </para>
____________________________________________________________________________-->
  <para>
   <literal>UNION</literal>有效地把<replaceable>query2</replaceable>的结果附加到<replaceable>query1</replaceable>的结果上（不过我们不能保证这就是这些行实际被返回的顺序）。此外，它将删除结果中所有重复的行， 就象<literal>DISTINCT</literal>做的那样，除非你使用了<literal>UNION ALL</literal>。
  </para>

<!--==========================orignal english content==========================
  <para>
   <literal>INTERSECT</literal> returns all rows that are both in the result
   of <replaceable>query1</replaceable> and in the result of
   <replaceable>query2</replaceable>.  Duplicate rows are eliminated
   unless <literal>INTERSECT ALL</literal> is used.
  </para>
____________________________________________________________________________-->
  <para>
   <literal>INTERSECT</literal>返回那些同时存在于<replaceable>query1</replaceable>和<replaceable>query2</replaceable>的结果中的行，除非声明了<literal>INTERSECT ALL</literal>， 否则所有重复行都被消除。
  </para>

<!--==========================orignal english content==========================
  <para>
   <literal>EXCEPT</literal> returns all rows that are in the result of
   <replaceable>query1</replaceable> but not in the result of
   <replaceable>query2</replaceable>.  (This is sometimes called the
   <firstterm>difference</firstterm> between two queries.)  Again, duplicates
   are eliminated unless <literal>EXCEPT ALL</literal> is used.
  </para>
____________________________________________________________________________-->
  <para>
   <literal>EXCEPT</literal>返回所有在<replaceable>query1</replaceable>的结果中但是不在<replaceable>query2</replaceable>的结果中的行（有时侯这叫做两个查询的<firstterm>差</firstterm>）。同样的，除非声明了<literal>EXCEPT ALL</literal>，否则所有重复行都被消除。
  </para>

<!--==========================orignal english content==========================
  <para>
   In order to calculate the union, intersection, or difference of two
   queries, the two queries must be <quote>union compatible</quote>,
   which means that they return the same number of columns and
   the corresponding columns have compatible data types, as
   described in <xref linkend="typeconv-union-case"/>.
  </para>
____________________________________________________________________________-->
  <para>
   为了计算两个查询的并、交、差，这两个查询必须是<quote>并操作兼容的</quote>，也就意味着它们都返回同样数量的列， 并且对应的列有兼容的数据类型，如<xref linkend="typeconv-union-case"/>中描述的那样。
  </para>
 </sect1>


 <sect1 id="queries-order">
<!--==========================orignal english content==========================
  <title>Sorting Rows</title>
____________________________________________________________________________-->
  <title>行排序</title>

<!--==========================orignal english content==========================
  <indexterm zone="queries-order">
   <primary>sorting</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="queries-order">
   <primary>排序</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm zone="queries-order">
   <primary>ORDER BY</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="queries-order">
   <primary>ORDER BY</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   After a query has produced an output table (after the select list
   has been processed) it can optionally be sorted.  If sorting is not
   chosen, the rows will be returned in an unspecified order.  The actual
   order in that case will depend on the scan and join plan types and
   the order on disk, but it must not be relied on.  A particular
   output ordering can only be guaranteed if the sort step is explicitly
   chosen.
  </para>
____________________________________________________________________________-->
  <para>
   在一个查询生成一个输出表之后（在处理完选择列表之后），还可以选择性地对它进行排序。如果没有选择排序，那么行将以未指定的顺序返回。 这时候的实际顺序将取决于扫描和连接计划类型以及行在磁盘上的顺序，但是肯定不能依赖这些东西。一种特定的顺序只能在显式地选择了排序步骤之后才能被保证。
  </para>

<!--==========================orignal english content==========================
  <para>
   The <literal>ORDER BY</literal> clause specifies the sort order:
<synopsis>
SELECT <replaceable>select_list</replaceable>
    FROM <replaceable>table_expression</replaceable>
    ORDER BY <replaceable>sort_expression1</replaceable> <optional>ASC | DESC</optional> <optional>NULLS { FIRST | LAST }</optional>
             <optional>, <replaceable>sort_expression2</replaceable> <optional>ASC | DESC</optional> <optional>NULLS { FIRST | LAST }</optional> ...</optional>
</synopsis>
   The sort expression(s) can be any expression that would be valid in the
   query's select list.  An example is:
<programlisting>
SELECT a, b FROM table1 ORDER BY a + b, c;
</programlisting>
   When more than one expression is specified,
   the later values are used to sort rows that are equal according to the
   earlier values.  Each expression can be followed by an optional
   <literal>ASC</literal> or <literal>DESC</literal> keyword to set the sort direction to
   ascending or descending.  <literal>ASC</literal> order is the default.
   Ascending order puts smaller values first, where
   <quote>smaller</quote> is defined in terms of the
   <literal>&lt;</literal> operator.  Similarly, descending order is
   determined with the <literal>&gt;</literal> operator.
    <footnote>
     <para>
      Actually, <productname>PostgreSQL</productname> uses the <firstterm>default B-tree
      operator class</firstterm> for the expression's data type to determine the sort
      ordering for <literal>ASC</literal> and <literal>DESC</literal>.  Conventionally,
      data types will be set up so that the <literal>&lt;</literal> and
      <literal>&gt;</literal> operators correspond to this sort ordering,
      but a user-defined data type's designer could choose to do something
      different.
     </para>
    </footnote>
  </para>
____________________________________________________________________________-->
  <para>
   <literal>ORDER BY</literal>子句指定了排序顺序：
<synopsis>
SELECT <replaceable>select_list</replaceable>
    FROM <replaceable>table_expression</replaceable>
    ORDER BY <replaceable>sort_expression1</replaceable> <optional>ASC | DESC</optional> <optional>NULLS { FIRST | LAST }</optional>
             <optional>, <replaceable>sort_expression2</replaceable> <optional>ASC | DESC</optional> <optional>NULLS { FIRST | LAST }</optional> ...</optional>
</synopsis>
   排序表达式可以是任何在查询的选择列表中合法的表达式。一个例子是：
<programlisting>
SELECT a, b FROM table1 ORDER BY a + b, c;
</programlisting>
   当多于一个表达式被指定，后面的值将被用于排序那些在前面值上相等的行。每一个表达式后可以选择性地放置一个<literal>ASC</literal>或<literal>DESC</literal>关键词来设置排序方向为升序或降序。<literal>ASC</literal>顺序是默认值。升序会把较小的值放在前面，而<quote>较小</quote>则由<literal>&lt;</literal>操作符定义。相似地，降序则由<literal>&gt;</literal>操作符定义。
    <footnote>
     <para>
      事实上，<productname>PostgreSQL</productname>为表达式的数据类型使用<firstterm>默认B-tree操作符类</firstterm>来决定<literal>ASC</literal>和<literal>DESC</literal>的排序顺序。照惯例，数据类型将被建立，这样<literal>&lt;</literal>和<literal>&gt;</literal>操作符负责这个排序顺序，但是一个用户定义的数据类型的设计者可以选择做些不同的设置。
     </para>
    </footnote>
  </para>

<!--==========================orignal english content==========================
  <para>
   The <literal>NULLS FIRST</literal> and <literal>NULLS LAST</literal> options can be
   used to determine whether nulls appear before or after non-null values
   in the sort ordering.  By default, null values sort as if larger than any
   non-null value; that is, <literal>NULLS FIRST</literal> is the default for
   <literal>DESC</literal> order, and <literal>NULLS LAST</literal> otherwise.
  </para>
____________________________________________________________________________-->
  <para>
   <literal>NULLS FIRST</literal>和<literal>NULLS LAST</literal>选项将可以被用来决定在排序顺序中，空值是出现在非空值之前或者出现在非空值之后。默认情况下，排序时空值被认为比任何非空值都要大，即<literal>NULLS FIRST</literal>是<literal>DESC</literal>顺序的默认值，而不是<literal>NULLS LAST</literal>的默认值。
  </para>

<!--==========================orignal english content==========================
  <para>
   Note that the ordering options are considered independently for each
   sort column.  For example <literal>ORDER BY x, y DESC</literal> means
   <literal>ORDER BY x ASC, y DESC</literal>, which is not the same as
   <literal>ORDER BY x DESC, y DESC</literal>.
  </para>
____________________________________________________________________________-->
  <para>
   注意顺序选项是对每一个排序列独立考虑的。例如<literal>ORDER BY x, y DESC</literal>表示<literal>ORDER BY x ASC, y DESC</literal>，而和<literal>ORDER BY x DESC, y DESC</literal>不同。
  </para>

<!--==========================orignal english content==========================
  <para>
   A <replaceable>sort_expression</replaceable> can also be the column label or number
   of an output column, as in:
<programlisting>
SELECT a + b AS sum, c FROM table1 ORDER BY sum;
SELECT a, max(b) FROM table1 GROUP BY a ORDER BY 1;
</programlisting>
   both of which sort by the first output column.  Note that an output
   column name has to stand alone, that is, it cannot be used in an expression
   &mdash; for example, this is <emphasis>not</emphasis> correct:
<programlisting>
SELECT a + b AS sum, c FROM table1 ORDER BY sum + c;          -&minus; wrong
</programlisting>
   This restriction is made to reduce ambiguity.  There is still
   ambiguity if an <literal>ORDER BY</literal> item is a simple name that
   could match either an output column name or a column from the table
   expression.  The output column is used in such cases.  This would
   only cause confusion if you use <literal>AS</literal> to rename an output
   column to match some other table column's name.
  </para>
____________________________________________________________________________-->
  <para>
   一个<replaceable>sort_expression</replaceable>也可以是列标签或者一个输出列的编号，如：
<programlisting>
SELECT a + b AS sum, c FROM table1 ORDER BY sum;
SELECT a, max(b) FROM table1 GROUP BY a ORDER BY 1;
</programlisting>
   两者都根据第一个输出列排序。注意一个输出列的名字必须孤立，即它不能被用在一个表达式中 &mdash; 例如，这是<emphasis>不</emphasis>正确的：
<programlisting>
SELECT a + b AS sum, c FROM table1 ORDER BY sum + c;          -- 错误
</programlisting>
   该限制是为了减少混淆。如果一个<literal>ORDER BY</literal>项是一个单一名字并且匹配一个输出列名或者一个表表达式的列，仍然会出现混淆。在这种情况中输出列将被使用。只有在你使用<literal>AS</literal>来重命名一个输出列来匹配某些其他表列的名字时，这才会导致混淆。
  </para>

<!--==========================orignal english content==========================
  <para>
   <literal>ORDER BY</literal> can be applied to the result of a
   <literal>UNION</literal>, <literal>INTERSECT</literal>, or <literal>EXCEPT</literal>
   combination, but in this case it is only permitted to sort by
   output column names or numbers, not by expressions.
  </para>
____________________________________________________________________________-->
  <para>
   <literal>ORDER BY</literal>可以被应用于<literal>UNION</literal>、<literal>INTERSECT</literal>或<literal>EXCEPT</literal>组合的结果，但是在这种情况中它只被允许根据输出列名或编号排序，而不能根据表达式排序。
  </para>
 </sect1>


 <sect1 id="queries-limit">
<!--==========================orignal english content==========================
  <title><literal>LIMIT</literal> and <literal>OFFSET</literal></title>
____________________________________________________________________________-->
  <title><literal>LIMIT</literal>和<literal>OFFSET</literal></title>

<!--==========================orignal english content==========================
  <indexterm zone="queries-limit">
   <primary>LIMIT</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="queries-limit">
   <primary>LIMIT</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm zone="queries-limit">
   <primary>OFFSET</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="queries-limit">
   <primary>OFFSET</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   <literal>LIMIT</literal> and <literal>OFFSET</literal> allow you to retrieve just
   a portion of the rows that are generated by the rest of the query:
<synopsis>
SELECT <replaceable>select_list</replaceable>
    FROM <replaceable>table_expression</replaceable>
    <optional> ORDER BY ... </optional>
    <optional> LIMIT { <replaceable>number</replaceable> | ALL } </optional> <optional> OFFSET <replaceable>number</replaceable> </optional>
</synopsis>
  </para>
____________________________________________________________________________-->
  <para>
   <literal>LIMIT</literal>和<literal>OFFSET</literal>允许你只检索查询剩余部分产生的行的一部分：
<synopsis>
SELECT <replaceable>select_list</replaceable>
    FROM <replaceable>table_expression</replaceable>
    <optional> ORDER BY ... </optional>
    <optional> LIMIT { <replaceable>number</replaceable> | ALL } </optional> <optional> OFFSET <replaceable>number</replaceable> </optional>
</synopsis>
  </para>

<!--==========================orignal english content==========================
  <para>
   If a limit count is given, no more than that many rows will be
   returned (but possibly fewer, if the query itself yields fewer rows).
   <literal>LIMIT ALL</literal> is the same as omitting the <literal>LIMIT</literal>
   clause, as is <literal>LIMIT</literal> with a NULL argument.
  </para>
____________________________________________________________________________-->
  <para>
   如果给出了一个限制计数，那么会返回数量不超过该限制的行（但可能更少些，因为查询本身可能生成的行数就比较少）。<literal>LIMIT ALL</literal>的效果和省略<literal>LIMIT</literal>子句一样，就像是<literal>LIMIT</literal>带有 NULL 参数一样。
  </para>

<!--==========================orignal english content==========================
  <para>
   <literal>OFFSET</literal> says to skip that many rows before beginning to
   return rows.  <literal>OFFSET 0</literal> is the same as omitting the
   <literal>OFFSET</literal> clause, as is <literal>OFFSET</literal> with a NULL argument.
  </para>
____________________________________________________________________________-->
  <para>
   <literal>OFFSET</literal>说明在开始返回行之前忽略多少行。<literal>OFFSET 0</literal>的效果和省略<literal>OFFSET</literal>子句是一样的，并且<literal>LIMIT NULL</literal>的效果和省略<literal>LIMIT</literal>子句一样，就像是<literal>OFFSET</literal>带有 NULL 参数一样。
  </para>

<!--==========================orignal english content==========================
  <para>
   If both <literal>OFFSET</literal>
   and <literal>LIMIT</literal> appear, then <literal>OFFSET</literal> rows are
   skipped before starting to count the <literal>LIMIT</literal> rows that
   are returned.
  </para>
____________________________________________________________________________-->
  <para>
   如果<literal>OFFSET</literal>和<literal>LIMIT</literal>都出现了， 那么在返回<literal>LIMIT</literal>个行之前要先忽略<literal>OFFSET</literal>行。
  </para>

<!--==========================orignal english content==========================
  <para>
   When using <literal>LIMIT</literal>, it is important to use an
   <literal>ORDER BY</literal> clause that constrains the result rows into a
   unique order.  Otherwise you will get an unpredictable subset of
   the query's rows. You might be asking for the tenth through
   twentieth rows, but tenth through twentieth in what ordering? The
   ordering is unknown, unless you specified <literal>ORDER BY</literal>.
  </para>
____________________________________________________________________________-->
  <para>
   如果使用<literal>LIMIT</literal>，那么用一个<literal>ORDER BY</literal>子句把结果行约束成一个唯一的顺序是很重要的。否则你就会拿到一个不可预料的该查询的行的子集。你要的可能是第十到第二十行，但以什么顺序的第十到第二十？除非你指定了<literal>ORDER BY</literal>，否则顺序是不知道的。
  </para>

<!--==========================orignal english content==========================
  <para>
   The query optimizer takes <literal>LIMIT</literal> into account when
   generating query plans, so you are very likely to get different
   plans (yielding different row orders) depending on what you give
   for <literal>LIMIT</literal> and <literal>OFFSET</literal>.  Thus, using
   different <literal>LIMIT</literal>/<literal>OFFSET</literal> values to select
   different subsets of a query result <emphasis>will give
   inconsistent results</emphasis> unless you enforce a predictable
   result ordering with <literal>ORDER BY</literal>.  This is not a bug; it
   is an inherent consequence of the fact that SQL does not promise to
   deliver the results of a query in any particular order unless
   <literal>ORDER BY</literal> is used to constrain the order.
  </para>
____________________________________________________________________________-->
  <para>
   查询优化器在生成查询计划时会考虑<literal>LIMIT</literal>，因此如果你给定<literal>LIMIT</literal>和<literal>OFFSET</literal>，那么你很可能收到不同的规划（产生不同的行顺序）。因此，使用不同的<literal>LIMIT</literal>/<literal>OFFSET</literal>值选择查询结果的不同子集<emphasis>将生成不一致的结果</emphasis>，除非你用<literal>ORDER BY</literal>强制一个可预测的顺序。这并非bug， 这是一个很自然的结果，因为 SQL 没有许诺把查询的结果按照任何特定的顺序发出，除非用了<literal>ORDER BY</literal>来约束顺序。
  </para>

<!--==========================orignal english content==========================
  <para>
   The rows skipped by an <literal>OFFSET</literal> clause still have to be
   computed inside the server; therefore a large <literal>OFFSET</literal>
   might be inefficient.
  </para>
____________________________________________________________________________-->
  <para>
   被<literal>OFFSET</literal>子句忽略的行仍然需要在服务器内部计算；因此，一个很大的<literal>OFFSET</literal>的效率可能还是不够高。
  </para>
 </sect1>


 <sect1 id="queries-values">
<!--==========================orignal english content==========================
  <title><literal>VALUES</literal> Lists</title>
____________________________________________________________________________-->
  <title><literal>VALUES</literal>列表</title>

<!--==========================orignal english content==========================
  <indexterm zone="queries-values">
   <primary>VALUES</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="queries-values">
   <primary>VALUES</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   <literal>VALUES</literal> provides a way to generate a <quote>constant table</quote>
   that can be used in a query without having to actually create and populate
   a table on-disk.  The syntax is
<synopsis>
VALUES ( <replaceable class="parameter">expression</replaceable> [, ...] ) [, ...]
</synopsis>
   Each parenthesized list of expressions generates a row in the table.
   The lists must all have the same number of elements (i.e., the number
   of columns in the table), and corresponding entries in each list must
   have compatible data types.  The actual data type assigned to each column
   of the result is determined using the same rules as for <literal>UNION</literal>
   (see <xref linkend="typeconv-union-case"/>).
  </para>
____________________________________________________________________________-->
  <para>
   <literal>VALUES</literal>提供了一种生成<quote>常量表</quote>的方法，它可以被使用在一个查询中而不需要实际在磁盘上创建一个表。语法是：
<synopsis>
VALUES ( <replaceable class="parameter">expression</replaceable> [, ...] ) [, ...]
</synopsis>
   每一个被圆括号包围的表达式列表生成表中的一行。列表都必须具有相同数据的元素（即表中列的数目），并且在每个列表中对应的项必须具有可兼容的数据类型。分配给结果的每一列的实际数据类型使用和<literal>UNION</literal>相同的规则确定（参见<xref linkend="typeconv-union-case"/>）。
  </para>

<!--==========================orignal english content==========================
  <para>
   As an example:
<programlisting>
VALUES (1, 'one'), (2, 'two'), (3, 'three');
</programlisting>

   will return a table of two columns and three rows.  It's effectively
   equivalent to:
<programlisting>
SELECT 1 AS column1, 'one' AS column2
UNION ALL
SELECT 2, 'two'
UNION ALL
SELECT 3, 'three';
</programlisting>

   By default, <productname>PostgreSQL</productname> assigns the names
   <literal>column1</literal>, <literal>column2</literal>, etc. to the columns of a
   <literal>VALUES</literal> table.  The column names are not specified by the
   SQL standard and different database systems do it differently, so
   it's usually better to override the default names with a table alias
   list, like this:
<programlisting>
=&gt; SELECT * FROM (VALUES (1, 'one'), (2, 'two'), (3, 'three')) AS t (num,letter);
 num | letter
-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;
   1 | one
   2 | two
   3 | three
(3 rows)
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   一个例子：
<programlisting>
VALUES (1, 'one'), (2, 'two'), (3, 'three');
</programlisting>

   将会返回一个有两列三行的表。它实际上等效于：
<programlisting>
SELECT 1 AS column1, 'one' AS column2
UNION ALL
SELECT 2, 'two'
UNION ALL
SELECT 3, 'three';
</programlisting>

   在默认情况下，<productname>PostgreSQL</productname>将<literal>column1</literal>、<literal>column2</literal>等名字分配给一个<literal>VALUES</literal>表的列。这些列名不是由SQL标准指定的，并且不同的数据库系统的做法也不同，因此通常最好使用表别名列表来重写这些默认的名字，像这样：
<programlisting>
=&gt; SELECT * FROM (VALUES (1, 'one'), (2, 'two'), (3, 'three')) AS t (num,letter);
 num | letter
-----+--------
   1 | one
   2 | two
   3 | three
(3 rows)
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Syntactically, <literal>VALUES</literal> followed by expression lists is
   treated as equivalent to:
<synopsis>
SELECT <replaceable>select_list</replaceable> FROM <replaceable>table_expression</replaceable>
</synopsis>
   and can appear anywhere a <literal>SELECT</literal> can.  For example, you can
   use it as part of a <literal>UNION</literal>, or attach a
   <replaceable>sort_specification</replaceable> (<literal>ORDER BY</literal>,
   <literal>LIMIT</literal>, and/or <literal>OFFSET</literal>) to it.  <literal>VALUES</literal>
   is most commonly used as the data source in an <command>INSERT</command> command,
   and next most commonly as a subquery.
  </para>
____________________________________________________________________________-->
  <para>
   在句法上，后面跟随着表达式列表的<literal>VALUES</literal>列表被视为和
<synopsis>
SELECT <replaceable>select_list</replaceable> FROM <replaceable>table_expression</replaceable>
</synopsis>
   一样，并且可以出现在<literal>SELECT</literal>能出现的任何地方。例如，你可以把它用作<literal>UNION</literal>的一部分，或者附加一个<replaceable>sort_specification</replaceable>（<literal>ORDER BY</literal>、<literal>LIMIT</literal>和/或<literal>OFFSET</literal>）给它。<literal>VALUES</literal>最常见的用途是作为一个<command>INSERT</command>命令的数据源，以及作为一个子查询。
  </para>

<!--==========================orignal english content==========================
  <para>
   For more information see <xref linkend="sql-values"/>.
  </para>
____________________________________________________________________________-->
  <para>
   更多信息请见<xref linkend="sql-values"/>。
  </para>

 </sect1>


 <sect1 id="queries-with">
<!--==========================orignal english content==========================
  <title><literal>WITH</literal> Queries (Common Table Expressions)</title>
____________________________________________________________________________-->
  <title><literal>WITH</literal>查询（公共表表达式）</title>

<!--==========================orignal english content==========================
  <indexterm zone="queries-with">
   <primary>WITH</primary>
   <secondary>in SELECT</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="queries-with">
   <primary>WITH</primary>
   <secondary>in SELECT</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>common table expression</primary>
   <see>WITH</see>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>公共表表达式</primary>
   <see>WITH</see>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   <literal>WITH</literal> provides a way to write auxiliary statements for use in a
   larger query.  These statements, which are often referred to as Common
   Table Expressions or <acronym>CTE</acronym>s, can be thought of as defining
   temporary tables that exist just for one query.  Each auxiliary statement
   in a <literal>WITH</literal> clause can be a <command>SELECT</command>,
   <command>INSERT</command>, <command>UPDATE</command>, or <command>DELETE</command>; and the
   <literal>WITH</literal> clause itself is attached to a primary statement that can
   also be a <command>SELECT</command>, <command>INSERT</command>, <command>UPDATE</command>, or
   <command>DELETE</command>.
  </para>
____________________________________________________________________________-->
  <para>
   <literal>WITH</literal>提供了一种方式来书写在一个大型查询中使用的辅助语句。这些语句通常被称为公共表表达式或<acronym>CTE</acronym>，它们可以被看成是定义只在一个查询中存在的临时表。在<literal>WITH</literal>子句中的每一个辅助语句可以是一个<command>SELECT</command>、<command>INSERT</command>、<command>UPDATE</command>或<command>DELETE</command>，并且<literal>WITH</literal>子句本身也可以被附加到一个主语句，主语句也可以是<command>SELECT</command>、<command>INSERT</command>、<command>UPDATE</command>或<command>DELETE</command>。
  </para>

 <sect2 id="queries-with-select">
<!--==========================orignal english content==========================
   <title><command>SELECT</command> in <literal>WITH</literal></title>
____________________________________________________________________________-->
   <title><literal>WITH</literal>中的<command>SELECT</command></title>

<!--==========================orignal english content==========================
  <para>
   The basic value of <command>SELECT</command> in <literal>WITH</literal> is to
   break down complicated queries into simpler parts.  An example is:

<programlisting>
WITH regional_sales AS (
    SELECT region, SUM(amount) AS total_sales
    FROM orders
    GROUP BY region
), top_regions AS (
    SELECT region
    FROM regional_sales
    WHERE total_sales &gt; (SELECT SUM(total_sales)/10 FROM regional_sales)
)
SELECT region,
       product,
       SUM(quantity) AS product_units,
       SUM(amount) AS product_sales
FROM orders
WHERE region IN (SELECT region FROM top_regions)
GROUP BY region, product;
</programlisting>

   which displays per-product sales totals in only the top sales regions.
   The <literal>WITH</literal> clause defines two auxiliary statements named
   <structname>regional_sales</structname> and <structname>top_regions</structname>,
   where the output of <structname>regional_sales</structname> is used in
   <structname>top_regions</structname> and the output of <structname>top_regions</structname>
   is used in the primary <command>SELECT</command> query.
   This example could have been written without <literal>WITH</literal>,
   but we'd have needed two levels of nested sub-<command>SELECT</command>s.  It's a bit
   easier to follow this way.
  </para>
____________________________________________________________________________-->
  <para>
   <literal>WITH</literal>中<command>SELECT</command>的基本价值是将复杂的查询分解称为简单的部分。一个例子：

<programlisting>
WITH regional_sales AS (
    SELECT region, SUM(amount) AS total_sales
    FROM orders
    GROUP BY region
), top_regions AS (
    SELECT region
    FROM regional_sales
    WHERE total_sales &gt; (SELECT SUM(total_sales)/10 FROM regional_sales)
)
SELECT region,
       product,
       SUM(quantity) AS product_units,
       SUM(amount) AS product_sales
FROM orders
WHERE region IN (SELECT region FROM top_regions)
GROUP BY region, product;
</programlisting>

   它只显示在高销售区域每种产品的销售总额。<literal>WITH</literal>子句定义了两个辅助语句<structname>regional_sales</structname>和<structname>top_regions</structname>，其中<structname>regional_sales</structname>的输出用在<structname>top_regions</structname>中而<structname>top_regions</structname>的输出用在主<command>SELECT</command>查询。这个例子可以不用<literal>WITH</literal>来书写，但是我们必须要用两层嵌套的子<command>SELECT</command>。使用这种方法要更简单些。
  </para>

<!--==========================orignal english content==========================
  <para>
   <indexterm>
    <primary>RECURSIVE</primary>
    <secondary>in common table expressions</secondary>
   </indexterm>
   The optional <literal>RECURSIVE</literal> modifier changes <literal>WITH</literal>
   from a mere syntactic convenience into a feature that accomplishes
   things not otherwise possible in standard SQL.  Using
   <literal>RECURSIVE</literal>, a <literal>WITH</literal> query can refer to its own
   output.  A very simple example is this query to sum the integers from 1
   through 100:

<programlisting>
WITH RECURSIVE t(n) AS (
    VALUES (1)
  UNION ALL
    SELECT n+1 FROM t WHERE n &lt; 100
)
SELECT sum(n) FROM t;
</programlisting>

   The general form of a recursive <literal>WITH</literal> query is always a
   <firstterm>non-recursive term</firstterm>, then <literal>UNION</literal> (or
   <literal>UNION ALL</literal>), then a
   <firstterm>recursive term</firstterm>, where only the recursive term can contain
   a reference to the query's own output.  Such a query is executed as
   follows:
  </para>
____________________________________________________________________________-->
  <para>
   <indexterm>
    <primary>RECURSIVE</primary>
    <secondary>in common table expressions</secondary>
   </indexterm>
   可选的<literal>RECURSIVE</literal>修饰符将<literal>WITH</literal>从单纯的句法便利变成了一种在标准SQL中不能完成的特性。通过使用<literal>RECURSIVE</literal>，一个<literal>WITH</literal>查询可以引用它自己的输出。一个非常简单的例子是计算从1到100的整数合的查询：

<programlisting>
WITH RECURSIVE t(n) AS (
    VALUES (1)
  UNION ALL
    SELECT n+1 FROM t WHERE n &lt; 100
)
SELECT sum(n) FROM t;
</programlisting>

   一个递归<literal>WITH</literal>查询的通常形式总是一个<firstterm>非递归项</firstterm>，然后是<literal>UNION</literal>（或者<literal>UNION ALL</literal>），再然后是一个<firstterm>递归项</firstterm>，其中只有递归项能够包含对于查询自身输出的引用。这样一个查询可以被这样执行：
  </para>

  <procedure>
<!--==========================orignal english content==========================
   <title>Recursive Query Evaluation</title>
____________________________________________________________________________-->
   <title>递归查询求值</title>

   <step performance="required">
<!--==========================orignal english content==========================
    <para>
     Evaluate the non-recursive term.  For <literal>UNION</literal> (but not
     <literal>UNION ALL</literal>), discard duplicate rows.  Include all remaining
     rows in the result of the recursive query, and also place them in a
     temporary <firstterm>working table</firstterm>.
    </para>
____________________________________________________________________________-->
    <para>
     计算非递归项。对<literal>UNION</literal>（但不对<literal>UNION ALL</literal>），抛弃重复行。把所有剩余的行包括在递归查询的结果中，并且也把它们放在一个临时的<firstterm>工作表</firstterm>中。
    </para>
   </step>

   <step performance="required">
<!--==========================orignal english content==========================
    <para>
     So long as the working table is not empty, repeat these steps:
    </para>
____________________________________________________________________________-->
    <para>
     只要工作表不为空，重复下列步骤：
    </para>
    <substeps>
     <step performance="required">
<!--==========================orignal english content==========================
      <para>
       Evaluate the recursive term, substituting the current contents of
       the working table for the recursive self-reference.
       For <literal>UNION</literal> (but not <literal>UNION ALL</literal>), discard
       duplicate rows and rows that duplicate any previous result row.
       Include all remaining rows in the result of the recursive query, and
       also place them in a temporary <firstterm>intermediate table</firstterm>.
      </para>
____________________________________________________________________________-->
      <para>
       计算递归项，用当前工作表的内容替换递归自引用。对<literal>UNION</literal>（不是<literal>UNION ALL</literal>），抛弃重复行以及那些与之前结果行重复的行。将剩下的所有行包括在递归查询的结果中，并且也把它们放在一个临时的<firstterm>中间表</firstterm>中。
      </para>
     </step>

     <step performance="required">
<!--==========================orignal english content==========================
      <para>
       Replace the contents of the working table with the contents of the
       intermediate table, then empty the intermediate table.
      </para>
____________________________________________________________________________-->
      <para>
       用中间表的内容替换工作表的内容，然后清空中间表。
      </para>
     </step>
    </substeps>
   </step>
  </procedure>

  <note>
<!--==========================orignal english content==========================
   <para>
    Strictly speaking, this process is iteration not recursion, but
    <literal>RECURSIVE</literal> is the terminology chosen by the SQL standards
    committee.
   </para>
____________________________________________________________________________-->
   <para>
    严格来说，这个处理是迭代而不是递归，但是<literal>RECURSIVE</literal>是SQL标准委员会选择的术语。
   </para>
  </note>

<!--==========================orignal english content==========================
  <para>
   In the example above, the working table has just a single row in each step,
   and it takes on the values from 1 through 100 in successive steps.  In
   the 100th step, there is no output because of the <literal>WHERE</literal>
   clause, and so the query terminates.
  </para>
____________________________________________________________________________-->
  <para>
   在上面的例子中，工作表在每一步只有一个行，并且它在连续的步骤中取值从1到100。在第100步，由于<literal>WHERE</literal>子句导致没有输出，因此查询终止。
  </para>

<!--==========================orignal english content==========================
  <para>
   Recursive queries are typically used to deal with hierarchical or
   tree-structured data.  A useful example is this query to find all the
   direct and indirect sub-parts of a product, given only a table that
   shows immediate inclusions:

<programlisting>
WITH RECURSIVE included_parts(sub_part, part, quantity) AS (
    SELECT sub_part, part, quantity FROM parts WHERE part = 'our_product'
  UNION ALL
    SELECT p.sub_part, p.part, p.quantity
    FROM included_parts pr, parts p
    WHERE p.part = pr.sub_part
)
SELECT sub_part, SUM(quantity) as total_quantity
FROM included_parts
GROUP BY sub_part
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   递归查询通常用于处理层次或者树状结构的数据。一个有用的例子是这个用于找到一个产品的直接或间接部件的查询，只要给定一个显示了直接包含关系的表：

<programlisting>
WITH RECURSIVE included_parts(sub_part, part, quantity) AS (
    SELECT sub_part, part, quantity FROM parts WHERE part = 'our_product'
  UNION ALL
    SELECT p.sub_part, p.part, p.quantity
    FROM included_parts pr, parts p
    WHERE p.part = pr.sub_part
)
SELECT sub_part, SUM(quantity) as total_quantity
FROM included_parts
GROUP BY sub_part
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   When working with recursive queries it is important to be sure that
   the recursive part of the query will eventually return no tuples,
   or else the query will loop indefinitely.  Sometimes, using
   <literal>UNION</literal> instead of <literal>UNION ALL</literal> can accomplish this
   by discarding rows that duplicate previous output rows.  However, often a
   cycle does not involve output rows that are completely duplicate: it may be
   necessary to check just one or a few fields to see if the same point has
   been reached before.  The standard method for handling such situations is
   to compute an array of the already-visited values.  For example, consider
   the following query that searches a table <structname>graph</structname> using a
   <structfield>link</structfield> field:

<programlisting>
WITH RECURSIVE search_graph(id, link, data, depth) AS (
    SELECT g.id, g.link, g.data, 1
    FROM graph g
  UNION ALL
    SELECT g.id, g.link, g.data, sg.depth + 1
    FROM graph g, search_graph sg
    WHERE g.id = sg.link
)
SELECT * FROM search_graph;
</programlisting>

   This query will loop if the <structfield>link</structfield> relationships contain
   cycles.  Because we require a <quote>depth</quote> output, just changing
   <literal>UNION ALL</literal> to <literal>UNION</literal> would not eliminate the looping.
   Instead we need to recognize whether we have reached the same row again
   while following a particular path of links.  We add two columns
   <structfield>path</structfield> and <structfield>cycle</structfield> to the loop-prone query:

<programlisting>
WITH RECURSIVE search_graph(id, link, data, depth, path, cycle) AS (
    SELECT g.id, g.link, g.data, 1,
      ARRAY[g.id],
      false
    FROM graph g
  UNION ALL
    SELECT g.id, g.link, g.data, sg.depth + 1,
      path || g.id,
      g.id = ANY(path)
    FROM graph g, search_graph sg
    WHERE g.id = sg.link AND NOT cycle
)
SELECT * FROM search_graph;
</programlisting>

   Aside from preventing cycles, the array value is often useful in its own
   right as representing the <quote>path</quote> taken to reach any particular row.
  </para>
____________________________________________________________________________-->
  <para>
   在使用递归查询时，确保查询的递归部分最终将不返回元组非常重要，否则查询将会无限循环。在某些时候，使用<literal>UNION</literal>替代<literal>UNION ALL</literal>可以通过抛弃与之前输出行重复的行来达到这个目的。不过，经常有循环不涉及到完全重复的输出行：它可能只需要检查一个或几个域来看相同点之前是否达到过。处理这种情况的标准方法是计算一个已经访问过值的数组。例如，考虑下面这个使用<structfield>link</structfield>域搜索表<structname>graph</structname>的查询：

<programlisting>
WITH RECURSIVE search_graph(id, link, data, depth) AS (
    SELECT g.id, g.link, g.data, 1
    FROM graph g
  UNION ALL
    SELECT g.id, g.link, g.data, sg.depth + 1
    FROM graph g, search_graph sg
    WHERE g.id = sg.link
)
SELECT * FROM search_graph;
</programlisting>

   如果<structfield>link</structfield>关系包含环，这个查询将会循环。因为我们要求一个<quote>depth</quote>输出，仅仅将<literal>UNION ALL</literal> 改为<literal>UNION</literal>不会消除循环。反过来在我们顺着一个特定链接路径搜索时，我们需要识别我们是否再次到达了一个相同的行。我们可以项这个有循环倾向的查询增加两个列<structfield>path</structfield>和<structfield>cycle</structfield>：

<programlisting>
WITH RECURSIVE search_graph(id, link, data, depth, path, cycle) AS (
    SELECT g.id, g.link, g.data, 1,
      ARRAY[g.id],
      false
    FROM graph g
  UNION ALL
    SELECT g.id, g.link, g.data, sg.depth + 1,
      path || g.id,
      g.id = ANY(path)
    FROM graph g, search_graph sg
    WHERE g.id = sg.link AND NOT cycle
)
SELECT * FROM search_graph;
</programlisting>

   除了阻止环，数组值对于它们自己的工作显示到达任何特定行的<quote>path</quote>也有用。
  </para>

<!--==========================orignal english content==========================
  <para>
   In the general case where more than one field needs to be checked to
   recognize a cycle, use an array of rows.  For example, if we needed to
   compare fields <structfield>f1</structfield> and <structfield>f2</structfield>:

<programlisting>
WITH RECURSIVE search_graph(id, link, data, depth, path, cycle) AS (
    SELECT g.id, g.link, g.data, 1,
      ARRAY[ROW(g.f1, g.f2)],
      false
    FROM graph g
  UNION ALL
    SELECT g.id, g.link, g.data, sg.depth + 1,
      path || ROW(g.f1, g.f2),
      ROW(g.f1, g.f2) = ANY(path)
    FROM graph g, search_graph sg
    WHERE g.id = sg.link AND NOT cycle
)
SELECT * FROM search_graph;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   在通常情况下如果需要检查多于一个域来识别一个环，请用行数组。例如，如果我们需要比较域<structfield>f1</structfield>和<structfield>f2</structfield>：

<programlisting>
WITH RECURSIVE search_graph(id, link, data, depth, path, cycle) AS (
    SELECT g.id, g.link, g.data, 1,
      ARRAY[ROW(g.f1, g.f2)],
      false
    FROM graph g
  UNION ALL
    SELECT g.id, g.link, g.data, sg.depth + 1,
      path || ROW(g.f1, g.f2),
      ROW(g.f1, g.f2) = ANY(path)
    FROM graph g, search_graph sg
    WHERE g.id = sg.link AND NOT cycle
)
SELECT * FROM search_graph;
</programlisting>
  </para>

  <tip>
<!--==========================orignal english content==========================
   <para>
    Omit the <literal>ROW()</literal> syntax in the common case where only one field
    needs to be checked to recognize a cycle.  This allows a simple array
    rather than a composite-type array to be used, gaining efficiency.
   </para>
____________________________________________________________________________-->
   <para>
    在通常情况下只有一个域需要被检查来识别一个环，可以省略<literal>ROW()</literal>语法。这允许使用一个简单的数组而不是一个组合类型数组，可以获得效率。
   </para>
  </tip>

  <tip>
<!--==========================orignal english content==========================
   <para>
    The recursive query evaluation algorithm produces its output in
    breadth-first search order.  You can display the results in depth-first
    search order by making the outer query <literal>ORDER BY</literal> a
    <quote>path</quote> column constructed in this way.
   </para>
____________________________________________________________________________-->
   <para>
    递归查询计算算法使用宽度优先搜索顺序产生它的输出。你可以通过让外部查询<literal>ORDER BY</literal>一个以这种方法构建的<quote>path</quote>，用来以深度优先搜索顺序显示结果。
   </para>
  </tip>

<!--==========================orignal english content==========================
  <para>
   A helpful trick for testing queries
   when you are not certain if they might loop is to place a <literal>LIMIT</literal>
   in the parent query.  For example, this query would loop forever without
   the <literal>LIMIT</literal>:

<programlisting>
WITH RECURSIVE t(n) AS (
    SELECT 1
  UNION ALL
    SELECT n+1 FROM t
)
SELECT n FROM t LIMIT 100;
</programlisting>

   This works because <productname>PostgreSQL</productname>'s implementation
   evaluates only as many rows of a <literal>WITH</literal> query as are actually
   fetched by the parent query.  Using this trick in production is not
   recommended, because other systems might work differently.  Also, it
   usually won't work if you make the outer query sort the recursive query's
   results or join them to some other table, because in such cases the
   outer query will usually try to fetch all of the <literal>WITH</literal> query's
   output anyway.
  </para>
____________________________________________________________________________-->
  <para>
   当你不确定查询是否可能循环时，一个测试查询的有用技巧是在父查询中放一个<literal>LIMIT</literal>。例如，这个查询没有<literal>LIMIT</literal>时会永远循环：

<programlisting>
WITH RECURSIVE t(n) AS (
    SELECT 1
  UNION ALL
    SELECT n+1 FROM t
)
SELECT n FROM t LIMIT 100;
</programlisting>

   这会起作用，因为<productname>PostgreSQL</productname>的实现只计算<literal>WITH</literal>查询中被父查询实际取到的行。不推荐在生产中使用这个技巧，因为其他系统可能以不同方式工作。同样，如果你让外层查询排序递归查询的结果或者把它们连接成某种其他表，这个技巧将不会起作用，因为在这些情况下外层查询通常将尝试取得<literal>WITH</literal>查询的所有输出。
  </para>

<!--==========================orignal english content==========================
  <para>
   A useful property of <literal>WITH</literal> queries is that they are
   normally evaluated only once per execution of the parent query, even if
   they are referred to more than once by the parent query or
   sibling <literal>WITH</literal> queries.
   Thus, expensive calculations that are needed in multiple places can be
   placed within a <literal>WITH</literal> query to avoid redundant work.  Another
   possible application is to prevent unwanted multiple evaluations of
   functions with side-effects.
   However, the other side of this coin is that the optimizer is not able to
   push restrictions from the parent query down into a multiply-referenced
   <literal>WITH</literal> query, since that might affect all uses of the
   <literal>WITH</literal> query's output when it should affect only one.
   The multiply-referenced <literal>WITH</literal> query will be
   evaluated as written, without suppression of rows that the parent query
   might discard afterwards.  (But, as mentioned above, evaluation might stop
   early if the reference(s) to the query demand only a limited number of
   rows.)
  </para>
____________________________________________________________________________-->
  <para>
   <literal>WITH</literal>查询的一个有用的特性是在每一次父查询的执行中它们通常只被计算一次，即使它们被父查询或兄弟<literal>WITH</literal>查询引用了超过一次。
   因此，在多个地方需要的昂贵计算可以被放在一个<literal>WITH</literal>查询中来避免冗余工作。另一种可能的应用是阻止不希望的多个函数计算产生副作用。
   但是，从另一方面来看，优化器不能将来自父查询的约束下推到乘法引用<literal>WITH</literal>查询，因为当他应该只影响一个时它可能会影响所有使用<literal>WITH</literal>查询的输出的使用。
   乘法引用<literal>WITH</literal>查询通常将会被按照所写的方式计算，而不抑制父查询以后可能会抛弃的行（但是，如上所述，如果对查询的引用只请求有限数目的行，计算可能会提前停止）。
  </para>

<!--==========================orignal english content==========================
  <para>
   However, if a <literal>WITH</literal> query is non-recursive and
   side-effect-free (that is, it is a <literal>SELECT</literal> containing
   no volatile functions) then it can be folded into the parent query,
   allowing joint optimization of the two query levels.  By default, this
   happens if the parent query references the <literal>WITH</literal> query
   just once, but not if it references the <literal>WITH</literal> query
   more than once.  You can override that decision by
   specifying <literal>MATERIALIZED</literal> to force separate calculation
   of the <literal>WITH</literal> query, or by specifying <literal>NOT
   MATERIALIZED</literal> to force it to be merged into the parent query.
   The latter choice risks duplicate computation of
   the <literal>WITH</literal> query, but it can still give a net savings if
   each usage of the <literal>WITH</literal> query needs only a small part
   of the <literal>WITH</literal> query's full output.
  </para>
____________________________________________________________________________-->
  <para>
   但是，如果 <literal>WITH</literal> 查询是非递归和边际效应无关的（就是说，它是一个<literal>SELECT</literal>包含没有可变函数），则它可以合并到父查询中，允许两个查询级别的联合优化。 
   默认情况下，这发生在如果父查询仅引用 <literal>WITH</literal>查询一次的时候，而不是它引用<literal>WITH</literal>查询多于一次时。 
   你可以超越控制这个决策，通过指定 <literal>MATERIALIZED</literal> 来强制分开计算 <literal>WITH</literal> 查询，或者通过指定 <literal>NOT MATERIALIZED</literal>来强制它被合并到父查询中。
   后一种选择存在重复计算<literal>WITH</literal>查询的风险，但它仍然能提供净节省，如果<literal>WITH</literal>查询的每个使用只需要<literal>WITH</literal>查询的完整输出的一小部分。
  </para>

<!--==========================orignal english content==========================
  <para>
   A simple example of these rules is
<programlisting>
WITH w AS (
    SELECT * FROM big_table
)
SELECT * FROM w WHERE key = 123;
</programlisting>
   This <literal>WITH</literal> query will be folded, producing the same
   execution plan as
<programlisting>
SELECT * FROM big_table WHERE key = 123;
</programlisting>
   In particular, if there's an index on <structfield>key</structfield>,
   it will probably be used to fetch just the rows having <literal>key =
   123</literal>.  On the other hand, in
<programlisting>
WITH w AS (
    SELECT * FROM big_table
)
SELECT * FROM w AS w1 JOIN w AS w2 ON w1.key = w2.ref
WHERE w2.key = 123;
</programlisting>
   the <literal>WITH</literal> query will be materialized, producing a
   temporary copy of <structname>big_table</structname> that is then
   joined with itself &mdash; without benefit of any index.  This query
   will be executed much more efficiently if written as
<programlisting>
WITH w AS NOT MATERIALIZED (
    SELECT * FROM big_table
)
SELECT * FROM w AS w1 JOIN w AS w2 ON w1.key = w2.ref
WHERE w2.key = 123;
</programlisting>
   so that the parent query's restrictions can be applied directly
   to scans of <structname>big_table</structname>.
  </para>
____________________________________________________________________________-->
  <para>
   这些规则的一个简单示例是
<programlisting>
WITH w AS (
    SELECT * FROM big_table
)
SELECT * FROM w WHERE key = 123;
</programlisting>
   这个 <literal>WITH</literal> 查询将被合并，生成相同的执行计划为
<programlisting>
SELECT * FROM big_table WHERE key = 123;
</programlisting>
   特别是，如果在<structfield>key</structfield>上有一个索引，它可能只用于获取具有 <literal>key = 123</literal>的行。 另一方面，在
<programlisting>
WITH w AS (
    SELECT * FROM big_table
)
SELECT * FROM w AS w1 JOIN w AS w2 ON w1.key = w2.ref
WHERE w2.key = 123;
</programlisting>
   <literal>WITH</literal>查询将被物化，生成一个<structname>big_table</structname>的临时拷贝，然后与其自身 &mdash 联合；没有任何索引的益处。
   这个查询将被执行的更有效率，如果写为
<programlisting>
WITH w AS NOT MATERIALIZED (
    SELECT * FROM big_table
)
SELECT * FROM w AS w1 JOIN w AS w2 ON w1.key = w2.ref
WHERE w2.key = 123;
</programlisting>
   所以父查询的限制可以直接应用于<structname>big_table</structname>的扫描。
  </para>

<!--==========================orignal english content==========================
  <para>
   An example where <literal>NOT MATERIALIZED</literal> could be
   undesirable is
<programlisting>
WITH w AS (
    SELECT key, very_expensive_function(val) as f FROM some_table
)
SELECT * FROM w AS w1 JOIN w AS w2 ON w1.f = w2.f;
</programlisting>
   Here, materialization of the <literal>WITH</literal> query ensures
   that <function>very_expensive_function</function> is evaluated only
   once per table row, not twice.
  </para>
____________________________________________________________________________-->
  <para>
   一个<literal>NOT MATERIALIZED</literal> 可能不理想的例子为
<programlisting>
WITH w AS (
    SELECT key, very_expensive_function(val) as f FROM some_table
)
SELECT * FROM w AS w1 JOIN w AS w2 ON w1.f = w2.f;
</programlisting>
   在这里，<literal>WITH</literal>查询的物化确保<function>very_expensive_function</function>每个表行只计算一次，而不是两次。
  </para>

<!--==========================orignal english content==========================
  <para>
   The examples above only show <literal>WITH</literal> being used with
   <command>SELECT</command>, but it can be attached in the same way to
   <command>INSERT</command>, <command>UPDATE</command>, or <command>DELETE</command>.
   In each case it effectively provides temporary table(s) that can
   be referred to in the main command.
  </para>
____________________________________________________________________________-->
  <para>
   以上的例子只展示了和<command>SELECT</command>一起使用的<literal>WITH</literal>，但是它可以被以相同的方式附加在<command>INSERT</command>、<command>UPDATE</command>或<command>DELETE</command>上。在每一种情况中，它实际上提供了可在主命令中引用的临时表。
  </para>
 </sect2>

 <sect2 id="queries-with-modifying">
<!--==========================orignal english content==========================
   <title>Data-Modifying Statements in <literal>WITH</literal></title>
____________________________________________________________________________-->
   <title><literal>WITH</literal>中的数据修改语句</title>

<!--==========================orignal english content==========================
   <para>
    You can use data-modifying statements (<command>INSERT</command>,
    <command>UPDATE</command>, or <command>DELETE</command>) in <literal>WITH</literal>.  This
    allows you to perform several different operations in the same query.
    An example is:

<programlisting>
WITH moved_rows AS (
    DELETE FROM products
    WHERE
        "date" &gt;= '2010-10-01' AND
        "date" &lt; '2010-11-01'
    RETURNING *
)
INSERT INTO products_log
SELECT * FROM moved_rows;
</programlisting>

    This query effectively moves rows from <structname>products</structname> to
    <structname>products_log</structname>.  The <command>DELETE</command> in <literal>WITH</literal>
    deletes the specified rows from <structname>products</structname>, returning their
    contents by means of its <literal>RETURNING</literal> clause; and then the
    primary query reads that output and inserts it into
    <structname>products_log</structname>.
   </para>
____________________________________________________________________________-->
   <para>
    你可以在<literal>WITH</literal>中使用数据修改语句（<command>INSERT</command>、<command>UPDATE</command>或<command>DELETE</command>）。这允许你在同一个查询中执行多个而不同操作。一个例子：

<programlisting>
WITH moved_rows AS (
    DELETE FROM products
    WHERE
        "date" &gt;= '2010-10-01' AND
        "date" &lt; '2010-11-01'
    RETURNING *
)
INSERT INTO products_log
SELECT * FROM moved_rows;
</programlisting>

    这个查询实际上从<structname>products</structname>把行移动到<structname>products_log</structname>。<literal>WITH</literal>中的<command>DELETE</command>删除来自<structname>products</structname>的指定行，以它的<literal>RETURNING</literal>子句返回它们的内容，并且接着主查询读该输出并将它插入到<structname>products_log</structname>。
   </para>

<!--==========================orignal english content==========================
   <para>
    A fine point of the above example is that the <literal>WITH</literal> clause is
    attached to the <command>INSERT</command>, not the sub-<command>SELECT</command> within
    the <command>INSERT</command>.  This is necessary because data-modifying
    statements are only allowed in <literal>WITH</literal> clauses that are attached
    to the top-level statement.  However, normal <literal>WITH</literal> visibility
    rules apply, so it is possible to refer to the <literal>WITH</literal>
    statement's output from the sub-<command>SELECT</command>.
   </para>
____________________________________________________________________________-->
   <para>
    上述例子中好的一点是<literal>WITH</literal>子句被附加给<command>INSERT</command>，而没有附加给<command>INSERT</command>的子<command>SELECT</command>。这是必需的，因为数据修改语句只允许出现在附加给顶层语句的<literal>WITH</literal>子句中。不过，普通<literal>WITH</literal>可见性规则应用，这样才可能从子<command>SELECT</command>中引用到<literal>WITH</literal>语句的输出。
   </para>

<!--==========================orignal english content==========================
   <para>
    Data-modifying statements in <literal>WITH</literal> usually have
    <literal>RETURNING</literal> clauses (see <xref linkend="dml-returning"/>),
    as shown in the example above.
    It is the output of the <literal>RETURNING</literal> clause, <emphasis>not</emphasis> the
    target table of the data-modifying statement, that forms the temporary
    table that can be referred to by the rest of the query.  If a
    data-modifying statement in <literal>WITH</literal> lacks a <literal>RETURNING</literal>
    clause, then it forms no temporary table and cannot be referred to in
    the rest of the query.  Such a statement will be executed nonetheless.
    A not-particularly-useful example is:

<programlisting>
WITH t AS (
    DELETE FROM foo
)
DELETE FROM bar;
</programlisting>

    This example would remove all rows from tables <structname>foo</structname> and
    <structname>bar</structname>.  The number of affected rows reported to the client
    would only include rows removed from <structname>bar</structname>.
   </para>
____________________________________________________________________________-->
   <para>
    正如上述例子所示，<literal>WITH</literal>中的数据修改语句通常具有<literal>RETURNING</literal>子句（见<xref linkend="dml-returning"/>）。它是<literal>RETURNING</literal>子句的输出，<emphasis>不是</emphasis>数据修改语句的目标表，它形成了剩余查询可以引用的临时表。如果一个<literal>WITH</literal>中的数据修改语句缺少一个<literal>RETURNING</literal>子句，则它形不成临时表并且不能在剩余的查询中被引用。但是这样一个语句将被执行。一个非特殊使用的例子：

<programlisting>
WITH t AS (
    DELETE FROM foo
)
DELETE FROM bar;
</programlisting>

    这个例子将从表<structname>foo</structname>和<structname>bar</structname>中移除所有行。被报告给客户端的受影响行的数目可能只包括从<structname>bar</structname>中移除的行。
   </para>

<!--==========================orignal english content==========================
   <para>
    Recursive self-references in data-modifying statements are not
    allowed.  In some cases it is possible to work around this limitation by
    referring to the output of a recursive <literal>WITH</literal>, for example:

<programlisting>
WITH RECURSIVE included_parts(sub_part, part) AS (
    SELECT sub_part, part FROM parts WHERE part = 'our_product'
  UNION ALL
    SELECT p.sub_part, p.part
    FROM included_parts pr, parts p
    WHERE p.part = pr.sub_part
)
DELETE FROM parts
  WHERE part IN (SELECT part FROM included_parts);
</programlisting>

    This query would remove all direct and indirect subparts of a product.
   </para>
____________________________________________________________________________-->
   <para>
    数据修改语句中不允许递归自引用。在某些情况中可以采取引用一个递归<literal>WITH</literal>的输出来操作这个限制，例如：

<programlisting>
WITH RECURSIVE included_parts(sub_part, part) AS (
    SELECT sub_part, part FROM parts WHERE part = 'our_product'
  UNION ALL
    SELECT p.sub_part, p.part
    FROM included_parts pr, parts p
    WHERE p.part = pr.sub_part
)
DELETE FROM parts
  WHERE part IN (SELECT part FROM included_parts);
</programlisting>

    这个查询将会移除一个产品的所有直接或间接子部件。
   </para>

<!--==========================orignal english content==========================
   <para>
    Data-modifying statements in <literal>WITH</literal> are executed exactly once,
    and always to completion, independently of whether the primary query
    reads all (or indeed any) of their output.  Notice that this is different
    from the rule for <command>SELECT</command> in <literal>WITH</literal>: as stated in the
    previous section, execution of a <command>SELECT</command> is carried only as far
    as the primary query demands its output.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>WITH</literal>中的数据修改语句只被执行一次，并且总是能结束，而不管主查询是否读取它们所有（或者任何）的输出。注意这和<literal>WITH</literal>中<command>SELECT</command>的规则不同：正如前一小节所述，直到主查询要求<command>SELECT</command>的输出时，<command>SELECT</command>才会被执行。
   </para>

<!--==========================orignal english content==========================
   <para>
    The sub-statements in <literal>WITH</literal> are executed concurrently with
    each other and with the main query.  Therefore, when using data-modifying
    statements in <literal>WITH</literal>, the order in which the specified updates
    actually happen is unpredictable.  All the statements are executed with
    the same <firstterm>snapshot</firstterm> (see <xref linkend="mvcc"/>), so they
    cannot <quote>see</quote> one another's effects on the target tables.  This
    alleviates the effects of the unpredictability of the actual order of row
    updates, and means that <literal>RETURNING</literal> data is the only way to
    communicate changes between different <literal>WITH</literal> sub-statements and
    the main query.  An example of this is that in

<programlisting>
WITH t AS (
    UPDATE products SET price = price * 1.05
    RETURNING *
)
SELECT * FROM products;
</programlisting>

    the outer <command>SELECT</command> would return the original prices before the
    action of the <command>UPDATE</command>, while in

<programlisting>
WITH t AS (
    UPDATE products SET price = price * 1.05
    RETURNING *
)
SELECT * FROM t;
</programlisting>

    the outer <command>SELECT</command> would return the updated data.
   </para>
____________________________________________________________________________-->
   <para>
    The sub-statements in <literal>WITH</literal>中的子语句被和每一个其他子语句以及主查询并发执行。因此在使用<literal>WITH</literal>中的数据修改语句时，指定更新的顺序实际是以不可预测的方式发生的。所有的语句都使用同一个<firstterm>snapshot</firstterm>执行（参见<xref linkend="mvcc"/>），因此它们不能<quote>看见</quote>在目标表上另一个执行的效果。这减轻了行更新的实际顺序的不可预见性的影响，并且意味着<literal>RETURNING</literal>数据是在不同<literal>WITH</literal>子语句和主查询之间传达改变的唯一方法。其例子

<programlisting>
WITH t AS (
    UPDATE products SET price = price * 1.05
    RETURNING *
)
SELECT * FROM products;
</programlisting>

    外层<command>SELECT</command>可以返回在<command>UPDATE</command>动作之前的原始价格，而在

<programlisting>
WITH t AS (
    UPDATE products SET price = price * 1.05
    RETURNING *
)
SELECT * FROM t;
</programlisting>

    外部<command>SELECT</command>将返回更新过的数据。
   </para>

<!--==========================orignal english content==========================
   <para>
    Trying to update the same row twice in a single statement is not
    supported.  Only one of the modifications takes place, but it is not easy
    (and sometimes not possible) to reliably predict which one.  This also
    applies to deleting a row that was already updated in the same statement:
    only the update is performed.  Therefore you should generally avoid trying
    to modify a single row twice in a single statement.  In particular avoid
    writing <literal>WITH</literal> sub-statements that could affect the same rows
    changed by the main statement or a sibling sub-statement.  The effects
    of such a statement will not be predictable.
   </para>
____________________________________________________________________________-->
   <para>
    在一个语句中试图两次更新同一行是不被支持的。只会发生一次修改，但是该办法不能很容易地（有时是不可能）可靠地预测哪一个会被执行。这也应用于删除一个已经在同一个语句中被更新过的行：只有更新被执行。因此你通常应该避免尝试在一个语句中尝试两次修改同一个行。尤其是防止书写可能影响被主语句或兄弟子语句修改的相同行。这样一个语句的效果将是不可预测的。
   </para>

<!--==========================orignal english content==========================
   <para>
    At present, any table used as the target of a data-modifying statement in
    <literal>WITH</literal> must not have a conditional rule, nor an <literal>ALSO</literal>
    rule, nor an <literal>INSTEAD</literal> rule that expands to multiple statements.
   </para>
____________________________________________________________________________-->
   <para>
    当前，在<literal>WITH</literal>中一个数据修改语句中被用作目标的任何表不能有条件规则、<literal>ALSO</literal>规则或<literal>INSTEAD</literal>规则，这些规则会扩展成为多个语句。
   </para>

  </sect2>

 </sect1>

</chapter>
