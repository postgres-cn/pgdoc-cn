<!-- doc/src/sgml/queries.sgml -->

<chapter id="queries">
 <title>查询</title>

 <indexterm zone="queries">
  <primary>查询</primary>
 </indexterm>

 <indexterm zone="queries">
  <primary>SELECT</primary>
 </indexterm>

 <para>
  前面的章节解释了如何创建表、如何用数据填充它们 以及如何操纵那些数据。现在我们终于可以讨论如何从数据库中检索数据了。
 </para>


 <sect1 id="queries-overview">
  <title>概述</title>

  <para>
   从数据库中检索数据的过程或命令叫做<firstterm>查询</firstterm>。在 SQL 里<xref linkend="sql-select">命令用于指定查询。 <command>SELECT</command>命令的一般语法是
<synopsis>
<optional>WITH <replaceable>with_queries</replaceable></optional> SELECT <replaceable>select_list</replaceable> FROM <replaceable>table_expression</replaceable> <optional><replaceable>sort_specification</replaceable></optional>
</synopsis>
   下面几个小节描述选择列表、表表达式和排序声明的细节。<literal>WITH</>查询等高级特性将在最后讨论。
  </para>

  <para>
   一个简单类型的查询的形式：
<programlisting>
SELECT * FROM table1;
</programlisting>
  假设有一个表叫做<literal>table1</literal>，这条命令将<literal>table1</literal>中检索所有行和所有用户定义的列（检索的方法取决于客户端应用。例如，<application>psql</application>程序将在屏幕上显示一个 ASCII 形式的表格， 而客户端库将提供函数来从检索结果中抽取单个值）。 选择列表声明<literal>*</literal>意味着所有表表达式提供的列。 一个选择列表也可以选择可用列的一个子集或者在使用它们之前对列进行计算。例如，如果<literal>table1</literal>有叫做<literal>a</>、<literal>b</>和<literal>c</>的列（可能还有其他），那么你可以用下面的查询：
<programlisting>
SELECT a, b + c FROM table1;
</programlisting>
  （假设<literal>b</>和<literal>c</>都是数字数据类型）。 参阅<xref linkend="queries-select-lists">获取更多细节。
 </para>

 <para>
  <literal>FROM table1</literal>是一种非常简单的表表达式：它只读取了一个表。通常，表表达式可以是基本表、连接和子查询组成的复杂结构。 但你也可以省略整个表表达式而把<command>SELECT</command>命令当做一个计算器：
<programlisting>
SELECT 3 * 4;
</programlisting>
  如果选择列表里的表达式返回变化的结果，那么这就更有用了。例如，你可以用这种方法调用函数：
<programlisting>
SELECT random();
</programlisting>
  </para>
 </sect1>


 <sect1 id="queries-table-expressions">
  <title>表表达式</title>

  <indexterm zone="queries-table-expressions">
   <primary>表表达式</primary>
  </indexterm>

  <para>
   <firstterm>表表达式</firstterm>计算一个表。该表表达式包含一个<literal>FROM</>子句，该子句后面可以根据需要选用<literal>WHERE</>、<literal>GROUP BY</>和<literal>HAVING</>子句。最简单的表表达式只是引用磁盘上的一个表，一个所谓的基本表，但是我们可以用更复杂的表表达式以多种方法修改或组合基本表。
  </para>

  <para>
   表表达式里可选的<literal>WHERE</>、<literal>GROUP BY</>和<literal>HAVING</>子句指定一系列对源自<literal>FROM</>子句的表的转换操作。所有这些转换最后生成一个虚拟表，它提供行传递给选择列表计算查询的输出行。
  </para>

  <sect2 id="queries-from">
   <title><literal>FROM</literal>子句</title>

   <para>
    <xref linkend="sql-from" endterm="sql-from-title">从一个用逗号分隔的表引用列表中的一个或更多个其它表中生成一个表。
<synopsis>
FROM <replaceable>table_reference</replaceable> <optional>, <replaceable>table_reference</replaceable> <optional>, ...</optional></optional>
</synopsis>

    表引用可以是一个表名字（可能有模式限定）或者是一个生成的表， 例如子查询、一个<literal>JOIN</>结构或者这些东西的复杂组合。如果在<literal>FROM</>子句中引用了多于一个表， 那么它们被交叉连接（即构造它们的行的笛卡尔积，见下文）。<literal>FROM</>列表的结果是一个中间的虚拟表，该表可以进行由<literal>WHERE</>、<literal>GROUP BY</>和<literal>HAVING</>子句指定的转换，并最后生成全局的表表达式结果。
   </para>

   <indexterm>
    <primary>ONLY</primary>
   </indexterm>

   <para>
    如果一个表引用是一个简单的表名字并且它是表继承层次中的父表，那么该表引用将产生该表和它的后代表中的行，除非你在该表名字前面放上<literal>ONLY</>关键字。但是，这种引用只会产生出现在该命名表中的列 &mdash; 在子表中增加的列都会被忽略。
   </para>

   <para>
    除了在表名前写<literal>ONLY</>，你可以在表名后面写上<literal>*</>来显式地指定要包括所有的后代表。书写<literal>*</>并不是必需的，因为该行为是默认值（除非你修改<xref linkend="guc-sql-inheritance">配置选项的设置）。不过对于强调附加表也应该被搜索，书写<literal>*</>是有用的。
   </para>

   <sect3 id="queries-join">
    <title>连接表</title>

    <indexterm zone="queries-join">
     <primary>连接</primary>
    </indexterm>

    <para>
     一个连接表是根据特定的连接类型的规则从两个其它表
     （真实表或生成表）中派生的表。目前支持内连接、
     外连接和交叉连接。
     一个连接表的一般语法是：
<synopsis>
<replaceable>T1</replaceable> <replaceable>join_type</replaceable> <replaceable>T2</replaceable> <optional> <replaceable>join_condition</replaceable> </optional>
</synopsis>
     所有类型的连接都可以被链在一起或者嵌套：<replaceable>T1</replaceable>
     和<replaceable>T2</replaceable>都可以是连接表。在<literal>JOIN</>
     子句周围可以使用圆括号来控制连接顺序。如果不使用圆括号，
     <literal>JOIN</>子句会从左至右嵌套。
    </para>

    <variablelist>
     <title>连接类型</title>

     <varlistentry>
      <term>交叉连接

      <indexterm>
       <primary>连接</primary>
       <secondary>交叉</secondary>
      </indexterm>

      <indexterm>
       <primary>交叉连接</primary>
      </indexterm>
      </term>

      <listitem>
<synopsis>
<replaceable>T1</replaceable> CROSS JOIN <replaceable>T2</replaceable>
</synopsis>

       <para>
        对来自于<replaceable>T1</replaceable>和<replaceable>T2</replaceable>的行的每一种可能的组合（即笛卡尔积），连接表将包含这样一行：它由所有<replaceable>T1</replaceable>里面的列后面跟着所有<replaceable>T2</replaceable>里面的列构成。如果两个表分别有 N 和 M 行，连接表将有 N * M 行。
       </para>

       <para>
        <literal>FROM <replaceable>T1</replaceable> CROSS JOIN
        <replaceable>T2</replaceable></literal>等效于
        <literal>FROM <replaceable>T1</replaceable> INNER JOIN
        <replaceable>T2</replaceable> ON TRUE</literal>（见下文）。
        它也等效于
        <literal>FROM <replaceable>T1</replaceable>,
        <replaceable>T2</replaceable></literal>。
        <note>
        <para>
         当多于两个表出现时，后一种等效并不严格成立，因为
         <literal>JOIN</>比逗号绑得更紧。例如
         <literal>FROM <replaceable>T1</replaceable> CROSS JOIN
         <replaceable>T2</replaceable> INNER JOIN <replaceable>T3</replaceable>
         ON <replaceable>condition</replaceable></literal>和
         <literal>FROM <replaceable>T1</replaceable>,
         <replaceable>T2</replaceable> INNER JOIN <replaceable>T3</replaceable>
         ON <replaceable>condition</replaceable></literal>并不完全相同，
         因为第一种情况中的<replaceable>condition</replaceable>可以引用
         <replaceable>T1</replaceable>，但在第二种情况中却不行。
        </para>
        </note>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>条件连接

      <indexterm>
       <primary>join</primary>
       <secondary>outer</secondary>
      </indexterm>

      <indexterm>
       <primary>外连接</primary>
      </indexterm>
      </term>

      <listitem>
<synopsis>
<replaceable>T1</replaceable> { <optional>INNER</optional> | { LEFT | RIGHT | FULL } <optional>OUTER</optional> } JOIN <replaceable>T2</replaceable> ON <replaceable>boolean_expression</replaceable>
<replaceable>T1</replaceable> { <optional>INNER</optional> | { LEFT | RIGHT | FULL } <optional>OUTER</optional> } JOIN <replaceable>T2</replaceable> USING ( <replaceable>join column list</replaceable> )
<replaceable>T1</replaceable> NATURAL { <optional>INNER</optional> | { LEFT | RIGHT | FULL } <optional>OUTER</optional> } JOIN <replaceable>T2</replaceable>
</synopsis>

       <para>
        <literal>INNER</literal>和<literal>OUTER</literal>对所有连接形式都是可选的。<literal>INNER</literal>是缺省；<literal>LEFT</literal>、<literal>RIGHT</literal>和<literal>FULL</literal>指示一个外连接。
       </para>

       <para>
        <firstterm>连接条件</firstterm>在<literal>ON</>或<literal>USING</>子句中指定， 或者用关键字<literal>NATURAL</>隐含地指定。连接条件决定来自两个源表中的哪些行是<quote>匹配</quote>的，这些我们将在后文详细解释。
       </para>

       <para>
        可能的条件连接类型是：

       <variablelist>
        <varlistentry>
         <term><literal>INNER JOIN</></term>

         <listitem>
          <para>
           对于 T1 的每一行 R1，生成的连接表都有一行对应 T2 中的每一个满足和 R1 的连接条件的行。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>LEFT OUTER JOIN</>

         <indexterm>
          <primary>连接</primary>
          <secondary>左</secondary>
         </indexterm>

         <indexterm>
          <primary>左连接</primary>
         </indexterm>
         </term>

         <listitem>
          <para>
           首先，执行一次内连接。然后，为 T1 中每一个无法在连接条件上匹配 T2 里任何一行的行返回一个连接行，该连接行中 T2 的列用空值补齐。因此，生成的连接表里为来自 T1 的每一行都至少包含一行。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>RIGHT OUTER JOIN</>

         <indexterm>
          <primary>连接</primary>
          <secondary>右</secondary>
         </indexterm>
         </term>

         <indexterm>
          <primary>右连接</primary>
         </indexterm>

         <listitem>
          <para>
           首先，执行一次内连接。然后，为 T2 中每一个无法在连接条件上匹配 T1 里任何一行的行返回一个连接行，该连接行中 T1 的列用空值补齐。因此，生成的连接表里为来自 T2 的每一行都至少包含一行。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>FULL OUTER JOIN</></term>

         <listitem>
          <para>
           首先，执行一次内连接。然后，为 T1 中每一个无法在连接条件上匹配 T2 里任何一行的行返回一个连接行，该连接行中 T2 的列用空值补齐。同样，为 T2 中每一个无法在连接条件上匹配 T1 里任何一行的行返回一个连接行，该连接行中 T1 的列用空值补齐。
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
       </para>
       
       <para>
       <literal>ON</>子句是最常见的连接条件的形式：它接收一个和<literal>WHERE</>子句里用的一样的布尔值表达式。 如果两个分别来自<replaceable>T1</>和<replaceable>T2</>的行在<literal>ON</>表达式上运算的结果为真，那么它们就算是匹配的行。
       </para>

       <para>
        <literal>USING</>是个缩写符号，它允许你利用特殊的情况：
        连接的两端都具有相同的连接列名。它接受共享列名的一个逗号分隔
        列表，并且为其中每一个共享列构造一个包含等值比较的连接条件。
        例如用<literal>USING (a, b)</>连接<replaceable>T1</>
        和<replaceable>T2</>会产生连接条件
        <literal>ON <replaceable>T1</>.a
        = <replaceable>T2</>.a AND <replaceable>T1</>.b
        = <replaceable>T2</>.b</literal>。
       </para>
       
       <para>
        更进一步，<literal>JOIN USING</>的输出会废除冗余列：不需要把匹配
        上的列都打印出来，因为它们必须具有相等的值。不过<literal>JOIN
        ON</>会先产生来自<replaceable>T1</>的所有列，后面跟上所有来自
        <replaceable>T2</>的列；而<literal>JOIN USING</>会先为列出的每
        一个列对产生一个输出列，然后先跟上来自<replaceable>T1</>的剩余列，
        最后跟上来自<replaceable>T2</>的剩余列。
       </para>

       <para>
        <indexterm>
         <primary>连接</primary>
         <secondary>自然</secondary>
        </indexterm>
        <indexterm>
         <primary>自然连接</primary>
        </indexterm>
        最后，<literal>NATURAL</>是<literal>USING</>的缩写形式：它形成一个<literal>USING</>列表， 该列表由那些在两个表里都出现了的列名组成。和<literal>USING</>一样，这些列只在输出表里出现一次。如果不存在公共列，<literal>NATURAL</literal>的行为将和<literal>CROSS JOIN</literal>一样。
       </para>
       
       <note>
        <para>
         <literal>USING</literal>对于连接关系中的列改变是相当安全的，因为
         只有被列出的列会被组合成连接条件。<literal>NATURAL</>的风险更大，
         因为如果其中一个关系的模式改变会导致出现一个新的匹配列名，就会导致
         连接将新列也组合成连接条件。
        </para>
       </note>
      </listitem>
     </varlistentry>
    </variablelist>

    <para>
     为了解释这些问题，假设我们有一个表<literal>t1</literal>：
<programlisting>
 num | name
-----+------
   1 | a
   2 | b
   3 | c
</programlisting>
     和<literal>t2</literal>：
<programlisting>
 num | value
-----+-------
   1 | xxx
   3 | yyy
   5 | zzz
</programlisting>
     然后我们用不同的连接方式可以获得各种结果：
<screen>
<prompt>=&gt;</> <userinput>SELECT * FROM t1 CROSS JOIN t2;</>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   1 | a    |   3 | yyy
   1 | a    |   5 | zzz
   2 | b    |   1 | xxx
   2 | b    |   3 | yyy
   2 | b    |   5 | zzz
   3 | c    |   1 | xxx
   3 | c    |   3 | yyy
   3 | c    |   5 | zzz
(9 rows)

<prompt>=&gt;</> <userinput>SELECT * FROM t1 INNER JOIN t2 ON t1.num = t2.num;</>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   3 | c    |   3 | yyy
(2 rows)

<prompt>=&gt;</> <userinput>SELECT * FROM t1 INNER JOIN t2 USING (num);</>
 num | name | value
-----+------+-------
   1 | a    | xxx
   3 | c    | yyy
(2 rows)

<prompt>=&gt;</> <userinput>SELECT * FROM t1 NATURAL INNER JOIN t2;</>
 num | name | value
-----+------+-------
   1 | a    | xxx
   3 | c    | yyy
(2 rows)

<prompt>=&gt;</> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num;</>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |   3 | yyy
(3 rows)

<prompt>=&gt;</> <userinput>SELECT * FROM t1 LEFT JOIN t2 USING (num);</>
 num | name | value
-----+------+-------
   1 | a    | xxx
   2 | b    |
   3 | c    | yyy
(3 rows)

<prompt>=&gt;</> <userinput>SELECT * FROM t1 RIGHT JOIN t2 ON t1.num = t2.num;</>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   3 | c    |   3 | yyy
     |      |   5 | zzz
(3 rows)

<prompt>=&gt;</> <userinput>SELECT * FROM t1 FULL JOIN t2 ON t1.num = t2.num;</>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |   3 | yyy
     |      |   5 | zzz
(4 rows)
</screen>
    </para>

    <para>
     用<literal>ON</>指定的连接条件也可以包含与连接不直接相关的条件。这种功能可能对某些查询很有用，但是需要我们仔细想清楚。例如：
<screen>
<prompt>=&gt;</> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num AND t2.value = 'xxx';</>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |     |
(3 rows)
</screen>
     注意把限制放在<literal>WHERE</>子句中会产生不同的结果：
<screen>
<prompt>=&gt;</> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num WHERE t2.value = 'xxx';</>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
(1 row)
</screen>
     这是因为放在<literal>ON</>子句中的一个约束在连接<emphasis>之前</>被处理，而放在<literal>WHERE</>子句中的一个约束是在连接<emphasis>之后</>被处理。这对内连接没有关系，但是对于外连接会带来麻烦。
    </para>
   </sect3>

   <sect3 id="queries-table-aliases">
    <title>表和列别名</title>

    <indexterm zone="queries-table-aliases">
     <primary>别名</primary>
     <secondary>在FROM子句中</secondary>
    </indexterm>

    <indexterm>
     <primary>标签</primary>
     <see>别名</see>
    </indexterm>

    <para>
     你可以给一个表或复杂的表引用指定一个临时的名字，用于剩下的查询中引用那些派生的表。这被叫做<firstterm>表别名</firstterm>。
    </para>

    <para>
     要创建一个表别名，我们可以写：
<synopsis>
FROM <replaceable>table_reference</replaceable> AS <replaceable>alias</replaceable>
</synopsis>
     或者
<synopsis>
FROM <replaceable>table_reference</replaceable> <replaceable>alias</replaceable>
</synopsis>
     <literal>AS</literal>关键字是可选的。<replaceable>别名</replaceable>可以是任意标识符。
    </para>

    <para>
     表别名的典型应用是给长表名赋予比较短的标识符， 好让连接子句更易读。例如：
<programlisting>
SELECT * FROM some_very_long_table_name s JOIN another_fairly_long_name a ON s.id = a.num;
</programlisting>
    </para>

    <para>
     到这里，别名成为当前查询的表引用的新名称 &mdash; 我们不再能够用该表最初的名字引用它了。因此，下面的用法是不合法的：
<programlisting>
SELECT * FROM my_table AS m WHERE my_table.a &gt; 5;    -- 错误
</programlisting>
    </para>

    <para>
     表别名主要用于简化符号，但是当把一个表连接到它自身时必须使用别名，例如：
<programlisting>
SELECT * FROM people AS mother JOIN people AS child ON mother.id = child.mother_id;
</programlisting>
     此外，如果一个表引用是一个子查询，则必须要使用一个别名（见<xref linkend="queries-subqueries">）。
    </para>

    <para>
     圆括弧用于解决歧义。在下面的例子中，第一个语句将把别名<literal>b</literal>赋给<literal>my_table</>的第二个实例，但是第二个语句把别名赋给连接的结果：
<programlisting>
SELECT * FROM my_table AS a CROSS JOIN my_table AS b ...
SELECT * FROM (my_table AS a CROSS JOIN my_table) AS b ...
</programlisting>
    </para>

    <para>
     另外一种给表指定别名的形式是给表的列赋予临时名字，就像给表本身指定别名一样：
<synopsis>
FROM <replaceable>table_reference</replaceable> <optional>AS</optional> <replaceable>alias</replaceable> ( <replaceable>column1</replaceable> <optional>, <replaceable>column2</replaceable> <optional>, ...</optional></optional> )
</synopsis>
     如果指定的列别名比表里实际的列少，那么剩下的列就没有被重命名。这种语法对于自连接或子查询特别有用。
    </para>

    <para>
     如果用这些形式中的任何一种给一个<literal>JOIN</>子句的输出附加了一个别名， 那么该别名就在<literal>JOIN</>的作用下隐去了其原始的名字。例如：
<programlisting>
SELECT a.* FROM my_table AS a JOIN your_table AS b ON ...
</programlisting>
     是合法 SQL，但是：
<programlisting>
SELECT a.* FROM (my_table AS a JOIN your_table AS b ON ...) AS c
</programlisting>
     是不合法的：表别名<literal>a</>在别名<literal>c</>外面是看不到的。
    </para>
   </sect3>

   <sect3 id="queries-subqueries">
    <title>子查询</title>

    <indexterm zone="queries-subqueries">
     <primary>子查询</primary>
    </indexterm>

    <para>
     子查询指定了一个派生表，它必须被包围在圆括弧里并且<emphasis>必须</emphasis>被赋予一个表别名（参阅<xref linkend="queries-table-aliases">）。例如：
<programlisting>
FROM (SELECT * FROM table1) AS alias_name
</programlisting>
    </para>

    <para>
     这个例子等效于<literal>FROM table1 AS alias_name</literal>。更有趣的情况是在子查询里面有分组或聚集的时候， 子查询不能被简化为一个简单的连接。
    </para>

    <para>
     一个子查询也可以是一个<command>VALUES</>列表：
<programlisting>
FROM (VALUES ('anne', 'smith'), ('bob', 'jones'), ('joe', 'blow'))
     AS names(first, last)
</programlisting>
     再次的，这里要求一个表别名。为<command>VALUES</>列表中的列分配别名是可选的，但是选择这样做是一个好习惯。更多信息可参见<xref linkend="queries-values">。
    </para>
   </sect3>

   <sect3 id="queries-tablefunctions">
    <title>表函数</title>

    <indexterm zone="queries-tablefunctions"><primary>表函数</></>

    <indexterm zone="queries-tablefunctions">
     <primary>函数</>
     <secondary>在FROM子句中</>
    </indexterm>

    <para>
     表函数是那些生成一个行集合的函数，这个集合可以是由基本数据类型（标量类型）组成， 也可以是由复合数据类型（表行）组成。它们的用法类似一个表、视图或者在查询的<literal>FROM</>子句里的子查询。表函数返回的列可以像一个表列、视图或者子查询那样被包含在<literal>SELECT</>、<literal>JOIN</>或<literal>WHERE</>子句里。
    </para>

    <para>
     也可以使用<literal>ROWS FROM</>语法将平行列返回的结果组合成表函数；
     这种情况下结果行的数量是最大一个函数结果的数量，较小的结果会用空值来填充。
    </para>

<synopsis>
<replaceable>function_call</replaceable> <optional>WITH ORDINALITY</optional> <optional><optional>AS</optional> <replaceable>table_alias</replaceable> <optional>(<replaceable>column_alias</replaceable> <optional>, ... </optional>)</optional></optional>
ROWS FROM( <replaceable>function_call</replaceable> <optional>, ... </optional> ) <optional>WITH ORDINALITY</optional> <optional><optional>AS</optional> <replaceable>table_alias</replaceable> <optional>(<replaceable>column_alias</replaceable> <optional>, ... </optional>)</optional></optional>
</synopsis>

    <para>
     如果指定了<literal>WITH ORDINALITY</literal>子句，一个额外的
     <type>bigint</type>类型的列将会被增加到函数的结果列中。这个列对
     函数结果集的行进行编号，编号从 1 开始（这是对 SQL 标准语法
     <literal>UNNEST ... WITH ORDINALITY</literal>的一般化）。默认情
     况下，序数列被称为<literal>ordinality</>，但也可以通过使用一个
     <literal>AS</literal>子句给它分配一个不同的列名。
    </para>

    <para>
     调用特殊的表函数<literal>UNNEST</literal>可以使用任意数量的数组参数，
     它会返回对应的列数，就好像在每一个参数上单独调用
     <literal>UNNEST</literal>（<xref linkend="functions-array">）并且使用
     <literal>ROWS FROM</literal>结构把它们组合起来。
    </para>

<synopsis>
UNNEST( <replaceable>array_expression</replaceable> <optional>, ... </optional> ) <optional>WITH ORDINALITY</optional> <optional><optional>AS</optional> <replaceable>table_alias</replaceable> <optional>(<replaceable>column_alias</replaceable> <optional>, ... </optional>)</optional></optional>
</synopsis>

    <para>
     如果没有指定<replaceable>table_alias</replaceable>，该函数名将被用作
     表名。在<literal>ROWS FROM()</>结构的情况中，会使用第一个函数名。
    </para>

    <para>
     如果没有提供列的别名，那么对于一个返回基数据类型的函数，列名也与该函数
     名相同。对于一个返回组合类型的函数，结果列会从该类型的属性得到名称。
    </para>

    <para>
     例子：
<programlisting>
CREATE TABLE foo (fooid int, foosubid int, fooname text);

CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS $$
    SELECT * FROM foo WHERE fooid = $1;
$$ LANGUAGE SQL;

SELECT * FROM getfoo(1) AS t1;

SELECT * FROM foo
    WHERE foosubid IN (
                        SELECT foosubid
                        FROM getfoo(foo.fooid) z
                        WHERE z.fooid = foo.fooid
                      );

CREATE VIEW vw_getfoo AS SELECT * FROM getfoo(1);

SELECT * FROM vw_getfoo;
</programlisting>
    </para>

    <para>
     有时侯，定义一个能够根据它们被调用方式返回不同列集合的表函数是很有用的。为了支持这些，表函数可以被声明为返回伪类型<type>record</>。 如果在查询里使用这样的函数，那么我们必须在查询中指定所预期的行结构，这样系统才知道如何分析和规划该查询。这种语法是这样的：
     </para>

<synopsis>
<replaceable>function_call</replaceable> <optional>AS</optional> <replaceable>alias</replaceable> (<replaceable>column_definition</replaceable> <optional>, ... </optional>)
<replaceable>function_call</replaceable> AS <optional><replaceable>alias</replaceable></optional> (<replaceable>column_definition</replaceable> <optional>, ... </optional>)
ROWS FROM( ... <replaceable>function_call</replaceable> AS (<replaceable>column_definition</replaceable> <optional>, ... </optional>) <optional>, ... </optional> )
</synopsis>

    <para>
     在没有使用<literal>ROWS FROM()</>语法时，
     <replaceable>column_definition</replaceable>列表会取代无法附着在
     <literal>FROM</>项上的列别名列表，列定义中的名称就起到列别名的作用。
     在使用<literal>ROWS FROM()</>语法时，
     可以为每一个成员函数单独附着一个
     <replaceable>column_definition</replaceable>列表；或者在只有一个成员
     函数并且没有<literal>WITH ORDINALITY</>子句的情况下，可以在
     <literal>ROWS FROM()</>后面写一个
     <replaceable>column_definition</replaceable>列表来取代一个列别名列表。
    </para>

    <para>
     考虑下面的例子：
<programlisting>
SELECT *
    FROM dblink('dbname=mydb', 'SELECT proname, prosrc FROM pg_proc')
      AS t1(proname name, prosrc text)
    WHERE proname LIKE 'bytea%';
</programlisting>
     <xref linkend="CONTRIB-DBLINK-FUNCTION">函数（<xref linkend="dblink">模块的一部分）执行一个远程的查询。它被声明为返回<type>record</>，因为它可能会被用于任何类型的查询。 实际的列集必须在调用它的查询中指定，这样分析器才知道类似<literal>*</>这样的东西应该扩展成什么样子。
    </para>
   </sect3>

   <sect3 id="queries-lateral">
    <title><literal>LATERAL</>子查询</title>

    <indexterm zone="queries-lateral">
     <primary>LATERAL</>
     <secondary>在FROM子句中</>
    </indexterm>

    <para>
     可以在出现于<literal>FROM</>中的子查询前放置关键词<literal>LATERAL</>。这允许它们引用前面的<literal>FROM</>项提供的列（如果没有<literal>LATERAL</literal>，每一个子查询将被独立计算，并且因此不能被其他<literal>FROM</literal>项交叉引用）。
    </para>

    <para>
     出现在<literal>FROM</>中的表函数的前面也可以被放上关键词<literal>LATERAL</>，但对于函数该关键词是可选的，在任何情况下函数的参数都可以包含对前面的<literal>FROM</>项提供的列的引用。
    </para>

    <para>
     一个<literal>LATERAL</literal>项可以出现在<literal>FROM</>列表顶层，或者出现在一个<literal>JOIN</>树中。在后一种情况下，如果它出现在<literal>JOIN</>的右部，那么它也可以引用 在<literal>JOIN</>左部的任何项。
    </para>

    <para>
     如果一个<literal>FROM</>项包含<literal>LATERAL</literal>交叉引用，计算过程如下：对于提供交叉引用列的<literal>FROM</>项的每一行，或者多个提供这些列的多个<literal>FROM</>项的行集合，<literal>LATERAL</literal>项将被使用该行或者行集中的列值进行计算。得到的结果行将和它们被计算出来的行进行正常的连接。对于来自这些列的源表的每一行或行集，该过程将重复。
    </para>

    <para>
     <literal>LATERAL</literal>的一个简单例子：
<programlisting>
SELECT * FROM foo, LATERAL (SELECT * FROM bar WHERE bar.id = foo.bar_id) ss;
</programlisting>
     这不是非常有用，因为它和一种更简单的形式得到的结果完全一样：
<programlisting>
SELECT * FROM foo, bar WHERE bar.id = foo.bar_id;
</programlisting>
     在必须要使用交叉引用列来计算那些即将要被连接的行时，<literal>LATERAL</literal>是最有用的。一种常用的应用是为一个返回集合的函数提供一个参数值。例如，假设<function>vertices(polygon)</>返回一个多边形的顶点集合，我们可以这样标识存储在一个表中的多边形中靠近的顶点：
<programlisting>
SELECT p1.id, p2.id, v1, v2
FROM polygons p1, polygons p2,
     LATERAL vertices(p1.poly) v1,
     LATERAL vertices(p2.poly) v2
WHERE (v1 &lt;-&gt; v2) &lt; 10 AND p1.id != p2.id;
</programlisting>
     这个查询也可以被写成：
<programlisting>
SELECT p1.id, p2.id, v1, v2
FROM polygons p1 CROSS JOIN LATERAL vertices(p1.poly) v1,
     polygons p2 CROSS JOIN LATERAL vertices(p2.poly) v2
WHERE (v1 &lt;-&gt; v2) &lt; 10 AND p1.id != p2.id;
</programlisting>
     或者写成其他几种等价的公式（正如以上提到的，<literal>LATERAL</>关键词在这个例子中并不是必不可少的，但是我们在这里使用它是为了使表述更清晰）。
    </para>

    <para>
     有时候也会很特别地把<literal>LEFT JOIN</>放在一个<literal>LATERAL</literal>子查询的前面，这样即使<literal>LATERAL</literal>子查询对源行不产生行，源行也会出现在结果中。例如，如果<function>get_product_names()</>返回一个制造商制造的产品的名字，但是某些制造商在我们的表中目前没有制造产品，我们可以找出哪些制造商是这样：
<programlisting>
SELECT m.name
FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true
WHERE pname IS NULL;
</programlisting>
    </para>
   </sect3>
  </sect2>

  <sect2 id="queries-where">
   <title><literal>WHERE</literal>子句</title>

   <indexterm zone="queries-where">
    <primary>WHERE</primary>
   </indexterm>

   <para>
    <xref linkend="sql-where" endterm="sql-where-title">的语法是
<synopsis>
WHERE <replaceable>search_condition</replaceable>
</synopsis>
    这里的<replaceable>search_condition</replaceable>是任意返回一个<type>boolean</type>类型值的值表达式（参阅<xref linkend="sql-expressions">）。
   </para>

   <para>
    在完成对<literal>FROM</>子句的处理之后，生成的虚拟表的每一行都会对根据搜索条件进行检查。 如果该条件的结果是真，那么该行被保留在输出表中；否则（也就是说，如果结果是假或空）就把它抛弃。搜索条件通常至少要引用一些在<literal>FROM</>子句里生成的列；虽然这不是必须的，但如果不引用这些列，那么<literal>WHERE</>子句就没什么用了。
   </para>

   <note>
    <para>
     内连接的连接条件既可以写在<literal>WHERE</>子句也可以写在<literal>JOIN</>子句里。例如，这些表表达式是等效的：
<programlisting>
FROM a, b WHERE a.id = b.id AND b.val &gt; 5
</programlisting>
     和：
<programlisting>
FROM a INNER JOIN b ON (a.id = b.id) WHERE b.val &gt; 5
</programlisting>
     或者可能还有：
<programlisting>
FROM a NATURAL JOIN b WHERE b.val &gt; 5
</programlisting>
     你想用哪个只是一个风格问题。<literal>FROM</>子句里的<literal>JOIN</>语法可能不那么容易移植到其它SQL数据库管理系统中。 对于外部连接而言没有选择：它们必须在<literal>FROM</>子句中完成。 外部连接的<literal>ON</>或<literal>USING</>子句<emphasis>不</>等于<literal>WHERE</>条件，因为它导致最终结果中行的增加（对那些不匹配的输入行）和减少。
    </para>
   </note>

   <para>
    这里是一些<literal>WHERE</literal>子句的例子：
<programlisting>
SELECT ... FROM fdt WHERE c1 &gt; 5

SELECT ... FROM fdt WHERE c1 IN (1, 2, 3)

SELECT ... FROM fdt WHERE c1 IN (SELECT c1 FROM t2)

SELECT ... FROM fdt WHERE c1 IN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10)

SELECT ... FROM fdt WHERE c1 BETWEEN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10) AND 100

SELECT ... FROM fdt WHERE EXISTS (SELECT c1 FROM t2 WHERE c2 &gt; fdt.c1)
</programlisting>
    在上面的例子里，<literal>fdt</literal>是从FROM子句中派生的表。 那些不符合<literal>WHERE</>子句的搜索条件的行会被从<literal>fdt</literal>中删除。请注意我们把标量子查询当做一个值表达式来用。 和任何其它查询一样，子查询里可以使用复杂的表表达式。同时还请注意<literal>fdt</literal>在子查询中也被引用。只有在<literal>c1</>也是作为子查询输入表的生成表的列时，才必须把<literal>c1</>限定成<literal>fdt.c1</>。但限定列名字可以增加语句的清晰度，即使有时候不是必须的。这个例子展示了一个外层查询的列名范围如何扩展到它的内层查询。
   </para>
  </sect2>


  <sect2 id="queries-group">
   <title><literal>GROUP BY</literal>和<literal>HAVING</literal>子句</title>

   <indexterm zone="queries-group">
    <primary>GROUP BY</primary>
   </indexterm>

   <indexterm zone="queries-group">
    <primary>分组</primary>
   </indexterm>

   <para>
    在通过了<literal>WHERE</>过滤器之后，生成的输入表可以使用<literal>GROUP BY</>子句进行分组，然后用<literal>HAVING</>子句删除一些分组行。
   </para>

<synopsis>
SELECT <replaceable>select_list</replaceable>
    FROM ...
    <optional>WHERE ...</optional>
    GROUP BY <replaceable>grouping_column_reference</replaceable> <optional>, <replaceable>grouping_column_reference</replaceable></optional>...
</synopsis>

   <para>
    <xref linkend="sql-groupby" endterm="sql-groupby-title">被用来把表中在所列出的列上具有相同值的行分组在一起。 这些列的列出顺序并没有什么关系。其效果是把每组具有相同值的行组合为一个组行，它代表该组里的所有行。 这样就可以删除输出里的重复和/或计算应用于这些组的聚集。例如：
<screen>
<prompt>=&gt;</> <userinput>SELECT * FROM test1;</>
 x | y
---+---
 a | 3
 c | 2
 b | 5
 a | 1
(4 rows)

<prompt>=&gt;</> <userinput>SELECT x FROM test1 GROUP BY x;</>
 x
---
 a
 b
 c
(3 rows)
</screen>
   </para>

   <para>
    在第二个查询里，我们不能写成<literal>SELECT * FROM test1 GROUP BY x</literal>， 因为列<literal>y</>里没有哪个值可以和每个组相关联起来。被分组的列可以在选择列表中引用是因为它们在每个组都有单一的值。
   </para>

   <para>
    通常，如果一个表被分了组，那么没有在<literal>GROUP BY</>中列出的列都不能被引用，除非在聚集表达式中被引用。 一个用聚集表达式的例子是：
<screen>
<prompt>=&gt;</> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x;</>
 x | sum
---+-----
 a |   4
 b |   5
 c |   2
(3 rows)
</screen>
    这里的<literal>sum</literal>是一个聚集函数，它在整个组上计算出一个单一值。有关可用的聚集函数的更多信息可以在<xref linkend="functions-aggregate">。
   </para>

   <tip>
    <para>
     没有聚集表达式的分组实际上计算了一个列中可区分值的集合。我们也可以用<literal>DISTINCT</>子句实现（参阅<xref linkend="queries-distinct">）。
    </para>
   </tip>

   <para>
    这里是另外一个例子：它计算每种产品的总销售额（而不是所有产品的总销售额）：
<programlisting>
SELECT product_id, p.name, (sum(s.units) * p.price) AS sales
    FROM products p LEFT JOIN sales s USING (product_id)
    GROUP BY product_id, p.name, p.price;
</programlisting>
    在这个例子里，列<literal>product_id</literal>、<literal>p.name</literal>和<literal>p.price</literal>必须在<literal>GROUP BY</>子句里， 因为它们都在查询的选择列表里被引用到（但见下文）。列<literal>s.units</>不必在<literal>GROUP BY</>列表里，因为它只是在一个聚集表达式（<literal>sum(...)</literal>）里使用，它代表一组产品的销售额。对于每种产品，这个查询都返回一个该产品的所有销售额的总和行。
   </para>

   <indexterm><primary>函数依赖</primary></indexterm>

   <para>
    如果产品表被建立起来，例如<literal>product_id</literal>是主键，那么在上面的例子中用<literal>product_id</literal>来分组就够了，因为名称和价格都是<firstterm>函数依赖</firstterm>于产品ID，并且关于为每个产品ID分组返回哪个名称和价格值就不会有歧义。
   </para>

   <para>
    在严格的 SQL 里，<literal>GROUP BY</>只能对源表的列进行分组，但<productname>PostgreSQL</productname>把这个扩展为也允许<literal>GROUP BY</>去根据选择列表中的列分组。也允许对值表达式进行分组，而不仅是简单的列名。
   </para>

   <indexterm>
    <primary>HAVING</primary>
   </indexterm>

   <para>
    如果一个表已经用<literal>GROUP BY</literal>子句分了组，然后你又只对其中的某些组感兴趣， 那么就可以用<literal>HAVING</literal>子句，它很象<literal>WHERE</>子句，用于从结果中删除一些组。其语法是：
<synopsis>
SELECT <replaceable>select_list</replaceable> FROM ... <optional>WHERE ...</optional> GROUP BY ... HAVING <replaceable>boolean_expression</replaceable>
</synopsis>
    在<literal>HAVING</>子句中的表达式可以引用分组的表达式和未分组的表达式（后者必须涉及一个聚集函数）。
   </para>

   <para>
    例子：
<screen>
<prompt>=&gt;</> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x HAVING sum(y) &gt; 3;</>
 x | sum
---+-----
 a |   4
 b |   5
(2 rows)

<prompt>=&gt;</> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x HAVING x &lt; 'c';</>
 x | sum
---+-----
 a |   4
 b |   5
(2 rows)
</screen>
   </para>

   <para>
    再次，一个更现实的例子：
<programlisting>
SELECT product_id, p.name, (sum(s.units) * (p.price - p.cost)) AS profit
    FROM products p LEFT JOIN sales s USING (product_id)
    WHERE s.date &gt; CURRENT_DATE - INTERVAL '4 weeks'
    GROUP BY product_id, p.name, p.price, p.cost
    HAVING sum(p.price * s.units) &gt; 5000;
</programlisting>
    在上面的例子里，<literal>WHERE</>子句用那些非分组的列选择数据行（表达式只是对那些最近四周发生的销售为真）。 而<literal>HAVING</>子句限制输出为总销售收入超过 5000 的组。请注意聚集表达式不需要在查询中的所有地方都一样。
   </para>

   <para>
    如果一个查询包含聚集函数调用，但是没有<literal>GROUP BY</>子句，分组仍然会发生：结果是一个单一行（或者根本就没有行，如果该单一行被<literal>HAVING</>所消除）。它包含一个<literal>HAVING</>子句时也是这样，即使没有任何聚集函数调用或者<literal>GROUP BY</>子句。
   </para>
  </sect2>

  <sect2 id="queries-window">
   <title>窗口函数处理</title>

   <indexterm zone="queries-window">
    <primary>窗口函数</primary>
    <secondary>执行顺序</>
   </indexterm>

   <para>
    如果查询包含任何窗口函数（见<xref linkend="tutorial-window">、<xref linkend="functions-window">和<xref linkend="syntax-window-functions">），这些函数将在任何分组、聚集和<literal>HAVING</>过滤被执行之后被计算。也就是说如果查询使用了任何聚集、<literal>GROUP BY</>或<literal>HAVING</>，则窗口函数看到的行是分组行而不是来自于<literal>FROM</>/<literal>WHERE</>的原始表行。
   </para>

   <para>
    当多个窗口函数被使用，所有在窗口定义中有句法上等效的<literal>PARTITION BY</>和<literal>ORDER BY</>子句的窗口函数被保证在数据上的同一趟扫描中计算。因此它们将会看到相同的排序顺序，即使<literal>ORDER BY</>没有唯一地决定一个顺序。但是，对于具有不同<literal>PARTITION BY</>或<literal>ORDER BY</>定义的函数的计算没有这种保证（在这种情况中，在多个窗口函数计算之间通常要求一个排序步骤，并且并不保证保留行的顺序，即使它的<literal>ORDER BY</>把这些行视为等效的）。
   </para>

   <para>
    目前，窗口函数总是要求排序好的数据，并且这样查询的输出总是被根据窗口函数的<literal>PARTITION BY</>/<literal>ORDER BY</>子句的一个或者另一个排序。但是，我们不推荐依赖于此。如果你希望确保结果以特定的方式排序，请显式使用顶层的<literal>ORDER BY</>子句。
   </para>
  </sect2>
 </sect1>


 <sect1 id="queries-select-lists">
  <title>选择列表</title>

  <indexterm>
   <primary>SELECT</primary>
   <secondary>选择列表</secondary>
  </indexterm>

  <para>
   如前面的小节说明的那样， 在<command>SELECT</command>命令里的表表达式构造了一个中间的虚拟表， 方法可能有组合表、视图、消除行、分组等等。这个表最后被<firstterm>选择列表</firstterm>传递下去处理。选择列表判断中间表的哪个<emphasis>列</emphasis>是实际输出。
  </para>

  <sect2 id="queries-select-list-items">
   <title>选择列表项</title>

   <indexterm>
    <primary>*</primary>
   </indexterm>

   <para>
    最简单的选择列表类型是<literal>*</literal>，它发出表表达式生成的所有列。否则，一个选择列表是一个逗号分隔的值表达式的列表（和在<xref linkend="sql-expressions">里定义的一样）。 例如，它可能是一个列名的列表：
<programlisting>
SELECT a, b, c FROM ...
</programlisting>
     列名字<literal>a</>、<literal>b</>和<literal>c</>要么是在<literal>FROM</>子句里引用的表中列的实际名字，要么是像<xref linkend="queries-table-aliases">里解释的那样的别名。在选择列表里可用的名字空间和在<literal>WHERE</>子句里的一样， 除非你使用了分组，这时候它和<literal>HAVING</>子句一样。
   </para>

   <para>
    如果超过一个表有同样的列名，那么你还必须给出表名字，如：
<programlisting>
SELECT tbl1.a, tbl2.a, tbl1.b FROM ...
</programlisting>
    在使用多个表时，要求一个特定表的所有列也是有用的：
<programlisting>
SELECT tbl1.*, tbl2.a FROM ...
</programlisting>
    （另见<xref linkend="queries-where">）。
   </para>

   <para>
    如果将任意值表达式用于选择列表，那么它在概念上向返回的表中增加了一个新的虚拟列。 值表达式为结果的每一行进行一次计算，对任何列引用替换行的值。 不过选择列表中的这个表达式并非一定要引用来自<literal>FROM</>子句中表表达式里面的列，例如它也可以是任意常量算术表达式。
   </para>
  </sect2>

  <sect2 id="queries-column-labels">
   <title>列标签</title>

   <indexterm zone="queries-column-labels">
    <primary>别名</primary>
    <secondary>在选择列表中</secondary>
   </indexterm>

   <para>
    选择列表中的项可以被赋予名字，用于进一步的处理。 例如为了在一个<literal>ORDER BY</>子句中使用或者为了客户端应用显示。例如：
<programlisting>
SELECT a AS value, b + c AS sum FROM ...
</programlisting>
   </para>

   <para>
    如果没有使用<literal>AS</>指定输出列名，那么系统会分配一个缺省的列名。对于简单的列引用， 它是被引用列的名字。对于函数调用，它是函数的名字。对于复杂表达式，系统会生成一个通用的名字。
   </para>

   <para>
    只有在新列无法匹配任何<productname>PostgreSQL</productname>关键词（见<xref linkend="sql-keywords-appendix">）时，<literal>AS</>关键词是可选的。为了避免一个关键字的意外匹配，你可以使用双引号来修饰列名。例如，<literal>VALUE</>是一个关键字，所以下面的语句不会工作：
<programlisting>
SELECT a value, b + c AS sum FROM ...
</programlisting>
    但是这个可以：
<programlisting>
SELECT a "value", b + c AS sum FROM ...
</programlisting>
    为了防止未来可能的关键词增加，我们推荐总是写<literal>AS</literal>或者用双引号修饰输出列名。
   </para>

   <note>
    <para>
     输出列的命名和在<literal>FROM</>子句里的命名是不一样的 （参阅<xref linkend="queries-table-aliases">）。 它实际上允许你对同一个列命名两次，但是在选择列表中分配的名字是要传递下去的名字。
    </para>
   </note>
  </sect2>

  <sect2 id="queries-distinct">
   <title><literal>DISTINCT</literal></title>

   <indexterm zone="queries-distinct">
    <primary>DISTINCT</primary>
   </indexterm>

   <indexterm zone="queries-distinct">
    <primary>重复</primary>
   </indexterm>

   <para>
    在处理完选择列表之后，结果表可以可选的删除重复行。我们可以直接在<literal>SELECT</literal>后面写上<literal>DISTINCT</literal>关键字来指定：
<synopsis>
SELECT DISTINCT <replaceable>select_list</replaceable> ...
</synopsis>
    （如果不用<literal>DISTINCT</>你可以用<literal>ALL</literal>关键词来指定获得的所有行的缺省行为）。
   </para>

   <indexterm>
    <primary>空值</>
    <secondary sortas="DISTINCT">in DISTINCT</>
   </indexterm>

   <para>
    显然，如果两行里至少有一个列有不同的值，那么我们认为它是可区分的。空值在这种比较中被认为是相同的。
   </para>

   <para>
    另外，我们还可以用任意表达式来判断什么行可以被认为是可区分的：
<synopsis>
SELECT DISTINCT ON (<replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ...</optional>) <replaceable>select_list</replaceable> ...
</synopsis>
    这里<replaceable>expression</replaceable>是任意值表达式，它为所有行计算。如果一个行集合里所有表达式的值是一样的， 那么我们认为它们是重复的并且因此只有第一行保留在输出中。请注意这里的一个集合的<quote>第一行</quote>是不可预料的， 除非你在足够多的列上对该查询排了序，保证到达<literal>DISTINCT</>过滤器的行的顺序是唯一的（<literal>DISTINCT ON</>处理是发生在<literal>ORDER BY</>排序后面的）。
   </para>

   <para>
    <literal>DISTINCT ON</>子句不是 SQL 标准的一部分， 有时候有人认为它是一个糟糕的风格，因为它的结果是不可判定的。 如果有选择的使用<literal>GROUP BY</>和在<literal>FROM</>中的子查询，那么我们可以避免使用这个构造， 但是通常它是更方便的候选方法。
   </para>
  </sect2>
 </sect1>


 <sect1 id="queries-union">
  <title>组合查询</title>

  <indexterm zone="queries-union">
   <primary>UNION</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>INTERSECT</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>EXCEPT</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>集合并</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>集合交</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>集合差</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>集合操作</primary>
  </indexterm>

  <para>
   两个查询的结果可以用集合操作并、交、差进行组合。语法是
<synopsis>
<replaceable>query1</replaceable> UNION <optional>ALL</optional> <replaceable>query2</replaceable>
<replaceable>query1</replaceable> INTERSECT <optional>ALL</optional> <replaceable>query2</replaceable>
<replaceable>query1</replaceable> EXCEPT <optional>ALL</optional> <replaceable>query2</replaceable>
</synopsis>
   <replaceable>query1</replaceable>和<replaceable>query2</replaceable>都是可以使用以上所有特性的查询。集合操作也可以嵌套和级连，例如
<synopsis>
<replaceable>query1</replaceable> UNION <replaceable>query2</replaceable> UNION <replaceable>query3</replaceable>
</synopsis>
   实际执行的是：
<synopsis>
(<replaceable>query1</replaceable> UNION <replaceable>query2</replaceable>) UNION <replaceable>query3</replaceable>
</synopsis>
  </para>

  <para>
   <literal>UNION</>有效地把<replaceable>query2</replaceable>的结果附加到<replaceable>query1</replaceable>的结果上（不过我们不能保证这就是这些行实际被返回的顺序）。此外，它将删除结果中所有重复的行， 就象<literal>DISTINCT</>做的那样，除非你使用了<literal>UNION ALL</>。
  </para>

  <para>
   <literal>INTERSECT</>返回那些同时存在于<replaceable>query1</replaceable>和<replaceable>query2</replaceable>的结果中的行，除非声明了<literal>INTERSECT ALL</>， 否则所有重复行都被消除。
  </para>

  <para>
   <literal>EXCEPT</>返回所有在<replaceable>query1</replaceable>的结果中但是不在<replaceable>query2</replaceable>的结果中的行（有时侯这叫做两个查询的<firstterm>差</>）。同样的，除非声明了<literal>EXCEPT ALL</>，否则所有重复行都被消除。
  </para>

  <para>
   为了计算两个查询的并、交、差，这两个查询必须是<quote>并操作兼容的</quote>，也就意味着它们都返回同样数量的列， 并且对应的列有兼容的数据类型，如<xref linkend="typeconv-union-case">中描述的那样。
  </para>
 </sect1>


 <sect1 id="queries-order">
  <title>行排序</title>

  <indexterm zone="queries-order">
   <primary>排序</primary>
  </indexterm>

  <indexterm zone="queries-order">
   <primary>ORDER BY</primary>
  </indexterm>

  <para>
   在一个查询生成一个输出表之后（在处理完选择列表之后），还可以选择性地对它进行排序。如果没有选择排序，那么行将以未指定的顺序返回。 这时候的实际顺序将取决于扫描和连接计划类型以及行在磁盘上的顺序，但是肯定不能依赖这些东西。一种特定的顺序只能在显式地选择了排序步骤之后才能被保证。
  </para>

  <para>
   <literal>ORDER BY</>子句指定了排序顺序：
<synopsis>
SELECT <replaceable>select_list</replaceable>
    FROM <replaceable>table_expression</replaceable>
    ORDER BY <replaceable>sort_expression1</replaceable> <optional>ASC | DESC</optional> <optional>NULLS { FIRST | LAST }</optional>
             <optional>, <replaceable>sort_expression2</replaceable> <optional>ASC | DESC</optional> <optional>NULLS { FIRST | LAST }</optional> ...</optional>
</synopsis>
   排序表达式可以是任何在查询的选择列表中合法的表达式。一个例子是：
<programlisting>
SELECT a, b FROM table1 ORDER BY a + b, c;
</programlisting>
   当多于一个表达式被指定，后面的值将被用于排序那些在前面值上相等的行。每一个表达式后可以选择性地放置一个<literal>ASC</>或<literal>DESC</>关键词来设置排序方向为升序或降序。<literal>ASC</>顺序是默认值。升序会把较小的值放在前面，而<quote>较小</quote>则由<literal>&lt;</literal>操作符定义。相似地，降序则由<literal>&gt;</literal>操作符定义。
    <footnote>
     <para>
      事实上，<productname>PostgreSQL</>为表达式的数据类型使用<firstterm>默认B-tree操作符类</>来决定<literal>ASC</>和<literal>DESC</>的排序顺序。照惯例，数据类型将被建立，这样<literal>&lt;</literal>和<literal>&gt;</literal>操作符负责这个排序顺序，但是一个用户定义的数据类型的设计者可以选择做些不同的设置。
     </para>
    </footnote>
  </para>

  <para>
   <literal>NULLS FIRST</>和<literal>NULLS LAST</>选项将可以被用来决定在排序顺序中，空值是出现在非空值之前或者出现在非空值之后。默认情况下，排序时空值被认为比任何非空值都要大，即<literal>NULLS FIRST</>是<literal>DESC</>顺序的默认值，而不是<literal>NULLS LAST</>的默认值。
  </para>

  <para>
   注意顺序选项是对每一个排序列独立考虑的。例如<literal>ORDER BY x, y DESC</>表示<literal>ORDER BY x ASC, y DESC</>，而和<literal>ORDER BY x DESC, y DESC</>不同。
  </para>

  <para>
   一个<replaceable>sort_expression</>也可以是列标签或者一个输出列的编号，如：
<programlisting>
SELECT a + b AS sum, c FROM table1 ORDER BY sum;
SELECT a, max(b) FROM table1 GROUP BY a ORDER BY 1;
</programlisting>
   两者都根据第一个输出列排序。注意一个输出列的名字必须孤立，即它不能被用在一个表达式中 &mdash; 例如，这是<emphasis>不</>正确的：
<programlisting>
SELECT a + b AS sum, c FROM table1 ORDER BY sum + c;          -- 错误
</programlisting>
   该限制是为了减少混淆。如果一个<literal>ORDER BY</>项是一个单一名字并且匹配一个输出列名或者一个表表达式的列，仍然会出现混淆。在这种情况中输出列将被使用。只有在你使用<literal>AS</>来重命名一个输出列来匹配某些其他表列的名字时，这才会导致混淆。
  </para>

  <para>
   <literal>ORDER BY</>可以被应用于<literal>UNION</>、<literal>INTERSECT</>或<literal>EXCEPT</>组合的结果，但是在这种情况中它只被允许根据输出列名或编号排序，而不能根据表达式排序。
  </para>
 </sect1>


 <sect1 id="queries-limit">
  <title><literal>LIMIT</literal>和<literal>OFFSET</literal></title>

  <indexterm zone="queries-limit">
   <primary>LIMIT</primary>
  </indexterm>

  <indexterm zone="queries-limit">
   <primary>OFFSET</primary>
  </indexterm>

  <para>
   <literal>LIMIT</>和<literal>OFFSET</>允许你只检索查询剩余部分产生的行的一部分：
<synopsis>
SELECT <replaceable>select_list</replaceable>
    FROM <replaceable>table_expression</replaceable>
    <optional> ORDER BY ... </optional>
    <optional> LIMIT { <replaceable>number</replaceable> | ALL } </optional> <optional> OFFSET <replaceable>number</replaceable> </optional>
</synopsis>
  </para>

  <para>
   如果给出了一个限制计数，那么会返回数量不超过该限制的行（但可能更少些，因为查询本身可能生成的行数就比较少）。<literal>LIMIT ALL</>的效果和省略<literal>LIMIT</>子句一样。
  </para>

  <para>
   <literal>OFFSET</>说明在开始返回行之前忽略多少行。<literal>OFFSET 0</>的效果和省略<literal>OFFSET</>子句是一样的，并且<literal>LIMIT NULL</>的效果和省略<literal>LIMIT</>子句一样。如果<literal>OFFSET</>和<literal>LIMIT</>都出现了， 那么在返回<literal>LIMIT</>个行之前要先忽略<literal>OFFSET</>行。
  </para>

  <para>
   如果使用<literal>LIMIT</>，那么用一个<literal>ORDER BY</>子句把结果行约束成一个唯一的顺序是很重要的。否则你就会拿到一个不可预料的该查询的行的子集。你要的可能是第十到第二十行，但以什么顺序的第十到第二十？除非你指定了<literal>ORDER BY</>，否则顺序是不知道的。
  </para>

  <para>
   查询优化器在生成查询计划时会考虑<literal>LIMIT</>，因此如果你给定<literal>LIMIT</>和<literal>OFFSET</>，那么你很可能收到不同的规划（产生不同的行顺序）。因此，使用不同的<literal>LIMIT</>/<literal>OFFSET</>值选择查询结果的不同子集<emphasis>将生成不一致的结果</emphasis>，除非你用<literal>ORDER BY</>强制一个可预测的顺序。这并非bug， 这是一个很自然的结果，因为 SQL 没有许诺把查询的结果按照任何特定的顺序发出，除非用了<literal>ORDER BY</>来约束顺序。
  </para>

  <para>
   被<literal>OFFSET</>子句忽略的行仍然需要在服务器内部计算；因此，一个很大的<literal>OFFSET</>的效率可能还是不够高。
  </para>
 </sect1>


 <sect1 id="queries-values">
  <title><literal>VALUES</literal>列表</title>

  <indexterm zone="queries-values">
   <primary>VALUES</primary>
  </indexterm>

  <para>
   <literal>VALUES</>提供了一种生成<quote>常量表</>的方法，它可以被使用在一个查询中而不需要实际在磁盘上创建一个表。语法是：
<synopsis>
VALUES ( <replaceable class="PARAMETER">expression</replaceable> [, ...] ) [, ...]
</synopsis>
   每一个被圆括号包围的表达式列表生成表中的一行。列表都必须具有相同数据的元素（即表中列的数目），并且在每个列表中对应的项必须具有可兼容的数据类型。分配给结果的每一列的实际数据类型使用和<literal>UNION</>相同的规则确定（参见<xref linkend="typeconv-union-case">）。
  </para>

  <para>
   一个例子：
<programlisting>
VALUES (1, 'one'), (2, 'two'), (3, 'three');
</programlisting>

   将会返回一个有两列三行的表。它实际上等效于：
<programlisting>
SELECT 1 AS column1, 'one' AS column2
UNION ALL
SELECT 2, 'two'
UNION ALL
SELECT 3, 'three';
</programlisting>

   在默认情况下，<productname>PostgreSQL</productname>将<literal>column1</>、<literal>column2</>等名字分配给一个<literal>VALUES</>表的列。这些列名不是由SQL标准指定的，并且不同的数据库系统的做法也不同，因此通常最好使用表别名列表来重写这些默认的名字，像这样：
<programlisting>
=> SELECT * FROM (VALUES (1, 'one'), (2, 'two'), (3, 'three')) AS t (num,letter);
 num | letter
-----+--------
   1 | one
   2 | two
   3 | three
(3 rows)
</programlisting>
  </para>

  <para>
   在句法上，后面跟随着表达式列表的<literal>VALUES</>列表被视为和
<synopsis>
SELECT <replaceable>select_list</replaceable> FROM <replaceable>table_expression</replaceable>
</synopsis>
   一样，并且可以出现在<literal>SELECT</>能出现的任何地方。例如，你可以把它用作<literal>UNION</>的一部分，或者附加一个<replaceable>sort_specification</replaceable>（<literal>ORDER BY</>、<literal>LIMIT</>和/或<literal>OFFSET</>）给它。<literal>VALUES</>最常见的用途是作为一个<command>INSERT</>命令的数据源，以及作为一个子查询。
  </para>

  <para>
   更多信息请见<xref linkend="sql-values">。
  </para>

 </sect1>


 <sect1 id="queries-with">
  <title><literal>WITH</literal>查询（公共表表达式）</title>

  <indexterm zone="queries-with">
   <primary>WITH</primary>
   <secondary>in SELECT</secondary>
  </indexterm>

  <indexterm>
   <primary>公共表表达式</primary>
   <see>WITH</see>
  </indexterm>

  <para>
   <literal>WITH</>提供了一种方式来书写在一个大型查询中使用的辅助语句。这些语句通常被称为公共表表达式或<acronym>CTE</acronym>，它们可以被看成是定义只在一个查询中存在的临时表。在<literal>WITH</>子句中的每一个辅助语句可以是一个<command>SELECT</>、<command>INSERT</>、<command>UPDATE</>或<command>DELETE</>，并且<literal>WITH</>子句本身也可以被附加到一个主语句，主语句也可以是<command>SELECT</>、<command>INSERT</>、<command>UPDATE</>或<command>DELETE</>。
  </para>

 <sect2 id="queries-with-select">
   <title><literal>WITH</>中的<command>SELECT</></title>

  <para>
   <literal>WITH</>中<command>SELECT</>的基本价值是将复杂的查询分解称为简单的部分。一个例子：

<programlisting>
WITH regional_sales AS (
        SELECT region, SUM(amount) AS total_sales
        FROM orders
        GROUP BY region
     ), top_regions AS (
        SELECT region
        FROM regional_sales
        WHERE total_sales &gt; (SELECT SUM(total_sales)/10 FROM regional_sales)
     )
SELECT region,
       product,
       SUM(quantity) AS product_units,
       SUM(amount) AS product_sales
FROM orders
WHERE region IN (SELECT region FROM top_regions)
GROUP BY region, product;
</programlisting>

   它只显示在高销售区域每种产品的销售总额。<literal>WITH</>子句定义了两个辅助语句<structname>regional_sales</>和<structname>top_regions</>，其中<structname>regional_sales</>的输出用在<structname>top_regions</>中而<structname>top_regions</>的输出用在主<command>SELECT</>查询。这个例子可以不用<literal>WITH</>来书写，但是我们必须要用两层嵌套的子<command>SELECT</command>。使用这种方法要更简单些。
  </para>

  <para>
   可选的<literal>RECURSIVE</>修饰符将<literal>WITH</>从单纯的句法便利变成了一种在标准SQL中不能完成的特性。通过使用<literal>RECURSIVE</>，一个<literal>WITH</>查询可以引用它自己的输出。一个非常简单的例子是计算从1到100的整数合的查询：

<programlisting>
WITH RECURSIVE t(n) AS (
    VALUES (1)
  UNION ALL
    SELECT n+1 FROM t WHERE n &lt; 100
)
SELECT sum(n) FROM t;
</programlisting>

   一个递归<literal>WITH</>查询的通常形式总是一个<firstterm>非递归项</>，然后是<literal>UNION</>（或者<literal>UNION ALL</>），再然后是一个<firstterm>递归项</>，其中只有递归项能够包含对于查询自身输出的引用。这样一个查询可以被这样执行：
  </para>

  <procedure>
   <title>递归查询求值</title>

   <step performance="required">
    <para>
     计算非递归项。对<literal>UNION</>（但不对<literal>UNION ALL</>），抛弃重复行。把所有剩余的行包括在递归查询的结果中，并且也把它们放在一个临时的<firstterm>工作表</>中。
    </para>
   </step>

   <step performance="required">
    <para>
     只要工作表不为空，重复下列步骤：
    </para>
    <substeps>
     <step performance="required">
      <para>
       计算递归项，用当前工作表的内容替换递归自引用。对<literal>UNION</>（不是<literal>UNION ALL</>），抛弃重复行以及那些与之前结果行重复的行。将剩下的所有行包括在递归查询的结果中，并且也把它们放在一个临时的<firstterm>中间表</>中。
      </para>
     </step>

     <step performance="required">
      <para>
       用中间表的内容替换工作表的内容，然后清空中间表。
      </para>
     </step>
    </substeps>
   </step>
  </procedure>

  <note>
   <para>
    严格来说，这个处理是迭代而不是递归，但是<literal>RECURSIVE</>是SQL标准委员会选择的术语。
   </para>
  </note>

  <para>
   在上面的例子中，工作表在每一步只有一个行，并且它在连续的步骤中取值从1到100。在第100步，由于<literal>WHERE</>子句导致没有输出，因此查询终止。
  </para>

  <para>
   递归查询通常用于处理层次或者树状结构的数据。一个有用的例子是这个用于找到一个产品的直接或间接部件的查询，只要给定一个显示了直接包含关系的表：

<programlisting>
WITH RECURSIVE included_parts(sub_part, part, quantity) AS (
    SELECT sub_part, part, quantity FROM parts WHERE part = 'our_product'
  UNION ALL
    SELECT p.sub_part, p.part, p.quantity
    FROM included_parts pr, parts p
    WHERE p.part = pr.sub_part
  )
SELECT sub_part, SUM(quantity) as total_quantity
FROM included_parts
GROUP BY sub_part
</programlisting>
  </para>

  <para>
   在使用递归查询时，确保查询的递归部分最终将不返回元组非常重要，否则查询将会无限循环。在某些时候，使用<literal>UNION</>替代<literal>UNION ALL</>可以通过抛弃与之前输出行重复的行来达到这个目的。不过，经常有循环不涉及到完全重复的输出行：它可能只需要检查一个或几个域来看相同点之前是否达到过。处理这种情况的标准方法是计算一个已经访问过值的数组。例如，考虑下面这个使用<structfield>link</>域搜索表<structname>graph</>的查询：

<programlisting>
WITH RECURSIVE search_graph(id, link, data, depth) AS (
        SELECT g.id, g.link, g.data, 1
        FROM graph g
      UNION ALL
        SELECT g.id, g.link, g.data, sg.depth + 1
        FROM graph g, search_graph sg
        WHERE g.id = sg.link
)
SELECT * FROM search_graph;
</programlisting>

   如果<structfield>link</>关系包含环，这个查询将会循环。因为我们要求一个<quote>depth</>输出，仅仅将<literal>UNION ALL</> 改为<literal>UNION</>不会消除循环。反过来在我们顺着一个特定链接路径搜索时，我们需要识别我们是否再次到达了一个相同的行。我们可以项这个有循环倾向的查询增加两个列<structfield>path</>和<structfield>cycle</>：

<programlisting>
WITH RECURSIVE search_graph(id, link, data, depth, path, cycle) AS (
        SELECT g.id, g.link, g.data, 1,
          ARRAY[g.id],
          false
        FROM graph g
      UNION ALL
        SELECT g.id, g.link, g.data, sg.depth + 1,
          path || g.id,
          g.id = ANY(path)
        FROM graph g, search_graph sg
        WHERE g.id = sg.link AND NOT cycle
)
SELECT * FROM search_graph;
</programlisting>

   除了阻止环，数组值对于它们自己的工作显示到达任何特定行的<quote>path</>也有用。
  </para>

  <para>
   在通常情况下如果需要检查多于一个域来识别一个环，请用行数组。例如，如果我们需要比较域<structfield>f1</>和<structfield>f2</>：

<programlisting>
WITH RECURSIVE search_graph(id, link, data, depth, path, cycle) AS (
        SELECT g.id, g.link, g.data, 1,
          ARRAY[ROW(g.f1, g.f2)],
          false
        FROM graph g
      UNION ALL
        SELECT g.id, g.link, g.data, sg.depth + 1,
          path || ROW(g.f1, g.f2),
          ROW(g.f1, g.f2) = ANY(path)
        FROM graph g, search_graph sg
        WHERE g.id = sg.link AND NOT cycle
)
SELECT * FROM search_graph;
</programlisting>
  </para>

  <tip>
   <para>
    在通常情况下只有一个域需要被检查来识别一个环，可以省略<literal>ROW()</>语法。这允许使用一个简单的数组而不是一个组合类型数组，可以获得效率。
   </para>
  </tip>

  <tip>
   <para>
    递归查询计算算法使用宽度优先搜索顺序产生它的输出。你可以通过让外部查询<literal>ORDER BY</>一个以这种方法构建的<quote>path</>，用来以深度优先搜索顺序显示结果。
   </para>
  </tip>

  <para>
   当你不确定查询是否可能循环时，一个测试查询的有用技巧是在父查询中放一个<literal>LIMIT</>。例如，这个查询没有<literal>LIMIT</>时会永远循环：

<programlisting>
WITH RECURSIVE t(n) AS (
    SELECT 1
  UNION ALL
    SELECT n+1 FROM t
)
SELECT n FROM t LIMIT 100;
</programlisting>

   这会起作用，因为<productname>PostgreSQL</productname>的实现只计算<literal>WITH</>查询中被父查询实际取到的行。不推荐在生产中使用这个技巧，因为其他系统可能以不同方式工作。同样，如果你让外层查询排序递归查询的结果或者把它们连接成某种其他表，这个技巧将不会起作用，因为在这些情况下外层查询通常将尝试取得<literal>WITH</>查询的所有输出。
  </para>

  <para>
   <literal>WITH</>查询的一个有用的特性是在每一次父查询的执行中它们只被计算一次，即使它们被父查询或兄弟<literal>WITH</>查询引用了超过一次。因此，在多个地方需要的昂贵计算可以被放在一个<literal>WITH</>查询中来避免冗余工作。另一种可能的应用是阻止不希望的多个函数计算产生副作用。但是，从另一方面来看，优化器不能将来自父查询的约束下推到<literal>WITH</>查询中而不是一个普通子查询。<literal>WITH</>查询通常将会被按照所写的方式计算，而不抑制父查询以后可能会抛弃的行（但是，如上所述，如果对查询的引用只请求有限数目的行，计算可能会提前停止）。
  </para>

  <para>
   以上的例子只展示了和<command>SELECT</>一起使用的<literal>WITH</>，但是它可以被以相同的方式附加在<command>INSERT</>、<command>UPDATE</>或<command>DELETE</>上。在每一种情况中，它实际上提供了可在主命令中引用的临时表。
  </para>
 </sect2>

 <sect2 id="queries-with-modifying">
   <title><literal>WITH</>中的数据修改语句</title>

   <para>
    你可以在<literal>WITH</>中使用数据修改语句（<command>INSERT</>、<command>UPDATE</>或<command>DELETE</>）。这允许你在同一个查询中执行多个而不同操作。一个例子：

<programlisting>
WITH moved_rows AS (
    DELETE FROM products
    WHERE
        "date" &gt;= '2010-10-01' AND
        "date" &lt; '2010-11-01'
    RETURNING *
)
INSERT INTO products_log
SELECT * FROM moved_rows;
</programlisting>

    这个查询实际上从<structname>products</>把行移动到<structname>products_log</>。<literal>WITH</>中的<command>DELETE</>删除来自<structname>products</>的指定行，以它的<literal>RETURNING</>子句返回它们的内容，并且接着主查询读该输出并将它插入到<structname>products_log</>。
   </para>

   <para>
    上述例子中好的一点是<literal>WITH</>子句被附加给<command>INSERT</>，而没有附加给<command>INSERT</>的子<command>SELECT</>。这是必需的，因为数据修改语句只允许出现在附加给顶层语句的<literal>WITH</>子句中。不过，普通<literal>WITH</>可见性规则应用，这样才可能从子<command>SELECT</>中引用到<literal>WITH</>语句的输出。
   </para>

   <para>
    正如上述例子所示，<literal>WITH</>中的数据修改语句通常具有<literal>RETURNING</>子句。它是<literal>RETURNING</>子句的输出，<emphasis>不是</>数据修改语句的目标表，它形成了剩余查询可以引用的临时表。如果一个<literal>WITH</>中的数据修改语句缺少一个<literal>RETURNING</>子句，则它形不成临时表并且不能在剩余的查询中被引用。但是这样一个语句将被执行。一个非特殊使用的例子：

<programlisting>
WITH t AS (
    DELETE FROM foo
)
DELETE FROM bar;
</programlisting>

    这个例子将从表<structname>foo</>和<structname>bar</>中移除所有行。被报告给客户端的受影响行的数目可能只包括从<structname>bar</>中移除的行。
   </para>

   <para>
    数据修改语句中不允许递归自引用。在某些情况中可以采取引用一个递归<literal>WITH</>的输出来操作这个限制，例如：

<programlisting>
WITH RECURSIVE included_parts(sub_part, part) AS (
    SELECT sub_part, part FROM parts WHERE part = 'our_product'
  UNION ALL
    SELECT p.sub_part, p.part
    FROM included_parts pr, parts p
    WHERE p.part = pr.sub_part
  )
DELETE FROM parts
  WHERE part IN (SELECT part FROM included_parts);
</programlisting>

    这个查询将会移除一个产品的所有直接或间接子部件。
   </para>

   <para>
    <literal>WITH</>中的数据修改语句只被执行一次，并且总是能结束，而不管主查询是否读取它们所有（或者任何）的输出。注意这和<literal>WITH</>中<command>SELECT</>的规则不同：正如前一小节所述，直到主查询要求<command>SELECT</>的输出时，<command>SELECT</>才会被执行。
   </para>

   <para>
    The sub-statements in <literal>WITH</>中的子语句被和每一个其他子语句以及主查询并发执行。因此在使用<literal>WITH</>中的数据修改语句时，指定更新的顺序实际是以不可预测的方式发生的。所有的语句都使用同一个<firstterm>snapshot</>执行（参见<xref linkend="mvcc">），因此它们不能<quote>看见</>在目标表上另一个执行的效果。这减轻了行更新的实际顺序的不可预见性的影响，并且意味着<literal>RETURNING</>数据是在不同<literal>WITH</>子语句和主查询之间传达改变的唯一方法。其例子

<programlisting>
WITH t AS (
    UPDATE products SET price = price * 1.05
    RETURNING *
)
SELECT * FROM products;
</programlisting>

    外层<command>SELECT</>可以返回在<command>UPDATE</>动作之前的原始价格，而在

<programlisting>
WITH t AS (
    UPDATE products SET price = price * 1.05
    RETURNING *
)
SELECT * FROM t;
</programlisting>

    外部<command>SELECT</>将返回更新过的数据。
   </para>

   <para>
    在一个语句中试图两次更新同一行是不被支持的。只会发生一次修改，但是该办法不能很容易地（有时是不可能）可靠地预测哪一个会被执行。这也应用于删除一个已经在同一个语句中被更新过的行：只有更新被执行。因此你通常应该避免尝试在一个语句中尝试两次修改同一个行。尤其是防止书写可能影响被主语句或兄弟子语句修改的相同行。这样一个语句的效果将是不可预测的。
   </para>

   <para>
    当前，在<literal>WITH</>中一个数据修改语句中被用作目标的任何表不能有条件规则、<literal>ALSO</>规则或<literal>INSTEAD</>规则，这些规则会扩展成为多个语句。
   </para>

  </sect2>

 </sect1>

</chapter>
