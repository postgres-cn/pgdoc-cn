<!-- doc/src/sgml/protocol.sgml -->

<chapter id="protocol">
 <title>前端/后端协议</title>

 <indexterm zone="protocol">
  <primary>协议</primary>
  <secondary>前端-后端</secondary>
 </indexterm>

 <para>
  <productname>PostgreSQL</productname>使用一种基于消息的协议用于前端和后端（服务器和客户机）之间通讯。该协议是在<acronym>TCP/IP</acronym>和Unix 域套接字上实现的。端口号 5432 已经在IANA 注册为支持这种协议的服务器的常用端口，但实际上任何非特权端口号都可以使用。
 </para>

 <para>
  这份文档描述了版本3.0的协议，它在<productname>PostgreSQL</productname>版本 7.4 和以后的版本中实现。对于以前版本协议的描述，请参考以前版本的<productname>PostgreSQL</productname>文档。 一个服务器可以支持多种协议版本。最开始的启动请求信息会告诉服务器客户端尝试使用的协议版本，然后服务器则遵循该版本的协议——如果它能做到的话。
 </para>

  <para>
   为了可以有效地为多个客户端提供服务，服务器为每个客户端派生一个新的<quote>后端</>进程。 在目前的实现里，在检测到新来的连接请求后，马上创建一个新的子进程。 不过，这些是对协议透明的。对于协议而言，术语<quote>后端</>和<quote>服务器</>是可以互换的； 类似的还有<quote>前端</>和<quote>客户端</>也是可以互换的。
  </para>

 <sect1 id="protocol-overview">
  <title>概述</title>

  <para>
   协议在启动和正常操作过程中有不同的阶段。在启动阶段里，前端打开一个到服务器的连接并且认证自身以满足服务器（这可能涉及到一条或多条消息，取决于使用的认证方法）。 如果一切正常，服务器就发送状态信息给前端，并最后进入正常操作。除了最初的启动请求消息之外，协议的这个部分是服务器驱动的。
  </para>

  <para>
   在正常操作中，前端发送查询和其它命令到后端，然后后端返回查询结果和其它响应。在少数几种情况（比如<command>NOTIFY</>）中，后端会发送未被请求的消息，但这个会话中的绝大多部分都是由前端请求驱动的。
  </para>

  <para>
   会话的终止通常是由前端来选择的，但是也可以在某些情况下由后端强制执行。不管在那种情况下，如果后端关闭连接，那么它将在退出之前回滚所有打开的（未完成的）事务。
  </para>

  <para>
   在正常操作中，SQL命令可以通过两个子协议中的任何一个执行。 在<quote>简单查询</>协议中，前端只是发送一个文本查询串， 然后后端马上分析并执行它。在<quote>扩展查询</>协议中， 查询的处理被分割为多个步骤：分析、参数值绑定和执行。这样就可以提供灵活性和性能的改进，但代价是额外的复杂性。
  </para>

  <para>
   正常操作还有用于类似<command>COPY</>这样的额外的子协议。
  </para>

 <sect2 id="protocol-message-concepts">
  <title>消息概貌</title>

  <para>
   所有通讯都是通过一个消息流进行的。消息的第一个字节标识消息类型， 然后后面跟着的四个字节声明消息剩下部分的长度（这个长度包括长度域自身，但是不包括消息类型字节）。 剩下的消息内容由消息类型决定。由于历史原因，客户端发送的最初的消息（启动消息）不包含消息类型字节。
  </para>

  <para>
   为了避免失去与消息流的同步，服务器和客户端通常都是把整个消息读取到一个缓冲区里（使用字节计数）， 然后才试图处理其内容。这样在处理内容的过程时如果发现错误，就比较容易恢复。 在非常极端的情况下（比如说没有足够的内存缓冲消息），接收端可以使用字节计数来判断它在继续读取消息之前需要跳过多少输入。
  </para>

  <para>
   反之，服务器和客户端都需要注意决不能发送一条不完整的消息。保证这一点的方法通常是在发送整条信息之前先在一个缓冲区里整理整条消息。 如果在发送或者接受一条消息的中间发生了通讯错误，那么唯一合理的响应是放弃连接，因为恢复消息边界同步的希望很小。
  </para>
 </sect2>

  <sect2 id="protocol-query-concepts">
   <title> 扩展查询概述</title>

   <para>
    在扩展查询协议中，SQL命令的执行是分割成多个步骤的。步骤与步骤之间保存的状态是由两类的对象代表的：<firstterm>预备语句</>（prepared statements）和<firstterm>入口</>（portals）。 一个预备语句代表一个文本查询字符串的经过分析、语意解析以及规划之后的结果。一个预备语句不代表它已经可以被执行，因为它可能还缺乏 <firstterm>参数</>的值。 一个入口代表一个已经可以执行的或者已经被部分执行过的语句，所有缺失的参数值都已经填充到位了（对于<command>SELECT</>语句，入口等效于一个打开的游标， 但我们使用不同的术语是因为游标不能处理非<command>SELECT</>语句）。
   </para>

   <para>
    完整的执行周期包括一个<firstterm>分析</>步骤， 它从一个文本的查询字符串里创建一个预备语句； 一个<firstterm>绑定</>步骤， 它用一个预备语句和任何所需的参数值创建一个入口；以及一个 <firstterm>执行</>步骤，它运行一个入口中的查询。如果查询会返回数据行（<command>SELECT</>、<command>SHOW</>等）， 执行步骤会被告知只抓取有限的一些行，这样就可能需要多个执行步骤来完成操作。
   </para>

   <para>
    后端可以跟踪多个预备语句和入口（但是要注意，这些只存在于一个会话内部，不能在会话之间共享）。现有的预备语句和入口都是用创建它们的时候赋予的名字引用的。 另外，还存在一个<quote>未命名</> 的预备语句和入口。 尽管它们的行为和命名对象大部分相同，但是它们是针对只执行一次然后就抛弃的查询而优化的， 而在命名对象上的操作是针对多次使用而优化的。
   </para>
  </sect2>

  <sect2 id="protocol-format-codes">
   <title> 格式和格式代码</title>

   <para>
    特定数据类型的数据可以用几种不同的<firstterm>格式</>中的任意一种来传递。 从<productname>PostgreSQL</> 7.4开始，只支持<quote>文本</>和<quote>二进制</>两种格式， 但是协议为未来的扩展提供了的手段。任意值要求的格式用一个<firstterm>格式代码</>声明。 客户端可以为每个传输的参数值和查询结果的每个列指定一个格式代码。 文本的格式代码是零，二进制的格式代码是一，所有其它的格式代码都保留给将来定义。
   </para>

   <para>
    文本形式的数值是特定数据类型的输入/输出转换函数生成或接受的任何字符串。在传输形式上，字符串没有末尾空字符；如果前端要想把收到的值当作C字符串处理，那么必须自己加上一个（顺便说一下，文本格式不允许嵌入空字符）。
   </para>

   <para>
    整数的二进制形式采用网络字节序（高位在前）。对于其它数据类型，请参考文档或者源代码获取其二进制形式的信息。请注意，复杂数据类型的二进制形式可能在不同服务器版本之间变化； 文本格式通常是最具有移植性的选择。
   </para>
  </sect2>
 </sect1>

 <sect1 id="protocol-flow">
  <title>消息流</title>

  <para>
   本节描述消息流以及每种消息类型的语意（每种信息的准确形式在<xref linkend="protocol-message-formats">里）。根据连接的状态不同，存在几种不同的子协议： 启动、查询、函数调用、<command>COPY</command>和终止。还有特殊的规定用于一步操作（包括通知响应和命令取消），这些可能在启动阶段过后的任何时间产生。
  </para>

  <sect2>
   <title>启动</title>

   <para>
    要开始一个会话，前端打开一个与服务器的连接并且发送一个启动消息。这个消息包括用户名以及用户希望连接的数据库名； 它还标识要使用的特定的协议版本（启动信息可以有选择地包括运行时参数的额外设置）。服务器然后就使用这些信息及服务器配置文件的内容 （比如 <filename>pg_hba.conf</filename>）来判断这个连接是否可以接受以及需要什么样的额外的认证（如果需要）。
   </para>

   <para>
    然后服务器就发送合适的认证请求信息，前端必须用合适的认证响应信息来响应（比如一个口令）。对于除了GSSAPI和SSPI之外的所有认证方式都至少有一个请求和一个响应。在有些方法中前端不需要发出任何响应，并且因此就不会由任何认证请求发生。对于GSSAPI和SSPI，可能需要多个包的交换才能完成认证。
   </para>

   <para>
    认证周期要么以服务器的拒绝连接（ErrorResponse）结束， 要么以AuthenticationOK 结束。
   </para>

   <para>
    这个阶段来自服务器可能消息是：

    <variablelist>
     <varlistentry>
      <term>ErrorResponse</term>
      <listitem>
       <para>
        连接请求被拒绝。然后服务器马上关闭连接。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationOk</term>
      <listitem>
       <para>
        认证交换成功完成。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationKerberosV5</term>
      <listitem>
       <para>
        现在前端必须与服务器进行一次Kerberos V5认证对话（在这里没有描述，Kerberos规范的一部分）。 如果对话成功，服务器响应一个AuthenticationOk，否则它响应一个ErrorResponse。这已经不再被支持。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationCleartextPassword</term>
      <listitem>
       <para>
        现在前端必须以明文形式发送一个包含口令的PasswordMessage。如果这是正确的口令，服务器用一个 AuthenticationOk，否则它响应一个ErrorResponse。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationMD5Password</term>
      <listitem>
       <para>
        现在前端必须发送一个PasswordMessage，其中包含口令，且口令先用用户名做MD5加密，然后使用在AuthenticationMD5Password消息里指定的4字节盐粒加密。 如果这是正确口令，服务器用一个AuthenticationOk 响应，否则它用一个ErrorResponse 响应。实际的PasswordMessage可以用SQL来计算：<literal>concat('md5',        md5(concat(md5(concat(password, username)), random-salt)))</>（记住<function>md5()</>函数返回的结果是一个十六进制串）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationSCMCredential</term>
      <listitem>
       <para>
        这个响应只用于在支持SCM信任消息的平台上的本地Unix域连接。前端必须发出一条SCM信任消息然后发送一个数据字节（数据字节的内容并没有意义； 它只被用于确保服务器等待足够长的时间来接受信任信息）。如果信任是可以接受的， 那么服务器用AuthenticationOk响应，否则用ErrorResponse响应（该消息只在9.1之前的服务器中发出。它可能最终会从协议规范中被删除）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationGSS</term>
      <listitem>
       <para>
        前端必须现在开始一次GSSAPI谈判。前端将发送一个带有GSSAPI数据流第一部分的PasswordMessage来响应。如果需要进一步的消息，服务器将会响应AuthenticationGSSContinue。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationSSPI</term>
      <listitem>
       <para>
        前端必须现在开始一次SSPI谈判。前端将发送一个带有SSPI数据流第一部分的PasswordMessage来响应。如果需要进一步的消息，服务器将会响应AuthenticationGSSContinue。
       </para>
      </listitem>

     </varlistentry>
     <varlistentry>
      <term>AuthenticationGSSContinue</term>
      <listitem>
       <para>
        这个消息包含对于前一步的GSSAPI或SSPI谈判（AuthenticationGSS、AuthenticationSSPI或者前一个AuthenticationGSSContinue）的响应数据。如果这个消息中的GSSAPI或SSPI数据指示需要更多数据来完成认证，前端必须将所需的数据作为另一个PasswordMessage发送。如果这个消息就能完成GSSAPI或SSPI认证，服务器将接着发送AuthenticationOk来指示成功认证，或者发送ErrorResponse来指示失败。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

   <para>
    如果前端不支持服务器要求的认证方式，那么它应该马上关闭连接。
   </para>

   <para>
    在收到AuthenticationOk包之后， 前端必须等待来自服务器的进一步消息。在这个阶段会启动一个后端进程， 而前端只是一个感兴趣的旁观者。启动后端进程的尝试仍然有可能失败（ErrorResponse），但是通常情况下，后端将发送一些ParameterStatus消息、BackendKeyData以及最后的ReadyForQuery。
   </para>

   <para>
    在这个阶段，后端将尝试应用任何在启动消息里给出的额外的运行时参数设置。如果成功，这些值将成为会话的缺省值。错误将导致ErrorResponse并退出。
   </para>

   <para>
    这个阶段来自后端的可能消息是：

    <variablelist>
     <varlistentry>
      <term>BackendKeyData</term>
      <listitem>
       <para>
        这个消息提供了密钥数据，前端如果想要在稍后发出取消请求，则必须保存这个数据。前端不应该响应这个信息，但是应该继续侦听等待ReadyForQuery消息。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ParameterStatus</term>
      <listitem>
       <para>
        这个消息告诉前端有关后端参数的当前（初始）设置，比如<xref linkend="guc-client-encoding">或者<xref linkend="guc-datestyle">等。前端可以忽略这些信息，或者记录其设置用于将来使用； 参阅<xref linkend="protocol-async">获取更多细节。前端不应该响应这些信息， 而是应该继续侦听ReadyForQuery消息。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ReadyForQuery</term>
      <listitem>
       <para>
        启动成功，前端现在可以发出命令。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ErrorResponse</term>
      <listitem>
       <para>
        启动失败，在发送完这个消息之后连接被关闭。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>NoticeResponse</term>
      <listitem>
       <para>
        发出了一个警告信息。前端应该显示这个信息，但是要继续监听ReadyForQuery或ErrorResponse。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    后端在每个命令周期后都会发出一个相同的ReadyForQuery消息。 出于前端的编码需要，前端可以合理地认为ReadyForQuery是一个命令周期的开始，或者认为ReadyForQuery 是启动阶段和每个随后命令周期的结束， 具体是那种情况取决于前端的编码需要。
   </para>
  </sect2>

  <sect2>
   <title> 简单查询</title>

   <para>
    一个简单查询周期是由前端发送一条Query消息给后端进行初始化的。这条消息包含一个用文本字符串表达的 SQL 命令（或者一些命令）。 后端根据查询命令串的内容发送一条或者更多条响应消息给前端，并且最后是一条ReadyForQuery响应消息。ReadyForQuery通知前端它可以安全地发送新命令了 （实际上前端不必在发送其它命令之前等待ReadyForQuery，但是这样一来，前端必须能发现较早发出的命令失败而稍后发出的命令成功的情况）。
   </para>

   <para>
    来自后端的可能的消息是：

    <variablelist>
     <varlistentry>
      <term>CommandComplete</term>
      <listitem>
       <para>
        一个SQL命令正常结束。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>CopyInResponse</term>
      <listitem>
       <para>
        后端已经准备好从前端拷贝数据到一个表里面去，参见<xref linkend="protocol-copy">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>CopyOutResponse</term>
      <listitem>
       <para>
        后端已经准备好从一个表里拷贝数据到前端，参见<xref linkend="protocol-copy">。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>RowDescription</term>
      <listitem>
       <para>
        表示为了响应一个<command>SELECT</command>、<command>FETCH</command>等查询， 将要返回行。这条消息的内容描述了行的列布局。这条消息后面将跟着DataRow消息，每个DataRow消息包含一个要被返回的行。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>DataRow</term>
      <listitem>
       <para>
        <command>SELECT</command>、<command>FETCH</command>等查询返回的结果集中的一行。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>EmptyQueryResponse</term>
      <listitem>
       <para>
        识别了一个空的查询字符串。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ErrorResponse</term>
      <listitem>
       <para>
        出错了。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ReadyForQuery</term>
      <listitem>
       <para>
        查询字符串的处理完成。发送一个独立的消息来标识这种情况是因为查询字符串可能包含多个SQL命令（CommandComplete只是标记一条SQL命令处理完毕，而不是整个查询字符串处理完毕）。不管是处理成功结束还是产生错误，ReadyForQuery总会被发送。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>NoticeResponse</term>
      <listitem>
       <para>
        发送了一个与查询有关的警告信息。提示信息是附加在其他响应上的，也就是说，后端将继续处理该命令。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

   <para>
    对SELECT查询（或其它返回行集的查询，比如<command>EXPLAIN</>或<command>SHOW</>）的响应通常包含 RowDescription、零个或者多个 DataRow 消息以及最后的 CommandComplete。 <command>COPY</>到前端或者从前端<command>COPY</>会调用<xref linkend="protocol-copy">里描述的特殊协议。所有其他查询类型通常只产生一个CommandComplete消息。
   </para>

   <para>
    因为查询字符串可能包含若干个查询（用分号分隔），所以在后端完成查询字符串的处理之前可能有好几个这样的响应序列。如果整个字符串已经处理完，后端已经准备好接受新查询字符串的时候则发出 ReadyForQuery消息。
   </para>

   <para>
    如果收到一个完全空（除了空白之外没有内容）的查询字符串，那么响应是一条EmptyQueryResponse后面跟着ReadyForQuery。
   </para>

   <para>
    在出现错误的时候，发出一个ErrorResponse消息，后面跟着ReadyForQuery。查询字符串的所有进一步的处理都被ErrorResponse中止（即使里面还有查询）。请注意这些事情可能在处理一个查询产生的消息序列的中途发生。
   </para>

   <para>
    在简单查询模式中，检索出来的值的格式总是文本，除非给出的命令是在一个使用<literal>BINARY</>选项声明的游标上<command>FETCH</>。 在这种情况下，检索出来的值是二进制格式的。在 RowDescription消息里给出的格式代码将告诉我们用了那种格式。
   </para>

   <para>
    前端在等待其他类型的消息时必须准备接收ErrorResponse和NoticeResponse消息。 参阅 <xref linkend="protocol-async">来了解后端因为外部事件可能生成的消息。
   </para>

   <para>
    我们建议的方法是把前端代码写成状态机的风格，它可以在任何时刻接受任何有意义的消息类型，而不是假设消息的序列总是准确。
   </para>
  </sect2>

  <sect2 id="protocol-flow-ext-query">
   <title>扩展查询</title>

   <para>
    扩展查询协议把上面描述的简单协议分裂成若干个步骤。准备步骤的结果可以被多次复用以提高效率。另外，还可以获得额外的特性， 比如可以把数据值作为独立的参数提供而不是必须把它们直接插入一个查询字符串。
   </para>

   <para>
   在扩展协议里，前端首先发送一个Parse消息，它包含一个文本查询字符串， 另外还有一些可选的有关参数占位符的数据类型的信息，以及一个最终的预备语句对象的名字（一个空字符串选择未命名的预备语句）。响应是一个ParseComplete或者ErrorResponse。 参数的数据类型可以用OID来指定；如果没有给出，那么分析器将试图用应付无类型文字符串常量的方法来推导其数据类型。
   </para>

   <note>
    <para>
     一个参数的数据类型可以通过设置为零， 或者让参数类型OID的数目比查询字符串里的参数符号（<literal>$</><replaceable>n</>）的数目少的方式不予指定。另外一个特例是参数的类型可以声明为<type>void</>（也就是说，伪类型<type>void</>的OID）。这是为了允许用于某些函数参数的参数符号实际上是OUT参数。通常情况下，没有什么环境会用到<type>void</>参数， 但是如果在函数的参数列表里出现了这么一个参数符号，那么它实际上会被忽略。比如，一个像这样的函数调用：<literal>foo($1,$2,$3,$4)</>，如果<literal>$3</>和<literal>$4</>被指定为具有类型是<type>void</>，那么这个函数调用会匹配一个带有两个IN和两个OUT参数的函数。
    </para>
   </note>

   <note>
    <para>
     在一个Parse消息里包含的查询字符串不能包含超过一个SQL语句；否则就会报告一个语法错误。这个限制在简单查询协议中并不存在， 是它存在于扩展协议中，因为允许预备语句或者入口包含多个命令将导致协议过度地复杂。
    </para>
   </note>

   <para>
    如果成功创建了一个命名的预备语句对象，那么它将持续到当前会话结束， 除非被明确地删除。一个未命名的预备语句只持续到下一个声明未命名语句的Parse语句发出为止（请注意一个简单的查询消息也会销毁未命名语句）。命名预备语句必须被明确地关闭，然后才能用一个Parse消息重新定义，但是未命名语句并不要求这个动作。命名预备语句也可以在SQL命令级别创建和访问，方法是使用<command>PREPARE</>和<command>EXECUTE</>。
   </para>

   <para>
    一旦一个预备语句存在，就可以很使用Bind消息使之进入执行状态。Bind消息给出源预备语句的名字（空字符串表示未命名预备语句）、目标入口的名字（空字符串表示未命名的入口）及用于那些在预备语句中出现的所有参数占位符的值。提供的参数集必须匹配那些预备语句所需要的参数（如果你在Parse消息里声明任何<type>void</>参数，那么在Bind消息里给它们传递NULL值）。Bind还指定被查询返回的数据的格式；格式可以在总体上声明，也可以对每个列进行声明。响应是BindComplete或ErrorResponse。
   </para>

   <note>
    <para>
     输出的格式是文本还是二进制是由Bind里给出的格式代码决定的，而不管涉及的是什么SQL命令。在使用扩展查询协议的时候，游标声明里的<literal>BINARY</>属性是无关的。
    </para>
   </note>

   <para>
    当Bind消息被处理时通常会进行查询规划。如果预备语句没有参数或者是被反复执行，服务器可能会保存创建好的计划并在后续对同一个预备语句的Bind消息中重用之。不过，当它发现可以创建一个效率比依赖指定参数值的计划不低很多的一般性计划时，它仍然会进行查询规划。但是这对于协议所关注的来说是透明的。
   </para>

   <para>
    如果成功创建了一个命名入口对象，那么它将持续到当前事务的结尾，除非被明确地删除。一个未命名入口在事务的结尾删除，或者是在发出的下一个Bind语句声明了一个未命名入口为止（请注意一个简单查询消息也会删除这个未命名入口）。命名入口在可以用一个Bind消息重新定义之前必须明确地关闭，但是未命名入口不要求这个动作。命名入口也可以在SQL命令的级别创建和访问，方法是使用<command>DECLARE CURSOR</>和<command>FETCH</>。
   </para>

   <para>
    一旦一个入口存在，那么就可以用一个Execute消息执行它。Execute消息指定入口的名字（空字符串表示未命名入口）和一个最大的结果行计数（零表示<quote>取出所有行</>）。 结果行计数只对包含返回行集的入口有意义；在其它情况下，该命令总是被执行到结束，而行计数会被忽略。Execute消息的可能响应和那些通过简单查询协议发出的查询一样，只不过执行不会导致后端发出ReadyForQuery或者RowDescription。
   </para>

   <para>
    如果Execute在入口的执行完成之前终止（因为达到了一个非零的结果行计数），它将发送一个PortalSuspended消息；这个消息的出现告诉前端应该在同一个入口上发出另外一个Execute消息以完成操作。在入口的执行完成之前，不会发出表示源SQL命令结束的CommandComplete消息。因此执行阶段总是由下列消息之一出现标志着结束：CommandComplete、EmptyQueryResponse（如果入口是从一个空字符串创建出来的）、ErrorResponse或者PortalSuspended。
   </para>

   <para>
    每个扩展查询消息序列完成后，前端都应该发出一条Sync消息。这个无参数的消息导致后端关闭当前事务——如果当前事务不是在一个<command>BEGIN</>/<command>COMMIT</>事务块中（<quote>关闭</>的意思就是在没有错误的情况下提交， 或者是有错误的情况下回滚）。然后响应一条ReadyForQuery消息。Sync的目的是提供一个错误恢复的重新同步的点。 如果在处理任何扩展查询消息的时候侦测到任何错误，那么后端会发出ErrorResponse，然后读取并抛弃消息直到一个Sync到来，然后发出ReadyForQuery并且返回到正常的消息处理中（但是要注意如果正在处理Sync的时候发生了错误，那么不会忽略任何东西 — 这样就保证了为每个Sync发出一个并且只是一个ReadyForQuery）。
   </para>

   <note>
    <para>
     Sync并不导致一个用<command>BEGIN</>打开的事务块关闭。我们可以侦测到这种情况，因为ReadyForQuery消息包含事务状态信息。
    </para>
   </note>

   <para>
    除了这些基本的、必须的操作之外，在扩展查询协议里还有几种可选的操作可以使用。
   </para>

   <para>
    Describe消息（入口变体）指定一个现有的入口的名字（或者一个空字符串表示未命名入口）。响应是一个RowDescription消息，它描述了执行该入口将要返回的行；或者是一个NoData消息——果入口并不包含会返回行的查询；或者是一个ErrorResponse——如果入口不存在。
   </para>

   <para>
    Describe消息（语句变体）指定一个现有的预备语句的名字（或者一个空字符串表示未命名预备语句）。 响应是一个描述该语句需要的参数的ParameterDescription消息，后面跟着一个描述该语句最终执行后返回的行的RowDescription消息（或者是 NoData 消息，如果该语句不返回行）。如果没有这样的预备语句，则返回ErrorResponse。请注意因为还没有发出Bind，所以后端还不知道用于返回列的格式；在这种情况下，RowDescription消息里面的格式代码域将是零。
   </para>

   <tip>
    <para>
     在大多数情况下，前端在发出Execute之前应该发出某种Describe的变体，以保证它知道如何解析它将得到的结果。
    </para>
   </tip>

   <para>
    Close消息关闭一个现有的预备语句或者入口，并且释放资源。对一个不存在的语句或者入口发出Close不是一个错误。响应通常是CloseComplete，但如果在释放资源的时候遇到了一些困难也可以是ErrorResponse。请注意关闭一个预备语句会隐含地关闭任何从该语句构造出来的打开的入口。
   </para>

   <para>
    Flush消息并产生任何特定的输出，但是强制后端发送任何还在它的输出缓冲区中待处理的数据。Flush必须在除Sync外的任何扩展查询命令后面发出——如果前端希望在发出更多的命令之前检查该命令的结果的话。如果没有Flush，后端返回的消息将组合成尽可能少的数据包，以减少网络负荷。
   </para>

   <note>
    <para>
     简单查询消息大概等于一系列使用未命名预备语句和无参数入口对象的Parse、Bind、入口Describe、Execute、Close、Sync。一个区别是它会在查询字符串中接受多个SQL语句，并连续地为每个语句自动执行绑定/描述/执行序列。另外一个区别是它不会返回ParseComplete、Bindcomplete、CloseComplete或者NoData消息。
    </para>
   </note>
  </sect2>

  <sect2>
   <title> 函数调用</title>

   <para>
    函数调用子协议允许客户端请求一个对存在于数据库<structname>pg_proc</structname>系统表中的任意函数的直接调用。客户端必须在该函数上有执行的权限。
   </para>

   <note>
    <para>
     函数调用子协议是一个遗留的特性，在新代码里可能最好避免用它。类似的结果可以通过设置一个执行<literal>SELECT function($1, ...)</>的预备语句得到。这样函数调用周期就可以用 Bind/Execute 代替。
    </para>
   </note>

   <para>
    一个函数调用周期是由前端向后端发送一条FunctionCall消息初始化的。然后后端根据函数调用的结果发送一条或者更多响应消息，并且最后是一条ReadyForQuery响应消息。ReadyForQuery通知前端它可以安全地发送一个新的查询或者函数调用了。
   </para>

   <para>
    来自后端的可能的响应消息是：

    <variablelist>
     <varlistentry>
      <term>ErrorResponse</term>
      <listitem>
       <para>
        发生了一个错误。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>FunctionCallResponse</term>
      <listitem>
       <para>
        函数调用完成并且在消息中返回一个结果（请注意函数调用协议只能处理单个标量结果，不能处理行类型或者集合类型的结果）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ReadyForQuery</term>
      <listitem>
       <para>
        函数调用处理完成。ReadyForQuery将总是被发送，不管是成功完成处理还是发生一个错误。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>NoticeResponse</term>
      <listitem>
       <para>
        发出了一条有关该函数调用的警告信息。通知是附加在其他响应上的，也就是说，后端将继续处理该命令。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="protocol-copy">
   <title>COPY操作</title>

   <para>
    <command>COPY</>命令允许在服务器和客户端之间进行高速大批量数据传输。拷贝入和拷贝出操作每个都把连接切换到一个独立的子协议中，并且持续到操作结束。
   </para>

   <para>
    拷贝入模式（数据传输到服务器）是在后端执行一个<command>COPY FROM STDIN</>语句的时候初始化的。后端发送一个CopyInResponse消息给前端。前端应该发送零条或者更多CopyData消息，形成一个输出数据的流（消息的边界和行的边界没有任何相关性要求，尽管通常那是合理的选择）。前端可以通过发送一个CopyDone消息来终止拷贝入操作（允许成功终止），也可以发出一个CopyFail消息（它将导致<command>COPY</>语句带着错误失败）。 然后后端就恢复回它在<command>COPY</>开始之前的命令处理模式，可能是简单查询协议，也可能是扩展查询协议。然后它会发送CommandComplete（如果成功）或者ErrorResponse（如果失败）。
   </para>

   <para>
    如果在拷贝入模式下后端检测到了错误（包括接受接收到CopyFiail消息， 或者是任何除了CopyData或者CopyDone之外的前端消息），那么后端将发出一个ErrorResponse消息。如果<command>COPY</>命令是通过一个扩展查询消息发出的， 那么后端从现在开始将抛弃前端消息，直到一个Sync消息到达，然后它将发出ReadyForQuery并且返回到正常的处理中。如果<command>COPY</>命令是在一个简单查询消息里发出的，那么该消息剩余部分被丢弃然后发出ReadyForQuery消息。不管是哪种情况，任何前端发出的CopyData、CopyDone或者CopyFail消息都将被简单地抛弃。
   </para>

   <para>
    在拷贝入模式下，后端将忽略所收到的Flush和Sync消息。收到任何其他非拷贝消息类型都会造成一个错误，它将导致上面所描述的拷贝入状态中断（Flush和Sync的例外是为了方便客户端库，它们总是在一个Execute消息之后发送Flush和Sync，而不检查被执行的命令是否为一个<command>COPY FROM STDIN</>）。
   </para>

   <para>
    拷贝出模式（数据从服务器发出）是在后端执行一个<command>COPY TO STDOUT</>语句的时候初始化的。后端发出一个CopyOutResponse消息给前端，后面跟着零或者多个CopyData消息（总是每行一个），然后跟着CopyDone。然后后端回退到它在<command>COPY</>开始之前的命令处理模式，然后发送CommandComplete。前端不能退出传输（除非是关闭连接或者发出一个Cancel请求），但是它可以抛弃不需要的CopyData和CopyDone消息。
   </para>

   <para>
    在拷贝出模式中，如果后端检测到错误，那么它将发出一个ErrorResponse消息并且回到正常的处理。前端应该把收到ErrorResponse当作终止拷贝出模式的标志。
   </para>

   <para>
    在CopyData消息中间可能会散布有NoticeResponse和ParameterStatus消息。前端必须处理这些情况，并且应该也为异步消息类型（参见<xref linkend="protocol-async">）准备好。否则任何除CopyData或CopyDone之外的消息类型都会被认为是要中止拷贝出模式。
   </para>

   <para>
    还有另外一种被称为双向拷贝的与拷贝相关的模式，它允许“向”<emphasis>和</>“从”服务器高速传输大批量数据。当后端处于walsender模式中执行一个<command>START_REPLICATION</command>语句时，它会启动双向拷贝模式。后端会发送一个CopyBothResponse消息给前端。然后前端和后端都会发送CopyData消息，然后直到最后发送一个CopyDone消息。在客户端发送一个CopyDone消息后，连接将从双向拷贝模式转换到拷贝出模式，并且客户端将不能发送更多CopyData消息。类似的，当服务器发送了一个CopyDone消息，连接进入到拷贝入模式，并且服务器将不能发送更多CopyData消息。在双方发送完一个CopyDone消息后，拷贝模式被中断，而后端将回到之前的命令处理模式。如果在双向拷贝模式中出现一个后端检测到的错误，后端将发出一个ErrorResponse消息，然后将发出ReadyForQuery并返回到普通处理。前端将把收到ErrorResponse作为在双向上中断拷贝的信号，在这种情况下不会有CopyDone被发出。关于在双向拷贝模式下传输的子协议请参见<xref linkend="protocol-replication">。
   </para>

   <para>
    CopyInResponse、CopyOutResponse和CopyBothResponse消息包括域和格式代码，域告诉前端每行的列数，而格式代码则用于具体每个列（就目前的实现而言，一个给定<command>COPY</>操作中的所有列都将使用同样的格式，但是消息设计并不做这个假设）。
   </para>

  </sect2>

  <sect2 id="protocol-async">
   <title> 异步操作</title>

   <para>
    有几种情况下后端会发送一些并非由特定前端命令流传达的消息。在任何时候前端都必须准备处理这些消息，即使它是并未参与一个查询。在最低限度下，我们应该在开始读取查询响应之前检查这些情况。
   </para>

   <para>
    NoticeResponse消息有可能是因为外部的活动而产生的；比如，如果数据库管理员进行一次<quote>快速</>数据库关闭，那么后端将在关闭连接之前发送一个NoticeResponse来表明这些。相应地，前端应该总是准备接受和显示NoticeResponse消息，即使连接事实上是空闲的。
   </para>

   <para>
    如果任何时候有任何参数值的活跃值改变且后端认为前端应该知道这些，那么都会产生ParameterStatus消息。这种情况最常见发生的情形是对前端执行的一个<command>SET</>命令进行响应，并且这种情况实际上是同步的 &mdash; 但是也有可能是数据库管理员改变了配置文件然后项服务器发出<systemitem>SIGHUP</systemitem>信号导致了参数状态的变化。同样，如果一个<command>SET</command>命令回滚，那么也会生成一个合适的ParameterStatus 消息以报告当前有效值。
   </para>

   <para>
    目前，系统内有一套会生成ParameterStatus消息的写成硬代码的参数，它们是：
    
     （server_encoding，TimeZone 和 integer_datetimes 在 8.0 版本之前没有报告。standard_conforming_strings 在版本 8.1 之前没有报告。） 请注意 server_version， server_encoding 和 integer_datetimes 是伪参数，启动后不能修改。 这些可能在将来改变，或者甚至是变成可以配置的。 因此，前端应该简单地忽略那些它不懂或者不关心的 ParameterStatus。
    <varname>server_version</>、
    <varname>server_encoding</>、
    <varname>client_encoding</>、
    <varname>application_name</>、
    <varname>is_superuser</>、
    <varname>session_authorization</>、
    <varname>DateStyle</>、
    <varname>IntervalStyle</>、
    <varname>TimeZone</>、
    <varname>integer_datetimes</>以及
    <varname>standard_conforming_strings</>
    （<varname>server_encoding</>、<varname>TimeZone</>以及<varname>integer_datetimes</>在版本8.0之前不会被报告；
    <varname>standard_conforming_strings</>在版本8.1之前不会被报告；
    <varname>IntervalStyle</>在版本8.4之前不会被报告；
    <varname>application_name</>在版本9.0之前不会被报告）。
    注意<varname>server_version</>、<varname>server_encoding</>以及<varname>integer_datetimes</>是伪参数，它们不能在启动之后被改变。这种设置可能在未来改变，甚至变成可配置的。相应地，一个前端应该简单地忽略那些与它不懂或者不关心的参数相关的ParameterStatus。
   </para>

   <para>
    如果前端发出一个<command>LISTEN</command>命令， 那么无论何时在为同一个通道名<command>NOTIFY</command>时，后端将发送一个NotificationResponse消息（不要和NoticeResponse搞混！）。
   </para>

   <note>
    <para>
     目前，NotificationResponse只能在一个事务外面发送，因此它将不会在一个命令响应序列中间出现，但是它可能正好在ReadyForQuery之前出现。不过，在前端逻辑中做上述假设是不明智的。好的做法是在协议的任何点上都可以接受NotificationResponse。
    </para>
   </note>
  </sect2>

  <sect2>
   <title> 取消正在处理的请求</title>

   <para>
    在一条查询正在处理的时候，前端可以请求取消该查询。这种取消请求不是直接通过打开的连接发送给后端的，这么做是因为实现的效率：我们不希望后端在处理查询的过程中不停地检查前端来的输入。 取消请求应该相对而言比较少见，所以我们把取消做得稍微笨拙一些，以便不影响正常状况的性能。
   </para>

   <para>
    要发出一条取消请求，前端打开一个与服务器的新连接并且发送一条CancelRequest消息， 而不是通常在新连接中经常发送的StartupMessage消息。服务器将处理这个请求然后关闭连接。 出于安全原因，对取消请求消息不做直接的响应。
   </para>

   <para>
    除非CancelRequest消息包含在连接启动过程中传递给前端的相同的关键数据（PID和密钥），否则它将被忽略。如果该请求匹配当前运行着的后端的PID和密钥， 则退出当前查询的处理（目前的实现里采用的方法是向正在处理该查询的后端进程发送一个特殊的信号）。
   </para>

   <para>
    取消信号可能产生或者不产生效果 &mdash; 例如，如果它在后端完成查询的处理后到达，那么它就没有做用。如果取消起作用了，会导致当前命令伴随着一个错误消息提前退出。
   </para>

   <para>
    这么做是对安全性和有效性通盘考虑的结果，前端没有直接的方法获知一个取消请求是否成功。它必须继续等待后端对查询响应。发出一个取消仅仅是增加了当前查询快些结束的可能性， 同时也增加了当前查询会伴随着一条错误消息失败而不是成功执行的可能性。
   </para>

   <para>
    因为取消请求是通过新的联接发送给服务器而不是通过平常的前端/后端通讯链接，所以取消请求可能被任意进程发出的，而不仅仅是要取消查询的前端。 这样可能对创建多进程应用提供了更多的灵活性。同时这样也带来了安全风险，因为任何一个非授权用户都可能试图取消查询。这个安全风险通过要求在取消请求中提供一个动态生成的密钥来解决。
   </para>
  </sect2>

  <sect2>
   <title>终止</title>

   <para>
    通常优雅的终止过程是前端发送一条Terminate消息并且立刻关闭连接。一旦收到消息，后端马上关闭连接并且终止。
   </para>

   <para>
    在少数情况下（比如一个管理员命令数据库关闭），后端可能在没有任何前端请求的情况下断开连接。在这种情况下，后端将在它断开连接之前尝试发送一个错误或者通知消息给出断开的原因。
   </para>

   <para>
    其它终止的情况发生在各种失败的场合，比如某一方的内核转储、失去通讯链路、丢失了消息边界同步等。不管是前端还是后端看到了一个意外的连接关闭，那么它应该清理现场并且终止。 如果前端不想终止自己，那么它有一个选项是重连服务器的方法启动一个新的后端。如果收到了一个无法识别的消息类型，那么我们也建议关闭连接，因为出现这种情况可能意味着是丢失了消息边界的同步。
   </para>

   <para>
    不管是正常还是不正常的终止，任何打开的事务都会回滚而不是提交。不过，我们应该注意的是如果一个前端在一个非<command>SELECT</command>查询正在处理的时候断开， 那么后端很可能在发现断开之前先完成查询的处理。如果查询处于任何事务块之外（<command>BEGIN</> ... <command>COMMIT</>序列），那么其结果很可能在得知断开之前被提交。
   </para>
  </sect2>

  <sect2>
   <title><acronym>SSL</acronym>会话加密</title>

   <para>
    如果编译<productname>PostgreSQL</>的时候打开了<acronym>SSL</acronym>支持，那么前后端通讯就可以用<acronym>SSL</acronym>加密。 这样就提供了一种在攻击者可能捕获会话通讯数据包的环境下保证通讯安全的方法。有关使用<acronym>SSL</acronym>加密<productname>PostgreSQL</productname>会话的更多信息， 请参阅<xref linkend="ssl-tcp">。
   </para>

   <para>
    要开始一次<acronym>SSL</acronym>加密连接，前端先是发送一个SSLRequest消息，而不是StartupMessage。然后服务器以一个包含<literal>S</>或<literal>N</>的字节响应，分别表示它愿意还是不愿意进行<acronym>SSL</acronym>。如果此时前端对响应不满意， 那么它可以关闭连接。要在<literal>S</>之后继续，那么先进行与服务器的<acronym>SSL</acronym>启动握手（没有在这里描述，是<acronym>SSL</acronym>规范的一部分）。 如果这些成功了，那么继续发送普通的StartupMessage。这种情况下，StartupMessage和所有随后的数据都将由<acronym>SSL</acronym>加密。要在<literal>N</>之后继续，则发送普通的StartupMessage并不适用加密继续处理。
   </para>

   <para>
    前端应该也准备处理一个来自服务器的给SSLRequest的ErrorMessage响应。这种情况只在服务器早于<productname>PostgreSQL</>的<acronym>SSL</acronym>支持的情况下才会出现（这种服务器现在非常古老，并且可能不再存在了）。在这种情况下，连接必需关闭，但是前端可以选择打开一个新的连接然后不使用<acronym>SSL</acronym>进行连接。
   </para>

   <para>
    一个初始化的 SSLRequest 也可以用于打开来用于发送一条 CancelRequest 消息的联接中。An initial SSLRequest can also be used in a connection that is being
    opened to send a CancelRequest message.
   </para>

   <para>
    如果协议本身并未提供某种方法强制<acronym>SSL</acronym>加密，那么管理员可以把服务器配置为拒绝未加密的会话，这是认证检查的一个副产品。
   </para>
  </sect2>
 </sect1>

<sect1 id="protocol-replication">
<title>流复制协议</title>

<para>
要启动流复制，前端在启动消息中发送<literal>replication</>参数。
一个布尔值<literal>true</>会告诉后端进入到walsender模式，
在其中一小组复制命令而不是SQL命令可以被发出。只有简单查询协议
可以在walsender模式中使用。传递<literal>database</>作为值指示
walsender 连接到<literal>dbname</>参数指定的数据库，这将允许
该连接被用于来自哪个数据库的逻辑复制。
</para>
<para>
 出于测试复制命令的目的，你可以通过<application>psql</application>
 或者任何使用<literal>libpq</literal>的工具使用包含
 <literal>replication</literal>选项的连接字符串建立一个复制连接，例如：
<programlisting>
psql "dbname=postgres replication=database" -c "IDENTIFY_SYSTEM;"
</programlisting>
 不过更常用的是：
 <application>pg_receivexlog</application> (for physical replication) or
 <application>pg_recvlogical</application> (for logical replication).
</para>

<para>

在walsender模式中可以接受的命令有：

<variablelist>
  <varlistentry>
    <term>IDENTIFY_SYSTEM
     <indexterm><primary>IDENTIFY_SYSTEM</primary></indexterm>
    </term>
    <listitem>
     <para>
      请求服务器标识它自己。服务器以一个行构成的结果集作为答复，其中包含四个域：
     </para>

     <para>
      <variablelist>
      <varlistentry>
      <term>
       systemid
      </term>
      <listitem>
      <para>
       标识该集簇的唯一的系统标识符。这可以被用来检查用于初始化后备机的基础备份是否来自于同一个集簇。
      </para>
      </listitem>
      </varlistentry>

      <varlistentry>
      <term>
       timeline
      </term>
      <listitem>
      <para>
       当前的TimelineID。也对于检查后备机是否与主控机一致有用。
      </para>
      </listitem>
      </varlistentry>

      <varlistentry>
      <term>
       xlogpos
      </term>
      <listitem>
      <para>
       当前的 xlog 刷写位置。用于得到一个在事务日志中的已知位置作为流的开始位置。
      </para>
      </listitem>
      </varlistentry>
      
      <varlistentry>
      <term>
       dbname
      </term>
      <listitem>
      <para>
       要连接到的数据库或者 NULL。
      </para>
      </listitem>
      </varlistentry>

      </variablelist>
     </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>TIMELINE_HISTORY <replaceable class="parameter">tli</replaceable>
     <indexterm><primary>TIMELINE_HISTORY</primary></indexterm>
    </term>
    <listitem>
     <para>
      请求服务器将时间线<replaceable class="parameter">tli</replaceable>的历史文件发送过来。服务器将以一行组成的结果集作为答复，其中包含两个域：
     </para>

     <para>
      <variablelist>
      <varlistentry>
      <term>
       filename
      </term>
      <listitem>
      <para>
       时间线历史文件的文件名，例如<filename>00000002.history</>。
      </para>
      </listitem>
      </varlistentry>

      <varlistentry>
      <term>
       content
      </term>
      <listitem>
      <para>
       时间线历史文件的内容。
      </para>
      </listitem>
      </varlistentry>

      </variablelist>
     </para>
    </listitem>
  </varlistentry>
  
  <varlistentry>
    <term>CREATE_REPLICATION_SLOT <replaceable class="parameter">slot_name</> { <literal>PHYSICAL</> | <literal>LOGICAL</> <replaceable class="parameter">output_plugin</> }
     <indexterm><primary>CREATE_REPLICATION_SLOT</primary></indexterm>
    </term>
    <listitem>
     <para>
      创建一个物理的或者逻辑的复制槽。更多关于复制槽的内容请见
      <xref linkend="streaming-replication-slots">。
     </para>
     <variablelist>
      <varlistentry>
       <term><replaceable class="parameter">slot_name</></term>
       <listitem>
         <para>
          要创建的槽的名称。必须是一个合法的复制槽名称（见
          <xref linkend="streaming-replication-slots-manipulation">）。
         </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><replaceable class="parameter">output_plugin</></term>
       <listitem>
         <para>
          被用于逻辑解码的输出插件的名称（见
          <xref linkend="logicaldecoding-output-plugin">）。
         </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>START_REPLICATION [<literal>SLOT</literal> <replaceable class="parameter">slot_name</>] [<literal>PHYSICAL</literal>] <replaceable class="parameter">XXX/XXX</> [<literal>TIMELINE</literal> <replaceable class="parameter">tli</>]
     <indexterm><primary>START_REPLICATION</primary></indexterm>
    </term>
    <listitem>
     <para>
      指示服务器开始启动流WAL，从 WAL 位置
      <replaceable class="parameter">XXX/XXX</>开始。
      如果<literal>TIMELINE</literal>选项被指定，流传送会在
      时间线<replaceable class="parameter">tli</>上开始，
      否则会选择服务器的当前时间线。服务器可以回复一个错误，
      例如如果被请求的WAL节已经被回收了。如果成功，
      服务器将会响应一个CopyBothResponse消息，并且然后开
      始以流的方式把WAL传送给前端。
     </para>
     
     <para>
      如果通过<replaceable class="parameter">slot_name</>
      提供了一个槽的名称，它将被更新复制进度，这样该服务器知道
      哪些 WAL 段以及哪些事务（如果
      <varname>hot_standby_feedback</>为打开）仍然被后备机
      所需要。
     </para>

     <para>
      如果客户端请求一个并非最新的时间线，但是属于服务器历史的一部分，服务器将会把该时间线上从请求点开始的所有WAL以流式传送，一直到服务器切换到另外一个时间线的点。如果客户端请求在一个老的时间线末尾进行流传送，服务器将在不进入COPY模式的情况下立即响应CommandComplete。
     </para>

     <para>
      在流传送完一个非最新时间线上所有的WAL之后，服务器将会通过退出COPY模式来结束流。当客户端认识到这一点并也退出COPY模式时，服务器会发送一个包含一行两列的结果集，以指示在该服务器历史中的下一个时间线。第一列是下一个时间线的ID，而第二列是发生切换的XLOG位置。通常，切换位置是被流传送的WAL的末尾，但是在很少的情况下服务器会从旧的时间线中发送一些WAL，而该时间线是服务器本身在提示之前还没有重放的。最后，服务器发送CommandComplete消息，并且做好准备接受一个新的命令。
     </para>

     <para>
      WAL数据以一系列CopyData消息的形式被发送（这允许其他信息穿插其中，特别是服务器可以在开始流传送后遇到失败时发送一个ErrorResponse消息）。每个从服务器到客户端的CopyData消息承载了一个下列格式之一的消息：
     </para>

     <para>
      <variablelist>
      <varlistentry>
      <term>
          XLogData (B)
      </term>
      <listitem>
      <para>
      <variablelist>
      <varlistentry>
      <term>
          Byte1('w')
      </term>
      <listitem>
      <para>
          标识该消息是WAL数据。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
          在消息中WAL数据的起始点。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
          服务器上WAL的当前终点。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
          在传送时服务器的系统时钟，以从2000-01-01午夜开始的微妙计。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Byte<replaceable>n</replaceable>
      </term>
      <listitem>
      <para>
          WAL数据流的一节。
      </para>
      <para>
          一个WAL记录绝不会被分割到两个XLogData消息。如果一个WAL记录跨越了一个WAL页面的边界，并且因此已经被使用连续的记录分割，它可以在页面边界被分割。换句话说，第一个主要WAL记录和它的后续记录可以在不同的XLogData消息中被发送。
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          主要存活消息 (B)
      </term>
      <listitem>
      <para>
      <variablelist>
      <varlistentry>
      <term>
          Byte1('k')
      </term>
      <listitem>
      <para>
          标识该消息是一个发送者存活消息。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
          服务器上WAL的当前终点。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
          在传送时服务器的系统时钟，以从2000-01-01午夜开始的微妙计。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Byte1
      </term>
      <listitem>
      <para>
          1表示客户端应该尽快回复该消息，以避免连接超时。否则为0。
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
     </para>

     <para>
       接收进程可以在任何时候给发送者发送回复，回复可以使用下列消息格式之一（也在CopData消息中使用）：
     </para>

     <para>
      <variablelist>
      <varlistentry>
      <term>
          后备机状态更新 (F)
      </term>
      <listitem>
      <para>
      <variablelist>
      <varlistentry>
      <term>
          Byte1('r')
      </term>
      <listitem>
      <para>
          标识该消息是一个接收者状态更新。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
          接收到并且写入到后备机磁盘的最后一个WAL比特的位置+1。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
          被刷入到后备机磁盘的最后一个WAL比特的位置+1。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
          被应用在后备机上的最后一个WAL比特的位置+1。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
          在传送时客户端的系统时钟，以从2000-01-01午夜开始的微妙计。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Byte1
      </term>
      <listitem>
      <para>
          如果为1，客户端要求服务器马上回复这个消息。这可以被用来ping服务器以测试连接是否仍然完好。
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
     </para>

     <para>
      <variablelist>
      <varlistentry>
      <term>
          热备机反馈消息 (F)
      </term>
      <listitem>
      <para>
      <variablelist>
      <varlistentry>
      <term>
          Byte1('h')
      </term>
      <listitem>
      <para>
          标识该消息是一个热备机反馈消息。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
          在传送时客户端的系统时钟，以从2000-01-01午夜开始的微妙计。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int32
      </term>
      <listitem>
      <para>
          后备机当前的xmin。如果后备机正在发送通知告知热备机反馈将不再通过此连接发送，这个值可能为0。后来的非0消息将重新启动反馈机制。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int32
      </term>
      <listitem>
      <para>
          后备机的当前世代。
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
     </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>START_REPLICATION <literal>SLOT</literal> <replaceable class="parameter">slot_name</> <literal>LOGICAL</literal> <replaceable class="parameter">XXX/XXX</> [ ( <replaceable>option_name</replaceable> [<replaceable>option_value</replaceable>] [, ... ] ) ]</term>
    <listitem>
     <para>
      指示服务器为逻辑复制开始流式传送 WAL，从 WAL 位置
      <replaceable class="parameter">XXX/XXX</>开始。服务器可以
      回复一个错误，例如如果请求的 WAL 小节已经回环。如果成功，服务
      器会响应一个 CopyBothResponse 消息，并且接着开始流失传送 WAL
      给前端。
     </para>

     <para>
      消息内部的消息与
      <literal>START_REPLICATION ... PHYSICAL</literal>中记录的格式相同。
     </para>

     <para>
      与选中槽关联的输出插件被用来处理流的输出。
     </para>

     <variablelist>
      <varlistentry>
       <term><literal>SLOT</literal> <replaceable class="parameter">slot_name</></term>
       <listitem>
         <para>
          要从哪个槽流式传送改变。这个参数是必须的，并且必须对应于一个
          现有的用<literal>LOGICAL</literal>模式的
          <literal>CREATE_REPLICATION_SLOT</literal>创建的逻辑复制槽。
         </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><replaceable class="parameter">XXX/XXX</></term>
       <listitem>
        <para>
         要开始流传送的 WAL 位置。
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><replaceable class="parameter">option_name</></term>
       <listitem>
        <para>
         一个传递给该槽的逻辑解码插件的选项的名称。
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><replaceable class="parameter">option_value</></term>
       <listitem>
        <para>
         字符串常量形式的选项值，与前面指定的选项关联。
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>DROP_REPLICATION_SLOT <replaceable class="parameter">slot_name</>
     <indexterm><primary>DROP_REPLICATION_SLOT</primary></indexterm>
    </term>
    <listitem>
     <para>
      删除一个复制槽，释放任何保留的服务器端资源。
      如果该槽当前正在被一个活动连接使用，这个命令会失败。
     </para>
     <variablelist>
      <varlistentry>
       <term><replaceable class="parameter">slot_name</></term>
       <listitem>
         <para>
          要删除的槽的名称。
         </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>BASE_BACKUP [<literal>LABEL</literal> <replaceable>'label'</replaceable>] [<literal>PROGRESS</literal>] [<literal>FAST</literal>] [<literal>WAL</literal>] [<literal>NOWAIT</literal>] [<literal>MAX_RATE</literal> <replaceable>rate</replaceable>]
     <indexterm><primary>BASE_BACKUP</primary></indexterm>
    </term>
    <listitem>
     <para>
      指示服务器开始流传送一个基础备份。在备份开始之前系统将自动被置于备份模式，而在备份结束时会自动被退出备份模式。可以接受下列选项：
      <variablelist>
       <varlistentry>
        <term><literal>LABEL</literal> <replaceable>'label'</replaceable></term>
        <listitem>
         <para>
          设置备份的标签。如果没有指定，将会使用<literal>base backup</literal>作为标签。标签的引号规则和<xref linkend="guc-standard-conforming-strings">开启时标准SQL字符串的一样。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>PROGRESS</></term>
        <listitem>
         <para>
          请求用以生成一个进度报告的信息。这将送回位于每个表空间头部的一个近似大小，它可以被用于计算流还有多久才能被完成。它通过在传输开始之前枚举所有文件大小来计算，并且可能会对性能产生一种负面影响 -- 特别情况下它可能会在流传送第一个数据之前就耗费很长时间。因为数据库文件可能在备份期间改变，这个大小只是近似的并且可能在近似计算和发送真正的文件之间增长或者收缩。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>FAST</></term>
        <listitem>
         <para>
          请求一个快速检查点。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>WAL</literal></term>
        <listitem>
         <para>
          在备份中包含必需的WAL段。这将把开始和停止备份之间的所有文件包括在base目录tar文件中的<filename>pg_xlog</filename>目录中。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>NOWAIT</literal></term>
        <listitem>
         <para>
          默认情况下，备份会等待直到最后一个要求的xlog段被归档，或者当日至归档被禁用时发出一个警告。指定<literal>NOWAIT</literal>会禁用等待和警告，而让客户端负责确保所要求的日志是可用的。
         </para>
         </listitem>
       </varlistentry>
       
       <varlistentry>
        <term><literal>MAX_RATE</literal> <replaceable>rate</></term>
        <listitem>
         <para>
          单位时间内从服务器传输到客户端的最大数据量限制。期望的单位
          是千字节每秒。如果指定了这个选项，值必须等于零或者位于 32 kB
          到 1 GB（包括）范围之间。如果 0 被传入或者没有指定该选项，对于
          传输将没有限制。
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
     <para>
      当备份被启动，服务器将首先发送两个普通结果集，后面会跟着一个或多个CopyResponse结果。
     </para>
     <para>
      第一个普通结果集在一行两列中包含了备份的起始位置。第一列包含使用XLogRecPtr格式给出的开始位置，第二列包含相应的时间线ID。
     </para>
     <para>
      第二个普通结果集中为每一个表空间都有一行。行中的域有：
      <variablelist>
       <varlistentry>
        <term>spcoid</term>
        <listitem>
         <para>
          表空间的oid，如果是base目录则为<literal>NULL</>。
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>spclocation</term>
        <listitem>
         <para>
          表空间目录的完整路径，如果是base目录则为<literal>NULL</>。
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>size</term>
        <listitem>
         <para>
          如果进度报告被请求，这里是表空间的近似大小，否则为<literal>NULL</>。
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
     <para>
      在第二个普通结果集之后，一个或多个CopyResponse结果将被发送，一个用于PGDATA而对每一个除<literal>pg_default</>和<literal>pg_global</>之外的额外表空间也会有一个。CopyResponse结果中的数据将会使一个tar格式（遵循POSIX 1003.1-2008标准中指定的<quote>ustar交换格式</>）的表空间内容转储，不过标准中定义的两个拖尾全0块将被忽略。在tar数据完成后，一个最终普通结果集将被发送，包含了备份的WAL结束位置，格式与起始位置相同。
     </para>

     <para>
      用于数据目录和每个表空间的tar归档将包含目录中的所有文件，不管它们是否为<productname>PostgreSQL</>文件或者是被加入的其他文件。唯一被排除的文件是：
      <itemizedlist spacing="compact" mark="bullet">
       <listitem>
        <para>
         <filename>postmaster.pid</>
        </para>
       </listitem>
       <listitem>
        <para>
         <filename>postmaster.opts</>
        </para>
       </listitem>
       <listitem>
        <para>
         在 PostgreSQL 服务器操作期间创建的多个临时文件
        </para>
       </listitem>
       <listitem>
        <para>
         <filename>pg_xlog</>及其子目录。如果备份运行时要求包括WAL文件，一个<filename>pg_xlog</filename>的合成版本将被包括进来，但是只会包含那些备份工作必需的文件，而不是包含剩下的内容。
        </para>
       </listitem>
       <listitem>
        <para>
         <filename>pg_replslot</>被复制为一个空目录。
        </para>
       </listitem>
       <listitem>
        <para>
         除常规文件和目录之外的其他文件（例如符号链接和特殊设备文件）
         会被跳过（<filename>pg_tblspc</filename>中的符号链接会被
         保留）。
        </para>
       </listitem>
      </itemizedlist>
      如果服务器上的底层文件系统支持，所有者、组合文件模式都会被设置。
     </para>
     <para>
      一旦所有的表空间已经被发送，一个最终普通结果集将被发送。这个结果集包含了备份的结束位置，它在一个单行单列的结果中使用XLogRecPtr格式给出。
     </para>
    </listitem>
  </varlistentry>
</variablelist>

</para>

</sect1>

<sect1 id="protocol-message-types">
<title>消息数据类型</title>

<para>
本节描述消息里用到的基本数据类型。

<variablelist>

<varlistentry>
<term>
        Int<replaceable>n</replaceable>(<replaceable>i</replaceable>)
</term>
<listitem>
<para>
                一个网络字节序（高位在前）的<replaceable>n</replaceable>位整数。 如果指定了<replaceable>i</replaceable>， 它就是将出现的准确值，否则该值就是一个变量。如 Int16、Int32(42)。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Int<replaceable>n</replaceable>[<replaceable>k</replaceable>]
</term>
<listitem>
<para>
                一个<replaceable>k</replaceable>个<replaceable>n</replaceable>位整数的数组， 每个都是以网络字节序表示的。数组长度<replaceable>k</replaceable>总是由消息前面的域来判断的。比如，Int16[M]。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        String(<replaceable>s</replaceable>)
</term>
<listitem>
<para>
                一个（C风格的）空值结束的字符串。对字符串没有特别的长度限制。如果指定了<replaceable>s</replaceable>，那么它是将出现的确切的值， 否则这个值就是一个变量。比如，String, String("user")。
</para>

<note>
<para>
后端能返回的字符串的长度<emphasis>没有预定义的限制</emphasis>。所以对前端比较好的编码策略是使用某种可扩展的缓冲区，以便能接受任何能放进内存里的东西。如果那样做不可行，则读取完整的字符串然后抛弃不能放进固定大小缓冲区的尾部字符。
</para>
</note>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Byte<replaceable>n</replaceable>(<replaceable>c</replaceable>)
</term>
<listitem>
<para>
                精确的<replaceable>n</replaceable>字节。 如果域宽度<replaceable>n</replaceable>不是一个常量， 那么我们总是可以从消息中更早的域中判断它。如果指定了<replaceable>c</replaceable>，那么它就是确切数值。 例如，Byte2, Byte1('\n')。
</para>
</listitem>
</varlistentry>

</variablelist>
</para>
</sect1>

<sect1 id="protocol-message-formats">
<title>消息格式</title>

<para>
本节描述各种消息的详细格式。每种消息都标记来指示它是由前端（F）、后端（B）或者两者（F & B）发送的。 请注意，尽管每条消息在开头都包含一个字节计数，但是消息格式也被定义为无需参考字节计数就可以找到消息的结尾。 这样是为了有效性检查（CopyData消息是一个例外，因为它形成一个数据流的一部分；任意独立的CopyData消息可能是无法自解释的）。
</para>

<variablelist>


<varlistentry>
<term>
AuthenticationOk (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                标识该消息是一条认证请求。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
                以字节计的消息内容长度，包括这个长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(0)
</term>
<listitem>
<para>
                指定该认证是成功的。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
AuthenticationKerberosV5 (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                标识该消息是一条认证请求。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
                以字节计的消息内容长度，包括长度自身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(2)
</term>
<listitem>
<para>
                指定要求Kerberos V5认证。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
AuthenticationCleartextPassword (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                标识该消息是一条认证请求。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
                以字节计的消息内容长度，包括长度自身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(3)
</term>
<listitem>
<para>
                指定要求一个明文的口令。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
AuthenticationMD5Password (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                标识这条消息是一个认证请求。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(12)
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(5)
</term>
<listitem>
<para>
                指定要求一个MD5加密的口令。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte4
</term>
<listitem>
<para>
                加密口令的时候使用的盐粒。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
AuthenticationSCMCredential (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                标识这条消息是一个认证请求。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
                以字节计的消息内容长度，包括长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(6)
</term>
<listitem>
<para>
                指定请求一个SCM信任消息。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
AuthenticationGSS (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                标识该消息是一个认证请求。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
                
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(7)
</term>
<listitem>
<para>
                指定被请求的是GSSAPI认证。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
AuthenticationSSPI (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                标识该消息是一个认证请求。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
                
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(9)
</term>
<listitem>
<para>
                指定被请求的是SSPI认证。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
AuthenticationGSSContinue (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                标识该消息是一个认证请求。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
                指定该消息包含GSSAPI或SSPI数据。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                GSSAPI或SSPI认证数据。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
BackendKeyData (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('K')
</term>
<listitem>
<para>
                标识该消息是一个取消键数据。如果前端希望能够在稍后发出CancelRequest消息， 那么它必须保存这个值。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(12)
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                后端的进程号（PID）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                此后端的密钥。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Bind (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('B')
</term>
<listitem>
<para>
                标识该信息是一个绑定命令。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                目标入口的名字（空字符串则选取未命名的入口）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                源预备语句的名字（空字符串则选取未命名的预备语句）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                后面跟着的参数格式代码的数目（由下文的<replaceable>C</>说明）。 这个数值可以是零，表示没有参数，或者是参数都使用缺省格式（文本）； 也可以是一，这种情况下指定的格式代码被应用于所有参数；或者它可以等于实际参数的数目。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>C</>]
</term>
<listitem>
<para>
                参数格式代码。目前每个都必须是零（文本）或者一（二进制）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                后面跟着的参数值的数目（可能为零）。这些必须和查询需要的参数个数匹配。
</para>
</listitem>
</varlistentry>
</variablelist>
        然后，每个参数都会出现下面的域对：
<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                参数值的长度，以字节计（这个长度并不包含长度本身）。可以为零。 一个特殊的情况是，-1 表示一个NULL参数值。在NULL 的情况下， 后面不会跟着字节值。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                参数值，使用关联的格式代码表示的格式。<replaceable>n</replaceable>是上文的长度。
</para>
</listitem>
</varlistentry>
</variablelist>
        在最后一个参数之后，出现下面的域：
<variablelist>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                后面跟着的结果列格式代码数目（下文的<replaceable>R</>描述）。 这个数目可以是零表示没有结果列或者结果列都使用缺省格式（文本）； 也可以是一，这种情况下指定的格式代码被应用于所有结果列（如果有的话）；或者它可以等于查询的结果列的实际数目。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>R</>]
</term>
<listitem>
<para>
                结果列格式代码。目前每个必须是零（文本）或者一（二进制）。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
BindComplete (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('2')
</term>
<listitem>
<para>
                标识该消息为一个绑定结束标识符。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                以字节计的消息长度，包括长度本身。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
CancelRequest (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Int32(16)
</term>
<listitem>
<para>
                以字节计的消息长度。包括长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(80877102)
</term>
<listitem>
<para>
                取消请求代码。该值被选中在高16位包含<literal>1234</>，并且在低16位包含 <literal>5678</>（为避免混淆，这个代码不能和任何协议版本号相同）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                目标后端的进程号（PID）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                目标后端的密钥。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Close (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('C')
</term>
<listitem>
<para>
                标识这条消息是一个Close命令。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容长度，包括长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte1
</term>
<listitem>
<para>
                '<literal>S</>'关闭一个准备的语句；或者'<literal>P</>'关闭一个入口。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                一个要关闭的预备语句或者入口的名字（一个空字符串选择未命名的预备语句或者入口）。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
CloseComplete (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('3')
</term>
<listitem>
<para>
                标识消息是一个Close完成指示器。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度本身。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
CommandComplete (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('C')
</term>
<listitem>
<para>
                标识此消息是一个命令结束响应。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
       <para>
        命令标记。它通常是一个单字，标识被完成的SQL命令。
       </para>

       <para>
        对于<command>INSERT</command>命令，该标记是<literal>INSERT <replaceable>oid</replaceable> <replaceable>rows</replaceable></literal>， 其中<replaceable>rows</replaceable>是已被插入的行数。<replaceable>oid</replaceable>是在<replaceable>rows</replaceable>为 1并且目标表有OID时已插入行的对象ID；否则<replaceable>oid</replaceable>就是 0。
       </para>

       <para>
        对于<command>DELETE</command>命令，该标记是<literal>DELETE <replaceable>rows</replaceable></literal>， 其中<replaceable>rows</replaceable>是已被删除的行数。
       </para>

       <para>
        对于<command>UPDATE</command>命令，该标记是<literal>UPDATE <replaceable>rows</replaceable></literal>，其中<replaceable>rows</replaceable>是已被更新的行数。
       </para>

       <para>
        对于<command>SELECT</command>或<command>CREATE TABLE AS</command>命令，该标记是<literal>SELECT <replaceable>rows</replaceable></literal>，其中<replaceable>rows</replaceable>是被检索的行数。
       </para>

       <para>
        对于<command>MOVE</command>命令，该标记是<literal>MOVE <replaceable>rows</replaceable></literal>，其中<replaceable>rows</replaceable>是游标位置被移动的行数。
       </para>

       <para>
        对于<command>FETCH</command>命令，该标记是<literal>FETCH <replaceable>rows</replaceable></literal>，其中<replaceable>rows</replaceable>是已从游标中检索出来的行数。
       </para>

       <para>
        对于<command>COPY</command>命令，该标记是<literal>COPY <replaceable>rows</replaceable></literal>，其中<replaceable>rows</replaceable>是已拷贝的行数（注意，行计数只在<productname>PostgreSQL</productname> 8.2及其后的版本中出现）。
       </para>

</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
CopyData (F &amp; B)
</term>
<listitem>
<para>
<variablelist>
<varlistentry>
<term>
        Byte1('d')
</term>
<listitem>
<para>
                标识这条消息是一个<command>COPY</command>数据。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                构成<command>COPY</command>数据流的一部分的数据。从后端发出的消息总是对应单一的数据行，但是前端发出的消息可能会任意分割数据流。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
CopyDone (F &amp; B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('c')
</term>
<listitem>
<para>
                标识这条信息是一个<command>COPY</command>结束指示器。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                以字节计的消息内容长度，包括长度本身。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
CopyFail (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('f')
</term>
<listitem>
<para>
                标识这条消息是一个<command>COPY</command>失败指示器。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                一个报告失败原因的错误消息。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
CopyInResponse (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('G')
</term>
<listitem>
<para>
                标识这条消息是一条Start Copy In（开始拷贝入）响应消息。前端现在必须发送拷贝入数据（如果还没准备好做这些事情，那么发送一条CopyFail消息）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int8
</term>
<listitem>
<para>
                0表示全体拷贝格式都是文本（数据行由新符分隔， 列由分隔字符分隔等等）。1 表示全体拷贝格式都是二进制的（类似于DataRow 格式）。参阅<xref linkend="sql-copy">获取更多信息。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                要拷贝的数据中的列数（由下文的<replaceable>N</>解释）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>N</>]
</term>
<listitem>
<para>
                每个列要使用的格式代码。目前每个都必须是零（文本）或者一（二进制）。 如果全体拷贝格式都是文本，那么所有的都必须是零。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
CopyOutResponse (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('H')
</term>
<listitem>
<para>
                标识这条消息是一条Start Copy Out（开始拷贝出）响应消息。这条消息后面将跟着拷贝出数据。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括它自己。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int8
</term>
<listitem>
<para>
                0表示全体拷贝格式都是文本（数据行由新符分隔， 列由分隔字符分隔等等）。1 表示全体拷贝格式都是二进制的（类似于DataRow 格式）。参阅<xref linkend="sql-copy">获取更多信息。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                要拷贝的数据的列数（在下文的<replaceable>N</>说明）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>N</>]
</term>
<listitem>
<para>
                每个列要使用的格式代码。目前每个都必须是零（文本）或者一（二进制）。 如果全体拷贝格式都是文本，那么所有的都必须是零。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
CopyBothResponse (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('W')
</term>
<listitem>
<para>
                标识这个消息是一个Start Copy Both（启动双向复制）响应。这个消息只用于流复制。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度自身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int8
</term>
<listitem>
<para>
                0表示全体<command>COPY</command>格式都是文本（数据行由新符分隔，列由分隔字符分隔等等）。1 表示全体拷贝格式都是二进制的（类似于DataRow格式）。参阅<xref linkend="sql-copy">获取更多信息。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                要拷贝的数据中的列数目（在下文的<replaceable>N</>说明）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>N</>]
</term>
<listitem>
<para>
                每个列要使用的格式代码。目前每个都必须是零（文本）或者一（二进制）。 如果全体拷贝格式都是文本，那么所有的代码都必须是零。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
DataRow (B)
</term>
<listitem>
<para>
<variablelist>
<varlistentry>
<term>
        Byte1('D')
</term>
<listitem>
<para>
                标识这个消息是一个数据行。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度自身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                后面跟着的列值的个数（可能是零）。
</para>
</listitem>
</varlistentry>
</variablelist>
        然后，为每个列都会出现下面的域对：
<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                列值的长度，以字节计（这个长度不包括它自己）。可以为零。一个特殊的情况是，-1表示一个NULL的域值。 如果是NULL的情况则后面不会跟着值字节。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                一个列的数值，以相关的格式代码指示的格式展现。<replaceable>n</replaceable>是上文的长度。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Describe (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('D')
</term>
<listitem>
<para>
                标识该消息是一个Describe（描述）命令。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括字节本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte1
</term>
<listitem>
<para>
               '<literal>S</>'描述一个预备语句；或者 '<literal>P</>' 描述一个入口。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                要描述的预备语句或者入口的名字（或者一个空字符串，就会选取未命名的预备语句或者入口）。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
EmptyQueryResponse (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('I')
</term>
<listitem>
<para>
                标识这条消息是对一个空查询字符串的响应（这个消息替换了CommandComplete）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                以字节计的消息内容长度，包括它自己。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
ErrorResponse (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('E')
</term>
<listitem>
<para>
                标识该消息是一条错误。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度本身。
</para>
</listitem>
</varlistentry>
</variablelist>
        消息体由一个或多个标识域组成，后面跟着一个零字节作为终止符。域可以以任何顺序出现。对于每个域都有下面的东西：
<variablelist>
<varlistentry>
<term>
        Byte1
</term>
<listitem>
<para>
                一个标识域类型的代码；如果为零，这就是消息终止符并且不会跟着有字符串。目前定义的域类型在<xref linkend="protocol-error-fields">列出。由于将来可能增加更多的域类型，所以前端应该默默地忽略未识别类型的域。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                域值。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Execute (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('E')
</term>
<listitem>
<para>
                标识该消息是一个Execute命令。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度自身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                要执行的入口的名字（空字符串选择未命名的入口）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                要返回的最大行数，如果入口包含返回行的查询（否则忽略）。零表示<quote>无限制</>。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Flush (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('H')
</term>
<listitem>
<para>
                标识该消息是一条Flush命令。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度本身。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
FunctionCall (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('F')
</term>
<listitem>
<para>
                标识该消息是一个函数调用。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                指定要调用的函数的对象ID（OID）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                后面跟着的参数格式代码的数目（用下文的<replaceable>C</>表示）。 它可以是零，表示没有参数，或者是所有参数都使用缺省格式（文本）； 也可以是一，这种情况下声明的格式代码被应用于所有参数；或者它可以等于参数的实际个数。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>C</>]
</term>
<listitem>
<para>
                参数格式代码。目前每个必须是零（文本）或者一（二进制）
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                指定提供给函数的参数个数。
</para>
</listitem>
</varlistentry>
</variablelist>
        然后，对每个参数都出现下面域对：
<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的参数值的长度（不包括长度本身）。可以为零。一个特殊的例子是，-1表示一个NULL参数值。如果是NULL，则没有参数字节跟在后面。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                参数的值，格式由相关的格式代码指示。<replaceable>n</replaceable>是上文的长度。
</para>
</listitem>
</varlistentry>
</variablelist>
        在最后一个参数之后，出现下面的域：
<variablelist>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                函数结果的格式代码。目前必须是零（文本）或者一（二进制）。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
FunctionCallResponse (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('V')
</term>
<listitem>
<para>
                标识这条消息是一个函数调用结果。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容长度，包括长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的函数结果值的长度（不包括长度本身）。可以为零。一个特殊的情况是，-1表示NULL函数结果。如果是NULL则后面没有值字节跟随。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                函数结果的值，格式由相关联的格式代码指示。<replaceable>n</replaceable>是上文的长度。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
NoData (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('n')
</term>
<listitem>
<para>
                标识这条消息是一个无数据指示器。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                以字节计的消息内容长度，包括长度本身。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
NoticeResponse (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('N')
</term>
<listitem>
<para>
                标识这条消息是一个通知。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容长度，包括长度本身。
</para>
</listitem>
</varlistentry>
</variablelist>
        消息体由一个或多个标识域组成，后面跟着零字节作为中止符。域可以以任何顺序出现。对于每个域，都有下面的东西：
<variablelist>
<varlistentry>
<term>
        Byte1
</term>
<listitem>
<para>
                一个标识域类型的代码；如果为零，那么它就是消息终止符，并且后面不会跟着字符串。目前定义的域类型在<xref linkend="protocol-error-fields">里列出。由于将来可能会增加更多域类型，所以前端应该将不能识别的域安静地忽略掉。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                域值。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
NotificationResponse (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('A')
</term>
<listitem>
<para>
                标识这条消息是一个通知响应。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计地消息内容地长度，包括长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                通知后端进程的进程ID。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                通知被抛出的通道的名字。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                从通知进程传递过来的<quote>载荷</>字符串。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
ParameterDescription (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('t')
</term>
<listitem>
<para>
                标识该消息是一个参数描述。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容长度，包括长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                语句所使用的参数的个数（可以为零）。
</para>
</listitem>
</varlistentry>
</variablelist>
        然后，对每个参数，有下面的东西：
<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                指定参数数据类型的对象ID。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
ParameterStatus (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('S')
</term>
<listitem>
<para>
                标识这条消息是一个运行时参数的状态报告。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度自身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                被报告的运行时参数的名字。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                参数的当前值。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Parse (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('P')
</term>
<listitem>
<para>
                标识该消息是一条Parse命令。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度自身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                目的预备语句的名字（空字符串选取未命名的预备语句）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                要分析的查询字符串。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                指定的参数数据类型的数目（可以为零）。请注意这个参数并不表示可能在查询字符串里出现的参数个数， 只是前端希望预先为其指定类型的参数数目。
</para>
</listitem>
</varlistentry>
</variablelist>
        然后，对每个参数，有下面的东西：
<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                指定参数数据类型的对象ID。这里为零等效于不指定该类型。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
ParseComplete (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('1')
</term>
<listitem>
<para>
                标识该消息是一个Parse完成指示器。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                以字节计的消息内容长度，包括长度自身。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
PasswordMessage (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('p')
</term>
<listitem>
<para>
                标识该消息是一个口令响应。注意这也被用于GSSAPI和SSPI响应消息（这实际是一个设计错误，因为在这种情况下包含的数据不是一个空值终止的字符串，而可能是任意二进制数据）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                口令（如果要求了，就是加密后的）。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
PortalSuspended (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('s')
</term>
<listitem>
<para>
                标识这条消息是一个入口暂停指示器。请注意这个消息只出现在达到一条Execute消息的行计数限制的时候。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度自身。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Query (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('Q')
</term>
<listitem>
<para>
                标识该消息是一个简单查询。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度自身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                查询字符串自身。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
ReadyForQuery (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('Z')
</term>
<listitem>
<para>
                标识消息的类型。在后端为新的查询周期准备好的时候，总会发送 ReadyForQuery。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(5)
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte1
</term>
<listitem>
<para>
                当前后端事务状态指示器。可能的值是空闲状况下的'<literal>I</>'（不在事务块里）；在事务块里是'<literal>T</>'； 或者在一个失败的事务块里是'<literal>E</>'（在事务块结束之前，任何查询都将被拒绝）。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
RowDescription (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('T')
</term>
<listitem>
<para>
                标识该消息是一个行描述。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度自身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                指定在一个行里面的域的数目（可以为零）。
</para>
</listitem>
</varlistentry>
</variablelist>
        然后对于每个字段，有下面的东西：
<variablelist>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                字段名字。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                如果域可以被标识为一个指定表的列，这里就是表的对象ID；否则就是零。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                如果该域可以被标识为一个指定表的列，这里就是该列的属性号；否则就是零。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                域数据类型的对象ID。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                数据类型尺寸（参阅<varname>pg_type.typlen</>）。请注意负值表示变宽类型。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                类型修饰词（参阅<varname>pg_attribute.atttypmod</>）。 修饰词的含义是类型相关的。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                用于该域的格式码。目前会是零（文本）或者一（二进制）。 在Describe语句的变体返回的RowDescription里，格式码还是未知的，因此总是零。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
SSLRequest (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(80877103)
</term>
<listitem>
<para>
                <acronym>SSL</acronym>请求码。选取的值在高16位里包含<literal>1234</>，在低16位里包含<literal>5679</> （为了避免混淆，这个编码必须和任何协议版本号不同）。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
StartupMessage (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容长度，包括长度自身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(196608)
</term>
<listitem>
<para>
                协议版本号。高16位是主版本号（对这里描述的协议而言是 3）。低16位是次版本号（对于这里描述的协议而言是 0）。
</para>
</listitem>
</varlistentry>
</variablelist>
        协议版本号后面跟着一个或多个参数名和值字符串的对。要求在最后一个名字/数值对后面有个零字节作为终止符。 参数可以以任意顺序出现。<literal>user</>是必须的，其它都是可选的。每个参数是这样指定的：
<variablelist>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                参数名。目前可以识别的名字是：

<variablelist>
<varlistentry>
<term>
                <literal>user</>
</term>
<listitem>
<para>
                        用于连接的数据库用户名。必须；无缺省。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
                <literal>database</>
</term>
<listitem>
<para>
                        要连接的数据库。缺省是用户名。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
                <literal>options</>
</term>
<listitem>
<para>
                        给后端的命令行参数（这个特性已经废弃，更好的方法是设置单独的运行时参数）。
</para>
</listitem>
</varlistentry>
</variablelist>

                除了上文提到的外，在后端启动时可设置的任何运行时参数都可以被列出来。 这样的设置将在后端启动时被应用（在分析了可能出现的命令行参数之后）。这些值将成为会话缺省。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                参数值。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Sync (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('S')
</term>
<listitem>
<para>
                表示该消息为一条 Sync 命令。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度自身。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Terminate (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('X')
</term>
<listitem>
<para>
                标识本消息是一个终止。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度自身。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


</variablelist>

</sect1>


<sect1 id="protocol-error-fields">
<title>错误和通知消息域</title>

<para>
本节描述那些可能出现在ErrorResponse和NoticeResponse消息里的域。 每个域类型有一个单字节标识记号。请注意，任意给定的域类型在每条消息里应该最多出现一次。
</para>

<variablelist>

<varlistentry>
<term>
<literal>S</>
</term>
<listitem>
<para>
        严重性：该域的内容是<literal>ERROR</>、<literal>FATAL</>或者<literal>PANIC</>（在一个错误消息里），或者<literal>WARNING</>、<literal>NOTICE</>、<literal>DEBUG</>、<literal>INFO</>或者<literal>LOG</>（在一条通知消息里），或者是这些形式的某种本地化翻译。总是会出现。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>C</>
</term>
<listitem>
<para>
        代码：错误的SQLSTATE代码（参阅<xref linkend="errcodes-appendix">）。非本地化。总是出现。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>M</>
</term>
<listitem>
<para>
        消息：人类可读的错误消息的主体。这些信息应该准确并且简洁（通常是一行）。总是出现。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>D</>
</term>
<listitem>
<para>
        细节：一个可选的二级错误消息，携带了有关问题的更多错误消息。可以是多行。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>H</>
</term>
<listitem>
<para>
        提示：一个可选的有关如何处理问题的建议。它和细节不同的地方是它提出了建议（可能并不合适）而不仅仅是事实。可以是多行。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>P</>
</term>
<listitem>
<para>
        位置：这个域值是一个十进制ASCII整数，表示一个错误游标的位置，它是一个指向原始查询字符串的索引。第一个字符的索引是 1，位置是以字符计算而非字节计算的。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>p</>
</term>
<listitem>
<para>
        内部位置：这个域和<literal>P</>域定义相同，但是它被用于当游标位置指向一个内部生成的命令的情况， 而不是用于客户端提交的命令。这个域出现的时候，总是会出现<literal>q</>域。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>q</>
</term>
<listitem>
<para>
        内部查询：失败的内部生成的命令的文本。比如，它可能是一个PL/pgSQL函数发出的 SQL 查询。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>W</>
</term>
<listitem>
<para>
        哪里：一个指示错误发生的环境的指示器。目前，它包含一个活跃的过程语言函数的调用堆栈的路径和内部生成的查询。 这个路径每个项记录一行，最新的在最前面。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>s</>
</term>
<listitem>
<para>
        模式名：如果错误与一个指定数据库对象相关，这里是包含该对象的模式名（如果有）。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>t</>
</term>
<listitem>
<para>
        表明：如果错误与一个指定表相关，这里是表的名字（引用该表模式的名字的模式名域）。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>c</>
</term>
<listitem>
<para>
        列名：如果错误与一个指定表列相关，这里是该列的名字（引用该模式和表的名字来标识该表）。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>d</>
</term>
<listitem>
<para>
        数据类型名：如果错误与一个指定数据类型相关，这里是该数据类型的名字（引用该数据类型模式的名字的模式名域）。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>n</>
</term>
<listitem>
<para>
        约束名：如果错误是和一个指定约束相关，这里是该约束的名字。引用至上面列出的相关表或域的域（为了这个目的，索引被视作约束，即使它们并不是按照约束语法创建的）。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>F</>
</term>
<listitem>
<para>
        文件：报告的错误在源代码中的文件名。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>L</>
</term>
<listitem>
<para>
        行：报告的错误所在的源代码的位置的行号。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>R</>
</term>
<listitem>
<para>
        例程：报告错误的例程在源代码中的名字。
</para>
</listitem>
</varlistentry>

</variablelist>

<note>
 <para>
  用于模式名、表名、列名、数据类型名和约束名只提供给有限的几种错误类型；请参考<xref linkend="errcodes-appendix">。前端不应当假设任何一个这些域的出现会保证其他域的出现。核心错误资源会看到上面提示的相互关系，但是用户定义的函数可能会以其他方式使用这些域。同样的道理，客户端不应该假设这些域表示当前数据库中同一时期的对象。
 </para>
</note>

<para>
客户端负责格式化要显示的信息以符合需要；特别是它应该根据需要断开长的行。在错误消息域里出现的新行字符应该被当作一个分段的符号，而不是换行。
</para>

</sect1>

<sect1 id="protocol-changes">
<title>自协议2.0以来的变化总结</title>

<para>
本节提供一个快速的改变检查列表，以便于那些试图将现有的客户端库更新到3.0协议的开发人员。
</para>

<para>
初始化的启动包用了一个灵活的字符串列表格式取代了固定的格式。请注意，运行时参数的会话缺省值现在可以直接在启动包中指定（实际上，你可以在使用<literal>options</>域之前干这件事情，但是因为<literal>options</>的宽度限制以及缺乏引用值中空白的方法，这并不是很安全的技巧）。
</para>

<para>
现在所有的消息在消息类型字节后面都有一个长度计数（除了启动包之外，它没有类型字节）。同时还要注意现在PasswordMessage有一个类型字节。
</para>

<para>
ErrorResponse和NoticeResponse（'<literal>E</>' 和 '<literal>N</>'）消息现在包含多个域， 从这些域里客户端代码可以组合出自己所希望的详细程度的错误消息。请注意个体的域通常不是用新行终止的，虽然在老的协议里发送的单个字符串总是会用新行终止。
</para>

<para>
ReadyForQuery（'<literal>Z</>'）消息包括一个事务状态指示符。
</para>

<para>
BinaryRow和DataRow消息类型之间的区别不再存在了；单个DataRow消息类型用于返回所有格式的数据。请注意DataRow的布局已经被变得更容易分析。同样，二进制值的表现形式已经改变了：它不再直接和服务器的内部表现形式绑定。
</para>

<para>
有了一种新的<quote>扩展查询</>的子协议，它增加了前端消息类型Parse、Bind、Execute、Describe、Close、Flush和Sync，以及后端消息类型ParseComplete、 BindComplete、PortalSuspended、ParameterDescription、NoData和CloseComplete。现有的客户端不用关心这个子协议，但是利用这个子协议将令我们可能提升性能或者功能。
</para>

<para>
<command>COPY</command>数据现在封装到了CopyData和CopyDone消息里。现在有种很好的方法从正在进行的<command>COPY</command>动作中的错误恢复。 最后一行的特殊的<quote><literal>\.</></quote>不再需要了，并且在<command>COPY OUT</command>的过程中不再发送（在<command>COPY IN</command>的时候它仍然被认为是一个终止符，但是它的使用已经废弃了并且最终将被删除）。 现在支持二进制<command>COPY</command>。CopyInResponse和CopyOutResponse消息包括指示列数目和每个列格式的域。
</para>

<para>
FunctionCall和FunctionCallResponse消息的布局变化了。FunctionCall现在支持给函数传递NULL参数。它同样可以处理以文本或者二进制格式传递参数和检索结果。我们不用再认为FunctionCall有潜在的安全性漏洞，因为它并不提供对内部服务器数据表现形式的直接访问。
</para>

<para>
在连接启动期间，后端会为它认为客户端库感兴趣的所有参数发送ParameterStatus（'<literal>S</>'）消息。随后，如果这些参数的任何活跃值发生变化，那么将发送一条ParameterStatus消息。
</para>

<para>
RowDescription（'<literal>T</>'）消息为所描述的行的每个列运载新表的OID和列编号域。它同样还表示每个列的格式代码。
</para>

<para>
后端不再生成 CursorResponse（'<literal>P</>'）消息。
</para>

<para>
NotificationResponse（'<literal>A</>'）消息有一个附加的字符串域，它能携带来自<command>NOTIFY</command>事件发送者的一个<quote>载荷</>字符串。
</para>

<para>
EmptyQueryResponse（'<literal>I</>'）以前包含一个空字符串参数；现在已经被删除。
</para>

</sect1>

</chapter>
