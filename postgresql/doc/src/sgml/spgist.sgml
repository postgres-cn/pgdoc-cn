<!-- doc/src/sgml/spgist.sgml -->

<chapter id="SPGiST">
<!--
<title>SP-GiST Indexes</title>
-->
<title>SP-GiST索引</title>

   <indexterm>
<!--
    <primary>index</primary>
-->
    <primary>索引</primary>
    <secondary>SP-GiST</secondary>
   </indexterm>

<sect1 id="spgist-intro">
<!--
 <title>Introduction</title>
-->
 <title>介绍</title>

 <para>
<!--
  <acronym>SP-GiST</acronym> is an abbreviation for space-partitioned
  <acronym>GiST</acronym>.  <acronym>SP-GiST</acronym> supports partitioned
  search trees, which facilitate development of a wide range of different
  non-balanced data structures, such as quad-trees, k-d trees, and radix
  trees (tries).  The common feature of these structures is that they
  repeatedly divide the search space into partitions that need not be
  of equal size.  Searches that are well matched to the partitioning rule
  can be very fast.
-->
<acronym>SP-GiST</acronym>是空间分割的(Space-Partitioned)<acronym>GiST</acronym>的省略语。
<acronym>SP-GiST</acronym>支持分区的搜索树，这有助于开发四叉树，KD树，基数树(radix tree)等范围广泛的不同的非平衡数据结构。
这些结构的共通特征是它们反复地把搜索空间划分成大小不必相等的分区。能很好的匹配分区规则的查询会非常快。
 </para>

 <para>
<!--
  These popular data structures were originally developed for in-memory
  usage.  In main memory, they are usually designed as a set of dynamically
  allocated nodes linked by pointers.  This is not suitable for direct
  storing on disk, since these chains of pointers can be rather long which
  would require too many disk accesses.  In contrast, disk-based data
  structures should have a high fanout to minimize I/O.  The challenge
  addressed by <acronym>SP-GiST</acronym> is to map search tree nodes to
  disk pages in such a way that a search need access only a few disk pages,
  even if it traverses many nodes.
-->
这些流行的数据结构一开始是被设计用在内存中的。
在内存中，它们通常被设计为由指针链接起来的动态分配的节点的集合。
这不适合直接在磁盘上存储，因为这些指针链相当长可能需要太多的磁盘访问。
相对的，基于磁盘的数据结构应该在最小的I/O上有很高的展开。
<acronym>SP-GiST</acronym>要解决的挑战是把搜索树映射到磁盘页面上，通过这种方式即使遍历很多节点也只需访问很少的磁盘页面。
 </para>

 <para>
<!--
  Like <acronym>GiST</acronym>, <acronym>SP-GiST</acronym> is meant to allow
  the development of custom data types with the appropriate access methods,
  by an expert in the domain of the data type, rather than a database expert.
-->
和<acronym>GiST</acronym>一样，<acronym>SP-GiST</acronym>允许伴随相应访问方法的定制数据类型由该数据类型领域里的专家而不是数据库专家来开发。
 </para>

 <para>
<!--
  Some of the information here is derived from Purdue University's
  SP-GiST Indexing Project
  <ulink url="http://www.cs.purdue.edu/spgist/">web site</ulink>.
  The <acronym>SP-GiST</acronym> implementation in
  <productname>PostgreSQL</productname> is primarily maintained by Teodor
  Sigaev and Oleg Bartunov, and there is more information on their
-->
  <!-- URL will be changed -->
<!--
  <ulink url="http://www.sai.msu.su/~megera/wiki/spgist_dev">web site</ulink>.
-->
这里的有些信息是来自普渡大学(Purdue University)的 SP-GiST索引项目
<ulink url="http://www.cs.purdue.edu/spgist/">网站</ulink>。
<productname>PostgreSQL</productname>中的<acronym>SP-GiST</acronym>
实现目前主要是 Teodor Sigaev 和 Oleg Bartunov 维护的，在他们的
<ulink url="http://www.sai.msu.su/~megera/wiki/spgist_dev">网站</ulink>上有更多信息。
 </para>
</sect1>

<sect1 id="spgist-builtin-opclasses">
<!-- 
 <title>Built-in Operator Classes</title> 
-->
 <title>内建操作符类</title>

 <para>
<!-- 
  The core <productname>PostgreSQL</> distribution
  includes the <acronym>SP-GiST</acronym> operator classes shown in
  <xref linkend="spgist-builtin-opclasses-table">.
-->
内核<productname>PostgreSQL</>发布包括<acronym>SP-GiST</acronym>
操作符类，显示在<xref linkend="spgist-builtin-opclasses-table">中。
 </para>

  <table id="spgist-builtin-opclasses-table">
<!-- 
   <title>Built-in <acronym>SP-GiST</acronym> Operator Classes</title> 
-->
   <title>内建<acronym>SP-GiST</acronym>操作符类</title>
   <tgroup cols="3">
    <thead>
     <row>
<!-- 
      <entry>Name</entry>
      <entry>Indexed Data Type</entry>
      <entry>Indexable Operators</entry> 
-->
      <entry>名字</entry>
      <entry>索引的数据类型</entry>
      <entry>可索引的操作符</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><literal>kd_point_ops</></entry>
      <entry><type>point</></entry>
      <entry>
       <literal>&lt;&lt;</>
       <literal>&lt;@</>
       <literal>&lt;^</>
       <literal>&gt;&gt;</>
       <literal>&gt;^</>
       <literal>~=</>
      </entry>
     </row>
     <row>
      <entry><literal>quad_point_ops</></entry>
      <entry><type>point</></entry>
      <entry>
       <literal>&lt;&lt;</>
       <literal>&lt;@</>
       <literal>&lt;^</>
       <literal>&gt;&gt;</>
       <literal>&gt;^</>
       <literal>~=</>
      </entry>
     </row>
     <row>
      <entry><literal>range_ops</></entry>
<!-- 
      <entry>any range type</entry> 
-->
      <entry>任意范围类型</entry>
      <entry>
       <literal>&amp;&amp;</>
       <literal>&amp;&lt;</>
       <literal>&amp;&gt;</>
       <literal>-|-</>
       <literal>&lt;&lt;</>
       <literal>&lt;@</>
       <literal>=</>
       <literal>&gt;&gt;</>
       <literal>@&gt;</>
      </entry>
     </row>
     <row>
      <entry><literal>text_ops</></entry>
      <entry><type>text</></entry>
      <entry>
       <literal>&lt;</>
       <literal>&lt;=</>
       <literal>=</>
       <literal>&gt;</>
       <literal>&gt;=</>
       <literal>~&lt;=~</>
       <literal>~&lt;~</>
       <literal>~&gt;=~</>
       <literal>~&gt;~</>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!-- 
 <para>
  Of the two operator classes for type <type>point</>,
  <literal>quad_point_ops</> is the default.  <literal>kd_point_ops</>
  supports the same operators but uses a different index data structure which
  may offer better performance in some applications.
 </para> 
-->
 <para>
  类型<type>point</>的两个操作符类，<literal>quad_point_ops</>是缺省。
  <literal>kd_point_ops</>支持相同的操作符，但是使用不同的索引数据结构，
  这在一些应用中可能会提供更好的性能。
 </para>

</sect1>

<sect1 id="spgist-extensibility">
<!--
 <title>Extensibility</title>
-->
 <title>扩展性</title>

 <para>
<!--
  <acronym>SP-GiST</acronym> offers an interface with a high level of
  abstraction, requiring the access method developer to implement only
  methods specific to a given data type. The <acronym>SP-GiST</acronym> core
  is responsible for efficient disk mapping and searching the tree structure.
  It also takes care of concurrency and logging considerations.
-->
<acronym>SP-GiST</acronym>提供了一个高度抽象的接口,只需要访问方法开发人员实现特定于给定数据类型的方法。<acronym>SP-GiST</acronym>核心负责高效的磁盘映射和搜索树结构。它还负责考虑并发性和日志记录。
 </para>

 <para>
<!--
  Leaf tuples of an <acronym>SP-GiST</acronym> tree contain values of the
  same data type as the indexed column.  Leaf tuples at the root level will
  always contain the original indexed data value, but leaf tuples at lower
  levels might contain only a compressed representation, such as a suffix.
  In that case the operator class support functions must be able to
  reconstruct the original value using information accumulated from the
  inner tuples that are passed through to reach the leaf level.
-->
<acronym>SP-GiST</acronym>树的叶元组包含和被索引列相同数据类型的值。
在根层级的叶元组总是包含原来的索引数据值,但是低层级的叶元组可能只包含一个压缩表示,如一个后缀。
在这种情况下,操作符类支持函数必须能够，通过利用从到达叶元组所经过的内部元组中收集到的信息，重建原始值。

 </para>

 <para>
<!--
  Inner tuples are more complex, since they are branching points in the
  search tree.  Each inner tuple contains a set of one or more
  <firstterm>nodes</>, which represent groups of similar leaf values.
  A node contains a downlink that leads to either another, lower-level inner
  tuple, or a short list of leaf tuples that all lie on the same index page.
  Each node has a <firstterm>label</> that describes it; for example,
  in a radix tree the node label could be the next character of the string
  value.  Optionally, an inner tuple can have a <firstterm>prefix</> value
  that describes all its members.  In a radix tree this could be the common
  prefix of the represented strings.  The prefix value is not necessarily
  really a prefix, but can be any data needed by the operator class;
  for example, in a quad-tree it can store the central point that the four
  quadrants are measured with respect to.  A quad-tree inner tuple would
  then also contain four nodes corresponding to the quadrants around this
  central point.
-->
内部元组更为复杂,因为它们是搜索树中的分支点。
每个内部元组包含由一个或多个<firstterm>节点</>组成的集合,表示一组类似的叶元组值。
一个节点包含一个链接指向另一个低级内部元组,或指向一个短的叶元组的列表，这些叶元组存储在相同的索引页面中。
每个节点都有一个用来描述它的<firstterm>标签</>。例如,在一个基数树中节点标签可以是字符串值的下一个字符。
可选地,一个内部元组可以有一个<firstterm>前缀</>值,描述了它的所有成员。
在基数树中这可能是其所代表的字符串的共同前缀。
前缀值不一定真的是一个前缀,可以是操作符类所要求的任何数据。
例如,在四叉树中它可以存储可度量四个象限的中心点，四叉树的内部元组也就会相应的存储四个节点，每个代表了这个中心点周围的一个象限。
 </para>

 <para>
<!--
  Some tree algorithms require knowledge of level (or depth) of the current
  tuple, so the <acronym>SP-GiST</acronym> core provides the possibility for
  operator classes to manage level counting while descending the tree.
  There is also support for incrementally reconstructing the represented
  value when that is needed.
-->
一些树算法需要知道当前元组的层级(或深度),所以<acronym>SP-GiST</acronym>核心为操作符类提供了在向下访问树时管理层级计数的能力。
并且也支持在需要时递增地重建所代表的值。

 </para>

 <note>
  <para>
<!--
   The <acronym>SP-GiST</acronym> core code takes care of null entries.
   Although <acronym>SP-GiST</acronym> indexes do store entries for nulls
   in indexed columns, this is hidden from the index operator class code:
   no null index entries or search conditions will ever be passed to the
   operator class methods.  (It is assumed that <acronym>SP-GiST</acronym>
   operators are strict and so cannot succeed for null values.)  Null values
   are therefore not discussed further here.
-->
<acronym>SP-GiST</acronym>核心代码考虑了null条目。
尽管<acronym>SP-GiST</acronym>索引为被索引列中的null值存储了的条目,但这对索引操作符类代码是隐藏的:null索引条目或搜索条件不会被传递给操作符类的方法。
(假定<acronym>SP-GiST</acronym>操作符是严格的,因此不能在null值上匹配成功。)因此后面也就不会再讨论null值的问题了。
  </para>
 </note>

 <para>
<!--
  There are five user-defined methods that an index operator class for
  <acronym>SP-GiST</acronym> must provide.  All five follow the convention
  of accepting two <type>internal</> arguments, the first of which is a
  pointer to a C struct containing input values for the support method,
  while the second argument is a pointer to a C struct where output values
  must be placed.  Four of the methods just return <type>void</>, since
  all their results appear in the output struct; but
  <function>leaf_consistent</> additionally returns a <type>boolean</> result.
  The methods must not modify any fields of their input structs.  In all
  cases, the output struct is initialized to zeroes before calling the
  user-defined method.
-->
一个用于<acronym>SP-GiST</acronym>的索引操作符类必须提供五个用户定义的方法。
所有五个方法按照约定接受两个<type>internal</>参数，第一个参数是一个指向包含了支持方法的输入值的C结构体的指针，而第二个参数是一个指向放置输出值的C结构体的指针。其中四个方法只是返回void,因为它们所有的结果都出现在输出结构体里;但<function>leaf_consistent</>返回一个布尔结果。这些方法不能修改输入结构体中的任何域。在所有情况下，在调用用户定义的方法之前，输出结构体的内容被用初始化为0。
 </para>

 <para>
<!--
  The five user-defined methods are:
-->
五个用户定义的方法如下：
 </para>

 <variablelist>
    <varlistentry>
     <term><function>config</></term>
     <listitem>
      <para>
<!--
       Returns static information about the index implementation, including
       the data type OIDs of the prefix and node label data types.
-->
返回关于索引实现的静态信息,包括前缀的数据类型OID和节点标签的数据类型。
      </para>
     <para>
<!--
      The <acronym>SQL</> declaration of the function must look like this:
-->
函数的<acronym>SQL</>声明必须看起来像这样:
<programlisting>
CREATE FUNCTION my_config(internal, internal) RETURNS void ...
</programlisting>
<!--
      The first argument is a pointer to a <structname>spgConfigIn</>
      C struct, containing input data for the function.
      The second argument is a pointer to a <structname>spgConfigOut</>
      C struct, which the function must fill with result data.
-->
第一个参数是一个指向C结构体<structname>spgConfigIn</>的指针,包含函数的输入数据。
第二个参数是一个指向C结构体<structname>spgConfigOut</>的指针,该函数必须填充结果数据到里面。

<programlisting>
typedef struct spgConfigIn
{
    Oid         attType;        /* Data type to be indexed */
} spgConfigIn;

typedef struct spgConfigOut
{
    Oid         prefixType;     /* Data type of inner-tuple prefixes */
    Oid         labelType;      /* Data type of inner-tuple node labels */
    bool        canReturnData;  /* Opclass can reconstruct original data */
    bool        longValuesOK;   /* Opclass can cope with values &gt; 1 page */
} spgConfigOut;
</programlisting>

<!--
      <structfield>attType</> is passed in order to support polymorphic
      index operator classes; for ordinary fixed-data-type operator classes, it
      will always have the same value and so can be ignored.
-->
传递<structfield>attType</>是为了支持多态索引操作符类。
对普通固定数据类型操作符类,它将总是有相同的值,因此可以忽略。
     </para>

     <para>
<!--
      For operator classes that do not use prefixes,
      <structfield>prefixType</> can be set to <literal>VOIDOID</>.
      Likewise, for operator classes that do not use node labels,
      <structfield>labelType</> can be set to <literal>VOIDOID</>.
      <structfield>canReturnData</> should be set true if the operator class
      is capable of reconstructing the originally-supplied index value.
      <structfield>longValuesOK</> should be set true only when the
      <structfield>attType</> is of variable length and the operator
      class is capable of segmenting long values by repeated suffixing
      (see <xref linkend="spgist-limits">).
-->
对于不使用前缀的操作符类,<structfield>prefixType</>可以被设置成<literal>VOIDOID</>。
同样,对不使用节点标签的操作符类，<structfield>labelType</>可以被设置成<literal>VOIDOID</>。
如果操作符类能够重建最初提供的索引值，<structfield>canReturnData</>应设置为true。
只有当<structfield>attType</>是可变长类型并且操作符类能够通过反复的添加后缀分割很长的值的时候，<structfield>longValuesOK</>才应该被设置为true(参见<xref linkend="spgist-limits">)。

     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>choose</></term>
     <listitem>
      <para>
<!--
        Chooses a method for inserting a new value into an inner tuple.
-->
选择一种方法将一个新值插入到一个内部元组。
      </para>

     <para>
<!--
      The <acronym>SQL</> declaration of the function must look like this:
-->
函数的<acronym>SQL</>声明必须看起来像这样:
<programlisting>
CREATE FUNCTION my_choose(internal, internal) RETURNS void ...
</programlisting>
<!--
      The first argument is a pointer to a <structname>spgChooseIn</>
      C struct, containing input data for the function.
      The second argument is a pointer to a <structname>spgChooseOut</>
      C struct, which the function must fill with result data.
-->
第一个参数是一个指向C结构体<structname>spgChooseIn</>的指针,包含函数的输入数据。
第二个参数是一个指向C结构体<structname>spgChooseOut</>的指针,该函数必须填充结果数据到里面。
<programlisting>
typedef struct spgChooseIn
{
    Datum       datum;          /* original datum to be indexed */
    Datum       leafDatum;      /* current datum to be stored at leaf */
    int         level;          /* current level (counting from zero) */

    /* Data from current inner tuple */
    bool        allTheSame;     /* tuple is marked all-the-same? */
    bool        hasPrefix;      /* tuple has a prefix? */
    Datum       prefixDatum;    /* if so, the prefix value */
    int         nNodes;         /* number of nodes in the inner tuple */
    Datum      *nodeLabels;     /* node label values (NULL if none) */
} spgChooseIn;

typedef enum spgChooseResultType
{
    spgMatchNode = 1,           /* descend into existing node */
    spgAddNode,                 /* add a node to the inner tuple */
    spgSplitTuple               /* split inner tuple (change its prefix) */
} spgChooseResultType;

typedef struct spgChooseOut
{
    spgChooseResultType resultType;     /* action code, see above */
    union
    {
        struct                  /* results for spgMatchNode */
        {
            int         nodeN;      /* descend to this node (index from 0) */
            int         levelAdd;   /* increment level by this much */
            Datum       restDatum;  /* new leaf datum */
        }           matchNode;
        struct                  /* results for spgAddNode */
        {
            Datum       nodeLabel;  /* new node's label */
            int         nodeN;      /* where to insert it (index from 0) */
        }           addNode;
        struct                  /* results for spgSplitTuple */
        {
            /* Info to form new inner tuple with one node */
            bool        prefixHasPrefix;    /* tuple should have a prefix? */
            Datum       prefixPrefixDatum;  /* if so, its value */
            Datum       nodeLabel;          /* node's label */

            /* Info to form new lower-level inner tuple with all old nodes */
            bool        postfixHasPrefix;   /* tuple should have a prefix? */
            Datum       postfixPrefixDatum; /* if so, its value */
        }           splitTuple;
    }           result;
} spgChooseOut;
</programlisting>

<!--
       <structfield>datum</> is the original datum that was to be inserted
       into the index.
       <structfield>leafDatum</> is initially the same as
       <structfield>datum</>, but can change at lower levels of the tree
       if the <function>choose</function> or <function>picksplit</function>
       methods change it.  When the insertion search reaches a leaf page,
       the current value of <structfield>leafDatum</> is what will be stored
       in the newly created leaf tuple.
       <structfield>level</> is the current inner tuple's level, starting at
       zero for the root level.
       <structfield>allTheSame</> is true if the current inner tuple is
       marked as containing multiple equivalent nodes
       (see <xref linkend="spgist-all-the-same">).
       <structfield>hasPrefix</> is true if the current inner tuple contains
       a prefix; if so,
       <structfield>prefixDatum</> is its value.
       <structfield>nNodes</> is the number of child nodes contained in the
       inner tuple, and
       <structfield>nodeLabels</> is an array of their label values, or
       NULL if there are no labels.
-->
<structfield>datum</>是被插入到索引的原始数据。
<structfield>leafDatum</>最初和<structfield>datum</>是一样的，如果函数<function>choose</function>或者<function>picksplit</function>把它修改了，在树的低层级可能会不同。
当插入搜索到达叶页面，当前的<structfield>leafDatum</>值就是存储到新生成的叶元组中的值。
<structfield>level</>是当前内部元组的层级，从0，也就是根的层级，开始计数。
如果当前内部元组包含多个等价节点，<structfield>allTheSame</>为true(参见<xref linkend="spgist-all-the-same">)。
如果当前内部元组包含前缀，<structfield>hasPrefix</>为true。
此时，<structfield>prefixDatum</>是前缀值。
<structfield>nNodes</>是内部元组中包含子节点的数量，<structfield>nodeLabels</>是它们的标签值的数组,或者是NULL如果没有标签的话。
      </para>

      <para>
<!--
       The <function>choose</function> function can determine either that
       the new value matches one of the existing child nodes, or that a new
       child node must be added, or that the new value is inconsistent with
       the tuple prefix and so the inner tuple must be split to create a
       less restrictive prefix.
-->
<function>choose</function>函数可以确定新值匹配一个现有的子节点,或者必须添加一个新的子节点,或者新值与元组前缀不一致,所以内部元组必须分裂开以创建一个限制较少的前缀。
      </para>

      <para>
<!--
       If the new value matches one of the existing child nodes,
       set <structfield>resultType</> to <literal>spgMatchNode</>.
       Set <structfield>nodeN</> to the index (from zero) of that node in
       the node array.
       Set <structfield>levelAdd</> to the increment in
       <structfield>level</> caused by descending through that node,
       or leave it as zero if the operator class does not use levels.
       Set <structfield>restDatum</> to equal <structfield>datum</>
       if the operator class does not modify datums from one level to the
       next, or otherwise set it to the modified value to be used as
       <structfield>leafDatum</> at the next level.
-->
如果新值匹配的一个现有的子节点,把<structfield>resultType</>设置为<literal>spgMatchNode</>。
把<structfield>nodeN</>设置为那个索引节点在节点数组中的索引(从0开始)。
把<structfield>levelAdd</>设置为，由下降到那个节点导致的<structfield>level</>增量；
或者为0如果操作符类不使用层级。
把<structfield>restDatum</>设置为和<structfield>datum</>相等的值，如果操作符类从一个层级到下一个层级不会修改数据值；否则将其设置为修改后的值，它在下一个层级被用作<structfield>leafDatum</>。
      </para>

      <para>
<!--
       If a new child node must be added,
       set <structfield>resultType</> to <literal>spgAddNode</>.
       Set <structfield>nodeLabel</> to the label to be used for the new
       node, and set <structfield>nodeN</> to the index (from zero) at which
       to insert the node in the node array.
       After the node has been added, the <function>choose</function>
       function will be called again with the modified inner tuple;
       that call should result in an <literal>spgMatchNode</> result.
-->
如果必须添加一个新的子节点,把<structfield>resultType</>设置为<literal>spgAddNode</>。
设置<structfield>nodeLabel</>为新节点的标签,并设置<structfield>nodeN</>为插入位置在节点数组中的索引(从0开始)。
添加了节点后,<function>choose</function>函数将再次与被修改的内部元组一起被调用，那次调用应该导致一个<literal>spgMatchNode</>结果。
      </para>

      <para>
<!--
       If the new value is inconsistent with the tuple prefix,
       set <structfield>resultType</> to <literal>spgSplitTuple</>.
       This action moves all the existing nodes into a new lower-level
       inner tuple, and replaces the existing inner tuple with a tuple
       having a single node that links to the new lower-level inner tuple.
       Set <structfield>prefixHasPrefix</> to indicate whether the new
       upper tuple should have a prefix, and if so set
       <structfield>prefixPrefixDatum</> to the prefix value.  This new
       prefix value must be sufficiently less restrictive than the original
       to accept the new value to be indexed, and it should be no longer
       than the original prefix.
       Set <structfield>nodeLabel</> to the label to be used for the
       node that will point to the new lower-level inner tuple.
       Set <structfield>postfixHasPrefix</> to indicate whether the new
       lower-level inner tuple should have a prefix, and if so set
       <structfield>postfixPrefixDatum</> to the prefix value.  The
       combination of these two prefixes and the additional label must
       have the same meaning as the original prefix, because there is
       no opportunity to alter the node labels that are moved to the new
       lower-level tuple, nor to change any child index entries.
       After the node has been split, the <function>choose</function>
       function will be called again with the replacement inner tuple.
       That call will usually result in an <literal>spgAddNode</> result,
       since presumably the node label added in the split step will not
       match the new value; so after that, there will be a third call
       that finally returns <literal>spgMatchNode</> and allows the
       insertion to descend to the leaf level.
-->
如果新值与元组前缀是不一致的,把<structfield>resultType</>设置为<literal>spgSplitTuple</>。
这一动作把所有现有的节点移动到一个新的低层级的内部元组,并把现有内部元组替换为一个只有一个链接到新的低层级内部元组的单个节点的元组。
设定<structfield>prefixHasPrefix</>表明是否新的较高的元组应该有一个前缀,如果是的话，设置<structfield>prefixPrefixDatum</>为前缀值。
这个新的前缀值必须比原来的限制足够小以接受新的被索引值,而且应当不超过原前缀的长度。
设置<structfield>nodeLabel</>为指向新的低层级内部元组的节点的标签值。
设定<structfield>postfixHasPrefix</>表明是否新的较低的元组应该有一个前缀,如果是的话，设置<structfield>postfixPrefixDatum</>为前缀值。
这两个前缀和额外的标签的组合必须与原始前缀具有相同的含义,因为没有机会改变被移动到新的低层级元组中的节点标签，也不能改变任何子索引条目。
节点被分裂后,<function>choose</function>会被再次调用，针对替换的内部元组。那个调用通常会导致<literal>spgAddNode</>结果,因为分裂步骤添加的节点标签可能不会匹配新值；所以在那之后,还会有第三次调用,最后的调用返回<literal>spgMatchNode</>,允许插入操作下去到叶层级。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>picksplit</></term>
     <listitem>
      <para>
<!--
       Decides how to create a new inner tuple over a set of leaf tuples.
-->
决定如何在一组叶元组之上创建一个新的内部元组。
      </para>

      <para>
<!--
        The <acronym>SQL</> declaration of the function must look like this:
-->
函数的<acronym>SQL</>声明必须看起来像这样:
<programlisting>
CREATE FUNCTION my_picksplit(internal, internal) RETURNS void ...
</programlisting>
<!--
      The first argument is a pointer to a <structname>spgPickSplitIn</>
      C struct, containing input data for the function.
      The second argument is a pointer to a <structname>spgPickSplitOut</>
      C struct, which the function must fill with result data.
-->
第一个参数是一个指向C结构体<structname>spgPickSplitIn</>的指针,包含函数的输入数据。
第二个参数是一个指向C结构体<structname>spgPickSplitOut</>的指针,该函数必须填充结果数据到里面。
<programlisting>
typedef struct spgPickSplitIn
{
    int         nTuples;        /* number of leaf tuples */
    Datum      *datums;         /* their datums (array of length nTuples) */
    int         level;          /* current level (counting from zero) */
} spgPickSplitIn;

typedef struct spgPickSplitOut
{
    bool        hasPrefix;      /* new inner tuple should have a prefix? */
    Datum       prefixDatum;    /* if so, its value */

    int         nNodes;         /* number of nodes for new inner tuple */
    Datum      *nodeLabels;     /* their labels (or NULL for no labels) */

    int        *mapTuplesToNodes;   /* node index for each leaf tuple */
    Datum      *leafTupleDatums;    /* datum to store in each new leaf tuple */
} spgPickSplitOut;
</programlisting>

<!--
       <structfield>nTuples</> is the number of leaf tuples provided.
       <structfield>datums</> is an array of their datum values.
       <structfield>level</> is the current level that all the leaf tuples
       share, which will become the level of the new inner tuple.
-->
<structfield>nTuples</>是提供的叶元组的数量。
<structfield>datums</>是数据值的数组。
<structfield>level</>是所有的叶元组共享的当前层级,这将成为新的内部元组的层级。
      </para>

      <para>
<!--
       Set <structfield>hasPrefix</> to indicate whether the new inner
       tuple should have a prefix, and if so set
       <structfield>prefixDatum</> to the prefix value.
       Set <structfield>nNodes</> to indicate the number of nodes that
       the new inner tuple will contain, and
       set <structfield>nodeLabels</> to an array of their label values.
       (If the nodes do not require labels, set <structfield>nodeLabels</>
       to NULL; see <xref linkend="spgist-null-labels"> for details.)
       Set <structfield>mapTuplesToNodes</> to an array that gives the index
       (from zero) of the node that each leaf tuple should be assigned to.
       Set <structfield>leafTupleDatums</> to an array of the values to
       be stored in the new leaf tuples (these will be the same as the
       input <structfield>datums</> if the operator class does not modify
       datums from one level to the next).
       Note that the <function>picksplit</> function is
       responsible for palloc'ing the
       <structfield>nodeLabels</>, <structfield>mapTuplesToNodes</> and
       <structfield>leafTupleDatums</> arrays.
-->
<structfield>hasPrefix</>表明是否新的内部元组应该有一个前缀,如果是的话设置prefixDatum前缀值。
<structfield>nNodes</>表明新内部元组将包含的节点数量,并设置<structfield>nodeLabels</>为它们的标签值的数组。
(如果节点不需要标签,设置<structfield>nodeLabels</>为NULL;有关详细信息,请参见<xref linkend="spgist-null-labels">。)
设置<structfield>mapTuplesToNodes</>为各个叶元组应该被分配的节点的索引(从0开始)的数组。
设置<structfield>leafTupleDatums</>为存储在新的叶元组的值的数组(如果操作符类从一个层级到下一个层级不修改数据,它们将和输入数据相同)。
注意,<function>picksplit</>函数负责分配(palloc) <structfield>nodeLabels</>, <structfield>mapTuplesToNodes</>和<structfield>leafTupleDatums</>数组。 
      </para>

      <para>
<!--
       If more than one leaf tuple is supplied, it is expected that the
       <function>picksplit</> function will classify them into more than
       one node; otherwise it is not possible to split the leaf tuples
       across multiple pages, which is the ultimate purpose of this
       operation.  Therefore, if the <function>picksplit</> function
       ends up placing all the leaf tuples in the same node, the core
       SP-GiST code will override that decision and generate an inner
       tuple in which the leaf tuples are assigned at random to several
       identically-labeled nodes.  Such a tuple is marked
       <literal>allTheSame</> to signify that this has happened.  The
       <function>choose</> and <function>inner_consistent</> functions
       must take suitable care with such inner tuples.
       See <xref linkend="spgist-all-the-same"> for more information.
-->
如果提供了不止一个叶元组,预计<function>picksplit</>函数会把它们分类到多个节点,否则不可能把叶元组分裂到多个页面,这是这个操作的最终目的。
因此,如果<function>picksplit</>函数最终把所有叶元组放在同一节点,核心SP-GiST代码将覆盖这一决定并生成一个内部元组，这些叶元组会被随机分配到这个内部元组的几个有等价标签(identically-labeled)的节点上。
这样的元组被设置了<literal>allTheSame</>标志，以表示发生这样的事情了。
<function>choose</>和<function>inner_consistent</>函数必须小心对待这样的内部元组。
有关更多信息,请参见<xref linkend="spgist-all-the-same">。
      </para>

      <para>
<!--
       <function>picksplit</> can be applied to a single leaf tuple only
       in the case that the <function>config</> function set
       <structfield>longValuesOK</> to true and a larger-than-a-page input
       value has been supplied.  In this case the point of the operation is
       to strip off a prefix and produce a new, shorter leaf datum value.
       The call will be repeated until a leaf datum short enough to fit on
       a page has been produced.  See <xref linkend="spgist-limits"> for
       more information.
-->
只有当<function>config</>函数设置<structfield>longValuesOK</>为true,并且提供了大于一页面的输入值时，
<function>picksplit</>才可以被应用到单个叶元组。
在这种情况下操作的要点是剥离前缀并产生一个新的、更短的叶数据值。
这个调用将被反复执行，直到叶数据已经短到可以放到一个被生成的页面上。
有关更多信息,请参见<xref linkend="spgist-limits">。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>inner_consistent</></term>
     <listitem>
      <para>
<!--
       Returns set of nodes (branches) to follow during tree search.
-->
返回树搜索需要继续访问的节点集合(分支)。
      </para>

      <para>
<!--
       The <acronym>SQL</> declaration of the function must look like this:
-->
函数的<acronym>SQL</>声明必须看起来像这样:
<programlisting>
CREATE FUNCTION my_inner_consistent(internal, internal) RETURNS void ...
</programlisting>
<!--
      The first argument is a pointer to a <structname>spgInnerConsistentIn</>
      C struct, containing input data for the function.
      The second argument is a pointer to a <structname>spgInnerConsistentOut</>
      C struct, which the function must fill with result data.
-->
第一个参数是一个指向C结构体<structname>spgInnerConsistentIn</>的指针,包含函数的输入数据。
第二个参数是一个指向C结构体<structname>spgInnerConsistentOut</>的指针,该函数必须填充结果数据到里面。

<programlisting>
typedef struct spgInnerConsistentIn
{
    ScanKey     scankeys;       /* array of operators and comparison values */
    int         nkeys;          /* length of array */

    Datum       reconstructedValue;     /* value reconstructed at parent */
    int         level;          /* current level (counting from zero) */
    bool        returnData;     /* original data must be returned? */

    /* Data from current inner tuple */
    bool        allTheSame;     /* tuple is marked all-the-same? */
    bool        hasPrefix;      /* tuple has a prefix? */
    Datum       prefixDatum;    /* if so, the prefix value */
    int         nNodes;         /* number of nodes in the inner tuple */
    Datum      *nodeLabels;     /* node label values (NULL if none) */
} spgInnerConsistentIn;

typedef struct spgInnerConsistentOut
{
    int         nNodes;         /* number of child nodes to be visited */
    int        *nodeNumbers;    /* their indexes in the node array */
    int        *levelAdds;      /* increment level by this much for each */
    Datum      *reconstructedValues;    /* associated reconstructed values */
} spgInnerConsistentOut;
</programlisting>

<!--
       The array <structfield>scankeys</>, of length <structfield>nkeys</>,
       describes the index search condition(s).  These conditions are
       combined with AND &mdash; only index entries that satisfy all of
       them are interesting.  (Note that <structfield>nkeys</> = 0 implies
       that all index entries satisfy the query.)  Usually the consistent
       function only cares about the <structfield>sk_strategy</> and
       <structfield>sk_argument</> fields of each array entry, which
       respectively give the indexable operator and comparison value.
       In particular it is not necessary to check <structfield>sk_flags</> to
       see if the comparison value is NULL, because the SP-GiST core code
       will filter out such conditions.
       <structfield>reconstructedValue</> is the value reconstructed for the
       parent tuple; it is <literal>(Datum) 0</> at the root level or if the
       <function>inner_consistent</> function did not provide a value at the
       parent level.
       <structfield>level</> is the current inner tuple's level, starting at
       zero for the root level.
       <structfield>returnData</> is <literal>true</> if reconstructed data is
       required for this query; this will only be so if the
       <function>config</> function asserted <structfield>canReturnData</>.
       <structfield>allTheSame</> is true if the current inner tuple is
       marked <quote>all-the-same</>; in this case all the nodes have the
       same label (if any) and so either all or none of them match the query
       (see <xref linkend="spgist-all-the-same">).
       <structfield>hasPrefix</> is true if the current inner tuple contains
       a prefix; if so,
       <structfield>prefixDatum</> is its value.
       <structfield>nNodes</> is the number of child nodes contained in the
       inner tuple, and
       <structfield>nodeLabels</> is an array of their label values, or
       NULL if the nodes do not have labels.
-->
长度为<structfield>nkeys</>的<structfield>scankeys</>数组描述了索引搜索条件。
这些条件以"AND"联接在一起，即，只有满足所有条件的索引条目才能匹配这个查询。
(注意,如果<structfield>nkeys</>为0意味着所有索引条目都满足查询。)
通常这个函数只关心每个数组项目的<structfield>sk_strategy</>和<structfield>sk_argument</>字段,它们分别给出了可索引的操作符和比较值。
特别是没有必要看<structfield>sk_flags</>以检查比较值是否为NULL,因为SP-GiST核心代码会过滤掉这样的条件。
<structfield>reconstructedValue</>是为父元组重建的值；如果在根层级或<function>inner_consistent</>函数在父层级没有提供一个值，它会是0。
<structfield>level</>是当前内部元组的层级，从0，也就是根的层级，开始计数。
<structfield>returnData</>为<literal>true</>，如果这个查询需要重建数据的话；只有<function>config</>函数声明了<structfield>canReturnData</>时，才有可能是这样。
<structfield>allTheSame</>是true，如果当前内部元组标记<quote>all-the-same</>;在这种情况下的所有节点具有相同的标签(如果有的话),所以要么全部要么没有一个匹配这个查询(参见<xref linkend="spgist-all-the-same">)。
如果当前内部元组包含前缀，<structfield>hasPrefix</>为true。
此时，<structfield>prefixDatum</>是前缀值。
<structfield>nNodes</>是内部元组中包含子节点的数量，<structfield>nodeLabels</>是它们的标签值的数组,或者是NULL如果节点没有标签。
      </para>

      <para>
<!--
       <structfield>nNodes</> must be set to the number of child nodes that
       need to be visited by the search, and
       <structfield>nodeNumbers</> must be set to an array of their indexes.
       If the operator class keeps track of levels, set
       <structfield>levelAdds</> to an array of the level increments
       required when descending to each node to be visited.  (Often these
       increments will be the same for all the nodes, but that's not
       necessarily so, so an array is used.)
       If value reconstruction is needed, set
       <structfield>reconstructedValues</> to an array of the values
       reconstructed for each child node to be visited; otherwise, leave
       <structfield>reconstructedValues</> as NULL.
       Note that the <function>inner_consistent</> function is
       responsible for palloc'ing the
       <structfield>nodeNumbers</>, <structfield>levelAdds</> and
       <structfield>reconstructedValues</> arrays.
-->
<structfield>nNodes</>必须被设置为搜索需要访问的子节点的数量,
并且<structfield>nodeNumbers</>必须被设置的它们的索引的数组。
如果操作符类跟踪层级,设置<structfield>levelAdds</>为向下访问到每个节点时层级增量的数组。
(通常这些增量对所有节点是相同的,但这并不一定是这样,所以使用一个数组)。
如果需要重建数据值,设置<structfield>reconstructedValues</>为每个要访问的子节点的重建值的数组;否则,保持<structfield>reconstructedValues</>为NULL。
注意,<function>inner_consistent</>函数负责分配(palloc) <structfield>nodeNumbers</>, <structfield>levelAdds</>和<structfield>reconstructedValues</>数组。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>leaf_consistent</></term>
     <listitem>
      <para>
<!--
       Returns true if a leaf tuple satisfies a query.
-->
如果叶元组满足查询返回true。
      </para>

      <para>
<!--
       The <acronym>SQL</> declaration of the function must look like this:
-->
函数的<acronym>SQL</>声明必须看起来像这样:
<programlisting>
CREATE FUNCTION my_leaf_consistent(internal, internal) RETURNS bool ...
</programlisting>
<!--
      The first argument is a pointer to a <structname>spgLeafConsistentIn</>
      C struct, containing input data for the function.
      The second argument is a pointer to a <structname>spgLeafConsistentOut</>
      C struct, which the function must fill with result data.
-->
第一个参数是一个指向C结构体<structname>spgLeafConsistentIn</>的指针,包含函数的输入数据。
第二个参数是一个指向C结构体<structname>spgLeafConsistentOut</>的指针,该函数必须填充结果数据到里面。
<programlisting>
typedef struct spgLeafConsistentIn
{
    ScanKey     scankeys;       /* array of operators and comparison values */
    int         nkeys;          /* length of array */

    Datum       reconstructedValue;     /* value reconstructed at parent */
    int         level;          /* current level (counting from zero) */
    bool        returnData;     /* original data must be returned? */

    Datum       leafDatum;      /* datum in leaf tuple */
} spgLeafConsistentIn;

typedef struct spgLeafConsistentOut
{
    Datum       leafValue;      /* reconstructed original data, if any */
    bool        recheck;        /* set true if operator must be rechecked */
} spgLeafConsistentOut;
</programlisting>

<!--
       The array <structfield>scankeys</>, of length <structfield>nkeys</>,
       describes the index search condition(s).  These conditions are
       combined with AND &mdash; only index entries that satisfy all of
       them satisfy the query.  (Note that <structfield>nkeys</> = 0 implies
       that all index entries satisfy the query.)  Usually the consistent
       function only cares about the <structfield>sk_strategy</> and
       <structfield>sk_argument</> fields of each array entry, which
       respectively give the indexable operator and comparison value.
       In particular it is not necessary to check <structfield>sk_flags</> to
       see if the comparison value is NULL, because the SP-GiST core code
       will filter out such conditions.
       <structfield>reconstructedValue</> is the value reconstructed for the
       parent tuple; it is <literal>(Datum) 0</> at the root level or if the
       <function>inner_consistent</> function did not provide a value at the
       parent level.
       <structfield>level</> is the current leaf tuple's level, starting at
       zero for the root level.
       <structfield>returnData</> is <literal>true</> if reconstructed data is
       required for this query; this will only be so if the
       <function>config</> function asserted <structfield>canReturnData</>.
       <structfield>leafDatum</> is the key value stored in the current
       leaf tuple.
-->
长度为<structfield>nkeys</>的<structfield>scankeys</>数组描述了索引搜索条件。
这些条件以"AND"联接在一起，即，只有满足所有条件的索引条目才能匹配这个查询。
(注意,如果<structfield>nkeys</>为0意味着所有索引条目都满足查询。)
通常这个函数只关心每个数组项目的<structfield>sk_strategy</>和<structfield>sk_argument</>字段,它们分别给出了可索引的操作符和比较值。
特别是没有必要看<structfield>sk_flags</>以检查比较值是否为NULL,因为SP-GiST核心代码会过滤掉这样的条件。
<structfield>reconstructedValue</>是父元组重建的值；如果在根层级或<function>inner_consistent</>函数在父层级没有提供一个值，它会是0。
<structfield>level</>是当前叶元组的层级，从0，也就是根的层级，开始计数。
<structfield>returnData</>为<literal>true</>，如果这个查询需要重建数据的话；只有<function>config</>函数声明了<structfield>canReturnData</>时，才有可能是这样。
<structfield>leafDatum</>是存储在当前叶元组中的键值。
      </para>

      <para>
<!--
       The function must return <literal>true</> if the leaf tuple matches the
       query, or <literal>false</> if not.  In the <literal>true</> case,
       if <structfield>returnData</> is <literal>true</> then
       <structfield>leafValue</> must be set to the value originally supplied
       to be indexed for this leaf tuple.  Also,
       <structfield>recheck</> may be set to <literal>true</> if the match
       is uncertain and so the operator(s) must be re-applied to the actual
       heap tuple to verify the match.
-->
如果这个叶元组匹配查询，这个函数必须返回<literal>true</>,否则返回<literal>false</>。
在<literal>true</>的情况下,如果<structfield>returnData</>是<literal>true</>，
那么<structfield>leafValue</>必须被设置为最初提供的这个叶元组索引的值。
如果匹配是不确定的,<structfield>recheck</>也被设置为<literal>true</>，因此操作符必须被重新应用到实际的堆元组上以验证匹配。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

  <para>
<!--
   All the SP-GiST support methods are normally called in a short-lived
   memory context; that is, <varname>CurrentMemoryContext</> will be reset
   after processing of each tuple.  It is therefore not very important to
   worry about pfree'ing everything you palloc.  (The <function>config</>
   method is an exception: it should try to avoid leaking memory.  But
   usually the <function>config</> method need do nothing but assign
   constants into the passed parameter struct.)
-->
所有SP-GiST支持方法通常在一个短期的内存上下文中被调用;也就是说,
在处理每一个元组后<varname>CurrentMemoryContext</>将被重置。
因此不太需要担心地去pfree你palloc出来的所有东西。 
（<function>config</>方法是一个例外:它应该尽量避免内存泄露。
但通常<function>config</>方法除了把常数赋值到传递过来的结构体中外，其它什么也不需要做。）
  </para>

  <para>
<!--
   If the indexed column is of a collatable data type, the index collation
   will be passed to all the support methods, using the standard
   <function>PG_GET_COLLATION()</> mechanism.
-->
如果被索引列是一个collatable数据类型,该索引排序规则将被传递给所有的支持方法,使用标准的<function>PG_GET_COLLATION()</> 机制。
  </para>

</sect1>

<sect1 id="spgist-implementation">
<!--
 <title>Implementation</title>
-->
 <title>实现</title>

  <para>
<!--
   This section covers implementation details and other tricks that are
   useful for implementers of <acronym>SP-GiST</acronym> operator classes to
   know.
-->
本节讨论实现细节和其他对<acronym>SP-GiST</acronym>操作符类的实现者有用的技巧。
  </para>

 <sect2 id="spgist-limits">
<!--
  <title>SP-GiST Limits</title>
-->
  <title>SP-GiST的限制</title>

  <para>
<!--
   Individual leaf tuples and inner tuples must fit on a single index page
   (8KB by default).  Therefore, when indexing values of variable-length
   data types, long values can only be supported by methods such as radix
   trees, in which each level of the tree includes a prefix that is short
   enough to fit on a page, and the final leaf level includes a suffix also
   short enough to fit on a page.  The operator class should set
   <structfield>longValuesOK</> to TRUE only if it is prepared to arrange for
   this to happen.  Otherwise, the <acronym>SP-GiST</acronym> core will
   reject any request to index a value that is too large to fit
   on an index page.
-->
单个的叶元组和内部元组必须容纳在一个索引页(默认8KB)里。
因此,当索引可变长数据类型的值时,长值只能被像基数树这样的方法支持,在树的每一层包含一个前缀,这个前缀足够短,可容纳在一个页面上,并且最后的叶子层级包括的后缀也足够短以容纳在一个页面上。
操作符类只有准备好了处理这样的事情，才应该设置<structfield>longValuesOK</>为TRUE。
否则,<acronym>SP-GiST</acronym>核心将拒绝一个太大以致不能装入一个页面的数据值的索引请求。
  </para>

  <para>
<!--
   Likewise, it is the operator class's responsibility that inner tuples
   do not grow too large to fit on an index page; this limits the number
   of child nodes that can be used in one inner tuple, as well as the
   maximum size of a prefix value.
-->
同样,不要让内部元组增长得过大以致不能容纳在一个索引页面,这也是操作符类的责任；这限制了在一个内部元组里可以使用的子节点的数量,以及一个前缀值的最大大小。
  </para>

  <para>
<!--
   Another limitation is that when an inner tuple's node points to a set
   of leaf tuples, those tuples must all be in the same index page.
   (This is a design decision to reduce seeking and save space in the
   links that chain such tuples together.)  If the set of leaf tuples
   grows too large for a page, a split is performed and an intermediate
   inner tuple is inserted.  For this to fix the problem, the new inner
   tuple <emphasis>must</> divide the set of leaf values into more than one
   node group.  If the operator class's <function>picksplit</> function
   fails to do that, the <acronym>SP-GiST</acronym> core resorts to
   extraordinary measures described in <xref linkend="spgist-all-the-same">.
-->
另一个限制是,当一个内部元组的节点指向一组叶元组,这些元组必须都在相同的索引页面上。
(这个设计决定是为了减少寻址以及节省把这些元组联接在一起的链接的空间)。
如果叶元组的集合增大到超过一个页面,就会执行分裂并插入一个中间的内部元组。
为了解决这个问题,新内部元组<emphasis>必须</>把叶子中的值的集合划分到多个节点组。
如果操作符类的<function>picksplit</>函数未能这样做,<acronym>SP-GiST</acronym>
将会采取<xref linkend="spgist-all-the-same">中描述的非常手段。
  </para>
 </sect2>

 <sect2 id="spgist-null-labels">
<!--
  <title>SP-GiST Without Node Labels</title>
-->
  <title>没有节点标签的SP-GiST</title>

  <para>
<!--
   Some tree algorithms use a fixed set of nodes for each inner tuple;
   for example, in a quad-tree there are always exactly four nodes
   corresponding to the four quadrants around the inner tuple's centroid
   point.  In such a case the code typically works with the nodes by
   number, and there is no need for explicit node labels.  To suppress
   node labels (and thereby save some space), the <function>picksplit</>
   function can return NULL for the <structfield>nodeLabels</> array.
   This will in turn result in <structfield>nodeLabels</> being NULL during
   subsequent calls to <function>choose</> and <function>inner_consistent</>.
   In principle, node labels could be used for some inner tuples and omitted
   for others in the same index.
-->
一些树算法在每个内部元组中使用固定数量的节点;
例如,在四叉树中总是正好的有4个节点，它们代表围绕内部元组的中心点的四个象限。
在这种情况下代码典型的通过数值和节点打交道,没有必要有显式的节点标签。
为了废止节点标签(从而节省一些空间),<function>picksplit</>函数可以为<structfield>nodeLabels</>数组返回NULL。
结果这将导致随后调用<function>choose</>和<function>inner_consistent</>函数时，<structfield>nodeLabels</>为NULL。
原则上,节点标签可用于一些内部元组，而在相同索引的其它元组上省略。
  </para>

  <para>
<!--
   When working with an inner tuple having unlabeled nodes, it is an error
   for <function>choose</> to return <literal>spgAddNode</>, since the set
   of nodes is supposed to be fixed in such cases.  Also, there is no
   provision for generating an unlabeled node in <literal>spgSplitTuple</>
   actions, since it is expected that an <literal>spgAddNode</> action will
   be needed as well.
-->
当使用一个包含无标签节点的内部元组时,<function>choose</>函数返回<literal>spgAddNode</>是错误的,
因为在这种情况下，节点的集合被假定为固定的。
同样也没有在<literal>spgSplitTuple</>动作中产生无标签节点的条款，因为预计将需要一个<literal>spgAddNode</>动作。

  </para>
 </sect2>

 <sect2 id="spgist-all-the-same">
<!--
  <title><quote>All-the-same</> Inner Tuples</title>
-->
  <title><quote>All-the-same</>内部元组</title>

  <para>
<!--
   The <acronym>SP-GiST</acronym> core can override the results of the
   operator class's <function>picksplit</> function when
   <function>picksplit</> fails to divide the supplied leaf values into
   at least two node categories.  When this happens, the new inner tuple
   is created with multiple nodes that each have the same label (if any)
   that <function>picksplit</> gave to the one node it did use, and the
   leaf values are divided at random among these equivalent nodes.
   The <literal>allTheSame</> flag is set on the inner tuple to warn the
   <function>choose</> and <function>inner_consistent</> functions that the
   tuple does not have the node set that they might otherwise expect.
-->
如果操作符类的<function>picksplit</>函数不能把提供的叶子值划分到至少两个分类中，
<acronym>SP-GiST</acronym>核心可以覆盖<function>picksplit</>函数的结果。
如果发生了这种事情,包含多个节点的新的内部元组会被创建。
每个节点的标签都和<function>picksplit</>给一个节点使用的标签相同(如果有的话),并且叶值被随机划分到这些等价节点中。
<literal>allTheSame</>标志会被设置到这个内部元组上，以警告<function>choose</> 和 <function>inner_consistent</>函数这个元组可能没有它们期望的节点集合。
  </para>

  <para>
<!--
   When dealing with an <literal>allTheSame</> tuple, a <function>choose</>
   result of <literal>spgMatchNode</> is interpreted to mean that the new
   value can be assigned to any of the equivalent nodes; the core code will
   ignore the supplied  <structfield>nodeN</> value and descend into one
   of the nodes at random (so as to keep the tree balanced).  It is an
   error for <function>choose</> to return <literal>spgAddNode</>, since
   that would make the nodes not all equivalent; the
   <literal>spgSplitTuple</> action must be used if the value to be inserted
   doesn't match the existing nodes.
-->
当处理一个<literal>allTheSame</>元组,<function>choose</>的结果<literal>spgMatchNode</>
被解释为新的值可以被分配到任何等价节点;核心代码将忽略提供的<structfield>nodeN</>值并随机的进入其中一个节点(以保持树的平衡)。
<function>choose</>返回<literal>spgAddNode</>是错误的，因为将使这些节点不再是所有都等价。
如果要插入的值不匹配现有的节点，必须使用<literal>spgSplitTuple</>动作。

  </para>

  <para>
<!--
   When dealing with an <literal>allTheSame</> tuple, the
   <function>inner_consistent</> function should return either all or none
   of the nodes as targets for continuing the index search, since they are
   all equivalent.  This may or may not require any special-case code,
   depending on how much the <function>inner_consistent</> function normally
   assumes about the meaning of the nodes.
-->
当处理一个<literal>allTheSame</>元组,<function>inner_consistent</>函数应该返回所有或没有一个节点作为继续索引搜索的目标,因为他们都是等价的。
这可能需要也可能不需要任何特殊的代码,这取决于<function>inner_consistent</>函数通常假设了多少节点的含义。
  </para>
 </sect2>

</sect1>

<sect1 id="spgist-examples">
<!--
 <title>Examples</title>
-->
 <title>示例</title>

 <para>
<!--
  The <productname>PostgreSQL</productname> source distribution includes
  several examples of index operator classes for
  <acronym>SP-GiST</acronym>.  The core system currently provides radix
  trees over text columns and two types of trees over points: quad-tree and
  k-d tree.  Look into <filename>src/backend/access/spgist/</> to see the
  code.
-->
<productname>PostgreSQL</productname>源码发布包括几个<acronym>SP-GiST</acronym>索引操作符类的例子。
目前核心系统提供了文本列上的基数树和点的两种树类型:四叉树和KD树。
如果要查看代码，可进入<filename>src/backend/access/spgist/</>。
 </para>

</sect1>

</chapter>
