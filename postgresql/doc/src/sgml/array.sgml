<!-- doc/src/sgml/array.sgml -->

<sect1 id="arrays">
<!--==========================orignal english content==========================
 <title>Arrays</title>
____________________________________________________________________________-->
 <title>数组</title>

<!--==========================orignal english content==========================
 <indexterm>
  <primary>array</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm>
  <primary>array</primary>
 </indexterm>

<!--==========================orignal english content==========================
 <para>
  <productname>PostgreSQL</productname> allows columns of a table to be
  defined as variable-length multidimensional arrays. Arrays of any
  built-in or user-defined base type, enum type, composite type, range type,
  or domain can be created.
 </para>
____________________________________________________________________________-->
 <para>
  <productname>PostgreSQL</productname>允许一个表中的列定义为变长多维数组。可以创建任何内建或用户定义的基类、枚举类型、组合类型或者域的数组。
 </para>

 <sect2 id="arrays-declaration">
<!--==========================orignal english content==========================
  <title>Declaration of Array Types</title>
____________________________________________________________________________-->
  <title>数组类型的定义</title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>array</primary>
   <secondary>declaration</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>array</primary>
   <secondary>declaration</secondary>
  </indexterm>

<!--==========================orignal english content==========================
 <para>
  To illustrate the use of array types, we create this table:
<programlisting>
CREATE TABLE sal_emp (
    name            text,
    pay_by_quarter  integer[],
    schedule        text[][]
);
</programlisting>
  As shown, an array data type is named by appending square brackets
  (<literal>[]</literal>) to the data type name of the array elements.  The
  above command will create a table named
  <structname>sal_emp</structname> with a column of type
  <type>text</type> (<structfield>name</structfield>), a
  one-dimensional array of type <type>integer</type>
  (<structfield>pay_by_quarter</structfield>), which represents the
  employee's salary by quarter, and a two-dimensional array of
  <type>text</type> (<structfield>schedule</structfield>), which
  represents the employee's weekly schedule.
 </para>
____________________________________________________________________________-->
 <para>
  为了展示数组类型的使用，我们创建这样一个表：
<programlisting>
CREATE TABLE sal_emp (
    name            text,
    pay_by_quarter  integer[],
    schedule        text[][]
);
</programlisting>
  如上所示，一个数组数据类型可以通过在数组元素的数据类型名称后面加上方括号（<literal>[]</literal>）来命名。上述命令将创建一个名为<structname>sal_emp</structname>的表，它有一个类型为<type>text</type>的列（<structfield>name</structfield>），一个表示雇员的季度工资的一维<type>integer</type>类型数组（<structfield>pay_by_quarter</structfield>），以及一个表示雇员每周日程表的二维<type>text</type>类型数组（<structfield>schedule</structfield>）。
 </para>

<!--==========================orignal english content==========================
 <para>
  The syntax for <command>CREATE TABLE</command> allows the exact size of
  arrays to be specified, for example:

<programlisting>
CREATE TABLE tictactoe (
    squares   integer[3][3]
);
</programlisting>

  However, the current implementation ignores any supplied array size
  limits, i.e., the behavior is the same as for arrays of unspecified
  length.
 </para>
____________________________________________________________________________-->
 <para>
  <command>CREATE TABLE</command>的语法允许指定数组的确切大小，例如：

<programlisting>
CREATE TABLE tictactoe (
    squares   integer[3][3]
);
</programlisting>

  然而，当前的实现忽略任何提供的数组尺寸限制，即其行为与未指定长度的数组相同。
 </para>

<!--==========================orignal english content==========================
 <para>
  The current implementation does not enforce the declared
  number of dimensions either.  Arrays of a particular element type are
  all considered to be of the same type, regardless of size or number
  of dimensions.  So, declaring the array size or number of dimensions in
  <command>CREATE TABLE</command> is simply documentation; it does not
  affect run-time behavior.
 </para>
____________________________________________________________________________-->
 <para>
  当前的实现也不会强制所声明的维度数。一个特定元素类型的数组全部被当作是相同的类型，而不论其尺寸或维度数。因此，在<command>CREATE TABLE</command>中声明数组的尺寸或维度数仅仅只是文档而已，它并不影响运行时的行为。
 </para>

<!--==========================orignal english content==========================
 <para>
  An alternative syntax, which conforms to the SQL standard by using
  the keyword <literal>ARRAY</literal>, can be used for one-dimensional arrays.
  <structfield>pay_by_quarter</structfield> could have been defined
  as:
<programlisting>
    pay_by_quarter  integer ARRAY[4],
</programlisting>
  Or, if no array size is to be specified:
<programlisting>
    pay_by_quarter  integer ARRAY,
</programlisting>
  As before, however, <productname>PostgreSQL</productname> does not enforce the
  size restriction in any case.
 </para>
____________________________________________________________________________-->
 <para>
  另一种符合SQL标准的语法是使用关键词<literal>ARRAY</literal>，可以用来定义一维数组。<structfield>pay_by_quarter</structfield>可以这样定义：
<programlisting>
    pay_by_quarter  integer ARRAY[4],
</programlisting>
  或者，不指定数组尺寸：
<programlisting>
    pay_by_quarter  integer ARRAY,
</programlisting>
  但是和前面一样，<productname>PostgreSQL</productname>在任何情况下都不会强制尺寸限制。
 </para>
 </sect2>

 <sect2 id="arrays-input">
<!--==========================orignal english content==========================
  <title>Array Value Input</title>
____________________________________________________________________________-->
  <title>数组值输入</title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>array</primary>
   <secondary>constant</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>array</primary>
   <secondary>constant</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   To write an array value as a literal constant, enclose the element
   values within curly braces and separate them by commas.  (If you
   know C, this is not unlike the C syntax for initializing
   structures.)  You can put double quotes around any element value,
   and must do so if it contains commas or curly braces.  (More
   details appear below.)  Thus, the general format of an array
   constant is the following:
<synopsis>
'{ <replaceable>val1</replaceable> <replaceable>delim</replaceable> <replaceable>val2</replaceable> <replaceable>delim</replaceable> ... }'
</synopsis>
   where <replaceable>delim</replaceable> is the delimiter character
   for the type, as recorded in its <literal>pg_type</literal> entry.
   Among the standard data types provided in the
   <productname>PostgreSQL</productname> distribution, all use a comma
   (<literal>,</literal>), except for type <type>box</type> which uses a semicolon
   (<literal>;</literal>). Each <replaceable>val</replaceable> is
   either a constant of the array element type, or a subarray. An example
   of an array constant is:
<programlisting>
'{{1,2,3},{4,5,6},{7,8,9}}'
</programlisting>
   This constant is a two-dimensional, 3-by-3 array consisting of
   three subarrays of integers.
  </para>
____________________________________________________________________________-->
  <para>
   要把一个数组值写成一个文字常数，将元素值用花括号包围并用逗号分隔（如果你懂C，这和初始化结构的C语法没什么两样）。在任意元素值周围可以使用双引号，并且在元素值包含逗号或花括号时必须这样做（更多细节如下所示）。因此，一个数组常量的一般格式如下：
<synopsis>
'{ <replaceable>val1</replaceable> <replaceable>delim</replaceable> <replaceable>val2</replaceable> <replaceable>delim</replaceable> ... }'
</synopsis>
   这里<replaceable>delim</replaceable>是类型的定界符，记录在类型的<literal>pg_type</literal>项中。在<productname>PostgreSQL</productname>发行提供的标准数据类型中，所有的都使用一个逗号（<literal>,</literal>），除了类型<type>box</type>使用一个分号（<literal>;</literal>）。每个<replaceable>val</replaceable>可以是数组元素类型的一个常量，也可以是一个子数组。一个数组常量的例子是：
<programlisting>
'{{1,2,3},{4,5,6},{7,8,9}}'
</programlisting>
   该常量是一个二维的，3乘3数组，它由3个整数子数组构成。
  </para>

<!--==========================orignal english content==========================
  <para>
   To set an element of an array constant to NULL, write <literal>NULL</literal>
   for the element value.  (Any upper- or lower-case variant of
   <literal>NULL</literal> will do.)  If you want an actual string value
   <quote>NULL</quote>, you must put double quotes around it.
  </para>
____________________________________________________________________________-->
  <para>
   要设置一个数组常量的一个元素为NULL，在该元素值处写<literal>NULL</literal>（任何<literal>NULL</literal>的大写或小写变体都有效）。如果你需要一个真正的字符串值<quote>NULL</quote>，你必须在它两边放上双引号。
  </para>

<!--==========================orignal english content==========================
  <para>
   (These kinds of array constants are actually only a special case of
   the generic type constants discussed in <xref
   linkend="sql-syntax-constants-generic"/>.  The constant is initially
   treated as a string and passed to the array input conversion
   routine.  An explicit type specification might be necessary.)
  </para>
____________________________________________________________________________-->
  <para>
   （这些种类的数组常数实际是<xref linkend="sql-syntax-constants-generic"/>中讨论的一般类型常量的一种特殊形式。常数最初被当做一个字符串，然后被传给数组的输入转换例程。有必要时可能需要一个显式的类型指定。）
  </para>

<!--==========================orignal english content==========================
  <para>
   Now we can show some <command>INSERT</command> statements:

<programlisting>
INSERT INTO sal_emp
    VALUES ('Bill',
    '{10000, 10000, 10000, 10000}',
    '{{"meeting", "lunch"}, {"training", "presentation"}}');

INSERT INTO sal_emp
    VALUES ('Carol',
    '{20000, 25000, 25000, 25000}',
    '{{"breakfast", "consulting"}, {"meeting", "lunch"}}');
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   现在我们可以展示一些<command>INSERT</command>语句：

<programlisting>
INSERT INTO sal_emp
    VALUES ('Bill',
    '{10000, 10000, 10000, 10000}',
    '{{"meeting", "lunch"}, {"training", "presentation"}}');

INSERT INTO sal_emp
    VALUES ('Carol',
    '{20000, 25000, 25000, 25000}',
    '{{"breakfast", "consulting"}, {"meeting", "lunch"}}');
</programlisting>
  </para>

<!--==========================orignal english content==========================
 <para>
  The result of the previous two inserts looks like this:

<programlisting>
SELECT * FROM sal_emp;
 name  |      pay_by_quarter       |                 schedule
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 Bill  | {10000,10000,10000,10000} | {{meeting,lunch},{training,presentation}}
 Carol | {20000,25000,25000,25000} | {{breakfast,consulting},{meeting,lunch}}
(2 rows)
</programlisting>
 </para>
____________________________________________________________________________-->
 <para>
  前两个插入的结果看起来像这样：

<programlisting>
SELECT * FROM sal_emp;
 name  |      pay_by_quarter       |                 schedule
-------+---------------------------+-------------------------------------------
 Bill  | {10000,10000,10000,10000} | {{meeting,lunch},{training,presentation}}
 Carol | {20000,25000,25000,25000} | {{breakfast,consulting},{meeting,lunch}}
(2 rows)
</programlisting>
 </para>

<!--==========================orignal english content==========================
 <para>
  Multidimensional arrays must have matching extents for each
  dimension. A mismatch causes an error, for example:

<programlisting>
INSERT INTO sal_emp
    VALUES ('Bill',
    '{10000, 10000, 10000, 10000}',
    '{{"meeting", "lunch"}, {"meeting"}}');
ERROR:  multidimensional arrays must have array expressions with matching dimensions
</programlisting>
 </para>
____________________________________________________________________________-->
 <para>
  多维数组的每一维都必须有相匹配的长度。不匹配会造成错误，例如：

<programlisting>
INSERT INTO sal_emp
    VALUES ('Bill',
    '{10000, 10000, 10000, 10000}',
    '{{"meeting", "lunch"}, {"meeting"}}');
ERROR:  multidimensional arrays must have array expressions with matching dimensions
</programlisting>
 </para>

<!--==========================orignal english content==========================
 <para>
  The <literal>ARRAY</literal> constructor syntax can also be used:
<programlisting>
INSERT INTO sal_emp
    VALUES ('Bill',
    ARRAY[10000, 10000, 10000, 10000],
    ARRAY[['meeting', 'lunch'], ['training', 'presentation']]);

INSERT INTO sal_emp
    VALUES ('Carol',
    ARRAY[20000, 25000, 25000, 25000],
    ARRAY[['breakfast', 'consulting'], ['meeting', 'lunch']]);
</programlisting>
  Notice that the array elements are ordinary SQL constants or
  expressions; for instance, string literals are single quoted, instead of
  double quoted as they would be in an array literal.  The <literal>ARRAY</literal>
  constructor syntax is discussed in more detail in
  <xref linkend="sql-syntax-array-constructors"/>.
 </para>
____________________________________________________________________________-->
 <para>
  <literal>ARRAY</literal>构造器语法也可以被用于：
<programlisting>
INSERT INTO sal_emp
    VALUES ('Bill',
    ARRAY[10000, 10000, 10000, 10000],
    ARRAY[['meeting', 'lunch'], ['training', 'presentation']]);

INSERT INTO sal_emp
    VALUES ('Carol',
    ARRAY[20000, 25000, 25000, 25000],
    ARRAY[['breakfast', 'consulting'], ['meeting', 'lunch']]);
</programlisting>
  注意数组元素是普通SQL常数或表达式，例如，字符串文字使用单引号而不是双引号包围，因为双引号可以出现在一个数组文字中。<literal>ARRAY</literal>构造器语法的详细讨论请见<xref linkend="sql-syntax-array-constructors"/>。
 </para>
 </sect2>

 <sect2 id="arrays-accessing">
<!--==========================orignal english content==========================
  <title>Accessing Arrays</title>
____________________________________________________________________________-->
  <title>访问数组</title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>array</primary>
   <secondary>accessing</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>array</primary>
   <secondary>accessing</secondary>
  </indexterm>

<!--==========================orignal english content==========================
 <para>
  Now, we can run some queries on the table.
  First, we show how to access a single element of an array.
  This query retrieves the names of the employees whose pay changed in
  the second quarter:

<programlisting>
SELECT name FROM sal_emp WHERE pay_by_quarter[1] &lt;&gt; pay_by_quarter[2];

 name
-&minus;-&minus;-&minus;-
 Carol
(1 row)
</programlisting>

  The array subscript numbers are written within square brackets.
  By default <productname>PostgreSQL</productname> uses a
  one-based numbering convention for arrays, that is,
  an array of <replaceable>n</replaceable> elements starts with <literal>array[1]</literal> and
  ends with <literal>array[<replaceable>n</replaceable>]</literal>.
 </para>
____________________________________________________________________________-->
 <para>
  现在，我们可以在该表上运行一些查询。首先，我们展示如何访问一个数组中的一个元素。下面的查询检索在第二季度工资发生变化的雇员的名字：

<programlisting>
SELECT name FROM sal_emp WHERE pay_by_quarter[1] &lt;&gt; pay_by_quarter[2];

 name
-------
 Carol
(1 row)
</programlisting>

  数组下标写在方括号内。默认情况下，<productname>PostgreSQL</productname>为数组使用了一种从1开始的编号习惯，即一个具有<replaceable>n</replaceable>个元素的数组从<literal>array[1]</literal>开始，结束于<literal>array[<replaceable>n</replaceable>]</literal>。
 </para>

<!--==========================orignal english content==========================
 <para>
  This query retrieves the third quarter pay of all employees:

<programlisting>
SELECT pay_by_quarter[3] FROM sal_emp;

 pay_by_quarter
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
          10000
          25000
(2 rows)
</programlisting>
 </para>
____________________________________________________________________________-->
 <para>
  下面的查询检索所有员工第三季度的工资：

<programlisting>
SELECT pay_by_quarter[3] FROM sal_emp;

 pay_by_quarter
----------------
          10000
          25000
(2 rows)
</programlisting>
 </para>

<!--==========================orignal english content==========================
 <para>
  We can also access arbitrary rectangular slices of an array, or
  subarrays.  An array slice is denoted by writing
  <literal><replaceable>lower-bound</replaceable>:<replaceable>upper-bound</replaceable></literal>
  for one or more array dimensions.  For example, this query retrieves the first
  item on Bill's schedule for the first two days of the week:

<programlisting>
SELECT schedule[1:2][1:1] FROM sal_emp WHERE name = 'Bill';

        schedule
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 {{meeting},{training}}
(1 row)
</programlisting>

  If any dimension is written as a slice, i.e., contains a colon, then all
  dimensions are treated as slices.  Any dimension that has only a single
  number (no colon) is treated as being from 1
  to the number specified.  For example, <literal>[2]</literal> is treated as
  <literal>[1:2]</literal>, as in this example:

<programlisting>
SELECT schedule[1:2][2] FROM sal_emp WHERE name = 'Bill';

                 schedule
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 {{meeting,lunch},{training,presentation}}
(1 row)
</programlisting>

  To avoid confusion with the non-slice case, it's best to use slice syntax
  for all dimensions, e.g., <literal>[1:2][1:1]</literal>, not <literal>[2][1:1]</literal>.
 </para>
____________________________________________________________________________-->
 <para>
  我们也可以访问一个数组的任意矩形切片或者子数组。一个数组切片可以通过在一个或多个数组维度上指定<literal><replaceable>下界</replaceable>:<replaceable>上界</replaceable></literal>来定义例如，下面的查询检索Bill在本周头两天日程中的第一项：

<programlisting>
SELECT schedule[1:2][1:1] FROM sal_emp WHERE name = 'Bill';

        schedule
------------------------
 {{meeting},{training}}
(1 row)
</programlisting>

  如果任何维度被写成一个切片，即包含一个冒号，那么所有的维度都被看成是切片对待。其中任何只有一个数字（无冒号）的维度被视作是从1到指定的数字。例如，下面例子中的<literal>[2]</literal>被认为是<literal>[1:2]</literal>：

<programlisting>
SELECT schedule[1:2][2] FROM sal_emp WHERE name = 'Bill';

                 schedule
-------------------------------------------
 {{meeting,lunch},{training,presentation}}
(1 row)
</programlisting>

  为了避免和非切片情况搞混，最好在所有的维度上都使用切片语法，例如<literal>[1:2][1:1]</literal>而不是<literal>[2][1:1]</literal>。
 </para>
 
<!--==========================orignal english content==========================
 <para>
  It is possible to omit the <replaceable>lower-bound</replaceable> and/or
  <replaceable>upper-bound</replaceable> of a slice specifier; the missing
  bound is replaced by the lower or upper limit of the array's subscripts.
  For example:

<programlisting>
SELECT schedule[:2][2:] FROM sal_emp WHERE name = 'Bill';

        schedule
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 {{lunch},{presentation}}
(1 row)

SELECT schedule[:][1:1] FROM sal_emp WHERE name = 'Bill';

        schedule
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 {{meeting},{training}}
(1 row)
</programlisting>
 </para>
____________________________________________________________________________-->
 <para>
  可以省略一个切片说明符的<replaceable>lower-bound</replaceable>或者
  <replaceable>upper-bound</replaceable>（亦可两者都省略），缺失的
  边界会被数组下标的上下限所替代。例如：

<programlisting>
SELECT schedule[:2][2:] FROM sal_emp WHERE name = 'Bill';

        schedule
------------------------
 {{lunch},{presentation}}
(1 row)

SELECT schedule[:][1:1] FROM sal_emp WHERE name = 'Bill';

        schedule
------------------------
 {{meeting},{training}}
(1 row)
</programlisting>
 </para>

<!--==========================orignal english content==========================
 <para>
  An array subscript expression will return null if either the array itself or
  any of the subscript expressions are null.  Also, null is returned if a
  subscript is outside the array bounds (this case does not raise an error).
  For example, if <literal>schedule</literal>
  currently has the dimensions <literal>[1:3][1:2]</literal> then referencing
  <literal>schedule[3][3]</literal> yields NULL.  Similarly, an array reference
  with the wrong number of subscripts yields a null rather than an error.
 </para>
____________________________________________________________________________-->
 <para>
  如果数组本身为空或者任何一个下标表达式为空，访问数组下标表达式将会返回空值。如果下标超过了数组边界，下标表达式也会返回空值（这种情况不会抛出错误）。例如，如果<literal>schedule</literal>目前具有的维度是<literal>[1:3][1:2]</literal>，那么引用<literal>schedule[3][3]</literal>将得到NULL。相似地，使用错误的下标号引用一个数组会得到空值而不是错误。
 </para>

<!--==========================orignal english content==========================
 <para>
  An array slice expression likewise yields null if the array itself or
  any of the subscript expressions are null.  However, in other
  cases such as selecting an array slice that
  is completely outside the current array bounds, a slice expression
  yields an empty (zero-dimensional) array instead of null.  (This
  does not match non-slice behavior and is done for historical reasons.)
  If the requested slice partially overlaps the array bounds, then it
  is silently reduced to just the overlapping region instead of
  returning null.
 </para>
____________________________________________________________________________-->
 <para>
  如果数组本身或者任何一个下标表达式为空，则一个数组切片表达式也会得到空值。但是，在其他情况例如选择一个完全位于当前数组边界之外的切片时，一个切片表达式会得到一个空（零维）数组而不是空值（由于历史原因，这并不符合非切片行为）。  如果所请求的切片和数组边界重叠，那么它会被缩减为重叠的区域而不是返回空。
 </para>

<!--==========================orignal english content==========================
 <para>
  The current dimensions of any array value can be retrieved with the
  <function>array_dims</function> function:

<programlisting>
SELECT array_dims(schedule) FROM sal_emp WHERE name = 'Carol';

 array_dims
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 [1:2][1:2]
(1 row)
</programlisting>

  <function>array_dims</function> produces a <type>text</type> result,
  which is convenient for people to read but perhaps inconvenient
  for programs.  Dimensions can also be retrieved with
  <function>array_upper</function> and <function>array_lower</function>,
  which return the upper and lower bound of a
  specified array dimension, respectively:

<programlisting>
SELECT array_upper(schedule, 1) FROM sal_emp WHERE name = 'Carol';

 array_upper
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
           2
(1 row)
</programlisting>

 <function>array_length</function> will return the length of a specified
 array dimension:

<programlisting>
SELECT array_length(schedule, 1) FROM sal_emp WHERE name = 'Carol';

 array_length
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
            2
(1 row)
</programlisting>

 <function>cardinality</function> returns the total number of elements in an
 array across all dimensions.  It is effectively the number of rows a call to
 <function>unnest</function> would yield:

<programlisting>
SELECT cardinality(schedule) FROM sal_emp WHERE name = 'Carol';

 cardinality
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
           4
(1 row)
</programlisting>
 </para>
____________________________________________________________________________-->
 <para>
  任何数组值的当前维度可以使用<function>array_dims</function>函数获得：

<programlisting>
SELECT array_dims(schedule) FROM sal_emp WHERE name = 'Carol';

 array_dims
------------
 [1:2][1:2]
(1 row)
</programlisting>

  <function>array_dims</function>产生一个<type>text</type>结果，它便于人类阅读但是不便于程序读取。  Dimensions can also be retrieved with
  也可以通过<function>array_upper</function>和<function>array_lower</function>来获得维度，它们将分别返回一个指定数组的上界和下界：

<programlisting>
SELECT array_upper(schedule, 1) FROM sal_emp WHERE name = 'Carol';

 array_upper
-------------
           2
(1 row)
</programlisting>

 <function>array_length</function>将返回一个指定数组维度的长度：

<programlisting>
SELECT array_length(schedule, 1) FROM sal_emp WHERE name = 'Carol';

 array_length
--------------
            2
(1 row)
</programlisting>

 <function>cardinality</function>返回一个数组中在所有维度上的元素总数。
 这实际上是调用<function>unnest</function>将会得到的行数：

<programlisting>
SELECT cardinality(schedule) FROM sal_emp WHERE name = 'Carol';

 cardinality
-------------
           4
(1 row)
</programlisting>
 </para>
 </sect2>

 <sect2 id="arrays-modifying">
<!--==========================orignal english content==========================
  <title>Modifying Arrays</title>
____________________________________________________________________________-->
  <title>修改数组</title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>array</primary>
   <secondary>modifying</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>array</primary>
   <secondary>modifying</secondary>
  </indexterm>

<!--==========================orignal english content==========================
 <para>
  An array value can be replaced completely:

<programlisting>
UPDATE sal_emp SET pay_by_quarter = '{25000,25000,27000,27000}'
    WHERE name = 'Carol';
</programlisting>

  or using the <literal>ARRAY</literal> expression syntax:

<programlisting>
UPDATE sal_emp SET pay_by_quarter = ARRAY[25000,25000,27000,27000]
    WHERE name = 'Carol';
</programlisting>

  An array can also be updated at a single element:

<programlisting>
UPDATE sal_emp SET pay_by_quarter[4] = 15000
    WHERE name = 'Bill';
</programlisting>

  or updated in a slice:

<programlisting>
UPDATE sal_emp SET pay_by_quarter[1:2] = '{27000,27000}'
    WHERE name = 'Carol';
</programlisting>

  The slice syntaxes with omitted <replaceable>lower-bound</replaceable> and/or
  <replaceable>upper-bound</replaceable> can be used too, but only when
  updating an array value that is not NULL or zero-dimensional (otherwise,
  there is no existing subscript limit to substitute).
 </para>
____________________________________________________________________________-->
 <para>
  一个数组值可以被整个替换：

<programlisting>
UPDATE sal_emp SET pay_by_quarter = '{25000,25000,27000,27000}'
    WHERE name = 'Carol';
</programlisting>

  或者使用<literal>ARRAY</literal>表达式语法：

<programlisting>
UPDATE sal_emp SET pay_by_quarter = ARRAY[25000,25000,27000,27000]
    WHERE name = 'Carol';
</programlisting>

  一个数组也可以在一个元素上被更新：

<programlisting>
UPDATE sal_emp SET pay_by_quarter[4] = 15000
    WHERE name = 'Bill';
</programlisting>

  或者在一个切片上被更新：

<programlisting>
UPDATE sal_emp SET pay_by_quarter[1:2] = '{27000,27000}'
    WHERE name = 'Carol';
</programlisting>

  也可以使用省略<replaceable>lower-bound</replaceable>或者
  <replaceable>upper-bound</replaceable>的切片语法，但是只能用于
  更新一个不是 NULL 或者零维的数组值（否则无法替换现有的下标界线）。
 </para>

<!--==========================orignal english content==========================
 <para>
  A stored array value can be enlarged by assigning to elements not already
  present.  Any positions between those previously present and the newly
  assigned elements will be filled with nulls.  For example, if array
  <literal>myarray</literal> currently has 4 elements, it will have six
  elements after an update that assigns to <literal>myarray[6]</literal>;
  <literal>myarray[5]</literal> will contain null.
  Currently, enlargement in this fashion is only allowed for one-dimensional
  arrays, not multidimensional arrays.
 </para>
____________________________________________________________________________-->
 <para>
  一个已存储的数组值可以被通过为其还不存在的元素赋值来扩大之。任何位于之前已存在的元素和新元素之间的位置都将被空值填充。例如，如果数组<literal>myarray</literal>目前有4个元素，在用一个更新对<literal>myarray[6]</literal>赋值后它将有6个元素，其中<literal>myarray[5]</literal>为空值。目前，采用这种方式扩大数组只允许使用在一维数组上。
 </para>

<!--==========================orignal english content==========================
 <para>
  Subscripted assignment allows creation of arrays that do not use one-based
  subscripts.  For example one might assign to <literal>myarray[-2:7]</literal> to
  create an array with subscript values from -2 to 7.
 </para>
____________________________________________________________________________-->
 <para>
  带下标的赋值方式允许创建下标不是从1开始的数组。例如，我们可以为<literal>myarray[-2:7]</literal>赋值来创建一个下标值从-2到7的数组。
 </para>

<!--==========================orignal english content==========================
 <para>
  New array values can also be constructed using the concatenation operator,
  <literal>||</literal>:
<programlisting>
SELECT ARRAY[1,2] || ARRAY[3,4];
 ?column?
-&minus;-&minus;-&minus;-&minus;-&minus;-
 {1,2,3,4}
(1 row)

SELECT ARRAY[5,6] || ARRAY[[1,2],[3,4]];
      ?column?
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 {{5,6},{1,2},{3,4}}
(1 row)
</programlisting>
 </para>
____________________________________________________________________________-->
 <para>
  新的数组值也可以通过串接操作符<literal>||</literal>构建：
<programlisting>
SELECT ARRAY[1,2] || ARRAY[3,4];
 ?column?
-----------
 {1,2,3,4}
(1 row)

SELECT ARRAY[5,6] || ARRAY[[1,2],[3,4]];
      ?column?
---------------------
 {{5,6},{1,2},{3,4}}
(1 row)
</programlisting>
 </para>

<!--==========================orignal english content==========================
 <para>
  The concatenation operator allows a single element to be pushed onto the
  beginning or end of a one-dimensional array. It also accepts two
  <replaceable>N</replaceable>-dimensional arrays, or an <replaceable>N</replaceable>-dimensional
  and an <replaceable>N+1</replaceable>-dimensional array.
 </para>
____________________________________________________________________________-->
 <para>
  串接操作符允许把一个单独的元素加入到一个一维数组的开头或末尾。它也能接受两个<replaceable>N</replaceable>维数组，或者一个<replaceable>N</replaceable>维数组和一个<replaceable>N+1</replaceable>维数组。
 </para>

<!--==========================orignal english content==========================
 <para>
  When a single element is pushed onto either the beginning or end of a
  one-dimensional array, the result is an array with the same lower bound
  subscript as the array operand. For example:
<programlisting>
SELECT array_dims(1 || '[0:1]={2,3}'::int[]);
 array_dims
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 [0:2]
(1 row)

SELECT array_dims(ARRAY[1,2] || 3);
 array_dims
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 [1:3]
(1 row)
</programlisting>
 </para>
____________________________________________________________________________-->
 <para>
  当一个单独的元素被加入到一个一维数组的开头或末尾时，其结果是一个和数组操作数具有相同下界下标的新数组。例如：
<programlisting>
SELECT array_dims(1 || '[0:1]={2,3}'::int[]);
 array_dims
------------
 [0:2]
(1 row)

SELECT array_dims(ARRAY[1,2] || 3);
 array_dims
------------
 [1:3]
(1 row)
</programlisting>
 </para>

<!--==========================orignal english content==========================
 <para>
  When two arrays with an equal number of dimensions are concatenated, the
  result retains the lower bound subscript of the left-hand operand's outer
  dimension. The result is an array comprising every element of the left-hand
  operand followed by every element of the right-hand operand. For example:
<programlisting>
SELECT array_dims(ARRAY[1,2] || ARRAY[3,4,5]);
 array_dims
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 [1:5]
(1 row)

SELECT array_dims(ARRAY[[1,2],[3,4]] || ARRAY[[5,6],[7,8],[9,0]]);
 array_dims
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 [1:5][1:2]
(1 row)
</programlisting>
 </para>
____________________________________________________________________________-->
 <para>
  当两个具有相同维度数的数组被串接时，其结果保留左操作数的外维度的下界下标。结果将是一个数组，它由左操作数的每一个元素以及紧接着的右操作数的每一个元素。例如：
<programlisting>
SELECT array_dims(ARRAY[1,2] || ARRAY[3,4,5]);
 array_dims
------------
 [1:5]
(1 row)

SELECT array_dims(ARRAY[[1,2],[3,4]] || ARRAY[[5,6],[7,8],[9,0]]);
 array_dims
------------
 [1:5][1:2]
(1 row)
</programlisting>
 </para>

<!--==========================orignal english content==========================
 <para>
  When an <replaceable>N</replaceable>-dimensional array is pushed onto the beginning
  or end of an <replaceable>N+1</replaceable>-dimensional array, the result is
  analogous to the element-array case above. Each <replaceable>N</replaceable>-dimensional
  sub-array is essentially an element of the <replaceable>N+1</replaceable>-dimensional
  array's outer dimension. For example:
<programlisting>
SELECT array_dims(ARRAY[1,2] || ARRAY[[3,4],[5,6]]);
 array_dims
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 [1:3][1:2]
(1 row)
</programlisting>
 </para>
____________________________________________________________________________-->
 <para>
  当一个<replaceable>N</replaceable>维数组被放在另一个<replaceable>N+1</replaceable>维数组的前面或者后面时，结果和上面的例子相似。每一个<replaceable>N</replaceable>维子数组实际上是<replaceable>N+1</replaceable>维数组外维度的一个元素。例如：
<programlisting>
SELECT array_dims(ARRAY[1,2] || ARRAY[[3,4],[5,6]]);
 array_dims
------------
 [1:3][1:2]
(1 row)
</programlisting>
 </para>

<!--==========================orignal english content==========================
 <para>
  An array can also be constructed by using the functions
  <function>array_prepend</function>, <function>array_append</function>,
  or <function>array_cat</function>. The first two only support one-dimensional
  arrays, but <function>array_cat</function> supports multidimensional arrays.
  Some examples:

<programlisting>
SELECT array_prepend(1, ARRAY[2,3]);
 array_prepend
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 {1,2,3}
(1 row)

SELECT array_append(ARRAY[1,2], 3);
 array_append
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 {1,2,3}
(1 row)

SELECT array_cat(ARRAY[1,2], ARRAY[3,4]);
 array_cat
-&minus;-&minus;-&minus;-&minus;-&minus;-
 {1,2,3,4}
(1 row)

SELECT array_cat(ARRAY[[1,2],[3,4]], ARRAY[5,6]);
      array_cat
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 {{1,2},{3,4},{5,6}}
(1 row)

SELECT array_cat(ARRAY[5,6], ARRAY[[1,2],[3,4]]);
      array_cat
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 {{5,6},{1,2},{3,4}}
</programlisting>
 </para>
____________________________________________________________________________-->
 <para>
  一个数组也可以通过使用函数<function>array_prepend</function>、<function>array_append</function>或<function>array_cat</function>构建。前两个函数仅支持一维数组，但<function>array_cat</function>支持多维数组。

  一些例子：

<programlisting>
SELECT array_prepend(1, ARRAY[2,3]);
 array_prepend
---------------
 {1,2,3}
(1 row)

SELECT array_append(ARRAY[1,2], 3);
 array_append
--------------
 {1,2,3}
(1 row)

SELECT array_cat(ARRAY[1,2], ARRAY[3,4]);
 array_cat
-----------
 {1,2,3,4}
(1 row)

SELECT array_cat(ARRAY[[1,2],[3,4]], ARRAY[5,6]);
      array_cat
---------------------
 {{1,2},{3,4},{5,6}}
(1 row)

SELECT array_cat(ARRAY[5,6], ARRAY[[1,2],[3,4]]);
      array_cat
---------------------
 {{5,6},{1,2},{3,4}}
</programlisting>
 </para>
 
<!--==========================orignal english content==========================
 <para>
  In simple cases, the concatenation operator discussed above is preferred
  over direct use of these functions.  However, because the concatenation
  operator is overloaded to serve all three cases, there are situations where
  use of one of the functions is helpful to avoid ambiguity.  For example
  consider:

<programlisting>
SELECT ARRAY[1, 2] || '{3, 4}';  -&minus; the untyped literal is taken as an array
 ?column?
-&minus;-&minus;-&minus;-&minus;-&minus;-
 {1,2,3,4}

SELECT ARRAY[1, 2] || '7';                 -&minus; so is this one
ERROR:  malformed array literal: "7"

SELECT ARRAY[1, 2] || NULL;                -&minus; so is an undecorated NULL
 ?column?
-&minus;-&minus;-&minus;-&minus;-&minus;
 {1,2}
(1 row)

SELECT array_append(ARRAY[1, 2], NULL);    -&minus; this might have been meant
 array_append
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 {1,2,NULL}
</programlisting>

  In the examples above, the parser sees an integer array on one side of the
  concatenation operator, and a constant of undetermined type on the other.
  The heuristic it uses to resolve the constant's type is to assume it's of
  the same type as the operator's other input &mdash; in this case,
  integer array.  So the concatenation operator is presumed to
  represent <function>array_cat</function>, not <function>array_append</function>.  When
  that's the wrong choice, it could be fixed by casting the constant to the
  array's element type; but explicit use of <function>array_append</function> might
  be a preferable solution.
 </para>
____________________________________________________________________________-->
 <para>
  在简单的情况中，上面讨论的串接操作符比直接使用这些函数更好。不过，由于
  串接操作符需要服务于所有三种情况，所以它的负担比较重，在有些情况下使用
  这些函数之一有助于避免混淆。例如：

<programlisting>
SELECT ARRAY[1, 2] || '{3, 4}';  -- 没有指定类型的文字被当做一个数组
 ?column?
-----------
 {1,2,3,4}

SELECT ARRAY[1, 2] || '7';                 -- 这个也是
ERROR:  malformed array literal: "7"

SELECT ARRAY[1, 2] || NULL;                -- 未修饰的 NULL 也是如此
 ?column?
----------
 {1,2}
(1 row)

SELECT array_append(ARRAY[1, 2], NULL);    -- 这可能才是想要的意思
 array_append
--------------
 {1,2,NULL}
</programlisting>

  在上面的例子中，解析器看到在串接操作符的一遍看到了一个整数数组，并且在
  另一边看到了一个未确定类型的常量。它用来决定该常量类型的启发式规则是假
  定它和该操作符的另一个输入具有相同的类型 &mdash; 在这种情况中是整数数
  组。因此串接操作符表示<function>array_cat</function>而不是
  <function>array_append</function>。如果这样做是错误的选择，它可以通过将该常
  量造型成数组的元素类型来修复。但是显式地使用<function>array_append</function>
  可能是一种最好的方案。
 </para>
 </sect2>

 <sect2 id="arrays-searching">
<!--==========================orignal english content==========================
  <title>Searching in Arrays</title>
____________________________________________________________________________-->
  <title>在数组中搜索</title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>array</primary>
   <secondary>searching</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>array</primary>
   <secondary>searching</secondary>
  </indexterm>

<!--==========================orignal english content==========================
 <para>
  To search for a value in an array, each value must be checked.
  This can be done manually, if you know the size of the array.
  For example:

<programlisting>
SELECT * FROM sal_emp WHERE pay_by_quarter[1] = 10000 OR
                            pay_by_quarter[2] = 10000 OR
                            pay_by_quarter[3] = 10000 OR
                            pay_by_quarter[4] = 10000;
</programlisting>

  However, this quickly becomes tedious for large arrays, and is not
  helpful if the size of the array is unknown. An alternative method is
  described in <xref linkend="functions-comparisons"/>. The above
  query could be replaced by:

<programlisting>
SELECT * FROM sal_emp WHERE 10000 = ANY (pay_by_quarter);
</programlisting>

  In addition, you can find rows where the array has all values
  equal to 10000 with:

<programlisting>
SELECT * FROM sal_emp WHERE 10000 = ALL (pay_by_quarter);
</programlisting>

 </para>
____________________________________________________________________________-->
 <para>
  要在一个数组中搜索一个值，每一个值都必须被检查。这可以手动完成，但是我们必须知道数组的尺寸。例如：

<programlisting>
SELECT * FROM sal_emp WHERE pay_by_quarter[1] = 10000 OR
                            pay_by_quarter[2] = 10000 OR
                            pay_by_quarter[3] = 10000 OR
                            pay_by_quarter[4] = 10000;
</programlisting>

  但是这对于大型数组来说太过冗长，且在数组尺寸未知时无法使用。一种可选的方法可见<xref linkend="functions-comparisons"/>。上面的查询可以被替换为：

<programlisting>
SELECT * FROM sal_emp WHERE 10000 = ANY (pay_by_quarter);
</programlisting>

  此外，我们还可以查找所有元素值都为10000的数组所在的行：

<programlisting>
SELECT * FROM sal_emp WHERE 10000 = ALL (pay_by_quarter);
</programlisting>

 </para>

<!--==========================orignal english content==========================
 <para>
  Alternatively, the <function>generate_subscripts</function> function can be used.
  For example:

<programlisting>
SELECT * FROM
   (SELECT pay_by_quarter,
           generate_subscripts(pay_by_quarter, 1) AS s
      FROM sal_emp) AS foo
 WHERE pay_by_quarter[s] = 10000;
</programlisting>

  This function is described in <xref linkend="functions-srf-subscripts"/>.
 </para>
____________________________________________________________________________-->
 <para>
  另外，<function>generate_subscripts</function>函数也可以用来完成类似的查找。例如：

<programlisting>
SELECT * FROM
   (SELECT pay_by_quarter,
           generate_subscripts(pay_by_quarter, 1) AS s
      FROM sal_emp) AS foo
 WHERE pay_by_quarter[s] = 10000;
</programlisting>

  该函数的描述见<xref linkend="functions-srf-subscripts"/>。
 </para>

<!--==========================orignal english content==========================
 <para>
  You can also search an array using the <literal>&amp;&amp;</literal> operator,
  which checks whether the left operand overlaps with the right operand.
  For instance:

<programlisting>
SELECT * FROM sal_emp WHERE pay_by_quarter &amp;&amp; ARRAY[10000];
</programlisting>

  This and other array operators are further described in
  <xref linkend="functions-array"/>.  It can be accelerated by an appropriate
  index, as described in <xref linkend="indexes-types"/>.
 </para>
____________________________________________________________________________-->
 <para>
  我们也可以使用<literal>&amp;&amp;</literal>操作符来搜索一个数组，它会检查左操作数是否与右操作数重叠。例如：

<programlisting>
SELECT * FROM sal_emp WHERE pay_by_quarter &amp;&amp; ARRAY[10000];
</programlisting>

  该操作符和其他数组操作符的进一步描述请见<xref linkend="functions-array"/>。如<xref linkend="indexes-types"/>所述，它可以使用一个合适的索引来提速。
 </para>
 
<!--==========================orignal english content==========================
 <para>
  You can also search for specific values in an array using the <function>array_position</function>
  and <function>array_positions</function> functions. The former returns the subscript of
  the first occurrence of a value in an array; the latter returns an array with the
  subscripts of all occurrences of the value in the array.  For example:

<programlisting>
SELECT array_position(ARRAY['sun','mon','tue','wed','thu','fri','sat'], 'mon');
 array_position
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
              2
(1 row)

SELECT array_positions(ARRAY[1, 4, 3, 1, 3, 4, 2, 1], 1);
 array_positions
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 {1,4,8}
(1 row)
</programlisting>
 </para>
____________________________________________________________________________-->
 <para>
  你也可以使用<function>array_position</function>和<function>array_positions</function>在一个
  数组中搜索特定值。前者返回值在数组中第一次出现的位置的下标。后者返回一个数组，
  其中有该值在数组中的所有出现位置的下标。例如：

<programlisting>
SELECT array_position(ARRAY['sun','mon','tue','wed','thu','fri','sat'], 'mon');
 array_position
----------------
              2
(1 row)

SELECT array_positions(ARRAY[1, 4, 3, 1, 3, 4, 2, 1], 1);
 array_positions
-----------------
 {1,4,8}
(1 row)
</programlisting>
 </para>

 <tip>
<!--==========================orignal english content==========================
  <para>
   Arrays are not sets; searching for specific array elements
   can be a sign of database misdesign.  Consider
   using a separate table with a row for each item that would be an
   array element.  This will be easier to search, and is likely to
   scale better for a large number of elements.
  </para>
____________________________________________________________________________-->
  <para>
   数组不是集合，在其中搜索指定数组元素可能是数据设计失误的表现。考虑使用一个独立的表来替代，其中每一行都对应于一个数组元素。这将更有利于搜索，并且对于大量元素的可扩展性更好。
  </para>
 </tip>
 </sect2>

 <sect2 id="arrays-io">
<!--==========================orignal english content==========================
  <title>Array Input and Output Syntax</title>
____________________________________________________________________________-->
  <title>数组输入和输出语法</title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>array</primary>
   <secondary>I/O</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>array</primary>
   <secondary>I/O</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The external text representation of an array value consists of items that
   are interpreted according to the I/O conversion rules for the array's
   element type, plus decoration that indicates the array structure.
   The decoration consists of curly braces (<literal>{</literal> and <literal>}</literal>)
   around the array value plus delimiter characters between adjacent items.
   The delimiter character is usually a comma (<literal>,</literal>) but can be
   something else: it is determined by the <literal>typdelim</literal> setting
   for the array's element type.  Among the standard data types provided
   in the <productname>PostgreSQL</productname> distribution, all use a comma,
   except for type <type>box</type>, which uses a semicolon (<literal>;</literal>).
   In a multidimensional array, each dimension (row, plane,
   cube, etc.) gets its own level of curly braces, and delimiters
   must be written between adjacent curly-braced entities of the same level.
  </para>
____________________________________________________________________________-->
  <para>
   一个数组值的外部文本表现由根据数组元素类型的I/O转换规则解释的项构成，并在其上加上修饰用于指示数组结构。修饰包括数组值周围的花括号（<literal>{</literal>和<literal>}</literal>）以及相邻项之间的定界字符。定界字符通常是一个逗号（<literal>,</literal>），但是也可能是别的：它由数组元素类型的<literal>typdelim</literal>设置决定。在<productname>PostgreSQL</productname>发行版提供的标准数据类型中，除了<type>box</type>类型使用分号（<literal>;</literal>）之外，其他都是用逗号。在一个多维数组中，每一个维度（行、平面、方体等）都有其自己的花括号层次，且同层的被花括号限定的相邻实体之间也必须有定界符。
  </para>

<!--==========================orignal english content==========================
  <para>
   The array output routine will put double quotes around element values
   if they are empty strings, contain curly braces, delimiter characters,
   double quotes, backslashes, or white space, or match the word
   <literal>NULL</literal>.  Double quotes and backslashes
   embedded in element values will be backslash-escaped.  For numeric
   data types it is safe to assume that double quotes will never appear, but
   for textual data types one should be prepared to cope with either the presence
   or absence of quotes.
  </para>
____________________________________________________________________________-->
  <para>
   如果元素值是空字符串、包含花括号、包含定界字符、包含双引号、包含反斜线、包含空白或者匹配词<literal>NULL</literal>，数组输出例程将在元素值周围放上双引号。嵌在元素值中的双引号以及反斜线将被反斜线转义。对于数字数据类型可以安全地假设双引号绝不会出现，但是对于文本数据类型我们必须准备好处理可能出现亦可能不出现的引号。
  </para>

<!--==========================orignal english content==========================
  <para>
   By default, the lower bound index value of an array's dimensions is
   set to one.  To represent arrays with other lower bounds, the array
   subscript ranges can be specified explicitly before writing the
   array contents.
   This decoration consists of square brackets (<literal>[]</literal>)
   around each array dimension's lower and upper bounds, with
   a colon (<literal>:</literal>) delimiter character in between. The
   array dimension decoration is followed by an equal sign (<literal>=</literal>).
   For example:
<programlisting>
SELECT f1[1][-2][3] AS e1, f1[1][-1][5] AS e2
 FROM (SELECT '[1:1][-2:-1][3:5]={{{1,2,3},{4,5,6}}}'::int[] AS f1) AS ss;

 e1 | e2
-&minus;-&minus;+-&minus;-&minus;
  1 |  6
(1 row)
</programlisting>
   The array output routine will include explicit dimensions in its result
   only when there are one or more lower bounds different from one.
  </para>
____________________________________________________________________________-->
  <para>
   默认情况下，一个数组的一个维度的下界索引值被设置为1。要表示具有其他下界的数组，数组下标的范围应在填充数组内容之前被显式地指定好。这种修饰包括在每个数组维度上下界周围的方括号（<literal>[]</literal>），以及上下界之间的一个冒号（<literal>:</literal>）定界符。数组维度修饰后面要跟一个等号（<literal>=</literal>）。例如：
<programlisting>
SELECT f1[1][-2][3] AS e1, f1[1][-1][5] AS e2
 FROM (SELECT '[1:1][-2:-1][3:5]={{{1,2,3},{4,5,6}}}'::int[] AS f1) AS ss;

 e1 | e2
----+----
  1 |  6
(1 row)
</programlisting>
   只有当数组的维度中有一个或多个的下界不为1时，数组输出例程才会在结果中包括维度。
  </para>

<!--==========================orignal english content==========================
  <para>
   If the value written for an element is <literal>NULL</literal> (in any case
   variant), the element is taken to be NULL.  The presence of any quotes
   or backslashes disables this and allows the literal string value
   <quote>NULL</quote> to be entered.  Also, for backward compatibility with
   pre-8.2 versions of <productname>PostgreSQL</productname>, the <xref
   linkend="guc-array-nulls"/> configuration parameter can be turned
   <literal>off</literal> to suppress recognition of <literal>NULL</literal> as a NULL.
  </para>
____________________________________________________________________________-->
  <para>
   如果为一个元素给定的值是<literal>NULL</literal>（或者是任何变体），该元素将被设置为NULL。任何引号或反斜线的存在将阻止这种行为，而允许为元素值输入<quote>NULL</quote>的字面意思。为了向后兼容<productname>PostgreSQL</productname>的8.2之前的版本，可将<xref linkend="guc-array-nulls"/>配置参数设置为<literal>off</literal>来阻止将<literal>NULL</literal>识别为NULL。
  </para>

<!--==========================orignal english content==========================
  <para>
   As shown previously, when writing an array value you can use double
   quotes around any individual array element. You <emphasis>must</emphasis> do so
   if the element value would otherwise confuse the array-value parser.
   For example, elements containing curly braces, commas (or the data type's
   delimiter character), double quotes, backslashes, or leading or trailing
   whitespace must be double-quoted.  Empty strings and strings matching the
   word <literal>NULL</literal> must be quoted, too.  To put a double
   quote or backslash in a quoted array element value, precede it
   with a backslash. Alternatively, you can avoid quotes and use
   backslash-escaping to protect all data characters that would otherwise
   be taken as array syntax.
  </para>
____________________________________________________________________________-->
  <para>
   如前所示，在写一个数组值时我们可以在任何单独数组元素周围使用引号。如果元素值可能混淆数组值分析器时，我们<emphasis>必须</emphasis> 这样做。例如，包含花括号、逗号（或者数据类型的定界符）、双引号、反斜线或首尾有空白的元素必须使用双引号。空字符串和匹配单词<literal>NULL</literal>的字符串也必须使用双引号。要把一个双引号或反斜线放在一个使用了双引号的数组元素值中，需要在它前面放一个反斜线。作为一种选择，我们可以免去使用引号而使用反斜线转义的方式来保护可能被认为是数组语法的所有数据字符。
  </para>

<!--==========================orignal english content==========================
  <para>
   You can add whitespace before a left brace or after a right
   brace. You can also add whitespace before or after any individual item
   string. In all of these cases the whitespace will be ignored. However,
   whitespace within double-quoted elements, or surrounded on both sides by
   non-whitespace characters of an element, is not ignored.
  </para>
____________________________________________________________________________-->
  <para>
   我们可以在左括号前面或右括号后面增加空白。我们也可以在任何单独的项之前或之后加上空白。在所有这些情况中空白将被忽略。但是，在被使用了双引号的元素中的空白以及周围有其他非空白字符的空白不会被忽略。
  </para>

 <tip>
<!--==========================orignal english content==========================
  <para>
   The <literal>ARRAY</literal> constructor syntax (see
   <xref linkend="sql-syntax-array-constructors"/>) is often easier to work
   with than the array-literal syntax when writing array values in SQL
   commands. In <literal>ARRAY</literal>, individual element values are written the
   same way they would be written when not members of an array.
  </para>
____________________________________________________________________________-->
  <para>
   在SQL命令中写数组值时，<literal>ARRAY</literal>构造器语法（见<xref linkend="sql-syntax-array-constructors"/>）常常比数组文字语法要更容易使用。在<literal>ARRAY</literal>中，单独的元素值可以使用不属于数组成员时的方式来书写。
  </para>
 </tip>
 </sect2>

</sect1>
