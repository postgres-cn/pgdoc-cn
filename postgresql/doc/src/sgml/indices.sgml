<!-- doc/src/sgml/indices.sgml -->

<chapter id="indexes">
<!--==========================orignal english content==========================
 <title>Indexes</title>
____________________________________________________________________________-->
 <title>索引</title>

<!--==========================orignal english content==========================
 <indexterm zone="indexes">
  <primary>index</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="indexes">
  <primary>索引</primary>
 </indexterm>

<!--==========================orignal english content==========================
 <para>
  Indexes are a common way to enhance database performance.  An index
  allows the database server to find and retrieve specific rows much
  faster than it could do without an index.  But indexes also add
  overhead to the database system as a whole, so they should be used
  sensibly.
 </para>
____________________________________________________________________________-->
 <para>
  索引是提高数据库性能的常用途径。比起没有索引，使用索引可以让数据库服务器更快找到并获取特定行。但是索引同时也会增加数据库系统的日常管理负担，因此我们应该聪明地使用索引。
 </para>


 <sect1 id="indexes-intro">
<!--==========================orignal english content==========================
  <title>Introduction</title>
____________________________________________________________________________-->
  <title>简介</title>

<!--==========================orignal english content==========================
  <para>
   Suppose we have a table similar to this:
<programlisting>
CREATE TABLE test1 (
    id integer,
    content varchar
);
</programlisting>
   and the application issues many queries of the form:
<programlisting>
SELECT content FROM test1 WHERE id = <replaceable>constant</replaceable>;
</programlisting>
   With no advance preparation, the system would have to scan the entire
   <structname>test1</structname> table, row by row, to find all
   matching entries.  If there are many rows in
   <structname>test1</structname> and only a few rows (perhaps zero
   or one) that would be returned by such a query, this is clearly an
   inefficient method.  But if the system has been instructed to maintain an
   index on the <structfield>id</structfield> column, it can use a more
   efficient method for locating matching rows.  For instance, it
   might only have to walk a few levels deep into a search tree.
  </para>
____________________________________________________________________________-->
  <para>
   假设我们有一个如下的表：
<programlisting>
CREATE TABLE test1 (
    id integer,
    content varchar
);
</programlisting>
   而应用发出很多以下形式的查询：
<programlisting>
SELECT content FROM test1 WHERE id = <replaceable>constant</replaceable>;
</programlisting>
   在没有事前准备的情况下，系统不得不扫描整个<structname>test1</structname>表，一行一行地去找到所有匹配的项。如果<structname>test1</structname>中有很多行但是只有一小部分行（可能是0或者1）需要被该查询返回，这显然是一种低效的方式。但是如果系统被指示维护一个在<structfield>id</structfield>列上的索引，它就能使用一种更有效的方式来定位匹配行。例如，它可能仅仅需要遍历一棵搜索树的几层而已。
  </para>

<!--==========================orignal english content==========================
  <para>
   A similar approach is used in most non-fiction books:  terms and
   concepts that are frequently looked up by readers are collected in
   an alphabetic index at the end of the book.  The interested reader
   can scan the index relatively quickly and flip to the appropriate
   page(s), rather than having to read the entire book to find the
   material of interest.  Just as it is the task of the author to
   anticipate the items that readers are likely to look up,
   it is the task of the database programmer to foresee which indexes
   will be useful.
  </para>
____________________________________________________________________________-->
  <para>
   类似的方法也被用于大部分非小说书籍中：经常被读者查找的术语和概念被收集在一个字母序索引中放在书籍的末尾。感兴趣的读者可以相对快地扫描索引并跳到合适的页而不需要阅读整本书来寻找感兴趣的材料。正如作者的任务是准备好读者可能会查找的术语一样，数据库程序员也需要预见哪些索引会有用。
  </para>

<!--==========================orignal english content==========================
  <para>
   The following command can be used to create an index on the
   <structfield>id</structfield> column, as discussed:
<programlisting>
CREATE INDEX test1_id_index ON test1 (id);
</programlisting>
   The name <structname>test1_id_index</structname> can be chosen
   freely, but you should pick something that enables you to remember
   later what the index was for.
  </para>
____________________________________________________________________________-->
  <para>
   正如前面讨论的，下列命令可以用来在<structfield>id</structfield>列上创建一个索引：
<programlisting>
CREATE INDEX test1_id_index ON test1 (id);
</programlisting>
   索引的名字<structname>test1_id_index</structname>可以自由选择，但我们最好选择一个能让我们想起该索引用途的名字。
  </para>

<!--==========================orignal english content==========================
  <para>
   To remove an index, use the <command>DROP INDEX</command> command.
   Indexes can be added to and removed from tables at any time.
  </para>
____________________________________________________________________________-->
  <para>
   为了移除一个索引，可以使用<command>DROP INDEX</command>命令。索引可以随时被创建或删除。
  </para>

<!--==========================orignal english content==========================
  <para>
   Once an index is created, no further intervention is required: the
   system will update the index when the table is modified, and it will
   use the index in queries when it thinks doing so would be more efficient
   than a sequential table scan.  But you might have to run the
   <command>ANALYZE</command> command regularly to update
   statistics to allow the query planner to make educated decisions.
   See <xref linkend="performance-tips"/> for information about
   how to find out whether an index is used and when and why the
   planner might choose <emphasis>not</emphasis> to use an index.
  </para>
____________________________________________________________________________-->
  <para>
   一旦一个索引被创建，就不再需要进一步的干预：系统会在表更新时更新索引，而且会在它觉得使用索引比顺序扫描表效率更高时使用索引。但我们可能需要定期地运行<command>ANALYZE</command>命令来更新统计信息以便查询规划器能做出正确的决定。通过<xref linkend="performance-tips"/>的信息可以了解如何找出一个索引是否被使用以及规划器在何时以及为什么会选择<emphasis>不</emphasis>使用索引。
  </para>

<!--==========================orignal english content==========================
  <para>
   Indexes can also benefit <command>UPDATE</command> and
   <command>DELETE</command> commands with search conditions.
   Indexes can moreover be used in join searches.  Thus,
   an index defined on a column that is part of a join condition can
   also significantly speed up queries with joins.
  </para>
____________________________________________________________________________-->
  <para>
   索引也会使带有搜索条件的<command>UPDATE</command>和<command>DELETE</command>命令受益。此外索引还可以在连接搜索中使用。因此，一个定义在连接条件列上的索引可以显著地提高连接查询的速度。
  </para>

<!--==========================orignal english content==========================
  <para>
   Creating an index on a large table can take a long time.  By default,
   <productname>PostgreSQL</productname> allows reads (<command>SELECT</command> statements) to occur
   on the table in parallel with index creation, but writes (<command>INSERT</command>,
   <command>UPDATE</command>, <command>DELETE</command>) are blocked until the index build is finished.
   In production environments this is often unacceptable.
   It is possible to allow writes to occur in parallel with index
   creation, but there are several caveats to be aware of &mdash;
   for more information see <xref linkend="sql-createindex-concurrently"/>.
  </para>
____________________________________________________________________________-->
  <para>
   在一个大表上创建一个索引会耗费很长的时间。默认情况下，<productname>PostgreSQL</productname>允许在索引创建时并行地进行读（<command>SELECT</command>命令），但写（<command>INSERT</command>、<command>UPDATE</command>和<command>DELETE</command>）则会被阻塞直到索引创建完成。在生产环境中这通常是不可接受的。在创建索引时允许并行的写是可能的，但是有些警告需要注意，更多信息可以参考<xref linkend="sql-createindex-concurrently"/>。
  </para>

<!--==========================orignal english content==========================
  <para>
   After an index is created, the system has to keep it synchronized with the
   table.  This adds overhead to data manipulation operations.
   Therefore indexes that are seldom or never used in queries
   should be removed.
  </para>
____________________________________________________________________________-->
  <para>
   一个索引被创建后，系统必须保持它与表同步。这增加了数据操作的负担。因此那些很少或从不在查询中使用的索引应该被移除。
  </para>
 </sect1>


 <sect1 id="indexes-types">
<!--==========================orignal english content==========================
  <title>Index Types</title>
____________________________________________________________________________-->
  <title>索引类型</title>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname> provides several index types:
   B-tree, Hash, GiST, SP-GiST, GIN and BRIN.
   Each index type uses a different
   algorithm that is best suited to different types of queries.
   By default, the <command>CREATE INDEX</command> command creates
   B-tree indexes, which fit the most common situations.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>提供了多种索引类型：
   B-tree、Hash、GiST、SP-GiST 、GIN 和 BRIN。每一种索引类型使用了
   一种不同的算法来适应不同类型的查询。默认情况下，
   <command>CREATE INDEX</command>命令创建适合于大部分情况的B-tree 索引。
  </para>

<!--==========================orignal english content==========================
  <para>
   <indexterm>
    <primary>index</primary>
    <secondary>B-tree</secondary>
   </indexterm>
   <indexterm>
    <primary>B-tree</primary>
    <see>index</see>
   </indexterm>
   B-trees can handle equality and range queries on data that can be sorted
   into some ordering.
   In particular, the <productname>PostgreSQL</productname> query planner
   will consider using a B-tree index whenever an indexed column is
   involved in a comparison using one of these operators:

   <simplelist>
    <member><literal>&lt;</literal></member>
    <member><literal>&lt;=</literal></member>
    <member><literal>=</literal></member>
    <member><literal>&gt;=</literal></member>
    <member><literal>&gt;</literal></member>
   </simplelist>

   Constructs equivalent to combinations of these operators, such as
   <literal>BETWEEN</literal> and <literal>IN</literal>, can also be implemented with
   a B-tree index search.  Also, an <literal>IS NULL</literal> or <literal>IS NOT
   NULL</literal> condition on an index column can be used with a B-tree index.
  </para>
____________________________________________________________________________-->
  <para>
   <indexterm>
    <primary>index</primary>
    <secondary>B-tree</secondary>
   </indexterm>
   <indexterm>
    <primary>B-tree</primary>
    <see>index</see>
   </indexterm>
   B-tree可以在可排序数据上的处理等值和范围查询。特别地，<productname>PostgreSQL</productname>的查询规划器会在任何一种涉及到以下操作符的已索引列上考虑使用B-tree索引：

   <simplelist>
    <member><literal>&lt;</literal></member>
    <member><literal>&lt;=</literal></member>
    <member><literal>=</literal></member>
    <member><literal>&gt;=</literal></member>
    <member><literal>&gt;</literal></member>
   </simplelist>

   将这些操作符组合起来，例如<literal>BETWEEN</literal>和<literal>IN</literal>，也可以用B-tree索引搜索实现。同样，在索引列上的<literal>IS NULL</literal>或<literal>IS NOT
   NULL</literal>条件也可以在B-tree索引中使用。
  </para>

<!--==========================orignal english content==========================
  <para>
   The optimizer can also use a B-tree index for queries involving the
   pattern matching operators <literal>LIKE</literal> and <literal>~</literal>
   <emphasis>if</emphasis> the pattern is a constant and is anchored to
   the beginning of the string &mdash; for example, <literal>col LIKE
   'foo%'</literal> or <literal>col ~ '^foo'</literal>, but not
   <literal>col LIKE '%bar'</literal>. However, if your database does not
   use the C locale you will need to create the index with a special
   operator class to support indexing of pattern-matching queries; see
   <xref linkend="indexes-opclass"/> below. It is also possible to use
   B-tree indexes for <literal>ILIKE</literal> and
   <literal>~*</literal>, but only if the pattern starts with
   non-alphabetic characters, i.e., characters that are not affected by
   upper/lower case conversion.
  </para>
____________________________________________________________________________-->
  <para>
   优化器也会将B-tree索引用于涉及到模式匹配操作符<literal>LIKE</literal>和<literal>~</literal> 的查询，前提是<emphasis>如果</emphasis>模式是一个常量且被固定在字符串的开头&mdash;例如：<literal>col LIKE
   'foo%'</literal>或者<literal>col ~ '^foo'</literal>, 但在<literal>col LIKE '%bar'</literal>上则不会。但是，如果我们的数据库没有使用C区域设置，我们需要创建一个具有特殊操作符类的索引来支持模式匹配查询，参见下面的<xref linkend="indexes-opclass"/>。同样可以将B-tree索引用于<literal>ILIKE</literal>和<literal>~*</literal>，但仅当模式以非字母字符开始，即不受大小写转换影响的字符。
  </para>

<!--==========================orignal english content==========================
  <para>
   B-tree indexes can also be used to retrieve data in sorted order.
   This is not always faster than a simple scan and sort, but it is
   often helpful.
  </para>
____________________________________________________________________________-->
  <para>
   B-tree索引也可以用于检索排序数据。这并不会总是比简单扫描和排序更快，但是总是有用的。
  </para>

<!--==========================orignal english content==========================
  <para>
   <indexterm>
    <primary>index</primary>
    <secondary>hash</secondary>
   </indexterm>
   <indexterm>
    <primary>hash</primary>
    <see>index</see>
   </indexterm>
   Hash indexes can only handle simple equality comparisons.
   The query planner will consider using a hash index whenever an
   indexed column is involved in a comparison using the
   <literal>=</literal> operator.
   The following command is used to create a hash index:
<synopsis>
CREATE INDEX <replaceable>name</replaceable> ON <replaceable>table</replaceable> USING HASH (<replaceable>column</replaceable>);
</synopsis>
  </para>
____________________________________________________________________________-->
  <para>
   <indexterm>
    <primary>index</primary>
    <secondary>hash</secondary>
   </indexterm>
   <indexterm>
    <primary>hash</primary>
    <see>index</see>
   </indexterm>
   Hash索引只能处理简单等值比较。不论何时当一个索引列涉及到一个使用了<literal>=</literal>操作符的比较时，查询规划器将考虑使用一个Hash索引。下面的命令将创建一个Hash索引：
<synopsis>
CREATE INDEX <replaceable>name</replaceable> ON <replaceable>table</replaceable> USING HASH (<replaceable>column</replaceable>);
</synopsis>
  </para>

<!--==========================orignal english content==========================
  <para>
   <indexterm>
    <primary>index</primary>
    <secondary>GiST</secondary>
   </indexterm>
   <indexterm>
    <primary>GiST</primary>
    <see>index</see>
   </indexterm>
   GiST indexes are not a single kind of index, but rather an infrastructure
   within which many different indexing strategies can be implemented.
   Accordingly, the particular operators with which a GiST index can be
   used vary depending on the indexing strategy (the <firstterm>operator
   class</firstterm>).  As an example, the standard distribution of
   <productname>PostgreSQL</productname> includes GiST operator classes
   for several two-dimensional geometric data types, which support indexed
   queries using these operators:

   <simplelist>
    <member><literal>&lt;&lt;</literal></member>
    <member><literal>&amp;&lt;</literal></member>
    <member><literal>&amp;&gt;</literal></member>
    <member><literal>&gt;&gt;</literal></member>
    <member><literal>&lt;&lt;|</literal></member>
    <member><literal>&amp;&lt;|</literal></member>
    <member><literal>|&amp;&gt;</literal></member>
    <member><literal>|&gt;&gt;</literal></member>
    <member><literal>@&gt;</literal></member>
    <member><literal>&lt;@</literal></member>
    <member><literal>~=</literal></member>
    <member><literal>&amp;&amp;</literal></member>
   </simplelist>

   (See <xref linkend="functions-geometry"/> for the meaning of
   these operators.)
   The GiST operator classes included in the standard distribution are
   documented in <xref linkend="gist-builtin-opclasses-table"/>.
   Many other GiST operator
   classes are available in the <literal>contrib</literal> collection or as separate
   projects.  For more information see <xref linkend="gist"/>.
  </para>
____________________________________________________________________________-->
  <para>
   <indexterm>
    <primary>index</primary>
    <secondary>GiST</secondary>
   </indexterm>
   <indexterm>
    <primary>GiST</primary>
    <see>index</see>
   </indexterm>
   GiST索引并不是一种单独的索引，而是可以用于实现很多不同索引策略的基础设施。相应地，可以使用一个GiST索引的特定操作符根据索引策略（<firstterm>操作符类</firstterm>）而变化。作为一个例子，<productname>PostgreSQL</productname>的标准捐献包中包括了用于多种二维几何数据类型的GiST操作符类，它用来支持使用下列操作符的索引化查询：

   <simplelist>
    <member><literal>&lt;&lt;</literal></member>
    <member><literal>&amp;&lt;</literal></member>
    <member><literal>&amp;&gt;</literal></member>
    <member><literal>&gt;&gt;</literal></member>
    <member><literal>&lt;&lt;|</literal></member>
    <member><literal>&amp;&lt;|</literal></member>
    <member><literal>|&amp;&gt;</literal></member>
    <member><literal>|&gt;&gt;</literal></member>
    <member><literal>@&gt;</literal></member>
    <member><literal>&lt;@</literal></member>
    <member><literal>~=</literal></member>
    <member><literal>&amp;&amp;</literal></member>
   </simplelist>

   （这些操作符的含义见<xref linkend="functions-geometry"/>）<xref linkend="gist-builtin-opclasses-table"/>中给出了标准发布中所包括的 GiST 操作符类。<literal>contrib</literal>集合中还包括了很多其他GiST操作符类，可见<xref linkend="gist"/>。
  </para>

<!--==========================orignal english content==========================
  <para>
   GiST indexes are also capable of optimizing <quote>nearest-neighbor</quote>
   searches, such as
<programlisting><![CDATA[
SELECT * FROM places ORDER BY location <-> point '(101,456)' LIMIT 10;
]]>
</programlisting>
   which finds the ten places closest to a given target point.  The ability
   to do this is again dependent on the particular operator class being used.
   In <xref linkend="gist-builtin-opclasses-table"/>, operators that can be
   used in this way are listed in the column <quote>Ordering Operators</quote>.
  </para>
____________________________________________________________________________-->
  <para>
   GiST索引也有能力优化<quote>最近邻</quote>搜索，例如：
<programlisting><![CDATA[
SELECT * FROM places ORDER BY location <-> point '(101,456)' LIMIT 10;
]]>
</programlisting>
   它将找到离给定目标点最近的10个位置。能够支持这种查询的能力同样取决于被使用的特定操作符类。
   在<xref linkend="gist-builtin-opclasses-table"/>中，<quote>Ordering Operators</quote>列中列出了可以在这种方法中使用的操作符。
  </para>

<!--==========================orignal english content==========================
  <para>
   <indexterm>
    <primary>index</primary>
    <secondary>SP-GiST</secondary>
   </indexterm>
   <indexterm>
    <primary>SP-GiST</primary>
    <see>index</see>
   </indexterm>
   SP-GiST indexes, like GiST indexes, offer an infrastructure that supports
   various kinds of searches.  SP-GiST permits implementation of a wide range
   of different non-balanced disk-based data structures, such as quadtrees,
   k-d trees, and radix trees (tries).  As an example, the standard distribution of
   <productname>PostgreSQL</productname> includes SP-GiST operator classes
   for two-dimensional points, which support indexed
   queries using these operators:

   <simplelist>
    <member><literal>&lt;&lt;</literal></member>
    <member><literal>&gt;&gt;</literal></member>
    <member><literal>~=</literal></member>
    <member><literal>&lt;@</literal></member>
    <member><literal>&lt;^</literal></member>
    <member><literal>&gt;^</literal></member>
   </simplelist>

   (See <xref linkend="functions-geometry"/> for the meaning of
   these operators.)
   The SP-GiST operator classes included in the standard distribution are
   documented in <xref linkend="spgist-builtin-opclasses-table"/>.
   For more information see <xref linkend="spgist"/>.
  </para>
____________________________________________________________________________-->
  <para>
   <indexterm>
    <primary>index</primary>
    <secondary>SP-GiST</secondary>
   </indexterm>
   <indexterm>
    <primary>SP-GiST</primary>
    <see>index</see>
   </indexterm>
   和GiST相似，SP-GiST索引为支持多种搜索提供了一种基础结构。SP-GiST 允许实现众多不同的非平衡的基于磁盘的数据结构，例如四叉树、k-d树和radix树。作为一个例
子，<productname>PostgreSQL</productname>的标准捐献包中包含了一个用于二维点的SP-GiST操作符类，它用于支持使用下列操作符的索引化查询：

   <simplelist>
    <member><literal>&lt;&lt;</literal></member>
    <member><literal>&gt;&gt;</literal></member>
    <member><literal>~=</literal></member>
    <member><literal>&lt;@</literal></member>
    <member><literal>&lt;^</literal></member>
    <member><literal>&gt;^</literal></member>
   </simplelist>

   （其含义见<xref linkend="functions-geometry"/>）<xref linkend="spgist-builtin-opclasses-table"/>中给出了标准发布中所包括的 SP-GiST 操作符类。更多信息参见<xref linkend="spgist"/>。
  </para>

<!--==========================orignal english content==========================
  <para>
   Like GiST, SP-GiST supports <quote>nearest-neighbor</quote> searches.
   For SP-GiST operator classes that support distance ordering, the
   corresponding operator is specified in the <quote>Ordering Operators</quote>
   column in <xref linkend="spgist-builtin-opclasses-table"/>.
  </para>
____________________________________________________________________________-->
  <para>
   就像 GiST, SP-GiST 支持 <quote>nearest-neighbor</quote> 搜索.
   对于支持距离排序的 SP-GiST 运算符类别，相应的运算符被规定在<xref linkend="spgist-builtin-opclasses-table"/>里面的<quote>Ordering Operators</quote>列中。
  </para>

<!--==========================orignal english content==========================
  <para>
   <indexterm>
    <primary>index</primary>
    <secondary>GIN</secondary>
   </indexterm>
   <indexterm>
    <primary>GIN</primary>
    <see>index</see>
   </indexterm>
   GIN indexes are <quote>inverted indexes</quote> which are appropriate for
   data values that contain multiple component values, such as arrays.  An
   inverted index contains a separate entry for each component value, and
   can efficiently handle queries that test for the presence of specific
   component values.
  </para>
____________________________________________________________________________-->
  <para>
   <indexterm>
    <primary>index</primary>
    <secondary>GIN</secondary>
   </indexterm>
   <indexterm>
    <primary>GIN</primary>
    <see>index</see>
   </indexterm>
   GIN 索引是<quote>倒排索引</quote>，它适合于包含多个组成值的数据值，例如数组。倒排索引中为每一个组成值都包含一个单独的项，它可以高效地处理测试指定组成值是否存在的查询。
  </para>

<!--==========================orignal english content==========================
  <para>
   Like GiST and SP-GiST, GIN can support
   many different user-defined indexing strategies, and the particular
   operators with which a GIN index can be used vary depending on the
   indexing strategy.
   As an example, the standard distribution of
   <productname>PostgreSQL</productname> includes a GIN operator class
   for arrays, which supports indexed queries using these operators:

   <simplelist>
    <member><literal>&lt;@</literal></member>
    <member><literal>@&gt;</literal></member>
    <member><literal>=</literal></member>
    <member><literal>&amp;&amp;</literal></member>
   </simplelist>

   (See <xref linkend="functions-array"/> for the meaning of
   these operators.)
   The GIN operator classes included in the standard distribution are
   documented in <xref linkend="gin-builtin-opclasses-table"/>.
   Many other GIN operator
   classes are available in the <literal>contrib</literal> collection or as separate
   projects.  For more information see <xref linkend="gin"/>.
  </para>
____________________________________________________________________________-->
  <para>
   与 GiST 和 SP-GiST相似， GIN 可以支持多种不同的用户定义的索引策略，并且可以与一个 GIN 索引配合使用的特定操作符取决于索引策略。作为一个例子，<productname>PostgreSQL</productname>的标准贡献包中包含了用于数组的GIN操作符类，它用于支持使用下列操作符的索引化查询：

   <simplelist>
    <member><literal>&lt;@</literal></member>
    <member><literal>@&gt;</literal></member>
    <member><literal>=</literal></member>
    <member><literal>&amp;&amp;</literal></member>
   </simplelist>

   （这些操作符的含义见<xref linkend="functions-array"/>）<xref linkend="gin-builtin-opclasses-table"/>中给出了标准发布中所包括的 GIN 操作符类。在<literal>contrib</literal>集合中还有更多其他GIN操作符类，更多信息参见<xref linkend="gin"/>。
  </para>

<!--==========================orignal english content==========================
  <para>
   <indexterm>
    <primary>index</primary>
    <secondary>BRIN</secondary>
   </indexterm>
   <indexterm>
    <primary>BRIN</primary>
    <see>index</see>
   </indexterm>
   BRIN indexes (a shorthand for Block Range INdexes) store summaries about
   the values stored in consecutive physical block ranges of a table.
   Like GiST, SP-GiST and GIN,
   BRIN can support many different indexing strategies,
   and the particular operators with which a BRIN index can be used
   vary depending on the indexing strategy.
   For data types that have a linear sort order, the indexed data
   corresponds to the minimum and maximum values of the
   values in the column for each block range.  This supports indexed queries
   using these operators:

   <simplelist>
    <member><literal>&lt;</literal></member>
    <member><literal>&lt;=</literal></member>
    <member><literal>=</literal></member>
    <member><literal>&gt;=</literal></member>
    <member><literal>&gt;</literal></member>
   </simplelist>

   The BRIN operator classes included in the standard distribution are
   documented in <xref linkend="brin-builtin-opclasses-table"/>.
   For more information see <xref linkend="brin"/>.
  </para>
____________________________________________________________________________-->
  <para>
   <indexterm>
    <primary>index</primary>
    <secondary>BRIN</secondary>
   </indexterm>
   <indexterm>
    <primary>BRIN</primary>
    <see>index</see>
   </indexterm>
   BRIN 索引（块范围索引的缩写）存储有关存放在一个表的连续物理块范围上的值摘要信息。与 GiST、SP-GiST 和 GIN 相似，BRIN 可以支持很多种不同的索引策略，并且可以与一个 BRIN 索引配合使用的特定操作符取决于索引策略。对于具有线性排序顺序的数据类型，被索引的数据对应于每个块范围的列中值的最小值和最大值，使用这些操作符来支持用到索引的查询：

   <simplelist>
    <member><literal>&lt;</literal></member>
    <member><literal>&lt;=</literal></member>
    <member><literal>=</literal></member>
    <member><literal>&gt;=</literal></member>
    <member><literal>&gt;</literal></member>
   </simplelist>

   包括在标准发布中的 BRIN 操作符类的文档在<xref linkend="brin-builtin-opclasses-table"/>中。更多信息请见<xref linkend="brin"/>。
  </para>
 </sect1>


 <sect1 id="indexes-multicolumn">
<!--==========================orignal english content==========================
  <title>Multicolumn Indexes</title>
____________________________________________________________________________-->
  <title>多列索引</title>

<!--==========================orignal english content==========================
  <indexterm zone="indexes-multicolumn">
   <primary>index</primary>
   <secondary>multicolumn</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="indexes-multicolumn">
   <primary>index</primary>
   <secondary>multicolumn</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   An index can be defined on more than one column of a table.  For example, if
   you have a table of this form:
<programlisting>
CREATE TABLE test2 (
  major int,
  minor int,
  name varchar
);
</programlisting>
   (say, you keep your <filename class="directory">/dev</filename>
   directory in a database...) and you frequently issue queries like:
<programlisting>
SELECT name FROM test2 WHERE major = <replaceable>constant</replaceable> AND minor = <replaceable>constant</replaceable>;
</programlisting>
   then it might be appropriate to define an index on the columns
   <structfield>major</structfield> and
   <structfield>minor</structfield> together, e.g.:
<programlisting>
CREATE INDEX test2_mm_idx ON test2 (major, minor);
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   一个索引可以定义在表的多个列上。例如，我们有这样一个表：
<programlisting>
CREATE TABLE test2 (
  major int,
  minor int,
  name varchar
);
</programlisting>
   （即将我们的<filename class="directory">/dev</filename>目录保存在数据库中）而且我们经常会做如下形式的查询：
<programlisting>
SELECT name FROM test2 WHERE major = <replaceable>constant</replaceable> AND minor = <replaceable>constant</replaceable>;
</programlisting>
   那么我们可以在<structfield>major</structfield>和<structfield>minor</structfield>上定义一个索引：
<programlisting>
CREATE INDEX test2_mm_idx ON test2 (major, minor);
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Currently, only the B-tree, GiST, GIN, and BRIN
   index types support multicolumn
   indexes.  Up to 32 columns can be specified.  (This limit can be
   altered when building <productname>PostgreSQL</productname>; see the
   file <filename>pg_config_manual.h</filename>.)
  </para>
____________________________________________________________________________-->
  <para>
   目前，只有 B-tree、GiST、GIN 和 BRIN 索引类型支持多列索引，最多可以指定32个列（该限制可以在源代码文件<filename>pg_config_manual.h</filename>中修改，但是修改后需要重新编译<productname>PostgreSQL</productname>）。
  </para>

<!--==========================orignal english content==========================
  <para>
   A multicolumn B-tree index can be used with query conditions that
   involve any subset of the index's columns, but the index is most
   efficient when there are constraints on the leading (leftmost) columns.
   The exact rule is that equality constraints on leading columns, plus
   any inequality constraints on the first column that does not have an
   equality constraint, will be used to limit the portion of the index
   that is scanned.  Constraints on columns to the right of these columns
   are checked in the index, so they save visits to the table proper, but
   they do not reduce the portion of the index that has to be scanned.
   For example, given an index on <literal>(a, b, c)</literal> and a
   query condition <literal>WHERE a = 5 AND b &gt;= 42 AND c &lt; 77</literal>,
   the index would have to be scanned from the first entry with
   <literal>a</literal> = 5 and <literal>b</literal> = 42 up through the last entry with
   <literal>a</literal> = 5.  Index entries with <literal>c</literal> &gt;= 77 would be
   skipped, but they'd still have to be scanned through.
   This index could in principle be used for queries that have constraints
   on <literal>b</literal> and/or <literal>c</literal> with no constraint on <literal>a</literal>
   &mdash; but the entire index would have to be scanned, so in most cases
   the planner would prefer a sequential table scan over using the index.
  </para>
____________________________________________________________________________-->
  <para>
   一个B-tree索引可以用于条件中涉及到任意索引列子集的查询，但是当先导列（即最左边的那些列）上有约束条件时索引最为有效。确切的规则是：在先导列上的等值约束，加上第一个无等值约束的列上的不等值约束，将被用于限制索引被扫描的部分。在这些列右边的列上的约束将在索引中被检查，这样它们适当节约了对表的访问，但它们并未减小索引被扫描的部分。例如，在<literal>(a, b, c)</literal>上有一个索引并且给定一个查询条件<literal>WHERE a = 5 AND b &gt;= 42 AND c &lt; 77</literal>，对索引的扫描将从第一个具有<literal>a</literal> = 5和<literal>b</literal> = 42的项开始向上进行，直到最后一个具有<literal>a</literal> = 5的项。在扫描过程中，具有<literal>c</literal> &gt;= 77的索引项将被跳过，但是它们还是会被扫描到。这个索引在原则上可以被用于在<literal>b</literal>和/或<literal>c</literal>上有约束而在<literal>a</literal>上没有约束的查询，但是整个索引都不得不被扫描，因此在大部分情况下规划器宁可使用一个顺序的表扫描来替代索引。
  </para>

<!--==========================orignal english content==========================
  <para>
   A multicolumn GiST index can be used with query conditions that
   involve any subset of the index's columns. Conditions on additional
   columns restrict the entries returned by the index, but the condition on
   the first column is the most important one for determining how much of
   the index needs to be scanned.  A GiST index will be relatively
   ineffective if its first column has only a few distinct values, even if
   there are many distinct values in additional columns.
  </para>
____________________________________________________________________________-->
  <para>
   一个多列GiST索引可以用于条件中涉及到任意索引列子集的查询。在其余列上的条件将限制由索引返回的项，但是第一列上的条件是决定索引上扫描量的最重要因素。当第一列中具有很少的可区分值时，一个GiST索引将会相对比较低效，即便在其他列上有很多可区分值。
  </para>

<!--==========================orignal english content==========================
  <para>
   A multicolumn GIN index can be used with query conditions that
   involve any subset of the index's columns. Unlike B-tree or GiST,
   index search effectiveness is the same regardless of which index column(s)
   the query conditions use.
  </para>
____________________________________________________________________________-->
  <para>
   一个GIN索引可以用于条件中涉及到任意索引列子集的查询。与B-tree和GiST不同，GIN的搜索效率与查询条件中使用哪些索引列无关。
  </para>

<!--==========================orignal english content==========================
  <para>
   A multicolumn BRIN index can be used with query conditions that
   involve any subset of the index's columns. Like GIN and unlike B-tree or
   GiST, index search effectiveness is the same regardless of which index
   column(s) the query conditions use. The only reason to have multiple BRIN
   indexes instead of one multicolumn BRIN index on a single table is to have
   a different <literal>pages_per_range</literal> storage parameter.
  </para>
____________________________________________________________________________-->
  <para>
   多列 BRIN 索引可以被用于涉及该索引被索引列的任意子集的查询条件。和 GIN 相似且不同于 B-树 或者 GiST，索引搜索效率与查询条件使用哪个索引列无关。在单个表上使用多个 BRIN 索引来取代一个多列 BRIN 索引的唯一原因是为了使用不同的<literal>pages_per_range</literal>存储参数。
  </para>

<!--==========================orignal english content==========================
  <para>
   Of course, each column must be used with operators appropriate to the index
   type; clauses that involve other operators will not be considered.
  </para>
____________________________________________________________________________-->
  <para>
   当然，要使索引起作用，查询条件中的列必须要使用适合于索引类型的操作符，使用其他操作符的子句将不会被考虑使用索引。
  </para>

<!--==========================orignal english content==========================
  <para>
   Multicolumn indexes should be used sparingly.  In most situations,
   an index on a single column is sufficient and saves space and time.
   Indexes with more than three columns are unlikely to be helpful
   unless the usage of the table is extremely stylized.  See also
   <xref linkend="indexes-bitmap-scans"/> and
   <xref linkend="indexes-index-only-scans"/> for some discussion of the
   merits of different index configurations.
  </para>
____________________________________________________________________________-->
  <para>
   多列索引应该较少地使用。在绝大多数情况下，单列索引就足够了且能节约时间和空间。具有超过三个列的索引不太有用，除非该表的使用是极端程式化的。<xref linkend="indexes-bitmap-scans"/>以及<xref linkend="indexes-index-only-scans"/>中有对不同索引配置优点的讨论。
  </para>
 </sect1>


 <sect1 id="indexes-ordering">
<!--==========================orignal english content==========================
  <title>Indexes and <literal>ORDER BY</literal></title>
____________________________________________________________________________-->
  <title>索引和<literal>ORDER BY</literal></title>

<!--==========================orignal english content==========================
  <indexterm zone="indexes-ordering">
   <primary>index</primary>
   <secondary>and <literal>ORDER BY</literal></secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="indexes-ordering">
   <primary>index</primary>
   <secondary>and <literal>ORDER BY</literal></secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   In addition to simply finding the rows to be returned by a query,
   an index may be able to deliver them in a specific sorted order.
   This allows a query's <literal>ORDER BY</literal> specification to be honored
   without a separate sorting step.  Of the index types currently
   supported by <productname>PostgreSQL</productname>, only B-tree
   can produce sorted output &mdash; the other index types return
   matching rows in an unspecified, implementation-dependent order.
  </para>
____________________________________________________________________________-->
  <para>
   除了简单地查找查询要返回的行外，一个索引可能还需要将它们以指定的顺序传递。这使得查询中的<literal>ORDER BY</literal>不需要独立的排序步骤。在<productname>PostgreSQL</productname>当前支持的索引类型中，只有B-tree可以产生排序后的输出，其他索引类型会把行以一种没有指定的且与实现相关的顺序返回。
  </para>

<!--==========================orignal english content==========================
  <para>
   The planner will consider satisfying an <literal>ORDER BY</literal> specification
   either by scanning an available index that matches the specification,
   or by scanning the table in physical order and doing an explicit
   sort.  For a query that requires scanning a large fraction of the
   table, an explicit sort is likely to be faster than using an index
   because it requires
   less disk I/O due to following a sequential access pattern.  Indexes are
   more useful when only a few rows need be fetched.  An important
   special case is <literal>ORDER BY</literal> in combination with
   <literal>LIMIT</literal> <replaceable>n</replaceable>: an explicit sort will have to process
   all the data to identify the first <replaceable>n</replaceable> rows, but if there is
   an index matching the <literal>ORDER BY</literal>, the first <replaceable>n</replaceable>
   rows can be retrieved directly, without scanning the remainder at all.
  </para>
____________________________________________________________________________-->
  <para>
   规划器会考虑以两种方式来满足一个<literal>ORDER BY</literal>说明：扫描一个符合说明的可用索引，或者先以物理顺序扫描表然后再显式排序。对于一个需要扫描表的大部分的查询，一个显式的排序很可能比使用一个索引更快，因为其顺序访问模式使得它所需要的磁盘I/O更少。只有在少数行需要被取出时，索引才会更有用。一种重要的特殊情况是<literal>ORDER BY</literal>与<literal>LIMIT</literal> <replaceable>n</replaceable>联合使用：一个显式的排序将会处理所有的数据来确定最前面的<replaceable>n</replaceable>行，但如果有一个符合<literal>ORDER BY</literal>的索引，前<replaceable>n</replaceable>行将会被直接获取且根本不需要扫描剩下的数据。
  </para>

<!--==========================orignal english content==========================
  <para>
   By default, B-tree indexes store their entries in ascending order
   with nulls last (table TID is treated as a tiebreaker column among
   otherwise equal entries).  This means that a forward scan of an
   index on column <literal>x</literal> produces output satisfying <literal>ORDER BY x</literal>
   (or more verbosely, <literal>ORDER BY x ASC NULLS LAST</literal>).  The
   index can also be scanned backward, producing output satisfying
   <literal>ORDER BY x DESC</literal>
   (or more verbosely, <literal>ORDER BY x DESC NULLS FIRST</literal>, since
   <literal>NULLS FIRST</literal> is the default for <literal>ORDER BY DESC</literal>).
  </para>
____________________________________________________________________________-->
  <para>
   默认情况下，B-tree索引将它的项以升序方式存储，并将空值放在最后(表TID被处理为其它相等条目之间的分线器列)。这意味着对列<literal>x</literal>上索引的一次前向扫描将产生满足<literal>ORDER BY x</literal>（或者更长的形式：<literal>ORDER BY x ASC NULLS LAST</literal>）的结果。索引也可以被后向扫描，产生满足<literal>ORDER BY x DESC</literal>（<literal>ORDER BY x DESC NULLS FIRST</literal>， <literal>NULLS FIRST</literal>是<literal>ORDER BY DESC</literal>的默认情况）。
  </para>

<!--==========================orignal english content==========================
  <para>
   You can adjust the ordering of a B-tree index by including the
   options <literal>ASC</literal>, <literal>DESC</literal>, <literal>NULLS FIRST</literal>,
   and/or <literal>NULLS LAST</literal> when creating the index; for example:
<programlisting>
CREATE INDEX test2_info_nulls_low ON test2 (info NULLS FIRST);
CREATE INDEX test3_desc_index ON test3 (id DESC NULLS LAST);
</programlisting>
   An index stored in ascending order with nulls first can satisfy
   either <literal>ORDER BY x ASC NULLS FIRST</literal> or
   <literal>ORDER BY x DESC NULLS LAST</literal> depending on which direction
   it is scanned in.
  </para>
____________________________________________________________________________-->
  <para>
   我们可以在创建B-tree索引时通过<literal>ASC</literal>、<literal>DESC</literal>、<literal>NULLS FIRST</literal>和<literal>NULLS LAST</literal>选项来改变索引的排序，例如：
<programlisting>
CREATE INDEX test2_info_nulls_low ON test2 (info NULLS FIRST);
CREATE INDEX test3_desc_index ON test3 (id DESC NULLS LAST);
</programlisting>
   一个以升序存储且将空值前置的索引可以根据扫描方向来支持<literal>ORDER BY x ASC NULLS FIRST</literal>或 <literal>ORDER BY x DESC NULLS LAST</literal>。
  </para>

<!--==========================orignal english content==========================
  <para>
   You might wonder why bother providing all four options, when two
   options together with the possibility of backward scan would cover
   all the variants of <literal>ORDER BY</literal>.  In single-column indexes
   the options are indeed redundant, but in multicolumn indexes they can be
   useful.  Consider a two-column index on <literal>(x, y)</literal>: this can
   satisfy <literal>ORDER BY x, y</literal> if we scan forward, or
   <literal>ORDER BY x DESC, y DESC</literal> if we scan backward.
   But it might be that the application frequently needs to use
   <literal>ORDER BY x ASC, y DESC</literal>.  There is no way to get that
   ordering from a plain index, but it is possible if the index is defined
   as <literal>(x ASC, y DESC)</literal> or <literal>(x DESC, y ASC)</literal>.
  </para>
____________________________________________________________________________-->
  <para>
   读者可能会疑惑为什么要麻烦地提供所有四个选项，因为两个选项连同可能的后向扫描可以覆盖所有<literal>ORDER BY</literal>的变体。在单列索引中这些选项确实有冗余，但是在多列索引中它们却很有用。考虑<literal>(x, y)</literal>上的一个两列索引：它可以通过前向扫描满足<literal>ORDER BY x, y</literal>，或者通过后向扫描满足<literal>ORDER BY x DESC, y DESC</literal>。但是应用可能需要频繁地使用<literal>ORDER BY x ASC, y DESC</literal>。这样就没有办法从通常的索引中得到这种顺序，但是如果将索引定义为<literal>(x ASC, y DESC)</literal>或者<literal>(x DESC, y ASC)</literal>就可以产生这种排序。
  </para>

<!--==========================orignal english content==========================
  <para>
   Obviously, indexes with non-default sort orderings are a fairly
   specialized feature, but sometimes they can produce tremendous
   speedups for certain queries.  Whether it's worth maintaining such an
   index depends on how often you use queries that require a special
   sort ordering.
  </para>
____________________________________________________________________________-->
  <para>
   显然，具有非默认排序的索引是相当专门的特性，但是有时它们会为特定查询提供巨大的速度提升。是否值得维护这样一个索引取决于我们会多频繁地使用需要特殊排序的查询。
  </para>
 </sect1>


 <sect1 id="indexes-bitmap-scans">
<!--==========================orignal english content==========================
  <title>Combining Multiple Indexes</title>
____________________________________________________________________________-->
  <title>组合多个索引</title>

<!--==========================orignal english content==========================
  <indexterm zone="indexes-bitmap-scans">
   <primary>index</primary>
   <secondary>combining multiple indexes</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="indexes-bitmap-scans">
   <primary>index</primary>
   <secondary>combining multiple indexes</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm zone="indexes-bitmap-scans">
   <primary>bitmap scan</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="indexes-bitmap-scans">
   <primary>bitmap scan</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   A single index scan can only use query clauses that use the index's
   columns with operators of its operator class and are joined with
   <literal>AND</literal>.  For example, given an index on <literal>(a, b)</literal>
   a query condition like <literal>WHERE a = 5 AND b = 6</literal> could
   use the index, but a query like <literal>WHERE a = 5 OR b = 6</literal> could not
   directly use the index.
  </para>
____________________________________________________________________________-->
  <para>
   只有查询子句中在索引列上使用了索引操作符类中的操作符并且通过<literal>AND</literal>连接时才能使用单一索引。例如，给定一个<literal>(a, b)</literal> 上的索引，查询条件<literal>WHERE a = 5 AND b = 6</literal>可以使用该索引，而查询<literal>WHERE a = 5 OR b = 6</literal>不能直接使用该索引。
  </para>

<!--==========================orignal english content==========================
  <para>
   Fortunately,
   <productname>PostgreSQL</productname> has the ability to combine multiple indexes
   (including multiple uses of the same index) to handle cases that cannot
   be implemented by single index scans.  The system can form <literal>AND</literal>
   and <literal>OR</literal> conditions across several index scans.  For example,
   a query like <literal>WHERE x = 42 OR x = 47 OR x = 53 OR x = 99</literal>
   could be broken down into four separate scans of an index on <literal>x</literal>,
   each scan using one of the query clauses.  The results of these scans are
   then ORed together to produce the result.  Another example is that if we
   have separate indexes on <literal>x</literal> and <literal>y</literal>, one possible
   implementation of a query like <literal>WHERE x = 5 AND y = 6</literal> is to
   use each index with the appropriate query clause and then AND together
   the index results to identify the result rows.
  </para>
____________________________________________________________________________-->
  <para>
   幸运的是，<productname>PostgreSQL</productname>具有组合多个索引（包括多次使用同一个索引）的能力来处理那些不 能用单个索引扫描实现的情况。系统能在多个索引扫描之间安排<literal>AND</literal>和<literal>OR</literal>条件。例如， <literal>WHERE x = 42 OR x = 47 OR x = 53 OR x = 99</literal>这样一个查询可以被分解成为四个独立的在<literal>x</literal>上索引扫描，每一个扫描使用其中一个条件。这些查询的结果将被“或”起来形成最后的结果。另一个例子是如果我们在<literal>x</literal>和<literal>y</literal>上都有独立的索引，<literal>WHERE x = 5 AND y = 6</literal>这样的查询的一种可能的实现方式就是分别使用两个索引配合相应的条件，然后将结果“与”起来得到最后的结果行。
  </para>

<!--==========================orignal english content==========================
  <para>
   To combine multiple indexes, the system scans each needed index and
   prepares a <firstterm>bitmap</firstterm> in memory giving the locations of
   table rows that are reported as matching that index's conditions.
   The bitmaps are then ANDed and ORed together as needed by the query.
   Finally, the actual table rows are visited and returned.  The table rows
   are visited in physical order, because that is how the bitmap is laid
   out; this means that any ordering of the original indexes is lost, and
   so a separate sort step will be needed if the query has an <literal>ORDER
   BY</literal> clause.  For this reason, and because each additional index scan
   adds extra time, the planner will sometimes choose to use a simple index
   scan even though additional indexes are available that could have been
   used as well.
  </para>
____________________________________________________________________________-->
  <para>
   为了组合多个索引，系统扫描每一个所需的索引并在内存中准备一个<firstterm>位图</firstterm>用于指示表中符合索引条件的行的位置。然后这些位图会被根据查询的需要“与”和“或”起来。最后，实际的表行将被访问并返回。表行将被以物理顺序访问，因为位图就是以这种顺序布局的。这意味着原始索引中的任何排序都会被丢失，并且如果存在一个<literal>ORDER BY</literal>子句就需要一个单独的排序步骤。由于这个原因以及每一个附加的索引都需要额外的时间，即使有额外的索引可用，规划器有时也会选择使用单一索引扫描。
  </para>

<!--==========================orignal english content==========================
  <para>
   In all but the simplest applications, there are various combinations of
   indexes that might be useful, and the database developer must make
   trade-offs to decide which indexes to provide.  Sometimes multicolumn
   indexes are best, but sometimes it's better to create separate indexes
   and rely on the index-combination feature.  For example, if your
   workload includes a mix of queries that sometimes involve only column
   <literal>x</literal>, sometimes only column <literal>y</literal>, and sometimes both
   columns, you might choose to create two separate indexes on
   <literal>x</literal> and <literal>y</literal>, relying on index combination to
   process the queries that use both columns.  You could also create a
   multicolumn index on <literal>(x, y)</literal>.  This index would typically be
   more efficient than index combination for queries involving both
   columns, but as discussed in <xref linkend="indexes-multicolumn"/>, it
   would be almost useless for queries involving only <literal>y</literal>, so it
   should not be the only index.  A combination of the multicolumn index
   and a separate index on <literal>y</literal> would serve reasonably well.  For
   queries involving only <literal>x</literal>, the multicolumn index could be
   used, though it would be larger and hence slower than an index on
   <literal>x</literal> alone.  The last alternative is to create all three
   indexes, but this is probably only reasonable if the table is searched
   much more often than it is updated and all three types of query are
   common.  If one of the types of query is much less common than the
   others, you'd probably settle for creating just the two indexes that
   best match the common types.
  </para>
____________________________________________________________________________-->
  <para>
   在所有的应用（除了最简单的应用）中，可能会有多种有用的索引组合，数据库开发人员必须做出权衡以决定提供哪些索引。有时候多列索引最好，但是有时更好的选择是创建单独的索引并依赖于索引组合特性。例如，如果我们的查询中有时只涉及到列<literal>x</literal>，有时候只涉及到列<literal>y</literal>，还有时候会同时涉及到两列，我们可以选择在x和y上创建两个独立索引然后依赖索引组合来处理同时涉及到两列的查询。我们当然也可以创建一个<literal>(x, y)</literal>上的多列索引。当查询同时涉及到两列时，该索引会比组合索引效率更高，但是正如<xref linkend="indexes-multicolumn"/>中讨论的，它在只涉及到y的查询中几乎完全无用，因此它不能是唯一的一个索引。一个多列索引和一个<literal>y</literal>上的独立索引的组合将会工作得很好。多列索引可以用于那些只涉及到<literal>x</literal>的查询，尽管它比<literal>x</literal>上的独立索引更大且更慢。最后一种选择是创建所有三个索引，但是这种选择最适合表经常被执行所有三种查询但是很少被更新的情况。如果其中一种查询要明显少于其他类型的查询，我们可能需要只为常见类型的查询创建两个索引。
  </para>

 </sect1>


 <sect1 id="indexes-unique">
<!--==========================orignal english content==========================
  <title>Unique Indexes</title>
____________________________________________________________________________-->
  <title>唯一索引</title>

<!--==========================orignal english content==========================
  <indexterm zone="indexes-unique">
   <primary>index</primary>
   <secondary>unique</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="indexes-unique">
   <primary>index</primary>
   <secondary>unique</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   Indexes can also be used to enforce uniqueness of a column's value,
   or the uniqueness of the combined values of more than one column.
<synopsis>
CREATE UNIQUE INDEX <replaceable>name</replaceable> ON <replaceable>table</replaceable> (<replaceable>column</replaceable> <optional>, ...</optional>);
</synopsis>
   Currently, only B-tree indexes can be declared unique.
  </para>
____________________________________________________________________________-->
  <para>
   索引也可以被用来强制列值的唯一性，或者是多个列组合值的唯一性。
<synopsis>
CREATE UNIQUE INDEX <replaceable>name</replaceable> ON <replaceable>table</replaceable> (<replaceable>column</replaceable> <optional>, ...</optional>);
</synopsis>
   当前，只有B-tree能够被声明为唯一。
  </para>

<!--==========================orignal english content==========================
  <para>
   When an index is declared unique, multiple table rows with equal
   indexed values are not allowed.  Null values are not considered
   equal.  A multicolumn unique index will only reject cases where all
   indexed columns are equal in multiple rows.
  </para>
____________________________________________________________________________-->
  <para>
   当一个索引被声明为唯一时，索引中不允许多个表行具有相同的索引值。空值被视为不相同。一个多列唯一索引将会拒绝在所有索引列上具有相同组合值的表行。
  </para>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname> automatically creates a unique
   index when a unique constraint or primary key is defined for a table.
   The index covers the columns that make up the primary key or unique
   constraint (a multicolumn index, if appropriate), and is the mechanism
   that enforces the constraint.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>会自动为定义了一个唯一约束或主键的表创建一个唯一索引。该索引包含组成主键或唯一约束的所有列（可能是一个多列索引），它也是用于强制这些约束的机制。
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    There's no need to manually
    create indexes on unique columns; doing so would just duplicate
    the automatically-created index.
   </para>
____________________________________________________________________________-->
   <para>
    不需要手工在唯一列上创建索引，如果那样做也只是重复了自动创建的索引而已。
   </para>
  </note>
 </sect1>


 <sect1 id="indexes-expressional">
<!--==========================orignal english content==========================
  <title>Indexes on Expressions</title>
____________________________________________________________________________-->
  <title>表达式索引</title>

<!--==========================orignal english content==========================
  <indexterm zone="indexes-expressional">
   <primary>index</primary>
   <secondary sortas="expressions">on expressions</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="indexes-expressional">
   <primary>index</primary>
   <secondary sortas="expressions">on expressions</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   An index column need not be just a column of the underlying table,
   but can be a function or scalar expression computed from one or
   more columns of the table.  This feature is useful to obtain fast
   access to tables based on the results of computations.
  </para>
____________________________________________________________________________-->
  <para>
   一个索引列并不一定是底层表的一个列，也可以是从表的一列或多列计算而来的一个函数或者标量表达式。这种特性对于根据计算结果快速获取表中内容是有用的。
  </para>

<!--==========================orignal english content==========================
  <para>
   For example, a common way to do case-insensitive comparisons is to
   use the <function>lower</function> function:
<programlisting>
SELECT * FROM test1 WHERE lower(col1) = 'value';
</programlisting>
   This query can use an index if one has been
   defined on the result of the <literal>lower(col1)</literal>
   function:
<programlisting>
CREATE INDEX test1_lower_col1_idx ON test1 (lower(col1));
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   例如，一种进行大小写不敏感比较的常用方法是使用<function>lower</function>函数：
<programlisting>
SELECT * FROM test1 WHERE lower(col1) = 'value';
</programlisting>
   这种查询可以利用一个建立在<literal>lower(col1)</literal>函数结果之上的索引：
<programlisting>
CREATE INDEX test1_lower_col1_idx ON test1 (lower(col1));
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   If we were to declare this index <literal>UNIQUE</literal>, it would prevent
   creation of rows whose <literal>col1</literal> values differ only in case,
   as well as rows whose <literal>col1</literal> values are actually identical.
   Thus, indexes on expressions can be used to enforce constraints that
   are not definable as simple unique constraints.
  </para>
____________________________________________________________________________-->
  <para>
   如果我们将该索引声明为<literal>UNIQUE</literal>，它将阻止创建在<literal>col1</literal>值上只有大小写不同的行。
  </para>

<!--==========================orignal english content==========================
  <para>
   As another example, if one often does queries like:
<programlisting>
SELECT * FROM people WHERE (first_name || ' ' || last_name) = 'John Smith';
</programlisting>
   then it might be worth creating an index like this:
<programlisting>
CREATE INDEX people_names ON people ((first_name || ' ' || last_name));
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   另外一个例子，如果我们经常进行如下的查询：
<programlisting>
SELECT * FROM people WHERE (first_name || ' ' || last_name) = 'John Smith';
</programlisting>
   那么值得创建一个这样的索引：
<programlisting>
CREATE INDEX people_names ON people ((first_name || ' ' || last_name));
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   The syntax of the <command>CREATE INDEX</command> command normally requires
   writing parentheses around index expressions, as shown in the second
   example.  The parentheses can be omitted when the expression is just
   a function call, as in the first example.
  </para>
____________________________________________________________________________-->
  <para>
   正如第二个例子所示，<command>CREATE INDEX</command>命令的语法通常要求在被索引的表达式周围书写圆括号。而如第一个例子所示，当表达式只是一个函数调用时可以省略掉圆括号。
  </para>

<!--==========================orignal english content==========================
  <para>
   Index expressions are relatively expensive to maintain, because the
   derived expression(s) must be computed for each row upon insertion
   and whenever it is updated.  However, the index expressions are
   <emphasis>not</emphasis> recomputed during an indexed search, since they are
   already stored in the index.  In both examples above, the system
   sees the query as just <literal>WHERE indexedcolumn = 'constant'</literal>
   and so the speed of the search is equivalent to any other simple index
   query.  Thus, indexes on expressions are useful when retrieval speed
   is more important than insertion and update speed.
  </para>
____________________________________________________________________________-->
  <para>
   索引表达式的维护代价较为昂贵，因为在每一个行被插入或更新时都得为它重新计算相应的表达式。然而，索引表达式在进行索引搜索时却<emphasis>不</emphasis>需要重新计算，因为它们的结果已经被存储在索引中了。在上面两个例子中，系统将会发现查询的条件是<literal>WHERE indexedcolumn = 'constant'</literal>，因此查询的速度将等同于其他简单索引查询。因此，表达式索引对于检索速度远比插入和更新速度重要的情况非常有用。
  </para>
 </sect1>


 <sect1 id="indexes-partial">
<!--==========================orignal english content==========================
  <title>Partial Indexes</title>
____________________________________________________________________________-->
  <title>部分索引</title>

<!--==========================orignal english content==========================
  <indexterm zone="indexes-partial">
   <primary>index</primary>
   <secondary>partial</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="indexes-partial">
   <primary>index</primary>
   <secondary>partial</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   A <firstterm>partial index</firstterm> is an index built over a
   subset of a table; the subset is defined by a conditional
   expression (called the <firstterm>predicate</firstterm> of the
   partial index).  The index contains entries only for those table
   rows that satisfy the predicate.  Partial indexes are a specialized
   feature, but there are several situations in which they are useful.
  </para>
____________________________________________________________________________-->
  <para>
   一个<firstterm>部分索引</firstterm>是建立在表的一个子集上，而该子集则由一个条件表达式（被称为部分索引的<firstterm>谓词</firstterm>）定义。而索引中只包含那些符合该谓词的表行的项。部分索引是一种专门的特性，但在很多种情况下它们也很有用。
  </para>

<!--==========================orignal english content==========================
  <para>
   One major reason for using a partial index is to avoid indexing common
   values.  Since a query searching for a common value (one that
   accounts for more than a few percent of all the table rows) will not
   use the index anyway, there is no point in keeping those rows in the
   index at all.  This reduces the size of the index, which will speed
   up those queries that do use the index.  It will also speed up many table
   update operations because the index does not need to be
   updated in all cases.  <xref linkend="indexes-partial-ex1"/> shows a
   possible application of this idea.
  </para>
____________________________________________________________________________-->
  <para>
   使用部分索引的一个主要原因是避免索引公值。由于搜索一个公值的查询（一个在所有表行中占比超过一定百分比的值）不会使用索引，所以完全没有理由将这些行保留在索引中。这可以减小索引的尺寸，同时也将加速使用索引的查询。它也将加速很多表更新操作，因为这种索引并不需要在所有情况下都被更新。<xref linkend="indexes-partial-ex1"/>展示了一种可能的应用：
  </para>

  <example id="indexes-partial-ex1">
<!--==========================orignal english content==========================
   <title>Setting up a Partial Index to Exclude Common Values</title>
____________________________________________________________________________-->
   <title>建立一个部分索引来排除公值</title>

<!--==========================orignal english content==========================
   <para>
    Suppose you are storing web server access logs in a database.
    Most accesses originate from the IP address range of your organization but
    some are from elsewhere (say, employees on dial-up connections).
    If your searches by IP are primarily for outside accesses,
    you probably do not need to index the IP range that corresponds to your
    organization's subnet.
   </para>
____________________________________________________________________________-->
   <para>
    假设我们要在一个数据库中保存网页服务器访问日志。大部分访问都来自于我们组织内的IP地址，但是有些来自于其他地方（如使用拨号连接的员工）。如果我们主要通过IP搜索来自于外部的访问，我们就没有必要索引对应于我们组织内网的IP范围。
   </para>

<!--==========================orignal english content==========================
   <para>
    Assume a table like this:
<programlisting>
CREATE TABLE access_log (
    url varchar,
    client_ip inet,
    ...
);
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    假设有这样一个表：
<programlisting>
CREATE TABLE access_log (
    url varchar,
    client_ip inet,
    ...
);
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    To create a partial index that suits our example, use a command
    such as this:
<programlisting>
CREATE INDEX access_log_client_ip_ix ON access_log (client_ip)
WHERE NOT (client_ip &gt; inet '192.168.100.0' AND
           client_ip &lt; inet '192.168.100.255');
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    用以下命令可以创建适用于我们的部分索引：
<programlisting>
CREATE INDEX access_log_client_ip_ix ON access_log (client_ip)
WHERE NOT (client_ip &gt; inet '192.168.100.0' AND
           client_ip &lt; inet '192.168.100.255');
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    A typical query that can use this index would be:
<programlisting>
SELECT *
FROM access_log
WHERE url = '/index.html' AND client_ip = inet '212.78.10.32';
</programlisting>
    Here the query's IP address is covered by the partial index.  The
    following query cannot use the partial index, as it uses an IP address
    that is excluded from the index:
<programlisting>
SELECT *
FROM access_log
WHERE url = '/index.html' AND client_ip = inet '192.168.100.23';
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    一个使用该索引的典型查询是：
<programlisting>
SELECT *
FROM access_log
WHERE url = '/index.html' AND client_ip = inet '212.78.10.32';
</programlisting>
    此处查询的IP地址由部分索引覆盖。以下查询无法使用部分索引，因为它使用从索引中排除的 IP 地址：
<programlisting>
SELECT *
FROM access_log
WHERE url = '/index.html' AND client_ip = inet '192.168.100.23';
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    Observe that this kind of partial index requires that the common
    values be predetermined, so such partial indexes are best used for
    data distributions that do not change.  Such indexes can be recreated
    occasionally to adjust for new data distributions, but this adds
    maintenance effort.
   </para>
____________________________________________________________________________-->
   <para>
    可以看到部分索引查询要求公值能被预知，因此部分索引最适合于数据分布不会改变的情况。这样的索引也可以偶尔被重建来适应新的数据分布，但是这会增加维护负担。
   </para>
  </example>

<!--==========================orignal english content==========================
  <para>
   Another possible use for a partial index is to exclude values from the
   index that the
   typical query workload is not interested in; this is shown in <xref
   linkend="indexes-partial-ex2"/>.  This results in the same
   advantages as listed above, but it prevents the
   <quote>uninteresting</quote> values from being accessed via that
   index, even if an index scan might be profitable in that
   case.  Obviously, setting up partial indexes for this kind of
   scenario will require a lot of care and experimentation.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="indexes-partial-ex2"/>展示了部分索引的另一个可能的用途：从索引中排除那些查询不感兴趣的值。这导致了上述相同的好处，但它防止了通过索引来访问<quote>不感兴趣的</quote>值，即便在这种情况下一个索引扫描是有益的。显然，为这种场景建立部分索引需要很多考虑和实验。
  </para>

  <example id="indexes-partial-ex2">
<!--==========================orignal english content==========================
   <title>Setting up a Partial Index to Exclude Uninteresting Values</title>
____________________________________________________________________________-->
   <title>建立一个部分索引来排除不感兴趣的值</title>

<!--==========================orignal english content==========================
   <para>
    If you have a table that contains both billed and unbilled orders,
    where the unbilled orders take up a small fraction of the total
    table and yet those are the most-accessed rows, you can improve
    performance by creating an index on just the unbilled rows.  The
    command to create the index would look like this:
<programlisting>
CREATE INDEX orders_unbilled_index ON orders (order_nr)
    WHERE billed is not true;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    如果我们有一个表包含已上账和未上账的订单，其中未上账的订单在整个表中占据一小部分且它们是最经常被访问的行。我们可以通过只在未上账的行上创建一个索引来提高性能。创建索引的命令如下：
<programlisting>
CREATE INDEX orders_unbilled_index ON orders (order_nr)
    WHERE billed is not true;
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    A possible query to use this index would be:
<programlisting>
SELECT * FROM orders WHERE billed is not true AND order_nr &lt; 10000;
</programlisting>
    However, the index can also be used in queries that do not involve
    <structfield>order_nr</structfield> at all, e.g.:
<programlisting>
SELECT * FROM orders WHERE billed is not true AND amount &gt; 5000.00;
</programlisting>
    This is not as efficient as a partial index on the
    <structfield>amount</structfield> column would be, since the system has to
    scan the entire index.  Yet, if there are relatively few unbilled
    orders, using this partial index just to find the unbilled orders
    could be a win.
   </para>
____________________________________________________________________________-->
   <para>
    使用该索引的一个可能查询是：
<programlisting>
SELECT * FROM orders WHERE billed is not true AND order_nr &lt; 10000;
</programlisting>
    然而，索引也可以用于完全不涉及<structfield>order_nr</structfield>的查询，例如：
<programlisting>
SELECT * FROM orders WHERE billed is not true AND amount &gt; 5000.00;
</programlisting>
    这并不如在<structfield>amount</structfield>列上部分索引有效，因为系统必须扫描整个索引。然而，如果有相对较少的未上账订单，使用这个部分索引来查找未上账订单将会更好。
   </para>

<!--==========================orignal english content==========================
   <para>
    Note that this query cannot use this index:
<programlisting>
SELECT * FROM orders WHERE order_nr = 3501;
</programlisting>
    The order 3501 might be among the billed or unbilled
    orders.
   </para>
____________________________________________________________________________-->
   <para>
    注意这个查询将不会使用该索引：
<programlisting>
SELECT * FROM orders WHERE order_nr = 3501;
</programlisting>
    订单3501可能在已上账订单或未上账订单中。
   </para>
  </example>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="indexes-partial-ex2"/> also illustrates that the
   indexed column and the column used in the predicate do not need to
   match.  <productname>PostgreSQL</productname> supports partial
   indexes with arbitrary predicates, so long as only columns of the
   table being indexed are involved.  However, keep in mind that the
   predicate must match the conditions used in the queries that
   are supposed to benefit from the index.  To be precise, a partial
   index can be used in a query only if the system can recognize that
   the <literal>WHERE</literal> condition of the query mathematically implies
   the predicate of the index.
   <productname>PostgreSQL</productname> does not have a sophisticated
   theorem prover that can recognize mathematically equivalent
   expressions that are written in different forms.  (Not
   only is such a general theorem prover extremely difficult to
   create, it would probably be too slow to be of any real use.)
   The system can recognize simple inequality implications, for example
   <quote>x &lt; 1</quote> implies <quote>x &lt; 2</quote>; otherwise
   the predicate condition must exactly match part of the query's
   <literal>WHERE</literal> condition
   or the index will not be recognized as usable. Matching takes
   place at query planning time, not at run time. As a result,
   parameterized query clauses do not work with a partial index. For
   example a prepared query with a parameter might specify
   <quote>x &lt; ?</quote> which will never imply
   <quote>x &lt; 2</quote> for all possible values of the parameter.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="indexes-partial-ex2"/>也显示索引列和谓词中使用的列并不需要匹配。<productname>PostgreSQL</productname>支持使用任意谓词的部分索引，只要其中涉及的只有被索引表的列。然而，记住谓词必须匹配在将要受益于索引的查询中使用的条件。更准确地，只有当系统能识别查询的<literal>WHERE</literal>条件从数学上索引的谓词时，一个部分索引才能被用于一个查询。<productname>PostgreSQL</productname>并不能给出一个精致的定理证明器来识别写成不同形式在数学上等价的表达式（一方面创建这种证明器极端困难，另一方面即便能创建出来对于实用也过慢）。系统可以识别简单的不等蕴含，例如<quote>x &lt; 1</quote>蕴含<quote>x &lt; 2</quote>；否则谓词条件必须准确匹配查询的<literal>WHERE</literal>条件中的部分，或者索引将不会被识别为可用。匹配发生在查询规划期间而不是运行期间。因此，参数化查询子句无法配合一个部分索引工作。例如，对于参数的所有可能值来说，一个具有参数<quote>x &lt; ?</quote>的预备查询绝不会蕴含<quote>x &lt; 2</quote>。
  </para>

<!--==========================orignal english content==========================
  <para>
   A third possible use for partial indexes does not require the
   index to be used in queries at all.  The idea here is to create
   a unique index over a subset of a table, as in <xref
   linkend="indexes-partial-ex3"/>.  This enforces uniqueness
   among the rows that satisfy the index predicate, without constraining
   those that do not.
  </para>
____________________________________________________________________________-->
  <para>
   部分索引的第三种可能的用途并不要求索引被用于查询。其思想是在一个表的子集上创建一个唯一索引，如<xref
   linkend="indexes-partial-ex3"/>所示。这对那些满足索引谓词的行强制了唯一性，而对那些不满足的行则没有影响。
  </para>

  <example id="indexes-partial-ex3">
<!--==========================orignal english content==========================
   <title>Setting up a Partial Unique Index</title>
____________________________________________________________________________-->
   <title>建立一个部分唯一索引</title>

<!--==========================orignal english content==========================
   <para>
    Suppose that we have a table describing test outcomes.  We wish
    to ensure that there is only one <quote>successful</quote> entry for
    a given subject and target combination, but there might be any number of
    <quote>unsuccessful</quote> entries.  Here is one way to do it:
<programlisting>
CREATE TABLE tests (
    subject text,
    target text,
    success boolean,
    ...
);

CREATE UNIQUE INDEX tests_success_constraint ON tests (subject, target)
    WHERE success;
</programlisting>
    This is a particularly efficient approach when there are few
    successful tests and many unsuccessful ones.  It is also possible to
    allow only one null in a column by creating a unique partial index
    with an <literal>IS NULL</literal> restriction.
   </para>
____________________________________________________________________________-->
   <para>
    假设我们有一个描述测试结果的表。我们希望保证其中对于一个给定的主题和目标组合只有一个<quote>成功</quote>项，但其中可能会有任意多个<quote>不成功</quote>项。实现它的方式是：
<programlisting>
CREATE TABLE tests (
    subject text,
    target text,
    success boolean,
    ...
);

CREATE UNIQUE INDEX tests_success_constraint ON tests (subject, target)
    WHERE success;
</programlisting>
    当有少数成功测试和很多不成功测试时这是一种特别有效的方法。通过创建具有<literal>IS NULL</literal>限制的惟一部分索引，也可以允许列中仅有一个空。
   </para>

  </example>

<!--==========================orignal english content==========================
  <para>
   Finally, a partial index can also be used to override the system's
   query plan choices.  Also, data sets with peculiar
   distributions might cause the system to use an index when it really
   should not.  In that case the index can be set up so that it is not
   available for the offending query.  Normally,
   <productname>PostgreSQL</productname> makes reasonable choices about index
   usage (e.g., it avoids them when retrieving common values, so the
   earlier example really only saves index size, it is not required to
   avoid index usage), and grossly incorrect plan choices are cause
   for a bug report.
  </para>
____________________________________________________________________________-->
  <para>
   最后，一个部分索引也可以被用来重载系统的查询规划选择。同样，具有特殊分布的数据集可能导致系统在它并不需要索引的时候选择使用索引。在此种情况下可以被建立，这样它将不会被那些无关的查询所用。通常，<productname>PostgreSQL</productname>会对索引使用做出合理的选择（例如，它会在检索公值时避开索引，这样前面的例子只能节约索引尺寸，它并非是避免索引使用所必需的），非常不正确的规划选择则需要作为故障报告。
  </para>

<!--==========================orignal english content==========================
  <para>
   Keep in mind that setting up a partial index indicates that you
   know at least as much as the query planner knows, in particular you
   know when an index might be profitable.  Forming this knowledge
   requires experience and understanding of how indexes in
   <productname>PostgreSQL</productname> work.  In most cases, the
   advantage of a partial index over a regular index will be minimal.
   There are cases where they are quite counterproductive, as in <xref
   linkend="indexes-partial-ex4"/>.
  </para>
____________________________________________________________________________-->
  <para>
   记住建立一个部分索引意味着我们知道的至少和查询规划器所知的一样多，尤其是我们知道什么时候一个索引会是有益的。
   构建这些知识需要经验和对于<productname>PostgreSQL</productname>中索引工作方式的理解。
   在大部分情况下，一个部分索引相对于一个普通索引的优势很小。在某些情况下，它们会完全相反，例如<xref linkend="indexes-partial-ex4"/>。
  </para>

  <example id="indexes-partial-ex4">
<!--==========================orignal english content==========================
   <title>Do Not Use Partial Indexes as a Substitute for Partitioning</title>
____________________________________________________________________________-->
   <title>不要使用部分索引代替分区</title>

<!--==========================orignal english content==========================
   <para>
    You might be tempted to create a large set of non-overlapping partial
    indexes, for example

<programlisting>
CREATE INDEX mytable_cat_1 ON mytable (data) WHERE category = 1;
CREATE INDEX mytable_cat_2 ON mytable (data) WHERE category = 2;
CREATE INDEX mytable_cat_3 ON mytable (data) WHERE category = 3;
...
CREATE INDEX mytable_cat_<replaceable>N</replaceable> ON mytable (data) WHERE category = <replaceable>N</replaceable>;
</programlisting>

    This is a bad idea!  Almost certainly, you'll be better off with a
    single non-partial index, declared like

<programlisting>
CREATE INDEX mytable_cat_data ON mytable (category, data);
</programlisting>

    (Put the category column first, for the reasons described in
    <xref linkend="indexes-multicolumn"/>.)  While a search in this larger
    index might have to descend through a couple more tree levels than a
    search in a smaller index, that's almost certainly going to be cheaper
    than the planner effort needed to select the appropriate one of the
    partial indexes.  The core of the problem is that the system does not
    understand the relationship among the partial indexes, and will
    laboriously test each one to see if it's applicable to the current
    query.
   </para>
____________________________________________________________________________-->
   <para>
    你可能想尝试创建一组巨大的、不重叠的部分索引，例如

<programlisting>
CREATE INDEX mytable_cat_1 ON mytable (data) WHERE category = 1;
CREATE INDEX mytable_cat_2 ON mytable (data) WHERE category = 2;
CREATE INDEX mytable_cat_3 ON mytable (data) WHERE category = 3;
...
CREATE INDEX mytable_cat_<replaceable>N</replaceable> ON mytable (data) WHERE category = <replaceable>N</replaceable>;
</programlisting>

    这是个个坏主意!几乎可以肯定，使用一个非部分索引会更好一些，声明如

<programlisting>
CREATE INDEX mytable_cat_data ON mytable (category, data);
</programlisting>

    (将类别列放在前面，基于<xref linkend="indexes-multicolumn"/>所述的原因。)
    虽然在这个更大的索引中进行搜索可能比在更小的索引中进行搜索要下降两倍以上的树级别，
    但这几乎肯定会比选择适当的部分索引中的一个所需的规划器的开销更便宜。
    问题的核心是系统不理解部分索引之间的关系，并将费力地测试每个索引，以确定它是否适用于当前查询。
   </para>

<!--==========================orignal english content==========================
   <para>
    If your table is large enough that a single index really is a bad idea,
    you should look into using partitioning instead (see
    <xref linkend="ddl-partitioning"/>).  With that mechanism, the system
    does understand that the tables and indexes are non-overlapping, so
    far better performance is possible.
   </para>
____________________________________________________________________________-->
   <para>
    如果你的表足够大，单个索引确实是一个坏主意，你应该考虑使用分区代替(参见<xref linkend="ddl-partitioning"/>)。
    通过这种机制，系统理解表和索引是不重叠的，就此而言可以获得更好的性能。
   </para>
  </example>

<!--==========================orignal english content==========================
  <para>
   More information about partial indexes can be found in <xref
   linkend="ston89b"/>, <xref linkend="olson93"/>, and <xref
   linkend="seshadri95"/>.
  </para>
____________________________________________________________________________-->
  <para>
   关于部分索引的更多信息可以在<xref
   linkend="ston89b"/>、<xref linkend="olson93"/>和<xref
   linkend="seshadri95"/>中找到。
   </para>
 </sect1>


 <sect1 id="indexes-index-only-scans">
<!--==========================orignal english content==========================
  <title>Index-Only Scans and Covering Indexes</title>
____________________________________________________________________________-->
  <title>只用索引的扫描和覆盖索引</title>

<!--==========================orignal english content==========================
  <indexterm zone="indexes-index-only-scans">
   <primary>index</primary>
   <secondary>index-only scans</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="indexes-index-only-scans">
   <primary>索引</primary>
   <secondary>只用索引的扫描</secondary>
  </indexterm>
<!--==========================orignal english content==========================
  <indexterm zone="indexes-index-only-scans">
   <primary>index-only scan</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="indexes-index-only-scans">
   <primary>只用索引的扫描</primary>
  </indexterm>
<!--==========================orignal english content==========================
  <indexterm zone="indexes-index-only-scans">
   <primary>index</primary>
   <secondary>covering</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="indexes-index-only-scans">
   <primary>索引</primary>
   <secondary>覆盖</secondary>
  </indexterm>
<!--==========================orignal english content==========================
  <indexterm zone="indexes-index-only-scans">
   <primary>covering index</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="indexes-index-only-scans">
   <primary>覆盖索引</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   All indexes in <productname>PostgreSQL</productname>
   are <firstterm>secondary</firstterm> indexes, meaning that each index is
   stored separately from the table's main data area (which is called the
   table's <firstterm>heap</firstterm>
   in <productname>PostgreSQL</productname> terminology).  This means that
   in an ordinary index scan, each row retrieval requires fetching data from
   both the index and the heap.  Furthermore, while the index entries that
   match a given indexable <literal>WHERE</literal> condition are usually
   close together in the index, the table rows they reference might be
   anywhere in the heap.  The heap-access portion of an index scan thus
   involves a lot of random access into the heap, which can be slow,
   particularly on traditional rotating media.  (As described in
   <xref linkend="indexes-bitmap-scans"/>, bitmap scans try to alleviate
   this cost by doing the heap accesses in sorted order, but that only goes
   so far.)
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>中的所有索引是<firstterm>二级</firstterm>索引,这意味着每个索引都是与表的主数据区（在<productname>PostgreSQL</productname>术语称为表的<firstterm>堆</firstterm>中）分开存储。这意味着在普通索引扫描中，每行检索都需要从索引和堆中取数据。 此外，虽然匹配给定的可索引<literal>WHERE</literal>条件的索引条目通常在一起靠近存储，但它们引用的表行可能在堆中的任何地方。 因此索引扫描的堆访问部分涉及到对堆的大量随机访问，这可能很慢，特别是在传统旋转媒介上。如 <xref linkend ="indexes-bitmap-scans"/>
   中所述，位图扫描尝试通过按排序的顺序进行堆访问来减少成本，但这远远不够）。
  </para>

<!--==========================orignal english content==========================
  <para>
   To solve this performance problem, <productname>PostgreSQL</productname>
   supports <firstterm>index-only scans</firstterm>, which can answer
   queries from an index alone without any heap access.  The basic idea is
   to return values directly out of each index entry instead of consulting
   the associated heap entry.  There are two fundamental restrictions on
   when this method can be used:

   <orderedlist>
    <listitem>
     <para>
      The index type must support index-only scans.  B-tree indexes always
      do.  GiST and SP-GiST indexes support index-only scans for some
      operator classes but not others.  Other index types have no support.
      The underlying requirement is that the index must physically store, or
      else be able to reconstruct, the original data value for each index
      entry.  As a counterexample, GIN indexes cannot support index-only
      scans because each index entry typically holds only part of the
      original data value.
     </para>
    </listitem>

    <listitem>
     <para>
      The query must reference only columns stored in the index.  For
      example, given an index on columns <literal>x</literal>
      and <literal>y</literal> of a table that also has a
      column <literal>z</literal>, these queries could use index-only scans:
<programlisting>
SELECT x, y FROM tab WHERE x = 'key';
SELECT x FROM tab WHERE x = 'key' AND y &lt; 42;
</programlisting>
      but these queries could not:
<programlisting>
SELECT x, z FROM tab WHERE x = 'key';
SELECT x FROM tab WHERE x = 'key' AND z &lt; 42;
</programlisting>
      (Expression indexes and partial indexes complicate this rule,
      as discussed below.)
     </para>
    </listitem>
   </orderedlist>
  </para>
____________________________________________________________________________-->
  <para>
   为了解决这种性能问题，<productname>PostgreSQL</productname>支持<firstterm>只用索引的扫描</firstterm>，这类扫描可以仅用一个索引来回答查询而不产生任何堆访问。其基本思想是直接从每一个索引项中直接返回值，而不是去参考相关的堆项。在使用这种方法时有两个根本的限制：

   <orderedlist>
    <listitem>
     <para>
      索引类型必须支持只用索引的扫描。B-树索引总是支持只用索引的扫描。GiST 和 SP-GiST 索引只对某些操作符类支持只用索引的扫描。其他索引类型不支持这种扫描。底层的要求是索引必须在物理上存储或者可以重构出每一个索引项对应的原始数据值。GIN 索引是一个不支持只用索引的扫描的反例，因为它的每一个索引项通常只包含原始数据值的一部分。
     </para>
    </listitem>

    <listitem>
     <para>
      查询必须只引用存储在该索引中的列。例如，给定的索引建立在表的列<literal>x</literal>和<literal>y</literal>上，而该表还有一个列<literal>z</literal>，这些查询可以使用只用索引的扫描：
<programlisting>
SELECT x, y FROM tab WHERE x = 'key';
SELECT x FROM tab WHERE x = 'key' AND y &lt; 42;
</programlisting>
      但是这些查询不能使用只用索引的查询：
<programlisting>
SELECT x, z FROM tab WHERE x = 'key';
SELECT x FROM tab WHERE x = 'key' AND z &lt; 42;
</programlisting>
      （如下面所讨论的，表达式索引和部分索引会让这条规则更加复杂）。
     </para>
    </listitem>
   </orderedlist>
  </para>

<!--==========================orignal english content==========================
  <para>
   If these two fundamental requirements are met, then all the data values
   required by the query are available from the index, so an index-only scan
   is physically possible.  But there is an additional requirement for any
   table scan in <productname>PostgreSQL</productname>: it must verify that
   each retrieved row be <quote>visible</quote> to the query's MVCC
   snapshot, as discussed in <xref linkend="mvcc"/>.  Visibility information
   is not stored in index entries, only in heap entries; so at first glance
   it would seem that every row retrieval would require a heap access
   anyway.  And this is indeed the case, if the table row has been modified
   recently.  However, for seldom-changing data there is a way around this
   problem.  <productname>PostgreSQL</productname> tracks, for each page in
   a table's heap, whether all rows stored in that page are old enough to be
   visible to all current and future transactions.  This information is
   stored in a bit in the table's <firstterm>visibility map</firstterm>.  An
   index-only scan, after finding a candidate index entry, checks the
   visibility map bit for the corresponding heap page.  If it's set, the row
   is known visible and so the data can be returned with no further work.
   If it's not set, the heap entry must be visited to find out whether it's
   visible, so no performance advantage is gained over a standard index
   scan.  Even in the successful case, this approach trades visibility map
   accesses for heap accesses; but since the visibility map is four orders
   of magnitude smaller than the heap it describes, far less physical I/O is
   needed to access it.  In most situations the visibility map remains
   cached in memory all the time.
  </para>
____________________________________________________________________________-->
  <para>
   如果符合这两个根本要求，那么该查询所要求的所有数据值都可以从索引得到，因此才可能使用只用索引的扫描。但是对<productname>PostgreSQL</productname>中的任何表扫描还有一个额外的要求：必须验证每一个检索到的行对该查询的 MVCC 快照是<quote>可见的</quote>，如<xref linkend="mvcc"/>中讨论的那样。可见性信息并不存储在索引项中，只存储在堆项中。因此，乍一看似乎每一次行检索无论如何都会要求一次堆访问。如果表行最近被修改过，确实是这样。但是，对于很少更改的数据有一种方法可以解决这个问题。<productname>PostgreSQL</productname>为表堆中的每一个页面跟踪是否其中所有的行的年龄都足够大，以至于对所有当前以及未来的事务都可见。这个信息存储在该表的<firstterm>可见性映射</firstterm>的一个位中。在找到一个候选索引项后，只用索引的扫描会检查对应堆页面的可见性映射位。如果该位被设置，那么这一行就是可见的并且该数据库可以直接被返回。如果该位没有被设置，那么就必须访问堆项以确定这一行是否可见，这种情况下相对于标准索引扫描就没有性能优势。即便是在成功的情况下，这种方法也是把对堆的访问换成了对可见性映射的访问。不过由于可见性映射比它所描述的堆要小四个数量级，所以访问可见性映射所需的物理 I/O 要少很多。在大部分情况下，可见性映射总是会被保留在内存中的缓冲中。
  </para>

<!--==========================orignal english content==========================
  <para>
   In short, while an index-only scan is possible given the two fundamental
   requirements, it will be a win only if a significant fraction of the
   table's heap pages have their all-visible map bits set.  But tables in
   which a large fraction of the rows are unchanging are common enough to
   make this type of scan very useful in practice.
  </para>
____________________________________________________________________________-->
  <para>
   总之，虽然当两个根本要求满足时可以使用只用索引的扫描，但是只有该表的堆页面中有很大一部分的“所有都可见”映射位被设置时这种索引才有优势。不过，有很大一部分行不被更改的表是很常见的，这也让这一类扫描在实际中非常有用。
  </para> 
<!--==========================orignal english content==========================
  <para>
   <indexterm>
    <primary><literal>INCLUDE</literal></primary>
    <secondary>in index definitions</secondary>
   </indexterm>
   To make effective use of the index-only scan feature, you might choose to
   create a <firstterm>covering index</firstterm>, which is an index
   specifically designed to include the columns needed by a particular
   type of query that you run frequently.  Since queries typically need to
   retrieve more columns than just the ones they search
   on, <productname>PostgreSQL</productname> allows you to create an index
   in which some columns are just <quote>payload</quote> and are not part
   of the search key.  This is done by adding an <literal>INCLUDE</literal>
   clause listing the extra columns.  For example, if you commonly run
   queries like
<programlisting>
SELECT y FROM tab WHERE x = 'key';
</programlisting>
   the traditional approach to speeding up such queries would be to create
   an index on <literal>x</literal> only.  However, an index defined as
<programlisting>
CREATE INDEX tab_x_y ON tab(x) INCLUDE (y);
</programlisting>
   could handle these queries as index-only scans,
   because <literal>y</literal> can be obtained from the index without
   visiting the heap.
  </para>
____________________________________________________________________________-->
  <para>
   <indexterm>
    <primary><literal>INCLUDE</literal></primary>
    <secondary>in index definitions</secondary>
   </indexterm>
   为了有效利用仅索引扫描功能，您可以选择创建一个<firstterm>覆盖索引</firstterm>，它是一个特别设计的索引，包含经常运行的特殊类型查询所需要的列。由于查询通常需要检索的列不仅仅是他们搜索的列，<productname>PostgreSQL</productname>允许您创建索引,这个索引中有些列只是<quote>负荷</quote>而不是搜索键的一部分。这可以通过添加<literal>INCLUDE</literal>来完成子句来列出了额外的列。 例如，如果您通常可以运行这样的查询：
<programlisting>
SELECT y FROM tab WHERE x = 'key';
</programlisting>
   加快此类查询的传统方法是仅在<literal>x</literal>上的索引。但是，一个索引定义为
<programlisting>
CREATE INDEX tab_x_y ON tab(x) INCLUDE (y);
</programlisting>
   可以将这些查询作为仅索引扫描处理，因为<literal>y</literal>可以从索引中获取而不需要访问堆。
  </para>

<!--==========================orignal english content==========================
  <para>
   Because column <literal>y</literal> is not part of the index's search
   key, it does not have to be of a data type that the index can handle;
   it's merely stored in the index and is not interpreted by the index
   machinery.  Also, if the index is a unique index, that is
<programlisting>
CREATE UNIQUE INDEX tab_x_y ON tab(x) INCLUDE (y);
</programlisting>
   the uniqueness condition applies to just column <literal>x</literal>,
   not to the combination of <literal>x</literal> and <literal>y</literal>.
   (An <literal>INCLUDE</literal> clause can also be written
   in <literal>UNIQUE</literal> and <literal>PRIMARY KEY</literal>
   constraints, providing alternative syntax for setting up an index like
   this.)
  </para>
____________________________________________________________________________-->
  <para>
   因为列<literal>y</literal>不是搜索键的一部分，它不必是索引可以处理的数据类型；它只存储在索引中，不由索引机解释。另外，如果索引是唯一的索引，则
<programlisting>
CREATE UNIQUE INDEX tab_x_y ON tab(x) INCLUDE (y);
</programlisting>
   唯一性条件仅适用于<literal>x </literal>列，而不是<literal>x</literal>和<literal>y</literal>的组合。（如果使用和在索引中设置的类似语法，一个<literal>INCLUDE</literal>子句可以写在<literal>UNIQUE</literal>和<literal>PRIMARY KEY</literal>约束中。）
 </para>

<!--==========================orignal english content==========================
  <para>
   It's wise to be conservative about adding non-key payload columns to an
   index, especially wide columns.  If an index tuple exceeds the
   maximum size allowed for the index type, data insertion will fail.
   In any case, non-key columns duplicate data from the index's table
   and bloat the size of the index, thus potentially slowing searches.
   And remember that there is little point in including payload columns in an
   index unless the table changes slowly enough that an index-only scan is
   likely to not need to access the heap.  If the heap tuple must be visited
   anyway, it costs nothing more to get the column's value from there.
   Other restrictions are that expressions are not currently supported as
   included columns, and that only B-tree and GiST indexes currently support
   included columns.
  </para>
____________________________________________________________________________-->
  <para>
   保守地将非键负载列添加到索引是明智的，尤其是宽列。 如果索引元组超过索引类型允许的最大大小，数据插入将失败。在任何情况下，非键列都将复制索引表中的数据并放大了索引的大小，从而有可能减慢搜索速度。请记住，除非一个表足够慢以至于仅索引扫描可能不必访问堆，否则没有什么理由在一个索引中包含负载列。无论如何，如果必须访问堆元组，从堆里获取列的值并不会带来更高的开销。其他限制是表达式不被作为包含的来支持。只有B树和GiST索引当前支持包含的列。
  </para>

<!--==========================orignal english content==========================
  <para>
   Before <productname>PostgreSQL</productname> had
   the <literal>INCLUDE</literal> feature, people sometimes made covering
   indexes by writing the payload columns as ordinary index columns,
   that is writing
<programlisting>
CREATE INDEX tab_x_y ON tab(x, y);
</programlisting>
   even though they had no intention of ever using <literal>y</literal> as
   part of a <literal>WHERE</literal> clause.  This works fine as long as
   the extra columns are trailing columns; making them be leading columns is
   unwise for the reasons explained in <xref linkend="indexes-multicolumn"/>.
   However, this method doesn't support the case where you want the index to
   enforce uniqueness on the key column(s).
  </para>
____________________________________________________________________________-->
  <para>
   在<productname> PostgreSQL</productname>有<literal>INCLUDE</literal>特性之前，人们有时会通过写负载列作为普通索引列来制作覆盖索引。它这样写：
   <programlisting>
      CREATE INDEX tab_x_y ON tab(x, y);
   </programlisting>
   即使他们无意将<literal>y</literal>用作<literal>WHER</literal>子句的一部分，只要额外的列是尾列就可以很好的工作。 让它们成为前导字段是不明智的，原因在<xref linkend ="indexes-multicolumn"/>中有说明。但是，此方法不支持您希望索引在键列上实施唯一性。 
  </para>

<!--==========================orignal english content==========================
  <para>
   <firstterm>Suffix truncation</firstterm> always removes non-key
   columns from upper B-Tree levels.  As payload columns, they are
   never used to guide index scans.  The truncation process also
   removes one or more trailing key column(s) when the remaining
   prefix of key column(s) happens to be sufficient to describe tuples
   on the lowest B-Tree level.  In practice, covering indexes without
   an <literal>INCLUDE</literal> clause often avoid storing columns
   that are effectively payload in the upper levels.  However,
   explicitly defining payload columns as non-key columns
   <emphasis>reliably</emphasis> keeps the tuples in upper levels
   small.
  </para>
____________________________________________________________________________-->
  <para>
   <firstterm>Suffix truncation</firstterm>总是从B-Tree的上层移除非键列。作为有效负载列，它们从不用于指导索引扫描。
   当键列的其余前缀恰好足以描述最低B-Tree级别上的元组时，截断过程还会删除一个或多个尾随的键列。
   实际中，不使用<literal>INCLUDE</literal>子句覆盖索引通常会避免存储在上层有效负载的列。
   然而，显式地将有效负载列定义为非键列<emphasis>reliably</emphasis>使上层元组保持较小。
  </para>

<!--==========================orignal english content==========================
  <para>
   In principle, index-only scans can be used with expression indexes.
   For example, given an index on <literal>f(x)</literal>
   where <literal>x</literal> is a table column, it should be possible to
   execute
<programlisting>
SELECT f(x) FROM tab WHERE f(x) &lt; 1;
</programlisting>
   as an index-only scan; and this is very attractive
   if <literal>f()</literal> is an expensive-to-compute function.
   However, <productname>PostgreSQL</productname>'s planner is currently not
   very smart about such cases.  It considers a query to be potentially
   executable by index-only scan only when all <emphasis>columns</emphasis>
   needed by the query are available from the index.  In this
   example, <literal>x</literal> is not needed except in the
   context <literal>f(x)</literal>, but the planner does not notice that and
   concludes that an index-only scan is not possible.  If an index-only scan
   seems sufficiently worthwhile, this can be worked around by
   adding <literal>x</literal> as an included column, for example
<programlisting>
CREATE INDEX tab_f_x ON tab (f(x)) INCLUDE (x);
</programlisting>
   An additional caveat, if the goal is to avoid
   recalculating <literal>f(x)</literal>, is that the planner won't
   necessarily match uses of <literal>f(x)</literal> that aren't in
   indexable <literal>WHERE</literal> clauses to the index column.  It will
   usually get this right in simple queries such as shown above, but not in
   queries that involve joins.  These deficiencies may be remedied in future
   versions of <productname>PostgreSQL</productname>.
  </para>
____________________________________________________________________________-->
  <para>
   原则上，只用索引的扫描可以被用于表达式索引。例如，给定一个<literal>f(x)</literal>上的索引（<literal>x</literal>是一个表列），可以把
<programlisting>
SELECT f(x) FROM tab WHERE f(x) &lt; 1;
</programlisting>
   作为只用索引的扫描执行，如果<literal>f()</literal>是一个计算代价昂贵的函数，这会非常有吸引力。不过，<productname>PostgreSQL</productname>的规划器当前面对这类情况时并不是很聪明。只有在索引中有查询所需要的所有<emphasis>列</emphasis>时，规划器才会考虑用只用索引的扫描来执行一个查询。在这个例子中，除了在<literal>f(x)</literal>环境中之外，查询的其他部分不需要<literal>x</literal>，但是规划器并不能意识到这一点，因此它会得出不能使用只用索引的扫描的结论。如果只用索引的扫描足够有价值，有一种解决方法是把该索引定义在<literal>(f(x), x)</literal>上，其中第二个列实际上并不会被使用，它只是用来说服规划器可以使用只用索引的扫描而已。如果目标是避免重复计算<literal>f(x)</literal>，一个额外的警示是规划器不一定会把不在可索引<literal>WHERE</literal>子句中对<literal>f(x)</literal>的使用匹配到索引列。通常在上述那种简单查询中一切正常，但是涉及到连接的查询中就不行了。这些不足将在未来的<productname>PostgreSQL</productname>版本中修正。
  </para>

<!--==========================orignal english content==========================
  <para>
   Partial indexes also have interesting interactions with index-only scans.
   Consider the partial index shown in <xref linkend="indexes-partial-ex3"/>:
<programlisting>
CREATE UNIQUE INDEX tests_success_constraint ON tests (subject, target)
    WHERE success;
</programlisting>
   In principle, we could do an index-only scan on this index to satisfy a
   query like
<programlisting>
SELECT target FROM tests WHERE subject = 'some-subject' AND success;
</programlisting>
   But there's a problem: the <literal>WHERE</literal> clause refers
   to <literal>success</literal> which is not available as a result column
   of the index.  Nonetheless, an index-only scan is possible because the
   plan does not need to recheck that part of the <literal>WHERE</literal>
   clause at run time: all entries found in the index necessarily
   have <literal>success = true</literal> so this need not be explicitly
   checked in the plan.  <productname>PostgreSQL</productname> versions 9.6
   and later will recognize such cases and allow index-only scans to be
   generated, but older versions will not.
  </para>
____________________________________________________________________________-->
  <para>
   部分索引也和只用索引的扫描之间有着有趣的关系。考虑<xref linkend="indexes-partial-ex3"/>中所展示的部分索引：
<programlisting>
CREATE UNIQUE INDEX tests_success_constraint ON tests (subject, target)
    WHERE success;
</programlisting>
   原则上，我们可以在这个索引上使用只用索引的扫描来满足查询
<programlisting>
SELECT target FROM tests WHERE subject = 'some-subject' AND success;
</programlisting>
   但是有一个问题：<literal>WHERE</literal>子句引用的是不能作为索引结果列的<literal>success</literal>。尽管如此，还是可以使用只用索引的扫描，因为在运行时计划不需要重新检查<literal>WHERE</literal>子句的那个部分：在该索引中找到的所有项必定具有<literal>success = true</literal>，因此在计划中检查这个部分的需要并不明显。<productname>PostgreSQL</productname> 9.6 和以后的版本将会识别这种情况，并且允许生成只用索引的扫描，但是旧版本无法这样做。
  </para>
 </sect1>


 <sect1 id="indexes-opclass">
<!--==========================orignal english content==========================
  <title>Operator Classes and Operator Families</title>
____________________________________________________________________________-->
  <title>操作符类和操作符族</title>

<!--==========================orignal english content==========================
  <indexterm zone="indexes-opclass">
   <primary>operator class</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="indexes-opclass">
   <primary>operator class</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm zone="indexes-opclass">
   <primary>operator family</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="indexes-opclass">
   <primary>operator family</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   An index definition can specify an <firstterm>operator
   class</firstterm> for each column of an index.
<synopsis>
CREATE INDEX <replaceable>name</replaceable> ON <replaceable>table</replaceable> (<replaceable>column</replaceable> <replaceable>opclass</replaceable> [ ( <replaceable>opclass_options</replaceable> ) ] <optional><replaceable>sort options</replaceable></optional> <optional>, ...</optional>);
</synopsis>
   The operator class identifies the operators to be used by the index
   for that column.  For example, a B-tree index on the type <type>int4</type>
   would use the <literal>int4_ops</literal> class; this operator
   class includes comparison functions for values of type <type>int4</type>.
   In practice the default operator class for the column's data type is
   usually sufficient.  The main reason for having operator classes is
   that for some data types, there could be more than one meaningful
   index behavior.  For example, we might want to sort a complex-number data
   type either by absolute value or by real part.  We could do this by
   defining two operator classes for the data type and then selecting
   the proper class when making an index.  The operator class determines
   the basic sort ordering (which can then be modified by adding sort options
   <literal>COLLATE</literal>,
   <literal>ASC</literal>/<literal>DESC</literal> and/or
   <literal>NULLS FIRST</literal>/<literal>NULLS LAST</literal>).
  </para>
____________________________________________________________________________-->
  <para>
   一个索引定义可以为索引中的每一列都指定一个<firstterm>操作符类</firstterm>。
<synopsis>
CREATE INDEX <replaceable>name</replaceable> ON <replaceable>table</replaceable> (<replaceable>column</replaceable> <replaceable>opclass</replaceable> [ ( <replaceable>opclass_options</replaceable> ) ] <optional><replaceable>sort options</replaceable></optional> <optional>, ...</optional>);
</synopsis>
   操作符类标识该列上索引要使用的操作符。例如，一个<type>int4</type>类型上的B树索引会使用<literal>int4_ops</literal>类，这个操作符类包括用于<type>int4</type>类型值的比较函数。实际上列的数据类型的默认操作符类通常就足够了。存在多个操作符类的原因是，对于某些数据类型可能会有多于一种的有意义的索引行为。例如，我们可能想要对一种复数数据类型按照绝对值排序或者按照实数部分排序。我们可以通过为该数据类型定义两个操作符类来实现，并且在创建一个索引时选择合适的类。操作符类会决定基本的排序顺序（可以通过增加排序选项<literal>COLLATE</literal>、
   <literal>ASC</literal>/<literal>DESC</literal>和/或
   <literal>NULLS FIRST</literal>/<literal>NULLS LAST</literal>来修改）。
  </para>

<!--==========================orignal english content==========================
  <para>
   There are also some built-in operator classes besides the default ones:

   <itemizedlist>
    <listitem>
     <para>
      The operator classes <literal>text_pattern_ops</literal>,
      <literal>varchar_pattern_ops</literal>, and
      <literal>bpchar_pattern_ops</literal> support B-tree indexes on
      the types <type>text</type>, <type>varchar</type>, and
      <type>char</type> respectively.  The
      difference from the default operator classes is that the values
      are compared strictly character by character rather than
      according to the locale-specific collation rules.  This makes
      these operator classes suitable for use by queries involving
      pattern matching expressions (<literal>LIKE</literal> or POSIX
      regular expressions) when the database does not use the standard
      <quote>C</quote> locale.  As an example, you might index a
      <type>varchar</type> column like this:
<programlisting>
CREATE INDEX test_index ON test_table (col varchar_pattern_ops);
</programlisting>
      Note that you should also create an index with the default operator
      class if you want queries involving ordinary <literal>&lt;</literal>,
      <literal>&lt;=</literal>, <literal>&gt;</literal>, or <literal>&gt;=</literal> comparisons
      to use an index.  Such queries cannot use the
      <literal><replaceable>xxx</replaceable>_pattern_ops</literal>
      operator classes.  (Ordinary equality comparisons can use these
      operator classes, however.)  It is possible to create multiple
      indexes on the same column with different operator classes.
      If you do use the C locale, you do not need the
      <literal><replaceable>xxx</replaceable>_pattern_ops</literal>
      operator classes, because an index with the default operator class
      is usable for pattern-matching queries in the C locale.
     </para>
    </listitem>
   </itemizedlist>
  </para>
____________________________________________________________________________-->
  <para>
   除了默认的操作符类，还有一些内建的操作符类：

   <itemizedlist>
    <listitem>
     <para>
      操作符类<literal>text_pattern_ops</literal>、<literal>varchar_pattern_ops</literal>和
      <literal>bpchar_pattern_ops</literal>分别支持类型<type>text</type>、<type>varchar</type>和
      <type>char</type>上的B树索引。它们与默认操作符类的区别是值的比较是严格按照字符进行而不是根据区域相关的排序规则。这使得这些操作符类适合于当一个数据库没有使用标准<quote>C</quote>区域时被使用在涉及模式匹配表达式（<literal>LIKE</literal>或POSIX正则表达式）的查询中。一个例子是，你可以这样索引一个<type>varchar</type>列：
<programlisting>
CREATE INDEX test_index ON test_table (col varchar_pattern_ops);
</programlisting>
      注意如果你希望涉及到<literal>&lt;</literal>、<literal>&lt;=</literal>、<literal>&gt;</literal>或<literal>&gt;=</literal>比较的查询使用一个索引，你也应该创建一个使用默认操作符类的索引。这些查询不能使用<literal><replaceable>xxx</replaceable>_pattern_ops</literal>操作符类（但是普通的等值比较可以使用这些操作符类）。可以在同一个列上创建多个使用不同操作符类的索引。如果你正在使用C区域，你并不需要<literal><replaceable>xxx</replaceable>_pattern_ops</literal>操作符类，因为在C区域中的模式匹配查询可以用带有默认操作符类的索引。
     </para>
    </listitem>
   </itemizedlist>
  </para>

<!--==========================orignal english content==========================
  <para>
    The following query shows all defined operator classes:

<programlisting>
SELECT am.amname AS index_method,
       opc.opcname AS opclass_name,
       opc.opcintype::regtype AS indexed_type,
       opc.opcdefault AS is_default
    FROM pg_am am, pg_opclass opc
    WHERE opc.opcmethod = am.oid
    ORDER BY index_method, opclass_name;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
    下面的查询展示了所有已定义的操作符类：

<programlisting>
SELECT am.amname AS index_method,
       opc.opcname AS opclass_name,
       opc.opcintype::regtype AS indexed_type,
       opc.opcdefault AS is_default
    FROM pg_am am, pg_opclass opc
    WHERE opc.opcmethod = am.oid
    ORDER BY index_method, opclass_name;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   An operator class is actually just a subset of a larger structure called an
   <firstterm>operator family</firstterm>.  In cases where several data types have
   similar behaviors, it is frequently useful to define cross-data-type
   operators and allow these to work with indexes.  To do this, the operator
   classes for each of the types must be grouped into the same operator
   family.  The cross-type operators are members of the family, but are not
   associated with any single class within the family.
  </para>
____________________________________________________________________________-->
  <para>
   一个操作符类实际上只是一个更大的被称为<firstterm>操作符族</firstterm>的结构的一个子集。在多种数据类型具有相似行为的情况下，常常会定义跨数据类型的操作符并且允许索引使用它们。为了实现该目的，这些类型的操作符类必须被分组到同一个操作符族中。跨类型的操作符是该族的成员，但是并不与族内任意一个单独的类相关联。
  </para>

<!--==========================orignal english content==========================
  <para>
    This expanded version of the previous query shows the operator family
    each operator class belongs to:
<programlisting>
SELECT am.amname AS index_method,
       opc.opcname AS opclass_name,
       opf.opfname AS opfamily_name,
       opc.opcintype::regtype AS indexed_type,
       opc.opcdefault AS is_default
    FROM pg_am am, pg_opclass opc, pg_opfamily opf
    WHERE opc.opcmethod = am.oid AND
          opc.opcfamily = opf.oid
    ORDER BY index_method, opclass_name;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
    前一个查询的扩展版本展示了每个操作符类所属的操作符族：
<programlisting>
SELECT am.amname AS index_method,
       opc.opcname AS opclass_name,
       opf.opfname AS opfamily_name,
       opc.opcintype::regtype AS indexed_type,
       opc.opcdefault AS is_default
    FROM pg_am am, pg_opclass opc, pg_opfamily opf
    WHERE opc.opcmethod = am.oid AND
          opc.opcfamily = opf.oid
    ORDER BY index_method, opclass_name;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
    This query shows all defined operator families and all
    the operators included in each family:
<programlisting>
SELECT am.amname AS index_method,
       opf.opfname AS opfamily_name,
       amop.amopopr::regoperator AS opfamily_operator
    FROM pg_am am, pg_opfamily opf, pg_amop amop
    WHERE opf.opfmethod = am.oid AND
          amop.amopfamily = opf.oid
    ORDER BY index_method, opfamily_name, opfamily_operator;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
    这个查询展示所有已定义的操作符族和每一个族中包含的所有操作符：
<programlisting>
SELECT am.amname AS index_method,
       opf.opfname AS opfamily_name,
       amop.amopopr::regoperator AS opfamily_operator
    FROM pg_am am, pg_opfamily opf, pg_amop amop
    WHERE opf.opfmethod = am.oid AND
          amop.amopfamily = opf.oid
    ORDER BY index_method, opfamily_name, opfamily_operator;
</programlisting>
  </para>

  <tip>
<!--==========================orignal english content==========================
   <para>
    <xref linkend="app-psql"/> has
    commands <command>\dAc</command>, <command>\dAf</command>,
    and <command>\dAo</command>, which provide slightly more sophisticated
    versions of these queries.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="app-psql"/> has
    commands <command>\dAc</command>, <command>\dAf</command>,
    and <command>\dAo</command>, which provide slightly more sophisticated
    versions of these queries.
   </para>
  </tip>
 </sect1>


 <sect1 id="indexes-collations">
<!--==========================orignal english content==========================
  <title>Indexes and Collations</title>
____________________________________________________________________________-->
  <title>索引和排序规则</title>

<!--==========================orignal english content==========================
  <para>
   An index can support only one collation per index column.
   If multiple collations are of interest, multiple indexes may be needed.
  </para>
____________________________________________________________________________-->
  <para>
   一个索引在每一个索引列上只能支持一种排序规则。如果需要多种排序规则，你可能需要多个索引。
  </para>

<!--==========================orignal english content==========================
  <para>
   Consider these statements:
<programlisting>
CREATE TABLE test1c (
    id integer,
    content varchar COLLATE "x"
);

CREATE INDEX test1c_content_index ON test1c (content);
</programlisting>
   The index automatically uses the collation of the
   underlying column.  So a query of the form
<programlisting>
SELECT * FROM test1c WHERE content &gt; <replaceable>constant</replaceable>;
</programlisting>
   could use the index, because the comparison will by default use the
   collation of the column.  However, this index cannot accelerate queries
   that involve some other collation.  So if queries of the form, say,
<programlisting>
SELECT * FROM test1c WHERE content &gt; <replaceable>constant</replaceable> COLLATE "y";
</programlisting>
   are also of interest, an additional index could be created that supports
   the <literal>"y"</literal> collation, like this:
<programlisting>
CREATE INDEX test1c_content_y_index ON test1c (content COLLATE "y");
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   考虑这些语句：
<programlisting>
CREATE TABLE test1c (
    id integer,
    content varchar COLLATE "x"
);

CREATE INDEX test1c_content_index ON test1c (content);
</programlisting>
   该索引自动使用下层列的排序规则。因此一个如下形式的查询：
<programlisting>
SELECT * FROM test1c WHERE content &gt; <replaceable>constant</replaceable>;
</programlisting>
   可以使用该索引，因为比较会默认使用列的排序规则。但是，这个索引无法加速涉及到某些其他排序规则的查询。因此对于下面形式的查询：
<programlisting>
SELECT * FROM test1c WHERE content &gt; <replaceable>constant</replaceable> COLLATE "y";
</programlisting>
   可以创建一个额外的支持<literal>"y"</literal>排序规则的索引，例如：
<programlisting>
CREATE INDEX test1c_content_y_index ON test1c (content COLLATE "y");
</programlisting>
  </para>
 </sect1>


 <sect1 id="indexes-examine">
<!--==========================orignal english content==========================
  <title>Examining Index Usage</title>
____________________________________________________________________________-->
  <title>检查索引使用</title>

<!--==========================orignal english content==========================
  <indexterm zone="indexes-examine">
   <primary>index</primary>
   <secondary>examining usage</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="indexes-examine">
   <primary>index</primary>
   <secondary>检查用量</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   Although indexes in <productname>PostgreSQL</productname> do not need
   maintenance or tuning, it is still important to check
   which indexes are actually used by the real-life query workload.
   Examining index usage for an individual query is done with the
   <xref linkend="sql-explain"/>
   command; its application for this purpose is
   illustrated in <xref linkend="using-explain"/>.
   It is also possible to gather overall statistics about index usage
   in a running server, as described in <xref linkend="monitoring-stats"/>.
  </para>
____________________________________________________________________________-->
  <para>   
   尽管<productname>PostgreSQL</productname>中的索引并不需要维护或调优，但是检查真实的查询负载实际使用了哪些索引仍然非常重要。检查一个独立查询的索引使用情况可以使用<xref linkend="sql-explain"/>命令，它应用于这种目的的内容在<xref linkend="using-explain"/>中有介绍。也可以在一个运行中的服务器上收集有关索引使用的总体统计情况，如<xref linkend="monitoring-stats"/>所述。
  </para>

<!--==========================orignal english content==========================
  <para>
   It is difficult to formulate a general procedure for determining
   which indexes to create.  There are a number of typical cases that
   have been shown in the examples throughout the previous sections.
   A good deal of experimentation is often necessary.
   The rest of this section gives some tips for that:
  </para>
____________________________________________________________________________-->
  <para>
   很难明确地表达决定创建哪些索引的通用过程。在之前的小节中的例子里有一些典型的情况。通常需要大量的实验才能决定应该创建哪些索引。本小节剩余的部分将给出一些创建索引的提示：
  </para>

  <itemizedlist>
   <listitem>
<!--==========================orignal english content==========================
    <para>
     Always run <xref linkend="sql-analyze"/>
     first.  This command
     collects statistics about the distribution of the values in the
     table.  This information is required to estimate the number of rows
     returned by a query, which is needed by the planner to assign
     realistic costs to each possible query plan.  In absence of any
     real statistics, some default values are assumed, which are
     almost certain to be inaccurate.  Examining an application's
     index usage without having run <command>ANALYZE</command> is
     therefore a lost cause.
     See <xref linkend="vacuum-for-statistics"/>
     and <xref linkend="autovacuum"/> for more information.
    </para>
____________________________________________________________________________-->
    <para>
     总是先运行<xref linkend="sql-analyze"/>。这个命令会收集有关表中值分布情况的统计信息。估计一个查询将要返回的行数需要这些信息，而结果行数则被规划器用来为每一个可能的查询计划分配实际的代价。如果没有任何真实的统计信息，将会假定一些默认值，这几乎肯定是不准确的。在没有运行的情况下检查一个应用的索引使用情况是注定要失败的。详见<xref linkend="vacuum-for-statistics"/>和<xref linkend="autovacuum"/>。
    </para>
   </listitem>

   <listitem>
<!--==========================orignal english content==========================
    <para>
     Use real data for experimentation.  Using test data for setting
     up indexes will tell you what indexes you need for the test data,
     but that is all.
    </para>
____________________________________________________________________________-->
    <para>
     使用真实数据进行实验。使用测试数据来建立索引将会告诉你测试数据需要什么样的索引，但这并不代表真实数据的需要。
    </para>

<!--==========================orignal english content==========================
    <para>
     It is especially fatal to use very small test data sets.
     While selecting 1000 out of 100000 rows could be a candidate for
     an index, selecting 1 out of 100 rows will hardly be, because the
     100 rows probably fit within a single disk page, and there
     is no plan that can beat sequentially fetching 1 disk page.
    </para>
____________________________________________________________________________-->
    <para>
     使用非常小的测试数据集是特别致命的。在从100000行中选出1000行时可能会用到索引，但是从100行里选出1行是很难用到索引的，因为100行完全可能放入到一个磁盘页面中，而没有任何计划能够比得上从一个磁盘页面顺序获取的计划。
    </para>

<!--==========================orignal english content==========================
    <para>
     Also be careful when making up test data, which is often
     unavoidable when the application is not yet in production.
     Values that are very similar, completely random, or inserted in
     sorted order will skew the statistics away from the distribution
     that real data would have.
    </para>
____________________________________________________________________________-->
    <para>
     在创建测试数据时也要小心，特别是当应用还没有产生时通常是不可避免的。值非常相似、完全随机或以排好序的方式被插入都将使得统计信息倾斜于真实数据中的值分布。
    </para>
   </listitem>

   <listitem>
<!--==========================orignal english content==========================
    <para>
     When indexes are not used, it can be useful for testing to force
     their use.  There are run-time parameters that can turn off
     various plan types (see <xref linkend="runtime-config-query-enable"/>).
     For instance, turning off sequential scans
     (<varname>enable_seqscan</varname>) and nested-loop joins
     (<varname>enable_nestloop</varname>), which are the most basic plans,
     will force the system to use a different plan.  If the system
     still chooses a sequential scan or nested-loop join then there is
     probably a more fundamental reason why the index is not being
     used; for example, the query condition does not match the index.
     (What kind of query can use what kind of index is explained in
     the previous sections.)
    </para>
____________________________________________________________________________-->
    <para>
     如果索引没有被用到，强制使用它们将会对测试非常有用。有一些运行时参数可以关闭多种计划类型（参见<xref linkend="runtime-config-query-enable"/>）。例如，关闭顺序扫描（<varname>enable_seqscan</varname>）以及嵌套循环连接（<varname>enable_nestloop</varname>）将强制系统使用一种不同的计划。如果系统仍然选择使用一个顺序扫描或嵌套循环连接，则索引没有被使用的原因可能更加根本，例如查询条件不匹配索引（哪种查询能够使用哪种索引已经在前面的小节中解释过了）。
    </para>
   </listitem>

   <listitem>
<!--==========================orignal english content==========================
    <para>
     If forcing index usage does use the index, then there are two
     possibilities: Either the system is right and using the index is
     indeed not appropriate, or the cost estimates of the query plans
     are not reflecting reality.  So you should time your query with
     and without indexes.  The <command>EXPLAIN ANALYZE</command>
     command can be useful here.
    </para>
____________________________________________________________________________-->
    <para>
     如果强制索引使用确实使用了索引，则有两种可能性：系统是正确的并且索引确实不合适，或者查询计划的代价估计并没有反映真实情况。因此你应该对用索引的查询和不用索引的查询计时。此时<command>EXPLAIN ANALYZE</command>命令就能发挥作用了。
    </para>
   </listitem>

   <listitem>
<!--==========================orignal english content==========================
    <para>
     If it turns out that the cost estimates are wrong, there are,
     again, two possibilities.  The total cost is computed from the
     per-row costs of each plan node times the selectivity estimate of
     the plan node.  The costs estimated for the plan nodes can be adjusted
     via run-time parameters (described in <xref
     linkend="runtime-config-query-constants"/>).
     An inaccurate selectivity estimate is due to
     insufficient statistics.  It might be possible to improve this by
     tuning the statistics-gathering parameters (see
     <xref linkend="sql-altertable"/>).
    </para>
____________________________________________________________________________-->
    <para>
     如果发现代价估计是错误的，也分为两种可能性。总代价是用每个计划节点的每行代价乘以计划节点的选择度估计来计算的。计划节点的代价估计可以通过运行时参数调整（如<xref linkend="runtime-config-query-constants"/>所述）。不准确的选择度估计可能是由于缺乏统计信息，可以通过调节统计信息收集参数（见<xref linkend="sql-altertable"/>）来改进。
    </para>

<!--==========================orignal english content==========================
    <para>
     If you do not succeed in adjusting the costs to be more
     appropriate, then you might have to resort to forcing index usage
     explicitly.  You might also want to contact the
     <productname>PostgreSQL</productname> developers to examine the issue.
    </para>
____________________________________________________________________________-->
    <para>
     如果你不能成功地把代价调整得更合适，那么你可能必须依靠显式地强制索引使用。你也可能希望联系<productname>PostgreSQL</productname>开发者来检查该问题。
    </para>
   </listitem>
  </itemizedlist>
 </sect1>
</chapter>
