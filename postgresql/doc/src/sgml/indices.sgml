<!-- doc/src/sgml/indices.sgml -->

<chapter id="indexes">
 <!-- 
 <title>Indexes</title> 
 -->
 <title>索引</title>

 <indexterm zone="indexes">
  <!-- 
  <primary>index</primary> 
  -->
  <primary>索引</primary>
 </indexterm>

 <!--
<para>
  Indexes are a common way to enhance database performance.  An index
  allows the database server to find and retrieve specific rows much
  faster than it could do without an index.  But indexes also add
  overhead to the database system as a whole, so they should be used
  sensibly.
 </para>
-->
<para>
索引是提高数据库性能的常用方法。
索引可以令数据库服务器以比没有索引快得多的速度查找和检索特定的行。
不过索引也在总体上增加了数据库系统的负荷，因此我们应该恰当地使用它们。
</para>


 <sect1 id="indexes-intro">
  <!-- 
  <title>Introduction</title> 
  -->
  <title>介绍</title>
  
<para>
<!--
   Suppose we have a table similar to this:
-->
假设有像下面这样一个表：
<programlisting>
CREATE TABLE test1 (
    id integer,
    content varchar
);
</programlisting>
   <!-- and the application issues many queries of the form: -->
   发出大量下面这样的语句进行查询：
<programlisting>
SELECT content FROM test1 WHERE id = <replaceable>constant</replaceable>;
</programlisting>
<!-- 
   With no advance preparation, the system would have to scan the entire
   <structname>test1</structname> table, row by row, to find all
   matching entries.  If there are many rows in
   <structname>test1</structname> and only a few rows (perhaps zero
   or one) that would be returned by such a query, this is clearly an
   inefficient method.  But if the system has been instructed to maintain an
   index on the <structfield>id</structfield> column, it can use a more
   efficient method for locating matching rows.  For instance, it
   might only have to walk a few levels deep into a search tree. 
-->
通常，数据库系统不得不一行一行地扫描整个<structname>test1</structname>
表以寻找所有匹配的记录。如果在<structname>test1</structname>里面有许多行，
但是只返回少数几行(可能是零行或一行)，那么上面这个方法可就很差劲了。
如果我们让数据库系统在<structfield>id</structfield>列上维护一个索引用于定位匹配的行。
这样，数据库系统只需要在搜索树中走少数的几层就可以找到匹配行。
  </para>

  <!--
<para>
   A similar approach is used in most non-fiction books:  terms and
   concepts that are frequently looked up by readers are collected in
   an alphabetic index at the end of the book.  The interested reader
   can scan the index relatively quickly and flip to the appropriate
   page(s), rather than having to read the entire book to find the
   material of interest.  Just as it is the task of the author to
   anticipate the items that readers are likely to look up,
   it is the task of the database programmer to foresee which indexes
   will be useful.
  </para>
-->
<para>
在大多数非小说的书籍里面都使用了类似这样的方法：在书的背后收集着读者会经常查找的术语和概念的索引，
并按照字母顺序排列。有兴趣的读者可以快速地扫描该索引并且切换到合适的页，
因此不用阅读整本书就能查找到感兴趣的位置。作者的任务之一就是预计哪些项是读者最需要查找的东西，
与之类似，预计哪些索引可以带来便利也是数据库程序员的任务。
</para>

  
<para>
<!--
   The following command can be used to create an index on the
   <structfield>id</structfield> column, as discussed:
-->
下面的命令可以用于在<structfield>id</structfield>列上创建前面讨论过的索引：
<programlisting>
CREATE INDEX test1_id_index ON test1 (id);
</programlisting>
<!-- 
   The name <structname>test1_id_index</structname> can be chosen
   freely, but you should pick something that enables you to remember
   later what the index was for. 
-->
索引名字<structname>test1_id_index</structname>可以自由选择，
但是应该选那些稍后可以让你回忆起索引含义的名字。
  </para>


  <!--
<para>
   To remove an index, use the <command>DROP INDEX</command> command.
   Indexes can be added to and removed from tables at any time.
  </para>
-->
<para>
要删除一个索引，使用<command>DROP INDEX</command>命令。
你可以在任何时候向表里增加索引或者从表中删除索引。
</para>

  <!--
<para>
   Once an index is created, no further intervention is required: the
   system will update the index when the table is modified, and it will
   use the index in queries when it thinks doing so would be more efficient
   than a sequential table scan.  But you might have to run the
   <command>ANALYZE</command> command regularly to update
   statistics to allow the query planner to make educated decisions.
   See <xref linkend="performance-tips"> for information about
   how to find out whether an index is used and when and why the
   planner might choose <emphasis>not</emphasis> to use an index.
  </para>
-->
<para>
一旦你创建了索引，那么就不需要更多干涉了：当表有修改时系统会更新索引，
并且当系统认为用索引比顺序的表扫描快的时候它就会使用索引。
不过你可能必须经常性地运行<command>ANALYZE</command>命令以更新统计信息，
好让查询规划器能够做出训练有素的判断。参见<xref linkend="performance-tips">
获取关于如何获知是否使用了索引的信息，以及在什么时候、什么原因下规划器会决定
<emphasis>不</emphasis>使用索引。
</para>

  <!--
<para>
   Indexes can also benefit <command>UPDATE</command> and
   <command>DELETE</command> commands with search conditions.
   Indexes can moreover be used in join searches.  Thus,
   an index defined on a column that is part of a join condition can
   also significantly speed up queries with joins.
  </para>
-->
<para>
索引对带搜索条件的<command>UPDATE</command>和<command>DELETE</command>命令也有好处。
索引更可以用于表连接查询。因此，如果你定义了索引的列是连接条件的一部分，
那么它也可以显著提高连接的查询速度。
</para>

  <!--
<para>
   Creating an index on a large table can take a long time.  By default,
   <productname>PostgreSQL</productname> allows reads (<command>SELECT</command> statements) to occur
   on the table in parallel with index creation, but writes (<command>INSERT</command>,
   <command>UPDATE</command>, <command>DELETE</command>) are blocked until the index build is finished.
   In production environments this is often unacceptable.
   It is possible to allow writes to occur in parallel with index
   creation, but there are several caveats to be aware of &mdash;
   for more information see <xref linkend="SQL-CREATEINDEX-CONCURRENTLY"
   endterm="SQL-CREATEINDEX-CONCURRENTLY-title">.
  </para>
-->
<para>
在一个巨大的表上创建索引可能会消耗大量的时间。缺省时，<productname>PostgreSQL</productname>
允许在创建索引的同时读取表(<command>SELECT</command>语句)，但是写入表(<command>INSERT</command>,
<command>UPDATE</command>, <command>DELETE</command>)的动作将被阻塞到索引创建完毕。
在生产环境下这种阻塞通常是不可接受的，因此也允许在创建索引的同时写入表，
但是有一些警告需要注意，更多信息参见<xref linkend="SQL-CREATEINDEX-CONCURRENTLY"
 endterm="SQL-CREATEINDEX-CONCURRENTLY-title">。
</para>

  <!--
<para>
   After an index is created, the system has to keep it synchronized with the
   table.  This adds overhead to data manipulation operations.
   Therefore indexes that are seldom or never used in queries
   should be removed.
  </para>
-->
<para>
创建索引之后，它必须和表保持同步。这些操作增加了数据操作的负荷。
因此我们应该把那些非关键或者根本用不上的索引删除掉。
</para>
 </sect1>


 <sect1 id="indexes-types">
  <!-- 
  <title>Index Types</title> 
  -->
  <title>索引类型</title>

  <!--
<para>
   <productname>PostgreSQL</productname> provides several index types:
   B-tree, Hash, GiST, SP-GiST and GIN.  Each index type uses a different
   algorithm that is best suited to different types of queries.
   By default, the <command>CREATE INDEX</command> command creates
   B-tree indexes, which fit the most common situations.
  </para>
-->
<para>
<productname>PostgreSQL</productname>提供了好几种索引类型：B-tree, Hash, GiST, SP-GiST和GIN 。
每种索引类型都比较适合某些特定的查询类型，因为它们用了不同的算法。缺省时，
<command>CREATE INDEX</command>命令将创建 B-tree 索引，它适合大多数情况。
</para>

  
<para>
   <indexterm>
   <!--
    <primary>index</primary>
-->
<primary>索引</primary>
    <secondary>B-tree</secondary>
   </indexterm>
   <indexterm>
    <primary>B-tree</primary>
    <!-- 
<see>index</see> 
-->
<see>索引</see>
   </indexterm>
<!-- 
   B-trees can handle equality and range queries on data that can be sorted
   into some ordering.
   In particular, the <productname>PostgreSQL</productname> query planner
   will consider using a B-tree index whenever an indexed column is
   involved in a comparison using one of these operators:
-->
B-tree 适合处理那些能够按顺序存储的数据之上的等于和范围查询。
特别是在一个建立了索引的字段涉及到使用 
   <simplelist>
    <member><literal>&lt;</literal></member>
    <member><literal>&lt;=</literal></member>
    <member><literal>=</literal></member>
    <member><literal>&gt;=</literal></member>
    <member><literal>&gt;</literal></member>
   </simplelist>
<!-- 
   Constructs equivalent to combinations of these operators, such as
   <literal>BETWEEN</> and <literal>IN</>, can also be implemented with
   a B-tree index search.  Also, an <literal>IS NULL</> or <literal>IS NOT
   NULL</> condition on an index column can be used with a B-tree index.
-->
操作符之一进行比较的时候，<productname>PostgreSQL</productname>
的查询规划器都会考虑使用 B-tree 索引。等效于这些操作符组合的构造，
比如<literal>BETWEEN</>和<literal>IN</>，也可以用搜索 B-tree 索引实现。
同样，索引列中的<literal>IS NULL</>或<literal>IS NOT NULL</>条件可以和B-tree索引一起使用。
  </para>

  <!--
<para>
   The optimizer can also use a B-tree index for queries involving the
   pattern matching operators <literal>LIKE</> and <literal>~</literal>
   <emphasis>if</emphasis> the pattern is a constant and is anchored to
   the beginning of the string &mdash; for example, <literal>col LIKE
   'foo%'</literal> or <literal>col ~ '^foo'</literal>, but not
   <literal>col LIKE '%bar'</literal>. However, if your database does not
   use the C locale you will need to create the index with a special
   operator class to support indexing of pattern-matching queries; see
   <xref linkend="indexes-opclass"> below. It is also possible to use
   B-tree indexes for <literal>ILIKE</literal> and
   <literal>~*</literal>, but only if the pattern starts with
   non-alphabetic characters, i.e., characters that are not affected by
   upper/lower case conversion.
  </para>
-->
<para>
<emphasis>仅当</emphasis>模式是一个常量，并且锚定在字符串开头的时候，
优化器才会把 B-tree 索引用于模式匹配操作符<literal>LIKE</>和<literal>~</literal>，
比如：<literal>col LIKE 'foo%'</literal>或<literal>col ~ '^foo'</literal>，
但是<literal>col LIKE '%bar'</literal>就不行。同时，如果你的数据库未使用 C 区域设置，
那么你需要用一个特殊的操作符类创建索引来支持模式匹配查询上的索引。
参阅<xref linkend="indexes-opclass">。还有可能将 B-tree 索引用于<literal>ILIKE</literal>
和<literal>~*</literal>，但是仅当模式以非字母字符(不受大小写影响的字符)开头才可以。
</para>

  <!--
<para>
   B-tree indexes can also be used to retrieve data in sorted order.
   This is not always faster than a simple scan and sort, but it is
   often helpful.
  </para>
-->
<para>
B-tree索引也可以用来按照排序顺序检索数据。这并不总是比一个简单的扫描和排序快，
但通常是有帮助的。
</para>

  
<para>
<!--
   <indexterm>
    <primary>index</primary>
    <secondary>hash</secondary>
   </indexterm>
   <indexterm>
    <primary>hash</primary>
    <see>index</see>
   </indexterm>
   Hash indexes can only handle simple equality comparisons.
   The query planner will consider using a hash index whenever an
   indexed column is involved in a comparison using the
   <literal>=</literal> operator.
   The following command is used to create a hash index:
-->
<indexterm>
    <primary>索引</primary>
    <secondary>哈希</secondary>
   </indexterm>
   <indexterm>
    <primary>哈希</primary>
    <see>索引</see>
   </indexterm>
Hash 索引只能处理简单的等于比较。当一个索引了的列涉及到使用<literal>=</literal>
操作符进行比较的时候，查询规划器会考虑使用 Hash 索引。下面的命令用于创建 Hash 索引：
<synopsis>
CREATE INDEX <replaceable>name</replaceable> ON <replaceable>table</replaceable> USING hash (<replaceable>column</replaceable>);
</synopsis>
  </para>

  <caution>
   <!--
<para>
    Hash index operations are not presently WAL-logged,
    so hash indexes might need to be rebuilt with <command>REINDEX</>
    after a database crash if there were unwritten changes.
    Also, changes to hash indexes are not replicated over streaming or
    file-based replication after the initial base backup, so they
    give wrong answers to queries that subsequently use them.
    For these reasons, hash index use is presently discouraged.
   </para>
-->
<para>
Hash 索引操作目前没有记录 WAL 日志，因此如果数据库崩溃有未写入的改变，
我们可能需要用<command>REINDEX</>重建 Hash 索引。另外，
对hash索引的改变在初始的基础备份后不是基于流复制或者基于文件复制的，
所以对于随后使用它们的查询会给出错误的回复。因为这些原因，
我们并不鼓励使用 Hash 索引。
</para>
  </caution>

  
<para>
<!--
   <indexterm>
    <primary>index</primary>
    <secondary>GiST</secondary>
   </indexterm>
   <indexterm>
    <primary>GiST</primary>
    <see>index</see>
   </indexterm>
   GiST indexes are not a single kind of index, but rather an infrastructure
   within which many different indexing strategies can be implemented.
   Accordingly, the particular operators with which a GiST index can be
   used vary depending on the indexing strategy (the <firstterm>operator
   class</>).  As an example, the standard distribution of
   <productname>PostgreSQL</productname> includes GiST operator classes
   for several two-dimensional geometric data types, which support indexed
   queries using these operators:
-->
<indexterm>
    <primary>索引</primary>
    <secondary>GiST</secondary>
   </indexterm>
   <indexterm>
    <primary>GiST</primary>
    <see>索引</see>
   </indexterm>
GiST 索引不是单独一种索引类型，而是一种架构，可以在这种架构上实现很多不同的索引策略。
因此，可以使用 GiST 索引的特定操作符类型高度依赖于索引策略(<firstterm>操作符类</>)。
作为示例，<productname>PostgreSQL</productname>的标准发布中包含用于二维几何数据类型的
 GiST 操作符类，它支持 
   <simplelist>
    <member><literal>&lt;&lt;</literal></member>
    <member><literal>&amp;&lt;</literal></member>
    <member><literal>&amp;&gt;</literal></member>
    <member><literal>&gt;&gt;</literal></member>
    <member><literal>&lt;&lt;|</literal></member>
    <member><literal>&amp;&lt;|</literal></member>
    <member><literal>|&amp;&gt;</literal></member>
    <member><literal>|&gt;&gt;</literal></member>
    <member><literal>@&gt;</literal></member>
    <member><literal>&lt;@</literal></member>
    <member><literal>~=</literal></member>
    <member><literal>&amp;&amp;</literal></member>
   </simplelist>

<!-- 
   (See <xref linkend="functions-geometry"> for the meaning of
   these operators.)
   Many other GiST operator
   classes are available in the <literal>contrib</> collection or as separate
   projects.  For more information see <xref linkend="GiST">. 
-->
操作符的索引查询。这些操作符的含义参见<xref linkend="functions-geometry">。
许多其它 GiST 操作符类可用于<literal>contrib</>中，或者是单独的项目，
更多信息参见<xref linkend="GiST">。
  </para>

  
<para>
<!--
   GiST indexes are also capable of optimizing <quote>nearest-neighbor</>
   searches, such as
-->
GiST索引也可最优化<quote>nearest-neighbor</>检索，例如
<programlisting><![CDATA[
SELECT * FROM places ORDER BY location <-> point '(101,456)' LIMIT 10;
]]>
</programlisting>
<!-- 
   which finds the ten places closest to a given target point.  The ability
   to do this is again dependent on the particular operator class being used. 
-->
找出距离给出目标点最近的十个地点。能这样做也是依赖于使用特定的操作符类。
  </para>
  
<para>
<!--
   <indexterm>
    <primary>index</primary>
    <secondary>SP-GiST</secondary>
   </indexterm>
   <indexterm>
    <primary>SP-GiST</primary>
    <see>index</see>
   </indexterm>
   SP-GiST indexes, like GiST indexes, offer an infrastructure that supports
   various kinds of searches.  SP-GiST permits implementation of a wide range
   of different non-balanced disk-based data structures, such as quadtrees,
   k-d trees, and radix trees (tries).  As an example, the standard distribution of
   <productname>PostgreSQL</productname> includes SP-GiST operator classes
   for two-dimensional points, which support indexed
   queries using these operators:
-->
   <indexterm>
    <primary>索引</primary>
    <secondary>SP-GiST</secondary>
   </indexterm>
   <indexterm>
    <primary>SP-GiST</primary>
    <see>索引</see>
   </indexterm>
SP-GiST索引类似于GiST索引，提供一个支持不同类型检索的架构。
SP-GiST允许广泛不同的非平衡基于磁盘的数据结构的实施，例如四叉树，k-d树和根树(尝试)。
作为示例，<productname>PostgreSQL</productname>的标准发布中包含用于二维点的SP-GiST操作符类，
它支持
   <simplelist>
    <member><literal>&lt;&lt;</literal></member>
    <member><literal>&gt;&gt;</literal></member>
    <member><literal>~=</literal></member>
    <member><literal>&lt;@</literal></member>
    <member><literal>&lt;^</literal></member>
    <member><literal>&gt;^</literal></member>
   </simplelist>

<!-- 
   (See <xref linkend="functions-geometry"> for the meaning of
   these operators.)
   For more information see <xref linkend="SPGiST">.
-->
操作符的索引查询。（这些操作符的含义参见<xref linkend="functions-geometry">。）
更多信息参见<xref linkend="SPGiST">。
  </para>

  
<para>
<!--
   <indexterm>
    <primary>index</primary>
    <secondary>GIN</secondary>
   </indexterm>
   <indexterm>
    <primary>GIN</primary>
    <see>index</see>
   </indexterm>
   GIN indexes are inverted indexes which can handle values that contain more
   than one key, arrays for example. Like GiST and SP-GiST, GIN can support
   many different user-defined indexing strategies and the particular
   operators with which a GIN index can be used vary depending on the
   indexing strategy.
   As an example, the standard distribution of
   <productname>PostgreSQL</productname> includes GIN operator classes
   for one-dimensional arrays, which support indexed
   queries using these operators:
-->
   <indexterm>
    <primary>索引</primary>
    <secondary>GIN</secondary>
   </indexterm>
   <indexterm>
    <primary>GIN</primary>
    <see>索引</see>
   </indexterm>
GIN 索引是反转索引，它可以处理包含多个键的值(比如数组)。与 GiST和SP-GiST 类似，
GIN 支持用户定义的索引策略，可以使用 GIN 索引的特定操作符类型根据索引策略的不同而不同。
作为示例，<productname>PostgreSQL</productname>的标准发布中包含用于一维数组的
GIN 操作符类，它支持 
   <simplelist>
    <member><literal>&lt;@</literal></member>
    <member><literal>@&gt;</literal></member>
    <member><literal>=</literal></member>
    <member><literal>&amp;&amp;</literal></member>
   </simplelist>
<!-- 
   (See <xref linkend="functions-array"> for the meaning of
   these operators.)
   Many other GIN operator
   classes are available in the <literal>contrib</> collection or as separate
   projects.  For more information see <xref linkend="GIN">.
-->
操作符的索引查询。这些操作符的含义参见<xref linkend="functions-array">。
许多其它 GIN 操作符类可用于<literal>contrib</>集合或作为单独的项目。
更多信息参见<xref linkend="GIN">。
  </para>

 </sect1>


 <sect1 id="indexes-multicolumn">
  <!-- 
  <title>Multicolumn Indexes</title> 
  -->
  <title>多字段索引</title>

  <indexterm zone="indexes-multicolumn">
   <!-- 
   <primary>index</primary>
   <secondary>multicolumn</secondary> 
   -->
   <primary>索引</primary>
   <secondary>多字段</secondary>
  </indexterm>

  
<para>
<!--
   An index can be defined on more than one column of a table.  For example, if
   you have a table of this form:
-->
一个索引可以定义在表中多个字段上。比如下面这样的表(把<filename class="directory">/dev</filename>
目录保存在一个数据库里)：
<programlisting>
CREATE TABLE test2 (
  major int,
  minor int,
  name varchar
);
</programlisting>
<!-- 
   (say, you keep your <filename class="directory">/dev</filename>
   directory in a database...) and you frequently issue queries like: 
-->
并且你经常发出下面这样的查询：
<programlisting>
SELECT name FROM test2 WHERE major = <replaceable>constant</replaceable> AND minor = <replaceable>constant</replaceable>;
</programlisting>
<!-- 
   then it might be appropriate to define an index on the columns
   <structfield>major</structfield> and
   <structfield>minor</structfield> together, e.g.: 
-->
那么在字段<structfield>major</structfield>和<structfield>minor</structfield>
上联合定义一个索引是比较合适的做法，也就是：
<programlisting>
CREATE INDEX test2_mm_idx ON test2 (major, minor);
</programlisting>
  </para>

  <!--
<para>
   Currently, only the B-tree, GiST and GIN index types support multicolumn
   indexes.  Up to 32 columns can be specified.  (This limit can be
   altered when building <productname>PostgreSQL</productname>; see the
   file <filename>pg_config_manual.h</filename>.)
  </para>
-->
<para>
目前，只有 B-tree , GiST和 GIN 支持多字段索引。缺省最多可以声明 32 个字段
(这个限制可以在编译<productname>PostgreSQL</productname>时改变，
见<filename>pg_config_manual.h</filename>文件)。
</para>

  <!--
<para>
   A multicolumn B-tree index can be used with query conditions that
   involve any subset of the index's columns, but the index is most
   efficient when there are constraints on the leading (leftmost) columns.
   The exact rule is that equality constraints on leading columns, plus
   any inequality constraints on the first column that does not have an
   equality constraint, will be used to limit the portion of the index
   that is scanned.  Constraints on columns to the right of these columns
   are checked in the index, so they save visits to the table proper, but
   they do not reduce the portion of the index that has to be scanned.
   For example, given an index on <literal>(a, b, c)</literal> and a
   query condition <literal>WHERE a = 5 AND b &gt;= 42 AND c &lt; 77</>,
   the index would have to be scanned from the first entry with
   <literal>a</> = 5 and <literal>b</> = 42 up through the last entry with
   <literal>a</> = 5.  Index entries with <literal>c</> &gt;= 77 would be
   skipped, but they'd still have to be scanned through.
   This index could in principle be used for queries that have constraints
   on <literal>b</> and/or <literal>c</> with no constraint on <literal>a</>
   &mdash; but the entire index would have to be scanned, so in most cases
   the planner would prefer a sequential table scan over using the index.
  </para>
-->
<para>
一个多字段的 B-tree 索引可以用在包含索引字段子集的查询条件里，不过，
如果在前导字段(最左边)上有约束条件，那么效率最高。准确的规则是前导字段上的等于约束，
加上第一个没有等于约束的非等于约束字段，将用于限制所扫描的索引范围。
将检查这两个字段右边字段上的索引以减少对表的访问，但是并不减少需要扫描的索引。比如，
假如我们有一个在<literal>(a, b, c)</literal>上的索引，查询条件是<literal>WHERE a = 5 AND b &gt;= 42 AND c &lt; 77</>，
那么索引就需要先扫描所有<literal>a</>= 5 且<literal>b</>= 42 ，直到所有<literal>a</> = 5 
的记录扫描完毕。那些<literal>c</> &gt;= 77的索引条目将被忽略，但是他们仍然会被扫描。
这个索引原则上仍然会被用于那些在<literal>b</>和/或<literal>c</>上有约束，
但是在<literal>a</>上没有约束的查询，但是就必须扫描整个索引了。因此，在大多数这种情况下，
优化器会选择顺序扫描表，而不使用索引。
</para>

  <!--
<para>
   A multicolumn GiST index can be used with query conditions that
   involve any subset of the index's columns. Conditions on additional
   columns restrict the entries returned by the index, but the condition on
   the first column is the most important one for determining how much of
   the index needs to be scanned.  A GiST index will be relatively
   ineffective if its first column has only a few distinct values, even if
   there are many distinct values in additional columns.
  </para>
-->
<para>
一个多字段的 GiST 索引可以用于那些查询条件包含索引字段子集的查询中。
附加字段上的条件会限制索引返回的条目，
但是第一个字段上的条件是决定需要扫描多少索引内容的最重要的字段。
如果在第一个字段上只有很少的一些唯一的数值，那么 GiST 就相对来说不那么高效了，
即使在附加字段上有许多独立的数值也如此。
</para>

  <!--
<para>
   A multicolumn GIN index can be used with query conditions that
   involve any subset of the index's columns. Unlike B-tree or GiST,
   index search effectiveness is the same regardless of which index column(s)
   the query conditions use.
  </para>
-->
<para>
一个多字段的 GIN 索引可以用于那些查询条件包含索引字段子集的查询中。
不像B-tree 或 GiST，除了查询条件使用的索引字段外，索引的搜索效率是相同的。
</para>

  <!--
<para>
   Of course, each column must be used with operators appropriate to the index
   type; clauses that involve other operators will not be considered.
  </para>
-->
<para>
当然，每个字段都必须和适合该索引类型的操作符一起使用；包含其它操作符的子句将不会被考虑。
</para>

  <!--
<para>
   Multicolumn indexes should be used sparingly.  In most situations,
   an index on a single column is sufficient and saves space and time.
   Indexes with more than three columns are unlikely to be helpful
   unless the usage of the table is extremely stylized.  See also
   <xref linkend="indexes-bitmap-scans"> for some discussion of the
   merits of different index configurations.
  </para>
-->
<para>
使用多字段索引应该谨慎。在大多数情况下，在单字段上的索引就足够了，并且还节约时间和空间。
除非表的使用模式非常固定，否则超过三个字段的索引几乎没什么用处。
又见<xref linkend="indexes-bitmap-scans">获取有关不同索引设置的优缺点的讨论。
</para>
 </sect1>


 <sect1 id="indexes-ordering">
  <!-- 
  <title>Indexes and <literal>ORDER BY</></title> 
  -->
  <title>索引和<literal>ORDER BY</></title>

  <indexterm zone="indexes-ordering">
   <!-- 
   <primary>index</primary>
   <secondary>and <literal>ORDER BY</></secondary> 
   -->
   <primary>索引</primary>
   <secondary>和<literal>ORDER BY</></secondary>
  </indexterm>

  <!--
<para>
   In addition to simply finding the rows to be returned by a query,
   an index may be able to deliver them in a specific sorted order.
   This allows a query's <literal>ORDER BY</> specification to be honored
   without a separate sorting step.  Of the index types currently
   supported by <productname>PostgreSQL</productname>, only B-tree
   can produce sorted output &mdash; the other index types return
   matching rows in an unspecified, implementation-dependent order.
  </para>
-->
<para>
除了只是返回查询到的行，索引可以以一个特定的顺序传送它们。这样就允许查询的<literal>ORDER BY</>
说明可以不用一个单独的排序步骤。当前<productname>PostgreSQL</productname>支持的索引类型，
只有 B-tree 可以产生排序的输出&mdash;其他的索引类型返回的行是非指定的、依赖于实现的顺序。
</para>

  <!--
<para>
   The planner will consider satisfying an <literal>ORDER BY</> specification
   either by scanning an available index that matches the specification,
   or by scanning the table in physical order and doing an explicit
   sort.  For a query that requires scanning a large fraction of the
   table, an explicit sort is likely to be faster than using an index
   because it requires
   less disk I/O due to following a sequential access pattern.  Indexes are
   more useful when only a few rows need be fetched.  An important
   special case is <literal>ORDER BY</> in combination with
   <literal>LIMIT</> <replaceable>n</>: an explicit sort will have to process
   all the data to identify the first <replaceable>n</> rows, but if there is
   an index matching the <literal>ORDER BY</>, the first <replaceable>n</>
   rows can be retrieved directly, without scanning the remainder at all.
  </para>
-->
<para>
规划器将考虑满足<literal>ORDER BY</>声明，通过扫描匹配声明的可用的索引，
或者通过扫描物理顺序的表和做一个明确的排序。对于一个需要扫描表的一大部分的查询，
明确的排序可能要比使用索引快的多，因为它使用顺序存取模式所以需要较少的磁盘I/O。
当只需要获取几行时，索引是更有效的。一个重要的特殊情况是<literal>ORDER BY</>和
<literal>LIMIT</> <replaceable>n</>一起使用:一个明确的排序将处理所有的数据以识别前 
<replaceable>n</>行，但是如果有一个索引匹配<literal>ORDER BY</>，那么前<replaceable>n</>
行可以直接找出，而不用扫描剩下的部分。
</para>

  <!--
<para>
   By default, B-tree indexes store their entries in ascending order
   with nulls last.  This means that a forward scan of an index on
   column <literal>x</> produces output satisfying <literal>ORDER BY x</>
   (or more verbosely, <literal>ORDER BY x ASC NULLS LAST</>).  The
   index can also be scanned backward, producing output satisfying
   <literal>ORDER BY x DESC</>
   (or more verbosely, <literal>ORDER BY x DESC NULLS FIRST</>, since
   <literal>NULLS FIRST</> is the default for <literal>ORDER BY DESC</>).
  </para>
-->
<para>
默认的，B-tree索引以递增、空值最后的顺序存储记录。这意味着在字段<literal>x</>
上向前扫描索引产生的输出满足<literal>ORDER BY x</>（或者<literal>ORDER BY x ASC NULLS LAST</>）。
索引扫描也可以向后扫描，产生的输出满足<literal>ORDER BY x DESC</>（或者
<literal>ORDER BY x DESC NULLS FIRST</>，因为<literal>NULLS FIRST</>默认是<literal>ORDER BY DESC</>）。
</para>
  
<para>
<!--
   You can adjust the ordering of a B-tree index by including the
   options <literal>ASC</>, <literal>DESC</>, <literal>NULLS FIRST</>,
   and/or <literal>NULLS LAST</> when creating the index; for example:
-->
创建索引时，可以通过包含选项<literal>ASC</>, <literal>DESC</>, <literal>NULLS FIRST</>,
和/或 <literal>NULLS LAST</>调整B-tree索引的顺序；例如：
<programlisting>
CREATE INDEX test2_info_nulls_low ON test2 (info NULLS FIRST);
CREATE INDEX test3_desc_index ON test3 (id DESC NULLS LAST);
</programlisting>
<!-- 
   An index stored in ascending order with nulls first can satisfy
   either <literal>ORDER BY x ASC NULLS FIRST</> or
   <literal>ORDER BY x DESC NULLS LAST</> depending on which direction
   it is scanned in. 
-->
以递增顺序、空值在前的顺序存储的索引可以满足<literal>ORDER BY x ASC NULLS FIRST</>或
<literal>ORDER BY x DESC NULLS LAST</>，取决于扫描的方向。
  </para>

  <!--
<para>
   You might wonder why bother providing all four options, when two
   options together with the possibility of backward scan would cover
   all the variants of <literal>ORDER BY</>.  In single-column indexes
   the options are indeed redundant, but in multicolumn indexes they can be
   useful.  Consider a two-column index on <literal>(x, y)</>: this can
   satisfy <literal>ORDER BY x, y</> if we scan forward, or
   <literal>ORDER BY x DESC, y DESC</> if we scan backward.
   But it might be that the application frequently needs to use
   <literal>ORDER BY x ASC, y DESC</>.  There is no way to get that
   ordering from a plain index, but it is possible if the index is defined
   as <literal>(x ASC, y DESC)</> or <literal>(x DESC, y ASC)</>.
  </para>
-->
<para>
你可能想知道为什么麻烦的提供所有的四个选项，当向后扫描时两个选项可以包含<literal>ORDER BY</>
的所有变体。在单字段索引中，这些选项确实冗余，但是在多字段索引中，它们就是有用的了。
考虑一个在<literal>(x, y)</>上的两字段索引：当我们向前扫描时，可以满足<literal>ORDER BY x, y</>，
或者当我们向后扫描时，可以满足<literal>ORDER BY x DESC, y DESC</>。但是可能应用经常的需要使用
<literal>ORDER BY x ASC, y DESC</>。在普通的索引上无法得到这种顺序，但是如果索引定义为
<literal>(x ASC, y DESC)</>或<literal>(x DESC, y ASC)</>就是可能的了。
</para>

  <!--
<para>
   Obviously, indexes with non-default sort orderings are a fairly
   specialized feature, but sometimes they can produce tremendous
   speedups for certain queries.  Whether it's worth maintaining such an
   index depends on how often you use queries that require a special
   sort ordering.
  </para>
-->
<para>
明显的，没有默认排序顺序的索引是比较专业的特征，但是有时它们对特定的查询可以产生极大的加速。
是否值得维持这样的索引取决于你使用需要特殊排序顺序的查询的频率。
</para>
 </sect1>


 <sect1 id="indexes-bitmap-scans">
  <!-- 
  <title>Combining Multiple Indexes</title> 
  -->
  <title>组合多个索引</title>

  <indexterm zone="indexes-bitmap-scans">
   <!-- 
   <primary>index</primary>
   <secondary>combining multiple indexes</secondary>
   -->
   <primary>索引</primary>
   <secondary>组合多个索引</secondary>
  </indexterm>

  <indexterm zone="indexes-bitmap-scans">
   <!-- 
   <primary>bitmap scan</primary> 
   -->
   <primary>位图扫描</primary>
  </indexterm>

  <!--
<para>
   A single index scan can only use query clauses that use the index's
   columns with operators of its operator class and are joined with
   <literal>AND</>.  For example, given an index on <literal>(a, b)</literal>
   a query condition like <literal>WHERE a = 5 AND b = 6</> could
   use the index, but a query like <literal>WHERE a = 5 OR b = 6</> could not
   directly use the index.
  </para>
-->
<para>
一个单独的索引扫描只能用于这样的条件子句：使用被索引字段和索引操作符类中操作符，
并这些条件以<literal>AND</>连接。假设在<literal>(a, b)</literal>上有一个索引，
那么类似<literal>WHERE a = 5 AND b = 6</>的条件可以使用索引，但是像
<literal>WHERE a = 5 OR b = 6</>的条件就不能直接使用索引。
</para>

  <!--
<para>
   Fortunately,
   <productname>PostgreSQL</> has the ability to combine multiple indexes
   (including multiple uses of the same index) to handle cases that cannot
   be implemented by single index scans.  The system can form <literal>AND</>
   and <literal>OR</> conditions across several index scans.  For example,
   a query like <literal>WHERE x = 42 OR x = 47 OR x = 53 OR x = 99</>
   could be broken down into four separate scans of an index on <literal>x</>,
   each scan using one of the query clauses.  The results of these scans are
   then ORed together to produce the result.  Another example is that if we
   have separate indexes on <literal>x</> and <literal>y</>, one possible
   implementation of a query like <literal>WHERE x = 5 AND y = 6</> is to
   use each index with the appropriate query clause and then AND together
   the index results to identify the result rows.
  </para>
-->
<para>
幸运的，<productname>PostgreSQL</>能够组合多个索引(包括同一索引的多次使用)
来处理单个索引扫描不能实现的情况。系统可以在多个索引扫描之间组成<literal>AND</>
和<literal>OR</>条件。比如，一个类似<literal>WHERE x = 42 OR x = 47 OR x = 53 OR x = 99</>
这样的查询可以分解成四个在<literal>x</>上的独立扫描，每个扫描使用一个条件，
最后将这些扫描的结果 OR 在一起，生成最终结果。另外一个例子是，如果我们在<literal>x</>
和<literal>y</>上有独立的索引，一个类似<literal>WHERE x = 5 AND y = 6</>
这样的查询可以分解为几个使用独立索引的子句，然后把这几个结果 AND 在一起，生成最终结果。
</para>

  <!--
<para>
   To combine multiple indexes, the system scans each needed index and
   prepares a <firstterm>bitmap</> in memory giving the locations of
   table rows that are reported as matching that index's conditions.
   The bitmaps are then ANDed and ORed together as needed by the query.
   Finally, the actual table rows are visited and returned.  The table rows
   are visited in physical order, because that is how the bitmap is laid
   out; this means that any ordering of the original indexes is lost, and
   so a separate sort step will be needed if the query has an <literal>ORDER
   BY</> clause.  For this reason, and because each additional index scan
   adds extra time, the planner will sometimes choose to use a simple index
   scan even though additional indexes are available that could have been
   used as well.
  </para>
-->
<para>
为了组合多个索引，系统扫描每个需要的索引，然后在内存里组织一个<firstterm>位图</>，
它给出索引扫描报告中符合索引条件的表数据行位置。然后，根据查询的需要，
把这个位图使用 AND 和 OR 合并在一起。最后，访问实际的表检索并返回数据行。
表的数据行是按照物理顺序进行访问的，因为那就是位图的布局；
这就意味着任何原来的索引排序都将消失，而如果查询有一个<literal>ORDER BY</>子句，
那么还会有一个额外的排序步骤。因为这个原因，以及每个额外的索引扫描都增加了额外的时间，
规划器有时候会选择使用简单的索引扫描，即使有多个索引可用也如此。
</para>

  <!--
<para>
   In all but the simplest applications, there are various combinations of
   indexes that might be useful, and the database developer must make
   trade-offs to decide which indexes to provide.  Sometimes multicolumn
   indexes are best, but sometimes it's better to create separate indexes
   and rely on the index-combination feature.  For example, if your
   workload includes a mix of queries that sometimes involve only column
   <literal>x</>, sometimes only column <literal>y</>, and sometimes both
   columns, you might choose to create two separate indexes on
   <literal>x</> and <literal>y</>, relying on index combination to
   process the queries that use both columns.  You could also create a
   multicolumn index on <literal>(x, y)</>.  This index would typically be
   more efficient than index combination for queries involving both
   columns, but as discussed in <xref linkend="indexes-multicolumn">, it
   would be almost useless for queries involving only <literal>y</>, so it
   should not be the only index.  A combination of the multicolumn index
   and a separate index on <literal>y</> would serve reasonably well.  For
   queries involving only <literal>x</>, the multicolumn index could be
   used, though it would be larger and hence slower than an index on
   <literal>x</> alone.  The last alternative is to create all three
   indexes, but this is probably only reasonable if the table is searched
   much more often than it is updated and all three types of query are
   common.  If one of the types of query is much less common than the
   others, you'd probably settle for creating just the two indexes that
   best match the common types.
  </para>
-->
<para>
在大多数最简单的应用里，可能有多种索引组合都是有用的，数据库开发人员必须在使用哪个索引之间作出平衡。
有时候多字段索引是最好的，有时候创建一个独立索引并依靠索引组合是最好的。比如，
假如你的查询有时候只涉及字段<literal>x</>，有时候只涉及字段<literal>y</>，有时候两个字段都涉及，
那么你可能会选择在<literal>x</>和<literal>y</>上创建两个独立的索引，
然后依靠索引组合来处理同时使用两个字段的查询。你也可以在<literal>(x, y)</>上创建一个多字段索引，
它在同时使用两个字段的查询通常比索引组合更高效，但是，正如我们在<xref linkend="indexes-multicolumn">
里面讨论的，它对那些只包含<literal>y</>的查询几乎没有用，因此它不能是唯一一个索引。
一个多字段索引和<literal>y</>上的独立索引可能会更好。因为对那些只涉及<literal>x</>的查询，
可以使用多字段索引，但是它会更大，因此也比只在<literal>x</>上的索引更慢。最后一个选择是创建三个索引，
但是这种方法只有在表的更新远比查询少得多，并且所有三种查询都很普遍的情况下才是合理的。
如果其中一种查询比其它的少很多，那么你可能更愿意仅仅创建两种匹配更常见查询的索引。
</para>

 </sect1>


 <sect1 id="indexes-unique">
  <!-- 
  <title>Unique Indexes</title> 
  -->
  <title>唯一索引</title>

  <indexterm zone="indexes-unique">
   <!-- 
   <primary>index</primary>
   <secondary>unique</secondary>
   -->
   <primary>索引</primary>
   <secondary>唯一</secondary>
  </indexterm>

<para>
<!--
   Indexes can also be used to enforce uniqueness of a column's value,
   or the uniqueness of the combined values of more than one column.
-->
索引还可以用于强迫字段数值的唯一性，或者是多个字段组合值的唯一性。
<synopsis>
CREATE UNIQUE INDEX <replaceable>name</replaceable> ON <replaceable>table</replaceable> (<replaceable>column</replaceable> <optional>, ...</optional>);
</synopsis>
<!-- 
   Currently, only B-tree indexes can be declared unique. 
-->
目前，只有 B-tree 索引可以声明为唯一。
  </para>

  <!--
<para>
   When an index is declared unique, multiple table rows with equal
   indexed values are not allowed.  Null values are not considered
   equal.  A multicolumn unique index will only reject cases where all
   indexed columns are equal in multiple rows.
  </para>
-->
<para>
如果索引声明为唯一的，那么就不允许出现多个索引值相同的行。NULL 值被认为互不相等。
一个多字段唯一索引只在多行数据里所有被索引字段都相同时才拒绝。
</para>

  <!--
<para>
   <productname>PostgreSQL</productname> automatically creates a unique
   index when a unique constraint or primary key is defined for a table.
   The index covers the columns that make up the primary key or unique
   constraint (a multicolumn index, if appropriate), and is the mechanism
   that enforces the constraint.
  </para>
-->
<para>
如果一个表声明了唯一约束或者主键，那么<productname>PostgreSQL</productname>
自动在组成主键或唯一约束的字段上创建唯一索引(可能是多字段索引)，以强迫这些约束。
</para>

  <note>
   <!--
<para>
    The preferred way to add a unique constraint to a table is
    <literal>ALTER TABLE ... ADD CONSTRAINT</literal>.  The use of
    indexes to enforce unique constraints could be considered an
    implementation detail that should not be accessed directly.
    One should, however, be aware that there's no need to manually
    create indexes on unique columns; doing so would just duplicate
    the automatically-created index.
   </para>
-->
<para>
给表增加唯一约束比较好的办法是<literal>ALTER TABLE ... ADD CONSTRAINT</literal>。
用索引强制唯一约束应该认为是一个实现细节，而不应该直接访问。不过，
我们应该知道没有必要在唯一字段上建立索引，那样做只会重复建立自动创建的索引。
</para>
  </note>
 </sect1>


 <sect1 id="indexes-expressional">
  <!-- 
  <title>Indexes on Expressions</title> 
  -->
  <title>表达式上的索引</title>

  <indexterm zone="indexes-expressional">
   <!-- 
   <primary>index</primary>
   <secondary sortas="expressions">on expressions</secondary> 
   -->
   <primary>索引</primary>
   <secondary sortas="expressions">表达式上</secondary>
  </indexterm>

  <!--
<para>
   An index column need not be just a column of the underlying table,
   but can be a function or scalar expression computed from one or
   more columns of the table.  This feature is useful to obtain fast
   access to tables based on the results of computations.
  </para>
-->
<para>
索引并非一定要是一个底层表的字段，还可以是一个函数或者从一个或多个字段计算出来的标量表达式。
这个特性对于快速访问那些基于计算结果的表非常有用。
</para>
  
<para>
<!--
   For example, a common way to do case-insensitive comparisons is to
   use the <function>lower</function> function:
-->
比如，做大小写无关比较的常用方法是使用<function>lower</function>函数：
<programlisting>
SELECT * FROM test1 WHERE lower(col1) = 'value';
</programlisting>
<!-- 
   This query can use an index if one has been
   defined on the result of the <literal>lower(col1)</literal>
   function:
-->
如果我们在<literal>lower(col1)</literal>函数的结果上定义索引
<programlisting>
CREATE INDEX test1_lower_col1_idx ON test1 (lower(col1));
</programlisting>
  </para>


  <!--
<para>
   If we were to declare this index <literal>UNIQUE</>, it would prevent
   creation of rows whose <literal>col1</> values differ only in case,
   as well as rows whose <literal>col1</> values are actually identical.
   Thus, indexes on expressions can be used to enforce constraints that
   are not definable as simple unique constraints.
  </para>
-->
<para>
那么上述查询就可以使用该索引。如果我们把这个索引声明为<literal>UNIQUE</>，
那么它会禁止创建那种<literal>col1</>数值只是大小写有别或完全相同的数据行。
因此，在表达式上的索引可以用于强制那些无法定义为简单唯一约束的约束。
</para>
  
<para>
<!--
   As another example, if one often does queries like:
-->
另外一个例子是，如果我们经常使用下面这样的查询：
<programlisting>
SELECT * FROM people WHERE (first_name || ' ' || last_name) = 'John Smith';
</programlisting>
   <!-- 
   then it might be worth creating an index like this: 
   -->
   那么我们就值得创建下面这样的索引：
<programlisting>
CREATE INDEX people_names ON people ((first_name || ' ' || last_name));
</programlisting>
  </para>

  <!--
<para>
   The syntax of the <command>CREATE INDEX</> command normally requires
   writing parentheses around index expressions, as shown in the second
   example.  The parentheses can be omitted when the expression is just
   a function call, as in the first example.
  </para>
-->
<para>
<command>CREATE INDEX</>命令的语法通常要求在索引表达式周围书写圆括弧，
就像我们在第二个例子里显示的那样。如果表达式只是一个函数调用，
那么可以省略，就像我们在第一个例子里显示的那样。
</para>

  <!--
<para>
   Index expressions are relatively expensive to maintain, because the
   derived expression(s) must be computed for each row upon insertion
   and whenever it is updated.  However, the index expressions are
   <emphasis>not</> recomputed during an indexed search, since they are
   already stored in the index.  In both examples above, the system
   sees the query as just <literal>WHERE indexedcolumn = 'constant'</>
   and so the speed of the search is equivalent to any other simple index
   query.  Thus, indexes on expressions are useful when retrieval speed
   is more important than insertion and update speed.
  </para>
-->
<para>
从维护角度来看，索引表达式相对费劲一些，因为在插入数据行或者更新数据行的时候，
都必须为每一行计算生成的表达式。不过，索引表达式<emphasis>不是</>在索引查找的时候进行计算的，
因为它们已经存储在索引里了。在上面的两个例子里，系统都把查询看做只是
<literal>WHERE indexedcolumn = 'constant'</>，所以搜索的速度等效于任何其它简单的索引查询。
因此，表达式上的索引在检索速度比插入和更新速度更重要的场合下是有用的。
</para>
 </sect1>


 <sect1 id="indexes-partial">
  <!-- 
  <title>Partial Indexes</title> 
  -->
  <title>部分索引</title>

  <indexterm zone="indexes-partial">
   <!-- 
   <primary>index</primary>
   <secondary>partial</secondary> 
   -->
   <primary>索引</primary>
   <secondary>部分</secondary>
  </indexterm>

  <!--
<para>
   A <firstterm>partial index</firstterm> is an index built over a
   subset of a table; the subset is defined by a conditional
   expression (called the <firstterm>predicate</firstterm> of the
   partial index).  The index contains entries only for those table
   rows that satisfy the predicate.  Partial indexes are a specialized
   feature, but there are several situations in which they are useful.
  </para>
-->
<para>
<firstterm>部分索引</firstterm>是建立在一个表的子集上的索引；
该子集是由一个条件表达式定义的(叫做部分索引的<firstterm>谓词</firstterm>)。
该索引只包含表中那些满足这个谓词的行。部分索引是一个特殊的特性，但是在某些场合很有用。
</para>

  <!--
<para>
   One major reason for using a partial index is to avoid indexing common
   values.  Since a query searching for a common value (one that
   accounts for more than a few percent of all the table rows) will not
   use the index anyway, there is no point in keeping those rows in the
   index at all.  This reduces the size of the index, which will speed
   up those queries that do use the index.  It will also speed up many table
   update operations because the index does not need to be
   updated in all cases.  <xref linkend="indexes-partial-ex1"> shows a
   possible application of this idea.
  </para>
-->
<para>
部分索引的主要动机是为了避免对普通数值(大量重复的数值)建立索引。
因为在普通数值上的查询就算使用索引也没什么好处，那么还不如从索引中剔除这些大量重复的行。
这样可以减小索引尺寸，提高那些真正使用索引的查询的速度。同时它也能提高更新操作的速度，
因为不是所有情况都需要更新索引。<xref linkend="indexes-partial-ex1">
显示了一个潜在的这方面应用的例子。
</para>

  <example id="indexes-partial-ex1">
   <!-- 
   <title>Setting up a Partial Index to Exclude Common Values</title> 
   -->
   <title>设置一个部分索引以排除普通数值</title>

   <!--
<para>
    Suppose you are storing web server access logs in a database.
    Most accesses originate from the IP address range of your organization but
    some are from elsewhere (say, employees on dial-up connections).
    If your searches by IP are primarily for outside accesses,
    you probably do not need to index the IP range that corresponds to your
    organization's subnet.
   </para>
-->
<para>
假设你在数据库中存储 web 服务器的访问日志。大多数访问是从你的组织内部的 IP 地址范围发起的，
但也有一小部分来自其它地方(比如那些通过拨号进行连接的雇员)。如果你主要搜索来自外部访问的 IP ，
那么你就不需要对组织子网的 IP 范围进行索引。
</para>
   
<para>
<!--
    Assume a table like this:
-->
假设表像下面这样：
<programlisting>
CREATE TABLE access_log (
    url varchar,
    client_ip inet,
    ...
);
</programlisting>
   </para>

   
<para>
<!--
    To create a partial index that suits our example, use a command
    such as this:
-->
要创建符合例子的索引，使用像下面这样的命令：
<programlisting>
CREATE INDEX access_log_client_ip_ix ON access_log (client_ip)
WHERE NOT (client_ip &gt; inet '192.168.100.0' AND
           client_ip &lt; inet '192.168.100.255');
</programlisting>
   </para>

   
<para>
<!--
    A typical query that can use this index would be:
-->
一个可以使用这个索引的典型的查询像这样：
<programlisting>
SELECT *
FROM access_log
WHERE url = '/index.html' AND client_ip = inet '212.78.10.32';
</programlisting>
    <!-- 
A query that cannot use this index is: 
-->
一个不能使用这个索引的查询是：
<programlisting>
SELECT *
FROM access_log
WHERE client_ip = inet '192.168.100.23';
</programlisting>
   </para>

   <!--
<para>
    Observe that this kind of partial index requires that the common
    values be predetermined, so such partial indexes are best used for
    data distributions that do not change.  The indexes can be recreated
    occasionally to adjust for new data distributions, but this adds
    maintenance effort.
   </para>
-->
<para>
我们通过观察可以看出，这种类型的部分索引要求普通数值是可以预计的。
所以这种部分索引最好用于没有改变的数据分布。索引可以不定期的重建来适应新数据的分布，
但是这增加了维护工作。
</para>
  </example>

  <!--
<para>
   Another possible use for a partial index is to exclude values from the
   index that the
   typical query workload is not interested in; this is shown in <xref
   linkend="indexes-partial-ex2">.  This results in the same
   advantages as listed above, but it prevents the
   <quote>uninteresting</quote> values from being accessed via that
   index, even if an index scan might be profitable in that
   case.  Obviously, setting up partial indexes for this kind of
   scenario will require a lot of care and experimentation.
  </para>
-->
<para>
另外一个用途在<xref linkend="indexes-partial-ex2">里显示，它把不感兴趣的数值排除在索引之外。
这个结果有与上面列出的同样的优点，但是它完全拒绝了通过索引访问<quote>不感兴趣</quote>的数值，
即使索引扫描可能对那些数据也有利。显然，为这种情况设置部分索引需要非常仔细并且需要大量试验。
</para>

  <example id="indexes-partial-ex2">
   <!-- 
   <title>Setting up a Partial Index to Exclude Uninteresting Values</title>
   -->
   <title>设置一个部分索引以排除不感兴趣的数值</title>
   
<para>
<!--
    If you have a table that contains both billed and unbilled orders,
    where the unbilled orders take up a small fraction of the total
    table and yet those are the most-accessed rows, you can improve
    performance by creating an index on just the unbilled rows.  The
    command to create the index would look like this:
-->
如果你有一个表，包含已付款和未付款的定单，而未付款的定单只占总表的一小部分并且是经常使用的部分，
那么你可以通过只在未付款定单上创建一个索引来改善性能。创建索引的命令看起来会像这样：
<programlisting>
CREATE INDEX orders_unbilled_index ON orders (order_nr)
    WHERE billed is not true;
</programlisting>
   </para>

   
<para>
<!--
    A possible query to use this index would be:
-->
可能用到这个索引的查询看起来像：
<programlisting>
SELECT * FROM orders WHERE billed is not true AND order_nr &lt; 10000;
</programlisting>
<!-- 
    However, the index can also be used in queries that do not involve
    <structfield>order_nr</> at all, e.g.: 
-->
不过，该索引也可以用于那些完全不涉及<structfield>order_nr</>查询，比如：
<programlisting>
SELECT * FROM orders WHERE billed is not true AND amount &gt; 5000.00;
</programlisting>
<!-- 
    This is not as efficient as a partial index on the
    <structfield>amount</> column would be, since the system has to
    scan the entire index.  Yet, if there are relatively few unbilled
    orders, using this partial index just to find the unbilled orders
    could be a win. 
-->
这个查询不像在<structfield>amount</>字段上的部分索引那么有效，
因为系统必须扫描整个索引。但是，如果未付款的定单相对较少，
那么用这个部分索引找出未付款的定单将会更快些。
   </para>
   
<para>
<!--
    Note that this query cannot use this index:
-->
请注意下面这个查询无法使用这个索引：
<programlisting>
SELECT * FROM orders WHERE order_nr = 3501;
</programlisting>
<!-- 
    The order 3501 might be among the billed or unbilled
    orders. 
-->
定单 3501 可能是已付款也可能是未付款。
   </para>
  </example>

  
<para>
<!--
   <xref linkend="indexes-partial-ex2"> also illustrates that the
   indexed column and the column used in the predicate do not need to
   match.  <productname>PostgreSQL</productname> supports partial
   indexes with arbitrary predicates, so long as only columns of the
   table being indexed are involved.  However, keep in mind that the
   predicate must match the conditions used in the queries that
   are supposed to benefit from the index.  To be precise, a partial
   index can be used in a query only if the system can recognize that
   the <literal>WHERE</> condition of the query mathematically implies
   the predicate of the index.
-->
<xref linkend="indexes-partial-ex2">还说明了建了索引的字段和谓词中的字段不必相配。
<productname>PostgreSQL</productname>支持带任意谓词的部分索引，只要只涉及被索引表的字段就行。
不过，我们要记住的是谓词必须和那些希望从该索引中获益的查询条件相匹配。准确说，
只有在系统能够识别出该查询的<literal>WHERE</>条件在数学上蕴涵了该索引的谓词时，
这个部分索引才能用于该查询。
<!-- 
   <productname>PostgreSQL</productname> does not have a sophisticated
   theorem prover that can recognize mathematically equivalent
   expressions that are written in different forms.  (Not
   only is such a general theorem prover extremely difficult to
   create, it would probably be too slow to be of any real use.)
   The system can recognize simple inequality implications, for example
   <quote>x &lt; 1</quote> implies <quote>x &lt; 2</quote>; otherwise
   the predicate condition must exactly match part of the query's
   <literal>WHERE</> condition
   or the index will not be recognized as usable. Matching takes
   place at query planning time, not at run time. As a result,
   parameterized query clauses do not work with a partial index. For
   example a prepared query with a parameter might specify
   <quote>x &lt; ?</quote> which will never imply
   <quote>x &lt; 2</quote> for all possible values of the parameter. 
-->
<productname>PostgreSQL</productname>还没有智能到可以完全识别那些形式不同但数学上相等的谓词。
做到这样不仅非常困难，而且在实际使用中也可能非常慢。系统可以识别简单的不相等蕴涵，
比如<quote>x &lt; 1</quote>蕴涵<quote>x &lt; 2</quote>；否则，谓词条件必须准确匹配查询的
<literal>WHERE</>条件，不然系统将无法识别该索引是可用的。匹配发生在查询规划期间，
而不是运行期间。因此，参数化的查询子句必定不会使用部分索引。例如，
一个预先写好的、带有参数的查询可能指定了<quote>x &lt; ?</quote>，
它不可能对所有可能的参数值都蕴涵<quote>x &lt; 2</quote>。
  </para>

  <!--
<para>
   A third possible use for partial indexes does not require the
   index to be used in queries at all.  The idea here is to create
   a unique index over a subset of a table, as in <xref
   linkend="indexes-partial-ex3">.  This enforces uniqueness
   among the rows that satisfy the index predicate, without constraining
   those that do not.
  </para>
-->
<para>
部分索引的第三种用途是禁止在查询中使用索引。如<xref linkend="indexes-partial-ex3">所示，
这里的概念是在表的子集里创建唯一索引。这样就强制在满足谓词的行中保持唯一性，
而并不约束那些不需要唯一的行。
</para>

  <example id="indexes-partial-ex3">
   <!-- 
   <title>Setting up a Partial Unique Index</title> 
   -->
   <title>设置一个部分唯一索引</title>
   
<para>
<!--
    Suppose that we have a table describing test outcomes.  We wish
    to ensure that there is only one <quote>successful</> entry for
    a given subject and target combination, but there might be any number of
    <quote>unsuccessful</> entries.  Here is one way to do it:
-->
假设我们有一个记录测试输出的表。我们希望确保在每个目标和课题的组合中只有一个
<quote>成功</>记录，但是可以有任意数量的<quote>不成功</>记录。下面是实现方法：
<programlisting>
CREATE TABLE tests (
    subject text,
    target text,
    success boolean,
    ...
);

CREATE UNIQUE INDEX tests_success_constraint ON tests (subject, target)
    WHERE success;
</programlisting>
<!-- 
    This is a particularly efficient approach when there are few
    successful tests and many unsuccessful ones. 
-->
如果只有少数成功测试而有很多不成功测试，那么这是一种非常有效的实现方法。
   </para>
  </example>

  <!--
<para>
   Finally, a partial index can also be used to override the system's
   query plan choices.  Also, data sets with peculiar
   distributions might cause the system to use an index when it really
   should not.  In that case the index can be set up so that it is not
   available for the offending query.  Normally,
   <productname>PostgreSQL</> makes reasonable choices about index
   usage (e.g., it avoids them when retrieving common values, so the
   earlier example really only saves index size, it is not required to
   avoid index usage), and grossly incorrect plan choices are cause
   for a bug report.
  </para>
-->
<para>
最后，部分索引也可以用于取代系统选择的查询规划。同样，如果数据集的分布是比较特定的形状，
那么会导致系统在不该使用索引的时候使用它。在这种情况下，
我们可以把索引设置为在违反规律的查询中不可用。通常<productname>PostgreSQL</>
对索引的使用会做出合理的选择(比如，它在检索普通数值的时候避免使用它，
因此前面的例子实际上只是节约了索引的尺寸，它并不要求避免索引的使用)，
但是如果出现了错误的规划选择那么请提交一个Bug报告。
</para>

  <!--
<para>
   Keep in mind that setting up a partial index indicates that you
   know at least as much as the query planner knows, in particular you
   know when an index might be profitable.  Forming this knowledge
   requires experience and understanding of how indexes in
   <productname>PostgreSQL</> work.  In most cases, the advantage of a
   partial index over a regular index will be minimal.
  </para>
-->
<para>
请记住一件事：设置一个部分索引表示你至少和查询规划器知道的一样多，
特别是你知道什么场合下索引是有效的。要形成这些知识要求你经验丰富并且理解
<productname>PostgreSQL</>的索引是如何运作的。在大多数情况下，
部分索引对普通索引的优势并不太明显。
</para>

  <!--
<para>
   More information about partial indexes can be found in <xref
   linkend="STON89b">, <xref linkend="OLSON93">, and <xref
   linkend="SESHADRI95">.
  </para>
-->
<para>
更多有关部分索引的信息可以在<xref linkend="STON89b">, <xref linkend="OLSON93">, 
和 <xref linkend="SESHADRI95">获得。
</para>
 </sect1>


 <sect1 id="indexes-opclass">
  <!-- 
  <title>Operator Classes and Operator Families</title> 
  -->
  <title>操作符类和操作符族</title>

  <indexterm zone="indexes-opclass">
   <!-- 
   <primary>operator class</primary> 
   -->
   <primary>操作符类</primary>
  </indexterm>

  <indexterm zone="indexes-opclass">
   <!-- 
   <primary>operator family</primary> 
   -->
   <primary>操作符族</primary>
  </indexterm>
 
<para>
 <!--
   An index definition can specify an <firstterm>operator
   class</firstterm> for each column of an index.
-->
定义索引的同时可以为索引的每个字段声明一个<firstterm>操作符类</firstterm>。
<synopsis>
CREATE INDEX <replaceable>name</replaceable> ON <replaceable>table</replaceable> (<replaceable>column</replaceable> <replaceable>opclass</replaceable> <optional><replaceable>sort options</replaceable></optional> <optional>, ...</optional>);
</synopsis>
<!-- 
   The operator class identifies the operators to be used by the index
   for that column.  For example, a B-tree index on the type <type>int4</type>
   would use the <literal>int4_ops</literal> class; this operator
   class includes comparison functions for values of type <type>int4</type>.
   In practice the default operator class for the column's data type is
   usually sufficient.  The main reason for having operator classes is
   that for some data types, there could be more than one meaningful
   index behavior.  For example, we might want to sort a complex-number data
   type either by absolute value or by real part.  We could do this by
   defining two operator classes for the data type and then selecting
   the proper class when making an index.  The operator class determines
   the basic sort ordering (which can then be modified by adding sort options
   <literal>COLLATE</literal>,
   <literal>ASC</>/<literal>DESC</> and/or
   <literal>NULLS FIRST</>/<literal>NULLS LAST</>). 
-->
这个操作符类指明该索引用于该字段时要使用的操作符。例如，一个在<type>int4</type>
上的 B-tree 索引将使用<literal>int4_ops</literal>类；这个操作符类包括用于<type>int4</type>
的比较函数。实际上，字段类型的缺省操作符通常就足够了。拥有操作符类的主要原因是：
对于某些数据类型，可能存在多个有意义的索引行为。例如，我们可能想排序两个复数，
既可能通过绝对值，也可能通过实部。我们可以通过为该数据类型定义两个操作符类，
然后在建立索引时选择合适的那个。操作符类决定了基本的排序方式（这个方式可以通过添加排序选项来修改：
<literal>COLLATE</literal>, <literal>ASC</>/<literal>DESC</> 和/或 <literal>NULLS FIRST</>/<literal>NULLS LAST</>）。
  </para>

  
<para>
<!--
   There are also some built-in operator classes besides the default ones:
-->
除了缺省的以外，还有一些有内置的操作符类：
   <itemizedlist>
    <listitem>
     <para>
<!-- 
      The operator classes <literal>text_pattern_ops</literal>,
      <literal>varchar_pattern_ops</literal>, and
      <literal>bpchar_pattern_ops</literal> support B-tree indexes on
      the types <type>text</type>, <type>varchar</type>, and
      <type>char</type> respectively.  The
      difference from the default operator classes is that the values
      are compared strictly character by character rather than
      according to the locale-specific collation rules.  This makes
      these operator classes suitable for use by queries involving
      pattern matching expressions (<literal>LIKE</literal> or POSIX
      regular expressions) when the database does not use the standard
      <quote>C</quote> locale.  As an example, you might index a
      <type>varchar</type> column like this: 
-->
<literal>text_pattern_ops</literal>,<literal>varchar_pattern_ops</literal>和<literal>bpchar_pattern_ops</literal>
操作符类分别支持在<type>text</type>, <type>varchar</type>和<type>char</type>类型上的 B-tree 索引。
他们与初始的操作符类的区别是数值是严格地逐个字节比较的，而不是根据区域相关的集合规则进行比较。
这样，如果数据库不使用标准的<quote>C</quote>区域设置，那么这些操作符类适用于那些涉及模式匹配表达式
(<literal>LIKE</literal>或者 POSIX 正则表达式)的查询。举一个例子，
你可以像下面这样对一个<type>varchar</type>字段进行索引：
<programlisting>
CREATE INDEX test_index ON test_table (col varchar_pattern_ops);
</programlisting>
<!-- 
      Note that you should also create an index with the default operator
      class if you want queries involving ordinary <literal>&lt;</>,
      <literal>&lt;=</>, <literal>&gt;</>, or <literal>&gt;=</> comparisons
      to use an index.  Such queries cannot use the
      <literal><replaceable>xxx</replaceable>_pattern_ops</literal>
      operator classes.  (Ordinary equality comparisons can use these
      operator classes, however.)  It is possible to create multiple
      indexes on the same column with different operator classes.
      If you do use the C locale, you do not need the
      <literal><replaceable>xxx</replaceable>_pattern_ops</literal>
      operator classes, because an index with the default operator class
      is usable for pattern-matching queries in the C locale. 
-->
请注意，如果你希望包含普通<literal>&lt;</>,<literal>&lt;=</>, <literal>&gt;</>,或
<literal>&gt;=</>比较的查询使用索引，那么你还应该创建一个使用缺省操作符类的索引。
这样的查询不能使用<literal><replaceable>xxx</replaceable>_pattern_ops</literal>操作符类。
（不过普通相等比较可以使用这个操作符类。）在同一个字段上创建多个使用不同操作符类的索引是可能的。
如果你确实使用了标准的"C"区域设置，那么你就不需要<literal><replaceable>xxx</replaceable>_pattern_ops</literal>
操作符类，因为使用缺省操作符类的索引可以用于 C 区域里面的模式匹配查询。
     </para>
    </listitem>
   </itemizedlist>
  </para>

  
<para>
<!--
    The following query shows all defined operator classes:
-->
下面的查询显示所有已定义的操作符类：
<programlisting>
SELECT am.amname AS index_method,
       opc.opcname AS opclass_name
    FROM pg_am am, pg_opclass opc
    WHERE opc.opcmethod = am.oid
    ORDER BY index_method, opclass_name;
</programlisting>
  </para>

  <!--
<para>
   An operator class is actually just a subset of a larger structure called an
   <firstterm>operator family</>.  In cases where several data types have
   similar behaviors, it is frequently useful to define cross-data-type
   operators and allow these to work with indexes.  To do this, the operator
   classes for each of the types must be grouped into the same operator
   family.  The cross-type operators are members of the family, but are not
   associated with any single class within the family.
  </para>
-->
<para>
一个操作符类实际上只是一个名为<firstterm>操作符族</>的大构造的子集。在这种情况下，
一些数据类型有相同的行为，这对于定义跨数据类型的操作符通常是有用的，并且允许与索引一起使用。
为了这样做，每种类型的操作符类必须分入相同的操作符族内。跨类型的操作符是这个族的成员，
但是与族内的任何一个类都没有关系。
</para>
  
<para>
<!--
    This query shows all defined operator families and all
    the operators included in each family:
-->
这个查询显示所有定义的操作符族和每个族内的所有操作符：
<programlisting>
SELECT am.amname AS index_method,
       opf.opfname AS opfamily_name,
       amop.amopopr::regoperator AS opfamily_operator
    FROM pg_am am, pg_opfamily opf, pg_amop amop
    WHERE opf.opfmethod = am.oid AND
          amop.amopfamily = opf.oid
    ORDER BY index_method, opfamily_name, opfamily_operator;
</programlisting>
  </para>
 </sect1>


 <sect1 id="indexes-collations">
  <!-- 
  <title>Indexes and Collations</title> 
  -->
  <title>索引和排序</title>

  <!--
<para>
   An index can support only one collation per index column.
   If multiple collations are of interest, multiple indexes may be needed.
  </para>
-->
<para>
一个索引只能对每个索引列支持一种排序规则。如果需要多种排序规则，就应该建多个索引。
</para>
  
<para>
 <!--
 Consider these statements:
-->
考虑这些语句：
<programlisting>
CREATE TABLE test1c (
    id integer,
    content varchar COLLATE "x"
);

CREATE INDEX test1c_content_index ON test1c (content);
</programlisting>
<!-- 
   The index automatically uses the collation of the
   underlying column.  So a query of the form 
-->
索引自动使用底层字段的排序规则。所以一个下列格式的查询
<programlisting>
SELECT * FROM test1c WHERE content &gt; <replaceable>constant</replaceable>;
</programlisting>
<!-- 
   could use the index, because the comparison will by default use the
   collation of the column.  However, this index cannot accelerate queries
   that involve some other collation.  So if queries of the form, say, 
-->
可以使用这个索引，因为这个比较会默认使用这一列的排序规则。然而，
这个索引不能对使用其他排序规则的查询进行加速。所以如果查询是下列格式，那么，
<programlisting>
SELECT * FROM test1c WHERE content &gt; <replaceable>constant</replaceable> COLLATE "y";
</programlisting>
<!-- 
   are also of interest, an additional index could be created that supports
   the <literal>"y"</literal> collation, like this: 
-->
可以创建一个额外的支持<literal>"y"</literal>排序规则的索引，就像这样：
<programlisting>
CREATE INDEX test1c_content_y_index ON test1c (content COLLATE "y");
</programlisting>
  </para>
 </sect1>


 <sect1 id="indexes-examine">
  <!-- 
  <title>Examining Index Usage</title> 
  -->
  <title>检查索引的使用</title>

  <indexterm zone="indexes-examine">
   <!-- 
   <primary>index</primary>
   <secondary>examining usage</secondary> 
   -->
   <primary>索引</primary>
   <secondary>查询使用</secondary>
  </indexterm>

  <!--
<para>
   Although indexes in <productname>PostgreSQL</> do not need
   maintenance or tuning, it is still important to check
   which indexes are actually used by the real-life query workload.
   Examining index usage for an individual query is done with the
   <xref linkend="sql-explain">
   command; its application for this purpose is
   illustrated in <xref linkend="using-explain">.
   It is also possible to gather overall statistics about index usage
   in a running server, as described in <xref linkend="monitoring-stats">.
  </para>
-->
<para>
尽管在<productname>PostgreSQL</>里的索引并不需要维护或调节，
但是检查一下哪些索引在实际查询中被使用了仍然非常重要。
检查索引的使用是通过<xref linkend="sql-explain">命令进行的；
为此目的做的应用在<xref linkend="using-explain">里演示。
我们也可以在一个运行的服务器上收集有关索引使用的统计信息，
就像<xref linkend="monitoring-stats">里描述的那样。
</para>

  <!--
<para>
   It is difficult to formulate a general procedure for determining
   which indexes to create.  There are a number of typical cases that
   have been shown in the examples throughout the previous sections.
   A good deal of experimentation is often necessary.
   The rest of this section gives some tips for that:
  </para>
-->
<para>
归纳一个判断需要设置哪些索引的通用过程是很难的。在前面的章节中已经列出了许多典型的例子。
在大多数情况下我们都需要许多试验。本节的剩余部分就是给出一些这方面的窍门。
</para>

  <itemizedlist>
   <listitem>
    <!--
<para>
     Always run <xref linkend="sql-analyze">
     first.  This command
     collects statistics about the distribution of the values in the
     table.  This information is required to estimate the number of rows
     returned by a query, which is needed by the planner to assign
     realistic costs to each possible query plan.  In absence of any
     real statistics, some default values are assumed, which are
     almost certain to be inaccurate.  Examining an application's
     index usage without having run <command>ANALYZE</command> is
     therefore a lost cause.
     See <xref linkend="vacuum-for-statistics">
     and <xref linkend="autovacuum"> for more information.
    </para>
-->
<para>
总是先运行<xref linkend="sql-analyze">命令收集关于表中数值分布的统计信息。
估计一个查询返回的行数需要这个信息，而规划器需要这个行数以便给每个可能的查询规划赋予真实开销值。
如果缺乏任何真实的统计信息，那么就会假设一些缺省数值，那肯定是不准确的。因此，
如果还没有运行<command>ANALYZE</command>就检查一个应用的索引使用状况，那实际上就是一次失败的检查。
参阅<xref linkend="vacuum-for-statistics">和<xref linkend="autovacuum">获取详细信息。
</para>
   </listitem>

   <listitem>
    <!--
<para>
     Use real data for experimentation.  Using test data for setting
     up indexes will tell you what indexes you need for the test data,
     but that is all.
    </para>
-->
<para>
使用真实的数据做实验。用测试数据设置索引将告诉你在测试数据中需要什么索引，
而不是在真实数据中。
</para>

    <!--
<para>
     It is especially fatal to use very small test data sets.
     While selecting 1000 out of 100000 rows could be a candidate for
     an index, selecting 1 out of 100 rows will hardly be, because the
     100 rows probably fit within a single disk page, and there
     is no plan that can beat sequentially fetching 1 disk page.
    </para>
-->
<para>
最要命的是用很小的数据集。如果从 100000 行中选 1000 行是使用索引的好时机，
那么从 100 行中选 1 行很难说也需要索引，因为 100 行很可能是装在一个磁盘页里面的，
因此没有任何查询规划能比通过顺序访问抓取一个磁盘页面更有效。
</para>

    <!--
<para>
     Also be careful when making up test data, which is often
     unavoidable when the application is not yet in production.
     Values that are very similar, completely random, or inserted in
     sorted order will skew the statistics away from the distribution
     that real data would have.
    </para>
-->
<para>
做测试数据的时候也要小心，如果应用还不能在生产环境中使用，那么这也是不可避免的。
那些非常相似的数据、完全随机的数据、或者按照排序顺序插入的数据会令统计信息偏离实际数据的特征。
</para>
   </listitem>

   <listitem>
    <!--
<para>
     When indexes are not used, it can be useful for testing to force
     their use.  There are run-time parameters that can turn off
     various plan types (see <xref linkend="runtime-config-query-enable">).
     For instance, turning off sequential scans
     (<varname>enable_seqscan</>) and nested-loop joins
     (<varname>enable_nestloop</>), which are the most basic plans,
     will force the system to use a different plan.  If the system
     still chooses a sequential scan or nested-loop join then there is
     probably a more fundamental reason why the index is not being
     used; for example, the query condition does not match the index.
     (What kind of query can use what kind of index is explained in
     the previous sections.)
    </para>
-->
<para>
如果索引没有得到使用，那么在测试中强制它的使用也许有些价值。
有一些运行时参数可以关闭各种各样的查询规划(在<xref linkend="runtime-config-query-enable">中描述)。
比如，关闭顺序扫描(<varname>enable_seqscan</>)和嵌套循环连接(<varname>enable_nestloop</>)
将强迫系统使用不同的规划。如果系统仍然选择顺序扫描或者嵌套循环连接，
那么在为何索引没有得到使用的问题中可能有更基本的问题，比如，
查询条件和索引不匹配等(前面的章节中介绍了什么样的查询可以使用什么样的索引)。
</para>
   </listitem>

   <listitem>
    <!--
<para>
     If forcing index usage does use the index, then there are two
     possibilities: Either the system is right and using the index is
     indeed not appropriate, or the cost estimates of the query plans
     are not reflecting reality.  So you should time your query with
     and without indexes.  The <command>EXPLAIN ANALYZE</command>
     command can be useful here.
    </para>
-->
<para>
如果强制索引用法确实使用了索引，那么就有两种可能：要么是系统选择是正确的：
使用索引实际上并不合适，要么是查询计划的开销计算并不反映现实情况。
这样你就应该对使用和不使用索引的查询进行计时。
这个时候<command>EXPLAIN ANALYZE</command>命令就很有用了。
</para>
   </listitem>

   <listitem>
    <!--
<para>
     If it turns out that the cost estimates are wrong, there are,
     again, two possibilities.  The total cost is computed from the
     per-row costs of each plan node times the selectivity estimate of
     the plan node.  The costs estimated for the plan nodes can be adjusted
     via run-time parameters (described in <xref
     linkend="runtime-config-query-constants">).
     An inaccurate selectivity estimate is due to
     insufficient statistics.  It might be possible to improve this by
     tuning the statistics-gathering parameters (see
     <xref linkend="sql-altertable">).
    </para>
-->
<para>
如果实际情况说明开销计算是错误的，那么仍然有两种可能。
总开销是从每行的每个规划节点的开销乘以每个规划节点的选择性估计计算出来的。
规划节点的开销估计可以用一些运行时参数进行调节(在<xref linkend="runtime-config-query-constants">
中描述)。不准确的选择性估计是因为统计信息不够充分。
我们可以通过调节统计收集参数(参阅<xref linkend="sql-altertable">)提高选择性估计的精度。
</para>

    <!--
<para>
     If you do not succeed in adjusting the costs to be more
     appropriate, then you might have to resort to forcing index usage
     explicitly.  You might also want to contact the
     <productname>PostgreSQL</> developers to examine the issue.
    </para>
-->
<para>
如果你没能通过将开销调整得更准确而实现索引的使用，那么你可能不得不求助于明确地强制索引使用。
并且与<productname>PostgreSQL</>开发人员联系并讨论你的情况。
</para>
   </listitem>
  </itemizedlist>
 </sect1>
</chapter>
