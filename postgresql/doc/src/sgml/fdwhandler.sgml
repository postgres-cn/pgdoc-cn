<!-- doc/src/sgml/fdwhandler.sgml -->

 <chapter id="fdwhandler">
  <!--
   <title>Writing A Foreign Data Wrapper</title>
  -->
    <title>写一个外部数据封装器</title>

   <indexterm zone="fdwhandler">
   <!--
    <primary>foreign data wrapper</primary>
-->
 <primary>外数据封装</primary>
    <secondary>handler for</secondary>
   </indexterm>

   <!--
<para>
    All operations on a foreign table are handled through its foreign data
    wrapper, which consists of a set of functions that the core server
    calls.  The foreign data wrapper is responsible for fetching
    data from the remote data source and returning it to the
    <productname>PostgreSQL</productname> executor.  If updating foreign
    tables is to be supported, the wrapper must handle that, too.
    This chapter outlines how to write a new foreign data wrapper.
   </para>
-->
<para>
    在外表上的所有操作都是通过它的外数据封装进行处理的，
它由核心服务器调用函数集组成。
外数据封装负责从远程数据源抓取数据，并且将它返回给<productname>PostgreSQL</productname>执行器。
如果支持更新外表，那么封装也必须处理。
本章概述了如何写新的外数据封装。
</para>

   <!--
<para>
    The foreign data wrappers included in the standard distribution are good
    references when trying to write your own.  Look into the
    <filename>contrib</> subdirectory of the source tree.
    The <xref linkend="sql-createforeigndatawrapper"> reference page also has
    some useful details.
   </para>
-->
<para>
     当尝试自己写的时候，在标准发布中的外部数据封装器是好的参考。
 查看下源代码树的<filename>contrib</>子目录。<xref linkend="sql-createforeigndatawrapper">
 参考页也有一些有用细节。
</para>

   <note>
    <!--
<para>
     The SQL standard specifies an interface for writing foreign data wrappers.
     However, PostgreSQL does not implement that API, because the effort to
     accommodate it into PostgreSQL would be large, and the standard API hasn't
     gained wide adoption anyway.
    </para>
-->
<para>
     SQL标准指定写外数据封装接口。然而，PostgreSQL不会实现API，因为努力调节它到PostgreSQL将是巨大的，
 并且标准API没有获得广泛采用。
 
</para>
   </note>

   <sect1 id="fdw-functions">
   <!--
    <title>Foreign Data Wrapper Functions</title>
   -->
     <title>外数据封装函数</title>

    <!--
<para>
     The FDW author needs to implement a handler function, and optionally
     a validator function. Both functions must be written in a compiled
     language such as C, using the version-1 interface.
     For details on C language calling conventions and dynamic loading,
     see <xref linkend="xfunc-c">.
    </para>
-->
<para>
    FDW作者需要实现一个处理函数，并且任选一个验证函数。这两个函数必须写在一个编译语言里比如C，
使用版本-1接口。关于在C语言中调用约定和动态加载的详细细节，参阅<xref linkend="xfunc-c">。
</para>

    <!--
<para>
     The handler function simply returns a struct of function pointers to
     callback functions that will be called by the planner, executor, and
     various maintenance commands.
     Most of the effort in writing an FDW is in implementing these callback
     functions.
     The handler function must be registered with
     <productname>PostgreSQL</productname> as taking no arguments and
     returning the special pseudo-type <type>fdw_handler</type>.  The
     callback functions are plain C functions and are not visible or
     callable at the SQL level.  The callback functions are described in
     <xref linkend="fdw-callbacks">.
    </para>
-->
<para>
    处理函数只返回调用函数的函数指针结构，其中通过规划器，执行器，以及各种维护命令
调用回调函数。写FDW的努力在于实现这些回调函数。
使用无参的<productname>PostgreSQL</productname>注册处理函数，
并且返回特殊伪类型<type>fdw_handler</type>。
回调函数是普通C函数，是不可见的或者在SQL级别上可随时调用的。
    在<xref linkend="fdw-callbacks">中描述回调函数。
</para>

    <!--
<para>
     The validator function is responsible for validating options given in
     <command>CREATE</command> and <command>ALTER</command> commands for its
     foreign data wrapper, as well as foreign servers, user mappings, and
     foreign tables using the wrapper.
     The validator function must be registered as taking two arguments, a
     text array containing the options to be validated, and an OID
     representing the type of object the options are associated with (in
     the form of the OID of the system catalog the object would be stored
     in, either
     <literal>ForeignDataWrapperRelationId</>,
     <literal>ForeignServerRelationId</>,
     <literal>UserMappingRelationId</>,
     or <literal>ForeignTableRelationId</>).
     If no validator function is supplied, options are not checked at object
     creation time or object alteration time.
    </para>
-->
<para>
      验证函数负责验证
      由<command>CREATE</command>和<command>ALTER</command>命令为外数据封装，以及外服务器，用户映射和使用封装的外表
  给定的选项，验证函数必须作为两个参数来注册，验证包含该选项的文本数组，并且该选项与表示对象类型的OID相关联（
  在系统目录OID形式下该对象被存储在，要么<literal>ForeignDataWrapperRelationId</>,
     <literal>ForeignServerRelationId</>,
     <literal>UserMappingRelationId</>,
     或者<literal>ForeignTableRelationId</>中）。
 如果不提供验证函数，则在对象创建时间或者对象变更时间不检查该选项。   
</para>

   </sect1>

   <sect1 id="fdw-callbacks">
   <!--
    <title>Foreign Data Wrapper Callback Routines</title>
   -->
     <title>外数据封装回调程序</title>

    <!--
<para>
     The FDW handler function returns a palloc'd <structname>FdwRoutine</>
     struct containing pointers to the callback functions described below.
     The scan-related functions are required, the rest are optional.
    </para>
-->
<para>
     
 FDW处理函数返回包含指向下面描述的回调函数指针的palloc'd <structname>FdwRoutine</>结构。   
 扫描相关函数是必须的，其余的是可选的。
</para>

    <!--
<para>
     The <structname>FdwRoutine</> struct type is declared in
     <filename>src/include/foreign/fdwapi.h</>, which see for additional
     details.
    </para>
-->
<para>
      在<filename>src/include/foreign/fdwapi.h</>中声明<structname>FdwRoutine</>结构类型，
  参阅额外详情。
</para>

   <sect2 id="fdw-callbacks-scan">
   <!--
    <title>FDW Routines For Scanning Foreign Tables</title>
   -->
     <title>扫描外表的FDW程序</title>

    
<para>
<programlisting>
void
GetForeignRelSize (PlannerInfo *root,
                   RelOptInfo *baserel,
                   Oid foreigntableid);
</programlisting>
     <!--
     Obtain relation size estimates for a foreign table.  This is called
     at the beginning of planning for a query that scans a foreign table.
     <literal>root</> is the planner's global information about the query;
     <literal>baserel</> is the planner's information about this table; and
     <literal>foreigntableid</> is the <structname>pg_class</> OID of the
     foreign table.  (<literal>foreigntableid</> could be obtained from the
     planner data structures, but it's passed explicitly to save effort.)
 -->
 获得评估外表关系大小。这就是所谓的开始扫描外表的查询规划。
 <literal>root</>是关于查询的规划器的全局信息；
 <literal>baserel</>是关于这个表的规划器信息；
 <literal>foreigntableid</>是外表的<structname>pg_class</> OID。
 （<literal>foreigntableid</>可以从规划器数据结构中获得，
 但是它明确被传递用来节省力气。）
 
    </para>

    <!--
<para>
     This function should update <literal>baserel-&gt;rows</> to be the
     expected number of rows returned by the table scan, after accounting for
     the filtering done by the restriction quals.  The initial value of
     <literal>baserel-&gt;rows</> is just a constant default estimate, which
     should be replaced if at all possible.  The function may also choose to
     update <literal>baserel-&gt;width</> if it can compute a better estimate
     of the average result row width.
    </para>
-->
<para>
     在说明限制资格测试执行过滤之后，
 该函数应该更新<literal>baserel-&gt;rows</>为通过表扫描返回的行期望数。
 <literal>baserel-&gt;rows</>的初始值仅仅是恒定缺省估计，
 如果可能的话，这应该被替换。如果它可以对平均结果行宽度计算出更好的评估，那么
 该函数可能也会选择更新<literal>baserel-&gt;width</>。
</para>

    <!--
<para>
     See <xref linkend="fdw-planning"> for additional information.
    </para>
-->
<para>
     参阅<xref linkend="fdw-planning">可以获取额外信息。 
</para>

    
<para>
<programlisting>
void
GetForeignPaths (PlannerInfo *root,
                 RelOptInfo *baserel,
                 Oid foreigntableid);
</programlisting>
     <!--
     Create possible access paths for a scan on a foreign table.
     This is called during query planning.
     The parameters are the same as for <function>GetForeignRelSize</>,
     which has already been called.
 -->
 创建外表扫描的可能访问路径。
 这就是所谓的查询规划。
 它被调用的参数和<function>GetForeignRelSize</>相同。
    </para>

    <!--
<para>
     This function must generate at least one access path
     (<structname>ForeignPath</> node) for a scan on the foreign table and
     must call <function>add_path</> to add each such path to
     <literal>baserel-&gt;pathlist</>.  It's recommended to use
     <function>create_foreignscan_path</> to build the
     <structname>ForeignPath</> nodes.  The function can generate multiple
     access paths, e.g., a path which has valid <literal>pathkeys</> to
     represent a pre-sorted result.  Each access path must contain cost
     estimates, and can contain any FDW-private information that is needed to
     identify the specific scan method intended.
    </para>
-->
<para>
     该函数必须为外表扫描产生至少1个访问路径(<structname>ForeignPath</>节点)而且
 必须调用<function>add_path</>添加每个这样的路径到<literal>baserel-&gt;pathlist</>中。
 推荐使用<function>create_foreignscan_path</>建立<structname>ForeignPath</>节点。
 该函数可以生成多个访问路径，比如具有有效<literal>pathkeys</>表示预排序结果路径。
 每个访问路径必须包含成本估计，并且包含需要标识具体预期扫描方法的任何FDW-私有信息。
</para>

    <!--
<para>
     See <xref linkend="fdw-planning"> for additional information.
    </para>
-->
<para>
    参阅<xref linkend="fdw-planning">获取额外信息。
</para>

    
<para>
<programlisting>
ForeignScan *
GetForeignPlan (PlannerInfo *root,
                RelOptInfo *baserel,
                Oid foreigntableid,
                ForeignPath *best_path,
                List *tlist,
                List *scan_clauses);
</programlisting>
    <!--
     Create a <structname>ForeignScan</> plan node from the selected foreign
     access path.  This is called at the end of query planning.
     The parameters are as for <function>GetForeignRelSize</>, plus
     the selected <structname>ForeignPath</> (previously produced by
     <function>GetForeignPaths</>), the target list to be emitted by the
     plan node, and the restriction clauses to be enforced by the plan node.
-->
 从所选择的外访问路径中创建<structname>ForeignScan</>规划节点。
 这从查询规划结尾被调用。
 该参数为<function>GetForeignRelSize</>，加上所选择的<structname>ForeignPath</>
 （通过<function>GetForeignPaths</>预先生成），
 通过规划节点发出目标列表，并且限制子句通过规划节点被执行。
    </para>

    <!--
<para>
     This function must create and return a <structname>ForeignScan</> plan
     node; it's recommended to use <function>make_foreignscan</> to build the
     <structname>ForeignScan</> node.
    </para>
-->
<para>
     该函数必须创建并且返回<structname>ForeignScan</>规划节点；
 推荐使用<function>make_foreignscan</>建立<structname>ForeignScan</>节点。
</para>

    <!--
<para>
     See <xref linkend="fdw-planning"> for additional information.
    </para>
-->
<para>
    参阅<xref linkend="fdw-planning">获取额外信息。
</para>

   
<para>
<programlisting>
void
BeginForeignScan (ForeignScanState *node,
                  int eflags);
</programlisting>
      <!--
     Begin executing a foreign scan. This is called during executor startup.
     It should perform any initialization needed before the scan can start,
     but not start executing the actual scan (that should be done upon the
     first call to <function>IterateForeignScan</>).
     The <structname>ForeignScanState</> node has already been created, but
     its <structfield>fdw_state</> field is still NULL.  Information about
     the table to scan is accessible through the
     <structname>ForeignScanState</> node (in particular, from the underlying
     <structname>ForeignScan</> plan node, which contains any FDW-private
     information provided by <function>GetForeignPlan</>).
     <literal>eflags</> contains flag bits describing the executor's
     operating mode for this plan node.
 -->
  开始执行一个外部扫描。这是在执行器启动期间调用。它应该执行扫描开始前需要的任何初始化。
  但没有开始执行实际扫描（应该执行第一次调用<function>IterateForeignScan</>）。
  <structname>ForeignScanState</>节点已经被创建，但是它的<structfield>fdw_state</>字段仍然是NULL。
  通过<structname>ForeignScanState</>节点扫描的表信息（尤其是，来自底层的<structname>ForeignScan</>规划节点，
  它包含任何通过<function>GetForeignPlan</>提供的FDW-私有信息）。
   <literal>eflags</>包含描述该规划节点执行器的操作模式的标志位。
  
    </para>


    <!--
<para>
     Note that when <literal>(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</> is
     true, this function should not perform any externally-visible actions;
     it should only do the minimum required to make the node state valid
     for <function>ExplainForeignScan</> and <function>EndForeignScan</>.
    </para>
-->
<para>
     注意当<literal>(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</>为真时，
 该函数不应该执行任何外部可见行为；
 它应该为<function>ExplainForeignScan</>和
 <function>EndForeignScan</>执行最小需求使得节点状态有效。
 
</para>

    
<para>
<programlisting>
TupleTableSlot *
IterateForeignScan (ForeignScanState *node);
</programlisting>
     <!--
     Fetch one row from the foreign source, returning it in a tuple table slot
     (the node's <structfield>ScanTupleSlot</> should be used for this
     purpose).  Return NULL if no more rows are available.  The tuple table
     slot infrastructure allows either a physical or virtual tuple to be
     returned; in most cases the latter choice is preferable from a
     performance standpoint.  Note that this is called in a short-lived memory
     context that will be reset between invocations.  Create a memory context
     in <function>BeginForeignScan</> if you need longer-lived storage, or use
     the <structfield>es_query_cxt</> of the node's <structname>EState</>.
 -->
 从外部源读取一行，在元组表槽中返回它（节点的<structfield>ScanTupleSlot</>用于这个目的）。
 如果没有更多行可用，那么返回NULL。元组表槽基础设施允许返回物理或者虚拟元组。
 在大多数情况下后者选择从性能角度更可取。
 注意这被称为在调用期间被重置的短暂内存语境。如果
 你需要较长时间存储，或者使用节点的<structname>EState</>的<structfield>es_query_cxt</>，
 那么在<function>BeginForeignScan</>中创建内存上下文。
 
    </para>

    <!--
<para>
     The rows returned must match the column signature of the foreign table
     being scanned.  If you choose to optimize away fetching columns that
     are not needed, you should insert nulls in those column positions.
    </para>
-->
<para>
    返回的行必须匹配扫描外表的列标志。如果你选择优化掉不需要的列，那么
你应该在那些列位置插入空值。
</para>

    <!--
<para>
     Note that <productname>PostgreSQL</productname>'s executor doesn't care
     whether the rows returned violate any <literal>NOT NULL</literal>
     constraints that were defined on the foreign table columns &mdash; but
     the planner does care, and may optimize queries incorrectly if
     <literal>NULL</> values are present in a column declared not to contain
     them.  If a <literal>NULL</> value is encountered when the user has
     declared that none should be present, it may be appropriate to raise an
     error (just as you would need to do in the case of a data type mismatch).
    </para>
-->
<para>
     注意<productname>PostgreSQL</productname>的执行器并不在乎返回的行是否违反任何在外表列定义的<literal>NOT NULL</literal>
 约束&mdash; 但是规划器关心，如果<literal>NULL</>值出现在声明列中而不包含它们，那么可能错误地优化查询。
 当用户声明不应该存在时，如果遇到<literal>NULL</>值，它可能会适当提高错误
 （正如你需要在数据类型不匹配的情况下执行）。
</para>

    
<para>
<programlisting>
void
ReScanForeignScan (ForeignScanState *node);
</programlisting>
     <!--
     Restart the scan from the beginning.  Note that any parameters the
     scan depends on may have changed value, so the new scan does not
     necessarily return exactly the same rows.
 -->
 从开始重启扫描。注意任何参数扫描取决于已改变的值，
 因此扫描不一定返回完全相同的行。
    </para>

    
<para>
<programlisting>
void
EndForeignScan (ForeignScanState *node);
</programlisting>
     <!--
     End the scan and release resources.  It is normally not important
     to release palloc'd memory, but for example open files and connections
     to remote servers should be cleaned up.
 -->
 结束扫描并且释放资源。释放palloc内存往往不重要，但是比如打开文件并且链接远程服务器应该
 被清理干净。
    </para>


   </sect2>

   <sect2 id="fdw-callbacks-update">
   <!--
    <title>FDW Routines For Updating Foreign Tables</title>
   -->
     <title>更新外表FDW程序</title>

    <!--
<para>
     If an FDW supports writable foreign tables, it should provide
     some or all of the following callback functions depending on
     the needs and capabilities of the FDW:
    </para>
-->
<para>
      如果FDW支持可写外表，
  那么它应该提供一些或者所有下面的依赖于
  FDW的需要和能力的回调函数：
</para>

    
<para>
<programlisting>
void
AddForeignUpdateTargets (Query *parsetree,
                         RangeTblEntry *target_rte,
                         Relation target_relation);
</programlisting>
     <!--
     <command>UPDATE</> and <command>DELETE</> operations are performed
     against rows previously fetched by the table-scanning functions.  The
     FDW may need extra information, such as a row ID or the values of
     primary-key columns, to ensure that it can identify the exact row to
     update or delete.  To support that, this function can add extra hidden,
     or <quote>junk</>, target columns to the list of columns that are to be
     retrieved from the foreign table during an <command>UPDATE</> or
     <command>DELETE</>.
 -->
 在通过表扫描函数预先读取行之前执行<command>UPDATE</>和<command>DELETE</>操作。
 FDW可能需要额外信息，比如行ID或者主键列值，为了确保它可以找到确切行更新或者删除。
 为了支持它，该函数可以添加额外隐藏，或者<quote>junk</>，在<command>UPDATE</>或者
     <command>DELETE</>中从外表中检索列表中的目标列。
 
    </para>

    <!--
<para>
     To do that, add <structname>TargetEntry</> items to
     <literal>parsetree-&gt;targetList</>, containing expressions for the
     extra values to be fetched.  Each such entry must be marked
     <structfield>resjunk</> = <literal>true</>, and must have a distinct
     <structfield>resname</> that will identify it at execution time.
     Avoid using names matching <literal>ctid<replaceable>N</></literal>,
     <literal>wholerow</literal>, or
     <literal>wholerow<replaceable>N</></literal>, as the core system can
     generate junk columns of these names.
    </para>
-->
<para>
    要做到这一点，添加<structname>TargetEntry</>项到
     <literal>parsetree-&gt;targetList</>，包含读取的额外值的表达式。
 每个这样的项必须被标记<structfield>resjunk</> = <literal>true</>，
 并且有一个不同的<structfield>resname</>在执行期间标识它。
 避免使用匹配<literal>ctid<replaceable>N</></literal>、<literal>wholerow</literal>
 或者<literal>wholerow<replaceable>N</></literal>的名称，正如核心系统可以
 产生这些名字的垃圾列。
</para>

    <!--
<para>
     This function is called in the rewriter, not the planner, so the
     information available is a bit different from that available to the
     planning routines.
     <literal>parsetree</> is the parse tree for the <command>UPDATE</> or
     <command>DELETE</> command, while <literal>target_rte</> and
     <literal>target_relation</> describe the target foreign table.
    </para>
-->
<para>
     在改写过程中调用该函数，而不是规划器，因此该可用信息不同于可用的规划程序。
当<literal>target_rte</>和
    <literal>target_relation</>描述目标外表时，<literal>parsetree</>是<command>UPDATE</>或者
    <command>DELETE</>命令的解析树。
</para>

    <!--
<para>
     If the <function>AddForeignUpdateTargets</> pointer is set to
     <literal>NULL</>, no extra target expressions are added.
     (This will make it impossible to implement <command>DELETE</>
     operations, though <command>UPDATE</> may still be feasible if the FDW
     relies on an unchanging primary key to identify rows.)
    </para>
-->
<para>
     如果<function>AddForeignUpdateTargets</>指针被设置为<literal>NULL</>，
 那么没有额外目标表达式被添加。
 （这将不可能实现<command>DELETE</>操作，尽管<command>UPDATE</>可能仍然是可行的，
 如果FDW依赖于一个标识行的未改变主键）。
</para>

    
<para>
<programlisting>
List *
PlanForeignModify (PlannerInfo *root,
                   ModifyTable *plan,
                   Index resultRelation,
                   int subplan_index);
</programlisting>

     <!--
     Perform any additional planning actions needed for an insert, update, or
     delete on a foreign table.  This function generates the FDW-private
     information that will be attached to the <structname>ModifyTable</> plan
     node that performs the update action.  This private information must
     have the form of a <literal>List</>, and will be delivered to
     <function>BeginForeignModify</> during the execution stage.
 -->
 执行任何额外规划操作需要插入，更新或者删除外表。
 该函数产生附属于执行更新操作的<structname>ModifyTable</>规划节点
 的FDW-私有信息。这个私有信息必须有<literal>List</>形式，并且
 在执行阶段将转交给<function>BeginForeignModify</>。
    </para>

    <!--
<para>
     <literal>root</> is the planner's global information about the query.
     <literal>plan</> is the <structname>ModifyTable</> plan node, which is
     complete except for the <structfield>fdwPrivLists</> field.
     <literal>resultRelation</> identifies the target foreign table by its
     rangetable index.  <literal>subplan_index</> identifies which target of
     the <structname>ModifyTable</> plan node this is, counting from zero;
     use this if you want to index into <literal>plan-&gt;plans</> or other
     substructure of the <literal>plan</> node.
    </para>
-->
<para>
      <literal>root</>是关于查询的规划器的全局信息。
  <literal>plan</>是<structname>ModifyTable</>规划节点，
  除了<structfield>fdwPrivLists</>字段外它是完整的。
  <literal>resultRelation</>通过射程表索引识别目标外表。
  <literal>subplan_index</>识别从零开始计算的<structname>ModifyTable</>规划节点是哪个目标；
  如果你想要索引<literal>plan-&gt;plans</>或者其他<literal>plan</>节点的子结构，那么使用它。
  
</para>

    <!--
<para>
     See <xref linkend="fdw-planning"> for additional information.
    </para>
-->
<para>
     参阅<xref linkend="fdw-planning">获取更多额外信息。
</para>

    <!--
<para>
     If the <function>PlanForeignModify</> pointer is set to
     <literal>NULL</>, no additional plan-time actions are taken, and the
     <literal>fdw_private</> list delivered to
     <function>BeginForeignModify</> will be NIL.
    </para>
-->
<para>
     如果<function>PlanForeignModify</>指针被设置为<literal>NULL</>，
 没有采取额外规划时间操作，并且<literal>fdw_private</>列表转交给
 <function>BeginForeignModify</>为零。
</para>

    
<para>
<programlisting>
void
BeginForeignModify (ModifyTableState *mtstate,
                    ResultRelInfo *rinfo,
                    List *fdw_private,
                    int subplan_index,
                    int eflags);
</programlisting>
     <!--
     Begin executing a foreign table modification operation.  This routine is
     called during executor startup.  It should perform any initialization
     needed prior to the actual table modifications.  Subsequently,
     <function>ExecForeignInsert</>, <function>ExecForeignUpdate</> or
     <function>ExecForeignDelete</> will be called for each tuple to be
     inserted, updated, or deleted.
 -->
 开始执行一个外表修改操作。这个程序在执行器启动时调用。
 应该在实际表修改前执行任何初始化。随后，<function>ExecForeignInsert</>, <function>ExecForeignUpdate</>或者
     <function>ExecForeignDelete</>需要每个元组被插入，更新或者删除。
 
 
    </para>

    <!--
<para>
     <literal>mtstate</> is the overall state of the
     <structname>ModifyTable</> plan node being executed; global data about
     the plan and execution state is available via this structure.
     <literal>rinfo</> is the <structname>ResultRelInfo</> struct describing
     the target foreign table.  (The <structfield>ri_FdwState</> field of
     <structname>ResultRelInfo</> is available for the FDW to store any
     private state it needs for this operation.)
     <literal>fdw_private</> contains the private data generated by
     <function>PlanForeignModify</>, if any.
     <literal>subplan_index</> identifies which target of
     the <structname>ModifyTable</> plan node this is.
     <literal>eflags</> contains flag bits describing the executor's
     operating mode for this plan node.
    </para>
-->
<para>
    <literal>mtstate</>是被执行的<structname>ModifyTable</>规划节点的整体状态；
关于规划的全局数据和执行状态通过该结构是可用的。
<literal>rinfo</>是描述目标外表的<structname>ResultRelInfo</>结构。
（<structname>ResultRelInfo</>的<structfield>ri_FdwState</>字段用于FDW存储任何需要该操作的私有状态。）
如果任何的，那么<literal>fdw_private</>包含通过<function>PlanForeignModify</>产生的私有数据。
<literal>subplan_index</>识别<structname>ModifyTable</>规划节点是哪个目标。
<literal>eflags</>包含描述这个规划节点的执行器操作模式的标志位。
</para>

    <!--
<para>
     Note that when <literal>(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</> is
     true, this function should not perform any externally-visible actions;
     it should only do the minimum required to make the node state valid
     for <function>ExplainForeignModify</> and <function>EndForeignModify</>.
    </para>
-->
<para>
     注意当<literal>(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</>为真时，
 该函数不应该执行任何外部可见操作；
 它应该为<function>ExplainForeignModify</>和
 <function>EndForeignModify</>执行最小需求使得节点状态有效。
</para>

    <!--
<para>
     If the <function>BeginForeignModify</> pointer is set to
     <literal>NULL</>, no action is taken during executor startup.
    </para>
-->
<para>
    如果<function>BeginForeignModify</>指针被设置为<literal>NULL</>，
那么在执行器启动期间不采取任何操作。
</para>

    
<para>
<programlisting>
TupleTableSlot *
ExecForeignInsert (EState *estate,
                   ResultRelInfo *rinfo,
                   TupleTableSlot *slot,
                   TupleTableSlot *planSlot);
</programlisting>
     <!--
     Insert one tuple into the foreign table.
     <literal>estate</> is global execution state for the query.
     <literal>rinfo</> is the <structname>ResultRelInfo</> struct describing
     the target foreign table.
     <literal>slot</> contains the tuple to be inserted; it will match the
     row-type definition of the foreign table.
     <literal>planSlot</> contains the tuple that was generated by the
     <structname>ModifyTable</> plan node's subplan; it differs from
     <literal>slot</> in possibly containing additional <quote>junk</>
     columns.  (The <literal>planSlot</> is typically of little interest
     for <command>INSERT</> cases, but is provided for completeness.)
 -->
 插入一个元组到外表。<literal>estate</>是查询的全局执行状态。
 <literal>rinfo</>是描述目标外表的<structname>ResultRelInfo</>结构。
 <literal>slot</>包含要插入的元组；它将匹配外表rowtype定义。
 <literal>planSlot</>包含通过<structname>ModifyTable</>规划节点的子计划产生的元组；
 它不同于可能包含额外<quote>junk</>列的<literal>slot</>。
 
    </para>

    <!--
<para>
     The return value is either a slot containing the data that was actually
     inserted (this might differ from the data supplied, for example as a
     result of trigger actions), or NULL if no row was actually inserted
     (again, typically as a result of triggers).  The passed-in
     <literal>slot</> can be re-used for this purpose.
    </para>
-->
<para>
     返回值要么是包含实际插入的数据的槽（这可能与提供的数据不同，比如作为触发器操作结果），
 如果没有行实际被插入，那么返回NULL（再次，通常作为触发器结果）。
 传入的<literal>slot</>可以重新用于这个目的。
  
</para>

    <!--
<para>
     The data in the returned slot is used only if the <command>INSERT</>
     query has a <literal>RETURNING</> clause or the foreign table has
     an <literal>AFTER ROW</> trigger.  Triggers require all columns, but the
     FDW could choose to optimize away returning some or all columns depending
     on the contents of the <literal>RETURNING</> clause.  Regardless, some
     slot must be returned to indicate success, or the query's reported row
     count will be wrong.
    </para>
-->
<para>
只有<command>INSERT</>查询有<literal>RETURNING</>子句，或该外部表有一个
<literal>AFTER ROW</>触发器时，才使用返回槽中的数据。触发器请求所有的字段，
但是FDW可能选择优化返回依赖于<literal>RETURNING</>子句内容的一些或者全部列。
不管怎样，必须返回一些槽以表示成功，否则该查询报告的行数是错误的。
</para>

    <!--
<para>
     If the <function>ExecForeignInsert</> pointer is set to
     <literal>NULL</>, attempts to insert into the foreign table will fail
     with an error message.
    </para>
-->
<para>
    如果<function>ExecForeignInsert</>指针被设置为<literal>NULL</>，
尝试插入外表将带有错误消息而失败。
</para>

    
<para>
<programlisting>
TupleTableSlot *
ExecForeignUpdate (EState *estate,
                   ResultRelInfo *rinfo,
                   TupleTableSlot *slot,
                   TupleTableSlot *planSlot);
</programlisting>
     <!--
     Update one tuple in the foreign table.
     <literal>estate</> is global execution state for the query.
     <literal>rinfo</> is the <structname>ResultRelInfo</> struct describing
     the target foreign table.
     <literal>slot</> contains the new data for the tuple; it will match the
     row-type definition of the foreign table.
     <literal>planSlot</> contains the tuple that was generated by the
     <structname>ModifyTable</> plan node's subplan; it differs from
     <literal>slot</> in possibly containing additional <quote>junk</>
     columns.  In particular, any junk columns that were requested by
     <function>AddForeignUpdateTargets</> will be available from this slot.
 -->
 更新外表上的元组。
 <literal>estate</>是查询的全局执行状态。<literal>rinfo</>是描述目标外表的
 <structname>ResultRelInfo</>结构。<literal>slot</>包含元组的新数据；
 它将匹配外表rowtype定义。
 <literal>planSlot</>包含通过<structname>ModifyTable</>规划节点的子计划产生的元组；
 它不同于可能包含额外<quote>junk</>列的<literal>slot</>。
 尤其是，通过<function>AddForeignUpdateTargets</>请求的任何垃圾列将从该槽中提供。
    </para>

    <!--
<para>
     The return value is either a slot containing the row as it was actually
     updated (this might differ from the data supplied, for example as a
     result of trigger actions), or NULL if no row was actually updated
     (again, typically as a result of triggers).  The passed-in
     <literal>slot</> can be re-used for this purpose.
    </para>
-->
<para>
     返回值要么是包含实际更新的行的槽（这可能与提供的数据不同，比如作为触发器操作结果），
 如果没有行实际被更新，那么返回NULL（再次，通常作为触发器结果）。
 传入的<literal>slot</>可以重新用于这个目的。
</para>

    <!--
<para>
     The data in the returned slot is used only if the <command>UPDATE</>
     query has a <literal>RETURNING</> clause or the foreign table has
     an <literal>AFTER ROW</> trigger.  Triggers require all columns, but the
     FDW could choose to optimize away returning some or all columns depending
     on the contents of the <literal>RETURNING</> clause.  Regardless, some
     slot must be returned to indicate success, or the query's reported row
     count will be wrong.
    </para>
-->
<para>
只有<command>UPDATE</>查询有<literal>RETURNING</>子句时，或该外部表有一个
<literal>AFTER ROW</>触发器时，才使用返回槽中的数据。触发器请求所有的字段，
但是FDW可能选择优化返回依赖于<literal>RETURNING</>子句内容的一些或者全部列。
不管怎样，必须返回一些槽以表示成功，否则该查询报告的行数是错误的。
</para>

    <!--
<para>
     If the <function>ExecForeignUpdate</> pointer is set to
     <literal>NULL</>, attempts to update the foreign table will fail
     with an error message.
    </para>
-->
<para>
    如果<function>ExecForeignUpdate</>指针被设置为<literal>NULL</>，
尝试更新外表将带有错误消息而失败。
</para>

    
<para>
<programlisting>
TupleTableSlot *
ExecForeignDelete (EState *estate,
                   ResultRelInfo *rinfo,
                   TupleTableSlot *slot,
                   TupleTableSlot *planSlot);
</programlisting>
     <!--
     Delete one tuple from the foreign table.
     <literal>estate</> is global execution state for the query.
     <literal>rinfo</> is the <structname>ResultRelInfo</> struct describing
     the target foreign table.
     <literal>slot</> contains nothing useful upon call, but can be used to
     hold the returned tuple.
     <literal>planSlot</> contains the tuple that was generated by the
     <structname>ModifyTable</> plan node's subplan; in particular, it will
     carry any junk columns that were requested by
     <function>AddForeignUpdateTargets</>.  The junk column(s) must be used
     to identify the tuple to be deleted.
 -->
 删除外表上的元组。
 <literal>estate</>是查询的全局执行状态。<literal>rinfo</>是描述目标外表的
 <structname>ResultRelInfo</>结构。<literal>slot</>不包含任何有用调用，
 但是可以用于保留返回的元组。
 <literal>planSlot</>包含通过<structname>ModifyTable</>规划节点的子计划产生的元组；
 尤其是，它将具有通过<function>AddForeignUpdateTargets</>请求的任何垃圾列。
 垃圾列必须用于标识要删除的元组。
    </para>


    <!--
<para>
     The return value is either a slot containing the row that was deleted,
     or NULL if no row was deleted (typically as a result of triggers).  The
     passed-in <literal>slot</> can be used to hold the tuple to be returned.
    </para>
-->
<para>
    返回值要么是包含实际被删除行的槽，
 如果没有行实际被删除，那么返回NULL（再次，通常作为触发器结果）。
 传入的<literal>slot</>可以用于保留返回的元组。
</para>

    <!--
<para>
     The data in the returned slot is used only if the <command>DELETE</>
     query has a <literal>RETURNING</> clause or the foreign table has
     an <literal>AFTER ROW</> trigger.  Triggers require all columns, but the
     FDW could choose to optimize away returning some or all columns depending
     on the contents of the <literal>RETURNING</> clause.  Regardless, some
     slot must be returned to indicate success, or the query's reported row
     count will be wrong.
    </para>
-->
<para>
    只有<command>DELETE</>查询有<literal>RETURNING</>子句，或该外部表有一个
<literal>AFTER ROW</>触发器时，才使用返回槽中的数据。触发器请求所有的字段，
但是FDW可能选择优化返回依赖于<literal>RETURNING</>子句内容的一些或者全部列。
不管怎样，必须返回一些槽以表示成功，否则该查询报告的行数是错误的。
</para>

    <!--
<para>
     If the <function>ExecForeignDelete</> pointer is set to
     <literal>NULL</>, attempts to delete from the foreign table will fail
     with an error message.
    </para>
-->
<para>
      如果<function>ExecForeignDelete</>指针被设置为<literal>NULL</>，
  尝试删除外表将带有错误消息而失败。
</para>

    
<para>
<programlisting>
void
EndForeignModify (EState *estate,
                  ResultRelInfo *rinfo);
</programlisting>
     <!--
     End the table update and release resources.  It is normally not important
     to release palloc'd memory, but for example open files and connections
     to remote servers should be cleaned up.
 -->
 结束表更新并且释放资源。释放palloc内存往往不重要，但是比如打开文件并且链接远程服务器应该
 被清理干净。
    </para>

    <!--
<para>
     If the <function>EndForeignModify</> pointer is set to
     <literal>NULL</>, no action is taken during executor shutdown.
    </para>
-->
<para>
     如果<function>EndForeignModify</>指针被设置为<literal>NULL</>，
 那么在执行器关闭期间不采取任何操作。 
</para>

    
<para>
<programlisting>
int
IsForeignRelUpdatable (Relation rel);
</programlisting>
    <!--
     Report which update operations the specified foreign table supports.
     The return value should be a bitmask of rule event numbers indicating
     which operations are supported by the foreign table, using the
     <literal>CmdType</> enumeration; that is,
     <literal>(1 << CMD_UPDATE) = 4</> for <command>UPDATE</>,
     <literal>(1 << CMD_INSERT) = 8</> for <command>INSERT</>, and
     <literal>(1 << CMD_DELETE) = 16</> for <command>DELETE</>.
 -->
 报告指定外表支持的更新操作。返回值应该是规则事件数的位掩码，标志着
 使用<literal>CmdType</>枚举通过外表支持的操作；即<literal>(1 << CMD_UPDATE) = 4</>为<command>UPDATE</>,
     <literal>(1 << CMD_INSERT) = 8</>为<command>INSERT</>并且
     <literal>(1 << CMD_DELETE) = 16</>为<command>DELETE</>。
 
    </para>

    <!--
<para>
     If the <function>IsForeignRelUpdatable</> pointer is set to
     <literal>NULL</>, foreign tables are assumed to be insertable, updatable,
     or deletable if the FDW provides <function>ExecForeignInsert</>,
     <function>ExecForeignUpdate</>, or <function>ExecForeignDelete</>
     respectively.  This function is only needed if the FDW supports some
     tables that are updatable and some that are not.  (Even then, it's
     permissible to throw an error in the execution routine instead of
     checking in this function.  However, this function is used to determine
     updatability for display in the <literal>information_schema</> views.)
    </para>
-->
<para>
      如果<function>IsForeignRelUpdatable</>指针被设置为<literal>NULL</>，那么FDW分别
  提供<function>ExecForeignInsert</>,
     <function>ExecForeignUpdate</>或者<function>ExecForeignDelete</>，那么
 外表被认为是可插入，可更新或者可删除的。
 如果FDW支持一些可更新的和一些不可更新的表，那么需要这个函数。
 （即使这样，它允许在执行程序中抛出错误而不是在这个函数中进行检查。然而，该函数
 用于在<literal>information_schema</>视图中显示可更新。）
  
</para>

   </sect2>

   <sect2 id="fdw-callbacks-explain">
   <!--
    <title>FDW Routines for <command>EXPLAIN</></title>
   -->
    <title><command>EXPLAIN</>的FDW程序</title>

    
<para>
<programlisting>
void
ExplainForeignScan (ForeignScanState *node,
                    ExplainState *es);
</programlisting>

     <!--
     Print additional <command>EXPLAIN</> output for a foreign table scan.
     This function can call <function>ExplainPropertyText</> and
     related functions to add fields to the <command>EXPLAIN</> output.
     The flag fields in <literal>es</> can be used to determine what to
     print, and the state of the <structname>ForeignScanState</> node
     can be inspected to provide run-time statistics in the <command>EXPLAIN
     ANALYZE</> case.
 -->
 为外表扫描打印额外<command>EXPLAIN</>输出。
 该函数可以调用<function>ExplainPropertyText</>和相关函数添加到<command>EXPLAIN</>输出字段。
 <literal>es</>中的标志位可以用于决定打印什么，并且检查<structname>ForeignScanState</>节点状态
 用来在<command>EXPLAIN ANALYZE</>情况下提供运行时统计。
  
    </para>

    <!--
<para>
     If the <function>ExplainForeignScan</> pointer is set to
     <literal>NULL</>, no additional information is printed during
     <command>EXPLAIN</>.
    </para>
-->
<para>
    如果<function>ExplainForeignScan</>指针被设置为<literal>NULL</>，那么
在<command>EXPLAIN</>期间不打印额外信息。
</para>

    
<para>
<programlisting>
void
ExplainForeignModify (ModifyTableState *mtstate,
                      ResultRelInfo *rinfo,
                      List *fdw_private,
                      int subplan_index,
                      struct ExplainState *es);
</programlisting>
     <!--
     Print additional <command>EXPLAIN</> output for a foreign table update.
     This function can call <function>ExplainPropertyText</> and
     related functions to add fields to the <command>EXPLAIN</> output.
     The flag fields in <literal>es</> can be used to determine what to
     print, and the state of the <structname>ModifyTableState</> node
     can be inspected to provide run-time statistics in the <command>EXPLAIN
     ANALYZE</> case.  The first four arguments are the same as for
     <function>BeginForeignModify</>.
 -->
 为外表更新打印额外<command>EXPLAIN</>输出。
 该函数可以调用<function>ExplainPropertyText</>和相关函数添加到<command>EXPLAIN</>输出字段。
 <literal>es</>中的标志位可以用于决定打印什么，并且检查<structname>ModifyTableState</>节点状态
 用来在<command>EXPLAIN ANALYZE</>情况下提供运行时统计。前四个参数为<function>BeginForeignModify</>
 是相同的。
 
    </para>

    <!--
<para>
     If the <function>ExplainForeignModify</> pointer is set to
     <literal>NULL</>, no additional information is printed during
     <command>EXPLAIN</>.
    </para>
-->
<para>
     如果<function>ExplainForeignModify</>指针被设置为<literal>NULL</>，那么
 在<command>EXPLAIN</>期间不打印任何额外信息。
</para>

   </sect2>

   <sect2 id="fdw-callbacks-analyze">
   <!--
    <title>FDW Routines for <command>ANALYZE</></title>
   -->
     <title><command>ANALYZE</>的FDW程序</title>

    
<para>
<programlisting>
bool
AnalyzeForeignTable (Relation relation,
                     AcquireSampleRowsFunc *func,
                     BlockNumber *totalpages);
</programlisting>
     <!--
     This function is called when <xref linkend="sql-analyze"> is executed on
     a foreign table.  If the FDW can collect statistics for this
     foreign table, it should return <literal>true</>, and provide a pointer
     to a function that will collect sample rows from the table in
     <parameter>func</>, plus the estimated size of the table in pages in
     <parameter>totalpages</>.  Otherwise, return <literal>false</>.
 -->
 当在外表上执行<xref linkend="sql-analyze">时，调用该函数。
 如果FDW可以收集外表的统计，它应该返回<literal>真</>，
 并且提供一个指针给函数，该函数从<parameter>func</>中的表中收集样本行。
 以及<parameter>totalpages</>的页中表的估计大小。
 否则，返回<literal>false</>。
    </para>


    <!--
<para>
     If the FDW does not support collecting statistics for any tables, the
     <function>AnalyzeForeignTable</> pointer can be set to <literal>NULL</>.
    </para>
-->
<para>
     如果FDW不支持任何表的统计，那么<function>AnalyzeForeignTable</>指针可以设置为<literal>NULL</>。
</para>

    
<para>
     <!--
     If provided, the sample collection function must have the signature
 -->
 如果提供，那么样本收集函数必须有识别标志
 
<programlisting>
int
AcquireSampleRowsFunc (Relation relation, int elevel,
                       HeapTuple *rows, int targrows,
                       double *totalrows,
                       double *totaldeadrows);
</programlisting>
     <!--
     A random sample of up to <parameter>targrows</> rows should be collected
     from the table and stored into the caller-provided <parameter>rows</>
     array.  The actual number of rows collected must be returned.  In
     addition, store estimates of the total numbers of live and dead rows in
     the table into the output parameters <parameter>totalrows</> and
     <parameter>totaldeadrows</>.  (Set <parameter>totaldeadrows</> to zero
     if the FDW does not have any concept of dead rows.)
 -->
 应该从表中收集达到<parameter>targrows</>行的随机抽样调查，并且存储到
 调用者提供的<parameter>rows</>数组。必须返回收集行的真实数。
 此外，将表中死的和活行
 总数估计存储到输出参数<parameter>totalrows</>和
     <parameter>totaldeadrows</>中。（如果FDW
 没有死行的任何概念，那么设置<parameter>totaldeadrows</>为零。）
    </para>

   </sect2>

   </sect1>

   <sect1 id="fdw-helpers">
   <!--
    <title>Foreign Data Wrapper Helper Functions</title>
  -->
    <title>外数据封装辅助函数</title>

    <!--
<para>
     Several helper functions are exported from the core server so that
     authors of foreign data wrappers can get easy access to attributes of
     FDW-related objects, such as FDW options.
     To use any of these functions, you need to include the header file
     <filename>foreign/foreign.h</filename> in your source file.
     That header also defines the struct types that are returned by
     these functions.
    </para>
-->
<para>
    从核心服务器输出一些辅助函数，因此外数据封装作者可以很容易访问FDW-相关对象的属性，比如FDW选项。
为了使用任何这些函数，你需要包含你的源文件中的头文件<filename>foreign/foreign.h</filename>。
该头文件也定义了这些函数返回的结构体类型。
</para>

    
<para>
<programlisting>
ForeignDataWrapper *
GetForeignDataWrapper(Oid fdwid);
</programlisting>
     <!--
     This function returns a <structname>ForeignDataWrapper</structname>
     object for the foreign-data wrapper with the given OID.  A
     <structname>ForeignDataWrapper</structname> object contains properties
     of the FDW (see <filename>foreign/foreign.h</filename> for details).
 -->
 该函数为给定OID的外数据封装返回一个<structname>ForeignDataWrapper</structname>对象。 
     <structname>ForeignDataWrapper</structname>对象包含
     FDW的属性 (参阅<filename>foreign/foreign.h</filename>获取更多详情）。
 
    </para>

    
<para>
<programlisting>
ForeignServer *
GetForeignServer(Oid serverid);
</programlisting>
     <!--
     This function returns a <structname>ForeignServer</structname> object
     for the foreign server with the given OID.  A
     <structname>ForeignServer</structname> object contains properties
     of the server (see <filename>foreign/foreign.h</filename> for details).
 -->
 该函数为给定OID的外服务器返回一个<structname>ForeignServer</structname>对象。 
     <structname>ForeignServer</structname>对象包含
     服务器的属性 (参阅<filename>foreign/foreign.h</filename>获取更多详情）。
 
    </para>

    
<para>
<programlisting>
UserMapping *
GetUserMapping(Oid userid, Oid serverid);
</programlisting>
     <!--
     This function returns a <structname>UserMapping</structname> object for
     the user mapping of the given role on the given server.  (If there is no
     mapping for the specific user, it will return the mapping for
     <literal>PUBLIC</>, or throw error if there is none.)  A
     <structname>UserMapping</structname> object contains properties of the
     user mapping (see <filename>foreign/foreign.h</filename> for details).
 -->
 该函数为给定服务器上给定角色的用户映射返回<structname>UserMapping</structname>对象。
 （如果没有特定用户映射，那么它将返回<literal>PUBLIC</>映射，或者如果什么没有，则抛出错误。）
 <structname>UserMapping</structname>对象包含用户映射属性(参阅<filename>foreign/foreign.h</filename>
 获取详情）。
 
    </para>

    
<para>
<programlisting>
ForeignTable *
GetForeignTable(Oid relid);
</programlisting>
     <!--
     This function returns a <structname>ForeignTable</structname> object for
     the foreign table with the given OID.  A
     <structname>ForeignTable</structname> object contains properties of the
     foreign table (see <filename>foreign/foreign.h</filename> for details).
 -->
 该函数为给定OID外表返回<structname>ForeignTable</structname>对象。
 <structname>ForeignTable</structname>对象包含外表属性(参阅
 <filename>foreign/foreign.h</filename>获取更多详情)。
 
    </para>

    
<para>
<programlisting>
List *
GetForeignColumnOptions(Oid relid, AttrNumber attnum);
</programlisting>
     <!--
     This function returns the per-column FDW options for the column with the
     given foreign table OID and attribute number, in the form of a list of
     <structname>DefElem</structname>.  NIL is returned if the column has no
     options.
 -->
 该函数返回在列表<structname>DefElem</structname>形式中具有给定外表OID和属性数每列FDW选项，
 如果该列没有选项，那么返回零。
 
    </para>


    <!--
<para>
     Some object types have name-based lookup functions in addition to the
     OID-based ones:
    </para>
-->
<para>
     一些对象类型除了基于OID的那个有基于名字的查找函数：
</para>

    
<para>
<programlisting>
ForeignDataWrapper *
GetForeignDataWrapperByName(const char *name, bool missing_ok);
</programlisting>
     <!--
     This function returns a <structname>ForeignDataWrapper</structname>
     object for the foreign-data wrapper with the given name.  If the wrapper
     is not found, return NULL if missing_ok is true, otherwise raise an
     error.
 -->
 该函数返回具有给定名称的外数据封装的<structname>ForeignDataWrapper</structname>对象。
 如果没有找到封装，如果missing_ok是真的，那么返回NULL，否则抛出错误。
    </para>

    
<para>
<programlisting>
ForeignServer *
GetForeignServerByName(const char *name, bool missing_ok);
</programlisting>
     <!--
     This function returns a <structname>ForeignServer</structname> object
     for the foreign server with the given name.  If the server is not found,
     return NULL if missing_ok is true, otherwise raise an error.
 -->
 该函数为给定名字的外服务器返回<structname>ForeignServer</structname>对象。
 如果没有找到服务器，如果missing_ok是真的，那么返回NULL，否则抛出错误。
    </para>

   </sect1>

   <sect1 id="fdw-planning">
   <!--
    <title>Foreign Data Wrapper Query Planning</title>
 -->
    <title>外数据封装查询规划</title>

    <!--
<para>
     The FDW callback functions <function>GetForeignRelSize</>,
     <function>GetForeignPaths</>, <function>GetForeignPlan</>, and
     <function>PlanForeignModify</> must fit into the workings of the
     <productname>PostgreSQL</> planner.  Here are some notes about what
     they must do.
    </para>
-->
<para>
    FDW回调函数<function>GetForeignRelSize</>,
     <function>GetForeignPaths</>, <function>GetForeignPlan</>和
     <function>PlanForeignModify</>必须适合<productname>PostgreSQL</>规划器的工作。
 这有一些他们必须做的说明。
</para>

    <!--
<para>
     The information in <literal>root</> and <literal>baserel</> can be used
     to reduce the amount of information that has to be fetched from the
     foreign table (and therefore reduce the cost).
     <literal>baserel-&gt;baserestrictinfo</> is particularly interesting, as
     it contains restriction quals (<literal>WHERE</> clauses) that should be
     used to filter the rows to be fetched.  (The FDW itself is not required
     to enforce these quals, as the core executor can check them instead.)
     <literal>baserel-&gt;reltargetlist</> can be used to determine which
     columns need to be fetched; but note that it only lists columns that
     have to be emitted by the <structname>ForeignScan</> plan node, not
     columns that are used in qual evaluation but not output by the query.
    </para>
-->
<para>
   在<literal>root</>和<literal>baserel</>中的信息可以用于减少从外表中（因此降低成本）读取的信息量。
   <literal>baserel-&gt;baserestrictinfo</>特别有趣，正如它包含应该用于过滤读取的行的限制资格测试(<literal>WHERE</> clauses)。
   （FDW本身不需要执行这些测试，正如核心执行者反而可以检查它们。）
   <literal>baserel-&gt;reltargetlist</>可以用于决定需要抓取哪个列；但是注意它仅仅列出通过
   <structname>ForeignScan</>规划节点发出的列，不是在质量评估中使用的列也不是查询输出列。
   
</para>

    <!--
<para>
     Various private fields are available for the FDW planning functions to
     keep information in.  Generally, whatever you store in FDW private fields
     should be palloc'd, so that it will be reclaimed at the end of planning.
    </para>
-->
<para>
    各种私有字段可用于FDW规划函数保持信息。一般来说，无论在FDW私有字段存储什么
应该是palloc，所以它将在规划结束后被回收。
</para>

    <!--
<para>
     <literal>baserel-&gt;fdw_private</> is a <type>void</> pointer that is
     available for FDW planning functions to store information relevant to
     the particular foreign table.  The core planner does not touch it except
     to initialize it to NULL when the <literal>baserel</> node is created.
     It is useful for passing information forward from
     <function>GetForeignRelSize</> to <function>GetForeignPaths</> and/or
     <function>GetForeignPaths</> to <function>GetForeignPlan</>, thereby
     avoiding recalculation.
    </para>
-->
<para>
   <literal>baserel-&gt;fdw_private</>是<type>空</>指针，可用于FDW规划函数存储与特定外表相关的
   信息。当创建<literal>baserel</>结点时，核心规划器并不接触它除了初始化为NULL外。
   从<function>GetForeignRelSize</>到<function>GetForeignPaths</>和/或者
   <function>GetForeignPaths</>到<function>GetForeignPlan</>传递信息是非常有用的，
   从而避免重复计算。
 
</para>

    <!--
<para>
     <function>GetForeignPaths</> can identify the meaning of different
     access paths by storing private information in the
     <structfield>fdw_private</> field of <structname>ForeignPath</> nodes.
     <structfield>fdw_private</> is declared as a <type>List</> pointer, but
     could actually contain anything since the core planner does not touch
     it.  However, best practice is to use a representation that's dumpable
     by <function>nodeToString</>, for use with debugging support available
     in the backend.
    </para>
-->
<para>
     <function>GetForeignPaths</>可以通过在<structname>ForeignPath</>节点的
 <structfield>fdw_private</>字段存储私有信息标识不同访问路径的含义。
 作为<type>List</>指针声明<structfield>fdw_private</>，但是实际上可以包含任何由于
 核心规划器没有接触的东西。然而，最好办法是通过<function>nodeToString</>可倾式表示形式，
 用于调试后端可用支持。
</para>

    <!--
<para>
     <function>GetForeignPlan</> can examine the <structfield>fdw_private</>
     field of the selected <structname>ForeignPath</> node, and can generate
     <structfield>fdw_exprs</> and <structfield>fdw_private</> lists to be
     placed in the <structname>ForeignScan</> plan node, where they will be
     available at execution time.  Both of these lists must be
     represented in a form that <function>copyObject</> knows how to copy.
     The <structfield>fdw_private</> list has no other restrictions and is
     not interpreted by the core backend in any way.  The
     <structfield>fdw_exprs</> list, if not NIL, is expected to contain
     expression trees that are intended to be executed at run time.  These
     trees will undergo post-processing by the planner to make them fully
     executable.
    </para>
-->
<para>
    <function>GetForeignPlan</>可以检查所选的<structname>ForeignPath</>节点的
<structfield>fdw_private</>字段，并且可以产生放在<structname>ForeignScan</>
规划节点中的<structfield>fdw_exprs</>和<structfield>fdw_private</>列表，
在执行时间他们可用。这些列表必须在<function>copyObject</>知道如何拷贝的形式中被表示。
<structfield>fdw_private</>列表没有其他限制，并且不能通过任何方式的核心后端进行解释。
<structfield>fdw_exprs</>列表如果不是零，那么希望包含在运行时执行的表达式树。
这些树将通过规划器使得它们完全可执行进行后处理。


</para>

    <!--
<para>
     In <function>GetForeignPlan</>, generally the passed-in target list can
     be copied into the plan node as-is.  The passed <literal>scan_clauses</> list
     contains the same clauses as <literal>baserel-&gt;baserestrictinfo</>,
     but may be re-ordered for better execution efficiency.  In simple cases
     the FDW can just strip <structname>RestrictInfo</> nodes from the
     <literal>scan_clauses</> list (using <function>extract_actual_clauses</>) and put
     all the clauses into the plan node's qual list, which means that all the
     clauses will be checked by the executor at run time.  More complex FDWs
     may be able to check some of the clauses internally, in which case those
     clauses can be removed from the plan node's qual list so that the
     executor doesn't waste time rechecking them.
    </para>
-->
<para>
     在<function>GetForeignPlan</>中，往往目标列表可以拷贝到规划节点中。
 已通过的<literal>scan_clauses</>列表包含和<literal>baserel-&gt;baserestrictinfo</>相同分句，
 但是为了更好的执行效率可能重新排序。
 在简单情况下FDW可以从<literal>scan_clauses</>列表（使用<function>extract_actual_clauses</>）中删除<structname>RestrictInfo</>节点，
 并且将所有分句放入规划节点的资格列表中，这意味着在运行期间通过执行器将检查所有分句。
 更多复杂的FDW可能检查一些内部分句，在这种情况下那些分句可以从规划节点的列表中删除，以便执行器
 不会浪费复查它们的时间。
 
</para>

    <!--
<para>
     As an example, the FDW might identify some restriction clauses of the
     form <replaceable>foreign_variable</> <literal>=</>
     <replaceable>sub_expression</>, which it determines can be executed on
     the remote server given the locally-evaluated value of the
     <replaceable>sub_expression</>.  The actual identification of such a
     clause should happen during <function>GetForeignPaths</>, since it would
     affect the cost estimate for the path.  The path's
     <structfield>fdw_private</> field would probably include a pointer to
     the identified clause's <structname>RestrictInfo</> node.  Then
     <function>GetForeignPlan</> would remove that clause from <literal>scan_clauses</>,
     but add the <replaceable>sub_expression</> to <structfield>fdw_exprs</>
     to ensure that it gets massaged into executable form.  It would probably
     also put control information into the plan node's
     <structfield>fdw_private</> field to tell the execution functions what
     to do at run time.  The query transmitted to the remote server would
     involve something like <literal>WHERE <replaceable>foreign_variable</> =
     $1</literal>, with the parameter value obtained at run time from
     evaluation of the <structfield>fdw_exprs</> expression tree.
    </para>
-->
<para>
     作为一个例子，FDW可能标识一些来自<replaceable>foreign_variable</> <literal>=</>
     <replaceable>sub_expression</>的限制分句，它决定了在给定<replaceable>sub_expression</>的本地评估值的
 远程服务器上被执行。在<function>GetForeignPaths</>期间产生了该分句的实际标识，
 因为它会影响路径的成本估算。路径的<structfield>fdw_private</>字段可能包含一个指向
 已标识分句的<structname>RestrictInfo</>节点的指针。然后<function>GetForeignPlan</>从<literal>scan_clauses</>中
 删除该分句，但是增加<replaceable>sub_expression</>到<structfield>fdw_exprs</>以确保
 它获得可执行形式。它也可能将控制信息放到规划节点的<structfield>fdw_private</>
 字段以告知执行函数在运行时间执行什么。传送到远程服务器的查询可能涉及到像<literal>WHERE <replaceable>foreign_variable</> =
     $1</literal>的一些内容，使用从<structfield>fdw_exprs</>表达式树评估中获得的参数值。
 
</para>

    <!--
<para>
     The FDW should always construct at least one path that depends only on
     the table's restriction clauses.  In join queries, it might also choose
     to construct path(s) that depend on join clauses, for example
     <replaceable>foreign_variable</> <literal>=</>
     <replaceable>local_variable</>.  Such clauses will not be found in
     <literal>baserel-&gt;baserestrictinfo</> but must be sought in the
     relation's join lists.  A path using such a clause is called a
     <quote>parameterized path</>.  It must identify the other relations
     used in the selected join clause(s) with a suitable value of
     <literal>param_info</>; use <function>get_baserel_parampathinfo</>
     to compute that value.  In <function>GetForeignPlan</>, the
     <replaceable>local_variable</> portion of the join clause would be added
     to <structfield>fdw_exprs</>, and then at run time the case works the
     same as for an ordinary restriction clause.
    </para>
-->
<para>
    FDW应该总是构建至少一个仅仅依赖于表的限制分句的路径，在连接查询中，它也可能选择构建依赖于连接分句的路径，
比如 <replaceable>foreign_variable</> <literal>=</>
     <replaceable>local_variable</>。该分句没有在<literal>baserel-&gt;baserestrictinfo</>中找到，
 但是必须在关系的连接列表中寻找。
 使用分句的路径被称为<quote>参数化路径</>。
 它必须标识用于使用<literal>param_info</>合适值的已选择连接分句的其他关系；
 使用<function>get_baserel_parampathinfo</>计算该值。在<function>GetForeignPlan</>中，
 连接分句的<replaceable>local_variable</>部分将被添加到<structfield>fdw_exprs</>中，
 然后运行时该情况与普通限制分句一样运行。
 
</para>

    <!--
<para>
     When planning an <command>UPDATE</> or <command>DELETE</>,
     <function>PlanForeignModify</> can look up the <structname>RelOptInfo</>
     struct for the foreign table and make use of the
     <literal>baserel-&gt;fdw_private</> data previously created by the
     scan-planning functions.  However, in <command>INSERT</> the target
     table is not scanned so there is no <structname>RelOptInfo</> for it.
     The <structname>List</> returned by <function>PlanForeignModify</> has
     the same restrictions as the <structfield>fdw_private</> list of a
     <structname>ForeignScan</> plan node, that is it must contain only
     structures that <function>copyObject</> knows how to copy.
    </para>
-->
<para>
     当规划一个<command>UPDATE</>或者<command>DELETE</>的时候，
  <function>PlanForeignModify</>可以查找外表的<structname>RelOptInfo</>结构，
 并且充分使用通过扫描规划函数预先创建的<literal>baserel-&gt;fdw_private</>数据。
 然而，在<command>INSERT</>中不扫描目标表，所以没有<structname>RelOptInfo</>。
 通过<function>PlanForeignModify</>返回的<structname>List</>与<structname>ForeignScan</>规划节点
 的<structfield>fdw_private</>列表有相同的限制，
 即它必须包含<function>copyObject</>知道如何拷贝的结构。
 
</para>

    <!--
<para>
     For an <command>UPDATE</> or <command>DELETE</> against an external data
     source that supports concurrent updates, it is recommended that the
     <literal>ForeignScan</> operation lock the rows that it fetches, perhaps
     via the equivalent of <command>SELECT FOR UPDATE</>.  The FDW may also
     choose to lock rows at fetch time when the foreign table is referenced
     in a <command>SELECT FOR UPDATE/SHARE</>; if it does not, the
     <literal>FOR UPDATE</> or <literal>FOR SHARE</> option is essentially a
     no-op so far as the foreign table is concerned.  This behavior may yield
     semantics slightly different from operations on local tables, where row
     locking is customarily delayed as long as possible: remote rows may get
     locked even though they subsequently fail locally-applied restriction or
     join conditions.  However, matching the local semantics exactly would
     require an additional remote access for every row, and might be
     impossible anyway depending on what locking semantics the external data
     source provides.
    </para>
-->
<para>
    <command>UPDATE</>或者<command>DELETE</>反对外部数据源支持并发更新，推荐
<literal>ForeignScan</>操作锁定抓取的行，也许通过<command>SELECT FOR UPDATE</>的等价物。
当在<command>SELECT FOR UPDATE/SHARE</>引用外表时，FDW可能也会在抓取时选择锁定行。
如果没有做，就有关外表来说，
那么<literal>FOR UPDATE</>或者<literal>FOR SHARE</>选项本质上是无操作的。
这种操作可能会产生本地表操作上轻微的语义差异，行锁定通常尽可能的延迟：
远程行可能获得锁定即使他们随后没有本地应用限制或者连接条件。
然而，匹配局部语义确实需要每行的额外远程访问，并且不可能依赖于
外部数据源提供的锁定语义内容。


</para>

  </sect1>

 </chapter>
