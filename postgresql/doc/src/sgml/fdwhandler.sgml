<!-- doc/src/sgml/fdwhandler.sgml -->

 <chapter id="fdwhandler">
<!-- pgdoc-cn_start sig_en=d5b0e2dd7f37d0c7195f505cba3b6445 sig_cn_org=None source=14.1 
   <title>Writing a Foreign Data Wrapper</title>
________________________________________________________-->
   <title>编写一个外部数据包装器</title>
<!-- pgdoc-cn_end sig_en=d5b0e2dd7f37d0c7195f505cba3b6445 -->

<!-- pgdoc-cn_start sig_en=cdafc40711490b625e0267ab93f90225 sig_cn_org=None source=14.1 
   <indexterm zone="fdwhandler">
    <primary>foreign data wrapper</primary>
    <secondary>handler for</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="fdwhandler">
    <primary>foreign data wrapper</primary>
    <secondary>handler for</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=cdafc40711490b625e0267ab93f90225 -->

<!-- pgdoc-cn_start sig_en=f82c253ed26948f0f66db53dd58da29b sig_cn_org=None source=14.1 
   <para>
    All operations on a foreign table are handled through its foreign data
    wrapper, which consists of a set of functions that the core server
    calls.  The foreign data wrapper is responsible for fetching
    data from the remote data source and returning it to the
    <productname>PostgreSQL</productname> executor.  If updating foreign
    tables is to be supported, the wrapper must handle that, too.
    This chapter outlines how to write a new foreign data wrapper.
   </para>
________________________________________________________-->
   <para>
    所有在一个外部表上的操作都通过它的外部数据包装器来处理，外部数据包装器由一组被核心服务器调用的函数组成。外部数据包装器负责从远程数据源取得数据并把它返回给<productname>PostgreSQL</productname>执行器。如果要支持更新外部表，包装器也需要处理更新。本章将介绍如何编写一个新的外部数据包装器。
   </para>
<!-- pgdoc-cn_end sig_en=f82c253ed26948f0f66db53dd58da29b -->

<!-- pgdoc-cn_start sig_en=bfa6df85777d46408ba09c0092c4a56b sig_cn_org=None source=14.1 
   <para>
    The foreign data wrappers included in the standard distribution are good
    references when trying to write your own.  Look into the
    <filename>contrib</filename> subdirectory of the source tree.
    The <xref linkend="sql-createforeigndatawrapper"/> reference page also has
    some useful details.
   </para>
________________________________________________________-->
   <para>
    在你试图编写你自己的外部数据包装器时，包含在标准发布中的外部数据包装器会是很好的参考。请看看源代码树的<filename>contrib</filename>子目录。<xref linkend="sql-createforeigndatawrapper"/>参考页也会有很多有用的细节。
   </para>
<!-- pgdoc-cn_end sig_en=bfa6df85777d46408ba09c0092c4a56b -->

   <note>
<!-- pgdoc-cn_start sig_en=931c8d8ddf84d8d3a9ecaa961834f615 sig_cn_org=None source=14.1 
    <para>
     The SQL standard specifies an interface for writing foreign data wrappers.
     However, PostgreSQL does not implement that API, because the effort to
     accommodate it into PostgreSQL would be large, and the standard API hasn't
     gained wide adoption anyway.
    </para>
________________________________________________________-->
    <para>
     SQL 标准声明了一个接口用来编写外部数据包装器。但是，PostgreSQL 没有实现该 API，因为将其纳入到 PostgreSQL 中的工作量将会很大，并且标准的 API 并没有得到广泛地采用。
    </para>
<!-- pgdoc-cn_end sig_en=931c8d8ddf84d8d3a9ecaa961834f615 -->
   </note>

   <sect1 id="fdw-functions">
<!-- pgdoc-cn_start sig_en=4a7873ace34b01c8c1997caea3a00c8a sig_cn_org=None source=14.1 
    <title>Foreign Data Wrapper Functions</title>
________________________________________________________-->
    <title>外部数据包装器函数</title>
<!-- pgdoc-cn_end sig_en=4a7873ace34b01c8c1997caea3a00c8a -->

<!-- pgdoc-cn_start sig_en=d9e2ef48aa0d5f2c3a9518d4392b8ddd sig_cn_org=None source=14.1 
    <para>
     The FDW author needs to implement a handler function, and optionally
     a validator function. Both functions must be written in a compiled
     language such as C, using the version-1 interface.
     For details on C language calling conventions and dynamic loading,
     see <xref linkend="xfunc-c"/>.
    </para>
________________________________________________________-->
    <para>
     FDW的作者需要实现一个处理器函数，并且可以有选择地实现一个验证器函数。两个函数都必须被用一种编译语言（如 C）来编写，并使用版本-1接口。关于 C 语言调用规范和动态载入的细节，请见<xref linkend="xfunc-c"/>。
    </para>
<!-- pgdoc-cn_end sig_en=d9e2ef48aa0d5f2c3a9518d4392b8ddd -->

<!-- pgdoc-cn_start sig_en=cd897b78ddd82a2801926cc05bc031fc sig_cn_org=None source=14.1 
    <para>
     The handler function simply returns a struct of function pointers to
     callback functions that will be called by the planner, executor, and
     various maintenance commands.
     Most of the effort in writing an FDW is in implementing these callback
     functions.
     The handler function must be registered with
     <productname>PostgreSQL</productname> as taking no arguments and
     returning the special pseudo-type <type>fdw_handler</type>.  The
     callback functions are plain C functions and are not visible or
     callable at the SQL level.  The callback functions are described in
     <xref linkend="fdw-callbacks"/>.
    </para>
________________________________________________________-->
    <para>
     处理器函数简单地返回一个包含了多个回调函数指针的结构体，回调函数将被规划器、执行器和多种维护命令调用。编写一个FDW的大部分工作量都在实现这些回调函数上。处理器函数必须被注册在<productname>PostgreSQL</productname>中，并且注册为不需要参数并且返回特殊的伪类型<type>fdw_handler</type>。回调函数则是普通的 C 函数并且对于 SQL 层是不可见的或者不可调用的。回调函数在<xref linkend="fdw-callbacks"/>中描述。
    </para>
<!-- pgdoc-cn_end sig_en=cd897b78ddd82a2801926cc05bc031fc -->

<!-- pgdoc-cn_start sig_en=08dc8f8979e7d13f13ed6a7142534455 sig_cn_org=5f59a937fd37b39cd1c8f2485fb0e1df source=15.7 
    <para>
     The validator function is responsible for validating options given in
     <command>CREATE</command> and <command>ALTER</command> commands for its
     foreign data wrapper, as well as foreign servers, user mappings, and
     foreign tables using the wrapper.
     The validator function must be registered as taking two arguments, a
     text array containing the options to be validated, and an OID
     representing the type of object the options are associated with. The
     latter corresponds to the OID of the system catalog the object
     would be stored in, one of:
     <itemizedlist spacing="compact">
      <listitem><para><literal>AttributeRelationId</literal></para></listitem>
      <listitem><para><literal>ForeignDataWrapperRelationId</literal></para></listitem>
      <listitem><para><literal>ForeignServerRelationId</literal></para></listitem>
      <listitem><para><literal>ForeignTableRelationId</literal></para></listitem>
      <listitem><para><literal>UserMappingRelationId</literal></para></listitem>
     </itemizedlist>
     If no validator function is supplied, options are not checked at object
     creation time or object alteration time.
    </para>
________________________________________________________-->
    <para>
     验证函数负责验证在<command>CREATE</command>和<command>ALTER</command>命令中给定的选项，
     以及使用该包装器的外部数据包装器的外部服务器、用户映射和外部表。
     验证函数必须注册为接受两个参数，一个包含要验证的选项的文本数组，
     另一个表示选项所关联的对象类型的OID。后者对应于对象将存储在的系统目录的OID之一:
     <itemizedlist spacing="compact">
      <listitem><para><literal>AttributeRelationId</literal></para></listitem>
      <listitem><para><literal>ForeignDataWrapperRelationId</literal></para></listitem>
      <listitem><para><literal>ForeignServerRelationId</literal></para></listitem>
      <listitem><para><literal>ForeignTableRelationId</literal></para></listitem>
      <listitem><para><literal>UserMappingRelationId</literal></para></listitem>
     </itemizedlist>
     如果没有提供验证函数，则在对象创建时间或对象更改时间不会检查选项。
    </para>
<!-- pgdoc-cn_end sig_en=08dc8f8979e7d13f13ed6a7142534455 -->

   </sect1>

   <sect1 id="fdw-callbacks">
<!-- pgdoc-cn_start sig_en=748dc9d2af6e4d8bdc6232fbc24d9154 sig_cn_org=None source=14.1 
    <title>Foreign Data Wrapper Callback Routines</title>
________________________________________________________-->
    <title>外部数据包装器回调例程</title>
<!-- pgdoc-cn_end sig_en=748dc9d2af6e4d8bdc6232fbc24d9154 -->

<!-- pgdoc-cn_start sig_en=176ad63be3c8345f25b6b8a29ed32c12 sig_cn_org=None source=14.1 
    <para>
     The FDW handler function returns a palloc'd <structname>FdwRoutine</structname>
     struct containing pointers to the callback functions described below.
     The scan-related functions are required, the rest are optional.
    </para>
________________________________________________________-->
    <para>
     FDW处理器函数返回一个palloc过的<structname>FdwRoutine</structname>结构，它包含下文描述的回调函数的指针。扫描相关的函数是必需的，剩下的是可选的。
    </para>
<!-- pgdoc-cn_end sig_en=176ad63be3c8345f25b6b8a29ed32c12 -->

<!-- pgdoc-cn_start sig_en=2d022300ab4cd68b4c1397e50f5ab8c8 sig_cn_org=None source=14.1 
    <para>
     The <structname>FdwRoutine</structname> struct type is declared in
     <filename>src/include/foreign/fdwapi.h</filename>, which see for additional
     details.
    </para>
________________________________________________________-->
    <para>
     <structname>FdwRoutine</structname>结构类型被声明在<filename>src/include/foreign/fdwapi.h</filename>中，可以查看它来获得额外的信息。
    </para>
<!-- pgdoc-cn_end sig_en=2d022300ab4cd68b4c1397e50f5ab8c8 -->

   <sect2 id="fdw-callbacks-scan">
<!-- pgdoc-cn_start sig_en=03ba30e6a4da75b72000930c36cf19ef sig_cn_org=None source=14.1 
    <title>FDW Routines for Scanning Foreign Tables</title>
________________________________________________________-->
    <title>用于扫描外部表的FDW例程</title>
<!-- pgdoc-cn_end sig_en=03ba30e6a4da75b72000930c36cf19ef -->

<!-- pgdoc-cn_start sig_en=d71423a15cb8703dcb2393b57b6ef486 sig_cn_org=None source=14.1 
    <para>
<programlisting>
void
GetForeignRelSize(PlannerInfo *root,
                  RelOptInfo *baserel,
                  Oid foreigntableid);
</programlisting>

     Obtain relation size estimates for a foreign table.  This is called
     at the beginning of planning for a query that scans a foreign table.
     <literal>root</literal> is the planner's global information about the query;
     <literal>baserel</literal> is the planner's information about this table; and
     <literal>foreigntableid</literal> is the <structname>pg_class</structname> OID of the
     foreign table.  (<literal>foreigntableid</literal> could be obtained from the
     planner data structures, but it's passed explicitly to save effort.)
    </para>
________________________________________________________-->
    <para>
<programlisting>
void
GetForeignRelSize(PlannerInfo *root,
                  RelOptInfo *baserel,
                  Oid foreigntableid);
</programlisting>

     获取一个外部表的关系尺寸估计。在对一个扫描外部表的查询进行规划的开头将调用该函数。<literal>root</literal>是规划器的关于该查询的全局信息；<literal>baserel</literal>是规划器的关于该表的信息；<literal>foreigntableid</literal>是外部表在<structname>pg_class</structname>中的 OID （<literal>foreigntableid</literal>可以从规划器的数据结构中获得，但是为了减少工作量，这里直接显式地将它传递给函数）。
    </para>
<!-- pgdoc-cn_end sig_en=d71423a15cb8703dcb2393b57b6ef486 -->

<!-- pgdoc-cn_start sig_en=49d541f3862226fffaaf5d9c80fb3eae sig_cn_org=None source=14.1 
    <para>
     This function should update <literal>baserel-&gt;rows</literal> to be the
     expected number of rows returned by the table scan, after accounting for
     the filtering done by the restriction quals.  The initial value of
     <literal>baserel-&gt;rows</literal> is just a constant default estimate, which
     should be replaced if at all possible.  The function may also choose to
     update <literal>baserel-&gt;width</literal> if it can compute a better estimate
     of the average result row width.
     (The initial value is based on column data types and on column
     average-width values measured by the last <command>ANALYZE</command>.)
     Also, this function may update <literal>baserel-&gt;tuples</literal> if
     it can compute a better estimate of the foreign table's total row count.
     (The initial value is
     from <structname>pg_class</structname>.<structfield>reltuples</structfield>
     which represents the total row count seen by the
     last <command>ANALYZE</command>; it will be <literal>-1</literal> if
     no <command>ANALYZE</command> has been done on this foreign table.)
    </para>
________________________________________________________-->
    <para>
     这个函数应该更新<literal>baserel-&gt;rows</literal>为表扫描根据限制条件完成了过滤后将返回的预期行数。
     <literal>baserel-&gt;rows</literal>的初始值只是一个常数的默认估计值，应该尽可能把它替换掉。
     如果该函数能够计算出一个平均结果行宽度的更好的估计值，该函数也可能选择更新<literal>baserel-&gt;width</literal>。
     (初始值基于列数据类型和最后一个<command>ANALYZE</command>测量的列平均宽度值。)
     此外，如果该函数能够更好地计算出外部表的总行数，则该函数可以更新<literal>baserel-&gt;tuples</literal>。
     （初始值来自<structname>pg_class</structname>。
     <structfield>reltuples</structfield>表示最后一次<command>ANALYZE</command>看到的总行数;如果没有<command>ANALYZE</command>在此外表上完成，它将是<literal>-1</literal>。）
    </para>
<!-- pgdoc-cn_end sig_en=49d541f3862226fffaaf5d9c80fb3eae -->

<!-- pgdoc-cn_start sig_en=9ebc87c867b5bc8ae8287659c072e25e sig_cn_org=None source=14.1 
    <para>
     See <xref linkend="fdw-planning"/> for additional information.
    </para>
________________________________________________________-->
    <para>
     更多信息请见<xref linkend="fdw-planning"/>。
    </para>
<!-- pgdoc-cn_end sig_en=9ebc87c867b5bc8ae8287659c072e25e -->

<!-- pgdoc-cn_start sig_en=b9ffcfa601baf6ec85948faa597e0071 sig_cn_org=None source=14.1 
    <para>
<programlisting>
void
GetForeignPaths(PlannerInfo *root,
                RelOptInfo *baserel,
                Oid foreigntableid);
</programlisting>

     Create possible access paths for a scan on a foreign table.
     This is called during query planning.
     The parameters are the same as for <function>GetForeignRelSize</function>,
     which has already been called.
    </para>
________________________________________________________-->
    <para>
<programlisting>
void
GetForeignPaths(PlannerInfo *root,
                RelOptInfo *baserel,
                Oid foreigntableid);
</programlisting>

     为一个外部表上的扫描创建可能的访问路径。这个函数在查询规划过程中被调用。参数和<function>GetForeignRelSize</function>相同，后者已经被调用过了。
    </para>
<!-- pgdoc-cn_end sig_en=b9ffcfa601baf6ec85948faa597e0071 -->

<!-- pgdoc-cn_start sig_en=26eb98737ecc141d72ecfdd50d458350 sig_cn_org=None source=14.1 
    <para>
     This function must generate at least one access path
     (<structname>ForeignPath</structname> node) for a scan on the foreign table and
     must call <function>add_path</function> to add each such path to
     <literal>baserel-&gt;pathlist</literal>.  It's recommended to use
     <function>create_foreignscan_path</function> to build the
     <structname>ForeignPath</structname> nodes.  The function can generate multiple
     access paths, e.g., a path which has valid <literal>pathkeys</literal> to
     represent a pre-sorted result.  Each access path must contain cost
     estimates, and can contain any FDW-private information that is needed to
     identify the specific scan method intended.
    </para>
________________________________________________________-->
    <para>
     这个函数必须为外部表上的扫描生成至少一个访问路径（<structname>ForeignPath</structname>节点），并且必须调用<function>add_path</function>把每一个这样的路径加入到<literal>baserel-&gt;pathlist</literal>中。我们推荐使用<function>create_foreignscan_path</function>来建立<structname>ForeignPath</structname>节点。该函数可以生成多个访问路径，例如一个具有合法<literal>pathkeys</literal>的路径表示一个预排序好的结果。每一个反问路径必须包含代价估计，并且能包含任何FDW的私有信息，这种信息被用来标识想要使用的指定扫描方法。
    </para>
<!-- pgdoc-cn_end sig_en=26eb98737ecc141d72ecfdd50d458350 -->

<!-- pgdoc-cn_start sig_en=9ebc87c867b5bc8ae8287659c072e25e sig_cn_org=None source=14.1 
    <para>
     See <xref linkend="fdw-planning"/> for additional information.
    </para>
________________________________________________________-->
    <para>
     更多信息请见<xref linkend="fdw-planning"/>。
    </para>
<!-- pgdoc-cn_end sig_en=9ebc87c867b5bc8ae8287659c072e25e -->

<!-- pgdoc-cn_start sig_en=ed341d4c1110097c7059b30f154eefae sig_cn_org=None source=14.1 
    <para>
<programlisting>
ForeignScan *
GetForeignPlan(PlannerInfo *root,
               RelOptInfo *baserel,
               Oid foreigntableid,
               ForeignPath *best_path,
               List *tlist,
               List *scan_clauses,
               Plan *outer_plan);
</programlisting>

     Create a <structname>ForeignScan</structname> plan node from the selected foreign
     access path.  This is called at the end of query planning.
     The parameters are as for <function>GetForeignRelSize</function>, plus
     the selected <structname>ForeignPath</structname> (previously produced by
     <function>GetForeignPaths</function>, <function>GetForeignJoinPaths</function>,
     or <function>GetForeignUpperPaths</function>),
     the target list to be emitted by the plan node,
     the restriction clauses to be enforced by the plan node,
     and the outer subplan of the <structname>ForeignScan</structname>,
     which is used for rechecks performed by <function>RecheckForeignScan</function>.
     (If the path is for a join rather than a base
     relation, <literal>foreigntableid</literal> is <literal>InvalidOid</literal>.)
    </para>
________________________________________________________-->
    <para>
<programlisting>
ForeignScan *
GetForeignPlan(PlannerInfo *root,
               RelOptInfo *baserel,
               Oid foreigntableid,
               ForeignPath *best_path,
               List *tlist,
               List *scan_clauses,
               Plan *outer_plan);
</programlisting>

     从选择的外部访问路径创建一个<structname>ForeignScan</structname>计划节点。这个函数在查询规划的末尾被调用。参数和<function>GetForeignRelSize</function>的一样，外加选中的<structname>ForeignPath</structname>（在前面由<function>GetForeignPaths</function>、<function>GetForeignJoinPaths</function>或者<function>GetForeignUpperPaths</function>产生）、被计划节点发出的目标列表以及计划节点强制的限制子句以及被<function>RecheckForeignScan</function>执行的复查所使用的<structname>ForeignScan</structname>的外子计划（如果该路径是用于一个连接而非基本关系，则<literal>foreigntableid</literal>是<literal>InvalidOid</literal>）。
    </para>
<!-- pgdoc-cn_end sig_en=ed341d4c1110097c7059b30f154eefae -->

<!-- pgdoc-cn_start sig_en=be18c48c0f207bbbff6fcaae040f5deb sig_cn_org=None source=14.1 
    <para>
     This function must create and return a <structname>ForeignScan</structname> plan
     node; it's recommended to use <function>make_foreignscan</function> to build the
     <structname>ForeignScan</structname> node.
    </para>
________________________________________________________-->
    <para>
     这个函数必须创建并返回一个<structname>ForeignScan</structname>计划节点，我们对剑使用<function>make_foreignscan</function>来建立<structname>ForeignScan</structname>节点。
    </para>
<!-- pgdoc-cn_end sig_en=be18c48c0f207bbbff6fcaae040f5deb -->

<!-- pgdoc-cn_start sig_en=9ebc87c867b5bc8ae8287659c072e25e sig_cn_org=None source=14.1 
    <para>
     See <xref linkend="fdw-planning"/> for additional information.
    </para>
________________________________________________________-->
    <para>
     更多信息请见<xref linkend="fdw-planning"/>。
    </para>
<!-- pgdoc-cn_end sig_en=9ebc87c867b5bc8ae8287659c072e25e -->

<!-- pgdoc-cn_start sig_en=d21c7cbbf539626a6f06136ac8f2b840 sig_cn_org=None source=14.1 
    <para>
<programlisting>
void
BeginForeignScan(ForeignScanState *node,
                 int eflags);
</programlisting>

     Begin executing a foreign scan. This is called during executor startup.
     It should perform any initialization needed before the scan can start,
     but not start executing the actual scan (that should be done upon the
     first call to <function>IterateForeignScan</function>).
     The <structname>ForeignScanState</structname> node has already been created, but
     its <structfield>fdw_state</structfield> field is still NULL.  Information about
     the table to scan is accessible through the
     <structname>ForeignScanState</structname> node (in particular, from the underlying
     <structname>ForeignScan</structname> plan node, which contains any FDW-private
     information provided by <function>GetForeignPlan</function>).
     <literal>eflags</literal> contains flag bits describing the executor's
     operating mode for this plan node.
    </para>
________________________________________________________-->
    <para>
<programlisting>
void
BeginForeignScan(ForeignScanState *node,
                 int eflags);
</programlisting>

     开始执行一个外部扫描。这个函数在执行器启动阶段被调用。它应该执行任何在扫描能够开始之前需要完成的初始化工作，但是并不开始执行真正的扫描（会在第一次调用<function>IterateForeignScan</function>时完成）。<structname>ForeignScanState</structname>节点已经被创建好了，但是它的<structfield>fdw_state</structfield>域仍然为 NULL。关于要被扫描的表的信息可以通过<structname>ForeignScanState</structname>节点访问（特殊地，从底层的<structname>ForeignScan</structname>计划节点，它包含任何由<function>GetForeignPlan</function>提供的FDW私有信息）。<literal>eflags</literal>包含描述执行器对该计划节点操作模式的标志位。
    </para>
<!-- pgdoc-cn_end sig_en=d21c7cbbf539626a6f06136ac8f2b840 -->

<!-- pgdoc-cn_start sig_en=cd1c558261811d44be8405d50d1a8173 sig_cn_org=None source=14.1 
    <para>
     Note that when <literal>(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</literal> is
     true, this function should not perform any externally-visible actions;
     it should only do the minimum required to make the node state valid
     for <function>ExplainForeignScan</function> and <function>EndForeignScan</function>.
    </para>
________________________________________________________-->
    <para>
     注意当<literal>(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</literal>为真时，这个函数不应该执行任何外部可见的动作；它应当只做最少的事情来创建对<function>ExplainForeignScan</function>和<function>EndForeignScan</function>有效的节点状态。
    </para>
<!-- pgdoc-cn_end sig_en=cd1c558261811d44be8405d50d1a8173 -->

<!-- pgdoc-cn_start sig_en=d0f4b6abfe9f8653dc3bdbe5b0a1a5cb sig_cn_org=None source=14.1 
    <para>
<programlisting>
TupleTableSlot *
IterateForeignScan(ForeignScanState *node);
</programlisting>

     Fetch one row from the foreign source, returning it in a tuple table slot
     (the node's <structfield>ScanTupleSlot</structfield> should be used for this
     purpose).  Return NULL if no more rows are available.  The tuple table
     slot infrastructure allows either a physical or virtual tuple to be
     returned; in most cases the latter choice is preferable from a
     performance standpoint.  Note that this is called in a short-lived memory
     context that will be reset between invocations.  Create a memory context
     in <function>BeginForeignScan</function> if you need longer-lived storage, or use
     the <structfield>es_query_cxt</structfield> of the node's <structname>EState</structname>.
    </para>
________________________________________________________-->
    <para>
<programlisting>
TupleTableSlot *
IterateForeignScan(ForeignScanState *node);
</programlisting>

     从外部源获得一行，将它放在一个元组表槽中返回（节点的<structfield>ScanTupleSlot</structfield>应当被用于此目的）。如果没有更多的行可用则返回 NULL。元组表槽设施允许一个物理的或者虚拟的元组被返回；在大部分情况下出于性能的考虑会倾向于选择后者。注意这是在一个短期存在的内存上下文中被调用的，该内存上下文会在调用之间被重置。如果你需要长期存在的存储，请在<function>BeginForeignScan</function>中创建内存上下文，或者使用节点的<structname>EState</structname>中的<structfield>es_query_cxt</structfield>。
    </para>
<!-- pgdoc-cn_end sig_en=d0f4b6abfe9f8653dc3bdbe5b0a1a5cb -->

<!-- pgdoc-cn_start sig_en=80b3108fdbc15445e8246292ee7de57d sig_cn_org=None source=14.1 
    <para>
     The rows returned must match the <structfield>fdw_scan_tlist</structfield> target
     list if one was supplied, otherwise they must match the row type of the
     foreign table being scanned.  If you choose to optimize away fetching
     columns that are not needed, you should insert nulls in those column
     positions, or else generate a <structfield>fdw_scan_tlist</structfield> list with
     those columns omitted.
    </para>
________________________________________________________-->
    <para>
     如果提供了<structfield>fdw_scan_tlist</structfield>目标列表，被返回的行必须匹配它，如果没有提供则它们必须匹配被扫描的外部表的行类型。如果选择优化掉不需要的列，你应该在那些列的位置上插入控制或者生成一个忽略了那些列的<structfield>fdw_scan_tlist</structfield>列表。
    </para>
<!-- pgdoc-cn_end sig_en=80b3108fdbc15445e8246292ee7de57d -->

<!-- pgdoc-cn_start sig_en=2c5abe159524815443f391544e7f600a sig_cn_org=None source=14.1 
    <para>
     Note that <productname>PostgreSQL</productname>'s executor doesn't care
     whether the rows returned violate any constraints that were defined on
     the foreign table &mdash; but the planner does care, and may optimize
     queries incorrectly if there are rows visible in the foreign table that
     do not satisfy a declared constraint.  If a constraint is violated when
     the user has declared that the constraint should hold true, it may be
     appropriate to raise an error (just as you would need to do in the case
     of a data type mismatch).
    </para>
________________________________________________________-->
    <para>
     注意<productname>PostgreSQL</productname>的执行器并不在乎被返回的行是否违背了定义在该外部表上的任何约束 &mdash; 但是规划器会在乎这一点，并且如果在外部表中有可见行不满足一个约束，规划器可能会错误地优化查询。如果当用户已经声明一个约束应该为真时它却被违背，最合适的处理可能是产生一个错误（就像在数据类型失配的情况下所作的那样）。
    </para>
<!-- pgdoc-cn_end sig_en=2c5abe159524815443f391544e7f600a -->

<!-- pgdoc-cn_start sig_en=5fedbd571d5f6e5d75b3760c84ed0b95 sig_cn_org=None source=14.1 
    <para>
<programlisting>
void
ReScanForeignScan(ForeignScanState *node);
</programlisting>

     Restart the scan from the beginning.  Note that any parameters the
     scan depends on may have changed value, so the new scan does not
     necessarily return exactly the same rows.
    </para>
________________________________________________________-->
    <para>
<programlisting>
void
ReScanForeignScan(ForeignScanState *node);
</programlisting>

     从头开始重启一个扫描。注意扫描所依赖的任何参数可能已经改变了值，因此新扫描不一定会返回完全相同的行。
    </para>
<!-- pgdoc-cn_end sig_en=5fedbd571d5f6e5d75b3760c84ed0b95 -->

<!-- pgdoc-cn_start sig_en=3bb275682a4e9c7e9159ad5697bef235 sig_cn_org=None source=14.1 
    <para>
<programlisting>
void
EndForeignScan(ForeignScanState *node);
</programlisting>

     End the scan and release resources.  It is normally not important
     to release palloc'd memory, but for example open files and connections
     to remote servers should be cleaned up.
    </para>
________________________________________________________-->
    <para>
<programlisting>
void
EndForeignScan(ForeignScanState *node);
</programlisting>

     结束扫描并释放资源。通常释放palloc过的内存并不重要，但是打开的文件和到远程服务器的连接等应该被清理。
    </para>
<!-- pgdoc-cn_end sig_en=3bb275682a4e9c7e9159ad5697bef235 -->

   </sect2>

   <sect2 id="fdw-callbacks-join-scan">
<!-- pgdoc-cn_start sig_en=076c2d105c676883c200627dd8b2dba2 sig_cn_org=None source=14.1 
    <title>FDW Routines for Scanning Foreign Joins</title>
________________________________________________________-->
    <title>用于扫描外部连接的 FDW 例程</title>
<!-- pgdoc-cn_end sig_en=076c2d105c676883c200627dd8b2dba2 -->

<!-- pgdoc-cn_start sig_en=16b12706147c12824eb1e0e268f29ddc sig_cn_org=None source=14.1 
    <para>
     If an FDW supports performing foreign joins remotely (rather than
     by fetching both tables' data and doing the join locally), it should
     provide this callback function:
    </para>
________________________________________________________-->
    <para>
     如果一个 FDW 支持远程执行外部连接（而不是先把两个表的数据取到本地然后做本地连接），它应该提供这个回调函数：
    </para>
<!-- pgdoc-cn_end sig_en=16b12706147c12824eb1e0e268f29ddc -->

<!-- pgdoc-cn_start sig_en=6a1d7570299bd2ff68bb4ccffdf91b4c sig_cn_org=None source=14.1 
    <para>
<programlisting>
void
GetForeignJoinPaths(PlannerInfo *root,
                    RelOptInfo *joinrel,
                    RelOptInfo *outerrel,
                    RelOptInfo *innerrel,
                    JoinType jointype,
                    JoinPathExtraData *extra);
</programlisting>
     Create possible access paths for a join of two (or more) foreign tables
     that all belong to the same foreign server.  This optional
     function is called during query planning.  As
     with <function>GetForeignPaths</function>, this function should
     generate <structname>ForeignPath</structname> path(s) for the
     supplied <literal>joinrel</literal>
     (use <function>create_foreign_join_path</function> to build them),
     and call <function>add_path</function> to add these
     paths to the set of paths considered for the join.  But unlike
     <function>GetForeignPaths</function>, it is not necessary that this function
     succeed in creating at least one path, since paths involving local
     joining are always possible.
    </para>
________________________________________________________-->
    <para>
<programlisting>
void
GetForeignJoinPaths(PlannerInfo *root,
                    RelOptInfo *joinrel,
                    RelOptInfo *outerrel,
                    RelOptInfo *innerrel,
                    JoinType jointype,
                    JoinPathExtraData *extra);
</programlisting>
     它为两个（或更多）同属于一台外部服务器的外部表的连接创建可能的访问路径。这个可选的函数会在查询规划过程中被调用。
     和<function>GetForeignPaths</function>一样，这个函数应该为提供的<literal>joinrel</literal>生成<structname>ForeignPath</structname>路径(用 <function>create_foreign_join_path</function> 构建它们)，并且调用<function>add_path</function>把这些路径加入到该连接应该考虑的路径集合中。但是和<function>GetForeignPaths</function>不一样的是，不需要这个函数产生最少一个路径，因为涉及本地连接的路径总是可用的。
    </para>
<!-- pgdoc-cn_end sig_en=6a1d7570299bd2ff68bb4ccffdf91b4c -->

<!-- pgdoc-cn_start sig_en=eae97a07eced5af9c2dad6172ac29181 sig_cn_org=None source=14.1 
    <para>
     Note that this function will be invoked repeatedly for the same join
     relation, with different combinations of inner and outer relations; it is
     the responsibility of the FDW to minimize duplicated work.
    </para>
________________________________________________________-->
    <para>
     注意为相同的连接关系将会重复地调用这个函数用来生成内外关系的不同组合。FDW 需要负责最小化其中重复的工作。
    </para>
<!-- pgdoc-cn_end sig_en=eae97a07eced5af9c2dad6172ac29181 -->

<!-- pgdoc-cn_start sig_en=3bb0ebbd6c6b47f4bbe9a3716ad04914 sig_cn_org=None source=14.1 
    <para>
     If a <structname>ForeignPath</structname> path is chosen for the join, it will
     represent the entire join process; paths generated for the component
     tables and subsidiary joins will not be used.  Subsequent processing of
     the join path proceeds much as it does for a path scanning a single
     foreign table.  One difference is that the <structfield>scanrelid</structfield> of
     the resulting <structname>ForeignScan</structname> plan node should be set to zero,
     since there is no single relation that it represents; instead,
     the <structfield>fs_relids</structfield> field of the <structname>ForeignScan</structname>
     node represents the set of relations that were joined.  (The latter field
     is set up automatically by the core planner code, and need not be filled
     by the FDW.)  Another difference is that, because the column list for a
     remote join cannot be found from the system catalogs, the FDW must
     fill <structfield>fdw_scan_tlist</structfield> with an appropriate list
     of <structfield>TargetEntry</structfield> nodes, representing the set of columns
     it will supply at run time in the tuples it returns.
    </para>
________________________________________________________-->
    <para>
     如果一个<structname>ForeignPath</structname>路径被选中用于该连接，它将在整个连接处理中存在，为其中的成分表和子连接产生的路径将不会被使用。后续对该连接路径的处理大部分和扫描单个外部表的路径一样。一点不同是<structname>ForeignScan</structname>计划节点的<structfield>scanrelid</structfield>应该被设置为零，因为它表示的不是单个关系，而是用<structname>ForeignScan</structname>节点的<structfield>fs_relids</structfield>域来表示被连接的关系集合（后一个域会被核心规划器代码自动设置，不需要由 FDW 填充）。另一点不同是，由于一个远程连接的列列表无法在系统目录中找到，FDW 必须用一个合适的<structfield>TargetEntry</structfield>节点列表来填充<structfield>fdw_scan_tlist</structfield>，表示运行时它返回的元组中提供的列的集合。
    </para>
<!-- pgdoc-cn_end sig_en=3bb0ebbd6c6b47f4bbe9a3716ad04914 -->

<!-- pgdoc-cn_start sig_en=9ebc87c867b5bc8ae8287659c072e25e sig_cn_org=None source=14.1 
    <para>
     See <xref linkend="fdw-planning"/> for additional information.
    </para>
________________________________________________________-->
    <para>
     更多信息请见<xref linkend="fdw-planning"/>。
    </para>
<!-- pgdoc-cn_end sig_en=9ebc87c867b5bc8ae8287659c072e25e -->
   </sect2>

   <sect2 id="fdw-callbacks-upper-planning">
<!-- pgdoc-cn_start sig_en=97db4a6039d3f48b07fc5fa27d5fa46c sig_cn_org=None source=14.1 
    <title>FDW Routines for Planning Post-Scan/Join Processing</title>
________________________________________________________-->
    <title>用于规划扫描/连接后处理的 FDW 例程</title>
<!-- pgdoc-cn_end sig_en=97db4a6039d3f48b07fc5fa27d5fa46c -->

<!-- pgdoc-cn_start sig_en=c45b5c710218dbf5bcfd57c280fa7b68 sig_cn_org=None source=14.1 
    <para>
     If an FDW supports performing remote post-scan/join processing, such as
     remote aggregation, it should provide this callback function:
    </para>
________________________________________________________-->
    <para>
     如果一个 FDW 支持执行远程的扫描/连接后处理，例如远程聚集，那么它应该提供这个回调函数：
    </para>
<!-- pgdoc-cn_end sig_en=c45b5c710218dbf5bcfd57c280fa7b68 -->

<!-- pgdoc-cn_start sig_en=0562f594153df579b5c7be31ad64e184 sig_cn_org=None source=14.1 
    <para>
<programlisting>
void
GetForeignUpperPaths(PlannerInfo *root,
                     UpperRelationKind stage,
                     RelOptInfo *input_rel,
                     RelOptInfo *output_rel,
                     void *extra);
</programlisting>
     Create possible access paths for <firstterm>upper relation</firstterm> processing,
     which is the planner's term for all post-scan/join query processing, such
     as aggregation, window functions, sorting, and table updates.  This
     optional function is called during query planning.  Currently, it is
     called only if all base relation(s) involved in the query belong to the
     same FDW.  This function should generate <structname>ForeignPath</structname>
     path(s) for any post-scan/join processing that the FDW knows how to
     perform remotely
     (use <function>create_foreign_upper_path</function> to build them),
     and call <function>add_path</function> to add these paths to
     the indicated upper relation.  As with <function>GetForeignJoinPaths</function>,
     it is not necessary that this function succeed in creating any paths,
     since paths involving local processing are always possible.
    </para>
________________________________________________________-->
    <para>
<programlisting>
void
GetForeignUpperPaths(PlannerInfo *root,
                     UpperRelationKind stage,
                     RelOptInfo *input_rel,
                     RelOptInfo *output_rel,
                     void *extra);
</programlisting>
     为<firstterm>上层关系</firstterm>处理创建可能的访问路径，这是规划器针对所有扫描/连接后查询处理的术语，例如聚集、窗口函数、排序和表更新。在查询规划期间会调用这个可选的函数。当前，只有当该查询中涉及的所有基本关系都属于同一个 FDW 时才会调用这个函数。
     这个函数应该为 FDW 知道如何远程执行的任何扫描/连接后处理生成<structname>ForeignPath</structname>路径(用 <function>create_foreign_upper_path</function> 构建它们)，并且调用<function>add_path</function>把这些路径加入到上层关系中。就<function>GetForeignJoinPaths</function>来说，并不要求这个函数在创建任何路径时都能成功，因为路径总是有可能涉及到本地处理。
    </para>
<!-- pgdoc-cn_end sig_en=0562f594153df579b5c7be31ad64e184 -->

<!-- pgdoc-cn_start sig_en=a969b4bc006710b786a7bb48853f65b7 sig_cn_org=None source=14.1 
    <para>
     The <literal>stage</literal> parameter identifies which post-scan/join step is
     currently being considered.  <literal>output_rel</literal> is the upper relation
     that should receive paths representing computation of this step,
     and <literal>input_rel</literal> is the relation representing the input to this
     step.  The <literal>extra</literal> parameter provides additional details,
     currently, it is set only for <literal>UPPERREL_PARTIAL_GROUP_AGG</literal>
     or <literal>UPPERREL_GROUP_AGG</literal>, in which case it points to a
     <literal>GroupPathExtraData</literal> structure;
     or for <literal>UPPERREL_FINAL</literal>, in which case it points to a
     <literal>FinalPathExtraData</literal> structure.
     (Note that <structname>ForeignPath</structname> paths added
     to <literal>output_rel</literal> would typically not have any direct dependency
     on paths of the <literal>input_rel</literal>, since their processing is expected
     to be done externally.  However, examining paths previously generated for
     the previous processing step can be useful to avoid redundant planning
     work.)
    </para>
________________________________________________________-->
    <para>
     <literal>stage</literal>参数表示当前正在考虑的是哪一个扫描/连接后处理步骤。<literal>output_rel</literal>是接收表示这一个步骤的路径的上层关系，而<literal>input_rel</literal>是表示这个步骤输入的关系。
     <literal>extra</literal>参数提供额外的细节，当前只会为<literal>UPPERREL_PARTIAL_GROUP_AGG</literal>或者<literal>UPPERREL_GROUP_AGG</literal>设置它，这种情况下它会指向一个<literal>GroupPathExtraData</literal>结构；或者对于 <literal>UPPERREL_FINAL</literal>, 在某种情况下它指向一个<literal>FinalPathExtraData</literal> 结构。（注意被加入到<literal>output_rel</literal>中的<structname>ForeignPath</structname>路径通常对<literal>input_rel</literal>的路径没有直接的依赖，因为它们的处理被认为是在外部处理的。不过，检查为前一个处理步骤生成的路径有助于避免冗余的规划工作）。
    </para>
<!-- pgdoc-cn_end sig_en=a969b4bc006710b786a7bb48853f65b7 -->

<!-- pgdoc-cn_start sig_en=9ebc87c867b5bc8ae8287659c072e25e sig_cn_org=None source=14.1 
    <para>
     See <xref linkend="fdw-planning"/> for additional information.
    </para>
________________________________________________________-->
    <para>
     更多信息请见<xref linkend="fdw-planning"/>。
    </para>
<!-- pgdoc-cn_end sig_en=9ebc87c867b5bc8ae8287659c072e25e -->
   </sect2>

   <sect2 id="fdw-callbacks-update">
<!-- pgdoc-cn_start sig_en=28c51f7ff47cfaf4ba7214f6bdd1ea2e sig_cn_org=None source=14.1 
    <title>FDW Routines for Updating Foreign Tables</title>
________________________________________________________-->
    <title>更新外部表的FDW例程</title>
<!-- pgdoc-cn_end sig_en=28c51f7ff47cfaf4ba7214f6bdd1ea2e -->

<!-- pgdoc-cn_start sig_en=54448dfbff226d23e6b22599c8c1ea2c sig_cn_org=None source=14.1 
    <para>
     If an FDW supports writable foreign tables, it should provide
     some or all of the following callback functions depending on
     the needs and capabilities of the FDW:
    </para>
________________________________________________________-->
    <para>
     如果一个FDW支持可写的外部表，根据FDW的需要和功能它应该提供某些或者全部下列回调函数：
    </para>
<!-- pgdoc-cn_end sig_en=54448dfbff226d23e6b22599c8c1ea2c -->

<!-- pgdoc-cn_start sig_en=a0bae23ee05a05873d0d6813f2b426d2 sig_cn_org=None source=14.1 
    <para>
<programlisting>
void
AddForeignUpdateTargets(PlannerInfo *root,
                        Index rtindex,
                        RangeTblEntry *target_rte,
                        Relation target_relation);
</programlisting>

     <command>UPDATE</command> and <command>DELETE</command> operations are performed
     against rows previously fetched by the table-scanning functions.  The
     FDW may need extra information, such as a row ID or the values of
     primary-key columns, to ensure that it can identify the exact row to
     update or delete.  To support that, this function can add extra hidden,
     or <quote>junk</quote>, target columns to the list of columns that are to be
     retrieved from the foreign table during an <command>UPDATE</command> or
     <command>DELETE</command>.
    </para>
________________________________________________________-->
    <para>
<programlisting>
void
AddForeignUpdateTargets(PlannerInfo *root,
                        Index rtindex,
                        RangeTblEntry *target_rte,
                        Relation target_relation);
</programlisting>

     <command>UPDATE</command>和<command>DELETE</command>操作是在之前由表扫描函数取出的行上被执行的。FDW可能需要额外的信息（例如一个行ID或主键列的值）来保证它能够找到要更新或删除的准确行。要支持这些要求，这个函数可以项列列表中增加额外的隐藏或<quote>junk</quote>的目标列，它们在一个<command>UPDATE</command>或<command>DELETE</command>期间会被从外部表中获取。
    </para>
<!-- pgdoc-cn_end sig_en=a0bae23ee05a05873d0d6813f2b426d2 -->

<!-- pgdoc-cn_start sig_en=c877487c435291625df6fc1071413cf4 sig_cn_org=None source=14.1 
    <para>
     To do that, construct a <structname>Var</structname> representing
     an extra value you need, and pass it
     to <function>add_row_identity_var</function>, along with a name for
     the junk column.  (You can do this more than once if several columns
     are needed.)  You must choose a distinct junk column name for each
     different <structname>Var</structname> you need, except
     that <structname>Var</structname>s that are identical except for
     the <structfield>varno</structfield> field can and should share a
     column name.
     The core system uses the junk column names
     <literal>tableoid</literal> for a
     table's <structfield>tableoid</structfield> column,
     <literal>ctid</literal>
     or <literal>ctid<replaceable>N</replaceable></literal>
     for <structfield>ctid</structfield>,
     <literal>wholerow</literal>
     for a whole-row <structname>Var</structname> marked with
     <structfield>vartype</structfield> = <type>RECORD</type>,
     and <literal>wholerow<replaceable>N</replaceable></literal>
     for a whole-row <structname>Var</structname> with
     <structfield>vartype</structfield> equal to the table's declared row type.
     Re-use these names when you can (the planner will combine duplicate
     requests for identical junk columns).  If you need another kind of
     junk column besides these, it might be wise to choose a name prefixed
     with your extension name, to avoid conflicts against other FDWs.
    </para>
________________________________________________________-->
    <para>
     要做到这一点，构造一个<structname>Var</structname>以表示你需要的额外值，并将其传递给<function>add_row_identity_var</function>，与junk列的名称一起。
     (如果需要多个列，你可以多次执行此操作。)
     你必须为你需要的每个不同的<structname>Var</structname>选择一个不同的junk列名，除了<structname>Var</structname>s是相同的，以及除了<structfield>varno</structfield>字段能够并且应该共享一个列名。
     核心系统使用junk列名<literal>tableoid</literal>来表示表的<structfield>tableoid</structfield>列，
     <literal>ctid</literal> 或 <literal>ctid<replaceable>N</replaceable></literal> 表示 <structfield>ctid</structfield>，
     <literal>wholerow</literal> 表示以 <structfield>vartype</structfield> = <type>RECORD</type>标记的整个行 <structname>Var</structname> ，
     以及<literal>wholerow<replaceable>N</replaceable></literal>表示 整个行 <structname>Var</structname> ，其<structfield>vartype</structfield>等于表的声明行类型。
     在你可以的情况下重新用这些名称(计划器将合并完全相同的junk列的重复请求)。
     如果你还需要除此之外的其他类型的junk列，也许明智的方法是选择以扩展名为前缀的名称，以避免与其他FDWs发生冲突。
    </para>
<!-- pgdoc-cn_end sig_en=c877487c435291625df6fc1071413cf4 -->

<!-- pgdoc-cn_start sig_en=045f9a7fa304ed9488d009240b53b335 sig_cn_org=None source=14.1 
    <para>
     If the <function>AddForeignUpdateTargets</function> pointer is set to
     <literal>NULL</literal>, no extra target expressions are added.
     (This will make it impossible to implement <command>DELETE</command>
     operations, though <command>UPDATE</command> may still be feasible if the FDW
     relies on an unchanging primary key to identify rows.)
    </para>
________________________________________________________-->
    <para>
     如果<function>AddForeignUpdateTargets</function>指针被设置为<literal>NULL</literal>，则不会有额外的目标表达式被加入（这将使得我们不可能实现<command>DELETE</command>操作，而<command>UPDATE</command>则还有可能是可行的，前提是FDW依赖一个未改变的主键来标识行）。
    </para>
<!-- pgdoc-cn_end sig_en=045f9a7fa304ed9488d009240b53b335 -->

<!-- pgdoc-cn_start sig_en=5dfaaa2c1725020e7d4dd657fd417399 sig_cn_org=None source=14.1 
    <para>
<programlisting>
List *
PlanForeignModify(PlannerInfo *root,
                  ModifyTable *plan,
                  Index resultRelation,
                  int subplan_index);
</programlisting>

     Perform any additional planning actions needed for an insert, update, or
     delete on a foreign table.  This function generates the FDW-private
     information that will be attached to the <structname>ModifyTable</structname> plan
     node that performs the update action.  This private information must
     have the form of a <literal>List</literal>, and will be delivered to
     <function>BeginForeignModify</function> during the execution stage.
    </para>
________________________________________________________-->
    <para>
<programlisting>
List *
PlanForeignModify(PlannerInfo *root,
                  ModifyTable *plan,
                  Index resultRelation,
                  int subplan_index);
</programlisting>

     执行外部表上插入、更新或删除所需的任何附加规划动作。这个函数生成FDW私有信息，该信息将被附加到执行该更新动作的<structname>ModifyTable</structname>计划节点。这个私有信息的形式必须是一个<literal>List</literal>，并将会在执行阶段被传递给<function>BeginForeignModify</function>。
    </para>
<!-- pgdoc-cn_end sig_en=5dfaaa2c1725020e7d4dd657fd417399 -->

<!-- pgdoc-cn_start sig_en=0c78f7392df709ba5a9cfd19dfe8ed9d sig_cn_org=None source=14.1 
    <para>
     <literal>root</literal> is the planner's global information about the query.
     <literal>plan</literal> is the <structname>ModifyTable</structname> plan node, which is
     complete except for the <structfield>fdwPrivLists</structfield> field.
     <literal>resultRelation</literal> identifies the target foreign table by its
     range table index.  <literal>subplan_index</literal> identifies which target of
     the <structname>ModifyTable</structname> plan node this is, counting from zero;
     use this if you want to index into per-target-relation substructures of the
     <literal>plan</literal> node.
    </para>
________________________________________________________-->
    <para>
     <literal>root</literal>是规划器关于该查询的全局信息。
     <literal>plan</literal>是<structname>ModifyTable</structname>计划节点，它除了<structfield>fdwPrivLists</structfield>域之外是完整的。
     <literal>resultRelation</literal>通过目标外部表的范围表索引来标识它。
     <literal>subplan_index</literal>标识这是<structname>ModifyTable</structname>计划节点的哪个目标，从零开始计数；
     如果你希望索引到<literal>plan</literal>节点的每-目标-关系子结构中，请使用它。
    </para>
<!-- pgdoc-cn_end sig_en=0c78f7392df709ba5a9cfd19dfe8ed9d -->

<!-- pgdoc-cn_start sig_en=9ebc87c867b5bc8ae8287659c072e25e sig_cn_org=None source=14.1 
    <para>
     See <xref linkend="fdw-planning"/> for additional information.
    </para>
________________________________________________________-->
    <para>
     更多信息请见<xref linkend="fdw-planning"/>。
    </para>
<!-- pgdoc-cn_end sig_en=9ebc87c867b5bc8ae8287659c072e25e -->

<!-- pgdoc-cn_start sig_en=cee2fd3ee59cc3daacc44fb57325bb72 sig_cn_org=None source=14.1 
    <para>
     If the <function>PlanForeignModify</function> pointer is set to
     <literal>NULL</literal>, no additional plan-time actions are taken, and the
     <literal>fdw_private</literal> list delivered to
     <function>BeginForeignModify</function> will be NIL.
    </para>
________________________________________________________-->
    <para>
     如果<function>PlanForeignModify</function>指针被设置为<literal>NULL</literal>，则不会有额外的计划时动作被执行，并且传递给<function>BeginForeignModify</function>的<literal>fdw_private</literal>列表也将为 NIL。
    </para>
<!-- pgdoc-cn_end sig_en=cee2fd3ee59cc3daacc44fb57325bb72 -->

<!-- pgdoc-cn_start sig_en=b19ba33c547c06402d43736386c461be sig_cn_org=None source=14.1 
    <para>
<programlisting>
void
BeginForeignModify(ModifyTableState *mtstate,
                   ResultRelInfo *rinfo,
                   List *fdw_private,
                   int subplan_index,
                   int eflags);
</programlisting>

     Begin executing a foreign table modification operation.  This routine is
     called during executor startup.  It should perform any initialization
     needed prior to the actual table modifications.  Subsequently,
     <function>ExecForeignInsert/ExecForeignBatchInsert</function>,
     <function>ExecForeignUpdate</function> or
     <function>ExecForeignDelete</function> will be called for tuple(s) to be
     inserted, updated, or deleted.
    </para>
________________________________________________________-->
    <para>
<programlisting>
void
BeginForeignModify(ModifyTableState *mtstate,
                   ResultRelInfo *rinfo,
                   List *fdw_private,
                   int subplan_index,
                   int eflags);
</programlisting>

     开始执行一个外部表修改操作。
     这个例程在执行器启动期间被调用。
     它应该执行任何先于实际表修改的初始化工作。
     随后，<function>ExecForeignInsert/ExecForeignBatchInsert</function>、<function>ExecForeignUpdate</function>或<function>ExecForeignDelete</function>将被为被插入、更新或删除的元组调用。
    </para>
<!-- pgdoc-cn_end sig_en=b19ba33c547c06402d43736386c461be -->

<!-- pgdoc-cn_start sig_en=77c8c4b621d63f23c81e137bacff43d8 sig_cn_org=None source=14.1 
    <para>
     <literal>mtstate</literal> is the overall state of the
     <structname>ModifyTable</structname> plan node being executed; global data about
     the plan and execution state is available via this structure.
     <literal>rinfo</literal> is the <structname>ResultRelInfo</structname> struct describing
     the target foreign table.  (The <structfield>ri_FdwState</structfield> field of
     <structname>ResultRelInfo</structname> is available for the FDW to store any
     private state it needs for this operation.)
     <literal>fdw_private</literal> contains the private data generated by
     <function>PlanForeignModify</function>, if any.
     <literal>subplan_index</literal> identifies which target of
     the <structname>ModifyTable</structname> plan node this is.
     <literal>eflags</literal> contains flag bits describing the executor's
     operating mode for this plan node.
    </para>
________________________________________________________-->
    <para>
     <literal>mtstate</literal>是要被执行的<structname>ModifyTable</structname>计划节点的状态信息；通过这个结构可以得到关于规划和执行阶段的全局数据。<literal>rinfo</literal>是描述目标外部表的<structname>ResultRelInfo</structname>结构（<structname>ResultRelInfo</structname>的<structfield>ri_FdwState</structfield>域用于FDW来存储它在此操作中需要的任何私有状态）。<literal>fdw_private</literal>包含<function>PlanForeignModify</function>生成的私有数据。<literal>subplan_index</literal>标识这是<structname>ModifyTable</structname>计划节点的哪个目标。<literal>eflags</literal>包含描述执行器对该计划节点操作模式的标志位。
    </para>
<!-- pgdoc-cn_end sig_en=77c8c4b621d63f23c81e137bacff43d8 -->

<!-- pgdoc-cn_start sig_en=c0c28b8ed4a4a2b60eeb63b35fc45e4f sig_cn_org=None source=14.1 
    <para>
     Note that when <literal>(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</literal> is
     true, this function should not perform any externally-visible actions;
     it should only do the minimum required to make the node state valid
     for <function>ExplainForeignModify</function> and <function>EndForeignModify</function>.
    </para>
________________________________________________________-->
    <para>
     注意当<literal>(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</literal>为真，这个函数不应执行任何外部可见的动作；它只应该做最少的工作来创建<function>ExplainForeignModify</function>和<function>EndForeignModify</function>可用的节点状态。
    </para>
<!-- pgdoc-cn_end sig_en=c0c28b8ed4a4a2b60eeb63b35fc45e4f -->

<!-- pgdoc-cn_start sig_en=1bfba42b582a2072996012dbb11dd32f sig_cn_org=None source=14.1 
    <para>
     If the <function>BeginForeignModify</function> pointer is set to
     <literal>NULL</literal>, no action is taken during executor startup.
    </para>
________________________________________________________-->
    <para>
     如果<function>BeginForeignModify</function>指针被设置为<literal>NULL</literal>，在执行器启动期间将不会采取任何动作。
    </para>
<!-- pgdoc-cn_end sig_en=1bfba42b582a2072996012dbb11dd32f -->

<!-- pgdoc-cn_start sig_en=04a0dac66afad9bd09c6f75deab869b7 sig_cn_org=None source=14.1 
    <para>
<programlisting>
TupleTableSlot *
ExecForeignInsert(EState *estate,
                  ResultRelInfo *rinfo,
                  TupleTableSlot *slot,
                  TupleTableSlot *planSlot);
</programlisting>

     Insert one tuple into the foreign table.
     <literal>estate</literal> is global execution state for the query.
     <literal>rinfo</literal> is the <structname>ResultRelInfo</structname> struct describing
     the target foreign table.
     <literal>slot</literal> contains the tuple to be inserted; it will match the
     row-type definition of the foreign table.
     <literal>planSlot</literal> contains the tuple that was generated by the
     <structname>ModifyTable</structname> plan node's subplan; it differs from
     <literal>slot</literal> in possibly containing additional <quote>junk</quote>
     columns.  (The <literal>planSlot</literal> is typically of little interest
     for <command>INSERT</command> cases, but is provided for completeness.)
    </para>
________________________________________________________-->
    <para>
<programlisting>
TupleTableSlot *
ExecForeignInsert(EState *estate,
                  ResultRelInfo *rinfo,
                  TupleTableSlot *slot,
                  TupleTableSlot *planSlot);
</programlisting>

     插入一个元组到外部表。<literal>estate</literal>是查询的全局执行状态。<literal>rinfo</literal>是描述目标外部表的<structname>ResultRelInfo</structname>结构。<literal>slot</literal>包含要被插入的元组；它将匹配外部表的行类型定义。<literal>planSlot</literal>包含由<structname>ModifyTable</structname>计划节点的子计划生成的元组；它与<literal>slot</literal>不同，它可能包含额外的<quote>junk</quote>列（<command>INSERT</command>情况通常不关心<literal>planSlot</literal>，但是为了完整性还是在这里提供它）。
    </para>
<!-- pgdoc-cn_end sig_en=04a0dac66afad9bd09c6f75deab869b7 -->

<!-- pgdoc-cn_start sig_en=3c4af936377ac120045dfee90f054bb6 sig_cn_org=None source=14.1 
    <para>
     The return value is either a slot containing the data that was actually
     inserted (this might differ from the data supplied, for example as a
     result of trigger actions), or NULL if no row was actually inserted
     (again, typically as a result of triggers).  The passed-in
     <literal>slot</literal> can be re-used for this purpose.
    </para>
________________________________________________________-->
    <para>
     返回值可以是一个包含实际被插入的数据的槽（这可能会和所提供的数据不同，例如一个触发器动作的结果），或者为 NULL 表示实际没有插入行（还是触发器的结果）。被传入的<literal>slot</literal>可以被重用于这个目的。
    </para>
<!-- pgdoc-cn_end sig_en=3c4af936377ac120045dfee90f054bb6 -->

<!-- pgdoc-cn_start sig_en=e12e47aba19cfd93ecc44e1d4fd93bc3 sig_cn_org=None source=14.1 
    <para>
     The data in the returned slot is used only if the <command>INSERT</command>
     statement has a <literal>RETURNING</literal> clause or involves a view
     <literal>WITH CHECK OPTION</literal>; or if the foreign table has
     an <literal>AFTER ROW</literal> trigger.  Triggers require all columns,
     but the FDW could choose to optimize away returning some or all columns
     depending on the contents of the <literal>RETURNING</literal> clause or
     <literal>WITH CHECK OPTION</literal> constraints.  Regardless, some slot
     must be returned to indicate success, or the query's reported row count
     will be wrong.
    </para>
________________________________________________________-->
    <para>
     在返回槽中的数据只有在<command>INSERT</command>语句具有一个<literal>RETURNING</literal>子句或包括一个视图<literal>WITH CHECK OPTION</literal>; 或者如果外部表具有一个<literal>AFTER ROW</literal>触发器时才被使用。
     触发器要求所有的列，但是 FDW 应该选择优化成根据<literal>RETURNING</literal>子句的内容或<literal>WITH CHECK OPTION</literal>约束返回某些或全部列。
     不管怎样，某些槽必须被返回来指示成功，或者查询报告的行计数将会是错误的。
    </para>
<!-- pgdoc-cn_end sig_en=e12e47aba19cfd93ecc44e1d4fd93bc3 -->

<!-- pgdoc-cn_start sig_en=ea683b7ba84fcd2ed5594a42e7d2ce9f sig_cn_org=None source=14.1 
    <para>
     If the <function>ExecForeignInsert</function> pointer is set to
     <literal>NULL</literal>, attempts to insert into the foreign table will fail
     with an error message.
    </para>
________________________________________________________-->
    <para>
     如果<function>ExecForeignInsert</function>指针被设置为<literal>NULL</literal>，尝试向外部表插入将会失败并报告一个错误消息。
    </para>
<!-- pgdoc-cn_end sig_en=ea683b7ba84fcd2ed5594a42e7d2ce9f -->

<!-- pgdoc-cn_start sig_en=0158102b4aad652381c8d0b0161605da sig_cn_org=None source=14.1 
    <para>
     Note that this function is also called when inserting routed tuples into
     a foreign-table partition or executing <command>COPY FROM</command> on
     a foreign table, in which case it is called in a different way than it
     is in the <command>INSERT</command> case.  See the callback functions
     described below that allow the FDW to support that.
    </para>
________________________________________________________-->
    <para>
     请注意，在外表上将路由元组插入外表分区或执行 <command>COPY FROM</command> 时也会调用此函数，在这种情况下，它的调用方式与<command>INSERT</command> 中的情况有所不同。
     请参阅下面所述的允许 FDW 支持的回调函数。
    </para>
<!-- pgdoc-cn_end sig_en=0158102b4aad652381c8d0b0161605da -->

<!-- pgdoc-cn_start sig_en=309729439e6883496677a2620b3e5542 sig_cn_org=None source=14.1 
    <para>
<programlisting>
TupleTableSlot **
ExecForeignBatchInsert(EState *estate,
                       ResultRelInfo *rinfo,
                       TupleTableSlot **slots,
                       TupleTableSlot **planSlots,
                       int *numSlots);
</programlisting>

     Insert multiple tuples in bulk into the foreign table.
     The parameters are the same for <function>ExecForeignInsert</function>
     except <literal>slots</literal> and <literal>planSlots</literal> contain
     multiple tuples and <literal>*numSlots</literal> specifies the number of
     tuples in those arrays.
    </para>
________________________________________________________-->
    <para>
<programlisting>
TupleTableSlot **
ExecForeignBatchInsert(EState *estate,
                       ResultRelInfo *rinfo,
                       TupleTableSlot **slots,
                       TupleTableSlot **planSlots,
                       int *numSlots);
</programlisting>

     将多个元组成批地插入外表。
     参数与<function>ExecForeignInsert</function>相同，除了<literal>slots</literal> 和 <literal>planSlots</literal>包含多个元组，并且<literal>*numSlots</literal>指定这些数组中的元组的数量。
    </para>
<!-- pgdoc-cn_end sig_en=309729439e6883496677a2620b3e5542 -->

<!-- pgdoc-cn_start sig_en=786ae650308ac67570ff0bca7f156fb7 sig_cn_org=None source=14.1 
    <para>
     The return value is an array of slots containing the data that was
     actually inserted (this might differ from the data supplied, for
     example as a result of trigger actions.)
     The passed-in <literal>slots</literal> can be re-used for this purpose.
     The number of successfully inserted tuples is returned in
     <literal>*numSlots</literal>.
    </para>
________________________________________________________-->
    <para>
     返回值是一个槽的数组，包含实际插入的数据(这可能与提供的数据不同，例如作为触发器活动的结果)。
     传入的<literal>slots</literal>可以重复用于此目的。
     成功插入元组的数量以<literal>*numSlots</literal>返回。
    </para>
<!-- pgdoc-cn_end sig_en=786ae650308ac67570ff0bca7f156fb7 -->

<!-- pgdoc-cn_start sig_en=5e78af70100399c55392091fed412231 sig_cn_org=None source=14.1 
    <para>
     The data in the returned slot is used only if the <command>INSERT</command>
     statement involves a view
     <literal>WITH CHECK OPTION</literal>; or if the foreign table has
     an <literal>AFTER ROW</literal> trigger.  Triggers require all columns,
     but the FDW could choose to optimize away returning some or all columns
     depending on the contents of the
     <literal>WITH CHECK OPTION</literal> constraints.
    </para>
________________________________________________________-->
    <para>
     只有当<command>INSERT</command> 语句涉及到<literal>WITH CHECK OPTION</literal>视图时，返回槽中的数据才会被使用;或者如果外表有一个<literal>AFTER ROW</literal>触发器时。
     触发器需要所有列，但是FDW可以根据<literal>WITH CHECK OPTION</literal>约束的内容选择优化返回部分或全部列。
    </para>
<!-- pgdoc-cn_end sig_en=5e78af70100399c55392091fed412231 -->

<!-- pgdoc-cn_start sig_en=baf8f8eaecbf32aa4bde4d7be6c5cbbd sig_cn_org=None source=14.1 
    <para>
     If the <function>ExecForeignBatchInsert</function> or
     <function>GetForeignModifyBatchSize</function> pointer is set to
     <literal>NULL</literal>, attempts to insert into the foreign table will
     use <function>ExecForeignInsert</function>.
     This function is not used if the <command>INSERT</command> has the
     <literal>RETURNING</literal> clause.
    </para>
________________________________________________________-->
    <para>
     如果<function>ExecForeignBatchInsert</function> 或 <function>GetForeignModifyBatchSize</function>指针被设置为<literal>NULL</literal>，尝试插入外表将使用<function>ExecForeignInsert</function>。
     如果<command>INSERT</command>有<literal>RETURNING</literal>子句，这个函数不被使用。
    </para>
<!-- pgdoc-cn_end sig_en=baf8f8eaecbf32aa4bde4d7be6c5cbbd -->

<!-- pgdoc-cn_start sig_en=89e13659e74453921e82412ff572e1d5 sig_cn_org=None source=14.1 
    <para>
     Note that this function is also called when inserting routed tuples into
     a foreign-table partition.  See the callback functions
     described below that allow the FDW to support that.
    </para>
________________________________________________________-->
    <para>
     注意这个函数也会被调用，当把路由元组插入外表分区时。
     请参阅下面允许FDW支持该功能的回调函数的描述。
    </para>
<!-- pgdoc-cn_end sig_en=89e13659e74453921e82412ff572e1d5 -->

<!-- pgdoc-cn_start sig_en=4d86e83a7b1f3a3800ac343cc425a175 sig_cn_org=None source=14.1 
    <para>
<programlisting>
int
GetForeignModifyBatchSize(ResultRelInfo *rinfo);
</programlisting>

     Report the maximum number of tuples that a single
     <function>ExecForeignBatchInsert</function> call can handle for
     the specified foreign table.  The executor passes at most
     the given number of tuples to <function>ExecForeignBatchInsert</function>.
     <literal>rinfo</literal> is the <structname>ResultRelInfo</structname> struct describing
     the target foreign table.
     The FDW is expected to provide a foreign server and/or foreign
     table option for the user to set this value, or some hard-coded value.
    </para>
________________________________________________________-->
    <para>
<programlisting>
int
GetForeignModifyBatchSize(ResultRelInfo *rinfo);
</programlisting>

     报告单个<function>ExecForeignBatchInsert</function>调用可以为指定外表处理的元组的最大数量。
     执行器传递最多给定数量的元组到<function>ExecForeignBatchInsert</function>。
     <literal>rinfo</literal>是描述目标外表的<structname>ResultRelInfo</structname>结构体。
     FDW应该为用户提供一个外部服务器和/或外部表选项来设置这个值，或者一些硬-编码的值。
    </para>
<!-- pgdoc-cn_end sig_en=4d86e83a7b1f3a3800ac343cc425a175 -->

<!-- pgdoc-cn_start sig_en=ff546ce2586e118833e9cfabbc7b2b89 sig_cn_org=None source=14.1 
    <para>
     If the <function>ExecForeignBatchInsert</function> or
     <function>GetForeignModifyBatchSize</function> pointer is set to
     <literal>NULL</literal>, attempts to insert into the foreign table will
     use <function>ExecForeignInsert</function>.
    </para>
________________________________________________________-->
    <para>
     如果<function>ExecForeignBatchInsert</function> 或 <function>GetForeignModifyBatchSize</function> 指针被设置为<literal>NULL</literal>，尝试插入到外表将使用<function>ExecForeignInsert</function>。
    </para>
<!-- pgdoc-cn_end sig_en=ff546ce2586e118833e9cfabbc7b2b89 -->

<!-- pgdoc-cn_start sig_en=b64b9a33869ae2890b8d8abffd5e9e48 sig_cn_org=None source=14.1 
    <para>
<programlisting>
TupleTableSlot *
ExecForeignUpdate(EState *estate,
                  ResultRelInfo *rinfo,
                  TupleTableSlot *slot,
                  TupleTableSlot *planSlot);
</programlisting>

     Update one tuple in the foreign table.
     <literal>estate</literal> is global execution state for the query.
     <literal>rinfo</literal> is the <structname>ResultRelInfo</structname> struct describing
     the target foreign table.
     <literal>slot</literal> contains the new data for the tuple; it will match the
     row-type definition of the foreign table.
     <literal>planSlot</literal> contains the tuple that was generated by the
     <structname>ModifyTable</structname> plan node's subplan.  Unlike
     <literal>slot</literal>, this tuple contains only the new values for
     columns changed by the query, so do not rely on attribute numbers of the
     foreign table to index into <literal>planSlot</literal>.
     Also, <literal>planSlot</literal> typically contains
     additional <quote>junk</quote> columns.  In particular, any junk columns
     that were requested by <function>AddForeignUpdateTargets</function> will
     be available from this slot.
    </para>
________________________________________________________-->
    <para>
<programlisting>
TupleTableSlot *
ExecForeignUpdate(EState *estate,
                  ResultRelInfo *rinfo,
                  TupleTableSlot *slot,
                  TupleTableSlot *planSlot);
</programlisting>

     更新外部表中的一个元组。
     <literal>estate</literal>是查询的全局执行状态。
     <literal>rinfo</literal>是描述目标外部表的<structname>ResultRelInfo</structname>结构。
     <literal>slot</literal>包含元组的新数据；它将匹配外部表的行类型定义。
     <literal>planSlot</literal>包含由<structname>ModifyTable</structname>计划节点的子计划生成的元组。
     不像<literal>slot</literal>，此元组仅包含查询所更改的列的新值，因此不依赖外表的属性号来索引<literal>planSlot</literal>。
     此外，<literal>planSlot</literal>通常包含额外的<quote>junk</quote>列。
     特殊地，任何<function>AddForeignUpdateTargets</function>所要求的junk列在这个槽中都是有效的。
    </para>
<!-- pgdoc-cn_end sig_en=b64b9a33869ae2890b8d8abffd5e9e48 -->

<!-- pgdoc-cn_start sig_en=04862c97879a63e28d08a992b0936be9 sig_cn_org=None source=14.1 
    <para>
     The return value is either a slot containing the row as it was actually
     updated (this might differ from the data supplied, for example as a
     result of trigger actions), or NULL if no row was actually updated
     (again, typically as a result of triggers).  The passed-in
     <literal>slot</literal> can be re-used for this purpose.
    </para>
________________________________________________________-->
    <para>
     返回值可以是一个包含实际被更新的数据的槽（这可能会和所提供的数据不同，例如一个触发器动作的结果），或者为 NULL 表示实际没有更新行（还是触发器的结果）。被传入的<literal>slot</literal>可以被重用于这个目的。
    </para>
<!-- pgdoc-cn_end sig_en=04862c97879a63e28d08a992b0936be9 -->

<!-- pgdoc-cn_start sig_en=6cde327280026c1be4d2989758b60f17 sig_cn_org=None source=14.1 
    <para>
     The data in the returned slot is used only if the <command>UPDATE</command>
     statement has a <literal>RETURNING</literal> clause or involves a view
     <literal>WITH CHECK OPTION</literal>; or if the foreign table has
     an <literal>AFTER ROW</literal> trigger.  Triggers require all columns,
     but the FDW could choose to optimize away returning some or all columns
     depending on the contents of the <literal>RETURNING</literal> clause or
     <literal>WITH CHECK OPTION</literal> constraints.  Regardless, some slot
     must be returned to indicate success, or the query's reported row count
     will be wrong.
    </para>
________________________________________________________-->
    <para>
     在返回槽中的数据只有在<command>UPDATE</command>语句具有一个<literal>RETURNING</literal>子句或者包括一个视图<literal>WITH CHECK OPTION</literal>；或者如果外部表具有一个<literal>AFTER ROW</literal>触发器时才被使用。
     触发器要求所有的列，但是 FDW 应该选择优化成根据<literal>RETURNING</literal>子句的内容或<literal>WITH CHECK OPTION</literal> 约束返回某些或全部列。
     不管怎样，某些槽必须被返回来指示成功，或者查询报告的行计数将会是错误的。
    </para>
<!-- pgdoc-cn_end sig_en=6cde327280026c1be4d2989758b60f17 -->

<!-- pgdoc-cn_start sig_en=8d1ca62fb8838ce0ae01bf884a01629f sig_cn_org=None source=14.1 
    <para>
     If the <function>ExecForeignUpdate</function> pointer is set to
     <literal>NULL</literal>, attempts to update the foreign table will fail
     with an error message.
    </para>
________________________________________________________-->
    <para>
     如果<function>ExecForeignUpdate</function>指针被设置为<literal>NULL</literal>，尝试更新外部表将会失败并报告一个错误消息。
    </para>
<!-- pgdoc-cn_end sig_en=8d1ca62fb8838ce0ae01bf884a01629f -->

<!-- pgdoc-cn_start sig_en=712ae7f9dcab28cb16662a7a9c5028ce sig_cn_org=None source=14.1 
    <para>
<programlisting>
TupleTableSlot *
ExecForeignDelete(EState *estate,
                  ResultRelInfo *rinfo,
                  TupleTableSlot *slot,
                  TupleTableSlot *planSlot);
</programlisting>

     Delete one tuple from the foreign table.
     <literal>estate</literal> is global execution state for the query.
     <literal>rinfo</literal> is the <structname>ResultRelInfo</structname> struct describing
     the target foreign table.
     <literal>slot</literal> contains nothing useful upon call, but can be used to
     hold the returned tuple.
     <literal>planSlot</literal> contains the tuple that was generated by the
     <structname>ModifyTable</structname> plan node's subplan; in particular, it will
     carry any junk columns that were requested by
     <function>AddForeignUpdateTargets</function>.  The junk column(s) must be used
     to identify the tuple to be deleted.
    </para>
________________________________________________________-->
    <para>
<programlisting>
TupleTableSlot *
ExecForeignDelete(EState *estate,
                  ResultRelInfo *rinfo,
                  TupleTableSlot *slot,
                  TupleTableSlot *planSlot);
</programlisting>

     从外部表删除一个元组。<literal>estate</literal>是查询的全局执行状态。<literal>rinfo</literal>是描述目标外部表的<structname>ResultRelInfo</structname>结构。<literal>slot</literal>在调用时不包含任何有用的东西，但是可以被用于保持被返回的元组。<literal>planSlot</literal>包含由<structname>ModifyTable</structname>计划节点的子计划生成的元组；特殊地，它将携带<function>AddForeignUpdateTargets</function>所要求的任意垃圾列。垃圾列被用来标识要被删除的元组。
    </para>
<!-- pgdoc-cn_end sig_en=712ae7f9dcab28cb16662a7a9c5028ce -->

<!-- pgdoc-cn_start sig_en=f209623e716b4240d741ca9132c7e391 sig_cn_org=None source=14.1 
    <para>
     The return value is either a slot containing the row that was deleted,
     or NULL if no row was deleted (typically as a result of triggers).  The
     passed-in <literal>slot</literal> can be used to hold the tuple to be returned.
    </para>
________________________________________________________-->
    <para>
     返回值可以是一个包含实际被删除的数据的槽（这可能会和所提供的数据不同，例如一个触发器动作的结果），或者为 NULL 表示实际没有删除行（还是触发器的结果）。被传入的<literal>slot</literal>可以被重用于这个目的。
    </para>
<!-- pgdoc-cn_end sig_en=f209623e716b4240d741ca9132c7e391 -->

<!-- pgdoc-cn_start sig_en=656d4f089a6eda59b26fda0251abf31f sig_cn_org=None source=14.1 
    <para>
     The data in the returned slot is used only if the <command>DELETE</command>
     query has a <literal>RETURNING</literal> clause or the foreign table has
     an <literal>AFTER ROW</literal> trigger.  Triggers require all columns, but the
     FDW could choose to optimize away returning some or all columns depending
     on the contents of the <literal>RETURNING</literal> clause.  Regardless, some
     slot must be returned to indicate success, or the query's reported row
     count will be wrong.
    </para>
________________________________________________________-->
    <para>
     在返回槽中的数据只有在<command>DELETE</command>查询具有一个<literal>RETURNING</literal>子句或者外部表具有一个<literal>AFTER ROW</literal>触发器时才被使用。
     触发器要求所有的列，但是 FDW 应该选择优化成根据<literal>RETURNING</literal>子句的内容返回某些或全部列。
     不管怎样，某些槽必须被返回来指示成功，或者查询报告的行计数将会是错误的。
    </para>
<!-- pgdoc-cn_end sig_en=656d4f089a6eda59b26fda0251abf31f -->

<!-- pgdoc-cn_start sig_en=880732002dc677a97cfd9a62115ee22a sig_cn_org=None source=14.1 
    <para>
     If the <function>ExecForeignDelete</function> pointer is set to
     <literal>NULL</literal>, attempts to delete from the foreign table will fail
     with an error message.
    </para>
________________________________________________________-->
    <para>
     如果<function>ExecForeignDelete</function>指针被设置为<literal>NULL</literal>，尝试从外部表中删除将会失败并报告一个错误消息。
    </para>
<!-- pgdoc-cn_end sig_en=880732002dc677a97cfd9a62115ee22a -->

<!-- pgdoc-cn_start sig_en=e4e010394dfb4edeafa4ed64d2315b62 sig_cn_org=None source=14.1 
    <para>
<programlisting>
void
EndForeignModify(EState *estate,
                 ResultRelInfo *rinfo);
</programlisting>

     End the table update and release resources.  It is normally not important
     to release palloc'd memory, but for example open files and connections
     to remote servers should be cleaned up.
    </para>
________________________________________________________-->
    <para>
<programlisting>
void
EndForeignModify(EState *estate,
                 ResultRelInfo *rinfo);
</programlisting>

     结束表更新并释放资源。通常释放palloc的内存并不重要，但是打开的文件和到远程服务器的连接等应当被清除。
    </para>
<!-- pgdoc-cn_end sig_en=e4e010394dfb4edeafa4ed64d2315b62 -->

<!-- pgdoc-cn_start sig_en=51c58dd9a2483e19e40da3fccc74845e sig_cn_org=None source=14.1 
    <para>
     If the <function>EndForeignModify</function> pointer is set to
     <literal>NULL</literal>, no action is taken during executor shutdown.
    </para>
________________________________________________________-->
    <para>
     如果<function>EndForeignModify</function>指针被设置为<literal>NULL</literal>，在执行器关闭期间不会采取任何动作。
    </para>
<!-- pgdoc-cn_end sig_en=51c58dd9a2483e19e40da3fccc74845e -->

<!-- pgdoc-cn_start sig_en=a3caa5bfbde60d07c9a4b853ffeb5082 sig_cn_org=None source=14.1 
    <para>
     Tuples inserted into a partitioned table by <command>INSERT</command> or
     <command>COPY FROM</command> are routed to partitions.  If an FDW
     supports routable foreign-table partitions, it should also provide the
     following callback functions.  These functions are also called when
     <command>COPY FROM</command> is executed on a foreign table.
    </para>
________________________________________________________-->
    <para>
     被<command>INSERT</command>或者<command>COPY FROM</command>插入到分区表中的元组会被路由到分区。如果一个FDW支持可路由的外部表分区，它还应该提供下面的回调函数。当在外部表上执行<command>COPY FROM</command>时，也会调用这些函数。
    </para>
<!-- pgdoc-cn_end sig_en=a3caa5bfbde60d07c9a4b853ffeb5082 -->

<!-- pgdoc-cn_start sig_en=92e0f3bbf0d3b7ce576970a00dbee447 sig_cn_org=None source=14.1 
    <para>
<programlisting>
void
BeginForeignInsert(ModifyTableState *mtstate,
                   ResultRelInfo *rinfo);
</programlisting>

     Begin executing an insert operation on a foreign table.  This routine is
     called right before the first tuple is inserted into the foreign table
     in both cases when it is the partition chosen for tuple routing and the
     target specified in a <command>COPY FROM</command> command.  It should
     perform any initialization needed prior to the actual insertion.
     Subsequently, <function>ExecForeignInsert</function> or
     <function>ExecForeignBatchInsert</function> will be called for
     tuple(s) to be inserted into the foreign table.
    </para>
________________________________________________________-->
    <para>
<programlisting>
void
BeginForeignInsert(ModifyTableState *mtstate,
                   ResultRelInfo *rinfo);
</programlisting>

     开始在外部表上执行插入操作。
     当外部表被选中作为元组路由的分区以及<command>COPY FROM</command>命令中指定的目标时，在第一个元组被插入到该外部表之前会调用这个例程。
     它应该执行实际插入之前所需的任何初始化工作。
     随后，为每一个被插入到该外部表的元组都将调用<function>ExecForeignInsert</function>或<function>ExecForeignBatchInsert</function>。
    </para>
<!-- pgdoc-cn_end sig_en=92e0f3bbf0d3b7ce576970a00dbee447 -->

<!-- pgdoc-cn_start sig_en=feb72a1489ccad2bac66a6d52b2d43b1 sig_cn_org=None source=14.1 
    <para>
     <literal>mtstate</literal> is the overall state of the
     <structname>ModifyTable</structname> plan node being executed; global data about
     the plan and execution state is available via this structure.
     <literal>rinfo</literal> is the <structname>ResultRelInfo</structname> struct describing
     the target foreign table.  (The <structfield>ri_FdwState</structfield> field of
     <structname>ResultRelInfo</structname> is available for the FDW to store any
     private state it needs for this operation.)
    </para>
________________________________________________________-->
    <para>
     <literal>mtstate</literal>是正在被执行的<structname>ModifyTable</structname>计划节点的总体状态，通过这个结构可以得到有关计划和执行的全局数据。<literal>rinfo</literal>是描述目标外部表的<structname>ResultRelInfo</structname>结构（对于FDW，<structname>ResultRelInfo</structname>的<structfield>ri_FdwState</structfield>字段用来存放这个操作所需要的私有状态）。
    </para>
<!-- pgdoc-cn_end sig_en=feb72a1489ccad2bac66a6d52b2d43b1 -->

<!-- pgdoc-cn_start sig_en=1eb0475dbe9f62e7c6c6735e44972977 sig_cn_org=None source=14.1 
    <para>
     When this is called by a <command>COPY FROM</command> command, the
     plan-related global data in <literal>mtstate</literal> is not provided
     and the <literal>planSlot</literal> parameter of
     <function>ExecForeignInsert</function> subsequently called for each
     inserted tuple is <literal>NULL</literal>, whether the foreign table is
     the partition chosen for tuple routing or the target specified in the
     command.
    </para>
________________________________________________________-->
    <para>
     当这个例程被一个<command>COPY FROM</command>命令调用时，不会提供<literal>mtstate</literal>中与计划相关的全局数据，并且后续为每个插入元组调用的<function>ExecForeignInsert</function>的<literal>planSlot</literal>参数为<literal>NULL</literal>，不管该外部表是为元组路由选中的分区还是命令中指定的目标。
    </para>
<!-- pgdoc-cn_end sig_en=1eb0475dbe9f62e7c6c6735e44972977 -->

<!-- pgdoc-cn_start sig_en=1eaaa1594e0e69dbf4df6acbc56d05c1 sig_cn_org=None source=14.1 
    <para>
     If the <function>BeginForeignInsert</function> pointer is set to
     <literal>NULL</literal>, no action is taken for the initialization.
    </para>
________________________________________________________-->
    <para>
     如果<function>BeginForeignInsert</function>指针被设置为<literal>NULL</literal>，则不会采取初始化动作。
    </para>
<!-- pgdoc-cn_end sig_en=1eaaa1594e0e69dbf4df6acbc56d05c1 -->

<!-- pgdoc-cn_start sig_en=2597221ee4ebe90bd591d2d98a71f9a5 sig_cn_org=None source=14.1 
    <para>
     Note that if the FDW does not support routable foreign-table partitions
     and/or executing <command>COPY FROM</command> on foreign tables, this
     function or <function>ExecForeignInsert/ExecForeignBatchInsert</function>
     subsequently called must throw error as needed.
    </para>
________________________________________________________-->
    <para>
     请注意如果 FDW 不支持在外表上的可路由外表分区和/或执行 <command>COPY FROM</command> ，这个函数或 <function>ExecForeignInsert/ExecForeignBatchInsert</function> 后续的调用必须根据需要发出错误。
    </para>
<!-- pgdoc-cn_end sig_en=2597221ee4ebe90bd591d2d98a71f9a5 -->

<!-- pgdoc-cn_start sig_en=b332a0dbac1c614af396d10418fe2972 sig_cn_org=None source=14.1 
    <para>
<programlisting>
void
EndForeignInsert(EState *estate,
                 ResultRelInfo *rinfo);
</programlisting>

     End the insert operation and release resources.  It is normally not important
     to release palloc'd memory, but for example open files and connections
     to remote servers should be cleaned up.
    </para>
________________________________________________________-->
    <para>
<programlisting>
void
EndForeignInsert(EState *estate,
                 ResultRelInfo *rinfo);
</programlisting>

     结束插入操作并且释放资源。通常释放palloc的内存并不重要，但是打开的文件和与远程服务器的连接应该被清除。
    </para>
<!-- pgdoc-cn_end sig_en=b332a0dbac1c614af396d10418fe2972 -->

<!-- pgdoc-cn_start sig_en=9ede094beb0443136eda463697a809e5 sig_cn_org=None source=14.1 
    <para>
     If the <function>EndForeignInsert</function> pointer is set to
     <literal>NULL</literal>, no action is taken for the termination.
    </para>
________________________________________________________-->
    <para>
     如果<function>EndForeignInsert</function>指针被设置为<literal>NULL</literal>，则不会采取终止动作。
    </para>
<!-- pgdoc-cn_end sig_en=9ede094beb0443136eda463697a809e5 -->

<!-- pgdoc-cn_start sig_en=d1830210c4184ce441d87d64322d265f sig_cn_org=None source=14.1 
    <para>
<programlisting>
int
IsForeignRelUpdatable(Relation rel);
</programlisting>

     Report which update operations the specified foreign table supports.
     The return value should be a bit mask of rule event numbers indicating
     which operations are supported by the foreign table, using the
     <literal>CmdType</literal> enumeration; that is,
     <literal>(1 &lt;&lt; CMD_UPDATE) = 4</literal> for <command>UPDATE</command>,
     <literal>(1 &lt;&lt; CMD_INSERT) = 8</literal> for <command>INSERT</command>, and
     <literal>(1 &lt;&lt; CMD_DELETE) = 16</literal> for <command>DELETE</command>.
    </para>
________________________________________________________-->
    <para>
<programlisting>
int
IsForeignRelUpdatable(Relation rel);
</programlisting>

     报告指定的外部表支持哪些更新操作。返回值应该是一个规则事件编号的位掩码，它指示了哪些操作被外部表支持，它使用<literal>CmdType</literal>枚举，即：
     <literal>(1 &lt;&lt; CMD_UPDATE) = 4</literal>表示<command>UPDATE</command>、
     <literal>(1 &lt;&lt; CMD_INSERT) = 8</literal>表示<command>INSERT</command>以及
     <literal>(1 &lt;&lt; CMD_DELETE) = 16</literal>表示<command>DELETE</command>。
    </para>
<!-- pgdoc-cn_end sig_en=d1830210c4184ce441d87d64322d265f -->

<!-- pgdoc-cn_start sig_en=966231cb019be4f0ec23fed51c46ce9c sig_cn_org=None source=14.1 
    <para>
     If the <function>IsForeignRelUpdatable</function> pointer is set to
     <literal>NULL</literal>, foreign tables are assumed to be insertable, updatable,
     or deletable if the FDW provides <function>ExecForeignInsert</function>,
     <function>ExecForeignUpdate</function>, or <function>ExecForeignDelete</function>
     respectively.  This function is only needed if the FDW supports some
     tables that are updatable and some that are not.  (Even then, it's
     permissible to throw an error in the execution routine instead of
     checking in this function.  However, this function is used to determine
     updatability for display in the <literal>information_schema</literal> views.)
    </para>
________________________________________________________-->
    <para>
     如果<function>IsForeignRelUpdatable</function>指针被设置为<literal>NULL</literal>，而FDW提供了<function>ExecForeignInsert</function>、<function>ExecForeignUpdate</function>或<function>ExecForeignDelete</function>，则外部表分别被假定为可插入、可更新或可删除。只有在FDW支持某些表是可更新的而某些不是可更新的时候，才需要这个函数（即便如此，也允许在执行例程中抛出一个错误而不是在这个函数中检查。但是，这个函数被用来决定显示在<literal>information_schema</literal>视图中的可更新性）。
    </para>
<!-- pgdoc-cn_end sig_en=966231cb019be4f0ec23fed51c46ce9c -->

<!-- pgdoc-cn_start sig_en=0e519ac7c7ec9fee88d9dcba776cc184 sig_cn_org=None source=14.1 
    <para>
     Some inserts, updates, and deletes to foreign tables can be optimized
     by implementing an alternative set of interfaces.  The ordinary
     interfaces for inserts, updates, and deletes fetch rows from the remote
     server and then modify those rows one at a time.  In some cases, this
     row-by-row approach is necessary, but it can be inefficient.  If it is
     possible for the foreign server to determine which rows should be
     modified without actually retrieving them, and if there are no local
     structures which would affect the operation (row-level local triggers,
     stored generated columns, or <literal>WITH CHECK OPTION</literal>
     constraints from parent views), then it is possible to arrange things
     so that the entire operation is performed on the remote server.  The
     interfaces described below make this possible.
    </para>
________________________________________________________-->
    <para>
     一些对于外部表的插入、更新和删除可以通过实现另一组接口来优化。普通的插入、更新和删除接口会从远程服务器取得行，然后一次修改其中一行。在某些情况下，这种逐行的方式是必要的，但是可能效率不高。
     如果有可能让外部服务器判断哪些行可以直接修改而无需先检索它们，并且没有本地结构会影响该操作(行级本地触发器，存储生成的列, 或 来自父视图的<literal>WITH CHECK OPTION</literal>约束。
     那么可以让整个操作在远程服务器上执行。下面介绍的接口能让这种做法变成可能。
    </para>
<!-- pgdoc-cn_end sig_en=0e519ac7c7ec9fee88d9dcba776cc184 -->

<!-- pgdoc-cn_start sig_en=c47aa07d04c17951c3c0624e3794735f sig_cn_org=None source=14.1 
    <para>
<programlisting>
bool
PlanDirectModify(PlannerInfo *root,
                 ModifyTable *plan,
                 Index resultRelation,
                 int subplan_index);
</programlisting>

     Decide whether it is safe to execute a direct modification
     on the remote server.  If so, return <literal>true</literal> after performing
     planning actions needed for that.  Otherwise, return <literal>false</literal>.
     This optional function is called during query planning.
     If this function succeeds, <function>BeginDirectModify</function>,
     <function>IterateDirectModify</function> and <function>EndDirectModify</function> will
     be called at the execution stage, instead.  Otherwise, the table
     modification will be executed using the table-updating functions
     described above.
     The parameters are the same as for <function>PlanForeignModify</function>.
    </para>
________________________________________________________-->
    <para>
<programlisting>
bool
PlanDirectModify(PlannerInfo *root,
                 ModifyTable *plan,
                 Index resultRelation,
                 int subplan_index);
</programlisting>

     决定在远程服务器上执行直接修改是否安全。如果安全，执行所需的规划动作然后返回<literal>true</literal>。否则返回<literal>false</literal>。这个可选的函数在查询规划期间被调用。如果这个函数成功，在执行阶段将会调用<function>BeginDirectModify</function>、<function>IterateDirectModify</function>和<function>EndDirectModify</function>。否则，对表的修改将采用上文描述的表更新函数来执行。参数和<function>PlanForeignModify</function>的相同。
    </para>
<!-- pgdoc-cn_end sig_en=c47aa07d04c17951c3c0624e3794735f -->

<!-- pgdoc-cn_start sig_en=c0315910006b55a278acadf6a9637424 sig_cn_org=None source=14.1 
    <para>
     To execute the direct modification on the remote server, this function
     must rewrite the target subplan with a <structname>ForeignScan</structname> plan
     node that executes the direct modification on the remote server.  The
     <structfield>operation</structfield> and <structfield>resultRelation</structfield> fields
     of the <structname>ForeignScan</structname> must be set appropriately.
     <structfield>operation</structfield> must be set to the <literal>CmdType</literal>
     enumeration corresponding to the statement kind (that is,
     <literal>CMD_UPDATE</literal> for <command>UPDATE</command>,
     <literal>CMD_INSERT</literal> for <command>INSERT</command>, and
     <literal>CMD_DELETE</literal> for <command>DELETE</command>), and the
     <literal>resultRelation</literal> argument must be copied to the
     <structfield>resultRelation</structfield> field.
    </para>
________________________________________________________-->
    <para>
     要在远程服务器上执行直接修改，这个函数必须用一个<structname>ForeignScan</structname>计划节点（它在远程服务器上执行直接修改）重写目标子计划。
     <structname>ForeignScan</structname>的<structfield>operation</structfield>和<structfield>resultRelation</structfield>字段必须被合适地设置。
     <structfield>operation</structfield>必须被设置为与语句类型相对应的<literal>CmdType</literal>枚举值(也就是，<literal>CMD_UPDATE</literal> 对 <command>UPDATE</command>、<literal>CMD_INSERT</literal> 对 <command>INSERT</command>、以及<literal>CMD_DELETE</literal> 对 <command>DELETE</command>)，并且<literal>resultRelation</literal> 参数必须拷贝到 <structfield>resultRelation</structfield> 字段。
    </para>
<!-- pgdoc-cn_end sig_en=c0315910006b55a278acadf6a9637424 -->

<!-- pgdoc-cn_start sig_en=9ebc87c867b5bc8ae8287659c072e25e sig_cn_org=None source=14.1 
    <para>
     See <xref linkend="fdw-planning"/> for additional information.
    </para>
________________________________________________________-->
    <para>
     更多信息请见<xref linkend="fdw-planning"/>。
    </para>
<!-- pgdoc-cn_end sig_en=9ebc87c867b5bc8ae8287659c072e25e -->

<!-- pgdoc-cn_start sig_en=3dd6d96387ed57123d7ee0b24ad9025f sig_cn_org=None source=14.1 
    <para>
     If the <function>PlanDirectModify</function> pointer is set to
     <literal>NULL</literal>, no attempts to execute a direct modification on the
     remote server are taken.
    </para>
________________________________________________________-->
    <para>
     如果<function>PlanDirectModify</function>指针被设置为<literal>NULL</literal>，不会尝试在远程服务器上执行直接修改。
    </para>
<!-- pgdoc-cn_end sig_en=3dd6d96387ed57123d7ee0b24ad9025f -->

<!-- pgdoc-cn_start sig_en=45410d2677d980a47f9991c9f4dda9b0 sig_cn_org=None source=14.1 
    <para>
<programlisting>
void
BeginDirectModify(ForeignScanState *node,
                  int eflags);
</programlisting>

     Prepare to execute a direct modification on the remote server.
     This is called during executor startup.  It should perform any
     initialization needed prior to the direct modification (that should be
     done upon the first call to <function>IterateDirectModify</function>).
     The <structname>ForeignScanState</structname> node has already been created, but
     its <structfield>fdw_state</structfield> field is still NULL.  Information about
     the table to modify is accessible through the
     <structname>ForeignScanState</structname> node (in particular, from the underlying
     <structname>ForeignScan</structname> plan node, which contains any FDW-private
     information provided by <function>PlanDirectModify</function>).
     <literal>eflags</literal> contains flag bits describing the executor's
     operating mode for this plan node.
    </para>
________________________________________________________-->
    <para>
<programlisting>
void
BeginDirectModify(ForeignScanState *node,
                  int eflags);
</programlisting>

     准备在远程服务器上执行一次直接修改。这个函数会在执行器启动时被调用。它应该执行直接修改所需的任何初始化工作（应该在第一次<function>IterateDirectModify</function>调用之前完成）。<structname>ForeignScanState</structname>节点已经被创建，但是它的<structfield>fdw_state</structfield>域仍然为 NULL。有关要被修改的表的信息可以通过<structname>ForeignScanState</structname>节点（具体地，从底层的<structname>ForeignScan</structname>计划节点，它包含了<function>PlanDirectModify</function>提供的 FDW-私有信息）访问。<literal>eflags</literal>包含描述执行器对于这个计划节点操作模式的标志位。
    </para>
<!-- pgdoc-cn_end sig_en=45410d2677d980a47f9991c9f4dda9b0 -->

<!-- pgdoc-cn_start sig_en=b3e74457170aae0d309e884c5ba52547 sig_cn_org=None source=14.1 
    <para>
     Note that when <literal>(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</literal> is
     true, this function should not perform any externally-visible actions;
     it should only do the minimum required to make the node state valid
     for <function>ExplainDirectModify</function> and <function>EndDirectModify</function>.
    </para>
________________________________________________________-->
    <para>
     注意当<literal>(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</literal>为真时，这个函数不应该执行任何外部可见的动作。它应当只做最少的工作让该节点状态对<function>ExplainDirectModify</function>和<function>EndDirectModify</function>有效。
    </para>
<!-- pgdoc-cn_end sig_en=b3e74457170aae0d309e884c5ba52547 -->

<!-- pgdoc-cn_start sig_en=5caa2c8da39af55a307cb51844201963 sig_cn_org=None source=14.1 
    <para>
     If the <function>BeginDirectModify</function> pointer is set to
     <literal>NULL</literal>, no attempts to execute a direct modification on the
     remote server are taken.
    </para>
________________________________________________________-->
    <para>
     如果<function>BeginDirectModify</function>指针被设置为<literal>NULL</literal>，不会尝试在远程服务器上执行直接修改。
    </para>
<!-- pgdoc-cn_end sig_en=5caa2c8da39af55a307cb51844201963 -->

<!-- pgdoc-cn_start sig_en=666eed5245cf4b1370449a982827656b sig_cn_org=None source=14.1 
    <para>
<programlisting>
TupleTableSlot *
IterateDirectModify(ForeignScanState *node);
</programlisting>

     When the <command>INSERT</command>, <command>UPDATE</command> or <command>DELETE</command>
     query doesn't have a <literal>RETURNING</literal> clause, just return NULL
     after a direct modification on the remote server.
     When the query has the clause, fetch one result containing the data
     needed for the <literal>RETURNING</literal> calculation, returning it in a
     tuple table slot (the node's <structfield>ScanTupleSlot</structfield> should be
     used for this purpose).  The data that was actually inserted, updated
     or deleted must be stored in
     <literal>node->resultRelInfo->ri_projectReturning-&gt;pi_exprContext-&gt;ecxt_scantuple</literal>.
     Return NULL if no more rows are available.
     Note that this is called in a short-lived memory context that will be
     reset between invocations.  Create a memory context in
     <function>BeginDirectModify</function> if you need longer-lived storage, or use
     the <structfield>es_query_cxt</structfield> of the node's <structname>EState</structname>.
    </para>
________________________________________________________-->
    <para>
<programlisting>
TupleTableSlot *
IterateDirectModify(ForeignScanState *node);
</programlisting>

     当<command>INSERT</command>、<command>UPDATE</command>或者<command>DELETE</command>查询没有<literal>RETURNING</literal>子句时，完成远程服务器上的直接修改后返回 NULL。
     当查询有该子句时，取出一个包含<literal>RETURNING</literal>计算所需数据的结果，用一个元组表槽返回它（节点的<structfield>ScanTupleSlot</structfield>应被用于这一目的）。
     实际被插入、更新或者删除的数据必须被存储在<literal>node->resultRelInfo->ri_projectReturning-&gt;pi_exprContext-&gt;ecxt_scantuple</literal>中。
     如果没有更多行可用，则返回 NULL。
     注意这个函数会在一个短期生存的内存上下文中被调用，该上下文会在两次调用之间被重置。
     如果需要一个长期存在的存储，可以在<function>BeginDirectModify</function>中创建一个内存上下文，或者使用该节点的<structname>EState</structname>中的<structfield>es_query_cxt</structfield>。
    </para>
<!-- pgdoc-cn_end sig_en=666eed5245cf4b1370449a982827656b -->

<!-- pgdoc-cn_start sig_en=ae144716930ba74d0097183f0ea64ac6 sig_cn_org=None source=14.1 
    <para>
     The rows returned must match the <structfield>fdw_scan_tlist</structfield> target
     list if one was supplied, otherwise they must match the row type of the
     foreign table being updated.  If you choose to optimize away fetching
     columns that are not needed for the <literal>RETURNING</literal> calculation,
     you should insert nulls in those column positions, or else generate a
     <structfield>fdw_scan_tlist</structfield> list with those columns omitted.
    </para>
________________________________________________________-->
    <para>
     如果提供了<structfield>fdw_scan_tlist</structfield>目标列表，则被返回的行必须匹配它。否则，被返回的行必须匹配被更新的外部表的行类型。如果选择优化掉<literal>RETURNING</literal>计算不需要的列，应该在这些列的位置上插入空值，或者生成一个忽略这些列的<structfield>fdw_scan_tlist</structfield>列表。
    </para>
<!-- pgdoc-cn_end sig_en=ae144716930ba74d0097183f0ea64ac6 -->

<!-- pgdoc-cn_start sig_en=09d87390668fe888d6b821b5212c1d98 sig_cn_org=None source=14.1 
    <para>
     Whether the query has the clause or not, the query's reported row count
     must be incremented by the FDW itself.  When the query doesn't have the
     clause, the FDW must also increment the row count for the
     <structname>ForeignScanState</structname> node in the <command>EXPLAIN ANALYZE</command>
     case.
    </para>
________________________________________________________-->
    <para>
     不管该查询是否具有<literal>RETURNING</literal>子句，查询所报告的行计数必须由 FDW 本身增加。当查询没有该子句时，FDW 还必须为<command>EXPLAIN ANALYZE</command>情况下的<structname>ForeignScanState</structname>节点增加行计数。
    </para>
<!-- pgdoc-cn_end sig_en=09d87390668fe888d6b821b5212c1d98 -->

<!-- pgdoc-cn_start sig_en=2293dacbff8de9bd968b4b73ae2fbcd6 sig_cn_org=None source=14.1 
    <para>
     If the <function>IterateDirectModify</function> pointer is set to
     <literal>NULL</literal>, no attempts to execute a direct modification on the
     remote server are taken.
    </para>
________________________________________________________-->
    <para>
     如果<function>IterateDirectModify</function>指针被设置为<literal>NULL</literal>，不会尝试在远程服务器上执行直接修改。
    </para>
<!-- pgdoc-cn_end sig_en=2293dacbff8de9bd968b4b73ae2fbcd6 -->

<!-- pgdoc-cn_start sig_en=f06d741d11ce21fa786a758706338254 sig_cn_org=None source=14.1 
    <para>
<programlisting>
void
EndDirectModify(ForeignScanState *node);
</programlisting>

     Clean up following a direct modification on the remote server.  It is
     normally not important to release palloc'd memory, but for example open
     files and connections to the remote server should be cleaned up.
    </para>
________________________________________________________-->
    <para>
<programlisting>
void
EndDirectModify(ForeignScanState *node);
</programlisting>

     在远程服务器上的直接修改后进行清理。通常释放用 palloc 分配的内存并不重要，但是诸如打开的文件和到远程服务器的连接应该被清除。
    </para>
<!-- pgdoc-cn_end sig_en=f06d741d11ce21fa786a758706338254 -->

<!-- pgdoc-cn_start sig_en=1cbfb1aec9be5e4f62b11254e34b80be sig_cn_org=None source=14.1 
    <para>
     If the <function>EndDirectModify</function> pointer is set to
     <literal>NULL</literal>, no attempts to execute a direct modification on the
     remote server are taken.
    </para>
________________________________________________________-->
    <para>
     如果<function>EndDirectModify</function>指针被设置为<literal>NULL</literal>，不会尝试在远程服务器上执行直接修改。
    </para>
<!-- pgdoc-cn_end sig_en=1cbfb1aec9be5e4f62b11254e34b80be -->

   </sect2>

   <sect2 id="fdw-callbacks-truncate">
<!-- pgdoc-cn_start sig_en=8acea5f7c5e1181c7f7070b8d87ddeed sig_cn_org=None source=14.1 
    <title>FDW Routines for <command>TRUNCATE</command></title>
________________________________________________________-->
    <title>FDW Routines for <command>TRUNCATE</command></title>
<!-- pgdoc-cn_end sig_en=8acea5f7c5e1181c7f7070b8d87ddeed -->

<!-- pgdoc-cn_start sig_en=84a0cd68ec082cc8b78a91391177c0de sig_cn_org=None source=14.1 
    <para>
<programlisting>
void
ExecForeignTruncate(List *rels,
                    DropBehavior behavior,
                    bool restart_seqs);
</programlisting>

     Truncate foreign tables.  This function is called when
     <xref linkend="sql-truncate"/> is executed on a foreign table.
     <literal>rels</literal> is a list of <structname>Relation</structname>
     data structures of foreign tables to truncate.
    </para>
________________________________________________________-->
    <para>
<programlisting>
void
ExecForeignTruncate(List *rels,
                    DropBehavior behavior,
                    bool restart_seqs);
</programlisting>

     截断外表。
     当在外表上执行<xref linkend="sql-truncate"/>时该函数被调用。
     <literal>rels</literal>是要截断的外表的<structname>Relation</structname>数据结构的列表。
    </para>
<!-- pgdoc-cn_end sig_en=84a0cd68ec082cc8b78a91391177c0de -->

<!-- pgdoc-cn_start sig_en=d83b4d00a7c77a179148782664334201 sig_cn_org=None source=14.1 
    <para>
     <literal>behavior</literal> is either <literal>DROP_RESTRICT</literal>
     or <literal>DROP_CASCADE</literal> indicating that the
     <literal>RESTRICT</literal> or <literal>CASCADE</literal> option was
     requested in the original <command>TRUNCATE</command> command,
     respectively.
    </para>
________________________________________________________-->
    <para>
     <literal>behavior</literal>是<literal>DROP_RESTRICT</literal>或<literal>DROP_CASCADE</literal>，分别表示在原始的<command>TRUNCATE</command>命令中请求了<literal>RESTRICT</literal> 或 <literal>CASCADE</literal>选项。
    </para>
<!-- pgdoc-cn_end sig_en=d83b4d00a7c77a179148782664334201 -->

<!-- pgdoc-cn_start sig_en=697701f2b2435c20448e11434d8e9165 sig_cn_org=None source=14.1 
    <para>
     If <literal>restart_seqs</literal> is <literal>true</literal>,
     the original <command>TRUNCATE</command> command requested the
     <literal>RESTART IDENTITY</literal> behavior, otherwise the
     <literal>CONTINUE IDENTITY</literal> behavior was requested.
    </para>
________________________________________________________-->
    <para>
     如果<literal>restart_seqs</literal>为<literal>true</literal>，原始的<command>TRUNCATE</command>命令需要<literal>RESTART IDENTITY</literal>行为，否则将需要<literal>CONTINUE IDENTITY</literal>行为。
    </para>
<!-- pgdoc-cn_end sig_en=697701f2b2435c20448e11434d8e9165 -->

<!-- pgdoc-cn_start sig_en=96b4c27dcf5f862fdbf9afa94b5b3b58 sig_cn_org=None source=14.1 
    <para>
     Note that the <literal>ONLY</literal> options specified
     in the original <command>TRUNCATE</command> command are not passed to
     <function>ExecForeignTruncate</function>.  This behavior is similar to
     the callback functions of <command>SELECT</command>,
     <command>UPDATE</command> and <command>DELETE</command> on
     a foreign table.
    </para>
________________________________________________________-->
    <para>
     注意在原始<command>TRUNCATE</command> 命令中指定的<literal>ONLY</literal>选项不会传递给<function>ExecForeignTruncate</function>。
     这个行为类似于外表上的<command>SELECT</command>、<command>UPDATE</command> 和 <command>DELETE</command>的回调函数。
    </para>
<!-- pgdoc-cn_end sig_en=96b4c27dcf5f862fdbf9afa94b5b3b58 -->

<!-- pgdoc-cn_start sig_en=9d824cf77df531de9b11f559fefaaf5d sig_cn_org=None source=14.1 
    <para>
     <function>ExecForeignTruncate</function> is invoked once per
     foreign server for which foreign tables are to be truncated.
     This means that all foreign tables included in <literal>rels</literal>
     must belong to the same server.
    </para>
________________________________________________________-->
    <para>
     对于要被截断的外表的每个外表服务器，<function>ExecForeignTruncate</function>被调用一次。
     这意味着包含在<literal>rels</literal> 中的所有外表必须属于相同的服务器。
    </para>
<!-- pgdoc-cn_end sig_en=9d824cf77df531de9b11f559fefaaf5d -->

<!-- pgdoc-cn_start sig_en=c64eaa3b71035ab186dd88168e41cb5f sig_cn_org=None source=14.1 
    <para>
     If the <function>ExecForeignTruncate</function> pointer is set to
     <literal>NULL</literal>, attempts to truncate foreign tables will
     fail with an error message.
    </para>
________________________________________________________-->
    <para>
     如果<function>ExecForeignTruncate</function>指针被设置为<literal>NULL</literal>，截断外表的尝试将失败并随带错误消息。
    </para>
<!-- pgdoc-cn_end sig_en=c64eaa3b71035ab186dd88168e41cb5f -->
   </sect2>

   <sect2 id="fdw-callbacks-row-locking">
<!-- pgdoc-cn_start sig_en=b76690e88f87d0bbf08282aae190f0b1 sig_cn_org=None source=14.1 
    <title>FDW Routines for Row Locking</title>
________________________________________________________-->
    <title>用于行锁定的 FDW 例程</title>
<!-- pgdoc-cn_end sig_en=b76690e88f87d0bbf08282aae190f0b1 -->

<!-- pgdoc-cn_start sig_en=ce9d6f256dd20737b19c08fb8f0b5696 sig_cn_org=None source=14.1 
    <para>
     If an FDW wishes to support <firstterm>late row locking</firstterm> (as described
     in <xref linkend="fdw-row-locking"/>), it must provide the following
     callback functions:
    </para>
________________________________________________________-->
    <para>
     如果一个 FDW 希望支持<firstterm>后期行锁定</firstterm>（如<xref linkend="fdw-row-locking"/>中所述），它必须提供下列回调函数：
    </para>
<!-- pgdoc-cn_end sig_en=ce9d6f256dd20737b19c08fb8f0b5696 -->

<!-- pgdoc-cn_start sig_en=a3b2093101eb4b3c68c1c079939a2e5d sig_cn_org=None source=14.1 
    <para>
<programlisting>
RowMarkType
GetForeignRowMarkType(RangeTblEntry *rte,
                      LockClauseStrength strength);
</programlisting>

     Report which row-marking option to use for a foreign table.
     <literal>rte</literal> is the <structname>RangeTblEntry</structname> node for the table
     and <literal>strength</literal> describes the lock strength requested by the
     relevant <literal>FOR UPDATE/SHARE</literal> clause, if any.  The result must be
     a member of the <literal>RowMarkType</literal> enum type.
    </para>
________________________________________________________-->
    <para>
<programlisting>
RowMarkType
GetForeignRowMarkType(RangeTblEntry *rte,
                      LockClauseStrength strength);
</programlisting>

     报告要对一个外部表使用哪个行标记选项。<literal>rte</literal>是该表的<structname>RangeTblEntry</structname>节点，而<literal>strength</literal>描述<literal>FOR UPDATE/SHARE</literal>子句（如果有）所要求的锁长度。结果必须是<literal>RowMarkType</literal>枚举类型的一个成员。
    </para>
<!-- pgdoc-cn_end sig_en=a3b2093101eb4b3c68c1c079939a2e5d -->

<!-- pgdoc-cn_start sig_en=5155f219ed538b56e593924d298ecc13 sig_cn_org=None source=14.1 
    <para>
     This function is called during query planning for each foreign table that
     appears in an <command>UPDATE</command>, <command>DELETE</command>, or <command>SELECT
     FOR UPDATE/SHARE</command> query and is not the target of <command>UPDATE</command>
     or <command>DELETE</command>.
    </para>
________________________________________________________-->
    <para>
     这个函数在查询规划期间会为每一个出现在<command>UPDATE</command>、<command>DELETE</command>或者<command>SELECT FOR UPDATE/SHARE</command>查询中的外部表调用，并且该外部表不是<command>UPDATE</command>和<command>DELETE</command>的目标。
    </para>
<!-- pgdoc-cn_end sig_en=5155f219ed538b56e593924d298ecc13 -->

<!-- pgdoc-cn_start sig_en=29c1d130c94ddd0bfed25d4c683ff87c sig_cn_org=None source=14.1 
    <para>
     If the <function>GetForeignRowMarkType</function> pointer is set to
     <literal>NULL</literal>, the <literal>ROW_MARK_COPY</literal> option is always used.
     (This implies that <function>RefetchForeignRow</function> will never be called,
     so it need not be provided either.)
    </para>
________________________________________________________-->
    <para>
     如果<function>GetForeignRowMarkType</function>指针被设置为<literal>NULL</literal>，将总是使用<literal>ROW_MARK_COPY</literal>选项（这意味着将不会调用<function>RefetchForeignRow</function>，因此也不必提供它）。
    </para>
<!-- pgdoc-cn_end sig_en=29c1d130c94ddd0bfed25d4c683ff87c -->

<!-- pgdoc-cn_start sig_en=f8106cbda6417ed5da95b6f020c45f6e sig_cn_org=None source=14.1 
    <para>
     See <xref linkend="fdw-row-locking"/> for more information.
    </para>
________________________________________________________-->
    <para>
     更多信息请见<xref linkend="fdw-row-locking"/>。
    </para>
<!-- pgdoc-cn_end sig_en=f8106cbda6417ed5da95b6f020c45f6e -->

<!-- pgdoc-cn_start sig_en=583342996f21f513910c34e994a9e789 sig_cn_org=None source=14.1 
    <para>
<programlisting>
void
RefetchForeignRow(EState *estate,
                  ExecRowMark *erm,
                  Datum rowid,
                  TupleTableSlot *slot,
                  bool *updated);
</programlisting>

     Re-fetch one tuple slot from the foreign table, after locking it if required.
     <literal>estate</literal> is global execution state for the query.
     <literal>erm</literal> is the <structname>ExecRowMark</structname> struct describing
     the target foreign table and the row lock type (if any) to acquire.
     <literal>rowid</literal> identifies the tuple to be fetched.
     <literal>slot</literal> contains nothing useful upon call, but can be used to
     hold the returned tuple. <literal>updated</literal> is an output parameter.
    </para>
________________________________________________________-->
    <para>
<programlisting>
void
RefetchForeignRow(EState *estate,
                  ExecRowMark *erm,
                  Datum rowid,
                  TupleTableSlot *slot,
                  bool *updated);
</programlisting>

     从外部表中重新取得一个元组槽，如有必要先锁定它。<literal>estate</literal>是该查询的全局执行状态。<literal>erm</literal>是描述目标外部表以及要获取的行锁类型（如果有）的<structname>ExecRowMark</structname>结构。<literal>rowid</literal>标识要取得的元组。
     <literal>slot</literal>在调用时不包含有用内容，但可用于保存返回的元组。<literal>updated</literal>是一个输出参数。
    </para>
<!-- pgdoc-cn_end sig_en=583342996f21f513910c34e994a9e789 -->

<!-- pgdoc-cn_start sig_en=9d4bec30976d88a3eb8342d2986625ff sig_cn_org=None source=14.1 
    <para>
     This function should store the tuple into the provided slot, or clear it if
     the row lock couldn't be obtained.  The row lock type to acquire is
     defined by <literal>erm-&gt;markType</literal>, which is the value
     previously returned by <function>GetForeignRowMarkType</function>.
     (<literal>ROW_MARK_REFERENCE</literal> means to just re-fetch the tuple
     without acquiring any lock, and <literal>ROW_MARK_COPY</literal> will
     never be seen by this routine.)
    </para>
________________________________________________________-->
    <para>
     此函数应将元组存储到提供的槽中，或者在无法获得行锁时清除该槽。
     要获得的行锁由<literal>erm-&gt;markType</literal>定义，它是之前由<function>GetForeignRowMarkType</function>返回的值（<literal>ROW_MARK_REFERENCE</literal>标识只重新取得元组但不获得任何锁，这个例程将不会看到<literal>ROW_MARK_COPY</literal>）。
    </para>
<!-- pgdoc-cn_end sig_en=9d4bec30976d88a3eb8342d2986625ff -->

<!-- pgdoc-cn_start sig_en=36e36a746752400f36afeb8f9ccb79a9 sig_cn_org=None source=14.1 
    <para>
     In addition, <literal>*updated</literal> should be set to <literal>true</literal>
     if what was fetched was an updated version of the tuple rather than
     the same version previously obtained.  (If the FDW cannot be sure about
     this, always returning <literal>true</literal> is recommended.)
    </para>
________________________________________________________-->
    <para>
     此外，如果取得的是一个更新过的版本而不是之前获得的同一版本，<literal>*updated</literal>应被设置为<literal>true</literal>（如果 FDW 无法确定这一点，推荐总是返回<literal>true</literal>）。
    </para>
<!-- pgdoc-cn_end sig_en=36e36a746752400f36afeb8f9ccb79a9 -->

<!-- pgdoc-cn_start sig_en=9938267336a7518569c9324ce39b419d sig_cn_org=None source=14.1 
    <para>
     Note that by default, failure to acquire a row lock should result in
     raising an error; returning with an empty slot is only appropriate if
     the <literal>SKIP LOCKED</literal> option is specified
     by <literal>erm-&gt;waitPolicy</literal>.
    </para>
________________________________________________________-->
    <para>
     注意在默认情况下，获取行锁失败应该导致产生错误。如果<literal>erm-&gt;waitPolicy</literal>指定了<literal>SKIP LOCKED</literal>，只有返回空槽才是合适的。
    </para>
<!-- pgdoc-cn_end sig_en=9938267336a7518569c9324ce39b419d -->

<!-- pgdoc-cn_start sig_en=f9e6b018aa1041cbbae57769fd6a7aed sig_cn_org=None source=14.1 
    <para>
     The <literal>rowid</literal> is the <structfield>ctid</structfield> value previously read
     for the row to be re-fetched.  Although the <literal>rowid</literal> value is
     passed as a <type>Datum</type>, it can currently only be a <type>tid</type>.  The
     function API is chosen in hopes that it may be possible to allow other
     data types for row IDs in future.
    </para>
________________________________________________________-->
    <para>
     <literal>rowid</literal>是要被重新取得的行之前读到的<structfield>ctid</structfield>值。尽管<literal>rowid</literal>值被作为<type>Datum</type>传递，但是目前它只能被读作<type>tid</type>。选择该函数 API 是希望未来能允许其他的行 ID 数据类型。
    </para>
<!-- pgdoc-cn_end sig_en=f9e6b018aa1041cbbae57769fd6a7aed -->

<!-- pgdoc-cn_start sig_en=10d35be66fd950d903e383343f18879e sig_cn_org=None source=14.1 
    <para>
     If the <function>RefetchForeignRow</function> pointer is set to
     <literal>NULL</literal>, attempts to re-fetch rows will fail
     with an error message.
    </para>
________________________________________________________-->
    <para>
     如果<function>RefetchForeignRow</function>指针被设置为<literal>NULL</literal>，重新取得行的尝试将会失败并伴随有一个错误消息。
    </para>
<!-- pgdoc-cn_end sig_en=10d35be66fd950d903e383343f18879e -->

<!-- pgdoc-cn_start sig_en=f8106cbda6417ed5da95b6f020c45f6e sig_cn_org=None source=14.1 
    <para>
     See <xref linkend="fdw-row-locking"/> for more information.
    </para>
________________________________________________________-->
    <para>
     更多信息请见<xref linkend="fdw-row-locking"/>。
    </para>
<!-- pgdoc-cn_end sig_en=f8106cbda6417ed5da95b6f020c45f6e -->

<!-- pgdoc-cn_start sig_en=f22fb5c09a4b19eb7700fab5079bb039 sig_cn_org=None source=14.1 
    <para>
<programlisting>
bool
RecheckForeignScan(ForeignScanState *node,
                   TupleTableSlot *slot);
</programlisting>
     Recheck that a previously-returned tuple still matches the relevant
     scan and join qualifiers, and possibly provide a modified version of
     the tuple.  For foreign data wrappers which do not perform join pushdown,
     it will typically be more convenient to set this to <literal>NULL</literal> and
     instead set <structfield>fdw_recheck_quals</structfield> appropriately.
     When outer joins are pushed down, however, it isn't sufficient to
     reapply the checks relevant to all the base tables to the result tuple,
     even if all needed attributes are present, because failure to match some
     qualifier might result in some attributes going to NULL, rather than in
     no tuple being returned.  <literal>RecheckForeignScan</literal> can recheck
     qualifiers and return true if they are still satisfied and false
     otherwise, but it can also store a replacement tuple into the supplied
     slot.
    </para>
________________________________________________________-->
    <para>
<programlisting>
bool
RecheckForeignScan(ForeignScanState *node,
                   TupleTableSlot *slot);
</programlisting>
     重新检查之前返回的元组是否仍然匹配相关的扫描和连接条件，并且可能提供该元组的一个修改版本。对于不执行连接下推的外部数据包装器，通常把这设置为<literal>NULL</literal>并且恰当地设置<structfield>fdw_recheck_quals</structfield>会更方便。不过当外部连接被下推时，把与所有基表相关的检查重新应用在结果元组上是不够的，即便所有需要的属性都存在也是如此，因为匹配某个条件失败可能会导致某些属性变成 NULL，而不是没有元组被返回。<literal>RecheckForeignScan</literal>能够重新检查条件，并且在它们仍然满足时返回真，否则返回假，但是它也能够在提供的槽中存储一个替换元组。
    </para>
<!-- pgdoc-cn_end sig_en=f22fb5c09a4b19eb7700fab5079bb039 -->

<!-- pgdoc-cn_start sig_en=5bfcab95930f735e2408c1e13631963a sig_cn_org=None source=14.1 
    <para>
     To implement join pushdown, a foreign data wrapper will typically
     construct an alternative local join plan which is used only for
     rechecks; this will become the outer subplan of the
     <literal>ForeignScan</literal>.  When a recheck is required, this subplan
     can be executed and the resulting tuple can be stored in the slot.
     This plan need not be efficient since no base table will return more
     than one row; for example, it may implement all joins as nested loops.
     The function <literal>GetExistingLocalJoinPath</literal> may be used to search
     existing paths for a suitable local join path, which can be used as the
     alternative local join plan.  <literal>GetExistingLocalJoinPath</literal>
     searches for an unparameterized path in the path list of the specified
     join relation.  (If it does not find such a path, it returns NULL, in
     which case a foreign data wrapper may build the local path by itself or
     may choose not to create access paths for that join.)
    </para>
________________________________________________________-->
    <para>
     要实现连接下推，外部数据包装器通常将构造一个可替代的本地连接计划，它只被用来做重新检查。这将变成<literal>ForeignScan</literal>的外子计划。在需要一次重新检查时，这个子计划可以被执行并且结果元组可以被存储在槽中。这个计划不需要效率很高，因为不会有基表返回超过一行。例如，它可以把所有的连接实现为嵌套循环。函数<literal>GetExistingLocalJoinPath</literal>可以被用来在已有的路径中搜索合适的本地连接路径，它可以被用作替换的本地连接计划。<literal>GetExistingLocalJoinPath</literal>会在指定连接关系的路径列表中搜索一个非参数化路径（如果没有找到这样的路径，它会返回 NULL，这种情况下外部数据包装器可以自行构造本地路径或者可以选择不为这个连接创建访问路径）。
    </para>
<!-- pgdoc-cn_end sig_en=5bfcab95930f735e2408c1e13631963a -->
   </sect2>

   <sect2 id="fdw-callbacks-explain">
<!-- pgdoc-cn_start sig_en=4e851010c66eb01d68437cffc86f0f8c sig_cn_org=None source=14.1 
    <title>FDW Routines for <command>EXPLAIN</command></title>
________________________________________________________-->
    <title><command>EXPLAIN</command>的FDW例程</title>
<!-- pgdoc-cn_end sig_en=4e851010c66eb01d68437cffc86f0f8c -->

<!-- pgdoc-cn_start sig_en=9cd7488722495ade2c47dfa68de93884 sig_cn_org=None source=14.1 
    <para>
<programlisting>
void
ExplainForeignScan(ForeignScanState *node,
                   ExplainState *es);
</programlisting>

     Print additional <command>EXPLAIN</command> output for a foreign table scan.
     This function can call <function>ExplainPropertyText</function> and
     related functions to add fields to the <command>EXPLAIN</command> output.
     The flag fields in <literal>es</literal> can be used to determine what to
     print, and the state of the <structname>ForeignScanState</structname> node
     can be inspected to provide run-time statistics in the <command>EXPLAIN
     ANALYZE</command> case.
    </para>
________________________________________________________-->
    <para>
<programlisting>
void
ExplainForeignScan(ForeignScanState *node,
                   ExplainState *es);
</programlisting>

     为一个外部表扫描打印额外的<command>EXPLAIN</command>输出。这个函数可以调用<function>ExplainPropertyText</function>和相关函数来向<command>EXPLAIN</command>输出中增加域。<literal>es</literal>中的标志域可以被用来决定什么将被打印，并且<structname>ForeignScanState</structname>节点的状态可以被检查来为<command>EXPLAIN ANALYZE</command>提供运行时统计数据。
    </para>
<!-- pgdoc-cn_end sig_en=9cd7488722495ade2c47dfa68de93884 -->

<!-- pgdoc-cn_start sig_en=eca00700d8628cce69c6aff1712882f8 sig_cn_org=None source=14.1 
    <para>
     If the <function>ExplainForeignScan</function> pointer is set to
     <literal>NULL</literal>, no additional information is printed during
     <command>EXPLAIN</command>.
    </para>
________________________________________________________-->
    <para>
     如果<function>ExplainForeignScan</function>指针被设置为<literal>NULL</literal>，在<command>EXPLAIN</command>期间不会打印任何额外的信息。
    </para>
<!-- pgdoc-cn_end sig_en=eca00700d8628cce69c6aff1712882f8 -->

<!-- pgdoc-cn_start sig_en=b710441e7dd8fceea045227b1aec8c49 sig_cn_org=None source=14.1 
    <para>
<programlisting>
void
ExplainForeignModify(ModifyTableState *mtstate,
                     ResultRelInfo *rinfo,
                     List *fdw_private,
                     int subplan_index,
                     struct ExplainState *es);
</programlisting>

     Print additional <command>EXPLAIN</command> output for a foreign table update.
     This function can call <function>ExplainPropertyText</function> and
     related functions to add fields to the <command>EXPLAIN</command> output.
     The flag fields in <literal>es</literal> can be used to determine what to
     print, and the state of the <structname>ModifyTableState</structname> node
     can be inspected to provide run-time statistics in the <command>EXPLAIN
     ANALYZE</command> case.  The first four arguments are the same as for
     <function>BeginForeignModify</function>.
    </para>
________________________________________________________-->
    <para>
<programlisting>
void
ExplainForeignModify(ModifyTableState *mtstate,
                     ResultRelInfo *rinfo,
                     List *fdw_private,
                     int subplan_index,
                     struct ExplainState *es);
</programlisting>

     为一个外部表更新打印额外的<command>EXPLAIN</command>输出。这个函数可以调用<function>ExplainPropertyText</function>和相关函数来向<command>EXPLAIN</command>输出中增加域。<literal>es</literal>中的标志域可以被用来决定什么将被打印，并且<structname>ModifyTableState</structname>节点的状态可以被检查来为<command>EXPLAIN ANALYZE</command>提供运行时统计数据。前四个参数和<function>BeginForeignModify</function>相同。
    </para>
<!-- pgdoc-cn_end sig_en=b710441e7dd8fceea045227b1aec8c49 -->

<!-- pgdoc-cn_start sig_en=0f22d192cf598b3318a1e094b3033013 sig_cn_org=None source=14.1 
    <para>
     If the <function>ExplainForeignModify</function> pointer is set to
     <literal>NULL</literal>, no additional information is printed during
     <command>EXPLAIN</command>.
    </para>
________________________________________________________-->
    <para>
     如果<function>ExplainForeignModify</function>指针被设置为<literal>NULL</literal>，在<command>EXPLAIN</command>期间不会打印任何额外的信息。
    </para>
<!-- pgdoc-cn_end sig_en=0f22d192cf598b3318a1e094b3033013 -->

<!-- pgdoc-cn_start sig_en=f830f6fa9ec981f976b10f0fa5d8314b sig_cn_org=None source=14.1 
    <para>
<programlisting>
void
ExplainDirectModify(ForeignScanState *node,
                    ExplainState *es);
</programlisting>

     Print additional <command>EXPLAIN</command> output for a direct modification
     on the remote server.
     This function can call <function>ExplainPropertyText</function> and
     related functions to add fields to the <command>EXPLAIN</command> output.
     The flag fields in <literal>es</literal> can be used to determine what to
     print, and the state of the <structname>ForeignScanState</structname> node
     can be inspected to provide run-time statistics in the <command>EXPLAIN
     ANALYZE</command> case.
    </para>
________________________________________________________-->
    <para>
<programlisting>
void
ExplainDirectModify(ForeignScanState *node,
                    ExplainState *es);
</programlisting>

     为远程服务器上的直接修改打印额外的<command>EXPLAIN</command>输出。这个函数可以调用<function>ExplainPropertyText</function>和相关函数来为<command>EXPLAIN</command>输出增加域。<literal>es</literal>中的标志域可以被用来判断要打印什么，并且在<command>EXPLAIN ANALYZE</command>情况中可以观察<structname>ForeignScanState</structname>节点的状态来提供运行时统计信息。
    </para>
<!-- pgdoc-cn_end sig_en=f830f6fa9ec981f976b10f0fa5d8314b -->

<!-- pgdoc-cn_start sig_en=b0859c9ffbca9a183ff57032b01a06d5 sig_cn_org=None source=14.1 
    <para>
     If the <function>ExplainDirectModify</function> pointer is set to
     <literal>NULL</literal>, no additional information is printed during
     <command>EXPLAIN</command>.
    </para>
________________________________________________________-->
    <para>
     如果<function>ExplainDirectModify</function>指针被设置为<literal>NULL</literal>，<command>EXPLAIN</command>期间不会打印出额外的信息。
    </para>
<!-- pgdoc-cn_end sig_en=b0859c9ffbca9a183ff57032b01a06d5 -->

   </sect2>

   <sect2 id="fdw-callbacks-analyze">
<!-- pgdoc-cn_start sig_en=73e4c508fdd580f2e1beb357ab264f7a sig_cn_org=None source=14.1 
    <title>FDW Routines for <command>ANALYZE</command></title>
________________________________________________________-->
    <title><command>ANALYZE</command>的FDW例程</title>
<!-- pgdoc-cn_end sig_en=73e4c508fdd580f2e1beb357ab264f7a -->

<!-- pgdoc-cn_start sig_en=2e70bffe136f2fd744cfd300b098dd3c sig_cn_org=None source=14.1 
    <para>
<programlisting>
bool
AnalyzeForeignTable(Relation relation,
                    AcquireSampleRowsFunc *func,
                    BlockNumber *totalpages);
</programlisting>

     This function is called when <xref linkend="sql-analyze"/> is executed on
     a foreign table.  If the FDW can collect statistics for this
     foreign table, it should return <literal>true</literal>, and provide a pointer
     to a function that will collect sample rows from the table in
     <parameter>func</parameter>, plus the estimated size of the table in pages in
     <parameter>totalpages</parameter>.  Otherwise, return <literal>false</literal>.
    </para>
________________________________________________________-->
    <para>
<programlisting>
bool
AnalyzeForeignTable(Relation relation,
                    AcquireSampleRowsFunc *func,
                    BlockNumber *totalpages);
</programlisting>

     当<xref linkend="sql-analyze"/>被执行在一个外部表上时会调用这个函数。如果FDW可以为这个外部表收集统计信息，它会返回<literal>true</literal>并提供一个函数指针，该函数将将从<parameter>func</parameter>中的表上收集采样行，外加<parameter>totalpages</parameter>中页面中的表尺寸估计值。否则，返回<literal>false</literal>。
    </para>
<!-- pgdoc-cn_end sig_en=2e70bffe136f2fd744cfd300b098dd3c -->

<!-- pgdoc-cn_start sig_en=922e2a66df71d1cb27234f534783981f sig_cn_org=None source=14.1 
    <para>
     If the FDW does not support collecting statistics for any tables, the
     <function>AnalyzeForeignTable</function> pointer can be set to <literal>NULL</literal>.
    </para>
________________________________________________________-->
    <para>
     如果FDW不支持为任何表收集统计信息，<function>AnalyzeForeignTable</function>指针可以被设置为<literal>NULL</literal>。
    </para>
<!-- pgdoc-cn_end sig_en=922e2a66df71d1cb27234f534783981f -->

<!-- pgdoc-cn_start sig_en=90850875b42f7f38fa1ec13f12e7b031 sig_cn_org=None source=14.1 
    <para>
     If provided, the sample collection function must have the signature
<programlisting>
int
AcquireSampleRowsFunc(Relation relation,
                      int elevel,
                      HeapTuple *rows,
                      int targrows,
                      double *totalrows,
                      double *totaldeadrows);
</programlisting>

     A random sample of up to <parameter>targrows</parameter> rows should be collected
     from the table and stored into the caller-provided <parameter>rows</parameter>
     array.  The actual number of rows collected must be returned.  In
     addition, store estimates of the total numbers of live and dead rows in
     the table into the output parameters <parameter>totalrows</parameter> and
     <parameter>totaldeadrows</parameter>.  (Set <parameter>totaldeadrows</parameter> to zero
     if the FDW does not have any concept of dead rows.)
    </para>
________________________________________________________-->
    <para>
     如果提供，采样收集函数必须具有签名
<programlisting>
int
AcquireSampleRowsFunc(Relation relation,
                      int elevel,
                      HeapTuple *rows,
                      int targrows,
                      double *totalrows,
                      double *totaldeadrows);
</programlisting>

     应该从该表上收集最多<parameter>targrows</parameter>行的一个随机采样并将它存放到调用者提供的<parameter>rows</parameter>数组中。实际被收集的行的数量必须被返回。另外，将表中有效行和死亡行的总数存储到输出参数<parameter>totalrows</parameter>和<parameter>totaldeadrows</parameter>中（如果FDW没有死亡行的概念，将<parameter>totaldeadrows</parameter>设置为 0 ）。
    </para>
<!-- pgdoc-cn_end sig_en=90850875b42f7f38fa1ec13f12e7b031 -->

   </sect2>

   <sect2 id="fdw-callbacks-import">
<!-- pgdoc-cn_start sig_en=8683d4fd763717b12bcbcc5e838e8e0e sig_cn_org=None source=14.1 
    <title>FDW Routines for <command>IMPORT FOREIGN SCHEMA</command></title>
________________________________________________________-->
    <title><command>IMPORT FOREIGN SCHEMA</command>的 FDW 例程</title>
<!-- pgdoc-cn_end sig_en=8683d4fd763717b12bcbcc5e838e8e0e -->

<!-- pgdoc-cn_start sig_en=3f3e60cefa4cf5b6b48aad1c050a0ccd sig_cn_org=None source=14.1 
    <para>
<programlisting>
List *
ImportForeignSchema(ImportForeignSchemaStmt *stmt, Oid serverOid);
</programlisting>

     Obtain a list of foreign table creation commands.  This function is
     called when executing <xref linkend="sql-importforeignschema"/>, and is
     passed the parse tree for that statement, as well as the OID of the
     foreign server to use.  It should return a list of C strings, each of
     which must contain a <xref linkend="sql-createforeigntable"/> command.
     These strings will be parsed and executed by the core server.
    </para>
________________________________________________________-->
    <para>
<programlisting>
List *
ImportForeignSchema(ImportForeignSchemaStmt *stmt, Oid serverOid);
</programlisting>

     取得一个外部表创建命令的列表。在执行<xref linkend="sql-importforeignschema"/>时会调用这个函数，并且会把该语句的解析树以及要使用的外部服务器的 OID 传递给它。它应该返回一个 C 字符串的列表，每一个必须包含一个<xref linkend="sql-createforeigntable"/>命令。这些命令将被核心服务器所解析和执行。
    </para>
<!-- pgdoc-cn_end sig_en=3f3e60cefa4cf5b6b48aad1c050a0ccd -->

<!-- pgdoc-cn_start sig_en=eb0d5231a26a7fecd7f69a3203ec1955 sig_cn_org=None source=14.1 
    <para>
     Within the <structname>ImportForeignSchemaStmt</structname> struct,
     <structfield>remote_schema</structfield> is the name of the remote schema from
     which tables are to be imported.
     <structfield>list_type</structfield> identifies how to filter table names:
     <literal>FDW_IMPORT_SCHEMA_ALL</literal> means that all tables in the remote
     schema should be imported (in this case <structfield>table_list</structfield> is
     empty), <literal>FDW_IMPORT_SCHEMA_LIMIT_TO</literal> means to include only
     tables listed in <structfield>table_list</structfield>,
     and <literal>FDW_IMPORT_SCHEMA_EXCEPT</literal> means to exclude the tables
     listed in <structfield>table_list</structfield>.
     <structfield>options</structfield> is a list of options used for the import process.
     The meanings of the options are up to the FDW.
     For example, an FDW could use an option to define whether the
     <literal>NOT NULL</literal> attributes of columns should be imported.
     These options need not have anything to do with those supported by the
     FDW as database object options.
    </para>
________________________________________________________-->
    <para>
     在<structname>ImportForeignSchemaStmt</structname>结构中，<structfield>remote_schema</structfield>是要从其中导入这些表的远程模式的名称。<structfield>list_type</structfield>标识如何过滤表名：<literal>FDW_IMPORT_SCHEMA_ALL</literal>表示该远程模式中的所有表都应该被导入（这种情况下<structfield>table_list</structfield>为空），<literal>FDW_IMPORT_SCHEMA_LIMIT_TO</literal>表示只包括<structfield>table_list</structfield>中列出的表，而<literal>FDW_IMPORT_SCHEMA_EXCEPT</literal>则表示排除<structfield>table_list</structfield>中列出的表。<structfield>options</structfield>是一个用于该导入处理的选项列表。选项的含义由 FDW 决定。例如，一个 FDW 可以用一个选项来定义是否应该导入列的<literal>NOT NULL</literal>属性。这些选项不需要与那些 FDW 支持的数据库对象选项有什么关系。
    </para>
<!-- pgdoc-cn_end sig_en=eb0d5231a26a7fecd7f69a3203ec1955 -->

<!-- pgdoc-cn_start sig_en=18c456f953edd20173d52d4e274b28aa sig_cn_org=None source=14.1 
    <para>
     The FDW may ignore the <structfield>local_schema</structfield> field of
     the <structname>ImportForeignSchemaStmt</structname>, because the core server
     will automatically insert that name into the parsed <command>CREATE
     FOREIGN TABLE</command> commands.
    </para>
________________________________________________________-->
    <para>
     FDW 可能会忽略<structname>ImportForeignSchemaStmt</structname>的<structfield>local_schema</structfield>域，因为核心服务器会自动地向解析好的<command>CREATE FOREIGN TABLE</command>命令中插入本地模式的名称。
    </para>
<!-- pgdoc-cn_end sig_en=18c456f953edd20173d52d4e274b28aa -->

<!-- pgdoc-cn_start sig_en=96060b9c72abf2fd6f27a9ef60e87b7b sig_cn_org=None source=14.1 
    <para>
     The FDW does not have to concern itself with implementing the filtering
     specified by <structfield>list_type</structfield> and <structfield>table_list</structfield>,
     either, as the core server will automatically skip any returned commands
     for tables excluded according to those options.  However, it's often
     useful to avoid the work of creating commands for excluded tables in the
     first place.  The function <function>IsImportableForeignTable()</function> may be
     useful to test whether a given foreign-table name will pass the filter.
    </para>
________________________________________________________-->
    <para>
     FDW 也不必担心实现<structfield>list_type</structfield>以及<structfield>table_list</structfield>所指定的过滤，因为核心服务器将自动根据那些选项跳过为被排除的表所返回的命令。不过，起初就避免为被排除的表创建命令当然更好。函数<function>IsImportableForeignTable()</function>可以用来测试一个给定的外部表名是否能通过该过滤器。
    </para>
<!-- pgdoc-cn_end sig_en=96060b9c72abf2fd6f27a9ef60e87b7b -->

<!-- pgdoc-cn_start sig_en=e20c83fb02b1f08c634cc3cd7e552117 sig_cn_org=None source=14.1 
    <para>
     If the FDW does not support importing table definitions, the
     <function>ImportForeignSchema</function> pointer can be set to <literal>NULL</literal>.
    </para>
________________________________________________________-->
    <para>
     如果 FDW 不支持导入表定义，<function>ImportForeignSchema</function>指针可以被设置为<literal>NULL</literal>。
    </para>
<!-- pgdoc-cn_end sig_en=e20c83fb02b1f08c634cc3cd7e552117 -->

   </sect2>

   <sect2 id="fdw-callbacks-parallel">
<!-- pgdoc-cn_start sig_en=0b4a2abd498c136d5a267a3a08e94a04 sig_cn_org=None source=14.1 
    <title>FDW Routines for Parallel Execution</title>
________________________________________________________-->
    <title>并行执行的 FDW 例程</title>
<!-- pgdoc-cn_end sig_en=0b4a2abd498c136d5a267a3a08e94a04 -->
<!-- pgdoc-cn_start sig_en=1dfcadfbb56cd6f3fd8a491015121a0c sig_cn_org=None source=14.1 
    <para>
     A <structname>ForeignScan</structname> node can, optionally, support parallel
     execution.  A parallel <structname>ForeignScan</structname> will be executed
     in multiple processes and must return each row exactly once across
     all cooperating processes.  To do this, processes can coordinate through
     fixed-size chunks of dynamic shared memory.  This shared memory is not
     guaranteed to be mapped at the same address in every process, so it
     must not contain pointers.  The following functions are all optional,
     but most are required if parallel execution is to be supported.
    </para>
________________________________________________________-->
    <para>
     <structname>ForeignScan</structname>节点可以选择支持并行执行。一个并行的<structname>ForeignScan</structname>将在多个进程中被执行并且在相互合作的进程中每一个元组必须只被返回一次。要做到这样，进程可以通过动态共享内存的固定尺寸块来协作。并不保证在每一个进程中这部份共享内存都被映射到相同的地址，因此不能包含指针。下面的函数通常都是可选的，但是如果要支持并行执行就必须提供其中的大部分。
    </para>
<!-- pgdoc-cn_end sig_en=1dfcadfbb56cd6f3fd8a491015121a0c -->

<!-- pgdoc-cn_start sig_en=949752b6fc582c6ef36d2c33e4e083cb sig_cn_org=None source=14.1 
    <para>
<programlisting>
bool
IsForeignScanParallelSafe(PlannerInfo *root, RelOptInfo *rel,
                          RangeTblEntry *rte);
</programlisting>
    Test whether a scan can be performed within a parallel worker.  This
    function will only be called when the planner believes that a parallel
    plan might be possible, and should return true if it is safe for that scan
    to run within a parallel worker.  This will generally not be the case if
    the remote data source has transaction semantics, unless the worker's
    connection to the data can somehow be made to share the same transaction
    context as the leader.
    </para>
________________________________________________________-->
    <para>
<programlisting>
bool
IsForeignScanParallelSafe(PlannerInfo *root, RelOptInfo *rel,
                          RangeTblEntry *rte);
</programlisting>
    测试一个扫描是否可以在一个并行工作者中被执行。只有当规划器相信可以使用并行计划时才会调用这个函数，如果该扫描在并行工作者中可以安全运行这个函数应该返回真。如果远程数据源具有事务语义，情况通常都不是这样，除非工作者到数据的连接能够以某种方式共享与领导者相同的事务环境。
    </para>
<!-- pgdoc-cn_end sig_en=949752b6fc582c6ef36d2c33e4e083cb -->

<!-- pgdoc-cn_start sig_en=4818c4fb7c45f52daf4412aaccc18188 sig_cn_org=None source=14.1 
    <para>
    If this function is not defined, it is assumed that the scan must take
    place within the parallel leader.  Note that returning true does not mean
    that the scan itself can be done in parallel, only that the scan can be
    performed within a parallel worker.  Therefore, it can be useful to define
    this method even when parallel execution is not supported.
    </para>
________________________________________________________-->
    <para>
    如果没有定义这个函数，则假定该扫描必须被放置在并行领导者中。注意返回真并不意味着该扫描本身可以被并行完成，只是说明该扫描可以在一个并行工作者中执行。因此，即便当不支持并行执行时，定义这个方法也是有用的。
    </para>
<!-- pgdoc-cn_end sig_en=4818c4fb7c45f52daf4412aaccc18188 -->

<!-- pgdoc-cn_start sig_en=c20142ab887f11d4a94d831bfa2d4e5e sig_cn_org=None source=14.1 
    <para>
<programlisting>
Size
EstimateDSMForeignScan(ForeignScanState *node, ParallelContext *pcxt);
</programlisting>
    Estimate the amount of dynamic shared memory that will be required
    for parallel operation.  This may be higher than the amount that will
    actually be used, but it must not be lower.  The return value is in bytes.
    This function is optional, and can be omitted if not needed; but if it
    is omitted, the next three functions must be omitted as well, because
    no shared memory will be allocated for the FDW's use.
    </para>
________________________________________________________-->
    <para>
<programlisting>
Size
EstimateDSMForeignScan(ForeignScanState *node, ParallelContext *pcxt);
</programlisting>
    估算并行操作所需的动态共享内存的数量。这可能比实际要用的数量更大，但是绝不能更小。返回值的单位是字节。这个函数是可选的，并且在不需要时可以省略。但是如果它被省略，接下来的三个函数也必须被省略，因为不会为FDW分配共享内存。
    </para>
<!-- pgdoc-cn_end sig_en=c20142ab887f11d4a94d831bfa2d4e5e -->

<!-- pgdoc-cn_start sig_en=86a75ba11c2a97ee76bfe6fa8567146a sig_cn_org=None source=14.1 
    <para>
<programlisting>
void
InitializeDSMForeignScan(ForeignScanState *node, ParallelContext *pcxt,
                         void *coordinate);
</programlisting>
    Initialize the dynamic shared memory that will be required for parallel
    operation.  <literal>coordinate</literal> points to a shared memory area of
    size equal to the return value of <function>EstimateDSMForeignScan</function>.
    This function is optional, and can be omitted if not needed.
   </para>
________________________________________________________-->
    <para>
<programlisting>
void
InitializeDSMForeignScan(ForeignScanState *node, ParallelContext *pcxt,
                         void *coordinate);
</programlisting>
    初始化并行操作所需的动态共享内存。<literal>coordinate</literal>指向一块共享内存区域，其尺寸等于<function>EstimateDSMForeignScan</function>的返回值。这个函数是可选的，并且在不需要时可以省略。
   </para>
<!-- pgdoc-cn_end sig_en=86a75ba11c2a97ee76bfe6fa8567146a -->

<!-- pgdoc-cn_start sig_en=edca0b79c2989499a013c98ec38ef4d9 sig_cn_org=None source=14.1 
    <para>
<programlisting>
void
ReInitializeDSMForeignScan(ForeignScanState *node, ParallelContext *pcxt,
                           void *coordinate);
</programlisting>
    Re-initialize the dynamic shared memory required for parallel operation
    when the foreign-scan plan node is about to be re-scanned.
    This function is optional, and can be omitted if not needed.
    Recommended practice is that this function reset only shared state,
    while the <function>ReScanForeignScan</function> function resets only local
    state.  Currently, this function will be called
    before <function>ReScanForeignScan</function>, but it's best not to rely on
    that ordering.
   </para>
________________________________________________________-->
    <para>
<programlisting>
void
ReInitializeDSMForeignScan(ForeignScanState *node, ParallelContext *pcxt,
                           void *coordinate);
</programlisting>
    当外部扫描计划将要被重新扫描时，重新初始化并行操作所要求的动态共享内存。这个函数是可选的，并且在不需要时可以省略。推荐的措施是这个函数只重置共享状态，而<function>ReScanForeignScan</function>函数仅重置本地状态。当前，这个函数将在<function>ReScanForeignScan</function>之前被调用，但是最好不要依赖于这种顺序。
   </para>
<!-- pgdoc-cn_end sig_en=edca0b79c2989499a013c98ec38ef4d9 -->

<!-- pgdoc-cn_start sig_en=b375b74ef70dba84a691e1e6add235f9 sig_cn_org=None source=14.1 
   <para>
<programlisting>
void
InitializeWorkerForeignScan(ForeignScanState *node, shm_toc *toc,
                            void *coordinate);
</programlisting>
    Initialize a parallel worker's local state based on the shared state
    set up by the leader during <function>InitializeDSMForeignScan</function>.
    This function is optional, and can be omitted if not needed.
   </para>
________________________________________________________-->
   <para>
<programlisting>
void
InitializeWorkerForeignScan(ForeignScanState *node, shm_toc *toc,
                            void *coordinate);
</programlisting>
    基于领导者在<function>InitializeDSMForeignScan</function>期间建立的共享状态初始化并行工作者的本地状态。这个函数是可选的，并且在不需要时可以省略。
   </para>
<!-- pgdoc-cn_end sig_en=b375b74ef70dba84a691e1e6add235f9 -->

<!-- pgdoc-cn_start sig_en=e47fd8f2ad32e8a7cafae24c996a20c6 sig_cn_org=None source=14.1 
   <para>
<programlisting>
void
ShutdownForeignScan(ForeignScanState *node);
</programlisting>
    Release resources when it is anticipated the node will not be executed
    to completion.  This is not called in all cases; sometimes,
    <literal>EndForeignScan</literal> may be called without this function having
    been called first.  Since the DSM segment used by parallel query is
    destroyed just after this callback is invoked, foreign data wrappers that
    wish to take some action before the DSM segment goes away should implement
    this method.
   </para>
________________________________________________________-->
   <para>
<programlisting>
void
ShutdownForeignScan(ForeignScanState *node);
</programlisting>
    在预见到节点将不会被执行完时释放资源。这个函数不会在所有的情况中执行，有时会在没有先调用这个函数之前调用<literal>EndForeignScan</literal>。由于在这个回调被调用之后并行查询使用的DSM段将被销毁，希望在DMS段消失前采取某种行动的外部数据包装器应该实现这个方法。
   </para>
<!-- pgdoc-cn_end sig_en=e47fd8f2ad32e8a7cafae24c996a20c6 -->
   </sect2>

   <sect2 id="fdw-callbacks-async">
<!-- pgdoc-cn_start sig_en=ac058e1cbeb1d4b394ead595d9b143c4 sig_cn_org=None source=14.1 
    <title>FDW Routines for Asynchronous Execution</title>
________________________________________________________-->
    <title>FDW Routines for Asynchronous Execution</title>
<!-- pgdoc-cn_end sig_en=ac058e1cbeb1d4b394ead595d9b143c4 -->
<!-- pgdoc-cn_start sig_en=22b68394383cf3c7efee162f1a7c9149 sig_cn_org=None source=14.1 
    <para>
     A <structname>ForeignScan</structname> node can, optionally, support
     asynchronous execution as described in
     <filename>src/backend/executor/README</filename>.  The following
     functions are all optional, but are all required if asynchronous
     execution is to be supported.
    </para>
________________________________________________________-->
    <para>
     <structname>ForeignScan</structname>节点能够，可选的，支持异步执行，就像<filename>src/backend/executor/README</filename>中所描述的那样。
     以下函数都是可选的，但是如果要支持异步执行，则都是必需的。
    </para>
<!-- pgdoc-cn_end sig_en=22b68394383cf3c7efee162f1a7c9149 -->

<!-- pgdoc-cn_start sig_en=992497031b9232d376ef235f5f7b6733 sig_cn_org=None source=14.1 
    <para>
<programlisting>
bool
IsForeignPathAsyncCapable(ForeignPath *path);
</programlisting>
     Test whether a given <structname>ForeignPath</structname> path can scan
     the underlying foreign relation asynchronously.
     This function will only be called at the end of query planning when the
     given path is a direct child of an <structname>AppendPath</structname>
     path and when the planner believes that asynchronous execution improves
     performance, and should return true if the given path is able to scan the
     foreign relation asynchronously.
    </para>
________________________________________________________-->
    <para>
<programlisting>
bool
IsForeignPathAsyncCapable(ForeignPath *path);
</programlisting>
     测试给定的<structname>ForeignPath</structname>路径是否可以异步扫描底层外部关系。
     当给定路径是<structname>AppendPath</structname>路径的直接子路径，并且计划器认为异步执行提高性能时，才会在查询计划结束时调用该函数。
     如果给出的路径能够异步扫描外部关系，则将返回真。
    </para>
<!-- pgdoc-cn_end sig_en=992497031b9232d376ef235f5f7b6733 -->

<!-- pgdoc-cn_start sig_en=bffa8f84827fdffaaf105883b31f4f4c sig_cn_org=None source=14.1 
    <para>
     If this function is not defined, it is assumed that the given path scans
     the foreign relation using <function>IterateForeignScan</function>.
     (This implies that the callback functions described below will never be
     called, so they need not be provided either.)
    </para>
________________________________________________________-->
    <para>
     如果这个函数没有被定义，则假定给定的路径使用<function>IterateForeignScan</function>扫描外部关系。
     (这意味着下面描述的回调函数将永远不会被调用，因此它们也不需要被提供。)
    </para>
<!-- pgdoc-cn_end sig_en=bffa8f84827fdffaaf105883b31f4f4c -->

<!-- pgdoc-cn_start sig_en=d7ba7fe59de9d004a57c8d697b112bb5 sig_cn_org=None source=14.1 
    <para>
<programlisting>
void
ForeignAsyncRequest(AsyncRequest *areq);
</programlisting>
     Produce one tuple asynchronously from the
     <structname>ForeignScan</structname> node.  <literal>areq</literal> is
     the <structname>AsyncRequest</structname> struct describing the
     <structname>ForeignScan</structname> node and the parent
     <structname>Append</structname> node that requested the tuple from it.
     This function should store the tuple into the slot specified by
     <literal>areq-&gt;result</literal>, and set
     <literal>areq-&gt;request_complete</literal> to <literal>true</literal>;
     or if it needs to wait on an event external to the core server such as
     network I/O, and cannot produce any tuple immediately, set the flag to
     <literal>false</literal>, and set
     <literal>areq-&gt;callback_pending</literal> to <literal>true</literal>
     for the <structname>ForeignScan</structname> node to get a callback from
     the callback functions described below.  If no more tuples are available,
     set the slot to NULL or an empty slot, and the
     <literal>areq-&gt;request_complete</literal> flag to
     <literal>true</literal>.  It's recommended to use
     <function>ExecAsyncRequestDone</function> or
     <function>ExecAsyncRequestPending</function> to set the output parameters
     in the <literal>areq</literal>.
    </para>
________________________________________________________-->
    <para>
<programlisting>
void
ForeignAsyncRequest(AsyncRequest *areq);
</programlisting>
     从<structname>ForeignScan</structname>节点异步的生成一个元组。
     <literal>areq</literal>是描述<structname>ForeignScan</structname>节点和父<structname>Append</structname>节点请求元组的<structname>AsyncRequest</structname>结构。
     该函数应该将元组存储在<literal>areq-&gt;result</literal>指定的槽中，并将<literal>areq-&gt;request_complete</literal>设置为<literal>true</literal>；或者如果它需要等待核心服务器外部的事件，例如网络I/O，并且不能立刻生成任何元组，则将设置标记为<literal>false</literal>，并且将<literal>areq-&gt;callback_pending</literal>设置为<literal>true</literal>，以便<structname>ForeignScan</structname>节点从下面描述的回调函数中获取回调。
     如果没有更多的元组可用，则将槽位设置为NULL或空槽位，以及将<literal>areq-&gt;request_complete</literal>标志设置为<literal>true</literal>。
     建议使用<function>ExecAsyncRequestDone</function> 或 <function>ExecAsyncRequestPending</function>来设置<literal>areq</literal>中的输出参数。
    </para>
<!-- pgdoc-cn_end sig_en=d7ba7fe59de9d004a57c8d697b112bb5 -->

<!-- pgdoc-cn_start sig_en=20e027d91447482e90f0a7e50a35fb7e sig_cn_org=None source=14.1 
    <para>
<programlisting>
void
ForeignAsyncConfigureWait(AsyncRequest *areq);
</programlisting>
     Configure a file descriptor event for which the
     <structname>ForeignScan</structname> node wishes to wait.
     This function will only be called when the
     <structname>ForeignScan</structname> node has the
     <literal>areq-&gt;callback_pending</literal> flag set, and should add
     the event to the <structfield>as_eventset</structfield> of the parent
     <structname>Append</structname> node described by the
     <literal>areq</literal>.  See the comments for
     <function>ExecAsyncConfigureWait</function> in
     <filename>src/backend/executor/execAsync.c</filename> for additional
     information.  When the file descriptor event occurs,
     <function>ForeignAsyncNotify</function> will be called.
    </para>
________________________________________________________-->
    <para>
<programlisting>
void
ForeignAsyncConfigureWait(AsyncRequest *areq);
</programlisting>
     配置一个为了<structname>ForeignScan</structname> 节点希望等待的文件描述符事件。
     只有当<structname>ForeignScan</structname>节点具有<literal>areq-&gt;callback_pending</literal>标志设置时，这个函数将会被调用，并且应该将事件添加到由<literal>areq</literal>描述的父<structname>Append</structname>节点的<structfield>as_eventset</structfield> 中。
     更多的信息，请参阅针对<filename>src/backend/executor/execAsync.c</filename>中的<function>ExecAsyncConfigureWait</function>的注释。
     当文件描述符事件发生时，<function>ForeignAsyncNotify</function>将被调用。
    </para>
<!-- pgdoc-cn_end sig_en=20e027d91447482e90f0a7e50a35fb7e -->

<!-- pgdoc-cn_start sig_en=5baf1ff39d811e23ee923f3ece27cb1e sig_cn_org=None source=14.1 
    <para>
<programlisting>
void
ForeignAsyncNotify(AsyncRequest *areq);
</programlisting>
     Process a relevant event that has occurred, then produce one tuple
     asynchronously from the <structname>ForeignScan</structname> node.
     This function should set the output parameters in the
     <literal>areq</literal> in the same way as
     <function>ForeignAsyncRequest</function>.
    </para>
________________________________________________________-->
    <para>
<programlisting>
void
ForeignAsyncNotify(AsyncRequest *areq);
</programlisting>
     处理已经发生的相关事件，然后从<structname>ForeignScan</structname>节点异步的生成一个元组。
     该函数将设置<literal>areq</literal> 中的输出参数，与<function>ForeignAsyncRequest</function>的方法相同。
    </para>
<!-- pgdoc-cn_end sig_en=5baf1ff39d811e23ee923f3ece27cb1e -->
   </sect2>

   <sect2 id="fdw-callbacks-reparameterize-paths">
<!-- pgdoc-cn_start sig_en=8e50e78684af562dba7265fa6e76f669 sig_cn_org=None source=14.1 
    <title>FDW Routines for Reparameterization of Paths</title>
________________________________________________________-->
    <title>用于路径重新参数化的FDW例程</title>
<!-- pgdoc-cn_end sig_en=8e50e78684af562dba7265fa6e76f669 -->

<!-- pgdoc-cn_start sig_en=0c6e2c7003360a5e0befc808a55391c9 sig_cn_org=None source=14.1 
    <para>
<programlisting>
List *
ReparameterizeForeignPathByChild(PlannerInfo *root, List *fdw_private,
                                 RelOptInfo *child_rel);
</programlisting>
    This function is called while converting a path parameterized by the
    top-most parent of the given child relation <literal>child_rel</literal> to be
    parameterized by the child relation. The function is used to reparameterize
    any paths or translate any expression nodes saved in the given
    <literal>fdw_private</literal> member of a <structname>ForeignPath</structname>. The
    callback may use <literal>reparameterize_path_by_child</literal>,
    <literal>adjust_appendrel_attrs</literal> or
    <literal>adjust_appendrel_attrs_multilevel</literal> as required.
    </para>
________________________________________________________-->
    <para>
<programlisting>
List *
ReparameterizeForeignPathByChild(PlannerInfo *root, List *fdw_private,
                                 RelOptInfo *child_rel);
</programlisting>
    在把一个由给定子关系<literal>child_rel</literal>的最顶层父关系参数化的路径转换成由该子关系参数化的路径时会调用这个函数。该函数被用于重新参数化任意路径或者转化一个<structname>ForeignPath</structname>的给定<literal>fdw_private</literal>成员中保存的任意表达式节点。该回调可能会根据需要使用<literal>reparameterize_path_by_child</literal>、<literal>adjust_appendrel_attrs</literal>或者<literal>adjust_appendrel_attrs_multilevel</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=0c6e2c7003360a5e0befc808a55391c9 -->
   </sect2>

   </sect1>

   <sect1 id="fdw-helpers">
<!-- pgdoc-cn_start sig_en=92530c80199dc5ae7b128faa13f3a609 sig_cn_org=None source=14.1 
    <title>Foreign Data Wrapper Helper Functions</title>
________________________________________________________-->
    <title>外部数据包装器助手函数</title>
<!-- pgdoc-cn_end sig_en=92530c80199dc5ae7b128faa13f3a609 -->

<!-- pgdoc-cn_start sig_en=42d1a0645c765235dce5402a01a5f3dd sig_cn_org=None source=14.1 
    <para>
     Several helper functions are exported from the core server so that
     authors of foreign data wrappers can get easy access to attributes of
     FDW-related objects, such as FDW options.
     To use any of these functions, you need to include the header file
     <filename>foreign/foreign.h</filename> in your source file.
     That header also defines the struct types that are returned by
     these functions.
    </para>
________________________________________________________-->
    <para>
     多个助手函数被从核心服务器输出，这样外部数据包装器的作者们可以很容易访问到FDW相关对象的属性，例如FDW选项。要使用任何其中一个函数，你需要在你的源文件中包括头文件<filename>foreign/foreign.h</filename>。这个头也定义了被这些函数返回的结构类型。
    </para>
<!-- pgdoc-cn_end sig_en=42d1a0645c765235dce5402a01a5f3dd -->

<!-- pgdoc-cn_start sig_en=e560eb43b89a893188aeba9e0592ad36 sig_cn_org=None source=14.1 
    <para>
<programlisting>
ForeignDataWrapper *
GetForeignDataWrapperExtended(Oid fdwid, bits16 flags);
</programlisting>

     This function returns a <structname>ForeignDataWrapper</structname>
     object for the foreign-data wrapper with the given OID.  A
     <structname>ForeignDataWrapper</structname> object contains properties
     of the FDW (see <filename>foreign/foreign.h</filename> for details).
     <structfield>flags</structfield> is a bitwise-or'd bit mask indicating
     an extra set of options.  It can take the value
     <literal>FDW_MISSING_OK</literal>, in which case a <literal>NULL</literal>
     result is returned to the caller instead of an error for an undefined
     object.
    </para>
________________________________________________________-->
    <para>
<programlisting>
ForeignDataWrapper *
GetForeignDataWrapperExtended(Oid fdwid, bits16 flags);
</programlisting>

     此功能返回具有给定 OID 的外数据包装器的<structname>ForeignDataWrapper</structname>对象。
     <structname>ForeignDataWrapper</structname>对象包含 FDW 的属性（详细信息请参阅<filename>foreign/foreign.h</filename>）。
     <structfield>flags</structfield>是一个 bitwise-or'd位掩码，指示一组外加的选项集。
     它可以取值<literal>FDW_MISSING_OK</literal>，在这种情况下<literal>NULL</literal> 结果将返回给调用方，而不是返回错误给未定义的对象。
    </para>
<!-- pgdoc-cn_end sig_en=e560eb43b89a893188aeba9e0592ad36 -->

<!-- pgdoc-cn_start sig_en=db569d77ae75d47b2bdbd732798870a8 sig_cn_org=None source=14.1 
    <para>
<programlisting>
ForeignDataWrapper *
GetForeignDataWrapper(Oid fdwid);
</programlisting>

     This function returns a <structname>ForeignDataWrapper</structname>
     object for the foreign-data wrapper with the given OID.  A
     <structname>ForeignDataWrapper</structname> object contains properties
     of the FDW (see <filename>foreign/foreign.h</filename> for details).
    </para>
________________________________________________________-->
    <para>
<programlisting>
ForeignDataWrapper *
GetForeignDataWrapper(Oid fdwid);
</programlisting>

     这个函数为具有给定 OID 的外部数据包装器返回一个<structname>ForeignDataWrapper</structname>对象。一个<structname>ForeignDataWrapper</structname>对象包含该FDW的特性（详见<filename>foreign/foreign.h</filename>）。
    </para>
<!-- pgdoc-cn_end sig_en=db569d77ae75d47b2bdbd732798870a8 -->

<!-- pgdoc-cn_start sig_en=ac34fce13182e2d6ae48a5659739777e sig_cn_org=None source=14.1 
    <para>
<programlisting>
ForeignServer *
GetForeignServerExtended(Oid serverid, bits16 flags);
</programlisting>

     This function returns a <structname>ForeignServer</structname> object
     for the foreign server with the given OID.  A
     <structname>ForeignServer</structname> object contains properties
     of the server (see <filename>foreign/foreign.h</filename> for details).
     <structfield>flags</structfield> is a bitwise-or'd bit mask indicating
     an extra set of options.  It can take the value
     <literal>FSV_MISSING_OK</literal>, in which case a <literal>NULL</literal>
     result is returned to the caller instead of an error for an undefined
     object.
    </para>
________________________________________________________-->
    <para>
<programlisting>
ForeignServer *
GetForeignServerExtended(Oid serverid, bits16 flags);
</programlisting>

     此功能返回具有给定 OID 的外数据包装器的<structname>ForeignServer</structname>对象。
     <structname>ForeignServer</structname>对象包含 FDW 的属性（详细信息请参阅<filename>foreign/foreign.h</filename>）。
     <structfield>flags</structfield>是一个 bitwise-or'd位掩码，指示一组外加的选项集。
     它可以取值<literal>FDW_MISSING_OK</literal>，在这种情况下<literal>NULL</literal> 结果将返回给调用方，而不是返回错误给未定义的对象。
    </para>
<!-- pgdoc-cn_end sig_en=ac34fce13182e2d6ae48a5659739777e -->

<!-- pgdoc-cn_start sig_en=ac51ff3ddf41472ec63b86ed355a736c sig_cn_org=None source=14.1 
    <para>
<programlisting>
ForeignServer *
GetForeignServer(Oid serverid);
</programlisting>

     This function returns a <structname>ForeignServer</structname> object
     for the foreign server with the given OID.  A
     <structname>ForeignServer</structname> object contains properties
     of the server (see <filename>foreign/foreign.h</filename> for details).
    </para>
________________________________________________________-->
    <para>
<programlisting>
ForeignServer *
GetForeignServer(Oid serverid);
</programlisting>

     这个函数为一个具有给定 OID 的外部服务器返回<structname>ForeignServer</structname>对象。一个<structname>ForeignServer</structname>对象包含该服务器的特性（详见<filename>foreign/foreign.h</filename>）。
    </para>
<!-- pgdoc-cn_end sig_en=ac51ff3ddf41472ec63b86ed355a736c -->

<!-- pgdoc-cn_start sig_en=a96385a5adfc34b80a18b0df6865a589 sig_cn_org=None source=14.1 
    <para>
<programlisting>
UserMapping *
GetUserMapping(Oid userid, Oid serverid);
</programlisting>

     This function returns a <structname>UserMapping</structname> object for
     the user mapping of the given role on the given server.  (If there is no
     mapping for the specific user, it will return the mapping for
     <literal>PUBLIC</literal>, or throw error if there is none.)  A
     <structname>UserMapping</structname> object contains properties of the
     user mapping (see <filename>foreign/foreign.h</filename> for details).
    </para>
________________________________________________________-->
    <para>
<programlisting>
UserMapping *
GetUserMapping(Oid userid, Oid serverid);
</programlisting>

     这个函数为在给定服务器上的给定角色的用户映射返回<structname>UserMapping</structname>对象（如果指定用户没有映射，它将返回<literal>PUBLIC</literal>的映射，如果也没有则抛出错误）。一个<structname>UserMapping</structname>对象包含该用户映射的特性（详见<filename>foreign/foreign.h</filename>）。
    </para>
<!-- pgdoc-cn_end sig_en=a96385a5adfc34b80a18b0df6865a589 -->

<!-- pgdoc-cn_start sig_en=f97bc7c167e8bc4786d6c221d289fd57 sig_cn_org=None source=14.1 
    <para>
<programlisting>
ForeignTable *
GetForeignTable(Oid relid);
</programlisting>

     This function returns a <structname>ForeignTable</structname> object for
     the foreign table with the given OID.  A
     <structname>ForeignTable</structname> object contains properties of the
     foreign table (see <filename>foreign/foreign.h</filename> for details).
    </para>
________________________________________________________-->
    <para>
<programlisting>
ForeignTable *
GetForeignTable(Oid relid);
</programlisting>

     该函数为一个具有给定 OID 的外部表返回<structname>ForeignTable</structname>对象。一个<structname>ForeignTable</structname>对象包含该外部表的特性（详见<filename>foreign/foreign.h</filename>）。
    </para>
<!-- pgdoc-cn_end sig_en=f97bc7c167e8bc4786d6c221d289fd57 -->

<!-- pgdoc-cn_start sig_en=7fe23accc8bd036bf9789cf230a9ba1f sig_cn_org=None source=14.1 
    <para>
<programlisting>
List *
GetForeignColumnOptions(Oid relid, AttrNumber attnum);
</programlisting>

     This function returns the per-column FDW options for the column with the
     given foreign table OID and attribute number, in the form of a list of
     <structname>DefElem</structname>.  NIL is returned if the column has no
     options.
    </para>
________________________________________________________-->
    <para>
<programlisting>
List *
GetForeignColumnOptions(Oid relid, AttrNumber attnum);
</programlisting>

     这个函数为一个具有给定外部表 OID 和属性号的列返回针对每一列的FDW选项，形式为一个<structname>DefElem</structname>列表。如果该列没有选项则返回 NIL。
    </para>
<!-- pgdoc-cn_end sig_en=7fe23accc8bd036bf9789cf230a9ba1f -->

<!-- pgdoc-cn_start sig_en=d478808a6c5a11be5b1d6b51a905aa14 sig_cn_org=None source=14.1 
    <para>
     Some object types have name-based lookup functions in addition to the
     OID-based ones:
    </para>
________________________________________________________-->
    <para>
     某些对象类型除了基于OID的查找函数之外，还具有基于名称的查找函数：
    </para>
<!-- pgdoc-cn_end sig_en=d478808a6c5a11be5b1d6b51a905aa14 -->

<!-- pgdoc-cn_start sig_en=ca3655a1a380f7b7d79169520e770067 sig_cn_org=None source=14.1 
    <para>
<programlisting>
ForeignDataWrapper *
GetForeignDataWrapperByName(const char *name, bool missing_ok);
</programlisting>

     This function returns a <structname>ForeignDataWrapper</structname>
     object for the foreign-data wrapper with the given name.  If the wrapper
     is not found, return NULL if missing_ok is true, otherwise raise an
     error.
    </para>
________________________________________________________-->
    <para>
<programlisting>
ForeignDataWrapper *
GetForeignDataWrapperByName(const char *name, bool missing_ok);
</programlisting>

     这个函数为一个具有给定名称的外部数据包装器返回<structname>ForeignDataWrapper</structname>对象。如果包装器没有找到，在missing_ok为真时返回 NULL，否则抛出一个错误。
    </para>
<!-- pgdoc-cn_end sig_en=ca3655a1a380f7b7d79169520e770067 -->

<!-- pgdoc-cn_start sig_en=5945fa70e3ef2e54df4c16e4ef06c772 sig_cn_org=None source=14.1 
    <para>
<programlisting>
ForeignServer *
GetForeignServerByName(const char *name, bool missing_ok);
</programlisting>

     This function returns a <structname>ForeignServer</structname> object
     for the foreign server with the given name.  If the server is not found,
     return NULL if missing_ok is true, otherwise raise an error.
    </para>
________________________________________________________-->
    <para>
<programlisting>
ForeignServer *
GetForeignServerByName(const char *name, bool missing_ok);
</programlisting>

     这个函数为一个具有给定名称的外部服务器返回<structname>ForeignServer</structname>对象。如果该服务器没有被找到，在missing_ok为真时返回 NULL，否则抛出一个错误。
    </para>
<!-- pgdoc-cn_end sig_en=5945fa70e3ef2e54df4c16e4ef06c772 -->

   </sect1>

   <sect1 id="fdw-planning">
<!-- pgdoc-cn_start sig_en=45c9c0e9a848cedf05c55c279b0d8834 sig_cn_org=None source=14.1 
    <title>Foreign Data Wrapper Query Planning</title>
________________________________________________________-->
    <title>外部数据包装器查询规划</title>
<!-- pgdoc-cn_end sig_en=45c9c0e9a848cedf05c55c279b0d8834 -->

<!-- pgdoc-cn_start sig_en=46a01929db0af29db576c47d2de15458 sig_cn_org=None source=14.1 
    <para>
     The FDW callback functions <function>GetForeignRelSize</function>,
     <function>GetForeignPaths</function>, <function>GetForeignPlan</function>,
     <function>PlanForeignModify</function>, <function>GetForeignJoinPaths</function>,
     <function>GetForeignUpperPaths</function>, and <function>PlanDirectModify</function>
     must fit into the workings of the <productname>PostgreSQL</productname> planner.
     Here are some notes about what they must do.
    </para>
________________________________________________________-->
    <para>
     FDW回调函数<function>GetForeignRelSize</function>、<function>GetForeignPaths</function>、<function>GetForeignPlan</function>、<function>PlanForeignModify</function>、<function>GetForeignJoinPaths</function>、<function>GetForeignUpperPaths</function>以及<function>PlanDirectModify</function>必须适合<productname>PostgreSQL</productname>规划器的工作。这里有一些关于它们必须做什么的注记。
    </para>
<!-- pgdoc-cn_end sig_en=46a01929db0af29db576c47d2de15458 -->

<!-- pgdoc-cn_start sig_en=c6bf7cff23da5edc3b0110236f503018 sig_cn_org=None source=14.1 
    <para>
     The information in <literal>root</literal> and <literal>baserel</literal> can be used
     to reduce the amount of information that has to be fetched from the
     foreign table (and therefore reduce the cost).
     <literal>baserel-&gt;baserestrictinfo</literal> is particularly interesting, as
     it contains restriction quals (<literal>WHERE</literal> clauses) that should be
     used to filter the rows to be fetched.  (The FDW itself is not required
     to enforce these quals, as the core executor can check them instead.)
     <literal>baserel-&gt;reltarget-&gt;exprs</literal> can be used to determine which
     columns need to be fetched; but note that it only lists columns that
     have to be emitted by the <structname>ForeignScan</structname> plan node, not
     columns that are used in qual evaluation but not output by the query.
    </para>
________________________________________________________-->
    <para>
     <literal>root</literal>和<literal>baserel</literal>中的信息可以被用来减少必须从外部表获得的信息量（并且因此降低代价）。<literal>baserel-&gt;baserestrictinfo</literal>是特别有趣的，因为它包含限制条件（<literal>WHERE</literal>）子句，它应该被用来过滤要被获取的行（FDW本身并不要求强制这些条件，因为核心执行器可以检查它们）。<literal>baserel-&gt;reltarget-&gt;exprs</literal>可以被用来决定哪些类需要被获取；但是注意它仅列出了<structname>ForeignScan</structname>计划节点所发出的列，不包含在条件计算中使用但并不被查询输出的列。
    </para>
<!-- pgdoc-cn_end sig_en=c6bf7cff23da5edc3b0110236f503018 -->

<!-- pgdoc-cn_start sig_en=4f16029881c18859966db0b9bac2c055 sig_cn_org=None source=14.1 
    <para>
     Various private fields are available for the FDW planning functions to
     keep information in.  Generally, whatever you store in FDW private fields
     should be palloc'd, so that it will be reclaimed at the end of planning.
    </para>
________________________________________________________-->
    <para>
     有多个私有域可以给FDW规划函数来保存信息。通常，不管你存储什么在FDW私有域中，它们都应该被palloc，这样它会在规划结束时被回收。    </para>
<!-- pgdoc-cn_end sig_en=4f16029881c18859966db0b9bac2c055 -->

<!-- pgdoc-cn_start sig_en=0b20c7708d209eebe1299ede9081b0c4 sig_cn_org=None source=14.1 
    <para>
     <literal>baserel-&gt;fdw_private</literal> is a <type>void</type> pointer that is
     available for FDW planning functions to store information relevant to
     the particular foreign table.  The core planner does not touch it except
     to initialize it to NULL when the <literal>RelOptInfo</literal> node is created.
     It is useful for passing information forward from
     <function>GetForeignRelSize</function> to <function>GetForeignPaths</function> and/or
     <function>GetForeignPaths</function> to <function>GetForeignPlan</function>, thereby
     avoiding recalculation.
    </para>
________________________________________________________-->
    <para>
     <literal>baserel-&gt;fdw_private</literal>是一个<type>void</type>指针，它可以被FDW规划函数用来存储与特定外部表相关的信息。核心规划器不会碰它除非当<literal>RelOptInfo</literal>节点被创建时把它初始化为NULL。它对从<function>GetForeignRelSize</function>传递信息给<function>GetForeignPaths</function>和/或从<function>GetForeignPaths</function>传递信息给<function>GetForeignPlan</function>非常有用，这样避免了重新计算。
    </para>
<!-- pgdoc-cn_end sig_en=0b20c7708d209eebe1299ede9081b0c4 -->

<!-- pgdoc-cn_start sig_en=75d6b085cd0b6e6ad74dd94487378de8 sig_cn_org=None source=14.1 
    <para>
     <function>GetForeignPaths</function> can identify the meaning of different
     access paths by storing private information in the
     <structfield>fdw_private</structfield> field of <structname>ForeignPath</structname> nodes.
     <structfield>fdw_private</structfield> is declared as a <type>List</type> pointer, but
     could actually contain anything since the core planner does not touch
     it.  However, best practice is to use a representation that's dumpable
     by <function>nodeToString</function>, for use with debugging support available
     in the backend.
    </para>
________________________________________________________-->
    <para>
     <function>GetForeignPaths</function>可以通过在<structname>ForeignPath</structname>节点的<structfield>fdw_private</structfield>域中存储私有信息来标识不同的访问路径。<structfield>fdw_private</structfield>被声明为一个<type>List</type>指针，但是可能实际上包含任何东西，因为规划器不会触碰它。但是，最好是使用一种<function>nodeToString</function>可导出的形式，这样在后端可以用于调试支持。
    </para>
<!-- pgdoc-cn_end sig_en=75d6b085cd0b6e6ad74dd94487378de8 -->

<!-- pgdoc-cn_start sig_en=35151fe666791245fef74d3b52fce26d sig_cn_org=None source=14.1 
    <para>
     <function>GetForeignPlan</function> can examine the <structfield>fdw_private</structfield>
     field of the selected <structname>ForeignPath</structname> node, and can generate
     <structfield>fdw_exprs</structfield> and <structfield>fdw_private</structfield> lists to be
     placed in the <structname>ForeignScan</structname> plan node, where they will be
     available at execution time.  Both of these lists must be
     represented in a form that <function>copyObject</function> knows how to copy.
     The <structfield>fdw_private</structfield> list has no other restrictions and is
     not interpreted by the core backend in any way.  The
     <structfield>fdw_exprs</structfield> list, if not NIL, is expected to contain
     expression trees that are intended to be executed at run time.  These
     trees will undergo post-processing by the planner to make them fully
     executable.
    </para>
________________________________________________________-->
    <para>
     <function>GetForeignPlan</function>可以检查选中的<structname>ForeignPath</structname>节点的<structfield>fdw_private</structfield>域，并且可以生成被放置于<structname>ForeignPath</structname>计划节点中的<structfield>fdw_exprs</structfield>和<structfield>fdw_private</structfield>列表。这两个列表必须被表示为一种<function>copyObject</function>可复制的形式。<structfield>fdw_private</structfield>列表没有任何其他限制并且不会被核心后端以任何形式解释。非 NIL 的<structfield>fdw_exprs</structfield>应该包含表达式树，该树会在运行时被执行。这些树将由规划器在后期处理，以便让它们变成完全可执行的。
    </para>
<!-- pgdoc-cn_end sig_en=35151fe666791245fef74d3b52fce26d -->

<!-- pgdoc-cn_start sig_en=64c0cb6598a4a0add69518edc13a8532 sig_cn_org=None source=14.1 
    <para>
     In <function>GetForeignPlan</function>, generally the passed-in target list can
     be copied into the plan node as-is.  The passed <literal>scan_clauses</literal> list
     contains the same clauses as <literal>baserel-&gt;baserestrictinfo</literal>,
     but may be re-ordered for better execution efficiency.  In simple cases
     the FDW can just strip <structname>RestrictInfo</structname> nodes from the
     <literal>scan_clauses</literal> list (using <function>extract_actual_clauses</function>) and put
     all the clauses into the plan node's qual list, which means that all the
     clauses will be checked by the executor at run time.  More complex FDWs
     may be able to check some of the clauses internally, in which case those
     clauses can be removed from the plan node's qual list so that the
     executor doesn't waste time rechecking them.
    </para>
________________________________________________________-->
    <para>
     在<function>GetForeignPlan</function>中，通常被传入的目标列表可以被照样复制到计划节点中。被传入的<literal>scan_clauses</literal> 列表包含和<literal>baserel-&gt;baserestrictinfo</literal>相同的子句，但是可能为了更好的执行效率会被重新排序。在简单情况下，FDW可以只把<structname>RestrictInfo</structname>节点从<literal>scan_clauses</literal> 列表剥离（使用<function>extract_actual_clauses</function>）并且把所有子句放到计划节点的条件列表中，这意味着所有子句将在运行时由执行器检查。更复杂的FDW可能可以在内部检查某些子句，着这种情况下哪些子句可以从计划节点的条件列表中删除，这样执行器就不用浪费时间去检查它们。
    </para>
<!-- pgdoc-cn_end sig_en=64c0cb6598a4a0add69518edc13a8532 -->

<!-- pgdoc-cn_start sig_en=60b4273e6aa084b5aab146da048527e2 sig_cn_org=None source=14.1 
    <para>
     As an example, the FDW might identify some restriction clauses of the
     form <replaceable>foreign_variable</replaceable> <literal>=</literal>
     <replaceable>sub_expression</replaceable>, which it determines can be executed on
     the remote server given the locally-evaluated value of the
     <replaceable>sub_expression</replaceable>.  The actual identification of such a
     clause should happen during <function>GetForeignPaths</function>, since it would
     affect the cost estimate for the path.  The path's
     <structfield>fdw_private</structfield> field would probably include a pointer to
     the identified clause's <structname>RestrictInfo</structname> node.  Then
     <function>GetForeignPlan</function> would remove that clause from <literal>scan_clauses</literal>,
     but add the <replaceable>sub_expression</replaceable> to <structfield>fdw_exprs</structfield>
     to ensure that it gets massaged into executable form.  It would probably
     also put control information into the plan node's
     <structfield>fdw_private</structfield> field to tell the execution functions what
     to do at run time.  The query transmitted to the remote server would
     involve something like <literal>WHERE <replaceable>foreign_variable</replaceable> =
     $1</literal>, with the parameter value obtained at run time from
     evaluation of the <structfield>fdw_exprs</structfield> expression tree.
    </para>
________________________________________________________-->
    <para>
     作为一个例子，FDW可以标识某些<replaceable>foreign_variable</replaceable> <literal>=</literal>
     <replaceable>sub_expression</replaceable>形式的限制子句，它决定哪些可以使用由<replaceable>sub_expression</replaceable>给出的本地计算值在远程服务器上被执行。这样一个子句的实际标识应该在<function>GetForeignPaths</function>期间发生，因为它可能会影响路径的代价估计。路径的<structfield>fdw_private</structfield>域可能包括一个已标识的子句的<structname>RestrictInfo</structname>节点。然后<function>GetForeignPlan</function>将从<literal>scan_clauses</literal> 中移除该子句，但是将<replaceable>sub_expression</replaceable>加到<structfield>fdw_exprs</structfield>来保证它被揉成可执行的形式。它可能还将把控制信息放入到计划节点的<structfield>fdw_private</structfield>域来告诉执行函数在运行时要做什么。传递给远程服务器的查询将涉及类似<literal>WHERE <replaceable>foreign_variable</replaceable> = $1</literal>的东西，使用在运行时从<structfield>fdw_exprs</structfield>表达式树获得的参数值。
    </para>
<!-- pgdoc-cn_end sig_en=60b4273e6aa084b5aab146da048527e2 -->

<!-- pgdoc-cn_start sig_en=5c3878652f56cc830d092b8f4661d519 sig_cn_org=None source=14.1 
    <para>
     Any clauses removed from the plan node's qual list must instead be added
     to <literal>fdw_recheck_quals</literal> or rechecked by
     <literal>RecheckForeignScan</literal> in order to ensure correct behavior
     at the <literal>READ COMMITTED</literal> isolation level.  When a concurrent
     update occurs for some other table involved in the query, the executor
     may need to verify that all of the original quals are still satisfied for
     the tuple, possibly against a different set of parameter values.  Using
     <literal>fdw_recheck_quals</literal> is typically easier than implementing checks
     inside <literal>RecheckForeignScan</literal>, but this method will be
     insufficient when outer joins have been pushed down, since the join tuples
     in that case might have some fields go to NULL without rejecting the
     tuple entirely.
    </para>
________________________________________________________-->
    <para>
     任何从该计划节点的条件列表移除的子句必须被加入到<literal>fdw_recheck_quals</literal>或者由<literal>RecheckForeignScan</literal>重新检查以便确保在<literal>READ COMMITTED</literal>隔离级别的正确行为。当查询中涉及的某个其他表上发生并发更新时，执行器可能需要验证原来的所有条件仍然对该元组满足（可能用一组不同的参数值）。使用<literal>fdw_recheck_quals</literal>通常比在<literal>RecheckForeignScan</literal>中实现检查要更容易，但是这种方法不足以应付外连接被下推的情况，因为那种情况下的连接元组可能会有一些域具有 NULL 但是不会导致整个元组被拒绝。
    </para>
<!-- pgdoc-cn_end sig_en=5c3878652f56cc830d092b8f4661d519 -->

<!-- pgdoc-cn_start sig_en=4c5fc94d63e53360e2838fcbfa79738c sig_cn_org=None source=14.1 
    <para>
     Another <structname>ForeignScan</structname> field that can be filled by FDWs
     is <structfield>fdw_scan_tlist</structfield>, which describes the tuples returned by
     the FDW for this plan node.  For simple foreign table scans this can be
     set to <literal>NIL</literal>, implying that the returned tuples have the
     row type declared for the foreign table.  A non-<symbol>NIL</symbol> value must be a
     target list (list of <structname>TargetEntry</structname>s) containing Vars and/or
     expressions representing the returned columns.  This might be used, for
     example, to show that the FDW has omitted some columns that it noticed
     won't be needed for the query.  Also, if the FDW can compute expressions
     used by the query more cheaply than can be done locally, it could add
     those expressions to <structfield>fdw_scan_tlist</structfield>.  Note that join
     plans (created from paths made by <function>GetForeignJoinPaths</function>) must
     always supply <structfield>fdw_scan_tlist</structfield> to describe the set of
     columns they will return.
    </para>
________________________________________________________-->
    <para>
     另一个可以由 FDW 填充的<structname>ForeignScan</structname>域是<structfield>fdw_scan_tlist</structfield>，它描述 FDW 为这个计划节点返回的元组。对于简单的外部表扫描这可以设置为<literal>NIL</literal>，表示返回的元组具有为外部表声明的行类型。非-<symbol>NIL</symbol>值必须是一个包含表示返回列的 Var 或表达式的目标列表（<structname>TargetEntry</structname>的列表）。例如，这可以被用来显示 FDW 省略了某些查询不需要的列。还有，如果 FDW 计算表达式比在本地计算代价更低，可以把那些表达式加入到<structfield>fdw_scan_tlist</structfield>。注意连接计划（从<function>GetForeignJoinPaths</function>创建的路径得到）必须总是提供<structfield>fdw_scan_tlist</structfield>来描述它们将返回的列集合。
    </para>
<!-- pgdoc-cn_end sig_en=4c5fc94d63e53360e2838fcbfa79738c -->

<!-- pgdoc-cn_start sig_en=81c8bcbb1a155fe9f6b1580ead032c70 sig_cn_org=None source=14.1 
    <para>
     The FDW should always construct at least one path that depends only on
     the table's restriction clauses.  In join queries, it might also choose
     to construct path(s) that depend on join clauses, for example
     <replaceable>foreign_variable</replaceable> <literal>=</literal>
     <replaceable>local_variable</replaceable>.  Such clauses will not be found in
     <literal>baserel-&gt;baserestrictinfo</literal> but must be sought in the
     relation's join lists.  A path using such a clause is called a
     <quote>parameterized path</quote>.  It must identify the other relations
     used in the selected join clause(s) with a suitable value of
     <literal>param_info</literal>; use <function>get_baserel_parampathinfo</function>
     to compute that value.  In <function>GetForeignPlan</function>, the
     <replaceable>local_variable</replaceable> portion of the join clause would be added
     to <structfield>fdw_exprs</structfield>, and then at run time the case works the
     same as for an ordinary restriction clause.
    </para>
________________________________________________________-->
    <para>
     FDW应该总是只依靠表的限制子句构建至少一个路径。在连接查询中，它可能还会选择依靠连接子句构建路径，例如<replaceable>foreign_variable</replaceable> <literal>=</literal> <replaceable>local_variable</replaceable>。这样的子句将不会在<literal>baserel-&gt;baserestrictinfo</literal>中找到，但是必须出现在关系的连接列表中。使用这样一个子句的路径被称为一个<quote>参数化路径</quote>。它必须用一个合适的<literal>param_info</literal>值来标识其他被使用在选中的连接子句中的关系；使用<function>get_baserel_parampathinfo</function>来计算该值。在<function>GetForeignPlan</function>中，连接子句的<replaceable>local_variable</replaceable>部分将被加到<structfield>fdw_exprs</structfield>中，并且接着在运行时和一个普通限制子句一样工作。
    </para>
<!-- pgdoc-cn_end sig_en=81c8bcbb1a155fe9f6b1580ead032c70 -->

<!-- pgdoc-cn_start sig_en=7974e09cd051189f33dde134b7cbcc6b sig_cn_org=None source=14.1 
    <para>
     If an FDW supports remote joins, <function>GetForeignJoinPaths</function> should
     produce <structname>ForeignPath</structname>s for potential remote joins in much
     the same way as <function>GetForeignPaths</function> works for base tables.
     Information about the intended join can be passed forward
     to <function>GetForeignPlan</function> in the same ways described above.
     However, <structfield>baserestrictinfo</structfield> is not relevant for join
     relations; instead, the relevant join clauses for a particular join are
     passed to <function>GetForeignJoinPaths</function> as a separate parameter
     (<literal>extra-&gt;restrictlist</literal>).
    </para>
________________________________________________________-->
    <para>
     如果一个 FDW 支持远程连接，<function>GetForeignJoinPaths</function>应该和<function>GetForeignPaths</function>对基本表所作的那样为潜在的远程连接产生<structname>ForeignPath</structname>。有关想要进行的连接的信息可以以上述相同的方式传递给<function>GetForeignPlan</function>。不过，<structfield>baserestrictinfo</structfield>与连接关系无关，一个特定连接的相关连接子句将被作为一个独立的参数（<literal>extra-&gt;restrictlist</literal>）被传递给<function>GetForeignJoinPaths</function>。
    </para>
<!-- pgdoc-cn_end sig_en=7974e09cd051189f33dde134b7cbcc6b -->

<!-- pgdoc-cn_start sig_en=c7bae155bc46c3af5d212ae0fcddbc60 sig_cn_org=None source=14.1 
    <para>
     An FDW might additionally support direct execution of some plan actions
     that are above the level of scans and joins, such as grouping or
     aggregation.  To offer such options, the FDW should generate paths and
     insert them into the appropriate <firstterm>upper relation</firstterm>.  For
     example, a path representing remote aggregation should be inserted into
     the <literal>UPPERREL_GROUP_AGG</literal> relation, using <function>add_path</function>.
     This path will be compared on a cost basis with local aggregation
     performed by reading a simple scan path for the foreign relation (note
     that such a path must also be supplied, else there will be an error at
     plan time).  If the remote-aggregation path wins, which it usually would,
     it will be converted into a plan in the usual way, by
     calling <function>GetForeignPlan</function>.  The recommended place to generate
     such paths is in the <function>GetForeignUpperPaths</function>
     callback function, which is called for each upper relation (i.e., each
     post-scan/join processing step), if all the base relations of the query
     come from the same FDW.
    </para>
________________________________________________________-->
    <para>
     FDW 可能会额外地支持直接执行某些在扫描和连接层次之上的计划动作，例如分组或者聚集。为了提供这类选项，FDW 应该生成路径并且把它们插入到合适的<firstterm>上层关系中</firstterm>。例如，一条表示远程聚集的路径应该被使用<function>add_path</function>插入到<literal>UPPERREL_GROUP_AGG</literal>关系中。这条路径的代价将会与通过读取外部关系的简单扫描路径的本地聚集（注意这样一条路径也必须被提供，否则规划时会有错误）进行比较。如果远程聚集路径胜出（通常是这样），它会被以通常的方式（调用<function>GetForeignPlan</function>）转化成计划。如果该查询的所有基本关系都来自于同一个 FDW，推荐在<function>GetForeignUpperPaths</function>回调函数中生成这种路径，该函数会为每一个上层关系被调用（即每一次扫描/连接后处理步骤）。
    </para>
<!-- pgdoc-cn_end sig_en=c7bae155bc46c3af5d212ae0fcddbc60 -->

<!-- pgdoc-cn_start sig_en=2e6fe6e3f3cd32425ac4f16d41b8060f sig_cn_org=None source=14.1 
    <para>
     <function>PlanForeignModify</function> and the other callbacks described in
     <xref linkend="fdw-callbacks-update"/> are designed around the assumption
     that the foreign relation will be scanned in the usual way and then
     individual row updates will be driven by a local <literal>ModifyTable</literal>
     plan node.  This approach is necessary for the general case where an
     update requires reading local tables as well as foreign tables.
     However, if the operation could be executed entirely by the foreign
     server, the FDW could generate a path representing that and insert it
     into the <literal>UPPERREL_FINAL</literal> upper relation, where it would
     compete against the <literal>ModifyTable</literal> approach.  This approach
     could also be used to implement remote <literal>SELECT FOR UPDATE</literal>,
     rather than using the row locking callbacks described in
     <xref linkend="fdw-callbacks-row-locking"/>.  Keep in mind that a path
     inserted into <literal>UPPERREL_FINAL</literal> is responsible for
     implementing <emphasis>all</emphasis> behavior of the query.
    </para>
________________________________________________________-->
    <para>
     <xref linkend="fdw-callbacks-update"/>中描述的<function>PlanForeignModify</function>以及其他回调的设计是建立在这样一个假设之上：外部表将以通常的方式被扫描并且行更新将被一个本地<literal>ModifyTable</literal>计划节点所驱动。这种方法对于更新需要读取本地表以及外部表的一般情况下是必要的。不过，如果操作可以完全由外部服务器执行，FDW 可以产生一个表示这种操作的计划并且把它插入到<literal>UPPERREL_FINAL</literal>上层关系中，在其中它会与<literal>ModifyTable</literal>方法竞争。这种方法还可以被用来实现远程<literal>SELECT FOR UPDATE</literal>，而不使用<xref linkend="fdw-callbacks-row-locking"/>中描述的行锁定回调。记住插入到<literal>UPPERREL_FINAL</literal>中的路径负责实现查询的<emphasis>所有</emphasis>行为。
    </para>
<!-- pgdoc-cn_end sig_en=2e6fe6e3f3cd32425ac4f16d41b8060f -->

<!-- pgdoc-cn_start sig_en=e7b671d2cd1c49a56880d112ba3bcbbf sig_cn_org=None source=14.1 
    <para>
     When planning an <command>UPDATE</command> or <command>DELETE</command>,
     <function>PlanForeignModify</function> and <function>PlanDirectModify</function>
     can look up the <structname>RelOptInfo</structname>
     struct for the foreign table and make use of the
     <literal>baserel-&gt;fdw_private</literal> data previously created by the
     scan-planning functions.  However, in <command>INSERT</command> the target
     table is not scanned so there is no <structname>RelOptInfo</structname> for it.
     The <structname>List</structname> returned by <function>PlanForeignModify</function> has
     the same restrictions as the <structfield>fdw_private</structfield> list of a
     <structname>ForeignScan</structname> plan node, that is it must contain only
     structures that <function>copyObject</function> knows how to copy.
    </para>
________________________________________________________-->
    <para>
     在规划一个<command>UPDATE</command>或<command>DELETE</command>时，<function>PlanForeignModify</function>和<function>PlanDirectModify</function>能为外部表查找<structname>RelOptInfo</structname>结构，并利用之前由扫描规划函数创建的<literal>baserel-&gt;fdw_private</literal>数据。但是，在<command>INSERT</command>中目标表不会被扫描，因此不会有它的<structname>RelOptInfo</structname>。由<function>PlanForeignModify</function>返回的<structname>List</structname>具有和<structname>ForeignScan</structname>计划节点的<structfield>fdw_private</structfield>列表相同的限制，即它必须只包含<function>copyObject</function>知道怎么拷贝的结构。
    </para>
<!-- pgdoc-cn_end sig_en=e7b671d2cd1c49a56880d112ba3bcbbf -->

<!-- pgdoc-cn_start sig_en=171c623b7b6f60df6f3cb946e7c3098e sig_cn_org=None source=14.1 
    <para>
     <command>INSERT</command> with an <literal>ON CONFLICT</literal> clause does not
     support specifying the conflict target, as unique constraints or
     exclusion constraints on remote tables are not locally known. This
     in turn implies that <literal>ON CONFLICT DO UPDATE</literal> is not supported,
     since the specification is mandatory there.
    </para>
________________________________________________________-->
    <para>
     带有一个<literal>ON CONFLICT</literal>子句的<command>INSERT</command>不支持指定冲突目标，因为本地不知道远程表上的唯一约束和排除约束的情况。然后这也意味着<literal>ON CONFLICT DO UPDATE</literal>不被支持，因为该说明是强制性的。
    </para>
<!-- pgdoc-cn_end sig_en=171c623b7b6f60df6f3cb946e7c3098e -->

   </sect1>

   <sect1 id="fdw-row-locking">
<!-- pgdoc-cn_start sig_en=5ddce0bbe492399404a517c6f0603499 sig_cn_org=None source=14.1 
    <title>Row Locking in Foreign Data Wrappers</title>
________________________________________________________-->
    <title>外部数据包装器中的行锁定</title>
<!-- pgdoc-cn_end sig_en=5ddce0bbe492399404a517c6f0603499 -->

<!-- pgdoc-cn_start sig_en=c5520010c39c6d0caa9ceb9b5b266c46 sig_cn_org=None source=14.1 
    <para>
     If an FDW's underlying storage mechanism has a concept of locking
     individual rows to prevent concurrent updates of those rows, it is
     usually worthwhile for the FDW to perform row-level locking with as
     close an approximation as practical to the semantics used in
     ordinary <productname>PostgreSQL</productname> tables.  There are multiple
     considerations involved in this.
    </para>
________________________________________________________-->
    <para>
     如果一个 FDW 的底层存储机制具有锁定行的概念来阻止对行的并发更新，通常值得 FDW 去执行行级锁定以尽可能接近在普通<productname>PostgreSQL</productname>表中所实际使用的语义。涉及这个问题有多种考虑。
    </para>
<!-- pgdoc-cn_end sig_en=c5520010c39c6d0caa9ceb9b5b266c46 -->

<!-- pgdoc-cn_start sig_en=208d4e085d290bb7c832de5294fa2b27 sig_cn_org=None source=14.1 
    <para>
     One key decision to be made is whether to perform <firstterm>early
     locking</firstterm> or <firstterm>late locking</firstterm>.  In early locking, a row is
     locked when it is first retrieved from the underlying store, while in
     late locking, the row is locked only when it is known that it needs to
     be locked.  (The difference arises because some rows may be discarded by
     locally-checked restriction or join conditions.)  Early locking is much
     simpler and avoids extra round trips to a remote store, but it can cause
     locking of rows that need not have been locked, resulting in reduced
     concurrency or even unexpected deadlocks.  Also, late locking is only
     possible if the row to be locked can be uniquely re-identified later.
     Preferably the row identifier should identify a specific version of the
     row, as <productname>PostgreSQL</productname> TIDs do.
    </para>
________________________________________________________-->
    <para>
     要做出的一个关键决定是执行<firstterm>早期锁定</firstterm>还是<firstterm>晚期锁定</firstterm>。在早期锁定中，当一行被第一次从底层存储中检索到时，它会被锁定；而在晚期锁定中，只有当行需要被锁定时才锁定它（由于某些行可能被本地检查的限制或者连接条件抛弃，所以会出现不同）。早期锁定更加简单并且能避免额外地与远程存储交互，但是可能会导致一些不需要锁定的行也被锁定，最终造成并发性下降甚至意外的死锁。还有，只有在要被锁定的行可以在后期唯一地重新标识时才可以用晚期锁定。较好的行标识符应该能标识行的特定版本，就像<productname>PostgreSQL</productname> TID 那样。
    </para>
<!-- pgdoc-cn_end sig_en=208d4e085d290bb7c832de5294fa2b27 -->

<!-- pgdoc-cn_start sig_en=9e89ffeb95a29b2f9aa53e92c77d1b43 sig_cn_org=None source=14.1 
    <para>
     By default, <productname>PostgreSQL</productname> ignores locking considerations
     when interfacing to FDWs, but an FDW can perform early locking without
     any explicit support from the core code.  The API functions described
     in <xref linkend="fdw-callbacks-row-locking"/>, which were added
     in <productname>PostgreSQL</productname> 9.5, allow an FDW to use late locking if
     it wishes.
    </para>
________________________________________________________-->
    <para>
     默认情况下，<productname>PostgreSQL</productname>在与 FDW 交互时会忽略锁定考虑，但是 FDW 可以在没有核心代码显式支持的情况下执行早期锁定。<xref linkend="fdw-callbacks-row-locking"/>中描述的 API 函数（在<productname>PostgreSQL</productname> 9.5 中加入）允许 FDW 按照意愿使用晚期锁定。
    </para>
<!-- pgdoc-cn_end sig_en=9e89ffeb95a29b2f9aa53e92c77d1b43 -->

<!-- pgdoc-cn_start sig_en=0f4534e3cf7d67360cf12a05af71f471 sig_cn_org=None source=14.1 
    <para>
     An additional consideration is that in <literal>READ COMMITTED</literal>
     isolation mode, <productname>PostgreSQL</productname> may need to re-check
     restriction and join conditions against an updated version of some
     target tuple.  Rechecking join conditions requires re-obtaining copies
     of the non-target rows that were previously joined to the target tuple.
     When working with standard <productname>PostgreSQL</productname> tables, this is
     done by including the TIDs of the non-target tables in the column list
     projected through the join, and then re-fetching non-target rows when
     required.  This approach keeps the join data set compact, but it
     requires inexpensive re-fetch capability, as well as a TID that can
     uniquely identify the row version to be re-fetched.  By default,
     therefore, the approach used with foreign tables is to include a copy of
     the entire row fetched from a foreign table in the column list projected
     through the join.  This puts no special demands on the FDW but can
     result in reduced performance of merge and hash joins.  An FDW that is
     capable of meeting the re-fetch requirements can choose to do it the
     first way.
    </para>
________________________________________________________-->
    <para>
     一个额外的考虑是在<literal>READ COMMITTED</literal>隔离模式中，<productname>PostgreSQL</productname>可能需要对某个目标元组的更新版本进行限制以及连接条件的重新检查。重新检查连接条件要求重新获得之前连接成目标元组的非目标行拷贝。在标准<productname>PostgreSQL</productname>表的情况下，这可以通过在连接投影出的列列表中包括非目标表的 TID 并且在需要时重新取得非目标行来做到。这种方法可以让连接数据集保持紧凑，但是它要求代价较低的重新取得元组的功能，还有 TID 要能够唯一地标识要被重新取得的行版本。因此，默认情况下用于外部表的方法是将整个外部表元组的拷贝包括在从连接投影出的列列表中。这不会对 FDW 有特殊的要求，但是会导致归并和哈希连接性能下降。要满足重新取得元组需求的 FDW 可以选择第一种方式。
    </para>
<!-- pgdoc-cn_end sig_en=0f4534e3cf7d67360cf12a05af71f471 -->

<!-- pgdoc-cn_start sig_en=fca4e3bb5c5c706dc466e002cd47e57e sig_cn_org=None source=14.1 
    <para>
     For an <command>UPDATE</command> or <command>DELETE</command> on a foreign table, it
     is recommended that the <literal>ForeignScan</literal> operation on the target
     table perform early locking on the rows that it fetches, perhaps via the
     equivalent of <command>SELECT FOR UPDATE</command>.  An FDW can detect whether
     a table is an <command>UPDATE</command>/<command>DELETE</command> target at plan time
     by comparing its relid to <literal>root-&gt;parse-&gt;resultRelation</literal>,
     or at execution time by using <function>ExecRelationIsTargetRelation()</function>.
     An alternative possibility is to perform late locking within the
     <function>ExecForeignUpdate</function> or <function>ExecForeignDelete</function>
     callback, but no special support is provided for this.
    </para>
________________________________________________________-->
    <para>
     对于在外部表上的<command>UPDATE</command>或者<command>DELETE</command>，推荐目标表上的<literal>ForeignScan</literal>操作在它取得的行上执行早期锁定（可能通过<command>SELECT FOR UPDATE</command>的等效体）。通过在规划时比较一个表的 relid 和<literal>root-&gt;parse-&gt;resultRelation</literal>或在执行时使用<function>ExecRelationIsTargetRelation()</function>，一个 FDW 可以检测该表是否为<command>UPDATE</command>/<command>DELETE</command>的目标。另一种可能性是在<function>ExecForeignUpdate</function>或者<function>ExecForeignDelete</function>回调中执行晚期锁定，但是对此没有特别的支持。
    </para>
<!-- pgdoc-cn_end sig_en=fca4e3bb5c5c706dc466e002cd47e57e -->

<!-- pgdoc-cn_start sig_en=8fa08b5dc8c4589d0a1145c2dc58b275 sig_cn_org=None source=14.1 
    <para>
     For foreign tables that are specified to be locked by a <command>SELECT
     FOR UPDATE/SHARE</command> command, the <literal>ForeignScan</literal> operation can
     again perform early locking by fetching tuples with the equivalent
     of <command>SELECT FOR UPDATE/SHARE</command>.  To perform late locking
     instead, provide the callback functions defined
     in <xref linkend="fdw-callbacks-row-locking"/>.
     In <function>GetForeignRowMarkType</function>, select rowmark option
     <literal>ROW_MARK_EXCLUSIVE</literal>, <literal>ROW_MARK_NOKEYEXCLUSIVE</literal>,
     <literal>ROW_MARK_SHARE</literal>, or <literal>ROW_MARK_KEYSHARE</literal> depending
     on the requested lock strength.  (The core code will act the same
     regardless of which of these four options you choose.)
     Elsewhere, you can detect whether a foreign table was specified to be
     locked by this type of command by using <function>get_plan_rowmark</function> at
     plan time, or <function>ExecFindRowMark</function> at execution time; you must
     check not only whether a non-null rowmark struct is returned, but that
     its <structfield>strength</structfield> field is not <literal>LCS_NONE</literal>.
    </para>
________________________________________________________-->
    <para>
     对于通过<command>SELECT FOR UPDATE/SHARE</command>命令指定要被锁定的外部表，<literal>ForeignScan</literal>操作同样可以通过用<command>SELECT FOR UPDATE/SHARE</command>的等效体取元组来执行早期锁定。要执行晚期锁定，请提供<xref linkend="fdw-callbacks-row-locking"/>中定义的回调函数。在<function>GetForeignRowMarkType</function>中，根据请求的锁长度来选择行标记选项<literal>ROW_MARK_EXCLUSIVE</literal>、<literal>ROW_MARK_NOKEYEXCLUSIVE</literal>、<literal>ROW_MARK_SHARE</literal>或者<literal>ROW_MARK_KEYSHARE</literal>（不管选择哪一种选项，核心代码都会做同样的事情）。在别的地方，可以在规划时用<function>get_plan_rowmark</function>或者在执行时用<function>ExecFindRowMark</function>来检测一个外部表是否被指定由这种类型的命令锁定。你必须不仅仅检测是否返回了一个非空的行标记结构，还要检测它的<structfield>strength</structfield>域不是<literal>LCS_NONE</literal>。
    </para>
<!-- pgdoc-cn_end sig_en=8fa08b5dc8c4589d0a1145c2dc58b275 -->

<!-- pgdoc-cn_start sig_en=29fd274c6631309d2af0dd6a66a4996e sig_cn_org=None source=14.1 
    <para>
     Lastly, for foreign tables that are used in an <command>UPDATE</command>,
     <command>DELETE</command> or <command>SELECT FOR UPDATE/SHARE</command> command but
     are not specified to be row-locked, you can override the default choice
     to copy entire rows by having <function>GetForeignRowMarkType</function> select
     option <literal>ROW_MARK_REFERENCE</literal> when it sees lock strength
     <literal>LCS_NONE</literal>.  This will cause <function>RefetchForeignRow</function> to
     be called with that value for <structfield>markType</structfield>; it should then
     re-fetch the row without acquiring any new lock.  (If you have
     a <function>GetForeignRowMarkType</function> function but don't wish to re-fetch
     unlocked rows, select option <literal>ROW_MARK_COPY</literal>
     for <literal>LCS_NONE</literal>.)
    </para>
________________________________________________________-->
    <para>
     最后，对于在<command>UPDATE</command>、<command>DELETE</command>或者<command>SELECT FOR UPDATE/SHARE</command>命令中使用但是没有被指定要行锁定的外部表，你可以在看到锁长度<literal>LCS_NONE</literal>时通过使用<function>GetForeignRowMarkType</function>选择选项<literal>ROW_MARK_REFERENCE</literal>来把默认选择覆盖为拷贝整个行。 这将导致用那个值作为<structfield>markType</structfield>来调用<function>RefetchForeignRow</function>。它应该接着重新取得该行而不获取任何新锁（如果你有一个<function>GetForeignRowMarkType</function>函数，但是不想重新取未锁定的行，可为<literal>LCS_NONE</literal>选择选项<literal>ROW_MARK_COPY</literal>）。
    </para>
<!-- pgdoc-cn_end sig_en=29fd274c6631309d2af0dd6a66a4996e -->

<!-- pgdoc-cn_start sig_en=a8401178a7ce0a17d62d043c50690a2e sig_cn_org=None source=14.1 
    <para>
     See <filename>src/include/nodes/lockoptions.h</filename>, the comments
     for <type>RowMarkType</type> and <type>PlanRowMark</type>
     in <filename>src/include/nodes/plannodes.h</filename>, and the comments for
     <type>ExecRowMark</type> in <filename>src/include/nodes/execnodes.h</filename> for
     additional information.
    </para>
________________________________________________________-->
    <para>
     更多信息可见<filename>src/include/nodes/lockoptions.h</filename>，以及<filename>src/include/nodes/plannodes.h</filename>中<type>RowMarkType</type>和<type>PlanRowMark</type>的注释，还有<filename>src/include/nodes/execnodes.h</filename>中<type>ExecRowMark</type>的注释。
    </para>
<!-- pgdoc-cn_end sig_en=a8401178a7ce0a17d62d043c50690a2e -->

  </sect1>

 </chapter>
