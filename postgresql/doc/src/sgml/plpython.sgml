<!-- doc/src/sgml/plpython.sgml -->

<chapter id="plpython">
<!-- pgdoc-cn_start sig_en=719dc9b53b3c78936524a30790579550 sig_cn_org=None source=14.1 
 <title>PL/Python &mdash; Python Procedural Language</title>
________________________________________________________-->
 <title>PL/Python &mdash; Python 过程语言</title>
<!-- pgdoc-cn_end sig_en=719dc9b53b3c78936524a30790579550 -->

<!-- pgdoc-cn_start sig_en=cb96e0abbd1f0e2392089f186d3d6a43 sig_cn_org=None source=14.1 
 <indexterm zone="plpython"><primary>PL/Python</primary></indexterm>
________________________________________________________-->
 <indexterm zone="plpython"><primary>PL/Python</primary></indexterm>
<!-- pgdoc-cn_end sig_en=cb96e0abbd1f0e2392089f186d3d6a43 -->
<!-- pgdoc-cn_start sig_en=26f54a5b3615edbe2e5fe596454b8d23 sig_cn_org=None source=14.1 
 <indexterm zone="plpython"><primary>Python</primary></indexterm>
________________________________________________________-->
 <indexterm zone="plpython"><primary>Python</primary></indexterm>
<!-- pgdoc-cn_end sig_en=26f54a5b3615edbe2e5fe596454b8d23 -->

<!-- pgdoc-cn_start sig_en=b0a36070c7282e2f82c827d0d132d3c4 sig_cn_org=None source=14.1 
 <para>
  The <application>PL/Python</application> procedural language allows
  <productname>PostgreSQL</productname> functions and procedures to be written in the
  <ulink url="https://www.python.org">Python language</ulink>.
 </para>
________________________________________________________-->
 <para>
  <application>PL/Python</application>过程语言允许用<ulink url="http://www.python.org">Python 语言</ulink>编写<productname>PostgreSQL</productname>函数和存储过程。
 </para>
<!-- pgdoc-cn_end sig_en=b0a36070c7282e2f82c827d0d132d3c4 -->

<!-- pgdoc-cn_start sig_en=16d86e3d782366e5529b2795e27703a3 sig_cn_org=506f7c19f595888b96ede29ca7a5a4f6 source=15.7 
 <para>
  To install PL/Python in a particular database, use
  <literal>CREATE EXTENSION plpython3u</literal>.
 </para>
________________________________________________________-->
 <para>
  要在特定数据库中安装PL/Python，请使用<literal>CREATE EXTENSION plpython3u</literal>。
</para>
<!-- pgdoc-cn_end sig_en=16d86e3d782366e5529b2795e27703a3 -->

  <tip>
<!-- pgdoc-cn_start sig_en=baccbbc8addfed07dd896e5e2dd7a4bb sig_cn_org=None source=14.1 
   <para>
    If a language is installed into <literal>template1</literal>, all subsequently
    created databases will have the language installed automatically.
   </para>
________________________________________________________-->
   <para>
    如果把一种语言安装在<literal>template1</literal>中，所有后续创建的数据库都会自动安装该语言。
   </para>
<!-- pgdoc-cn_end sig_en=baccbbc8addfed07dd896e5e2dd7a4bb -->
  </tip>

<!-- pgdoc-cn_start sig_en=f13bee54c57a281da95b13e8f007f699 sig_cn_org=3677289a39d7bbf029cb20ad5cdf65d8 source=15.7 
 <para>
  PL/Python is only available as an <quote>untrusted</quote> language, meaning
  it does not offer any way of restricting what users can do in it and
  is therefore named <literal>plpython3u</literal>.  A trusted
  variant <literal>plpython</literal> might become available in the future
  if a secure execution mechanism is developed in Python.  The
  writer of a function in untrusted PL/Python must take care that the
  function cannot be used to do anything unwanted, since it will be
  able to do anything that could be done by a user logged in as the
  database administrator.  Only superusers can create functions in
  untrusted languages such as <literal>plpython3u</literal>.
 </para>
________________________________________________________-->
 <para>
  PL/Python仅作为一种<quote>不受信任</quote>语言可用，这意味着它没有任何限制用户在其中可以做什么的方式，因此被命名为<literal>plpython3u</literal>。
  如果Python中开发了安全执行机制，未来可能会提供一个受信任的变体<literal>plpython</literal>。
  在不受信任的PL/Python中编写函数的作者必须注意，该函数不能被用于执行任何不需要的操作，因为它可以执行任何数据库管理员登录用户可以执行的操作。
  只有超级用户可以在不受信任的语言中创建函数，例如<literal>plpython3u</literal>。
</para>
<!-- pgdoc-cn_end sig_en=f13bee54c57a281da95b13e8f007f699 -->

 <note>
<!-- pgdoc-cn_start sig_en=d32158d0314d6fe09f1d9dfd593e88ba sig_cn_org=None source=14.1 
  <para>
   Users of source packages must specially enable the build of
   PL/Python during the installation process.  (Refer to the
   installation instructions for more information.)  Users of binary
   packages might find PL/Python in a separate subpackage.
  </para>
________________________________________________________-->
  <para>
   源码包的用户必须在安装过程中特别地启用 PL/Python 的编译（更多信息请参考安装指导）。二进制包的用户可以在一个单独的子包中找到 PL/Python。
  </para>
<!-- pgdoc-cn_end sig_en=d32158d0314d6fe09f1d9dfd593e88ba -->
 </note>

 <sect1 id="plpython-funcs">
<!-- pgdoc-cn_start sig_en=099fba2ca58020361d512a1d4185a81d sig_cn_org=None source=14.1 
  <title>PL/Python Functions</title>
________________________________________________________-->
  <title>PL/Python 函数</title>
<!-- pgdoc-cn_end sig_en=099fba2ca58020361d512a1d4185a81d -->

<!-- pgdoc-cn_start sig_en=6a863399a490eca54214cbe3733c8ba6 sig_cn_org=36cd899b1780b118a8d02adce00be9b1 source=15.7 
  <para>
   Functions in PL/Python are declared via the
   standard <xref linkend="sql-createfunction"/> syntax:

<programlisting>
CREATE FUNCTION <replaceable>funcname</replaceable> (<replaceable>argument-list</replaceable>)
  RETURNS <replaceable>return-type</replaceable>
AS $$
  # PL/Python function body
$$ LANGUAGE plpython3u;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   在PL/Python中，函数是通过标准的<xref linkend="sql-createfunction"/>语法声明的：

<programlisting>
CREATE FUNCTION <replaceable>funcname</replaceable> (<replaceable>argument-list</replaceable>)
  RETURNS <replaceable>return-type</replaceable>
AS $$
  # PL/Python function body
$$ LANGUAGE plpython3u;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=6a863399a490eca54214cbe3733c8ba6 -->

<!-- pgdoc-cn_start sig_en=df1c4df222fdec0850f71f32595b5b12 sig_cn_org=None source=14.1 
  <para>
   The body of a function is simply a Python script. When the function
   is called, its arguments are passed as elements of the list
   <varname>args</varname>; named arguments are also passed as
   ordinary variables to the Python script.  Use of named arguments is
   usually more readable.  The result is returned from the Python code
   in the usual way, with <literal>return</literal> or
   <literal>yield</literal> (in case of a result-set statement).  If
   you do not provide a return value, Python returns the default
   <symbol>None</symbol>. <application>PL/Python</application> translates
   Python's <symbol>None</symbol> into the SQL null value.  In a procedure,
   the result from the Python code must be <symbol>None</symbol> (typically
   achieved by ending the procedure without a <literal>return</literal>
   statement or by using a <literal>return</literal> statement without
   argument); otherwise, an error will be raised.
  </para>
________________________________________________________-->
  <para>
   函数体就是一个 Python 脚本。当函数被调用时，它的参数被当做列表<varname>args</varname>的元素传递，命名参数也被作为普通变量传递给 Python 脚本。使用命名参数通常可读性更好。Python 代码会以通常的方式返回结果，即使用<literal>return</literal>或者<literal>yield</literal>（在结果集合语句的情况中）。如果没有提供一个返回值，Python 会返回默认的<symbol>None</symbol>。<application>PL/Python</application>会把 Python 的<symbol>None</symbol>翻译成 SQL 空值。在一个过程中，Python代码的结果必须是<symbol>None</symbol>（通常实现为结束过程时不写<literal>return</literal>语句或者使用不带参数的<literal>return</literal>），否则将会发生错误。
  </para>
<!-- pgdoc-cn_end sig_en=df1c4df222fdec0850f71f32595b5b12 -->

<!-- pgdoc-cn_start sig_en=4d3551c7739a2321181b2e903d4a5b82 sig_cn_org=b9ea8739f3ba41381ecfba14a909cb81 source=15.7 
  <para>
   For example, a function to return the greater of two integers can be
   defined as:

<programlisting>
CREATE FUNCTION pymax (a integer, b integer)
  RETURNS integer
AS $$
  if a &gt; b:
    return a
  return b
$$ LANGUAGE plpython3u;
</programlisting>

   The Python code that is given as the body of the function definition
   is transformed into a Python function. For example, the above results in:

<programlisting>
def __plpython_procedure_pymax_23456():
  if a &gt; b:
    return a
  return b
</programlisting>

   assuming that 23456 is the OID assigned to the function by
   <productname>PostgreSQL</productname>.
  </para>
________________________________________________________-->
  <para>
   例如，一个返回两个整数中较大值的函数可以定义为：

<programlisting>
CREATE FUNCTION pymax (a integer, b integer)
  RETURNS integer
AS $$
  if a &gt; b:
    return a
  return b
$$ LANGUAGE plpython3u;
</programlisting>

   作为函数定义主体给出的Python代码被转换为Python函数。例如，上述代码会得到：

<programlisting>
def __plpython_procedure_pymax_23456():
  if a &gt; b:
    return a
  return b
</programlisting>

   假设23456是由<productname>PostgreSQL</productname>分配给该函数的OID。
</para>
<!-- pgdoc-cn_end sig_en=4d3551c7739a2321181b2e903d4a5b82 -->

<!-- pgdoc-cn_start sig_en=1ce7ad92954b0f46549bbc48ad3cba3d sig_cn_org=40158f3214f0d7c43be37a1054adda2e source=15.7 
  <para>
   The arguments are set as global variables.  Because of the scoping
   rules of Python, this has the subtle consequence that an argument
   variable cannot be reassigned inside the function to the value of
   an expression that involves the variable name itself, unless the
   variable is redeclared as global in the block.  For example, the
   following won't work:
<programlisting>
CREATE FUNCTION pystrip(x text)
  RETURNS text
AS $$
  x = x.strip()  # error
  return x
$$ LANGUAGE plpython3u;
</programlisting>
   because assigning to <varname>x</varname>
   makes <varname>x</varname> a local variable for the entire block,
   and so the <varname>x</varname> on the right-hand side of the
   assignment refers to a not-yet-assigned local
   variable <varname>x</varname>, not the PL/Python function
   parameter.  Using the <literal>global</literal> statement, this can
   be made to work:
<programlisting>
CREATE FUNCTION pystrip(x text)
  RETURNS text
AS $$
  global x
  x = x.strip()  # ok now
  return x
$$ LANGUAGE plpython3u;
</programlisting>
   But it is advisable not to rely on this implementation detail of
   PL/Python.  It is better to treat the function parameters as
   read-only.
  </para>
________________________________________________________-->
  <para>
   参数被设置为全局变量。由于Python的作用域规则，这带来了一个微妙的后果，即参数变量不能在函数内部重新赋值为涉及变量名本身的表达式的值，除非在块中将变量重新声明为全局变量。例如，以下情况不起作用：
<programlisting>
CREATE FUNCTION pystrip(x text)
  RETURNS text
AS $$
  x = x.strip()  # error
  return x
$$ LANGUAGE plpython3u;
</programlisting>
   因为对<varname>x</varname>赋值会使整个块中的<varname>x</varname>成为局部变量，因此赋值语句右侧的<varname>x</varname>指的是一个尚未分配的局部变量<varname>x</varname>，而不是PL/Python函数参数。使用<literal>global</literal>语句，可以使其正常工作：
<programlisting>
CREATE FUNCTION pystrip(x text)
  RETURNS text
AS $$
  global x
  x = x.strip()  # ok now
  return x
$$ LANGUAGE plpython3u;
</programlisting>
   但最好不要依赖于PL/Python的这个实现细节。最好将函数参数视为只读。
</para>
<!-- pgdoc-cn_end sig_en=1ce7ad92954b0f46549bbc48ad3cba3d -->
 </sect1>

 <sect1 id="plpython-data">
<!-- pgdoc-cn_start sig_en=0822003b4029dd65ffd9f95c3db0fbc3 sig_cn_org=None source=14.1 
  <title>Data Values</title>
________________________________________________________-->
  <title>数据值</title>
<!-- pgdoc-cn_end sig_en=0822003b4029dd65ffd9f95c3db0fbc3 -->
<!-- pgdoc-cn_start sig_en=d4c5cbcb18e4ab5ad762c0487f29badd sig_cn_org=None source=14.1 
  <para>
   Generally speaking, the aim of PL/Python is to provide
   a <quote>natural</quote> mapping between the PostgreSQL and the
   Python worlds.  This informs the data mapping rules described
   below.
  </para>
________________________________________________________-->
  <para>
   一般来讲，PL/Python 的目标是提供在 PostgreSQL 和 Python 世界之间的一种<quote>自然的</quote>映射。这包括下面介绍的数据映射规则。
  </para>
<!-- pgdoc-cn_end sig_en=d4c5cbcb18e4ab5ad762c0487f29badd -->

  <sect2>
<!-- pgdoc-cn_start sig_en=d2642d6a07b9d1f3e7cb241fd0b6e7c8 sig_cn_org=None source=14.1 
   <title>Data Type Mapping</title>
________________________________________________________-->
   <title>数据类型映射</title>
<!-- pgdoc-cn_end sig_en=d2642d6a07b9d1f3e7cb241fd0b6e7c8 -->
<!-- pgdoc-cn_start sig_en=9bdee8aba260e818739416f4fecbf2a7 sig_cn_org=15518ec56d37ad61c7bd6d7f87b4f4e2 source=15.7 
   <para>
    When a PL/Python function is called, its arguments are converted from
    their PostgreSQL data type to a corresponding Python type:

    <itemizedlist>
     <listitem>
      <para>
       PostgreSQL <type>boolean</type> is converted to Python <type>bool</type>.
      </para>
     </listitem>

     <listitem>
      <para>
       PostgreSQL <type>smallint</type>, <type>int</type>, <type>bigint</type>
       and <type>oid</type> are converted to Python <type>int</type>.
      </para>
     </listitem>

     <listitem>
      <para>
       PostgreSQL <type>real</type> and <type>double</type> are converted to
       Python <type>float</type>.
      </para>
     </listitem>

     <listitem>
      <para>
       PostgreSQL <type>numeric</type> is converted to
       Python <type>Decimal</type>.  This type is imported from
       the <literal>cdecimal</literal> package if that is available.
       Otherwise,
       <literal>decimal.Decimal</literal> from the standard library will be
       used.  <literal>cdecimal</literal> is significantly faster
       than <literal>decimal</literal>.  In Python 3.3 and up,
       however, <literal>cdecimal</literal> has been integrated into the
       standard library under the name <literal>decimal</literal>, so there is
       no longer any difference.
      </para>
     </listitem>

     <listitem>
      <para>
       PostgreSQL <type>bytea</type> is converted to Python <type>bytes</type>.
      </para>
     </listitem>

     <listitem>
      <para>
       All other data types, including the PostgreSQL character string types,
       are converted to a Python <type>str</type> (in Unicode like all Python
       strings).
      </para>
     </listitem>

     <listitem>
      <para>
       For nonscalar data types, see below.
      </para>
     </listitem>
    </itemizedlist>
   </para>
________________________________________________________-->
   <para>
    当调用PL/Python函数时，其参数将从其PostgreSQL数据类型转换为相应的Python类型：

    <itemizedlist>
     <listitem>
      <para>
       PostgreSQL <type>boolean</type> 被转换为 Python <type>bool</type>。
      </para>
     </listitem>

     <listitem>
      <para>
       PostgreSQL <type>smallint</type>、<type>int</type>、<type>bigint</type>
       和 <type>oid</type> 被转换为 Python <type>int</type>。
      </para>
     </listitem>

     <listitem>
      <para>
       PostgreSQL <type>real</type> 和 <type>double</type> 被转换为
       Python <type>float</type>。
      </para>
     </listitem>

     <listitem>
      <para>
       PostgreSQL <type>numeric</type> 被转换为
       Python <type>Decimal</type>。如果可用，此类型将从
       <literal>cdecimal</literal> 包中导入。
       否则，
       将使用标准库中的 <literal>decimal.Decimal</literal>。在性能上，
       <literal>cdecimal</literal> 明显快于 <literal>decimal</literal>。
       然而，在Python 3.3及更高版本中，
       <literal>cdecimal</literal> 已经整合到标准库中，以 <literal>decimal</literal> 的名称存在，
       因此不再有任何区别。
      </para>
     </listitem>

     <listitem>
      <para>
       PostgreSQL <type>bytea</type> 被转换为 Python <type>bytes</type>。
      </para>
     </listitem>

     <listitem>
      <para>
       所有其他数据类型，包括PostgreSQL字符串类型，
       都被转换为 Python <type>str</type>（与所有Python字符串一样，都是Unicode）。
      </para>
     </listitem>

     <listitem>
      <para>
       对于非标量数据类型，请参见下文。
      </para>
     </listitem>
    </itemizedlist>
   </para>
<!-- pgdoc-cn_end sig_en=9bdee8aba260e818739416f4fecbf2a7 -->

<!-- pgdoc-cn_start sig_en=3e6b5eb4353e0bbc7b8066ce71c6c986 sig_cn_org=87e50ffa626ef1d55ae080c570399ed8 source=15.7 
   <para>
    When a PL/Python function returns, its return value is converted to the
    function's declared PostgreSQL return data type as follows:

    <itemizedlist>
     <listitem>
      <para>
       When the PostgreSQL return type is <type>boolean</type>, the
       return value will be evaluated for truth according to the
       <emphasis>Python</emphasis> rules.  That is, 0 and empty string
       are false, but notably <literal>'f'</literal> is true.
      </para>
     </listitem>

     <listitem>
      <para>
       When the PostgreSQL return type is <type>bytea</type>, the return value
       will be converted to Python <type>bytes</type> using the respective
       Python built-ins, with the result being converted to
       <type>bytea</type>.
      </para>
     </listitem>

     <listitem>
      <para>
       For all other PostgreSQL return types, the return value is converted
       to a string using the Python built-in <literal>str</literal>, and the
       result is passed to the input function of the PostgreSQL data type.
       (If the Python value is a <type>float</type>, it is converted using
       the <literal>repr</literal> built-in instead of <literal>str</literal>, to
       avoid loss of precision.)
      </para>

      <para>
       Strings are automatically converted to the PostgreSQL server encoding
       when they are passed to PostgreSQL.
      </para>
     </listitem>

     <listitem>
      <para>
       For nonscalar data types, see below.
      </para>
     </listitem>
    </itemizedlist>

    Note that logical mismatches between the declared PostgreSQL
    return type and the Python data type of the actual return object
    are not flagged; the value will be converted in any case.
   </para>
________________________________________________________-->
   <para>
    当PL/Python函数返回时，其返回值将根据以下方式转换为函数声明的PostgreSQL返回数据类型：

    <itemizedlist>
     <listitem>
      <para>
       当PostgreSQL返回类型为<type>boolean</type>时，返回值将根据<emphasis>Python</emphasis>规则进行真值评估。
       即，0和空字符串为假，但值为<literal>'f'</literal>为真。
      </para>
     </listitem>

     <listitem>
      <para>
       当PostgreSQL返回类型为<type>bytea</type>时，返回值将使用相应的Python内置函数转换为Python <type>bytes</type>，
       然后将结果转换为<type>bytea</type>。
      </para>
     </listitem>

     <listitem>
      <para>
       对于所有其他PostgreSQL返回类型，返回值将使用Python内置函数<literal>str</literal>转换为字符串，
       然后将结果传递给PostgreSQL数据类型的输入函数。
       （如果Python值为<type>float</type>，则使用<literal>repr</literal>内置函数进行转换，而不是<literal>str</literal>，
       以避免精度丢失。）
      </para>

      <para>
       当字符串传递给PostgreSQL时，会自动转换为PostgreSQL服务器编码。
      </para>
     </listitem>

     <listitem>
      <para>
       对于非标量数据类型，请参见下文。
      </para>
     </listitem>
    </itemizedlist>

    请注意，声明的PostgreSQL返回类型与实际返回对象的Python数据类型之间的逻辑不匹配不会被标记；
    无论如何，值都将被转换。
   </para>
<!-- pgdoc-cn_end sig_en=3e6b5eb4353e0bbc7b8066ce71c6c986 -->
  </sect2>

  <sect2>
<!-- pgdoc-cn_start sig_en=24512f60759dd1216d37ebe8f057cc21 sig_cn_org=None source=14.1 
   <title>Null, None</title>
________________________________________________________-->
   <title>Null, None</title>
<!-- pgdoc-cn_end sig_en=24512f60759dd1216d37ebe8f057cc21 -->
<!-- pgdoc-cn_start sig_en=c767f06f85b6f4120f7eacc0e929d2d9 sig_cn_org=50df7b6529b3d375dc5b45d97b295e86 source=15.7 
  <para>
   If an SQL null value<indexterm><primary>null value</primary><secondary
   sortas="PL/Python">in PL/Python</secondary></indexterm> is passed to a
   function, the argument value will appear as <symbol>None</symbol> in
   Python. For example, the function definition of <function>pymax</function>
   shown in <xref linkend="plpython-funcs"/> will return the wrong answer for null
   inputs. We could add <literal>STRICT</literal> to the function definition
   to make <productname>PostgreSQL</productname> do something more reasonable:
   if a null value is passed, the function will not be called at all,
   but will just return a null result automatically. Alternatively,
   we could check for null inputs in the function body:

<programlisting>
CREATE FUNCTION pymax (a integer, b integer)
  RETURNS integer
AS $$
  if (a is None) or (b is None):
    return None
  if a &gt; b:
    return a
  return b
$$ LANGUAGE plpython3u;
</programlisting>

   As shown above, to return an SQL null value from a PL/Python
   function, return the value <symbol>None</symbol>. This can be done whether the
   function is strict or not.
  </para>
________________________________________________________-->
  <para>
   如果在PL/Python中传递了一个SQL空值<indexterm><primary>null value</primary><secondary
   sortas="PL/Python">在PL/Python中</secondary></indexterm>给一个函数，参数值将在Python中显示为<symbol>None</symbol>。
   例如，<function>pymax</function>函数的定义如<xref linkend="plpython-funcs"/>中所示，对于空输入将返回错误的答案。
   我们可以在函数定义中添加<literal>STRICT</literal>，让<productname>PostgreSQL</productname>做一些更合理的事情：
   如果传递了空值，函数将根本不会被调用，而只会自动返回一个空结果。另外，我们可以在函数体中检查空输入：

<programlisting>
CREATE FUNCTION pymax (a integer, b integer)
  RETURNS integer
AS $$
  if (a is None) or (b is None):
    return None
  if a &gt; b:
    return a
  return b
$$ LANGUAGE plpython3u;
</programlisting>

   如上所示，要从PL/Python函数中返回一个SQL空值，返回值为<symbol>None</symbol>。无论函数是否严格，都可以这样做。
</para>
<!-- pgdoc-cn_end sig_en=c767f06f85b6f4120f7eacc0e929d2d9 -->
  </sect2>

  <sect2 id="plpython-arrays">
<!-- pgdoc-cn_start sig_en=43a2e4bfba6fd69f8c64f777c606ea11 sig_cn_org=None source=14.1 
   <title>Arrays, Lists</title>
________________________________________________________-->
   <title>数组、列表</title>
<!-- pgdoc-cn_end sig_en=43a2e4bfba6fd69f8c64f777c606ea11 -->
<!-- pgdoc-cn_start sig_en=a88e1330b56615090b0e69d80d22adfe sig_cn_org=93d10661cc8a1500900fbbda673cf614 source=15.7 
  <para>
   SQL array values are passed into PL/Python as a Python list.  To
   return an SQL array value out of a PL/Python function, return a
   Python list:

<programlisting>
CREATE FUNCTION return_arr()
  RETURNS int[]
AS $$
return [1, 2, 3, 4, 5]
$$ LANGUAGE plpython3u;

SELECT return_arr();
 return_arr
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 {1,2,3,4,5}
(1 row)
</programlisting>

   Multidimensional arrays are passed into PL/Python as nested Python lists.
   A 2-dimensional array is a list of lists, for example. When returning
   a multi-dimensional SQL array out of a PL/Python function, the inner
   lists at each level must all be of the same size. For example:

<programlisting>
CREATE FUNCTION test_type_conversion_array_int4(x int4[]) RETURNS int4[] AS $$
plpy.info(x, type(x))
return x
$$ LANGUAGE plpython3u;

SELECT * FROM test_type_conversion_array_int4(ARRAY[[1,2,3],[4,5,6]]);
INFO:  ([[1, 2, 3], [4, 5, 6]], &lt;type 'list'&gt;)
 test_type_conversion_array_int4
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 {{1,2,3},{4,5,6}}
(1 row)
</programlisting>

   Other Python sequences, like tuples, are also accepted for
   backwards-compatibility with PostgreSQL versions 9.6 and below, when
   multi-dimensional arrays were not supported. However, they are always
   treated as one-dimensional arrays, because they are ambiguous with
   composite types. For the same reason, when a composite type is used in a
   multi-dimensional array, it must be represented by a tuple, rather than a
   list.
  </para>
________________________________________________________-->
  <para>
   SQL数组值作为Python列表传入PL/Python。要从PL/Python函数中返回SQL数组值，
   返回一个Python列表：

<programlisting>
CREATE FUNCTION return_arr()
  RETURNS int[]
AS $$
return [1, 2, 3, 4, 5]
$$ LANGUAGE plpython3u;

SELECT return_arr();
 return_arr
-------------
 {1,2,3,4,5}
(1 row)
</programlisting>

   多维数组作为嵌套的Python列表传入PL/Python。例如，2维数组是一个列表的列表。
   当从PL/Python函数中返回多维SQL数组时，每个级别的内部列表必须大小相同。例如：

<programlisting>
CREATE FUNCTION test_type_conversion_array_int4(x int4[]) RETURNS int4[] AS $$
plpy.info(x, type(x))
return x
$$ LANGUAGE plpython3u;

SELECT * FROM test_type_conversion_array_int4(ARRAY[[1,2,3],[4,5,6]]);
INFO:  ([[1, 2, 3], [4, 5, 6]], &lt;type 'list'&gt;)
 test_type_conversion_array_int4
---------------------------------
 {{1,2,3},{4,5,6}}
(1 row)
</programlisting>

   其他Python序列，如元组，在与PostgreSQL版本9.6及以下版本向后兼容时也被接受，
   当时不支持多维数组。然而，它们始终被视为一维数组，因为它们与复合类型模糊不清。
   出于同样的原因，当复合类型在多维数组中使用时，必须用元组表示，而不是列表。
</para>
<!-- pgdoc-cn_end sig_en=a88e1330b56615090b0e69d80d22adfe -->
<!-- pgdoc-cn_start sig_en=3888c978dbb40c31713ef71b96464915 sig_cn_org=e324ee12e2e1da520de60c251f92c4e6 source=15.7 
  <para>
   Note that in Python, strings are sequences, which can have
   undesirable effects that might be familiar to Python programmers:

<programlisting>
CREATE FUNCTION return_str_arr()
  RETURNS varchar[]
AS $$
return "hello"
$$ LANGUAGE plpython3u;

SELECT return_str_arr();
 return_str_arr
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 {h,e,l,l,o}
(1 row)
</programlisting>
  </para>
________________________________________________________-->
  <para>
   请注意，在Python中，字符串是序列，可能会产生一些不良影响，这可能对Python程序员来说很熟悉：

<programlisting>
CREATE FUNCTION return_str_arr()
  RETURNS varchar[]
AS $$
return "hello"
$$ LANGUAGE plpython3u;

SELECT return_str_arr();
 return_str_arr
----------------
 {h,e,l,l,o}
(1 row)
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=3888c978dbb40c31713ef71b96464915 -->
  </sect2>

  <sect2>
<!-- pgdoc-cn_start sig_en=f3b2f5a3e6cd2d4f9d699f2b3ad65cc7 sig_cn_org=None source=14.1 
   <title>Composite Types</title>
________________________________________________________-->
   <title>组合类型</title>
<!-- pgdoc-cn_end sig_en=f3b2f5a3e6cd2d4f9d699f2b3ad65cc7 -->
<!-- pgdoc-cn_start sig_en=07573175f9c87124fd8730678f6fc037 sig_cn_org=f927bc8aef121ab5056108a078da94f5 source=15.7 
  <para>
   Composite-type arguments are passed to the function as Python mappings. The
   element names of the mapping are the attribute names of the composite type.
   If an attribute in the passed row has the null value, it has the value
   <symbol>None</symbol> in the mapping. Here is an example:

<programlisting>
CREATE TABLE employee (
  name text,
  salary integer,
  age integer
);

CREATE FUNCTION overpaid (e employee)
  RETURNS boolean
AS $$
  if e["salary"] &gt; 200000:
    return True
  if (e["age"] &lt; 30) and (e["salary"] &gt; 100000):
    return True
  return False
$$ LANGUAGE plpython3u;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   复合类型参数作为Python映射传递给函数。映射的元素名称是复合类型的属性名称。
   如果传递的行中的属性具有空值，则在映射中具有值<symbol>None</symbol>。这里是一个示例：

<programlisting>
CREATE TABLE employee (
  name text,
  salary integer,
  age integer
);

CREATE FUNCTION overpaid (e employee)
  RETURNS boolean
AS $$
  if e["salary"] &gt; 200000:
    return True
  if (e["age"] &lt; 30) and (e["salary"] &gt; 100000):
    return True
  return False
$$ LANGUAGE plpython3u;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=07573175f9c87124fd8730678f6fc037 -->

<!-- pgdoc-cn_start sig_en=b4547b5f21dff1497288f6513c0d6acf sig_cn_org=edae785154e170489fe509491094b73d source=15.7 
  <para>
   There are multiple ways to return row or composite types from a Python
   function. The following examples assume we have:

<programlisting>
CREATE TYPE named_value AS (
  name   text,
  value  integer
);
</programlisting>

   A composite result can be returned as a:

   <variablelist>
    <varlistentry>
     <term>Sequence type (a tuple or list, but not a set because
     it is not indexable)</term>
     <listitem>
      <para>
       Returned sequence objects must have the same number of items as the
       composite result type has fields. The item with index 0 is assigned to
       the first field of the composite type, 1 to the second and so on. For
       example:

<programlisting>
CREATE FUNCTION make_pair (name text, value integer)
  RETURNS named_value
AS $$
  return ( name, value )
  # or alternatively, as list: return [ name, value ]
$$ LANGUAGE plpython3u;
</programlisting>

       To return an SQL null for any column, insert <symbol>None</symbol> at
       the corresponding position.
      </para>
      <para>
       When an array of composite types is returned, it cannot be returned as a list,
       because it is ambiguous whether the Python list represents a composite type,
       or another array dimension.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Mapping (dictionary)</term>
     <listitem>
      <para>
       The value for each result type column is retrieved from the mapping
       with the column name as key. Example:

<programlisting>
CREATE FUNCTION make_pair (name text, value integer)
  RETURNS named_value
AS $$
  return { "name": name, "value": value }
$$ LANGUAGE plpython3u;
</programlisting>

       Any extra dictionary key/value pairs are ignored. Missing keys are
       treated as errors.
       To return an SQL null value for any column, insert
       <symbol>None</symbol> with the corresponding column name as the key.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Object (any object providing method <literal>__getattr__</literal>)</term>
     <listitem>
      <para>
       This works the same as a mapping.
       Example:

<programlisting>
CREATE FUNCTION make_pair (name text, value integer)
  RETURNS named_value
AS $$
  class named_value:
    def __init__ (self, n, v):
      self.name = n
      self.value = v
  return named_value(name, value)

  # or simply
  class nv: pass
  nv.name = name
  nv.value = value
  return nv
$$ LANGUAGE plpython3u;
</programlisting>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
________________________________________________________-->
  <para>
   有多种方法可以从Python函数返回行或复合类型。以下示例假设我们有：

<programlisting>
CREATE TYPE named_value AS (
  name   text,
  value  integer
);
</programlisting>

   复合结果可以作为以下之一返回：

   <variablelist>
    <varlistentry>
     <term>序列类型（元组或列表，但不是集合，因为它不可索引）</term>
     <listitem>
      <para>
       返回的序列对象必须具有与复合结果类型字段相同数量的项。索引为0的项分配给复合类型的第一个字段，1分配给第二个字段，依此类推。例如：

<programlisting>
CREATE FUNCTION make_pair (name text, value integer)
  RETURNS named_value
AS $$
  return ( name, value )
  # 或者作为列表返回：return [ name, value ]
$$ LANGUAGE plpython3u;
</programlisting>

       要为任何列返回SQL空值，请在相应位置插入<symbol>None</symbol>。
      </para>
      <para>
       当返回复合类型的数组时，不能将其作为列表返回，因为Python列表表示复合类型还是另一个数组维度是模棱两可的。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>映射（字典）</term>
     <listitem>
      <para>
       每个结果类型列的值从具有列名作为键的映射中检索。例如：

<programlisting>
CREATE FUNCTION make_pair (name text, value integer)
  RETURNS named_value
AS $$
  return { "name": name, "value": value }
$$ LANGUAGE plpython3u;
</programlisting>

       任何额外的字典键/值对都将被忽略。缺少的键将被视为错误。
       要为任何列返回SQL空值，请使用相应的列名作为键插入<symbol>None</symbol>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>对象（提供方法<literal>__getattr__</literal>的任何对象）</term>
     <listitem>
      <para>
       这与映射相同。例如：

<programlisting>
CREATE FUNCTION make_pair (name text, value integer)
  RETURNS named_value
AS $$
  class named_value:
    def __init__ (self, n, v):
      self.name = n
      self.value = v
  return named_value(name, value)

  # or simply
  class nv: pass
  nv.name = name
  nv.value = value
  return nv
$$ LANGUAGE plpython3u;
</programlisting>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
<!-- pgdoc-cn_end sig_en=b4547b5f21dff1497288f6513c0d6acf -->

<!-- pgdoc-cn_start sig_en=715b0b48da7915eba8b398bef583d225 sig_cn_org=1f59f1ce69dc3eff891d1aca509d6801 source=15.7 
   <para>
    Functions with <literal>OUT</literal> parameters are also supported.  For example:
<programlisting>
CREATE FUNCTION multiout_simple(OUT i integer, OUT j integer) AS $$
return (1, 2)
$$ LANGUAGE plpython3u;

SELECT * FROM multiout_simple();
</programlisting>
   </para>
________________________________________________________-->
   <para>
    支持带<literal>OUT</literal>参数的函数。例如：
<programlisting>
CREATE FUNCTION multiout_simple(OUT i integer, OUT j integer) AS $$
return (1, 2)
$$ LANGUAGE plpython3u;

SELECT * FROM multiout_simple();
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=715b0b48da7915eba8b398bef583d225 -->

<!-- pgdoc-cn_start sig_en=62eaf52c46315cb8e2f94a2e3944c5fb sig_cn_org=7da2c110ebd0cf3a4fa0f1fdaf52c18a source=15.7 
   <para>
    Output parameters of procedures are passed back the same way.  For example:
<programlisting>
CREATE PROCEDURE python_triple(INOUT a integer, INOUT b integer) AS $$
return (a * 3, b * 3)
$$ LANGUAGE plpython3u;

CALL python_triple(5, 10);
</programlisting>
   </para>
________________________________________________________-->
   <para>
    过程的输出参数以相同的方式传回。例如:
<programlisting>
CREATE PROCEDURE python_triple(INOUT a integer, INOUT b integer) AS $$
return (a * 3, b * 3)
$$ LANGUAGE plpython3u;

CALL python_triple(5, 10);
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=62eaf52c46315cb8e2f94a2e3944c5fb -->
  </sect2>

  <sect2>
<!-- pgdoc-cn_start sig_en=f56f2f6ad03a032e222749d73e15a748 sig_cn_org=None source=14.1 
   <title>Set-Returning Functions</title>
________________________________________________________-->
   <title>集合返回函数</title>
<!-- pgdoc-cn_end sig_en=f56f2f6ad03a032e222749d73e15a748 -->
<!-- pgdoc-cn_start sig_en=9892e925beab3347fc61de0c68f3be53 sig_cn_org=a0c0fa71205f4fca74b28b14af36a35b source=15.7 
  <para>
   A <application>PL/Python</application> function can also return sets of
   scalar or composite types. There are several ways to achieve this because
   the returned object is internally turned into an iterator. The following
   examples assume we have composite type:

<programlisting>
CREATE TYPE greeting AS (
  how text,
  who text
);
</programlisting>

   A set result can be returned from a:

   <variablelist>
    <varlistentry>
     <term>Sequence type (tuple, list, set)</term>
     <listitem>
      <para>
<programlisting>
CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  # return tuple containing lists as composite types
  # all other combinations work also
  return ( [ how, "World" ], [ how, "PostgreSQL" ], [ how, "PL/Python" ] )
$$ LANGUAGE plpython3u;
</programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Iterator (any object providing <symbol>__iter__</symbol> and
      <symbol>next</symbol> methods)</term>
     <listitem>
      <para>
<programlisting>
CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  class producer:
    def __init__ (self, how, who):
      self.how = how
      self.who = who
      self.ndx = -1

    def __iter__ (self):
      return self

    def next (self):
      self.ndx += 1
      if self.ndx == len(self.who):
        raise StopIteration
      return ( self.how, self.who[self.ndx] )

  return producer(how, [ "World", "PostgreSQL", "PL/Python" ])
$$ LANGUAGE plpython3u;
</programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>Generator (<literal>yield</literal>)</term>
     <listitem>
      <para>
<programlisting>
CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  for who in [ "World", "PostgreSQL", "PL/Python" ]:
    yield ( how, who )
$$ LANGUAGE plpython3u;
</programlisting>

      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
________________________________________________________-->
  <para>
   一个<application>PL/Python</application>函数也可以返回标量或复合类型的集合。
   有几种方法可以实现这一点，因为返回的对象在内部被转换为迭代器。以下示例假设我们有复合类型：

<programlisting>
CREATE TYPE greeting AS (
  how text,
  who text
);
</programlisting>

   可以从以下返回一个集合结果：

   <variablelist>
    <varlistentry>
     <term>序列类型（元组，列表，集合）</term>
     <listitem>
      <para>
<programlisting>
CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  # return tuple containing lists as composite types
  # all other combinations work also
  return ( [ how, "World" ], [ how, "PostgreSQL" ], [ how, "PL/Python" ] )
$$ LANGUAGE plpython3u;
</programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>迭代器（提供<symbol>__iter__</symbol>和<symbol>next</symbol>方法的任何对象）</term>
     <listitem>
      <para>
<programlisting>
CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  class producer:
    def __init__ (self, how, who):
      self.how = how
      self.who = who
      self.ndx = -1

    def __iter__ (self):
      return self

    def next (self):
      self.ndx += 1
      if self.ndx == len(self.who):
        raise StopIteration
      return ( self.how, self.who[self.ndx] )

  return producer(how, [ "World", "PostgreSQL", "PL/Python" ])
$$ LANGUAGE plpython3u;
</programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>生成器（<literal>yield</literal>）</term>
     <listitem>
      <para>
<programlisting>
CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  for who in [ "World", "PostgreSQL", "PL/Python" ]:
    yield ( how, who )
$$ LANGUAGE plpython3u;
</programlisting>

      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
<!-- pgdoc-cn_end sig_en=9892e925beab3347fc61de0c68f3be53 -->

<!-- pgdoc-cn_start sig_en=7e4aaeb273cfbe7381b5baffe5461732 sig_cn_org=a29d60c32058df0d8801db243b32685f source=15.7 
   <para>
    Set-returning functions with <literal>OUT</literal> parameters
    (using <literal>RETURNS SETOF record</literal>) are also
    supported.  For example:
<programlisting>
CREATE FUNCTION multiout_simple_setof(n integer, OUT integer, OUT integer) RETURNS SETOF record AS $$
return [(1, 2)] * n
$$ LANGUAGE plpython3u;

SELECT * FROM multiout_simple_setof(3);
</programlisting>
   </para>
________________________________________________________-->
   <para>
    支持带<literal>OUT</literal>参数的返回集函数（使用<literal>RETURNS SETOF record</literal>）。
    例如：
<programlisting>
CREATE FUNCTION multiout_simple_setof(n integer, OUT integer, OUT integer) RETURNS SETOF record AS $$
return [(1, 2)] * n
$$ LANGUAGE plpython3u;

SELECT * FROM multiout_simple_setof(3);
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=7e4aaeb273cfbe7381b5baffe5461732 -->
  </sect2>
 </sect1>

 <sect1 id="plpython-sharing">
<!-- pgdoc-cn_start sig_en=7a22f9c85d2ca78d20e3ceea25b2aa1f sig_cn_org=None source=14.1 
  <title>Sharing Data</title>
________________________________________________________-->
  <title>共享数据</title>
<!-- pgdoc-cn_end sig_en=7a22f9c85d2ca78d20e3ceea25b2aa1f -->
<!-- pgdoc-cn_start sig_en=d8061f315c5a61c05322736ff3de0f6c sig_cn_org=None source=14.1 
  <para>
   The global dictionary <varname>SD</varname> is available to store
   private data between repeated calls to the same function.
   The global dictionary <varname>GD</varname> is public data,
   that is available to all Python functions within a session;  use with
   care.<indexterm><primary>global data</primary>
   <secondary>in PL/Python</secondary></indexterm>
  </para>
________________________________________________________-->
  <para>
   在对同一个函数的重复调用之间可用全局字典<varname>SD</varname>来存储私有数据。全局字典<varname>GD</varname>是公共数据，它对一个会话中的所有 Python 函数都可用，使用起来要小心。
   <indexterm><primary>全局数据</primary>
   <secondary>in PL/Python</secondary></indexterm>
  </para>
<!-- pgdoc-cn_end sig_en=d8061f315c5a61c05322736ff3de0f6c -->

<!-- pgdoc-cn_start sig_en=305bc9b0e103e05cf226afebcda543be sig_cn_org=None source=14.1 
  <para>
   Each function gets its own execution environment in the
   Python interpreter, so that global data and function arguments from
   <function>myfunc</function> are not available to
   <function>myfunc2</function>.  The exception is the data in the
   <varname>GD</varname> dictionary, as mentioned above.
  </para>
________________________________________________________-->
  <para>
   在 Python 解释器中每一个函数都会得到自己的执行环境，因此来自<function>myfunc</function>的全局数据和函数参数对<function>myfunc2</function>不可用。例外是<varname>GD</varname>字典中的数据。
  </para>
<!-- pgdoc-cn_end sig_en=305bc9b0e103e05cf226afebcda543be -->
 </sect1>

 <sect1 id="plpython-do">
<!-- pgdoc-cn_start sig_en=181ab5635a4fab9cfb9366b7b663a32b sig_cn_org=None source=14.1 
  <title>Anonymous Code Blocks</title>
________________________________________________________-->
  <title>匿名代码块</title>
<!-- pgdoc-cn_end sig_en=181ab5635a4fab9cfb9366b7b663a32b -->

<!-- pgdoc-cn_start sig_en=856ada8b54034dc1d74c4f25ffdac593 sig_cn_org=07ce8a0a6e02e926716646a47fce1a82 source=15.7 
  <para>
   PL/Python also supports anonymous code blocks called with the
   <xref linkend="sql-do"/> statement:

<programlisting>
DO $$
    # PL/Python code
$$ LANGUAGE plpython3u;
</programlisting>

   An anonymous code block receives no arguments, and whatever value it
   might return is discarded.  Otherwise it behaves just like a function.
  </para>
________________________________________________________-->
  <para>
   PL/Python还支持称为<xref linkend="sql-do"/>语句调用的匿名代码块：

<programlisting>
DO $$
    # PL/Python code
$$ LANGUAGE plpython3u;
</programlisting>

   匿名代码块不接收任何参数，并且它可能返回的任何值都将被丢弃。否则，它的行为就像一个函数。
</para>
<!-- pgdoc-cn_end sig_en=856ada8b54034dc1d74c4f25ffdac593 -->
 </sect1>

 <sect1 id="plpython-trigger">
<!-- pgdoc-cn_start sig_en=965893d4b4a1c249ddd8a87d973a20c7 sig_cn_org=None source=14.1 
  <title>Trigger Functions</title>
________________________________________________________-->
  <title>触发器函数</title>
<!-- pgdoc-cn_end sig_en=965893d4b4a1c249ddd8a87d973a20c7 -->

<!-- pgdoc-cn_start sig_en=2446d346d43b75ad763db0b9d52e9060 sig_cn_org=None source=14.1 
  <indexterm zone="plpython-trigger">
   <primary>trigger</primary>
   <secondary>in PL/Python</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="plpython-trigger">
   <primary>触发器</primary>
   <secondary>in PL/Python</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=2446d346d43b75ad763db0b9d52e9060 -->

<!-- pgdoc-cn_start sig_en=86356176efb08fe0211f8df82d871e8f sig_cn_org=None source=14.1 
  <para>
   When a function is used as a trigger, the dictionary
   <literal>TD</literal> contains trigger-related values:
   <variablelist>
    <varlistentry>
     <term><literal>TD["event"]</literal></term>
     <listitem>
      <para>
       contains the event as a string:
       <literal>INSERT</literal>, <literal>UPDATE</literal>,
       <literal>DELETE</literal>, or <literal>TRUNCATE</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["when"]</literal></term>
     <listitem>
      <para>
       contains one of <literal>BEFORE</literal>, <literal>AFTER</literal>, or
       <literal>INSTEAD OF</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["level"]</literal></term>
     <listitem>
      <para>
       contains <literal>ROW</literal> or <literal>STATEMENT</literal>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["new"]</literal></term>
     <term><literal>TD["old"]</literal></term>
     <listitem>
      <para>
       For a row-level trigger, one or both of these fields contain
       the respective trigger rows, depending on the trigger event.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["name"]</literal></term>
     <listitem>
      <para>
       contains the trigger name.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["table_name"]</literal></term>
     <listitem>
      <para>
       contains the name of the table on which the trigger occurred.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["table_schema"]</literal></term>
     <listitem>
      <para>
       contains the schema of the table on which the trigger occurred.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["relid"]</literal></term>
     <listitem>
      <para>
       contains the OID of the table on which the trigger occurred.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["args"]</literal></term>
     <listitem>
      <para>
       If the <command>CREATE TRIGGER</command> command
       included arguments, they are available in <literal>TD["args"][0]</literal> to
       <literal>TD["args"][<replaceable>n</replaceable>-1]</literal>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
________________________________________________________-->
  <para>
   当函数被用作触发器时，字典<literal>TD</literal>包含触发器相关的值：
   <variablelist>
    <varlistentry>
     <term><literal>TD["event"]</literal></term>
     <listitem>
      <para>
       包含字符串型的事件：<literal>INSERT</literal>、<literal>UPDATE</literal>、<literal>DELETE</literal>或者<literal>TRUNCATE</literal>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["when"]</literal></term>
     <listitem>
      <para>
       包含<literal>BEFORE</literal>、<literal>AFTER</literal>或者<literal>INSTEAD OF</literal>之一。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["level"]</literal></term>
     <listitem>
      <para>
       包含<literal>ROW</literal>或者<literal>STATEMENT</literal>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["new"]</literal></term>
     <term><literal>TD["old"]</literal></term>
     <listitem>
      <para>
       对于行级触发器，这些域的一个或者两个包含相应的触发器行，这取决于触发器事件是什么。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["name"]</literal></term>
     <listitem>
      <para>
       包含触发器的名称。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["table_name"]</literal></term>
     <listitem>
      <para>
       包含该触发器发生其上的表名。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["table_schema"]</literal></term>
     <listitem>
      <para>
       包含该触发器发生其上的表所属的模式名。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["relid"]</literal></term>
     <listitem>
      <para>
       包含该触发器发生其上的表的 OID。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["args"]</literal></term>
     <listitem>
      <para>
       如果<command>CREATE TRIGGER</command>命令包括参数，它们可以通过<literal>TD["args"][0]</literal>至<literal>TD["args"][<replaceable>n</replaceable>-1]</literal>使用。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
<!-- pgdoc-cn_end sig_en=86356176efb08fe0211f8df82d871e8f -->

<!-- pgdoc-cn_start sig_en=099d5f51a24b7b7d530a4f791667b916 sig_cn_org=None source=14.1 
  <para>
   If <literal>TD["when"]</literal> is <literal>BEFORE</literal> or
   <literal>INSTEAD OF</literal> and
   <literal>TD["level"]</literal> is <literal>ROW</literal>, you can
   return <literal>None</literal> or <literal>"OK"</literal> from the
   Python function to indicate the row is unmodified,
   <literal>"SKIP"</literal> to abort the event, or if <literal>TD["event"]</literal>
   is <command>INSERT</command> or <command>UPDATE</command> you can return
   <literal>"MODIFY"</literal> to indicate you've modified the new row.
   Otherwise the return value is ignored.
  </para>
________________________________________________________-->
  <para>
   如果<literal>TD["when"]</literal>是<literal>BEFORE</literal>或者<literal>INSTEAD OF</literal>并且<literal>TD["level"]</literal>是<literal>ROW</literal>，可以从 Python 函数返回<literal>None</literal>或者<literal>"OK"</literal>来表示行没有被修改。返回<literal>"SKIP"</literal>可以中止事件，或者在<literal>TD["event"]</literal>为<command>INSERT</command>或<command>UPDATE</command>时可以返回<literal>"MODIFY"</literal>以表示已经修改了新行。否则返回值会被忽略。
  </para>
<!-- pgdoc-cn_end sig_en=099d5f51a24b7b7d530a4f791667b916 -->
 </sect1>

 <sect1 id="plpython-database">
<!-- pgdoc-cn_start sig_en=ecbd9af8f318ffcee893cb0f3ff8f51b sig_cn_org=None source=14.1 
  <title>Database Access</title>
________________________________________________________-->
  <title>数据库访问</title>
<!-- pgdoc-cn_end sig_en=ecbd9af8f318ffcee893cb0f3ff8f51b -->

<!-- pgdoc-cn_start sig_en=ad60a7acde7173e50882207633523ba0 sig_cn_org=None source=14.1 
  <para>
   The PL/Python language module automatically imports a Python module
   called <literal>plpy</literal>.  The functions and constants in
   this module are available to you in the Python code as
   <literal>plpy.<replaceable>foo</replaceable></literal>.
  </para>
________________________________________________________-->
  <para>
   PL/Python 语言模块会自动导入一个被称为<literal>plpy</literal>的 Python 模块。这个模块中的函数和常量在 Python 代码中可以用<literal>plpy.<replaceable>foo</replaceable></literal>这样的方式访问。
  </para>
<!-- pgdoc-cn_end sig_en=ad60a7acde7173e50882207633523ba0 -->

  <sect2>
<!-- pgdoc-cn_start sig_en=f110af776f4116e68cd605f16aab443e sig_cn_org=None source=14.1 
    <title>Database Access Functions</title>
________________________________________________________-->
    <title>数据库访问函数</title>
<!-- pgdoc-cn_end sig_en=f110af776f4116e68cd605f16aab443e -->

<!-- pgdoc-cn_start sig_en=ada964c0c8883e28ea07a1d86a52c0c7 sig_cn_org=None source=14.1 
  <para>
   The <literal>plpy</literal> module provides several functions to execute
   database commands:
  </para>
________________________________________________________-->
  <para>
   <literal>plpy</literal>模块提供了几个函数来执行数据库命令：
  </para>
<!-- pgdoc-cn_end sig_en=ada964c0c8883e28ea07a1d86a52c0c7 -->

  <variablelist>
   <varlistentry>
    <term><literal>plpy.<function>execute</function>(<replaceable>query</replaceable> [, <replaceable>limit</replaceable>])</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=0b00f94ea1fa0d5d05cca303c9c9228d sig_cn_org=None source=14.1 
     <para>
      Calling <function>plpy.execute</function> with a query string and an
      optional row limit argument causes that query to be run and the result to
      be returned in a result object.
     </para>
________________________________________________________-->
     <para>
      用一个查询字符串和一个可选的行限制参数调用<function>plpy.execute</function>会让该查询运行并且其结果会被以一个结果对象返回。
     </para>
<!-- pgdoc-cn_end sig_en=0b00f94ea1fa0d5d05cca303c9c9228d -->

<!-- pgdoc-cn_start sig_en=769f29233b5c9553e674048739b733b9 sig_cn_org=652e6eb9d5be33984aba85e85f868679 source=15.7 
     <para>
      If <replaceable>limit</replaceable> is specified and is greater than
      zero, then <function>plpy.execute</function> retrieves at
      most <replaceable>limit</replaceable> rows, much as if the query
      included a <literal>LIMIT</literal>
      clause.  Omitting <replaceable>limit</replaceable> or specifying it as
      zero results in no row limit.
     </para>
________________________________________________________-->
     <para>
      如果指定了<replaceable>limit</replaceable>并且大于零，则<function>plpy.execute</function>检索最多<replaceable>limit</replaceable>行，就像查询包含<literal>LIMIT</literal>子句一样。省略<replaceable>limit</replaceable>或将其指定为零将导致没有行限制。
     </para>
<!-- pgdoc-cn_end sig_en=769f29233b5c9553e674048739b733b9 -->

<!-- pgdoc-cn_start sig_en=98ee269e5fea10aba999496ad47debda sig_cn_org=None source=14.1 
     <para>
      The result object emulates a list or dictionary object.  The result
      object can be accessed by row number and column name.  For example:
<programlisting>
rv = plpy.execute("SELECT * FROM my_table", 5)
</programlisting>
      returns up to 5 rows from <literal>my_table</literal>.  If
      <literal>my_table</literal> has a column
      <literal>my_column</literal>, it would be accessed as:
<programlisting>
foo = rv[i]["my_column"]
</programlisting>
      The number of rows returned can be obtained using the built-in
      <function>len</function> function.
     </para>
________________________________________________________-->
     <para>
      结果对象模拟一个列表或者字典对象。可以用行号和列名来访问结果对象。例如：
<programlisting>
rv = plpy.execute("SELECT * FROM my_table", 5)
</programlisting>
      会从<literal>my_table</literal>中返回 5 行。如果<literal>my_table</literal>有一列是<literal>my_column</literal>，可以这样来访问它：
<programlisting>
foo = rv[i]["my_column"]
</programlisting>
      可以用内建的<function>len</function>函数获得返回的行数。
     </para>
<!-- pgdoc-cn_end sig_en=98ee269e5fea10aba999496ad47debda -->

<!-- pgdoc-cn_start sig_en=4e839e03256ecb5fb01b8cabf55eca43 sig_cn_org=None source=14.1 
     <para>
      The result object has these additional methods:
      <variablelist>
       <varlistentry>
        <term><literal><function>nrows</function>()</literal></term>
        <listitem>
         <para>
          Returns the number of rows processed by the command.  Note that this
          is not necessarily the same as the number of rows returned.  For
          example, an <command>UPDATE</command> command will set this value but
          won't return any rows (unless <literal>RETURNING</literal> is used).
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal><function>status</function>()</literal></term>
        <listitem>
         <para>
          The <function>SPI_execute()</function> return value.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal><function>colnames</function>()</literal></term>
        <term><literal><function>coltypes</function>()</literal></term>
        <term><literal><function>coltypmods</function>()</literal></term>
        <listitem>
         <para>
          Return a list of column names, list of column type OIDs, and list of
          type-specific type modifiers for the columns, respectively.
         </para>

         <para>
          These methods raise an exception when called on a result object from
          a command that did not produce a result set, e.g.,
          <command>UPDATE</command> without <literal>RETURNING</literal>, or
          <command>DROP TABLE</command>.  But it is OK to use these methods on
          a result set containing zero rows.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal><function>__str__</function>()</literal></term>
        <listitem>
         <para>
          The standard <literal>__str__</literal> method is defined so that it
          is possible for example to debug query execution results
          using <literal>plpy.debug(rv)</literal>.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
________________________________________________________-->
     <para>
      结果对象有这些额外的方法：
      <variablelist>
       <varlistentry>
        <term><literal><function>nrows</function>()</literal></term>
        <listitem>
         <para>
          返回被该命令处理的行数。注意这不一定与返回的行数相同。例如，<command>UPDATE</command>命令将会设置这个值但是不返回任何行（除非使用<literal>RETURNING</literal>）。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal><function>status</function>()</literal></term>
        <listitem>
         <para>
          <function>SPI_execute()</function>的返回值。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal><function>colnames</function>()</literal></term>
        <term><literal><function>coltypes</function>()</literal></term>
        <term><literal><function>coltypmods</function>()</literal></term>
        <listitem>
         <para>
          分别返回一个列名列表、列类型 OID 列表以及列的类型相关的类型修饰符列表。
         </para>

         <para>
          在来自于不产生结果集合的命令的结果对象上调用这些方法会产生异常，例如不带<literal>RETURNING</literal>的<command>UPDATE</command>或者<command>DROP TABLE</command>。但是在包含的行数为零的结果集合上使用这些方法是 OK 的。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal><function>__str__</function>()</literal></term>
        <listitem>
         <para>
          也定义了标准的<literal>__str__</literal>方法，例如可以使用<literal>plpy.debug(rv)</literal>来调试查询执行结果。
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
<!-- pgdoc-cn_end sig_en=4e839e03256ecb5fb01b8cabf55eca43 -->

<!-- pgdoc-cn_start sig_en=71d2f9d3b71b24d4fc0d2df5fbacd4cd sig_cn_org=None source=14.1 
     <para>
      The result object can be modified.
     </para>
________________________________________________________-->
     <para>
      结果对象可以被修改。
     </para>
<!-- pgdoc-cn_end sig_en=71d2f9d3b71b24d4fc0d2df5fbacd4cd -->

<!-- pgdoc-cn_start sig_en=acbb79f21243ebf31d4abb5780d525ff sig_cn_org=None source=14.1 
     <para>
      Note that calling <literal>plpy.execute</literal> will cause the entire
      result set to be read into memory.  Only use that function when you are
      sure that the result set will be relatively small.  If you don't want to
      risk excessive memory usage when fetching large results,
      use <literal>plpy.cursor</literal> rather
      than <literal>plpy.execute</literal>.
     </para>
________________________________________________________-->
     <para>
      注意调用<literal>plpy.execute</literal>将会导致整个结果集合被读入到内存中。只有当确信结果集相对比较小时才应使用这个函数。在取得大型结果时，如果不想冒着耗尽内存的风险，应使用<literal>plpy.cursor</literal>而不是<literal>plpy.execute</literal>。
     </para>
<!-- pgdoc-cn_end sig_en=acbb79f21243ebf31d4abb5780d525ff -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>plpy.<function>prepare</function>(<replaceable>query</replaceable> [, <replaceable>argtypes</replaceable>])</literal></term>
    <term><literal>plpy.<function>execute</function>(<replaceable>plan</replaceable> [, <replaceable>arguments</replaceable> [, <replaceable>limit</replaceable>]])</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=93f75be7059be59e9a583231e42c9c97 sig_cn_org=None source=14.1 
     <para>
      <indexterm><primary>preparing a query</primary><secondary>in PL/Python</secondary></indexterm>
      <function>plpy.prepare</function> prepares the execution plan for a
      query.  It is called with a query string and a list of parameter types,
      if you have parameter references in the query.  For example:
<programlisting>
plan = plpy.prepare("SELECT last_name FROM my_users WHERE first_name = $1", ["text"])
</programlisting>
      <literal>text</literal> is the type of the variable you will be passing
      for <literal>$1</literal>.  The second argument is optional if you don't
      want to pass any parameters to the query.
     </para>
________________________________________________________-->
     <para>
      <indexterm><primary>准备一个查询</primary><secondary>in PL/Python</secondary></indexterm>
      <function>plpy.prepare</function>为一个查询准备执行计划。它的参数是一个查询串和一个参数类型列表（如果查询中有参数引用）。例如：
<programlisting>
plan = plpy.prepare("SELECT last_name FROM my_users WHERE first_name = $1", ["text"])
</programlisting>
      <literal>text</literal>是要为<literal>$1</literal>传递的变量的类型。如果不想给查询传递任何参数，第二个参数就是可选的。
     </para>
<!-- pgdoc-cn_end sig_en=93f75be7059be59e9a583231e42c9c97 -->
<!-- pgdoc-cn_start sig_en=d8e36ab1c2f8a227be038a2aed58a7b6 sig_cn_org=None source=14.1 
     <para>
      After preparing a statement, you use a variant of the
      function <function>plpy.execute</function> to run it:
<programlisting>
rv = plpy.execute(plan, ["name"], 5)
</programlisting>
      Pass the plan as the first argument (instead of the query string), and a
      list of values to substitute into the query as the second argument.  The
      second argument is optional if the query does not expect any parameters.
      The third argument is the optional row limit as before.
     </para>
________________________________________________________-->
     <para>
      在准备好一个语句后，可以使用函数<function>plpy.execute</function>的一种变体来运行它：
<programlisting>
rv = plpy.execute(plan, ["name"], 5)
</programlisting>
      把计划作为第一个参数传递（而不是查询字符串），并且把要替换到查询中的值列表作为第二个参数传递。如果查询不需要任何参数，则第二个参数是可选的。和前面一样，第三个参数是可选的，它用来指定行数限制。
     </para>
<!-- pgdoc-cn_end sig_en=d8e36ab1c2f8a227be038a2aed58a7b6 -->

<!-- pgdoc-cn_start sig_en=09378a6d805f99d724d37fb4870afe29 sig_cn_org=None source=14.1 
     <para>
      Alternatively, you can call the <function>execute</function> method on
      the plan object:
<programlisting>
rv = plan.execute(["name"], 5)
</programlisting>
     </para>
________________________________________________________-->
     <para>
      另外，你可以在计划对象上调用<function>execute</function>方法：
<programlisting>
rv = plan.execute(["name"], 5)
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=09378a6d805f99d724d37fb4870afe29 -->

<!-- pgdoc-cn_start sig_en=5b58b06a5064567e65cfe6f7c046d18b sig_cn_org=None source=14.1 
     <para>
      Query parameters and result row fields are converted between PostgreSQL
      and Python data types as described in <xref linkend="plpython-data"/>.
     </para>
________________________________________________________-->
     <para>
      查询参数以及结果行域会按照<xref linkend="plpython-data"/>中所述在 PostgreSQL 和 Python 数据类型之间转换。
     </para>
<!-- pgdoc-cn_end sig_en=5b58b06a5064567e65cfe6f7c046d18b -->

<!-- pgdoc-cn_start sig_en=ce095aea160e141194958fb7f9f62de3 sig_cn_org=5c8146aac883cb7688ad7d10480b05b0 source=15.7 
     <para>
      When you prepare a plan using the PL/Python module it is automatically
      saved.  Read the SPI documentation (<xref linkend="spi"/>) for a
      description of what this means.  In order to make effective use of this
      across function calls one needs to use one of the persistent storage
      dictionaries <literal>SD</literal> or <literal>GD</literal> (see
      <xref linkend="plpython-sharing"/>). For example:
<programlisting>
CREATE FUNCTION usesavedplan() RETURNS trigger AS $$
    if "plan" in SD:
        plan = SD["plan"]
    else:
        plan = plpy.prepare("SELECT 1")
        SD["plan"] = plan
    # rest of function
$$ LANGUAGE plpython3u;
</programlisting>
     </para>
________________________________________________________-->
     <para>
      当您使用PL/Python模块准备计划时，它会自动保存。阅读SPI文档（<xref linkend="spi"/>）以了解这意味着什么。
      为了在函数调用之间有效地使用这个功能，需要使用其中一个持久存储字典<literal>SD</literal>或<literal>GD</literal>（参见<xref linkend="plpython-sharing"/>）。例如：
<programlisting>
CREATE FUNCTION usesavedplan() RETURNS trigger AS $$
    if "plan" in SD:
        plan = SD["plan"]
    else:
        plan = plpy.prepare("SELECT 1")
        SD["plan"] = plan
    # rest of function
$$ LANGUAGE plpython3u;
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=ce095aea160e141194958fb7f9f62de3 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>plpy.<function>cursor</function>(<replaceable>query</replaceable>)</literal></term>
    <term><literal>plpy.<function>cursor</function>(<replaceable>plan</replaceable> [, <replaceable>arguments</replaceable>])</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=00b5deedb519857b0cc9d8b6927d43f3 sig_cn_org=None source=14.1 
     <para>
      The <literal>plpy.cursor</literal> function accepts the same arguments
      as <literal>plpy.execute</literal> (except for the row limit) and returns
      a cursor object, which allows you to process large result sets in smaller
      chunks.  As with <literal>plpy.execute</literal>, either a query string
      or a plan object along with a list of arguments can be used, or
      the <function>cursor</function> function can be called as a method of
      the plan object.
     </para>
________________________________________________________-->
     <para>
      <literal>plpy.cursor</literal>函数接受和<literal>plpy.execute</literal>相同的参数（行数限制除外）并且返回一个游标对象，它允许以较小的块来处理大型的结果集合。和<literal>plpy.execute</literal>一样（行数限制除外），既可以使用一个查询字符串，也可以使用带有参数列表的计划对象，或者<function>cursor</function>函数可以作为计划对象的一个方法来调用。
     </para>
<!-- pgdoc-cn_end sig_en=00b5deedb519857b0cc9d8b6927d43f3 -->

<!-- pgdoc-cn_start sig_en=b12879ac67527bdba5022df9feca5735 sig_cn_org=None source=14.1 
     <para>
      The cursor object provides a <literal>fetch</literal> method that accepts
      an integer parameter and returns a result object.  Each time you
      call <literal>fetch</literal>, the returned object will contain the next
      batch of rows, never larger than the parameter value.  Once all rows are
      exhausted, <literal>fetch</literal> starts returning an empty result
      object.  Cursor objects also provide an
      <ulink url="https://docs.python.org/library/stdtypes.html#iterator-types">iterator
      interface</ulink>, yielding one row at a time until all rows are
      exhausted.  Data fetched that way is not returned as result objects, but
      rather as dictionaries, each dictionary corresponding to a single result
      row.
     </para>
________________________________________________________-->
     <para>
      游标对象提供了一种<literal>fetch</literal>方法，它接受一个整数参数并返回一个结果对象。每次调用<literal>fetch</literal>，返回的对象将包含下一批行，行数不会超过参数值。一旦所有的行都被消耗掉，<literal>fetch</literal>会开始返回一个空的结果对象。游标对象也提供一种<ulink url="https://docs.python.org/library/stdtypes.html#iterator-types">迭代器接口</ulink>，它一次得到一行直到所有行被耗尽。用这种方法取得的数据不会被作为结果对象返回，而是以字典的形式返回，每一个字典对应于一个结果行。
     </para>
<!-- pgdoc-cn_end sig_en=b12879ac67527bdba5022df9feca5735 -->

<!-- pgdoc-cn_start sig_en=bd3008ab6f1f3b8997f8ccd7b1084394 sig_cn_org=f92c908454269a5e3a785a1c459bb764 source=15.7 
     <para>
      An example of two ways of processing data from a large table is:
<programlisting>
CREATE FUNCTION count_odd_iterator() RETURNS integer AS $$
odd = 0
for row in plpy.cursor("select num from largetable"):
    if row['num'] % 2:
         odd += 1
return odd
$$ LANGUAGE plpython3u;

CREATE FUNCTION count_odd_fetch(batch_size integer) RETURNS integer AS $$
odd = 0
cursor = plpy.cursor("select num from largetable")
while True:
    rows = cursor.fetch(batch_size)
    if not rows:
        break
    for row in rows:
        if row['num'] % 2:
            odd += 1
return odd
$$ LANGUAGE plpython3u;

CREATE FUNCTION count_odd_prepared() RETURNS integer AS $$
odd = 0
plan = plpy.prepare("select num from largetable where num % $1 &lt;&gt; 0", ["integer"])
rows = list(plpy.cursor(plan, [2]))  # or: = list(plan.cursor([2]))

return len(rows)
$$ LANGUAGE plpython3u;
</programlisting>
     </para>
________________________________________________________-->
     <para>
      从一个大表中处理数据的两种方式示例是：
<programlisting>
CREATE FUNCTION count_odd_iterator() RETURNS integer AS $$
odd = 0
for row in plpy.cursor("select num from largetable"):
    if row['num'] % 2:
         odd += 1
return odd
$$ LANGUAGE plpython3u;

CREATE FUNCTION count_odd_fetch(batch_size integer) RETURNS integer AS $$
odd = 0
cursor = plpy.cursor("select num from largetable")
while True:
    rows = cursor.fetch(batch_size)
    if not rows:
        break
    for row in rows:
        if row['num'] % 2:
            odd += 1
return odd
$$ LANGUAGE plpython3u;

CREATE FUNCTION count_odd_prepared() RETURNS integer AS $$
odd = 0
plan = plpy.prepare("select num from largetable where num % $1 &lt;&gt; 0", ["integer"])
rows = list(plpy.cursor(plan, [2]))  # or: = list(plan.cursor([2]))

return len(rows)
$$ LANGUAGE plpython3u;
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=bd3008ab6f1f3b8997f8ccd7b1084394 -->

<!-- pgdoc-cn_start sig_en=4e1853bfebdacd2be1b68a33b5f9931d sig_cn_org=None source=14.1 
     <para>
      Cursors are automatically disposed of.  But if you want to explicitly
      release all resources held by a cursor, use the <literal>close</literal>
      method.  Once closed, a cursor cannot be fetched from anymore.
     </para>
________________________________________________________-->
     <para>
      游标会被自动丢弃掉。但是如果想要显式地释放游标所持有的所有资源，可使用<literal>close</literal>方法。一旦被关闭，就再也不能从游标中取得数据。
     </para>
<!-- pgdoc-cn_end sig_en=4e1853bfebdacd2be1b68a33b5f9931d -->

     <tip>
<!-- pgdoc-cn_start sig_en=82a04d86c3c26e0d9ae9b6b63bb31916 sig_cn_org=None source=14.1 
      <para>
        Do not confuse objects created by <literal>plpy.cursor</literal> with
        DB-API cursors as defined by
        the <ulink url="https://www.python.org/dev/peps/pep-0249/">Python
        Database API specification</ulink>.  They don't have anything in common
        except for the name.
      </para>
________________________________________________________-->
      <para>
        不要把<literal>plpy.cursor</literal>创建的游标对象与<ulink url="https://www.python.org/dev/peps/pep-0249/">Python Database API specification</ulink>定义的 DB-API 游标弄混。除了名字之外，它们之间没有任何共同点。
      </para>
<!-- pgdoc-cn_end sig_en=82a04d86c3c26e0d9ae9b6b63bb31916 -->
     </tip>
    </listitem>
   </varlistentry>
  </variablelist>

  </sect2>

  <sect2 id="plpython-trapping">
<!-- pgdoc-cn_start sig_en=33720809531e26832b215af3db19d54d sig_cn_org=None source=14.1 
   <title>Trapping Errors</title>
________________________________________________________-->
   <title>捕捉错误</title>
<!-- pgdoc-cn_end sig_en=33720809531e26832b215af3db19d54d -->

<!-- pgdoc-cn_start sig_en=e1958c8ba0ebb00c0f9d695fca21ccbf sig_cn_org=65a4bb6196f6877de754d09d147e0186 source=15.7 
   <para>
    Functions accessing the database might encounter errors, which
    will cause them to abort and raise an exception.  Both
    <function>plpy.execute</function> and
    <function>plpy.prepare</function> can raise an instance of a subclass of
    <literal>plpy.SPIError</literal>, which by default will terminate
    the function.  This error can be handled just like any other
    Python exception, by using the <literal>try/except</literal>
    construct.  For example:
<programlisting>
CREATE FUNCTION try_adding_joe() RETURNS text AS $$
    try:
        plpy.execute("INSERT INTO users(username) VALUES ('joe')")
    except plpy.SPIError:
        return "something went wrong"
    else:
        return "Joe added"
$$ LANGUAGE plpython3u;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    访问数据库的函数可能会遇到错误，这将导致它们中止并引发异常。 
    <function>plpy.execute</function>和
    <function>plpy.prepare</function>都可以引发<literal>plpy.SPIError</literal>的子类实例，
    默认情况下会终止函数。 
    这个错误可以像处理其他Python异常一样处理，使用<literal>try/except</literal>结构。 
    例如：
<programlisting>
CREATE FUNCTION try_adding_joe() RETURNS text AS $$
    try:
        plpy.execute("INSERT INTO users(username) VALUES ('joe')")
    except plpy.SPIError:
        return "something went wrong"
    else:
        return "Joe added"
$$ LANGUAGE plpython3u;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=e1958c8ba0ebb00c0f9d695fca21ccbf -->

<!-- pgdoc-cn_start sig_en=9accd96da857ab84424c6f84e6776295 sig_cn_org=e8d616da61d91a52e8cecc585cf3c43e source=15.7 
   <para>
    The actual class of the exception being raised corresponds to the
    specific condition that caused the error.  Refer
    to <xref linkend="errcodes-table"/> for a list of possible
    conditions.  The module
    <literal>plpy.spiexceptions</literal> defines an exception class
    for each <productname>PostgreSQL</productname> condition, deriving
    their names from the condition name.  For
    instance, <literal>division_by_zero</literal>
    becomes <literal>DivisionByZero</literal>, <literal>unique_violation</literal>
    becomes <literal>UniqueViolation</literal>, <literal>fdw_error</literal>
    becomes <literal>FdwError</literal>, and so on.  Each of these
    exception classes inherits from <literal>SPIError</literal>.  This
    separation makes it easier to handle specific errors, for
    instance:
<programlisting>
CREATE FUNCTION insert_fraction(numerator int, denominator int) RETURNS text AS $$
from plpy import spiexceptions
try:
    plan = plpy.prepare("INSERT INTO fractions (frac) VALUES ($1 / $2)", ["int", "int"])
    plpy.execute(plan, [numerator, denominator])
except spiexceptions.DivisionByZero:
    return "denominator cannot equal zero"
except spiexceptions.UniqueViolation:
    return "already have that fraction"
except plpy.SPIError as e:
    return "other error, SQLSTATE %s" % e.sqlstate
else:
    return "fraction inserted"
$$ LANGUAGE plpython3u;
</programlisting>
    Note that because all exceptions from
    the <literal>plpy.spiexceptions</literal> module inherit
    from <literal>SPIError</literal>, an <literal>except</literal>
    clause handling it will catch any database access error.
   </para>
________________________________________________________-->
   <para>
    抛出的异常的实际类对应于导致错误的特定条件。参考<xref linkend="errcodes-table"/>以获取可能条件的列表。
    模块<literal>plpy.spiexceptions</literal>为每个<productname>PostgreSQL</productname>条件定义了一个异常类，
    从条件名称派生它们的名称。例如，<literal>division_by_zero</literal>变成<literal>DivisionByZero</literal>，
    <literal>unique_violation</literal>变成<literal>UniqueViolation</literal>，<literal>fdw_error</literal>变成
    <literal>FdwError</literal>，依此类推。每个异常类都继承自<literal>SPIError</literal>。这种分离使得更容易处理特定错误，
    例如：
<programlisting>
CREATE FUNCTION insert_fraction(numerator int, denominator int) RETURNS text AS $$
from plpy import spiexceptions
try:
    plan = plpy.prepare("INSERT INTO fractions (frac) VALUES ($1 / $2)", ["int", "int"])
    plpy.execute(plan, [numerator, denominator])
except spiexceptions.DivisionByZero:
    return "denominator cannot equal zero"
except spiexceptions.UniqueViolation:
    return "already have that fraction"
except plpy.SPIError as e:
    return "other error, SQLSTATE %s" % e.sqlstate
else:
    return "fraction inserted"
$$ LANGUAGE plpython3u;
</programlisting>
    请注意，由于<literal>plpy.spiexceptions</literal>模块中的所有异常都继承自<literal>SPIError</literal>，
    处理它的<literal>except</literal>子句将捕获任何数据库访问错误。
   </para>
<!-- pgdoc-cn_end sig_en=9accd96da857ab84424c6f84e6776295 -->

<!-- pgdoc-cn_start sig_en=acf3106d56b96969259c25404d10e597 sig_cn_org=None source=14.1 
   <para>
    As an alternative way of handling different error conditions, you
    can catch the <literal>SPIError</literal> exception and determine
    the specific error condition inside the <literal>except</literal>
    block by looking at the <literal>sqlstate</literal> attribute of
    the exception object.  This attribute is a string value containing
    the <quote>SQLSTATE</quote> error code.  This approach provides
    approximately the same functionality
   </para>
________________________________________________________-->
   <para>
    作为另一种处理不同错误情况的方法，可以捕捉<literal>SPIError</literal>异常并且在<literal>except</literal>块中通过查看异常对象的<literal>sqlstate</literal>属性来判断错误情况。这种属性是包含着<quote>SQLSTATE</quote>错误代码的一个字符串值。这种方法提供了近乎相同的功能
   </para>
<!-- pgdoc-cn_end sig_en=acf3106d56b96969259c25404d10e597 -->
  </sect2>
 </sect1>

 <sect1 id="plpython-subtransaction">
<!-- pgdoc-cn_start sig_en=296e002cd1f2d133f216353f7eb8f6d1 sig_cn_org=None source=14.1 
  <title>Explicit Subtransactions</title>
________________________________________________________-->
  <title>显式子事务</title>
<!-- pgdoc-cn_end sig_en=296e002cd1f2d133f216353f7eb8f6d1 -->

<!-- pgdoc-cn_start sig_en=0a880fea23881bff3dc9cd0d5343734e sig_cn_org=None source=14.1 
  <para>
   Recovering from errors caused by database access as described in
   <xref linkend="plpython-trapping"/> can lead to an undesirable
   situation where some operations succeed before one of them fails,
   and after recovering from that error the data is left in an
   inconsistent state.  PL/Python offers a solution to this problem in
   the form of explicit subtransactions.
  </para>
________________________________________________________-->
  <para>
   按<xref linkend="plpython-trapping"/>中所述的从数据库访问导致的错误中恢复可能导致不好的情况：某些操作在其中一个操作失败之前已经成功，并且在从错误中恢复后这些操作的数据形成了一种不一致的状态。PL/Python 通过显式子事务的形式为这种问题提供了一套解决方案。
  </para>
<!-- pgdoc-cn_end sig_en=0a880fea23881bff3dc9cd0d5343734e -->

  <sect2>
<!-- pgdoc-cn_start sig_en=e39810f1eb08fe7ba9ef0f77f9186612 sig_cn_org=None source=14.1 
   <title>Subtransaction Context Managers</title>
________________________________________________________-->
   <title>子事务上下文管理器</title>
<!-- pgdoc-cn_end sig_en=e39810f1eb08fe7ba9ef0f77f9186612 -->

<!-- pgdoc-cn_start sig_en=41abdaa0855cae672c74d3926c8cb118 sig_cn_org=77f6d204486da4f888d9840404aa35b0 source=15.7 
   <para>
    Consider a function that implements a transfer between two
    accounts:
<programlisting>
CREATE FUNCTION transfer_funds() RETURNS void AS $$
try:
    plpy.execute("UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'")
    plpy.execute("UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'")
except plpy.SPIError as e:
    result = "error transferring funds: %s" % e.args
else:
    result = "funds transferred correctly"
plan = plpy.prepare("INSERT INTO operations (result) VALUES ($1)", ["text"])
plpy.execute(plan, [result])
$$ LANGUAGE plpython3u;
</programlisting>
    If the second <literal>UPDATE</literal> statement results in an
    exception being raised, this function will report the error, but
    the result of the first <literal>UPDATE</literal> will
    nevertheless be committed.  In other words, the funds will be
    withdrawn from Joe's account, but will not be transferred to
    Mary's account.
   </para>
________________________________________________________-->
   <para>
    考虑一个实现两个账户之间转账的函数：
<programlisting>
CREATE FUNCTION transfer_funds() RETURNS void AS $$
try:
    plpy.execute("UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'")
    plpy.execute("UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'")
except plpy.SPIError as e:
    result = "error transferring funds: %s" % e.args
else:
    result = "funds transferred correctly"
plan = plpy.prepare("INSERT INTO operations (result) VALUES ($1)", ["text"])
plpy.execute(plan, [result])
$$ LANGUAGE plpython3u;
</programlisting>
    如果第二个<literal>UPDATE</literal>语句导致异常被触发，该函数将报告错误，但是第一个<literal>UPDATE</literal>的结果仍将被提交。
    换句话说，资金将从Joe的账户中提取，但不会转账到Mary的账户。
</para>
<!-- pgdoc-cn_end sig_en=41abdaa0855cae672c74d3926c8cb118 -->

<!-- pgdoc-cn_start sig_en=607bfa39ba6cd3cf9adc7cf1751ecb0f sig_cn_org=8448535087008483485f2837e715179c source=15.7 
   <para>
    To avoid such issues, you can wrap your
    <literal>plpy.execute</literal> calls in an explicit
    subtransaction.  The <literal>plpy</literal> module provides a
    helper object to manage explicit subtransactions that gets created
    with the <literal>plpy.subtransaction()</literal> function.
    Objects created by this function implement the
    <ulink url="https://docs.python.org/library/stdtypes.html#context-manager-types">
    context manager interface</ulink>.  Using explicit subtransactions
    we can rewrite our function as:
<programlisting>
CREATE FUNCTION transfer_funds2() RETURNS void AS $$
try:
    with plpy.subtransaction():
        plpy.execute("UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'")
        plpy.execute("UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'")
except plpy.SPIError as e:
    result = "error transferring funds: %s" % e.args
else:
    result = "funds transferred correctly"
plan = plpy.prepare("INSERT INTO operations (result) VALUES ($1)", ["text"])
plpy.execute(plan, [result])
$$ LANGUAGE plpython3u;
</programlisting>
    Note that the use of <literal>try</literal>/<literal>except</literal> is still
    required.  Otherwise the exception would propagate to the top of
    the Python stack and would cause the whole function to abort with
    a <productname>PostgreSQL</productname> error, so that the
    <literal>operations</literal> table would not have any row
    inserted into it.  The subtransaction context manager does not
    trap errors, it only assures that all database operations executed
    inside its scope will be atomically committed or rolled back.  A
    rollback of the subtransaction block occurs on any kind of
    exception exit, not only ones caused by errors originating from
    database access.  A regular Python exception raised inside an
    explicit subtransaction block would also cause the subtransaction
    to be rolled back.
   </para>
________________________________________________________-->
   <para>
    为了避免这种问题，您可以将<literal>plpy.execute</literal>调用包装在显式子事务中。
    <literal>plpy</literal>模块提供了一个帮助对象来管理显式子事务，该对象通过
    <literal>plpy.subtransaction()</literal>函数创建。
    由此函数创建的对象实现了
    <ulink url="https://docs.python.org/library/stdtypes.html#context-manager-types">
    上下文管理器接口</ulink>。使用显式子事务，我们可以重写我们的函数如下：
<programlisting>
CREATE FUNCTION transfer_funds2() RETURNS void AS $$
try:
    with plpy.subtransaction():
        plpy.execute("UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'")
        plpy.execute("UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'")
except plpy.SPIError as e:
    result = "error transferring funds: %s" % e.args
else:
    result = "funds transferred correctly"
plan = plpy.prepare("INSERT INTO operations (result) VALUES ($1)", ["text"])
plpy.execute(plan, [result])
$$ LANGUAGE plpython3u;
</programlisting>
    请注意，仍然需要使用<literal>try</literal>/<literal>except</literal>。
    否则，异常将传播到Python堆栈的顶部，并导致整个函数中止，
    并显示<productname>PostgreSQL</productname>错误，因此
    <literal>operations</literal>表将不会插入任何行。
    子事务上下文管理器不会捕获错误，它只确保其范围内执行的所有数据库操作
    将被原子地提交或回滚。子事务块的回滚发生在任何类型的异常退出时，
    不仅仅是由数据库访问引起的错误。在显式子事务块中引发的常规Python异常
    也会导致子事务被回滚。
   </para>
<!-- pgdoc-cn_end sig_en=607bfa39ba6cd3cf9adc7cf1751ecb0f -->
  </sect2>
 </sect1>

 <sect1 id="plpython-transactions">
<!-- pgdoc-cn_start sig_en=168b9264e23c07090b9e1a29f31a5165 sig_cn_org=None source=14.1 
  <title>Transaction Management</title>
________________________________________________________-->
  <title>事务管理</title>
<!-- pgdoc-cn_end sig_en=168b9264e23c07090b9e1a29f31a5165 -->

<!-- pgdoc-cn_start sig_en=cee48e6960d750af66a4c5271333382d sig_cn_org=None source=14.1 
  <para>
   In a procedure called from the top level or an anonymous code block
   (<command>DO</command> command) called from the top level it is possible to
   control transactions.  To commit the current transaction, call
   <literal>plpy.commit()</literal>.  To roll back the current transaction,
   call <literal>plpy.rollback()</literal>.  (Note that it is not possible to
   run the SQL commands <command>COMMIT</command> or
   <command>ROLLBACK</command> via <function>plpy.execute</function> or
   similar.  It has to be done using these functions.)  After a transaction is
   ended, a new transaction is automatically started, so there is no separate
   function for that.
  </para>
________________________________________________________-->
  <para>
   在从顶层调用的过程中或者从顶层调用的匿名代码块（<command>DO</command>命令）中，可以控制事务。要提交当前的事务，可调用<literal>plpy.commit()</literal>。要回滚当前事务，可调用<literal>plpy.rollback()</literal>（注意不能通过<function>plpy.execute</function>或类似的函数运行SQL命令<command>COMMIT</command>或者<command>ROLLBACK</command>。这类工作必须用这些函数完成）。在事务结束以后，一个新的事务会自动开始，因此没有独立的函数用来开始新事务。
  </para>
<!-- pgdoc-cn_end sig_en=cee48e6960d750af66a4c5271333382d -->

<!-- pgdoc-cn_start sig_en=eca0cf48cd533dd2d532c3d97ffbd54a sig_cn_org=6a21e338968dafbadd6d188bb2371845 source=15.7 
  <para>
   Here is an example:
<programlisting>
CREATE PROCEDURE transaction_test1()
LANGUAGE plpython3u
AS $$
for i in range(0, 10):
    plpy.execute("INSERT INTO test1 (a) VALUES (%d)" % i)
    if i % 2 == 0:
        plpy.commit()
    else:
        plpy.rollback()
$$;

CALL transaction_test1();
</programlisting>
  </para>
________________________________________________________-->
  <para>
   这里是一个示例:
<programlisting>
CREATE PROCEDURE transaction_test1()
LANGUAGE plpython3u
AS $$
for i in range(0, 10):
    plpy.execute("INSERT INTO test1 (a) VALUES (%d)" % i)
    if i % 2 == 0:
        plpy.commit()
    else:
        plpy.rollback()
$$;

CALL transaction_test1();
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=eca0cf48cd533dd2d532c3d97ffbd54a -->

<!-- pgdoc-cn_start sig_en=e57c06832c6afc2871ce468fbfc96bee sig_cn_org=None source=14.1 
  <para>
   Transactions cannot be ended when an explicit subtransaction is active.
  </para>
________________________________________________________-->
  <para>
   当一个显式的子事务处于活跃状态时，事务不能被结束。
  </para>
<!-- pgdoc-cn_end sig_en=e57c06832c6afc2871ce468fbfc96bee -->
 </sect1>

 <sect1 id="plpython-util">
<!-- pgdoc-cn_start sig_en=4775e42f20462e457bc07419c2c93a2a sig_cn_org=None source=14.1 
  <title>Utility Functions</title>
________________________________________________________-->
  <title>实用函数</title>
<!-- pgdoc-cn_end sig_en=4775e42f20462e457bc07419c2c93a2a -->
<!-- pgdoc-cn_start sig_en=5df5ceeba51ea4a8db9b8a2d00cb2726 sig_cn_org=None source=14.1 
  <para>
   The <literal>plpy</literal> module also provides the functions
   <simplelist>
    <member><literal>plpy.debug(<replaceable>msg, **kwargs</replaceable>)</literal></member>
    <member><literal>plpy.log(<replaceable>msg, **kwargs</replaceable>)</literal></member>
    <member><literal>plpy.info(<replaceable>msg, **kwargs</replaceable>)</literal></member>
    <member><literal>plpy.notice(<replaceable>msg, **kwargs</replaceable>)</literal></member>
    <member><literal>plpy.warning(<replaceable>msg, **kwargs</replaceable>)</literal></member>
    <member><literal>plpy.error(<replaceable>msg, **kwargs</replaceable>)</literal></member>
    <member><literal>plpy.fatal(<replaceable>msg, **kwargs</replaceable>)</literal></member>
   </simplelist>
   <indexterm><primary>elog</primary><secondary>in PL/Python</secondary></indexterm>
   <function>plpy.error</function> and <function>plpy.fatal</function>
   actually raise a Python exception which, if uncaught, propagates out to
   the calling query, causing the current transaction or subtransaction to
   be aborted.  <literal>raise plpy.Error(<replaceable>msg</replaceable>)</literal> and
   <literal>raise plpy.Fatal(<replaceable>msg</replaceable>)</literal> are
   equivalent to calling <literal>plpy.error(<replaceable>msg</replaceable>)</literal> and
   <literal>plpy.fatal(<replaceable>msg</replaceable>)</literal>, respectively but
   the <literal>raise</literal> form does not allow passing keyword arguments.
   The other functions only generate messages of different priority levels.
   Whether messages of a particular priority are reported to the client,
   written to the server log, or both is controlled by the
   <xref linkend="guc-log-min-messages"/> and
   <xref linkend="guc-client-min-messages"/> configuration
   variables. See <xref linkend="runtime-config"/> for more information.
  </para>
________________________________________________________-->
  <para>
   <literal>plpy</literal>模块也提供了函数
   <simplelist>
    <member><literal>plpy.debug(<replaceable>msg, **kwargs</replaceable>)</literal></member>
    <member><literal>plpy.log(<replaceable>msg, **kwargs</replaceable>)</literal></member>
    <member><literal>plpy.info(<replaceable>msg, **kwargs</replaceable>)</literal></member>
    <member><literal>plpy.notice(<replaceable>msg, **kwargs</replaceable>)</literal></member>
    <member><literal>plpy.warning(<replaceable>msg, **kwargs</replaceable>)</literal></member>
    <member><literal>plpy.error(<replaceable>msg, **kwargs</replaceable>)</literal></member>
    <member><literal>plpy.fatal(<replaceable>msg, **kwargs</replaceable>)</literal></member>
   </simplelist>
   <indexterm><primary>elog</primary><secondary>in PL/Python</secondary></indexterm>
   <function>plpy.error</function>和<function>plpy.fatal</function>实际上会产生一个 Python 异常（如果没被捕捉），它会被传播到调用查询中导致当前事务或者子事务被中止。<literal>raise plpy.Error(<replaceable>msg</replaceable>)</literal>和<literal>raise plpy.Fatal(<replaceable>msg</replaceable>)</literal>分别等效于调用<literal>plpy.error(<replaceable>msg</replaceable>)</literal>和<literal>plpy.fatal(<replaceable>msg</replaceable>)</literal>，不过<literal>raise</literal>形式不允许传递关键词参数。其他函数只生成不同优先级的消息。一个特定优先级的消息是被报告给客户端、写入服务器日志还是两者都做，由<xref linkend="guc-log-min-messages"/>和<xref linkend="guc-client-min-messages"/>配置变量控制。详见<xref linkend="runtime-config"/>。
  </para>
<!-- pgdoc-cn_end sig_en=5df5ceeba51ea4a8db9b8a2d00cb2726 -->

<!-- pgdoc-cn_start sig_en=f92d1a194d102ba619254338d4e50348 sig_cn_org=None source=14.1 
  <para>
   The <replaceable>msg</replaceable> argument is given as a positional argument.  For
   backward compatibility, more than one positional argument can be given. In
   that case, the string representation of the tuple of positional arguments
   becomes the message reported to the client.
  </para>
________________________________________________________-->
  <para>
   <replaceable>msg</replaceable>参数被给定位一个位置参数。为了向后兼容，可以给出多于一个位置参数。在那种情况下， 位置参数形成的元组的字符串表达将会变成报告给客户端的消息。
  </para>
<!-- pgdoc-cn_end sig_en=f92d1a194d102ba619254338d4e50348 -->

<!-- pgdoc-cn_start sig_en=62475fbf11ecf073263d900a342b88db sig_cn_org=b57c0bef0163ea4a31539a2eb40d6509 source=15.7 
  <para>
   The following keyword-only arguments are accepted:
   <simplelist>
    <member><literal>detail</literal></member>
    <member><literal>hint</literal></member>
    <member><literal>sqlstate</literal></member>
    <member><literal>schema_name</literal></member>
    <member><literal>table_name</literal></member>
    <member><literal>column_name</literal></member>
    <member><literal>datatype_name</literal></member>
    <member><literal>constraint_name</literal></member>
   </simplelist>
   The string representation of the objects passed as keyword-only arguments
   is used to enrich the messages reported to the client. For example:

<programlisting>
CREATE FUNCTION raise_custom_exception() RETURNS void AS $$
plpy.error("custom exception message",
           detail="some info about exception",
           hint="hint for users")
$$ LANGUAGE plpython3u;

=# SELECT raise_custom_exception();
ERROR:  plpy.Error: custom exception message
DETAIL:  some info about exception
HINT:  hint for users
CONTEXT:  Traceback (most recent call last):
  PL/Python function "raise_custom_exception", line 4, in &lt;module&gt;
    hint="hint for users")
PL/Python function "raise_custom_exception"
</programlisting>
  </para>
________________________________________________________-->
  <para>
   下列关键字参数被接受：
   <simplelist>
    <member><literal>detail</literal></member>
    <member><literal>hint</literal></member>
    <member><literal>sqlstate</literal></member>
    <member><literal>schema_name</literal></member>
    <member><literal>table_name</literal></member>
    <member><literal>column_name</literal></member>
    <member><literal>datatype_name</literal></member>
    <member><literal>constraint_name</literal></member>
   </simplelist>
   作为关键字参数传递的对象的字符串表示用于丰富向客户端报告的消息。例如：

<programlisting>
CREATE FUNCTION raise_custom_exception() RETURNS void AS $$
plpy.error("custom exception message",
           detail="some info about exception",
           hint="hint for users")
$$ LANGUAGE plpython3u;

=# SELECT raise_custom_exception();
ERROR:  plpy.Error: custom exception message
DETAIL:  some info about exception
HINT:  hint for users
CONTEXT:  Traceback (most recent call last):
  PL/Python function "raise_custom_exception", line 4, in &lt;module&gt;
    hint="hint for users")
PL/Python function "raise_custom_exception"
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=62475fbf11ecf073263d900a342b88db -->

<!-- pgdoc-cn_start sig_en=413ca3bc23d8583b356871d307fe8880 sig_cn_org=None source=14.1 
  <para>
   Another set of utility functions are
   <literal>plpy.quote_literal(<replaceable>string</replaceable>)</literal>,
   <literal>plpy.quote_nullable(<replaceable>string</replaceable>)</literal>, and
   <literal>plpy.quote_ident(<replaceable>string</replaceable>)</literal>.  They
   are equivalent to the built-in quoting functions described in <xref
   linkend="functions-string"/>.  They are useful when constructing
   ad-hoc queries.  A PL/Python equivalent of dynamic SQL from <xref
   linkend="plpgsql-quote-literal-example"/> would be:
<programlisting>
plpy.execute("UPDATE tbl SET %s = %s WHERE key = %s" % (
    plpy.quote_ident(colname),
    plpy.quote_nullable(newvalue),
    plpy.quote_literal(keyvalue)))
</programlisting>
  </para>
________________________________________________________-->
  <para>
   另一组工具函数是<literal>plpy.quote_literal(<replaceable>string</replaceable>)</literal>、<literal>plpy.quote_nullable(<replaceable>string</replaceable>)</literal>以及<literal>plpy.quote_ident(<replaceable>string</replaceable>)</literal>。它们等效于<xref linkend="functions-string"/>中描述的内建引用函数。在构建临时查询时它们能派上用场。<xref linkend="plpgsql-quote-literal-example"/>中动态 SQL 的 PL/Python 等效体是：
<programlisting>
plpy.execute("UPDATE tbl SET %s = %s WHERE key = %s" % (
    plpy.quote_ident(colname),
    plpy.quote_nullable(newvalue),
    plpy.quote_literal(keyvalue)))
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=413ca3bc23d8583b356871d307fe8880 -->
 </sect1>

 <sect1 id="plpython-python23">
<!-- pgdoc-cn_start sig_en=825a903fa309cdf50bde2eacd3221b8f sig_cn_org=None source=14.1 
  <title>Python 2 vs. Python 3</title>
________________________________________________________-->
  <title>Python 2 vs. Python 3</title>
<!-- pgdoc-cn_end sig_en=825a903fa309cdf50bde2eacd3221b8f -->

<!-- pgdoc-cn_start sig_en=d3b146630807084579cadb88070c445b sig_cn_org=ec4c6404ad50ffc87178a46ad78527ce source=15.7 
  <para>
   PL/Python supports only Python 3. Past versions of
   <productname>PostgreSQL</productname> supported Python 2, using the
   <literal>plpythonu</literal> and <literal>plpython2u</literal> language
   names.
  </para>
________________________________________________________-->
  <para>
   PL/Python 仅支持 Python 3。过去版本的<productname>PostgreSQL</productname>支持 Python 2，
   使用<literal>plpythonu</literal>和<literal>plpython2u</literal>语言名称。
</para>
<!-- pgdoc-cn_end sig_en=d3b146630807084579cadb88070c445b -->
 </sect1>

 <sect1 id="plpython-envar">
<!-- pgdoc-cn_start sig_en=d820450d6ca30f50cdab74296def074e sig_cn_org=None source=14.1 
  <title>Environment Variables</title>
________________________________________________________-->
  <title>环境变量</title>
<!-- pgdoc-cn_end sig_en=d820450d6ca30f50cdab74296def074e -->

<!-- pgdoc-cn_start sig_en=254ff48fa2bccc7e1865b92cf2d7c3d8 sig_cn_org=None source=14.1 
  <para>
   Some of the environment variables that are accepted by the Python
   interpreter can also be used to affect PL/Python behavior.  They
   would need to be set in the environment of the main PostgreSQL
   server process, for example in a start script.  The available
   environment variables depend on the version of Python; see the
   Python documentation for details.  At the time of this writing, the
   following environment variables have an affect on PL/Python,
   assuming an adequate Python version:
   <itemizedlist>
    <listitem>
     <para><envar>PYTHONHOME</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONPATH</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONY2K</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONOPTIMIZE</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONDEBUG</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONVERBOSE</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONCASEOK</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONDONTWRITEBYTECODE</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONIOENCODING</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONUSERBASE</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONHASHSEED</envar></para>
    </listitem>
   </itemizedlist>

   (It appears to be a Python implementation detail beyond the control
   of PL/Python that some of the environment variables listed on
   the <command>python</command> man page are only effective in a
   command-line interpreter and not an embedded Python interpreter.)
  </para>
________________________________________________________-->
  <para>
   某些 Python 解释器接受的环境变量也能被用来影响 PL/Python 行为。它们需要在主 PostgreSQL 服务器进程的环境中设置，例如在一个启动脚本中设置。可用的环境变量取决于 Python 的版本，细节可见 Python 文档。在编写这份文档时，下面的环境变量可以对 PL/Python 产生影响（假定有一个合适的 Python 版本）：
   <itemizedlist>
    <listitem>
     <para><envar>PYTHONHOME</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONPATH</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONY2K</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONOPTIMIZE</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONDEBUG</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONVERBOSE</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONCASEOK</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONDONTWRITEBYTECODE</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONIOENCODING</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONUSERBASE</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONHASHSEED</envar></para>
    </listitem>
   </itemizedlist>

   （Python 的实现细节似乎超出了 PL/Python 的控制范围，某些列在<command>python</command>手册页上的环境变量只在命令行解释器中有效，但在嵌入式 Python 解释器中无效）。
  </para>
<!-- pgdoc-cn_end sig_en=254ff48fa2bccc7e1865b92cf2d7c3d8 -->
 </sect1>
</chapter>
