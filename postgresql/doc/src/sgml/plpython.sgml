<!-- doc/src/sgml/plpython.sgml -->

<chapter id="plpython">
 <!--
 <title>PL/Python - Python Procedural Language</title>
 -->
 <title>PL/Python - Python 过程语言</title>

 <indexterm zone="plpython"><primary>PL/Python</></>
 <indexterm zone="plpython"><primary>Python</></>

 <!--
<para>
  The <application>PL/Python</application> procedural language allows
  <productname>PostgreSQL</productname> functions to be written in the
  <ulink url="http://www.python.org">Python language</ulink>.
 </para>
-->
<para>
<application>PL/Python</application>过程语言允许用
<ulink url="http://www.python.org">Python语言</ulink>编写
<productname>PostgreSQL</productname>函数。
</para>

 <!--
<para>
  To install PL/Python in a particular database, use
  <literal>CREATE EXTENSION plpythonu</>, or from the shell command line use
  <literal>createlang plpythonu <replaceable>dbname</></literal> (but
  see also <xref linkend="plpython-python23">).
 </para>
-->
<para>
要在特定数据库中安装PL/Python，使用<literal>CREATE EXTENSION plpythonu</>，
或者在命令行使用<literal>createlang plpythonu <replaceable>dbname</></literal>
（参见<xref linkend="plpython-python23">）。
</para>

  <tip>
   <!--
<para>
    If a language is installed into <literal>template1</>, all subsequently
    created databases will have the language installed automatically.
   </para>
-->
<para>
如果一门语言安装到了<literal>template1</>里面，那么随后创建的数据库都将会自动安装该语言。
</para>
  </tip>

 <!--
<para>
  As of <productname>PostgreSQL</productname> 7.4, PL/Python is only
  available as an <quote>untrusted</> language, meaning it does not
  offer any way of restricting what users can do in it.  It has
  therefore been renamed to <literal>plpythonu</>.  The trusted
  variant <literal>plpython</> might become available again in future,
  if a new secure execution mechanism is developed in Python.  The
  writer of a function in untrusted PL/Python must take care that the
  function cannot be used to do anything unwanted, since it will be
  able to do anything that could be done by a user logged in as the
  database administrator.  Only superusers can create functions in
  untrusted languages such as <literal>plpythonu</literal>.
 </para>
-->
<para>
到<productname>PostgreSQL</productname> 7.4为止，PL/Python只能当作一种
<quote>不可信</>语言，意思是它没有提供任何限制用户可为与不可为的手段。
因此，它被重新命名为<literal>plpythonu</>。可信任的变量<literal>plpython</>
可能在将来又变的可用，如果在Python里开发了一个新的安全执行机制。
在不受信任的PL/Python中函数的作者必须注意函数不能用来做任何不想要做的事情，
因为它能做可以由一个作为数据库管理员登录的用户所做的任何事情。
只有超级用户可以在不受信任的语言如<literal>plpythonu</literal>中创建函数。
</para>

 <note>
  <!--
<para>
   Users of source packages must specially enable the build of
   PL/Python during the installation process.  (Refer to the
   installation instructions for more information.)  Users of binary
   packages might find PL/Python in a separate subpackage.
  </para>
-->
<para>
使用源码包的用户必须在安装的过程中声明打开PL/Python的编译。
（更多信息参见安装操作指南）二进制包的用户可能会在独立的子包中找到PL/Python.
</para>
 </note>

 <sect1 id="plpython-python23">
  <!--
  <title>Python 2 vs. Python 3</title>
  -->
  <title>Python 2 vs. Python 3</title>

  
<para>
<!-- 
   PL/Python supports both the Python 2 and Python 3 language
   variants.  (The PostgreSQL installation instructions might contain
   more precise information about the exact supported minor versions
   of Python.)  Because the Python 2 and Python 3 language variants
   are incompatible in some important aspects, the following naming
   and transitioning scheme is used by PL/Python to avoid mixing them:
-->
PL/Python支持Python 2和Python 3语言变量。
（PostgreSQL安装操作指南可能包含确切的支持低版本的Python更精确的信息。）
因为Python 2 和 Python 3语言变量在某个重要的方面是不相容的，
PL/Python使用以下命名和过渡方案，以避免混合它们：
   <itemizedlist>
    <listitem>
<!--
     <para>
      The PostgreSQL language named <literal>plpython2u</literal>
      implements PL/Python based on the Python 2 language variant.
     </para>
-->
<para>
PostgreSQL语言命名<literal>plpython2u</literal>实现基于Python 2语言变体的PL/Python。
</para>
    </listitem>

    <listitem>
     <!--
<para>
      The PostgreSQL language named <literal>plpython3u</literal>
      implements PL/Python based on the Python 3 language variant.
     </para>
-->
<para>
PostgreSQL语言命名<literal>plpython3u</literal>实现基于Python 3语言变体的PL/Python。
</para>
    </listitem>

    <listitem>
     <!--
<para>
      The language named <literal>plpythonu</literal> implements
      PL/Python based on the default Python language variant, which is
      currently Python 2.  (This default is independent of what any
      local Python installations might consider to be
      their <quote>default</quote>, for example,
      what <filename>/usr/bin/python</filename> might be.)  The
      default will probably be changed to Python 3 in a distant future
      release of PostgreSQL, depending on the progress of the
      migration to Python 3 in the Python community.
     </para>
-->
<para>
命名为<literal>plpythonu</literal>的语言实现基于默认Python语言变体的PL/Python，
这是目前Python 2。（这个默认与本地Python安装可能会认为是他们的<quote>默认</quote>相独立，
例如，<filename>/usr/bin/python</filename>可能是什么。）在Python 社区中根据迁移到Python 3的进展，
默认会在PostgreSQL未来发布中改变成Python 3。
</para>
    </listitem>
   </itemizedlist>

<!--
   This scheme is analogous to the recommendations in <ulink
   url="http://www.python.org/dev/peps/pep-0394/">PEP 394</ulink> regarding the
   naming and transitioning of the <command>python</command> command.
-->
这个模式类似于<ulink url="http://www.python.org/dev/peps/pep-0394/">PEP 394</ulink>
中推荐的那个，关于<command>python</command>命令的命名和过度。
  </para>

  <!--
<para>
   It depends on the build configuration or the installed packages
   whether PL/Python for Python 2 or Python 3 or both are available.
  </para>
-->
<para>
它取决于编译配置或者安装包PL/Python对Python 2或Python 3或者两者都可用。
</para>

  <tip>
   <!--
<para>
    The built variant depends on which Python version was found during
    the installation or which version was explicitly set using
    the <envar>PYTHON</envar> environment variable;
    see <xref linkend="install-procedure">.  To make both variants of
    PL/Python available in one installation, the source tree has to be
    configured and built twice.
   </para>
-->
<para>
编译变量取决于在安装期间发现了哪个Python版本或使用<envar>PYTHON</envar>
环境变量明确设置了哪个版本，参见<xref linkend="install-procedure">。
要在一个安装中可用PL/Python的两个变量，必须配置源代码树并编译两次。
</para>
  </tip>

  
<para>
<!-- 
   This results in the following usage and migration strategy:
-->
产生下列用法和迁移策略：
   <itemizedlist>
    <listitem>
<!--
     <para>
      Existing users and users who are currently not interested in
      Python 3 use the language name <literal>plpythonu</literal> and
      don't have to change anything for the foreseeable future.  It is
      recommended to gradually <quote>future-proof</quote> the code
      via migration to Python 2.6/2.7 to simplify the eventual
      migration to Python 3.
     </para>
-->
<para>
已经存在的用户和目前对Python3不感兴趣的用户都使用语言名字<literal>plpythonu</literal>，
并且不必在可预见的将来改变什么。建议逐步的<quote>以防未来</quote>代码，
通过迁移到Python 2.6/2.7来简化最终迁移到Python 3。
</para>

     <!--
<para>
      In practice, many PL/Python functions will migrate to Python 3
      with few or no changes.
     </para>
-->
<para>
实际中，许多的PL/Python函数将迁移到Python 3，需要很少或根本没有改变。
</para>
    </listitem>

    <listitem>
     <!--
<para>
      Users who know that they have heavily Python 2 dependent code
      and don't plan to ever change it can make use of
      the <literal>plpython2u</literal> language name.  This will
      continue to work into the very distant future, until Python 2
      support might be completely dropped by PostgreSQL.
     </para>
-->
<para>
知道他们有大量Python 2相关的代码和不打算改变它的用户可以利用该
<literal>plpython2u</literal>语言名称。这将继续工作到遥远的将来，
直到Python 2支持完全被PostgreSQL抛弃。
</para>
    </listitem>

    <listitem>
     <!--
<para>
      Users who want to dive into Python 3 can use
      the <literal>plpython3u</literal> language name, which will keep
      working forever by today's standards.  In the distant future,
      when Python 3 might become the default, they might like to
      remove the <quote>3</quote> for aesthetic reasons.
     </para>
-->
<para>
想要投入Python 3的用户可以使用<literal>plpython3u</literal>语言名称，
这将在当前的标准永远工作。在遥远的未来，当Python 3可能会成为默认时，
他们可能会因为审美原因，想删除<quote>3</quote>。
</para>
    </listitem>

    <listitem>
     <!--
<para>
      Daredevils, who want to build a Python-3-only operating system
      environment, can change the contents of
      <link linkend="catalog-pg-pltemplate"><structname>pg_pltemplate</structname></link>
      to make <literal>plpythonu</literal> be equivalent
      to <literal>plpython3u</literal>, keeping in mind that this
      would make their installation incompatible with most of the rest
      of the world.
     </para>
-->
<para>
想要建立一个python-3-only操作系统环境的冒失鬼，可以更改
<link linkend="catalog-pg-pltemplate"><structname>pg_pltemplate</structname></link>
的内容，使<literal>plpythonu</literal>等效于<literal>plpython3u</literal>，
记住，这将使他们的安装与其他大多数人的不相容。
</para>
    </listitem>
   </itemizedlist>
  </para>

  <!--
<para>
   See also the
   document <ulink url="http://docs.python.org/py3k/whatsnew/3.0.html">What's
   New In Python 3.0</ulink> for more information about porting to
   Python 3.
  </para>
-->
<para>
关于迁移到Python 3的更多信息参见文档
<ulink url="http://docs.python.org/py3k/whatsnew/3.0.html">Python 3.0中的新特性</ulink>。
</para>

  <!--
<para>
   It is not allowed to use PL/Python based on Python 2 and PL/Python
   based on Python 3 in the same session, because the symbols in the
   dynamic modules would clash, which could result in crashes of the
   PostgreSQL server process.  There is a check that prevents mixing
   Python major versions in a session, which will abort the session if
   a mismatch is detected.  It is possible, however, to use both
   PL/Python variants in the same database, from separate sessions.
  </para>
-->
<para>
不允许在同一个会话中使用基于Python 2的PL/Python和基于Python 3的PL/Python，
因为在动态模块中的符号会发生冲突，这可能导致PostgreSQL服务器进程崩溃。
有一个检查可以防止在一个会话中混合Python的主要版本，如果检测到不匹配，
它将中止会话。不过，在同一个数据库的单独会话中使用PL/Python的变体是可能的。
</para>
 </sect1>

 <sect1 id="plpython-funcs">
  <!--
  <title>PL/Python Functions</title>
  -->
  <title>PL/Python 函数</title>

  
<para>
<!--
   Functions in PL/Python are declared via the
   standard <xref linkend="sql-createfunction"> syntax:
-->
PL/Python中的函数通过标准的<xref linkend="sql-createfunction">语法声明：
<programlisting>
CREATE FUNCTION <replaceable>funcname</replaceable> (<replaceable>argument-list</replaceable>)
  RETURNS <replaceable>return-type</replaceable>
AS $$
  # PL/Python function body
$$ LANGUAGE plpythonu;
</programlisting>
  </para>

  <!--
<para>
   The body of a function is simply a Python script. When the function
   is called, its arguments are passed as elements of the list
   <varname>args</varname>; named arguments are also passed as
   ordinary variables to the Python script.  Use of named arguments is
   usually more readable.  The result is returned from the Python code
   in the usual way, with <literal>return</literal> or
   <literal>yield</literal> (in case of a result-set statement).  If
   you do not provide a return value, Python returns the default
   <symbol>None</symbol>. <application>PL/Python</application> translates
   Python's <symbol>None</symbol> into the SQL null value.
  </para>
-->
<para>
函数体是一个简单的Python脚本，当函数被调用的时候，它的参数作为列表<varname>args</varname>
的元素传递；命名参数也会被当做普通的变量传递到Python脚本中。命名参数的使用通常更易读。
结果将使用<literal>return</literal>或<literal>yield</literal>（结果集语句的情况）
照常从Python代码中返回。如果没有提供返回值，Python返回缺省的<symbol>None</symbol>。
<application>PL/Python</application>翻译Python的<symbol>None</symbol>为SQL空值。
</para>

<para>
<!-- 
   For example, a function to return the greater of two integers can be
   defined as:
-->
比如，返回两个整数中较大者的函数可以定义为：
<programlisting>
CREATE FUNCTION pymax (a integer, b integer)
  RETURNS integer
AS $$
  if a &gt; b:
    return a
  return b
$$ LANGUAGE plpythonu;
</programlisting>
<!-- 
   The Python code that is given as the body of the function definition
   is transformed into a Python function. For example, the above results in:
-->
以函数体定义形式给出的Python代码转换成Python函数。比如，上面的转换成：
<programlisting>
def __plpython_procedure_pymax_23456():
  if a &gt; b:
    return a
  return b
</programlisting>

<!--
   assuming that 23456 is the OID assigned to the function by
   <productname>PostgreSQL</productname>.
-->
这里假设23456是<productname>PostgreSQL</productname>赋予这个函数的OID。
  </para>

<para>
<!-- 
   The arguments are set as global variables.  Because of the scoping
   rules of Python, this has the subtle consequence that an argument
   variable cannot be reassigned inside the function to the value of
   an expression that involves the variable name itself, unless the
   variable is redeclared as global in the block.  For example, the
   following won't work: 
-->
参数设置为全局变量。因为Python的作用域规则，这有些微妙的结果，
参数变量在函数内部不能分配给包含变量名本身的表达式值，
除非变量在块中重新定义为全局。例如，以下是行不通的：
<programlisting>
CREATE FUNCTION pystrip(x text)
  RETURNS text
AS $$
  x = x.strip()  # error
  return x
$$ LANGUAGE plpythonu;
</programlisting>
<!-- 
   because assigning to <varname>x</varname>
   makes <varname>x</varname> a local variable for the entire block,
   and so the <varname>x</varname> on the right-hand side of the
   assignment refers to a not-yet-assigned local
   variable <varname>x</varname>, not the PL/Python function
   parameter.  Using the <literal>global</literal> statement, this can
   be made to work: 
-->
因为分配到的<varname>x</varname>产生整个块的局部变量<varname>x</varname>，
所以<varname>x</varname>在分配的右侧指向一个未被分配的局部变量<varname>x</varname>，
不是PL/Python函数参数。使用<literal>global</literal>声明，这可以使其运行：
<programlisting>
CREATE FUNCTION pystrip(x text)
  RETURNS text
AS $$
  global x
  x = x.strip()  # ok now
  return x
$$ LANGUAGE plpythonu;
</programlisting>
<!-- 
   But it is advisable not to rely on this implementation detail of
   PL/Python.  It is better to treat the function parameters as
   read-only. 
-->
但最好不要依赖PL/Python的执行细节。最好是把函数参数作为只读的。
  </para>
 </sect1>

 <sect1 id="plpython-data">
  <!--
  <title>Data Values</title>
  -->
  <title>数据值</title>
  <!--
<para>
   Generally speaking, the aim of PL/Python is to provide
   a <quote>natural</quote> mapping between the PostgreSQL and the
   Python worlds.  This informs the data mapping rules described
   below.
  </para>
-->
<para>
一般来说，PL/Python的目的是提供PostgreSQL和Python世界之间的<quote>自然</quote>映射。
如下面描述的数据映射规则。
</para>

  <sect2>
   <!--
   <title>Data Type Mapping</title>
   -->
   <title>数据类型映射</title>
   
<para>
<!-- 
    Function arguments are converted from their PostgreSQL type to a
    corresponding Python type: 
-->
函数参数是从他们的PostgreSQL类型转换为相应的Python类型：
    <itemizedlist>
     <listitem>
<!--
      <para>
       PostgreSQL <type>boolean</type> is converted to Python <type>bool</type>.
      </para>
-->
<para>
PostgreSQL <type>boolean</type>转换成Python <type>bool</type>。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       PostgreSQL <type>smallint</type> and <type>int</type> are
       converted to Python <type>int</type>.
       PostgreSQL <type>bigint</type> and <type>oid</type> are converted
       to <type>long</type> in Python 2 and to <type>int</type> in
       Python 3.
      </para>
-->
<para>
PostgreSQL <type>smallint</type>和<type>int</type>转换成Python <type>int</type>。
PostgreSQL <type>bigint</type>和<type>oid</type>在Python 2中转换成<type>long</type>，
在Python 3中转换成<type>int</type>。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       PostgreSQL <type>real</type>, <type>double</type>,
       and <type>numeric</type> are converted to
       Python <type>float</type>.  Note that for
       the <type>numeric</type> this loses information and can lead to
       incorrect results.  This might be fixed in a future
       release.
      </para>
-->
<para>
PostgreSQL <type>real</type>，<type>double</type>和<type>numeric</type>
转换成Python <type>float</type>。请注意，<type>numeric</type>
可能丢失信息并且导致不正确的结果。这可能在未来的版本中固定。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       PostgreSQL <type>bytea</type> is converted to
       Python <type>str</type> in Python 2 and to <type>bytes</type>
       in Python 3.  In Python 2, the string should be treated as a
       byte sequence without any character encoding.
      </para>
-->
<para>
PostgreSQL <type>bytea</type>在Python 2中转换成Python <type>str</type>，
在Python 3中转换成<type>bytes</type>。在Python 2 中，字符串应被视为没有任何字符编码的字节序列。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       All other data types, including the PostgreSQL character string
       types, are converted to a Python <type>str</type>.  In Python
       2, this string will be in the PostgreSQL server encoding; in
       Python 3, it will be a Unicode string like all strings.
      </para>
-->
<para>
所有其他数据类型，包括PostgreSQL字符串类型，转换为Python <type>str</type>。
在Python 2中，这个字符串将以PostgreSQL服务器编码；在Python 3中，它是一个Unicode字符串，和所有的字符串一样。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       For nonscalar data types, see below.
      </para>
-->
<para>
对于非标量数据类型，见下文。
</para>
     </listitem>
    </itemizedlist>
   </para>

   
<para>
<!-- 
    Function return values are converted to the declared PostgreSQL
    return data type as follows: 
-->
函数的返回值被转换为声明的PostgreSQL返回数据类型，如下：
    <itemizedlist>
     <listitem>
<!--
      <para>
       When the PostgreSQL return type is <type>boolean</type>, the
       return value will be evaluated for truth according to the
       <emphasis>Python</emphasis> rules.  That is, 0 and empty string
       are false, but notably <literal>'f'</literal> is true.
      </para>
-->
<para>
当PostgreSQL返回类型是<type>boolean</type>，按照<emphasis>Python</emphasis>
规则返回值估计为真。也就是说，0和空字符串是假，但值得注意的是<literal>'f'</literal>是真。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       When the PostgreSQL return type is <type>bytea</type>, the
       return value will be converted to a string (Python 2) or bytes
       (Python 3) using the respective Python built-ins, with the
       result being converted <type>bytea</type>.
      </para>
-->
<para>
当postgreSQL返回类型是<type>bytea</type>时，返回值将使用各自的Python内建被转换成字符串
（Python 2）或者字节(Python 3)，其结果被转换成<type>bytea</type>。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       For all other PostgreSQL return types, the returned Python
       value is converted to a string using the Python
       built-in <literal>str</literal>, and the result is passed to the
       input function of the PostgreSQL data type.
      </para>
-->
<para>
对于所有其他PostgreSQL返回类型，返回的Python值使用Python内建<literal>str</literal>
转换成字符串，结果传递到PostgreSQL数据类型的输入函数。
</para>

      <!--
<para>
       Strings in Python 2 are required to be in the PostgreSQL server
       encoding when they are passed to PostgreSQL.  Strings that are
       not valid in the current server encoding will raise an error,
       but not all encoding mismatches can be detected, so garbage
       data can still result when this is not done correctly.  Unicode
       strings are converted to the correct encoding automatically, so
       it can be safer and more convenient to use those.  In Python 3,
       all strings are Unicode strings.
      </para>
-->
<para>
当在Python 2中的字符串要传递到PostgreSQL时，要求它们是以PostgreSQL服务器编码。
在当前服务器编码中无效的字符串将引发错误，但不是所有的编码不匹配都可以被检测到，
因此当做的不正确时，仍然会产生垃圾数据。Unicode字符串自动转换为正确的编码，
所以它可以更安全，更方便的使用。在Python 3中，所有的字符串都是Unicode字符串。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       For nonscalar data types, see below.
      </para>
-->
<para>
对于非标量数据类型，见下文。
</para>
     </listitem>
    </itemizedlist>

<!-- 
    Note that logical mismatches between the declared PostgreSQL
    return type and the Python data type of the actual return object
    are not flagged; the value will be converted in any case. 
-->
请注意，PostgreSQL声明的返回类型和实际返回对象的Python数据类型之间的逻辑不匹配是不标记的；
该值将在任何情况下被转换。
   </para>
  </sect2>

  <sect2>
   <title>Null, None</title>

<para>
<!-- 
   If an SQL null value<indexterm><primary>null value</primary><secondary
   sortas="PL/Python">in PL/Python</secondary></indexterm> is passed to a
   function, the argument value will appear as <symbol>None</symbol> in
   Python. For example, the function definition of <function>pymax</function>
   shown in <xref linkend="plpython-funcs"> will return the wrong answer for null
   inputs. We could add <literal>STRICT</literal> to the function definition
   to make <productname>PostgreSQL</productname> do something more reasonable:
   if a null value is passed, the function will not be called at all,
   but will just return a null result automatically. Alternatively,
   we could check for null inputs in the function body:
-->
如果向函数传递了一个SQL null值<indexterm><primary>null value</primary><secondary
   sortas="PL/Python">in PL/Python</secondary></indexterm>，参数值在Python中将会显示为
<symbol>None</symbol>。比如，在<xref linkend="plpython-funcs">中显示的
<function>pymax</function>的函数定义对于null输入将返回错误结果。
我们可以添加<literal>STRICT</literal>到函数定义，使得<productname>PostgreSQL</productname>
进行更加合理的操作：如果传入null值，函数将根本不会被调用，而是立即自动返回null。或者，
也可以在函数体中检查输入参数是否为null:
<programlisting>
CREATE FUNCTION pymax (a integer, b integer)
  RETURNS integer
AS $$
  if (a is None) or (b is None):
    return None
  if a &gt; b:
    return a
  return b
$$ LANGUAGE plpythonu;
</programlisting>

<!-- 
   As shown above, to return an SQL null value from a PL/Python
   function, return the value <symbol>None</symbol>. This can be done whether the
   function is strict or not. 
-->
如上所示，要从PL/Python函数中返回一个SQL null 值，返回<symbol>None</symbol>即可。
无论函数是否严格，这样做都有效。
  </para>
  </sect2>

  <sect2 id="plpython-arrays">
   <title>Arrays, Lists</title>

<para>
<!-- 
   SQL array values are passed into PL/Python as a Python list.  To
   return an SQL array value out of a PL/Python function, return a
   Python sequence, for example a list or tuple:
-->
SQL数组值作为Python列表传递给PL/Python。要从PL/Python函数返回一个SQL数组值，
只需返回一个Python序列，例如一个列表或元组：
<programlisting>
CREATE FUNCTION return_arr()
  RETURNS int[]
AS $$
return (1, 2, 3, 4, 5)
$$ LANGUAGE plpythonu;

SELECT return_arr();
 return_arr  
-------------
 {1,2,3,4,5}
(1 row)
</programlisting>
<!-- 
   Note that in Python, strings are sequences, which can have
   undesirable effects that might be familiar to Python programmers:
-->
注意:在Python中，字符串是序列，这可能有不良影响，这可能是Python程序员熟悉的：
<programlisting>
CREATE FUNCTION return_str_arr()
  RETURNS varchar[]
AS $$
return "hello"
$$ LANGUAGE plpythonu;

SELECT return_str_arr();
 return_str_arr
----------------
 {h,e,l,l,o}
(1 row)
</programlisting>
  </para>
  </sect2>

  <sect2>
   <!--
   <title>Composite Types</title>
   -->
   <title>复合类型</title>

<para>
<!-- 
   Composite-type arguments are passed to the function as Python mappings. The
   element names of the mapping are the attribute names of the composite type.
   If an attribute in the passed row has the null value, it has the value
   <symbol>None</symbol> in the mapping. Here is an example:
-->
复合类型参数将作为Python映射传递给函数。映射的元素名是复合类型的属性名。
如果被传递行的某个属性是null值，那么它在映射中的值是<symbol>None</symbol>。下面是例子：
<programlisting>
CREATE TABLE employee (
  name text,
  salary integer,
  age integer
);

CREATE FUNCTION overpaid (e employee)
  RETURNS boolean
AS $$
  if e["salary"] &gt; 200000:
    return True
  if (e["age"] &lt; 30) and (e["salary"] &gt; 100000):
    return True
  return False
$$ LANGUAGE plpythonu;
</programlisting>
  </para>

<para>
<!-- 
   There are multiple ways to return row or composite types from a Python
   function. The following examples assume we have:
-->
有多种从Python函数返回行或复合类型的方法。下面的例子假定我们有：
<programlisting>
CREATE TYPE named_value AS (
  name   text,
  value  integer
);
</programlisting>

  <!--
  A composite result can be returned as a:
  -->
  一个复合类型结果可以作为下列之一返回：

   <variablelist>
    <varlistentry>
     <!--
 <term>Sequence type (a tuple or list, but not a set because
     it is not indexable)</term>
 -->
 <term>序列类型（一个元组或列表，但不是一个集合，因为集合是不可以被索引的）</term>
     <listitem>
      <para>
       <!-- 
   Returned sequence objects must have the same number of items as the
       composite result type has fields. The item with index 0 is assigned to
       the first field of the composite type, 1 to the second and so on. For
       example: 
   -->
返回的序列对象必须与复合结果类型字段数相同。索引为0的项将被分配给复合类型的第一个字段，
索引为1的项分配给第2个字段，以此类推。比如：

<programlisting>
CREATE FUNCTION make_pair (name text, value integer)
  RETURNS named_value
AS $$
  return [ name, value ]
  # or alternatively, as tuple: return ( name, value )
$$ LANGUAGE plpythonu;
</programlisting>

<!-- 
       To return a SQL null for any column, insert <symbol>None</symbol> at
       the corresponding position. 
-->
要为任何字段返回SQL null，就在相应的位置插入<symbol>None</symbol>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <!--
 <term>Mapping (dictionary)</term>
 -->
 <term>映射（字典）</term>
     <listitem>

<para>
<!-- 
       The value for each result type column is retrieved from the mapping
       with the column name as key. Example:
-->
每个结果类型字段的值从映射中使用字段名作为键检索，例如：
<programlisting>
CREATE FUNCTION make_pair (name text, value integer)
  RETURNS named_value
AS $$
  return { "name": name, "value": value }
$$ LANGUAGE plpythonu;
</programlisting>

<!-- 
       Any extra dictionary key/value pairs are ignored. Missing keys are
       treated as errors.
       To return a SQL null value for any column, insert
       <symbol>None</symbol> with the corresponding column name as the key. 
-->
任何额外的字典键/值对被忽略。丢失的键将被当作错误。要为任何字段返回SQL null值，
就以相应的字段名作为键插入<symbol>None</symbol>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <!--
 <term>Object (any object providing method <literal>__getattr__</literal>)</term>
 -->
 <term>对象(任何提供<literal>__getattr__</literal>方法的对象)</term>
     <listitem>

<para>
<!-- 
       This works the same as a mapping.
       Example:
-->
它的工作方式和映射一样，例如：
<programlisting>
CREATE FUNCTION make_pair (name text, value integer)
  RETURNS named_value
AS $$
  class named_value:
    def __init__ (self, n, v):
      self.name = n
      self.value = v
  return named_value(name, value)

  # or simply
  class nv: pass
  nv.name = name
  nv.value = value
  return nv
$$ LANGUAGE plpythonu;
</programlisting>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

<para>
    <!--
Functions with <literal>OUT</literal> parameters are also supported.  For example:
-->
也支持带有<literal>OUT</literal>参数的函数。例如：
<programlisting>
CREATE FUNCTION multiout_simple(OUT i integer, OUT j integer) AS $$
return (1, 2)
$$ LANGUAGE plpythonu;

SELECT * FROM multiout_simple();
</programlisting>
   </para>
  </sect2>

  <sect2>
   <!--
   <title>Set-returning Functions</title>
   -->
   <title>设置返回函数</title>

<para>
<!-- 
   A <application>PL/Python</application> function can also return sets of
   scalar or composite types. There are several ways to achieve this because
   the returned object is internally turned into an iterator. The following
   examples assume we have composite type:
-->
<application>PL/Python</application>函数也可以返回标量或者复合类型的集合。
有多种方法可以达到这个目的，因为返回对象在内部被转换成一个迭代器。
下面的例子假定我们有一个复合类型：
<programlisting>
CREATE TYPE greeting AS (
  how text,
  who text
);
</programlisting>

   <!-- A set result can be returned from a: -->
   一个集合结果可以从下列之一返回：

   <variablelist>
    <varlistentry>
     <!--
 <term>Sequence type (tuple, list, set)</term>
 -->
 <term>序列类型（元组、列表、集合）</term>
     <listitem>
      <para>
<programlisting>
CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  # return tuple containing lists as composite types
  # all other combinations work also
  return ( [ how, "World" ], [ how, "PostgreSQL" ], [ how, "PL/Python" ] )
$$ LANGUAGE plpythonu;
</programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <!-- 
 <term>Iterator (any object providing <symbol>__iter__</symbol> and
      <symbol>next</symbol> methods)</term> 
  -->
  <term>迭代器（任何提供<symbol>__iter__</symbol>和<symbol>next</symbol>方法的对象）</term>
     <listitem>
<para>
<programlisting>
CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  class producer:
    def __init__ (self, how, who):
      self.how = how
      self.who = who
      self.ndx = -1

    def __iter__ (self):
      return self

    def next (self):
      self.ndx += 1
      if self.ndx == len(self.who):
        raise StopIteration
      return ( self.how, self.who[self.ndx] )

  return producer(how, [ "World", "PostgreSQL", "PL/Python" ])
$$ LANGUAGE plpythonu;
</programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <!--
 <term>Generator (<literal>yield</literal>)</term>
 -->
 <term>生成器(<literal>yield</literal>)</term>
     <listitem>
<para>
<programlisting>
CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  for who in [ "World", "PostgreSQL", "PL/Python" ]:
    yield ( how, who )
$$ LANGUAGE plpythonu;
</programlisting>

       <warning>
<!--
        <para>
         Due to Python
         <ulink url="http://bugs.python.org/issue1483133">bug #1483133</ulink>,
         some debug versions of Python 2.4
         (configured and compiled with option <literal>-&#045;with-pydebug</literal>)
         are known to crash the <productname>PostgreSQL</productname> server
         when using an iterator to return a set result.
         Unpatched versions of Fedora 4 contain this bug.
         It does not happen in production versions of Python or on patched
         versions of Fedora 4.
        </para>
-->
<para>
由于Python <ulink url="http://bugs.python.org/issue1483133">bug #1483133</ulink>的原因，
一些Python 2.4的调试版本(使用<literal>--with-pydebug</literal>选项配置和编译)
已知会让<productname>PostgreSQL</productname>服务器在使用迭代器返回集合时崩溃。
Fedora 4的应用补丁版本包含这个臭虫。但是在生产版本的Python或已经修补的Fedora 4上没有这个问题。
</para>
       </warning>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

<para>
<!--
     Set-returning functions with <literal>OUT</literal> parameters
    (using <literal>RETURNS SETOF record</literal>) are also
    supported.  For example:
-->
也支持带有<literal>OUT</literal>参数的设置返回函数（使用<literal>RETURNS SETOF记录</literal>）。
例如：
<programlisting>
CREATE FUNCTION multiout_simple_setof(n integer, OUT integer, OUT integer) RETURNS SETOF record AS $$
return [(1, 2)] * n
$$ LANGUAGE plpythonu;

SELECT * FROM multiout_simple_setof(3);
</programlisting>
   </para>
  </sect2>
 </sect1>

 <sect1 id="plpython-sharing">
  <!--
  <title>Sharing Data</title>
  -->
  <title>共享数据</title>
  <!--
<para>
   The global dictionary <varname>SD</varname> is available to store
   data between function calls.  This variable is private static data.
   The global dictionary <varname>GD</varname> is public data,
   available to all Python functions within a session.  Use with
   care.<indexterm><primary>global data</>
   <secondary>in PL/Python</></indexterm>
  </para>
-->
<para>
全局字典<varname>SD</varname>在函数调用之间用于存储数据。这些变量是私有静态数据。
全局字典<varname>GD</varname>是公共数据，在一个会话中用于全部的Python函数。
但在使用时需要小心。<indexterm><primary>全局数据</> <secondary>在PL/Python中</></indexterm>
</para>

  <!--
<para>
   Each function gets its own execution environment in the
   Python interpreter, so that global data and function arguments from
   <function>myfunc</function> are not available to
   <function>myfunc2</function>.  The exception is the data in the
   <varname>GD</varname> dictionary, as mentioned above.
  </para>
-->
<para>
每个函数都在Python解释器里获得自己的执行环境，因此来自<function>myfunc</function>
的全局数据和函数参数是<function>myfunc2</function>不可用的。
这里的例外是上面提到的<varname>GD</varname>字典中的数据。
</para>
 </sect1>

 <sect1 id="plpython-do">
  <!--
  <title>Anonymous Code Blocks</title>
  -->
  <title>匿名代码块</title>
  
<para>
<!-- 
   PL/Python also supports anonymous code blocks called with the
   <xref linkend="sql-do"> statement:
-->
PL/Python也支持<xref linkend="sql-do">声明的匿名代码块：
 <programlisting>
DO $$
    # PL/Python code
$$ LANGUAGE plpythonu;
</programlisting>

<!-- 
   An anonymous code block receives no arguments, and whatever value it
   might return is discarded.  Otherwise it behaves just like a function. 
-->
一个匿名代码块不接受参数，并且丢弃它可能返回的值。否则，它的行为就像一个函数。
  </para>
 </sect1>

 <sect1 id="plpython-trigger">
  <!--
  <title>Trigger Functions</title>
  -->
  <title>触发器函数</title>

  <indexterm zone="plpython-trigger">
   <!--
   <primary>trigger</primary>
   <secondary>in PL/Python</secondary>
   -->
   <primary>触发器</primary>
   <secondary>在PL/Python中</secondary>
  </indexterm>

  
<para>
<!--
    When a function is used as a trigger, the dictionary
   <literal>TD</literal> contains trigger-related values:
-->
当一个函数用作触发器的时候，字典<literal>TD</literal>包含触发器相关的值：
   <variablelist>
    <varlistentry>
     <term><literal>TD["event"]</></term>
     <listitem>
<!--
      <para>
       contains the event as a string:
       <literal>INSERT</>, <literal>UPDATE</>,
       <literal>DELETE</>, or <literal>TRUNCATE</>.
      </para>
-->
<para>
包含作为字符串的事件：<literal>INSERT</>、<literal>UPDATE</>、<literal>DELETE</>
或<literal>TRUNCATE</>。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["when"]</></term>
     <listitem>
      <!--
<para>
       contains one of <literal>BEFORE</>, <literal>AFTER</>, or
       <literal>INSTEAD OF</>.
      </para>
-->
<para>
包含<literal>BEFORE</>、<literal>AFTER</>或者<literal>INSTEAD OF</>之一。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["level"]</></term>
     <listitem>
      <!--
<para>
       contains <literal>ROW</> or <literal>STATEMENT</>.
      </para>
-->
<para>
包含<literal>ROW</>或者<literal>STATEMENT</>。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["new"]</></term>
     <term><literal>TD["old"]</></term>
     <listitem>
      <!--
<para>
       For a row-level trigger, one or both of these fields contain
       the respective trigger rows, depending on the trigger event.
      </para>
-->
<para>
对于一个行级别触发器，这些字段的一个或两个包含各自的触发器行，取决于触发器事件。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["name"]</></term>
     <listitem>
      <!--
<para>
       contains the trigger name.
      </para>
-->
<para>
包含触发器名字。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["table_name"]</></term>
     <listitem>
      <!--
<para>
       contains the name of the table on which the trigger occurred.
      </para>
-->
<para>
包含触发器发生的表的名称。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["table_schema"]</></term>
     <listitem>
      <!--
<para>
       contains the schema of the table on which the trigger occurred.
      </para>
-->
<para>
含触发器发生的表的模式。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["relid"]</></term>
     <listitem>
      <!--
<para>
       contains the OID of the table on which the trigger occurred.
      </para>
-->
<para>
包含触发器发生的表的OID。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["args"]</></term>
     <listitem>
      <!--
<para>
       If the <command>CREATE TRIGGER</> command
       included arguments, they are available in <literal>TD["args"][0]</> to
       <literal>TD["args"][<replaceable>n</>-1]</>.
      </para>
-->
<para>
如果<command>CREATE TRIGGER</>命令包括参数，那么这些参数可以通过
<literal>TD["args"][0]</>到<literal>TD["args"][<replaceable>n</>-1]</>获得。
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <!--
<para>
   If <literal>TD["when"]</literal> is <literal>BEFORE</> or
   <literal>INSTEAD OF</> and
   <literal>TD["level"]</literal> is <literal>ROW</>, you can
   return <literal>None</literal> or <literal>"OK"</literal> from the
   Python function to indicate the row is unmodified,
   <literal>"SKIP"</> to abort the event, or if <literal>TD["event"]</>
   is <command>INSERT</> or <command>UPDATE</> you can return
   <literal>"MODIFY"</> to indicate you've modified the new row.
   Otherwise the return value is ignored.
  </para>
-->
<para>
如果<literal>TD["when"]</literal>是<literal>BEFORE</>或者<literal>INSTEAD OF</>，
并且<literal>TD["level"]</literal>是<literal>ROW</>，那么你可以从Python函数返回
<literal>None</literal>或<literal>"OK"</literal>以表示该行没有修改，
返回<literal>"SKIP"</>以退出事件，或者如果<literal>TD["event"]</>是<command>INSERT</>
或<command>UPDATE</>，你可以返回<literal>"MODIFY"</>表示你已经修改了该行。否则忽略返回值。
</para>
 </sect1>

 <sect1 id="plpython-database">
  <!--
  <title>Database Access</title>
  -->
  <title>数据库访问</title>

  <!--
<para>
   The PL/Python language module automatically imports a Python module
   called <literal>plpy</literal>.  The functions and constants in
   this module are available to you in the Python code as
   <literal>plpy.<replaceable>foo</replaceable></literal>.
  </para>
-->
<para>
PL/Python语言模块自动输入一个叫<literal>plpy</literal>的Python模块。
在这个模块里的函数和常量可以在Python代码里以
<literal>plpy.<replaceable>foo</replaceable></literal>的名字获得。
</para>

  <sect2>
    <!--
<title>Database Access Functions</title>
-->
<title>数据库访问函数</title>

  <!--
<para>
   The <literal>plpy</literal> module provides several functions to execute
   database commands:
  </para>
-->
<para>
<literal>plpy</literal>模块提供几个函数执行数据库命令：
</para>

  <variablelist>
   <varlistentry>
    <term><literal>plpy.<function>execute</function>(<replaceable>query</replaceable> [, <replaceable>max-rows</replaceable>])</literal></term>
    <listitem>
     <!--
<para>
      Calling <function>plpy.execute</function> with a query string and an
      optional row limit argument causes that query to be run and the result to
      be returned in a result object.
     </para>
-->
<para>
拿一个查询字符串和一个可选的行限制参数调用<function>plpy.execute</function>可以运行该查询，
并且结果返回到一个结果对象里。
</para>

<para>
<!-- 
      The result object emulates a list or dictionary object.  The result
      object can be accessed by row number and column name.  For example: 
-->
结果对象仿真一个列表或者是字典对象。结果对象通过行号和字段名来访问。例如：
<programlisting>
rv = plpy.execute("SELECT * FROM my_table", 5)
</programlisting>
<!-- 
      returns up to 5 rows from <literal>my_table</literal>.  If
      <literal>my_table</literal> has a column
      <literal>my_column</literal>, it would be accessed as: 
-->
返回来自<literal>my_table</literal>的最多5行。如果<literal>my_table</literal>
有一个<literal>my_column</literal>字段，那么你可以用下面的方法访问它：
<programlisting>
foo = rv[i]["my_column"]
</programlisting>
<!-- 
      The number of rows returned can be obtained using the built-in
      <function>len</function> function.
-->
返回的行数可以使用内建<function>len</function>函数获得。
     </para>

     
<para>
      <!-- 
  The result object has these additional methods:
  -->
  结果对象有下面这些额外的方法：
      <variablelist>
       <varlistentry>
        <term><literal><function>nrows</function>()</literal></term>
        <listitem>
<!--
         <para>
          Returns the number of rows processed by the command.  Note that this
          is not necessarily the same as the number of rows returned.  For
          example, an <command>UPDATE</command> command will set this value but
          won't return any rows (unless <literal>RETURNING</literal> is used).
         </para>
-->
<para>
返回该命令处理的行数。请注意，这与返回的行数不一定相同。例如，<command>UPDATE</command>
命令将设置这个值，但是不会返回任何行（除非使用了<literal>RETURNING</literal>）。
</para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal><function>status</function>()</literal></term>
        <listitem>
         <!--
<para>
          The <function>SPI_execute()</function> return value.
         </para>
-->
<para>
<function>SPI_execute()</function>的返回值。
</para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal><function>colnames</function>()</literal></term>
        <term><literal><function>coltypes</function>()</literal></term>
        <term><literal><function>coltypmods</function>()</literal></term>
        <listitem>
         <!--
<para>
          Return a list of column names, list of column type OIDs, and list of
          type-specific type modifiers for the columns, respectively.
         </para>
-->
<para>
分别返回一个字段名的列表、字段类型OID的列表和该字段的特定于类型的类型修饰符的列表。
</para>

         <!--
<para>
          These methods raise an exception when called on a result object from
          a command that did not produce a result set, e.g.,
          <command>UPDATE</command> without <literal>RETURNING</literal>, or
          <command>DROP TABLE</command>.  But it is OK to use these methods on
          a result set containing zero rows.
         </para>
-->
<para>
这些方式在从一个不产生结果集命令的结果对象上调用时产生一个意外，比如，
不带有<literal>RETURNING</literal>的<command>UPDATE</command>，或<command>DROP TABLE</command>。
但是在一个包含零行的结果集上使用这些方法是可以的。
</para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal><function>__str__</function>()</literal></term>
        <listitem>
         <!--
<para>
          The standard <literal>__str__</literal> method is defined so that it
          is possible for example to debug query execution results
          using <literal>plpy.debug(rv)</literal>.
         </para>
-->
<para>
定义了标准的<literal>__str__</literal>方法，所以有可能，比如，
使用<literal>plpy.debug(rv)</literal>调试查询执行结果。
</para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>

     <!--
<para>
      The result object can be modified.
     </para>
-->
<para>
结果对象可以被修改。
</para>

     <!--
<para>
      Note that calling <literal>plpy.execute</literal> will cause the entire
      result set to be read into memory.  Only use that function when you are
      sure that the result set will be relatively small.  If you don't want to
      risk excessive memory usage when fetching large results,
      use <literal>plpy.cursor</literal> rather
      than <literal>plpy.execute</literal>.
     </para>
-->
<para>
请注意，调用<literal>plpy.execute</literal>将导致读取整个结果集到内存中。
只有在你确定结果集将相对较小的情况下使用这个函数。
如果你不希望在抓取大的结果集时承担过度使用内存的风险，
那么使用<literal>plpy.cursor</literal>而不是<literal>plpy.execute</literal>。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>plpy.<function>prepare</function>(<replaceable>query</replaceable> [, <replaceable>argtypes</replaceable>])</literal></term>
    <term><literal>plpy.<function>execute</function>(<replaceable>plan</replaceable> [, <replaceable>arguments</replaceable> [, <replaceable>max-rows</replaceable>]])</literal></term>
    <listitem>
     
<para>
<!--
      <indexterm><primary>preparing a query</><secondary>in PL/Python</></indexterm>
      <function>plpy.prepare</function> prepares the execution plan for a
      query.  It is called with a query string and a list of parameter types,
      if you have parameter references in the query.  For example:
-->
<indexterm><primary>准备一个查询</><secondary>在PL/Python中</></indexterm>
<function>plpy.prepare</function>为查询准备执行规划。
它用一个查询字符串和一个参数类型列表调用，如果在查询中你有参数引用。比如：
<programlisting>
plan = plpy.prepare("SELECT last_name FROM my_users WHERE first_name = $1", ["text"])
</programlisting>
<!-- 
      <literal>text</literal> is the type of the variable you will be passing
      for <literal>$1</literal>.  The second argument is optional if you don't
      want to pass any parameters to the query.
-->
<literal>text</literal>是将作为<literal>$1</literal>传递的变量类型。
如果你不想传递任何参数到查询，那么第二个参数是可选的。
     </para>
    
<para>
<!--
      After preparing a statement, you use a variant of the
      function <function>plpy.execute</function> to run it:
-->
在准备一个语句之后，你用函数<function>plpy.execute</function>的一个变量运行它：
<programlisting>
rv = plpy.execute(plan, ["name"], 5)
</programlisting>
<!-- 
      Pass the plan as the first argument (instead of the query string), and a
      list of values to substitute into the query as the second argument.  The
      second argument is optional if the query does not expect any parameters.
      The third argument is the optional row limit as before.
-->
传递的规划作为第一个参数（而不是查询字符串），一个值的列表代入查询中作为第二个参数。
如果查询不希望有任何参数则第二个参数是可选的。第三个参数和以前一样，是可选的，行数限制。
     </para>

     <!--
<para>
      Query parameters and result row fields are converted between PostgreSQL
      and Python data types as described in <xref linkend="plpython-data">.
      The exception is that composite types are currently not supported: They
      will be rejected as query parameters and are converted to strings when
      appearing in a query result.  As a workaround for the latter problem, the
      query can sometimes be rewritten so that the composite type result
      appears as a result row rather than as a field of the result row.
      Alternatively, the resulting string could be parsed apart by hand, but
      this approach is not recommended because it is not future-proof.
     </para>
-->
<para>
查询参数和结果行字段在PostgreSQL和<xref linkend="plpython-data">描述的Python数据类型之间进行转换。
例外是目前不支持复合类型：当在查询结果中出现时，将拒绝他们作为查询参数，并且转换成字符串。
对于后者问题的解决方法，查询有时可以被改写，这样复合类型的结果作为一个结果行出现而不是一个结果行字段。
可选的，结果字符串可以手动的单独解析，但是不建议使用这个方法，因为它会过时。
</para>
    
<para>
<!--
      When you prepare a plan using the PL/Python module it is automatically
      saved.  Read the SPI documentation (<xref linkend="spi">) for a
      description of what this means.  In order to make effective use of this
      across function calls one needs to use one of the persistent storage
      dictionaries <literal>SD</literal> or <literal>GD</literal> (see
      <xref linkend="plpython-sharing">). For example:
-->
在你用PL/Python模块准备一个计划的时候，该计划是自动保存的。请阅读 SPI 文档(<xref linkend="spi">)
获取这句话的含义。为了能有效的使用这个跨函数调用，需要使用永久存储字典
<literal>SD</literal>或<literal>GD</literal>之一(参阅<xref linkend="plpython-sharing">)。比如：
<programlisting>
CREATE FUNCTION usesavedplan() RETURNS trigger AS $$
    plan = SD.setdefault("plan", plpy.prepare("SELECT 1"))
    # rest of function
$$ LANGUAGE plpythonu;
</programlisting>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>plpy.<function>cursor</function>(<replaceable>query</replaceable>)</literal></term>
    <term><literal>plpy.<function>cursor</function>(<replaceable>plan</replaceable> [, <replaceable>arguments</replaceable>])</literal></term>
    <listitem>
     <!--
<para>
      The <literal>plpy.cursor</literal> function accepts the same arguments
      as <literal>plpy.execute</literal> (except for the row limit) and returns
      a cursor object, which allows you to process large result sets in smaller
      chunks.  As with <literal>plpy.execute</literal>, either a query string
      or a plan object along with a list of arguments can be used.
     </para>
-->
<para>
<literal>plpy.cursor</literal>函数接受和<literal>plpy.execute</literal>一样的参数
（除了行限制），并返回一个游标对象，它允许你在一个小的语块中处理大的结果集。
和<literal>plpy.execute</literal>一样，可以使用一个查询字符串或者一个带有参数列表的规划对象。
</para>

     <!--
<para>
      The cursor object provides a <literal>fetch</literal> method that accepts
      an integer parameter and returns a result object.  Each time you
      call <literal>fetch</literal>, the returned object will contain the next
      batch of rows, never larger than the parameter value.  Once all rows are
      exhausted, <literal>fetch</literal> starts returning an empty result
      object.  Cursor objects also provide an
      <ulink url="http://docs.python.org/library/stdtypes.html#iterator-types">iterator
      interface</ulink>, yielding one row at a time until all rows are
      exhausted.  Data fetched that way is not returned as result objects, but
      rather as dictionaries, each dictionary corresponding to a single result
      row.
     </para>
-->
<para>
该游标对象提供一个<literal>fetch</literal>方法，接受一个整型参数并返回一个结果对象。
每次你调用<literal>fetch</literal>，返回的对象将包含下一批行，从不大于参数值。
一旦所有行都获得了，<literal>fetch</literal>开始返回一个空的结果对象。
游标对象也提供一个<ulink url="http://docs.python.org/library/stdtypes.html#iterator-types">迭代器接口</ulink>，
一次生成一行直到所有行都获得。这种方式获取的数据不作为结果对象返回，而是作为字典，
每个字典对应于一个结果行。
</para>
     
<para>
<!--
      An example of two ways of processing data from a large table is:
-->
两种方式处理大表中数据的例子是：
<programlisting>
CREATE FUNCTION count_odd_iterator() RETURNS integer AS $$
odd = 0
for row in plpy.cursor("select num from largetable"):
    if row['num'] % 2:
         odd += 1
return odd
$$ LANGUAGE plpythonu;

CREATE FUNCTION count_odd_fetch(batch_size integer) RETURNS integer AS $$
odd = 0
cursor = plpy.cursor("select num from largetable")
while True:
    rows = cursor.fetch(batch_size)
    if not rows:
        break
    for row in rows:
        if row['num'] % 2:
            odd += 1
return odd
$$ LANGUAGE plpythonu;

CREATE FUNCTION count_odd_prepared() RETURNS integer AS $$
odd = 0
plan = plpy.prepare("select num from largetable where num % $1 &lt;&gt; 0", ["integer"])
rows = list(plpy.cursor(plan, [2]))

return len(rows)
$$ LANGUAGE plpythonu;
</programlisting>
     </para>

     <!--
<para>
      Cursors are automatically disposed of.  But if you want to explicitly
      release all resources held by a cursor, use the <literal>close</literal>
      method.  Once closed, a cursor cannot be fetched from anymore.
     </para>
-->
<para>
游标会自动处理。但是如果你希望明确的释放游标持有的所有资源，使用<literal>close</literal>方法。
一旦关闭了，游标不再能够获取。
</para>

     <tip>
      <!--
<para>
        Do not confuse objects created by <literal>plpy.cursor</literal> with
        DB-API cursors as defined by
        the <ulink url="http://www.python.org/dev/peps/pep-0249/">Python
        Database API specification</ulink>.  They don't have anything in common
        except for the name.
      </para>
-->
<para>
不要混淆<literal>plpy.cursor</literal>创建的对象和
<ulink url="http://www.python.org/dev/peps/pep-0249/">Python数据库API说明</ulink>定义的DB-API游标。
它们除了名字相同外没有什么相同的。
</para>
     </tip>
    </listitem>
   </varlistentry>
  </variablelist>

  </sect2>

  <sect2 id="plpython-trapping">
   <!--
   <title>Trapping Errors</title>
   -->
   <title>捕获错误</title>
  
<para>
<!--
    Functions accessing the database might encounter errors, which
    will cause them to abort and raise an exception.  Both
    <function>plpy.execute</function> and
    <function>plpy.prepare</function> can raise an instance of a subclass of
    <literal>plpy.SPIError</literal>, which by default will terminate
    the function.  This error can be handled just like any other
    Python exception, by using the <literal>try/except</literal>
    construct.  For example:
-->
访问数据库的函数可能会遇到错误，导致它们退出并引发异常。<function>plpy.execute</function>
和<function>plpy.prepare</function>都会一起一个<literal>plpy.SPIError</literal>
的子类的实例，缺省将终止函数。这个错误可以像任何其他Python异常那样处理，
通过使用<literal>try/except</literal>构造。例如：
<programlisting>
CREATE FUNCTION try_adding_joe() RETURNS text AS $$
    try:
        plpy.execute("INSERT INTO users(username) VALUES ('joe')")
    except plpy.SPIError:
        return "something went wrong"
    else:
        return "Joe added"
$$ LANGUAGE plpythonu;
</programlisting>
   </para>

<para>
<!-- 
    The actual class of the exception being raised corresponds to the
    specific condition that caused the error.  Refer
    to <xref linkend="errcodes-table"> for a list of possible
    conditions.  The module
    <literal>plpy.spiexceptions</literal> defines an exception class
    for each <productname>PostgreSQL</productname> condition, deriving
    their names from the condition name.  For
    instance, <literal>division_by_zero</literal>
    becomes <literal>DivisionByZero</literal>, <literal>unique_violation</literal>
    becomes <literal>UniqueViolation</literal>, <literal>fdw_error</literal>
    becomes <literal>FdwError</literal>, and so on.  Each of these
    exception classes inherits from <literal>SPIError</literal>.  This
    separation makes it easier to handle specific errors, for
    instance: 
-->
引发的异常的实际类对应于导致该错误的特定条件。查阅<xref linkend="errcodes-table">获取可能的条件的列表。
模块<literal>plpy.spiexceptions</literal>为每个<productname>PostgreSQL</productname>
条件定义一个异常类，从条件名中派生它们的名字。例如，<literal>division_by_zero</literal>
成为<literal>DivisionByZero</literal>，<literal>unique_violation</literal>成为
<literal>UniqueViolation</literal>，<literal>fdw_error</literal>成为<literal>FdwError</literal>等等。
每个异常类都从<literal>SPIError</literal>中继承。这个分离使得它更容易处理特定的错误，例如：
<programlisting>
CREATE FUNCTION insert_fraction(numerator int, denominator int) RETURNS text AS $$
from plpy import spiexceptions
try:
    plan = plpy.prepare("INSERT INTO fractions (frac) VALUES ($1 / $2)", ["int", "int"])
    plpy.execute(plan, [numerator, denominator])
except spiexceptions.DivisionByZero:
    return "denominator cannot equal zero"
except spiexceptions.UniqueViolation:
    return "already have that fraction"
except plpy.SPIError, e:
    return "other error, SQLSTATE %s" % e.sqlstate
else:
    return "fraction inserted"
$$ LANGUAGE plpythonu;
</programlisting>
<!-- 
    Note that because all exceptions from
    the <literal>plpy.spiexceptions</literal> module inherit
    from <literal>SPIError</literal>, an <literal>except</literal>
    clause handling it will catch any database access error. 
-->
请注意，因为所有来自<literal>plpy.spiexceptions</literal>模块的异常都从
<literal>SPIError</literal>继承，所以<literal>except</literal>子句处理它将捕获任何数据库访问错误。
   </para>

   <!--
<para>
    As an alternative way of handling different error conditions, you
    can catch the <literal>SPIError</literal> exception and determine
    the specific error condition inside the <literal>except</literal>
    block by looking at the <literal>sqlstate</literal> attribute of
    the exception object.  This attribute is a string value containing
    the <quote>SQLSTATE</quote> error code.  This approach provides
    approximately the same functionality
   </para>
-->
<para>
作为处理不同错误条件的一个替换方式，你可以捕获<literal>SPIError</literal>异常。
然后在<literal>except</literal>块中通过查看异常对象的<literal>sqlstate</literal>
属性确定特定的错误条件。这个属性是一个包含<quote>SQLSTATE</quote>错误代码的字符串值。
这个方法提供了差不多相同的功能。
</para>
  </sect2>
 </sect1>

 <sect1 id="plpython-subtransaction">
  <!--
  <title>Explicit Subtransactions</title>
  -->
  <title>明确的子事务</title>

  <!--
<para>
   Recovering from errors caused by database access as described in
   <xref linkend="plpython-trapping"> can lead to an undesirable
   situation where some operations succeed before one of them fails,
   and after recovering from that error the data is left in an
   inconsistent state.  PL/Python offers a solution to this problem in
   the form of explicit subtransactions.
  </para>
-->
<para>
从<xref linkend="plpython-trapping">中描述的数据库访问导致的错误中恢复可能会导致不良情况，
在一个操作失败之前已经有一些操作成功了，之后从错误中恢复使得数据停留在一个不一致的状态。
PL/Python提供了一个解决该问题的方法，以明确的子事务的形式。
</para>

  <sect2>
   <!--
   <title>Subtransaction Context Managers</title>
   -->
   <title>子事务内容管理器</title>

<para>
<!-- 
    Consider a function that implements a transfer between two
    accounts: 
-->
考虑一个实现在两个账户之间转换的函数：
<programlisting>
CREATE FUNCTION transfer_funds() RETURNS void AS $$
try:
    plpy.execute("UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'")
    plpy.execute("UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'")
except plpy.SPIError, e:
    result = "error transferring funds: %s" % e.args
else:
    result = "funds transferred correctly"
plan = plpy.prepare("INSERT INTO operations (result) VALUES ($1)", ["text"])
plpy.execute(plan, [result])
$$ LANGUAGE plpythonu;
</programlisting>
<!-- 
    If the second <literal>UPDATE</literal> statement results in an
    exception being raised, this function will report the error, but
    the result of the first <literal>UPDATE</literal> will
    nevertheless be committed.  In other words, the funds will be
    withdrawn from Joe's account, but will not be transferred to
    Mary's account. 
-->
如果第二个<literal>UPDATE</literal>语句导致异常发生，这个函数将报告该错误，
但是第一个<literal>UPDATE</literal>的结果将不会提交。换句话说，funds将从Joe的账户中退出，
但是不会转换到Mary的账户。
   </para>

<para>
<!-- 
    To avoid such issues, you can wrap your
    <literal>plpy.execute</literal> calls in an explicit
    subtransaction.  The <literal>plpy</literal> module provides a
    helper object to manage explicit subtransactions that gets created
    with the <literal>plpy.subtransaction()</literal> function.
    Objects created by this function implement the
    <ulink url="http://docs.python.org/library/stdtypes.html#context-manager-types">
    context manager interface</ulink>.  Using explicit subtransactions
    we can rewrite our function as: 
-->
为了避免这样的问题，你可以将你的<literal>plpy.execute</literal>调用封装在一个明确的子事务中。
<literal>plpy</literal>模块提供一个帮助对象管理用<literal>plpy.subtransaction()</literal>
函数创建的明确的子事务。这个函数创建的对象实现了
<ulink url="http://docs.python.org/library/stdtypes.html#context-manager-types">内容管理接口</ulink>。
使用明确的子事务我们可以重写我们的函数为：
<programlisting>
CREATE FUNCTION transfer_funds2() RETURNS void AS $$
try:
    with plpy.subtransaction():
        plpy.execute("UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'")
        plpy.execute("UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'")
except plpy.SPIError, e:
    result = "error transferring funds: %s" % e.args
else:
    result = "funds transferred correctly"
plan = plpy.prepare("INSERT INTO operations (result) VALUES ($1)", ["text"])
plpy.execute(plan, [result])
$$ LANGUAGE plpythonu;
</programlisting>
<!-- 
    Note that the use of <literal>try/catch</literal> is still
    required.  Otherwise the exception would propagate to the top of
    the Python stack and would cause the whole function to abort with
    a <productname>PostgreSQL</productname> error, so that the
    <literal>operations</literal> table would not have any row
    inserted into it.  The subtransaction context manager does not
    trap errors, it only assures that all database operations executed
    inside its scope will be atomically committed or rolled back.  A
    rollback of the subtransaction block occurs on any kind of
    exception exit, not only ones caused by errors originating from
    database access.  A regular Python exception raised inside an
    explicit subtransaction block would also cause the subtransaction
    to be rolled back. 
-->
请注意，仍然需要<literal>try/catch</literal>的使用。否则异常将传播到Python堆栈的顶部，
并导致整个函数带有<productname>PostgreSQL</productname>错误退出，所以
<literal>operations</literal>表将不会有任何行插入。子事务内容管理器并不捕获错误，
它只是保证在它的范围内执行的所有数据库操作都将自动提交或回滚。
一个子事务块的回滚在任何类型的异常退出上发生，不只是起源于数据库访问的错误导致的异常。
一个明确的子事务块内部发生的普通Python异常也会导致子事务回滚。
   </para>
  </sect2>

  <sect2>
   <!--
   <title>Older Python Versions</title> 
   -->
   <title>旧的Python版本</title>

<para>
<!-- 
    Context managers syntax using the <literal>with</literal> keyword
    is available by default in Python 2.6.  If using PL/Python with an
    older Python version, it is still possible to use explicit
    subtransactions, although not as transparently.  You can call the
    subtransaction manager's <literal>__enter__</literal> and
    <literal>__exit__</literal> functions using the
    <literal>enter</literal> and <literal>exit</literal> convenience
    aliases.  The example function that transfers funds could be
    written as: 
-->
使用<literal>with</literal>关键字的内容管理器语法缺省在Python 2.6中可用。
如果用旧的Python版本使用PL/Python，仍然可能使用明确的子事务，尽管不是透明的。
你可以使用方便的别名<literal>enter</literal>和<literal>exit</literal>
调用子事务管理器的<literal>__enter__</literal>和<literal>__exit__</literal>。
转换funds的例子函数可以写为：
<programlisting>
CREATE FUNCTION transfer_funds_old() RETURNS void AS $$
try:
    subxact = plpy.subtransaction()
    subxact.enter()
    try:
        plpy.execute("UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'")
        plpy.execute("UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'")
    except:
        import sys
        subxact.exit(*sys.exc_info())
        raise
    else:
        subxact.exit(None, None, None)
except plpy.SPIError, e:
    result = "error transferring funds: %s" % e.args
else:
    result = "funds transferred correctly"

plan = plpy.prepare("INSERT INTO operations (result) VALUES ($1)", ["text"])
plpy.execute(plan, [result])
$$ LANGUAGE plpythonu;
</programlisting>
   </para>

   <note>
    <!--
<para>
     Although context managers were implemented in Python 2.5, to use
     the <literal>with</literal> syntax in that version you need to
     use a <ulink
     url="http://docs.python.org/release/2.5/ref/future.html">future
     statement</ulink>.  Because of implementation details, however,
     you cannot use future statements in PL/Python functions.
    </para>
-->
<para>
尽管文本管理器是在Python 2.5中实现的，要在该版本中使用<literal>with</literal>
语法你需要使用一个<ulink url="http://docs.python.org/release/2.5/ref/future.html">未来声明</ulink>。
不过，由于实现的细节，你不能在PL/Python函数中使用未来声明。
</para>
   </note>
  </sect2>
 </sect1>

 <sect1 id="plpython-util">
  <!-- 
  <title>Utility Functions</title>
  -->
  <title>实用函数</title>
  <!--
<para>
   The <literal>plpy</literal> module also provides the functions
   <literal>plpy.debug(<replaceable>msg</>)</literal>,
   <literal>plpy.log(<replaceable>msg</>)</literal>,
   <literal>plpy.info(<replaceable>msg</>)</literal>,
   <literal>plpy.notice(<replaceable>msg</>)</literal>,
   <literal>plpy.warning(<replaceable>msg</>)</literal>,
   <literal>plpy.error(<replaceable>msg</>)</literal>, and
   <literal>plpy.fatal(<replaceable>msg</>)</literal>.<indexterm><primary>elog</><secondary>in PL/Python</></indexterm>
   <function>plpy.error</function> and
   <function>plpy.fatal</function> actually raise a Python exception
   which, if uncaught, propagates out to the calling query, causing
   the current transaction or subtransaction to be aborted.
   <literal>raise plpy.Error(<replaceable>msg</>)</literal> and
   <literal>raise plpy.Fatal(<replaceable>msg</>)</literal> are
   equivalent to calling
   <function>plpy.error</function> and
   <function>plpy.fatal</function>, respectively.
   The other functions only generate messages of different
   priority levels.
   Whether messages of a particular priority are reported to the client,
   written to the server log, or both is controlled by the
   <xref linkend="guc-log-min-messages"> and
   <xref linkend="guc-client-min-messages"> configuration
   variables. See <xref linkend="runtime-config"> for more information.
  </para>
-->
<para>
<literal>plpy</literal>模块也提供了函数<literal>plpy.debug(<replaceable>msg</>)</literal>、
<literal>plpy.log(<replaceable>msg</>)</literal>、<literal>plpy.info(<replaceable>msg</>)</literal>、
<literal>plpy.notice(<replaceable>msg</>)</literal>、<literal>plpy.warning(<replaceable>msg</>)</literal>、
<literal>plpy.error(<replaceable>msg</>)</literal>和<literal>plpy.fatal(<replaceable>msg</>)</literal>。
<indexterm><primary>elog</><secondary>在PL/Python中</></indexterm> <function>plpy.error</function>和
<function>plpy.fatal</function>实际上抛出了一个Python异常，如果没有捕获这个异常，
则会传播到调用的查询，导致当前事务或者子事务退出。<literal>raise plpy.Error(<replaceable>msg</>)</literal>
和<literal>raise plpy.Fatal(<replaceable>msg</>)</literal>分别等效于调用<function>plpy.error</function>
和<function>plpy.fatal</function>。其他函数只生成不同优先级的消息。特定优先级的消息是被报告给客户端、
写到服务器日志、还是两件事都做，是由<xref linkend="guc-log-min-messages">和
<xref linkend="guc-client-min-messages">配置参数控制的。参阅<xref linkend="runtime-config">获取更多信息。
</para>
 
<para>
<!--
   Another set of utility functions are
   <literal>plpy.quote_literal(<replaceable>string</>)</literal>,
   <literal>plpy.quote_nullable(<replaceable>string</>)</literal>, and
   <literal>plpy.quote_ident(<replaceable>string</>)</literal>.  They
   are equivalent to the built-in quoting functions described in <xref
   linkend="functions-string">.  They are useful when constructing
   ad-hoc queries.  A PL/Python equivalent of dynamic SQL from <xref
   linkend="plpgsql-quote-literal-example"> would be:
-->
另一个实用函数集是<literal>plpy.quote_literal(<replaceable>string</>)</literal>、
<literal>plpy.quote_nullable(<replaceable>string</>)</literal>和
<literal>plpy.quote_ident(<replaceable>string</>)</literal>。
它们相当于<xref linkend="functions-string">中描述的内建引用函数。
它们在构造ad-hoc查询的时候是有用的。一个来自<xref linkend="plpgsql-quote-literal-example">
的动态SQL的PL/Python等效将是：
<programlisting>
plpy.execute("UPDATE tbl SET %s = %s WHERE key = %s" % (
    plpy.quote_ident(colname),
    plpy.quote_nullable(newvalue),
    plpy.quote_literal(keyvalue)))
</programlisting>
  </para>
 </sect1>

 <sect1 id="plpython-envar">
  <!--
  <title>Environment Variables</title>
  -->
  <title>环境变量</title>

<para>
<!-- 
   Some of the environment variables that are accepted by the Python
   interpreter can also be used to affect PL/Python behavior.  They
   would need to be set in the environment of the main PostgreSQL
   server process, for example in a start script.  The available
   environment variables depend on the version of Python; see the
   Python documentation for details.  At the time of this writing, the
   following environment variables have an affect on PL/Python,
   assuming an adequate Python version: 
-->
Python解释器接受的一些环境变量可以影响PL/Python行为，
他们需要在PostgreSQL服务器主进程的环境中设置。例如，在启动脚本中。
可用的环境变量依赖于Python的版本；细节参见Python文档。在写这篇文章时，
下列环境变量对PL/Python有影响，假设一个适当的Python版本：
   <itemizedlist>
    <listitem>
     <para><envar>PYTHONHOME</envar></para>
    </listitem>

    <listitem>
<para><envar>PYTHONPATH</envar></para>
    </listitem>

    <listitem>
<para><envar>PYTHONY2K</envar></para>
    </listitem>

    <listitem>
<para><envar>PYTHONOPTIMIZE</envar></para>
    </listitem>

    <listitem>
<para><envar>PYTHONDEBUG</envar></para>
    </listitem>

    <listitem>
<para><envar>PYTHONVERBOSE</envar></para>
    </listitem>

    <listitem>
<para><envar>PYTHONCASEOK</envar></para>
    </listitem>

    <listitem>
<para><envar>PYTHONDONTWRITEBYTECODE</envar></para>
    </listitem>

    <listitem>
<para><envar>PYTHONIOENCODING</envar></para>
    </listitem>

    <listitem>
<para><envar>PYTHONUSERBASE</envar></para>
    </listitem>

    <listitem>
<para><envar>PYTHONHASHSEED</envar></para>
    </listitem>
   </itemizedlist>

<!-- 
   (It appears to be a Python implementation detail beyond the control
   of PL/Python that some of the environment variables listed on
   the <command>python</command> man page are only effective in a
   command-line interpreter and not an embedded Python interpreter.) 
-->
（这似乎是超出PL/Python控制的一个Python实现细节，在<command>python</command>
手册上列出的一些环境变量只影响一个命令行解释器，并非嵌入式Python解释器。）
  </para>
 </sect1>
</chapter>
