<!--
doc/src/sgml/ref/create_aggregate.sgml
PostgreSQL documentation
-->

<refentry id="SQL-CREATEAGGREGATE">
 <indexterm zone="sql-createaggregate">
  <primary>CREATE AGGREGATE</primary>
 </indexterm>
 <refmeta>
  <refentrytitle>CREATE AGGREGATE</refentrytitle>
  <manvolnum>7</manvolnum>
  <!--
<refmiscinfo>SQL - Language Statements</refmiscinfo>
-->
<refmiscinfo>SQL - 语句</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE AGGREGATE</refname>
  <!--
<refpurpose>define a new aggregate function</refpurpose>
-->
<refpurpose>
定义一个新的聚合函数
</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>

CREATE AGGREGATE <replaceable class="parameter">name</replaceable> ( [ <replaceable class="parameter">argmode</replaceable> ] [ <replaceable class="parameter">argname</replaceable> ] <replaceable class="parameter">arg_data_type</replaceable> [ , ... ] ) (
    SFUNC = <replaceable class="PARAMETER">sfunc</replaceable>,
    STYPE = <replaceable class="PARAMETER">state_data_type</replaceable>
    [ , SSPACE = <replaceable class="PARAMETER">state_data_size</replaceable> ]
    [ , FINALFUNC = <replaceable class="PARAMETER">ffunc</replaceable> ]
    [ , FINALFUNC_EXTRA ]
    [ , INITCOND = <replaceable class="PARAMETER">initial_condition</replaceable> ]
    [ , MSFUNC = <replaceable class="PARAMETER">msfunc</replaceable> ]
    [ , MINVFUNC = <replaceable class="PARAMETER">minvfunc</replaceable> ]
    [ , MSTYPE = <replaceable class="PARAMETER">mstate_data_type</replaceable> ]
    [ , MSSPACE = <replaceable class="PARAMETER">mstate_data_size</replaceable> ]
    [ , MFINALFUNC = <replaceable class="PARAMETER">mffunc</replaceable> ]
    [ , MFINALFUNC_EXTRA ]
    [ , MINITCOND = <replaceable class="PARAMETER">minitial_condition</replaceable> ]
    [ , SORTOP = <replaceable class="PARAMETER">sort_operator</replaceable> ]
)

CREATE AGGREGATE <replaceable class="parameter">name</replaceable> ( [ [ <replaceable class="parameter">argmode</replaceable> ] [ <replaceable class="parameter">argname</replaceable> ] <replaceable class="parameter">arg_data_type</replaceable> [ , ... ] ]
                        ORDER BY [ <replaceable class="parameter">argmode</replaceable> ] [ <replaceable class="parameter">argname</replaceable> ] <replaceable class="parameter">arg_data_type</replaceable> [ , ... ] ) (
    SFUNC = <replaceable class="PARAMETER">sfunc</replaceable>,
    STYPE = <replaceable class="PARAMETER">state_data_type</replaceable>
    [ , SSPACE = <replaceable class="PARAMETER">state_data_size</replaceable> ]
    [ , FINALFUNC = <replaceable class="PARAMETER">ffunc</replaceable> ]
    [ , FINALFUNC_EXTRA ]
    [ , INITCOND = <replaceable class="PARAMETER">initial_condition</replaceable> ]
    [ , HYPOTHETICAL ]
)


<!--
 <phrase>or the old syntax</phrase>
-->
<phrase>或者是老的语法</phrase>

CREATE AGGREGATE <replaceable class="PARAMETER">name</replaceable> (
    BASETYPE = <replaceable class="PARAMETER">base_type</replaceable>,
    SFUNC = <replaceable class="PARAMETER">sfunc</replaceable>,
    STYPE = <replaceable class="PARAMETER">state_data_type</replaceable>
    [ , SSPACE = <replaceable class="PARAMETER">state_data_size</replaceable> ]
    [ , FINALFUNC = <replaceable class="PARAMETER">ffunc</replaceable> ]
    [ , FINALFUNC_EXTRA ]
    [ , INITCOND = <replaceable class="PARAMETER">initial_condition</replaceable> ]
    [ , MSFUNC = <replaceable class="PARAMETER">msfunc</replaceable> ]
    [ , MINVFUNC = <replaceable class="PARAMETER">minvfunc</replaceable> ]
    [ , MSTYPE = <replaceable class="PARAMETER">mstate_data_type</replaceable> ]
    [ , MSSPACE = <replaceable class="PARAMETER">mstate_data_size</replaceable> ]
    [ , MFINALFUNC = <replaceable class="PARAMETER">mffunc</replaceable> ]
    [ , MFINALFUNC_EXTRA ]
    [ , MINITCOND = <replaceable class="PARAMETER">minitial_condition</replaceable> ]
    [ , SORTOP = <replaceable class="PARAMETER">sort_operator</replaceable> ]
)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <command>CREATE AGGREGATE</command> defines a new aggregate
   function. Some basic and commonly-used aggregate functions are
   included with the distribution; they are documented in <xref
   linkend="functions-aggregate">. If one defines new types or needs
   an aggregate function not already provided, then <command>CREATE
   AGGREGATE</command> can be used to provide the desired features.
  </para>
-->
<para>
<command>CREATE AGGREGATE</command>定义一个新的聚合函数。
一些常用的聚合函数已经包含在基础软件包里了；在<xref linkend="functions-aggregate">里有文档说明。
如果你需要定义一个新类型或需要一个还没有提供的聚合函数，这时<command>CREATE AGGREGATE</command>便可派上用场。 
</para>

  <!--
<para>
   If a schema name is given (for example, <literal>CREATE AGGREGATE
   myschema.myagg ...</>) then the aggregate function is created in the
   specified schema.  Otherwise it is created in the current schema.
  </para>
-->
<para>
如果给出了一个模式的名字(比如<literal>CREATE AGGREGATE myschema.myagg ...</>)，那么该聚合函数是在指定模式中创建的。
否则它是在当前模式中创建的。 
</para>

  <!--
<para>
   An aggregate function is identified by its name and input data type(s).
   Two aggregates in the same schema can have the same name if they operate on
   different input types.  The
   name and input data type(s) of an aggregate must also be distinct from
   the name and input data type(s) of every ordinary function in the same
   schema.
   This behavior is identical to overloading of ordinary function names
   (see <xref linkend="sql-createfunction">).
  </para>
-->
<para>
一个聚合函数是用它的名字和输入数据类型来标识的。
同一模式中如果两个聚合处理的输入数据不同，它们可以有相同的名字。
一个聚合函数的输入数据类型必须和所有同一模式中的普通函数的名字和输入类型不同。
这个行为和重载普通函数名相同（参阅<xref linkend="sql-createfunction">）。 
</para>

  <!--
<para>
   A simple aggregate function is made from one or two ordinary
   functions:
   a state transition function
   <replaceable class="PARAMETER">sfunc</replaceable>,
   and an optional final calculation function
   <replaceable class="PARAMETER">ffunc</replaceable>.
   These are used as follows:
<programlisting>
<replaceable class="PARAMETER">sfunc</replaceable>( internal-state, next-data-values ) &minus;&minus;-> next-internal-state
<replaceable class="PARAMETER">ffunc</replaceable>( internal-state ) &minus;&minus;-> aggregate-value
</programlisting>
  </para>
-->
<para>
一个简单的聚合函数是用一个或两个普通函数组成的：一个状态转换函数<replaceable class="PARAMETER">sfunc</replaceable>和一个可选的最终计算函数<replaceable class="PARAMETER">ffunc</replaceable>。
它们是这样使用的： 
<programlisting>
<replaceable class="PARAMETER">sfunc</replaceable>( internal-state, next-data-values ) ---> next-internal-state
<replaceable class="PARAMETER">ffunc</replaceable>( internal-state ) ---> aggregate-value
</programlisting>
</para>

  <!--
<para>
   <productname>PostgreSQL</productname> creates a temporary variable
   of data type <replaceable class="PARAMETER">stype</replaceable>
   to hold the current internal state of the aggregate.  At each input row,
   the aggregate argument value(s) are calculated and
   the state transition function is invoked with the current state value
   and the new argument value(s) to calculate a new
   internal state value.  After all the rows have been processed,
   the final function is invoked once to calculate the aggregate's return
   value.  If there is no final function then the ending state value
   is returned as-is.
  </para>
-->
<para>
<productname>PostgreSQL</productname>创建一个类型为<replaceable class="PARAMETER">stype</replaceable>的临时变量。
它保存这个聚合的当前内部状态。对于每个输入数据条目，都调用状态转换函数计算内部状态值的新数值。 
在处理完所有数据后，调用一次最终处理函数以计算聚合的返回值。如果没有最终处理函数， 则将最后的状态值当做返回值。 
</para>

  <!--
<para>
   An aggregate function can provide an initial condition,
   that is, an initial value for the internal state value.
   This is specified and stored in the database as a value of type
   <type>text</type>, but it must be a valid external representation
   of a constant of the state value data type.  If it is not supplied
   then the state value starts out null.
  </para>
-->
<para>
一个聚合函数还可能提供一个初始条件，也就是内部状态值的初始值。
这个值是作为一个类型为<type>text</type>的字段存储在数据库里的，不过它们必须是状态值数据类型的合法的外部 表现形式的常量。
如果没有提供状态，那么状态值初始化为 NULL 。 
</para>

<!--
<para>
   If the state transition function is declared <quote>strict</quote>,
   then it cannot be called with null inputs.  With such a transition
   function, aggregate execution behaves as follows.  Rows with any null input
   values are ignored (the function is not called and the previous state value
   is retained).  If the initial state value is null, then at the first row
   with all-nonnull input values, the first argument value replaces the state
   value, and the transition function is invoked at each subsequent row with
   all-nonnull input values.
   This is handy for implementing aggregates like <function>max</function>.
   Note that this behavior is only available when
   <replaceable class="PARAMETER">state_data_type</replaceable>
   is the same as the first
   <replaceable class="PARAMETER">arg_data_type</replaceable>.
   When these types are different, you must supply a nonnull initial
   condition or use a nonstrict transition function.
  </para>
-->
<para>
如果该状态转换函数被定义为<quote>strict</quote>，那么就不能用 NULL 输入调用它。
此时， 聚合的执行如下所述。带有任何 NULL 输入值的行将被忽略(不调用此函数并且保留前一个状态值)。 
如果初始状态值是 NULL ，那么在第一个含有非 NULL 值的行上，
使用第一个参数值替换状态值，然后状态转换函数在随后每个含有非 NULL 值的行上调用。
这样做让比较容易实现像<function>max</function>这样的聚合。
请注意这种行为只是当<replaceable class="PARAMETER">state_data_type</replaceable>
与第一个<replaceable class="PARAMETER">arg_data_type</replaceable>相同的时候才表现出来。 
如果这些类型不同，你必须提供一个非 NULL 的初始条件或者使用一个非"strict"的状态转换函数。 
</para>

  <!--
<para>
   If the state transition function is not strict, then it will be called
   unconditionally at each input row, and must deal with null inputs
   and null state values for itself.  This allows the aggregate
   author to have full control over the aggregate's handling of null values.
  </para>
-->
<para>
如果状态转换函数不是严格(strict)的，那么它将无条件地在每个输入行上调用，
并且必须自行处理空输入和空状态值，这样就允许聚合的作者对聚合中的空值有完全的控制。 
</para>

  <!--
<para>
   If the final function is declared <quote>strict</quote>, then it will not
   be called when the ending state value is null; instead a null result
   will be returned automatically.  (Of course this is just the normal
   behavior of strict functions.)  In any case the final function has
   the option of returning a null value.  For example, the final function for
   <function>avg</function> returns null when it sees there were zero
   input rows.
  </para>
-->
<para>
如果最终转换函数定义为<quote>strict</quote>，那么如果最终状态值是NULL 时就不会调用它； 
而是自动输出一个 NULL 结果。(这才是 strict 函数的正常特征。)
不管是哪种情况，最终处理函数 可以自由选择是否返回 NULL 。
比如，<function>avg</function>的最终处理函数在零输入记录时就会返回 NULL 。 
</para>

<!-- 
  <para>
   Sometimes it is useful to declare the final function as taking not just
   the state value, but extra parameters corresponding to the aggregate's
   input values.  The main reason for doing this is if the final function
   is polymorphic and the state value's data type would be inadequate to
   pin down the result type.  These extra parameters are always passed as
   NULL (and so the final function must not be strict when
   the <literal>FINALFUNC_EXTRA</> option is used), but nonetheless they
   are valid parameters.  The final function could for example make use
   of <function>get_fn_expr_argtype</> to identify the actual argument type
   in the current call.
  </para>
-->
<para>
有时声明最终函数不只是接受状态值是有用的，但是需要额外的参数对应到聚合的输入值。
这样做的主要原因是，如果最终函数是多态的并且状态值的数据类型不足以确定结果类型。
这些额外的参数总是作为NULL传递（因此最终函数在使用了<literal>FINALFUNC_EXTRA</>
选项时必须是非严格的），虽然如此，它们也是有效的参数。
最终函数可以，例如利用<function>get_fn_expr_argtype</>
确定当前调用中的实际参数类型。
</para>
<!-- 
  <para>
   An aggregate can optionally support <firstterm>moving-aggregate mode</>,
   as described in <xref linkend="xaggr-moving-aggregates">.  This requires
   specifying the <literal>MSFUNC</>, <literal>MINVFUNC</>,
   and <literal>MSTYPE</> parameters, and optionally
   the <literal>MSPACE</>, <literal>MFINALFUNC</>, <literal>MFINALFUNC_EXTRA</>,
   and <literal>MINITCOND</> parameters.  Except for <literal>MINVFUNC</>,
   these parameters work like the corresponding simple-aggregate parameters
   without <literal>M</>; they define a separate implementation of the
   aggregate that includes an inverse transition function.
  </para>
-->
<para>
一个聚合可以选择支持<firstterm>moving-aggregate mode</>，
就像<xref linkend="xaggr-moving-aggregates">中描述的那样。
这需要声明<literal>MSFUNC</>、<literal>MINVFUNC</>和<literal>MSTYPE</>参数，
可选的声明<literal>MSPACE</>、<literal>MFINALFUNC</>、<literal>MFINALFUNC_EXTRA</>
和<literal>MINITCOND</>参数。除了<literal>MINVFUNC</>，
这些参数和对应的简单的不带有<literal>M</>的聚合参数类似；
它们定义一个聚合的单独实现，包括反向转换函数。
</para>

<!-- 
  <para>
   The syntax with <literal>ORDER BY</literal> in the parameter list creates
   a special type of aggregate called an <firstterm>ordered-set
   aggregate</firstterm>; or if <literal>HYPOTHETICAL</> is specified, then
   a <firstterm>hypothetical-set aggregate</firstterm> is created.  These
   aggregates operate over groups of sorted values in order-dependent ways,
   so that specification of an input sort order is an essential part of a
   call.  Also, they can have <firstterm>direct</> arguments, which are
   arguments that are evaluated only once per aggregation rather than once
   per input row.  Hypothetical-set aggregates are a subclass of ordered-set
   aggregates in which some of the direct arguments are required to match,
   in number and data types, the aggregated argument columns.  This allows
   the values of those direct arguments to be added to the collection of
   aggregate-input rows as an additional <quote>hypothetical</> row.
  </para>
-->
<para>
在参数列表中带有<literal>ORDER BY</literal>的语法创建了一个名为
<firstterm>顺序集聚合</firstterm>的特殊聚合类型；或者如果声明了
<literal>HYPOTHETICAL</>，那么创建了一个<firstterm>假想集聚合</firstterm>。
这些聚合以顺序依赖的方式在存储的值组上操作，所以输入排序顺序的说明是调用的一个重要部分。
另外，它们可以有<firstterm>直接</>参数，这些参数仅在每个聚合中计算一次，
而不是在每个输入行中计算一次。假想集聚合是顺序集聚合的一个子类，
其中的一些直接参数需要在数量数据类型和聚合的参数字段上匹配。
这允许这些直接参数的值作为额外的<quote>假想</>
行添加到聚合输入行的集合。
</para>

  <!--
<para>
   Aggregates that behave like <function>MIN</> or <function>MAX</> can
   sometimes be optimized by looking into an index instead of scanning every
   input row.  If this aggregate can be so optimized, indicate it by
   specifying a <firstterm>sort operator</>.  The basic requirement is that
   the aggregate must yield the first element in the sort ordering induced by
   the operator; in other words:
<programlisting>
SELECT agg(col) FROM tab;
</programlisting>
   must be equivalent to:
<programlisting>
SELECT col FROM tab ORDER BY col USING sortop LIMIT 1;
</programlisting>
   Further assumptions are that the aggregate ignores null inputs, and that
   it delivers a null result if and only if there were no non-null inputs.
   Ordinarily, a data type's <literal>&lt;</> operator is the proper sort
   operator for <function>MIN</>, and <literal>&gt;</> is the proper sort
   operator for <function>MAX</>.  Note that the optimization will never
   actually take effect unless the specified operator is the <quote>less
   than</quote> or <quote>greater than</quote> strategy member of a B-tree
   index operator class.
  </para>
-->
<para>
行为类似<function>MIN</>或<function>MAX</>的聚合有时候可以优化为使用索引，而不用扫描 每个输入行。
如果这个聚合可以如此优化，则用一个<firstterm>排序操作符</>标识它。
这里基本的要求是聚合 必须以操作符归纳出来的排序顺序生成第一个元素；换句话说：
<programlisting>
SELECT agg(col) FROM tab;
</programlisting>
必须等于： 
<programlisting>
SELECT col FROM tab ORDER BY col USING sortop LIMIT 1;
</programlisting>
更多的假设是聚合忽略 NULL 输入，并且只有在输入没有非空数值的时候，它才生成NULL结果。 
通常，数据类型的 <literal>&lt;</> 操作符是<function>MIN</>的适用排序操作符，而 <literal>&gt;</> 是<function>MAX</> 的适用操作符。
请注意，除非声明的操作符是 B-tree 索引操作符类的<quote>小于</quote>或者<quote>大于</quote>策略号， 否则这种优化将不会生效。 
</para>

  <!--
<para>
   To be able to create an aggregate function, you must
   have <literal>USAGE</literal> privilege on the argument types, the state
   type(s), and the return type, as well as <literal>EXECUTE</literal>
   privilege on the transition and final functions.
  </para>
-->
<para>
要创建聚合函数，你必须具有相关参数类型、状态类型和返回类型的<literal>USAGE</literal>
权限，也必须具有转换函数和最终函数的<literal>EXECUTE</literal>权限。
</para>
 </refsect1>

 <refsect1>
  <!--
<title>Parameters</title>
-->
<title>参数</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="PARAMETER">name</replaceable></term>
    <listitem>
     <!--
<para>
      The name (optionally schema-qualified) of the aggregate function
      to create.
     </para>
-->
<para>
要创建的聚合函数名(可以有模式修饰) 。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">argmode</replaceable></term>
    <listitem>
<!-- 
     <para>
      The mode of an argument: <literal>IN</> or <literal>VARIADIC</>.
      (Aggregate functions do not support <literal>OUT</> arguments.)
      If omitted, the default is <literal>IN</>.  Only the last argument
      can be marked <literal>VARIADIC</>.
     </para>
-->
<para>
一个参数的模式：<literal>IN</>或<literal>VARIADIC</>。
（聚合函数不支持<literal>OUT</>参数。）如果省略，缺省是<literal>IN</>。
只有最后一个参数可以被标记为<literal>VARIADIC</>。
</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><replaceable class="parameter">argname</replaceable></term>

    <listitem>
<!-- 
     <para>
      The name of an argument.  This is currently only useful for
      documentation purposes.  If omitted, the argument has no name.
     </para>
-->
<para>
参数的名字。目前仅对文档有用。如果省略，该参数没有名字。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">arg_data_type</replaceable></term>
    <listitem>
     <!--
<para>
      An input data type on which this aggregate function operates.
      To create a zero-argument aggregate function, write <literal>*</>
      in place of the list of argument specifications.  (An example of such an
      aggregate is <function>count(*)</function>.)
     </para>
-->
<para>
该聚合函数要处理的输入数据类型。要创建一个零参数聚合函数，可以使用<literal>*</>代替参数说明列表。
（<function>count(*)</function>就是这种聚合函数的一个实例。 ）
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">base_type</replaceable></term>
    <listitem>
     <!--
<para>
      In the old syntax for <command>CREATE AGGREGATE</>, the input data type
      is specified by a <literal>basetype</> parameter rather than being
      written next to the aggregate name.  Note that this syntax allows
      only one input parameter.  To define a zero-argument aggregate function
      with this syntax, specify the <literal>basetype</> as
      <literal>"ANY"</> (not <literal>*</>).
      Ordered-set aggregates cannot be defined with the old syntax.
     </para>
-->
<para>
在以前的<command>CREATE AGGREGATE</>语法中，输入数据类型是通过<literal>basetype</>参数指定的，而不是写在聚合的名称之后。
需要注意的是这种以前语法仅允许一个输入参数。要用这个语法定义一个零参数聚合函数，
可以将<literal>basetype</>指定为<literal>"ANY"</>(而不是<literal>*</>)。
不能用老的语法定义顺序集聚合。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">sfunc</replaceable></term>
    <listitem>
     <!--
<para>
      The name of the state transition function to be called for each
      input row.  For a normal <replaceable class="PARAMETER">N</>-argument
      aggregate function, the <replaceable class="PARAMETER">sfunc</>
      must take <replaceable class="PARAMETER">N</>+1 arguments,
      the first being of type <replaceable
      class="PARAMETER">state_data_type</replaceable> and the rest
      matching the declared input data type(s) of the aggregate.
      The function must return a value of type <replaceable
      class="PARAMETER">state_data_type</replaceable>.  This function
      takes the current state value and the current input data value(s),
      and returns the next state value.
     </para>
-->
<para>
将在每一个输入行上调用的状态转换函数的名称。
对于有<replaceable class="PARAMETER">N</>个参数的聚合函数，<replaceable class="PARAMETER">sfunc</>必须有 <replaceable class="PARAMETER">+1 </>个参数，其中的第一个参数类型为<replaceable class="PARAMETER">state_data_type</replaceable>，其余的匹配已声明的输入数据类型。
函数必须返回一个<replaceable class="PARAMETER">state_data_type</replaceable>类型的值。
这个函数接受当前状态值和当前输入数据，并返回下个状态值。 
</para>

<!-- 
     <para>
      For ordered-set (including hypothetical-set) aggregates, the state
      transition function receives only the current state value and the
      aggregated arguments, not the direct arguments.  Otherwise it is the
      same.
     </para>
-->
<para>
对于顺序集聚合（包括假想集），状态转换函数仅接受当前状态值和聚合的参数，
不接受直接参数。否则它们就相同了。
      For ordered-set (including hypothetical-set) aggregates, the state
      transition function receives only the current state value and the
      aggregated arguments, not the direct arguments.  Otherwise it is the
      same.
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">state_data_type</replaceable></term>
    <listitem>
     <!--
<para>
      The data type for the aggregate's state value.
     </para>
-->
<para>
聚合的状态值的数据类型。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">state_data_size</replaceable></term>
    <listitem>
    
<!-- 
     <para>
      The approximate average size (in bytes) of the aggregate's state value.
      If this parameter is omitted or is zero, a default estimate is used
      based on the <replaceable>state_data_type</>.
      The planner uses this value to estimate the memory required for a
      grouped aggregate query.  The planner will consider using hash
      aggregation for such a query only if the hash table is estimated to fit
      in <xref linkend="guc-work-mem">; therefore, large values of this
      parameter discourage use of hash aggregation.
     </para>
--> 
<para>
聚合的状态值的大约平均大小（以字节计）。如果省略了这个参数或者参数值为0，
则使用基于<replaceable>state_data_type</>的缺省估计。
规划器使用这个值估计分组的聚合查询所需的内存。
只有预计哈希表适合<xref linkend="guc-work-mem">时，
规划器才为这样一个查询考虑使用哈希聚合；因此，
这个参数值较大的话，会妨碍使用哈希聚合。
</para>   
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">ffunc</replaceable></term>
    <listitem>
     <!--
<para>
      The name of the final function called to compute the aggregate's
      result after all input rows have been traversed.
      For a normal aggregate, this function
      must take a single argument of type <replaceable
      class="PARAMETER">state_data_type</replaceable>.  The return
      data type of the aggregate is defined as the return type of this
      function.  If <replaceable class="PARAMETER">ffunc</replaceable>
      is not specified, then the ending state value is used as the
      aggregate's result, and the return type is <replaceable
      class="PARAMETER">state_data_type</replaceable>.
     </para>
-->
<para>
在转换完所有输入行后调用的最终处理函数，它计算聚合的结果。对于一个普通聚合，
此函数必须接受一个类型为<replaceable class="PARAMETER">state_data_type</replaceable>的参数。
聚合的输出数据类型被定义为此函数的返回类型。
如果没有声明<replaceable class="PARAMETER">ffunc</replaceable>则使用聚合结果的状态值作为聚合的结果，且输出类型为<replaceable class="PARAMETER">state_data_type</replaceable>。 
</para>

<!-- 
     <para>
      For ordered-set (including hypothetical-set) aggregates, the
      final function receives not only the final state value,
      but also the values of all the direct arguments.
     </para>
-->
<para>
对于顺序集（包括假设集）聚合，最终函数不只是接受最终的状态值，
也接受所有直接参数的值。
</para>

<!-- 
     <para>
      If <literal>FINALFUNC_EXTRA</> is specified, then in addition to the
      final state value and any direct arguments, the final function
      receives extra NULL values corresponding to the aggregate's regular
      (aggregated) arguments.  This is mainly useful to allow correct
      resolution of the aggregate result type when a polymorphic aggregate
      is being defined.
     </para>
-->
<para>
如果声明了<literal>FINALFUNC_EXTRA</>，那么除了最终状态值和任何直接参数外，
最终函数还接受额外的NULL值对应于该聚合的普通（聚合的）参数。
这在定义多态聚合函数时，对于正确的解析聚合的结果类型很有帮助。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">initial_condition</replaceable></term>
    <listitem>
     <!--
<para>
      The initial setting for the state value.  This must be a string
      constant in the form accepted for the data type <replaceable
      class="PARAMETER">state_data_type</replaceable>.  If not
      specified, the state value starts out null.
     </para>
-->
<para>
状态值的初始设置(值)。
它必须是一个<replaceable class="PARAMETER">state_data_type</replaceable>类型可以接受的文本常量值。
如果没有声明，状态值初始为 NULL 。 
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">msfunc</replaceable></term>
    <listitem>
<!-- 
     <para>
      The name of the forward state transition function to be called for each
      input row in moving-aggregate mode.  This is exactly like the regular
      transition function, except that its first argument and result are of
      type <replaceable>mstate_data_type</>, which might be different
      from <replaceable>state_data_type</>.
     </para>
-->
<para>
moving-aggregate模式下每个输入行调用的正向状态转换函数的名字。
这恰好类似于普通转换函数，除了它的第一个参数和结果是
<replaceable>mstate_data_type</>类型的，与
<replaceable>state_data_type</>类型不同。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">minvfunc</replaceable></term>
    <listitem>
<!-- 
     <para>
      The name of the inverse state transition function to be used in
      moving-aggregate mode.  This function has the same argument and
      result types as <replaceable>msfunc</>, but it is used to remove
      a value from the current aggregate state, rather than add a value to
      it.  The inverse transition function must have the same strictness
      attribute as the forward state transition function.
     </para>
-->
<para>
moving-aggregate模式下使用的反向状态转换函数的名字。
这个函数有着和<replaceable>msfunc</>一样的参数和结果类型，
但是它是用来从当前聚合状态中移除一个值的，而不是添加一个值。
该反向转换函数必须和正向状态转换函数拥有严格相同的属性。
</para>
    </listitem>
   </varlistentry>
   
   <varlistentry>
    <term><replaceable class="PARAMETER">mstate_data_type</replaceable></term>
    <listitem>
<!-- 
     <para>
      The data type for the aggregate's state value, when using
      moving-aggregate mode.
     </para>
-->
<para>
当使用moving-aggregate模式时，聚合的状态值的数据类型。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">mstate_data_size</replaceable></term>
    <listitem>
<!-- 
     <para>
      The approximate average size (in bytes) of the aggregate's state
      value, when using moving-aggregate mode.  This works the same as
      <replaceable>state_data_size</>.
     </para>
-->
<para>
当使用moving-aggregate模式时，聚合的状态值的大约平均大小（以字节计）。
这和<replaceable>state_data_size</>相同。
</para>
    </listitem>
   </varlistentry>
   
   <varlistentry>
    <term><replaceable class="PARAMETER">mffunc</replaceable></term>
    <listitem>
<!-- 
     <para>
      The name of the final function called to compute the aggregate's
      result after all input rows have been traversed, when using
      moving-aggregate mode.  This works the same as <replaceable>ffunc</>,
      except that its first argument's type
      is <replaceable>mstate_data_type</> and extra dummy arguments are
      specified by writing <literal>MFINALFUNC_EXTRA</>.
      The aggregate result type determined by <replaceable>mffunc</>
      or <replaceable>mstate_data_type</> must match that determined by the
      aggregate's regular implementation.
     </para>
-->
<para>
使用moving-aggregate模式时，在所有输入行被转换后，
调用来计算聚合的结果的最终函数的名字。
这和<replaceable>ffunc</>相同，除了它的第一个参数的类型是
<replaceable>mstate_data_type</>和额外的空变量是通过<literal>MFINALFUNC_EXTRA</>
声明的。该聚合的结果类型视<replaceable>mffunc</>而定，
或者<replaceable>mstate_data_type</>必须匹配视该聚合的普通实现而定。
</para>
    </listitem>
   </varlistentry>   
   
   <varlistentry>
    <term><replaceable class="PARAMETER">minitial_condition</replaceable></term>
    <listitem>
<!-- 
     <para>
      The initial setting for the state value, when using moving-aggregate
      mode.  This works the same as <replaceable>initial_condition</>.
     </para>
-->
<para>
当使用moving-aggregate模式时，状态值的内部设置。
这和<replaceable>initial_condition</>相同。
</para>   
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">sort_operator</replaceable></term>
    <listitem>
     <!--
<para>
      The associated sort operator for a <function>MIN</>- or
      <function>MAX</>-like aggregate.
      This is just an operator name (possibly schema-qualified).
      The operator is assumed to have the same input data types as
      the aggregate (which must be a single-argument normal aggregate).
     </para>
-->
<para>
用于<function>MIN</>或<function>MAX</>类型聚合的排序操作符。
这个只是一个操作符名 (可以有模式修饰)。
这个操作符假设接受和聚合一样的输入数据类型（它必须是一个单参数普通聚合）。 
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>HYPOTHETICAL</literal></term>
    <listitem>
<!-- 
     <para>
      For ordered-set aggregates only, this flag specifies that the aggregate
      arguments are to be processed according to the requirements for
      hypothetical-set aggregates: that is, the last few direct arguments must
      match the data types of the aggregated (<literal>WITHIN GROUP</>)
      arguments.  The <literal>HYPOTHETICAL</literal> flag has no effect on
      run-time behavior, only on parse-time resolution of the data types and
      collations of the aggregate's arguments.
     </para>
-->
<para>
仅对于顺序集聚合，这个标志声明了根据假想集聚合的需求要被处理的聚合参数：
也就是，最后几个直接参数必须匹配聚合的（<literal>WITHIN GROUP</>）
参数的数据类型。<literal>HYPOTHETICAL</literal>标志对运行时行为没有影响，
只对分析时辨识数据类型和聚合的参数的排序有影响。
</para>
    </listitem>
   </varlistentry>
  </variablelist>

  <!--
<para>
   The parameters of <command>CREATE AGGREGATE</command> can be
   written in any order, not just the order illustrated above.
  </para>
-->
<para>
<command>CREATE AGGREGATE</command>的参数可以以任何顺序书写，而不只是上面显示的顺序。 
</para>
 </refsect1>

 <refsect1>
<!-- 
  <title>Notes</title>
-->
  <title>注意</title>
<!-- 
   <para>
    In parameters that specify support function names, you can write
    a schema name if needed, for example <literal>SFUNC = public.sum</>.
    Do not write argument types there, however &mdash; the argument types
    of the support functions are determined from other parameters.
   </para>
-->
<para>
在声明支持函数名的参数中，如果需要，你可以写入模式名，例如
<literal>SFUNC = public.sum</>。在这里不要写参数类型，
不过 &mdash; 支持的函数的参数类型是由其他参数决定的。
</para>

<!-- 
   <para>
    If an aggregate supports moving-aggregate mode, it will improve
    calculation efficiency when the aggregate is used as a window function
    for a window with moving frame start (that is, a frame start mode other
    than <literal>UNBOUNDED PRECEDING</>).  Conceptually, the forward
    transition function adds input values to the aggregate's state when
    they enter the window frame from the bottom, and the inverse transition
    function removes them again when they leave the frame at the top.  So,
    when values are removed, they are always removed in the same order they
    were added.  Whenever the inverse transition function is invoked, it will
    thus receive the earliest added but not yet removed argument value(s).
    The inverse transition function can assume that at least one row will
    remain in the current state after it removes the oldest row.  (When this
    would not be the case, the window function mechanism simply starts a
    fresh aggregation, rather than using the inverse transition function.)
   </para>
-->
<para>
如果一个聚合支持moving-aggregate模式，
那么当聚合用作一个带有移动帧起始的窗口的窗口函数时，
它将提升计算效率（也就是帧起始模式，而不是<literal>UNBOUNDED PRECEDING</>）。
从概念上讲，当从底部进入窗口帧时，正向转换函数添加输入值到聚合的状态，
当从顶部离开帧时反向转换函数删除它们。所以，当值被移除时，
它们总是以它们添加的顺序移除。当调用反向转换函数时，
它将因此收到最早添加但是还未删除的参数值。
反向转换函数可以假设在它删除最老的行之后至少还有一行保留在当前的状态中。
（当不是这种情况是，窗口函数机制只是启动一个新的聚合，
而不是使用反向转换函数。）
</para>

<!-- 
   <para>
    The forward transition function for moving-aggregate mode is not
    allowed to return NULL as the new state value. If the inverse
    transition function returns NULL, this is taken as an indication that
    the inverse function cannot reverse the state calculation for this
    particular input, and so the aggregate calculation will be redone from
    scratch for the current frame starting position.  This convention
    allows moving-aggregate mode to be used in situations where there are
    some infrequent cases that are impractical to reverse out of the
    running state value.
   </para>
-->
<para>
正向转换函数在moving-aggregate模式下是不允许返回NULL作为新的状态值的。
如果反向转换函数返回了NULL，这将被当做反向函数不能为这个特殊输入解析状态计算的指示，
并且因此聚合计算将从当前帧起始位置重做。
这个约定允许moving-aggregate模式用在一些不常见的不切实际的逆转运行状态值的情况下。
</para>

<!-- 
   <para>
    If no moving-aggregate implementation is supplied,
    the aggregate can still be used with moving frames,
    but <productname>PostgreSQL</productname> will recompute the whole
    aggregation whenever the start of the frame moves.
    Note that whether or not the aggregate supports moving-aggregate
    mode, <productname>PostgreSQL</productname> can handle a moving frame
    end without recalculation; this is done by continuing to add new values
    to the aggregate's state.  It is assumed that the final function does
    not damage the aggregate's state value, so that the aggregation can be
    continued even after an aggregate result value has been obtained for
    one set of frame boundaries.
   </para>
-->
<para>
如果没有应用moving-aggregate实现，聚合仍然可以使用移动帧，
但是<productname>PostgreSQL</productname>将在帧起始位置移动时重新计算整个聚合。
请注意，不管聚合是否支持moving-aggregate模式，
<productname>PostgreSQL</productname>都可以处理移动帧结束而不用重新计算，
这是通过持续添加新的值到聚合的状态做到的。它假设最终函数不毁坏聚合的状态值，
这样聚合可以持续，即使是在已经获得了一组帧的边界的聚合结果值之后。
</para>

<!-- 
   <para>
    The syntax for ordered-set aggregates allows <literal>VARIADIC</>
    to be specified for both the last direct parameter and the last
    aggregated (<literal>WITHIN GROUP</>) parameter.  However, the
    current implementation restricts use of <literal>VARIADIC</>
    in two ways.  First, ordered-set aggregates can only use
    <literal>VARIADIC "any"</>, not other variadic array types.
    Second, if the last direct parameter is <literal>VARIADIC "any"</>,
    then there can be only one aggregated parameter and it must also
    be <literal>VARIADIC "any"</>.  (In the representation used in the
    system catalogs, these two parameters are merged into a single
    <literal>VARIADIC "any"</> item, since <structname>pg_proc</> cannot
    represent functions with more than one <literal>VARIADIC</> parameter.)
    If the aggregate is a hypothetical-set aggregate, the direct arguments
    that match the <literal>VARIADIC "any"</> parameter are the hypothetical
    ones; any preceding parameters represent additional direct arguments
    that are not constrained to match the aggregated arguments.
   </para>
-->
<para>
顺序集聚合的语法允许为最后的直接参数和最后聚合的(<literal>WITHIN GROUP</>)
参数声明<literal>VARIADIC</>。不过，当前实现以两种方式约束使用
<literal>VARIADIC</>。第一，顺序集聚合只能使用<literal>VARIADIC "any"</>，
不能使用其他variadic数组类型。第二，如果最后的直接参数是
<literal>VARIADIC "any"</>，那么只能有一个聚合的参数并且它必须也是
<literal>VARIADIC "any"</>。（在系统目录中使用的表示，这两个参数合并为一个
<literal>VARIADIC "any"</>项，因为<structname>pg_proc</>
不能代表带有多于一个<literal>VARIADIC</>参数的函数。）
如果该聚合是一个假想集聚合，那么匹配<literal>VARIADIC "any"</>
参数的那个直接参数是假想的那一个；
任何之前的参数表示不必匹配聚合的参数的额外直接参数。
</para>

<!-- 
   <para>
    Currently, ordered-set aggregates do not need to support
    moving-aggregate mode, since they cannot be used as window functions.
   </para>
-->
<para>
目前，顺序集聚合不需要支持moving-aggregate模式，
因为它们不能用作窗口函数。
</para>

 </refsect1>

 <refsect1>
  <!--
<title>Examples</title>
-->
<title>例子</title>

  <!--
<para>
   See <xref linkend="xaggr">.
  </para>
-->
<para>
参见<xref linkend="xaggr">。
</para>
 </refsect1>

 <refsect1>
  <!--
<title>Compatibility</title>
-->
<title>兼容性</title>

  <!--
<para>
   <command>CREATE AGGREGATE</command> is a
   <productname>PostgreSQL</productname> language extension.  The SQL
   standard does not provide for user-defined aggregate functions.
  </para>
-->
<para>
<command>CREATE AGGREGATE</command>是<productname>PostgreSQL</productname>语言的扩展。
SQL标准没有提供用户自定义聚合函数的功能。 
</para>
 </refsect1>

 <refsect1>
  <!--
<title>See Also</title>
-->
<title>参见</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alteraggregate"></member>
   <member><xref linkend="sql-dropaggregate"></member>
  </simplelist>
 </refsect1>
</refentry>
