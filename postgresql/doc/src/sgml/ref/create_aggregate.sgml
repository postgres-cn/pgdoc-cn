<!--
doc/src/sgml/ref/create_aggregate.sgml
PostgreSQL documentation
-->

<refentry id="sql-createaggregate">
<!--==========================orignal english content==========================
 <indexterm zone="sql-createaggregate">
  <primary>CREATE AGGREGATE</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="sql-createaggregate">
  <primary>CREATE AGGREGATE</primary>
 </indexterm>

<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>CREATE AGGREGATE</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>CREATE AGGREGATE</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>CREATE AGGREGATE</refname>
  <refpurpose>define a new aggregate function</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>CREATE AGGREGATE</refname>
  <refpurpose>定义一个新的聚集函数</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
CREATE [ OR REPLACE ] AGGREGATE <replaceable class="parameter">name</replaceable> ( [ <replaceable class="parameter">argmode</replaceable> ] [ <replaceable class="parameter">argname</replaceable> ] <replaceable class="parameter">arg_data_type</replaceable> [ , ... ] ) (
    SFUNC = <replaceable class="parameter">sfunc</replaceable>,
    STYPE = <replaceable class="parameter">state_data_type</replaceable>
    [ , SSPACE = <replaceable class="parameter">state_data_size</replaceable> ]
    [ , FINALFUNC = <replaceable class="parameter">ffunc</replaceable> ]
    [ , FINALFUNC_EXTRA ]
    [ , FINALFUNC_MODIFY = { READ_ONLY | SHAREABLE | READ_WRITE } ]
    [ , COMBINEFUNC = <replaceable class="parameter">combinefunc</replaceable> ]
    [ , SERIALFUNC = <replaceable class="parameter">serialfunc</replaceable> ]
    [ , DESERIALFUNC = <replaceable class="parameter">deserialfunc</replaceable> ]
    [ , INITCOND = <replaceable class="parameter">initial_condition</replaceable> ]
    [ , MSFUNC = <replaceable class="parameter">msfunc</replaceable> ]
    [ , MINVFUNC = <replaceable class="parameter">minvfunc</replaceable> ]
    [ , MSTYPE = <replaceable class="parameter">mstate_data_type</replaceable> ]
    [ , MSSPACE = <replaceable class="parameter">mstate_data_size</replaceable> ]
    [ , MFINALFUNC = <replaceable class="parameter">mffunc</replaceable> ]
    [ , MFINALFUNC_EXTRA ]
    [ , MFINALFUNC_MODIFY = { READ_ONLY | SHAREABLE | READ_WRITE } ]
    [ , MINITCOND = <replaceable class="parameter">minitial_condition</replaceable> ]
    [ , SORTOP = <replaceable class="parameter">sort_operator</replaceable> ]
    [ , PARALLEL = { SAFE | RESTRICTED | UNSAFE } ]
)

CREATE [ OR REPLACE ] AGGREGATE <replaceable class="parameter">name</replaceable> ( [ [ <replaceable class="parameter">argmode</replaceable> ] [ <replaceable class="parameter">argname</replaceable> ] <replaceable class="parameter">arg_data_type</replaceable> [ , ... ] ]
                        ORDER BY [ <replaceable class="parameter">argmode</replaceable> ] [ <replaceable class="parameter">argname</replaceable> ] <replaceable class="parameter">arg_data_type</replaceable> [ , ... ] ) (
    SFUNC = <replaceable class="parameter">sfunc</replaceable>,
    STYPE = <replaceable class="parameter">state_data_type</replaceable>
    [ , SSPACE = <replaceable class="parameter">state_data_size</replaceable> ]
    [ , FINALFUNC = <replaceable class="parameter">ffunc</replaceable> ]
    [ , FINALFUNC_EXTRA ]
    [ , FINALFUNC_MODIFY = { READ_ONLY | SHAREABLE | READ_WRITE } ]
    [ , INITCOND = <replaceable class="parameter">initial_condition</replaceable> ]
    [ , PARALLEL = { SAFE | RESTRICTED | UNSAFE } ]
    [ , HYPOTHETICAL ]
)

<phrase>or the old syntax</phrase>

CREATE [ OR REPLACE ] AGGREGATE <replaceable class="parameter">name</replaceable> (
    BASETYPE = <replaceable class="parameter">base_type</replaceable>,
    SFUNC = <replaceable class="parameter">sfunc</replaceable>,
    STYPE = <replaceable class="parameter">state_data_type</replaceable>
    [ , SSPACE = <replaceable class="parameter">state_data_size</replaceable> ]
    [ , FINALFUNC = <replaceable class="parameter">ffunc</replaceable> ]
    [ , FINALFUNC_EXTRA ]
    [ , FINALFUNC_MODIFY = { READ_ONLY | SHAREABLE | READ_WRITE } ]
    [ , COMBINEFUNC = <replaceable class="parameter">combinefunc</replaceable> ]
    [ , SERIALFUNC = <replaceable class="parameter">serialfunc</replaceable> ]
    [ , DESERIALFUNC = <replaceable class="parameter">deserialfunc</replaceable> ]
    [ , INITCOND = <replaceable class="parameter">initial_condition</replaceable> ]
    [ , MSFUNC = <replaceable class="parameter">msfunc</replaceable> ]
    [ , MINVFUNC = <replaceable class="parameter">minvfunc</replaceable> ]
    [ , MSTYPE = <replaceable class="parameter">mstate_data_type</replaceable> ]
    [ , MSSPACE = <replaceable class="parameter">mstate_data_size</replaceable> ]
    [ , MFINALFUNC = <replaceable class="parameter">mffunc</replaceable> ]
    [ , MFINALFUNC_EXTRA ]
    [ , MFINALFUNC_MODIFY = { READ_ONLY | SHAREABLE | READ_WRITE } ]
    [ , MINITCOND = <replaceable class="parameter">minitial_condition</replaceable> ]
    [ , SORTOP = <replaceable class="parameter">sort_operator</replaceable> ]
)
</synopsis>
____________________________________________________________________________-->
<synopsis>
CREATE [ OR REPLACE ] AGGREGATE <replaceable class="parameter">name</replaceable> ( [ <replaceable class="parameter">argmode</replaceable> ] [ <replaceable class="parameter">argname</replaceable> ] <replaceable class="parameter">arg_data_type</replaceable> [ , ... ] ) (
    SFUNC = <replaceable class="parameter">sfunc</replaceable>,
    STYPE = <replaceable class="parameter">state_data_type</replaceable>
    [ , SSPACE = <replaceable class="parameter">state_data_size</replaceable> ]
    [ , FINALFUNC = <replaceable class="parameter">ffunc</replaceable> ]
    [ , FINALFUNC_EXTRA ]
    [ , FINALFUNC_MODIFY = { READ_ONLY | SHAREABLE | READ_WRITE } ]
    [ , COMBINEFUNC = <replaceable class="parameter">combinefunc</replaceable> ]
    [ , SERIALFUNC = <replaceable class="parameter">serialfunc</replaceable> ]
    [ , DESERIALFUNC = <replaceable class="parameter">deserialfunc</replaceable> ]
    [ , INITCOND = <replaceable class="parameter">initial_condition</replaceable> ]
    [ , MSFUNC = <replaceable class="parameter">msfunc</replaceable> ]
    [ , MINVFUNC = <replaceable class="parameter">minvfunc</replaceable> ]
    [ , MSTYPE = <replaceable class="parameter">mstate_data_type</replaceable> ]
    [ , MSSPACE = <replaceable class="parameter">mstate_data_size</replaceable> ]
    [ , MFINALFUNC = <replaceable class="parameter">mffunc</replaceable> ]
    [ , MFINALFUNC_EXTRA ]
    [ , MINITCOND = <replaceable class="parameter">minitial_condition</replaceable> ]
    [ , SORTOP = <replaceable class="parameter">sort_operator</replaceable> ]
    [ , PARALLEL = { SAFE | RESTRICTED | UNSAFE } ]
)

CREATE [ OR REPLACE ] AGGREGATE <replaceable class="parameter">name</replaceable> ( [ [ <replaceable class="parameter">argmode</replaceable> ] [ <replaceable class="parameter">argname</replaceable> ] <replaceable class="parameter">arg_data_type</replaceable> [ , ... ] ]
                        ORDER BY [ <replaceable class="parameter">argmode</replaceable> ] [ <replaceable class="parameter">argname</replaceable> ] <replaceable class="parameter">arg_data_type</replaceable> [ , ... ] ) (
    SFUNC = <replaceable class="parameter">sfunc</replaceable>,
    STYPE = <replaceable class="parameter">state_data_type</replaceable>
    [ , SSPACE = <replaceable class="parameter">state_data_size</replaceable> ]
    [ , FINALFUNC = <replaceable class="parameter">ffunc</replaceable> ]
    [ , FINALFUNC_EXTRA ]
    [ , FINALFUNC_MODIFY = { READ_ONLY | SHAREABLE | READ_WRITE } ]
    [ , INITCOND = <replaceable class="parameter">initial_condition</replaceable> ]
    [ , HYPOTHETICAL ]
    [ , PARALLEL = { SAFE | RESTRICTED | UNSAFE } ]
)

<phrase>或者旧的语法</phrase>

CREATE [ OR REPLACE ] AGGREGATE <replaceable class="parameter">name</replaceable> (
    BASETYPE = <replaceable class="parameter">base_type</replaceable>,
    SFUNC = <replaceable class="parameter">sfunc</replaceable>,
    STYPE = <replaceable class="parameter">state_data_type</replaceable>
    [ , SSPACE = <replaceable class="parameter">state_data_size</replaceable> ]
    [ , FINALFUNC = <replaceable class="parameter">ffunc</replaceable> ]
    [ , FINALFUNC_EXTRA ]
    [ , FINALFUNC_MODIFY = { READ_ONLY | SHAREABLE | READ_WRITE } ]
    [ , COMBINEFUNC = <replaceable class="parameter">combinefunc</replaceable> ]
    [ , SERIALFUNC = <replaceable class="parameter">serialfunc</replaceable> ]
    [ , DESERIALFUNC = <replaceable class="parameter">deserialfunc</replaceable> ]
    [ , INITCOND = <replaceable class="parameter">initial_condition</replaceable> ]
    [ , MSFUNC = <replaceable class="parameter">msfunc</replaceable> ]
    [ , MINVFUNC = <replaceable class="parameter">minvfunc</replaceable> ]
    [ , MSTYPE = <replaceable class="parameter">mstate_data_type</replaceable> ]
    [ , MSSPACE = <replaceable class="parameter">mstate_data_size</replaceable> ]
    [ , MFINALFUNC = <replaceable class="parameter">mffunc</replaceable> ]
    [ , MFINALFUNC_EXTRA ]
    [ , MFINALFUNC_MODIFY = { READ_ONLY | SHAREABLE | READ_WRITE } ]
    [ , MINITCOND = <replaceable class="parameter">minitial_condition</replaceable> ]
    [ , SORTOP = <replaceable class="parameter">sort_operator</replaceable> ]
)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <command>CREATE AGGREGATE</command> defines a new aggregate function.
   <command>CREATE OR REPLACE AGGREGATE</command> will either define a new
   aggregate function or replace an existing definition. Some basic and
   commonly-used aggregate functions are included with the distribution; they
   are documented in <xref linkend="functions-aggregate"/>. If one defines new
   types or needs an aggregate function not already provided, then
   <command>CREATE AGGREGATE</command> can be used to provide the desired
   features.
  </para>
____________________________________________________________________________-->
  <para>
   <command>CREATE AGGREGATE</command>定义一个新的聚集函数。<command>CREATE OR REPLACE AGGREGATE</command>将定义新的聚合函数或替换现有定义。
   在发布中已经包括了一些基本的和常用的聚集函数；它们的文档请见<xref linkend="functions-aggregate"/>。
   如果要定义一个新类型或者需要一个还没有被提供的聚集函数，那么<command>CREATE AGGREGATE</command>就可以被用来提供想要的特性。
  </para>

<!--==========================orignal english content==========================
  <para>
   When replacing an existing definition, the argument types, result type,
   and number of direct arguments may not be changed. Also, the new definition
   must be of the same kind (ordinary aggregate, ordered-set aggregate, or
   hypothetical-set aggregate) as the old one.
  </para>
____________________________________________________________________________-->
  <para>
   在替换现有定义时，参数类型、结果类型和直接参数的数量可能不会更改。
   此外，新定义的类型（普通聚合、有序集聚合或假设集聚合）必须与旧定义相同。
  </para>

<!--==========================orignal english content==========================
  <para>
   If a schema name is given (for example, <literal>CREATE AGGREGATE
   myschema.myagg ...</literal>) then the aggregate function is created in the
   specified schema.  Otherwise it is created in the current schema.
  </para>
____________________________________________________________________________-->
  <para>
   如果给定了一个模式名（例如<literal>CREATE AGGREGATE
   myschema.myagg ...</literal>），那么该聚集会被创建在指定的模式中。否则它
   会被创建在当前模式中。
  </para>

<!--==========================orignal english content==========================
  <para>
   An aggregate function is identified by its name and input data type(s).
   Two aggregates in the same schema can have the same name if they operate on
   different input types.  The
   name and input data type(s) of an aggregate must also be distinct from
   the name and input data type(s) of every ordinary function in the same
   schema.
   This behavior is identical to overloading of ordinary function names
   (see <xref linkend="sql-createfunction"/>).
  </para>
____________________________________________________________________________-->
  <para>
   一个聚集函数需要用它的名称和输入数据类型标识。同一个模式中的两个聚集
   可以具有相同的名称，只要它们在不同的输入类型上操作即可。一个聚集的名称
   和输入数据类型必须与同一模式中的每一个普通函数区分开。这种行为与普通函
   数名的重载完全一样（见<xref linkend="sql-createfunction"/>）。
  </para>

<!--==========================orignal english content==========================
  <para>
   A simple aggregate function is made from one or two ordinary
   functions:
   a state transition function
   <replaceable class="parameter">sfunc</replaceable>,
   and an optional final calculation function
   <replaceable class="parameter">ffunc</replaceable>.
   These are used as follows:
<programlisting>
<replaceable class="parameter">sfunc</replaceable>( internal-state, next-data-values ) -&minus;-> next-internal-state
<replaceable class="parameter">ffunc</replaceable>( internal-state ) -&minus;-> aggregate-value
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   一个简单的聚集函数由一个或者多个普通函数组成：
   一个状态转移函数
   <replaceable class="parameter">sfunc</replaceable>和一个可选的最终
   计算函数
   <replaceable class="parameter">ffunc</replaceable>。
   它们被这样使用：
<programlisting>
<replaceable class="parameter">sfunc</replaceable>( internal-state, next-data-values ) ---> next-internal-state
<replaceable class="parameter">ffunc</replaceable>( internal-state ) ---> aggregate-value
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname> creates a temporary variable
   of data type <replaceable class="parameter">stype</replaceable>
   to hold the current internal state of the aggregate.  At each input row,
   the aggregate argument value(s) are calculated and
   the state transition function is invoked with the current state value
   and the new argument value(s) to calculate a new
   internal state value.  After all the rows have been processed,
   the final function is invoked once to calculate the aggregate's return
   value.  If there is no final function then the ending state value
   is returned as-is.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>创建一个数据类型
   <replaceable class="parameter">stype</replaceable>的临时变量来
   保持聚集的当前内部状态。对每一个输入行，聚集参数值会被计算并且状态
   转移函数会被调用，它用当前状态值和新参数值计算一个新的内部状态值。
   等所有行都被处理完后，最终函数会被调用一次来计算该聚集的返回值。如果
   没有最终函数，则最终的状态值会被返回。
  </para>

<!--==========================orignal english content==========================
  <para>
   An aggregate function can provide an initial condition,
   that is, an initial value for the internal state value.
   This is specified and stored in the database as a value of type
   <type>text</type>, but it must be a valid external representation
   of a constant of the state value data type.  If it is not supplied
   then the state value starts out null.
  </para>
____________________________________________________________________________-->
  <para>
   一个聚集函数可以提供一个初始条件，即一个用于内部状态值的初始值。它被
   作为一个类型<type>text</type>的值指定并且存储在数据库中，但是它必须
   是状态值数据类型的一个常量的合法外部表示。如果没有提供，则状态值从空值
   开始。
  </para>

<!--==========================orignal english content==========================
  <para>
   If the state transition function is declared <quote>strict</quote>,
   then it cannot be called with null inputs.  With such a transition
   function, aggregate execution behaves as follows.  Rows with any null input
   values are ignored (the function is not called and the previous state value
   is retained).  If the initial state value is null, then at the first row
   with all-nonnull input values, the first argument value replaces the state
   value, and the transition function is invoked at each subsequent row with
   all-nonnull input values.
   This is handy for implementing aggregates like <function>max</function>.
   Note that this behavior is only available when
   <replaceable class="parameter">state_data_type</replaceable>
   is the same as the first
   <replaceable class="parameter">arg_data_type</replaceable>.
   When these types are different, you must supply a nonnull initial
   condition or use a nonstrict transition function.
  </para>
____________________________________________________________________________-->
  <para>
   如果状态转移函数被声明为<quote>strict</quote>，那么不能用空值输入来
   调用它。如果有这种转移函数，聚集将按照下面的行为执行。带有任何空值的
   行会被忽略（函数不被调用并且之前的状态值被保持）。如果初始状态值就是
   空值，那么碰到第一个没有空值的行时，状态值会被替换成第一个参数值，并且
   对于每一个后续的没有空值的行都会调用该转移函数。这对实现
   <function>max</function>这样的聚集很方便。注意只有当
   <replaceable class="parameter">state_data_type</replaceable>
   和第一个
   <replaceable class="parameter">arg_data_type</replaceable>相同时，
   这种行为才可用。当这些类型不同时，你必须提供一个非空初始条件或者使用
   一个非严格转移函数。
  </para>

<!--==========================orignal english content==========================
  <para>
   If the state transition function is not strict, then it will be called
   unconditionally at each input row, and must deal with null inputs
   and null state values for itself.  This allows the aggregate
   author to have full control over the aggregate's handling of null values.
  </para>
____________________________________________________________________________-->
  <para>
   如果状态转移函数不是严格的，那么在碰到每个输入行时都将会调用它，并且
   它必须自行处理空值输入和空状态值。这允许聚集的作者完全控制该聚集如何
   处理空值。
  </para>

<!--==========================orignal english content==========================
  <para>
   If the final function is declared <quote>strict</quote>, then it will not
   be called when the ending state value is null; instead a null result
   will be returned automatically.  (Of course this is just the normal
   behavior of strict functions.)  In any case the final function has
   the option of returning a null value.  For example, the final function for
   <function>avg</function> returns null when it sees there were zero
   input rows.
  </para>
____________________________________________________________________________-->
  <para>
   如果最终函数被声明为<quote>strict</quote>，那么当最终状态值为空时将
   不会调用它，而是自动地返回一个空结果（当然，这只是严格函数的普通行为）。
   在任何情况下最终函数都可以返回一个空值。例如，<function>avg</function>的最终函数会在看到零个
   输入行时返回空。
  </para>

<!--==========================orignal english content==========================
  <para>
   Sometimes it is useful to declare the final function as taking not just
   the state value, but extra parameters corresponding to the aggregate's
   input values.  The main reason for doing this is if the final function
   is polymorphic and the state value's data type would be inadequate to
   pin down the result type.  These extra parameters are always passed as
   NULL (and so the final function must not be strict when
   the <literal>FINALFUNC_EXTRA</literal> option is used), but nonetheless they
   are valid parameters.  The final function could for example make use
   of <function>get_fn_expr_argtype</function> to identify the actual argument type
   in the current call.
  </para>
____________________________________________________________________________-->
  <para>
   有时候把最终函数声明成不仅采用状态值还采用对应于聚集输入值的额外参数
   是有用的。这样做的主要原因是，如果最终函数是多态的，那么状态值的数据
   类型将不适合于用来确定结果类型。这些额外的参数总是以 NULL 形式传递
   （因此使用<literal>FINALFUNC_EXTRA</literal>选项时，最终函数不能是严格的），
   但尽管如此它们都是合法参数。例如，最终函数可以利用
   <function>get_fn_expr_argtype</function>来标识当前调用中的实际参数类型。
  </para>

<!--==========================orignal english content==========================
  <para>
   An aggregate can optionally support <firstterm>moving-aggregate mode</firstterm>,
   as described in <xref linkend="xaggr-moving-aggregates"/>.  This requires
   specifying the <literal>MSFUNC</literal>, <literal>MINVFUNC</literal>,
   and <literal>MSTYPE</literal> parameters, and optionally
   the <literal>MSSPACE</literal>, <literal>MFINALFUNC</literal>,
   <literal>MFINALFUNC_EXTRA</literal>, <literal>MFINALFUNC_MODIFY</literal>,
   and <literal>MINITCOND</literal> parameters.  Except for <literal>MINVFUNC</literal>,
   these parameters work like the corresponding simple-aggregate parameters
   without <literal>M</literal>; they define a separate implementation of the
   aggregate that includes an inverse transition function.
  </para>
____________________________________________________________________________-->
  <para>
   如<xref linkend="xaggr-moving-aggregates"/>中所述，一个聚集可以
   选择支持<firstterm>moving-aggregate mode</firstterm>。这要求指定
   <literal>MSFUNC</literal>、<literal>MINVFUNC</literal>以及
   <literal>MSTYPE</literal>参数，并且参数<literal>MSSPACE</literal>、
   <literal>MFINALFUNC</literal>、<literal>MFINALFUNC_EXTRA</literal>
   和<literal>MINITCOND</literal>是可选的。除了<literal>MINVFUNC</literal>，
   这些参数的工作都和对应的不带<literal>M</literal>的简单聚集参数相似，它们
   定义了包括一个逆向转移函数的聚集的一种独立实现。
  </para>

<!--==========================orignal english content==========================
  <para>
   The syntax with <literal>ORDER BY</literal> in the parameter list creates
   a special type of aggregate called an <firstterm>ordered-set
   aggregate</firstterm>; or if <literal>HYPOTHETICAL</literal> is specified, then
   a <firstterm>hypothetical-set aggregate</firstterm> is created.  These
   aggregates operate over groups of sorted values in order-dependent ways,
   so that specification of an input sort order is an essential part of a
   call.  Also, they can have <firstterm>direct</firstterm> arguments, which are
   arguments that are evaluated only once per aggregation rather than once
   per input row.  Hypothetical-set aggregates are a subclass of ordered-set
   aggregates in which some of the direct arguments are required to match,
   in number and data types, the aggregated argument columns.  This allows
   the values of those direct arguments to be added to the collection of
   aggregate-input rows as an additional <quote>hypothetical</quote> row.
  </para>
____________________________________________________________________________-->
  <para>
   在参数列表中带有<literal>ORDER BY</literal>的语法会创建一种被称为
   <firstterm>有序集聚集</firstterm>的特殊聚集类型。如果指定了
   <literal>HYPOTHETICAL</literal>，则会创建一个
   <firstterm>假想集聚集</firstterm>。这些聚集以依赖排序的方法在排好序
   的值上操作，因此指定一个输入排序顺序是调用过程的重要一环。还有，它们
   可以有<firstterm>直接</firstterm>参数，这类参数只对每次聚集计算一次，而不是对
   每一个输入行计算一次。假想集聚集是有序集聚集的一个子类，其中一些直接
   参数要求在数量和类型上都匹配被聚集的参数列。这允许这些直接参数的值被
   当做一个附加的<quote>假想</quote>行被加入到聚集输入行的集合中。
  </para>
  
<!--==========================orignal english content==========================
  <para>
   An aggregate can optionally support <firstterm>partial aggregation</firstterm>,
   as described in <xref linkend="xaggr-partial-aggregates"/>.
   This requires specifying the <literal>COMBINEFUNC</literal> parameter.
   If the <replaceable class="parameter">state_data_type</replaceable>
   is <type>internal</type>, it's usually also appropriate to provide the
   <literal>SERIALFUNC</literal> and <literal>DESERIALFUNC</literal> parameters so that
   parallel aggregation is possible.  Note that the aggregate must also be
   marked <literal>PARALLEL SAFE</literal> to enable parallel aggregation.
  </para>
____________________________________________________________________________-->
  <para>
   如<xref linkend="xaggr-partial-aggregates"/>中所示，一个聚集可以支持
   <firstterm>部分聚集</firstterm>。这要求指定<literal>COMBINEFUNC</literal>参数。
   如果<replaceable class="parameter">state_data_type</replaceable>
   为<type>internal</type>，通常也可以提供<literal>SERIALFUNC</literal>和
   <literal>DESERIALFUNC</literal>参数，这样可以让并行聚集成为可能。注意，
   该聚集还必须被标记为<literal>PARALLEL SAFE</literal>以启用并行聚集。
  </para>

<!--==========================orignal english content==========================
  <para>
   Aggregates that behave like <function>MIN</function> or <function>MAX</function> can
   sometimes be optimized by looking into an index instead of scanning every
   input row.  If this aggregate can be so optimized, indicate it by
   specifying a <firstterm>sort operator</firstterm>.  The basic requirement is that
   the aggregate must yield the first element in the sort ordering induced by
   the operator; in other words:
<programlisting>
SELECT agg(col) FROM tab;
</programlisting>
   must be equivalent to:
<programlisting>
SELECT col FROM tab ORDER BY col USING sortop LIMIT 1;
</programlisting>
   Further assumptions are that the aggregate ignores null inputs, and that
   it delivers a null result if and only if there were no non-null inputs.
   Ordinarily, a data type's <literal>&lt;</literal> operator is the proper sort
   operator for <function>MIN</function>, and <literal>&gt;</literal> is the proper sort
   operator for <function>MAX</function>.  Note that the optimization will never
   actually take effect unless the specified operator is the <quote>less
   than</quote> or <quote>greater than</quote> strategy member of a B-tree
   index operator class.
  </para>
____________________________________________________________________________-->
  <para>
   行为与<function>MIN</function>或<function>MAX</function>相似的聚集有时可以通过
   直接查看一个索引而不是扫描每一个输入行来优化。如果这个聚集可以被这样
   优化，请通过指定一个<firstterm>排序操作符</firstterm>来指出。基本要求是，该
   聚集必须得出由该操作符产生的排序顺序中的第一个元素，换句话说：
<programlisting>
SELECT agg(col) FROM tab;
</programlisting>
   必须等价于：
<programlisting>
SELECT col FROM tab ORDER BY col USING sortop LIMIT 1;
</programlisting>
   进一步的假定是该聚集忽略空输入，并且当且仅当没有非空输入时它才会返回
   一个空结果。通常，一种数据类型的<literal>&lt;</literal>操作符是
   <function>MIN</function>的合适的排序操作符，而<literal>&gt;</literal>是
   <function>MAX</function>的合适的排序操作符。注意，除非指定的操作符是一个
   B-树索引操作符类的<quote>小于</quote>或者<quote>大于</quote>
   策略成员，优化将永远不会产生实际效果。
  </para>

<!--==========================orignal english content==========================
  <para>
   To be able to create an aggregate function, you must
   have <literal>USAGE</literal> privilege on the argument types, the state
   type(s), and the return type, as well as <literal>EXECUTE</literal>
   privilege on the supporting functions.
  </para>
____________________________________________________________________________-->
  <para>
   要能够创建一个聚集函数，你必须具有参数类型、状态类型和返回类型上的
   <literal>USAGE</literal>特权，还有在支持函数上的
   <literal>EXECUTE</literal>特权。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Parameters</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">name</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">name</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The name (optionally schema-qualified) of the aggregate function
      to create.
     </para>
____________________________________________________________________________-->
     <para>
      要创建的聚集函数的名称（可以是模式限定的）。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">argmode</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">argmode</replaceable></term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      The mode of an argument: <literal>IN</literal> or <literal>VARIADIC</literal>.
      (Aggregate functions do not support <literal>OUT</literal> arguments.)
      If omitted, the default is <literal>IN</literal>.  Only the last argument
      can be marked <literal>VARIADIC</literal>.
     </para>
____________________________________________________________________________-->
     <para>
      一个参数的模式：<literal>IN</literal>或者<literal>VARIADIC</literal>（聚集函数
      不支持<literal>OUT</literal>参数）。如果忽略，默认值是<literal>IN</literal>。
      只有最后一个参数能被标记为<literal>VARIADIC</literal>。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">argname</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">argname</replaceable></term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      The name of an argument.  This is currently only useful for
      documentation purposes.  If omitted, the argument has no name.
     </para>
____________________________________________________________________________-->
     <para>
      一个参数的名称。当前这只用于文档的目的。如果被忽略，该参数就没有名称。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">arg_data_type</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">arg_data_type</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      An input data type on which this aggregate function operates.
      To create a zero-argument aggregate function, write <literal>*</literal>
      in place of the list of argument specifications.  (An example of such an
      aggregate is <function>count(*)</function>.)
     </para>
____________________________________________________________________________-->
     <para>
      这个聚集函数操作的一个输入数据类型。要创建一个零参数的聚集函数，可以
      写一个<literal>*</literal>来替代参数说明的列表（这类聚集的一个例子是
      <function>count(*)</function>）。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">base_type</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">base_type</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      In the old syntax for <command>CREATE AGGREGATE</command>, the input data type
      is specified by a <literal>basetype</literal> parameter rather than being
      written next to the aggregate name.  Note that this syntax allows
      only one input parameter.  To define a zero-argument aggregate function
      with this syntax, specify the <literal>basetype</literal> as
      <literal>"ANY"</literal> (not <literal>*</literal>).
      Ordered-set aggregates cannot be defined with the old syntax.
     </para>
____________________________________________________________________________-->
     <para>
      在<command>CREATE AGGREGATE</command>的旧语法中，输入数据类型是由
      一个<literal>basetype</literal>参数指定而不是写在聚集名之后。注意这种语法
      只允许一个输入参数。要用这种语法定义一个零参数的聚集函数，把
      <literal>basetype</literal>指定为<literal>"ANY"</literal>（不是<literal>*</literal>）。
      有序集聚集不能用旧语法定义。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">sfunc</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">sfunc</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The name of the state transition function to be called for each
      input row.  For a normal <replaceable class="parameter">N</replaceable>-argument
      aggregate function, the <replaceable class="parameter">sfunc</replaceable>
      must take <replaceable class="parameter">N</replaceable>+1 arguments,
      the first being of type <replaceable
      class="parameter">state_data_type</replaceable> and the rest
      matching the declared input data type(s) of the aggregate.
      The function must return a value of type <replaceable
      class="parameter">state_data_type</replaceable>.  This function
      takes the current state value and the current input data value(s),
      and returns the next state value.
     </para>
____________________________________________________________________________-->
     <para>
      要为每一个输入行调用的状态转移函数名。对于一个正常的
      <replaceable class="parameter">N</replaceable>-参数的聚集函数，
      <replaceable class="parameter">sfunc</replaceable>必须接收
      <replaceable class="parameter">N</replaceable>+1 个参数，
      第一个参数的类型是<replaceable 
      class="parameter">state_data_type</replaceable>而其余的参数匹配
      该聚集被声明的输入数据类型。该函数必须返回一个类型为
      <replaceable class="parameter">state_data_type</replaceable>
      的值。这个函数会采用当前的状态值以及当前的输入数据值，并且返回下一个
      状态值。
     </para>

<!--==========================orignal english content==========================
     <para>
      For ordered-set (including hypothetical-set) aggregates, the state
      transition function receives only the current state value and the
      aggregated arguments, not the direct arguments.  Otherwise it is the
      same.
     </para>
____________________________________________________________________________-->
     <para>
      对于有序集（包括假想集）聚集，状态转移函数只接收当前的状态值和聚集参数，
      但无需直接参数。否则它就和其他转移函数一样了。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">state_data_type</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">state_data_type</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The data type for the aggregate's state value.
     </para>
____________________________________________________________________________-->
     <para>
      聚集的状态值的数据类型。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">state_data_size</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">state_data_size</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The approximate average size (in bytes) of the aggregate's state value.
      If this parameter is omitted or is zero, a default estimate is used
      based on the <replaceable>state_data_type</replaceable>.
      The planner uses this value to estimate the memory required for a
      grouped aggregate query.
     </para>
____________________________________________________________________________-->
     <para>
      聚集的状态值的近似平均尺寸（以字节计）。如果这个参数被忽略或者为零，
      将使用一个基于<replaceable>state_data_type</replaceable>的默认估计值。规划器
      使用这个值来估计一个分组聚集查询所需的内存。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">ffunc</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">ffunc</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The name of the final function called to compute the aggregate's
      result after all input rows have been traversed.
      For a normal aggregate, this function
      must take a single argument of type <replaceable
      class="parameter">state_data_type</replaceable>.  The return
      data type of the aggregate is defined as the return type of this
      function.  If <replaceable class="parameter">ffunc</replaceable>
      is not specified, then the ending state value is used as the
      aggregate's result, and the return type is <replaceable
      class="parameter">state_data_type</replaceable>.
     </para>
____________________________________________________________________________-->
     <para>
      最终函数的名称，该函数在所有输入行都被遍历之后被调用来计算聚集的结果。
      对于一个常规聚集，这个函数必须只接受一个类型为<replaceable
      class="parameter">state_data_type</replaceable>的单一参数。该聚集
      的返回数据类型被定义为这个函数的返回类型。如果没有指定
      <replaceable class="parameter">ffunc</replaceable>，则结束状态值
      被用作聚集的结果，并且返回类型为<replaceable
      class="parameter">state_data_type</replaceable>。
     </para>

<!--==========================orignal english content==========================
     <para>
      For ordered-set (including hypothetical-set) aggregates, the
      final function receives not only the final state value,
      but also the values of all the direct arguments.
     </para>
____________________________________________________________________________-->
     <para>
      对于有序集（包括假想集）聚集，最终函数不仅接收最终状态值，还会接收所
      有直接参数的值。
     </para>

<!--==========================orignal english content==========================
     <para>
      If <literal>FINALFUNC_EXTRA</literal> is specified, then in addition to the
      final state value and any direct arguments, the final function
      receives extra NULL values corresponding to the aggregate's regular
      (aggregated) arguments.  This is mainly useful to allow correct
      resolution of the aggregate result type when a polymorphic aggregate
      is being defined.
     </para>
____________________________________________________________________________-->
     <para>
      如果指定了<literal>FINALFUNC_EXTRA</literal>，则除了最终状态值和任何直接
      参数之外，最终函数还接收额外的对应于该聚集的常规（聚集）参数的 NULL 值。
      这主要用于在定义了一个多态聚集时允许正确地决定聚集的结果类型。
     </para>
     </listitem>
     </varlistentry>

      <varlistentry>
<!--==========================orignal english content==========================
      <term><literal>FINALFUNC_MODIFY</literal> = { <literal>READ_ONLY</literal> | <literal>SHAREABLE</literal> | <literal>READ_WRITE</literal> }</term>
____________________________________________________________________________-->
      <term><literal>FINALFUNC_MODIFY</literal> = { <literal>READ_ONLY</literal> | <literal>SHAREABLE</literal> | <literal>READ_WRITE</literal> }</term>
      <listitem>
<!--==========================orignal english content==========================
      <para>
      This option specifies whether the final function is a pure function
      that does not modify its arguments.  <literal>READ_ONLY</literal> indicates
      it does not; the other two values indicate that it may change the
      transition state value.  See <xref linkend="sql-createaggregate-notes"/>
      below for more detail.  The
      default is <literal>READ_ONLY</literal>, except for ordered-set aggregates,
      for which the default is <literal>READ_WRITE</literal>.
     </para>
____________________________________________________________________________-->
      <para>
      此选项指定最终函数是否为不会修改参数的纯函数。<literal>READ_ONLY</literal>表示它不会修改；其他两个值表示它可能会更改迁移状态值。请参见<xref linkend="sql-createaggregate-notes"/> 以获取更多详细信息。除了有序集合的聚合使用默认值<literal>READ_WRITE</literal>，其他默认值均为<literal>READ_ONLY</literal>。
      </para>
      </listitem>
      </varlistentry> 
   <varlistentry>

<!--==========================orignal english content==========================
    <term><replaceable class="parameter">combinefunc</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">combinefunc</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The <replaceable class="parameter">combinefunc</replaceable> function
      may optionally be specified to allow the aggregate function to support
      partial aggregation.  If provided,
      the <replaceable class="parameter">combinefunc</replaceable> must
      combine two <replaceable class="parameter">state_data_type</replaceable>
      values, each containing the result of aggregation over some subset of
      the input values, to produce a
      new <replaceable class="parameter">state_data_type</replaceable> that
      represents the result of aggregating over both sets of inputs.  This
      function can be thought of as
      an <replaceable class="parameter">sfunc</replaceable>, where instead of
      acting upon an individual input row and adding it to the running
      aggregate state, it adds another aggregate state to the running state.
     </para>
____________________________________________________________________________-->
     <para>
      <replaceable class="parameter">combinefunc</replaceable>函数可以被
      有选择地指定以允许聚集函数支持部分聚集。如果提供这个函数，
      <replaceable class="parameter">combinefunc</replaceable>必须组合两个
      <replaceable class="parameter">state_data_type</replaceable>值，每一个
      都包含在输入值某个子集上的聚集结果，它会产生一个新的
      <replaceable class="parameter">state_data_type</replaceable>来表示在
      两个输入集上的聚集结果。这个函数可以被看做是一个
      <replaceable class="parameter">sfunc</replaceable>，和后者在一个个体
      输入行上操作并且把它加到运行聚集状态上不同，这个函数是把另一个聚集状态加
      到运行状态上。
     </para>

<!--==========================orignal english content==========================
     <para>
      The <replaceable class="parameter">combinefunc</replaceable> must be
      declared as taking two arguments of
      the <replaceable class="parameter">state_data_type</replaceable> and
      returning a value of
      the <replaceable class="parameter">state_data_type</replaceable>.
      Optionally this function may be <quote>strict</quote>. In this case the
      function will not be called when either of the input states are null;
      the other state will be taken as the correct result.
     </para>
____________________________________________________________________________-->
     <para>
      <replaceable class="parameter">combinefunc</replaceable>必须被声明为
      有两个<replaceable class="parameter">state_data_type</replaceable>参数
      并且返回一个<replaceable class="parameter">state_data_type</replaceable>
      值。这个函数可以有选择性地被标记为<quote>strict</quote>。在被标记的情况下，
      当任何一个输入状态为空时，将不会调用该函数，而是把另一个状态当作正确的结果。
     </para>

<!--==========================orignal english content==========================
     <para>
      For aggregate functions
      whose <replaceable class="parameter">state_data_type</replaceable>
      is <type>internal</type>,
      the <replaceable class="parameter">combinefunc</replaceable> must not
      be strict. In this case
      the <replaceable class="parameter">combinefunc</replaceable> must
      ensure that null states are handled correctly and that the state being
      returned is properly stored in the aggregate memory context.
     </para>
____________________________________________________________________________-->
     <para>
      对于<replaceable class="parameter">state_data_type</replaceable>为
      <type>internal</type>的聚集函数，
      <replaceable class="parameter">combinefunc</replaceable>不能为
      strict。这种情况下，
      <replaceable class="parameter">combinefunc</replaceable>必须确保
      正确地处理空状态并且被返回的状态能被恰当地存储在聚集内存上下文中。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">serialfunc</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">serialfunc</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      An aggregate function
      whose <replaceable class="parameter">state_data_type</replaceable>
      is <type>internal</type> can participate in parallel aggregation only if it
      has a <replaceable class="parameter">serialfunc</replaceable> function,
      which must serialize the aggregate state into a <type>bytea</type> value for
      transmission to another process.  This function must take a single
      argument of type <type>internal</type> and return type <type>bytea</type>.  A
      corresponding <replaceable class="parameter">deserialfunc</replaceable>
      is also required.
     </para>
____________________________________________________________________________-->
     <para>
      <replaceable class="parameter">state_data_type</replaceable>为
      <type>internal</type>的一个聚集函数可以参与到并行聚集中，当且仅当它具有一个
      <replaceable class="parameter">serialfunc</replaceable>函数，该函数
      必须把聚集状态序列化成一个<type>bytea</type>值以传送给另一个进程。这个函数
      必须有一个单一的<type>internal</type>类型参数并且返回类型<type>bytea</type>。
      相应地也需要一个<replaceable class="parameter">deserialfunc</replaceable>。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">deserialfunc</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">deserialfunc</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Deserialize a previously serialized aggregate state back into
      <replaceable class="parameter">state_data_type</replaceable>. This
      function must take two arguments of types <type>bytea</type>
      and <type>internal</type>, and produce a result of type <type>internal</type>.
      (Note: the second, <type>internal</type> argument is unused, but is required
      for type safety reasons.)
     </para>
____________________________________________________________________________-->
     <para>
      把一个之前序列化后的聚集状态反序列化为
      <replaceable class="parameter">state_data_type</replaceable>。这个函数
      必须有两个类型分别为<type>bytea</type>和<type>internal</type>的参数，并且产生
      一个类型<type>internal</type>的结果（注意：第二个类型为<type>internal</type>的
      参数是无用的，但是为了类型安全的原因还是要求有该参数）。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">initial_condition</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">initial_condition</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The initial setting for the state value.  This must be a string
      constant in the form accepted for the data type <replaceable
      class="parameter">state_data_type</replaceable>.  If not
      specified, the state value starts out null.
     </para>
____________________________________________________________________________-->
     <para>
      状态值的初始设置。这必须是以数据类型<replaceable
      class="parameter">state_data_type</replaceable>能够接受的形式出现
      的一个字符串常量。如果没有指定，状态值会从空值开始。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">msfunc</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">msfunc</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The name of the forward state transition function to be called for each
      input row in moving-aggregate mode.  This is exactly like the regular
      transition function, except that its first argument and result are of
      type <replaceable>mstate_data_type</replaceable>, which might be different
      from <replaceable>state_data_type</replaceable>.
     </para>
____________________________________________________________________________-->
     <para>
      前向状态转移函数的名称，在移动聚集模式中会为每个输入行调用这个函数。它
      非常像常规的转移函数，不过它的第一个参数和结果类型是
      <replaceable>mstate_data_type</replaceable>，这可能与
      <replaceable>state_data_type</replaceable>不同。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">minvfunc</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">minvfunc</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The name of the inverse state transition function to be used in
      moving-aggregate mode.  This function has the same argument and
      result types as <replaceable>msfunc</replaceable>, but it is used to remove
      a value from the current aggregate state, rather than add a value to
      it.  The inverse transition function must have the same strictness
      attribute as the forward state transition function.
     </para>
____________________________________________________________________________-->
     <para>
      在移动聚集模式中用到的逆向状态转移函数的名称。这个函数与
      <replaceable>msfunc</replaceable>具有相同的参数和结果类型，但是它被用于从当前聚集
      状态中移除一个值，而不是向其中增加一个值。逆向转移函数必须具有和前向状态
      转移函数相同的严格性属性。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">mstate_data_type</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">mstate_data_type</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The data type for the aggregate's state value, when using
      moving-aggregate mode.
     </para>
____________________________________________________________________________-->
     <para>
      使用移动聚集模式时，用于聚集状态值的数据类型。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">mstate_data_size</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">mstate_data_size</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The approximate average size (in bytes) of the aggregate's state
      value, when using moving-aggregate mode.  This works the same as
      <replaceable>state_data_size</replaceable>.
     </para>
____________________________________________________________________________-->
     <para>
      使用移动聚集模式时，聚集状态值的近似平均尺寸（以字节计）。它的作用和
      <replaceable>state_data_size</replaceable>相同。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">mffunc</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">mffunc</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The name of the final function called to compute the aggregate's
      result after all input rows have been traversed, when using
      moving-aggregate mode.  This works the same as <replaceable>ffunc</replaceable>,
      except that its first argument's type
      is <replaceable>mstate_data_type</replaceable> and extra dummy arguments are
      specified by writing <literal>MFINALFUNC_EXTRA</literal>.
      The aggregate result type determined by <replaceable>mffunc</replaceable>
      or <replaceable>mstate_data_type</replaceable> must match that determined by the
      aggregate's regular implementation.
     </para>
____________________________________________________________________________-->
     <para>
      使用移动聚集模式时用到的最终函数名称，当所有输入行都被遍历后会调用它来
      计算聚集的结果。它的工作和<replaceable>ffunc</replaceable>一样，但是它的第一个参
      数类型是<replaceable>mstate_data_type</replaceable>并且额外的空参数要通过书写
      <literal>MFINALFUNC_EXTRA</literal>来指定。<replaceable>mffunc</replaceable>
      或者<replaceable>mstate_data_type</replaceable>决定的聚集结果类型必须匹配由聚集
      的常规实现所确定的类型。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>MFINALFUNC_MODIFY</literal> = { <literal>READ_ONLY</literal> | <literal>SHAREABLE</literal> | <literal>READ_WRITE</literal> }</term>
____________________________________________________________________________-->
    <term><literal>MFINALFUNC_MODIFY</literal> = { <literal>READ_ONLY</literal> | <literal>SHAREABLE</literal> | <literal>READ_WRITE</literal> }</term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      This option is like <literal>FINALFUNC_MODIFY</literal>, but it describes
      the behavior of the moving-aggregate final function.
     </para>
____________________________________________________________________________-->
     <para>
     此选项类似于<literal>FINALFUNC_MODIFY</literal>，只是它描述了移动聚集最终函数的行为。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>


<!--==========================orignal english content==========================
    <term><replaceable class="parameter">minitial_condition</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">minitial_condition</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The initial setting for the state value, when using moving-aggregate
      mode.  This works the same as <replaceable>initial_condition</replaceable>.
     </para>
____________________________________________________________________________-->
     <para>
      使用移动聚集模式时，状态值的初始设置。它的作用和
      <replaceable>initial_condition</replaceable>一样。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">sort_operator</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">sort_operator</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The associated sort operator for a <function>MIN</function>- or
      <function>MAX</function>-like aggregate.
      This is just an operator name (possibly schema-qualified).
      The operator is assumed to have the same input data types as
      the aggregate (which must be a single-argument normal aggregate).
     </para>
____________________________________________________________________________-->
     <para>
      一个<function>MIN</function>- 类或者<function>MAX</function>-类聚集的相关
      排序操作符。这只是一个操作符名称（可能被模式限定）。这个操作符被
      假定为具有和该聚集（必须是一个单一参数的常规聚集）相同的输入数据
      类型。
     </para>
    </listitem>
   </varlistentry>
   
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>PARALLEL =</literal> { <literal>SAFE</literal> | <literal>RESTRICTED</literal> | <literal>UNSAFE</literal> }</term>
____________________________________________________________________________-->
    <term><literal>PARALLEL =</literal> { <literal>SAFE</literal> | <literal>RESTRICTED</literal> | <literal>UNSAFE</literal> }</term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The meanings of <literal>PARALLEL SAFE</literal>, <literal>PARALLEL
      RESTRICTED</literal>, and <literal>PARALLEL UNSAFE</literal> are the same as
      in <link linkend="sql-createfunction"><command>CREATE FUNCTION</command></link>.  An aggregate will not be
      considered for parallelization if it is marked <literal>PARALLEL
      UNSAFE</literal> (which is the default!) or <literal>PARALLEL RESTRICTED</literal>.
      Note that the parallel-safety markings of the aggregate's support
      functions are not consulted by the planner, only the marking of the
      aggregate itself.
     </para>
____________________________________________________________________________-->
     <para>
      <literal>PARALLEL SAFE</literal>、<literal>PARALLEL
      RESTRICTED</literal>和<literal>PARALLEL UNSAFE</literal>的含义和
      <link linkend="sql-createfunction"><command>CREATE FUNCTION</command></link>中的相同。如果一个聚集被标记为
      <literal>PARALLEL UNSAFE</literal>（默认）或者
      <literal>PARALLEL RESTRICTED</literal>，将不会考虑将它并行化。注意
      规划器不会参考聚集的支持函数的并行安全性标记，它只会考虑聚集本身
      的这类标记。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>HYPOTHETICAL</literal></term>
____________________________________________________________________________-->
    <term><literal>HYPOTHETICAL</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      For ordered-set aggregates only, this flag specifies that the aggregate
      arguments are to be processed according to the requirements for
      hypothetical-set aggregates: that is, the last few direct arguments must
      match the data types of the aggregated (<literal>WITHIN GROUP</literal>)
      arguments.  The <literal>HYPOTHETICAL</literal> flag has no effect on
      run-time behavior, only on parse-time resolution of the data types and
      collations of the aggregate's arguments.
     </para>
____________________________________________________________________________-->
     <para>
      只用于有序集聚集，这个标志指定聚集参数会被根据假想集聚集的要求进行处理：
      即后面的直接参数必须匹配聚集（<literal>WITHIN GROUP</literal>）参数的数据
      类型。<literal>HYPOTHETICAL</literal>标志在运行时没有任何效果，它只在
      命令解析期间对确定数据类型和聚集参数的排序规则有用。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

<!--==========================orignal english content==========================
  <para>
   The parameters of <command>CREATE AGGREGATE</command> can be
   written in any order, not just the order illustrated above.
  </para>
____________________________________________________________________________-->
  <para>
   <command>CREATE AGGREGATE</command>的参数可以用任意顺序书写，
   而无需遵照以上说明的顺序。
  </para>
 </refsect1>


 <refsect1 id="sql-createaggregate-notes" xreflabel="Notes">
<!--==========================orignal english content==========================
<title>Notes</title>
____________________________________________________________________________-->
<title>注解</title>
  
<!--==========================orignal english content==========================
   <para>
    In parameters that specify support function names, you can write
    a schema name if needed, for example <literal>SFUNC = public.sum</literal>.
    Do not write argument types there, however &mdash; the argument types
    of the support functions are determined from other parameters.
   </para>
____________________________________________________________________________-->
   <para>
    在指定支持函数名的参数中，如果需要你可以写一个模式名，例如
    <literal>SFUNC = public.sum</literal>。在这里不能写参数类型 &mdash; 支持函数
    的参数类型是根据其他参数决定的。
   </para>
<!--==========================orignal english content==========================
   <para>
    Ordinarily, PostgreSQL functions are expected to be true functions that
    do not modify their input values.  However, an aggregate transition
    function, <emphasis>when used in the context of an aggregate</emphasis>,
    is allowed to cheat and modify its transition-state argument in place.
    This can provide substantial performance benefits compared to making
    a fresh copy of the transition state each time.
   </para>
____________________________________________________________________________-->
   <para>
    通常，PostgreSQL函数是不要修改输入值的真函数。然而，一个聚合迁移函数<emphasis>在聚合上下文中使用时</emphasis>被允许诈欺并修改已在迁移状态的参数。因为与每次创建一个迁移状态的新的拷贝相比，这样可以提供实质的性能提升。
     
   </para>
<!--==========================orignal english content==========================
   <para>
    Likewise, while an aggregate final function is normally expected not to
    modify its input values, sometimes it is impractical to avoid modifying
    the transition-state argument.  Such behavior must be declared using
    the <literal>FINALFUNC_MODIFY</literal> parameter.
    The <literal>READ_WRITE</literal>
    value indicates that the final function modifies the transition state in
    unspecified ways.  This value prevents use of the aggregate as a window
    function, and it also prevents merging of transition states for aggregate
    calls that share the same input values and transition functions.
    The <literal>SHAREABLE</literal> value indicates that the transition function
    cannot be applied after the final function, but multiple final-function
    calls can be performed on the ending transition state value.  This value
    prevents use of the aggregate as a window function, but it allows merging
    of transition states.  (That is, the optimization of interest here is not
    applying the same final function repeatedly, but applying different final
    functions to the same ending transition state value.  This is allowed as
    long as none of the final functions are marked <literal>READ_WRITE</literal>.)
   </para>
____________________________________________________________________________-->
   <para>
    同样，虽然人们一般不期望聚合最终函数修改它的输入值，但有时回避修改迁移态参数是不切实际的。这种行为必须使用<literal>FINALFUNC_MODIFY</literal>参数声明。<literal>READ_WRITE</literal>值表示最终函数以某种未指定的方式修改了迁移状态值。这个值防止将聚合用作窗口函数，并且还可以防止因共用相同的输入值和迁移函数的聚合调用而合并迁移状态。<literal>SHAREABLE</literal>值表示过渡函数不能在最终功能之后使用用，但多重最终函数调用可以对最终的迁移状态值执行调用。这个值阻止将聚合用作窗口函数，但允许合并过渡状态。（也就是说，此处所关注的优化不是重复地使用相同的最终函数，而是把不同的最终函数应用到相同的最终迁移状态值。只要所有最终功能都没有标记为<literal>READ_WRITE</literal>就被允许。）
   </para>
<!--==========================orignal english content==========================
   <para>
    If an aggregate supports moving-aggregate mode, it will improve
    calculation efficiency when the aggregate is used as a window function
    for a window with moving frame start (that is, a frame start mode other
    than <literal>UNBOUNDED PRECEDING</literal>).  Conceptually, the forward
    transition function adds input values to the aggregate's state when
    they enter the window frame from the bottom, and the inverse transition
    function removes them again when they leave the frame at the top.  So,
    when values are removed, they are always removed in the same order they
    were added.  Whenever the inverse transition function is invoked, it will
    thus receive the earliest added but not yet removed argument value(s).
    The inverse transition function can assume that at least one row will
    remain in the current state after it removes the oldest row.  (When this
    would not be the case, the window function mechanism simply starts a
    fresh aggregation, rather than using the inverse transition function.)
   </para>
____________________________________________________________________________-->
   <para>
    如果一个聚集支持移动聚集模式，当该聚集被用于一个具有移动帧起点（即帧起点
    模式不是<literal>UNBOUNDED PRECEDING</literal>）的窗口函数时，它将提升计
    算效率。在概念上，当从底部进入窗口帧时前向转移函数会把输入值加到聚集的状
    态上，而逆向转移函数会在从顶部离开帧时再次移除输入值。因此，当值被移除时，
    它们总是按照被加入的相同顺序被移除。无论何时调用逆向转移函数，它都将因此
    接收最近增加但是还未被移除的参数值。逆向转移函数可以假定在它移除最旧的行
    之后至少有一行保留在当前状态中（当情况不是这样时，窗口函数机制会简单地开
    始一次新的聚集，而不是使用逆向转移函数）。
   </para>

<!--==========================orignal english content==========================
   <para>
    The forward transition function for moving-aggregate mode is not
    allowed to return NULL as the new state value. If the inverse
    transition function returns NULL, this is taken as an indication that
    the inverse function cannot reverse the state calculation for this
    particular input, and so the aggregate calculation will be redone from
    scratch for the current frame starting position.  This convention
    allows moving-aggregate mode to be used in situations where there are
    some infrequent cases that are impractical to reverse out of the
    running state value.
   </para>
____________________________________________________________________________-->
   <para>
    用于移动聚集模式的前向转移函数不允许返回 NULL 作为新的状态值。如果逆向
    转移函数返回 NULL，这表明逆向函数无法为这个特定的输入逆转状态计算，并且
    该聚集计算因此必须从当前帧的开始位置“从零开始”重新被计算。在一些少见的情
    况中，逆转正在计算中的状态值是不切实际的，这种习惯可以允许在此类情形中使用
    移动聚集模式。
   </para>

<!--==========================orignal english content==========================
   <para>
    If no moving-aggregate implementation is supplied,
    the aggregate can still be used with moving frames,
    but <productname>PostgreSQL</productname> will recompute the whole
    aggregation whenever the start of the frame moves.
    Note that whether or not the aggregate supports moving-aggregate
    mode, <productname>PostgreSQL</productname> can handle a moving frame
    end without recalculation; this is done by continuing to add new values
    to the aggregate's state.  This is why use of an aggregate as a window
    function requires that the final function be read-only: it must
    not damage the aggregate's state value, so that the aggregation can be
    continued even after an aggregate result value has been obtained for
    one set of frame boundaries.
   </para>
____________________________________________________________________________-->
   <para>
    如果没有提供移动聚集实现，聚集仍然可以被用于移动帧，但是
    只要帧起点移动，<productname>PostgreSQL</productname>都将会重新计算
    整个聚集。注意不管聚集有没有支持移动聚集模式，
    <productname>PostgreSQL</productname>都能处理一个移动帧结束而无需重
    新计算，这可以通过增加新值到聚集状态完成。这就是为什么使用聚合作为窗口函数需要最终函数只读的原因。人们认为最终函数不能破坏聚集的状
    态值，这样即使已经为一组帧边界得到了一个聚集结果值，该聚集也能继续下去。
   </para>

<!--==========================orignal english content==========================
   <para>
    The syntax for ordered-set aggregates allows <literal>VARIADIC</literal>
    to be specified for both the last direct parameter and the last
    aggregated (<literal>WITHIN GROUP</literal>) parameter.  However, the
    current implementation restricts use of <literal>VARIADIC</literal>
    in two ways.  First, ordered-set aggregates can only use
    <literal>VARIADIC "any"</literal>, not other variadic array types.
    Second, if the last direct parameter is <literal>VARIADIC "any"</literal>,
    then there can be only one aggregated parameter and it must also
    be <literal>VARIADIC "any"</literal>.  (In the representation used in the
    system catalogs, these two parameters are merged into a single
    <literal>VARIADIC "any"</literal> item, since <structname>pg_proc</structname> cannot
    represent functions with more than one <literal>VARIADIC</literal> parameter.)
    If the aggregate is a hypothetical-set aggregate, the direct arguments
    that match the <literal>VARIADIC "any"</literal> parameter are the hypothetical
    ones; any preceding parameters represent additional direct arguments
    that are not constrained to match the aggregated arguments.
   </para>
____________________________________________________________________________-->
   <para>
    有序集聚集的语法允许为最后一个直接参数以及最后一个聚集（
    <literal>WITHIN GROUP</literal>）参数指定<literal>VARIADIC</literal>。但是，当前的
    实现限制只能以两种方式使用<literal>VARIADIC</literal>。第一种，有续集聚集只能
    使用<literal>VARIADIC "any"</literal>，不能使用其他可变数组类型。第二种，如果最
    后一个直接参数是<literal>VARIADIC "any"</literal>，那么只能有一个聚集参数并且它
    也必须是<literal>VARIADIC "any"</literal>（在系统目录中使用的表示中，这两个参数
    会被合并为一个单一的<literal>VARIADIC "any"</literal>项，因为
    <structname>pg_proc</structname>无法表示具有超过一个<literal>VARIADIC</literal>参数的
    函数）。如果该聚集是一个假想集聚集，匹配<literal>VARIADIC "any"</literal>参数的
    直接参数就是假想参数。任何在前面的参数表示额外的直接参数，它们不被约束为需
    要匹配聚集参数。
   </para>

<!--==========================orignal english content==========================
   <para>
    Currently, ordered-set aggregates do not need to support
    moving-aggregate mode, since they cannot be used as window functions.
   </para>
____________________________________________________________________________-->
   <para>
    当前，有序集聚集无须支持移动聚集模式，因为它们不能被用作窗口函数。
   </para>
   
<!--==========================orignal english content==========================
   <para>
    Partial (including parallel) aggregation is currently not supported for
    ordered-set aggregates.  Also, it will never be used for aggregate calls
    that include <literal>DISTINCT</literal> or <literal>ORDER BY</literal> clauses, since
    those semantics cannot be supported during partial aggregation.
  </para>
____________________________________________________________________________-->
   <para>
    部分（包括并行）聚集当前不被有续集聚集支持。还有，包括
    <literal>DISTINCT</literal>或者<literal>ORDER BY</literal>子句的聚集调用将不会使用
    部分聚集，因为在部分聚集时无法支持那些语义。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Examples</title>
____________________________________________________________________________-->
  <title>示例</title>

<!--==========================orignal english content==========================
  <para>
   See <xref linkend="xaggr"/>.
  </para>
____________________________________________________________________________-->
  <para>
   见<xref linkend="xaggr"/>。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Compatibility</title>
____________________________________________________________________________-->
  <title>兼容性</title>

<!--==========================orignal english content==========================
  <para>
   <command>CREATE AGGREGATE</command> is a
   <productname>PostgreSQL</productname> language extension.  The SQL
   standard does not provide for user-defined aggregate functions.
  </para>
____________________________________________________________________________-->
  <para>
   <command>CREATE AGGREGATE</command>是一种
   <productname>PostgreSQL</productname>的语言扩展。SQL 标准没有提供
   用户定义的聚集函数。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>See Also</title>
____________________________________________________________________________-->
  <title>另见</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alteraggregate"/></member>
   <member><xref linkend="sql-dropaggregate"/></member>
  </simplelist>
 </refsect1>
</refentry>
