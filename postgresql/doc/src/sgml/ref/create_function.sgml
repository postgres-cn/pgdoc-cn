<!--
doc/src/sgml/ref/create_function.sgml
-->

<refentry id="SQL-CREATEFUNCTION">
 <refmeta>
  <refentrytitle>CREATE FUNCTION</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE FUNCTION</refname>
<!--
  <refpurpose>define a new function</refpurpose>
-->
  <refpurpose>定义一个新函数</refpurpose>
 </refnamediv>

 <indexterm zone="sql-createfunction">
  <primary>CREATE FUNCTION</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
CREATE [ OR REPLACE ] FUNCTION
    <replaceable class="parameter">name</replaceable> ( [ [ <replaceable class="parameter">argmode</replaceable> ] [ <replaceable class="parameter">argname</replaceable> ] <replaceable class="parameter">argtype</replaceable> [ { DEFAULT | = } <replaceable class="parameter">default_expr</replaceable> ] [, ...] ] )
    [ RETURNS <replaceable class="parameter">rettype</replaceable>
      | RETURNS TABLE ( <replaceable class="parameter">column_name</replaceable> <replaceable class="parameter">column_type</replaceable> [, ...] ) ]
  { LANGUAGE <replaceable class="parameter">lang_name</replaceable>
    | WINDOW
    | IMMUTABLE | STABLE | VOLATILE | [ NOT ] LEAKPROOF
    | CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT
    | [ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER
    | COST <replaceable class="parameter">execution_cost</replaceable>
    | ROWS <replaceable class="parameter">result_rows</replaceable>
    | SET <replaceable class="parameter">configuration_parameter</replaceable> { TO <replaceable class="parameter">value</replaceable> | = <replaceable class="parameter">value</replaceable> | FROM CURRENT }
    | AS '<replaceable class="parameter">definition</replaceable>'
    | AS '<replaceable class="parameter">obj_file</replaceable>', '<replaceable class="parameter">link_symbol</replaceable>'
  } ...
    [ WITH ( <replaceable class="parameter">attribute</replaceable> [, ...] ) ]
</synopsis>
 </refsynopsisdiv>

 <refsect1 id="sql-createfunction-description">
<!-- 
  <title>Description</title>
-->
 <title>描述</title>

<!-- 
  <para>
   <command>CREATE FUNCTION</command> defines a new function.
   <command>CREATE OR REPLACE FUNCTION</command> will either create a
   new function, or replace an existing definition.
   To be able to define a function, the user must have the
   <literal>USAGE</literal> privilege on the language.
  </para>
-->
  <para>
   <command>CREATE FUNCTION</command>定义一个新的函数。
   <command>CREATE OR REPLACE FUNCTION</command>
   如果函数不存在就创建一个新函数，否则替换现有的定义。用户必须有定义该函数所用语言的
   <literal>USAGE</literal> 权限才能定义新函数。
  </para>

<!-- 
  <para>
   If a schema name is included, then the function is created in the
   specified schema.  Otherwise it is created in the current schema.
   The name of the new function must not match any existing function
   with the same input argument types in the same schema.  However,
   functions of different argument types can share a name (this is
   called <firstterm>overloading</>).
  </para>
-->
  <para>
    如果包含了一个模式名，那么函数就在指定的模式中创建。否则它会在当前模式中创建。
    新函数的名字不能和同一个模式中的任何带有同样参数类型的函数同名。
    不过，参数类型不同的函数可以同名(这叫做<firstterm>重载</>)。
  </para>

<!-- 
  <para>
   To replace the current definition of an existing function, use
   <command>CREATE OR REPLACE FUNCTION</command>.  It is not possible
   to change the name or argument types of a function this way (if you
   tried, you would actually be creating a new, distinct function).
   Also, <command>CREATE OR REPLACE FUNCTION</command> will not let
   you change the return type of an existing function.  To do that,
   you must drop and recreate the function.  (When using <literal>OUT</>
   parameters, that means you cannot change the types of any
   <literal>OUT</> parameters except by dropping the function.)
  </para>
-->
  <para>
    使用 <command>CREATE OR REPLACE FUNCTION</command>
    替换一个现有函数的定义。
    不能用这个方法修改一个函数的名字或者参数类型，
    否则就会创建一个新的函数。同样
    <command>CREATE OR REPLACE FUNCTION</command>
    也不会允许你修改一个现有函数的返回类型。要做这些事情，
    你必须删除并重新创建函数。如果使用 <literal>OUT</> 参数，
    那就意味着除了删除函数之外，你不能修改任何 <literal>OUT</>
    参数的类型或者名字。
  </para>

<!-- 
  <para>
   When <command>CREATE OR REPLACE FUNCTION</> is used to replace an
   existing function, the ownership and permissions of the function
   do not change.  All other function properties are assigned the
   values specified or implied in the command.  You must own the function
   to replace it (this includes being a member of the owning role).
  </para>
-->
  <para>
    当使用 <command>CREATE OR REPLACE FUNCTION</> 替换现有函数的定义时，
    不会改变函数的属主和权限。函数其他的属性会被赋予命令中给定的值或默认值。
    只有函数的属主才可以替换函数（也可以是属主角色的成员）。
  </para>

<!-- 
  <para>
   If you drop and then recreate a function, the new function is not
   the same entity as the old; you will have to drop existing rules, views,
   triggers, etc. that refer to the old function.  Use
   <command>CREATE OR REPLACE FUNCTION</command> to change a function
   definition without breaking objects that refer to the function.
   Also, <command>ALTER FUNCTION</> can be used to change most of the
   auxiliary properties of an existing function.
  </para>
-->
<para>
   如果你删除然后重建一个函数，新函数和旧函数将是不同的实体；
   你就需要删除现有引用了老函数的规则、视图、触发器等等。
   使用<command>CREATE OR REPLACE FUNCTION</command>
   可以在不破坏引用该函数的对象的前提下修改函数定义。
   并且，使用<command>ALTER FUNCTION</> 能修改一个已有函数的大多数属性。
  </para>

<!-- 
  <para>
   The user that creates the function becomes the owner of the function.
  </para>
-->
  <para>
   创建这个函数的用户将成为函数的所有者。
  </para>

<!-- 
  <para>
   To be able to create a function, you must have <literal>USAGE</literal>
   privilege on the argument types and the return type.
  </para>
-->
  <para>
    你必须拥有要创建函数的参数类型和返回值类型的 <literal>USAGE</literal> 权限，
    才能创建该函数。
  </para>
 </refsect1>

 <refsect1>
<!-- 
  <title>Parameters</title>
-->
  <title>参数</title>

   <variablelist>

    <varlistentry>
     <term><replaceable class="parameter">name</replaceable></term>

     <listitem>
<!-- 
      <para>
       The name (optionally schema-qualified) of the function to create.
      </para>
-->
      <para>
要创建的函数名字(可以用模式修饰)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">argmode</replaceable></term>

     <listitem>
<!-- 
      <para>
       The mode of an argument: <literal>IN</>, <literal>OUT</>,
       <literal>INOUT</>, or <literal>VARIADIC</>.
       If omitted, the default is <literal>IN</>.
       Only <literal>OUT</> arguments can follow a <literal>VARIADIC</> one.
       Also, <literal>OUT</> and <literal>INOUT</> arguments cannot be used
       together with the <literal>RETURNS TABLE</> notation.
      </para>
-->
     <para>
       参数的模式： <literal>IN</>，<literal>OUT</>，<literal>INOUT</>,
       或 <literal>VARIADIC</>。缺省值是<literal>IN</>。只有 <literal>OUT</>
      模式的参数后面能跟<literal>VARIADIC</>。并且<literal>OUT</> 和
      <literal>INOUT</> 模式的参数不能用在 <literal>RETURNS TABLE</> 的函数定义中。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">argname</replaceable></term>

     <listitem>
<!-- 
      <para>
       The name of an argument. Some languages (including SQL and PL/pgSQL)
       let you use the name in the function body.  For other languages the
       name of an input argument is just extra documentation, so far as
       the function itself is concerned; but you can use input argument names
       when calling a function to improve readability (see <xref
       linkend="sql-syntax-calling-funcs">).  In any case, the name
       of an output argument is significant, because it defines the column
       name in the result row type.  (If you omit the name for an output
       argument, the system will choose a default column name.)
      </para>
-->
     <para>
一个参数的名字。有些语言(包括 SQL 和 PL/pgSQL)允许你在函数体里使用参数名字。
对于其它语言，输入参数名字只是额外的文档，这只是就函数定义本身而言的；
在调用函数时你可以使用输入参数名字来提高可读性。
（见 <xref linkend="sql-syntax-calling-funcs">）。
无论如何，输出参数的名字是非常重要的，因为它定义了结果行类型的列名。
（如果你省略了输出参数的名字，那么系统会自动选择一个缺省的列名。）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">argtype</replaceable></term>

     <listitem>
<!-- 
      <para>
       The data type(s) of the function's arguments (optionally
       schema-qualified), if any. The argument types can be base, composite,
       or domain types, or can reference the type of a table column.
      </para>
-->
     <para>
该函数的数据类型(可以有模式修饰)，如果有的话。可以是基本类型，
也可以是复合类型、域类型、或者可以引用一个现有字段相同的类型。
      </para>
<!-- 
      <para>
       Depending on the implementation language it might also be allowed
       to specify <quote>pseudotypes</> such as <type>cstring</>.
       Pseudotypes indicate that the actual argument type is either
       incompletely specified, or outside the set of ordinary SQL data types.
      </para>
-->
      <para>
根据实现语言的不同，还可以在这上面声明<quote>伪类型</>
        (比如 <type>cstring</>)。伪类型表示实际的参数类型要么是没有完整地声明，
        要么是在普通的 SQL 数据类型之外。
      </para>
<!-- 
      <para>
       The type of a column is referenced by writing
       <literal><replaceable
       class="parameter">table_name</replaceable>.<replaceable
       class="parameter">column_name</replaceable>%TYPE</literal>.
       Using this feature can sometimes help make a function independent of
       changes to the definition of a table.
      </para>
-->
      <para>
一个字段的类型是用 <literal><replaceable
       class="parameter">table_name</replaceable>.<replaceable
       class="parameter">column_name</replaceable>%TYPE</literal>
       表示的；使用这个特性有时候可以帮助创建一个不受表定义变化影响的函数。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">default_expr</replaceable></term>

     <listitem>
<!-- 
      <para>
       An expression to be used as default value if the parameter is
       not specified.  The expression has to be coercible to the
       argument type of the parameter.
       Only input (including <literal>INOUT</>) parameters can have a default
        value.  All input parameters following a
       parameter with a default value must have default values as well.
      </para>
-->
     <para>
当参数值没有指定时作为参数默认值的表达式。该表达式的类型必须可转化为参数的类型。
只有输入(也包括 <literal>INOUT</>)参数才能有默认值。具有默认值参数的输入参数必须在参数列表的最后。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">rettype</replaceable></term>

     <listitem>
<!-- 
      <para>
       The return data type (optionally schema-qualified). The return type
       can be a base, composite, or domain type,
       or can reference the type of a table column.
       Depending on the implementation language it might also be allowed
       to specify <quote>pseudotypes</> such as <type>cstring</>.
       If the function is not supposed to return a value, specify
       <type>void</> as the return type.
      </para>
-->
     <para>
        返回值的数据类型。可以声明为一个基本类型、复合类型、域类型、或者引用一个表的现有字段类型。
        根据实现语言的不同，还可以在这上面声明<quote>伪类型</>(比如 <type>cstring</>)。
        如果不打算返回任何值可以指定 <type>void</> 作为返回类型。
      </para>
<!-- 
      <para>
       When there are <literal>OUT</> or <literal>INOUT</> parameters,
       the <literal>RETURNS</> clause can be omitted.  If present, it
       must agree with the result type implied by the output parameters:
       <literal>RECORD</> if there are multiple output parameters, or
       the same type as the single output parameter.
      </para>
-->
      <para>
       如果存在 <literal>OUT</> 或 <literal>INOUT</> 参数，那么可以省略 <literal>RETURNS</> 子句。如果出现了，
       那么它必须隐含的和输出参数结果类型兼容：如果有多个输出参数，
       则必须是 <literal>RECORD</> ，如果只有一个输出参数，则与其相同。
      </para>
<!--
      <para>
       The <literal>SETOF</literal>
       modifier indicates that the function will return a set of
       items, rather than a single item.
      </para>
-->
      <para>
      <literal>SETOF</literal> 修饰词表示该函数将返回一个集合，而不是单独一条。
      </para>
<!-- 
      <para>
       The type of a column is referenced by writing
       <literal><replaceable
       class="parameter">table_name</replaceable>.<replaceable
       class="parameter">column_name</replaceable>%TYPE</literal>.
      </para>
-->
      <para>
      一个字段的类型是通过
       <literal><replaceable
       class="parameter">table_name</replaceable>.<replaceable
       class="parameter">column_name</replaceable>%TYPE</literal> 引用的。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">column_name</replaceable></term>

     <listitem>
<!-- 
      <para>
       The name of an output column in the <literal>RETURNS TABLE</>
       syntax.  This is effectively another way of declaring a named
       <literal>OUT</> parameter, except that <literal>RETURNS TABLE</>
       also implies <literal>RETURNS SETOF</>.
      </para>
-->
     <para>
       <literal>RETURNS TABLE</>的语法中输出字段名。
       这是另一种有效的声名带名字的 <literal>OUT</> 类型参数的方式，
       而且<literal>RETURNS TABLE</> 隐含 <literal>RETURNS SETOF</>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">column_type</replaceable></term>

     <listitem>
<!-- 
      <para>
       The data type of an output column in the <literal>RETURNS TABLE</>
       syntax.
      </para>
-->
     <para>
       <literal>RETURNS TABLE</>语法中输出字段的数据类型。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">lang_name</replaceable></term>

     <listitem>
<!-- 
      <para>
       The name of the language that the function is implemented in.
       Can be <literal>SQL</literal>, <literal>C</literal>,
       <literal>internal</literal>, or the name of a user-defined
       procedural language.  For backward compatibility,
       the name can be enclosed by single quotes.
      </para>
-->
     <para>
       用以实现函数的语言的名字。可以是 <literal>SQL</literal>, <literal>C</literal>,
       <literal>internal</literal>，或者是用户定义的过程语言名字。该名字可以用单引号包围。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>WINDOW</literal></term>

     <listitem>
<!-- 
      <para><literal>WINDOW</literal> indicates that the function is a
       <firstterm>window function</> rather than a plain function.
       This is currently only useful for functions written in C.
       The <literal>WINDOW</> attribute cannot be changed when
       replacing an existing function definition.
      </para>
-->
     <para><literal>WINDOW</literal> 表示该函数不是普通函数而是一个<firstterm>窗口函数</>。
       这个属性当前仅对用C写的函数起作用。
       当替换已有函数定义时不能改变函数的<literal>WINDOW</>属性。
      </para>
     </listitem>
     </varlistentry>

    <varlistentry>
     <term><literal>IMMUTABLE</literal></term>
     <term><literal>STABLE</literal></term>
     <term><literal>VOLATILE</literal></term>

     <listitem>
<!-- 
      <para>
       These attributes inform the query optimizer about the behavior
       of the function.  At most one choice
       can be specified.  If none of these appear,
       <literal>VOLATILE</literal> is the default assumption.
      </para>
-->
     <para>
       这些属性是在查询优化器中用来优化函数的调用的，只能指定一个。缺省值是 <literal>VOLATILE</literal>。
      </para>

<!-- 
      <para><literal>IMMUTABLE</literal> indicates that the function
       cannot modify the database and always
       returns the same result when given the same argument values; that
       is, it does not do database lookups or otherwise use information not
       directly present in its argument list.  If this option is given,
       any call of the function with all-constant arguments can be
       immediately replaced with the function value.
      </para>
-->
      <para><literal>IMMUTABLE</literal> 表示该函数不能修改数据库，
        并且在给出同样的参数值时总是返回同样的结果；
        也就是说，它不查询数据库或者只使用那些没有出现在参数列表里的信息。
        如果给出这个选项，那么任何全部使用常数对该函数的调用都将立即替换为该函数的值。
      </para>
<!-- 
      <para><literal>STABLE</literal> indicates that the function
       cannot modify the database,
       and that within a single table scan it will consistently
       return the same result for the same argument values, but that its
       result could change across SQL statements.  This is the appropriate
       selection for functions whose results depend on database lookups,
       parameter variables (such as the current time zone), etc.  (It is
       inappropriate for <literal>AFTER</> triggers that wish to
       query rows modified by the current command.)  Also note
       that the <function>current_timestamp</> family of functions qualify
       as stable, since their values do not change within a transaction.
      </para>
-->
      <para><literal>STABLE</literal> 表示该函数不能修改数据库，
        对相同参数值，在同一次表扫描里，该函数的返回值不变，但是返回值可能在不同 SQL 语句之间变化。
        这个选项对那些结果依赖数据库查找、参数变量(比如当前时区)之类的函数很合适。
        （但对于那些希望查询当前命令修改的行的 <literal>AFTER</> 类型的触发器是不合适的。）
        还要注意 <function>current_timestamp</> 函数族是稳定的，因为它们的值在一次事务中不会变化。
      </para>
<!-- 
      <para><literal>VOLATILE</literal> indicates that the function value can
       change even within a single table scan, so no optimizations can be
       made.  Relatively few database functions are volatile in this sense;
       some examples are <literal>random()</>, <literal>currval()</>,
       <literal>timeofday()</>.  But note that any function that has
       side-effects must be classified volatile, even if its result is quite
       predictable, to prevent calls from being optimized away; an example is
       <literal>setval()</>.
      </para>
-->
      <para><literal>VOLATILE</literal> 表示该函数值甚至可以在一次表扫描内改变，
        因此不会做任何优化。只有很少的数据库函数在这个概念上是易变的；
        一些例子是 <literal>random()</>, <literal>currval()</>, <literal>timeofday()</>。
        请注意任何有副作用的函数都必需列为易变类，即使其结果相当有规律也应该这样，
        这样才能避免它被优化；一个例子就是 <literal>setval()</>。
      </para>
<!-- 
      <para>
       For additional details see <xref linkend="xfunc-volatility">.
      </para>
-->
      <para>
        更多细节，请参阅<xref linkend="xfunc-volatility">。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>LEAKPROOF</literal></term>
     <listitem>
<!-- 
      <para>
       <literal>LEAKPROOF</literal> indicates that the function has no side
       effects.  It reveals no information about its arguments other than by
       its return value.  For example, a function which throws an error message
       for some argument values but not others, or which includes the argument
       values in any error message, is not leakproof.   The query planner may
       push leakproof functions (but not others) into views created with the
       <literal>security_barrier</literal> option.  See
       <xref linkend="sql-createview"> and <xref linkend="rules-privileges">.
       This option can only be set by the superuser.
      </para>
-->
     <para>
        <literal>LEAKPROOF</literal> 表示该函数没有涉密方面的副作用。
        它除了返回值外，不会泄露它的参数的任何信息。例如，一个函数抛出了一个参数不正确的错误，
        但错误消息里包含了参数值的信息，那这个函数就是不保密的(leakproof)。
        查询计划生成器可以把保密的函数放到用 <literal>security_barrier</literal> 选项生成的视图中，
        而不保密的函数则不可以。参见 <xref linkend="sql-createview"> 和 <xref linkend="rules-privileges">。
        这个选项只能由超级用户设置。
       </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>CALLED ON NULL INPUT</literal></term>
     <term><literal>RETURNS NULL ON NULL INPUT</literal></term>
     <term><literal>STRICT</literal></term>
     <listitem>
<!-- 
      <para><literal>CALLED ON NULL INPUT</literal> (the default) indicates
       that the function will be called normally when some of its
       arguments are null.  It is then the function author's
       responsibility to check for null values if necessary and respond
       appropriately.
      </para>
-->
     <para><literal>CALLED ON NULL INPUT</literal>
        (缺省)表明该函数在自己的某些参数是 NULL 的时候还是可以按照正常的方式调用。
        函数的作者必须负责检查 NULL 以及进行相应地处理。
      </para>

<!-- 
      <para><literal>RETURNS NULL ON NULL INPUT</literal> or
       <literal>STRICT</literal> indicates that the function always
       returns null whenever any of its arguments are null.  If this
       parameter is specified, the function is not executed when there
       are null arguments; instead a null result is assumed
       automatically.
      </para>
-->
     <para><literal>RETURNS NULL ON NULL INPUT</literal> 或
      <literal>STRICT</literal> 表明如果它的任何参数是 NULL，
      此函数总是返回 NULL。如果声明了这个参数，则如果存在 NULL 参数时不会执行该函数；
      而只是自动假设一个 NULL 结果。
     </para>
     </listitem>
    </varlistentry>

   <varlistentry>
    <term><literal><optional>EXTERNAL</optional> SECURITY INVOKER</literal></term>
    <term><literal><optional>EXTERNAL</optional> SECURITY DEFINER</literal></term>

    <listitem>
<!-- 
     <para><literal>SECURITY INVOKER</literal> indicates that the function
      is to be executed with the privileges of the user that calls it.
      That is the default.  <literal>SECURITY DEFINER</literal>
      specifies that the function is to be executed with the
      privileges of the user that created it.
     </para>
-->
    <para><literal>SECURITY INVOKER</literal> (缺省)表明该函数将使用调用它的用户权限执行。
        <literal>SECURITY DEFINER</literal> 声明该函数将以创建它的用户的权限执行。
      </para>
<!-- 
     <para>
      The key word <literal>EXTERNAL</literal> is allowed for SQL
      conformance, but it is optional since, unlike in SQL, this feature
      applies to all functions not only external ones.
     </para>
-->
      <para>
        关键字 <literal>EXTERNAL</literal> 的目的是和 SQL 兼容，
        它是可选的，因为这个特性适用于所有函数，而不仅仅在SQL中的外部函数。
     </para>
    </listitem>
   </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">execution_cost</replaceable></term>

     <listitem>
<!-- 
      <para>
       A positive number giving the estimated execution cost for the function,
       in units of <xref linkend="guc-cpu-operator-cost">.  If the function
       returns a set, this is the cost per returned row.  If the cost is
       not specified, 1 unit is assumed for C-language and internal functions,
       and 100 units for functions in all other languages.  Larger values
       cause the planner to try to avoid evaluating the function more often
       than necessary.
      </para>
-->
     <para>
         一个正数，表示以 <xref linkend="guc-cpu-operator-cost"> 为单位的该函数的估算的执行代价。
         如果函数返回的是一个结果集，它表示的是每行结果的代价。如果这个选项没有指定，
         对于用C语言函数和内部函数缺省值为 1，而其他语言定义的函数缺省值为 100。
         较大的值会使查询计划生成器在不必要的情况下尽量避免调用该函数。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">result_rows</replaceable></term>

     <listitem>
<!-- 
      <para>
       A positive number giving the estimated number of rows that the planner
       should expect the function to return.  This is only allowed when the
       function is declared to return a set.  The default assumption is
       1000 rows.
      </para>
-->
     <para>
        一个正数给出了查询计划生成器预期的该函数返回的估算的结果集行数，
        它仅允许返回结果集的函数指定。缺省值为 1000。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>configuration_parameter</replaceable></term>
     <term><replaceable>value</replaceable></term>
     <listitem>
<!-- 
      <para>
       The <literal>SET</> clause causes the specified configuration
       parameter to be set to the specified value when the function is
       entered, and then restored to its prior value when the function exits.
       <literal>SET FROM CURRENT</> saves the session's current value of
       the parameter as the value to be applied when the function is entered.
      </para>
-->
     <para>
       <literal>SET</> 语句能在进入函数时将某个配置参数设置成指定的值，
       并且当函数返回时恢复成之前的值。<literal>SET FROM CURRENT</>
       使用会话当前的该参数值做为进入函数时的该参数的值。
      </para>

<!-- 
      <para>
       If a <literal>SET</> clause is attached to a function, then
       the effects of a <command>SET LOCAL</> command executed inside the
       function for the same variable are restricted to the function: the
       configuration parameter's prior value is still restored at function exit.
       However, an ordinary
       <command>SET</> command (without <literal>LOCAL</>) overrides the
       <literal>SET</> clause, much as it would do for a previous <command>SET
       LOCAL</> command: the effects of such a command will persist after
       function exit, unless the current transaction is rolled back.
      </para>
-->
      <para>
        如果一个函数创建时带有某个配置参数的<literal>SET</> 语句，
        那么在函数内对于同一参数的<command>SET LOCAL</> 语句的作用域仅限于该函数：
        执行函数之前的该参数的值会在函数返回后恢复。然而一个一般的同一参数的
        <command>SET</> 语句（不带 <literal>LOCAL</>）的作用效果将在函数返回后继续保持，
        直到当前的事务回滚。
      </para>

<!-- 
      <para>
       See <xref linkend="sql-set"> and
       <xref linkend="runtime-config">
       for more information about allowed parameter names and values.
      </para>
-->
      <para>
       关于允许设置的参数和值的进一步信息请参考 <xref linkend="sql-set"> 和
       <xref linkend="runtime-config">。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">definition</replaceable></term>

     <listitem>
<!-- 
      <para>
       A string constant defining the function; the meaning depends on the
       language.  It can be an internal function name, the path to an
       object file, an SQL command, or text in a procedural language.
      </para>
-->
     <para>
        一个定义函数的字符串常量，含义取决于语言。它可以是一个内部函数名字、一个指向某个目标文件的路径、一个 SQL 查询、一个过程语言文本。
      </para>

<!-- 
      <para>
       It is often helpful to use dollar quoting (see <xref
       linkend="sql-syntax-dollar-quoting">) to write the function definition
       string, rather than the normal single quote syntax.  Without dollar
       quoting, any single quotes or backslashes in the function definition must
       be escaped by doubling them.
      </para>
-->
      <para>
        在写函数体字符串时经常使用美元符引用语法
        （见<xref linkend="sql-syntax-dollar-quoting">），而不通常的单引号语法，
        这是因为如果不使用美元符引用语法，
        在函数定义中出现的任何单引号和反斜线都需要前面再加一个相应的相同字符来转义。
      </para>

     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal><replaceable class="parameter">obj_file</replaceable>, <replaceable class="parameter">link_symbol</replaceable></literal></term>

     <listitem>
<!-- 
      <para>
       This form of the <literal>AS</literal> clause is used for
       dynamically loadable C language functions when the function name
       in the C language source code is not the same as the name of
       the SQL function. The string <replaceable
       class="parameter">obj_file</replaceable> is the name of the
       file containing the dynamically loadable object, and
       <replaceable class="parameter">link_symbol</replaceable> is the
       function's link symbol, that is, the name of the function in the C
       language source code.  If the link symbol is omitted, it is assumed
       to be the same as the name of the SQL function being defined.
      </para>
-->
     <para>
        这个形式的 <literal>AS</literal> 子句用于在函数的 C 源文件里的名字和 SQL 名字不同时可动态加载 C 语言函数。
        字符串 <replaceable class="parameter">obj_file</replaceable> 是包含可动态加载对象的文件名，
        而 <replaceable class="parameter">link_symbol</replaceable> 是函数的链接符号，
        也就是该函数在 C 源文件里的名字。如果省略了链接符号，那么就假设它和被定义的 SQL 函数同名。
      </para>

<!-- 
      <para>
       When repeated <command>CREATE FUNCTION</command> calls refer to
       the same object file, the file is only loaded once per session.
       To unload and
       reload the file (perhaps during development), start a new session.
      </para>
-->
      <para>
        当使用同一个可动态加载文件重复执行命令 <command>CREATE FUNCTION</command> 生成函数时，
        在一个全会话里该文件只会被加载一次。若想卸载或重新加载该文件（通常在开发过程中使用），
        可以开启一个新的会话。
      </para>

     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">attribute</replaceable></term>

     <listitem>
      <para>
<!-- 
       The historical way to specify optional pieces of information
       about the function.  The following attributes can appear here:
-->
      历史遗留的函数可选信息。下面的属性可以在此出现：

      <variablelist>
       <varlistentry>
        <term><literal>isStrict</></term>
        <listitem>
<!-- 
         <para>
          Equivalent to <literal>STRICT</literal> or <literal>RETURNS NULL ON NULL INPUT</literal>.
         </para>
-->
        <para>
           等效于 <literal>STRICT</literal> 或 <literal>RETURNS NULL ON NULL INPUT</literal>。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>isCachable</></term>
        <listitem>
<!-- 
         <para><literal>isCachable</literal> is an obsolete equivalent of
          <literal>IMMUTABLE</literal>; it's still accepted for
          backwards-compatibility reasons.
         </para>
-->
        <para><literal>isCachable</literal> 是 <literal>IMMUTABLE</literal> 的过时的等效语法；
            不过出于向下兼容，仍然接受它。
         </para>
        </listitem>
       </varlistentry>

      </variablelist>
<!-- 
      Attribute names are not case-sensitive.
-->
      属性名是大小写无关的。
     </para>
    </listitem>
   </varlistentry>

   </variablelist>

<!-- 
   <para>
    Refer to <xref linkend="xfunc"> for further information on writing
    functions.
   </para>
-->
   <para>
     请参阅<xref linkend="xfunc">获取更多关于书写函数的信息。
   </para>

 </refsect1>

 <refsect1 id="sql-createfunction-overloading">
<!-- 
  <title>Overloading</title>
-->
 <title>重载</title>

<!-- 
   <para>
    <productname>PostgreSQL</productname> allows function
    <firstterm>overloading</firstterm>; that is, the same name can be
    used for several different functions so long as they have distinct
    input argument types.  However, the C names of all functions must be
    different, so you must give overloaded C functions different C
    names (for example, use the argument types as part of the C
    names).
   </para>    
-->
 <para>
    <productname>PostgreSQL</productname> 允许函数<firstterm>重载</firstterm>；
    也就是只要输入参数不同，几个不同的函数可以同名。不过，所有函数的 C 名字必须不同，
    也就是说你必须给予重载的 C 函数不同的 C 名字(比如，使用参数类型作为 C 名字的一部分)。
   </para>

   <para>
<!-- 
    Two functions are considered the same if they have the same names and
    <emphasis>input</> argument types, ignoring any <literal>OUT</>
    parameters.  Thus for example these declarations conflict:
-->
   如果两个函数同名，并且<emphasis>输入</>参数类型也相同，
    那么就认为这两个函数是一样的，忽略所有 <literal>OUT</> 参数。
    因此，下面的声明是冲突的：
<programlisting>
CREATE FUNCTION foo(int) ...
CREATE FUNCTION foo(int, out text) ...
</programlisting>
   </para>

   <para>
<!-- 
    Functions that have different argument type lists will not be considered
    to conflict at creation time, but if defaults are provided they might
    conflict in use.  For example, consider
-->
   生成同名的但有不同的参数个数的函数是没有问题的，
    但是如果定义了默认值在调用时就有可能产生冲突，例如，考虑下面定义
<programlisting>
CREATE FUNCTION foo(int) ...
CREATE FUNCTION foo(int, int default 42) ...
</programlisting>
<!-- 
    A call <literal>foo(10)</> will fail due to the ambiguity about which
    function should be called.
-->
    函数调用<literal>foo(10)</>将会失败，因为系统不知道该调用哪一个函数版本。
   </para>

 </refsect1>

 <refsect1 id="sql-createfunction-notes">
<!-- 
  <title>Notes</title>
-->
 <title>注意</title>

<!-- 
   <para>
    The full <acronym>SQL</acronym> type syntax is allowed for
    input arguments and return value. However, some details of the
    type specification (e.g., the precision field for
    type <type>numeric</type>) are the responsibility of the
    underlying function implementation and are silently swallowed
    (i.e., not recognized or
    enforced) by the <command>CREATE FUNCTION</command> command.
   </para>
-->
 <para>
    允许你将完整的 <acronym>SQL</acronym> 类型语法用于输入参数和返回值。
    不过，有些类型声明的细节(比如 <type>numeric</type> 类型的精度域)是由下层函数实现负责的，
    并且会被 <command>CREATE FUNCTION</command> 命令悄悄地吞掉(也就是不再被识别或强制)。
   </para>

<!-- 
   <para>
    When replacing an existing function with <command>CREATE OR REPLACE
    FUNCTION</>, there are restrictions on changing parameter names.
    You cannot change the name already assigned to any input parameter
    (although you can add names to parameters that had none before).
    If there is more than one output parameter, you cannot change the
    names of the output parameters, because that would change the
    column names of the anonymous composite type that describes the
    function's result.  These restrictions are made to ensure that
    existing calls of the function do not stop working when it is replaced.
   </para>
-->
   <para>
    在使用 <command>CREATE OR REPLACE FUNCTION</> 替换一个已存在函数的定义时，
    改变函数的参数名字有一些限制。你不能对已使用了名字的输入参数改名
    （但是你可以给没有使用名字的输入参数加一个名字）。如果该函数有超过一个输出参数，
    你也不能改变输出参数的名字，因为改名会改变用来描述函数返回结果的匿名复合类型的列名。
    这些限制都是为了使在替换函数的定义后对该函数的已有调用还能正常工作。
   </para>

<!-- 
   <para>
    If a function is declared <literal>STRICT</> with a <literal>VARIADIC</>
    argument, the strictness check tests that the variadic array <emphasis>as
    a whole</> is non-null.  The function will still be called if the
    array has null elements.
   </para>
-->
   <para>
    如果一个函数声名为 <literal>STRICT</>，并带有一个 <literal>VARIADIC</> 模式的参数，
    参数的严格性检查将可变数组<emphasis>整体</>看作非空的（non-null）。
    所以当调用时参数数组有空（null）元素时，该函数仍然会被调用。
   </para>

 </refsect1>

 <refsect1 id="sql-createfunction-examples">
<!-- 
  <title>Examples</title>
-->
 <title>例子</title>

  <para>
<!-- 
   Here are some trivial examples to help you get started.  For more
   information and examples, see <xref linkend="xfunc">.
-->
  这里是一些简单的例子，用于帮助你开始掌握这个命令。更多信息和例子，
   参阅<xref linkend="xfunc">。
<programlisting>
CREATE FUNCTION add(integer, integer) RETURNS integer
    AS 'select $1 + $2;'
    LANGUAGE SQL
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;
</programlisting>
  </para>

  <para>
<!-- 
   Increment an integer, making use of an argument name, in
   <application>PL/pgSQL</application>:
-->
  利用参数名用 <application>PL/pgSQL</application> 自增一个整数：
<programlisting>
CREATE OR REPLACE FUNCTION increment(i integer) RETURNS integer AS $$
        BEGIN
                RETURN i + 1;
        END;
$$ LANGUAGE plpgsql;
</programlisting>
  </para>

  <para>
<!-- 
   Return a record containing multiple output parameters:
-->
  返回一个包含多个输出参数的记录：
<programlisting>
CREATE FUNCTION dup(in int, out f1 int, out f2 text)
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);
</programlisting>
<!-- 
   You can do the same thing more verbosely with an explicitly named
   composite type:
-->
   你可以通过命名明确的复合类型的方法冗长地干同样的事情：
<programlisting>
CREATE TYPE dup_result AS (f1 int, f2 text);

CREATE FUNCTION dup(int) RETURNS dup_result
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);
</programlisting>
<!-- 
   Another way to return multiple columns is to use a <literal>TABLE</>
   function:
-->
   另一个返回多列的方法是用 <literal>TABLE</> 函数：
<programlisting>
CREATE FUNCTION dup(int) RETURNS TABLE(f1 int, f2 text)
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);
</programlisting>
<!-- 
   However, a <literal>TABLE</> function is different from the
   preceding examples, because it actually returns a <emphasis>set</>
   of records, not just one record.
-->
   然而，<literal>TABLE</>是与前面的例子完全不同的，
   因为它实际上返回的是一个结果<emphasis>集</>，而不仅仅是一条记录。
  </para>
 </refsect1>

 <refsect1 id="sql-createfunction-security">
<!-- 
  <title>Writing <literal>SECURITY DEFINER</literal> Functions Safely</title>
-->
 <title>编写安全的 <literal>SECURITY DEFINER</literal> 函数</title>

  <indexterm>
<!-- 
   <primary><varname>search_path</varname> configuration parameter</>
   <secondary>use in securing functions</>
-->
  <primary><varname>search_path</varname> 配置参数</>
   <secondary>在安全函数中使用</>
  </indexterm>

<!-- 
   <para>
    Because a <literal>SECURITY DEFINER</literal> function is executed
    with the privileges of the user that created it, care is needed to
    ensure that the function cannot be misused.  For security,
    <xref linkend="guc-search-path"> should be set to exclude any schemas
    writable by untrusted users.  This prevents
    malicious users from creating objects that mask objects used by the
    function.  Particularly important in this regard is the
    temporary-table schema, which is searched first by default, and
    is normally writable by anyone.  A secure arrangement can be had
    by forcing the temporary schema to be searched last.  To do this,
    write <literal>pg_temp</><indexterm><primary>pg_temp</><secondary>securing functions</></> as the last entry in <varname>search_path</>.
    This function illustrates safe usage:
   </para>
-->
  <para>
    因为<literal>SECURITY DEFINER</literal>函数是以创建它的用户的权限执行的，
    所以一定确保这样的函数不被滥用。为了安全，
    应该设置 <xref linkend="guc-search-path"> 排除可以被任何不信任用户更改的模式。
    这能避免恶意用户用生成的对象来替代函数中用到的对象的攻击方法。
    特别应该注意的是临时表模式，该模式默认在搜索路径中排在第一个，并且对任何用户可写。
    为安全考虑可以强制临时表模式最后被搜索。为了达到这个目的，可以将
    <literal>pg_temp</><indexterm><primary>pg_temp</><secondary>安全函数</></>
    放到<varname>search_path</>的最后。下面是安全定义函数的一个例子：
   </para>

<programlisting>
CREATE FUNCTION check_password(uname TEXT, pass TEXT)
RETURNS BOOLEAN AS $$
DECLARE passed BOOLEAN;
BEGIN
        SELECT  (pwd = $2) INTO passed
        FROM    pwds
        WHERE   username = $1;

        RETURN passed;
END;
$$  LANGUAGE plpgsql
    SECURITY DEFINER
    -- <!-- Set a secure search_path: trusted schema(s), then 'pg_temp'. -->设置安全的 search_path: 信任的模式, 然后是 'pg_temp' 模式
    SET search_path = admin, pg_temp;
</programlisting>

<!-- 
   <para>
    Before <productname>PostgreSQL</productname> version 8.3, the
    <literal>SET</> option was not available, and so older functions may
    contain rather complicated logic to save, set, and restore
    <varname>search_path</>.  The <literal>SET</> option is far easier
    to use for this purpose.
   </para>
-->
   <para>
    因为 <productname>PostgreSQL</productname> 8.3 版本没有 <literal>SET</>
    选项，所以老函数可以包含比较复杂的逻辑去存储，设置和恢复 <varname>search_path</>
    参数，而使用 <literal>SET</> 选项则简单的多。
   </para>

<!-- 
   <para>
    Another point to keep in mind is that by default, execute privilege
    is granted to <literal>PUBLIC</> for newly created functions
    (see <xref linkend="sql-grant"> for more
    information).  Frequently you will wish to restrict use of a security
    definer function to only some users.  To do that, you must revoke
    the default <literal>PUBLIC</> privileges and then grant execute
    privilege selectively.  To avoid having a window where the new function
    is accessible to all, create it and set the privileges within a single
    transaction.  For example:
   </para>
-->
   <para>
    另一个需要注意的是：默认新创建的函数的执行权限被授予了 <literal>PUBLIC</>，
   （更多信息见<xref linkend="sql-grant">）。
    更常见的是你希望限制安全函数只给某些用户使用。为了实现这个目的，你必须收回默认的给
    <literal>PUBLIC</>的权限，并且单独给选定用户分配权限。为消除新函数能被所有人执行的时间窗口，
   可以在一个事务中创建和设置函数权限，例如：
   </para>

<programlisting>
BEGIN;
CREATE FUNCTION check_password(uname TEXT, pass TEXT) ... SECURITY DEFINER;
REVOKE ALL ON FUNCTION check_password(uname TEXT, pass TEXT) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION check_password(uname TEXT, pass TEXT) TO admins;
COMMIT;
</programlisting>

 </refsect1>

 <refsect1 id="sql-createfunction-compat">
<!-- 
  <title>Compatibility</title>
-->
 <title>兼容性</title>

<!-- 
  <para>
   A <command>CREATE FUNCTION</command> command is defined in SQL:1999 and later.
   The <productname>PostgreSQL</productname> version is similar but
   not fully compatible.  The attributes are not portable, neither are the
   different available languages.
  </para>
-->
 <para>
   <productname>PostgreSQL</productname> 里的版本和 SQL:1999 里的
   <command>CREATE FUNCTION</command> 命令类似但是不完全兼容。
   属性和可以使用的语言都是不可移植的。
  </para>

<!-- 
  <para>
   For compatibility with some other database systems,
   <replaceable class="parameter">argmode</replaceable> can be written
   either before or after <replaceable class="parameter">argname</replaceable>.
   But only the first way is standard-compliant.
  </para>
-->
  <para>
   为了和一些其它的数据库系统兼容，
   <replaceable class="parameter">argmode</replaceable> 可以在
   <replaceable class="parameter">argname</replaceable> 之前或者之后写，
   但是只有第一种写法是与标准兼容的。
  </para>

<!-- 
  <para>
   For parameter defaults, the SQL standard specifies only the syntax with
   the <literal>DEFAULT</literal> key word.  The syntax
   with <literal>=</literal> is used in T-SQL and Firebird.
  </para>
-->
  <para>
   对于默认参数，SQL标准仅仅规定了使用 <literal>DEFAULT</literal> 关键字的语法。
   在T-SQL 和 Firebird 中，也使用 <literal>=</literal> 的语法。
  </para>
 </refsect1>


 <refsect1>
<!-- 
  <title>See Also</title>
-->
 <title>又见</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alterfunction"></member>
   <member><xref linkend="sql-dropfunction"></member>
   <member><xref linkend="sql-grant"></member>
   <member><xref linkend="sql-load"></member>
   <member><xref linkend="sql-revoke"></member>
   <member><xref linkend="app-createlang"></member>
  </simplelist>
 </refsect1>

</refentry>

