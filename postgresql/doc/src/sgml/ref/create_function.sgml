<!--
doc/src/sgml/ref/create_function.sgml
PostgreSQL documentation
-->

<refentry id="sql-createfunction">
<!--==========================orignal english content==========================
 <indexterm zone="sql-createfunction">
  <primary>CREATE FUNCTION</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="sql-createfunction">
  <primary>CREATE FUNCTION</primary>
 </indexterm>

<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>CREATE FUNCTION</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>CREATE FUNCTION</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>CREATE FUNCTION</refname>
  <refpurpose>define a new function</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>CREATE FUNCTION</refname>
  <refpurpose>定义一个新函数</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
CREATE [ OR REPLACE ] FUNCTION
    <replaceable class="parameter">name</replaceable> ( [ [ <replaceable class="parameter">argmode</replaceable> ] [ <replaceable class="parameter">argname</replaceable> ] <replaceable class="parameter">argtype</replaceable> [ { DEFAULT | = } <replaceable class="parameter">default_expr</replaceable> ] [, ...] ] )
    [ RETURNS <replaceable class="parameter">rettype</replaceable>
      | RETURNS TABLE ( <replaceable class="parameter">column_name</replaceable> <replaceable class="parameter">column_type</replaceable> [, ...] ) ]
  { LANGUAGE <replaceable class="parameter">lang_name</replaceable>
    | TRANSFORM { FOR TYPE <replaceable class="parameter">type_name</replaceable> } [, ... ]
    | WINDOW
    | { IMMUTABLE | STABLE | VOLATILE }
    | [ NOT ] LEAKPROOF
    | { CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT }
    | { [ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER }
    | PARALLEL { UNSAFE | RESTRICTED | SAFE }
    | COST <replaceable class="parameter">execution_cost</replaceable>
    | ROWS <replaceable class="parameter">result_rows</replaceable>
    | SUPPORT <replaceable class="parameter">support_function</replaceable>
    | SET <replaceable class="parameter">configuration_parameter</replaceable> { TO <replaceable class="parameter">value</replaceable> | = <replaceable class="parameter">value</replaceable> | FROM CURRENT }
    | AS '<replaceable class="parameter">definition</replaceable>'
    | AS '<replaceable class="parameter">obj_file</replaceable>', '<replaceable class="parameter">link_symbol</replaceable>'
    | <replaceable class="parameter">sql_body</replaceable>
  } ...
</synopsis>
____________________________________________________________________________-->
<synopsis>
CREATE [ OR REPLACE ] FUNCTION
    <replaceable class="parameter">name</replaceable> ( [ [ <replaceable class="parameter">argmode</replaceable> ] [ <replaceable class="parameter">argname</replaceable> ] <replaceable class="parameter">argtype</replaceable> [ { DEFAULT | = } <replaceable class="parameter">default_expr</replaceable> ] [, ...] ] )
    [ RETURNS <replaceable class="parameter">rettype</replaceable>
      | RETURNS TABLE ( <replaceable class="parameter">column_name</replaceable> <replaceable class="parameter">column_type</replaceable> [, ...] ) ]
  { LANGUAGE <replaceable class="parameter">lang_name</replaceable>
    | TRANSFORM { FOR TYPE <replaceable class="parameter">type_name</replaceable> } [, ... ]
    | WINDOW
    | { IMMUTABLE | STABLE | VOLATILE }
    | [ NOT ] LEAKPROOF
    | { CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT }
    | { [ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER }
    | PARALLEL { UNSAFE | RESTRICTED | SAFE }
    | COST <replaceable class="parameter">execution_cost</replaceable>
    | ROWS <replaceable class="parameter">result_rows</replaceable>
    | SUPPORT <replaceable class="parameter">support_function</replaceable>
    | SET <replaceable class="parameter">configuration_parameter</replaceable> { TO <replaceable class="parameter">value</replaceable> | = <replaceable class="parameter">value</replaceable> | FROM CURRENT }
    | AS '<replaceable class="parameter">definition</replaceable>'
    | AS '<replaceable class="parameter">obj_file</replaceable>', '<replaceable class="parameter">link_symbol</replaceable>'
    | <replaceable class="parameter">sql_body</replaceable>
  } ...
</synopsis>
 </refsynopsisdiv>

 <refsect1 id="sql-createfunction-description">
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <command>CREATE FUNCTION</command> defines a new function.
   <command>CREATE OR REPLACE FUNCTION</command> will either create a
   new function, or replace an existing definition.
   To be able to define a function, the user must have the
   <literal>USAGE</literal> privilege on the language.
  </para>
____________________________________________________________________________-->
  <para>
   <command>CREATE FUNCTION</command>定义一个新函数。<command>CREATE OR REPLACE FUNCTION</command>将创建一个新函数或者替换一个现有的函数。要定义一个函数，用户必须具有该语言上的<literal>USAGE</literal>特权。
  </para>

<!--==========================orignal english content==========================
  <para>
   If a schema name is included, then the function is created in the
   specified schema.  Otherwise it is created in the current schema.
   The name of the new function must not match any existing function or procedure
   with the same input argument types in the same schema.  However,
   functions and procedures of different argument types can share a name (this is
   called <firstterm>overloading</firstterm>).
  </para>
____________________________________________________________________________-->
  <para>
   如果包括了一个模式名，那么该函数会被创建在指定的模式中。否则，它会被创建在当前模式中。新函数的名称不能匹配同一个模式中具有相同输入参数类型的任何现有函数或过程。不过，不同参数类型的函数和过程能够共享一个名字（这被称作<firstterm>重载</firstterm>）。
  </para>

<!--==========================orignal english content==========================
  <para>
   To replace the current definition of an existing function, use
   <command>CREATE OR REPLACE FUNCTION</command>.  It is not possible
   to change the name or argument types of a function this way (if you
   tried, you would actually be creating a new, distinct function).
   Also, <command>CREATE OR REPLACE FUNCTION</command> will not let
   you change the return type of an existing function.  To do that,
   you must drop and recreate the function.  (When using <literal>OUT</literal>
   parameters, that means you cannot change the types of any
   <literal>OUT</literal> parameters except by dropping the function.)
  </para>
____________________________________________________________________________-->
  <para>
   要替换一个现有函数的当前定义，可以使用<command>CREATE OR REPLACE FUNCTION</command>。但不能用这种方式更改函数的名称或者参数类型（如果尝试这样做，实际上就会创建一个新的不同的函数）。还有，<command>CREATE OR REPLACE FUNCTION</command>将不会让你更改一个现有函数的返回类型。要这样做，你必须先删除再重建该函数（在使用<literal>OUT</literal>参数时，这意味着除了删除函数之外无法更改任何<literal>OUT</literal>参数的类型）。
  </para>

<!--==========================orignal english content==========================
  <para>
   When <command>CREATE OR REPLACE FUNCTION</command> is used to replace an
   existing function, the ownership and permissions of the function
   do not change.  All other function properties are assigned the
   values specified or implied in the command.  You must own the function
   to replace it (this includes being a member of the owning role).
  </para>
____________________________________________________________________________-->
  <para>
   当<command>CREATE OR REPLACE FUNCTION</command>被用来替换一个现有的函数，该函数的拥有权和权限不会改变。所有其他的函数属性会按照该命令中所指定的或者隐含的来赋值。必须拥有（包括成为拥有角色的成员）该函数才能替换它。
  </para>

<!--==========================orignal english content==========================
  <para>
   If you drop and then recreate a function, the new function is not
   the same entity as the old; you will have to drop existing rules, views,
   triggers, etc. that refer to the old function.  Use
   <command>CREATE OR REPLACE FUNCTION</command> to change a function
   definition without breaking objects that refer to the function.
   Also, <command>ALTER FUNCTION</command> can be used to change most of the
   auxiliary properties of an existing function.
  </para>
____________________________________________________________________________-->
  <para>
   如果你删除并且重建一个函数，新函数将和旧的不一样，你将必须删掉引用旧函数的现有规则、视图、触发器等。使用<command>CREATE OR REPLACE FUNCTION</command>更改一个函数定义不会破坏引用该函数的对象。还有，<command>ALTER FUNCTION</command>可以被用来更改一个现有函数的大部分辅助属性。
  </para>

<!--==========================orignal english content==========================
  <para>
   The user that creates the function becomes the owner of the function.
  </para>
____________________________________________________________________________-->
  <para>
   创建该函数的用户将成为该函数的拥有者。
  </para>

<!--==========================orignal english content==========================
  <para>
   To be able to create a function, you must have <literal>USAGE</literal>
   privilege on the argument types and the return type.
  </para>
____________________________________________________________________________-->
  <para>
   要创建一个函数，你必须拥有参数类型和返回类型上的<literal>USAGE</literal>特权。
  </para>

<!--==========================orignal english content==========================
  <para>
   Refer to <xref linkend="xfunc"/> for further information on writing
   functions.
  </para>
____________________________________________________________________________-->
  <para>
   有关编写函数的详细信息，请参阅<xref linkend="xfunc"/>。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Parameters</title>
____________________________________________________________________________-->
  <title>参数</title>

   <variablelist>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><replaceable class="parameter">name</replaceable></term>
____________________________________________________________________________-->
     <term><replaceable class="parameter">name</replaceable></term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       The name (optionally schema-qualified) of the function to create.
      </para>
____________________________________________________________________________-->
      <para>
       要创建的函数的名称（可以被模式限定）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><replaceable class="parameter">argmode</replaceable></term>
____________________________________________________________________________-->
     <term><replaceable class="parameter">argmode</replaceable></term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       The mode of an argument: <literal>IN</literal>, <literal>OUT</literal>,
       <literal>INOUT</literal>, or <literal>VARIADIC</literal>.
       If omitted, the default is <literal>IN</literal>.
       Only <literal>OUT</literal> arguments can follow a <literal>VARIADIC</literal> one.
       Also, <literal>OUT</literal> and <literal>INOUT</literal> arguments cannot be used
       together with the <literal>RETURNS TABLE</literal> notation.
      </para>
____________________________________________________________________________-->
      <para>
       一个参数的模式：<literal>IN</literal>、<literal>OUT</literal>、<literal>INOUT</literal>或者<literal>VARIADIC</literal>。如果省略，默认为<literal>IN</literal>。只有<literal>OUT</literal>参数能跟在一个<literal>VARIADIC</literal>参数后面。还有，<literal>OUT</literal>和<literal>INOUT</literal>参数不能和<literal>RETURNS TABLE</literal>符号一起使用。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><replaceable class="parameter">argname</replaceable></term>
____________________________________________________________________________-->
     <term><replaceable class="parameter">argname</replaceable></term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       The name of an argument. Some languages (including SQL and PL/pgSQL)
       let you use the name in the function body.  For other languages the
       name of an input argument is just extra documentation, so far as
       the function itself is concerned; but you can use input argument names
       when calling a function to improve readability (see <xref
       linkend="sql-syntax-calling-funcs"/>).  In any case, the name
       of an output argument is significant, because it defines the column
       name in the result row type.  (If you omit the name for an output
       argument, the system will choose a default column name.)
      </para>
____________________________________________________________________________-->
      <para>
       一个参数的名称。一些语言（包括 SQL 和 PL/pgSQL）让你在函数体中使用该名称。对于其他语言，一个输入参数的名字只是额外的文字（就该函数本身所关心的来说）。但是你可以在调用一个函数时使用输入参数名来提高可读性（见<xref linkend="sql-syntax-calling-funcs"/>）。在任何情况下，输出参数的名称是有意义的，因为它定义了结果行类型中的列名（如果忽略一个输出参数的名称，系统将选择一个默认的列名）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><replaceable class="parameter">argtype</replaceable></term>
____________________________________________________________________________-->
     <term><replaceable class="parameter">argtype</replaceable></term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       The data type(s) of the function's arguments (optionally
       schema-qualified), if any. The argument types can be base, composite,
       or domain types, or can reference the type of a table column.
      </para>
____________________________________________________________________________-->
      <para>
       该函数参数（如果有）的数据类型（可以是模式限定的）。参数类型可以是基本类型、组合类型或者域类型，或者可以引用一个表列的类型。
      </para>
<!--==========================orignal english content==========================
      <para>
       Depending on the implementation language it might also be allowed
       to specify <quote>pseudo-types</quote> such as <type>cstring</type>.
       Pseudo-types indicate that the actual argument type is either
       incompletely specified, or outside the set of ordinary SQL data types.
      </para>
____________________________________________________________________________-->
      <para>
       根据实现语言，也可以允许指定<type>cstring</type>之类的<quote>伪类型</quote>。伪类型表示实际参数类型没有被完整指定或者不属于普通 SQL 数据类型集合。
      </para>
<!--==========================orignal english content==========================
      <para>
       The type of a column is referenced by writing
       <literal><replaceable
       class="parameter">table_name</replaceable>.<replaceable
       class="parameter">column_name</replaceable>%TYPE</literal>.
       Using this feature can sometimes help make a function independent of
       changes to the definition of a table.
      </para>
____________________________________________________________________________-->
      <para>
       可以写<literal><replaceable class="parameter">table_name</replaceable>.<replaceable class="parameter">column_name</replaceable>%TYPE</literal>来引用一列的类型。使用这种特性有时可以帮助创建一个不受表定义更改影响的函数。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><replaceable class="parameter">default_expr</replaceable></term>
____________________________________________________________________________-->
     <term><replaceable class="parameter">default_expr</replaceable></term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       An expression to be used as default value if the parameter is
       not specified.  The expression has to be coercible to the
       argument type of the parameter.
       Only input (including <literal>INOUT</literal>) parameters can have a default
        value.  All input parameters following a
       parameter with a default value must have default values as well.
      </para>
____________________________________________________________________________-->
      <para>
       如果参数没有被指定值时要用作默认值的表达式。该表达式必须能被强制为该参数的参数类型。只有输入（包括<literal>INOUT</literal>）参数可以具有默认值。所有跟随在一个具有默认值的参数之后的输入参数也必须有默认值。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><replaceable class="parameter">rettype</replaceable></term>
____________________________________________________________________________-->
     <term><replaceable class="parameter">rettype</replaceable></term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       The return data type (optionally schema-qualified). The return type
       can be a base, composite, or domain type,
       or can reference the type of a table column.
       Depending on the implementation language it might also be allowed
       to specify <quote>pseudo-types</quote> such as <type>cstring</type>.
       If the function is not supposed to return a value, specify
       <type>void</type> as the return type.
      </para>
____________________________________________________________________________-->
      <para>
       返回数据类型（可能被模式限定）。返回类型可以是一种基本类型、组合类型或者域类型，也可以引用一个表列的类型。根据实现语言，也可以允许指定<type>cstring</type>之类的<quote>伪类型</quote>。如果该函数不会返回一个值，可以指定返回类型为<type>void</type>。
      </para>
<!--==========================orignal english content==========================
      <para>
       When there are <literal>OUT</literal> or <literal>INOUT</literal> parameters,
       the <literal>RETURNS</literal> clause can be omitted.  If present, it
       must agree with the result type implied by the output parameters:
       <literal>RECORD</literal> if there are multiple output parameters, or
       the same type as the single output parameter.
      </para>
____________________________________________________________________________-->
      <para>
       当有<literal>OUT</literal>或者<literal>INOUT</literal>参数时，可以省略<literal>RETURNS</literal>子句。如果存在，该子句必须和输出参数所表示的结果类型一致：如果有多个输出参数，则为<literal>RECORD</literal>，否则与单个输出参数的类型相同。
      </para>
<!--==========================orignal english content==========================
      <para>
       The <literal>SETOF</literal>
       modifier indicates that the function will return a set of
       items, rather than a single item.
      </para>
____________________________________________________________________________-->
      <para>
       <literal>SETOF</literal>修饰符表示该函数将返回一个项的集合而不是一个单一项。
      </para>
<!--==========================orignal english content==========================
      <para>
       The type of a column is referenced by writing
       <literal><replaceable
       class="parameter">table_name</replaceable>.<replaceable
       class="parameter">column_name</replaceable>%TYPE</literal>.
      </para>
____________________________________________________________________________-->
      <para>
       可以写<literal><replaceable class="parameter">table_name</replaceable>.<replaceable class="parameter">column_name</replaceable>%TYPE</literal>来引用一列的类型。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><replaceable class="parameter">column_name</replaceable></term>
____________________________________________________________________________-->
     <term><replaceable class="parameter">column_name</replaceable></term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       The name of an output column in the <literal>RETURNS TABLE</literal>
       syntax.  This is effectively another way of declaring a named
       <literal>OUT</literal> parameter, except that <literal>RETURNS TABLE</literal>
       also implies <literal>RETURNS SETOF</literal>.
      </para>
____________________________________________________________________________-->
      <para>
       <literal>RETURNS TABLE</literal>语法中一个输出列的名称。这实际上是另一种声明<literal>OUT</literal>参数的方法，不过<literal>RETURNS TABLE</literal>也隐含了<literal>RETURNS SETOF</literal>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><replaceable class="parameter">column_type</replaceable></term>
____________________________________________________________________________-->
     <term><replaceable class="parameter">column_type</replaceable></term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       The data type of an output column in the <literal>RETURNS TABLE</literal>
       syntax.
      </para>
____________________________________________________________________________-->
      <para>
       <literal>RETURNS TABLE</literal>语法中的输出列的数据类型。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><replaceable class="parameter">lang_name</replaceable></term>
____________________________________________________________________________-->
     <term><replaceable class="parameter">lang_name</replaceable></term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       The name of the language that the function is implemented in.
       It can be <literal>sql</literal>, <literal>c</literal>,
       <literal>internal</literal>, or the name of a user-defined
       procedural language, e.g., <literal>plpgsql</literal>.  The default is
       <literal>sql</literal> if <replaceable
       class="parameter">sql_body</replaceable> is specified.  Enclosing the
       name in single quotes is deprecated and requires matching case.
      </para>
____________________________________________________________________________-->
      <para>
       用以实现该函数的语言的名称。可以是<literal>sql</literal>、<literal>c</literal>、
       <literal>internal</literal>或者一个用户定义的过程语言的名称，例如<literal>plpgsql</literal>。
       如果指定了<replaceable class="parameter">sql_body</replaceable>，
       则默认值为<literal>sql</literal>。不推荐使用单引号将名称括起来，并要求大小写匹配。
      </para>
     </listitem>
    </varlistentry>
    
    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal>TRANSFORM { FOR TYPE <replaceable class="parameter">type_name</replaceable> } [, ... ] }</literal></term>
____________________________________________________________________________-->
     <term><literal>TRANSFORM { FOR TYPE <replaceable class="parameter">type_name</replaceable> } [, ... ] }</literal></term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       Lists which transforms a call to the function should apply.  Transforms
       convert between SQL types and language-specific data types;
       see <xref linkend="sql-createtransform"/>.  Procedural language
       implementations usually have hardcoded knowledge of the built-in types,
       so those don't need to be listed here.  If a procedural language
       implementation does not know how to handle a type and no transform is
       supplied, it will fall back to a default behavior for converting data
       types, but this depends on the implementation.
      </para>
____________________________________________________________________________-->
      <para>
       一个由转换构成的列表，对该函数的调用适用于它们。转换在 SQL 类型和语言相关的数据类型之间进行变换，详见<xref linkend="sql-createtransform"/>。过程语言实现通常把有关内建类型的知识硬编码在代码中，因此那些不需要列举在这里。如果一种过程语言实现不知道如何处理一种类型并且没有转换被提供，它将回退到一种默认的行为来转换数据类型，但是这取决于具体实现。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal>WINDOW</literal></term>
____________________________________________________________________________-->
     <term><literal>WINDOW</literal></term>

     <listitem>
<!--==========================orignal english content==========================
      <para><literal>WINDOW</literal> indicates that the function is a
       <firstterm>window function</firstterm> rather than a plain function.
       This is currently only useful for functions written in C.
       The <literal>WINDOW</literal> attribute cannot be changed when
       replacing an existing function definition.
      </para>
____________________________________________________________________________-->
      <para><literal>WINDOW</literal>表示该函数是一个<firstterm>窗口函数</firstterm>而不是一个普通函数。当前只用于用 C 编写的函数。在替换一个现有函数定义时，不能更改<literal>WINDOW</literal>属性。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal>IMMUTABLE</literal></term>
____________________________________________________________________________-->
     <term><literal>IMMUTABLE</literal></term>
<!--==========================orignal english content==========================
     <term><literal>STABLE</literal></term>
____________________________________________________________________________-->
     <term><literal>STABLE</literal></term>
<!--==========================orignal english content==========================
     <term><literal>VOLATILE</literal></term>
____________________________________________________________________________-->
     <term><literal>VOLATILE</literal></term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       These attributes inform the query optimizer about the behavior
       of the function.  At most one choice
       can be specified.  If none of these appear,
       <literal>VOLATILE</literal> is the default assumption.
      </para>
____________________________________________________________________________-->
      <para>
       这些属性告知查询优化器该函数的行为。最多只能指定其中一个。如果这些都不出现，则会默认为<literal>VOLATILE</literal>。
      </para>

<!--==========================orignal english content==========================
      <para><literal>IMMUTABLE</literal> indicates that the function
       cannot modify the database and always
       returns the same result when given the same argument values; that
       is, it does not do database lookups or otherwise use information not
       directly present in its argument list.  If this option is given,
       any call of the function with all-constant arguments can be
       immediately replaced with the function value.
      </para>
____________________________________________________________________________-->
      <para><literal>IMMUTABLE</literal>表示该函数不能修改数据库并且对于给定的参数值总是会返回相同的值。也就是说，它不会做数据库查找或者使用没有在其参数列表中直接出现的信息。如果给定合格选项，任何用全常量参数对该函数的额调用可以立刻用该函数值替换。
      </para>

<!--==========================orignal english content==========================
      <para><literal>STABLE</literal> indicates that the function
       cannot modify the database,
       and that within a single table scan it will consistently
       return the same result for the same argument values, but that its
       result could change across SQL statements.  This is the appropriate
       selection for functions whose results depend on database lookups,
       parameter variables (such as the current time zone), etc.  (It is
       inappropriate for <literal>AFTER</literal> triggers that wish to
       query rows modified by the current command.)  Also note
       that the <function>current_timestamp</function> family of functions qualify
       as stable, since their values do not change within a transaction.
      </para>
____________________________________________________________________________-->
      <para><literal>STABLE</literal>表示该函数不能修改数据库，并且对于相同的参数值，它在一次表扫描中将返回相同的结果。但是这种结果在不同的 SQL 语句执行期间可能会变化。对于那些结果依赖于数据库查找、参数变量（例如当前时区）等的函数来说，这是合适的（对希望查询被当前命令修改的行的<literal>AFTER</literal>触发器不适合）。还要注意<function>current_timestamp</function>函数族适合被标记为稳定，因为它们的值在一个事务内不会改变。
      </para>

<!--==========================orignal english content==========================
      <para><literal>VOLATILE</literal> indicates that the function value can
       change even within a single table scan, so no optimizations can be
       made.  Relatively few database functions are volatile in this sense;
       some examples are <literal>random()</literal>, <literal>currval()</literal>,
       <literal>timeofday()</literal>.  But note that any function that has
       side-effects must be classified volatile, even if its result is quite
       predictable, to prevent calls from being optimized away; an example is
       <literal>setval()</literal>.
      </para>
____________________________________________________________________________-->
      <para><literal>VOLATILE</literal>表示该函数的值在一次表扫描中都有可能改变，因此不能做优化。在这种意义上，相对较少的数据库函数是不稳定的，一些例子是<literal>random()</literal>、<literal>currval()</literal>、<literal>timeofday()</literal>。但是注意任何有副作用的函数都必须被分类为不稳定的，即便其结果是可以预测的，这是为了调用被优化掉。一个例子是<literal>setval()</literal>。
      </para>

<!--==========================orignal english content==========================
      <para>
       For additional details see <xref linkend="xfunc-volatility"/>.
      </para>
____________________________________________________________________________-->
      <para>
       更多细节可见<xref linkend="xfunc-volatility"/>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal>LEAKPROOF</literal></term>
____________________________________________________________________________-->
     <term><literal>LEAKPROOF</literal></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       <literal>LEAKPROOF</literal> indicates that the function has no side
       effects.  It reveals no information about its arguments other than by
       its return value.  For example, a function which throws an error message
       for some argument values but not others, or which includes the argument
       values in any error message, is not leakproof.  This affects how the
       system executes queries against views created with the
       <literal>security_barrier</literal> option or tables with row level
       security enabled.  The system will enforce conditions from security
       policies and security barrier views before any user-supplied conditions
       from the query itself that contain non-leakproof functions, in order to
       prevent the inadvertent exposure of data.  Functions and operators
       marked as leakproof are assumed to be trustworthy, and may be executed
       before conditions from security policies and security barrier views.
       In addition, functions which do not take arguments or which are not
       passed any arguments from the security barrier view or table do not have
       to be marked as leakproof to be executed before security conditions.  See
       <xref linkend="sql-createview"/> and <xref linkend="rules-privileges"/>.
       This option can only be set by the superuser.
      </para>
____________________________________________________________________________-->
      <para>
       <literal>LEAKPROOF</literal>表示该函数没有副作用。它不会泄露有关其参数的信息（除了通过返回值）。例如，一个只对某些参数值抛出错误消息而对另外一些却不抛出错误的函数不是防泄漏的，一个把参数值包括在任何错误消息中的函数也不是防泄漏的。这会影响系统如何执行在使用<literal>security_barrier</literal>选项创建的视图或者开启了行级安全性的表上执行查询。对于包含有非防泄漏函数的查询，系统将在任何来自查询本身的用户提供条件之前强制来自安全策略或者安全屏障的条件，防止无意中的数据暴露。被标记为防泄漏的函数和操作符被假定是可信的，并且可以在安全性策略和安全性屏障视图的条件之前被执行。此外，没有参数的函数或者不从安全屏障视图或表传递任何参数的函数不一定要被标记为防泄漏的。详见<xref linkend="sql-createview"/>和<xref linkend="rules-privileges"/>。这个选项只能由超级用户设置。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal>CALLED ON NULL INPUT</literal></term>
____________________________________________________________________________-->
     <term><literal>CALLED ON NULL INPUT</literal></term>
<!--==========================orignal english content==========================
     <term><literal>RETURNS NULL ON NULL INPUT</literal></term>
____________________________________________________________________________-->
     <term><literal>RETURNS NULL ON NULL INPUT</literal></term>
<!--==========================orignal english content==========================
     <term><literal>STRICT</literal></term>
____________________________________________________________________________-->
     <term><literal>STRICT</literal></term>

     <listitem>
<!--==========================orignal english content==========================
      <para><literal>CALLED ON NULL INPUT</literal> (the default) indicates
       that the function will be called normally when some of its
       arguments are null.  It is then the function author's
       responsibility to check for null values if necessary and respond
       appropriately.
      </para>
____________________________________________________________________________-->
      <para><literal>CALLED ON NULL INPUT</literal>（默认）表示在某些参数为空值时应正常调用该函数。如果有必要，函数的作者应该负责检查空值并且做出适当的相应。
      </para>

<!--==========================orignal english content==========================
      <para><literal>RETURNS NULL ON NULL INPUT</literal> or
       <literal>STRICT</literal> indicates that the function always
       returns null whenever any of its arguments are null.  If this
       parameter is specified, the function is not executed when there
       are null arguments; instead a null result is assumed
       automatically.
      </para>
____________________________________________________________________________-->
      <para><literal>RETURNS NULL ON NULL INPUT</literal>或<literal>STRICT</literal>表示只要其任意参数为空值，该函数就会返回空值。如果指定了这个参数，当有空值参数时该函数不会被执行，而是自动返回一个空值结果。
      </para>
     </listitem>
    </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal><optional>EXTERNAL</optional> SECURITY INVOKER</literal></term>
____________________________________________________________________________-->
    <term><literal><optional>EXTERNAL</optional> SECURITY INVOKER</literal></term>
<!--==========================orignal english content==========================
    <term><literal><optional>EXTERNAL</optional> SECURITY DEFINER</literal></term>
____________________________________________________________________________-->
    <term><literal><optional>EXTERNAL</optional> SECURITY DEFINER</literal></term>

    <listitem>
<!--==========================orignal english content==========================
     <para><literal>SECURITY INVOKER</literal> indicates that the function
      is to be executed with the privileges of the user that calls it.
      That is the default.  <literal>SECURITY DEFINER</literal>
      specifies that the function is to be executed with the
      privileges of the user that owns it.
     </para>
____________________________________________________________________________-->
     <para><literal>SECURITY INVOKER</literal>表示要用调用该函数的用户的特权来执行它。这是默认值。<literal>SECURITY DEFINER</literal>指定要用拥有该函数的用户的特权来执行该函数。
     </para>

<!--==========================orignal english content==========================
     <para>
      The key word <literal>EXTERNAL</literal> is allowed for SQL
      conformance, but it is optional since, unlike in SQL, this feature
      applies to all functions not only external ones.
     </para>
____________________________________________________________________________-->
     <para>
      为了符合 SQL，允许使用关键词<literal>EXTERNAL</literal>。但是它是可选的，因为与 SQL 中不同，这个特性适用于所有函数而不仅是那些外部函数。
     </para>
    </listitem>
   </varlistentry>
   
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>PARALLEL</literal></term>
____________________________________________________________________________-->
    <term><literal>PARALLEL</literal></term>

    <listitem>
<!--==========================orignal english content==========================
     <para><literal>PARALLEL UNSAFE</literal> indicates that the function
      can't be executed in parallel mode and the presence of such a
      function in an SQL statement forces a serial execution plan.  This is
      the default.  <literal>PARALLEL RESTRICTED</literal> indicates that
      the function can be executed in parallel mode, but the execution is
      restricted to parallel group leader.  <literal>PARALLEL SAFE</literal>
      indicates that the function is safe to run in parallel mode without
      restriction.
     </para>
____________________________________________________________________________-->
     <para><literal>PARALLEL UNSAFE</literal>表示该函数不能在并行模式中运行并且 SQL 语句中存在一个这样的函数会强制使用顺序执行计划。这是默认选项。<literal>PARALLEL RESTRICTED</literal>表示该函数能在并行模式中运行，但是其执行被限制在并行组的领导者中。<literal>PARALLEL SAFE</literal>表示该函数对于在并行模式中运行是安全的并且不受限制。
     </para>

<!--==========================orignal english content==========================
     <para>
      Functions should be labeled parallel unsafe if they modify any database
      state, or if they make changes to the transaction such as using
      sub-transactions, or if they access sequences or attempt to make
      persistent changes to settings (e.g., <literal>setval</literal>).  They should
      be labeled as parallel restricted if they access temporary tables,
      client connection state, cursors, prepared statements, or miscellaneous
      backend-local state which the system cannot synchronize in parallel mode
      (e.g.,  <literal>setseed</literal> cannot be executed other than by the group
      leader because a change made by another process would not be reflected
      in the leader).  In general, if a function is labeled as being safe when
      it is restricted or unsafe, or if it is labeled as being restricted when
      it is in fact unsafe, it may throw errors or produce wrong answers
      when used in a parallel query.  C-language functions could in theory
      exhibit totally undefined behavior if mislabeled, since there is no way
      for the system to protect itself against arbitrary C code, but in most
      likely cases the result will be no worse than for any other function.
      If in doubt, functions should be labeled as <literal>UNSAFE</literal>, which is
      the default.
     </para>
____________________________________________________________________________-->
     <para>
      如果函数修改任何数据库状态、会使用子事务之类的方式改变事务、访问序列或者对设置（如<literal>setval</literal>）做出持久性的更改，它们就应该被标记为并行不安全。如果它们访问临时表、客户端连接状态、游标、预备语句或者系统无法在并行模式中同步的本地后端状态（例如<literal>setseed</literal>只能在组领导者中执行，因为另一个进程所作的更改不会在领导者中被反映出来），它们应该被标为并行受限。通常，如果一个函数是受限的或者不安全的却被标成了安全，或者它本来是不安全的却被标成了受限，在并行查询中执行时它可能会抛出错误或者产生错误的答案。如果被错误的标记， C 语言函数理论上可能展现出完全无法定义的行为，因为系统没有办法保护自己不受任意的 C 代码影响，但是在大部分情况下其结果也不会比任何其他函数差到哪里去。如果有疑问，函数应该被标为<literal>UNSAFE</literal>，这也是默认值。
     </para>
    </listitem>
   </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal>COST</literal> <replaceable class="parameter">execution_cost</replaceable></term>
____________________________________________________________________________-->
     <term><literal>COST</literal> <replaceable class="parameter">execution_cost</replaceable></term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       A positive number giving the estimated execution cost for the function,
       in units of <xref linkend="guc-cpu-operator-cost"/>.  If the function
       returns a set, this is the cost per returned row.  If the cost is
       not specified, 1 unit is assumed for C-language and internal functions,
       and 100 units for functions in all other languages.  Larger values
       cause the planner to try to avoid evaluating the function more often
       than necessary.
      </para>
____________________________________________________________________________-->
      <para>
       一个给出该函数的估计执行代价的正数，单位是<xref linkend="guc-cpu-operator-cost"/>。如果该函数返回一个集合，这就是每个被返回行的代价。如果没有指定代价，对 C 语言和内部函数会指定为 1 个单位，对其他语言的函数则会指定为 100 单位。更大的值会导致规划器尝试避免对该函数的不必要的过多计算。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal>ROWS</literal> <replaceable class="parameter">result_rows</replaceable></term>
____________________________________________________________________________-->
     <term><literal>ROWS</literal> <replaceable class="parameter">result_rows</replaceable></term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       A positive number giving the estimated number of rows that the planner
       should expect the function to return.  This is only allowed when the
       function is declared to return a set.  The default assumption is
       1000 rows.
      </para>
____________________________________________________________________________-->
      <para>
       一个正数，它给出规划器期望该函数返回的行数估计。只有当该函数被声明为返回一个集合时才允许这个参数。默认假设为 1000 行。
      </para>
     </listitem>
    </varlistentry>


    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal>SUPPORT</literal> <replaceable class="parameter">support_function</replaceable></term>
____________________________________________________________________________-->
     <term><literal>SUPPORT</literal> <replaceable class="parameter">support_function</replaceable></term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       The name (optionally schema-qualified) of a <firstterm>planner support
       function</firstterm> to use for this function.  See
       <xref linkend="xfunc-optimization"/> for details.
       You must be superuser to use this option.
      </para>
____________________________________________________________________________-->
      <para>
       用于此函数的<firstterm>planner support function</firstterm>的名称（可选的模式限定）。
       详请参见<xref linkend="xfunc-optimization"/>。你必须是超级用户才能使用此选项。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><replaceable>configuration_parameter</replaceable></term>
____________________________________________________________________________-->
     <term><replaceable>configuration_parameter</replaceable></term>
<!--==========================orignal english content==========================
     <term><replaceable>value</replaceable></term>
____________________________________________________________________________-->
     <term><replaceable>value</replaceable></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       The <literal>SET</literal> clause causes the specified configuration
       parameter to be set to the specified value when the function is
       entered, and then restored to its prior value when the function exits.
       <literal>SET FROM CURRENT</literal> saves the value of the parameter that
       is current when <command>CREATE FUNCTION</command> is executed as the value
       to be applied when the function is entered.
      </para>
____________________________________________________________________________-->
      <para>
       <literal>SET</literal>子句导致进入该函数时指定配置参数将被设置为指定值。并且在该函数退出时恢复到该参数之前的值。<literal>SET FROM CURRENT</literal>会把<command>CREATE FUNCTION</command>被执行时该参数的当前值保存为进入该函数时将被应用的值。
      </para>

<!--==========================orignal english content==========================
      <para>
       If a <literal>SET</literal> clause is attached to a function, then
       the effects of a <command>SET LOCAL</command> command executed inside the
       function for the same variable are restricted to the function: the
       configuration parameter's prior value is still restored at function exit.
       However, an ordinary
       <command>SET</command> command (without <literal>LOCAL</literal>) overrides the
       <literal>SET</literal> clause, much as it would do for a previous <command>SET
       LOCAL</command> command: the effects of such a command will persist after
       function exit, unless the current transaction is rolled back.
      </para>
____________________________________________________________________________-->
      <para>
       如果一个<literal>SET</literal>子句被附加到一个函数，那么在该函数内为同一个变量执行的<command>SET LOCAL</command>命令会被限制于该函数：在函数退出时该配置参数之前的值仍会被恢复。不过，一个普通的<command>SET</command>命令（没有<literal>LOCAL</literal>）会覆盖<literal>SET</literal>子句，更像一个之前的<command>SET LOCAL</command>命令所做的那样：这种命令的效果在函数退出后将会持续，除非当前事务被回滚。
      </para>

<!--==========================orignal english content==========================
      <para>
       See <xref linkend="sql-set"/> and
       <xref linkend="runtime-config"/>
       for more information about allowed parameter names and values.
      </para>
____________________________________________________________________________-->
      <para>
       更多有关允许的参数名和参数值的信息请见<xref linkend="sql-set"/>和<xref linkend="runtime-config"/>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><replaceable class="parameter">definition</replaceable></term>
____________________________________________________________________________-->
     <term><replaceable class="parameter">definition</replaceable></term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       A string constant defining the function; the meaning depends on the
       language.  It can be an internal function name, the path to an
       object file, an SQL command, or text in a procedural language.
      </para>
____________________________________________________________________________-->
      <para>
       一个定义该函数的字符串常量，其含义取决于语言。它可以是一个内部函数名、一个对象文件的路径、一个 SQL 命令或者用一种过程语言编写的文本。
      </para>

<!--==========================orignal english content==========================
      <para>
       It is often helpful to use dollar quoting (see <xref
       linkend="sql-syntax-dollar-quoting"/>) to write the function definition
       string, rather than the normal single quote syntax.  Without dollar
       quoting, any single quotes or backslashes in the function definition must
       be escaped by doubling them.
      </para>
____________________________________________________________________________-->
      <para>
       美元引用<xref linkend="sql-syntax-dollar-quoting"/>通常对书写函数定义字符串有所帮助，而普通单引号语法则不会有用。如果没有美元引用，函数定义中的任何单引号或者反斜线必须用双写来转义。
      </para>

     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal><replaceable class="parameter">obj_file</replaceable>, <replaceable class="parameter">link_symbol</replaceable></literal></term>
____________________________________________________________________________-->
     <term><literal><replaceable class="parameter">obj_file</replaceable>, <replaceable class="parameter">link_symbol</replaceable></literal></term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       This form of the <literal>AS</literal> clause is used for
       dynamically loadable C language functions when the function name
       in the C language source code is not the same as the name of
       the SQL function. The string <replaceable
       class="parameter">obj_file</replaceable> is the name of the shared
       library file containing the compiled C function, and is interpreted
       as for the <link linkend="sql-load"><command>LOAD</command></link> command.  The string
       <replaceable class="parameter">link_symbol</replaceable> is the
       function's link symbol, that is, the name of the function in the C
       language source code.  If the link symbol is omitted, it is assumed to
       be the same as the name of the SQL function being defined.  The C names
       of all functions must be different, so you must give overloaded C
       functions different C names (for example, use the argument types as
       part of the C names).
      </para>
____________________________________________________________________________-->
      <para>
       当 C 语言源代码中该函数的名称与 SQL 函数的名称不同时，这种形式的<literal>AS</literal>子句被用于动态可载入 C 语言函数。
       字符串<replaceable class="parameter">obj_file</replaceable>是包含编译好的C函数的动态库文件的名称，
       它会由<link linkend="sql-load"><command>LOAD</command></link>命令解析。
       字符串<replaceable class="parameter">link_symbol</replaceable>是该函数的链接符号，也就是该函数在 C 语言源代码中的名称。如果省略链接符号，它将被假定为要定义的 SQL 函数的名称。所有函数的C名称都必须不同，因此必须为重载的C函数给出不同的C名称（例如把参数类型作为C名称的一部分）。
      </para>

<!--==========================orignal english content==========================
      <para>
       When repeated <command>CREATE FUNCTION</command> calls refer to
       the same object file, the file is only loaded once per session.
       To unload and
       reload the file (perhaps during development), start a new session.
      </para>
____________________________________________________________________________-->
      <para>
       在重复调用引用同一对象文件的<command>CREATE FUNCTION</command>时，对每个会话该文件只会被载入一次。要卸载并且重新装载该文件（可能是在开发期间），需要开始一个新会话。
      </para>

     </listitem>
    </varlistentry>
    <varlistentry>
<!--==========================orignal english content==========================
     <term><replaceable class="parameter">sql_body</replaceable></term>
____________________________________________________________________________-->
     <term><replaceable class="parameter">sql_body</replaceable></term>

     <listitem>
<!--==========================orignal english content==========================
      <para>
       The body of a <literal>LANGUAGE SQL</literal> function.  This can
       either be a single statement
<programlisting>
RETURN <replaceable>expression</replaceable>
</programlisting>
       or a block
<programlisting>
BEGIN ATOMIC
  <replaceable>statement</replaceable>;
  <replaceable>statement</replaceable>;
  ...
  <replaceable>statement</replaceable>;
END
</programlisting>
      </para>
____________________________________________________________________________-->
      <para>
       <literal>LANGUAGE SQL</literal>函数的主体。
       这可以是单个语句
<programlisting>
RETURN <replaceable>expression</replaceable>
</programlisting>
       或者一个语句块
<programlisting>
BEGIN ATOMIC
  <replaceable>statement</replaceable>;
  <replaceable>statement</replaceable>;
  ...
  <replaceable>statement</replaceable>;
END
</programlisting>
      </para>

<!--==========================orignal english content==========================
      <para>
       This is similar to writing the text of the function body as a string
       constant (see <replaceable>definition</replaceable> above), but there
       are some differences: This form only works for <literal>LANGUAGE
       SQL</literal>, the string constant form works for all languages.  This
       form is parsed at function definition time, the string constant form is
       parsed at execution time; therefore this form cannot support
       polymorphic argument types and other constructs that are not resolvable
       at function definition time.  This form tracks dependencies between the
       function and objects used in the function body, so <literal>DROP
       ... CASCADE</literal> will work correctly, whereas the form using
       string literals may leave dangling functions.  Finally, this form is
       more compatible with the SQL standard and other SQL implementations.
      </para>
____________________________________________________________________________-->
      <para>
       这类似于将函数体的文本写成字符串常量（请参见上面的<replaceable>definition</replaceable>），
       但有一些不同：此形式仅适用于<literal>LANGUAGE SQL</literal>，字符串常量形式适用于所有语言。
       此形式在函数定义时解析，字符串常量形式在执行时解析；因此，此形式不能支持多态参数类型和其
       他在函数定义时无法解析的构造。
       此形式跟踪函数和函数体中使用的对象之间的依赖关系，因此<literal>DROP ... CASCADE</literal>
       将正常工作，而使用字符串文本的形式可能会留下悬空函数。最后，此形式与SQL标准和其他SQL实现更加兼容。
      </para>
     </listitem>
    </varlistentry>

   </variablelist>
 </refsect1>

 <refsect1 id="sql-createfunction-overloading">
<!--==========================orignal english content==========================
  <title>Overloading</title>
____________________________________________________________________________-->
  <title>重载</title>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</productname> allows function
    <firstterm>overloading</firstterm>; that is, the same name can be
    used for several different functions so long as they have distinct
    input argument types.  Whether or not you use it, this capability entails
    security precautions when calling functions in databases where some users
    mistrust other users; see <xref linkend="typeconv-func"/>.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>允许函数<firstterm>重载</firstterm>，也就是说同一个名称可以被用于多个不同的函数，只要它们具有可区分的输入参数类型。不管是否使用它，在有些用户不信任另一些用户的数据库中调用函数时，这种兼容性需要安全性的预防措施，请参考<xref linkend="typeconv-func"/>。
   </para>

<!--==========================orignal english content==========================
   <para>
    Two functions are considered the same if they have the same names and
    <emphasis>input</emphasis> argument types, ignoring any <literal>OUT</literal>
    parameters.  Thus for example these declarations conflict:
<programlisting>
CREATE FUNCTION foo(int) ...
CREATE FUNCTION foo(int, out text) ...
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    如果两个函数具有相同的名称和<emphasis>输入</emphasis>参数类型，它们被认为相同（不考虑任何<literal>OUT</literal>参数）。因此这些声明会冲突：
<programlisting>
CREATE FUNCTION foo(int) ...
CREATE FUNCTION foo(int, out text) ...
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    Functions that have different argument type lists will not be considered
    to conflict at creation time, but if defaults are provided they might
    conflict in use.  For example, consider
<programlisting>
CREATE FUNCTION foo(int) ...
CREATE FUNCTION foo(int, int default 42) ...
</programlisting>
    A call <literal>foo(10)</literal> will fail due to the ambiguity about which
    function should be called.
   </para>
____________________________________________________________________________-->
   <para>
    具有不同参数类型列表的函数在创建时将不会被认为是冲突的，但是如果默认值被提供，在使用时它们有可能会冲突。例如，考虑
<programlisting>
CREATE FUNCTION foo(int) ...
CREATE FUNCTION foo(int, int default 42) ...
</programlisting>
    调用<literal>foo(10)</literal>将会失败，因为在要决定应该调用哪个函数时会有歧义。
   </para>

 </refsect1>

 <refsect1 id="sql-createfunction-notes">
<!--==========================orignal english content==========================
  <title>Notes</title>
____________________________________________________________________________-->
  <title>注解</title>

<!--==========================orignal english content==========================
   <para>
    The full <acronym>SQL</acronym> type syntax is allowed for
    declaring a function's arguments and return value.  However,
    parenthesized type modifiers (e.g., the precision field for
    type <type>numeric</type>) are discarded by <command>CREATE FUNCTION</command>.
    Thus for example
    <literal>CREATE FUNCTION foo (varchar(10)) ...</literal>
    is exactly the same as
    <literal>CREATE FUNCTION foo (varchar) ...</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    允许把完整的<acronym>SQL</acronym>类型语法用于声明一个函数的参数和返回值。不过，<command>CREATE FUNCTION</command>会抛弃带圆括号的类型修饰符（例如类型<type>numeric</type>的精度域）。例如<literal>CREATE FUNCTION foo (varchar(10)) ...</literal>和<literal>CREATE FUNCTION foo (varchar) ...</literal>完全一样。
   </para>

<!--==========================orignal english content==========================
   <para>
    When replacing an existing function with <command>CREATE OR REPLACE
    FUNCTION</command>, there are restrictions on changing parameter names.
    You cannot change the name already assigned to any input parameter
    (although you can add names to parameters that had none before).
    If there is more than one output parameter, you cannot change the
    names of the output parameters, because that would change the
    column names of the anonymous composite type that describes the
    function's result.  These restrictions are made to ensure that
    existing calls of the function do not stop working when it is replaced.
   </para>
____________________________________________________________________________-->
   <para>
    在用<command>CREATE OR REPLACE FUNCTION</command>替换一个现有函数时，对于更改参数名是有限制的。不能更改已经分配给任何输入参数的名称（不过可以给之前没有名称的参数增加名称）。如果有多于一个输出参数，不能更改输出参数的名称，因为可能会改变描述函数结果的匿名组合类型的列名。这些限制是为了确保函数被替换时，已有的对该函数的调用不会停止工作。
   </para>

<!--==========================orignal english content==========================
   <para>
    If a function is declared <literal>STRICT</literal> with a <literal>VARIADIC</literal>
    argument, the strictness check tests that the variadic array <emphasis>as
    a whole</emphasis> is non-null.  The function will still be called if the
    array has null elements.
   </para>
____________________________________________________________________________-->
   <para>
    如果一个被声明为<literal>STRICT</literal>的函数带有一个<literal>VARIADIC</literal>参数，会严格检查该可变数组<emphasis>作为一个整体</emphasis>是否为非空。如果该数组有空值元素，该函数仍将被调用。
   </para>

 </refsect1>

 <refsect1 id="sql-createfunction-examples">
<!--==========================orignal english content==========================
  <title>Examples</title>
____________________________________________________________________________-->
  <title>示例</title>

<!--==========================orignal english content==========================
  <para>
   Add two integers using an SQL function:
<programlisting>
CREATE FUNCTION add(integer, integer) RETURNS integer
    AS 'select $1 + $2;'
    LANGUAGE SQL
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;
</programlisting>
   The same function written in a more SQL-conforming style, using argument
   names and an unquoted body:
<programlisting>
CREATE FUNCTION add(a integer, b integer) RETURNS integer
    LANGUAGE SQL
    IMMUTABLE
    RETURNS NULL ON NULL INPUT
    RETURN a + b;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   使用SQL函数对两个整数相加：
<programlisting>
CREATE FUNCTION add(integer, integer) RETURNS integer
    AS 'select $1 + $2;'
    LANGUAGE SQL
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;
</programlisting>
   同一个函数以更符合SQL习惯的样式编写，使用参数名称和未加引号的函数体，如下：
<programlisting>
CREATE FUNCTION add(a integer, b integer) RETURNS integer
    LANGUAGE SQL
    IMMUTABLE
    RETURNS NULL ON NULL INPUT
    RETURN a + b;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Increment an integer, making use of an argument name, in
   <application>PL/pgSQL</application>:
<programlisting>
CREATE OR REPLACE FUNCTION increment(i integer) RETURNS integer AS $$
        BEGIN
                RETURN i + 1;
        END;
$$ LANGUAGE plpgsql;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   在<application>PL/pgSQL</application>中，使用一个参数名称增加一个整数：
<programlisting>
CREATE OR REPLACE FUNCTION increment(i integer) RETURNS integer AS $$
        BEGIN
                RETURN i + 1;
        END;
$$ LANGUAGE plpgsql;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Return a record containing multiple output parameters:
<programlisting>
CREATE FUNCTION dup(in int, out f1 int, out f2 text)
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);
</programlisting>
   You can do the same thing more verbosely with an explicitly named
   composite type:
<programlisting>
CREATE TYPE dup_result AS (f1 int, f2 text);

CREATE FUNCTION dup(int) RETURNS dup_result
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);
</programlisting>
   Another way to return multiple columns is to use a <literal>TABLE</literal>
   function:
<programlisting>
CREATE FUNCTION dup(int) RETURNS TABLE(f1 int, f2 text)
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);
</programlisting>
   However, a <literal>TABLE</literal> function is different from the
   preceding examples, because it actually returns a <emphasis>set</emphasis>
   of records, not just one record.
  </para>
____________________________________________________________________________-->
  <para>
   返回一个包含多个输出参数的记录：
<programlisting>
CREATE FUNCTION dup(in int, out f1 int, out f2 text)
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);
</programlisting>
   你可以用更复杂的方式（用一个显式命名的组合类型）来做同样的事情：
<programlisting>
CREATE TYPE dup_result AS (f1 int, f2 text);

CREATE FUNCTION dup(int) RETURNS dup_result
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);
</programlisting>
   另一种返回多列的方法是使用一个<literal>TABLE</literal>函数：
<programlisting>
CREATE FUNCTION dup(int) RETURNS TABLE(f1 int, f2 text)
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);
</programlisting>
   不过，<literal>TABLE</literal>函数与之前的例子不同，因为它实际返回了一个记录<emphasis>集合</emphasis>而不只是一个记录。
  </para>
 </refsect1>

 <refsect1 id="sql-createfunction-security">
<!--==========================orignal english content==========================
  <title>Writing <literal>SECURITY DEFINER</literal> Functions Safely</title>
____________________________________________________________________________-->
  <title>安全地编写 <literal>SECURITY DEFINER</literal>函数</title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary><varname>search_path</varname> configuration parameter</primary>
   <secondary>use in securing functions</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary><varname>search_path</varname> 配置参数</primary>
   <secondary>use in securing functions</secondary>
  </indexterm>

<!--==========================orignal english content==========================
   <para>
    Because a <literal>SECURITY DEFINER</literal> function is executed
    with the privileges of the user that owns it, care is needed to
    ensure that the function cannot be misused.  For security,
    <xref linkend="guc-search-path"/> should be set to exclude any schemas
    writable by untrusted users.  This prevents
    malicious users from creating objects (e.g., tables, functions, and
    operators) that mask objects intended to be used by the function.
    Particularly important in this regard is the
    temporary-table schema, which is searched first by default, and
    is normally writable by anyone.  A secure arrangement can be obtained
    by forcing the temporary schema to be searched last.  To do this,
    write <literal>pg_temp</literal><indexterm><primary>pg_temp</primary><secondary>securing functions</secondary></indexterm> as the last entry in <varname>search_path</varname>.
    This function illustrates safe usage:

<programlisting>
CREATE FUNCTION check_password(uname TEXT, pass TEXT)
RETURNS BOOLEAN AS $$
DECLARE passed BOOLEAN;
BEGIN
        SELECT  (pwd = $2) INTO passed
        FROM    pwds
        WHERE   username = $1;

        RETURN passed;
END;
$$  LANGUAGE plpgsql
    SECURITY DEFINER
    -&minus; Set a secure search_path: trusted schema(s), then 'pg_temp'.
    SET search_path = admin, pg_temp;
</programlisting>

    This function's intention is to access a table <literal>admin.pwds</literal>.
    But without the <literal>SET</literal> clause, or with a <literal>SET</literal> clause
    mentioning only <literal>admin</literal>, the function could be subverted by
    creating a temporary table named <literal>pwds</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    因为一个<literal>SECURITY DEFINER</literal>函数会被以创建它的用户的特权来执行，需要小心地确保该函数不会被误用。为了安全，<xref linkend="guc-search-path"/>应该被设置为排除任何不可信用户可写的模式。这可以阻止恶意用户创建对象（例如表、函数以及操作符）来掩饰该函数所要用到的对象。在这方面特别重要的是临时表模式，默认情况下它会第一个被搜索并且通常对任何用户都是可写的。可以通过强制最后搜索临时模式来得到一种安全的布局。要这样做，把<literal>pg_temp</literal><indexterm><primary>pg_temp</primary><secondary>securing functions</secondary></indexterm>写成<varname>search_path</varname>中的最后一项。这个函数展示了安全的用法：

<programlisting>
CREATE FUNCTION check_password(uname TEXT, pass TEXT)
RETURNS BOOLEAN AS $$
DECLARE passed BOOLEAN;
BEGIN
        SELECT  (pwd = $2) INTO passed
        FROM    pwds
        WHERE   username = $1;

        RETURN passed;
END;
$$  LANGUAGE plpgsql
    SECURITY DEFINER
    -- 设置一个安全的 search_path：受信的模式，然后是 'pg_temp'。
    SET search_path = admin, pg_temp;
</programlisting>

    这个函数的目的是为了访问表<literal>admin.pwds</literal>。但是如果没有<literal>SET</literal>子句或者带有<literal>SET</literal>子句却只提到<literal>admin</literal>，该函数会变成创建一个名为<literal>pwds</literal>的临时表。
   </para>
   
<!--==========================orignal english content==========================
   <para>
    Before <productname>PostgreSQL</productname> version 8.3, the
    <literal>SET</literal> clause was not available, and so older functions may
    contain rather complicated logic to save, set, and restore
    <varname>search_path</varname>.  The <literal>SET</literal> clause is far easier
    to use for this purpose.
   </para>
____________________________________________________________________________-->
   <para>
    在<productname>PostgreSQL</productname> 版本 8.3 之前，<literal>SET</literal>子句不可用，因而较老的函数可能包含相当复杂的逻辑来保存、设置以及恢复<varname>search_path</varname>。对于这种目的，<literal>SET</literal>子句更容易。
   </para>

<!--==========================orignal english content==========================
   <para>
    Another point to keep in mind is that by default, execute privilege
    is granted to <literal>PUBLIC</literal> for newly created functions
    (see <xref linkend="ddl-priv"/> for more
    information).  Frequently you will wish to restrict use of a security
    definer function to only some users.  To do that, you must revoke
    the default <literal>PUBLIC</literal> privileges and then grant execute
    privilege selectively.  To avoid having a window where the new function
    is accessible to all, create it and set the privileges within a single
    transaction.  For example:
   </para>
____________________________________________________________________________-->
   <para>
    另一点要记住的是默认情况下，会为新创建的函数给<literal>PUBLIC</literal>授予执行特权（详见<xref linkend="ddl-priv"/>）。你常常会希望把安全定义器函数的使用限制在某些用户中。要这样做，你必须收回默认的<literal>PUBLIC</literal>特权，然后选择性地授予执行特权。为了避免出现新函数能被所有人访问的时间窗口，应在一个事务中创建它并且设置特权。例如：
   </para>

<!--==========================orignal english content==========================
<programlisting>
BEGIN;
CREATE FUNCTION check_password(uname TEXT, pass TEXT) ... SECURITY DEFINER;
REVOKE ALL ON FUNCTION check_password(uname TEXT, pass TEXT) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION check_password(uname TEXT, pass TEXT) TO admins;
COMMIT;
</programlisting>
____________________________________________________________________________-->
<programlisting>
BEGIN;
CREATE FUNCTION check_password(uname TEXT, pass TEXT) ... SECURITY DEFINER;
REVOKE ALL ON FUNCTION check_password(uname TEXT, pass TEXT) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION check_password(uname TEXT, pass TEXT) TO admins;
COMMIT;
</programlisting>

 </refsect1>

 <refsect1 id="sql-createfunction-compat">
<!--==========================orignal english content==========================
  <title>Compatibility</title>
____________________________________________________________________________-->
  <title>兼容性</title>

<!--==========================orignal english content==========================
  <para>
   A <command>CREATE FUNCTION</command> command is defined in the SQL
   standard.  The <productname>PostgreSQL</productname> implementation can be
   used in a compatible way but has many extensions.  Conversely, the SQL
   standard specifies a number of optional features that are not implemented
   in <productname>PostgreSQL</productname>.
  </para>
____________________________________________________________________________-->
  <para>
   SQL标准中定义了<command>CREATE FUNCTION</command>命令。
   <productname>PostgreSQL</productname>实现可以以兼容的方式使用，但有许多扩展。
   相反，SQL标准指定了许多未在<productname>PostgreSQL</productname>中实现的可选功能。
  </para>

<!--==========================orignal english content==========================
  <para>
   The following are important compatibility issues:

   <itemizedlist>
    <listitem>
     <para>
      <literal>OR REPLACE</literal> is a PostgreSQL extension.
     </para>
    </listitem>

    <listitem>
     <para>
      For compatibility with some other database systems, <replaceable
      class="parameter">argmode</replaceable> can be written either before or
      after <replaceable class="parameter">argname</replaceable>.  But only
      the first way is standard-compliant.
     </para>
    </listitem>

    <listitem>
     <para>
      For parameter defaults, the SQL standard specifies only the syntax with
      the <literal>DEFAULT</literal> key word.  The syntax with
      <literal>=</literal> is used in T-SQL and Firebird.
     </para>
    </listitem>

    <listitem>
     <para>
      The <literal>SETOF</literal> modifier is a PostgreSQL extension.
     </para>
    </listitem>

    <listitem>
     <para>
      Only <literal>SQL</literal> is standardized as a language.
     </para>
    </listitem>

    <listitem>
     <para>
      All other attributes except <literal>CALLED ON NULL INPUT</literal> and
      <literal>RETURNS NULL ON NULL INPUT</literal> are not standardized.
     </para>
    </listitem>

    <listitem>
     <para>
      For the body of <literal>LANGUAGE SQL</literal> functions, the SQL
      standard only specifies the <replaceable>sql_body</replaceable> form.
     </para>
    </listitem>
   </itemizedlist>
  </para>
____________________________________________________________________________-->
  <para>
   以下是重要的兼容性问题：

   <itemizedlist>
    <listitem>
     <para>
      <literal>OR REPLACE</literal>是PostgreSQL的扩展。
     </para>
    </listitem>

    <listitem>
     <para>
      为了与其他一些数据库系统兼容，<replaceable class="parameter">argmode</replaceable>
      可以在<replaceable class="parameter">argname</replaceable>之前或之后写入。
      但只有第一种方式符合标准。
     </para>
    </listitem>

    <listitem>
     <para>
      对于参数默认值，SQL标准仅指定带有<literal>DEFAULT</literal>关键字的语法。
      <literal>=</literal>的语法是在T-SQL和Firebird中被使用的。
     </para>
    </listitem>

    <listitem>
     <para>
      <literal>SETOF</literal>修饰符是PostgreSQL的扩展。
     </para>
    </listitem>

    <listitem>
     <para>
      只有<literal>SQL</literal>是被标准化的一个语言。
     </para>
    </listitem>

    <listitem>
     <para>
      除了 <literal>CALLED ON NULL INPUT</literal>和
      <literal>RETURNS NULL ON NULL INPUT</literal>以外的所有其他属性都没有标准化。
     </para>
    </listitem>

    <listitem>
     <para>
      对于<literal>LANGUAGE SQL</literal>函数的主体，SQL标准只指定了
      <replaceable>SQL_body</replaceable>形式。
     </para>
    </listitem>
   </itemizedlist>
  </para>

<!--==========================orignal english content==========================
  <para>
   Simple <literal>LANGUAGE SQL</literal> functions can be written in a way
   that is both standard-conforming and portable to other implementations.
   More complex functions using advanced features, optimization attributes, or
   other languages will necessarily be specific to PostgreSQL in a significant
   way.
  </para>
____________________________________________________________________________-->
  <para>
   简单的<literal>LANGUAGE SQL</literal>函数可以以既符合标准又可移植到其他实现的方式编写。
   使用高级特性、优化属性或其他语言的更复杂的函数必然在很大程度上特定于PostgreSQL。
  </para>
 </refsect1>


 <refsect1>
<!--==========================orignal english content==========================
  <title>See Also</title>
____________________________________________________________________________-->
  <title>另见</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alterfunction"/></member>
   <member><xref linkend="sql-dropfunction"/></member>
   <member><xref linkend="sql-grant"/></member>
   <member><xref linkend="sql-load"/></member>
   <member><xref linkend="sql-revoke"/></member>
  </simplelist>
 </refsect1>

</refentry>
