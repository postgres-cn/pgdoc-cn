<!--
doc/src/sgml/ref/create_function.sgml
-->

<refentry id="SQL-CREATEFUNCTION">
 <indexterm zone="sql-createfunction">
  <primary>CREATE FUNCTION</primary>
 </indexterm>

 <refmeta>
  <refentrytitle>CREATE FUNCTION</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE FUNCTION</refname>
  <refpurpose>定义一个新函数</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
CREATE [ OR REPLACE ] FUNCTION
    <replaceable class="parameter">name</replaceable> ( [ [ <replaceable class="parameter">argmode</replaceable> ] [ <replaceable class="parameter">argname</replaceable> ] <replaceable class="parameter">argtype</replaceable> [ { DEFAULT | = } <replaceable class="parameter">default_expr</replaceable> ] [, ...] ] )
    [ RETURNS <replaceable class="parameter">rettype</replaceable>
      | RETURNS TABLE ( <replaceable class="parameter">column_name</replaceable> <replaceable class="parameter">column_type</replaceable> [, ...] ) ]
  { LANGUAGE <replaceable class="parameter">lang_name</replaceable>
    | WINDOW
    | IMMUTABLE | STABLE | VOLATILE | [ NOT ] LEAKPROOF
    | CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT
    | [ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER
    | COST <replaceable class="parameter">execution_cost</replaceable>
    | ROWS <replaceable class="parameter">result_rows</replaceable>
    | SET <replaceable class="parameter">configuration_parameter</replaceable> { TO <replaceable class="parameter">value</replaceable> | = <replaceable class="parameter">value</replaceable> | FROM CURRENT }
    | AS '<replaceable class="parameter">definition</replaceable>'
    | AS '<replaceable class="parameter">obj_file</replaceable>', '<replaceable class="parameter">link_symbol</replaceable>'
  } ...
    [ WITH ( <replaceable class="parameter">attribute</replaceable> [, ...] ) ]
</synopsis>
 </refsynopsisdiv>

 <refsect1 id="sql-createfunction-description">
  <title>描述</title>

  <para>
   <command>CREATE FUNCTION</command>定义一个新函数。
   <command>CREATE OR REPLACE FUNCTION</command>将创建一个
   新函数或者替换一个现有的函数。要定义一个函数，用户必须具有该语言上的
   <literal>USAGE</literal>特权。
  </para>

  <para>
   如果包括了一个模式名，那么该函数会被创建在指定的模式中。否则，它会被
   创建在当前模式中。新函数的名称不能匹配同一个模式中具有相同输入参数类型
   的任何现有函数。不过，不同参数类型的函数能够共享一个名字（这被称作
   <firstterm>重载</>）。
  </para>

  <para>
   要替换一个现有函数的当前定义，可以使用
   <command>CREATE OR REPLACE FUNCTION</command>。但不能用这种
   方式更改函数的名称或者参数类型（如果尝试这样做，实际上就会创建一个新的
   不同的函数）。还有，
   <command>CREATE OR REPLACE FUNCTION</command>将不会让你更改
   一个现有函数的返回类型。要这样做，你必须先删除再重建该函数（在使用
   <literal>OUT</>参数时，这意味着除了删除函数之外无法更改任何
   <literal>OUT</>参数的类型）。
  </para>

  <para>
   当<command>CREATE OR REPLACE FUNCTION</>被用来替换一个现有的函数，
   该函数的拥有权和权限不会改变。所有其他的函数属性会按照该命令中所指定的或者
   隐含的来赋值。必须拥有（包括成为拥有角色的成员）该函数才能替换它。
  </para>

  <para>
   如果你删除并且重建一个函数，新函数将和旧的不一样，你将必须删掉引用旧函数的
   现有规则、视图、触发器等。使用
   <command>CREATE OR REPLACE FUNCTION</command>更改一个函数定义
   不会破坏引用该函数的对象。还有，<command>ALTER FUNCTION</>可以被用
   来更改一个现有函数的大部分辅助属性。
  </para>

  <para>
   创建该函数的用户将成为该函数的拥有者。
  </para>

  <para>
   要创建一个函数，你必须拥有参数类型和返回类型上的<literal>USAGE</literal>
   特权。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

   <variablelist>

    <varlistentry>
     <term><replaceable class="parameter">name</replaceable></term>

     <listitem>
      <para>
       要创建的函数的名称（可以被模式限定）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">argmode</replaceable></term>

     <listitem>
      <para>
       一个参数的模式：<literal>IN</>、<literal>OUT</>、
       <literal>INOUT</>或者<literal>VARIADIC</>。如果省略，默认为
       <literal>IN</>。只有<literal>OUT</>参数能跟在一个<literal>VARIADIC</>
       参数后面。还有，<literal>OUT</>和<literal>INOUT</>参数不能和
       <literal>RETURNS TABLE</>符号一起使用。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">argname</replaceable></term>

     <listitem>
      <para>
       一个参数的名称。一些语言（包括 SQL 和 PL/pgSQL）让你在函数体中使用
       该名称。对于其他语言，一个输入参数的名字只是额外的文字（就该函数本身
       所关心的来说）。但是你可以在调用一个函数时使用输入参数名来提高可读性
       （见<xref linkend="sql-syntax-calling-funcs">）。在任何情况下，输出参
       数的名称是有意义的，因为它定义了结果行类型中的列名（如果忽略一个输出
       参数的名称，系统将选择一个默认的列名）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">argtype</replaceable></term>

     <listitem>
      <para>
       该函数参数（如果有）的数据类型（可以是模式限定的）。参数类型可以是
       基本类型、组合类型或者域类型，或者可以引用一个表列的类型。
      </para>
      <para>
       根据实现语言，也可以允许指定<type>cstring</>之类的
       <quote>伪类型</>。伪类型表示实际参数类型没有被完整指定或者不属于
       普通 SQL 数据类型集合。
      </para>
      <para>
       可以写<literal><replaceable
       class="parameter">table_name</replaceable>.<replaceable
       class="parameter">column_name</replaceable>%TYPE</literal>来
       引用一列的类型。使用这种特性有时可以帮助创建一个不受表定义更改影响
       的函数。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">default_expr</replaceable></term>

     <listitem>
      <para>
       如果参数没有被指定值时要用作默认值的表达式。该表达式必须能被强制为该
       参数的参数类型。只有输入（包括<literal>INOUT</>）参数可以具有默认值。
       所有跟随在一个具有默认值的参数之后的输入参数也必须有默认值。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">rettype</replaceable></term>

     <listitem>
      <para>
       返回数据类型（可能被模式限定）。返回类型可以是一种基本类型、组合类型
       或者域类型，也可以引用一个表列的类型。根据实现语言，也可以允许指定
       <type>cstring</>之类的<quote>伪类型</>。如果该函数不会返回一个值，
       可以指定返回类型为<type>void</>。
      </para>
      <para>
       当有<literal>OUT</>或者<literal>INOUT</>参数时，可以省略
       <literal>RETURNS</>子句。如果存在，该子句必须和输出参数所表示的结果
       类型一致：如果有多个输出参数，则为<literal>RECORD</>，否则与单个输出
       参数的类型相同。
      </para>
      <para>
       <literal>SETOF</literal>修饰符表示该函数将返回一个项的集合而不是
       一个单一项。
      </para>
      <para>
       可以写<literal><replaceable
       class="parameter">table_name</replaceable>.<replaceable
       class="parameter">column_name</replaceable>%TYPE</literal>来
       引用一列的类型。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">column_name</replaceable></term>

     <listitem>
      <para>
       <literal>RETURNS TABLE</>语法中一个输出列的名称。这实际上是另一种声明
       <literal>OUT</>参数的方法，不过<literal>RETURNS TABLE</>也隐含了
       <literal>RETURNS SETOF</>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">column_type</replaceable></term>

     <listitem>
      <para>
       <literal>RETURNS TABLE</>语法中的输出列的数据类型。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">lang_name</replaceable></term>

     <listitem>
      <para>
       用以实现该函数的语言的名称。可以是<literal>sql</literal>、<literal>c</literal>、
       <literal>internal</literal>或者一个用户定义的过程语言的名称，例如
       <literal>plpgsql</literal>。不推荐用单引号包围该名称，并且要求区分大小写。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>WINDOW</literal></term>

     <listitem>
      <para><literal>WINDOW</literal>表示该函数是一个
      <firstterm>窗口函数</>而不是一个普通函数。当前只用于用 C 编写
      的函数。在替换一个现有函数定义时，不能更改
      <literal>WINDOW</>属性。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>IMMUTABLE</literal></term>
     <term><literal>STABLE</literal></term>
     <term><literal>VOLATILE</literal></term>

     <listitem>
      <para>
       这些属性告知查询优化器该函数的行为。最多只能指定其中一个。
       如果这些都不出现，则会默认为<literal>VOLATILE</literal>。
      </para>

      <para><literal>IMMUTABLE</literal>表示该函数不能修改数据库并且
      对于给定的参数值总是会返回相同的值。也就是说，它不会做数据库查找
      或者使用没有在其参数列表中直接出现的信息。如果给定合格选项，任何
      用全常量参数对该函数的额调用可以立刻用该函数值替换。
      </para>

      <para><literal>STABLE</literal>表示该函数不能修改数据库，并且对于
      相同的参数值，它在一次表扫描中将返回相同的结果。但是这种结果在不同
      的 SQL 语句执行期间可能会变化。对于那些结果依赖于数据库查找、参数
      变量（例如当前时区）等的函数来说，这是合适的（对希望查询被当前命令
      修改的行的<literal>AFTER</>触发器不适合）。还要注意
      <function>current_timestamp</>函数族适合被标记为稳定，因为它们的
      值在一个事务内不会改变。
      </para>

      <para><literal>VOLATILE</literal>表示该函数的值在一次表扫描中都有
      可能改变，因此不能做优化。在这种意义上，相对较少的数据库函数是不稳
      定的，一些例子是<literal>random()</>、<literal>currval()</>、
       <literal>timeofday()</>。但是注意任何有副作用的函数都必须被分类为
       不稳定的，即便其结果是可以预测的，这是为了调用被优化掉。一个例子是
       <literal>setval()</>。
      </para>

      <para>
       更多细节可见<xref linkend="xfunc-volatility">。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>LEAKPROOF</literal></term>
     <listitem>
      <para>
       <literal>LEAKPROOF</literal>表示该函数没有副作用。它不会泄露任何有关
       其参数的信息（除了返回值）。例如，一个为某些参数值会抛出
       错误消息（对其他参数则不抛出）的函数或者会把参数值包括在任意错误消息
       中的函数不是防泄漏的。查询规划器可能会把防泄漏的函数（而不是其他函数）
       推到用<literal>security_barrier</literal>选项创建的视图中。请参见
       <xref linkend="sql-createview"> and <xref linkend="rules-privileges">。
       这个选项只能被超级用户设置。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>CALLED ON NULL INPUT</literal></term>
     <term><literal>RETURNS NULL ON NULL INPUT</literal></term>
     <term><literal>STRICT</literal></term>

     <listitem>
      <para><literal>CALLED ON NULL INPUT</literal>（默认）表示在某些参数
      为空值时应正常调用该函数。如果有必要，函数的作者应该负责检查空值并且
      做出适当的相应。
      </para>

      <para><literal>RETURNS NULL ON NULL INPUT</literal>或
       <literal>STRICT</literal>表示只要其任意参数为空值，该函数就会返回空值。
       如果指定了这个参数，当有空值参数时该函数不会被执行，而是自动返回一个空值
       结果。
      </para>
     </listitem>
    </varlistentry>

   <varlistentry>
    <term><literal><optional>EXTERNAL</optional> SECURITY INVOKER</literal></term>
    <term><literal><optional>EXTERNAL</optional> SECURITY DEFINER</literal></term>

    <listitem>
     <para><literal>SECURITY INVOKER</literal>表示要用调用该函数的用户的
     特权来执行它。这是默认值。<literal>SECURITY DEFINER</literal>指定要用
     创建函数的用户的特权来执行该函数。
     </para>

     <para>
      为了符合 SQL，允许使用关键词<literal>EXTERNAL</literal>。但是它是
      可选的，因为与 SQL 中不同，这个特性适用于所有函数而不仅是那些外部
      函数。
     </para>
    </listitem>
   </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">execution_cost</replaceable></term>

     <listitem>
      <para>
       一个给出该函数的估计执行代价的正数，单位是
       <xref linkend="guc-cpu-operator-cost">。如果该函数返回一个集合，
       这就是每个被返回行的代价。如果没有指定代价，对 C 语言和内部函数会
       指定为 1 个单位，对其他语言的函数则会指定为 100 单位。更大的值会
       导致规划器尝试避免对该函数的不必要的过多计算。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">result_rows</replaceable></term>

     <listitem>
      <para>
       一个正数，它给出规划器期望该函数返回的行数估计。只有当该函数被声明为
       返回一个集合时才允许这个参数。默认假设为 1000 行。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>configuration_parameter</replaceable></term>
     <term><replaceable>value</replaceable></term>
     <listitem>
      <para>
       <literal>SET</>子句导致进入该函数时指定配置参数将被设置为指定值。
       并且在该函数退出时恢复到该参数之前的值。
       <literal>SET FROM CURRENT</>会把该参数的当前会话值保存为进入
       该函数时应该应用的值。
      </para>

      <para>
       如果一个<literal>SET</>子句被附加到一个函数，那么在该函数内为
       同一个变量执行的<command>SET LOCAL</>命令会被限制于该函数：
       在函数退出时该配置参数之前的值仍会被恢复。不过，一个普通的
       <command>SET</>命令（没有<literal>LOCAL</>）会覆盖
       <literal>SET</>子句，更像一个之前的<command>SET
       LOCAL</>命令所做的那样：这种命令的效果在函数退出后将会持续，
       除非当前事务被回滚。
      </para>

      <para>
       更多有关允许的参数名和参数值的信息请见<xref linkend="sql-set">和
       <xref linkend="runtime-config">。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">definition</replaceable></term>

     <listitem>
      <para>
       一个定义该函数的字符串常量，其含义取决于语言。它可以是一个内部
       函数名、一个对象文件的路径、一个 SQL 命令或者用一种过程语言编写
       的文本。
      </para>

      <para>
       美元引用<xref linkend="sql-syntax-dollar-quoting">通常对书写函数
       定义字符串有所帮助，而普通单引号语法则不会有用。如果没有美元引用，
       函数定义中的任何单引号或者反斜线必须用双写来转义。
      </para>

     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal><replaceable class="parameter">obj_file</replaceable>, <replaceable class="parameter">link_symbol</replaceable></literal></term>

     <listitem>
      <para>
       当 C 语言源代码中该函数的名称与 SQL 函数的名称不同时，这种形式的
       <literal>AS</literal>子句被用于动态可载入 C 语言函数。字符串
       <replaceable class="parameter">obj_file</replaceable>是包含动态
       可载入对象的文件名，并且
       <replaceable class="parameter">link_symbol</replaceable>是该
       函数的链接符号，也就是该函数在 C 语言源代码中的名称。如果省略链接
       符号，它将被假定为要定义的 SQL 函数的名称。
      </para>

      <para>
       在重复调用引用同一对象文件的
       <command>CREATE FUNCTION</command>时，对每个会话该文件
       只会被载入一次。要卸载并且重新装载该文件（可能是在开发期间），需要
       开始一个新会话。
      </para>

     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable class="parameter">attribute</replaceable></term>

     <listitem>
      <para>
       历史遗留的指定有关该函数可选信息的方法。可以出现下列属性：

      <variablelist>
       <varlistentry>
        <term><literal>isStrict</></term>
        <listitem>
         <para>
          等效于<literal>STRICT</literal>或者<literal>RETURNS NULL ON NULL INPUT</literal>。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>isCachable</></term>
        <listitem>
         <para><literal>isCachable</literal>是<literal>IMMUTABLE</literal>
         的一个已被废弃的等效体。为了向后兼容的原因，它仍被接受。
         </para>
        </listitem>
       </varlistentry>

      </variablelist>

      属性名大小写无关。
     </para>
    </listitem>
   </varlistentry>

   </variablelist>

   <para>
    编写函数的进一步信息可以参考<xref linkend="xfunc">。
   </para>

 </refsect1>

 <refsect1 id="sql-createfunction-overloading">
  <title>重载</title>

   <para>
    <productname>PostgreSQL</productname>允许函数
    <firstterm>重载</firstterm>，也就是说同一个名称可以被用于多个不同的
    函数，只要它们具有可区分的输入参数类型。不过，所有函数的 C 名称必须
    不同，因此你必须给被重载的 C 函数指定不同的 C 名称（例如，把参数类型
    作为 C 名称的一部分）。
   </para>

   <para>
    如果两个函数具有相同的名称和<emphasis>输入</>参数类型，它们被认为
    相同（不考虑任何<literal>OUT</>参数）。因此这些声明会冲突：
<programlisting>
CREATE FUNCTION foo(int) ...
CREATE FUNCTION foo(int, out text) ...
</programlisting>
   </para>

   <para>
    具有不同参数类型列表的函数在创建时将不会被认为是冲突的，但是如果默认值
    被提供，在使用时它们有可能会冲突。例如，考虑
<programlisting>
CREATE FUNCTION foo(int) ...
CREATE FUNCTION foo(int, int default 42) ...
</programlisting>
    调用<literal>foo(10)</>将会失败，因为在要决定应该调用哪个函数时会有歧义。
   </para>

 </refsect1>

 <refsect1 id="sql-createfunction-notes">
  <title>注解</title>

   <para>
    允许把完整的<acronym>SQL</acronym>类型语法用于声明一个函数的参数和
    返回值。不过，<command>CREATE FUNCTION</>会抛弃带圆括号的类型
    修饰符（例如类型<type>numeric</type>的精度域）。例如
    <literal>CREATE FUNCTION foo (varchar(10)) ...</>
    和
    <literal>CREATE FUNCTION foo (varchar) ...</>完全一样。
   </para>

   <para>
    在用<command>CREATE OR REPLACE
    FUNCTION</>替换一个现有函数时，对于更改参数名是有限制的。不能更改
    已经分配给任何输入参数的名称（不过可以给之前没有名称的参数增加名称）。
    如果有多于一个输出参数，不能更改输出参数的名称，因为可能会改变描述
    函数结果的匿名组合类型的列名。这些限制是为了确保函数被替换时，已有的
    对该函数的调用不会停止工作。
   </para>

   <para>
    如果一个被声明为<literal>STRICT</>的函数带有一个<literal>VARIADIC</>
    参数，会严格检查该可变数组<emphasis>作为一个整体</>是否为非空。如果
    该数组有空值元素，该函数仍将被调用。
   </para>

 </refsect1>

 <refsect1 id="sql-createfunction-examples">
  <title>示例</title>

  <para>
   这里是一些小例子，它们可以帮你了解函数创建。更多信息和例子可见
   <xref linkend="xfunc">。
<programlisting>
CREATE FUNCTION add(integer, integer) RETURNS integer
    AS 'select $1 + $2;'
    LANGUAGE SQL
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;
</programlisting>
  </para>

  <para>
   在<application>PL/pgSQL</application>中，使用一个参数名称增加一个整数：
<programlisting>
CREATE OR REPLACE FUNCTION increment(i integer) RETURNS integer AS $$
        BEGIN
                RETURN i + 1;
        END;
$$ LANGUAGE plpgsql;
</programlisting>
  </para>

  <para>
   返回一个包含多个输出参数的记录：
<programlisting>
CREATE FUNCTION dup(in int, out f1 int, out f2 text)
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);
</programlisting>
   你可以用更复杂的方式（用一个显式命名的组合类型）来做同样的事情：
<programlisting>
CREATE TYPE dup_result AS (f1 int, f2 text);

CREATE FUNCTION dup(int) RETURNS dup_result
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);
</programlisting>
   另一种返回多列的方法是使用一个<literal>TABLE</>函数：
<programlisting>
CREATE FUNCTION dup(int) RETURNS TABLE(f1 int, f2 text)
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);
</programlisting>
   不过，<literal>TABLE</>函数与之前的例子不同，因为它实际返回了一个
   记录<emphasis>集合</>而不只是一个记录。
  </para>
 </refsect1>

 <refsect1 id="sql-createfunction-security">
  <title>安全地编写 <literal>SECURITY DEFINER</literal>函数</title>

  <indexterm>
   <primary><varname>search_path</varname> 配置参数</>
   <secondary>use in securing functions</>
  </indexterm>

   <para>
    因为一个<literal>SECURITY DEFINER</literal>函数会被以创建它的用户
    的特权来执行，需要小心地确保该函数不会被误用。为了安全，
    <xref linkend="guc-search-path">应该被设置为排除任何不可信用户
    可写的模式。这可以阻止恶意用户创建对象来掩饰该函数所用到的对象。
    在这方面特别重要的是临时表模式，默认情况下它会第一个被搜索并且通常
    对任何用户都是可写的。可以通过强制最后搜索临时模式来得到一种安全的
    布局。要这样做，把
    <literal>pg_temp</><indexterm><primary>pg_temp</><secondary>securing functions</></>
    写成<varname>search_path</>中的最后一项。这个函数展示了安全的用法：
   </para>

<programlisting>
CREATE FUNCTION check_password(uname TEXT, pass TEXT)
RETURNS BOOLEAN AS $$
DECLARE passed BOOLEAN;
BEGIN
        SELECT  (pwd = $2) INTO passed
        FROM    pwds
        WHERE   username = $1;

        RETURN passed;
END;
$$  LANGUAGE plpgsql
    SECURITY DEFINER
    -- 设置一个安全的 search_path：受信的模式，然后是 'pg_temp'。
    SET search_path = admin, pg_temp;
</programlisting>

   <para>
    在<productname>PostgreSQL</productname> 版本 8.3 之前，
    <literal>SET</>选项不可用，因而较老的函数可能包含相当复杂的逻辑
    来保存、设置以及恢复<varname>search_path</>。对于这种目的，
    <literal>SET</>选项更容易。
   </para>

   <para>
    另一点要记住的是默认情况下，会为新创建的函数给<literal>PUBLIC</>
    授予执行特权（详见<xref linkend="sql-grant">）。你常常会希望把
    安全定义器函数的使用限制在某些用户中。要这样做，你必须收回默认的
    <literal>PUBLIC</>特权，然后选择性地授予执行特权。为了避免出现新
    函数能被所有人访问的时间窗口，应在一个事务中创建它并且设置特权。例如：
   </para>

<programlisting>
BEGIN;
CREATE FUNCTION check_password(uname TEXT, pass TEXT) ... SECURITY DEFINER;
REVOKE ALL ON FUNCTION check_password(uname TEXT, pass TEXT) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION check_password(uname TEXT, pass TEXT) TO admins;
COMMIT;
</programlisting>

 </refsect1>

 <refsect1 id="sql-createfunction-compat">
  <title>兼容性</title>

  <para>
   <command>CREATE FUNCTION</command>命令被定义在 SQL:1999 及
   其后的版本中。<productname>PostgreSQL</productname>的版本类似但
   不完全兼容。属性是不可移植的，不同的可用语言也是不能移植的。
  </para>

  <para>
   对于和一些其他数据库系统的兼容性，
   <replaceable class="parameter">argmode</replaceable>可以被写在
   <replaceable class="parameter">argname</replaceable>之前或者之后。
   但只有第一种方式是兼容标准的。
  </para>

  <para>
   对于参数默认值，SQL 标准只指定带有<literal>DEFAULT</literal>关键词
   的语法。带有<literal>=</literal>的语法被用在 T-SQL 和 Firebird 中。
  </para>
 </refsect1>


 <refsect1>
  <title>另见</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alterfunction"></member>
   <member><xref linkend="sql-dropfunction"></member>
   <member><xref linkend="sql-grant"></member>
   <member><xref linkend="sql-load"></member>
   <member><xref linkend="sql-revoke"></member>
   <member><xref linkend="app-createlang"></member>
  </simplelist>
 </refsect1>

</refentry>
