<!--
doc/src/sgml/ref/alter_table.sgml
PostgreSQL documentation
-->

<refentry id="SQL-ALTERTABLE">
 <refmeta>
  <refentrytitle>ALTER TABLE</refentrytitle>
  <manvolnum>7</manvolnum>
  <!--
<refmiscinfo>SQL - Language Statements</refmiscinfo>
-->
<refmiscinfo>SQL - 语句</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>ALTER TABLE</refname>
  <!--
  <refpurpose>change the definition of a table</refpurpose>
  -->
    <refpurpose>修改表的定义</refpurpose>
 </refnamediv>

 <indexterm zone="sql-altertable">
  <primary>ALTER TABLE</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
ALTER TABLE [ IF EXISTS ] [ ONLY ] <replaceable class="PARAMETER">name</replaceable> [ * ]
    <replaceable class="PARAMETER">action</replaceable> [, ... ]
ALTER TABLE [ IF EXISTS ] [ ONLY ] <replaceable class="PARAMETER">name</replaceable> [ * ]
    RENAME [ COLUMN ] <replaceable class="PARAMETER">column_name</replaceable> TO <replaceable class="PARAMETER">new_column_name</replaceable>
ALTER TABLE [ IF EXISTS ] [ ONLY ] <replaceable class="PARAMETER">name</replaceable> [ * ]
    RENAME CONSTRAINT <replaceable class="PARAMETER">constraint_name</replaceable> TO <replaceable class="PARAMETER">new_constraint_name</replaceable>
ALTER TABLE [ IF EXISTS ] <replaceable class="PARAMETER">name</replaceable>
    RENAME TO <replaceable class="PARAMETER">new_name</replaceable>
ALTER TABLE [ IF EXISTS ] <replaceable class="PARAMETER">name</replaceable>
    SET SCHEMA <replaceable class="PARAMETER">new_schema</replaceable>

<!--
<phrase>where <replaceable class="PARAMETER">action</replaceable> is one of:</phrase>
-->
<phrase>其中<replaceable class="PARAMETER">action</replaceable> 可以是以选项之一：</phrase>

    ADD [ COLUMN ] <replaceable class="PARAMETER">column_name</replaceable> <replaceable class="PARAMETER">data_type</replaceable> [ COLLATE <replaceable class="PARAMETER">collation</replaceable> ] [ <replaceable class="PARAMETER">column_constraint</replaceable> [ ... ] ]
    DROP [ COLUMN ] [ IF EXISTS ] <replaceable class="PARAMETER">column_name</replaceable> [ RESTRICT | CASCADE ]
    ALTER [ COLUMN ] <replaceable class="PARAMETER">column_name</replaceable> [ SET DATA ] TYPE <replaceable class="PARAMETER">data_type</replaceable> [ COLLATE <replaceable class="PARAMETER">collation</replaceable> ] [ USING <replaceable class="PARAMETER">expression</replaceable> ]
    ALTER [ COLUMN ] <replaceable class="PARAMETER">column_name</replaceable> SET DEFAULT <replaceable class="PARAMETER">expression</replaceable>
    ALTER [ COLUMN ] <replaceable class="PARAMETER">column_name</replaceable> DROP DEFAULT
    ALTER [ COLUMN ] <replaceable class="PARAMETER">column_name</replaceable> { SET | DROP } NOT NULL
    ALTER [ COLUMN ] <replaceable class="PARAMETER">column_name</replaceable> SET STATISTICS <replaceable class="PARAMETER">integer</replaceable>
    ALTER [ COLUMN ] <replaceable class="PARAMETER">column_name</replaceable> SET ( <replaceable class="PARAMETER">attribute_option</replaceable> = <replaceable class="PARAMETER">value</replaceable> [, ... ] )
    ALTER [ COLUMN ] <replaceable class="PARAMETER">column_name</replaceable> RESET ( <replaceable class="PARAMETER">attribute_option</replaceable> [, ... ] )
    ALTER [ COLUMN ] <replaceable class="PARAMETER">column_name</replaceable> SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN }
    ADD <replaceable class="PARAMETER">table_constraint</replaceable> [ NOT VALID ]
    ADD <replaceable class="PARAMETER">table_constraint_using_index</replaceable>
    VALIDATE CONSTRAINT <replaceable class="PARAMETER">constraint_name</replaceable>
    DROP CONSTRAINT [ IF EXISTS ]  <replaceable class="PARAMETER">constraint_name</replaceable> [ RESTRICT | CASCADE ]
    DISABLE TRIGGER [ <replaceable class="PARAMETER">trigger_name</replaceable> | ALL | USER ]
    ENABLE TRIGGER [ <replaceable class="PARAMETER">trigger_name</replaceable> | ALL | USER ]
    ENABLE REPLICA TRIGGER <replaceable class="PARAMETER">trigger_name</replaceable>
    ENABLE ALWAYS TRIGGER <replaceable class="PARAMETER">trigger_name</replaceable>
    DISABLE RULE <replaceable class="PARAMETER">rewrite_rule_name</replaceable>
    ENABLE RULE <replaceable class="PARAMETER">rewrite_rule_name</replaceable>
    ENABLE REPLICA RULE <replaceable class="PARAMETER">rewrite_rule_name</replaceable>
    ENABLE ALWAYS RULE <replaceable class="PARAMETER">rewrite_rule_name</replaceable>
    CLUSTER ON <replaceable class="PARAMETER">index_name</replaceable>
    SET WITHOUT CLUSTER
    SET WITH OIDS
    SET WITHOUT OIDS
    SET ( <replaceable class="PARAMETER">storage_parameter</replaceable> = <replaceable class="PARAMETER">value</replaceable> [, ... ] )
    RESET ( <replaceable class="PARAMETER">storage_parameter</replaceable> [, ... ] )
    INHERIT <replaceable class="PARAMETER">parent_table</replaceable>
    NO INHERIT <replaceable class="PARAMETER">parent_table</replaceable>
    OF <replaceable class="PARAMETER">type_name</replaceable>
    NOT OF
    OWNER TO <replaceable class="PARAMETER">new_owner</replaceable>
    SET TABLESPACE <replaceable class="PARAMETER">new_tablespace</replaceable>

<phrase>and <replaceable class="PARAMETER">table_constraint_using_index</replaceable> is:</phrase>

    [ CONSTRAINT <replaceable class="PARAMETER">constraint_name</replaceable> ]
    { UNIQUE | PRIMARY KEY } USING INDEX <replaceable class="PARAMETER">index_name</replaceable>
    [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <command>ALTER TABLE</command> changes the definition of an existing table.
   There are several subforms:
</para>
-->
<para>
   <command>ALTER TABLE</command> 改变一个现存表的定义。它有好几种子形式：
</para>


  <variablelist>
   <varlistentry>
    <term><literal>ADD COLUMN</literal></term>
    <listitem>
  <!--
     <para>
      This form adds a new column to the table, using the same syntax as
      <xref linkend="SQL-CREATETABLE">.
     </para>
-->
<para>
这种形式使用和<xref linkend="SQL-CREATETABLE">一样的语法向表中增加一个新的字段。
</para>

    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DROP COLUMN [ IF EXISTS ]</literal></term>
    <listitem>
     <!--
<para>
      This form drops a column from a table.  Indexes and
      table constraints involving the column will be automatically
      dropped as well.  You will need to say <literal>CASCADE</> if
      anything outside the table depends on the column, for example,
      foreign key references or views.
      If <literal>IF EXISTS</literal> is specified and the column
      does not exist, no error is thrown. In this case a notice
      is issued instead.
     </para>
-->
<para>
这种形式从表中删除一个字段。和这个字段相关的索引和表约束也会被自动删除。
如果任何表之外的对象依赖于这个字段，必须使用<literal>CASCADE</>选项，比如外键约束、视图等。
如果使用了<literal>IF EXISTS</literal>选项并且相关字段不存在，则在删除时不会显示错误，仅会有一个提示信息。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>IF EXISTS</literal></term>
    <listitem>
     <!--
<para>
      Do not throw an error if the table does not exist. A notice is issued
      in this case.
     </para>
-->
<para>
如果使用了<literal>IF EXISTS</literal>选项并且表不存在，则在删除时不会显示错误，仅会有一个提示信息。。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET DATA TYPE</literal></term>
    <listitem>
     <!--
<para>
      This form changes the type of a column of a table. Indexes and
      simple table constraints involving the column will be automatically
      converted to use the new column type by reparsing the originally
      supplied expression.
      The optional <literal>COLLATE</literal> clause specifies a collation
      for the new column; if omitted, the collation is the default for the
      new column type.
      The optional <literal>USING</literal>
      clause specifies how to compute the new column value from the old;
      if omitted, the default conversion is the same as an assignment
      cast from old data type to new.  A  <literal>USING</literal>
      clause must be provided if there is no implicit or assignment
      cast from old to new type.
     </para>
-->
<para>
这种形式改变表中一个字段的类型。该字段涉及的索引和简单的表约束将被自动地转换为使用新的字段类型，方法是重新分析最初提供的表达式。
可选的<literal>COLLATE</literal>选项定义了新列的字符集排序方式，如果不加这个选项，则排序方式使用新类型的缺省值。
可选的<literal>USING</literal>选项定义如何从旧的字段值里计算新的字段值；如果省略，那么缺省的转换就是从旧类型向新类型的赋值转换。
如果从旧数据类型到新类型没有隐含或者赋值的转换，那么必须提供一个<literal>USING</literal>选项。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET</literal>/<literal>DROP DEFAULT</literal></term>
    <listitem>
     <!--
<para>
      These forms set or remove the default value for a column.
      Default values only apply in subsequent <command>INSERT</command>
      or <command>UPDATE</> commands; they do not cause rows already in the
      table to change.
     </para>
-->
<para>
这种形式设置或是删除一列的缺省值。缺省值仅会对后续的<command>INSERT</command>或是<command>UPDATE</>命令，不会影响已经在表中存在的记录。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET</literal>/<literal>DROP NOT NULL</literal></term>
    <listitem>
     <!--
<para>
      These forms change whether a column is marked to allow null
      values or to reject null values.  You can only use <literal>SET
      NOT NULL</> when the column contains no null values.
     </para>
-->
<para>
这种形式修改一个字段是否允许 NULL 值或者拒绝 NULL 值。如果表中字段里包含非 NULL值 ，那么你只可以使用<literal>SET NOT NULL</>选项。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET STATISTICS</literal></term>
    <listitem>
     <!--
<para>
      This form
      sets the per-column statistics-gathering target for subsequent
      <xref linkend="sql-analyze"> operations.
      The target can be set in the range 0 to 10000; alternatively, set it
      to -1 to revert to using the system default statistics
      target (<xref linkend="guc-default-statistics-target">).
      For more information on the use of statistics by the
      <productname>PostgreSQL</productname> query planner, refer to
      <xref linkend="planner-stats">.
     </para>
-->
<para>
这种形式为后续的<xref linkend="sql-analyze">操作设置每列的数据统计目标值。
目标值可以设置为0至10000；相应地，设置为-1则会反向使用系统缺省的统计目标值 (<xref linkend="guc-default-statistics-target">)。
有关<productname>PostgreSQL</productname>查询规划器使用数据统计方面的更多信息，可以参阅<xref linkend="planner-stats">。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET ( <replaceable class="PARAMETER">attribute_option</replaceable> = <replaceable class="PARAMETER">value</replaceable> [, ... ] )</literal></term>
    <term><literal>RESET ( <replaceable class="PARAMETER">attribute_option</replaceable> [, ... ] )</literal></term>
    <listitem>
     <!--
<para>
      This form sets or resets per-attribute options.  Currently, the only
      defined per-attribute options are <literal>n_distinct</> and
      <literal>n_distinct_inherited</>, which override the
      number-of-distinct-values estimates made by subsequent
      <xref linkend="sql-analyze">
      operations.  <literal>n_distinct</> affects the statistics for the table
      itself, while <literal>n_distinct_inherited</> affects the statistics
      gathered for the table plus its inheritance children.  When set to a
      positive value, <command>ANALYZE</> will assume that the column contains
      exactly the specified number of distinct nonnull values.  When set to a
      negative value, which must be greater
      than or equal to -1, <command>ANALYZE</> will assume that the number of
      distinct nonnull values in the column is linear in the size of the
      table; the exact count is to be computed by multiplying the estimated
      table size by the absolute value of the given number.  For example,
      a value of -1 implies that all values in the column are distinct, while
      a value of -0.5 implies that each value appears twice on the average.
      This can be useful when the size of the table changes over time, since
      the multiplication by the number of rows in the table is not performed
      until query planning time.  Specify a value of 0 to revert to estimating
      the number of distinct values normally.  For more information on the use
      of statistics by the <productname>PostgreSQL</productname> query
      planner, refer to <xref linkend="planner-stats">.
     </para>
-->
<para>
这种形式设置或者重置每个属性的参数值。目前，已定义的属性参数值是<literal>n_distinct</>和<literal>n_distinct_inherited</>，
它们会覆盖由随后的<xref linkend="sql-analyze">操作所估算的number-of-distinct-values。
<literal>n_distinct</>影响表本身的统计值，而<literal>n_distinct_inherited</>影响表及其继承子表的统计。
当设置为一个正值时，<command>ANALYZE</>将会假定列准确包含明确的非空值的指定数目。 
当设置为一个必须大于或者等于-1的负值时，<command>ANALYZE</>将会假定在列中的不同的非空值的数目与表的大小关系是线性的；
确切的统计通过将估算的表大小与给定数字的绝对值相乘来统计。
例如， 值-1意味着在此列中的所有值是不同的，值-0.5意味着每个值平均出现两次。 
当表的大小随时间变化时这是很有效的，尽管表中行数的乘法运算在查询规划计时前是不会这样计算的，
声明一个0值来正常地恢复到估计不同数值的数目。
要获取关于使用<productname>PostgreSQL</productname>查询优化器做统计的信息，请参阅<xref linkend="planner-stats">。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <indexterm>
     <primary>TOAST</primary>
     <secondary>per-column storage settings</secondary>
    </indexterm>

    <term><literal>SET STORAGE</literal></term>
    <listitem>
     <!--
<para>
      This form sets the storage mode for a column. This controls whether this
      column is held inline or in a secondary <acronym>TOAST</> table, and
      whether the data
      should be compressed or not. <literal>PLAIN</literal> must be used
      for fixed-length values such as <type>integer</type> and is
      inline, uncompressed. <literal>MAIN</literal> is for inline,
      compressible data. <literal>EXTERNAL</literal> is for external,
      uncompressed data, and <literal>EXTENDED</literal> is for external,
      compressed data.  <literal>EXTENDED</literal> is the default for most
      data types that support non-<literal>PLAIN</literal> storage.
      Use of <literal>EXTERNAL</literal> will make substring operations on
      very large <type>text</type> and <type>bytea</type> values run faster,
      at the penalty of increased storage space.  Note that
      <literal>SET STORAGE</> doesn't itself change anything in the table,
      it just sets the strategy to be pursued during future table updates.
      See <xref linkend="storage-toast"> for more information.
     </para>
-->
<para>
这种形式为一个字段设置存储模式。这个设置控制这个字段是内联保存还是保存在一个<acronym>TOAST</>附属的表里，以及数据是否要压缩。
<literal>PLAIN</literal>选项必须用于定长的数值，比如<type>integer</type>并且是内联的、不压缩的。
<literal>MAIN</literal>用于内联、可压缩的数据。
<literal>EXTERNAL</literal>用于外部保存、不压缩的数据，<literal>EXTENDED</literal>用于外部的压缩数据。
<literal>EXTENDED</literal>是大多数支持非<literal>PLAIN</literal>存储的数据的缺省值。
使用<literal>EXTERNAL</literal>将会在<type>text</type>和<type>bytea</type>字段上的字符串操作更快，但付出的代价是增加了存储空间。
请注意<literal>SET STORAGE</>本身并不改变表上的任何东西，只是设置将来的表操作时，建议使用的策略。参阅<xref linkend="storage-toast">获取更多信息。 
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ADD <replaceable class="PARAMETER">table_constraint</replaceable> [ NOT VALID ]</literal></term>
    <listitem>
     <!--
<para>
      This form adds a new constraint to a table using the same syntax as
      <xref linkend="SQL-CREATETABLE">, plus the option <literal>NOT
      VALID</literal>, which is currently only allowed for foreign key
      and CHECK constraints.
      If the constraint is marked <literal>NOT VALID</literal>, the
      potentially-lengthy initial check to verify that all rows in the table
      satisfy the constraint is skipped.  The constraint will still be
      enforced against subsequent inserts or updates (that is, they'll fail
      unless there is a matching row in the referenced table, in the case
      of foreign keys; and they'll fail unless the new row matches the
      specified check constraints).  But the
      database will not assume that the constraint holds for all rows in
      the table, until it is validated by using the <literal>VALIDATE
      CONSTRAINT</literal> option.
     </para>
-->
<para>
这种形式给表增加一个新的约束，使用的语法和<xref linkend="SQL-CREATETABLE">一样，而与<literal>NOT VALID</literal>选项组合时，这种约束仅在对外键和CHECK类药束有效。 
如果约束条件增加了<literal>NOT VALID</literal>选项后，表中已有记录是否满足初始约束检查会被跳过。这种约束会对后续的新增记录或是记录更新产生影响（在外键约束的情况下，
除非是参照的表中有匹配的记录，否则这样的情形会出错；而在CHECK约束下，除非是新增记录满足CHECK约束条件，否则也会也错）。
但数据库自身不会认定这种约束会对表中所有记录生效，除非是在使用了<literal>VALIDATE CONSTRAINT</literal>选项进行了有效性检查。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ADD <replaceable class="PARAMETER">table_constraint_using_index</replaceable></literal></term>
    <listitem>
     <!--
<para>
      This form adds a new <literal>PRIMARY KEY</> or <literal>UNIQUE</>
      constraint to a table based on an existing unique index.  All the
      columns of the index will be included in the constraint.
     </para>
-->
<para>
这种形式根据已有的唯一索引给表增加新的<literal>PRIMARY KEY</>或<literal>UNIQUE</>约束。索引中所有的列也会在包含在约束中。
</para>

<!--
<para>
      The index cannot have expression columns nor be a partial index.
      Also, it must be a b-tree index with default sort ordering.  These
      restrictions ensure that the index is equivalent to one that would be
      built by a regular <literal>ADD PRIMARY KEY</> or <literal>ADD UNIQUE</>
      command.
     </para>
-->
<para>
索引中不能含有表达式列或者是局部索引。另外索引的缺省排序方式应是B-tree类型。这些限制保证了索引会与通过正常<literal>ADD PRIMARY KEY</>或<literal>ADD UNIQUE</>选项生成的索引相同。
</para>

<!--
<para>
      If <literal>PRIMARY KEY</> is specified, and the index's columns are not
      already marked <literal>NOT NULL</>, then this command will attempt to
      do <literal>ALTER COLUMN SET NOT NULL</> against each such column.
      That requires a full table scan to verify the column(s) contain no
      nulls.  In all other cases, this is a fast operation.
     </para>
-->
<para>
如果使用了<literal>PRIMARY KEY</>选项，则索引的列不能已定义为<literal>NOT NULL</>，因为这个选项会对涉及的列去执行<literal>ALTER COLUMN SET NOT NULL</>。
这也会对全表数据进行扫描以验证该列是否包含空值，（全表扫描很慢），在其他情况下，这是一个很快的操作。
</para>

<!--
<para>
      If a constraint name is provided then the index will be renamed to match
      the constraint name.  Otherwise the constraint will be named the same as
      the index.
     </para>
-->
<para>
如果指定了一个约束名，索引将会被重命名为指定的约束中的名称。相反，约束会被命名为索引名。
</para>

     <!--
<para>
      After this command is executed, the index is <quote>owned</> by the
      constraint, in the same way as if the index had been built by
      a regular <literal>ADD PRIMARY KEY</> or <literal>ADD UNIQUE</>
      command.  In particular, dropping the constraint will make the index
      disappear too.
     </para>
-->
<para>
在这个命令执行后，约束就相当于是索引的<quote>所有者</>了，就如同使用了<literal>ADD PRIMARY KEY</>或<literal>ADD UNIQUE</>命令创建的索引一样。
特别要注意的事，这种情况下删除约束也会清除了索引。
</para>

     <note>
<!--
<para>
       Adding a constraint using an existing index can be helpful in
       situations where a new constraint needs to be added without blocking
       table updates for a long time.  To do that, create the index using
       <command>CREATE INDEX CONCURRENTLY</>, and then install it as an
       official constraint using this syntax.  See the example below.
      </para>
-->
<para>
在新增约束时使用已有的索引对新约束增加时对表记录的较长时间不能更新的问题有较好的帮助。
使用<command>CREATE INDEX CONCURRENTLY</>指令可以实现这种方式，参见下面的示例。
</para>
     </note>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>VALIDATE CONSTRAINT</literal></term>
    <listitem>
     <!--
<para>
      This form validates a foreign key or check constraint that was previously created
      as <literal>NOT VALID</literal>, by scanning the table to ensure there
      are no rows for which the constraint is not satisfied.
      Nothing happens if the constraint is already marked valid.
     </para>
-->
<para>
这种形式用于验证一个外键或是一个使用<literal>NOT VALID</literal>选项创建的检查类约束，通过扫描全表来保证所有记录都符合约束条件。
如果约束已标记为有效时，什么操作也不会发生。
</para>
     <!--
<para>
      Validation can be a long process on larger tables and currently requires
      an <literal>ACCESS EXCLUSIVE</literal> lock.  The value of separating
      validation from initial creation is that you can defer validation to less
      busy times, or can be used to give additional time to correct pre-existing
      errors while preventing new errors.
     </para>
-->
<para>
对大表的记录进行验证一般是一个很长的过程，并且目前这种操作还需要<literal>ACCESS EXCLUSIVE</literal>排他类锁。
初始的不同验证可以将验证工作后延至系统不忙时进行，或者通过先花一点额外的时间来纠正可能存在的错误以防止新错误的发生。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DROP CONSTRAINT [ IF EXISTS ]</literal></term>
    <listitem>
     <!--
<para>
      This form drops the specified constraint on a table.
      If <literal>IF EXISTS</literal> is specified and the constraint
      does not exist, no error is thrown. In this case a notice is issued instead.
     </para>
-->
<para>
这种形式删除一个表中指定的约束，如果使用了 <literal>IF EXISTS</literal>选项并且约束并不存在时，也不会有错误产生，仅会有一个提示信息。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DISABLE</literal>/<literal>ENABLE [ REPLICA | ALWAYS ] TRIGGER</literal></term>
    <listitem>
     <!--
<para>
      These forms configure the firing of trigger(s) belonging to the table.
      A disabled trigger is still known to the system, but is not executed
      when its triggering event occurs.  For a deferred trigger, the enable
      status is checked when the event occurs, not when the trigger function
      is actually executed.  One can disable or enable a single
      trigger specified by name, or all triggers on the table, or only
      user triggers (this option excludes internally generated constraint
      triggers such as those that are used to implement foreign key
      constraints or deferrable uniqueness and exclusion constraints).
      Disabling or enabling internally generated constraint triggers
      requires superuser privileges; it should be done with caution since
      of course the integrity of the constraint cannot be guaranteed if the
      triggers are not executed.
      The trigger firing mechanism is also affected by the configuration
      variable <xref linkend="guc-session-replication-role">. Simply enabled
      triggers will fire when the replication role is <quote>origin</>
      (the default) or <quote>local</>. Triggers configured as <literal>ENABLE
      REPLICA</literal> will only fire if the session is in <quote>replica</>
      mode, and triggers configured as <literal>ENABLE ALWAYS</literal> will
      fire regardless of the current replication mode.
     </para>
-->
<para>
这种形式禁用或者启用属于该表的触发器。一个被关闭掉的触发器是系统仍然知道的，但是在触发器事件发生的时候不会被执行。
对于一个推迟了的触发器，在触发事件发生的时候会检查打开状态，触发器相关的函数实际也不会执行。
可以通过指定名字的方法启用或者禁用任意一个触发器，或者是该表上的所有触发器，或者只是用户自定义的触发器(这个选项排除了那些用于实现外键约束或是可延迟的唯一性约束或是排他性约束的触发器)。
启用或者禁用约束触发器要求超级用户权限；这么做的时候应该小心，因为如果触发器不执行的话，约束保证的数据完整性也就没有办法确保了。
触发器启动原理也受配置变量<xref linkend="guc-session-replication-role">影响。
简单启动的触发器将会在复制任务为<quote>初始</>(默认情况)或者<quote>本地</>时启动。
配置为<literal>ENABLE REPLICA</literal>的触发器将会仅在会话为"replica" 模式时启动，而配置为<literal>ENABLE ALWAYS</literal>的触发器将总是会启动，无论是否为当前复制模式。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DISABLE</literal>/<literal>ENABLE [ REPLICA | ALWAYS ] RULE</literal></term>
    <listitem>
     <!--
<para>
      These forms configure the firing of rewrite rules belonging to the table.
      A disabled rule is still known to the system, but is not applied
      during query rewriting. The semantics are as for disabled/enabled
      triggers. This configuration is ignored for <literal>ON SELECT</literal> rules, which
      are always applied in order to keep views working even if the current
      session is in a non-default replication role.
     </para>
-->
<para>
这种形式配置属于表的重写规则制定。一个已禁用的规则对系统来说仍然是可知的，但在查询重写期间是不被应用的。
语义为关闭/启动触发器。这个配置对<literal>ON SELECT</literal>规则来说是可忽略的，常常用来保持视图工作，即使当前会话处于一个非默认的复制角色中。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CLUSTER ON</literal></term>
    <listitem>
     <!--
<para>
      This form selects the default index for future
      <xref linkend="SQL-CLUSTER">
      operations.  It does not actually re-cluster the table.
     </para>
-->
<para>
这种形式为将来的<xref linkend="SQL-CLUSTER">操作选择默认索引。 实际上并没有重新盘簇化处理该表。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET WITHOUT CLUSTER</literal></term>
    <listitem>
     <!--
<para>
      This form removes the most recently used
      <xref linkend="SQL-CLUSTER">
      index specification from the table.  This affects
      future cluster operations that don't specify an index.
     </para>
-->
<para>
这种形式从表中删除最近一次用到的<xref linkend="SQL-CLUSTER">索引定义。这会影响将来不声明索引的盘簇化表的操作。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET WITH OIDS</literal></term>
    <listitem>
     <!--
<para>
      This form adds an <literal>oid</literal> system column to the
      table (see <xref linkend="ddl-system-columns">).
      It does nothing if the table already has OIDs.
     </para>
-->
<para>
这种形式向表中增加一个<literal>oid</literal>系统字段（参见<xref linkend="ddl-system-columns">）。
如果表中已存在有OID字段，则操作对表无任何影响。
</para>

     <!--
<para>
      Note that this is not equivalent to <literal>ADD COLUMN oid oid</>;
      that would add a normal column that happened to be named
      <literal>oid</>, not a system column.
     </para>
-->
<para>
注意这种形式与<literal>ADD COLUMN oid oid</>选项并不相同，后者对给表增加一个普通的字段，只不过它的名称恰好是叫 <literal>oid</>，并非是系统字段。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET WITHOUT OIDS</literal></term>
    <listitem>
     <!--
<para>
      This form removes the <literal>oid</literal> system column from the
      table.  This is exactly equivalent to
      <literal>DROP COLUMN oid RESTRICT</literal>,
      except that it will not complain if there is already no
      <literal>oid</literal> column.
     </para>
-->
<para>
这种形式从表中删除 <literal>oid</literal>系统字段。它和<literal>DROP COLUMN oid RESTRICT</literal>完全相同，只不过是如果表上已经没有<literal>oid</literal>字段的时候不会报错。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET ( <replaceable class="PARAMETER">storage_parameter</replaceable> = <replaceable class="PARAMETER">value</replaceable> [, ... ] )</literal></term>
    <listitem>
     <!--
<para>
      This form changes one or more storage parameters for the table.  See
      <xref linkend="SQL-CREATETABLE-storage-parameters"
      endterm="SQL-CREATETABLE-storage-parameters-title">
      for details on the available parameters.  Note that the table contents
      will not be modified immediately by this command; depending on the
      parameter you might need to rewrite the table to get the desired effects.
      That can be done with <link linkend="SQL-VACUUM">VACUUM
      FULL</>, <xref linkend="SQL-CLUSTER"> or one of the forms
      of <command>ALTER TABLE</> that forces a table rewrite.
     </para>
-->
<para>
这种形式改变表的一个或者更多存储参数。参阅<xref linkend="SQL-CREATETABLE-storage-parameters" endterm="SQL-CREATETABLE-storage-parameters-title">获取关于可用参数的详细信息。
请注意表的内容将不会因为此命令被立刻调整；根据此参数你可能需要重写此表来得到希望的效果。 
这可以通过<link linkend="SQL-VACUUM">VACUUM FULL</>、<xref linkend="SQL-CLUSTER">或者<command>ALTER TABLE</>命令中的选项之一来实现。
</para>

     <note>
      <!--
<para>
       While <command>CREATE TABLE</> allows <literal>OIDS</> to be specified
       in the <literal>WITH (<replaceable
       class="PARAMETER">storage_parameter</>)</literal> syntax,
       <command>ALTER TABLE</> does not treat <literal>OIDS</> as a
       storage parameter.  Instead use the <literal>SET WITH OIDS</>
       and <literal>SET WITHOUT OIDS</> forms to change OID status.
      </para>
-->
<para>
尽管<command>CREATE TABLE</>允许<literal>OIDS</>在<literal>WITH (<replaceable class="PARAMETER">storage_parameter</>)</literal>语义中声明，
但<command>ALTER TABLE</>不会将<literal>OIDS</>作为一个存储参数。
相反地，要使用<literal>SET WITH OIDS</>和<literal>SET WITHOUT OIDS</>形式来更改OID状态。
</para>
     </note>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>RESET ( <replaceable class="PARAMETER">storage_parameter</replaceable> [, ... ] )</literal></term>
    <listitem>
<!--
<para>
      This form resets one or more storage parameters to their
      defaults.  As with <literal>SET</>, a table rewrite might be
      needed to update the table entirely.
     </para>
-->
<para>
这种形式重置表的一个或多个存储参数为缺省值。与<literal>SET</>选项一样，根据参数的不同可能需要重写表才能获得想要的效果。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>INHERIT <replaceable class="PARAMETER">parent_table</replaceable></literal></term>
    <listitem>
     <!--
<para>
      This form adds the target table as a new child of the specified parent
      table.  Subsequently, queries against the parent will include records
      of the target table.  To be added as a child, the target table must
      already contain all the same columns as the parent (it could have
      additional columns, too).  The columns must have matching data types,
      and if they have <literal>NOT NULL</literal> constraints in the parent
      then they must also have <literal>NOT NULL</literal> constraints in the
      child.
     </para>
-->
<para>
这种形式将目标表添加为指定父表的新子表。
之后在父表上的查询将包含目标表中的记录。
要被添加为一个子表，目标表必须已经包含所有与父表相同的字段(除此之外 当然也可以包含一些其它字段)，这些字段的数据类型必须匹配，并且如果父表的字段有<literal>NOT NULL</literal>约束的话子表的相应字段也必须有<literal>NOT NULL</literal>约束。
</para>

<!--
<para>
      There must also be matching child-table constraints for all
      <literal>CHECK</literal> constraints of the parent, except those
      marked non-inheritable (that is, created with <literal>ALTER TABLE ... ADD CONSTRAINT ... NO INHERIT</literal>)
      in the parent, which are ignored; all child-table constraints matched
      must not be marked non-inheritable.
      Currently
      <literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal>, and
      <literal>FOREIGN KEY</literal> constraints are not considered, but
      this might change in the future.
     </para>
-->
<para>
所有父表的<literal>CHECK</literal>约束必须同时与子表的约束匹配。
不过一些标记为不可继承类的约束（类似使用<literal>ALTER TABLE ... ADD CONSTRAINT ... NO INHERIT</literal>创建的约束）不包括在内，
所有子表匹配的约束也不能标记为不可继承。
目前<literal>UNIQUE</literal>、<literal>PRIMARY KEY</literal>和<literal>FOREIGN KEY</literal>约束不被考虑在内，但是将来可能会有所改变。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NO INHERIT <replaceable class="PARAMETER">parent_table</replaceable></literal></term>
    <listitem>
     <!--
<para>
      This form removes the target table from the list of children of the
      specified parent table.
      Queries against the parent table will no longer include records drawn
      from the target table.
     </para>
-->
<para>
这种形式从指定父表的子表列表中删除目标表。这样，在父表上的查询将不再目标表中的记录。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OF <replaceable class="PARAMETER">type_name</replaceable></literal></term>
    <listitem>
     <!--
<para>
      This form links the table to a composite type as though <command>CREATE
      TABLE OF</> had formed it.  The table's list of column names and types
      must precisely match that of the composite type; the presence of
      an <literal>oid</> system column is permitted to differ.  The table must
      not inherit from any other table.  These restrictions ensure
      that <command>CREATE TABLE OF</> would permit an equivalent table
      definition.
     </para>
-->
<para>
这种形式将表链接至一种复合类型，就好象是使用<command>CREATE TABLE OF</>选项创建表一样。
表的字段的名称和类型必须精确匹配复合类型中的定义，不过<literal>oid</>系统字段允许不一样。
表不能是从任何其他表继承的。
这些限制确保<command>CREATE TABLE OF</>选项允许一个相同的表定义。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NOT OF</literal></term>
    <listitem>
     <!--
<para>
      This form dissociates a typed table from its type.
     </para>
-->
<para>
这种形式将一个与某类型进行关联的表进行关联的解除。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OWNER</literal></term>
    <listitem>
     <!--
<para>
      This form changes the owner of the table, sequence, or view to the
      specified user.
     </para>
-->
<para>
这种形式改变表、序列或是视图的所有者为一个指定的用户。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET TABLESPACE</literal></term>
    <listitem>
     <!--
<para>
      This form changes the table's tablespace to the specified tablespace and
      moves the data file(s) associated with the table to the new tablespace.
      Indexes on the table, if any, are not moved; but they can be moved
      separately with additional <literal>SET TABLESPACE</literal> commands.
      See also
      <xref linkend="SQL-CREATETABLESPACE">.
     </para>
-->
<para>
这种形式更改表的表空间为一个指定的表空间，并将与这个表相关的数据文件移至新的表空间。
表上如果有索引，一般不会移动。不过它们也可以通过使用<literal>SET TABLESPACE</literal>命令单独移动，参见<xref linkend="SQL-CREATETABLESPACE">。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>RENAME</literal></term>
    <listitem>
     <!--
<para>
      The <literal>RENAME</literal> forms change the name of a table
      (or an index, sequence, or view), the name of an individual column in
      a table, or the name of a constraint of the table. There is no effect on the stored data.
     </para>
-->
<para>
<literal>RENAME</literal>形式改变一个表(或者索引、序列、视图)的名称，表中单个字段的名称，或是表中约束的名称。
它们对存储的数据没有影响。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET SCHEMA</literal></term>
    <listitem>
     <!--
<para>
      This form moves the table into another schema.  Associated indexes,
      constraints, and sequences owned by table columns are moved as well.
     </para>
-->
<para>
这种形式把表移动到另外一个模式。相关的索引、约束、序列都跟着移动。
</para>
    </listitem>
   </varlistentry>

  </variablelist>


  <!--
<para>
   All the actions except <literal>RENAME</literal> and <literal>SET SCHEMA</>
   can be combined into
   a list of multiple alterations to apply in parallel.  For example, it
   is possible to add several columns and/or alter the type of several
   columns in a single command.  This is particularly useful with large
   tables, since only one pass over the table need be made.
  </para>
-->
<para>
除了<literal>RENAME</literal>和<literal>SET SCHEMA</>之外所有动作都可以组合在一个多次修改列表中同时使用。
比如，可以在一个命令里增加几个字段和/或修改几个字段的类型。
对于大表，这么做特别有用，因为只需要对该表做一次处理。
</para>

  <!--
<para>
   You must own the table to use <command>ALTER TABLE</>.
   To change the schema of a table, you must also have
   <literal>CREATE</literal> privilege on the new schema.
   To add the table as a new child of a parent table, you must own the
   parent table as well.
   To alter the owner, you must also be a direct or indirect member of the new
   owning role, and that role must have <literal>CREATE</literal> privilege on
   the table's schema.  (These restrictions enforce that altering the owner
   doesn't do anything you couldn't do by dropping and recreating the table.
   However, a superuser can alter ownership of any table anyway.)
   To add a column or alter a column type or use the <literal>OF</literal>
   clause, you must also have <literal>USAGE</literal> privilege on the data
   type.
  </para>
-->
<para>
要使用<command>ALTER TABLE</>，你必须是该表的所有者。
要修改一个表的模式，你还必须在新模式上拥有<literal>CREATE</literal>权限。
要把该表添加为一个父表的新子表，你必须同时是父表的所有者。
要修改所有者，你还必须是新的所有角色的直接或间接成员，并且该成员必须在此表的模式上有<literal>CREATE</literal>权限。
（这些限制强制了修改该所有者不会做任何通过删除和重建表不能做的事情。不过，超级用户可以以任何方式修改任意表的所有权。）
增加一个字段或是改变字段的类型或是使用<literal>OF</literal>选项，你也必须对那个数据类型有<literal>USAGE</literal>权限。
</para>
 </refsect1>

 <refsect1>
  <!--
<title>Parameters</title>
-->
<title>参数</title>

    <variablelist>

     <varlistentry>
      <term><replaceable class="PARAMETER">name</replaceable></term>
      <listitem>
       <!--
<para>
        The name (optionally schema-qualified) of an existing table to
        alter. If <literal>ONLY</> is specified before the table name, only
        that table is altered. If <literal>ONLY</> is not specified, the table
        and all its descendant tables (if any) are altered.  Optionally,
        <literal>*</> can be specified after the table name to explicitly
        indicate that descendant tables are included.
       </para>
-->
<para>
要修改的已有表的名称（可以有模式修饰）。若声明了<literal>ONLY</>选项，则只有那个表被更改。若未声明<literal>ONLY</>，该表及其所有子表都将会被更改。
另外，可以在表名称后面精确地增加<literal>*</>选项来指定包括子表。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">column_name</replaceable></term>
      <listitem>
       <!--
<para>
        Name of a new or existing column.
       </para>
-->
<para>
现存或新的字段名称。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">new_column_name</replaceable></term>
      <listitem>
       <!--
<para>
        New name for an existing column.
       </para>
-->
<para>
现存字段的新名称。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">new_name</replaceable></term>
      <listitem>
       <!--
<para>
        New name for the table.
       </para>
-->
<para>
表的新名称。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">type</replaceable></term>
      <listitem>
       <!--
<para>
        Data type of the new column, or new data type for an existing
        column.
       </para>
-->
<para>
新字段的类型，或者现存字段的新类型。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">table_constraint</replaceable></term>
      <listitem>
       <!--
<para>
        New table constraint for the table.
       </para>
-->
<para>
新的表约束。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">constraint_name</replaceable></term>
      <listitem>
<!--
<para>
        Name of an existing constraint to drop.
       </para>
-->
<para>
要删除的现有约束的名字。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CASCADE</literal></term>
      <listitem>
<!--
<para>
        Automatically drop objects that depend on the dropped column
        or constraint (for example, views referencing the column).
       </para>
-->
<para>
级联删除依赖于被依赖字段或者约束的对象(比如引用该字段的视图)。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>RESTRICT</literal></term>
      <listitem>
       <!--
<para>
        Refuse to drop the column or constraint if there are any dependent
        objects. This is the default behavior.
       </para>
-->
<para>
如果字段或者约束还有任何依赖的对象，则拒绝删除该字段。这是缺省行为。。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">trigger_name</replaceable></term>
      <listitem>
       <!--
<para>
        Name of a single trigger to disable or enable.
       </para>
-->
<para>
要启用或者禁用的单个触发器的名字。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ALL</literal></term>
      <listitem>
       <!--
<para>
        Disable or enable all triggers belonging to the table.
        (This requires superuser privilege if any of the triggers are
        internally generated constraint triggers such as those that are used
        to implement foreign key constraints or deferrable uniqueness and
        exclusion constraints.)
       </para>
-->
<para>
启用或者禁用所有属于该表的触发器。（如果任何触发器属于内部会产生约束的触发器，这要求超级用户权限，例如那些用于执行外键约束或者可推迟的独特性和排除约束。）
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>USER</literal></term>
      <listitem>
       <!--
<para>
        Disable or enable all triggers belonging to the table except for
        internally generated constraint triggers such as those that are used
        to implement foreign key constraints or deferrable uniqueness and
        exclusion constraints.
       </para>
-->
<para>
启用或者禁用所有属于表的触发器，除了任何属于内部会产生约束的触发器，例如那些用于执行外键约束或者可推迟的独特性和排除约束。）
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">index_name</replaceable></term>
      <listitem>
       <!--
<para>
        The index name on which the table should be marked for clustering.
       </para>
-->
<para>
要标记为盘簇化的表上面的索引名字。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">storage_parameter</replaceable></term>
      <listitem>
       <!--
<para>
        The name of a table storage parameter.
       </para>
-->
<para>
表的存储参数的名字。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">value</replaceable></term>
      <listitem>
       <!--
<para>
        The new value for a table storage parameter.
        This might be a number or a word depending on the parameter.
       </para>
-->
<para>
表的存储参数的新值，根据参数的不同，可能是一个数字或单词。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">parent_table</replaceable></term>
      <listitem>
       <!--
<para>
        A parent table to associate or de-associate with this table.
       </para>
-->
<para>
将要与该表建立/取消关联的父表。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">new_owner</replaceable></term>
      <listitem>
       <!--
<para>
        The user name of the new owner of the table.
       </para>
-->
<para>
该表的新所有者的用户名。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">new_tablespace</replaceable></term>
      <listitem>
       <!--
<para>
        The name of the tablespace to which the table will be moved.
       </para>
-->
<para>
这个表将要移动到的表空间名字。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">new_schema</replaceable></term>
      <listitem>
       <!--
<para>
        The name of the schema to which the table will be moved.
       </para>
-->
<para>
表将移动到的新模式的名字。
</para>
      </listitem>
     </varlistentry>

    </variablelist>
 </refsect1>

 <refsect1>
  <!--
<title>Notes</title>
-->
<title>注意</title>

   <!--
<para>
    The key word <literal>COLUMN</literal> is noise and can be omitted.
   </para>
-->
<para>
<literal>COLUMN</literal>关键字是多余的，可以省略。。
</para>

   <!--
<para>
    When a column is added with <literal>ADD COLUMN</literal>, all existing
    rows in the table are initialized with the column's default value
    (NULL if no <literal>DEFAULT</> clause is specified).
   </para>
-->
<para>
如果用<literal>ADD COLUMN</literal>增加一个字段，那么所有表中现有行都初始化为该字段的缺省值(如果没有声明<literal>DEFAULT</>子句，那么就是 NULL)。
</para>

   <!--
<para>
    Adding a column with a non-null default or changing the type of an
    existing column will require the entire table and indexes to be rewritten.
    As an exception, if the <literal>USING</> clause does not change the column
    contents and the old type is either binary coercible to the new type or
    an unconstrained domain over the new type, a table rewrite is not needed,
    but any indexes on the affected columns must still be rebuilt.  Adding or
    removing a system <literal>oid</> column also requires rewriting the entire
    table.  Table and/or index rebuilds may take a significant amount of time
    for a large table; and will temporarily require as much as double the disk
    space.
   </para>
-->
<para>
添加一个非空缺省值列或者改变一个原有列的类型需要重写整个表和索引。 
不过也有例外，如果使用<literal>USING</>选项不改变字段的内容并且字段的新旧类型是二进制兼容的，也可以不重写表。
添加或者删除一个系统<literal>oid</>列同样需要重写整个表。
大表及索引的重写可能需要非常长的时间，并且也临时需要两倍的磁盘空间。
</para>

   <!--
<para>
    Adding a <literal>CHECK</> or <literal>NOT NULL</> constraint requires
    scanning the table to verify that existing rows meet the constraint.
   </para>
-->
<para>
增加一个<literal>CHECK</>或<literal>NOT NULL</>约束将会扫描该表以保证现有的行符合约束要求。
</para>

   <!--
<para>
    The main reason for providing the option to specify multiple changes
    in a single <command>ALTER TABLE</> is that multiple table scans or
    rewrites can thereby be combined into a single pass over the table.
   </para>
-->
<para>
提供在一个<command>ALTER TABLE</>里面声明多个修改的主要原因是原先需要的对表的多次扫描和重写可以组合成一个操作。
</para>

   <!--
<para>
    The <literal>DROP COLUMN</literal> form does not physically remove
    the column, but simply makes it invisible to SQL operations.  Subsequent
    insert and update operations in the table will store a null value for the
    column. Thus, dropping a column is quick but it will not immediately
    reduce the on-disk size of your table, as the space occupied
    by the dropped column is not reclaimed.  The space will be
    reclaimed over time as existing rows are updated.  (These statements do
    not apply when dropping the system <literal>oid</> column; that is done
    with an immediate rewrite.)
   </para>
-->
<para>
<literal>DROP COLUMN</literal>命令并不是物理上把字段删除，而只是简单地 把它标记为对 SQL 操作不可见。
随后对该表的插入和更新将在该字段存储一个 NULL 。 
因此，删除一个字段是很快的，但是它不会立即释放表在磁盘上的空间，因为被删除 了的字段占据的空间还没有回收。
这些空间将随着现有的行的更新而得到回收。 (在删除系统<literal>oid</>列时，方式有点不同，这个操作是直接执行了一次表的重写。)
</para>

<!--
<para>
    To force an immediate rewrite of the table, you can use
    <link linkend="SQL-VACUUM">VACUUM FULL</>, <xref linkend="SQL-CLUSTER">
    or one of the forms of ALTER TABLE that forces a rewrite.  This results in
    no semantically-visible change in the table, but gets rid of
    no-longer-useful data.
   </para>
-->
<para>
要强制立刻执行一次表的重写，可以使用<link linkend="SQL-VACUUM">VACUUM FULL</>、<xref linkend="SQL-CLUSTER">或是ALTER TABLE命令中的一些形式。
这些命令从可见的语义上不会对表产生更新，但会清除不再有用的数据。
</para>

   <!--
<para>
    The <literal>USING</literal> option of <literal>SET DATA TYPE</> can actually
    specify any expression involving the old values of the row; that is, it
    can refer to other columns as well as the one being converted.  This allows
    very general conversions to be done with the <literal>SET DATA TYPE</>
    syntax.  Because of this flexibility, the <literal>USING</literal>
    expression is not applied to the column's default value (if any); the
    result might not be a constant expression as required for a default.
    This means that when there is no implicit or assignment cast from old to
    new type, <literal>SET DATA TYPE</> might fail to convert the default even
    though a <literal>USING</literal> clause is supplied.  In such cases,
    drop the default with <literal>DROP DEFAULT</>, perform the <literal>ALTER
    TYPE</>, and then use <literal>SET DEFAULT</> to add a suitable new
    default.  Similar considerations apply to indexes and constraints involving
    the column.
   </para>
-->
<para>
使用<literal>SET DATA TYPE</>命令中的<literal>USING</literal>选项实际上可以指定任何表达式涉及到记录旧值；
也就是说，它可以引用除了正在被转换的字段之外其它的字段。
这样，就可以用<literal>SET DATA TYPE</>E语法做非常普遍性的转换。
因为这个灵活性， <literal>USING</literal>表达式并没有应用于该字段的缺省值(如果有的话)；结果可能不是缺省表达式要求的常量表达式。
这就意味着如果从旧类型到新类型没有隐含或者赋值 转换的话，那么即使存在<literal>USING</literal>选项，<literal>SET DATA TYPE</>也可能无法把缺省值转换成新的类型。
在这种情况下，应该用<literal>DROP DEFAULT</>先删除缺省值，执行 <literal>ALTER TYPE</>，然后使用<literal>SET DEFAULT</>增加一个 合适的新缺省值。
类似的考虑也适用于涉及该字段的索引和约束。
</para>

   <!--
<para>
    If a table has any descendant tables, it is not permitted to add,
    rename, or change the type of a column, or rename an inherited constraint
    in the parent table without doing
    the same to the descendants.  That is, <command>ALTER TABLE ONLY</command>
    will be rejected.  This ensures that the descendants always have
    columns matching the parent.
   </para>
-->
<para>
如果一个表有子表，那么如果不在子表上做同样的修改的话，就不允许在父表上增加、 重命名、修改一个字段的类型。
也就是说，<command>ALTER TABLE ONLY</command>将被拒绝执行。
这样就保证了子表总是有和父表匹配的字段。
</para>

   <!--
<para>
    A recursive <literal>DROP COLUMN</literal> operation will remove a
    descendant table's column only if the descendant does not inherit
    that column from any other parents and never had an independent
    definition of the column.  A nonrecursive <literal>DROP
    COLUMN</literal> (i.e., <command>ALTER TABLE ONLY ... DROP
    COLUMN</command>) never removes any descendant columns, but
    instead marks them as independently defined rather than inherited.
   </para>
-->
<para>
一个递归 <literal>DROP COLUMN</literal>操作将只有在子表并不从任何其它父表中继承该字段并且从来没有独立定义该字段的时候才能删除一个子表的字段。
一个非递归的<literal>DROP COLUMN</literal>(也就是 <command>ALTER TABLE ONLY ... DROP COLUMN</command>) 从来不会删除任何子表字段，
而是把他们标记为独立定义的(而不是继承的)。
。
</para>

   <!--
<para>
    The <literal>TRIGGER</>, <literal>CLUSTER</>, <literal>OWNER</>,
    and <literal>TABLESPACE</> actions never recurse to descendant tables;
    that is, they always act as though <literal>ONLY</> were specified.
    Adding a constraint recurses only for <literal>CHECK</> constraints
    that are not marked <literal>NO INHERIT</>.
   </para>
-->
<para>
<literal>TRIGGER</>、<literal>CLUSTER</>、<literal>OWNER</>和<literal>TABLESPACE</>的操作绝不会递归影响到子表；
也就是说，它们的行为就像总是声明了<literal>ONLY</> 一样。 只有没有标记为<literal>NO INHERIT</>的<literal>CHECK</>约束才能添加一个递归性的约束。
</para>

   <!--
<para>
    Changing any part of a system catalog table is not permitted.
   </para>
-->
<para>
不允许更改系统表结构的任何部分。
</para>

   <!--
<para>
    Refer to <xref linkend="sql-createtable"> for a further description of valid
    parameters. <xref linkend="ddl"> has further information on
    inheritance.
   </para>
-->
<para>
请参考<xref linkend="sql-createtable">部分获取更多有效参数的描述。<xref linkend="ddl">章节里有更多有关继承的信息。。
</para>
 </refsect1>

 <refsect1>
  <!--
<title>Examples</title>
-->
<title>例子</title>

  <!--
<para>
   To add a column of type <type>varchar</type> to a table:
<programlisting>
ALTER TABLE distributors ADD COLUMN address varchar(30);
</programlisting>
  </para>
-->
<para>
向表中增加一个<type>varchar</type>字段：
<programlisting>
ALTER TABLE distributors ADD COLUMN address varchar(30);
</programlisting>
</para>

  <!--
<para>
   To drop a column from a table:
<programlisting>
ALTER TABLE distributors DROP COLUMN address RESTRICT;
</programlisting>
  </para>
-->
<para>
从表中删除一个字段：
<programlisting>
ALTER TABLE distributors DROP COLUMN address RESTRICT;
</programlisting>
</para>

  <!--
<para>
   To change the types of two existing columns in one operation:
<programlisting>
ALTER TABLE distributors
    ALTER COLUMN address TYPE varchar(80),
    ALTER COLUMN name TYPE varchar(100);
</programlisting>
  </para>
-->
<para>
在一个操作中修改两个现有字段的类型：
<programlisting>
ALTER TABLE distributors
    ALTER COLUMN address TYPE varchar(80),
    ALTER COLUMN name TYPE varchar(100);
</programlisting>
</para>

  <!--
<para>
   To change an integer column containing UNIX timestamps to <type>timestamp
   with time zone</type> via a <literal>USING</literal> clause:
<programlisting>
ALTER TABLE foo
    ALTER COLUMN foo_timestamp SET DATA TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second';
</programlisting>
  </para>
-->
<para>
使用一个<literal>USING</literal>选项，把一个包含 UNIX 时间戳的 integer 字段转化成 <type>timestamp with time zone</type>字段：
<programlisting>
ALTER TABLE foo
    ALTER COLUMN foo_timestamp SET DATA TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second';
</programlisting>
</para>

  <!--
<para>
   The same, when the column has a default expression that won't automatically
   cast to the new data type:
<programlisting>
ALTER TABLE foo
    ALTER COLUMN foo_timestamp DROP DEFAULT,
    ALTER COLUMN foo_timestamp TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second',
    ALTER COLUMN foo_timestamp SET DEFAULT now();
</programlisting>
  </para>
-->
<para>
同样地，当字段有一个不会自动转换成新类型的缺省值表达式时：
<programlisting>
ALTER TABLE foo
    ALTER COLUMN foo_timestamp DROP DEFAULT,
    ALTER COLUMN foo_timestamp TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second',
    ALTER COLUMN foo_timestamp SET DEFAULT now();
</programlisting>
</para>

  <!--
<para>
   To rename an existing column:
<programlisting>
ALTER TABLE distributors RENAME COLUMN address TO city;
</programlisting>
  </para>
-->
<para>
对现有字段改名：
<programlisting>
ALTER TABLE distributors RENAME COLUMN address TO city;
</programlisting>
</para>

  <!--
<para>
   To rename an existing table:
<programlisting>
ALTER TABLE distributors RENAME TO suppliers;
</programlisting>
  </para>
-->
<para>
更改现有表的名字：
<programlisting>
ALTER TABLE distributors RENAME TO suppliers;
</programlisting>
</para>

  <!--
<para>
   To rename an existing constraint:
<programlisting>
ALTER TABLE distributors RENAME CONSTRAINT zipchk TO zip_check;
</programlisting>
  </para>
-->
<para>
更改现有约束的名字：
<programlisting>
ALTER TABLE distributors RENAME CONSTRAINT zipchk TO zip_check;
</programlisting>
</para>

  <!--
<para>
   To add a not-null constraint to a column:
<programlisting>
ALTER TABLE distributors ALTER COLUMN street SET NOT NULL;
</programlisting>
   To remove a not-null constraint from a column:
<programlisting>
ALTER TABLE distributors ALTER COLUMN street DROP NOT NULL;
</programlisting>
  </para>
-->
<para>
给一个字段增加一个非空约束：
<programlisting>
ALTER TABLE distributors ALTER COLUMN street SET NOT NULL;
</programlisting>
从一个字段里删除一个非空约束：
<programlisting>
ALTER TABLE distributors ALTER COLUMN street DROP NOT NULL;
</programlisting>
</para>

  <!--
<para>
   To add a check constraint to a table and all its children:
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5);
</programlisting>
  </para>
-->
<para>
给一个表增加一个检查约束：
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5);
</programlisting>
</para>

  <!--
<para>
   To add a check constraint only to a table and not to its children:
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5) NO INHERIT;
</programlisting>
   (The check constraint will not be inherited by future children, either.)
  </para>
-->
<para>
给一个表且不包含其子表增加一个检查约束：
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5) NO INHERIT;
</programlisting>
（这个检查约束也不会被以后新增的子表继承。）
</para>

  <!--
<para>
   To remove a check constraint from a table and all its children:
<programlisting>
ALTER TABLE distributors DROP CONSTRAINT zipchk;
</programlisting>
  </para>
-->
<para>
删除一个表及其所有子表的检查约束：
<programlisting>
ALTER TABLE distributors DROP CONSTRAINT zipchk;
</programlisting>
</para>

  <!--
<para>
   To remove a check constraint from one table only:
<programlisting>
ALTER TABLE ONLY distributors DROP CONSTRAINT zipchk;
</programlisting>
   (The check constraint remains in place for any child tables.)
  </para>
-->
<para>
从表中删除一个检查约束（不包含子表）：
<programlisting>
ALTER TABLE ONLY distributors DROP CONSTRAINT zipchk;
</programlisting>
（这个检查约束对所有子表仍保留。）
</para>

  <!--
<para>
   To add a foreign key constraint to a table:
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES addresses (address);
</programlisting>
  </para>
-->
<para>
向表中增加一个外键约束：
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES addresses (address);
</programlisting>
</para>

  <!--
<para>
   To add a (multicolumn) unique constraint to a table:
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT dist_id_zipcode_key UNIQUE (dist_id, zipcode);
</programlisting>
  </para>
-->
<para>
给表增加一个(多字段)唯一约束：
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT dist_id_zipcode_key UNIQUE (dist_id, zipcode);
</programlisting>
</para>

  <!--
<para>
   To add an automatically named primary key constraint to a table, noting
   that a table can only ever have one primary key:
<programlisting>
ALTER TABLE distributors ADD PRIMARY KEY (dist_id);
</programlisting>
  </para>
-->
<para>
给一个表增加一个自动命名的主键约束，要注意的是一个表只能有一个主键：
<programlisting>
ALTER TABLE distributors ADD PRIMARY KEY (dist_id);
</programlisting>
</para>

  <!--
<para>
   To move a table to a different tablespace:
<programlisting>
ALTER TABLE distributors SET TABLESPACE fasttablespace;
</programlisting>
  </para>
-->
<para>
把表移动到另外一个表空间：
<programlisting>
ALTER TABLE distributors SET TABLESPACE fasttablespace;
</programlisting>
</para>

  <!--
<para>
   To move a table to a different schema:
<programlisting>
ALTER TABLE myschema.distributors SET SCHEMA yourschema;
</programlisting>
  </para>
-->
<para>
把表移动到另外一个模式：
<programlisting>
ALTER TABLE myschema.distributors SET SCHEMA yourschema;
</programlisting>
</para>

  <!--
<para>
   To recreate a primary key constraint, without blocking updates while the
   index is rebuilt:
<programlisting>
CREATE UNIQUE INDEX CONCURRENTLY dist_id_temp_idx ON distributors (dist_id);
ALTER TABLE distributors DROP CONSTRAINT distributors_pkey,
    ADD CONSTRAINT distributors_pkey PRIMARY KEY USING INDEX dist_id_temp_idx;
</programlisting></para>
-->
<para>
重新创建一个主键约束，并且在主键索引在创建时不影响记录的更新：
<programlisting>
CREATE UNIQUE INDEX CONCURRENTLY dist_id_temp_idx ON distributors (dist_id);
ALTER TABLE distributors DROP CONSTRAINT distributors_pkey,
    ADD CONSTRAINT distributors_pkey PRIMARY KEY USING INDEX dist_id_temp_idx;
</programlisting>
</para>

 </refsect1>

 <refsect1>
  <!--
<title>Compatibility</title>
-->
<title>兼容性</title>

  <!--
<para>
   The forms <literal>ADD</literal> (without <literal>USING INDEX</literal>),
   <literal>DROP</>, <literal>SET DEFAULT</>,
   and <literal>SET DATA TYPE</literal> (without <literal>USING</literal>)
   conform with the SQL standard.  The other forms are
   <productname>PostgreSQL</productname> extensions of the SQL standard.
   Also, the ability to specify more than one manipulation in a single
   <command>ALTER TABLE</> command is an extension.
  </para>
-->
<para>
<literal>ADD</literal> (不包含<literal>USING INDEX</literal>)、<literal>DROP</>、<literal>SET DEFAULT</>和<literal>SET DATA TYPE</literal> (不包含<literal>USING</literal>)形式与 SQL 标准兼容。
其它形式是<productname>PostgreSQL</productname>对 SQL 标准 的扩展。还有，在一个<command>ALTER TABLE</>命令里声明多个操作也是扩展。
</para>

  <!--
<para>
   <command>ALTER TABLE DROP COLUMN</> can be used to drop the only
   column of a table, leaving a zero-column table.  This is an
   extension of SQL, which disallows zero-column tables.
  </para>
-->
<para>
<command>ALTER TABLE DROP COLUMN</>可以用于删除表中的唯一的一个字段，留下一个零字段的表。这是对 SQL 的扩展，它不允许零字段表。
</para>
 </refsect1>

 <refsect1>
  <!--
<title>See Also</title>
-->
<title>参见</title>

  <simplelist type="inline">
   <member><xref linkend="sql-createtable"></member>
  </simplelist>
 </refsect1>
</refentry>
