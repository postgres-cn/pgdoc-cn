<!--
doc/src/sgml/ref/create_policy.sgml
PostgreSQL documentation
-->

<refentry id="SQL-CREATEPOLICY">
<!--==========================orignal english content==========================
 <indexterm zone="sql-createpolicy">
  <primary>CREATE POLICY</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="sql-createpolicy">
  <primary>CREATE POLICY</primary>
 </indexterm>

<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>CREATE POLICY</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>CREATE POLICY</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>CREATE POLICY</refname>
  <refpurpose>define a new row level security policy for a table</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>CREATE POLICY</refname>
  <refpurpose>为一个表定义一条新的行级安全性策略</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
CREATE POLICY <replaceable class="parameter">name</replaceable> ON <replaceable class="parameter">table_name</replaceable>
    [ AS { PERMISSIVE | RESTRICTIVE } ]
    [ FOR { ALL | SELECT | INSERT | UPDATE | DELETE } ]
    [ TO { <replaceable class="parameter">role_name</replaceable> | PUBLIC | CURRENT_USER | SESSION_USER } [, ...] ]
    [ USING ( <replaceable class="parameter">using_expression</replaceable> ) ]
    [ WITH CHECK ( <replaceable class="parameter">check_expression</replaceable> ) ]
</synopsis>
____________________________________________________________________________-->
<synopsis>
CREATE POLICY <replaceable class="parameter">name</replaceable> ON <replaceable class="parameter">table_name</replaceable>
    [ AS { PERMISSIVE | RESTRICTIVE } ]
    [ FOR { ALL | SELECT | INSERT | UPDATE | DELETE } ]
    [ TO { <replaceable class="parameter">role_name</replaceable> | PUBLIC | CURRENT_USER | SESSION_USER } [, ...] ]
    [ USING ( <replaceable class="parameter">using_expression</replaceable> ) ]
    [ WITH CHECK ( <replaceable class="parameter">check_expression</replaceable> ) ]
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   The <command>CREATE POLICY</command> command defines a new row-level
   security policy for a table.  Note that row-level security must be
   enabled on the table (using <command>ALTER TABLE ... ENABLE ROW LEVEL
   SECURITY</command>) in order for created policies to be applied.
  </para>
____________________________________________________________________________-->
  <para>
   <command>CREATE POLICY</command>为一个表定义一条行级
   安全性策略。注意为了应用已被创建的策略，在表上必须启用行级安全
   性（使用<command>ALTER TABLE ... ENABLE ROW LEVEL
   SECURITY</command>）。
  </para>

<!--==========================orignal english content==========================
  <para>
   A policy grants the permission to select, insert, update, or delete rows
   that match the relevant policy expression.  Existing table rows are
   checked against the expression specified in <literal>USING</literal>,
   while new rows that would be created via <literal>INSERT</literal>
   or <literal>UPDATE</literal> are checked against the expression specified
   in <literal>WITH CHECK</literal>.  When a <literal>USING</literal>
   expression returns true for a given row then that row is visible to the
   user, while if false or null is returned then the row is not visible.
   When a <literal>WITH CHECK</literal> expression returns true for a row
   then that row is inserted or updated, while if false or null is returned
   then an error occurs.
  </para>
____________________________________________________________________________-->
  <para>
   一条策略授予权限以选择、插入、更新或者删除匹配相关策略表达式的行。
   现有的表行会按照<literal>USING</literal>中指定的表达式进行检查，
   而将要通过<literal>INSERT</literal>或<literal>UPDATE</literal>创建
   的新行会按照<literal>WITH CHECK</literal>中指定的表达式进行检查。
   当<literal>USING</literal>表达式对于一个给定行返回真时，该行对用户
   可见，而返回假或空时该行不可见。当一个<literal>WITH CHECK</literal>
   表达式对一行返回真时，该行会被插入或更新，而如果返回假或空时会发生
   一个错误。
  </para>

<!--==========================orignal english content==========================
  <para>
   For <command>INSERT</command> and <command>UPDATE</command> statements,
   <literal>WITH CHECK</literal> expressions are enforced after
   <literal>BEFORE</literal> triggers are fired, and before any actual data
   modifications are made.  Thus a <literal>BEFORE ROW</literal> trigger may
   modify the data to be inserted, affecting the result of the security
   policy check.  <literal>WITH CHECK</literal> expressions are enforced
   before any other constraints.
  </para>
____________________________________________________________________________-->
  <para>
   对于<command>INSERT</command>和
   <command>UPDATE</command>语句，在<literal>BEFORE</literal>
   触发器被引发后并且在任何数据修改真正发生之前，
   <literal>WITH CHECK</literal>表达式会被强制。因此，
   一个<literal>BEFORE ROW</literal>触发器可以修改要被插入的数据，
   从而影响安全性策略检查的结果。<literal>WITH CHECK</literal>表达式
   在任何其他约束之前被强制。
  </para>

<!--==========================orignal english content==========================
  <para>
   Policy names are per-table.  Therefore, one policy name can be used for many
   different tables and have a definition for each table which is appropriate to
   that table.
  </para>
____________________________________________________________________________-->
  <para>
   策略名称是针对每个表的。因此，一个策略名称可以被用于很多个不同的表
   并且对于不同的表呈现适合于该表的定义。
  </para>

<!--==========================orignal english content==========================
  <para>
   Policies can be applied for specific commands or for specific roles.  The
   default for newly created policies is that they apply for all commands and
   roles, unless otherwise specified.
  </para>
____________________________________________________________________________-->
  <para>
   策略可以被应用于特定的命令或者特定的角色。除非特别指定，新创建的策略
   的默认行为是适用于所有命令和角色。
  </para>

<!--==========================orignal english content==========================
  <para>
   For policies that can have both <literal>USING</literal>
   and <literal>WITH CHECK</literal> expressions (<literal>ALL</literal>
   and <literal>UPDATE</literal>), if no <literal>WITH CHECK</literal>
   expression is defined, then the <literal>USING</literal> expression will be
   used both to determine which rows are visible (normal
   <literal>USING</literal> case) and which new rows will be allowed to be
   added (<literal>WITH CHECK</literal> case).
  </para>
____________________________________________________________________________-->
  <para>
   对同时具有<literal>USING</literal>和<literal>WITH CHECK</literal>
   表达式（<literal>ALL</literal>和<literal>UPDATE</literal>）的策略，
   如果没有定义<literal>WITH CHECK</literal>表达式，那么
   <literal>USING</literal>表达式将被用于决定哪些行可见（普通
   <literal>USING</literal>情况）以及允许哪些行被增加（
   <literal>WITH CHECK</literal>情况）。
  </para>

<!--==========================orignal english content==========================
  <para>
   If row-level security is enabled for a table, but no applicable policies
   exist, a <quote>default deny</> policy is assumed, so that no rows will
   be visible or updatable.
  </para>
____________________________________________________________________________-->
  <para>
   如果为一个表启用了行级安全性但是没有适用的策略存在，将假定为一种
   <quote>默认否定</>策略，这样任何行都不可见也不可更新。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Parameters</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">name</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">name</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The name of the policy to be created.  This must be distinct from the
      name of any other policy for the table.
     </para>
____________________________________________________________________________-->
     <para>
      要创建的策略的名称。这必须和该表上已有的任何其他策略名称相区分。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">table_name</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">table_name</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The name (optionally schema-qualified) of the table the
      policy applies to.
     </para>
____________________________________________________________________________-->
     <para>
      该策略适用的表的名称（可以被模式限定）。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>PERMISSIVE</literal></term>
____________________________________________________________________________-->
    <term><literal>PERMISSIVE</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Specify that the policy is to be created as a permissive policy.
      All permissive policies which are applicable to a given query will
      be combined together using the Boolean <quote>OR</quote> operator.  By creating
      permissive policies, administrators can add to the set of records
      which can be accessed.  Policies are permissive by default.
     </para>
____________________________________________________________________________-->
     <para>
      指定将策略创建为宽松策略。所有适用于给定查询的宽松策略将使用布尔的
	  <quote>OR</quote>运算符组合在一起。通过创建宽松的策略，
	  管理员可以添加到可以访问的记录集。策略默认是宽容的。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>RESTRICTIVE</literal></term>
____________________________________________________________________________-->
    <term><literal>RESTRICTIVE</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Specify that the policy is to be created as a restrictive policy.
      All restrictive policies which are applicable to a given query will
      be combined together using the Boolean <quote>AND</quote> operator.  By creating
      restrictive policies, administrators can reduce the set of records
      which can be accessed as all restrictive policies must be passed for
      each record.
     </para>
____________________________________________________________________________-->
     <para>
      指定将该策略创建为限制性策略。所有适用于给定查询的限制性策略将使用布尔
	  <quote>AND</quote>运算符组合在一起。通过创建限制性策略，
	  管理员可以减少可以访问的记录集，因为必须为每条记录传递所有限制性策略。
     </para>

<!--==========================orignal english content==========================
     <para>
      Note that there needs to be at least one permissive policy to grant
      access to records before restrictive policies can be usefully used to
      reduce that access. If only restrictive policies exist, then no records
      will be accessible. When a mix of permissive and restrictive policies
      are present, a record is only accessible if at least one of the
      permissive policies passes, in addition to all the restrictive
      policies.
     </para>
____________________________________________________________________________-->
     <para>
      请注意，在限制性策略可用于减少访问权限之前，
	  需要至少有一项宽松策略来授予对记录的访问权限。如果只有限制性政策存在，
	  则不能访问任何记录。如果存在一系列宽松策略和限制性策略，
	  那么除了所有限制性政策之外，只有在至少有一项宽松政策通过的情况下才能获得记录。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">command</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">command</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The command to which the policy applies.  Valid options are
      <command>ALL</command>, <command>SELECT</command>,
      <command>INSERT</command>, <command>UPDATE</command>,
      and <command>DELETE</command>.
      <command>ALL</command> is the default.
      See below for specifics regarding how these are applied.
     </para>
____________________________________________________________________________-->
     <para>
      该策略适用的命令。合法的选项是
      <command>ALL</command>、<command>SELECT</command>、
      <command>INSERT</command>、<command>UPDATE</command>
      以及<command>DELETE</command>。
      <command>ALL</command>为默认。有关这些策略如何被应用的
      细节见下文。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">role_name</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">role_name</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The role(s) to which the policy is to be applied.  The default is
      <literal>PUBLIC</literal>, which will apply the policy to all roles.
     </para>
____________________________________________________________________________-->
     <para>
      该策略适用的角色。默认是<literal>PUBLIC</literal>，它将把策略应用
      到所有的角色。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">using_expression</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">using_expression</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Any <acronym>SQL</acronym> conditional expression (returning
      <type>boolean</type>).  The conditional expression cannot contain
      any aggregate or window functions.  This expression will be added
      to queries that refer to the table if row level security is enabled.
      Rows for which the expression returns true will be visible.  Any
      rows for which the expression returns false or null will not be
      visible to the user (in a <command>SELECT</>), and will not be
      available for modification (in an <command>UPDATE</>
      or <command>DELETE</>).  Such rows are silently suppressed; no error
      is reported.
     </para>
____________________________________________________________________________-->
     <para>
      任意的<acronym>SQL</acronym>条件表达式（返回
      <type>boolean</type>）。该条件表达式不能包含任何聚集或者窗口
      函数。如果行级安全性被启用，这个表达式将被增加到引用该表的查询。
      让这个表达式返回真的行将可见。让这个表达式返回假或者空的任何行
      将对用户不可见（在<command>SELECT</>中）并且将对修改不可用（
      在<command>UPDATE</>或<command>DELETE</>中）。这类行
      会被悄悄地禁止而不会报告错误。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">check_expression</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">check_expression</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Any <acronym>SQL</acronym> conditional expression (returning
      <type>boolean</type>).  The conditional expression cannot contain
      any aggregate or window functions.  This expression will be used in
      <command>INSERT</command> and <command>UPDATE</command> queries against
      the table if row level security is enabled.  Only rows for which the
      expression evaluates to true will be allowed.  An error will be thrown
      if the expression evaluates to false or null for any of the records
      inserted or any of the records that result from the update.  Note that
      the <replaceable class="parameter">check_expression</replaceable> is
      evaluated against the proposed new contents of the row, not the
      original contents.
     </para>
____________________________________________________________________________-->
     <para>
      任意的<acronym>SQL</acronym>条件表达式（返回
      <type>boolean</type>）。该条件表达式不能包含任何聚集或者窗口
      函数。如果行级安全性被启用，这个表达式将被用在该表上的
      <command>INSERT</command>以及
      <command>UPDATE</command>查询中。只有让该表达式计算为真
      的行才被允许。如果任何被插入的记录或者跟新后的记录导致该表达式计
      算为假或者空，则会抛出一个错误。注意
      <replaceable class="parameter">check_expression</replaceable>
      是根据行的新内容而不是原始内容计算的。
     </para>
    </listitem>
   </varlistentry>

  </variablelist>

 <refsect2>
<!--==========================orignal english content==========================
   <title>Per-Command Policies</title>
____________________________________________________________________________-->
   <title>针对每种命令的策略</title>

   <variablelist>

     <varlistentry id="SQL-CREATEPOLICY-ALL">
<!--==========================orignal english content==========================
      <term><literal>ALL</></term>
____________________________________________________________________________-->
      <term><literal>ALL</></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
         Using <literal>ALL</literal> for a policy means that it will apply
         to all commands, regardless of the type of command.  If an
         <literal>ALL</literal> policy exists and more specific policies
         exist, then both the <literal>ALL</literal> policy and the more
         specific policy (or policies) will be applied.
         Additionally, <literal>ALL</literal> policies will be applied to
         both the selection side of a query and the modification side, using
         the <literal>USING</literal> expression for both cases if only
         a <literal>USING</literal> expression has been defined.
       </para>
____________________________________________________________________________-->
       <para>
         为一条策略使用<literal>ALL</literal>表示它将适用于所有命令，
         不管命令的类型如何。如果存在一条<literal>ALL</literal>策略
         以及更多特定的策略，则<literal>ALL</literal>策略和那些策略
         都会应用。此外，
         <literal>ALL</literal>策略将同时适用于一个查询的选择端和修
         改端，如果只定义了一个<literal>USING</literal>表达式则将
         该<literal>USING</literal>表达式用于两种情况。
       </para>
<!--==========================orignal english content==========================
       <para>
         As an example, if an <literal>UPDATE</literal> is issued, then the
         <literal>ALL</literal> policy will be applicable both to what the
         <literal>UPDATE</literal> will be able to select as rows to be
         updated (applying the <literal>USING</literal> expression),
         and to the resulting updated rows, to check if they are permitted
         to be added to the table (applying the <literal>WITH CHECK</literal>
         expression, if defined, and the <literal>USING</literal> expression
         otherwise).  If an <command>INSERT</command>
         or <command>UPDATE</command> command attempts to add rows to the
         table that do not pass the <literal>ALL</literal>
         policy's <literal>WITH CHECK</literal> expression, the entire
         command will be aborted.
       </para>
____________________________________________________________________________-->
       <para>
         例如，如果发出一个<literal>UPDATE</literal>，那么
         <literal>ALL</literal>策略将同时影响<literal>UPDATE</literal>
         能更新哪些行（应用<literal>USING</literal>表达式）以及更新后
         的行是否被允许加入到表中（如果定义了<literal>WITH CHECK</literal>
         表达式，则应用之；否则使用<literal>USING</literal>表达式）。
         如果一条<command>INSERT</command>
         或者<command>UPDATE</command>命令尝试增加行到表中，
         但行没有通过<literal>ALL</literal>策略的
         <literal>WITH CHECK</literal>表达式，则整个语句将会中断。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="SQL-CREATEPOLICY-SELECT">
<!--==========================orignal english content==========================
      <term><literal>SELECT</></term>
____________________________________________________________________________-->
      <term><literal>SELECT</></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
         Using <literal>SELECT</literal> for a policy means that it will apply
         to <literal>SELECT</literal> queries and whenever
         <literal>SELECT</literal> permissions are required on the relation the
         policy is defined for.  The result is that only those records from the
         relation that pass the <literal>SELECT</literal> policy will be
         returned during a <literal>SELECT</literal> query, and that queries
         that require <literal>SELECT</literal> permissions, such as
         <literal>UPDATE</literal>, will also only see those records
         that are allowed by the <literal>SELECT</literal> policy.
         A <literal>SELECT</literal> policy cannot have a <literal>WITH
         CHECK</literal> expression, as it only applies in cases where
         records are being retrieved from the relation.
       </para>
____________________________________________________________________________-->
       <para>
         对一条策略使用<literal>SELECT</literal>表示它将适用于
         <literal>SELECT</literal>查询，并且无论何时都要求该约束所在的关系上
         的<literal>SELECT</literal>权限。其结果是在一次
         <literal>SELECT</literal>查询期间，只有该关系中那些通过了
         <literal>SELECT</literal>策略的记录才将被返回，并且查询要求
         <literal>SELECT</literal>权限，例如
         <literal>UPDATE</literal>也将只能看到那些
         <literal>SELECT</literal>策略允许的行。一条
         <literal>SELECT</literal>策略不能具有<literal>WITH
         CHECK</literal>表达式，因为它只适用于正在从关系中检索记录的情况。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="SQL-CREATEPOLICY-INSERT">
<!--==========================orignal english content==========================
      <term><literal>INSERT</></term>
____________________________________________________________________________-->
      <term><literal>INSERT</></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
         Using <literal>INSERT</literal> for a policy means that it will apply
         to <literal>INSERT</literal> commands.  Rows being inserted that do
         not pass this policy will result in a policy violation error, and the
         entire <literal>INSERT</literal> command will be aborted.
         An <literal>INSERT</literal> policy cannot have
         a <literal>USING</literal> expression, as it only applies in cases
         where records are being added to the relation.
       </para>
____________________________________________________________________________-->
       <para>
         为一条策略使用<literal>INSERT</literal>表示它适用于
         <literal>INSERT</literal>命令。没有通过这种策略的正在被插入的行
         会导致策略违背错误，并且整个<literal>INSERT</literal>命令将会中止。
         一条<literal>INSERT</literal>策略不能具有<literal>USING</literal>
         表达式，因为它只适用于正在向关系增加记录的情况。
       </para>
<!--==========================orignal english content==========================
       <para>
         Note that <literal>INSERT</literal> with <literal>ON CONFLICT DO
         UPDATE</literal> checks <literal>INSERT</literal> policies'
         <literal>WITH CHECK</literal> expressions only for rows appended
         to the relation by the <literal>INSERT</literal> path.
       </para>
____________________________________________________________________________-->
       <para>
         注意在带有<literal>ON CONFLICT DO
         UPDATE</literal>的<literal>INSERT</literal>中，只有对通过
         <literal>INSERT</literal>路径追加到关系的行才会检查
         <literal>INSERT</literal>策略的<literal>WITH CHECK</literal>
         表达式。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="SQL-CREATEPOLICY-UPDATE">
<!--==========================orignal english content==========================
      <term><literal>UPDATE</></term>
____________________________________________________________________________-->
      <term><literal>UPDATE</></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
         Using <literal>UPDATE</literal> for a policy means that it will apply
         to <literal>UPDATE</literal>, <literal>SELECT FOR UPDATE</literal>
         and <literal>SELECT FOR SHARE</literal> commands, as well as
         auxiliary <literal>ON CONFLICT DO UPDATE</literal> clauses of
         <literal>INSERT</literal> commands.  Since <literal>UPDATE</literal>
         involves pulling an existing record and replacing it with a new
         modified record, <literal>UPDATE</literal>
         policies accept both a <literal>USING</literal> expression and
         a <literal>WITH CHECK</literal> expression.
         The <literal>USING</literal> expression determines which records
         the <literal>UPDATE</literal> command will see to operate against,
         while the <literal>WITH CHECK</literal> expression defines which
         modified rows are allowed to be stored back into the relation.
       </para>
____________________________________________________________________________-->
       <para>
         为一条策略使用<literal>UPDATE</literal>表示它适用于
         <literal>UPDATE</literal>、<literal>SELECT FOR UPDATE</literal>
		 和<literal>SELECT FOR SHARE</literal>命令，还有<literal>INSERT</literal>
         命令的<literal>ON CONFLICT DO UPDATE</literal>子句。因为
         <literal>UPDATE</literal>涉及到取出一个现有的记录并将其替换为新的修改记录，
		 <literal>UPDATE</literal>
         策略同时接受<literal>USING</literal>表达式和
         <literal>WITH CHECK</literal>表达式。<literal>USING</literal>
         表达式决定<literal>UPDATE</literal>命令将能看到哪些要对其操作
         的记录，而<literal>WITH CHECK</literal>表达式定义哪些被修改的
         行被允许存回到关系中。
       </para>

<!--==========================orignal english content==========================
       <para>
         Any rows whose updated values do not pass the
         <literal>WITH CHECK</literal> expression will cause an error, and the
         entire command will be aborted.  If only a <literal>USING</literal>
         clause is specified, then that clause will be used for both
         <literal>USING</literal> and <literal>WITH CHECK</literal> cases.
       </para>
____________________________________________________________________________-->
       <para>
         任何更新后的值无法通过<literal>WITH CHECK</literal>表达式的行
         将会导致错误，并且整个命令将被中止。如果只指定了一个
         <literal>USING</literal>子句，那么该子句将被用于
         <literal>USING</literal>和<literal>WITH CHECK</literal>两种情况。
       </para>

<!--==========================orignal english content==========================
       <para>
         Typically an <literal>UPDATE</literal> command also needs to read
         data from columns in the relation being updated (e.g., in a
         <literal>WHERE</literal> clause or a <literal>RETURNING</literal>
         clause, or in an expression on the right hand side of the
         <literal>SET</literal> clause).  In this case,
         <literal>SELECT</literal> rights are also required on the relation
         being updated, and the appropriate <literal>SELECT</literal> or
         <literal>ALL</literal> policies will be applied in addition to
         the <literal>UPDATE</literal> policies.  Thus the user must have
         access to the row(s) being updated through a <literal>SELECT</literal>
         or <literal>ALL</literal> policy in addition to being granted
         permission to update the row(s) via an <literal>UPDATE</literal>
         or <literal>ALL</literal> policy.
       </para>
____________________________________________________________________________-->
       <para>
         通常，一个<literal>UPDATE</literal>命令还需要从正在更新的关系中的列中读取数据
		 （例如，在<literal>WHERE</literal>子句或<literal>RETURNING</literal>子句中，
		 或者在<literal>SET</literal>子句右侧的表达式中）。在这种情况下，
		 正在更新的关系上还需要<literal>SELECT</literal>权限，并且除了
		 <literal>UPDATE</literal>策略之外，还将会应用适当的
		 <literal>SELECT</literal>或<literal>ALL</literal>策略。
		 因此，用户必须有权访问通过<literal>SELECT</literal>或<literal>ALL</literal>
		 策略更新的行，此外还要有权限更新通过<literal>UPDATE</literal>或
		 <literal>ALL</literal>策略的行。
       </para>
<!--==========================orignal english content==========================
       <para>
         When an <literal>INSERT</literal> command has an auxiliary
         <literal>ON CONFLICT DO UPDATE</literal> clause, if the
         <literal>UPDATE</literal> path is taken, the row to be updated is
         first checked against the <literal>USING</literal> expressions of
         any <literal>UPDATE</literal> policies, and then the new updated row
         is checked against the <literal>WITH CHECK</literal> expressions.
         Note, however, that unlike a standalone <literal>UPDATE</literal>
         command, if the existing row does not pass the
         <literal>USING</literal> expressions, an error will be thrown (the
         <literal>UPDATE</literal> path will <emphasis>never</> be silently
         avoided).
       </para>
____________________________________________________________________________-->
       <para>
         当<literal>INSERT</literal>命令具有<literal>ON CONFLICT DO UPDATE</literal>
		 子句时，如果采用<literal>UPDATE</literal>路径，
		 则首先检查要更新的行任何<literal>UPDATE</literal>策略的
		 <literal>USING</literal>表达式，然后根据<literal>WITH CHECK</literal>
		 表达式检查新更新的行。但是，请注意，与独立的<literal>UPDATE</literal>命令不同，
		 如果现有的行没有通过<literal>USING</literal>表达式，将会抛出一个错误
		 （<literal>UPDATE</literal>路径将<emphasis>永远不会</> 被默默地绕开）。
       </para>    
	</listitem>
     </varlistentry>

     <varlistentry id="SQL-CREATEPOLICY-DELETE">
<!--==========================orignal english content==========================
      <term><literal>DELETE</></term>
____________________________________________________________________________-->
      <term><literal>DELETE</></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
         Using <literal>DELETE</literal> for a policy means that it will apply
         to <literal>DELETE</literal> commands.  Only rows that pass this
         policy will be seen by a <literal>DELETE</literal> command.  There can
         be rows that are visible through a <literal>SELECT</literal> that are
         not available for deletion, if they do not pass the
         <literal>USING</literal> expression for
         the <literal>DELETE</literal> policy.
       </para>
____________________________________________________________________________-->
       <para>
         为一条策略使用<literal>DELETE</literal>表示它适用于
         <literal>DELETE</literal>命令。只有通过这条策略的行才将能被
         <literal>DELETE</literal>命令所看到。如果有的行不能通过该
         <literal>DELETE</literal>策略的<literal>USING</literal>表达式，则
         它们可以通过<literal>SELECT</literal>看到但不能被删除。
       </para>

<!--==========================orignal english content==========================
       <para>
         In most cases a <literal>DELETE</literal> command also needs to read
         data from columns in the relation that it is deleting from (e.g.,
         in a <literal>WHERE</literal> clause or a
         <literal>RETURNING</literal> clause). In this case,
         <literal>SELECT</literal> rights are also required on the relation,
         and the appropriate <literal>SELECT</literal> or
         <literal>ALL</literal> policies will be applied in addition to
         the <literal>DELETE</literal> policies.  Thus the user must have
         access to the row(s) being deleted through a <literal>SELECT</literal>
         or <literal>ALL</literal> policy in addition to being granted
         permission to delete the row(s) via a <literal>DELETE</literal> or
         <literal>ALL</literal> policy.
       </para>
____________________________________________________________________________-->
       <para>
         在大部分情况下，<literal>DELETE</literal>命令还需要读取要被删除的关系中的列上的数据
		 （例如，在<literal>WHERE</literal>子句或<literal>RETURNING</literal>子句中）。
		 在这种情况下，还要求该关系上的<literal>SELECT</literal>权限，
		 并且除了<literal>DELETE</literal>策略之外，还会应用合适的<literal>SELECT</literal>
		 或<literal>ALL</literal>测了。因此，用户有权访问通过<literal>SELECT</literal>
		 或<literal>ALL</literal>策略删除的行，此外还要有权限删除通过
		 <literal>DELETE</literal>或<literal>ALL</literal>策略的行。
       </para>

<!--==========================orignal english content==========================
       <para>
         A <literal>DELETE</literal> policy cannot have a <literal>WITH
         CHECK</literal> expression, as it only applies in cases where
         records are being deleted from the relation, so that there is no
         new row to check.
       </para>
____________________________________________________________________________-->
       <para>
         <literal>DELETE</literal>策略不能具有<literal>WITH
         CHECK</literal>表达式，因为它只适用于正在从关系中删除记录的情况，
         所以没有新行需要检查。
       </para>
      </listitem>
     </varlistentry>

   </variablelist>
  </refsect2>

  <refsect2>
<!--==========================orignal english content==========================
   <title>Application of Multiple Policies</title>
____________________________________________________________________________-->
   <title>多重策略的应用</title>

<!--==========================orignal english content==========================
   <para>
    When multiple policies of different command types apply to the same command
    (for example, <literal>SELECT</literal> and <literal>UPDATE</literal>
    policies applied to an <literal>UPDATE</literal> command), then the user
    must have both types of permissions (for example, permission to select rows
    from the relation as well as permission to update them).  Thus the
    expressions for one type of policy are combined with the expressions for
    the other type of policy using the <literal>AND</literal> operator.
   </para>
____________________________________________________________________________-->
   <para>
    当不同命令类型的多个策略应用于相同命令时（例如，应用于<literal>UPDATE</literal>
	命令的<literal>SELECT</literal>和<literal>UPDATE</literal>策略），
	则用户必须拥有两种类型的权限（例如，从关系中选择行的权限以及更新它们的权限）。
	因此，使用<literal>AND</literal>运算符将一种策略类型的表达式与其他类型策略
	的表达式组合在一起。
   </para>

<!--==========================orignal english content==========================
   <para>
    When multiple policies of the same command type apply to the same command,
    then there must be at least one <literal>PERMISSIVE</literal> policy
    granting access to the relation, and all of the
    <literal>RESTRICTIVE</literal> policies must pass.  Thus all the
    <literal>PERMISSIVE</literal> policy expressions are combined using
    <literal>OR</literal>, all the <literal>RESTRICTIVE</literal> policy
    expressions are combined using <literal>AND</literal>, and the results are
    combined using <literal>AND</literal>.  If there are no
    <literal>PERMISSIVE</literal> policies, then access is denied.
   </para>
____________________________________________________________________________-->
   <para>
    当同一命令类型的多个策略应用于同一个命令时，必须至少有一个允许访问该关系的
	<literal>PERMISSIVE</literal>策略，并且必须通过所有的<literal>RESTRICTIVE</literal>
	策略。因此，所有<literal>PERMISSIVE</literal>策略表达式都使用
	<literal>OR</literal>进行组合，所有<literal>RESTRICTIVE</literal>策略表达式都使用
	<literal>AND</literal>进行组合，并且结果使用<literal>AND</literal>进行组合。
	如果没有<literal>PERMISSIVE</literal>策略，则访问被拒绝。
   </para>

<!--==========================orignal english content==========================
   <para>
    Note that, for the purposes of combining multiple policies,
    <literal>ALL</literal> policies are treated as having the same type as
    whichever other type of policy is being applied.
   </para>
____________________________________________________________________________-->
   <para>
    请注意，出于合并多个策略的目的，<literal>ALL</literal>
	策略被视为具有与应用其他任何类型的策略相同的类型。
   </para>

<!--==========================orignal english content==========================
   <para>
    For example, in an <literal>UPDATE</literal> command requiring both
    <literal>SELECT</literal> and <literal>UPDATE</literal> permissions, if
    there are multiple applicable policies of each type, they will be combined
    as follows:

<programlisting>
<replaceable>expression</replaceable> from RESTRICTIVE SELECT/ALL policy 1
AND
<replaceable>expression</replaceable> from RESTRICTIVE SELECT/ALL policy 2
AND
...
AND
(
  <replaceable>expression</replaceable> from PERMISSIVE SELECT/ALL policy 1
  OR
  <replaceable>expression</replaceable> from PERMISSIVE SELECT/ALL policy 2
  OR
  ...
)
AND
<replaceable>expression</replaceable> from RESTRICTIVE UPDATE/ALL policy 1
AND
<replaceable>expression</replaceable> from RESTRICTIVE UPDATE/ALL policy 2
AND
...
AND
(
  <replaceable>expression</replaceable> from PERMISSIVE UPDATE/ALL policy 1
  OR
  <replaceable>expression</replaceable> from PERMISSIVE UPDATE/ALL policy 2
  OR
  ...
)
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    例如，在一个需要<literal>SELECT</literal>和<literal>UPDATE</literal>权限的
	<literal>UPDATE</literal>命令中，如果每个类型都有多个可以应用的策略，
	则它们将如下组合：

<programlisting>
<replaceable>expression</replaceable> from RESTRICTIVE SELECT/ALL policy 1
AND
<replaceable>expression</replaceable> from RESTRICTIVE SELECT/ALL policy 2
AND
...
AND
(
  <replaceable>expression</replaceable> from PERMISSIVE SELECT/ALL policy 1
  OR
  <replaceable>expression</replaceable> from PERMISSIVE SELECT/ALL policy 2
  OR
  ...
)
AND
<replaceable>expression</replaceable> from RESTRICTIVE UPDATE/ALL policy 1
AND
<replaceable>expression</replaceable> from RESTRICTIVE UPDATE/ALL policy 2
AND
...
AND
(
  <replaceable>expression</replaceable> from PERMISSIVE UPDATE/ALL policy 1
  OR
  <replaceable>expression</replaceable> from PERMISSIVE UPDATE/ALL policy 2
  OR
  ...
)
</programlisting>
   </para>

  </refsect2>
  </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Notes</title>
____________________________________________________________________________-->
  <title>注解</title>

<!--==========================orignal english content==========================
  <para>
   You must be the owner of a table to create or change policies for it.
  </para>
____________________________________________________________________________-->
  <para>
   要为一个表创建或者修改策略，你必须是该表的拥有者。
  </para>

<!--==========================orignal english content==========================
  <para>
   While policies will be applied for explicit queries against tables
   in the database, they are not applied when the system is performing internal
   referential integrity checks or validating constraints.  This means there are
   indirect ways to determine that a given value exists.  An example of this is
   attempting to insert a duplicate value into a column that is a primary key
   or has a unique constraint.  If the insert fails then the user can infer that
   the value already exists. (This example assumes that the user is permitted by
   policy to insert records which they are not allowed to see.)  Another example
   is where a user is allowed to insert into a table which references another,
   otherwise hidden table.  Existence can be determined by the user inserting
   values into the referencing table, where success would indicate that the
   value exists in the referenced table.  These issues can be addressed by
   carefully crafting policies to prevent users from being able to insert,
   delete, or update records at all which might possibly indicate a value they
   are not otherwise able to see, or by using generated values (e.g., surrogate
   keys) instead of keys with external meanings.
  </para>
____________________________________________________________________________-->
  <para>
   虽然策略将被应用于针对数据库中表的显式查询上，但当系统正在执行
   内部引用完整性检查或者验证约束时不会应用它们。这意味着有间接的
   方法来决定一个给定的值是否存在。一个例子是向一个作为主键或者拥
   有唯一约束的列中尝试插入重复值。如果插入失败则用户可以推导出该
   值已经存在（这个例子假设用户被策略允许插入他们看不到的记录）。
   另一个例子是一个用户被允许向一个引用了其他表的表中插入，然而另
   一个表是隐藏表。通过用户向引用表中插入值可以判断存在性，
   成功表示该值存在于被引用表中。为了解决这些问题，应该仔细地制作
   策略以完全阻止用户插入、删除或者更新那些可能指示他们不能看到的
   值的记录，或者使用生成的值（例如代理键）来代替具有外部含义的键。
  </para>

<!--==========================orignal english content==========================
  <para>
   Generally, the system will enforce filter conditions imposed using
   security policies prior to qualifications that appear in user queries,
   in order to prevent inadvertent exposure of the protected data to
   user-defined functions which might not be trustworthy.  However,
   functions and operators marked by the system (or the system
   administrator) as <literal>LEAKPROOF</literal> may be evaluated before
   policy expressions, as they are assumed to be trustworthy.
  </para>
____________________________________________________________________________-->
  <para>
   通常，系统将在应用用户查询中出现的条件之前先强制由安全性策略施
   加的过滤条件，这是为了防止无意中把受保护的数据暴露给可能不可信
   的用户定义函数。不过，被系统（或者系统管理员）标记为
   <literal>LEAKPROOF</literal>的函数和操作符可以在策略表达式之前
   被计算，因为它们已经被假定为可信。
  </para>

<!--==========================orignal english content==========================
  <para>
   Since policy expressions
   are added to the user's query directly, they will be run with the rights of
   the user running the overall query.  Therefore, users who are using a given
   policy must be able to access any tables or functions referenced in the
   expression or they will simply receive a permission denied error when
   attempting to query the table that has row-level security enabled.
   This does not change how views
   work, however.  As with normal queries and views, permission checks and
   policies for the tables which are referenced by a view will use the view
   owner's rights and any policies which apply to the view owner.
  </para>
____________________________________________________________________________-->
  <para>
   因为策略表达式会被直接加到用户查询上，它们将使用运行整个查询的用户的
   权限运行。因此，使用一条给定策略的用户必须能够访问表达式中引用的任何
   表或函数，否则在尝试查询启用了行级安全性的表时，他们将简单地收到一条
   没有权限的错误。不过，这不会改变视图的工作方式。就普通查询和视图来说，
   权限检查和视图所引用的表的策略将使用视图拥有者的权限以及任何适用于视
   图拥有者的策略。
  </para>

<!--==========================orignal english content==========================
  <para>
   Additional discussion and practical examples can be found
   in <xref linkend="ddl-rowsecurity">.
  </para>
____________________________________________________________________________-->
  <para>
   在<xref linkend="ddl-rowsecurity">中可以找到额外的讨论和实际的例子。
  </para>

 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Compatibility</title>
____________________________________________________________________________-->
  <title>兼容性</title>

<!--==========================orignal english content==========================
  <para>
   <command>CREATE POLICY</command> is a <productname>PostgreSQL</productname>
   extension.
  </para>
____________________________________________________________________________-->
  <para>
   <command>CREATE POLICY</command>是一种<productname>PostgreSQL</productname>扩展。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>See Also</title>
____________________________________________________________________________-->
  <title>另见</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alterpolicy"></member>
   <member><xref linkend="sql-droppolicy"></member>
   <member><xref linkend="sql-altertable"></member>
  </simplelist>
 </refsect1>

</refentry>
