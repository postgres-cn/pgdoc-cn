<!--
doc/src/sgml/ref/listen.sgml
PostgreSQL documentation
-->

<refentry id="sql-listen">
<!--==========================orignal english content==========================
 <indexterm zone="sql-listen">
  <primary>LISTEN</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="sql-listen">
  <primary>LISTEN</primary>
 </indexterm>
 
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>LISTEN</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>LISTEN</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - 语言语句</refmiscinfo>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>LISTEN</refname>
  <refpurpose>listen for a notification</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>LISTEN</refname>
  <refpurpose>监听一个通知</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
LISTEN <replaceable class="parameter">channel</replaceable>
</synopsis>
____________________________________________________________________________-->
<synopsis>
LISTEN <replaceable class="parameter">channel</replaceable>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <command>LISTEN</command> registers the current session as a
   listener on the notification channel named <replaceable
   class="parameter">channel</replaceable>.
   If the current session is already registered as a listener for
   this notification channel, nothing is done.
  </para>
____________________________________________________________________________-->
  <para>
   <command>LISTEN</command>在名为<replaceable class="parameter">channel</replaceable>的通知频道上将当前会话注册为一个监听者。如果当前会话已经被注册为这个通知频道的一个监听者，则什么也不会发生。
  </para>

<!--==========================orignal english content==========================
  <para>
   Whenever the command <command>NOTIFY <replaceable
   class="parameter">channel</replaceable></command> is invoked, either
   by this session or another one connected to the same database, all
   the sessions currently listening on that notification channel are
   notified, and each will in turn notify its connected client
   application.
  </para>
____________________________________________________________________________-->
  <para>
   只要命令<command>NOTIFY <replaceable class="parameter">channel</replaceable></command>被调用（不管是在这个会话还是在另一个连接到同一数据库的会话中），所有当前正在该通知频道上监听的会话都会被通知，并且每一个会话将会接着通知连接到它的客户端应用。
  </para>

<!--==========================orignal english content==========================
  <para>
   A session can be unregistered for a given notification channel with the
   <command>UNLISTEN</command> command.  A session's listen
   registrations are automatically cleared when the session ends.
  </para>
____________________________________________________________________________-->
  <para>
   可以使用<command>UNLISTEN</command>命令在一个给定通知频道上反注册一个会话。当会话结束时，它的监听注册会被自动清除。
  </para>

<!--==========================orignal english content==========================
  <para>
   The method a client application must use to detect notification events depends on
   which <productname>PostgreSQL</productname> application programming interface it
   uses.  With the <application>libpq</application> library, the application issues
   <command>LISTEN</command> as an ordinary SQL command, and then must
   periodically call the function <function>PQnotifies</function> to find out
   whether any notification events have been received.  Other interfaces such as
   <application>libpgtcl</application> provide higher-level methods for handling notify events; indeed,
   with <application>libpgtcl</application> the application programmer should not even issue
   <command>LISTEN</command> or <command>UNLISTEN</command> directly.  See the
   documentation for the interface you are using for more details.
  </para>
____________________________________________________________________________-->
  <para>
   一个客户端应用检测通知事件的必用方法取决于它使用的<productname>PostgreSQL</productname>应用编程接口。如果使用<application>libpq</application>库，应用会将<command>LISTEN</command>作为一个普通 SQL 命令发出，并且接着必须周期性地调用函数<function>PQnotifies</function>来查看是否接收到通知事件。其他诸如<application>libpgtcl</application>的接口提供了更高层次上的处理通知事件的方法。事实上，通过使用<application>libpgtcl</application>应用程序员甚至不必直接发出<command>LISTEN</command>或<command>UNLISTEN</command>。更多细节可参阅所使用的接口的文档。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Parameters</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">channel</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">channel</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Name of a notification channel (any identifier).
     </para>
____________________________________________________________________________-->
     <para>
      一个通知频道的名称（任意标识符）。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Notes</title>
____________________________________________________________________________-->
  <title>注解</title>

<!--==========================orignal english content==========================
  <para>
   <command>LISTEN</command> takes effect at transaction commit.
   If <command>LISTEN</command> or <command>UNLISTEN</command> is executed
   within a transaction that later rolls back, the set of notification
   channels being listened to is unchanged.
  </para>
____________________________________________________________________________-->
  <para>
   <command>LISTEN</command>在事务提交时生效。如果在一个后来被回滚的事务中执行了<command>LISTEN</command>或<command>UNLISTEN</command>，被监听的通知频道集合不会变化。
  </para>

<!--==========================orignal english content==========================
  <para>
   A transaction that has executed <command>LISTEN</command> cannot be
   prepared for two-phase commit.
  </para>
____________________________________________________________________________-->
  <para>
   一个已经执行了<command>LISTEN</command>的事务不能为两阶段提交做准备。
  </para>

<!--==========================orignal english content==========================
  <para>
   There is a race condition when first setting up a listening session:
   if concurrently-committing transactions are sending notify events,
   exactly which of those will the newly listening session receive?
   The answer is that the session will receive all events committed after
   an instant during the transaction's commit step.  But that is slightly
   later than any database state that the transaction could have observed
   in queries.  This leads to the following rule for
   using <command>LISTEN</command>: first execute (and commit!) that
   command, then in a new transaction inspect the database state as needed
   by the application logic, then rely on notifications to find out about
   subsequent changes to the database state.  The first few received
   notifications might refer to updates already observed in the initial
   database inspection, but this is usually harmless.
  </para>
____________________________________________________________________________-->
  <para>
   第一次设置侦听会话时有一个竞争条件：如果并发提交的事务正在发送通知事件，那么新的侦听会话将接收哪些事件？
   答案是，会话将接收在事务提交步骤中的一瞬间之后所有提交的事件。但这比事务在查询中可能观察到的任何
   数据库状态都要晚一些。这将导致使用<command>LISTEN</command>的以下规则：首先执行（并提交！）该命令，
   然后在一个新事务中根据应用程序逻辑的需要检查数据库状态，然后依靠通知来了解数据库状态的后续更改。最初收
   到的几个通知可能涉及在初始数据库检查中已经观察到的更新，但这通常是无害的。
  </para>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="sql-notify"/>
   contains a more extensive
   discussion of the use of <command>LISTEN</command> and
   <command>NOTIFY</command>.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="sql-notify"/>对<command>LISTEN</command>和<command>NOTIFY</command>的
   使用进行了更广泛的讨论。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Examples</title>
____________________________________________________________________________-->
  <title>例子</title>

<!--==========================orignal english content==========================
  <para>
   Configure and execute a listen/notify sequence from
   <application>psql</application>:

<programlisting>
LISTEN virtual;
NOTIFY virtual;
Asynchronous notification "virtual" received from server process with PID 8448.
</programlisting></para>
____________________________________________________________________________-->
  <para>
   从<application>psql</application>中配置并执行一个监听/通知序列

<programlisting>
LISTEN virtual;
NOTIFY virtual;
Asynchronous notification "virtual" received from server process with PID 8448.
</programlisting></para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Compatibility</title>
____________________________________________________________________________-->
  <title>兼容性</title>

<!--==========================orignal english content==========================
  <para>
   There is no <command>LISTEN</command> statement in the SQL
   standard.
  </para>
____________________________________________________________________________-->
  <para>
   在 SQL 标准中没有<command>LISTEN</command>语句。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>See Also</title>
____________________________________________________________________________-->
  <title>参见</title>

  <simplelist type="inline">
   <member><xref linkend="sql-notify"/></member>
   <member><xref linkend="sql-unlisten"/></member>
  </simplelist>
 </refsect1>
</refentry>
