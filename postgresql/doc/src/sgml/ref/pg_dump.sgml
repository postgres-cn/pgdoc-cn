<!--
doc/src/sgml/ref/pg_dump.sgml
PostgreSQL documentation
-->

<refentry id="APP-PGDUMP">
 <refmeta>
  <refentrytitle>pg_dump</refentrytitle>
  <manvolnum>1</manvolnum>
  <!-- 
  <refmiscinfo>Application</refmiscinfo> 
  -->
  <refmiscinfo>应用</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>pg_dump</refname>

<!-- 
  <refpurpose>
   extract a <productname>PostgreSQL</productname> database into a script file or other archive file
  </refpurpose> 
-->
  <refpurpose>
   将一个<productname>PostgreSQL</productname>数据库转储到一个脚本文件或者其它归档文件中
  </refpurpose>
 </refnamediv>

 <indexterm zone="app-pgdump">
  <primary>pg_dump</primary>
 </indexterm>

 <refsynopsisdiv>
  <cmdsynopsis>
   <command>pg_dump</command>
   <arg rep="repeat"><replaceable>connection-option</replaceable></arg>
   <arg rep="repeat"><replaceable>option</replaceable></arg>
   <arg choice="opt"><replaceable>dbname</replaceable></arg>
  </cmdsynopsis>
 </refsynopsisdiv>


 <refsect1 id="pg-dump-description">
  <!-- 
  <title>
   Description
  </title> 
  -->
  <title>
   描述
  </title>

  <!--
<para>
   <application>pg_dump</application> is a utility for backing up a
   <productname>PostgreSQL</productname> database. It makes consistent
   backups even if the database is being used concurrently.
   <application>pg_dump</application> does not block other users
   accessing the database (readers or writers).
  </para>
-->
<para>
<application>pg_dump</application>是一个用于备份<productname>PostgreSQL</productname>
数据库的工具。它甚至可以在数据库正在使用的时候进行完整一致的备份。
<application>pg_dump</application>并不阻塞其它用户对数据库的访问(读或者写)。
</para>

  <!--
<para>
   Dumps can be output in script or archive file formats. Script
   dumps are plain-text files containing the SQL commands required
   to reconstruct the database to the state it was in at the time it was
   saved. To restore from such a script, feed it to <xref
   linkend="app-psql">. Script files
   can be used to reconstruct the database even on other machines and
   other architectures; with some modifications, even on other SQL
   database products.
  </para>
-->
<para>
转储格式可以是一个脚本或者归档文件。脚本转储的格式是纯文本，它包含许多 SQL 命令，
这些 SQL 命令可以用于重建该数据库并将之恢复到保存成脚本的时候的状态。
使用<xref linkend="app-psql">从这样的脚本中恢复。
它们甚至可以用于在其它机器甚至是其它硬件体系的机器上重建该数据库，
通过对脚本进行一些修改，甚至可以在其它 SQL 数据库产品上重建该数据库。
</para>

  <!--
<para>
   The alternative archive file formats must be used with
   <xref linkend="app-pgrestore"> to rebuild the database.  They
   allow <application>pg_restore</application> to be selective about
   what is restored, or even to reorder the items prior to being
   restored.
   The archive file formats are designed to be portable across
   architectures.
  </para>
-->
<para>
归档文件格式必须和<xref linkend="app-pgrestore">一起使用重建数据库。
它们允许<application>pg_restore</application>对恢复什么东西进行选择，
或者甚至是在恢复之前对需要恢复的条目进行重新排序。归档文件也是设计成可以跨平台移植的。
</para>

  <!--
<para>
   When used with one of the archive file formats and combined with
   <application>pg_restore</application>,
   <application>pg_dump</application> provides a flexible archival and
   transfer mechanism. <application>pg_dump</application> can be used to
   backup an entire database, then <application>pg_restore</application>
   can be used to examine the archive and/or select which parts of the
   database are to be restored. The most flexible output file formats are
   the <quote>custom</quote> format (<option>-Fc</option>) and the
   <quote>directory</quote> format(<option>-Fd</option>). They allow
   for selection and reordering of all archived items, support parallel
   restoration, and are compressed by default. The <quote>directory</quote>
   format is the only format that supports parallel dumps.
  </para>
-->
<para>
如果一种候选文件格式和<application>pg_restore</application>结合，
那么<application>pg_dump</application>就能提供一种灵活的归档和传输机制。
<application>pg_dump</application>可以用于备份整个数据库，然后就可以使用
<application>pg_restore</application>检查这个归档和/或选择要恢复的数据库部分。
最灵活的输出文件格式是<quote>custom</quote>(自定义)格式(<option>-Fc</option>)和
<quote>directory</quote>（目录）格式(<option>-Fd</option>)。
它们允许对归档元素进行选取和重新排列，支持并行恢复并且缺省时是压缩的。
<quote>directory</quote>格式是唯一支持并行转储的格式。
</para>

  <!--
<para>
   While running <application>pg_dump</application>, one should examine the
   output for any warnings (printed on standard error), especially in
   light of the limitations listed below.
  </para>
-->
<para>
在运行<application>pg_dump</application>的时候，应该检查输出，
看看是否有任何警告存在(在标准错误上打印)，特别是下面列出的限制。
</para>

 </refsect1>

 <refsect1 id="pg-dump-options">
  <!-- 
  <title>Options</title> 
  -->
  <title>选项</title>

  
<para>
<!-- 
    The following command-line options control the content and
    format of the output.
-->
下面的命令行参数控制输出的内容和格式。
    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">dbname</replaceable></term>
      <listitem>
<!--
       <para>
        Specifies the name of the database to be dumped.  If this is
        not specified, the environment variable
        <envar>PGDATABASE</envar> is used.  If that is not set, the
        user name specified for the connection is used.
       </para>
-->
<para>
将要转储的数据库名。如果没有声明这个参数，那么使用环境变量<envar>PGDATABASE</envar>。
如果那个环境变量也没声明，那么使用发起连接的用户名。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-a</></term>
      <term><option>--data-only</></term>
      <listitem>
       <!--
<para>
        Dump only the data, not the schema (data definitions).
        Table data, large objects, and sequence values are dumped.
       </para>
-->
<para>
只输出数据，不输出模式(数据定义)。转储表数据、大对象和序列值。
</para>

       <!--
<para>
        This option is similar to, but for historical reasons not identical
        to, specifying <option>&#045;-section=data</>.
       </para>
-->
<para>
这个选项类似于声明<option>--section=data</>，但是只是因为历史原因存在并不完全相同。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-b</></term>
      <term><option>--blobs</></term>
      <listitem>
       <!--
<para>
        Include large objects in the dump.  This is the default behavior
        except when <option>&#045;-schema</>, <option>&#045;-table</>, or
        <option>&#045;-schema-only</> is specified, so the <option>-b</>
        switch is only useful to add large objects to selective dumps.
       </para>
-->
<para>
在转储中包含大对象。除非指定了<option>--schema</>, <option>--table</>, 
<option>--schema-only</>开关，否则这是默认行为。因此<option>-b</>
开关仅用于在选择性转储的时候添加大对象。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-c</option></term>
      <term><option>--clean</option></term>
      <listitem>
       <!--
<para>
        Output commands to clean (drop)
        database objects prior to outputting the commands for creating them.
        (Restore might generate some harmless error messages, if any objects
        were not present in the destination database.)
       </para>
-->
<para>
输出命令在输出创建数据库命令之前先清理(drop)该数据库对象。
（如果任何对象在目标数据库中不存在，则转储可能生成一些无害的错误信息。）
</para>

       <!--
<para>
        This option is only meaningful for the plain-text format.  For
        the archive formats, you can specify the option when you
        call <command>pg_restore</command>.
       </para>
-->
<para>
这个选项只是对纯文本格式有意义。对于归档格式，可以在调用<command>pg_restore</command>的时候声明该选项。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-C</></term>
      <term><option>--create</></term>
      <listitem>
       <!--
<para>
        Begin the output with a command to create the
        database itself and reconnect to the created database.  (With a
        script of this form, it doesn't matter which database in the
        destination installation you connect to before running the script.)
        If <option>&#045;-clean</option> is also specified, the script drops and
        recreates the target database before reconnecting to it.
       </para>
-->
<para>
以一条创建该数据库本身并且与这个数据库连接命令开头进行输出。如果是这种形式的脚本，
那么你在运行脚本之前和目的安装中的哪个数据库连接就不重要了。如果也声明了
<option>--clean</option>，那么脚本在重新连接到数据库之前删除并重新创建目标数据库。
</para>

       <!--
<para>
        This option is only meaningful for the plain-text format.  For
        the archive formats, you can specify the option when you
        call <command>pg_restore</command>.
       </para>
-->
<para>
这个选项只对纯文本格式有意义。对于归档格式，可以在调用<command>pg_restore</command>
的时候声明该选项。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-E <replaceable class="parameter">encoding</replaceable></option></term>
      <term><option>--encoding=<replaceable class="parameter">encoding</replaceable></option></term>
      <listitem>
       <!--
<para>
        Create the dump in the specified character set encoding. By default,
        the dump is created in the database encoding.  (Another way to get the
        same result is to set the <envar>PGCLIENTENCODING</envar> environment
        variable to the desired dump encoding.)
       </para>
-->
<para>
以指定的字符集编码创建转储。缺省时，转储是按照数据库编码创建的。
另外一个获取同样结果的方法是将<envar>PGCLIENTENCODING</envar>环境变量设置为期望的转储编码。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-f <replaceable class="parameter">file</replaceable></option></term>
      <term><option>--file=<replaceable class="parameter">file</replaceable></option></term>
      <listitem>
       <!--
<para>
        Send output to the specified file. This parameter can be omitted for
        file based output formats, in which case the standard output is used.
        It must be given for the directory output format however, where it
        specifies the target directory instead of a file. In this case the
        directory is created by <command>pg_dump</command> and must not exist
        before.
       </para>
-->
<para>
把输出发往指定的文件。文件基础输出格式时可以省略这个参数，这种情况下使用标准输出。
但是，在声明目标目录而不是文件时必须给出目录输出格式。在这种情况下，
目录通过<command>pg_dump</command>创建并且必须之前不存在。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-F <replaceable class="parameter">format</replaceable></option></term>
      <term><option>--format=<replaceable class="parameter">format</replaceable></option></term>
      <listitem>
       
<para>
<!-- 
        Selects the format of the output.
        <replaceable>format</replaceable> can be one of the following:
-->
选择输出的格式。<replaceable>format</replaceable>可以是下列之一：
       <variablelist>
        <varlistentry>
         <term><literal>p</></term>
         <term><literal>plain</></term>
         <listitem>
<!--
          <para>
           Output a plain-text <acronym>SQL</acronym> script file (the default).
          </para>
-->
<para>
纯文本<acronym>SQL</acronym>脚本文件(缺省)。
</para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>c</></term>
         <term><literal>custom</></term>
         <listitem>
          <!--
<para>
           Output a custom-format archive suitable for input into
           <application>pg_restore</application>.
           Together with the directory output format, this is the most flexible
           output format in that it allows manual selection and reordering of
           archived items during restore. This format is also compressed by
           default.
          </para>
-->
<para>
适合输入到<application>pg_restore</application>里的自定义格式归档。
加上目录输出格式，这是最灵活的格式，它允许在转储期间对已归档的条目进行手动选择和重新排列。
这个格式缺省的时候是压缩的。
</para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>d</></term>
         <term><literal>directory</></term>
         <listitem>
          <!--
<para>
           Output a directory-format archive suitable for input into
           <application>pg_restore</application>. This will create a directory
           with one file for each table and blob being dumped, plus a
           so-called Table of Contents file describing the dumped objects in a
           machine-readable format that <application>pg_restore</application>
           can read. A directory format archive can be manipulated with
           standard Unix tools; for example, files in an uncompressed archive
           can be compressed with the <application>gzip</application> tool.
           This format is compressed by default and also supports parallel
           dumps.
          </para>
-->
<para>
适合输入到<application>pg_restore</application>里的目录格式归档。这将创建一个目录，
该目录包含一个为每个被转储的表和二进制大对象的文件，加上一个号称目录的文件，
该文件以<application>pg_restore</application>可读的机器可读格式描述转储的对象。
目录格式归档可以用标准Unix工具操作；例如，在非压缩归档中的文件可以用
<application>gzip</application>工具压缩。这个格式缺省的时候是压缩的，
并且也支持并行转储。
</para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>t</></term>
         <term><literal>tar</></term>
         <listitem>
          <!--
<para>
           Output a <command>tar</command>-format archive suitable for input
           into <application>pg_restore</application>. The tar-format is
           compatible with the directory-format; extracting a tar-format
           archive produces a valid directory-format archive.
           However, the tar-format does not support compression and has a
           limit of 8 GB on the size of individual tables. Also, the relative
           order of table data items cannot be changed during restore.
          </para>
-->
<para>
适合输入到<application>pg_restore</application>里的<command>tar</command>归档文件。
tar格式兼容目录格式；提取tar格式归档产生一个有效的目录格式归档。不过，
tar格式不支持压缩并且限制单独的表为8 GB。还有，表数据条目的相关顺序在转储期间不能更改。
</para>
         </listitem>
        </varlistentry>
       </variablelist></para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-i</></term>
      <term><option>--ignore-version</></term>
      <listitem>
       <!--
<para>
        A deprecated option that is now ignored.
       </para>
-->
<para>
一个现在已经不用了的废弃选项。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-j <replaceable class="parameter">njobs</replaceable></></term>
      <term><option>--jobs=<replaceable class="parameter">njobs</replaceable></></term>
      <listitem>
       <!--
<para>
        Run the dump in parallel by dumping <replaceable class="parameter">njobs</replaceable>
        tables simultaneously. This option reduces the time of the dump but it also
        increases the load on the database server. You can only use this option with the
        directory output format because this is the only output format where multiple processes
        can write their data at the same time.
       </para>
-->
<para>
通过同时转储<replaceable class="parameter">njobs</replaceable>表并行运行转储。
该选项减少了转储的时间，但是也增加了数据库服务器的负载。可以只将这个选项用于目录输出格式，
因为这是多进程可以同时写它们的数据的唯一的输出格式。
</para>
       <!--
<para><application>pg_dump</> will open <replaceable class="parameter">njobs</replaceable>
        + 1 connections to the database, so make sure your <xref linkend="guc-max-connections">
        setting is high enough to accommodate all connections.
       </para>
-->
<para>
<application>pg_dump</>将打开<replaceable class="parameter">njobs</replaceable> + 1个到数据库的连接，
所以确保你的<xref linkend="guc-max-connections">设置足够高以适应所有的连接。
</para>
       <!--
<para>
        Requesting exclusive locks on database objects while running a parallel dump could
        cause the dump to fail. The reason is that the <application>pg_dump</> master process
        requests shared locks on the objects that the worker processes are going to dump later
        in order to
        make sure that nobody deletes them and makes them go away while the dump is running.
        If another client then requests an exclusive lock on a table, that lock will not be
        granted but will be queued waiting for the shared lock of the master process to be
        released.. Consequently any other access to the table will not be granted either and
        will queue after the exclusive lock request. This includes the worker process trying
        to dump the table. Without any precautions this would be a classic deadlock situation.
        To detect this conflict, the <application>pg_dump</> worker process requests another
        shared lock using the <literal>NOWAIT</> option. If the worker process is not granted
        this shared lock, somebody else must have requested an exclusive lock in the meantime
        and there is no way to continue with the dump, so <application>pg_dump</> has no choice
        but to abort the dump.
       </para>
-->
<para>
运行并行转储时在数据库对象上请求排他锁会导致转储失败。原因是<application>pg_dump</>
主进程在工作进程稍后转储的对象上请求共享锁，这样做是为了确保在转储运行时没有人删除它们或移走它们。
如果另一个客户端然后在一个表上请求一个排他锁，该锁将不被授予，但是将会排队等候主进程的共享锁释放。
因此，任意其他访问表的请求也将不被授予，并且会在排他锁请求后排队。
这包含工作进程尝试转储这个表。没有防范措施这将是一个经典的死锁情况。为了检测这个冲突，
<application>pg_dump</>工作进程请求使用<literal>NOWAIT</>选项请求另外一个共享锁。
如果没有授予工作进程这个共享锁，那么肯定是另外一个人在此期间请求了一个排他锁，
并且没有办法继续进行转储了，所以<application>pg_dump</>只能退出转储。
</para>
       <!--
<para>
        For a consistent backup, the database server needs to support synchronized snapshots,
        a feature that was introduced in <productname>PostgreSQL</productname> 9.2. With this
        feature, database clients can ensure they see the same data set even though they use
        different connections. <command>pg_dump -j</command> uses multiple database
        connections; it connects to the database once with the master process and
        once again for each worker job. Without the synchronized snapshot feature, the
        different worker jobs wouldn't be guaranteed to see the same data in each connection,
        which could lead to an inconsistent backup.
       </para>
-->
<para>
对于一个一致的备份，数据库服务器需要支持同步快照，这是<productname>PostgreSQL</productname> 9.2
引入的一个特性。有了这个特性，数据库客户端可以保证他们看到相同的数据设置，即使它们使用不同的连接。
<command>pg_dump -j</command>使用多个数据库连接；它与主进程连接到数据库一次，然后再次连接到每个worker工作。
没有同步快照特性，不同的worker工作将不会保证在每个连接中看到相同的数据，这将导致一个不一致的备份。
</para>
       <!--
<para>
        If you want to run a parallel dump of a pre-9.2 server, you need to make sure that the
        database content doesn't change from between the time the master connects to the
        database until the last worker job has connected to the database. The easiest way to
        do this is to halt any data modifying processes (DDL and DML) accessing the database
        before starting the backup. You also need to specify the
        <option>&#045;-no-synchronized-snapshots</option> parameter when running
        <command>pg_dump -j</command> against a pre-9.2 <productname>PostgreSQL</productname>
        server.
       </para>
-->
<para>
如果你想在一个9.2之前的服务器上运行并行转储，那么你需要保证在主进程到最后一个worker工作连接到数据库之间，
数据库内容不会改变。最简单的方法是在开始备份之前叫停所有数据修改进程（DDL和DML）访问数据库。
你也需要在9.2之前的<productname>PostgreSQL</productname>服务器上运行<command>pg_dump -j</command>
时，声明<option>--no-synchronized-snapshots</option>参数。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-n <replaceable class="parameter">schema</replaceable></option></term>
      <term><option>--schema=<replaceable class="parameter">schema</replaceable></option></term>
      <listitem>
       <!--
<para>
        Dump only schemas matching <replaceable
        class="parameter">schema</replaceable>; this selects both the
        schema itself, and all its contained objects.  When this option is
        not specified, all non-system schemas in the target database will be
        dumped.  Multiple schemas can be
        selected by writing multiple <option>-n</> switches.  Also, the
        <replaceable class="parameter">schema</replaceable> parameter is
        interpreted as a pattern according to the same rules used by
        <application>psql</>'s <literal>\d</> commands (see <xref
        linkend="APP-PSQL-patterns" endterm="APP-PSQL-patterns-title">),
        so multiple schemas can also be selected by writing wildcard characters
        in the pattern.  When using wildcards, be careful to quote the pattern
        if needed to prevent the shell from expanding the wildcards;  see
        <xref linkend="pg-dump-examples" endterm="pg-dump-examples-title">.
       </para>
-->
<para>
只转储匹配<replaceable class="parameter">schema</replaceable>的模式内容，
包括模式本身以及其中包含的对象。如果没有声明这个选项，
所有目标数据库中的非系统模式都会被转储出来。可以使用多个<option>-n</>选项指定多个模式。
同样，<replaceable class="parameter">schema</replaceable>参数将按照<application>psql</>
的<literal>\d</>命令的规则(参见<xref linkend="APP-PSQL-patterns" endterm="APP-PSQL-patterns-title">)
被解释为匹配模式，因此可以使用通配符匹配多个模式。在使用通配符的时候，最好用引号进行界定，
以防止 shell 将通配符进行扩展。参阅<xref linkend="pg-dump-examples" endterm="pg-dump-examples-title">。
</para>

       <note>
        <!--
<para>
         When <option>-n</> is specified, <application>pg_dump</application>
         makes no attempt to dump any other database objects that the selected
         schema(s) might depend upon. Therefore, there is no guarantee
         that the results of a specific-schema dump can be successfully
         restored by themselves into a clean database.
        </para>
-->
<para>
如果指定了<option>-n</>，那么<application>pg_dump</application>
将不会转储那些模式所依赖的其他数据库对象。因此，
无法保证转储出来的内容一定能够在另一个干净的数据库中恢复成功。
</para>
       </note>

       <note>
        <!--
<para>
         Non-schema objects such as blobs are not dumped when <option>-n</> is
         specified.  You can add blobs back to the dump with the
         <option>&#045;-blobs</> switch.
        </para>
-->
<para>
非模式对象(比如大对象)不会在指定<option>-n</>的时候被转储出来。
你可以使用<option>--blobs</>明确要求转储大对象。
</para>
       </note>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-N <replaceable class="parameter">schema</replaceable></option></term>
      <term><option>--exclude-schema=<replaceable class="parameter">schema</replaceable></option></term>
      <listitem>
       <!--
<para>
        Do not dump any schemas matching the <replaceable
        class="parameter">schema</replaceable> pattern.  The pattern is
        interpreted according to the same rules as for <option>-n</>.
        <option>-N</> can be given more than once to exclude schemas
        matching any of several patterns.
       </para>
-->
<para>
不转储任何匹配<replaceable class="parameter">schema</replaceable>的模式内容。
模式匹配规则与<option>-n</>完全相同。可以指定多个<option>-N</>以排除多种匹配的模式。
</para>

       <!--
<para>
        When both <option>-n</> and <option>-N</> are given, the behavior
        is to dump just the schemas that match at least one <option>-n</>
        switch but no <option>-N</> switches.  If <option>-N</> appears
        without <option>-n</>, then schemas matching <option>-N</> are
        excluded from what is otherwise a normal dump.
       </para>
-->
<para>
如果同时指定了<option>-n</>和<option>-N</>，那么将只转储匹配<option>-n</>
但不匹配<option>-N</>的模式。如果出现<option>-N</>但是不出现<option>-n</>，
那么匹配<option>-N</>的模式将不会被转储。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-o</></term>
      <term><option>--oids</></term>
      <listitem>
       <!--
<para>
        Dump object identifiers (<acronym>OID</acronym>s) as part of the
        data for every table.  Use this option if your application references
        the <acronym>OID</>
        columns in some way (e.g., in a foreign key constraint).
        Otherwise, this option should not be used.
       </para>
-->
<para>
作为数据的一部分，为每个表都输出对象标识(<acronym>OID</acronym>s)。
如果你的应用需要<acronym>OID</>字段的话(比如在外键约束中用到)，那么使用这个选项。
否则，不应该使用这个选项。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-O</></term>
      <term><option>--no-owner</option></term>
      <listitem>
       <!--
<para>
        Do not output commands to set
        ownership of objects to match the original database.
        By default, <application>pg_dump</application> issues
        <command>ALTER OWNER</> or
        <command>SET SESSION AUTHORIZATION</command>
        statements to set ownership of created database objects.
        These statements
        will fail when the script is run unless it is started by a superuser
        (or the same user that owns all of the objects in the script).
        To make a script that can be restored by any user, but will give
        that user ownership of all the objects, specify <option>-O</>.
       </para>
-->
<para>
不把对象的所有权设置为对应源数据库。<application>pg_dump</application>默认发出
<command>ALTER OWNER</>或<command>SET SESSION AUTHORIZATION</command>
语句以设置创建的数据库对象的所有权。如果这些脚本将来没有被超级用户
(或者拥有脚本中全部对象的用户)运行的话将会失败。<option>-O</>
选项就是为了让该脚本可以被任何用户恢复并且将脚本中对象的所有权赋予该选项指定的用户。
</para>

       <!--
<para>
        This option is only meaningful for the plain-text format.  For
        the archive formats, you can specify the option when you
        call <command>pg_restore</command>.
       </para>
-->
<para>
这个选项只是对纯文本格式有意义。对于归档格式，在调用<command>pg_restore</command>
的时候可以声明该选项。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-R</option></term>
      <term><option>--no-reconnect</option></term>
      <listitem>
       <!--
<para>
        This option is obsolete but still accepted for backwards
        compatibility.
       </para>
-->
<para>
这个选项已经过时，但是出于向下兼容的考虑，仍然接受这个选项。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-s</option></term>
      <term><option>--schema-only</option></term>
      <listitem>
       <!--
<para>
        Dump only the object definitions (schema), not data.
       </para>
-->
<para>
只输出对象定义(模式)，不输出数据。
</para>
       <!--
<para>
        This option is the inverse of <option>&#045;-data-only</>.
        It is similar to, but for historical reasons not identical to,
        specifying
        <option>&#045;-section=pre-data &#045;-section=post-data</>.
       </para>
-->
<para>
这个选项与<option>--data-only</>相反。类似于，但是由于历史原因不等于声明
<option>--section=pre-data --section=post-data</>。
</para>
       <!--
<para>
        (Do not confuse this with the <option>&#045;-schema</> option, which
        uses the word <quote>schema</> in a different meaning.)
       </para>
-->
<para>
不要与<option>--schema</>选项混淆，<option>--schema</>使用不同含义的<quote>schema</>。
</para>
       <!--
<para>
        To exclude table data for only a subset of tables in the database,
        see <option>&#045;-exclude-table-data</>.
       </para>
-->
<para>
排除表数据只是数据库中表的一个子集，参阅<option>--exclude-table-data</>。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-S <replaceable class="parameter">username</replaceable></option></term>
      <term><option>--superuser=<replaceable class="parameter">username</replaceable></option></term>
      <listitem>
       <!--
<para>
        Specify the superuser user name to use when disabling triggers.
        This is relevant only if <option>&#045;-disable-triggers</> is used.
        (Usually, it's better to leave this out, and instead start the
        resulting script as superuser.)
       </para>
-->
<para>
指定关闭触发器时需要用到的超级用户名。它只有使用了<option>--disable-triggers</>
的时候才有影响。一般情况下最好不要输入这个参数，而是用超级用户启动生成的脚本。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-t <replaceable class="parameter">table</replaceable></option></term>
      <term><option>--table=<replaceable class="parameter">table</replaceable></option></term>
      <listitem>
       <!--
<para>
        Dump only tables (or views or sequences or foreign tables) matching
        <replaceable class="parameter">table</replaceable>.  Multiple tables
        can be selected by writing multiple <option>-t</> switches.  Also, the
        <replaceable class="parameter">table</replaceable> parameter is
        interpreted as a pattern according to the same rules used by
        <application>psql</>'s <literal>\d</> commands (see <xref
        linkend="APP-PSQL-patterns" endterm="APP-PSQL-patterns-title">),
        so multiple tables can also be selected by writing wildcard characters
        in the pattern.  When using wildcards, be careful to quote the pattern
        if needed to prevent the shell from expanding the wildcards;  see
        <xref linkend="pg-dump-examples" endterm="pg-dump-examples-title">.
       </para>
-->
<para>
只转储出匹配<replaceable class="parameter">table</replaceable>的表（或视图、序列、外表）。
可以使用多个<option>-t</>选项匹配多个表。同样，<replaceable class="parameter">table</replaceable>
参数将按照<application>psql</>的<literal>\d</>命令的规则(参见
<xref linkend="APP-PSQL-patterns" endterm="APP-PSQL-patterns-title">)被解释为匹配模式，
因此可以使用通配符匹配多个模式。在使用通配符的时候，最好用引号进行界定，
以防止 shell 将通配符进行扩展。参阅<xref linkend="pg-dump-examples" endterm="pg-dump-examples-title">。
</para>

       <!--
<para>
        The <option>-n</> and <option>-N</> switches have no effect when
        <option>-t</> is used, because tables selected by <option>-t</> will
        be dumped regardless of those switches, and non-table objects will not
        be dumped.
       </para>
-->
<para>
使用了<option>-t</>之后，<option>-n</>和<option>-N</>选项就失效了。因为被<option>-t</>
选中的表将无视<option>-n</>和<option>-N</>选项而被转储，同时除了表之外的其他对象不会被转储。
</para>

       <note>
        <!--
<para>
         When <option>-t</> is specified, <application>pg_dump</application>
         makes no attempt to dump any other database objects that the selected
         table(s) might depend upon. Therefore, there is no guarantee
         that the results of a specific-table dump can be successfully
         restored by themselves into a clean database.
        </para>
-->
<para>
如果指定了<option>-t</>，那么<application>pg_dump</application>
将不会转储任何选中的表依赖的其它数据库对象。因此，
无法保证转储出来的表能在一个干净的数据库中成功恢复。
</para>
       </note>

       <note>
        <!--
<para>
         The behavior of the <option>-t</> switch is not entirely upward
         compatible with pre-8.2 <productname>PostgreSQL</productname>
         versions.  Formerly, writing <literal>-t tab</> would dump all
         tables named <literal>tab</>, but now it just dumps whichever one
         is visible in your default search path.  To get the old behavior
         you can write <literal>-t '*.tab'</>.  Also, you must write something
         like <literal>-t sch.tab</> to select a table in a particular schema,
         rather than the old locution of <literal>-n sch -t tab</>.
        </para>
-->
<para>
<option>-t</>选项与<productname>PostgreSQL</productname> 8.2 之前的版本不兼容。
之前的<literal>-t tab</>将转储所有名为<literal>tab</>的表，
但是现在只转储在默认搜索路径中可见的表。写成<literal>-t '*.tab'</>将等价于老版本的行为。
同样，你必须用<literal>-t sch.tab</>而不是老版本的<literal>-n sch -t tab</>选择特定模式中的表。
</para>
       </note>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-T <replaceable class="parameter">table</replaceable></option></term>
      <term><option>--exclude-table=<replaceable class="parameter">table</replaceable></option></term>
      <listitem>
       <!--
<para>
        Do not dump any tables matching the <replaceable
        class="parameter">table</replaceable> pattern.  The pattern is
        interpreted according to the same rules as for <option>-t</>.
        <option>-T</> can be given more than once to exclude tables
        matching any of several patterns.
       </para>
-->
<para>
不要转储任何匹配<replaceable class="parameter">table</replaceable>模式的表。
模式匹配规则与<option>-t</>完全相同。可以指定多个<option>-T</>以排除多种匹配的表。
</para>

       <!--
<para>
        When both <option>-t</> and <option>-T</> are given, the behavior
        is to dump just the tables that match at least one <option>-t</>
        switch but no <option>-T</> switches.  If <option>-T</> appears
        without <option>-t</>, then tables matching <option>-T</> are
        excluded from what is otherwise a normal dump.
       </para>
-->
<para>
如果同时指定了<option>-t</>和<option>-T</>，那么将只转储匹配<option>-t</>
但不匹配<option>-T</>的表。如果出现<option>-T</>但是不出现<option>-t</>，
那么匹配 <option>-T</>的表将不会被转储。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-v</></term>
      <term><option>--verbose</></term>
      <listitem>
       <!--
<para>
        Specifies verbose mode.  This will cause
        <application>pg_dump</application> to output detailed object
        comments and start/stop times to the dump file, and progress
        messages to standard error.
       </para>
-->
<para>
指定冗余模式。这样将令<application>pg_dump</application>
输出详细的对象评注以及转储文件的启停时间和进度信息到标准错误上。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
       <term><option>-V</></term>
       <term><option>--version</></term>
       <listitem>
       <!--
<para>
       Print the <application>pg_dump</application> version and exit.
       </para>
-->
<para>
打印<application>pg_dump</application>版本然后退出。
</para>
       </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-x</></term>
      <term><option>--no-privileges</></term>
      <term><option>--no-acl</></term>
      <listitem>
       <!--
<para>
        Prevent dumping of access privileges (grant/revoke commands).
       </para>
-->
<para>
禁止转储访问权限(grant/revoke 命令)。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-Z <replaceable class="parameter">0..9</replaceable></option></term>
      <term><option>--compress=<replaceable class="parameter">0..9</replaceable></option></term>
      <listitem>
       <!--
<para>
        Specify the compression level to use.  Zero means no compression.
        For the custom archive format, this specifies compression of
        individual table-data segments, and the default is to compress
        at a moderate level.
        For plain text output, setting a nonzero compression level causes
        the entire output file to be compressed, as though it had been
        fed through <application>gzip</>; but the default is not to compress.
        The tar archive format currently does not support compression at all.
       </para>
-->
<para>
指定要使用的压缩级别。0表示不压缩。对于自定义归档格式，指定单个表数据段的压缩，
并且缺省是中等水平的压缩。对于纯文本输出，设置非零压缩级别会压缩整个输出文件，
就像通过<application>gzip</>反馈回来一样；但是缺省是不压缩的。
tar归档模式当前不支持压缩。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--binary-upgrade</option></term>
      <listitem>
       <!--
<para>
        This option is for use by in-place upgrade utilities.  Its use
        for other purposes is not recommended or supported.  The
        behavior of the option may change in future releases without
        notice.
       </para>
-->
<para>
此选项用于在线升级工具。不建议也不支持用于其他目的。该选项的行为可能会在将来的版本中改变。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--column-inserts</option></term>
      <term><option>--attribute-inserts</option></term>
      <listitem>
       <!--
<para>
        Dump data as <command>INSERT</command> commands with explicit
        column names (<literal>INSERT INTO
        <replaceable>table</replaceable>
        (<replaceable>column</replaceable>, ...) VALUES
        ...</literal>).  This will make restoration very slow; it is mainly
        useful for making dumps that can be loaded into
        non-<productname>PostgreSQL</productname> databases.
        However, since this option generates a separate command for each row,
        an error in reloading a row causes only that row to be lost rather
        than the entire table contents.
       </para>
-->
<para>
把数据转储为带有明确字段名的<command>INSERT</command>命令
(<literal>INSERT INTO <replaceable>table</replaceable> (<replaceable>column</replaceable>, ...)
 VALUES ...</literal>)。这样会导致恢复非常缓慢，它主要用于制作那种可以用于其它非
<productname>PostgreSQL</productname>数据库的转储。由于这个选项为每条记录都生成一条命令，
因此如果其中某一行命令出错，那么将仅有该行数据丢失，而不是整个表的数据丢失。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--disable-dollar-quoting</></term>
      <listitem>
       <!--
<para>
        This option disables the use of dollar quoting for function bodies,
        and forces them to be quoted using SQL standard string syntax.
       </para>
-->
<para>
这个选项关闭使用美元符界定函数体。强制它们用 SQL 标准的字符串语法的引号包围。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--disable-triggers</></term>
      <listitem>
       <!--
<para>
        This option is relevant only when creating a data-only dump.
        It instructs <application>pg_dump</application> to include commands
        to temporarily disable triggers on the target tables while
        the data is reloaded.  Use this if you have referential
        integrity checks or other triggers on the tables that you
        do not want to invoke during data reload.
       </para>
-->
<para>
这个选项只是和创建仅有数据的转储相关。它告诉<application>pg_dump</application>
包含在恢复数据时临时关闭目标表上触发器的命令。如果在表上有参照完整性检查或者其它触发器，
而恢复数据的时候不想重载他们，那么就应该使用这个选项。
</para>

       <!--
<para>
        Presently, the commands emitted for <option>&#045;-disable-triggers</>
        must be done as superuser.  So, you should also specify
        a superuser name with <option>-S</>, or preferably be careful to
        start the resulting script as a superuser.
       </para>
-->
<para>
目前，为<option>--disable-triggers</>发出的命令必须以超级用户来执行。因此，
你应该同时用<option>-S</>声明一个超级用户名，
或者最好是用一个超级用户的身份来启动这个生成的脚本。
</para>

       <!--
<para>
        This option is only meaningful for the plain-text format.  For
        the archive formats, you can specify the option when you
        call <command>pg_restore</command>.
       </para>
-->
<para>
这个选项只对纯文本格式有意义。对于归档格式，可以在调用<command>pg_restore</command>
的时候声明这个选项。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--exclude-table-data=<replaceable class="parameter">table</replaceable></option></term>
      <listitem>
       <!--
<para>
        Do not dump data for any tables matching the <replaceable
        class="parameter">table</replaceable> pattern. The pattern is
        interpreted according to the same rules as for <option>-t</>.
        <option>&#045;-exclude-table-data</> can be given more than once to
        exclude tables matching any of several patterns. This option is
        useful when you need the definition of a particular table even
        though you do not need the data in it.
       </para>
-->
<para>
不要转储任何匹配<replaceable class="parameter">table</replaceable>模式的表。
模式匹配规则与<option>-t</>完全相同。可以给出多个<option>--exclude-table-data</>
以排除多个匹配的表。当你需要指定表的定义时该选项是有用的，即使你不需要表里面的数据。
</para>
       <!--
<para>
        To exclude data for all tables in the database, see <option>&#045;-schema-only</>.
       </para>
-->
<para>
要排除数据库中所有表的数据，参阅<option>--schema-only</>。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--inserts</option></term>
      <listitem>
       <!--
<para>
        Dump data as <command>INSERT</command> commands (rather
        than <command>COPY</command>).  This will make restoration very slow;
        it is mainly useful for making dumps that can be loaded into
        non-<productname>PostgreSQL</productname> databases.
        However, since this option generates a separate command for each row,
        an error in reloading a row causes only that row to be lost rather
        than the entire table contents.
        Note that
        the restore might fail altogether if you have rearranged column order.
        The <option>&#045;-column-inserts</option> option is safe against column
        order changes, though even slower.
       </para>
-->
<para>
将数据输出为的<command>INSERT</command>命令(而不是<command>COPY</command>)。
这样会导致恢复非常缓慢。这个选项主要用于制作那种可以用于其它非
<productname>PostgreSQL</productname>数据库的转储。由于这个选项为每条记录都生成一条命令，
因此如果其中某一行命令出错，那么将仅有该行数据丢失，而不是整个表的数据丢失。
请注意，如果你重新排列了字段顺序，那么恢复可能会完全失败。
<option>--column-inserts</option>更安全，但是也更慢。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--lock-wait-timeout=<replaceable class="parameter">timeout</replaceable></option></term>
      <listitem>
       <!--
<para>
        Do not wait forever to acquire shared table locks at the beginning of
        the dump. Instead fail if unable to lock a table within the specified
        <replaceable class="parameter">timeout</>. The timeout may be
        specified in any of the formats accepted by <command>SET
        statement_timeout</>.  (Allowed values vary depending on the server
        version you are dumping from, but an integer number of milliseconds
        is accepted by all versions since 7.3.  This option is ignored when
        dumping from a pre-7.3 server.)
       </para>
-->
<para>
在转储开始的时候不要等待请求一个共享表锁。相反，如果无法在指定的
<replaceable class="parameter">timeout</>内锁住表则失败。
timeout可以用任意<command>SET statement_timeout</>接受的格式声明。
（允许的值依赖于你转储的服务器版本，但是自7.3以来，所有的版本都接受毫秒的整数值。
当从7.3以前的版本服务器中转储时，省略该选项。）
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--no-security-labels</option></term>
      <listitem>
       <!--
<para>
        Do not dump security labels.
       </para>
-->
<para>
不转储安全标签。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--no-synchronized-snapshots</></term>
      <listitem>
       <!--
<para>
        This option allows running <command>pg_dump -j</> against a pre-9.2
        server, see the documentation of the <option>-j</option> parameter
        for more details.
       </para>
-->
<para>
该选项允许在9.2以前的服务器上运行<command>pg_dump -j</>，参阅<option>-j</option>
参数的文档获取更多信息。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--no-tablespaces</option></term>
      <listitem>
       <!--
<para>
        Do not output commands to select tablespaces.
        With this option, all objects will be created in whichever
        tablespace is the default during restore.
       </para>
-->
<para>
不要输出选择表空间的命令。有了该选项，所有对象在转储期间都将在缺省的表空间中创建。
</para>

       <!--
<para>
        This option is only meaningful for the plain-text format.  For
        the archive formats, you can specify the option when you
        call <command>pg_restore</command>.
       </para>
-->
<para>
这个选项只是对纯文本格式有意义。对于归档格式，在调用<command>pg_restore</command>
的时候可以声明该选项。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--no-unlogged-table-data</option></term>
      <listitem>
       <!--
<para>
        Do not dump the contents of unlogged tables.  This option has no
        effect on whether or not the table definitions (schema) are dumped;
        it only suppresses dumping the table data. Data in unlogged tables
        is always excluded when dumping from a standby server.
       </para>
-->
<para>
不要转储未记录表的内容。该选项对于表定义（模式）是否转储没有影响；
它只阻止转储表的数据。当从备用服务器转储时，未记录表中的数据总是排除。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--quote-all-identifiers</></term>
      <listitem>
       <!--
<para>
        Force quoting of all identifiers.  This may be useful when dumping a
        database for migration to a future version that may have introduced
        additional keywords.
       </para>
-->
<para>
强制给所有标识符加上引号。这在转储一个数据库到一个可能引入了额外关键字的新版本中时可能是有用的。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
       <term><option>--section=<replaceable class="parameter">sectionname</replaceable></option></term>
       <listitem>
         <!--
<para>
          Only dump the named section. The section name can be
          <option>pre-data</>, <option>data</>, or <option>post-data</>.
          This option can be specified more than once to select multiple
          sections. The default is to dump all sections.
         </para>
-->
<para>
只转储命名的章节。该章节名可以是<option>pre-data</>, <option>data</>, 或 
<option>post-data</>。可以多次声明这个选项以选择多个章节。
缺省是转储所有章节。
</para>
         <!--
<para>
          The data section contains actual table data, large-object
          contents, and sequence values.
          Post-data items include definitions of indexes, triggers, rules,
          and constraints other than validated check constraints.
          Pre-data items include all other data definition items.
         </para>
-->
<para>
数据章节包含实际的表数据、大对象内容和序列值。原始数据项包含索引、触发器、
规则和约束（除了验证检查约束）的定义。之前的数据项包含所有其他数据定义项。
</para>
       </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--serializable-deferrable</option></term>
      <listitem>
       <!--
<para>
        Use a <literal>serializable</literal> transaction for the dump, to
        ensure that the snapshot used is consistent with later database
        states; but do this by waiting for a point in the transaction stream
        at which no anomalies can be present, so that there isn't a risk of
        the dump failing or causing other transactions to roll back with a
        <literal>serialization_failure</literal>.  See <xref linkend="mvcc">
        for more information about transaction isolation and concurrency
        control.
       </para>
-->
<para>
为转储使用一个<literal>可串行化</literal>的事务，以保证使用的快照和稍后的数据库状态一致；
做这些是通过等待事务流中的一个点，该点没有异常会出现，所以不会有转储失败或导致其他事务
<literal>serialization_failure</literal>而回滚的风险。参阅<xref linkend="mvcc">
获取关于事务隔离和并发控制的更多信息。
</para>

       <!--
<para>
        This option is not beneficial for a dump which is intended only for
        disaster recovery.  It could be useful for a dump used to load a
        copy of the database for reporting or other read-only load sharing
        while the original database continues to be updated.  Without it the
        dump may reflect a state which is not consistent with any serial
        execution of the transactions eventually committed.  For example, if
        batch processing techniques are used, a batch may show as closed in
        the dump without all of the items which are in the batch appearing.
       </para>
-->
<para>
这个选项对于只打算灾难恢复的转储没有益处。对于原始数据库仍然在更新时，
加载一个数据库的拷贝作为报告或其他只读加载共享的转储是有帮助的。
没有这个选项，转储会反应一个与任何事务最终提交的序列化执行不一致的状态。
例如，如果使用了批处理技术，可能会在转储中显示一部分，而不是批处理中的所有条目。
</para>

       <!--
<para>
        This option will make no difference if there are no read-write
        transactions active when pg_dump is started.  If read-write
        transactions are active, the start of the dump may be delayed for an
        indeterminate length of time.  Once running, performance with or
        without the switch is the same.
       </para>
-->
<para>
在pg_dump开始时，如果没有读写事务在活动，则这个选项没有什么影响。
如果有读写事务在活动，那么转储开始时可能会延迟一段不确定的时间。
一旦运行，有没有开关的性能是一样的。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--use-set-session-authorization</></term>
      <listitem>
       <!--
<para>
        Output SQL-standard <command>SET SESSION AUTHORIZATION</> commands
        instead of <command>ALTER OWNER</> commands to determine object
        ownership.  This makes the dump more standards-compatible, but
        depending on the history of the objects in the dump, might not restore
        properly.  Also, a dump using <command>SET SESSION AUTHORIZATION</>
        will certainly require superuser privileges to restore correctly,
        whereas <command>ALTER OWNER</> requires lesser privileges.
       </para>
-->
<para>
输出符合 SQL 标准的<command>SET SESSION AUTHORIZATION</>命令而不是<command>ALTER OWNER</>
命令来确定对象所有权。这样令转储更加符合标准，但是如果转储文件中的对象的历史有些问题，
那么可能不能正确恢复。并且，使用<command>SET SESSION AUTHORIZATION</>
的转储需要数据库超级用户的权限才能转储成功，而<command>ALTER OWNER</>需要的权限则低得多。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
       <term><option>-?</></term>
       <term><option>--help</></term>
       <listitem>
       <!--
<para>
       Show help about <application>pg_dump</application> command line
       arguments, and exit.
       </para>
-->
<para>
显示关于<application>pg_dump</application>命令行参数的帮助然后退出。
</para>
       </listitem>
     </varlistentry>

    </variablelist>
   </para>

   
<para>
<!-- 
    The following command-line options control the database connection parameters.
 -->
 下面的命令行参数控制数据库的连接参数。
    <variablelist>
     <varlistentry>
      <term><option>-d <replaceable class="parameter">dbname</replaceable></></term>
      <term><option>--dbname=<replaceable class="parameter">dbname</replaceable></></term>
      <listitem>
<!--      <para>
       Specifies the name of the database to connect to. This is
       equivalent to specifying <replaceable
       class="parameter">dbname</replaceable> as the first non-option
       argument on the command line.
      </para>
-->
<para>
声明要连接的数据库名称。相当于在命令行中声明<replaceable class="parameter">dbname</replaceable>
作为第一个非选项参数。
</para>
      <!--
<para>
       If this parameter contains an <symbol>=</symbol> sign or starts
       with a valid <acronym>URI</acronym> prefix
       (<literal>postgresql://</literal>
       or <literal>postgres://</literal>), it is treated as a
       <parameter>conninfo</parameter> string. See <xref linkend="libpq-connect"> for more information.
      </para>
-->
<para>
如果这个参数包含一个<symbol>=</symbol>符号或以一个有效的<acronym>URI</acronym>前缀
(<literal>postgresql://</literal>或<literal>postgres://</literal>)开始，
那么将其看做一个<parameter>conninfo</parameter>字符串。参阅<xref linkend="libpq-connect">
获取更多信息。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-h <replaceable class="parameter">host</replaceable></option></term>
      <term><option>--host=<replaceable class="parameter">host</replaceable></option></term>
      <listitem>
       <!--
<para>
        Specifies the host name of the machine on which the server is
        running.  If the value begins with a slash, it is used as the
        directory for the Unix domain socket. The default is taken
        from the <envar>PGHOST</envar> environment variable, if set,
        else a Unix domain socket connection is attempted.
       </para>
-->
<para>
指定运行服务器的主机名。如果数值以斜杠开头，则被用作到 Unix 域套接字的路径。
缺省从<envar>PGHOST</envar>环境变量中获取(如果设置了的话)，否则，尝试一个 Unix 域套接字连接。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-p <replaceable class="parameter">port</replaceable></option></term>
      <term><option>--port=<replaceable class="parameter">port</replaceable></option></term>
      <listitem>
       <!--
<para>
        Specifies the TCP port or local Unix domain socket file
        extension on which the server is listening for connections.
        Defaults to the <envar>PGPORT</envar> environment variable, if
        set, or a compiled-in default.
       </para>
-->
<para>
指定服务器正在侦听的 TCP 端口或本地 Unix 域套接字文件的扩展(描述符)。
缺省使用<envar>PGPORT</envar>环境变量(如果设置了的话)，否则，编译时的缺省值。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-U <replaceable>username</replaceable></option></term>
      <term><option>--username=<replaceable class="parameter">username</replaceable></option></term>
      <listitem>
       <!--
<para>
        User name to connect as.
       </para>
-->
<para>
连接的用户名。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-w</></term>
      <term><option>--no-password</></term>
      <listitem>
       <!--
<para>
        Never issue a password prompt.  If the server requires
        password authentication and a password is not available by
        other means such as a <filename>.pgpass</filename> file, the
        connection attempt will fail.  This option can be useful in
        batch jobs and scripts where no user is present to enter a
        password.
       </para>
-->
<para>
从不发出密码提示问题。如果服务器要求密码认证并且密码不可用于其他意思如
<filename>.pgpass</filename>文件，则连接尝试将会失败。
该选项在批量工作和不存在用户输入密码的脚本中很有帮助。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-W</option></term>
      <term><option>--password</option></term>
      <listitem>
       <!--
<para>
        Force <application>pg_dump</application> to prompt for a
        password before connecting to a database.
       </para>
-->
<para>
强制<application>pg_dump</application>在连接到数据库之前提示一个密码。
</para>

       <!--
<para>
        This option is never essential, since
        <application>pg_dump</application> will automatically prompt
        for a password if the server demands password authentication.
        However, <application>pg_dump</application> will waste a
        connection attempt finding out that the server wants a password.
        In some cases it is worth typing <option>-W</> to avoid the extra
        connection attempt.
       </para>
-->
<para>
这个选项从来不是至关重要的，因为如果服务器需求密码认证，则<application>pg_dump</application>
自动提示一个密码。不过，<application>pg_dump</application>
将在找出服务器想要一个密码上浪费一个连接尝试。在某些情况下，值得输入<option>-W</>
以避免额外的连接尝试。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--role=<replaceable class="parameter">rolename</replaceable></option></term>
      <listitem>
       <!--
<para>
        Specifies a role name to be used to create the dump.
        This option causes <application>pg_dump</> to issue a
        <command>SET ROLE</> <replaceable class="parameter">rolename</>
        command after connecting to the database. It is useful when the
        authenticated user (specified by <option>-U</>) lacks privileges
        needed by <application>pg_dump</>, but can switch to a role with
        the required rights.  Some installations have a policy against
        logging in directly as a superuser, and use of this option allows
        dumps to be made without violating the policy.
       </para>
-->
<para>
指定创建转储的角色名。这个选项导致连接到数据库之后<application>pg_dump</>
发出一个<command>SET ROLE</> <replaceable class="parameter">rolename</>命令。
当认证的用户（通过<option>-U</>指定）缺乏<application>pg_dump</>所需的权限时是很有用的，
可以转变成有所需权限的角色。一些安装有反对作为超级用户直接登录的政策，
使用这个选项允许转储不违反该政策。
</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
 </refsect1>

 <refsect1>
  <!-- 
  <title>Environment</title> 
  -->
  <title>环境变量</title>

  <variablelist>
   <varlistentry>
    <term><envar>PGDATABASE</envar></term>
    <term><envar>PGHOST</envar></term>
    <term><envar>PGOPTIONS</envar></term>
    <term><envar>PGPORT</envar></term>

    <term><envar>PGUSER</envar></term>
    <listitem>
     <!--
<para>
      Default connection parameters.
     </para>
-->
<para>
缺省连接参数。
</para>
    </listitem>

   </varlistentry>
  </variablelist>

  <!--
<para>
   This utility, like most other <productname>PostgreSQL</> utilities,
   also uses the environment variables supported by <application>libpq</>
   (see <xref linkend="libpq-envars">).
  </para>
-->
<para>
这个功用，类似大多数其他<productname>PostgreSQL</>实用工具，
也使用由<application>libpq</>支持的环境变量（参阅<xref linkend="libpq-envars">）。
</para>

 </refsect1>

 <refsect1 id="app-pgdump-diagnostics">
  <!-- 
  <title>Diagnostics</title> 
  -->
  <title>诊断</title>

  <!--
<para>
   <application>pg_dump</application> internally executes
   <command>SELECT</command> statements. If you have problems running
   <application>pg_dump</application>, make sure you are able to
   select information from the database using, for example, <xref
   linkend="app-psql">.  Also, any default connection settings and environment
   variables used by the <application>libpq</application> front-end
   library will apply.
  </para>
-->
<para>
<application>pg_dump</application>在内部使用<command>SELECT</command>语句。
如果你运行<application>pg_dump</application>时碰到问题，确认你能够使用像
<xref linkend="app-psql">这样的程序从数据库选取信息。还有，要申请
任何<application>libpq</application>前端库要使用的缺省连接设置和环境变量。
</para>

  <!--
<para>
   The database activity of <application>pg_dump</application> is
   normally collected by the statistics collector.  If this is
   undesirable, you can set parameter <varname>track_counts</>
   to false via <envar>PGOPTIONS</envar> or the <literal>ALTER
   USER</literal> command.
  </para>
-->
<para>
<application>pg_dump</application>的数据库活动通常由统计收集器收集。
如果不需要，你可以通过<envar>PGOPTIONS</envar> 或 <literal>ALTER
   USER</literal>命令设置参数<varname>track_counts</>为假。
</para>

 </refsect1>


 <refsect1 id="pg-dump-notes">
  <!--
<title>Notes</title>
-->
<title>注意</title>

  <!--
<para>
   If your database cluster has any local additions to the <literal>template1</> database,
   be careful to restore the output of <application>pg_dump</application> into a
   truly empty database; otherwise you are likely to get errors due to
   duplicate definitions of the added objects.  To make an empty database
   without any local additions, copy from <literal>template0</> not <literal>template1</>,
   for example:
<programlisting>
CREATE DATABASE foo WITH TEMPLATE template0;
</programlisting>
  </para>
-->
<para>
如果你的数据库给<literal>template1</>数据库增加了任何你自己的东西，
那么请注意把<application>pg_dump</application>的输出恢复到一个真正空的数据库中；
否则你可能会收到因为重复定义所追加的对象而造成的错误信息。
要制作一个没有任何本地附属物的数据库，可以从<literal>template0</>
而不是<literal>template1</>拷贝，比如：
<programlisting>
CREATE DATABASE foo WITH TEMPLATE template0;
</programlisting>
</para>

  <!--
<para>
   When a data-only dump is chosen and the option <option>&#045;-disable-triggers</>
   is used, <application>pg_dump</application> emits commands
   to disable triggers on user tables before inserting the data,
   and then commands to re-enable them after the data has been
   inserted.  If the restore is stopped in the middle, the system
   catalogs might be left in the wrong state.
  </para>
-->
<para>
在进行纯数据转储并且使用了选项<option>--disable-triggers</>的时候，
<application>pg_dump</application>发出一些查询先关闭用户表上的触发器，
然后插入数据，插入完成后再打开触发器。如果恢复动作在中间停止，
那么系统表可能就会处于一种错误状态。
</para>

  <!--
<para>
   Members of tar archives are limited to a size less than 8 GB.
   (This is an inherent limitation of the tar file format.)  Therefore
   this format cannot be used if the textual representation of any one table
   exceeds that size.  The total size of a tar archive and any of the
   other output formats is not limited, except possibly by the
   operating system.
  </para>
-->
<para>
tar 归档的成员的大小限制于 8 GB 。这是 tar 文件格式的固有限制。
因此这个格式无法用于任何大小超过这个尺寸的表。
tar 归档和任何其它输出格式的总大小是不受限制的，只是可能会有操作系统的限制。
</para>

  <!--
<para>
   The dump file produced by <application>pg_dump</application>
   does not contain the statistics used by the optimizer to make
   query planning decisions.  Therefore, it is wise to run
   <command>ANALYZE</command> after restoring from a dump file
   to ensure optimal performance; see <xref linkend="vacuum-for-statistics">
   and <xref linkend="autovacuum"> for more information.
   The dump file also does not
   contain any <command>ALTER DATABASE ... SET</> commands;
   these settings are dumped by <xref linkend="app-pg-dumpall">,
   along with database users and other installation-wide settings.
  </para>
-->
<para>
<application>pg_dump</application>生成的转储文件并不包含优化器用于查询规划决策的统计信息。
因此，恢复完之后，建议在每个已恢复的对象上运行<command>ANALYZE</command>，
以保证最佳的性能；参阅<xref linkend="vacuum-for-statistics">和<xref linkend="autovacuum">
获取更多信息。转储文件也不包含任何<command>ALTER DATABASE ... SET</>命令；
这些设置通过<xref linkend="app-pg-dumpall">转储，连同数据库用户和其他安装范围的设置。
</para>

  <!--
<para>
   Because <application>pg_dump</application> is used to transfer data
   to newer versions of <productname>PostgreSQL</>, the output of
   <application>pg_dump</application> can be expected to load into
   <productname>PostgreSQL</> server versions newer than
   <application>pg_dump</>'s version.  <application>pg_dump</> can also
   dump from <productname>PostgreSQL</> servers older than its own version.
   (Currently, servers back to version 7.0 are supported.)
   However, <application>pg_dump</> cannot dump from
   <productname>PostgreSQL</> servers newer than its own major version;
   it will refuse to even try, rather than risk making an invalid dump.
   Also, it is not guaranteed that <application>pg_dump</>'s output can
   be loaded into a server of an older major version &mdash; not even if the
   dump was taken from a server of that version.  Loading a dump file
   into an older server may require manual editing of the dump file
   to remove syntax not understood by the older server.
  </para>
-->
<para>
因为<application>pg_dump</application>常用于向新版本的<productname>PostgreSQL</>
中传递数据，所以<application>pg_dump</application>的输出预计可以加载到比
<application>pg_dump</application>的版本更新的<productname>PostgreSQL</>
服务器版本中。<application>pg_dump</>还可以从比它自身版本老的<productname>PostgreSQL</>
服务器中转储。（当前，支持后退到版本7.0的服务器。）不过，<application>pg_dump</>
不能从比它自身主版本新的<productname>PostgreSQL</>服务器中转储；它会拒绝尝试，
而不是冒险制作一个不可用的转储。另外，它不保证<application>pg_dump</>
的输出可以加载到一个旧的主版本的服务器中，即使该转储是从那个版本的服务器中而来。
加载转储文件到一个旧的服务器可能需要手动编辑转储文件，以删除不被旧版本理解的语法。
</para>
 </refsect1>

 <refsect1 id="pg-dump-examples">
  <!-- 
  <title id="pg-dump-examples-title">Examples</title> 
  -->
  <title id="pg-dump-examples-title">例子</title>

  <!--
<para>
   To dump a database called <literal>mydb</> into a SQL-script file:
<screen>
<prompt>$</prompt> <userinput>pg_dump mydb &gt; db.sql</userinput>
</screen>
  </para>
-->
<para>
将<literal>mydb</>数据库转储到一个 SQL 脚本文件：
<screen>
<prompt>$</prompt> <userinput>pg_dump mydb &gt; db.sql</userinput>
</screen>
</para>

  <!--
<para>
   To reload such a script into a (freshly created) database named
   <literal>newdb</>:

<screen>
<prompt>$</prompt> <userinput>psql -d newdb -f db.sql</userinput>
</screen>
  </para>
-->
<para>
将上述脚本导入一个(新建的)数据库<literal>newdb</>：
<screen>
<prompt>$</prompt> <userinput>psql -d newdb -f db.sql</userinput>
</screen>
</para>

  <!--
<para>
   To dump a database into a custom-format archive file:

<screen>
<prompt>$</prompt> <userinput>pg_dump -Fc mydb &gt; db.dump</userinput>
</screen>
  </para>
-->
<para>
将数据库转储为自定义格式的归档文件
<screen>
<prompt>$</prompt> <userinput>pg_dump -Fc mydb &gt; db.dump</userinput>
</screen>
</para>

  <!--
<para>
   To dump a database into a directory-format archive:

<screen>
<prompt>$</prompt> <userinput>pg_dump -Fd mydb -f dumpdir</userinput>
</screen>
  </para>
-->
<para>
将数据库转储为目录格式归档：
<screen>
<prompt>$</prompt> <userinput>pg_dump -Fd mydb -f dumpdir</userinput>
</screen>
</para>

  <!--
<para>
   To dump a database into a directory-format archive in parallel with
   5 worker jobs:

<screen>
<prompt>$</prompt> <userinput>pg_dump -Fd mydb -j 5 -f dumpdir</userinput>
</screen>
  </para>
-->
<para>
将数据库转储为目录格式归档，并行5个worker工作：
<screen>
<prompt>$</prompt> <userinput>pg_dump -Fd mydb -j 5 -f dumpdir</userinput>
</screen>
</para>

  <!--
<para>
   To reload an archive file into a (freshly created) database named
   <literal>newdb</>:

<screen>
<prompt>$</prompt> <userinput>pg_restore -d newdb db.dump</userinput>
</screen>
  </para>
-->
<para>
将归档文件导入一个(新建的)数据库<literal>newdb</>：
<screen>
<prompt>$</prompt> <userinput>pg_restore -d newdb db.dump</userinput>
</screen>
</para>

  <!--
<para>
   To dump a single table named <literal>mytab</>:

<screen>
<prompt>$</prompt> <userinput>pg_dump -t mytab mydb &gt; db.sql</userinput>
</screen>
  </para>
-->
<para>
转储一个名为<literal>mytab</>的表：
<screen>
<prompt>$</prompt> <userinput>pg_dump -t mytab mydb &gt; db.sql</userinput>
</screen>
</para>

  <!--
<para>
   To dump all tables whose names start with <literal>emp</> in the
   <literal>detroit</> schema, except for the table named
   <literal>employee_log</literal>:

<screen>
<prompt>$</prompt> <userinput>pg_dump -t 'detroit.emp*' -T detroit.employee_log mydb &gt; db.sql</userinput>
</screen>
  </para>
-->
<para>
转储<literal>detroit</>模式中所有以<literal>emp</>开头的表，
但是不包括<literal>employee_log</literal>表：
<screen>
<prompt>$</prompt> <userinput>pg_dump -t 'detroit.emp*' -T detroit.employee_log mydb &gt; db.sql</userinput>
</screen>
</para>

  <!--
<para>
   To dump all schemas whose names start with <literal>east</> or
   <literal>west</> and end in <literal>gsm</>, excluding any schemas whose
   names contain the word <literal>test</>:

<screen>
<prompt>$</prompt> <userinput>pg_dump -n 'east*gsm' -n 'west*gsm' -N '*test*' mydb &gt; db.sql</userinput>
</screen>
  </para>
-->
<para>
转储所有以<literal>east</>或<literal>west</>开头并以<literal>gsm</>结尾的模式，
但是不包括名字中含有<literal>test</>模式：
<screen>
<prompt>$</prompt> <userinput>pg_dump -n 'east*gsm' -n 'west*gsm' -N '*test*' mydb &gt; db.sql</userinput>
</screen>
</para>

  <!--
<para>
   The same, using regular expression notation to consolidate the switches:

<screen>
<prompt>$</prompt> <userinput>pg_dump -n '(east|west)*gsm' -N '*test*' mydb &gt; db.sql</userinput>
</screen>
  </para>
-->
<para>
同上，不过这一次使用正则表达式的方法：
<screen>
<prompt>$</prompt> <userinput>pg_dump -n '(east|west)*gsm' -N '*test*' mydb &gt; db.sql</userinput>
</screen>
</para>

  <!--
<para>
   To dump all database objects except for tables whose names begin with
   <literal>ts_</literal>:

<screen>
<prompt>$</prompt> <userinput>pg_dump -T 'ts_*' mydb &gt; db.sql</userinput>
</screen>
  </para>
-->
<para>
转储所有数据库对象，但是不包括名字以<literal>ts_</literal>开头的表：
<screen>
<prompt>$</prompt> <userinput>pg_dump -T 'ts_*' mydb &gt; db.sql</userinput>
</screen>
</para>
  <!--
<para>
   To specify an upper-case or mixed-case name in <option>-t</> and related
   switches, you need to double-quote the name; else it will be folded to
   lower case (see <xref
   linkend="APP-PSQL-patterns" endterm="APP-PSQL-patterns-title">).  But
   double quotes are special to the shell, so in turn they must be quoted.
   Thus, to dump a single table with a mixed-case name, you need something
   like

<screen>
<prompt>$</prompt> <userinput>pg_dump -t "\"MixedCaseName\"" mydb &gt; mytab.sql</userinput>
</screen></para>
-->
<para>
在<option>-t</>等选项中指定大写字母或大小写混合的名字必须用双引号界定，
否则将被自动转换为小写(参见<xref linkend="APP-PSQL-patterns" endterm="APP-PSQL-patterns-title">)。
但是因为双引号在 shell 中有特殊含义，所以必须将双引号再放进单引号中。
这样一来，要转储一个大小写混合的表名，你就需要像下面这样：
<screen>
<prompt>$</prompt> <userinput>pg_dump -t "\"MixedCaseName\"" mydb &gt; mytab.sql</userinput>
</screen>
</para>
 </refsect1>

 <refsect1>
  <!--
<title>See Also</title>
-->
<title>又见</title>

  <simplelist type="inline">
   <member><xref linkend="app-pg-dumpall"></member>
   <member><xref linkend="app-pgrestore"></member>
   <member><xref linkend="app-psql"></member>
  </simplelist>
 </refsect1>

</refentry>
