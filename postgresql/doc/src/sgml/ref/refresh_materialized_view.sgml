<!--
doc/src/sgml/ref/refresh_materialized_view.sgml
PostgreSQL documentation
-->

<refentry id="SQL-REFRESHMATERIALIZEDVIEW">
 <indexterm zone="sql-refreshmaterializedview">
  <primary>REFRESH MATERIALIZED VIEW</primary>
 </indexterm>
 <refmeta>
  <refentrytitle>REFRESH MATERIALIZED VIEW</refentrytitle>
  <manvolnum>7</manvolnum>
  <!--
<refmiscinfo>SQL - Language Statements</refmiscinfo>
-->
<refmiscinfo>SQL - 语句</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>REFRESH MATERIALIZED VIEW</refname>
  <!-- 
  <refpurpose>replace the contents of a materialized view</refpurpose> 
  -->
  <refpurpose>替换物化视图的内容</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
REFRESH MATERIALIZED VIEW [ CONCURRENTLY ] <replaceable class="PARAMETER">name</replaceable>
    [ WITH [ NO ] DATA ]
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <command>REFRESH MATERIALIZED VIEW</command> completely replaces the
   contents of a materialized view.  The old contents are discarded.  If
   <literal>WITH DATA</literal> is specified (or defaults) the backing query
   is executed to provide the new data, and the materialized view is left in a
   scannable state.  If <literal>WITH NO DATA</literal> is specified no new
   data is generated and the materialized view is left in an unscannable
   state.
  </para>
-->
<para>
<command>REFRESH MATERIALIZED VIEW</command>完全替换一个物化视图的内容。旧的内容被丢弃。
如果声明了<literal>WITH DATA</literal>（或缺省），后端查询被执行以提供新的数据，
物化视图留在可扫描的状态。如果声明了<literal>WITH NO DATA</literal>，
那么不会产生新的数据，并且物化视图留在一个不可扫描的状态。
</para>

<!-- 
  <para>
   <literal>CONCURRENTLY</literal> and <literal>WITH NO DATA</literal> may not
   be specified together.
  </para>
-->
<para>
<literal>CONCURRENTLY</literal>和<literal>WITH NO DATA</literal>不能一起声明。
</para>
 </refsect1>

 <refsect1>
  <!--
<title>Parameters</title>
-->
<title>参数</title>

  <variablelist>
   <varlistentry>
    <term><literal>CONCURRENTLY</literal></term>
    <listitem>
<!-- 
     <para>
      Refresh the materialized view without locking out concurrent selects on
      the materialized view.  Without this option a refresh which affects a
      lot of rows will tend to use fewer resources and complete more quickly,
      but could block other connections which are trying to read from the
      materialized view.  This option may be faster in cases where a small
      number of rows are affected.
     </para>
-->
<para>
刷新物化视图而不锁定该物化视图上并发的选择。没有这个选项，
一个影响多行的刷新将尝试使用更少的资源并完成的更快，
但是会锁定其他尝试读取该物化视图的连接。
这个选项在影响少量行数的情况下执行的更快。
</para>
<!-- 
     <para>
      This option is only allowed if there is at least one
      <literal>UNIQUE</literal> index on the materialized view which uses only
      column names and includes all rows; that is, it must not index on any
      expressions nor include a <literal>WHERE</literal> clause.
     </para>
-->
<para>
这个选项仅在只使用字段名且包括所有行的物化视图上至少有一个
<literal>UNIQUE</literal>索引的时候使用；也就是，
它必须不在任何表达式上索引并且也不包括<literal>WHERE</literal>子句。
</para>
<!-- 
     <para>
      This option may not be used when the materialized view is not already
      populated.
     </para> 
-->
<para>
当物化视图还未填充时不能使用这个选项。
</para>
<!-- 
     <para>
      Even with this option only one <literal>REFRESH</literal> at a time may
      run against any one materialized view.
     </para>
-->
<para>
尽管使用这个选项，一次在任何一个物化视图上只能运行一个<literal>REFRESH</literal>。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">name</replaceable></term>
    <listitem>
     <!--
<para>
      The name (optionally schema-qualified) of the materialized view to
      refresh.
     </para>
-->
<para>
要刷新内容的物化视图的名字（可以有模式修饰）。
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <!--
<title>Notes</title>
-->
<title>注意</title>

  <!--
<para>
   While the default index for future
   <xref linkend="SQL-CLUSTER">
   operations is retained, <command>REFRESH MATERIALIZED VIEW</> does not
   order the generated rows based on this property. If you want the data
   to be ordered upon generation, you must use an <literal>ORDER BY</>
   clause in the backing query.
  </para>
-->
<para>
当保留了未来的<xref linkend="SQL-CLUSTER">操作的缺省索引时，<command>REFRESH MATERIALIZED VIEW</>
不要求生成的行基于这个属性。如果你希望数据根据生成排序，必须在后端查询中使用一个
<literal>ORDER BY</>子句。
</para>
 </refsect1>

 <refsect1>
  <!--
<title>Examples</title>
-->
<title>例子</title>

  <!--
<para>
   This command will replace the contents of the materialized view called
   <literal>order_summary</literal> using the query from the materialized
   view's definition, and leave it in a scannable state:
<programlisting>
REFRESH MATERIALIZED VIEW order_summary;
</programlisting>
  </para>
-->
<para>
这个命令将刷新物化视图<literal>order_summary</literal>的内容，使用来自物化视图定义的查询，
并且使它留在可扫描的状态：
<programlisting>
REFRESH MATERIALIZED VIEW order_summary;
</programlisting>
</para>

  <!--
<para>
   This command will free storage associated with the materialized view
   <literal>annual_statistics_basis</literal> and leave it in an unscannable
   state:
<programlisting>
REFRESH MATERIALIZED VIEW annual_statistics_basis WITH NO DATA;
</programlisting></para>
-->
<para>
这个命令将清空物化视图<literal>annual_statistics_basis</literal>的存储区，并使它留在不可扫描的状态：
<programlisting>
REFRESH MATERIALIZED VIEW annual_statistics_basis WITH NO DATA;
</programlisting>
</para>
 </refsect1>

 <refsect1>
  <!--
<title>Compatibility</title>
-->
<title>兼容性</title>

  <!--
<para>
   <command>REFRESH MATERIALIZED VIEW</command> is a
   <productname>PostgreSQL</productname> extension.
  </para>
-->
<para>
<command>REFRESH MATERIALIZED VIEW</command>是一个<productname>PostgreSQL</productname>扩展。
</para>
 </refsect1>

 <refsect1>
  <!--
<title>See Also</title>
-->
<title>又见</title>

  <simplelist type="inline">
   <member><xref linkend="sql-creatematerializedview"></member>
   <member><xref linkend="sql-altermaterializedview"></member>
   <member><xref linkend="sql-dropmaterializedview"></member>
  </simplelist>
 </refsect1>

</refentry>
