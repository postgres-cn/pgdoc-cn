<!--
doc/src/sgml/ref/create_type.sgml
PostgreSQL documentation
-->

<refentry id="sql-createtype">
<!--==========================orignal english content==========================
 <indexterm zone="sql-createtype">
  <primary>CREATE TYPE</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="sql-createtype">
  <primary>CREATE TYPE</primary>
 </indexterm>

<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>CREATE TYPE</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>CREATE TYPE</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>CREATE TYPE</refname>
  <refpurpose>define a new data type</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>CREATE TYPE</refname>
  <refpurpose>定义一种新的数据类型</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
CREATE TYPE <replaceable class="parameter">name</replaceable> AS
    ( [ <replaceable class="parameter">attribute_name</replaceable> <replaceable class="parameter">data_type</replaceable> [ COLLATE <replaceable>collation</replaceable> ] [, ... ] ] )

CREATE TYPE <replaceable class="parameter">name</replaceable> AS ENUM
    ( [ '<replaceable class="parameter">label</replaceable>' [, ... ] ] )

CREATE TYPE <replaceable class="parameter">name</replaceable> AS RANGE (
    SUBTYPE = <replaceable class="parameter">subtype</replaceable>
    [ , SUBTYPE_OPCLASS = <replaceable class="parameter">subtype_operator_class</replaceable> ]
    [ , COLLATION = <replaceable class="parameter">collation</replaceable> ]
    [ , CANONICAL = <replaceable class="parameter">canonical_function</replaceable> ]
    [ , SUBTYPE_DIFF = <replaceable class="parameter">subtype_diff_function</replaceable> ]
    [ , MULTIRANGE_TYPE_NAME = <replaceable class="parameter">multirange_type_name</replaceable> ]
)

CREATE TYPE <replaceable class="parameter">name</replaceable> (
    INPUT = <replaceable class="parameter">input_function</replaceable>,
    OUTPUT = <replaceable class="parameter">output_function</replaceable>
    [ , RECEIVE = <replaceable class="parameter">receive_function</replaceable> ]
    [ , SEND = <replaceable class="parameter">send_function</replaceable> ]
    [ , TYPMOD_IN = <replaceable class="parameter">type_modifier_input_function</replaceable> ]
    [ , TYPMOD_OUT = <replaceable class="parameter">type_modifier_output_function</replaceable> ]
    [ , ANALYZE = <replaceable class="parameter">analyze_function</replaceable> ]
    [ , SUBSCRIPT = <replaceable class="parameter">subscript_function</replaceable> ]
    [ , INTERNALLENGTH = { <replaceable class="parameter">internallength</replaceable> | VARIABLE } ]
    [ , PASSEDBYVALUE ]
    [ , ALIGNMENT = <replaceable class="parameter">alignment</replaceable> ]
    [ , STORAGE = <replaceable class="parameter">storage</replaceable> ]
    [ , LIKE = <replaceable class="parameter">like_type</replaceable> ]
    [ , CATEGORY = <replaceable class="parameter">category</replaceable> ]
    [ , PREFERRED = <replaceable class="parameter">preferred</replaceable> ]
    [ , DEFAULT = <replaceable class="parameter">default</replaceable> ]
    [ , ELEMENT = <replaceable class="parameter">element</replaceable> ]
    [ , DELIMITER = <replaceable class="parameter">delimiter</replaceable> ]
    [ , COLLATABLE = <replaceable class="parameter">collatable</replaceable> ]
)

CREATE TYPE <replaceable class="parameter">name</replaceable>
</synopsis>
____________________________________________________________________________-->
<synopsis>
CREATE TYPE <replaceable class="parameter">name</replaceable> AS
    ( [ <replaceable class="parameter">attribute_name</replaceable> <replaceable class="parameter">data_type</replaceable> [ COLLATE <replaceable>collation</replaceable> ] [, ... ] ] )

CREATE TYPE <replaceable class="parameter">name</replaceable> AS ENUM
    ( [ '<replaceable class="parameter">label</replaceable>' [, ... ] ] )

CREATE TYPE <replaceable class="parameter">name</replaceable> AS RANGE (
    SUBTYPE = <replaceable class="parameter">subtype</replaceable>
    [ , SUBTYPE_OPCLASS = <replaceable class="parameter">subtype_operator_class</replaceable> ]
    [ , COLLATION = <replaceable class="parameter">collation</replaceable> ]
    [ , CANONICAL = <replaceable class="parameter">canonical_function</replaceable> ]
    [ , SUBTYPE_DIFF = <replaceable class="parameter">subtype_diff_function</replaceable> ]
    [ , MULTIRANGE_TYPE_NAME = <replaceable class="parameter">multirange_type_name</replaceable> ]
)

CREATE TYPE <replaceable class="parameter">name</replaceable> (
    INPUT = <replaceable class="parameter">input_function</replaceable>,
    OUTPUT = <replaceable class="parameter">output_function</replaceable>
    [ , RECEIVE = <replaceable class="parameter">receive_function</replaceable> ]
    [ , SEND = <replaceable class="parameter">send_function</replaceable> ]
    [ , TYPMOD_IN = <replaceable class="parameter">type_modifier_input_function</replaceable> ]
    [ , TYPMOD_OUT = <replaceable class="parameter">type_modifier_output_function</replaceable> ]
    [ , ANALYZE = <replaceable class="parameter">analyze_function</replaceable> ]
    [ , SUBSCRIPT = <replaceable class="parameter">subscript_function</replaceable> ]
    [ , INTERNALLENGTH = { <replaceable class="parameter">internallength</replaceable> | VARIABLE } ]
    [ , PASSEDBYVALUE ]
    [ , ALIGNMENT = <replaceable class="parameter">alignment</replaceable> ]
    [ , STORAGE = <replaceable class="parameter">storage</replaceable> ]
    [ , LIKE = <replaceable class="parameter">like_type</replaceable> ]
    [ , CATEGORY = <replaceable class="parameter">category</replaceable> ]
    [ , PREFERRED = <replaceable class="parameter">preferred</replaceable> ]
    [ , DEFAULT = <replaceable class="parameter">default</replaceable> ]
    [ , ELEMENT = <replaceable class="parameter">element</replaceable> ]
    [ , DELIMITER = <replaceable class="parameter">delimiter</replaceable> ]
    [ , COLLATABLE = <replaceable class="parameter">collatable</replaceable> ]
)

CREATE TYPE <replaceable class="parameter">name</replaceable>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <command>CREATE TYPE</command> registers a new data type for use in
   the current database.  The user who defines a type becomes its
   owner.
  </para>
____________________________________________________________________________-->
  <para>
   <command>CREATE TYPE</command>在当前数据库中注册一种新的
   数据类型。定义数据类型的用户将成为它的拥有者。
  </para>

<!--==========================orignal english content==========================
  <para>
   If a schema name is given then the type is created in the specified
   schema.  Otherwise it is created in the current schema.  The type
   name must be distinct from the name of any existing type or domain
   in the same schema.  (Because tables have associated data types,
   the type name must also be distinct from the name of any existing
   table in the same schema.)
  </para>
____________________________________________________________________________-->
  <para>
   如果给定一个模式名，那么该类型将被创建在指定的模式中。否则它会被
   创建在当前模式中。类型名称必须与同一个模式中任何现有的类型或者域
   相区别（因为表具有相关的数据类型，类型名称也必须与同一个模式中任
   何现有表的名字不同）。
  </para>

<!--==========================orignal english content==========================
  <para>
   There are five forms of <command>CREATE TYPE</command>, as shown in the
   syntax synopsis above.  They respectively create a <firstterm>composite
   type</firstterm>, an <firstterm>enum type</firstterm>, a <firstterm>range type</firstterm>, a
   <firstterm>base type</firstterm>, or a <firstterm>shell type</firstterm>.  The first four
   of these are discussed in turn below.  A shell type is simply a placeholder
   for a type to be defined later; it is created by issuing <command>CREATE
   TYPE</command> with no parameters except for the type name.  Shell types
   are needed as forward references when creating range types and base types,
   as discussed in those sections.
  </para>
____________________________________________________________________________-->
  <para>
   如上面的语法所示，有五种形式的<command>CREATE TYPE</command>。
   它们分别创建<firstterm>组合类型</firstterm>、<firstterm>枚举类型</firstterm>、
   <firstterm>范围类型</firstterm>、<firstterm>基础类型</firstterm>或者
   <firstterm>shell 类型</firstterm>。下文将依次讨论前四种形式。shell 类型仅仅
   是一种用于后面要定义的类型的占位符，通过发出一个不带除类型名之外其
   他参数的<command>CREATE TYPE</command>命令可以创建这种类型。
   在创建范围类型和基础类型时，需要 shell 类型作为一种向前引用。
  </para>

  <refsect2>
<!--==========================orignal english content==========================
   <title>Composite Types</title>
____________________________________________________________________________-->
   <title>组合类型</title>

<!--==========================orignal english content==========================
  <para>
   The first form of <command>CREATE TYPE</command>
   creates a composite type.
   The composite type is specified by a list of attribute names and data types.
   An attribute's collation can be specified too, if its data type is
   collatable.  A composite type is essentially the same as the row type
   of a table, but using <command>CREATE TYPE</command> avoids the need to
   create an actual table when all that is wanted is to define a type.
   A stand-alone composite type is useful, for example, as the argument or
   return type of a function.
  </para>
____________________________________________________________________________-->
  <para>
   第一种形式的<command>CREATE TYPE</command>创建组合类型。
   组合类型由一个属性名和数据类型的列表指定。如果属性的数据类型是可
   排序的，也可以指定该属性的排序规则。组合类型本质上和表的行类型相
   同，但是如果只想定义一种类型，使用
   <command>CREATE TYPE</command>避免了创建一个实际的表。单
   独的组合类型也是很有用的，例如可以作为函数的参数或者返回类型。
  </para>

<!--==========================orignal english content==========================
  <para>
   To be able to create a composite type, you must
   have <literal>USAGE</literal> privilege on all attribute types.
  </para>
____________________________________________________________________________-->
  <para>
   为了能够创建组合类型，必须拥有在其所有属性类型上的
   <literal>USAGE</literal>特权。
  </para>
  </refsect2>

  <refsect2 id="sql-createtype-enum">
<!--==========================orignal english content==========================
   <title>Enumerated Types</title>
____________________________________________________________________________-->
   <title>枚举类型</title>

<!--==========================orignal english content==========================
   <para>
    The second form of <command>CREATE TYPE</command> creates an enumerated
    (enum) type, as described in <xref linkend="datatype-enum"/>.
    Enum types take a list of quoted labels, each of which
    must be less than <symbol>NAMEDATALEN</symbol> bytes long (64 bytes in a
    standard <productname>PostgreSQL</productname> build).  (It is possible to
    create an enumerated type with zero labels, but such a type cannot be used
    to hold values before at least one label is added using <link
    linkend="sql-altertype"><command>ALTER TYPE</command></link>.)
   </para>
____________________________________________________________________________-->
   <para>
    如<xref linkend="datatype-enum"/>中所述，第二种形式的<command>CREATE TYPE</command>创建枚举类型。
    枚举类型需要一个带引号的标签构成的列表，每一个标签长度必须不超过<symbol>NAMEDATALEN</symbol>字节（在标准的<productname>PostgreSQL</productname>编译中是 64 字节）。
    可以创建具有零个标签的枚举类型，但是在使用<link linkend="sql-altertype"><command>ALTER TYPE</command></link>添加至少一个标签之前，不能使用这种类型来保存值。
   </para>
  </refsect2>

  <refsect2 id="sql-createtype-range">
<!--==========================orignal english content==========================
   <title>Range Types</title>
____________________________________________________________________________-->
   <title>范围类型</title>

<!--==========================orignal english content==========================
   <para>
    The third form of <command>CREATE TYPE</command> creates a new
    range type, as described in <xref linkend="rangetypes"/>.
   </para>
____________________________________________________________________________-->
   <para>
    如<xref linkend="rangetypes"/>中所述，第三种形式的
    <command>CREATE TYPE</command>创建范围类型。
   </para>

<!--==========================orignal english content==========================
   <para>
    The range type's <replaceable class="parameter">subtype</replaceable> can
    be any type with an associated b-tree operator class (to determine the
    ordering of values for the range type).  Normally the subtype's default
    b-tree operator class is used to determine ordering; to use a non-default
    operator class, specify its name with <replaceable
    class="parameter">subtype_opclass</replaceable>.  If the subtype is
    collatable, and you want to use a non-default collation in the range's
    ordering, specify the desired collation with the <replaceable
    class="parameter">collation</replaceable> option.
   </para>
____________________________________________________________________________-->
   <para>
    范围类型的<replaceable class="parameter">subtype</replaceable>可以
    是任何带有一个相关的 B 树操作符类（用来决定该范围类型值的顺序）的类型。
    通常，子类型的默认 B 树操作符类被用来决定顺序。要使用一种非默认操作符
    类，可以用
    <replaceable class="parameter">subtype_opclass</replaceable>指定它
    的名字。如果子类型是可排序的并且希望在该范围的顺序中使用一种非默认的
    排序规则，可以用<replaceable
    class="parameter">collation</replaceable>选项来指定。
   </para>

<!--==========================orignal english content==========================
   <para>
    The optional <replaceable class="parameter">canonical</replaceable>
    function must take one argument of the range type being defined, and
    return a value of the same type.  This is used to convert range values
    to a canonical form, when applicable.  See <xref
    linkend="rangetypes-defining"/> for more information.  Creating a
    <replaceable class="parameter">canonical</replaceable> function
    is a bit tricky, since it must be defined before the range type can be
    declared.  To do this, you must first create a shell type, which is a
    placeholder type that has no properties except a name and an
    owner.  This is done by issuing the command <literal>CREATE TYPE
    <replaceable>name</replaceable></literal>, with no additional parameters.  Then
    the function can be declared using the shell type as argument and result,
    and finally the range type can be declared using the same name.  This
    automatically replaces the shell type entry with a valid range type.
   </para>
____________________________________________________________________________-->
   <para>
    可选的<replaceable class="parameter">canonical</replaceable>函数
    必须接受一个所定义的范围类型的参数，并且返回同样类型的一个值。在适
    用时，它被用来把范围值转换成一种规范的形式。更多信息请见<xref
    linkend="rangetypes-defining"/>。创建一个
    <replaceable class="parameter">canonical</replaceable>函数有点棘
    手，因为必须在声明范围类型之前定义它。要这样做，必须首先创建一种
    shell 类型，它是一种没有属性只有名称和拥有者的占位符类型。这可以通过
    发出不带额外参数的命令<literal>CREATE TYPE
    <replaceable>name</replaceable></literal>来完成。然后可以使用该 shell 类型作为
    参数和结果来声明该函数，并且最终用同样的名称来声明范围类型。这会自动
    用一种合法的范围类型替换 shell 类型项。
   </para>

<!--==========================orignal english content==========================
   <para>
    The optional <replaceable class="parameter">subtype_diff</replaceable>
    function must take two values of the
    <replaceable class="parameter">subtype</replaceable> type as argument,
    and return a <type>double precision</type> value representing the
    difference between the two given values.  While this is optional,
    providing it allows much greater efficiency of GiST indexes on columns of
    the range type.  See <xref linkend="rangetypes-defining"/> for more
    information.
   </para>
____________________________________________________________________________-->
   <para>
    可选的<replaceable class="parameter">subtype_diff</replaceable>函数
    必须接受两个<replaceable class="parameter">subtype</replaceable>类型
    的值作为参数，并且返回一个<type>double precision</type>值表示两个给定
    值之间的差别。虽然这是可选的，但是提供这个函数会让该范围类型列上 GiST 索
    引效率更高。详见<xref linkend="rangetypes-defining"/>。
   </para>

<!--==========================orignal english content==========================
   <para>
    The optional <replaceable class="parameter">multirange_type_name</replaceable>
    parameter specifies the name of the corresponding multirange type.  If not
    specified, this name is chosen automatically as follows.
    If the range type name contains the substring <literal>range</literal>, then
    the multirange type name is formed by replacement of the <literal>range</literal>
    substring with <literal>multirange</literal> in the range
    type name.  Otherwise, the multirange type name is formed by appending a
    <literal>_multirange</literal> suffix to the range type name.
   </para>
____________________________________________________________________________-->
   <para>
    可选的<replaceable class="parameter">multirange_type_name</replaceable>参数指定相应的多范围类型的名称。
    如未指定，这个名称如下面那样自动选择。
    如果范围类型名称包含子字符串<literal>range</literal>，则通过将范围类型名称中的<literal>range</literal>子字符串替换为<literal>multirange</literal> ，构成多范围类型名称。
    否则，通过在范围类型名称后附加<literal>_multirange</literal>后缀来构成多范围类型名称。
   </para>
  </refsect2>

  <refsect2>
<!--==========================orignal english content==========================
   <title>Base Types</title>
____________________________________________________________________________-->
   <title>基础类型</title>

<!--==========================orignal english content==========================
  <para>
   The fourth form of <command>CREATE TYPE</command> creates a new base type
   (scalar type).  To create a new base type, you must be a superuser.
   (This restriction is made because an erroneous type definition could
   confuse or even crash the server.)
  </para>
____________________________________________________________________________-->
  <para>
   第四种形式的<command>CREATE TYPE</command>创建一种新的
   基本类型（标量类型）。为了创建一种新的基本类型，你必须是一个超级
   用户（做这种限制的原因是一种错误的类型定义可能让服务器混淆甚至
   崩溃）。
  </para>

<!--==========================orignal english content==========================
  <para>
   The parameters can appear in any order, not only that
   illustrated above, and most are optional.  You must register
   two or more functions (using <command>CREATE FUNCTION</command>) before
   defining the type.  The support functions
   <replaceable class="parameter">input_function</replaceable> and
   <replaceable class="parameter">output_function</replaceable>
   are required, while the functions
   <replaceable class="parameter">receive_function</replaceable>,
   <replaceable class="parameter">send_function</replaceable>,
   <replaceable class="parameter">type_modifier_input_function</replaceable>,
   <replaceable class="parameter">type_modifier_output_function</replaceable>,
   <replaceable class="parameter">analyze_function</replaceable>, and
   <replaceable class="parameter">subscript_function</replaceable>
   are optional.  Generally these functions have to be coded in C
   or another low-level language.
  </para>
____________________________________________________________________________-->
  <para>
   参数可以以任意顺序出现（而不仅是按照上面所示的顺序），并且大部分
   是可选的。在定义类型前，必须注册两个或者更多函数（使用
   <command>CREATE FUNCTION</command>）。支持函数
   <replaceable class="parameter">input_function</replaceable>以及
   <replaceable class="parameter">output_function</replaceable>
   是必需的，而函数
   <replaceable class="parameter">receive_function</replaceable>、
   <replaceable class="parameter">send_function</replaceable>、
   <replaceable class="parameter">type_modifier_input_function</replaceable>、
   <replaceable class="parameter">type_modifier_output_function</replaceable>和
   <replaceable class="parameter">type_modifier_output_function</replaceable>,
   <replaceable class="parameter">analyze_function</replaceable>, and
   <replaceable class="parameter">subscript_function</replaceable>
   是可选的。通常来说这些函数必须是用 C 或者另外一种低层语言编写的。
  </para>

<!--==========================orignal english content==========================
  <para>
   The <replaceable class="parameter">input_function</replaceable>
   converts the type's external textual representation to the internal
   representation used by the operators and functions defined for the type.
   <replaceable class="parameter">output_function</replaceable>
   performs the reverse transformation.  The input function can be
   declared as taking one argument of type <type>cstring</type>,
   or as taking three arguments of types
   <type>cstring</type>, <type>oid</type>, <type>integer</type>.
   The first argument is the input text as a C string, the second
   argument is the type's own OID (except for array types, which instead
   receive their element type's OID),
   and the third is the <literal>typmod</literal> of the destination column, if known
   (-1 will be passed if not).
   The input function must return a value of the data type itself.
   Usually, an input function should be declared STRICT; if it is not,
   it will be called with a NULL first parameter when reading a NULL
   input value.  The function must still return NULL in this case, unless
   it raises an error.
   (This case is mainly meant to support domain input functions, which
   might need to reject NULL inputs.)
   The output function must be
   declared as taking one argument of the new data type.
   The output function must return type <type>cstring</type>.
   Output functions are not invoked for NULL values.
  </para>
____________________________________________________________________________-->
  <para>
   <replaceable class="parameter">input_function</replaceable>将
   类型的外部文本表达转换成为该类型定义的操作符和函数所使用的内部
   表达。
   <replaceable class="parameter">output_function</replaceable>
   执行反向的转换。输入函数可以被声明为有一个<type>cstring</type>
   类型的参数，或者有三个类型分别为<type>cstring</type>、
   <type>oid</type>、<type>integer</type>的参数。第一个参数是
   以 C 字符串存在的输入文本，第二个参数是该类型自身的 OID（对于
   数组类型则是其元素类型的 OID），第三个参数是目标列的
   <literal>typmod</literal>（如果知道，不知道则将传递 -1）。输入函数必须
   返回一个该数据类型本身的值。通常，一个输入函数应该被声明为 STRICT。
   如果不是这样，在读到一个 NULL 输入值时，调用它时第一个参数会是
   NULL。在这种情况下，该函数必须仍然返回 NULL，除非它发生了错误（
   这种情况主要是想支持域输入函数，它们可能需要拒绝 NULL 输入）。
   输出函数必须被声明为有一个新数据类型的参数。输出函数必须返回类型
   <type>cstring</type>。对于 NULL 值不会调用输出函数。
  </para>

<!--==========================orignal english content==========================
  <para>
   The optional <replaceable class="parameter">receive_function</replaceable>
   converts the type's external binary representation to the internal
   representation.  If this function is not supplied, the type cannot
   participate in binary input.  The binary representation should be
   chosen to be cheap to convert to internal form, while being reasonably
   portable.  (For example, the standard integer data types use network
   byte order as the external binary representation, while the internal
   representation is in the machine's native byte order.)  The receive
   function should perform adequate checking to ensure that the value is
   valid.
   The receive function can be declared as taking one argument of type
   <type>internal</type>, or as taking three arguments of types
   <type>internal</type>, <type>oid</type>, <type>integer</type>.
   The first argument is a pointer to a <type>StringInfo</type> buffer
   holding the received byte string; the optional arguments are the
   same as for the text input function.
   The receive function must return a value of the data type itself.
   Usually, a receive function should be declared STRICT; if it is not,
   it will be called with a NULL first parameter when reading a NULL
   input value.  The function must still return NULL in this case, unless
   it raises an error.
   (This case is mainly meant to support domain receive functions, which
   might need to reject NULL inputs.)
   Similarly, the optional
   <replaceable class="parameter">send_function</replaceable> converts
   from the internal representation to the external binary representation.
   If this function is not supplied, the type cannot participate in binary
   output.  The send function must be
   declared as taking one argument of the new data type.
   The send function must return type <type>bytea</type>.
   Send functions are not invoked for NULL values.
  </para>
____________________________________________________________________________-->
  <para>
   T可选的<replaceable class="parameter">receive_function</replaceable>
   会把类型的外部二进制表达转换成内部表达。如果没有提供这个函数，
   该类型不能参与到二进制输入中。二进制表达转换成内部形式代价更低，
   然而却更容易移植（例如，标准的整数数据类型使用网络字节序作为外
   部二进制表达，而内部表达是机器本地的字节序）。接收函数应该执行
   足够的检查以确保该值是有效的。接收函数可以被声明为有一个
   <type>internal</type>类型的参数，或者有三个类型分别为
   <type>internal</type>、<type>oid</type>、<type>integer</type>
   的参数。第一个参数是一个指向<type>StringInfo</type>缓冲区的
   指针，其中保存着接收到的字节串。其余可选的参数和文本输入函数的
   相同。接收函数必须返回一个该数据类型本身的值。通常，一个接收函
   数应该被声明为 STRICT。如果不是这样，在读到一个 NULL 输入值时，
   调用它时第一个参数会是 NULL。在这种情况下，该函数必须仍然返回 
   NULL，除非它发生了错误（这种情况主要是想支持域接收函数，它们
   可能需要拒绝 NULL 输入）。类似地，可选的
   <replaceable class="parameter">send_function</replaceable>将
   内部表达转换成外部二进制表达。如果没有提供这个函数，该类型将不
   能参与到二进制输出中。发送函数必须被声明为有一个新数据类型的参
   数。发送函数必须返回类型<type>bytea</type>。对于 NULL 值不
   会调用发送函数。
  </para>

<!--==========================orignal english content==========================
  <para>
   You should at this point be wondering how the input and output functions
   can be declared to have results or arguments of the new type, when they
   have to be created before the new type can be created.  The answer is that
   the type should first be defined as a <firstterm>shell type</firstterm>, which is a
   placeholder type that has no properties except a name and an owner.  This
   is done by issuing the command <literal>CREATE TYPE
   <replaceable>name</replaceable></literal>, with no additional parameters.  Then the
   C I/O functions can be defined referencing the shell type.  Finally,
   <command>CREATE TYPE</command> with a full definition replaces the shell entry
   with a complete, valid type definition, after which the new type can be
   used normally.
  </para>
____________________________________________________________________________-->
  <para>
   到这里你应该在疑惑输入和输出函数是如何能被声明为具有新类型的
   结果或参数的？因为必须在创建新类型之前创建这两个函数。这个问题
   的答案是，新类型应该首先被定义为一种<firstterm>shell type</firstterm>，
   它是一种占位符类型，除了名称和拥有者之外它没有其他属性。这可以
   通过不带额外参数的命令<literal>CREATE TYPE
   <replaceable>name</replaceable></literal>做到。然后用 C 写的 I/O 函数可以
   被定义为引用这种 shell type。最后，用带有完整定义的
   <command>CREATE TYPE</command>把该 shell type 替换为一个完全的、合
   法的类型定义，之后新类型就可以正常使用了。
  </para>

<!--==========================orignal english content==========================
  <para>
   The optional
   <replaceable class="parameter">type_modifier_input_function</replaceable>
   and <replaceable class="parameter">type_modifier_output_function</replaceable>
   are needed if the type supports modifiers, that is optional constraints
   attached to a type declaration, such as <literal>char(5)</literal> or
   <literal>numeric(30,2)</literal>.  <productname>PostgreSQL</productname> allows
   user-defined types to take one or more simple constants or identifiers as
   modifiers.  However, this information must be capable of being packed into a
   single non-negative integer value for storage in the system catalogs.  The
   <replaceable class="parameter">type_modifier_input_function</replaceable>
   is passed the declared modifier(s) in the form of a <type>cstring</type>
   array.  It must check the values for validity (throwing an error if they
   are wrong), and if they are correct, return a single non-negative
   <type>integer</type> value that will be stored as the column <quote>typmod</quote>.
   Type modifiers will be rejected if the type does not have a
   <replaceable class="parameter">type_modifier_input_function</replaceable>.
   The <replaceable class="parameter">type_modifier_output_function</replaceable>
   converts the internal integer typmod value back to the correct form for
   user display.  It must return a <type>cstring</type> value that is the exact
   string to append to the type name; for example <type>numeric</type>'s
   function might return <literal>(30,2)</literal>.
   It is allowed to omit the
   <replaceable class="parameter">type_modifier_output_function</replaceable>,
   in which case the default display format is just the stored typmod integer
   value enclosed in parentheses.
  </para>
____________________________________________________________________________-->
  <para>
   如果该类型支持修饰符（附加在类型声明上的可选约束，例如
   <literal>char(5)</literal>或者<literal>numeric(30,2)</literal>），则需要可选的
   <replaceable class="parameter">type_modifier_input_function</replaceable>
   以及<replaceable class="parameter">type_modifier_output_function</replaceable>。
   <productname>PostgreSQL</productname>允许用户定义的类型有一个或者
   多个简单常量或者标识符作为修饰符。不过，为了存储在系统目录中，该信息必须
   能被打包到一个非负整数值中。所声明的修饰符会被以<type>cstring</type>数组的形式
   传递给
   <replaceable class="parameter">type_modifier_input_function</replaceable>。
   它必须检查该值的合法性（如果值错误就抛出一个错误），如果值正确，要返回
   一个非负<type>integer</type>值，它将被存储在<quote>typmod</quote>列中。如果
   类型没有
   <replaceable class="parameter">type_modifier_input_function</replaceable>
   则类型修饰符将被拒绝。
   <replaceable class="parameter">type_modifier_output_function</replaceable>
   把内部的整数 typmod 值转换回正确的形式用于用户显示。它必须返回一个
   <type>cstring</type>值，该值就是追加到类型名称后的字符串。例如
   <type>numeric</type>的函数可能会返回<literal>(30,2)</literal>。如果默认的显示格式
   就是只把存储的 typmod 整数值放在圆括号内，则允许省略
   <replaceable class="parameter">type_modifier_output_function</replaceable>。
  </para>

<!--==========================orignal english content==========================
  <para>
   The optional <replaceable class="parameter">analyze_function</replaceable>
   performs type-specific statistics collection for columns of the data type.
   By default, <command>ANALYZE</command> will attempt to gather statistics using
   the type's <quote>equals</quote> and <quote>less-than</quote> operators, if there
   is a default b-tree operator class for the type.  For non-scalar types
   this behavior is likely to be unsuitable, so it can be overridden by
   specifying a custom analysis function.  The analysis function must be
   declared to take a single argument of type <type>internal</type>, and return
   a <type>boolean</type> result.  The detailed API for analysis functions appears
   in <filename>src/include/commands/vacuum.h</filename>.
  </para>
____________________________________________________________________________-->
  <para>
   可选的<replaceable class="parameter">analyze_function</replaceable>
   为该数据类型的列执行与类型相关的统计信息收集。默认情况下，如果
   该类型有一个默认的 B-树操作符类，<command>ANALYZE</command>将尝试用
   类型的<quote>equals</quote>和<quote>less-than</quote>操作符来收集统计信息。
   这种行为对于非标量类型并不合适，因此可以通过指定一个自定义分析函数来
   覆盖这种行为。分析函数必须被声明为有一个类型为<type>internal</type>的参
   数，并且返回一个<type>boolean</type>结果。分析函数的详细 API 请见
   <filename>src/include/commands/vacuum.h</filename>。
  </para>

<!--==========================orignal english content==========================
  <para>
   The optional <replaceable class="parameter">subscript_function</replaceable>
   allows the data type to be subscripted in SQL commands.  Specifying this
   function does not cause the type to be considered a <quote>true</quote>
   array type; for example, it will not be a candidate for the result type
   of <literal>ARRAY[]</literal> constructs.  But if subscripting a value
   of the type is a natural notation for extracting data from it, then
   a <replaceable class="parameter">subscript_function</replaceable> can
   be written to define what that means.  The subscript function must be
   declared to take a single argument of type <type>internal</type>, and
   return an <type>internal</type> result, which is a pointer to a struct
   of methods (functions) that implement subscripting.
   The detailed API for subscript functions appears
   in <filename>src/include/nodes/subscripting.h</filename>.
   It may also be useful to read the array implementation
   in <filename>src/backend/utils/adt/arraysubs.c</filename>,
   or the simpler code
   in <filename>contrib/hstore/hstore_subs.c</filename>.
   Additional information appears in
   <xref linkend="sql-createtype-array"/> below.
  </para>
____________________________________________________________________________-->
  <para>
   可选的<replaceable class="parameter">subscript_function</replaceable>允许在SQL命令中对数据类型进行下标。
   指定此函数不会导致该类型被认为是<quote>true</quote>数组类型;例如，它不会是<literal>ARRAY[]</literal>结构的结果类型的候选者。
   但是，如果对该类型的值下标是从中提取的数据的自然符号，那么可以编写<replaceable class="parameter">subscript_function</replaceable>来定义它的含义。
   下标函数必须被声明为接受单个类型<type>internal</type>的参数，
   并返回一个<type>internal</type>结果，它是一个实现下标的方法(函数)结构的指针。
   下标函数的详细API体现在<filename>src/include/nodes/subscripting.h</filename>中。
   阅读<filename>contrib/hstore/hstore_subs.c</filename>中的数组实现可能也很比较用，或者<filename>contrib/hstore/hstore_subs.c</filename>中简单代码。
   更多信息见下面的<xref linkend="sql-createtype-array"/>。
  </para>

<!--==========================orignal english content==========================
  <para>
   While the details of the new type's internal representation are only
   known to the I/O functions and other functions you create to work with
   the type, there are several properties of the internal representation
   that must be declared to <productname>PostgreSQL</productname>.
   Foremost of these is
   <replaceable class="parameter">internallength</replaceable>.
   Base data types can be fixed-length, in which case
   <replaceable class="parameter">internallength</replaceable> is a
   positive integer, or variable-length, indicated by setting
   <replaceable class="parameter">internallength</replaceable>
   to <literal>VARIABLE</literal>.  (Internally, this is represented
   by setting <literal>typlen</literal> to -1.)  The internal representation of all
   variable-length types must start with a 4-byte integer giving the total
   length of this value of the type.  (Note that the length field is often
   encoded, as described in <xref linkend="storage-toast"/>; it's unwise
   to access it directly.)
  </para>
____________________________________________________________________________-->
  <para>
   虽然只有 I/O 函数和其他为该类型创建的函数才知道新类型的内部表达的细节，
   但是内部表达的一些属性必须被向
   <productname>PostgreSQL</productname>声明。其中最重要的是
   <replaceable class="parameter">internallength</replaceable>。基本数据
   类型可以是定长的（这种情况下
   <replaceable class="parameter">internallength</replaceable>是一个正
   整数）或者是变长的（把
   <replaceable class="parameter">internallength</replaceable>设置为
   <literal>VARIABLE</literal>，在内部通过把<literal>typlen</literal>设置为 -1 表示）。
   所有变长类型的内部表达都必须以一个 4 字节整数开始，它给出了这个值的总
   长度（注意如<xref linkend="storage-toast"/>中所述，长度域常常是被编码
   过的，直接接受它是不明智的）。
  </para>

<!--==========================orignal english content==========================
  <para>
   The optional flag <literal>PASSEDBYVALUE</literal> indicates that
   values of this data type are passed by value, rather than by
   reference.  Types passed by value must be fixed-length, and their internal
   representation cannot be larger than the size of the <type>Datum</type> type
   (4 bytes on some machines, 8 bytes on others).
  </para>
____________________________________________________________________________-->
  <para>
   可选的标志<literal>PASSEDBYVALUE</literal>表示这种数据类型的值需要
   被传值而不是传引用。传值的类型必须是定长的，并且它们的内部表达不能超
   过<type>Datum</type>类型（某些机器上是 4 字节，其他机器上是 8 字节）的
   尺寸。
  </para>

<!--==========================orignal english content==========================
  <para>
   The <replaceable class="parameter">alignment</replaceable> parameter
   specifies the storage alignment required for the data type.  The
   allowed values equate to alignment on 1, 2, 4, or 8 byte boundaries.
   Note that variable-length types must have an alignment of at least
   4, since they necessarily contain an <type>int4</type> as their first component.
  </para>
____________________________________________________________________________-->
  <para>
   <replaceable class="parameter">alignment</replaceable>参数指定数据
   类型的存储对齐要求。允许的值等同于以 1、2、4 或 8 字节边界对齐。注意
   变长类型的 alignment 参数必须至少为 4，因为它们需要包含一个
   <type>int4</type>作为它们的第一个组成部分。
  </para>

<!--==========================orignal english content==========================
  <para>
   The <replaceable class="parameter">storage</replaceable> parameter
   allows selection of storage strategies for variable-length data
   types.  (Only <literal>plain</literal> is allowed for fixed-length
   types.)  <literal>plain</literal> specifies that data of the type
   will always be stored in-line and not compressed.
   <literal>extended</literal> specifies that the system will first
   try to compress a long data value, and will move the value out of
   the main table row if it's still too long.
   <literal>external</literal> allows the value to be moved out of the
   main table, but the system will not try to compress it.
   <literal>main</literal> allows compression, but discourages moving
   the value out of the main table.  (Data items with this storage
   strategy might still be moved out of the main table if there is no
   other way to make a row fit, but they will be kept in the main
   table preferentially over <literal>extended</literal> and
   <literal>external</literal> items.)
  </para>
____________________________________________________________________________-->
  <para>
   <replaceable class="parameter">storage</replaceable>参数允许
   为变长数据类型选择存储策略（对定长类型只允许
   <literal>plain</literal>）。<literal>plain</literal>指定该类型的数
   据将总是被存储在线内并且不会被压缩。<literal>extended</literal>
   指定系统将首先尝试压缩一个长的数据值，并且将在数据仍然太长的情
   况下把值移出主表行。<literal>external</literal>允许值被移出主表，
   但是系统将不会尝试对它进行压缩。<literal>main</literal>允许压缩，
   但是不鼓励把值移出主表（如果没有其他办法让行的大小变得合适，具有
   这种存储策略的数据项仍将被移出主表，但比起
   <literal>extended</literal>以及<literal>external</literal>项来，
   这种存储策略的数据项会被优先考虑保留在主表中）。
  </para>

<!--==========================orignal english content==========================
  <para>
   All <replaceable class="parameter">storage</replaceable> values other
   than <literal>plain</literal> imply that the functions of the data type
   can handle values that have been <firstterm>toasted</firstterm>, as described
   in <xref linkend="storage-toast"/> and <xref linkend="xtypes-toast"/>.
   The specific other value given merely determines the default TOAST
   storage strategy for columns of a toastable data type; users can pick
   other strategies for individual columns using <literal>ALTER TABLE
   SET STORAGE</literal>.
  </para>
____________________________________________________________________________-->
  <para>
   如<xref linkend="storage-toast"/>和<xref linkend="xtypes-toast"/>
   所述，除<literal>plain</literal>之外所有的
   <replaceable class="parameter">storage</replaceable>值都暗示
   该数据类型的函数能处理被<firstterm>TOAST 过</firstterm>的值。指定的值
   仅仅是决定一种可 TOAST 数据类型的列的默认 TOAST 存储策略，用户
   可以使用<literal>ALTER TABLE SET STORAGE</literal>为列选取其他策略。
  </para>

<!--==========================orignal english content==========================
  <para>
   The <replaceable class="parameter">like_type</replaceable> parameter
   provides an alternative method for specifying the basic representation
   properties of a data type: copy them from some existing type. The values of
   <replaceable class="parameter">internallength</replaceable>,
   <replaceable class="parameter">passedbyvalue</replaceable>,
   <replaceable class="parameter">alignment</replaceable>, and
   <replaceable class="parameter">storage</replaceable> are copied from the
   named type.  (It is possible, though usually undesirable, to override
   some of these values by specifying them along with the <literal>LIKE</literal>
   clause.)  Specifying representation this way is especially useful when
   the low-level implementation of the new type <quote>piggybacks</quote> on an
   existing type in some fashion.
  </para>
____________________________________________________________________________-->
  <para>
   <replaceable class="parameter">like_type</replaceable>参数提供
   了另一种方法来指定一种数据类型的基本表达属性：从某种现有的类型中
   拷贝。<replaceable class="parameter">internallength</replaceable>、
   <replaceable class="parameter">passedbyvalue</replaceable>、
   <replaceable class="parameter">alignment</replaceable>和
   <replaceable class="parameter">storage</replaceable>的值会从指
   定的类型中复制而来（也可以通过在<literal>LIKE</literal>子句中指定这些属
   性的值来覆盖复制过来的值，不过通常并不这么做）。当新类型的低层
   实现是以一种现有的类型为<quote>载体</quote>时，用这种方式指定表达特别有用。
  </para>

<!--==========================orignal english content==========================
  <para>
   The <replaceable class="parameter">category</replaceable> and
   <replaceable class="parameter">preferred</replaceable> parameters can be
   used to help control which implicit cast will be applied in ambiguous
   situations.  Each data type belongs to a category named by a single ASCII
   character, and each type is either <quote>preferred</quote> or not within its
   category.  The parser will prefer casting to preferred types (but only from
   other types within the same category) when this rule is helpful in
   resolving overloaded functions or operators.  For more details see <xref
   linkend="typeconv"/>.  For types that have no implicit casts to or from any
   other types, it is sufficient to leave these settings at the defaults.
   However, for a group of related types that have implicit casts, it is often
   helpful to mark them all as belonging to a category and select one or two
   of the <quote>most general</quote> types as being preferred within the category.
   The <replaceable class="parameter">category</replaceable> parameter is
   especially useful when adding a user-defined type to an existing built-in
   category, such as the numeric or string types.  However, it is also
   possible to create new entirely-user-defined type categories.  Select any
   ASCII character other than an upper-case letter to name such a category.
  </para>
____________________________________________________________________________-->
  <para>
   <replaceable class="parameter">category</replaceable>和
   <replaceable class="parameter">preferred</replaceable>参数可以被用来
   帮助控制在混淆的情况下应用哪一种隐式造型。每一种数据类型都属于一个用
   单个 ASCII 字符命名的分类，并且每一种类型可以是其所属分类中的
   <quote>首选</quote>。当有助于解决重载函数或操作符时，解析器将优先
   造型到首选类型（但是只能从同类的其他类型造型）。更多细节请见
   <xref linkend="typeconv"/>。对于没有隐式造型到任意其他类型或者
   从任意其他类型造型的类型，让这些设置保持默认即可。不过，对于一组
   具有隐式造型的相关类型，把它们都标记为属于同一个类别并且选择一种
   或两种<quote>最常用</quote>的类型作为该类别的首选通常是很有用的。在
   把一种用户定义的类型增加到一个现有的内建类别（例如数字或者字符串
   类型）中时，
   <replaceable class="parameter">category</replaceable>参数特别
   有用。不过，也可以创建新的全部是用户定义类型的类别。对这样的类别，
   可选择除大写字母之外的任何 ASCII 字符。
  </para>

<!--==========================orignal english content==========================
  <para>
   A default value can be specified, in case a user wants columns of the
   data type to default to something other than the null value.
   Specify the default with the <literal>DEFAULT</literal> key word.
   (Such a default can be overridden by an explicit <literal>DEFAULT</literal>
   clause attached to a particular column.)
  </para>
____________________________________________________________________________-->
  <para>
   如果用户希望该数据类型的列被默认为某种非空值，可以指定一个默认值。
   默认值可以用<literal>DEFAULT</literal>关键词指定（这样一个默认值
   可以被附加到一个特定列的显式<literal>DEFAULT</literal>子句覆盖）。
  </para>

<!--==========================orignal english content==========================
  <para>
   To indicate that a type is a fixed-length array type,
   specify the type of the array
   elements using the <literal>ELEMENT</literal> key word.  For example, to
   define an array of 4-byte integers (<type>int4</type>), specify
   <literal>ELEMENT = int4</literal>.  For more details,
   see <xref linkend="sql-createtype-array"/> below.
  </para>
____________________________________________________________________________-->
  <para>
   要指定一种类型是固定长度数组类型，用<literal>ELEMENT</literal>关键词指定该数组元素的类型。
   例如，要定义一个 4 字节整数的数组（<type>int4</type>），应指定<literal>ELEMENT = int4</literal>。
   更多有关数组类型的细节请见下文<xref linkend="sql-createtype-array"/>。
  </para>

<!--==========================orignal english content==========================
  <para>
   To indicate the delimiter to be used between values in the external
   representation of arrays of this type, <replaceable
   class="parameter">delimiter</replaceable> can be
   set to a specific character.  The default delimiter is the comma
   (<literal>,</literal>).  Note that the delimiter is associated
   with the array element type, not the array type itself.
  </para>
____________________________________________________________________________-->
  <para>
   要指定在这种类型数组的外部表达中分隔值的定界符，可以把<replaceable
   class="parameter">delimiter</replaceable>设置为一个特定字符。默认
   的定界符是逗号（<literal>,</literal>）。注意定界符是与数组元素类型相
   关的，而不是数组类型本身相关。
  </para>

<!--==========================orignal english content==========================
  <para>
   If the optional Boolean
   parameter <replaceable class="parameter">collatable</replaceable>
   is true, column definitions and expressions of the type may carry
   collation information through use of
   the <literal>COLLATE</literal> clause.  It is up to the
   implementations of the functions operating on the type to actually
   make use of the collation information; this does not happen
   automatically merely by marking the type collatable.
  </para>
____________________________________________________________________________-->
  <para>
   如果可选的布尔参数
   <replaceable class="parameter">collatable</replaceable>为真，这种
   类型的列定义和表达式可能通过使用<literal>COLLATE</literal>子句携带
   有排序规则信息。在该类型上操作的函数的实现负责真正利用这些信息，仅
   把类型标记为可排序的并不会让它们自动地去使用这类信息。
  </para>
  </refsect2>

  <refsect2 id="sql-createtype-array" xreflabel="Array Types">
<!--==========================orignal english content==========================
   <title>Array Types</title>
____________________________________________________________________________-->
   <title>数组类型</title>

<!--==========================orignal english content==========================
   <para>
    Whenever a user-defined type is created,
    <productname>PostgreSQL</productname> automatically creates an
    associated array type, whose name consists of the element type's
    name prepended with an underscore, and truncated if necessary to keep
    it less than <symbol>NAMEDATALEN</symbol> bytes long.  (If the name
    so generated collides with an existing type name, the process is
    repeated until a non-colliding name is found.)
    This implicitly-created array type is variable length and uses the
    built-in input and output functions <literal>array_in</literal> and
    <literal>array_out</literal>.  Furthermore, this type is what the system
    uses for constructs such as <literal>ARRAY[]</literal> over the
    user-defined type.  The array type tracks any changes in its
    element type's owner or schema, and is dropped if the element type is.
   </para>
____________________________________________________________________________-->
   <para>
    只要一种用户定义的类型被创建，<productname>PostgreSQL</productname>会自动地创建一种相关的数组类型，其名称由元素类型的名称前面加上一个下划线组成，并且如果长度超过<symbol>NAMEDATALEN</symbol>字节会自动地被截断。
    （如果这样生成的名称与一种现有类型的名称冲突，该过程将会重复直到找到一个不冲突的名字）。
    这种隐式创建的数组类型是变长的并且使用内建的输入和输出函数（<literal>array_in</literal>以及<literal>array_out</literal>）。
    此外, 这种类型是系统用于构建诸如用户定义类型之上的<literal>ARRAY[]</literal>。
    该数组类型会追随其元素类型的拥有者或所在模式的任何更改，并且在元素类型被删除时也被删除。
   </para>

<!--==========================orignal english content==========================
   <para>
    You might reasonably ask why there is an <option>ELEMENT</option>
    option, if the system makes the correct array type automatically.
    The main case where it's useful to use <option>ELEMENT</option> is when you are
    making a fixed-length type that happens to be internally an array of a number of
    identical things, and you want to allow these things to be accessed
    directly by subscripting, in addition to whatever operations you plan
    to provide for the type as a whole.  For example, type <type>point</type>
    is represented as just two floating-point numbers, which can be accessed
    using <literal>point[0]</literal> and <literal>point[1]</literal>.
    Note that
    this facility only works for fixed-length types whose internal form
    is exactly a sequence of identical fixed-length fields.
    For historical reasons (i.e., this is clearly wrong but it's far too
    late to change it), subscripting of fixed-length array types starts from
    zero, rather than from one as for variable-length arrays.
   </para>
____________________________________________________________________________-->
   <para>
    如果系统会自动地创建正确的数组类型，你可能会很合情合理地问为什么会有一个<option>ELEMENT</option>选项。
    使用<option>ELEMENT</option>主要有用的情况是：当你在创建一种定长类型，它正好在内部是一个多个相同东西的数组，并且除了计划给该类型提供的整体操作之外，你想要允许用下标来直接访问这些东西。
    例如，类型<type>point</type>被表示为两个浮点数，可以使用<literal>point[0]</literal>以及<literal>point[1]</literal>来访问它们。
    注意，这种功能只适用于内部形式正好是一个相同定长域序列的定长类型。
    由于历史原因（即很明显是错的，但现在改已经太晚了），定长数组类型的下标是从零开始的，而不是像变长数组那样。
   </para>

<!--==========================orignal english content==========================
   <para>
    Specifying the <option>SUBSCRIPT</option> option allows a data type to
    be subscripted, even though the system does not otherwise regard it as
    an array type.  The behavior just described for fixed-length arrays is
    actually implemented by the <option>SUBSCRIPT</option> handler
    function <function>raw_array_subscript_handler</function>, which is
    used automatically if you specify <option>ELEMENT</option> for a
    fixed-length type without also writing <option>SUBSCRIPT</option>.
   </para>
____________________________________________________________________________-->
   <para>
    指定<option>SUBSCRIPT</option>选项允许数据类型被下标，即使系统没有，除此以外还将其视为数组类型。
    刚才描述的固定长度数组的行为实际上是由<option>SUBSCRIPT</option>处理函数<function>raw_array_subscript_handler</function>实现的，
    如果为固定长度类型指定<option>ELEMENT</option>，而没有另外写入<option>SUBSCRIPT</option>，则会自动使用。
   </para>

<!--==========================orignal english content==========================
   <para>
    When specifying a custom <option>SUBSCRIPT</option> function, it is
    not necessary to specify <option>ELEMENT</option> unless
    the <option>SUBSCRIPT</option> handler function needs to
    consult <structfield>typelem</structfield> to find out what to return.
    Be aware that specifying <option>ELEMENT</option> causes the system to
    assume that the new type contains, or is somehow physically dependent on,
    the element type; thus for example changing properties of the element
    type won't be allowed if there are any columns of the dependent type.
   </para>
____________________________________________________________________________-->
   <para>
    当指定一个自定义<option>SUBSCRIPT</option> 函数时，不必要指定<option>ELEMENT</option>，除非<option>SUBSCRIPT</option>处理函数需要参考<structfield>typelem</structfield>来查找返回了什么。
    注意指定<option>ELEMENT</option>会导致系统假定包含的新类型，或者在某种某种形式上实际上依赖，该元素类型;例如，如果存在依赖类型的列，更改元素类型的属性是不允许的。
   </para>
  </refsect2>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Parameters</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">name</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">name</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The name (optionally schema-qualified) of a type to be created.
     </para>
____________________________________________________________________________-->
     <para>
      要创建的类型的名称（可以被模式限定）。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">attribute_name</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">attribute_name</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The name of an attribute (column) for the composite type.
     </para>
____________________________________________________________________________-->
     <para>
      组合类型的一个属性（列）的名称。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">data_type</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">data_type</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The name of an existing data type to become a column of the
      composite type.
     </para>
____________________________________________________________________________-->
     <para>
      要成为组合类型的一个列的现有数据类型的名称。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">collation</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">collation</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The name of an existing collation to be associated with a column of
      a composite type, or with a range type.
     </para>
____________________________________________________________________________-->
     <para>
      要关联到组合类型的一列或者范围类型的现有排序规则的名称。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">label</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">label</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      A string literal representing the textual label associated with
      one value of an enum type.
     </para>
____________________________________________________________________________-->
     <para>
      一个字符串，它表达与枚举类型的一个值相关的文本标签。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">subtype</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">subtype</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The name of the element type that the range type will represent ranges
      of.
     </para>
____________________________________________________________________________-->
     <para>
      范围类型的元素类型的名称，范围类型表示的范围属于该类型。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">subtype_operator_class</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">subtype_operator_class</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The name of a b-tree operator class for the subtype.
     </para>
____________________________________________________________________________-->
     <para>
      用于 subtype 的 B 树操作符类的名称。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">canonical_function</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">canonical_function</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The name of the canonicalization function for the range type.
     </para>
____________________________________________________________________________-->
     <para>
      范围类型的规范化函数的名称。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">subtype_diff_function</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">subtype_diff_function</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The name of a difference function for the subtype.
     </para>
____________________________________________________________________________-->
     <para>
      用于 subtype 的差函数的名称。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">multirange_type_name</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">multirange_type_name</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The name of the corresponding multirange type.
     </para>
____________________________________________________________________________-->
     <para>
      相应多范围类型的名称。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">input_function</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">input_function</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The name of a function that converts data from the type's
      external textual form to its internal form.
     </para>
____________________________________________________________________________-->
     <para>
      将数据从类型的外部文本形式转换为内部形式的函数名。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">output_function</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">output_function</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The name of a function that converts data from the type's
      internal form to its external textual form.
     </para>
____________________________________________________________________________-->
     <para>
      将数据从类型的内部形式转换为外部文本形式的函数名。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">receive_function</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">receive_function</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The name of a function that converts data from the type's
      external binary form to its internal form.
     </para>
____________________________________________________________________________-->
     <para>
      将数据从类型的外部二进制形式转换成内部形式的函数名。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">send_function</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">send_function</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The name of a function that converts data from the type's
      internal form to its external binary form.
     </para>
____________________________________________________________________________-->
     <para>
      将数据从类型的内部形式转换为外部二进制形式的函数名。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">type_modifier_input_function</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">type_modifier_input_function</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The name of a function that converts an array of modifier(s) for the type
      into internal form.
     </para>
____________________________________________________________________________-->
     <para>
      将类型的修饰符数组转换为内部形式的函数名。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">type_modifier_output_function</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">type_modifier_output_function</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The name of a function that converts the internal form of the type's
      modifier(s) to external textual form.
     </para>
____________________________________________________________________________-->
     <para>
      将类型的修饰符的内部形式转换为外部文本形式的函数名。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">analyze_function</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">analyze_function</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The name of a function that performs statistical analysis for the
      data type.
     </para>
____________________________________________________________________________-->
     <para>
      为该数据类型执行统计分析的函数名。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">subscript_function</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">subscript_function</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The name of a function that defines what subscripting a value of the
      data type does.
     </para>
____________________________________________________________________________-->
     <para>
      函数的名称，该函数定义如何下标数据类型的值
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">internallength</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">internallength</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      A numeric constant that specifies the length in bytes of the new
      type's internal representation.  The default assumption is that
      it is variable-length.
     </para>
____________________________________________________________________________-->
     <para>
      一个数字常量，它指定新类型的内部表达的字节长度。默认的假设是
      它是变长的。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">alignment</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">alignment</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The storage alignment requirement of the data type.  If specified,
      it must be <literal>char</literal>, <literal>int2</literal>,
      <literal>int4</literal>, or <literal>double</literal>; the
      default is <literal>int4</literal>.
     </para>
____________________________________________________________________________-->
     <para>
      该数据类型的存储对齐需求。如果被指定，它必须是
      <literal>char</literal>、<literal>int2</literal>、
      <literal>int4</literal>或者<literal>double</literal>。默认是
      <literal>int4</literal>。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">storage</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">storage</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The storage strategy for the data type.  If specified, must be
      <literal>plain</literal>, <literal>external</literal>,
      <literal>extended</literal>, or <literal>main</literal>; the
      default is <literal>plain</literal>.
     </para>
____________________________________________________________________________-->
     <para>
      该数据类型的存储策略。如果被指定，必须是
      <literal>plain</literal>、<literal>external</literal>、
      <literal>extended</literal>或者<literal>main</literal>。
      默认是<literal>plain</literal>。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">like_type</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">like_type</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The name of an existing data type that the new type will have the
      same representation as.  The values of
      <replaceable class="parameter">internallength</replaceable>,
      <replaceable class="parameter">passedbyvalue</replaceable>,
      <replaceable class="parameter">alignment</replaceable>, and
      <replaceable class="parameter">storage</replaceable>
      are copied from that type, unless overridden by explicit
      specification elsewhere in this <command>CREATE TYPE</command> command.
     </para>
____________________________________________________________________________-->
     <para>
      与新类型具有相同表达的现有数据类型的名称。会从这个类型中复制
      <replaceable class="parameter">internallength</replaceable>、
      <replaceable class="parameter">passedbyvalue</replaceable>、
      <replaceable class="parameter">alignment</replaceable>以及
      <replaceable class="parameter">storage</replaceable>的值（
      除非在这个<command>CREATE TYPE</command>命令的其他地方用显式说
      明覆盖）。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">category</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">category</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The category code (a single ASCII character) for this type.
      The default is <literal>'U'</literal> for <quote>user-defined type</quote>.
      Other standard category codes can be found in
      <xref linkend="catalog-typcategory-table"/>.  You may also choose
      other ASCII characters in order to create custom categories.
     </para>
____________________________________________________________________________-->
     <para>
      这种类型的分类码（一个 ASCII 字符）。 默认是
      <quote>用户定义类型</quote>的<literal>'U'</literal>。其他的标准分类码可见
      <xref linkend="catalog-typcategory-table"/>。为了创建自定义分类，
      你也可以选择其他 ASCII 字符。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">preferred</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">preferred</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      True if this type is a preferred type within its type category,
      else false.  The default is false.  Be very careful about creating
      a new preferred type within an existing type category, as this
      could cause surprising changes in behavior.
     </para>
____________________________________________________________________________-->
     <para>
      如果这种类型是其类型分类中的优先类型则为真，否则为假。默认
      为假。在一个现有类型分类中创建一种新的优先类型要非常小心，
      因为这可能会导致行为上令人惊奇的改变。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">default</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">default</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The default value for the data type.  If this is omitted, the
      default is null.
     </para>
____________________________________________________________________________-->
     <para>
      数据类型的默认值。如果被省略，默认值是空。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">element</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">element</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The type being created is an array; this specifies the type of
      the array elements.
     </para>
____________________________________________________________________________-->
     <para>
      被创建的类型是一个数组，这指定了数组元素的类型。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">delimiter</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">delimiter</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The delimiter character to be used between values in arrays made
      of this type.
     </para>
____________________________________________________________________________-->
     <para>
      在由这种类型组成的数组中值之间的定界符。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">collatable</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">collatable</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      True if this type's operations can use collation information.
      The default is false.
     </para>
____________________________________________________________________________-->
     <para>
      如果这个类型的操作可以使用排序规则信息，则为真。默认为假。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1 id="sql-createtype-notes">
<!--==========================orignal english content==========================
  <title>Notes</title>
____________________________________________________________________________-->
  <title>注解</title>

<!--==========================orignal english content==========================
  <para>
   Because there are no restrictions on use of a data type once it's been
   created, creating a base type or range type is tantamount to granting
   public execute permission on the functions mentioned in the type definition.
   This is usually
   not an issue for the sorts of functions that are useful in a type
   definition.  But you might want to think twice before designing a type
   in a way that would require <quote>secret</quote> information to be used
   while converting it to or from external form.
  </para>
____________________________________________________________________________-->
  <para>
   由于一旦数据类型被创建，对该数据类型的使用就没有限制，创建一种基本类型
   或者范围类型就等同于在类型定义中提到的函数上授予公共执行权限。对于在类
   型定义中有用的函数来说这通常不是问题。但是如果设计一种类型时要求在转换
   到外部形式或者从外部形式转换时使用<quote>秘密</quote>信息，你就应该三思而
   后行。
  </para>

<!--==========================orignal english content==========================
  <para>
   Before <productname>PostgreSQL</productname> version 8.3, the name of
   a generated array type was always exactly the element type's name with one
   underscore character (<literal>_</literal>) prepended.  (Type names were
   therefore restricted in length to one fewer character than other names.)
   While this is still usually the case, the array type name may vary from
   this in case of maximum-length names or collisions with user type names
   that begin with underscore.  Writing code that depends on this convention
   is therefore deprecated.  Instead, use
   <structname>pg_type</structname>.<structfield>typarray</structfield> to locate the array type
   associated with a given type.
  </para>
____________________________________________________________________________-->
  <para>
   在<productname>PostgreSQL</productname>版本 8.3 之前，自动生成的
   数组类型的名称总是正好为元素类型的名称外加一个前置的下划线字符（
   <literal>_</literal>）。因此类型名称的长度限制比其他名称还要少一个字符。
   虽然现在这仍然是通常情况，但如果名称达到最大长度或者与其他下划线开头
   的用户类型名称冲突，数组类型的名称也可以不同于这种规则。因此依靠这种
   习惯编写代码现在已经不适用了。现在，可以使用
   <structname>pg_type</structname>.<structfield>typarray</structfield>来定位与给定类型相关
   的数组类型。
  </para>

<!--==========================orignal english content==========================
  <para>
   It may be advisable to avoid using type and table names that begin with
   underscore.  While the server will change generated array type names to
   avoid collisions with user-given names, there is still risk of confusion,
   particularly with old client software that may assume that type names
   beginning with underscores always represent arrays.
  </para>
____________________________________________________________________________-->
  <para>
   建议避免使用以下划线开始的类型名和表名。虽然服务器会改变生成的数组
   类型名称以避免与用户给定的名称冲突，仍然有混淆的风险，特别是对旧的
   客户端软件来说，它们可能会假定以下划线开始的类型名总是表示数组。
  </para>

<!--==========================orignal english content==========================
  <para>
   Before <productname>PostgreSQL</productname> version 8.2, the shell-type
   creation syntax
   <literal>CREATE TYPE <replaceable>name</replaceable></literal> did not exist.
   The way to create a new base type was to create its input function first.
   In this approach, <productname>PostgreSQL</productname> will first see
   the name of the new data type as the return type of the input function.
   The shell type is implicitly created in this situation, and then it
   can be referenced in the definitions of the remaining I/O functions.
   This approach still works, but is deprecated and might be disallowed in
   some future release.  Also, to avoid accidentally cluttering
   the catalogs with shell types as a result of simple typos in function
   definitions, a shell type will only be made this way when the input
   function is written in C.
  </para>
____________________________________________________________________________-->
  <para>
   在<productname>PostgreSQL</productname> 版本 8.2 之前，
   shell-type 的创建语法
   <literal>CREATE TYPE <replaceable>name</replaceable></literal>不存在。创建
   一种新基本类型的方法是先创建它的输入函数。在这种方法中，
   <productname>PostgreSQL</productname> 将首先把新数据类型的名
   称看做是输入函数的返回类型。在这种情况下 shell type 会被隐式地创建，
   并且能在剩余的 I/O 函数的定义中引用。这种方法现在仍然有效，但是已经
   被弃用并且可能会在未来的某个发行中被禁止。还有，为了避免由于函数定
   义中的打字错误导致 shell type 弄乱系统目录，当输入函数用 C 编写时，
   将只能用这种方法创建一种 shell type。
  </para>

 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Examples</title>
____________________________________________________________________________-->
  <title>示例</title>

<!--==========================orignal english content==========================
  <para>
   This example creates a composite type and uses it in
   a function definition:
<programlisting>
CREATE TYPE compfoo AS (f1 int, f2 text);

CREATE FUNCTION getfoo() RETURNS SETOF compfoo AS $$
    SELECT fooid, fooname FROM foo
$$ LANGUAGE SQL;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   这个例子创建了一种组合类型并且将其用在了一个函数定义中：
<programlisting>
CREATE TYPE compfoo AS (f1 int, f2 text);

CREATE FUNCTION getfoo() RETURNS SETOF compfoo AS $$
    SELECT fooid, fooname FROM foo
$$ LANGUAGE SQL;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   This example creates an enumerated type and uses it in
   a table definition:
<programlisting>
CREATE TYPE bug_status AS ENUM ('new', 'open', 'closed');

CREATE TABLE bug (
    id serial,
    description text,
    status bug_status
);
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   这个例子创建了一个枚举类型并且将其用在一个表定义中：
<programlisting>
CREATE TYPE bug_status AS ENUM ('new', 'open', 'closed');

CREATE TABLE bug (
    id serial,
    description text,
    status bug_status
);
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   This example creates a range type:
<programlisting>
CREATE TYPE float8_range AS RANGE (subtype = float8, subtype_diff = float8mi);
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   这个例子创建了一个范围类型：
<programlisting>
CREATE TYPE float8_range AS RANGE (subtype = float8, subtype_diff = float8mi);
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   This example creates the base data type <type>box</type> and then uses the
   type in a table definition:
<programlisting>
CREATE TYPE box;

CREATE FUNCTION my_box_in_function(cstring) RETURNS box AS ... ;
CREATE FUNCTION my_box_out_function(box) RETURNS cstring AS ... ;

CREATE TYPE box (
    INTERNALLENGTH = 16,
    INPUT = my_box_in_function,
    OUTPUT = my_box_out_function
);

CREATE TABLE myboxes (
    id integer,
    description box
);
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   这个例子创建了基本数据类型<type>box</type>然后将它用在一个表定义中：
<programlisting>
CREATE TYPE box;

CREATE FUNCTION my_box_in_function(cstring) RETURNS box AS ... ;
CREATE FUNCTION my_box_out_function(box) RETURNS cstring AS ... ;

CREATE TYPE box (
    INTERNALLENGTH = 16,
    INPUT = my_box_in_function,
    OUTPUT = my_box_out_function
);

CREATE TABLE myboxes (
    id integer,
    description box
);
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   If the internal structure of <type>box</type> were an array of four
   <type>float4</type> elements, we might instead use:
<programlisting>
CREATE TYPE box (
    INTERNALLENGTH = 16,
    INPUT = my_box_in_function,
    OUTPUT = my_box_out_function,
    ELEMENT = float4
);
</programlisting>
   which would allow a box value's component numbers to be accessed
   by subscripting.  Otherwise the type behaves the same as before.
  </para>
____________________________________________________________________________-->
  <para>
   如果<type>box</type>的内部结构是四个
   <type>float4</type>元素的一个数组，我们可能会使用：
<programlisting>
CREATE TYPE box (
    INTERNALLENGTH = 16,
    INPUT = my_box_in_function,
    OUTPUT = my_box_out_function,
    ELEMENT = float4
);
</programlisting>
   这将允许用下标来访问一个 box 值的组件编号。否则该类型的行为和
   前面的一样。
  </para>

<!--==========================orignal english content==========================
  <para>
   This example creates a large object type and uses it in
   a table definition:
<programlisting>
CREATE TYPE bigobj (
    INPUT = lo_filein, OUTPUT = lo_fileout,
    INTERNALLENGTH = VARIABLE
);
CREATE TABLE big_objs (
    id integer,
    obj bigobj
);
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   这个例子创建了一个大对象类型并且将它用在了一个表定义中：
<programlisting>
CREATE TYPE bigobj (
    INPUT = lo_filein, OUTPUT = lo_fileout,
    INTERNALLENGTH = VARIABLE
);
CREATE TABLE big_objs (
    id integer,
    obj bigobj
);
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   More examples, including suitable input and output functions, are
   in <xref linkend="xtypes"/>.
  </para>
____________________________________________________________________________-->
  <para>
   更多例子（包括配套的输入和输出函数）请见<xref linkend="xtypes"/>。
  </para>
 </refsect1>

 <refsect1 id="sql-createtype-compatibility">
<!--==========================orignal english content==========================
  <title>Compatibility</title>
____________________________________________________________________________-->
  <title>兼容性</title>

<!--==========================orignal english content==========================
  <para>
   The first form of the <command>CREATE TYPE</command> command, which
   creates a composite type, conforms to the <acronym>SQL</acronym> standard.
   The other forms are <productname>PostgreSQL</productname>
   extensions.  The <command>CREATE TYPE</command> statement in
   the <acronym>SQL</acronym> standard also defines other forms that are not
   implemented in <productname>PostgreSQL</productname>.
  </para>
____________________________________________________________________________-->
  <para>
   创建组合类型的第一种形式的<command>CREATE TYPE</command>命令
   符合<acronym>SQL</acronym>标准。其他的形式都是
   <productname>PostgreSQL</productname>扩展。<acronym>SQL</acronym>
   标准中的<command>CREATE TYPE</command>语句也定义了其他
   <productname>PostgreSQL</productname>中没有实现的形式。
  </para>

<!--==========================orignal english content==========================
  <para>
   The ability to create a composite type with zero attributes is
   a <productname>PostgreSQL</productname>-specific deviation from the
   standard (analogous to the same case in <command>CREATE TABLE</command>).
  </para>
____________________________________________________________________________-->
  <para>
   创建一种具有零个属性的组合类型的能力是一种
   <productname>PostgreSQL</productname>对标准的背离（类似于
   <command>CREATE TABLE</command>中相同的情况）。
  </para>
 </refsect1>

 <refsect1 id="sql-createtype-see-also">
<!--==========================orignal english content==========================
  <title>See Also</title>
____________________________________________________________________________-->
  <title>另见</title>

  <simplelist type="inline">
   <member><xref linkend="sql-altertype"/></member>
   <member><xref linkend="sql-createdomain"/></member>
   <member><xref linkend="sql-createfunction"/></member>
   <member><xref linkend="sql-droptype"/></member>
  </simplelist>
 </refsect1>

</refentry>
