<!--
doc/src/sgml/ref/pgupgrade.sgml
PostgreSQL documentation
-->

<refentry id="pgupgrade">
<!--==========================orignal english content==========================
 <indexterm zone="pgupgrade">
  <primary>pg_upgrade</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="pgupgrade">
  <primary>pg_upgrade</primary>
 </indexterm>

<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle><application>pg_upgrade</application></refentrytitle>
  <manvolnum>1</manvolnum>
  <refmiscinfo>Application</refmiscinfo>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle><application>pg_upgrade</application></refentrytitle>
  <manvolnum>1</manvolnum>
  <refmiscinfo>Application</refmiscinfo>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>pg_upgrade</refname>
  <refpurpose>upgrade a <productname>PostgreSQL</productname> server instance</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>pg_upgrade</refname>
  <refpurpose>升级<productname>PostgreSQL</productname>服务器实例</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<!--==========================orignal english content==========================
  <cmdsynopsis>
   <command>pg_upgrade</command>
   <arg choice="plain"><option>-b</option></arg>
   <arg choice="plain"><replaceable>oldbindir</replaceable></arg>
   <arg choice="plain"><option>-B</option></arg>
   <arg choice="plain"><replaceable>newbindir</replaceable></arg>
   <arg choice="plain"><option>-d</option></arg>
   <arg choice="plain"><replaceable>oldconfigdir</replaceable></arg>
   <arg choice="plain"><option>-D</option></arg>
   <arg choice="plain"><replaceable>newconfigdir</replaceable></arg>
   <arg rep="repeat"><replaceable>option</replaceable></arg>
  </cmdsynopsis>
____________________________________________________________________________-->
  <cmdsynopsis>
   <command>pg_upgrade</command>
   <arg choice="plain"><option>-b</option></arg>
   <arg choice="plain"><replaceable>oldbindir</replaceable></arg>
   <arg choice="plain"><option>-B</option></arg>
   <arg choice="plain"><replaceable>newbindir</replaceable></arg>
   <arg choice="plain"><option>-d</option></arg>
   <arg choice="plain"><replaceable>oldconfigdir</replaceable></arg>
   <arg choice="plain"><option>-D</option></arg>
   <arg choice="plain"><replaceable>newconfigdir</replaceable></arg>
   <arg rep="repeat"><replaceable>option</replaceable></arg>
  </cmdsynopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
 <para>
  <application>pg_upgrade</application> (formerly called <application>pg_migrator</application>) allows data
  stored in <productname>PostgreSQL</productname> data files to be upgraded to a later <productname>PostgreSQL</productname>
  major version without the data dump/reload typically required for
  major version upgrades, e.g., from 9.5.8 to 9.6.4 or from 10.7 to 11.2.
  It is not required for minor version upgrades, e.g., from 9.6.2 to 9.6.3
  or from 10.1 to 10.2.
 </para>
____________________________________________________________________________-->
 <para>
  <application>pg_upgrade</application>（之前被称为<application>pg_migrator</application>）
  允许存储在<productname>PostgreSQL</productname>数据文件中的数据被升级到一个较晚
  的<productname>PostgreSQL</productname>主版本而无需进行主版本升级（例如从9.5.8到9.6.4或者从10.7到11.2）通常所需的数据转储/重载。
  对于次版本升级（例如从9.6.2到9.6.3或者从10.1到10.2）则不需要这个程序。
 </para>

<!--==========================orignal english content==========================
 <para>
  Major PostgreSQL releases regularly add new features that often
  change the layout of the system tables, but the internal data storage
  format rarely changes.  <application>pg_upgrade</application> uses this fact
  to perform rapid upgrades by creating new system tables and simply
  reusing the old user data files.  If a future major release ever
  changes the data storage format in a way that makes the old data
  format unreadable, <application>pg_upgrade</application> will not be usable
  for such upgrades.  (The community will attempt to avoid such
  situations.)
 </para>
____________________________________________________________________________-->
 <para>
  PostgreSQL主发行版本通常会加入新的特性，这些新特性常常会更改系统表的
  布局，但是内部数据存储格式很少会改变。<application>pg_upgrade</application>
  使用这一事实来通过创建新系统表并且重用旧的用户数据文件来执行快速升级。
  如果未来的主发行版本更改了数据存储格式，导致旧数据格式不可读，那么
  <application>pg_upgrade</application>将无法用于此类升级。（社区将努力避免这种情况）。
 </para>

<!--==========================orignal english content==========================
 <para>
  <application>pg_upgrade</application> does its best to
  make sure the old and new clusters are binary-compatible, e.g.,  by
  checking for compatible compile-time settings, including 32/64-bit
  binaries.  It is important that
  any external modules are also binary compatible, though this cannot
  be checked by <application>pg_upgrade</application>.
 </para>
____________________________________________________________________________-->
 <para>
  <application>pg_upgrade</application>会尽力（例如通过检查兼容的编译时设
  置）确保新旧集簇在二进制上也是兼容的，包括 32/64 位二进制。保持
  外部模块也是二进制兼容的也很重要，不过
  <application>pg_upgrade</application>无法检查这一点。
 </para>

<!--==========================orignal english content==========================
  <para>
   pg_upgrade supports upgrades from 8.4.X and later to the current
   major release of <productname>PostgreSQL</productname>, including snapshot and beta releases.
  </para>
____________________________________________________________________________-->
  <para>
   pg_upgrade 支持从 8.4.X 及其后版本升级到当前的
   <productname>PostgreSQL</productname>主发布，包括快照和 beta 发布。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Options</title>
____________________________________________________________________________-->
  <title>选项</title>

<!--==========================orignal english content==========================
   <para>
    <application>pg_upgrade</application> accepts the following command-line arguments:

    <variablelist>

     <varlistentry>
      <term><option>-b</option> <replaceable>bindir</replaceable></term>
      <term><option>-&minus;old-bindir=</option><replaceable>bindir</replaceable></term>
      <listitem><para>the old PostgreSQL executable directory;
      environment variable <envar>PGBINOLD</envar></para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-B</option> <replaceable>bindir</replaceable></term>
      <term><option>-&minus;new-bindir=</option><replaceable>bindir</replaceable></term>
      <listitem><para>the new PostgreSQL executable directory;
      default is the directory where <application>pg_upgrade</application> resides;
      environment variable <envar>PGBINNEW</envar></para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-c</option></term>
      <term><option>-&minus;check</option></term>
      <listitem><para>check clusters only, don't change any data</para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-d</option> <replaceable>configdir</replaceable></term>
      <term><option>-&minus;old-datadir=</option><replaceable>configdir</replaceable></term>
      <listitem><para>the old database cluster configuration directory; environment
      variable <envar>PGDATAOLD</envar></para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-D</option> <replaceable>configdir</replaceable></term>
      <term><option>-&minus;new-datadir=</option><replaceable>configdir</replaceable></term>
      <listitem><para>the new database cluster configuration directory; environment
      variable <envar>PGDATANEW</envar></para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-j <replaceable class="parameter">njobs</replaceable></option></term>
      <term><option>-&minus;jobs=<replaceable class="parameter">njobs</replaceable></option></term>
      <listitem><para>number of simultaneous processes or threads to use
      </para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-k</option></term>
      <term><option>-&minus;link</option></term>
      <listitem><para>use hard links instead of copying files to the new
      cluster</para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-o</option> <replaceable class="parameter">options</replaceable></term>
      <term><option>-&minus;old-options</option> <replaceable class="parameter">options</replaceable></term>
      <listitem><para>options to be passed directly to the
      old <command>postgres</command> command;  multiple
      option invocations are appended</para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-O</option> <replaceable class="parameter">options</replaceable></term>
      <term><option>-&minus;new-options</option> <replaceable class="parameter">options</replaceable></term>
      <listitem><para>options to be passed directly to the
      new <command>postgres</command> command;  multiple
      option invocations are appended</para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-p</option> <replaceable>port</replaceable></term>
      <term><option>-&minus;old-port=</option><replaceable>port</replaceable></term>
      <listitem><para>the old cluster port number; environment
      variable <envar>PGPORTOLD</envar></para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-P</option> <replaceable>port</replaceable></term>
      <term><option>-&minus;new-port=</option><replaceable>port</replaceable></term>
      <listitem><para>the new cluster port number; environment
      variable <envar>PGPORTNEW</envar></para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-r</option></term>
      <term><option>-&minus;retain</option></term>
      <listitem><para>retain SQL and log files even after successful completion
      </para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-s</option> <replaceable>dir</replaceable></term>
      <term><option>-&minus;socketdir=</option><replaceable>dir</replaceable></term>
      <listitem><para>directory to use for postmaster sockets during upgrade;
      default is current working directory; environment
      variable <envar>PGSOCKETDIR</envar></para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-U</option> <replaceable>username</replaceable></term>
      <term><option>-&minus;username=</option><replaceable>username</replaceable></term>
      <listitem><para>cluster's install user name; environment
      variable <envar>PGUSER</envar></para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-v</option></term>
      <term><option>-&minus;verbose</option></term>
      <listitem><para>enable verbose internal logging</para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-V</option></term>
      <term><option>-&minus;version</option></term>
      <listitem><para>display version information, then exit</para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-&minus;clone</option></term>
      <listitem>
       <para>
        Use efficient file cloning (also known as <quote>reflinks</quote> on
        some systems) instead of copying files to the new cluster.  This can
        result in near-instantaneous copying of the data files, giving the
        speed advantages of <option>-k</option>/<option>-&minus;link</option> while
        leaving the old cluster untouched.
       </para>

       <para>
        File cloning is only supported on some operating systems and file
        systems.  If it is selected but not supported, the
        <application>pg_upgrade</application> run will error.  At present, it
        is supported on Linux (kernel 4.5 or later) with Btrfs and XFS (on
        file systems created with reflink support), and on macOS with APFS.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-?</option></term>
      <term><option>-&minus;help</option></term>
      <listitem><para>show help, then exit</para></listitem>
     </varlistentry>

    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    <application>pg_upgrade</application>接受下列命令行参数：

    <variablelist>

     <varlistentry>
      <term><option>-b</option> <replaceable>bindir</replaceable></term>
      <term><option>--old-bindir=</option><replaceable>bindir</replaceable></term>
      <listitem><para>旧的 PostgreSQL 可执行文件目录；
      环境变量<envar>PGBINOLD</envar></para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-B</option> <replaceable>bindir</replaceable></term>
      <term><option>--new-bindir=</option><replaceable>bindir</replaceable></term>
      <listitem><para>新的 PostgreSQL 可执行文件目录；
      默认为<application>pg_upgrade</application>所在的目录；
      环境变量<envar>PGBINNEW</envar></para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-c</option></term>
      <term><option>--check</option></term>
      <listitem><para>只检查集簇，不更改任何数据</para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-d</option> <replaceable>configdir</replaceable></term>
      <term><option>--old-datadir=</option><replaceable>configdir</replaceable></term>
      <listitem><para>旧的集簇数据目录；环境变量
      <envar>PGDATAOLD</envar></para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-D</option> <replaceable>configdir</replaceable></term>
      <term><option>--new-datadir=</option><replaceable>configdir</replaceable></term>
      <listitem><para>新的集簇数据目录；环境变量
      <envar>PGDATANEW</envar></para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-j</option></term>
      <term><option>--jobs=<replaceable class="parameter">njobs</replaceable></option></term>
      <listitem><para>要同时使用的进程或线程数
      </para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-k</option></term>
      <term><option>--link</option></term>
      <listitem><para>使用硬链接来代替将文件拷贝到新集簇</para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-o</option> <replaceable class="parameter">options</replaceable></term>
      <term><option>--old-options</option> <replaceable class="parameter">options</replaceable></term>
      <listitem><para>直接传送给旧
      <command>postgres</command>命令的选项，多个选项可以追加在后面</para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-O</option> <replaceable class="parameter">options</replaceable></term>
      <term><option>--new-options</option> <replaceable class="parameter">options</replaceable></term>
      <listitem><para>直接传送给新
      <command>postgres</command>命令的选项，多个选项可以追加在后面</para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-p</option> <replaceable>port</replaceable></term>
      <term><option>--old-port=</option><replaceable>port</replaceable></term>
      <listitem><para>旧的集簇端口号；环境变量
      <envar>PGPORTOLD</envar></para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-P</option> <replaceable>port</replaceable></term>
      <term><option>--new-port=</option><replaceable>port</replaceable></term>
      <listitem><para>新的集簇端口号；环境变量
      <envar>PGPORTNEW</envar></para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-r</option></term>
      <term><option>--retain</option></term>
      <listitem><para>即使在成功完成后也保留 SQL 和日志文件
      </para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-s</option> <replaceable>dir</replaceable></term>
      <term><option>--socketdir=</option><replaceable>dir</replaceable></term>
      <listitem><para>用于升级期间postmaster套接字的目录;默认是当前目录; 
      环境变量 <envar>PGSOCKETDIR</envar></para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-U</option> <replaceable>username</replaceable></term>
      <term><option>--username=</option><replaceable>username</replaceable></term>
      <listitem><para>集簇的安装用户名；环境变量
      <envar>PGUSER</envar></para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-v</option></term>
      <term><option>--verbose</option></term>
      <listitem><para>启用详细的内部日志</para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-V</option></term>
      <term><option>--version</option></term>
      <listitem><para>显示版本信息，然后退出</para></listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--clone</option></term>
      <listitem>
       <para>
        使用有效的文件克隆（在一些系统上也被称为<quote>reflinks</quote>），而不是将文件拷贝到新群集。
        这可以导致数据文件接近瞬时的复制，从而获得<option>-k</option>/<option>--link</option>的速度优势，同时保留旧群集不受影响。
       </para>

       <para>
        文件克隆仅在某些操作系统和文件系统上得到支持。如果选中但不被支持，则 <application>pg_upgrade</application>运行将会出错。
        目前，它支持在Linux（内核4.5或更高版本）上的Btrfs和XFS（在文件系统创建reflink支持），以及macOS上的APFS。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-?</option></term>
      <term><option>--help</option></term>
      <listitem><para>显示帮助，然后退出</para></listitem>
     </varlistentry>

    </variablelist>
   </para>

 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Usage</title>
____________________________________________________________________________-->
  <title>使用</title>

<!--==========================orignal english content==========================
  <para>
   These are the steps to perform an upgrade
   with <application>pg_upgrade</application>:
  </para>
____________________________________________________________________________-->
  <para>
   下面是用<application>pg_upgrade</application>执行一次升级的步骤：
  </para>

  <procedure>
   <step performance="optional">
<!--==========================orignal english content==========================
    <title>Optionally move the old cluster</title>
____________________________________________________________________________-->
    <title>移动旧集簇（可选）</title>

<!--==========================orignal english content==========================
    <para>
     If you are using a version-specific installation directory, e.g.,
     <filename>/opt/PostgreSQL/&majorversion;</filename>, you do not need to move the old cluster. The
     graphical installers all use version-specific installation directories.
    </para>
____________________________________________________________________________-->
    <para>
     如果你在使用一个与版本相关的安装目录（例如
     <filename>/opt/PostgreSQL/&majorversion;</filename>），你就不需要移动旧的集簇。
     图形化的安装程序会使用版本相关的安装目录。
    </para>

<!--==========================orignal english content==========================
    <para>
     If your installation directory is not version-specific, e.g.,
     <filename>/usr/local/pgsql</filename>, it is necessary to move the current PostgreSQL install
     directory so it does not interfere with the new <productname>PostgreSQL</productname> installation.
     Once the current <productname>PostgreSQL</productname> server is shut down, it is safe to rename the
     PostgreSQL installation directory; assuming the old directory is
     <filename>/usr/local/pgsql</filename>, you can do:

<programlisting>
mv /usr/local/pgsql /usr/local/pgsql.old
</programlisting>
     to rename the directory.
    </para>
____________________________________________________________________________-->
    <para>
     如果你的安装目录不是版本相关的（例如<filename>/usr/local/pgsql</filename>），
     就有必要移动当前的 PostgreSQL 安装目录，以免它干扰新的
     <productname>PostgreSQL</productname>安装。一旦当前的
     <productname>PostgreSQL</productname>服务器被关闭，就可以安全地重命名
     PostgreSQL 安装目录。假设旧目录是
     <filename>/usr/local/pgsql</filename>，你可以这样：

<programlisting>
mv /usr/local/pgsql /usr/local/pgsql.old
</programlisting>
     来重命名该目录。
    </para>
   </step>

   <step>
<!--==========================orignal english content==========================
    <title>For source installs, build the new version</title>
____________________________________________________________________________-->
    <title>对于源码安装，编译新版本</title>

<!--==========================orignal english content==========================
    <para>
     Build the new PostgreSQL source with <command>configure</command> flags that are compatible
     with the old cluster. <application>pg_upgrade</application> will check <command>pg_controldata</command> to make
     sure all settings are compatible before starting the upgrade.
    </para>
____________________________________________________________________________-->
    <para>
     用兼容旧集簇的<command>configure</command>标记编译新的
     PostgreSQL 源码。在开始升级之前，<application>pg_upgrade</application>
     将检查<command>pg_controldata</command>来确保所有设置都是兼容的。
    </para>
   </step>

   <step>
<!--==========================orignal english content==========================
    <title>Install the new PostgreSQL binaries</title>
____________________________________________________________________________-->
    <title>安装新的 PostgreSQL 二进制文件</title>

<!--==========================orignal english content==========================
    <para>
     Install the new server's binaries and support
     files.  <application>pg_upgrade</application> is included in a default installation.
    </para>
____________________________________________________________________________-->
    <para>
     安装新服务器的二进制文件和支持文件。<application>pg_upgrade</application>
     会被包含在默认的安装中。
    </para>

<!--==========================orignal english content==========================
    <para>
     For source installs, if you wish to install the new server in a custom
     location, use the <literal>prefix</literal> variable:

<programlisting>
make prefix=/usr/local/pgsql.new install
</programlisting></para>
____________________________________________________________________________-->
    <para>
     对于源码安装，如果你希望把新服务器安装在一个自定义的位置，
     可以使用<literal>prefix</literal>变量：

<programlisting>
make prefix=/usr/local/pgsql.new install
</programlisting></para>
   </step>

   <step>
<!--==========================orignal english content==========================
    <title>Initialize the new PostgreSQL cluster</title>
____________________________________________________________________________-->
    <title>初始化新的 PostgreSQL 集簇</title>

<!--==========================orignal english content==========================
    <para>
     Initialize the new cluster using <command>initdb</command>.
     Again, use compatible <command>initdb</command>
     flags that match the old cluster. Many
     prebuilt installers do this step automatically. There is no need to
     start the new cluster.
    </para>
____________________________________________________________________________-->
    <para>
     使用<command>initdb</command>初始化新集簇。这里也要使用与
     旧集簇相兼容的<command>initdb</command>标志。许多预编译的
     安装程序会自动做这个步骤。这里没有必要启动新集簇。
    </para>
   </step>

   <step>
<!--==========================orignal english content==========================
    <title>Install extension shared object files</title>
____________________________________________________________________________-->
    <title>安装扩展共享对象文件</title>

<!--==========================orignal english content==========================
    <para>
     Many extensions and custom modules, whether from
     <filename>contrib</filename> or another source, use shared object
     files (or DLLs), e.g., <filename>pgcrypto.so</filename>.  If the old
     cluster used these, shared object files matching the new server binary
     must be installed in the new cluster, usually via operating system
     commands.  Do not load the schema definitions, e.g., <command>CREATE
     EXTENSION pgcrypto</command>, because these will be duplicated from
     the old cluster.  If extension updates are available,
     <application>pg_upgrade</application> will report this and create
     a script that can be run later to update them.
    </para>
____________________________________________________________________________-->
    <para>
     许多扩展和自定义模块，无论是来自<filename>contrib</filename>或其他源，使用共享对象文件(或DLLs)，例如， <filename>pgcrypto.so</filename>。
     如果旧集群使用过这些，匹配新服务器二进制的共享对象文件，必须安装在新集群中。
     通常是通过操作系统命令。
     不要加载模式定义，例如<command>CREATE EXTENSION pgcrypto</command>，因为这些将从旧集群复制。
     如果扩展更新是可用的，<application>pg_upgrade</application>将报告这一点，并创建一个脚本，可以稍后运行来更新它们。
    </para>
   </step>

   <step>
<!--==========================orignal english content==========================
    <title>Copy custom full-text search files</title>
____________________________________________________________________________-->
    <title>拷贝定制的全文本检索文件</title>

<!--==========================orignal english content==========================
    <para>
     Copy any custom full text search files (dictionary, synonym,
     thesaurus, stop words) from the old to the new cluster.
    </para>
____________________________________________________________________________-->
    <para>
     从旧集群向新集群拷贝任何定制化全文本检索文件(词典、同义词、辞典、停用词)
    </para>
   </step>

   <step>
<!--==========================orignal english content==========================
    <title>Adjust authentication</title>
____________________________________________________________________________-->
    <title>调整认证</title>

<!--==========================orignal english content==========================
    <para>
     <command>pg_upgrade</command> will connect to the old and new servers several
     times, so you might want to set authentication to <literal>peer</literal>
     in <filename>pg_hba.conf</filename> or use a <filename>~/.pgpass</filename> file
     (see <xref linkend="libpq-pgpass"/>).
    </para>
____________________________________________________________________________-->
    <para>
     <command>pg_upgrade</command>将会多次连接到旧服务器和新服务器，因此
     你可能想要在<filename>pg_hba.conf</filename>中把认证设置成
     <literal>peer</literal>或者使用一个<filename>~/.pgpass</filename>文件（见
     <xref linkend="libpq-pgpass"/>）。
    </para>
   </step>

   <step>
<!--==========================orignal english content==========================
    <title>Stop both servers</title>
____________________________________________________________________________-->
    <title>停止两个服务器</title>

<!--==========================orignal english content==========================
    <para>
     Make sure both database servers are stopped using, on Unix, e.g.:

<programlisting>
pg_ctl -D /opt/PostgreSQL/9.6 stop
pg_ctl -D /opt/PostgreSQL/&majorversion; stop
</programlisting>

     or on Windows, using the proper service names:

<programlisting>
NET STOP postgresql-9.6
NET STOP postgresql-&majorversion;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     确认两个数据库服务器都被停止使用，例如在 Unix 上可以：

<programlisting>
pg_ctl -D /opt/PostgreSQL/9.6 stop
pg_ctl -D /opt/PostgreSQL/&majorversion; stop
</programlisting>

     或者在 Windows 上使用正确的服务名：

<programlisting>
NET STOP postgresql-9.6
NET STOP postgresql-&majorversion;
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     Streaming replication and log-shipping standby servers can
     remain running until a later step.
    </para>
____________________________________________________________________________-->
    <para>
     直到后面的步骤之前，流复制和日志传送后备服务器可以保持运行。
    </para>
   </step>

   <step>
<!--==========================orignal english content==========================
    <title>Prepare for standby server upgrades</title>
____________________________________________________________________________-->
    <title>为后备服务器升级做准备</title>

<!--==========================orignal english content==========================
    <para>
     If you are upgrading standby servers using methods outlined in section <xref
     linkend="pgupgrade-step-replicas"/>, verify that the old standby
     servers are caught up by running <application>pg_controldata</application>
     against the old primary and standby clusters.  Verify that the
     <quote>Latest checkpoint location</quote> values match in all clusters.
     (There will be a mismatch if old standby servers were shut down
     before the old primary or if the old standby servers are still running.)
     Also, make sure <varname>wal_level</varname> is not set to
     <literal>minimal</literal> in the <filename>postgresql.conf</filename> file on the
     new primary cluster.
    </para>
____________________________________________________________________________-->
    <para>
     如果正在使用小节<xref linkend="pgupgrade-step-replicas"/>中给出的方法升级后备服务器，请对旧的主集簇和后备集簇运行<application>pg_controldata</application>以验证旧的后备服务器已经完全追上。验证<quote>Latest checkpoint location</quote>值在所有集簇中都匹配（如果旧后备服务器在旧的主服务器之前被关闭或者如果旧的后备服务器仍在运行，则将会出现失配）。此外，请确保在新的主集簇上的<filename>postgresql.conf</filename>文件中，<varname>wal_level</varname>未设置为<literal>minimal</literal>。
    </para>
   </step>

   <step>
<!--==========================orignal english content==========================
    <title>Run <application>pg_upgrade</application></title>
____________________________________________________________________________-->
    <title>运行 <application>pg_upgrade</application></title>

<!--==========================orignal english content==========================
    <para>
     Always run the <application>pg_upgrade</application> binary of the new server, not the old one.
     <application>pg_upgrade</application> requires the specification of the old and new cluster's
     data and executable (<filename>bin</filename>) directories. You can also specify
     user and port values, and whether you want the data files linked or cloned
     instead of the default copy behavior.
    </para>
____________________________________________________________________________-->
    <para>
     总是应该运行新服务器而不是旧服务器的<application>pg_upgrade</application>二进制文件。
     <application>pg_upgrade</application>要求制定新旧集簇的数据和可执行文件（<filename>bin</filename>）目录。
     你也可以指定用户和端口值，以及你是否想要用链接或克隆来取代默认的复制行为对数据文件进行处理。
    </para>

<!--==========================orignal english content==========================
    <para>
     If you use link mode, the upgrade will be much faster (no file
     copying) and use less disk space, but you will not be able to access
     your old cluster
     once you start the new cluster after the upgrade.  Link mode also
     requires that the old and new cluster data directories be in the
     same file system.  (Tablespaces and <filename>pg_wal</filename> can be on
     different file systems.)
     Clone mode provides the same speed and disk space advantages but
     does not cause the old cluster to be unusable once the new cluster
     is started.  Clone mode also requires that the old and new data
     directories be in the same file system.  This mode is only available
     on certain operating systems and file systems.
    </para>
____________________________________________________________________________-->
    <para>
     如果你使用链接模式，升级将会快很多（不需要文件拷贝）并且将使用
     更少的磁盘空间，但是在升级后一旦启动新集簇，旧集簇就无法被访问。
     链接模式也要求新旧集簇数据目录位于同一个文件系统中（表空间和
     <filename>pg_wal</filename>可以在不同的文件系统中）。
     克隆模式提供了相同的速度以及磁盘空间优势，但不会导致新群集启动后旧群集不可用。 
     克隆模式还需要新旧数据目录位于同一文件系统中。 此模式仅在某些操作系统和文件系统上可用。
    </para>

<!--==========================orignal english content==========================
    <para>
     The <option>-&minus;jobs</option> option allows multiple CPU cores to be used
     for copying/linking of files and to dump and reload database schemas
     in parallel;  a good place to start is the maximum of the number of
     CPU cores and tablespaces.  This option can dramatically reduce the
     time to upgrade a multi-database server running on a multiprocessor
     machine.
    </para>
____________________________________________________________________________-->
    <para>
     <option>--jobs</option>选项允许多个 CPU 核心被用来复制/链接文件以及
     并行地转储和重载数据库模式。这个选项一个比较好的值是 CPU 核心数
     和表空间数的最大值。这个选项可以显著地减少升级运行在一台多处理
     器机器上的多数据库服务器的时间。
    </para>

<!--==========================orignal english content==========================
    <para>
     For Windows users, you must be logged into an administrative account, and
     then start a shell as the <literal>postgres</literal> user and set the proper path:

<programlisting>
RUNAS /USER:postgres "CMD.EXE"
SET PATH=%PATH%;C:\Program Files\PostgreSQL\&majorversion;\bin;
</programlisting>

     and then run <application>pg_upgrade</application> with quoted directories, e.g.:

<programlisting>
pg_upgrade.exe
        -&minus;old-datadir "C:/Program Files/PostgreSQL/9.6/data"
        -&minus;new-datadir "C:/Program Files/PostgreSQL/&majorversion;/data"
        -&minus;old-bindir "C:/Program Files/PostgreSQL/9.6/bin"
        -&minus;new-bindir "C:/Program Files/PostgreSQL/&majorversion;/bin"
</programlisting>

     Once started, <command>pg_upgrade</command> will verify the two clusters are compatible
     and then do the upgrade. You can use <command>pg_upgrade -&minus;check</command>
     to perform only the checks, even if the old server is still
     running. <command>pg_upgrade -&minus;check</command> will also outline any
     manual adjustments you will need to make after the upgrade.  If you
     are going to be using link or clone mode, you should use the option
     <option>-&minus;link</option> or <option>-&minus;clone</option> with
     <option>-&minus;check</option> to enable mode-specific checks.
     <command>pg_upgrade</command> requires write permission in the current directory.
    </para>
____________________________________________________________________________-->
    <para>
     对于 Windows 用户，你必须以一个超级账号登录，并且以
     <literal>postgres</literal>用户启动一个 shell 并且设置正确的路径：

<programlisting>
RUNAS /USER:postgres "CMD.EXE"
SET PATH=%PATH%;C:\Program Files\PostgreSQL\&majorversion;\bin;
</programlisting>

     并且用带引号的目录运行<application>pg_upgrade</application>，例如：

<programlisting>
pg_upgrade.exe
        --old-datadir "C:/Program Files/PostgreSQL/9.6/data"
        --new-datadir "C:/Program Files/PostgreSQL/&majorversion;/data"
        --old-bindir "C:/Program Files/PostgreSQL/9.6/bin"
        --new-bindir "C:/Program Files/PostgreSQL/&majorversion;/bin"
</programlisting>

     一旦启动，<command>pg_upgrade</command>将验证两个集簇是否兼容并且
     执行升级。你可以使用<command>pg_upgrade --check</command>来只执行检查，
     这种模式即使在旧服务器还在运行时也能使用。
     <command>pg_upgrade --check</command>也将列出任何在更新后需要做的手工调整。
     如果你将要使用链接或克隆模式，你应该使用<option>--link</option>或<option>--clone</option>选项和<option>--check</option>一起来启用链接模式相关的检查。
     <command>pg_upgrade</command>要求在当前目录中的写权限。
    </para>

<!--==========================orignal english content==========================
    <para>
     Obviously, no one should be accessing the clusters during the
     upgrade.  <application>pg_upgrade</application> defaults to running servers
     on port 50432 to avoid unintended client connections.
     You can use the same port number for both clusters when doing an
     upgrade because the old and new clusters will not be running at the
     same time.  However, when checking an old running server, the old
     and new port numbers must be different.
    </para>
____________________________________________________________________________-->
    <para>
     显然，没有人可以在升级期间访问这些集簇。<application>pg_upgrade</application>
     默认会在端口 50432 上运行服务器来避免意外的客户端连接。在做升级时，
     可以对两个集簇使用相同的端口号，因为新旧集簇不会在同时被运行。不过，
     在检查一个旧的运行中服务器时，新旧端口号必须不同。
    </para>

<!--==========================orignal english content==========================
    <para>
     If an error occurs while restoring the database schema, <command>pg_upgrade</command> will
     exit and you will have to revert to the old cluster as outlined in <xref linkend="pgupgrade-step-revert"/>
     below. To try <command>pg_upgrade</command> again, you will need to modify the old
     cluster so the pg_upgrade schema restore succeeds. If the problem is a
     <filename>contrib</filename> module, you might need to uninstall the <filename>contrib</filename> module from
     the old cluster and install it in the new cluster after the upgrade,
     assuming the module is not being used to store user data.
    </para>
____________________________________________________________________________-->
    <para>
     如果在恢复数据库模式时发生错误，<command>pg_upgrade</command>将会退出
     并且你必须按照下文<xref linkend="pgupgrade-step-revert"/>中所说的恢复
     旧集簇。要再次尝试<command>pg_upgrade</command>，你将需要修改
     旧集簇，这样 pg_upgrade 模式会成功恢复。如果问题是一个
     <filename>contrib</filename>模块，
     你可能需要从旧集簇中卸载该模块并且在升级后重新把它安装在新集簇中，不过
     这样做的前提是该模块没有被用来存储用户数据。
    </para>
   </step>

   <step id="pgupgrade-step-replicas">
<!--==========================orignal english content==========================
    <title>Upgrade streaming replication and log-shipping standby servers</title>
____________________________________________________________________________-->
    <title>升级流复制和日志传送后备服务器</title>

<!--==========================orignal english content==========================
    <para>
     If you used link mode and have Streaming Replication (see <xref
     linkend="streaming-replication"/>) or Log-Shipping (see <xref
     linkend="warm-standby"/>) standby servers, you can follow these steps to
     quickly upgrade them.  You will not be running <application>pg_upgrade</application> on
     the standby servers, but rather <application>rsync</application> on the primary.
     Do not start any servers yet.
    </para>
____________________________________________________________________________-->
    <para>
     如果使用链接模式并且有流复制（见<xref linkend="streaming-replication"/>）或者日志
     传送（见<xref linkend="warm-standby"/>）后备服务器，你可以遵照下面的
     步骤对它们进行快速的升级。你将不用在这些后备服务器上运行
     <application>pg_upgrade</application>，而是在主服务器上运行<application>rsync</application>。
     到这里还不要启动任何服务器。
    </para>

<!--==========================orignal english content==========================
    <para>
     If you did <emphasis>not</emphasis> use link mode, do not have or do not
     want to use <application>rsync</application>, or want an easier solution, skip
     the instructions in this section and simply recreate the standby
     servers once <application>pg_upgrade</application> completes and the new primary
     is running.
    </para>
____________________________________________________________________________-->
    <para>
     如果你<emphasis>没有</emphasis>使用链接模式、没有或不想使用<application>rsync</application>或者想用一种更容易的解决方案，请跳过这一节中的过程并且在<application>pg_upgrade</application>完成并且新的主集簇开始运行后重建后备服务器。
    </para>

    <substeps>

     <step>
<!--==========================orignal english content==========================
      <title>Install the new PostgreSQL binaries on standby servers</title>
____________________________________________________________________________-->
      <title>在后备服务器上安装新的 PostgreSQL 二进制文件</title>

<!--==========================orignal english content==========================
      <para>
       Make sure the new binaries and support files are installed on all
       standby servers.
      </para>
____________________________________________________________________________-->
      <para>
       确保新的二进制和支持文件被安装在所有后备服务器上。
      </para>
     </step>

     <step>
<!--==========================orignal english content==========================
      <title>Make sure the new standby data directories do <emphasis>not</emphasis> exist</title>
____________________________________________________________________________-->
      <title>确保<emphasis>不</emphasis>存在新的后备机数据目录</title>

<!--==========================orignal english content==========================
      <para>
       Make sure the new standby data directories do <emphasis>not</emphasis>
       exist or are empty.  If <application>initdb</application> was run, delete
       the standby servers' new data directories.
      </para>
____________________________________________________________________________-->
      <para>
       确保新的后备机数据目录<emphasis>不</emphasis>存在或者为空。如果
       运行过<application>initdb</application>，请删除后备服务器的新数据目录。
      </para>
     </step>

     <step>
<!--==========================orignal english content==========================
      <title>Install extension shared object files</title>
____________________________________________________________________________-->
      <title>安装扩展共享对象文件</title>

<!--==========================orignal english content==========================
      <para>
       Install the same extension shared object files on the new standbys
       that you installed in the new primary cluster.
      </para>
____________________________________________________________________________-->
      <para>
       在新的后备机上安装和新的主集簇中相同的扩展共享对象文件。
      </para>
     </step>

     <step>
<!--==========================orignal english content==========================
      <title>Stop standby servers</title>
____________________________________________________________________________-->
      <title>停止后备服务器</title>

<!--==========================orignal english content==========================
      <para>
       If the standby servers are still running, stop them now using the
       above instructions.
      </para>
____________________________________________________________________________-->
      <para>
       如果后备服务器仍在运行，现在使用上述的指令停止它们。
      </para>
     </step>

     <step>
<!--==========================orignal english content==========================
      <title>Save configuration files</title>
____________________________________________________________________________-->
      <title>保存配置文件</title>

<!--==========================orignal english content==========================
      <para>
       Save any configuration files from the old standbys' configuration
       directories you need to keep, e.g.,  <filename>postgresql.conf</filename>
       (and any files included by it), <filename>postgresql.auto.conf</filename>,
       <literal>pg_hba.conf</literal>, because these will be overwritten
       or removed in the next step.
      </para>
____________________________________________________________________________-->
      <para>
       从旧后备机的配置目录保存任何需要保留的配置文件，例如
       <filename>postgresql.conf</filename>（以及它包含的任何文件）、
       <filename>postgresql.auto.conf</filename>、<literal>pg_hba.conf</literal>，
       因为这些文件在下一步中会被重写或者移除。
      </para>
     </step>

     <step>
<!--==========================orignal english content==========================
      <title>Run <application>rsync</application></title>
____________________________________________________________________________-->
      <title>运行<application>rsync</application></title>

<!--==========================orignal english content==========================
      <para>
       When using link mode, standby servers can be quickly upgraded using
       <application>rsync</application>.  To accomplish this, from a directory on
       the primary server that is above the old and new database cluster
       directories, run this on the <emphasis>primary</emphasis> for each standby
       server:

<programlisting>
rsync -&minus;archive -&minus;delete -&minus;hard-links -&minus;size-only -&minus;no-inc-recursive old_cluster new_cluster remote_dir
</programlisting>

       where <option>old_cluster</option> and <option>new_cluster</option> are relative
       to the current directory on the primary, and <option>remote_dir</option>
       is <emphasis>above</emphasis> the old and new cluster directories
       on the standby.  The directory structure under the specified
       directories on the primary and standbys must match.  Consult the
       <application>rsync</application> manual page for details on specifying the
       remote directory, e.g.,

<programlisting>
rsync -&minus;archive -&minus;delete -&minus;hard-links -&minus;size-only -&minus;no-inc-recursive /opt/PostgreSQL/9.5 \
      /opt/PostgreSQL/9.6 standby.example.com:/opt/PostgreSQL
</programlisting>

       You can verify what the command will do using
       <application>rsync</application>'s <option>-&minus;dry-run</option> option.  While
       <application>rsync</application> must be run on the primary for at least one
       standby, it is possible to run <application>rsync</application> on an upgraded
       standby to upgrade other standbys, as long as the upgraded standby
       has not been started.
      </para>
____________________________________________________________________________-->
      <para>
       在使用链接模式时，后备服务器可以使用<application>rsync</application>快速升级。为了实现这一点，在<emphasis>主</emphasis>服务器上一个高于新旧数据库集簇目录的目录中为每个后备服务器运行这个命令：

<programlisting>
rsync --archive --delete --hard-links --size-only --no-inc-recursive old_cluster new_cluster remote_dir
</programlisting>

       其中<option>old_cluster</option>和<option>new_cluster</option>是相对于主服务器上的当前目录的，而<option>remote_dir</option>是后备服务器上<emphasis>高于</emphasis>新旧集簇目录的一个目录。在主服务器和后备服务器上指定目录之下的目录结构必须匹配。指定远程目录的详细情况请参考<application>rsync</application>的手册，例如：

<programlisting>
rsync --archive --delete --hard-links --size-only --no-inc-recursive /opt/PostgreSQL/9.5 \
      /opt/PostgreSQL/9.6 standby.example.com:/opt/PostgreSQL
</programlisting>

       可以使用<application>rsync</application>的<option>--dry-run</option>选项验证该命令将做的事情。虽然在主服务器上必须为至少一台后备运行<application>rsync</application>，可以在一台已经升级过的后备服务器上运行<application>rsync</application>来升级其他的后备服务器，只要已升级的后备服务器还没有被启动。
      </para>

<!--==========================orignal english content==========================
      <para>
       What this does is to record the links created by
       <application>pg_upgrade</application>'s link mode that connect files in the
       old and new clusters on the primary server.  It then finds matching
       files in the standby's old cluster and creates links for them in the
       standby's new cluster.  Files that were not linked on the primary
       are copied from the primary to the standby.  (They are usually
       small.)  This provides rapid standby upgrades.  Unfortunately,
       <application>rsync</application> needlessly copies files associated with
       temporary and unlogged tables because these files don't normally
       exist on standby servers.
      </para>
____________________________________________________________________________-->
      <para>
       这个命令所做的事情是记录由<application>pg_upgrade</application>的链接模式创建的链接，它们连接主服务器上新旧集簇中的文件。该命令接下来在后备服务器的旧集簇中寻找匹配的文件并且为它们在该后备的新集簇中创建链接。主服务器上没有被链接的文件会被从主服务器拷贝到后备服务器（通常都很小）。这提供了快速的后备服务器升级。不幸地是，<application>rsync</application>会不必要地拷贝与临时表和不做日志表相关的文件，因为通常在后备服务器上不存在这些文件。
      </para>

<!--==========================orignal english content==========================
      <para>
       If you have tablespaces, you will need to run a similar
       <application>rsync</application> command for each tablespace directory, e.g.:

<programlisting>
rsync -&minus;archive -&minus;delete -&minus;hard-links -&minus;size-only -&minus;no-inc-recursive /vol1/pg_tblsp/PG_9.5_201510051 \
      /vol1/pg_tblsp/PG_9.6_201608131 standby.example.com:/vol1/pg_tblsp
</programlisting>

       If you have relocated <filename>pg_wal</filename> outside the data
       directories, <application>rsync</application> must be run on those directories
       too.
      </para>
____________________________________________________________________________-->
      <para>
       如果有表空间，你将需要为每个表空间目录运行一个类似的<application>rsync</application>命令，例如：

<programlisting>
rsync --archive --delete --hard-links --size-only --no-inc-recursive /vol1/pg_tblsp/PG_9.5_201510051 \
      /vol1/pg_tblsp/PG_9.6_201608131 standby.example.com:/vol1/pg_tblsp
</programlisting>

       如果你已经把<filename>pg_wal</filename>放在数据目录外面，也必须在那些目录上运行<application>rsync</application>。
      </para>
     </step>

     <step>
<!--==========================orignal english content==========================
      <title>Configure streaming replication and log-shipping standby servers</title>
____________________________________________________________________________-->
      <title>配置流复制和日志传送后备服务器</title>

<!--==========================orignal english content==========================
      <para>
       Configure the servers for log shipping.  (You do not need to run
       <function>pg_start_backup()</function> and <function>pg_stop_backup()</function>
       or take a file system backup as the standbys are still synchronized
       with the primary.)
      </para>
____________________________________________________________________________-->
      <para>
       为日志传送配置服务器（不需要运行<function>pg_start_backup()</function>
       以及<function>pg_stop_backup()</function>或者做文件系统备份，因为从属机
       仍在与主机同步）。
      </para>
     </step>

    </substeps>

   </step>

   <step>
<!--==========================orignal english content==========================
    <title>Restore <filename>pg_hba.conf</filename></title>
____________________________________________________________________________-->
    <title>恢复 <filename>pg_hba.conf</filename></title>

<!--==========================orignal english content==========================
    <para>
     If you modified <filename>pg_hba.conf</filename>, restore its original settings.
     It might also be necessary to adjust other configuration files in the new
     cluster to match the old cluster, e.g., <filename>postgresql.conf</filename>
     (and any files included by it), <filename>postgresql.auto.conf</filename>.
    </para>
____________________________________________________________________________-->
    <para>
     如果你修改了<filename>pg_hba.conf</filename>，则要将其恢复到原始的设置。
     也可能需要调整新集簇中的其他配置文件来匹配旧集簇，例如
     <filename>postgresql.conf</filename>（以及它包含的任何文件）和
     <filename>postgresql.auto.conf</filename>。
    </para>
   </step>

   <step>
<!--==========================orignal english content==========================
    <title>Start the new server</title>
____________________________________________________________________________-->
    <title>启动新服务器</title>

<!--==========================orignal english content==========================
    <para>
     The new server can now be safely started, and then any
     <application>rsync</application>'ed standby servers.
    </para>
____________________________________________________________________________-->
    <para>
     现在可以安全地启动新的服务器，并且可以接着启动任何
     <application>rsync</application>过的后备服务器。
    </para>
   </step>

   <step>
<!--==========================orignal english content==========================
    <title>Post-upgrade processing</title>
____________________________________________________________________________-->
    <title>升级后处理</title>

<!--==========================orignal english content==========================
    <para>
     If any post-upgrade processing is required, pg_upgrade will issue
     warnings as it completes. It will also generate script files that must
     be run by the administrator. The script files will connect to each
     database that needs post-upgrade processing. Each script should be
     run using:

<programlisting>
psql -&minus;username=postgres -&minus;file=script.sql postgres
</programlisting>

     The scripts can be run in any order and can be deleted once they have
     been run.
    </para>
____________________________________________________________________________-->
    <para>
     如果需要做任何升级后处理，pg_upgrade 将在完成后发出警告。它也将
     生成必须由管理员运行的脚本文件。这些脚本文件将连接到每一个需要做
     升级后处理的数据库。每一个脚本应该这样运行：

<programlisting>
psql --username=postgres --file=script.sql postgres
</programlisting>

     这些脚本可以以任何顺序运行并且在运行之后立即删除。
    </para>

    <caution>
<!--==========================orignal english content==========================
    <para>
     In general it is unsafe to access tables referenced in rebuild scripts
     until the rebuild scripts have run to completion; doing so could yield
     incorrect results or poor performance. Tables not referenced in rebuild
     scripts can be accessed immediately.
    </para>
____________________________________________________________________________-->
    <para>
     通常在重建脚本运行完成之前访问重建脚本中引用的表是不安全的，这样做
     可能会得到不正确的结果或者很差的性能。没有在重建脚本中引用的表可以
     随时被访问。
    </para>
    </caution>
   </step>

   <step>
<!--==========================orignal english content==========================
    <title>Statistics</title>
____________________________________________________________________________-->
    <title>统计信息</title>

<!--==========================orignal english content==========================
    <para>
     Because optimizer statistics are not transferred by <command>pg_upgrade</command>, you will
     be instructed to run a command to regenerate that information at the end
     of the upgrade.  You might need to set connection parameters to
     match your new cluster.
    </para>
____________________________________________________________________________-->
    <para>
     由于<command>pg_upgrade</command>并未传输优化器统计信息，在升级的尾声
     你将被指示运行一个命令来生成这些信息。你可能需要设置连接参数来匹配你
     的新集簇。
    </para>
   </step>

   <step>
<!--==========================orignal english content==========================
    <title>Delete old cluster</title>
____________________________________________________________________________-->
    <title>删除旧集簇</title>

<!--==========================orignal english content==========================
    <para>
     Once you are satisfied with the upgrade, you can delete the old
     cluster's data directories by running the script mentioned when
     <command>pg_upgrade</command> completes. (Automatic deletion is not
     possible if you have user-defined tablespaces inside the old data
     directory.)  You can also delete the old installation directories
     (e.g., <filename>bin</filename>, <filename>share</filename>).
    </para>
____________________________________________________________________________-->
    <para>
     一旦你对升级表示满意，你就可以通过运行
     <command>pg_upgrade</command>完成时提到的脚本来删除旧集簇的
     数据目录（如果在旧数据目录中有用户定义的表空间就不可能实现自动删除）。
     你也可以删除旧安装目录（例如<filename>bin</filename>、<filename>share</filename>）。
    </para>
   </step>

   <step id="pgupgrade-step-revert" performance="optional">
<!--==========================orignal english content==========================
    <title>Reverting to old cluster</title>
____________________________________________________________________________-->
    <title>恢复到旧集簇</title>

<!--==========================orignal english content==========================
    <para>
     If, after running <command>pg_upgrade</command>, you wish to revert to the old cluster,
     there are several options:

     <itemizedlist>
      <listitem>
       <para>
        If the <option>-&minus;check</option> option was used, the old cluster
        was unmodified;  it can be restarted.
       </para>
      </listitem>

      <listitem>
       <para>
        If the <option>-&minus;link</option> option was <emphasis>not</emphasis>
        used, the old cluster was unmodified;  it can be restarted.
       </para>
      </listitem>

      <listitem>
       <para>
        If the <option>-&minus;link</option> option was used, the data
        files might be shared between the old and new cluster:

        <itemizedlist>
         <listitem>
          <para>
           If <command>pg_upgrade</command> aborted before linking started,
           the old cluster was unmodified;  it can be restarted.
          </para>
         </listitem>

         <listitem>
          <para>
           If you did <emphasis>not</emphasis> start the new cluster, the old
           cluster was unmodified except that, when linking started, a
           <literal>.old</literal> suffix was appended to
           <filename>$PGDATA/global/pg_control</filename>.  To reuse the old
           cluster, remove the <filename>.old</filename> suffix from
           <filename>$PGDATA/global/pg_control</filename>; you can then restart
           the old cluster.
          </para>
         </listitem>

         <listitem>
          <para>
           If you did start the new cluster, it has written to shared files
           and it is unsafe to use the old cluster.  The old cluster will
           need to be restored from backup in this case.
          </para>
         </listitem>

        </itemizedlist></para>
      </listitem>
     </itemizedlist></para>
____________________________________________________________________________-->
    <para>
     在运行<command>pg_upgrade</command>之后，如果你希望恢复到
     旧集簇，有几个选项：

     <itemizedlist>
      <listitem>
       <para>
        如果使用了 <option>--check</option> 选项, 则旧集群没有被修改；它可以被重新启动。
       </para>
      </listitem>

      <listitem>
       <para>
        如果 <option>--link</option> 选项 <emphasis>没有</emphasis>被使用, 旧集群没有被修改；它可以被重新启动。
       </para>
      </listitem>

      <listitem>
       <para>
        如果使用了<option>--link</option> 选项, 数据文件可能在新旧群集之间共享:

        <itemizedlist>
         <listitem>
          <para>
           如果<command>pg_upgrade</command>在链接启动之前中止，旧群集没有被修改，它可以重新启动。
          </para>
         </listitem>

         <listitem>
          <para>
           如果你<emphasis>没有</emphasis>启动新集群，旧集群没有被修改，当链接启动时，一个<literal>.old</literal>后缀会附加到<filename>$PGDATA/global/pg_control</filename>。
           如果要重用旧集群，从<filename>$PGDATA/global/pg_control</filename>移除<filename>.old</filename>后缀；你就可以重启旧集群。
          </para>
         </listitem>

         <listitem>
          <para>
           如果你已经启动新群集，它已经写入了共享文件，并且使用旧群集会不安全。这种情况下，需要从备份中还原旧群集。
          </para>
         </listitem>

        </itemizedlist>
       </para>
      </listitem>
     </itemizedlist>
    </para>
   </step>
  </procedure>

 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Notes</title>
____________________________________________________________________________-->
  <title>注解</title>

<!--==========================orignal english content==========================
  <para>
   <application>pg_upgrade</application> creates various working files, such
   as schema dumps, in the current working directory.  For security, be sure
   that that directory is not readable or writable by any other users.
  </para>
____________________________________________________________________________-->
  <para>
   <application>pg_upgrade</application>创建不同的工作文件，如模式转储，在当前工作目录中。为了安全，请确保该目录不可被任何其他用户读取或者写入。
  </para>

<!--==========================orignal english content==========================
  <para>
   <application>pg_upgrade</application> launches short-lived postmasters in
   the old and new data directories.  Temporary Unix socket files for
   communication with these postmasters are, by default, made in the current
   working directory.  In some situations the path name for the current
   directory might be too long to be a valid socket name.  In that case you
   can use the <option>-s</option> option to put the socket files in some
   directory with a shorter path name.  For security, be sure that that
   directory is not readable or writable by any other users.
   (This is not supported on Windows.)
  </para>
____________________________________________________________________________-->
  <para>
   <application>pg_upgrade</application>在新旧数据目录中启动短期的postmasters。临时 Unix 套接字文件用于与这些postmasters通信，默认情况下，在当前工作目录中进行。
   在某些情况下，当前目录的路径名称可能太长，无法成为有效的套接字名称。这种情况下你可以使用<option>-s</option>选项将套接字文件放在某些具有较短路径名称的目录中。
   为了安全原因，请确保该目录不可被任何其他用户读取或者写入。（这在 Windows 上不受支持。）
  </para>

<!--==========================orignal english content==========================
  <para>
   All failure, rebuild, and reindex cases will be reported by
   <application>pg_upgrade</application> if they affect your installation;
   post-upgrade scripts to rebuild tables and indexes will be
   generated automatically.  If you are trying to automate the upgrade
   of many clusters, you should find that clusters with identical database
   schemas require the same post-upgrade steps for all cluster upgrades;
   this is because the post-upgrade steps are based on the database
   schemas, and not user data.
  </para>
____________________________________________________________________________-->
  <para>
   如果失败、重建和重新索引会影响你的安装，<application>pg_upgrade</application>
   将会报告这些情况。用来重建表和索引的升级后脚本将会自动被建立。
   如果你正在尝试自动升级很多集簇，你应该发现具有相同数据库模式的集簇
   对所有集簇升级都要求同样的升级后步骤，这是因为升级后步骤是基于数据
   库模式而不是用户数据。
  </para>

<!--==========================orignal english content==========================
  <para>
   For deployment testing, create a schema-only copy of the old cluster,
   insert dummy data, and upgrade that.
  </para>
____________________________________________________________________________-->
  <para>
   对于部署测试，创建一个只有模式的旧集簇副本，在其中插入假数据并且升级。
  </para>

<!--==========================orignal english content==========================
  <para>
   <application>pg_upgrade</application> does not support upgrading of databases
   containing table columns using these <type>reg*</type> OID-referencing system data types:
   <simplelist>
    <member><type>regcollation</type></member>
    <member><type>regconfig</type></member>
    <member><type>regdictionary</type></member>
    <member><type>regnamespace</type></member>
    <member><type>regoper</type></member>
    <member><type>regoperator</type></member>
    <member><type>regproc</type></member>
    <member><type>regprocedure</type></member>
   </simplelist>
   (<type>regclass</type>, <type>regrole</type>, and <type>regtype</type> can be upgraded.)
  </para>
____________________________________________________________________________-->
  <para>
   <application>pg_upgrade</application>不支持包含使用这些<type>reg*</type> OID-引用 系统数据类型的表列的数据库的升级：
   <simplelist>
    <member><type>regcollation</type></member>
    <member><type>regconfig</type></member>
    <member><type>regdictionary</type></member>
    <member><type>regnamespace</type></member>
    <member><type>regoper</type></member>
    <member><type>regoperator</type></member>
    <member><type>regproc</type></member>
    <member><type>regprocedure</type></member>
   </simplelist>
   (<type>regclass</type>, <type>regrole</type>, and <type>regtype</type> can be upgraded.)
  </para>

<!--==========================orignal english content==========================
  <para>
   If you are upgrading a pre-<productname>PostgreSQL</productname> 9.2 cluster
   that uses a configuration-file-only directory, you must pass the
   real data directory location to <application>pg_upgrade</application>, and
   pass the configuration directory location to the server, e.g.,
   <literal>-d /real-data-directory -o '-D /configuration-directory'</literal>.
  </para>
____________________________________________________________________________-->
  <para>
   如果你在升级一个<productname>PostgreSQL</productname> 9.2 之前的集簇，并且
   它使用一个只有配置文件的目录，你必须向<application>pg_upgrade</application>
   传递真正的数据目录位置，并且把配置目录位置传递给服务器，例如
   <literal>-d /real-data-directory -o '-D /configuration-directory'</literal>。
  </para>

<!--==========================orignal english content==========================
  <para>
   If using a pre-9.1 old server that is using a non-default Unix-domain
   socket directory or a default that differs from the default of the
   new cluster, set <envar>PGHOST</envar> to point to the old server's socket
   location.  (This is not relevant on Windows.)
  </para>
____________________________________________________________________________-->
  <para>
   如果正在使用的一个 9.1 之前的旧服务器用的是一个非默认Unix 域套接字目录
   或者使用的默认值不同于新集簇的默认值，请把<envar>PGHOST</envar>设置为
   指向旧服务器的套接字位置（这与 Windows 无关）。
  </para>

<!--==========================orignal english content==========================
  <para>
   If you want to use link mode and you do not want your old cluster
   to be modified when the new cluster is started, consider using the clone mode.
   If that is not available, make a copy of the
   old cluster and upgrade that in link mode. To make a valid copy
   of the old cluster, use <command>rsync</command> to create a dirty
   copy of the old cluster while the server is running, then shut down
   the old server and run <command>rsync -&minus;checksum</command> again to update the
   copy with any changes to make it consistent.  (<option>-&minus;checksum</option>
   is necessary because <command>rsync</command> only has file modification-time
   granularity of one second.)  You might want to exclude some
   files, e.g., <filename>postmaster.pid</filename>, as documented in <xref
   linkend="backup-lowlevel-base-backup"/>.  If your file system supports
   file system snapshots or copy-on-write file copies, you can use that
   to make a backup of the old cluster and tablespaces, though the snapshot
   and copies must be created simultaneously or while the database server
   is down.
  </para>
____________________________________________________________________________-->
  <para>
   如果你想要使用链接模式并且你不想让你的旧集簇在新集簇启动时被修改，考虑使用克隆模式。
   如果(克隆模式)不可用，可以复制一份旧集簇并且在副本上以链接模式进行升级。要创建旧集簇的一
   份合法拷贝，可以在服务器运行时使用<command>rsync</command>创建旧集簇的
   一份脏拷贝，然后关闭旧服务器并且再次运行<command>rsync --checksum</command>
   把更改更新到该拷贝以让其一致（<option>--checksum</option>是必要的，因为
   <command>rsync</command>在判断文件修改时间的更改时的精度只能到秒级）。如
   <xref linkend="backup-lowlevel-base-backup"/>中所述，你可能想要排除
   一些文件，例如<filename>postmaster.pid</filename>。如果你的文件系统支持文
   件系统快照或者 copy-on-write 文件副本，你可以使用它们来创建旧集簇和
   表空间的一个备份，不过快照和副本必须被同时创建或者在数据库服务器关闭
   期间被创建。
  </para>

 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>See Also</title>
____________________________________________________________________________-->
  <title>另见</title>

  <simplelist type="inline">
   <member><xref linkend="app-initdb"/></member>
   <member><xref linkend="app-pg-ctl"/></member>
   <member><xref linkend="app-pgdump"/></member>
   <member><xref linkend="app-postgres"/></member>
  </simplelist>
 </refsect1>
</refentry>
