<!--
doc/src/sgml/ref/create_domain.sgml
PostgreSQL documentation
-->

<refentry id="SQL-CREATEDOMAIN">
 <indexterm zone="sql-createdomain">
  <primary>CREATE DOMAIN</primary>
 </indexterm>

 <refmeta>
  <refentrytitle>CREATE DOMAIN</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE DOMAIN</refname>
  <refpurpose>定义一个新的域</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
CREATE DOMAIN <replaceable class="parameter">name</replaceable> [ AS ] <replaceable class="parameter">data_type</replaceable>
    [ COLLATE <replaceable>collation</replaceable> ]
    [ DEFAULT <replaceable>expression</replaceable> ]
    [ <replaceable class="PARAMETER">constraint</replaceable> [ ... ] ]

<phrase>其中 <replaceable class="PARAMETER">constraint</replaceable> 是：</phrase>

[ CONSTRAINT <replaceable class="PARAMETER">constraint_name</replaceable> ]
{ NOT NULL | NULL | CHECK (<replaceable class="PARAMETER">expression</replaceable>) }
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <command>CREATE DOMAIN</command>创建一个新的域。域
   本质上是一种带有可选约束（在允许的值集合上的限制）的数据类型。
   定义一个域的用户将成为它的拥有者。
  </para>

  <para>
   如果给定一个模式名（例如<literal>CREATE DOMAIN
   myschema.mydomain ...</>），那么域将被创建在该指定的模式中。
   否则它会被创建在当前模式中。域的名称在其模式中的类型和域之间
   必须保持唯一。
  </para>

  <para>
   域主要被用于把字段上的常用约束抽象到一个单一的位置以便维护。例如，
   几个表可能都包含电子邮件地址列，而且都要求相同的 CHECK 约束来验证
   地址的语法。可以为此定义一个域，而不是在每个表上都单独设置一个约束。
  </para>

  <para>
   要创建一个域，你必须在其底层类型上拥有<literal>USAGE</literal>特权。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">name</replaceable></term>
      <listitem>
       <para>
        要被创建的域的名称（可以被模式限定）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">data_type</replaceable></term>
      <listitem>
       <para>
        域的底层数据类型。可以包括数组指示符。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable>collation</replaceable></term>
      <listitem>
       <para>
        用于该域的可选的排序规则。如果没有指定排序规则，将使用底层
        数据类型的默认排序规则。如果指定了<literal>COLLATE</>，
        底层类型必须是可排序的。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DEFAULT <replaceable>expression</replaceable></literal></term>

      <listitem>
       <para>
        <literal>DEFAULT</>子句为该域数据类型的列指定一个默认值。
        该值是任何没有变量的表达式（但不允许子查询）。默认值表达式
        的数据类型必须匹配域的数据类型。如果没有指定默认值，那么
        默认值就是空值。
       </para>

       <para>
        默认值表达式将被用在任何没有指定列值的插入操作中。如果为一个
        特定列定义了默认值，它会覆盖与域相关的默认值。继而，域默认值
        会覆盖任何与底层数据类型相关的默认值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CONSTRAINT <replaceable class="PARAMETER">constraint_name</replaceable></literal></term>
      <listitem>
       <para>
        一个约束的名称（可选）。如果没有指定，系统会生成一个名称。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NOT NULL</></term>
      <listitem>
       <para>
        这个域的值通常不能为空值。不过，如果带有这种约束的域
        被赋值了一个已经成为空值的相匹配的域类型，仍有可能让
        它接受空值，例如通过 LEFT OUTER JOIN 或者
        <command>INSERT INTO tab (domcol) VALUES ((SELECT domcol FROM
        tab WHERE false))</command>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NULL</></term>
      <listitem>
       <para>
        这个域的值允许为空值。这是默认值。
       </para>

       <para>
        这个子句只是为了与非标准 SQL 数据库相兼容而设计。在新的
        应用中不鼓励使用它。
       </para>
      </listitem>
     </varlistentry>

   <varlistentry>
    <term><literal>CHECK (<replaceable class="PARAMETER">expression</replaceable>)</literal></term>
    <listitem>
     <para><literal>CHECK</>子句指定该域的值必须满足的完整性
     约束或者测试。每一个约束必须是一个产生布尔结果的表达式。
     它应该使用关键词<literal>VALUE</>来引用要被测试的值。
     </para>

     <para>
      当前，<literal>CHECK</literal>表达式不能包含子查询，也不能
      引用除<literal>VALUE</>之外的其他变量。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>示例</title>

  <para>
   这个例子创建<type>us_postal_code</type>数据类型并且把它用在
   一个表定义中。一个正则表达式测试被用来验证值是否看起来像一个
   合法的 US 邮政编码：

<programlisting>
CREATE DOMAIN us_postal_code AS TEXT
CHECK(
   VALUE ~ '^\d{5}$'
OR VALUE ~ '^\d{5}-\d{4}$'
);

CREATE TABLE us_snail_addy (
  address_id SERIAL PRIMARY KEY,
  street1 TEXT NOT NULL,
  street2 TEXT,
  street3 TEXT,
  city TEXT NOT NULL,
  postal us_postal_code NOT NULL
);
</programlisting></para>
 </refsect1>

 <refsect1 id="SQL-CREATEDOMAIN-compatibility">
  <title>兼容性</title>

  <para>
   命令<command>CREATE DOMAIN</command>符合 SQL 标准。
  </para>
 </refsect1>

 <refsect1 id="SQL-CREATEDOMAIN-see-also">
  <title>另见</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alterdomain"></member>
   <member><xref linkend="sql-dropdomain"></member>
  </simplelist>
 </refsect1>

</refentry>
