<!--
doc/src/sgml/ref/create_view.sgml
PostgreSQL documentation
-->

<refentry id="SQL-CREATEVIEW">
 <indexterm zone="sql-createview">
  <primary>CREATE VIEW</primary>
 </indexterm>
 <refmeta>
  <refentrytitle>CREATE VIEW</refentrytitle>
  <manvolnum>7</manvolnum>
  <!--
<refmiscinfo>SQL - Language Statements</refmiscinfo>
-->
<refmiscinfo>SQL - 语句</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE VIEW</refname>
  <!--
  <refpurpose>define a new view</refpurpose>
  -->
  <refpurpose>定义一个新视图</refpurpose>
 </refnamediv>


 <refsynopsisdiv>
<synopsis>
CREATE [ OR REPLACE ] [ TEMP | TEMPORARY ] [ RECURSIVE ] VIEW <replaceable class="PARAMETER">name</replaceable> [ ( <replaceable class="PARAMETER">column_name</replaceable> [, ...] ) ]
    [ WITH ( <replaceable class="PARAMETER">view_option_name</replaceable> [= <replaceable class="PARAMETER">view_option_value</replaceable>] [, ... ] ) ]
    AS <replaceable class="PARAMETER">query</replaceable>
    [ WITH [ CASCADED | LOCAL ] CHECK OPTION ]
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <command>CREATE VIEW</command> defines a view of a query.  The view
   is not physically materialized. Instead, the query is run every time
   the view is referenced in a query.
  </para>
-->
<para>
<command>CREATE VIEW</command>定义一个查询的视图。
这个视图不是物理上实际存在的，并且在该视图每次被引用的时候都会运行一次查询。
</para>

  <!--
<para>
   <command>CREATE OR REPLACE VIEW</command> is similar, but if a view
   of the same name already exists, it is replaced.  The new query must
   generate the same columns that were generated by the existing view query
   (that is, the same column names in the same order and with the same data
   types), but it may add additional columns to the end of the list.  The
   calculations giving rise to the output columns may be completely different.
  </para>
-->
<para>
<command>CREATE OR REPLACE VIEW</command>是类似的，不过如果一个同名的视图已经存在，
那么将替换它。新查询必须生成与现有视图查询生成的字段相同的字段（也就是，
相同的字段名字，相同的顺序和相同的数据类型），但是可能添加额外的字段到列表的结尾。
该计算导致输出字段可能完全不同。
</para>

  <!--
<para>
   If a schema name is given (for example, <literal>CREATE VIEW
   myschema.myview ...</>) then the view is created in the specified
   schema.  Otherwise it is created in the current schema.  Temporary
   views exist in a special schema, so a schema name cannot be given
   when creating a temporary view. The name of the view must be
   distinct from the name of any other view, table, sequence, index or foreign table
   in the same schema.
  </para>
-->
<para>
如果给出了一个模式名(比如<literal>CREATE VIEW myschema.myview ...</>)，
那么该视图将在指定的模式中创建，否则将在当前模式中创建。
临时视图存在于一个特殊的模式里，所以创建临时视图的时候，不能给出模式名。
新视图名字必需和同一模式中任何其它视图、表、序列、索引或外部表的名字不同。
</para>
 </refsect1>

 <refsect1>
  <!--
<title>Parameters</title>
-->
<title>参数</title>

  <variablelist>
   <varlistentry>
    <!--
<term><literal>TEMPORARY</> or <literal>TEMP</></term>
-->
<term><literal>TEMPORARY</> 或 <literal>TEMP</></term>
    <listitem>
     <!--
<para>
      If specified, the view is created as a temporary view.
      Temporary views are automatically dropped at the end of the
      current session.  Existing
      permanent relations with the same name are not visible to the
      current session while the temporary view exists, unless they are
      referenced with schema-qualified names.
     </para>
-->
<para>
如果声明了这个子句，那么视图就以临时视图的方式创建。
临时视图在当前会话结束的时候将被自动删除。只要存在临时视图，
已有的同名永久关系表将对当前会话不可见，除非用带模式修饰的名字引用它们。
</para>

     <!--
<para>
      If any of the tables referenced by the view are temporary,
      the view is created as a temporary view (whether
      <literal>TEMPORARY</literal> is specified or not).
     </para>
-->
<para>
如果视图引用的任何基础表是临时的，那么视图将被创建为临时的
(不管是否声明了<literal>TEMPORARY</literal>)。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>RECURSIVE</></term>
    <listitem>
     <!--
<para>
      Creates a recursive view.  The syntax
<synopsis>
CREATE RECURSIVE VIEW <replaceable>name</> (<replaceable>columns</>) AS SELECT <replaceable>...</>;
</synopsis>
      is equivalent to
<synopsis>
CREATE VIEW <replaceable>name</> AS WITH RECURSIVE <replaceable>name</> (<replaceable>columns</>) AS (SELECT <replaceable>...</>) SELECT <replaceable>columns</> FROM <replaceable>name</>;
</synopsis>
      A view column list must be specified for a recursive view.
     </para>
-->
<para>
创建一个递归的视图。语法
<synopsis>
CREATE RECURSIVE VIEW <replaceable>name</> (<replaceable>columns</>) AS SELECT <replaceable>...</>;
</synopsis>
等同于
<synopsis>
CREATE VIEW <replaceable>name</> AS WITH RECURSIVE <replaceable>name</> (<replaceable>columns</>) AS (SELECT <replaceable>...</>) SELECT <replaceable>columns</> FROM <replaceable>name</>;
</synopsis>
必须为一个递归的视图指定一个视图字段列表。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">name</replaceable></term>
    <listitem>
     <!--
<para>
      The name (optionally schema-qualified) of a view to be created.
     </para>
-->
<para>
所要创建的视图名称(可以有模式修饰)。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">column_name</replaceable></term>
    <listitem>
     <!--
<para>
      An optional list of names to be used for columns of the view.
      If not given, the column names are deduced from the query.
     </para>
-->
<para>
一个可选的名字列表，用作视图的字段名。如果没有给出，字段名取自查询。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>WITH ( <replaceable class="PARAMETER">view_option_name</replaceable> [= <replaceable class="PARAMETER">view_option_value</replaceable>] [, ... ] )</literal></term>
    <listitem>

     <para>
<!-- 
      This clause specifies optional parameters for a view; the following
      parameters are supported: 
-->
      该子句为视图指定选项参数；支持下列参数：

      <variablelist>
       <varlistentry>
        <term><literal>check_option</literal> (<type>string</type>)</term>
        <listitem>
<!-- 
         <para>
          This parameter may be either <literal>local</> or
          <literal>cascaded</>, and is equivalent to specifying
          <literal>WITH [ CASCADED | LOCAL ] CHECK OPTION</> (see below).
          This option can be changed on existing views using <xref
          linkend="sql-alterview">.
         </para>
-->
<para>
这个参数可以是<literal>local</>或<literal>cascaded</>，相当于声明了
<literal>WITH [ CASCADED | LOCAL ] CHECK OPTION</>（见下文）。
可以使用<xref linkend="sql-alterview">在现有的视图中改变这个选项。
</para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>security_barrier</literal> (<type>string</type>)</term>
        <listitem>
<!-- 
         <para>
          This should be used if the view is intended to provide row-level
          security.  See <xref linkend="rules-privileges"> for full details.
         </para>
-->
<para>
如果视图打算提供行级别的安全就应该使用这个选项。参阅
<xref linkend="rules-privileges">获取全部信息。
</para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>

   <varlistentry>
    <term><replaceable class="parameter">query</replaceable></term>
    <listitem>
     <!--
<para>
      A <xref linkend="sql-select"> or
      <xref linkend="sql-values"> command
      which will provide the columns and rows of the view.
     </para>
-->
<para>
一个将为视图提供行和列的<xref linkend="sql-select">
或<xref linkend="sql-values">语句。
</para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term><literal>WITH [ CASCADED | LOCAL ] CHECK OPTION</literal></term>
    <listitem>
     <para>
      <indexterm zone="SQL-CREATEVIEW">
       <primary>CHECK OPTION</primary>
      </indexterm>
      <indexterm zone="SQL-CREATEVIEW">
       <primary>WITH CHECK OPTION</primary>
      </indexterm>
<!-- 
      This option controls the behavior of automatically updatable views.  When
      this option is specified, <command>INSERT</> and <command>UPDATE</>
      commands on the view will be checked to ensure that new rows satisfy the
      view-defining condition (that is, the new rows are checked to ensure that
      they are visible through the view).  If they are not, the update will be
      rejected.  If the <literal>CHECK OPTION</> is not specified,
      <command>INSERT</> and <command>UPDATE</> commands on the view are
      allowed to create rows that are not visible through the view.  The
      following check options are supported:
-->
这个选项控制自动可更新视图的行为。给出时，对视图的<command>INSERT</>
和<command>UPDATE</>都要检查以确保新行满足视图定义的条件（也就是说，
新行应该可以通过视图看到）。如果没有通过检查，更新将被拒绝。
如果没有声明<literal>CHECK OPTION</literal>，将允许对视图的<command>INSERT</>
和<command>UPDATE</>命令创建通过该视图不可见的行。
支持下列的检查选项：

      <variablelist>
       <varlistentry>
        <term><literal>LOCAL</literal></term>
        <listitem>
<!-- 
         <para>
          New rows are only checked against the conditions defined directly in
          the view itself.  Any conditions defined on underlying base views are
          not checked (unless they also specify the <literal>CHECK OPTION</>).
         </para>
-->
<para>
只对视图本身直接定义的条件检查新行。任何底层基础视图定义的条件都不检查
（除非它们也声明了<literal>CHECK OPTION</>）。
</para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><literal>CASCADED</literal></term>
        <listitem>

<!-- 
         <para>
          New rows are checked against the conditions of the view and all
          underlying base views.  If the <literal>CHECK OPTION</> is specified,
          and neither <literal>LOCAL</> nor <literal>CASCADED</> is specified,
          then <literal>CASCADED</> is assumed.
         </para>
-->
<para>
针对该视图和所有底层基础视图的条件检查新行。如果声明了<literal>CHECK OPTION</>，
并且没有声明<literal>LOCAL</>也没有声明<literal>CASCADED</>，
那么假设是<literal>CASCADED</>。
</para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
<!-- 
     <para>
      The <literal>CHECK OPTION</> may not be used with <literal>RECURSIVE</>
      views.
     </para>
-->
<para>
<literal>RECURSIVE</>视图不能使用<literal>CHECK OPTION</>。
</para>
<!-- 
     <para>
      Note that the <literal>CHECK OPTION</> is only supported on views that
      are automatically updatable, and do not have <literal>INSTEAD OF</>
      triggers or <literal>INSTEAD</> rules.  If an automatically updatable
      view is defined on top of a base view that has <literal>INSTEAD OF</>
      triggers, then the <literal>LOCAL CHECK OPTION</> may be used to check
      the conditions on the automatically updatable view, but the conditions
      on the base view with <literal>INSTEAD OF</> triggers will not be
      checked (a cascaded check option will not cascade down to a
      trigger-updatable view, and any check options defined directly on a
      trigger-updatable view will be ignored).  If the view or any of its base
      relations has an <literal>INSTEAD</> rule that causes the
      <command>INSERT</> or <command>UPDATE</> command to be rewritten, then
      all check options will be ignored in the rewritten query, including any
      checks from automatically updatable views defined on top of the relation
      with the <literal>INSTEAD</> rule.
     </para>
-->
<para>
请注意，只在可自动更新、并且没有<literal>INSTEAD OF</>触发器或<literal>INSTEAD</>
规则的视图上支持<literal>CHECK OPTION</>。如果一个可自动更新的视图定义在一个拥有
<literal>INSTEAD OF</>触发器的基础视图的上面，那么会使用<literal>LOCAL CHECK OPTION</>
检查可自动更新视图上的条件，但是不会检查带有<literal>INSTEAD OF</>
触发器的基础视图上的条件（级联的检查选项将不会级联到一个触发器可更新的视图，
并且任何直接定义在触发器可更新视图上的检查选项将被忽略）。
如果该视图或者任何它的基础关系有一个<literal>INSTEAD</>规则，
导致<command>INSERT</>或<command>UPDATE</>命令重写，
那么所有检查选项都将在重写的查询中忽略，包括任何来自定义在<literal>INSTEAD</>
规则的关系上的可自动更新视图的检查。
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <!--
<title>Notes</title>
-->
<title>注意</title>

   <!--
<para>
    Use the <xref linkend="sql-dropview">
    statement to drop views.
   </para>
-->
<para>
使用<xref linkend="sql-dropview">语句删除视图。
</para>

   <!--
<para>
    Be careful that the names and types of the view's columns will be
    assigned the way you want.  For example:
<programlisting>
CREATE VIEW vista AS SELECT 'Hello World';
</programlisting>
    is bad form in two ways: the column name defaults to <literal>?column?</>,
    and the column data type defaults to <type>unknown</>.  If you want a
    string literal in a view's result, use something like:
<programlisting>
CREATE VIEW vista AS SELECT text 'Hello World' AS hello;
</programlisting>
   </para>
-->
<para>
请注意视图字段的名字和类型不一定是你们期望的那样。比如，
<programlisting>
CREATE VIEW vista AS SELECT 'Hello World';
</programlisting>
在两个方面很糟糕：字段名缺省是<literal>?column?</>
并且字段的数据类型缺省是<type>unknown</>。
如果你想视图的结果是一个字符串文本，那么请像下面这样使用：
<programlisting>
CREATE VIEW vista AS SELECT text 'Hello World' AS hello;
</programlisting>
</para>

   <!--
<para>
    Access to tables referenced in the view is determined by permissions of
    the view owner.  In some cases, this can be used to provide secure but
    restricted access to the underlying tables.  However, not all views are
    secure against tampering; see <xref linkend="rules-privileges"> for
    details.  Functions called in the view are treated the same as if they had
    been called directly from the query using the view.  Therefore the user of
    a view must have permissions to call all functions used by the view.
   </para>
-->
<para>
对视图引用的表的访问的权限由视图的所有者决定。在一些情况下，
这可用于提供安全但是限制访问底层表。不过，不是所有视图对于篡改都是安全的；
参阅<xref linkend="rules-privileges">获取细节。
在视图里被调用的函数，被当作直接从使用视图的查询里调用它们看待。因此，
视图的用户必须有调用视图使用的所有函数的权限。
</para>

   <!--
<para>
    When <command>CREATE OR REPLACE VIEW</> is used on an
    existing view, only the view's defining SELECT rule is changed.
    Other view properties, including ownership, permissions, and non-SELECT
    rules, remain unchanged.  You must own the view
    to replace it (this includes being a member of the owning role).
   </para>
-->
<para>
当<command>CREATE OR REPLACE VIEW</>用在一个现有的视图上时，
只改变了视图定义的SELECT规则。其他视图属性，包括所有权、权限和非SELECT规则，
保持不变。要替换视图，你必须拥有该视图（包括成为拥有者角色的一员）。
</para>

  <refsect2 id="SQL-CREATEVIEW-updatable-views">
   <!--
   <title id="SQL-CREATEVIEW-updatable-views-title">Updatable Views</title>
   -->
   <title id="SQL-CREATEVIEW-updatable-views-title">可更新的视图</title>

   <indexterm zone="sql-createview-updatable-views">
    <!--
<primary>updatable views</primary>
-->
<primary>可更新的视图</primary>
   </indexterm>

   
<para>
<!-- 
    Simple views are automatically updatable: the system will allow
    <command>INSERT</>, <command>UPDATE</> and <command>DELETE</> statements
    to be used on the view in the same way as on a regular table.  A view is
    automatically updatable if it satisfies all of the following conditions:
 -->
简单的视图是自动可更新的：系统允许<command>INSERT</>、<command>UPDATE</>
和<command>DELETE</>语句，和在常规表上一样的方式，被用在视图上。
如果视图满足所有下列的条件，那么就是自动可更新的：
    <itemizedlist>
     <listitem>
<!--
      <para>
       The view must have exactly one entry in its <literal>FROM</> list,
       which must be a table or another updatable view.
      </para>
-->
<para>
视图在它的<literal>FROM</>列表中必须只有一个条目，
该条目必须是一个表或其他可更新视图。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       The view definition must not contain <literal>WITH</>,
       <literal>DISTINCT</>, <literal>GROUP BY</>, <literal>HAVING</>,
       <literal>LIMIT</>, or <literal>OFFSET</> clauses at the top level.
      </para>
-->
<para>
视图定义必须没有在顶级包含<literal>WITH</>、<literal>DISTINCT</>、<literal>GROUP BY</>、
<literal>HAVING</>、<literal>LIMIT</>或<literal>OFFSET</>子句。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       The view definition must not contain set operations (<literal>UNION</>,
       <literal>INTERSECT</> or <literal>EXCEPT</>) at the top level.
      </para>
-->
<para>
视图定义必须没有在顶级包含集合运算（<literal>UNION</>、<literal>INTERSECT</>
或<literal>EXCEPT</>）。
</para>
     </listitem>



     <listitem>
      <!--
<para>
       The view's select list must not contain any aggregates, window functions
       or set-returning functions.
      </para>
-->
<para>
该视图的选择列表必须不包含任何聚合、窗口函数或设置返回函数。
</para>
     </listitem>
    </itemizedlist>
   </para>

<!-- 
   <para>
    An automatically updatable view may contain a mix of updatable and
    non-updatable columns.  A column is updatable if it is a simple reference
    to an updatable column of the underlying base relation; otherwise the
    column is read-only, and an error will be raised if an <command>INSERT</>
    or <command>UPDATE</> statement attempts to assign a value to it.
   </para>
-->
<para>
一个可自动更新的视图可能包含可更新和不可更新字段的混合。
如果一个字段是一个对底层基础关系的可更新字段的简单引用，那么它是可更新的；
否则该字段是只读的，如果<command>INSERT</>或<command>UPDATE</>
语句尝试给它赋值，则会引起一个错误。
</para>

   <!--
<para>
    If the view is automatically updatable the system will convert any
    <command>INSERT</>, <command>UPDATE</> or <command>DELETE</> statement
    on the view into the corresponding statement on the underlying base
    relation.
   </para>
-->
<para>
如果视图是自动可更新的，那么系统将转换视图上的任意<command>INSERT</>、
<command>UPDATE</>或<command>DELETE</>语句为相应的底层基本关系上的语句。
</para>

   <!--
<para>
    If an automatically updatable view contains a <literal>WHERE</>
    condition, the condition restricts which rows of the base relation are
    available to be modified by <command>UPDATE</> and <command>DELETE</>
    statements on the view.  However, an <command>UPDATE</> is allowed to
    change a row so that it no longer satisfies the <literal>WHERE</>
    condition, and thus is no longer visible through the view.  Similarly,
    an <command>INSERT</> command can potentially insert base-relation rows
    that do not satisfy the <literal>WHERE</> condition and thus are not
    visible through the view.  The <literal>CHECK OPTION</> may be used to
    prevent <command>INSERT</> and <command>UPDATE</> commands from creating
    such rows that are not visible through the view.
   </para>
-->
<para>
如果一个自动可更新的视图包含一个<literal>WHERE</>条件，
那么该条件约束基本关系的哪些行可以被视图上的<command>UPDATE</>
和<command>DELETE</>语句修改。不过，允许<command>UPDATE</>
更改一个行，使得它不再满足<literal>WHERE</>条件，并且因此不再通过视图可见。
相似的，<command>INSERT</>命令也可以插入不满足<literal>WHERE</>
条件的基本关系行，并且因此对这个视图不可见。<literal>CHECK OPTION</>
可以用来阻止<command>INSERT</>和<command>UPDATE</>命令创建该视图不可见的行。
</para>

<!-- 
   <para>
    If an automatically updatable view is marked with the
    <literal>security_barrier</> property then all the view's <literal>WHERE</>
    conditions (and any conditions using operators which are marked as <literal>LEAKPROOF</literal>)
    will always be evaluated before any conditions that a user of the view has
    added.   See <xref linkend="rules-privileges"> for full details.  Note that,
    due to this, rows which are not ultimately returned (because they do not
    pass the user's <literal>WHERE</> conditions) may still end up being locked.
    <command>EXPLAIN</command> can be used to see which conditions are
    applied at the relation level (and therefore do not lock rows) and which are
    not.
   </para> 
-->
<para>
如果一个可自动更新的视图标记为<literal>security_barrier</>，
那么所有视图的<literal>WHERE</>条件（和任何使用标记为
<literal>LEAKPROOF</literal>的操作符的条件）将总是在视图的用户添加任何条件之前评估。
参阅<xref linkend="rules-privileges">获取全部信息。请注意，
由于这个原因，不是最终返回的行（因为它们不通过用户的<literal>WHERE</>条件）
最终可能仍然被锁。可以使用<command>EXPLAIN</command>查看哪个条件应用在了关系级别
（并且因此没有锁定行）。
</para>

   <!--
<para>
    A more complex view that does not satisfy all these conditions is
    read-only by default: the system will not allow an insert, update, or
    delete on the view.  You can get the effect of an updatable view by
    creating <literal>INSTEAD OF</> triggers on the view, which must
    convert attempted inserts, etc. on the view into appropriate actions
    on other tables.  For more information see <xref
    linkend="sql-createtrigger">.  Another possibility is to create rules
    (see <xref linkend="sql-createrule">), but in practice triggers are
    easier to understand and use correctly.
   </para>
-->
<para>
不满足所有这些条件的更复杂的视图缺省是只读的：系统将不允许在该视图上插入、
更新或删除。可以通过在该视图上创建<literal>INSTEAD OF</>触发器获得可更新视图的效果，
该触发器必须转换在该视图上的尝试插入等为其他表上的适当动作。更多信息请参见
<xref linkend="sql-createtrigger">。还有一种可能性是创建规则
（参阅<xref linkend="sql-createrule">），但是实际上触发器更容易理解和正确使用。
</para>

   <!--
<para>
    Note that the user performing the insert, update or delete on the view
    must have the corresponding insert, update or delete privilege on the
    view.  In addition the view's owner must have the relevant privileges on
    the underlying base relations, but the user performing the update does
    not need any permissions on the underlying base relations (see
    <xref linkend="rules-privileges">).
   </para>
-->
<para>
请注意，用户在视图上执行插入、更新或删除必须在该视图上有相应的插入、
更新或删除的权限。此外，视图的所有者必须在底层基础关系上有相关的权限，
但是执行更新的用户不需要在底层基础关系上的任何权限
（参阅<xref linkend="rules-privileges">）。
</para>
  </refsect2>
 </refsect1>

 <refsect1>
  <!--
<title>Examples</title>
-->
<title>例子</title>

  <!--
<para>
   Create a view consisting of all comedy films:

<programlisting>
CREATE VIEW comedies AS
    SELECT *
    FROM films
    WHERE kind = 'Comedy';
</programlisting>
   This will create a view containing the columns that are in the
   <literal>film</> table at the time of view creation.  Though
   <literal>*</> was used to create the view, columns added later to
   the table will not be part of the view.
  </para>
-->
<para>
创建一个由所有喜剧电影组成的视图：
<programlisting>
CREATE VIEW comedies AS
    SELECT *
    FROM films
    WHERE kind = 'Comedy';
</programlisting>
这将创建一个视图，包含了在视图创建时<literal>film</>表中的所有字段。
尽管用<literal>*</>创建了该视图，但是后来添加到表中的字段将不会是视图的一部分。
</para>

  <para>
<!-- 
   Create a view with <literal>LOCAL CHECK OPTION</>:
-->
创建一个带有<literal>LOCAL CHECK OPTION</>的视图：

<programlisting>

CREATE VIEW universal_comedies AS
    SELECT *
    FROM comedies
    WHERE classification = 'U'
    WITH LOCAL CHECK OPTION;
</programlisting>

<!-- 
   This will create a view based on the <literal>comedies</> view, showing
   only films with <literal>kind = 'Comedy'</> and
   <literal>classification = 'U'</>. Any attempt to <command>INSERT</> or
   <command>UPDATE</> a row in the view will be rejected if the new row
   doesn't have <literal>classification = 'U'</>, but the film
   <literal>kind</> will not be checked.
-->
这将创建一个基于<literal>comedies</>视图的视图，只显示<literal>kind = 'Comedy'</>
和<literal>classification = 'U'</>的电影。如果新行没有
<literal>classification = 'U'</>，那么任何<command>INSERT</>
或<command>UPDATE</>该视图中行的尝试都将被拒绝，但是电影<literal>kind</>
将不会检查。
  </para>


  <para>
<!-- 
   Create a view with <literal>CASCADED CHECK OPTION</>:
-->
创建一个带有<literal>CASCADED CHECK OPTION</>的视图：

<programlisting>
CREATE VIEW pg_comedies AS
    SELECT *
    FROM comedies
    WHERE classification = 'PG'
    WITH CASCADED CHECK OPTION;
</programlisting>
<!-- 
   This will create a view that checks both the <literal>kind</> and
   <literal>classification</> of new rows.
-->
这将创建一个检查新行的<literal>kind</>和<literal>classification</>的视图。
  </para>

  <para>
<!-- 
   Create a view with a mix of updatable and non-updatable columns:
-->
创建一个带有可更新和不可更新混合字段的视图：

<programlisting>
CREATE VIEW comedies AS
    SELECT f.*,
           country_code_to_name(f.country_code) AS country,
           (SELECT avg(r.rating)
            FROM user_ratings r
            WHERE r.film_id = f.id) AS avg_rating
    FROM films f
    WHERE f.kind = 'Comedy';
</programlisting>
<!-- 
   This view will support <command>INSERT</>, <command>UPDATE</> and
   <command>DELETE</>.  All the columns from the <literal>films</> table will
   be updatable, whereas the computed columns <literal>country</> and
   <literal>avg_rating</> will be read-only.
-->
这个视图将支持<command>INSERT</>、<command>UPDATE</>和<command>DELETE</>。
所有来自<literal>films</>表的字段都将被更新，而计算的字段
<literal>country</>和<literal>avg_rating</>将是只读的。
  </para>

  <!--
<para>
   Create a recursive view consisting of the numbers from 1 to 100:
<programlisting>
CREATE RECURSIVE VIEW nums_1_100 (n) AS
    VALUES (1)
UNION ALL
    SELECT n+1 FROM nums_1_100 WHERE n < 100;
</programlisting></para>
-->
<para>
创建一个由数字1到100组成的递归的视图：
<programlisting>
CREATE RECURSIVE VIEW nums_1_100 (n) AS
    VALUES (1)
UNION ALL
    SELECT n+1 FROM nums_1_100 WHERE n < 100;
</programlisting>
</para>
 </refsect1>

 <refsect1>
  <!--
<title>Compatibility</title>
-->
<title>兼容性</title>



  <!--
<para>
   <command>CREATE OR REPLACE VIEW</command> is a
   <productname>PostgreSQL</productname> language extension.
   So is the concept of a temporary view.
   The <literal>WITH ( ... )</> clause is an extension as well.
  </para>
-->
<para>
<command>CREATE OR REPLACE VIEW</command>是<productname>PostgreSQL</productname>
的扩展。临时视图的概念也是扩展。<literal>WITH ( ... )</>子句也是一个扩展。
</para>
 </refsect1>

 <refsect1>
  <!--
<title>See Also</title>
-->
<title>又见</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alterview"></member>
   <member><xref linkend="sql-dropview"></member>
   <member><xref linkend="sql-creatematerializedview"></member>
  </simplelist>
 </refsect1>
</refentry>
