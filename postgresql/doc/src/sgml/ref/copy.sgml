<!--
doc/src/sgml/ref/copy.sgml
PostgreSQL documentation
-->


<refentry id="SQL-COPY">
 <refmeta>
  <refentrytitle>COPY</refentrytitle>
  <manvolnum>7</manvolnum>
  <!--
<refmiscinfo>SQL - Language Statements</refmiscinfo>
-->
<refmiscinfo>SQL - 语句</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>COPY</refname>
  <!--
<refpurpose>copy data between a file and a table</refpurpose>
-->
<refpurpose>
在表和文件之间拷贝数据
</refpurpose>
 </refnamediv>

 <indexterm zone="sql-copy">
  <primary>COPY</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
COPY <replaceable class="parameter">table_name</replaceable> [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ]
    FROM { '<replaceable class="parameter">filename</replaceable>' | PROGRAM '<replaceable class="parameter">command</replaceable>' | STDIN }
    [ [ WITH ] ( <replaceable class="parameter">option</replaceable> [, ...] ) ]

COPY { <replaceable class="parameter">table_name</replaceable> [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ] | ( <replaceable class="parameter">query</replaceable> ) }
    TO { '<replaceable class="parameter">filename</replaceable>' | PROGRAM '<replaceable class="parameter">command</replaceable>' | STDOUT }
    [ [ WITH ] ( <replaceable class="parameter">option</replaceable> [, ...] ) ]

<phrase>where <replaceable class="parameter">option</replaceable> can be one of:</phrase>

    FORMAT <replaceable class="parameter">format_name</replaceable>
    OIDS [ <replaceable class="parameter">boolean</replaceable> ]
    FREEZE [ <replaceable class="parameter">boolean</replaceable> ]
    DELIMITER '<replaceable class="parameter">delimiter_character</replaceable>'
    NULL '<replaceable class="parameter">null_string</replaceable>'
    HEADER [ <replaceable class="parameter">boolean</replaceable> ]
    QUOTE '<replaceable class="parameter">quote_character</replaceable>'
    ESCAPE '<replaceable class="parameter">escape_character</replaceable>'
    FORCE_QUOTE { ( <replaceable class="parameter">column_name</replaceable> [, ...] ) | * }
    FORCE_NOT_NULL ( <replaceable class="parameter">column_name</replaceable> [, ...] )
    ENCODING '<replaceable class="parameter">encoding_name</replaceable>'
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <command>COPY</command> moves data between
   <productname>PostgreSQL</productname> tables and standard file-system
   files. <command>COPY TO</command> copies the contents of a table
   <emphasis>to</> a file, while <command>COPY FROM</command> copies
   data <emphasis>from</> a file to a table (appending the data to
   whatever is in the table already).  <command>COPY TO</command>
   can also copy the results of a <command>SELECT</> query.
  </para>
-->
<para>
<command>COPY</command>在<productname>PostgreSQL</productname>表和文件之间交换数据。
<command>COPY TO</command>把一个表的所有内容都拷贝到一个文件，而<command>COPY FROM</command>从一个文件里拷贝数据到一个表里(把数据附加到表中已经存在的内容里)。
<command>COPY TO</command>还能拷贝<command>SELECT</>查询的结果。
</para>

  <!--
<para>
   If a list of columns is specified, <command>COPY</command> will
   only copy the data in the specified columns to or from the file.
   If there are any columns in the table that are not in the column list,
   <command>COPY FROM</command> will insert the default values for
   those columns.
  </para>
-->
<para>
如果声明了一个字段列表，<command>COPY</command>将只在文件和表之间拷贝已声明字段的数据。 
如果表中有任何不在字段列表里的字段，那么<command>COPY FROM</command>将为那些字段插入缺省值。
</para>

  <!--
<para>
   <command>COPY</command> with a file name instructs the
   <productname>PostgreSQL</productname> server to directly read from
   or write to a file. The file must be accessible to the server and
   the name must be specified from the viewpoint of the server. When
   <literal>PROGRAM</literal> is specified, the server executes the
   given command, and reads from its standard input, or writes to its
   standard output. The command must be specified from the viewpoint of the
   server, and be executable by the <literal>postgres</> user. When
   <literal>STDIN</literal> or <literal>STDOUT</literal> is
   specified, data is transmitted via the connection between the
   client and the server.
  </para>
-->
<para>
带文件名的<command>COPY</command>指示<productname>PostgreSQL</productname>服务器直接从文件中读写数据。
如果声明了文件名，那么服务器必须可以访问该文件，而且文件名必须从服务器的角度声明。
如果使用了<literal>PROGRAM</literal>选项，则服务器会从指定的这个程序进行输入或是写入该程序作为输出。
如果使用了<literal>STDIN</literal> 或<literal>STDOUT</literal>选项，那么数据将通过客户端和服务器之间的连接来传输。
</para>
 </refsect1>

 <refsect1>
  <!--
<title>Parameters</title>
-->
<title>参数</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">table_name</replaceable></term>
    <listitem>
     <!--
<para>
      The name (optionally schema-qualified) of an existing table.
     </para>
-->
<para>
现存表的名字(可以有模式修饰)。。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">column_name</replaceable></term>
     <listitem>
     <!--
<para>
      An optional list of columns to be copied.  If no column list is
      specified, all columns of the table will be copied.
     </para>
-->
<para>
可选的待拷贝字段列表。如果没有声明字段列表，那么将使用所有字段。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">query</replaceable></term>
    <listitem>
     <!--
<para>
      A <xref linkend="sql-select"> or
      <xref linkend="sql-values"> command
      whose results are to be copied.
      Note that parentheses are required around the query.
     </para>
-->
<para>
一个必须用圆括弧包围的<xref linkend="sql-select">或<xref linkend="sql-values">命令，其结果将被拷贝。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">filename</replaceable></term>
    <listitem>
<!--
<para>
      The path name of the input or output file.  An input file name can be
      an absolute or relative path, but an output file name must be an absolute
      path.  Windows users might need to use an <literal>E''</> string and
      double any backslashes used in the path name.
     </para>
-->
<para>
输入或输出文件的路径名。输入文件名可以是绝对或是相对的路径，但输出文件名必须是绝对路径。
Windows用户可能需要使用<literal>E''</>字符串和双反斜线作为路径名称。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>PROGRAM</literal></term>
    <listitem>
     <!--
<para>
      A command to execute. In <command>COPY FROM</command>, the input is
      read from standard output of the command, and in <command>COPY TO</>,
      the output is written to the standard input of the command.
     </para>
-->
<para>
需执行的程序名。在<command>COPY FROM</command>命令中，输入是从程序的标准输出中读取，而在<command>COPY TO</>中，命令的输出会作为程序的标准输入。
</para>
     <!--
<para>
      Note that the command is invoked by the shell, so if you need to pass
      any arguments to shell command that come from an untrusted source, you
      must be careful to strip or escape any special characters that might
      have a special meaning for the shell. For security reasons, it is best
      to use a fixed command string, or at least avoid passing any user input
      in it.
     </para>
-->
<para>
注意，程序一般是在命令行界面下执行，当用户需要传递一些变量给程序时，如果这些变量的来源不是可靠的，用户必须小心过滤处理那些对命令行界面来说是有特殊意义的字符。
基于安全的原因，最好是使用固定的命令字符串，或者至少是应避免直接使用用户输入（应先过滤特殊字符）。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>STDIN</literal></term>
    <listitem>
     <!--
<para>
      Specifies that input comes from the client application.
     </para>
-->
<para>
声明输入是来自客户端应用。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>STDOUT</literal></term>
    <listitem>
     <!--
<para>
      Specifies that output goes to the client application.
     </para>
-->
<para>
声明输入将写入客户端应用。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">boolean</replaceable></term>
    <listitem>
     <!--
<para>
      Specifies whether the selected option should be turned on or off.
      You can write <literal>TRUE</literal>, <literal>ON</>, or
      <literal>1</literal> to enable the option, and <literal>FALSE</literal>,
      <literal>OFF</>, or <literal>0</literal> to disable it.  The
      <replaceable class="parameter">boolean</replaceable> value can also
      be omitted, in which case <literal>TRUE</literal> is assumed.
     </para>
-->
<para>
声明用户所选的选项是否应该被开启或者关闭。您可以写<literal>TRUE</literal>、 <literal>ON</>或<literal>1</literal>来启用这个选项，并且用<literal>FALSE</literal>、<literal>OFF</>或<literal>0</literal>来关闭它。
<replaceable class="parameter">boolean</replaceable>值也可以被省略，此时系统使用缺省值<literal>TRUE</literal>。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FORMAT</literal></term>
    <listitem>
     <!--
<para>
      Selects the data format to be read or written:
      <literal>text</>,
      <literal>csv</> (Comma Separated Values),
      or <literal>binary</>.
      The default is <literal>text</>.
     </para>
-->
<para>
选择被读或者写的数据格式：<literal>text</>、<literal>csv</>（逗号分隔值），或者<literal>binary</>。 默认是<literal>text</>。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OIDS</literal></term>
    <listitem>
     <!--
<para>
      Specifies copying the OID for each row.  (An error is raised if
      <literal>OIDS</literal> is specified for a table that does not
      have OIDs, or in the case of copying a <replaceable
      class="parameter">query</replaceable>.)
     </para>
-->
<para>
声明为每行记录都拷贝内部对象标识(OID)。
（如果为一个<replaceable class="parameter">query</replaceable>拷贝或者没有<literal>OIDS</literal>的表声明了OIDS选项，则抛出一个错误。）
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FREEZE</literal></term>
    <listitem>
     <!--
<para>
      Requests copying the data with rows already frozen, just as they
      would be after running the <command>VACUUM FREEZE</> command.
      This is intended as a performance option for initial data loading.
      Rows will be frozen only if the table being loaded has been created
      or truncated in the current subtransaction, there are no cursors
      open and there are no older snapshots held by this transaction.
     </para>
-->
<para>
请求拷贝那些已冻结的数据，就类似使用<command>VACUUM FREEZE</>的效果。
这主要于用于初始化时加载数据时的性能考虑。
仅在表记录初始创建或是在当前子事务中被清理的记录会补冻结，没有游标会打开，事务中也没有数据快照。
</para>
     <!--
<para>
      Note that all other sessions will immediately be able to see the data
      once it has been successfully loaded. This violates the normal rules
      of MVCC visibility and users specifying should be aware of the
      potential problems this might cause.
     </para>
-->
<para>
注意此时其他的事务会立刻看见刚加载的数据。
这不符合MVCC正常的可见性规则，用户应注意这可能带来的潜在问题。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DELIMITER</literal></term>
    <listitem>
     <!--
<para>
      Specifies the character that separates columns within each row
      (line) of the file.  The default is a tab character in text format,
      a comma in <literal>CSV</> format.
      This must be a single one-byte character.
      This option is not allowed when using <literal>binary</> format.
     </para>
-->
<para>
指定分隔每一行记录中的列的字符。默认是文本格式的制表符，<literal>CSV</>格式的逗号。 
必须有一个独立的一字节的字符。 在使用<literal>binary</>格式时这个选项是不允许的。 
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NULL</literal></term>
    <listitem>
     <!--
<para>
      Specifies the string that represents a null value. The default is
      <literal>\N</literal> (backslash-N) in text format, and an unquoted empty
      string in <literal>CSV</> format. You might prefer an
      empty string even in text format for cases where you don't want to
      distinguish nulls from empty strings.
      This option is not allowed when using <literal>binary</> format.
     </para>
-->
<para>
声明代表一个空值的字符串。默认是文本格式的<literal>\N</literal>，<literal>CSV</>格式的一个未被引用的空字符串。
即使是文本格式您可能也更偏向于空串，例如您不想从空字符串中区分空值。 
在使用<literal>binary</>格式时这个选项是不允许的。
</para>

     <note>
      <!--
<para>
       When using <command>COPY FROM</command>, any data item that matches
       this string will be stored as a null value, so you should make
       sure that you use the same string as you used with
       <command>COPY TO</command>.
      </para>
-->
<para>
在使用<command>COPY FROM</command>的时候，任何匹配这个字符串的字符串将被存储为NULL值，所以你应该确保你用的字符串和<command>COPY TO</command>相同。
</para>
     </note>

    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>HEADER</literal></term>
    <listitem>
     <!--
<para>
      Specifies that the file contains a header line with the names of each
      column in the file.  On output, the first line contains the column
      names from the table, and on input, the first line is ignored.
      This option is allowed only when using <literal>CSV</> format.
     </para>
-->
<para>
声明文件包含一个带有文件中每列名称的标题行。
在输出时，第一行包含表中的列名，在输入时，第一行是被忽略的。该选项仅仅在使用<literal>CSV</>格式时是允许的。 
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>QUOTE</literal></term>
    <listitem>
     <!--
<para>
      Specifies the quoting character to be used when a data value is quoted.
      The default is double-quote.
      This must be a single one-byte character.
      This option is allowed only when using <literal>CSV</> format.
     </para>
-->
<para>
指定引用数据的引用字符。默认的是双引号。这一定是一个1字节的字符。该选项仅仅在使用<literal>CSV</>格式时允许。 
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ESCAPE</literal></term>
    <listitem>
     <!--
<para>
      Specifies the character that should appear before a
      data character that matches the <literal>QUOTE</> value.
      The default is the same as the <literal>QUOTE</> value (so that
      the quoting character is doubled if it appears in the data).
      This must be a single one-byte character.
      This option is allowed only when using <literal>CSV</> format.
     </para>
-->
<para>
声明应该出现在一个匹配<literal>QUOTE</>值的数据字符之前的字符。
默认与<literal>QUOTE</>值相同（所以若它出现在数据中，则引用字符是翻一倍）。
这一定是一个1字节的字符。该选项只有在使用<literal>CSV</>格式时允许。 
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FORCE_QUOTE</></term>
    <listitem>
     <!--
<para>
      Forces quoting to be
      used for all non-<literal>NULL</> values in each specified column.
      <literal>NULL</> output is never quoted. If <literal>*</> is specified,
      non-<literal>NULL</> values will be quoted in all columns.
      This option is allowed only in <command>COPY TO</>, and only when
      using <literal>CSV</> format.
     </para>
-->
<para>
强制引用在每个指定列的所有非<literal>NULL</>值。<literal>NULL</>从不被引用。
如果声明了<literal>*</>，非<literal>NULL</>值将在所有列中被引用。
这个选项仅仅在<command>COPY TO</>中并且仅仅在使用<literal>CSV</>格式时允许。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FORCE_NOT_NULL</></term>
    <listitem>
<!--
<para>
      Do not match the specified columns' values against the null string.
      In the default case where the null string is empty, this means that
      empty values will be read as zero-length strings rather than nulls,
      even when they are not quoted.
      This option is allowed only in <command>COPY FROM</>, and only when
      using <literal>CSV</> format.
     </para>
-->
<para>
默认情况下空字符串是空的，这意味着空值将会被读作长度为零的字符串而不是空值，即使当他们不被引用。
这个选项仅仅在<command>COPY FROM</>中并且仅仅在使用<literal>CSV</>格式时允许。 
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ENCODING</></term>
    <listitem>
     <!--
<para>
      Specifies that the file is encoded in the <replaceable
      class="parameter">encoding_name</replaceable>.  If this option is
      omitted, the current client encoding is used. See the Notes below
      for more details.
     </para>
-->
<para>
声明文件的编码集是<replaceable class="parameter">encoding_name</replaceable>。
如果这个选项省略，则系统使用当前的用户编码集。
阅读下面的注意事项以了解更多内容。
</para>
    </listitem>
   </varlistentry>

  </variablelist>
 </refsect1>

 <refsect1>
  <title>Outputs</title>

  <!--
<para>
   On successful completion, a <command>COPY</> command returns a command
   tag of the form
<screen> COPY <replaceable class="parameter">count</replaceable></screen>
   The <replaceable class="parameter">count</replaceable> is the number
   of rows copied.
  </para>
-->
<para>
当<command>COPY</>命令执行成功后，会在屏幕上显示<screen> COPY <replaceable class="parameter">count</replaceable></screen>式样内容，
这里<replaceable class="parameter">count</replaceable>是已拷贝成功的记录数。

</para>
 </refsect1>

 <refsect1>
  <!--
<title>Notes</title>
-->
<title>注意</title>

   <!--
<para>
    <command>COPY</command> can only be used with plain tables, not
    with views.  However, you can write <literal>COPY (SELECT * FROM
    <replaceable class="parameter">viewname</replaceable>) TO ...</literal>.
   </para>
-->
<para>
<command>COPY</command>只能用于表，不能用于视图。当然也可以用于<literal>COPY (SELECT * FROM <replaceable class="parameter">viewname</replaceable>) TO ...</literal>
</para>

   <!--
<para>
    <command>COPY</command> only deals with the specific table named;
    it does not copy data to or from child tables.  Thus for example
    <literal>COPY <replaceable class="parameter">table</> TO</literal>
    shows the same data as <literal>SELECT * FROM ONLY <replaceable
    class="parameter">table</></literal>.  But <literal>COPY
    (SELECT * FROM <replaceable class="parameter">table</>) TO ...</literal>
    can be used to dump all of the data in an inheritance hierarchy.
   </para>
-->
<para>
<command>COPY</command>仅仅处理已指定的特定表；它将不复制数据到子表或从子表中复制数据。
因此比如<literal>COPY <replaceable class="parameter">table</> TO</literal>显示与<literal>SELECT * FROM ONLY <replaceable class="parameter">table</></literal>相同的数据。
但是<literal>COPY (SELECT * FROM <replaceable class="parameter">table</>) TO ...</literal>可以用于转储在继承层次结构的所有数据。
</para>

<!--
<para>
    You must have select privilege on the table
    whose values are read by <command>COPY TO</command>, and
    insert privilege on the table into which values
    are inserted by <command>COPY FROM</command>.  It is sufficient
    to have column privileges on the column(s) listed in the command.
   </para>
-->
<para>
你对任何要<command>COPY TO</command>出来的数据必须有查询的权限，对任何要<command>COPY FROM</command>入数据的表必须有插入权限。
对列在命令中的字段拥有列权限也是必须的。 
</para>

   <!--
<para>
    Files named in a <command>COPY</command> command are read or written
    directly by the server, not by the client application. Therefore,
    they must reside on or be accessible to the database server machine,
    not the client. They must be accessible to and readable or writable
    by the <productname>PostgreSQL</productname> user (the user ID the
    server runs as), not the client. Similarly,
    the command specified with <literal>PROGRAM</literal> is executed directly
    by the server, not by the client application, must be executable by the
    <productname>PostgreSQL</productname> user.
    <command>COPY</command> naming a file or command is only allowed to
    database superusers, since it allows reading or writing any file that the
    server has privileges to access.
   </para>
-->
<para>
<command>COPY</command>命令里面的文件必须是由服务器直接读或写的文件，而不是由客户端应用读写。
因此，它们必须位于数据库服务器上或者可以被数据库服务器所访问，而不是客户端程序。
它们必须被运行<productname>PostgreSQL</productname>服务器的用户可读或写，而不是客户端程序。
由<literal>PROGRAM</literal>选项指定的命令必须是由服务器来执行的，而不是客户端程序，必须是由<productname>PostgreSQL</productname>所属的用户。
<command>COPY</command>在指定一个程序或是命令时只允许数据库超级用户来执行，因为它允许读写任意服务器有权限访问的文件。 
</para>

   <!--
<para>
    Do not confuse <command>COPY</command> with the
    <application>psql</application> instruction
    <command><link linkend="APP-PSQL-meta-commands-copy">\copy</link></command>. <command>\copy</command> invokes
    <command>COPY FROM STDIN</command> or <command>COPY TO
    STDOUT</command>, and then fetches/stores the data in a file
    accessible to the <application>psql</application> client. Thus,
    file accessibility and access rights depend on the client rather
    than the server when <command>\copy</command> is used.
   </para>
-->
<para>
不要混淆<command>COPY</command>和 <application>psql</application>应用程序中的<command><link linkend="APP-PSQL-meta-commands-copy">\copy</link></command>指令。
<command>\copy</command>调用<command>COPY FROM STDIN</command>或<command>COPY TO STDOUT</command>，然后把数据抓取/存储到一个<application>psql</application>客户端可以访问的文件中。
因此，使用<command>\copy</command>的时候，文件访问权限是由客户端应用程序而不是服务器端决定的。 
</para>

   <!--
<para>
    It is recommended that the file name used in <command>COPY</command>
    always be specified as an absolute path. This is enforced by the
    server in the case of <command>COPY TO</command>, but for
    <command>COPY FROM</command> you do have the option of reading from
    a file specified by a relative path. The path will be interpreted
    relative to the working directory of the server process (normally
    the cluster's data directory), not the client's working directory.
   </para>
-->
<para>
建议在<command>COPY</command>里的文件名字总是使用绝对路径。
在<command>COPY TO</command>的时候是由服务器强制进行的，但是对于<command>COPY FROM</command>，你的确可从一个相对路径的文件里读取。
该路径将解释为相对于服务器的工作目录(通常是数据目录)，而不是客户端的工作目录。 
</para>

   <!--
<para>
    Executing a command with <literal>PROGRAM</literal> might be restricted
    by the operating system's access control mechanisms, such as SELinux.
   </para>
-->
<para>
执行一个<literal>PROGRAM</literal>选项指定的命令有可能还会受到操作系统的存取权限控制，如在SELinux下。
</para>

   <!--
<para>
    <command>COPY FROM</command> will invoke any triggers and check
    constraints on the destination table. However, it will not invoke rules.
   </para>
-->
<para>
<command>COPY FROM</command>在执行时会触发目标表上所有触发器和检查约束。不过，不会执行规则。 
</para>

   <!--
<para>
    <command>COPY</command> input and output is affected by
    <varname>DateStyle</varname>. To ensure portability to other
    <productname>PostgreSQL</productname> installations that might use
    non-default <varname>DateStyle</varname> settings,
    <varname>DateStyle</varname> should be set to <literal>ISO</> before
    using <command>COPY TO</>.  It is also a good idea to avoid dumping
    data with <varname>IntervalStyle</varname> set to
    <literal>sql_standard</>, because negative interval values might be
    misinterpreted by a server that has a different setting for
    <varname>IntervalStyle</varname>.
   </para>
-->
<para>
<command>COPY</command>输入和输出会被<varname>DateStyle</varname>参数影响。
为了和其它<productname>PostgreSQL</productname>不同服务器间进行数据转移(它们可能是非缺省<varname>DateStyle</varname>设置)，应该在使用<command>COPY TO</>前把<varname>DateStyle</varname>参数值设置为<literal>ISO</>。
另外也建议在导出数据时，不要将<varname>IntervalStyle</varname>参数设置为<literal>sql_standard</>。
因为负的区间值可能会被对<varname>IntervalStyle</varname>有不同设置的服务器误解。 
</para>

   <!--
<para>
    Input data is interpreted according to <literal>ENCODING</literal>
    option or the current client encoding, and output data is encoded
    in <literal>ENCODING</literal> or the current client encoding, even
    if the data does not pass through the client but is read from or
    written to a file directly by the server.
   </para>
-->
<para>
输入数据通过<literal>ENCODING</literal>参数或是当前客户端编码来解译，输出数据也是通过<literal>ENCODING</literal>参数或是为当前客户端的编码来编码，
即使数据不经过客户端的，仍会通过服务器直接将数据从文件中读出或者写入到文件中去。 
</para>

   <!--
<para>
    <command>COPY</command> stops operation at the first error. This
    should not lead to problems in the event of a <command>COPY
    TO</command>, but the target table will already have received
    earlier rows in a <command>COPY FROM</command>. These rows will not
    be visible or accessible, but they still occupy disk space. This might
    amount to a considerable amount of wasted disk space if the failure
    happened well into a large copy operation. You might wish to invoke
    <command>VACUUM</command> to recover the wasted space.
   </para>
-->
<para>
<command>COPY</command>在第一个错误处停下来。
这些在<command>COPY TO</command>中不应该导致问题，但在<command>COPY FROM</command>时目标表会已经接收到早先的行，
这些行将不可见或不可访问，但是仍然会占据磁盘空间。如果你碰巧拷贝大量数据文件的话，这些东西积累起来可能会占据相当大的磁盘空间。
你可以调用<command>VACUUM</command>来恢复那些磁盘空间。 
</para>

 </refsect1>

 <refsect1>
<!--
<title>File Formats</title>
-->
<title>文件格式</title>

  <refsect2>
<!--
<title>Text Format</title>
-->
<title>文本格式</title>

   <!--
<para>
    When the <literal>text</> format is used,
    the data read or written is a text file with one line per table row.
    Columns in a row are separated by the delimiter character.
    The column values themselves are strings generated by the
    output function, or acceptable to the input function, of each
    attribute's data type.  The specified null string is used in
    place of columns that are null.
    <command>COPY FROM</command> will raise an error if any line of the
    input file contains more or fewer columns than are expected.
    If <literal>OIDS</literal> is specified, the OID is read or written as the first column,
    preceding the user data columns.
   </para>
-->
<para>
当使用<literal>text</>格式时，读写的文件是一个文本文件，每行代表表中一个行。
行中的列(字段)用分隔符分开。字段值本身是由与每个字段类型相关的输出函数生成的字符串，或者是输入函数可接受的字符串。
数据中使用特定的NULL字符串表示那些值为NULL的字段。
如果输入文件的任意行包含比预期多或者少的字段，那么<command>COPY FROM</command>将抛出一个错误。
如果声明了<literal>OIDS</literal>选项，那么OID将作为第一个字段读写，放在所有用户字段前面。 
</para>

   <!--
<para>
    End of data can be represented by a single line containing just
    backslash-period (<literal>\.</>).  An end-of-data marker is
    not necessary when reading from a file, since the end of file
    serves perfectly well; it is needed only when copying data to or from
    client applications using pre-3.0 client protocol.
   </para>
-->
<para>
数据的结束可以用一个只包含反斜杠和句点(<literal>\.</>)的行表示。
如果从文件中读取数据，那么数据结束的标记是不必要的，因为文件结束符可以起到相同的作用；
但是在3.0之前的客户端协议里， 如果在客户端应用之间拷贝数据，那么必须要有结束标记。 
</para>

   <!--
<para>
    Backslash characters (<literal>\</>) can be used in the
    <command>COPY</command> data to quote data characters that might
    otherwise be taken as row or column delimiters. In particular, the
    following characters <emphasis>must</> be preceded by a backslash if
    they appear as part of a column value: backslash itself,
    newline, carriage return, and the current delimiter character.
   </para>
-->
<para>
反斜杠字符(<literal>\</>)可以用于<command>COPY</command>数据，来引用那些可能会被当作行或列分隔符的数据字符。
特别是以下字符，若以一列值的一部分出现则必须在前面加上反斜杠：反斜杠、换行符、回车以及当前的分隔符字符。
</para>

   <!--
<para>
    The specified null string is sent by <command>COPY TO</command> without
    adding any backslashes; conversely, <command>COPY FROM</command> matches
    the input against the null string before removing backslashes.  Therefore,
    a null string such as <literal>\N</literal> cannot be confused with
    the actual data value <literal>\N</literal> (which would be represented
    as <literal>\\N</literal>).
   </para>
-->
<para>
声明的空字符串被<command>COPY TO</command>不加任何反斜杠发送；
与之相对，<command>COPY FROM</command>在删除反斜杠之前拿它的输入与空字符串比较。
因此，像<literal>\N</literal>这样的空字符串不会和实际数据值<literal>\N</literal>之间混淆(因为后者会表现成<literal>\\N</literal>)。 
</para>

   <!--
<para>
    The following special backslash sequences are recognized by
    <command>COPY FROM</command>:

   <informaltable>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Sequence</entry>
       <entry>Represents</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>\b</></entry>
       <entry>Backspace (ASCII 8)</entry>
      </row>
      <row>
       <entry><literal>\f</></entry>
       <entry>Form feed (ASCII 12)</entry>
      </row>
      <row>
       <entry><literal>\n</></entry>
       <entry>Newline (ASCII 10)</entry>
      </row>
      <row>
       <entry><literal>\r</></entry>
       <entry>Carriage return (ASCII 13)</entry>
      </row>
      <row>
       <entry><literal>\t</></entry>
       <entry>Tab (ASCII 9)</entry>
      </row>
      <row>
       <entry><literal>\v</></entry>
       <entry>Vertical tab (ASCII 11)</entry>
      </row>
      <row>
       <entry><literal>\</><replaceable>digits</></entry>
       <entry>Backslash followed by one to three octal digits specifies
       the character with that numeric code</entry>
      </row>
      <row>
       <entry><literal>\x</><replaceable>digits</></entry>
       <entry>Backslash <literal>x</> followed by one or two hex digits specifies
       the character with that numeric code</entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>

    Presently, <command>COPY TO</command> will never emit an octal or
    hex-digits backslash sequence, but it does use the other sequences
    listed above for those control characters.
   </para>
-->
<para>
<command>COPY FROM</command>能够识别下列特殊反斜杠字符： 
   <informaltable>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>字符形式</entry>
       <entry>字符含义</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>\b</></entry>
       <entry>反斜杠 (ASCII 8)</entry>
      </row>
      <row>
       <entry><literal>\f</></entry>
       <entry>进纸 (ASCII 12)</entry>
      </row>
      <row>
       <entry><literal>\n</></entry>
       <entry>换行符 (ASCII 10)</entry>
      </row>
      <row>
       <entry><literal>\r</></entry>
       <entry>回车符 (ASCII 13)</entry>
      </row>
      <row>
       <entry><literal>\t</></entry>
       <entry>水平制表符 (ASCII 9)</entry>
      </row>
      <row>
       <entry><literal>\v</></entry>
       <entry>垂直制表符 (ASCII 11)</entry>
      </row>
      <row>
       <entry><literal>\</><replaceable>digits</></entry>
       <entry>反斜杠后面跟着一到三个八进制数，表示ASCII值为该数的字符</entry>
      </row>
      <row>
       <entry><literal>\x</><replaceable>digits</></entry>
       <entry>反斜杠<literal>\x</>后面跟着一个或两个十六进制位声明指定数值编码的字符</entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>

   目前，<command>COPY TO</command>绝不会发出一个八进制或者十六进制反斜杠序列，但是它的确使用了上面列出的其它字符用于控制字符。 
</para>

   <!--
<para>
    Any other backslashed character that is not mentioned in the above table
    will be taken to represent itself.  However, beware of adding backslashes
    unnecessarily, since that might accidentally produce a string matching the
    end-of-data marker (<literal>\.</>) or the null string (<literal>\N</> by
    default).  These strings will be recognized before any other backslash
    processing is done.
   </para>
-->
<para>
任何其他未在上表中提及的斜字符将会用来表示其本身。然而，也要注意不必要的情况添加反斜杠。
因为这可能意外地生成一个匹配数据结束标记(<literal>\.</>)或者空字符串 (默认为<literal>\N</>）的字符串。
这些字符串将在任何其他反斜杠处理做完之前确认。
</para>

   <!--
<para>
    It is strongly recommended that applications generating <command>COPY</command> data convert
    data newlines and carriage returns to the <literal>\n</> and
    <literal>\r</> sequences respectively.  At present it is
    possible to represent a data carriage return by a backslash and carriage
    return, and to represent a data newline by a backslash and newline.
    However, these representations might not be accepted in future releases.
    They are also highly vulnerable to corruption if the <command>COPY</command> file is
    transferred across different machines (for example, from Unix to Windows
    or vice versa).
   </para>
-->
<para>
强烈建议产生<command>COPY</command>数据的应用程序将数据换行符和回车分别转换为 <literal>\n</>和<literal>\r</>序列。
目前，可以由反斜杠和回车代表一个数据回车，并且由反斜杠和换行符代表一个数据换行。
然而，这些表示法在将来的版本中可能无法接受。<command>COPY</command>文件在不同操作系统之间转移时，它们也非常容易被误解读，
（例如：从Unix 系统移到Windows系统，或者反过来）。
</para>

   <!--
<para>
    <command>COPY TO</command> will terminate each row with a Unix-style
    newline (<quote><literal>\n</></>).  Servers running on Microsoft Windows instead
    output carriage return/newline (<quote><literal>\r\n</></>), but only for
    <command>COPY</> to a server file; for consistency across platforms,
    <command>COPY TO STDOUT</> always sends <quote><literal>\n</></>
    regardless of server platform.
    <command>COPY FROM</command> can handle lines ending with newlines,
    carriage returns, or carriage return/newlines.  To reduce the risk of
    error due to un-backslashed newlines or carriage returns that were
    meant as data, <command>COPY FROM</command> will complain if the line
    endings in the input are not all alike.
   </para>
-->
<para>
<command>COPY TO</command>将在每行的结尾用一个Unix风格的换行符(<quote><literal>\n</></>)。
运行在Windows上的服务器会输出的回车换行符(<quote><literal>\r\n</></>)，但只是用于<command>COPY</>到服务器 文件里；
为了在不同平台之间一致，<command>COPY TO STDOUT</>总是发送<quote><literal>\n</></>而不管服务器平台是什么。
<command>COPY FROM</command>可以处理那些以回车符、换行符、回车/换行符作为行结束的数据。
为了减少在数据中出现的未转义的新行或者回车导致的错误，如果输入的行结尾不像上面这些符号，<command>COPY FROM</command>会发出警告。
</para>
  </refsect2>

  <refsect2>
<!--
   <title>CSV Format</title>
-->
   <title>CSV 格式</title>

   <!--
<para>
    This format option is used for importing and exporting the Comma
    Separated Value (<literal>CSV</>) file format used by many other
    programs, such as spreadsheets. Instead of the escaping rules used by
    <productname>PostgreSQL</productname>'s standard text format, it
    produces and recognizes the common CSV escaping mechanism.
   </para>
-->
<para>
这个格式用于输入和输出逗号分隔数值(<literal>CSV</>)文件格式，许多其它程序都用这个文件格式，比如电子表格。
这个模式下生成并识别逗号分隔的CSV转义机制，而不是使用<productname>PostgreSQL</productname>标准文本的转义模式。 
</para>

   <!--
<para>
    The values in each record are separated by the <literal>DELIMITER</>
    character. If the value contains the delimiter character, the
    <literal>QUOTE</> character, the <literal>NULL</> string, a carriage
    return, or line feed character, then the whole value is prefixed and
    suffixed by the <literal>QUOTE</> character, and any occurrence
    within the value of a <literal>QUOTE</> character or the
    <literal>ESCAPE</> character is preceded by the escape character.
    You can also use <literal>FORCE_QUOTE</> to force quotes when outputting
    non-<literal>NULL</> values in specific columns.
   </para>
-->
<para>
每条记录的值都是用<literal>DELIMITER</>字符分隔的。
如果数值本身包含分隔字符、<literal>QUOTE</>字符、<literal>NULL</>字符串、回车符、换行符，那么整个数值用<literal>QUOTE</>字符前缀和后缀(包围)，
并且数值里任何<literal>QUOTE</>字符或<literal>ESCAPE</>字符都前导转义字符。
你也可以使用<literal>FORCE_QUOTE</>在输出非<literal>NULL</>的指定字段值时强制引号包围。 
</para>

   <!--
<para>
    The <literal>CSV</> format has no standard way to distinguish a
    <literal>NULL</> value from an empty string.
    <productname>PostgreSQL</>'s <command>COPY</> handles this by quoting.
    A <literal>NULL</> is output as the <literal>NULL</> parameter string
    and is not quoted, while a non-<literal>NULL</> value matching the
    <literal>NULL</> parameter string is quoted.  For example, with the
    default settings, a <literal>NULL</> is written as an unquoted empty
    string, while an empty string data value is written with double quotes
    (<literal>""</>). Reading values follows similar rules. You can
    use <literal>FORCE_NOT_NULL</> to prevent <literal>NULL</> input
    comparisons for specific columns.
   </para>
-->
<para>
<literal>CSV</>格式没有标准的办法区分一个<literal>NULL</>值和一个空字符串。
 <productname>PostgreSQL</>的<command>COPY</>通过引号包围来处理这些。
 一个当作<literal>NULL</> 输出的<literal>NULL</> 参数值是没有引号包围的，而匹配非<literal>NULL</>字符串的参数值是用引号包围的。
 比如，使用缺省设置时，一个<literal>NULL</>是写做一个无引号包围的空字符串，而一个空字符串数值写做 双引号包围(<literal>""</>)。
 读取数值也遵循类似的规则。 你可以使用<literal>FORCE_NOT_NULL</>来避免为特定字段进行<literal>NULL</>比较。 
</para>

   <!--
<para>
    Because backslash is not a special character in the <literal>CSV</>
    format, <literal>\.</>, the end-of-data marker, could also appear
    as a data value.  To avoid any misinterpretation, a <literal>\.</>
    data value appearing as a lone entry on a line is automatically
    quoted on output, and on input, if quoted, is not interpreted as the
    end-of-data marker.  If you are loading a file created by another
    application that has a single unquoted column and might have a
    value of <literal>\.</>, you might need to quote that value in the
    input file.
   </para>
-->
<para>
因为对于<literal>CSV</>格式而言，反斜杠不是特殊字符，数据的结束标志(<literal>\.</>) 可以作为数据值出现。
为了避免任何可能的歧意，一个单独的<literal>\.</>数据值在输出中将被自动使用引号包围；
在输入中，如果被引号界定，那么将不会当作数据结束标志。如果你要加载其它程序创建的、有未用引号界定字段的文件，并且其中含有<literal>\.</>值，你就必须用引号进行界定。
</para>

   <note>
    <!--
<para>
     In <literal>CSV</> format, all characters are significant. A quoted value
     surrounded by white space, or any characters other than
     <literal>DELIMITER</>, will include those characters. This can cause
     errors if you import data from a system that pads <literal>CSV</>
     lines with white space out to some fixed width. If such a situation
     arises you might need to preprocess the <literal>CSV</> file to remove
     the trailing white space, before importing the data into
     <productname>PostgreSQL</>.
    </para>
-->
<para>
在<literal>CSV</>模式下，所有字符都是有效的。
一个被空白包围的引号界定数值，或者任何非<literal>DELIMITER</>字符，都会被包含这些字符。
如果你给<literal>CSV</>行填充空白的系统里导入数据到定长字段，那么可能会导致错误。
如果出现这种情况，你可能需要先 处理一下<literal>CSV</>文件，删除结尾空白，然后再向<productname>PostgreSQL</>里导入数据。
</para>
   </note>

   <note>
    <!--
<para>
     CSV format will both recognize and produce CSV files with quoted
     values containing embedded carriage returns and line feeds. Thus
     the files are not strictly one line per table row like text-format
     files.
    </para>
-->
<para>
CSV格式可以识别和生成引号包围的回车和换行的CSV文件。因此这些文件并不像文本模式的文件那样严格地每条记录一行。
</para>
   </note>

   <note>
    <!--
<para>
     Many programs produce strange and occasionally perverse CSV files,
     so the file format is more a convention than a standard. Thus you
     might encounter some files that cannot be imported using this
     mechanism, and <command>COPY</> might produce files that other
     programs cannot process.
    </para>
-->
<para>
许多程序生成奇怪的并且有时候不正确的CSV文件，所以这个文件格式更像一种惯用格式，而不是一种标准。
因此你可能碰到一些不能使用这个机制输入的文件，而<command>COPY</>也可能生成一些其它程序不能处理的文件。 
</para>
   </note>

  </refsect2>

  <refsect2>
<!--
   <title>Binary Format</title>
  -->
<title>二进制格式</title>

   <!--
<para>
    The <literal>binary</literal> format option causes all data to be
    stored/read as binary format rather than as text.  It is
    somewhat faster than the text and <literal>CSV</> formats,
    but a binary-format file is less portable across machine architectures and
    <productname>PostgreSQL</productname> versions.
    Also, the binary format is very data type specific; for example
    it will not work to output binary data from a <type>smallint</> column
    and read it into an <type>integer</> column, even though that would work
    fine in text format.
   </para>
-->
<para>
<literal>binary</literal>形式的选项会使得所有的数据被存储/读作二进制格式而不是文本。
这比文本和<literal>CSV</>格式的要快一些，但是一个二进制格式文件在机器架构和<productname>PostgreSQL</productname>版本之间的可移植性比较差。
另外，二进制格式是对数据类型有一定要求的；例如，不能从<type>smallint</>列中输出二进制数据
并将二进制数据读入<type>integer</>列，尽管在文本格式下那会运行良好。
</para>

   <!--
<para>
    The <literal>binary</> file format consists
    of a file header, zero or more tuples containing the row data, and
    a file trailer.  Headers and data are in network byte order.
   </para>
-->
<para>
<literal>binary</>文件格式包含一个文件头，0或更多包含行数据的元组，以及一个文件尾。头和数据按照网络字节顺序。 
</para>

   <note>
    <!--
<para>
     <productname>PostgreSQL</productname> releases before 7.4 used a
     different binary file format.
    </para>
-->
<para>
 7.4版本之前的<productname>PostgreSQL</productname>版本使用的是不同的二进制文件格式。 
</para>
   </note>

   <refsect3>
<!--
    <title>File Header</title>
-->
    <title>文件头</title>

<!--
<para>
     The file header consists of 15 bytes of fixed fields, followed
     by a variable-length header extension area.  The fixed fields are:
</para>
-->
<para>
文件头由15个字节的固定域组成，后面跟着一个变长的头扩展区。固定域是： 
</para>

    <variablelist>
     <varlistentry>
<!--
<term>Signature</term>
-->
      <term>签名</term>
      <listitem>
      <!--
       <para>
11-byte sequence <literal>PGCOPY\n\377\r\n\0</> &mdash; note that the zero byte
is a required part of the signature.  (The signature is designed to allow
easy identification of files that have been munged by a non-8-bit-clean
transfer.  This signature will be changed by end-of-line-translation
filters, dropped zero bytes, dropped high bits, or parity changes.)
       </para>
       -->
       <para>
11字节的序列<literal>PGCOPY\n\377\r\n\0</>&mdash;，请注意字节零是签名必须的一部分。
（使用这个签名是为了能够很容易看出文件是否已经被一个非8位安全的转换器给破坏了。 
这个签名会被行尾转换过滤器、删除字节零、删除高位、奇偶变化而改变。） 
</para>

      </listitem>
     </varlistentry>

     <varlistentry>
     <!--
      <term>Flags field</term>
      -->
      <term>标志域</term>

      <listitem>
      <!--
<para>
32-bit integer bit mask to denote important aspects of the file format. Bits
are numbered from 0 (<acronym>LSB</>) to 31 (<acronym>MSB</>).  Note that
this field is stored in network byte order (most significant byte first),
as are all the integer fields used in the file format.  Bits
16-31 are reserved to denote critical file format issues; a reader
should abort if it finds an unexpected bit set in this range. Bits 0-15
are reserved to signal backwards-compatible format issues; a reader
should simply ignore any unexpected bits set in this range. Currently
only one flag bit is defined, and the rest must be zero:
</para>
-->
<para>
32位整数掩码表示该文件格式的重要方面。
位是从 0(<acronym>LSB</>)到 31(<acronym>MSB</>) 编码的，请注意这个域是以网络字节顺序存储的(高位在前)，后继的整数都是如此。
位16-31是 保留用做关键文件格式信息的；
如果阅读器发现一个不认识的位出现在这个范围内，那么它应该退出。 
位0-15都保留为标志向后兼容的格式使用；阅读器可以忽略这个范围内的不认识的位。
目前只定义了 一个标志位，而其它的必须是零： 
</para>


<variablelist>
         <varlistentry>
          <term>Bit 16</term>
          <listitem>
  <!--
           <para>
            if 1, OIDs are included in the data; if 0, not
           </para>
   -->
           <para>
   如果为1，那么在数据中包括了OIDS；如果为0，则没有。 
           </para>

          </listitem>
         </varlistentry>
        </variablelist>


      </listitem>
     </varlistentry>

     <varlistentry>
    <!--
      <term>Header extension area length</term>
      -->
      <term>头扩展范围长度</term>
      <listitem>
       <!--
<para>
32-bit integer, length in bytes of remainder of header, not including self.
Currently, this is zero, and the first tuple follows
immediately.  Future changes to the format might allow additional data
to be present in the header.  A reader should silently skip over any header
extension data it does not know what to do with.
       </para>
-->
<para>
32位整数，以字节计的头剩余长度，不包括自身。
目前，它是零，后面紧跟第一条记录行。
对该格式的更多修改都将允许额外的数据出现在头中。
阅读器应该忽略任何它不知道该如何处理的头扩展数据。 
</para>
      </listitem>
     </varlistentry>
    </variablelist>


    <!--
<para>
The header extension area is envisioned to contain a sequence of
self-identifying chunks.  The flags field is not intended to tell readers
what is in the extension area.  Specific design of header extension contents
is left for a later release.
    </para>
-->
<para>
头扩展数据用来保存自定义数据序列块。
这个标志域无意告诉阅读器扩展区的内容是什么。 
头扩展的具体设计内容留给以后的版本使用。 
</para>

    <!--
<para>
     This design allows for both backwards-compatible header additions (add
     header extension chunks, or set low-order flag bits) and
     non-backwards-compatible changes (set high-order flag bits to signal such
     changes, and add supporting data to the extension area if needed).
    </para>
-->
<para>
这样设计就允许向后兼容的头扩展(增加头扩展块或设置低位序标志位)以及非向后兼容的修改(设置高位标志位以标识这样的修改，并且根据需要向扩展区域增加支持数据)。 
</para>
   </refsect3>

   <refsect3>
   <!--
    <title>Tuples</title>
    -->
    <title>行记录</title>
    <!--
<para>
Each tuple begins with a 16-bit integer count of the number of fields in the
tuple.  (Presently, all tuples in a table will have the same count, but that
might not always be true.)  Then, repeated for each field in the tuple, there
is a 32-bit length word followed by that many bytes of field data.  (The
length word does not include itself, and can be zero.)  As a special case,
-1 indicates a NULL field value.  No value bytes follow in the NULL case.
    </para>
-->
<para>
每条行都以一个16位整数计数开头，该计数是行中字段的数目(目前，在一个表里的每行都有相同的计数，但可能不会永远这样)。
然后后面不断出现行中的各个字段，字段先是一个32位的长度字，后面跟着很多的字段数据。长度字并不包括自己，并且可以为零。
一个特例是：-1表示一个NULL字段值。在NULL情况下，后面不会跟着数值字节。 
</para>

    <!--
<para>
There is no alignment padding or any other extra data between fields.
    </para>
-->
<para>
在数据域之间没有对齐填充或者任何其它额外的数据。
</para>

    <!--
<para>
Presently, all data values in a binary-format file are
assumed to be in binary format (format code one).  It is anticipated that a
future extension might add a header field that allows per-column format codes
to be specified.
    </para>
-->
<para>
目前，一个二进制格式文件里的所有数据值都假设是二进制格式的(格式代码为一)。
预计将来的扩展可能增加一个头域，允许为每个字段声明格式代码。 
</para>

    <!--
<para>
To determine the appropriate binary format for the actual tuple data you
should consult the <productname>PostgreSQL</productname> source, in
particular the <function>*send</> and <function>*recv</> functions for
each column's data type (typically these functions are found in the
<filename>src/backend/utils/adt/</filename> directory of the source
distribution).
    </para>
-->
<para>
为了判断实际行数据的正确二进制格式，你应该阅读<productname>PostgreSQL</productname>源代码，特别是该字段数据类型的<function>*send</>和<function>*recv</>函数
(这些函数可以在源代码的<filename>src/backend/utils/adt/</filename>目录找到)。 
</para>

    <!--
<para>
If OIDs are included in the file, the OID field immediately follows the
field-count word.  It is a normal field except that it's not included
in the field-count.  In particular it has a length word &mdash; this will allow
handling of 4-byte vs. 8-byte OIDs without too much pain, and will allow
OIDs to be shown as null if that ever proves desirable.
    </para>
-->
<para>
如果在文件中包括了OIDs，那么该OID域立即跟在字段计数字后面。
它是一个普通的字段， 只不过它没有包括在字段计数。
但它包括长度字，这样就允许方便的处理4字节和8字节的OIDs，并且如果某个家伙允许OIDs是可选的话，那么还可以把OIDs显示成空。 
</para>
   </refsect3>

   <refsect3>
   <!--
    <title>File Trailer</title>
    -->
    <title>文件尾</title>

    <!--
<para>
     The file trailer consists of a 16-bit integer word containing -1.  This
     is easily distinguished from a tuple's field-count word.
    </para>
-->
<para>
文件尾包括保存着-1的一个16位整数字。这样就很容易与一条行的域计数字相区分。 
</para>

    <!--
<para>
     A reader should report an error if a field-count word is neither -1
     nor the expected number of columns.  This provides an extra
     check against somehow getting out of sync with the data.
    </para>
-->
<para>
如果一个域计数字既不是-1也不是预期的字段的数目，那么阅读器应该报错。这样就提供了对丢失与数据同步的额外检查。 
</para>
   </refsect3>
  </refsect2>
 </refsect1>

 <refsect1>
  <!--
<title>Examples</title>
-->
<title>例子</title>

  <!--
<para>
   The following example copies a table to the client
   using the vertical bar (<literal>|</literal>) as the field delimiter:
<programlisting>
COPY country TO STDOUT (DELIMITER '|');
</programlisting>
  </para>
-->
<para>
下面的例子把一个表拷贝到客户端，使用竖线(<literal>|</literal>)作为域分隔符： 
<programlisting>
COPY country TO STDOUT (DELIMITER '|');
</programlisting>
</para>

  <!--
<para>
   To copy data from a file into the <literal>country</> table:
<programlisting>
COPY country FROM '/usr1/proj/bray/sql/country_data';
</programlisting>
  </para>
-->
<para>
从文件中拷贝数据到<literal>country</>表中： 
<programlisting>
COPY country FROM '/usr1/proj/bray/sql/country_data';
</programlisting>
</para>

  <!--
<para>
   To copy into a file just the countries whose names start with 'A':
<programlisting>
COPY (SELECT * FROM country WHERE country_name LIKE 'A%') TO '/usr1/proj/bray/sql/a_list_countries.copy';
</programlisting>
  </para>
-->
<para>
把'A'开头的国家名拷贝到一个文件里： 
<programlisting>
COPY (SELECT * FROM country WHERE country_name LIKE 'A%') TO '/usr1/proj/bray/sql/a_list_countries.copy';
</programlisting>
</para>

  <!--
<para>
   To copy into a compressed file, you can pipe the output through an external
   compression program:
<programlisting>
COPY country TO PROGRAM 'gzip > /usr1/proj/bray/sql/country_data.gz';
</programlisting>
  </para>
-->
<para>
可以通过将输出数据通过管道方式重定向至一个外部压缩程序的方式将数据拷贝至一个压缩文件中：
<programlisting>
COPY country TO PROGRAM 'gzip > /usr1/proj/bray/sql/country_data.gz';
</programlisting>
</para>

  <!--
<para>
   Here is a sample of data suitable for copying into a table from
   <literal>STDIN</literal>:
<programlisting>
AF      AFGHANISTAN
AL      ALBANIA
DZ      ALGERIA
ZM      ZAMBIA
ZW      ZIMBABWE
</programlisting>
   Note that the white space on each line is actually a tab character.
  </para>
-->
<para>
下面是一个可以从<literal>STDIN</literal>中拷贝数据到表中的例子：
<programlisting>
AF      AFGHANISTAN
AL      ALBANIA
DZ      ALGERIA
ZM      ZAMBIA
ZW      ZIMBABWE
</programlisting>
注意，每行里的空白实际上是一个水平制表符。 
</para>

  <!--
<para>
   The following is the same data, output in binary format.
   The data is shown after filtering through the
   Unix utility <command>od -c</command>. The table has three columns;
   the first has type <type>char(2)</type>, the second has type <type>text</type>,
   and the third has type <type>integer</type>. All the rows have a null value
   in the third column.
<programlisting>
0000000   P   G   C   O   P   Y  \n 377  \r  \n  \0  \0  \0  \0  \0  \0
0000020  \0  \0  \0  \0 003  \0  \0  \0 002   A   F  \0  \0  \0 013   A
0000040   F   G   H   A   N   I   S   T   A   N 377 377 377 377  \0 003
0000060  \0  \0  \0 002   A   L  \0  \0  \0 007   A   L   B   A   N   I
0000100   A 377 377 377 377  \0 003  \0  \0  \0 002   D   Z  \0  \0  \0
0000120 007   A   L   G   E   R   I   A 377 377 377 377  \0 003  \0  \0
0000140  \0 002   Z   M  \0  \0  \0 006   Z   A   M   B   I   A 377 377
0000160 377 377  \0 003  \0  \0  \0 002   Z   W  \0  \0  \0  \b   Z   I
0000200   M   B   A   B   W   E 377 377 377 377 377 377
</programlisting>
</para>
-->
<para>
下面的是同样的数据，以二进制形式输出。
这些数据是用Unix工具<command>od -c</command>过滤之后输出的。
该表有三个字段；第一个是<type>char(2)</type>，第二个是<type>text</type>，第三个是<type>integer</type>。
所有的行在第三个域都是一个null值。 
<programlisting>
0000000   P   G   C   O   P   Y  \n 377  \r  \n  \0  \0  \0  \0  \0  \0
0000020  \0  \0  \0  \0 003  \0  \0  \0 002   A   F  \0  \0  \0 013   A
0000040   F   G   H   A   N   I   S   T   A   N 377 377 377 377  \0 003
0000060  \0  \0  \0 002   A   L  \0  \0  \0 007   A   L   B   A   N   I
0000100   A 377 377 377 377  \0 003  \0  \0  \0 002   D   Z  \0  \0  \0
0000120 007   A   L   G   E   R   I   A 377 377 377 377  \0 003  \0  \0
0000140  \0 002   Z   M  \0  \0  \0 006   Z   A   M   B   I   A 377 377
0000160 377 377  \0 003  \0  \0  \0 002   Z   W  \0  \0  \0  \b   Z   I
0000200   M   B   A   B   W   E 377 377 377 377 377 377
</programlisting>
</para>
 </refsect1>

 <refsect1>
  <!--
<title>Compatibility</title>
-->
<title>兼容性</title>

  <!--
<para>
   There is no <command>COPY</command> statement in the SQL standard.
  </para>
-->
<para>
SQL标准里没有<command>COPY</command>语句。 
</para>

  <!--
<para>
   The following syntax was used before <productname>PostgreSQL</>
   version 9.0 and is still supported:

<synopsis>
COPY <replaceable class="parameter">table_name</replaceable> [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ]
    FROM { '<replaceable class="parameter">filename</replaceable>' | STDIN }
    [ [ WITH ]
          [ BINARY ]
          [ OIDS ]
          [ DELIMITER [ AS ] '<replaceable class="parameter">delimiter</replaceable>' ]
          [ NULL [ AS ] '<replaceable class="parameter">null string</replaceable>' ]
          [ CSV [ HEADER ]
                [ QUOTE [ AS ] '<replaceable class="parameter">quote</replaceable>' ]
                [ ESCAPE [ AS ] '<replaceable class="parameter">escape</replaceable>' ]
                [ FORCE NOT NULL <replaceable class="parameter">column_name</replaceable> [, ...] ] ] ]

COPY { <replaceable class="parameter">table_name</replaceable> [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ] | ( <replaceable class="parameter">query</replaceable> ) }
    TO { '<replaceable class="parameter">filename</replaceable>' | STDOUT }
    [ [ WITH ]
          [ BINARY ]
          [ OIDS ]
          [ DELIMITER [ AS ] '<replaceable class="parameter">delimiter</replaceable>' ]
          [ NULL [ AS ] '<replaceable class="parameter">null string</replaceable>' ]
          [ CSV [ HEADER ]
                [ QUOTE [ AS ] '<replaceable class="parameter">quote</replaceable>' ]
                [ ESCAPE [ AS ] '<replaceable class="parameter">escape</replaceable>' ]
                [ FORCE QUOTE { <replaceable class="parameter">column_name</replaceable> [, ...] | * } ] ] ]
</synopsis>

   Note that in this syntax, <literal>BINARY</> and <literal>CSV</> are
   treated as independent keywords, not as arguments of a <literal>FORMAT</>
   option.
  </para>
-->
<para>
PostgreSQL9.0以前使用下面的语法，现在仍然支持：
<synopsis>
COPY <replaceable class="parameter">table_name</replaceable> [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ]
    FROM { '<replaceable class="parameter">filename</replaceable>' | STDIN }
    [ [ WITH ]
          [ BINARY ]
          [ OIDS ]
          [ DELIMITER [ AS ] '<replaceable class="parameter">delimiter</replaceable>' ]
          [ NULL [ AS ] '<replaceable class="parameter">null string</replaceable>' ]
          [ CSV [ HEADER ]
                [ QUOTE [ AS ] '<replaceable class="parameter">quote</replaceable>' ]
                [ ESCAPE [ AS ] '<replaceable class="parameter">escape</replaceable>' ]
                [ FORCE NOT NULL <replaceable class="parameter">column_name</replaceable> [, ...] ] ] ]

COPY { <replaceable class="parameter">table_name</replaceable> [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ] | ( <replaceable class="parameter">query</replaceable> ) }
    TO { '<replaceable class="parameter">filename</replaceable>' | STDOUT }
    [ [ WITH ]
          [ BINARY ]
          [ OIDS ]
          [ DELIMITER [ AS ] '<replaceable class="parameter">delimiter</replaceable>' ]
          [ NULL [ AS ] '<replaceable class="parameter">null string</replaceable>' ]
          [ CSV [ HEADER ]
                [ QUOTE [ AS ] '<replaceable class="parameter">quote</replaceable>' ]
                [ ESCAPE [ AS ] '<replaceable class="parameter">escape</replaceable>' ]
                [ FORCE QUOTE { <replaceable class="parameter">column_name</replaceable> [, ...] | * } ] ] ]
</synopsis>
请注意：在这个语法中，<literal>BINARY</>和<literal>CSV</>是作为独立的关键字，而不是作为<literal>FORMAT</>选项的一个参数。 
</para>

  <!--
<para>
   The following syntax was used before <productname>PostgreSQL</>
   version 7.3 and is still supported:

<synopsis>
COPY [ BINARY ] <replaceable class="parameter">table_name</replaceable> [ WITH OIDS ]
    FROM { '<replaceable class="parameter">filename</replaceable>' | STDIN }
    [ [USING] DELIMITERS '<replaceable class="parameter">delimiter</replaceable>' ]
    [ WITH NULL AS '<replaceable class="parameter">null string</replaceable>' ]

COPY [ BINARY ] <replaceable class="parameter">table_name</replaceable> [ WITH OIDS ]
    TO { '<replaceable class="parameter">filename</replaceable>' | STDOUT }
    [ [USING] DELIMITERS '<replaceable class="parameter">delimiter</replaceable>' ]
    [ WITH NULL AS '<replaceable class="parameter">null string</replaceable>' ]
</synopsis>
</para>
-->
<para>
<productname>PostgreSQL</>7.3以前使用下面的语法，现在仍然支持： 
<synopsis>
COPY [ BINARY ] <replaceable class="parameter">table_name</replaceable> [ WITH OIDS ]
    FROM { '<replaceable class="parameter">filename</replaceable>' | STDIN }
    [ [USING] DELIMITERS '<replaceable class="parameter">delimiter</replaceable>' ]
    [ WITH NULL AS '<replaceable class="parameter">null string</replaceable>' ]

COPY [ BINARY ] <replaceable class="parameter">table_name</replaceable> [ WITH OIDS ]
    TO { '<replaceable class="parameter">filename</replaceable>' | STDOUT }
    [ [USING] DELIMITERS '<replaceable class="parameter">delimiter</replaceable>' ]
    [ WITH NULL AS '<replaceable class="parameter">null string</replaceable>' ]
</synopsis>
</para>
 </refsect1>
</refentry>
