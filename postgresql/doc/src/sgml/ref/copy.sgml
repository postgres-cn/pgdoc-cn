<!--
doc/src/sgml/ref/copy.sgml
PostgreSQL documentation
-->

<refentry id="sql-copy">
<!-- pgdoc-cn_start sig_en=3c48ef573588e4d0d71efc5a81688c0e sig_cn_org=None source=14.1 
 <indexterm zone="sql-copy">
  <primary>COPY</primary>
 </indexterm>
________________________________________________________-->
 <indexterm zone="sql-copy">
  <primary>COPY</primary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=3c48ef573588e4d0d71efc5a81688c0e -->

 <refmeta>
  <refentrytitle>COPY</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

<!-- pgdoc-cn_start sig_en=07aee8402ae9fb974a52f2d28d8b1140 sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>COPY</refname>
  <refpurpose>copy data between a file and a table</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>COPY</refname>
  <refpurpose>在一个文件和一个表之间复制数据</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=07aee8402ae9fb974a52f2d28d8b1140 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=a53ffd9445b2de31b3a5ddf1c7ba4ffe sig_cn_org=a53ffd9445b2de31b3a5ddf1c7ba4ffe source=15.7 
<synopsis>
COPY <replaceable class="parameter">table_name</replaceable> [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ]
    FROM { '<replaceable class="parameter">filename</replaceable>' | PROGRAM '<replaceable class="parameter">command</replaceable>' | STDIN }
    [ [ WITH ] ( <replaceable class="parameter">option</replaceable> [, ...] ) ]
    [ WHERE <replaceable class="parameter">condition</replaceable> ]

COPY { <replaceable class="parameter">table_name</replaceable> [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ] | ( <replaceable class="parameter">query</replaceable> ) }
    TO { '<replaceable class="parameter">filename</replaceable>' | PROGRAM '<replaceable class="parameter">command</replaceable>' | STDOUT }
    [ [ WITH ] ( <replaceable class="parameter">option</replaceable> [, ...] ) ]

<phrase>where <replaceable class="parameter">option</replaceable> can be one of:</phrase>

    FORMAT <replaceable class="parameter">format_name</replaceable>
    FREEZE [ <replaceable class="parameter">boolean</replaceable> ]
    DELIMITER '<replaceable class="parameter">delimiter_character</replaceable>'
    NULL '<replaceable class="parameter">null_string</replaceable>'
    HEADER [ <replaceable class="parameter">boolean</replaceable> | MATCH ]
    QUOTE '<replaceable class="parameter">quote_character</replaceable>'
    ESCAPE '<replaceable class="parameter">escape_character</replaceable>'
    FORCE_QUOTE { ( <replaceable class="parameter">column_name</replaceable> [, ...] ) | * }
    FORCE_NOT_NULL ( <replaceable class="parameter">column_name</replaceable> [, ...] )
    FORCE_NULL ( <replaceable class="parameter">column_name</replaceable> [, ...] )
    ENCODING '<replaceable class="parameter">encoding_name</replaceable>'
</synopsis>
________________________________________________________-->
<synopsis>
COPY <replaceable class="parameter">table_name</replaceable> [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ]
    FROM { '<replaceable class="parameter">filename</replaceable>' | PROGRAM '<replaceable class="parameter">command</replaceable>' | STDIN }
    [ [ WITH ] ( <replaceable class="parameter">option</replaceable> [, ...] ) ]
    [ WHERE <replaceable class="parameter">condition</replaceable> ]

COPY { <replaceable class="parameter">table_name</replaceable> [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ] | ( <replaceable class="parameter">query</replaceable> ) }
    TO { '<replaceable class="parameter">filename</replaceable>' | PROGRAM '<replaceable class="parameter">command</replaceable>' | STDOUT }
    [ [ WITH ] ( <replaceable class="parameter">option</replaceable> [, ...] ) ]

<phrase>where <replaceable class="parameter">option</replaceable> can be one of:</phrase>

    FORMAT <replaceable class="parameter">format_name</replaceable>
    FREEZE [ <replaceable class="parameter">boolean</replaceable> ]
    DELIMITER '<replaceable class="parameter">delimiter_character</replaceable>'
    NULL '<replaceable class="parameter">null_string</replaceable>'
    HEADER [ <replaceable class="parameter">boolean</replaceable> | MATCH ]
    QUOTE '<replaceable class="parameter">quote_character</replaceable>'
    ESCAPE '<replaceable class="parameter">escape_character</replaceable>'
    FORCE_QUOTE { ( <replaceable class="parameter">column_name</replaceable> [, ...] ) | * }
    FORCE_NOT_NULL ( <replaceable class="parameter">column_name</replaceable> [, ...] )
    FORCE_NULL ( <replaceable class="parameter">column_name</replaceable> [, ...] )
    ENCODING '<replaceable class="parameter">encoding_name</replaceable>'
</synopsis>
<!-- pgdoc-cn_end sig_en=a53ffd9445b2de31b3a5ddf1c7ba4ffe -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=c91555ecb9c52ca579c4a101e084c5cc sig_cn_org=None source=14.1 
  <para>
   <command>COPY</command> moves data between
   <productname>PostgreSQL</productname> tables and standard file-system
   files. <command>COPY TO</command> copies the contents of a table
   <emphasis>to</emphasis> a file, while <command>COPY FROM</command> copies
   data <emphasis>from</emphasis> a file to a table (appending the data to
   whatever is in the table already).  <command>COPY TO</command>
   can also copy the results of a <command>SELECT</command> query.
  </para>
________________________________________________________-->
  <para>
   <command>COPY</command>在
   <productname>PostgreSQL</productname>表和标准文件系统文件之间
   移动数据。<command>COPY TO</command>把一个表的内容复制
   <emphasis>到</emphasis>一个文件，而<command>COPY FROM</command>
   则<emphasis>从</emphasis>一个文件复制数据到一个表（把数据追加到表中原有数
   据）。<command>COPY TO</command>也能复制一个
   <command>SELECT</command>查询的结果。
  </para>
<!-- pgdoc-cn_end sig_en=c91555ecb9c52ca579c4a101e084c5cc -->

<!-- pgdoc-cn_start sig_en=2fd4e8ebb6171e88e54a5c432be6b06b sig_cn_org=None source=14.1 
  <para>
   If a column list is specified, <command>COPY TO</command> copies only
   the data in the specified columns to the file.  For <command>COPY
   FROM</command>, each field in the file is inserted, in order, into the
   specified column.  Table columns not specified in the <command>COPY
   FROM</command> column list will receive their default values.
  </para>
________________________________________________________-->
  <para>
   如果指定了一个列列表，<command>COPY TO</command>将只把指定列的数据复制到文件。对于<command>COPY FROM</command>，文件中的每个字段将按顺序插入到指定列中。<command>COPY FROM</command>命令的列列表中没有指定的表列则会采纳其默认值。
  </para>
<!-- pgdoc-cn_end sig_en=2fd4e8ebb6171e88e54a5c432be6b06b -->

<!-- pgdoc-cn_start sig_en=d86dd40b31ed9e00e317565b382263d5 sig_cn_org=None source=14.1 
  <para>
   <command>COPY</command> with a file name instructs the
   <productname>PostgreSQL</productname> server to directly read from
   or write to a file. The file must be accessible by the
   <productname>PostgreSQL</productname> user (the user ID the server
   runs as) and the name must be specified from the viewpoint of the
   server. When <literal>PROGRAM</literal> is specified, the server
   executes the given command and reads from the standard output of the
   program, or writes to the standard input of the program. The command
   must be specified from the viewpoint of the server, and be executable
   by the <productname>PostgreSQL</productname> user.  When
   <literal>STDIN</literal> or <literal>STDOUT</literal> is
   specified, data is transmitted via the connection between the
   client and the server.
  </para>
________________________________________________________-->
  <para>
   带一个文件名的<command>COPY</command>指示
   <productname>PostgreSQL</productname>服务器直接从一个文件读取
   或者写入到一个文件。该文件必须是
   <productname>PostgreSQL</productname>用户（运行服务器的用户 ID）
   可访问的并且应该以服务器的视角来指定其名称。当指定了
   <literal>PROGRAM</literal>时，服务器执行给定的命令并且从该程序的标准
   输出读取或者写入到该程序的标准输入。该程序必须以服务器的视角指定，并且
   必须是<productname>PostgreSQL</productname>用户可执行的。在指定
   <literal>STDIN</literal>或者<literal>STDOUT</literal>时，数据会通过客
   户端和服务器之间的连接传输。
  </para>
<!-- pgdoc-cn_end sig_en=d86dd40b31ed9e00e317565b382263d5 -->

<!-- pgdoc-cn_start sig_en=b174fa82670c548e24b7a27cd8faf221 sig_cn_org=None source=14.1 
  <para>
    Each backend running <command>COPY</command> will report its progress
    in the <structname>pg_stat_progress_copy</structname> view. See
    <xref linkend="copy-progress-reporting"/> for details.
  </para>
________________________________________________________-->
  <para>
    运行<command>COPY</command>的每个后端将在
    <structname>pg_stat_progress_copy</structname>视图中报告其进度。
    有关详细信息，请参见<xref linkend="copy-progress-reporting"/>。
  </para>
<!-- pgdoc-cn_end sig_en=b174fa82670c548e24b7a27cd8faf221 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=55f21f3bddee6a8d223aa24ab57d80dc sig_cn_org=None source=14.1 
  <title>Parameters</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=55f21f3bddee6a8d223aa24ab57d80dc -->

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">table_name</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=bee2371f8b7b3b89298aad15bb57b9ba sig_cn_org=None source=14.1 
     <para>
      The name (optionally schema-qualified) of an existing table.
     </para>
________________________________________________________-->
     <para>
      一个现有表的名称（可以是模式限定的）。
     </para>
<!-- pgdoc-cn_end sig_en=bee2371f8b7b3b89298aad15bb57b9ba -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">column_name</replaceable></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=94d11d4038e52c5b0bbf8fb9dc5244cc sig_cn_org=None source=14.1 
     <para>
      An optional list of columns to be copied.  If no column list is
      specified, all columns of the table except generated columns will be
      copied.
     </para>
________________________________________________________-->
     <para>
      可选的要被复制的列列表。如果没有指定列列表，则该表的所有列除了生成的列都会被复制。
     </para>
<!-- pgdoc-cn_end sig_en=94d11d4038e52c5b0bbf8fb9dc5244cc -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">query</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=11ca2837326dbc730bc85b8e143fd514 sig_cn_org=None source=14.1 
     <para>
      A <link linkend="sql-select"><command>SELECT</command></link>,
      <link linkend="sql-values"><command>VALUES</command></link>,
      <link linkend="sql-insert"><command>INSERT</command></link>,
      <link linkend="sql-update"><command>UPDATE</command></link>, or
      <link linkend="sql-delete"><command>DELETE</command></link> command whose results are to be
      copied.  Note that parentheses are required around the query.
     </para>
________________________________________________________-->
     <para>
      其结果要被复制的<link linkend="sql-select"><command>SELECT</command></link>、
      <link linkend="sql-values"><command>VALUES</command></link>、
      <link linkend="sql-insert"><command>INSERT</command></link>、
      <link linkend="sql-update"><command>UPDATE</command></link>或者
      <link linkend="sql-delete"><command>DELETE</command></link>命令。
      注意查询周围的圆括号是必要的。
     </para>
<!-- pgdoc-cn_end sig_en=11ca2837326dbc730bc85b8e143fd514 -->
<!-- pgdoc-cn_start sig_en=34e975de91efed6b3f2ba520fe3f269c sig_cn_org=f156c48b12ca0918669c0793e08269c3 source=15.7 
     <para>
      For <command>INSERT</command>, <command>UPDATE</command> and
      <command>DELETE</command> queries a <literal>RETURNING</literal> clause
      must be provided, and the target relation must not have a conditional
      rule, nor an <literal>ALSO</literal> rule, nor an
      <literal>INSTEAD</literal> rule that expands to multiple statements.
     </para>
________________________________________________________-->
     <para>
      对于<command>INSERT</command>、<command>UPDATE</command>和
      <command>DELETE</command>查询，必须提供一个<literal>RETURNING</literal>子句，
      并且目标关系不能有条件规则，也不能有一个<literal>ALSO</literal>规则，
      也不能有一个扩展为多个语句的<literal>INSTEAD</literal>规则。
     </para>
<!-- pgdoc-cn_end sig_en=34e975de91efed6b3f2ba520fe3f269c -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">filename</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=f28f8b13c63b8bc920871238dfb07d47 sig_cn_org=None source=14.1 
     <para>
      The path name of the input or output file.  An input file name can be
      an absolute or relative path, but an output file name must be an absolute
      path.  Windows users might need to use an <literal>E''</literal> string and
      double any backslashes used in the path name.
     </para>
________________________________________________________-->
     <para>
      输入或者输出文件的路径名。一个输入文件的名称可以是一个绝对或相对路径，
      但一个输出文件的名称必须是绝对路径。Windows 用户可能需要使用一个
       <literal>E''</literal>字符串并且双写路径名称中使用的任何反斜线。
     </para>
<!-- pgdoc-cn_end sig_en=f28f8b13c63b8bc920871238dfb07d47 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>PROGRAM</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=75591b79c4d29ea061e685dec26a1491 sig_cn_org=None source=14.1 
     <para>
      A command to execute. In <command>COPY FROM</command>, the input is
      read from standard output of the command, and in <command>COPY TO</command>,
      the output is written to the standard input of the command.
     </para>
________________________________________________________-->
     <para>
      一个要执行的命令。在<command>COPY FROM</command>中，输入
      将从该命令的标准输出读取，而在<command>COPY TO</command>中，输出会
      写入到该命令的标准输入。
     </para>
<!-- pgdoc-cn_end sig_en=75591b79c4d29ea061e685dec26a1491 -->
<!-- pgdoc-cn_start sig_en=ea4597e328d353a254cd85208ba0054c sig_cn_org=None source=14.1 
     <para>
      Note that the command is invoked by the shell, so if you need to pass
      any arguments to shell command that come from an untrusted source, you
      must be careful to strip or escape any special characters that might
      have a special meaning for the shell. For security reasons, it is best
      to use a fixed command string, or at least avoid passing any user input
      in it.
     </para>
________________________________________________________-->
     <para>
      注意该命令是由 shell 调用，因此如果你需要传递任何来自不可信来源的
      参数给 shell 命令，你必须小心地剥离那些可能对 shell 有特殊意义的特殊
      字符。出于安全原因，最好使用一个固定的命令字符串，或者至少避免传递
      任何用户输入到其中。
     </para>
<!-- pgdoc-cn_end sig_en=ea4597e328d353a254cd85208ba0054c -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>STDIN</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=4bd8f35dbc028fd327bd62312eec40ec sig_cn_org=None source=14.1 
     <para>
      Specifies that input comes from the client application.
     </para>
________________________________________________________-->
     <para>
      指定输入来自客户端应用。
     </para>
<!-- pgdoc-cn_end sig_en=4bd8f35dbc028fd327bd62312eec40ec -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>STDOUT</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=722a3f45e0d1ff02f8ee31662ad4ad6c sig_cn_org=None source=14.1 
     <para>
      Specifies that output goes to the client application.
     </para>
________________________________________________________-->
     <para>
      指定输出会去到客户端应用。
     </para>
<!-- pgdoc-cn_end sig_en=722a3f45e0d1ff02f8ee31662ad4ad6c -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">boolean</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=8bf72cd4d6f8014b82e3bee2e1efc117 sig_cn_org=None source=14.1 
     <para>
      Specifies whether the selected option should be turned on or off.
      You can write <literal>TRUE</literal>, <literal>ON</literal>, or
      <literal>1</literal> to enable the option, and <literal>FALSE</literal>,
      <literal>OFF</literal>, or <literal>0</literal> to disable it.  The
      <replaceable class="parameter">boolean</replaceable> value can also
      be omitted, in which case <literal>TRUE</literal> is assumed.
     </para>
________________________________________________________-->
     <para>
      指定选中的选项是应该被关闭还是打开。可以写<literal>TRUE</literal>、
      <literal>ON</literal>或<literal>1</literal>来启用选项，写
      <literal>FALSE</literal>、<literal>OFF</literal>或<literal>0</literal>禁用它。
      <replaceable class="parameter">boolean</replaceable>值也可以被省略，
      那样会假定为<literal>TRUE</literal>。
     </para>
<!-- pgdoc-cn_end sig_en=8bf72cd4d6f8014b82e3bee2e1efc117 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FORMAT</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=b180403353f092e611e2f2a6faebbed5 sig_cn_org=None source=14.1 
     <para>
      Selects the data format to be read or written:
      <literal>text</literal>,
      <literal>csv</literal> (Comma Separated Values),
      or <literal>binary</literal>.
      The default is <literal>text</literal>.
     </para>
________________________________________________________-->
     <para>
      选择要读取或者写入的数据格式：
      <literal>text</literal>、
      <literal>csv</literal>（逗号分隔值）或者<literal>binary</literal>。
      默认是<literal>text</literal>。
     </para>
<!-- pgdoc-cn_end sig_en=b180403353f092e611e2f2a6faebbed5 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FREEZE</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=13dccde40798cea8495cac3efa3c5eaf sig_cn_org=None source=14.1 
     <para>
      Requests copying the data with rows already frozen, just as they
      would be after running the <command>VACUUM FREEZE</command> command.
      This is intended as a performance option for initial data loading.
      Rows will be frozen only if the table being loaded has been created
      or truncated in the current subtransaction, there are no cursors
      open and there are no older snapshots held by this transaction.  It is
      currently not possible to perform a <command>COPY FREEZE</command> on
      a partitioned table.
     </para>
________________________________________________________-->
     <para>
      请求复制已经完成了行冻结的数据，就好像在运行
      <command>VACUUM FREEZE</command>命令之后复制。这是为了初始
      数据载入的性能而设计的。只有被载入表已经在当前子事务中被创建
      或截断、该事务中没有游标打开并且该事务没有持有更旧的快照时，
      行才会被冻结。目前无法在分区表上执行<command>COPY FREEZE</command>。
     </para>
<!-- pgdoc-cn_end sig_en=13dccde40798cea8495cac3efa3c5eaf -->
<!-- pgdoc-cn_start sig_en=79cfe2aea6f965b8bea13c178fcd0254 sig_cn_org=None source=14.1 
     <para>
      Note that all other sessions will immediately be able to see the data
      once it has been successfully loaded. This violates the normal rules
      of MVCC visibility and users specifying should be aware of the
      potential problems this might cause.
     </para>
________________________________________________________-->
     <para>
      注意一旦成功地载入，所有其他会话将能立即看到该数据。这违背了
      普通的 MVCC 可见性规则，指定该选项的用户应该注意这可能会导致
      的潜在问题。
     </para>
<!-- pgdoc-cn_end sig_en=79cfe2aea6f965b8bea13c178fcd0254 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DELIMITER</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=d28790518a5262fda6c74f83e7d5a5cf sig_cn_org=None source=14.1 
     <para>
      Specifies the character that separates columns within each row
      (line) of the file.  The default is a tab character in text format,
      a comma in <literal>CSV</literal> format.
      This must be a single one-byte character.
      This option is not allowed when using <literal>binary</literal> format.
     </para>
________________________________________________________-->
     <para>
      指定分隔文件每行中各列的字符。文本格式中默认是一个制表符，
      而<literal>CSV</literal>格式中默认是一个逗号。这必须是一个单一
      的单字节字符。使用<literal>binary</literal>格式时不允许这个选项。
     </para>
<!-- pgdoc-cn_end sig_en=d28790518a5262fda6c74f83e7d5a5cf -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NULL</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=1d0abea65ed3a0f1d624b0c9cb7a4e6d sig_cn_org=None source=14.1 
     <para>
      Specifies the string that represents a null value. The default is
      <literal>\N</literal> (backslash-N) in text format, and an unquoted empty
      string in <literal>CSV</literal> format. You might prefer an
      empty string even in text format for cases where you don't want to
      distinguish nulls from empty strings.
      This option is not allowed when using <literal>binary</literal> format.
     </para>
________________________________________________________-->
     <para>
      指定表示一个空值的字符串。文本格式中默认是
      <literal>\N</literal>（反斜线-N），<literal>CSV</literal>格式中默认
      是一个未加引用的空串。在你不想区分空值和空串的情况下，即使在文本
      格式中你也可能更喜欢空串。使用<literal>binary</literal>格式时不允许这
      个选项。
     </para>
<!-- pgdoc-cn_end sig_en=1d0abea65ed3a0f1d624b0c9cb7a4e6d -->

     <note>
<!-- pgdoc-cn_start sig_en=13f29787b14e4855c4a8ab0a2ec88201 sig_cn_org=None source=14.1 
      <para>
       When using <command>COPY FROM</command>, any data item that matches
       this string will be stored as a null value, so you should make
       sure that you use the same string as you used with
       <command>COPY TO</command>.
      </para>
________________________________________________________-->
      <para>
       在使用<command>COPY FROM</command>时，任何匹配
       这个串的数据项将被存储为空值，因此你应该确定你使用的是和
       <command>COPY TO</command>时相同的串。
      </para>
<!-- pgdoc-cn_end sig_en=13f29787b14e4855c4a8ab0a2ec88201 -->
     </note>

    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>HEADER</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=a5629c9714e500728d504fc605bc5997 sig_cn_org=f0ebf3028dca843911415c33d25a6b8a source=15.7 
     <para>
      Specifies that the file contains a header line with the names of each
      column in the file.  On output, the first line contains the column
      names from the table.  On input, the first line is discarded when this
      option is set to <literal>true</literal> (or equivalent Boolean value).
      If this option is set to <literal>MATCH</literal>, the number and names
      of the columns in the header line must match the actual column names of
      the table, in order;  otherwise an error is raised.
      This option is not allowed when using <literal>binary</literal> format.
      The <literal>MATCH</literal> option is only valid for <command>COPY
      FROM</command> commands.
     </para>
________________________________________________________-->
     <para>
      指定文件包含一个带有文件中每列名称的标题行。在输出时，第一行包含表中的列名。
      在输入时，当此选项设置为<literal>true</literal>（或等效的布尔值）时，第一行将被丢弃。
      如果此选项设置为<literal>MATCH</literal>，则标题行中的列数和名称必须与表的实际列名按顺序匹配；否则将引发错误。
      当使用<literal>binary</literal>格式时，不允许使用此选项。
      <literal>MATCH</literal>选项仅对<command>COPY FROM</command>命令有效。
</para>
<!-- pgdoc-cn_end sig_en=a5629c9714e500728d504fc605bc5997 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>QUOTE</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=a77f24b9c5d9a75866b943fb8b6ba2af sig_cn_org=None source=14.1 
     <para>
      Specifies the quoting character to be used when a data value is quoted.
      The default is double-quote.
      This must be a single one-byte character.
      This option is allowed only when using <literal>CSV</literal> format.
     </para>
________________________________________________________-->
     <para>
      指定一个数据值被引用时使用的引用字符。默认是双引号。
      这必须是一个单一的单字节字符。只有使用
      <literal>CSV</literal>格式时才允许这个选项。
     </para>
<!-- pgdoc-cn_end sig_en=a77f24b9c5d9a75866b943fb8b6ba2af -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ESCAPE</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=5e2358fd73cc54fefd12c0b252b98bae sig_cn_org=None source=14.1 
     <para>
      Specifies the character that should appear before a
      data character that matches the <literal>QUOTE</literal> value.
      The default is the same as the <literal>QUOTE</literal> value (so that
      the quoting character is doubled if it appears in the data).
      This must be a single one-byte character.
      This option is allowed only when using <literal>CSV</literal> format.
     </para>
________________________________________________________-->
     <para>
      指定应该出现在一个匹配<literal>QUOTE</literal>值的数据字符之前
      的字符。默认和<literal>QUOTE</literal>值一样（这样如果引用字符
      出现在数据中，它会被双写）。这必须是一个单一的单字节字符。
      只有使用<literal>CSV</literal>格式时才允许这个选项。
     </para>
<!-- pgdoc-cn_end sig_en=5e2358fd73cc54fefd12c0b252b98bae -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FORCE_QUOTE</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=fdc7d9de465729bd38aacf5ca341ce0f sig_cn_org=None source=14.1 
     <para>
      Forces quoting to be
      used for all non-<literal>NULL</literal> values in each specified column.
      <literal>NULL</literal> output is never quoted. If <literal>*</literal> is specified,
      non-<literal>NULL</literal> values will be quoted in all columns.
      This option is allowed only in <command>COPY TO</command>, and only when
      using <literal>CSV</literal> format.
     </para>
________________________________________________________-->
     <para>
      强制必须对每个指定列中的所有非<literal>NULL</literal>值使用引用。
      <literal>NULL</literal>输出不会被引用。如果指定了<literal>*</literal>，
      所有列的非<literal>NULL</literal>值都将被引用。只有在
      <command>COPY TO</command>中使用<literal>CSV</literal>格式时才允许
      这个选项。
     </para>
<!-- pgdoc-cn_end sig_en=fdc7d9de465729bd38aacf5ca341ce0f -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FORCE_NOT_NULL</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=58b325b33826e012416a6b8c41b9e1c6 sig_cn_org=None source=14.1 
     <para>
      Do not match the specified columns' values against the null string.
      In the default case where the null string is empty, this means that
      empty values will be read as zero-length strings rather than nulls,
      even when they are not quoted.
      This option is allowed only in <command>COPY FROM</command>, and only when
      using <literal>CSV</literal> format.
     </para>
________________________________________________________-->
     <para>
      不要把指定列的值与空值串匹配。在空值串就是空串的默认情况下，
      这意味着空串将被读作长度为零的字符串而不是空值（即使它们没有
      被引用）。只有在<command>COPY FROM</command>中使用
      <literal>CSV</literal>格式时才允许这个选项。
     </para>
<!-- pgdoc-cn_end sig_en=58b325b33826e012416a6b8c41b9e1c6 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FORCE_NULL</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=4bba157866587852d12f189eca10bf06 sig_cn_org=None source=14.1 
     <para>
      Match the specified columns' values against the null string, even
      if it has been quoted, and if a match is found set the value to
      <literal>NULL</literal>. In the default case where the null string is empty,
      this converts a quoted empty string into NULL.
      This option is allowed only in <command>COPY FROM</command>, and only when
      using <literal>CSV</literal> format.
     </para>
________________________________________________________-->
     <para>
      将指定列的值与空值串匹配（即使它已经被加上引号），并且在找到
      匹配时将该值设置为<literal>NULL</literal>。在空值串就是空串的默认
      情况下，这会把一个被引用的空串转换为 NULL。
      只有在<command>COPY FROM</command>中使用
      <literal>CSV</literal>格式时才允许这个选项。
     </para>
<!-- pgdoc-cn_end sig_en=4bba157866587852d12f189eca10bf06 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ENCODING</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=fe9f618800cb0288fb6013e9f9c960fc sig_cn_org=None source=14.1 
     <para>
      Specifies that the file is encoded in the <replaceable
      class="parameter">encoding_name</replaceable>.  If this option is
      omitted, the current client encoding is used. See the Notes below
      for more details.
     </para>
________________________________________________________-->
     <para>
      指定文件被以<replaceable
      class="parameter">encoding_name</replaceable>编码。如果省略
      这个选项，将使用当前的客户端编码。详见下文的注解。
     </para>
<!-- pgdoc-cn_end sig_en=fe9f618800cb0288fb6013e9f9c960fc -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>WHERE</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=1e9f046ecf17114d04da8bc779f1df0c sig_cn_org=None source=14.1 
   <para>
    The optional <literal>WHERE</literal> clause has the general form
<synopsis>
WHERE <replaceable class="parameter">condition</replaceable>
</synopsis>
    where <replaceable class="parameter">condition</replaceable> is
    any expression that evaluates to a result of type
    <type>boolean</type>.  Any row that does not satisfy this
    condition will not be inserted to the table.  A row satisfies the
    condition if it returns true when the actual row values are
    substituted for any variable references.
   </para>
________________________________________________________-->
   <para>
    <literal>WHERE</literal>子句是可选的，其一般形式是：
<synopsis>
WHERE <replaceable class="parameter">condition</replaceable>
</synopsis>
    其中<replaceable class="parameter">condition</replaceable>是计算结果为<type>boolean</type>类型的任意表达式。任何不满足此条件的行都不会插入到表中。在用实际的行值替换任何变量引用时，如果该行返回true，则该行满足条件。
   </para>
<!-- pgdoc-cn_end sig_en=1e9f046ecf17114d04da8bc779f1df0c -->

<!-- pgdoc-cn_start sig_en=4fb2645b5c380e4d15ef88bfeb38bebc sig_cn_org=None source=14.1 
   <para>
    Currently, subqueries are not allowed in <literal>WHERE</literal>
    expressions, and the evaluation does not see any changes made by the
    <command>COPY</command> itself (this matters when the expression
    contains calls to <literal>VOLATILE</literal> functions).
   </para>
________________________________________________________-->
   <para>
    目前，在<literal>WHERE</literal>表达式中不允许使用子查询，并且值的计算不会看到<command>COPY</command>本身所做的任何更改（当表达式包含对<literal>VOLATILE</literal>函数的调用时，这一点很重要）。
   </para>
<!-- pgdoc-cn_end sig_en=4fb2645b5c380e4d15ef88bfeb38bebc -->

    </listitem>
   </varlistentry>

  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=83a929047ae9374bbfd2aa827d90c66a sig_cn_org=None source=14.1 
  <title>Outputs</title>
________________________________________________________-->
  <title>输出</title>
<!-- pgdoc-cn_end sig_en=83a929047ae9374bbfd2aa827d90c66a -->

<!-- pgdoc-cn_start sig_en=e27eac66c87ad1cb914a9e36a6117a51 sig_cn_org=None source=14.1 
  <para>
   On successful completion, a <command>COPY</command> command returns a command
   tag of the form
<screen>
COPY <replaceable class="parameter">count</replaceable>
</screen>
   The <replaceable class="parameter">count</replaceable> is the number
   of rows copied.
  </para>
________________________________________________________-->
  <para>
   在成功完成时，一个<command>COPY</command>命令会返回一个形为
<screen>
COPY <replaceable class="parameter">count</replaceable>
</screen>
   的命令标签。
   <replaceable class="parameter">count</replaceable>是被复制
   的行数。
  </para>
<!-- pgdoc-cn_end sig_en=e27eac66c87ad1cb914a9e36a6117a51 -->

  <note>
<!-- pgdoc-cn_start sig_en=dbfc1389a25284b66d36a1fa4802060f sig_cn_org=None source=14.1 
   <para>
    <application>psql</application> will print this command tag only if the command
    was not <literal>COPY ... TO STDOUT</literal>, or the
    equivalent <application>psql</application> meta-command
    <literal>\copy ... to stdout</literal>.  This is to prevent confusing the
    command tag with the data that was just printed.
   </para>
________________________________________________________-->
   <para>
    如果命令不是<literal>COPY ... TO STDOUT</literal>或者等效的
    <application>psql</application>元命令<literal>\copy ... to stdout</literal>，
    <application>psql</application>将只打印这个命令标签。这是为了防止弄混
    命令标签和刚刚打印的数据。
   </para>
<!-- pgdoc-cn_end sig_en=dbfc1389a25284b66d36a1fa4802060f -->
  </note>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 sig_cn_org=None source=14.1 
  <title>Notes</title>
________________________________________________________-->
  <title>注解</title>
<!-- pgdoc-cn_end sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 -->

<!-- pgdoc-cn_start sig_en=71543029bcfe018b96ef8aa877cfa953 sig_cn_org=None source=14.1 
   <para>
    <command>COPY TO</command> can be used only with plain
    tables, not views, and does not copy rows from child tables
    or child partitions.  For example, <literal>COPY <replaceable
    class="parameter">table</replaceable> TO</literal> copies
    the same rows as <literal>SELECT * FROM ONLY <replaceable
    class="parameter">table</replaceable></literal>.
    The syntax <literal>COPY (SELECT * FROM <replaceable
    class="parameter">table</replaceable>) TO ...</literal> can be used to
    dump all of the rows in an inheritance hierarchy, partitioned table,
    or view.
   </para>
________________________________________________________-->
   <para>
   <command>COPY TO</command>只能用于普通表，而不能用于视图，并且不能从子表或子分区复制行。
   例如，<literal>COPY <replaceable class="parameter">table</replaceable> TO</literal>
   复制与<literal>SELECT * FROM ONLY <replaceable class="parameter">table</replaceable></literal>
   相同的行。
   语法<literal>COPY (SELECT * FROM <replaceable class="parameter">table</replaceable>) TO ...</literal>
   可用于转储一个继承层次结构、分区表或视图中的所有行。
   </para>
<!-- pgdoc-cn_end sig_en=71543029bcfe018b96ef8aa877cfa953 -->

<!-- pgdoc-cn_start sig_en=d7895aa5cc7d2e47773cf05c7f282319 sig_cn_org=None source=14.1 
   <para>
    <command>COPY FROM</command> can be used with plain, foreign, or
    partitioned tables or with views that have
    <literal>INSTEAD OF INSERT</literal> triggers.
   </para>
________________________________________________________-->
   <para>
    <command>COPY FROM</command>可以被用于普通表、外部表、分区表或者具有<literal>INSTEAD OF INSERT</literal>触发器的视图。
   </para>
<!-- pgdoc-cn_end sig_en=d7895aa5cc7d2e47773cf05c7f282319 -->

<!-- pgdoc-cn_start sig_en=56cbbeb8ff44eda5bb43b712c877479a sig_cn_org=None source=14.1 
   <para>
    You must have select privilege on the table
    whose values are read by <command>COPY TO</command>, and
    insert privilege on the table into which values
    are inserted by <command>COPY FROM</command>.  It is sufficient
    to have column privileges on the column(s) listed in the command.
   </para>
________________________________________________________-->
   <para>
    你必须拥有被<command>COPY TO</command>读取的表上的选择特权，
    以及被<command>COPY FROM</command>插入的表上的插入特权。
    拥有在命令中列出的列上的特权就足够了。
   </para>
<!-- pgdoc-cn_end sig_en=56cbbeb8ff44eda5bb43b712c877479a -->

<!-- pgdoc-cn_start sig_en=bcf72ee260360bf46c83b2047ea3750f sig_cn_org=None source=14.1 
   <para>
    If row-level security is enabled for the table, the relevant
    <command>SELECT</command> policies will apply to <literal>COPY
    <replaceable class="parameter">table</replaceable> TO</literal> statements.
    Currently, <command>COPY FROM</command> is not supported for tables
    with row-level security. Use equivalent <command>INSERT</command>
    statements instead.
   </para>
________________________________________________________-->
   <para>
    如果对表启用了行级安全性，相关的<command>SELECT</command>策略将应用于<literal>COPY
    <replaceable class="parameter">table</replaceable> TO</literal>语句。当前，有行级安全性的表不支持<command>COPY FROM</command>。不过可以使用等效的<command>INSERT</command>语句。
   </para>
<!-- pgdoc-cn_end sig_en=bcf72ee260360bf46c83b2047ea3750f -->

<!-- pgdoc-cn_start sig_en=4799582f7d67f6b1fe5099da66660824 sig_cn_org=None source=14.1 
   <para>
    Files named in a <command>COPY</command> command are read or written
    directly by the server, not by the client application. Therefore,
    they must reside on or be accessible to the database server machine,
    not the client. They must be accessible to and readable or writable
    by the <productname>PostgreSQL</productname> user (the user ID the
    server runs as), not the client. Similarly,
    the command specified with <literal>PROGRAM</literal> is executed directly
    by the server, not by the client application, must be executable by the
    <productname>PostgreSQL</productname> user.
    <command>COPY</command> naming a file or command is only allowed to
    database superusers or users who are granted one of the roles
    <literal>pg_read_server_files</literal>,
    <literal>pg_write_server_files</literal>,
    or <literal>pg_execute_server_program</literal>, since it allows reading
    or writing any file or running a program that the server has privileges to
    access.
   </para>
________________________________________________________-->
   <para>
    <command>COPY</command>命令中提到的文件会被服务器（而不是
    客户端应用）直接读取或写入。因此它们必须位于数据库服务器（不是客户
    端）的机器上或者是数据库服务器可以访问的。它们必须是
    <productname>PostgreSQL</productname>用户（运行服务器的用户 
    ID）可访问的并且是可读或者可写的。类似地，用<literal>PROGRAM</literal>
    指定的命令也会由服务器（不是客户端应用）直接执行，它也必须是
    <productname>PostgreSQL</productname>用户可以执行的。
    只允许数据库超级用户或者授予了角色<literal>pg_read_server_files</literal>、
    <literal>pg_write_server_files</literal>及<literal>pg_execute_server_program</literal>
    之一的用户<command>COPY</command>一个文件或者命令，
    因为它允许读取或者写入服务器有特权访问的任何文件或者运行服务器有特权访问的程序。
   </para>
<!-- pgdoc-cn_end sig_en=4799582f7d67f6b1fe5099da66660824 -->

<!-- pgdoc-cn_start sig_en=334ac50a22c3c6f835eece44657b2a72 sig_cn_org=None source=14.1 
   <para>
    Do not confuse <command>COPY</command> with the
    <application>psql</application> instruction
    <command><link linkend="app-psql-meta-commands-copy">\copy</link></command>. <command>\copy</command> invokes
    <command>COPY FROM STDIN</command> or <command>COPY TO
    STDOUT</command>, and then fetches/stores the data in a file
    accessible to the <application>psql</application> client. Thus,
    file accessibility and access rights depend on the client rather
    than the server when <command>\copy</command> is used.
   </para>
________________________________________________________-->
   <para>
    不要把<command>COPY</command>和
    <application>psql</application>指令
    <command><link linkend="app-psql-meta-commands-copy">\copy</link></command>
    弄混。<command>\copy</command>会调用
    <command>COPY FROM STDIN</command>或者<command>COPY TO
    STDOUT</command>，然后读取/存储一个
    <application>psql</application>客户端可访问的文件中的数据。
    因此，在使用<command>\copy</command>时，文件的可访
    问性和访问权利取决于客户端而不是服务器。
   </para>
<!-- pgdoc-cn_end sig_en=334ac50a22c3c6f835eece44657b2a72 -->

<!-- pgdoc-cn_start sig_en=39dc1b242b6a54547551a147c17201b5 sig_cn_org=None source=14.1 
   <para>
    It is recommended that the file name used in <command>COPY</command>
    always be specified as an absolute path. This is enforced by the
    server in the case of <command>COPY TO</command>, but for
    <command>COPY FROM</command> you do have the option of reading from
    a file specified by a relative path. The path will be interpreted
    relative to the working directory of the server process (normally
    the cluster's data directory), not the client's working directory.
   </para>
________________________________________________________-->
   <para>
    我们推荐在<command>COPY</command>中使用的文件名总是
    指定为一个绝对路径。在<command>COPY TO</command>的
    情况下服务器会强制这一点，但是对于
    <command>COPY FROM</command>你可以选择从一个用相对
    路径指定的文件中读取。该路径将根据服务器进程（而不是客户端）
    的工作目录（通常是集簇的数据目录）解释。
   </para>
<!-- pgdoc-cn_end sig_en=39dc1b242b6a54547551a147c17201b5 -->

<!-- pgdoc-cn_start sig_en=46009931f9a228c992e43982189bfda4 sig_cn_org=None source=14.1 
   <para>
    Executing a command with <literal>PROGRAM</literal> might be restricted
    by the operating system's access control mechanisms, such as SELinux.
   </para>
________________________________________________________-->
   <para>
    用<literal>PROGRAM</literal>执行一个命令可能会受到操作系统
    的访问控制机制（如 SELinux）的限制。
   </para>
<!-- pgdoc-cn_end sig_en=46009931f9a228c992e43982189bfda4 -->

<!-- pgdoc-cn_start sig_en=4215d33c9ed3babb6e6046e4f7f4910a sig_cn_org=None source=14.1 
   <para>
    <command>COPY FROM</command> will invoke any triggers and check
    constraints on the destination table. However, it will not invoke rules.
   </para>
________________________________________________________-->
   <para>
    <command>COPY FROM</command>将调用目标表上的任何触发器
    和检查约束。但是它不会调用规则。
   </para>
<!-- pgdoc-cn_end sig_en=4215d33c9ed3babb6e6046e4f7f4910a -->

<!-- pgdoc-cn_start sig_en=67745015d43ff13a6746af2e5f871a39 sig_cn_org=None source=14.1 
   <para>
    For identity columns, the <command>COPY FROM</command> command will always
    write the column values provided in the input data, like
    the <command>INSERT</command> option <literal>OVERRIDING SYSTEM
    VALUE</literal>.
   </para>
________________________________________________________-->
   <para>
    对于标识列，<command>COPY FROM</command>命令将总是写上输入数据中提供的列值，这和<command>INSERT</command>的选项<literal>OVERRIDING SYSTEM VALUE</literal>的行为一样。
   </para>
<!-- pgdoc-cn_end sig_en=67745015d43ff13a6746af2e5f871a39 -->

<!-- pgdoc-cn_start sig_en=02c4f80cc82bd87d86a58b951368b3a1 sig_cn_org=None source=14.1 
   <para>
    <command>COPY</command> input and output is affected by
    <varname>DateStyle</varname>. To ensure portability to other
    <productname>PostgreSQL</productname> installations that might use
    non-default <varname>DateStyle</varname> settings,
    <varname>DateStyle</varname> should be set to <literal>ISO</literal> before
    using <command>COPY TO</command>.  It is also a good idea to avoid dumping
    data with <varname>IntervalStyle</varname> set to
    <literal>sql_standard</literal>, because negative interval values might be
    misinterpreted by a server that has a different setting for
    <varname>IntervalStyle</varname>.
   </para>
________________________________________________________-->
   <para>
    <command>COPY</command>输入和输出受到
    <varname>DateStyle</varname>的影响。为了确保到其他
    可能使用非默认<varname>DateStyle</varname>设置的
    <productname>PostgreSQL</productname>安装的可移植性，在使用
    <command>COPY TO</command>前应该把
    <varname>DateStyle</varname>设置为<literal>ISO</literal>。避免转储把
    <varname>IntervalStyle</varname>设置为
    <literal>sql_standard</literal>的数据也是一个好主意，因为负的区间值可能会
    被具有不同<varname>IntervalStyle</varname>设置的服务器解释错误。
   </para>
<!-- pgdoc-cn_end sig_en=02c4f80cc82bd87d86a58b951368b3a1 -->

<!-- pgdoc-cn_start sig_en=2b831def95f52905965427049603aa10 sig_cn_org=None source=14.1 
   <para>
    Input data is interpreted according to <literal>ENCODING</literal>
    option or the current client encoding, and output data is encoded
    in <literal>ENCODING</literal> or the current client encoding, even
    if the data does not pass through the client but is read from or
    written to a file directly by the server.
   </para>
________________________________________________________-->
   <para>
    即使数据会被服务器直接从一个文件读取或者写入一个文件而不通过
    客户端，输入数据也会被根据<literal>ENCODING</literal>选项或者当前
    客户端编码解释，并且输出数据会被根据<literal>ENCODING</literal>或
    者当前客户端编码进行编码。
   </para>
<!-- pgdoc-cn_end sig_en=2b831def95f52905965427049603aa10 -->

<!-- pgdoc-cn_start sig_en=17788af612a08b1d99f391f85746eff5 sig_cn_org=None source=14.1 
   <para>
    <command>COPY</command> stops operation at the first error. This
    should not lead to problems in the event of a <command>COPY
    TO</command>, but the target table will already have received
    earlier rows in a <command>COPY FROM</command>. These rows will not
    be visible or accessible, but they still occupy disk space. This might
    amount to a considerable amount of wasted disk space if the failure
    happened well into a large copy operation. You might wish to invoke
    <command>VACUUM</command> to recover the wasted space.
   </para>
________________________________________________________-->
   <para>
    <command>COPY</command>会在第一个错误处停止操作。这在
    <command>COPY TO</command>的情况下不会导致问题，但是
    在<command>COPY FROM</command>中目标表将已经收到了一
    些行。这些行将不会变得可见或者可访问，但是它们仍然占据磁盘空间。
    如果在一次大型的复制操作中出现错误，这可能浪费相当可观的磁盘空间。
    你可能希望调用<command>VACUUM</command>来恢复被浪费的
    空间。
   </para>
<!-- pgdoc-cn_end sig_en=17788af612a08b1d99f391f85746eff5 -->

<!-- pgdoc-cn_start sig_en=33f9208112de32b946e4f4cf17a71fc3 sig_cn_org=None source=14.1 
   <para>
    <literal>FORCE_NULL</literal> and <literal>FORCE_NOT_NULL</literal> can be used
    simultaneously on the same column. This results in converting quoted
    null strings to null values and unquoted null strings to empty strings.
   </para>
________________________________________________________-->
   <para>
    <literal>FORCE_NULL</literal>和<literal>FORCE_NOT_NULL</literal>可以被同时
    用在同一列上。这会导致把已被引用的空值串转换为空值并且把未引用的空值
    串转换为空串。
   </para>
<!-- pgdoc-cn_end sig_en=33f9208112de32b946e4f4cf17a71fc3 -->

 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=dbdcab522703a38f9e219bdabc264820 sig_cn_org=None source=14.1 
  <title>File Formats</title>
________________________________________________________-->
  <title>文件格式</title>
<!-- pgdoc-cn_end sig_en=dbdcab522703a38f9e219bdabc264820 -->

  <refsect2>
<!-- pgdoc-cn_start sig_en=da74ea6efcf42ef2113f623559321694 sig_cn_org=None source=14.1 
   <title>Text Format</title>
________________________________________________________-->
   <title>文本格式</title>
<!-- pgdoc-cn_end sig_en=da74ea6efcf42ef2113f623559321694 -->

<!-- pgdoc-cn_start sig_en=d2c161f9d078d6aeb8a5a7ad99ee3411 sig_cn_org=None source=14.1 
   <para>
    When the <literal>text</literal> format is used,
    the data read or written is a text file with one line per table row.
    Columns in a row are separated by the delimiter character.
    The column values themselves are strings generated by the
    output function, or acceptable to the input function, of each
    attribute's data type.  The specified null string is used in
    place of columns that are null.
    <command>COPY FROM</command> will raise an error if any line of the
    input file contains more or fewer columns than are expected.
   </para>
________________________________________________________-->
   <para>
    在使用<literal>text</literal>格式时，读取或写入的是一个文本文件，
    其中每一行就是表中的一行。一行中的列被定界字符分隔。列值
    本身是由输出函数产生的或者是可被输入函数接受的属于每个属性
    数据类型的字符串。在为空值的列的位置使用指定的空值串。如果
    输入文件的任何行包含比预期更多或者更少的列，
    <command>COPY FROM</command>将会抛出一个错误。
   </para>
<!-- pgdoc-cn_end sig_en=d2c161f9d078d6aeb8a5a7ad99ee3411 -->

<!-- pgdoc-cn_start sig_en=0c602417bd33b932a90a794a72923b35 sig_cn_org=None source=14.1 
   <para>
    End of data can be represented by a single line containing just
    backslash-period (<literal>\.</literal>).  An end-of-data marker is
    not necessary when reading from a file, since the end of file
    serves perfectly well; it is needed only when copying data to or from
    client applications using pre-3.0 client protocol.
   </para>
________________________________________________________-->
   <para>
    数据的结束可以表示为一个只包含反斜线-点号（<literal>\.</literal>）的
    单一行。从一个文件读取时，数据结束标记并不是必要的，因为文件
    结束符就已经足够用了。只有使用 3.0 客户端协议之前的客户端应用
    复制数据时才需要它。
   </para>
<!-- pgdoc-cn_end sig_en=0c602417bd33b932a90a794a72923b35 -->

<!-- pgdoc-cn_start sig_en=a2290c92723fe0a94f02280a531ed3c3 sig_cn_org=None source=14.1 
   <para>
    Backslash characters (<literal>\</literal>) can be used in the
    <command>COPY</command> data to quote data characters that might
    otherwise be taken as row or column delimiters. In particular, the
    following characters <emphasis>must</emphasis> be preceded by a backslash if
    they appear as part of a column value: backslash itself,
    newline, carriage return, and the current delimiter character.
   </para>
________________________________________________________-->
   <para>
    反斜线字符（<literal>\</literal>）可以被用在
    <command>COPY</command>数据中来引用被用作行或者列定界符的
    字符。特别地，如果下列字符作为一个列值的一部分出现，它们
    <emphasis>必须</emphasis>被前置一个反斜线：反斜线本身、新行、回车以及
    当前的定界符字符。
   </para>
<!-- pgdoc-cn_end sig_en=a2290c92723fe0a94f02280a531ed3c3 -->

<!-- pgdoc-cn_start sig_en=b8e9b5a2262b764b88b1b64974ac3976 sig_cn_org=None source=14.1 
   <para>
    The specified null string is sent by <command>COPY TO</command> without
    adding any backslashes; conversely, <command>COPY FROM</command> matches
    the input against the null string before removing backslashes.  Therefore,
    a null string such as <literal>\N</literal> cannot be confused with
    the actual data value <literal>\N</literal> (which would be represented
    as <literal>\\N</literal>).
   </para>
________________________________________________________-->
   <para>
    <command>COPY TO</command>会不加任何反斜线返回指定的空值串。
    相反，<command>COPY FROM</command>会在移除反斜线之前把输入
    与空值串相匹配。因此，一个空值串（例如<literal>\N</literal>）不会与实
    际的数据值<literal>\N</literal>（它会被表示为<literal>\\N</literal>）搞混。
   </para>
<!-- pgdoc-cn_end sig_en=b8e9b5a2262b764b88b1b64974ac3976 -->

<!-- pgdoc-cn_start sig_en=128551e76e3c79c1d3f4ae0d1291cab1 sig_cn_org=None source=14.1 
   <para>
    The following special backslash sequences are recognized by
    <command>COPY FROM</command>:

   <informaltable>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Sequence</entry>
       <entry>Represents</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>\b</literal></entry>
       <entry>Backspace (ASCII 8)</entry>
      </row>
      <row>
       <entry><literal>\f</literal></entry>
       <entry>Form feed (ASCII 12)</entry>
      </row>
      <row>
       <entry><literal>\n</literal></entry>
       <entry>Newline (ASCII 10)</entry>
      </row>
      <row>
       <entry><literal>\r</literal></entry>
       <entry>Carriage return (ASCII 13)</entry>
      </row>
      <row>
       <entry><literal>\t</literal></entry>
       <entry>Tab (ASCII 9)</entry>
      </row>
      <row>
       <entry><literal>\v</literal></entry>
       <entry>Vertical tab (ASCII 11)</entry>
      </row>
      <row>
       <entry><literal>\</literal><replaceable>digits</replaceable></entry>
       <entry>Backslash followed by one to three octal digits specifies
       the byte with that numeric code</entry>
      </row>
      <row>
       <entry><literal>\x</literal><replaceable>digits</replaceable></entry>
       <entry>Backslash <literal>x</literal> followed by one or two hex digits specifies
       the byte with that numeric code</entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>

    Presently, <command>COPY TO</command> will never emit an octal or
    hex-digits backslash sequence, but it does use the other sequences
    listed above for those control characters.
   </para>
________________________________________________________-->
   <para>
    <command>COPY FROM</command>识别下列特殊的反斜线序列：

   <informaltable>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>序列</entry>
       <entry>表示</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>\b</literal></entry>
       <entry>退格 (ASCII 8)</entry>
      </row>
      <row>
       <entry><literal>\f</literal></entry>
       <entry>换页 (ASCII 12)</entry>
      </row>
      <row>
       <entry><literal>\n</literal></entry>
       <entry>新行 (ASCII 10)</entry>
      </row>
      <row>
       <entry><literal>\r</literal></entry>
       <entry>回车 (ASCII 13)</entry>
      </row>
      <row>
       <entry><literal>\t</literal></entry>
       <entry>制表 (ASCII 9)</entry>
      </row>
      <row>
       <entry><literal>\v</literal></entry>
       <entry>纵向制表 (ASCII 11)</entry>
      </row>
      <row>
       <entry><literal>\</literal><replaceable>digits</replaceable></entry>
       <entry>反斜线后跟一到三个八进制数字表示该数字代码对应的字节</entry>
      </row>
      <row>
       <entry><literal>\x</literal><replaceable>digits</replaceable></entry>
       <entry>反斜线加<literal>x</literal>后跟一到三个十六进制数字表示该数字代码对应的字节</entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>

    当前，<command>COPY TO</command>不会发出一个八进制或十六进制位
    反斜线序列，但是它确实把上面列出的其他序列用于那些控制字符。
   </para>
<!-- pgdoc-cn_end sig_en=128551e76e3c79c1d3f4ae0d1291cab1 -->

<!-- pgdoc-cn_start sig_en=c7f7d61a19b3e5e246478f2e8561bf8a sig_cn_org=None source=14.1 
   <para>
    Any other backslashed character that is not mentioned in the above table
    will be taken to represent itself.  However, beware of adding backslashes
    unnecessarily, since that might accidentally produce a string matching the
    end-of-data marker (<literal>\.</literal>) or the null string (<literal>\N</literal> by
    default).  These strings will be recognized before any other backslash
    processing is done.
   </para>
________________________________________________________-->
   <para>
    任何上述表格中没有提到的其他反斜线字符将被当作表示其本身。不过，要注意
    增加不必要的反斜线，因为那可能意外地产生一个匹配数据结束标记（
    <literal>\.</literal>）或者空值串（默认是<literal>\N</literal>）的字符串。这些字符串
    将在完成任何其他反斜线处理之前被识别。
   </para>
<!-- pgdoc-cn_end sig_en=c7f7d61a19b3e5e246478f2e8561bf8a -->

<!-- pgdoc-cn_start sig_en=b283786fb6f6fd906db4ce7e06f0b14a sig_cn_org=None source=14.1 
   <para>
    It is strongly recommended that applications generating <command>COPY</command> data convert
    data newlines and carriage returns to the <literal>\n</literal> and
    <literal>\r</literal> sequences respectively.  At present it is
    possible to represent a data carriage return by a backslash and carriage
    return, and to represent a data newline by a backslash and newline.
    However, these representations might not be accepted in future releases.
    They are also highly vulnerable to corruption if the <command>COPY</command> file is
    transferred across different machines (for example, from Unix to Windows
    or vice versa).
   </para>
________________________________________________________-->
   <para>
    强烈建议产生<command>COPY</command>数据的应用把数据新行和回车分别
    转换为<literal>\n</literal>和<literal>\r</literal>序列。当前可以把一个数据回车表示为
    一个反斜线和回车，把一个数据新行表示为一个反斜线和新行。不过，未来的发行
    可能不会接受这些表示。如果在不同的机器之间（例如从 Unix 到 Windows）
    传输<command>COPY</command>文件，它们也很容易受到破坏。
   </para>
<!-- pgdoc-cn_end sig_en=b283786fb6f6fd906db4ce7e06f0b14a -->

<!-- pgdoc-cn_start sig_en=fe0df4388f1a2ce58904c48cb6385f0f sig_cn_org=None source=14.1 
   <para>
     All backslash sequences are interpreted after encoding conversion.
     The bytes specified with the octal and hex-digit backslash sequences must
     form valid characters in the database encoding.
   </para>
________________________________________________________-->
   <para>
     所有反斜杠序列都在编码转换后进行解释。
     用八进制和十六进制数字反斜杠序列指定的字节必须在数据库编码中形成有效字符。
   </para>
<!-- pgdoc-cn_end sig_en=fe0df4388f1a2ce58904c48cb6385f0f -->

<!-- pgdoc-cn_start sig_en=15af353ddc96fd0619bec857cb99ef1e sig_cn_org=None source=14.1 
   <para>
    <command>COPY TO</command> will terminate each row with a Unix-style
    newline (<quote><literal>\n</literal></quote>).  Servers running on Microsoft Windows instead
    output carriage return/newline (<quote><literal>\r\n</literal></quote>), but only for
    <command>COPY</command> to a server file; for consistency across platforms,
    <command>COPY TO STDOUT</command> always sends <quote><literal>\n</literal></quote>
    regardless of server platform.
    <command>COPY FROM</command> can handle lines ending with newlines,
    carriage returns, or carriage return/newlines.  To reduce the risk of
    error due to un-backslashed newlines or carriage returns that were
    meant as data, <command>COPY FROM</command> will complain if the line
    endings in the input are not all alike.
   </para>
________________________________________________________-->
   <para>
    <command>COPY TO</command>将用一个 Unix 风格的新行（
    <quote><literal>\n</literal></quote>）终止每一行。运行在 Microsoft Windows
    上的服务器则会输出回车/新行（<quote><literal>\r\n</literal></quote>），不过只对
    <command>COPY</command>到一个服务器文件这样做。为了做到跨平台一致，
    <command>COPY TO STDOUT</command>总是发送<quote><literal>\n</literal></quote>而
    不管服务器平台是什么。<command>COPY FROM</command>能够处理以
    新行、回车或者回车/新行结尾的行。为了减少由作为数据的未加反斜线的新行
    或者回车带来的风险，如果输出中的行结束并不完全相似，
    <command>COPY FROM</command>将会抱怨。
   </para>
<!-- pgdoc-cn_end sig_en=15af353ddc96fd0619bec857cb99ef1e -->
  </refsect2>

  <refsect2>
<!-- pgdoc-cn_start sig_en=9b0631f7754d565eefca2dfcac36ea37 sig_cn_org=None source=14.1 
   <title>CSV Format</title>
________________________________________________________-->
   <title>CSV 格式</title>
<!-- pgdoc-cn_end sig_en=9b0631f7754d565eefca2dfcac36ea37 -->

<!-- pgdoc-cn_start sig_en=2fe6dd54000d64c2318ded44e2579562 sig_cn_org=None source=14.1 
   <para>
    This format option is used for importing and exporting the Comma
    Separated Value (<literal>CSV</literal>) file format used by many other
    programs, such as spreadsheets. Instead of the escaping rules used by
    <productname>PostgreSQL</productname>'s standard text format, it
    produces and recognizes the common CSV escaping mechanism.
   </para>
________________________________________________________-->
   <para>
    这种格式选项被用于导入和导出很多其他程序（例如电子表格）使用的逗号
    分隔值（<literal>CSV</literal>）文件格式。不同于
    <productname>PostgreSQL</productname>标准文本格式使用的转义
    规则，它产生并且识别一般的 CSV 转义机制。
   </para>
<!-- pgdoc-cn_end sig_en=2fe6dd54000d64c2318ded44e2579562 -->

<!-- pgdoc-cn_start sig_en=58a4f01ddb10b6db495e8768055fb414 sig_cn_org=None source=14.1 
   <para>
    The values in each record are separated by the <literal>DELIMITER</literal>
    character. If the value contains the delimiter character, the
    <literal>QUOTE</literal> character, the <literal>NULL</literal> string, a carriage
    return, or line feed character, then the whole value is prefixed and
    suffixed by the <literal>QUOTE</literal> character, and any occurrence
    within the value of a <literal>QUOTE</literal> character or the
    <literal>ESCAPE</literal> character is preceded by the escape character.
    You can also use <literal>FORCE_QUOTE</literal> to force quotes when outputting
    non-<literal>NULL</literal> values in specific columns.
   </para>
________________________________________________________-->
   <para>
    每个记录中的值用<literal>DELIMITER</literal>字符分隔。如果值包含
    定界符字符、<literal>QUOTE</literal>字符、<literal>NULL</literal>字符串、
    一个回车或者换行字符，那么整个值会被加上<literal>QUOTE</literal>字符
    作为前缀或者后缀，并且在该值内<literal>QUOTE</literal>字符或者
    <literal>ESCAPE</literal>字符的任何一次出现之前放上转义字符。在输出
    指定列中非<literal>NULL</literal>值时，还可以使用
    <literal>FORCE_QUOTE</literal>来强制加上引用。
   </para>
<!-- pgdoc-cn_end sig_en=58a4f01ddb10b6db495e8768055fb414 -->

<!-- pgdoc-cn_start sig_en=6d687cab7de3ae6d8d5cd717df1b169e sig_cn_org=None source=14.1 
   <para>
    The <literal>CSV</literal> format has no standard way to distinguish a
    <literal>NULL</literal> value from an empty string.
    <productname>PostgreSQL</productname>'s <command>COPY</command> handles this by quoting.
    A <literal>NULL</literal> is output as the <literal>NULL</literal> parameter string
    and is not quoted, while a non-<literal>NULL</literal> value matching the
    <literal>NULL</literal> parameter string is quoted.  For example, with the
    default settings, a <literal>NULL</literal> is written as an unquoted empty
    string, while an empty string data value is written with double quotes
    (<literal>""</literal>). Reading values follows similar rules. You can
    use <literal>FORCE_NOT_NULL</literal> to prevent <literal>NULL</literal> input
    comparisons for specific columns. You can also use
    <literal>FORCE_NULL</literal> to convert quoted null string data values to
    <literal>NULL</literal>.
   </para>
________________________________________________________-->
   <para>
    <literal>CSV</literal>格式没有标准方式来区分<literal>NULL</literal>值和空字符串。
    <productname>PostgreSQL</productname>的<command>COPY</command>用引用来处理
    这种区分工作。<literal>NULL</literal>被按照<literal>NULL</literal>参数字符串输出
    并且不会被引用，而匹配<literal>NULL</literal>参数字符串的非<literal>NULL</literal>
    值会被加上引用。例如，使用默认设置时，<literal>NULL</literal>被写作一个未
    被引用的空字符串，而一个空字符串数据值会被写成带双引号（<literal>""</literal>）。
    值的读取遵循类似的规则。你可以用<literal>FORCE_NOT_NULL</literal>来防止
    对指定列的<literal>NULL</literal>输入比较。你还可以使用
    <literal>FORCE_NULL</literal>把带引用的空值字符串数据值转换成<literal>NULL</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=6d687cab7de3ae6d8d5cd717df1b169e -->

<!-- pgdoc-cn_start sig_en=c6c357b040764120d659d5fc1c6f1dbd sig_cn_org=None source=14.1 
   <para>
    Because backslash is not a special character in the <literal>CSV</literal>
    format, <literal>\.</literal>, the end-of-data marker, could also appear
    as a data value.  To avoid any misinterpretation, a <literal>\.</literal>
    data value appearing as a lone entry on a line is automatically
    quoted on output, and on input, if quoted, is not interpreted as the
    end-of-data marker.  If you are loading a file created by another
    application that has a single unquoted column and might have a
    value of <literal>\.</literal>, you might need to quote that value in the
    input file.
   </para>
________________________________________________________-->
   <para>
    因为反斜线在<literal>CSV</literal>格式中不是一种特殊字符，数据结束标记
    <literal>\.</literal>也可以作为一个数据值出现。为了避免任何解释误会，在
    一行上作为孤项出现的<literal>\.</literal>数据值输出时会自动被引用，并且
    输入时如果被引用，则不会被解释为数据结束标记。如果正在载入一个由
    另一个应用创建的文件并且其中具有一个未被引用的列且可能具有
    <literal>\.</literal>值，你可能需要在输入文件中引用该值。
   </para>
<!-- pgdoc-cn_end sig_en=c6c357b040764120d659d5fc1c6f1dbd -->

   <note>
<!-- pgdoc-cn_start sig_en=0fef08dcaf53b90b3061ffcd7c95da3f sig_cn_org=None source=14.1 
    <para>
     In <literal>CSV</literal> format, all characters are significant. A quoted value
     surrounded by white space, or any characters other than
     <literal>DELIMITER</literal>, will include those characters. This can cause
     errors if you import data from a system that pads <literal>CSV</literal>
     lines with white space out to some fixed width. If such a situation
     arises you might need to preprocess the <literal>CSV</literal> file to remove
     the trailing white space, before importing the data into
     <productname>PostgreSQL</productname>.
    </para>
________________________________________________________-->
    <para>
     <literal>CSV</literal>格式中，所有字符都是有意义的。一个被空白或者其他
     非 <literal>DELIMITER</literal>字符围绕的引用值将包括那些字符。在导入
     来自用空白填充<literal>CSV</literal>行到固定长度的系统的数据时，这可能
     会导致错误。如果出现这种情况，在导入数据到
     <productname>PostgreSQL</productname>之前，你可能需要预处理该
     <literal>CSV</literal>文件以移除拖尾的空白。
    </para>
<!-- pgdoc-cn_end sig_en=0fef08dcaf53b90b3061ffcd7c95da3f -->
   </note>

   <note>
<!-- pgdoc-cn_start sig_en=572660f92773156d6b50d50572627eec sig_cn_org=None source=14.1 
    <para>
     CSV format will both recognize and produce CSV files with quoted
     values containing embedded carriage returns and line feeds. Thus
     the files are not strictly one line per table row like text-format
     files.
    </para>
________________________________________________________-->
    <para>
     CSV 格式将识别并且产生带有包含嵌入的回车和换行的引用值的 CSV 
     文件。因此文件并不限于文本格式文件的每个表行一行的形式。
    </para>
<!-- pgdoc-cn_end sig_en=572660f92773156d6b50d50572627eec -->
   </note>

   <note>
<!-- pgdoc-cn_start sig_en=d10fd9c9d9e334afc8dc6eff3556ac23 sig_cn_org=None source=14.1 
    <para>
     Many programs produce strange and occasionally perverse CSV files,
     so the file format is more a convention than a standard. Thus you
     might encounter some files that cannot be imported using this
     mechanism, and <command>COPY</command> might produce files that other
     programs cannot process.
    </para>
________________________________________________________-->
    <para>
     很多程序会产生奇怪的甚至偶尔是不合常理的 CSV 文件，因此该文件
     格式更像是一种习惯而不是标准。因此你可能会碰到一些无法使用这种
     机制导入的文件，并且<command>COPY</command>也可能产生其他程序无
     法处理的文件。
    </para>
<!-- pgdoc-cn_end sig_en=d10fd9c9d9e334afc8dc6eff3556ac23 -->
   </note>

  </refsect2>

  <refsect2>
<!-- pgdoc-cn_start sig_en=3e717e87d0a8acd1a98327d5b016b6b3 sig_cn_org=None source=14.1 
   <title>Binary Format</title>
________________________________________________________-->
   <title>二进制格式</title>
<!-- pgdoc-cn_end sig_en=3e717e87d0a8acd1a98327d5b016b6b3 -->

<!-- pgdoc-cn_start sig_en=ab255ac5c146c93769eae87c7b9c92e8 sig_cn_org=None source=14.1 
   <para>
    The <literal>binary</literal> format option causes all data to be
    stored/read as binary format rather than as text.  It is
    somewhat faster than the text and <literal>CSV</literal> formats,
    but a binary-format file is less portable across machine architectures and
    <productname>PostgreSQL</productname> versions.
    Also, the binary format is very data type specific; for example
    it will not work to output binary data from a <type>smallint</type> column
    and read it into an <type>integer</type> column, even though that would work
    fine in text format.
   </para>
________________________________________________________-->
   <para>
    <literal>binary</literal>格式选项导致所有数据被以二进制格式
    而不是文本格式存储/读取。它比文本和<literal>CSV</literal>格式要
    快一些，但是二进制格式文件在不同的机器架构和
    <productname>PostgreSQL</productname>版本之间的可移
    植性要差些。还有，二进制格式与数据格式非常相关。例如不能从
    一个<type>smallint</type>列中输出二进制数据并且把它读入到一个
    <type>integer</type>列中，虽然这样做在文本格式中是可行的。
   </para>
<!-- pgdoc-cn_end sig_en=ab255ac5c146c93769eae87c7b9c92e8 -->

<!-- pgdoc-cn_start sig_en=1f078a91ded0fed59c6f0a8303d65e74 sig_cn_org=None source=14.1 
   <para>
    The <literal>binary</literal> file format consists
    of a file header, zero or more tuples containing the row data, and
    a file trailer.  Headers and data are in network byte order.
   </para>
________________________________________________________-->
   <para>
    <literal>binary</literal>文件格式由一个文件头、零个或者更多个包含
    行数据的元组以及一个文件尾构成。头部和数据都以网络字节序表示。
   </para>
<!-- pgdoc-cn_end sig_en=1f078a91ded0fed59c6f0a8303d65e74 -->

   <note>
<!-- pgdoc-cn_start sig_en=9be2b84645ff187ece18e1e87fabdc4d sig_cn_org=None source=14.1 
    <para>
     <productname>PostgreSQL</productname> releases before 7.4 used a
     different binary file format.
    </para>
________________________________________________________-->
    <para>
     7.4 之前的<productname>PostgreSQL</productname>发行
     使用一种不同的二进制文件格式。
    </para>
<!-- pgdoc-cn_end sig_en=9be2b84645ff187ece18e1e87fabdc4d -->
   </note>

   <refsect3>
<!-- pgdoc-cn_start sig_en=cf81f4b176c34c2b1ac5a2b1a5272709 sig_cn_org=None source=14.1 
    <title>File Header</title>
________________________________________________________-->
    <title>文件头</title>
<!-- pgdoc-cn_end sig_en=cf81f4b176c34c2b1ac5a2b1a5272709 -->

<!-- pgdoc-cn_start sig_en=f7a866fa36292c9040b7c5478d60a8cf sig_cn_org=None source=14.1 
    <para>
     The file header consists of 15 bytes of fixed fields, followed
     by a variable-length header extension area.  The fixed fields are:

    <variablelist>
     <varlistentry>
      <term>Signature</term>
      <listitem>
       <para>
11-byte sequence <literal>PGCOPY\n\377\r\n\0</literal> &mdash; note that the zero byte
is a required part of the signature.  (The signature is designed to allow
easy identification of files that have been munged by a non-8-bit-clean
transfer.  This signature will be changed by end-of-line-translation
filters, dropped zero bytes, dropped high bits, or parity changes.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Flags field</term>
      <listitem>
       <para>
32-bit integer bit mask to denote important aspects of the file format. Bits
are numbered from 0 (<acronym>LSB</acronym>) to 31 (<acronym>MSB</acronym>).  Note that
this field is stored in network byte order (most significant byte first),
as are all the integer fields used in the file format.  Bits
16&ndash;31 are reserved to denote critical file format issues; a reader
should abort if it finds an unexpected bit set in this range. Bits 0&ndash;15
are reserved to signal backwards-compatible format issues; a reader
should simply ignore any unexpected bits set in this range. Currently
only one flag bit is defined, and the rest must be zero:
        <variablelist>
         <varlistentry>
          <term>Bit 16</term>
          <listitem>
           <para>
            If 1, OIDs are included in the data; if 0, not. Oid system columns
            are not supported in <productname>PostgreSQL</productname>
            anymore, but the format still contains the indicator.
           </para>
          </listitem>
         </varlistentry>
        </variablelist></para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Header extension area length</term>
      <listitem>
       <para>
32-bit integer, length in bytes of remainder of header, not including self.
Currently, this is zero, and the first tuple follows
immediately.  Future changes to the format might allow additional data
to be present in the header.  A reader should silently skip over any header
extension data it does not know what to do with.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    </para>
________________________________________________________-->
    <para>
     文件头由 15 字节的固定域构成，后面跟着一个变长的头部扩展区。
     固定域有：

    <variablelist>
     <varlistentry>
      <term>签名</term>
      <listitem>
       <para>
11-字节的序列<literal>PGCOPY\n\377\r\n\0</literal> &mdash; 注意
零字节是签名的一个必要的部分（该签名是为了能容易地发现文件被
无法正确处理 8 位字符编码的传输所破坏。这个签名将被行尾翻译过
滤器、删除零字节、删除高位或者奇偶修改等改变）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>标志域</term>
      <listitem>
       <para>
32-位整数位掩码，用以表示该文件格式的重要方面。位被编号为
从 0 （<acronym>LSB</acronym>）到 31（<acronym>MSB</acronym>）。
注意这个域以网络字节序存放（最高有效位在前），所有该文件格式
中使用的整数域都是这样。16-31 位被保留用来表示严重的文件格式
问题， 读取者如果在这个范围内发现预期之外的被设置位，它应该
中止。0-15 位被保留用来表示向后兼容的格式问题，读取者应该简单
地略过这个范围内任何预期之外的被设置位。当前只定义了一个标志
位，其他位必须为零：
        <variablelist>
         <varlistentry>
          <term>位 16</term>
          <listitem>
           <para>
            如果为 1，表示数据中包含 OID；如果为 0，则不包含。<productname>PostgreSQL</productname>不再支持Oid系统列，但是格式仍然包含该指示符。
           </para>
          </listitem>
         </varlistentry>
        </variablelist></para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>头部扩展区长度</term>
      <listitem>
       <para>
32-为整数，表示头部剩余部分的以字节计的长度，不包括其本身。
当前，这个长度为零，并且其后就紧跟着第一个元组。未来对该
格式的更改可能会允许在头部中表示额外的数据。如果读取者不知
道要对头部扩展区数据做什么，可以安静地跳过它。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    </para>
<!-- pgdoc-cn_end sig_en=f7a866fa36292c9040b7c5478d60a8cf -->

<!-- pgdoc-cn_start sig_en=9fefd7b2c6b3f0458efebb1e97b0e99e sig_cn_org=None source=14.1 
    <para>
The header extension area is envisioned to contain a sequence of
self-identifying chunks.  The flags field is not intended to tell readers
what is in the extension area.  Specific design of header extension contents
is left for a later release.
    </para>
________________________________________________________-->
    <para>
头部扩展区域被预期包含一个能自我解释的块的序列。
该标志域并不想告诉读取者扩展数据是什么。详细的
头部扩展内容的设计留给后来的发行去做。
    </para>
<!-- pgdoc-cn_end sig_en=9fefd7b2c6b3f0458efebb1e97b0e99e -->

<!-- pgdoc-cn_start sig_en=9d81cd11a3ebda461b7790f3c38a4be2 sig_cn_org=None source=14.1 
    <para>
     This design allows for both backwards-compatible header additions (add
     header extension chunks, or set low-order flag bits) and
     non-backwards-compatible changes (set high-order flag bits to signal such
     changes, and add supporting data to the extension area if needed).
    </para>
________________________________________________________-->
    <para>
     这种设计允许向后兼容的头部增加（增加头部扩展块或者设置低位标志位）以及
     非向后兼容的更改（设置高位标志位来表示这类更改并且在需要时向扩展区域
     中增加支持数据）。
    </para>
<!-- pgdoc-cn_end sig_en=9d81cd11a3ebda461b7790f3c38a4be2 -->
   </refsect3>

   <refsect3>
<!-- pgdoc-cn_start sig_en=81f707e80b0a1354c4672539b4a308b9 sig_cn_org=None source=14.1 
    <title>Tuples</title>
________________________________________________________-->
    <title>元组</title>
<!-- pgdoc-cn_end sig_en=81f707e80b0a1354c4672539b4a308b9 -->
<!-- pgdoc-cn_start sig_en=5293b34b61edc7ef411f299f0e917190 sig_cn_org=None source=14.1 
    <para>
Each tuple begins with a 16-bit integer count of the number of fields in the
tuple.  (Presently, all tuples in a table will have the same count, but that
might not always be true.)  Then, repeated for each field in the tuple, there
is a 32-bit length word followed by that many bytes of field data.  (The
length word does not include itself, and can be zero.)  As a special case,
-1 indicates a NULL field value.  No value bytes follow in the NULL case.
    </para>
________________________________________________________-->
    <para>
每一个元组由一个表示元组中域数量的 16 位整数计数开始（当前，一个表中
的所有元组都应该具有相同的计数，但是这可能不会总是为真）。然后是元组
中的每一个域，它是一个 32 位的长度字，后面则跟随着这么多个字节的域数
据（长度字不包括其本身，并且可以是零）。作为一种特殊情况，-1 表示一个
NULL 域值。在 NULL 情况下，后面不会跟随值字节。
    </para>
<!-- pgdoc-cn_end sig_en=5293b34b61edc7ef411f299f0e917190 -->

<!-- pgdoc-cn_start sig_en=384db5511ff756c55c6f9bfd661e5c42 sig_cn_org=None source=14.1 
    <para>
There is no alignment padding or any other extra data between fields.
    </para>
________________________________________________________-->
    <para>
在域之间没有对齐填充或者任何其他额外的数据。
    </para>
<!-- pgdoc-cn_end sig_en=384db5511ff756c55c6f9bfd661e5c42 -->

<!-- pgdoc-cn_start sig_en=557ef99fb10f30b92709414b4872838a sig_cn_org=None source=14.1 
    <para>
Presently, all data values in a binary-format file are
assumed to be in binary format (format code one).  It is anticipated that a
future extension might add a header field that allows per-column format codes
to be specified.
    </para>
________________________________________________________-->
    <para>
当前，一个二进制格式文件中的所有数据值都被假设为二进制格式（格式代码一）。
可以预见未来的扩展可能会增加一个允许独立指定各列的格式代码的头部域。
    </para>
<!-- pgdoc-cn_end sig_en=557ef99fb10f30b92709414b4872838a -->

<!-- pgdoc-cn_start sig_en=7aae874bbf352a07c71312516452f21c sig_cn_org=None source=14.1 
    <para>
To determine the appropriate binary format for the actual tuple data you
should consult the <productname>PostgreSQL</productname> source, in
particular the <function>*send</function> and <function>*recv</function> functions for
each column's data type (typically these functions are found in the
<filename>src/backend/utils/adt/</filename> directory of the source
distribution).
    </para>
________________________________________________________-->
    <para>
要为实际的元组数据决定合适的二进制格式，你应该参考
<productname>PostgreSQL</productname>源码，特别是用于各列
数据类型的<function>*send</function>和<function>*recv</function>函数（通常可
以在源码的<filename>src/backend/utils/adt/</filename>目录中找到
这些函数）。
    </para>
<!-- pgdoc-cn_end sig_en=7aae874bbf352a07c71312516452f21c -->

<!-- pgdoc-cn_start sig_en=87d8eecc1eea9e79ffbe8f48c7b098f8 sig_cn_org=None source=14.1 
    <para>
If OIDs are included in the file, the OID field immediately follows the
field-count word.  It is a normal field except that it's not included in the
field-count.  Note that oid system columns are not supported in current
versions of <productname>PostgreSQL</productname>.
    </para>
________________________________________________________-->
    <para>
如果文件中包含 OID，OID 域会紧跟在域计数字之后。它是一个普通域，
不过它没有被包含在域计数中。注意<productname>PostgreSQL</productname>当前版本不支持oid系统列。
    </para>
<!-- pgdoc-cn_end sig_en=87d8eecc1eea9e79ffbe8f48c7b098f8 -->
   </refsect3>

   <refsect3>
<!-- pgdoc-cn_start sig_en=df92d237e447d7453943ec5a48c24292 sig_cn_org=None source=14.1 
    <title>File Trailer</title>
________________________________________________________-->
    <title>文件尾</title>
<!-- pgdoc-cn_end sig_en=df92d237e447d7453943ec5a48c24292 -->

<!-- pgdoc-cn_start sig_en=77cb7a6ec9e4e082036e675e7a81b436 sig_cn_org=None source=14.1 
    <para>
     The file trailer consists of a 16-bit integer word containing -1.  This
     is easily distinguished from a tuple's field-count word.
    </para>
________________________________________________________-->
    <para>
     文件位由一个包含 -1 的 16 位整数字组成。这很容易与一个
     元组的域计数字区分开。
    </para>
<!-- pgdoc-cn_end sig_en=77cb7a6ec9e4e082036e675e7a81b436 -->

<!-- pgdoc-cn_start sig_en=703c4524d571817fbdb58225002f5719 sig_cn_org=None source=14.1 
    <para>
     A reader should report an error if a field-count word is neither -1
     nor the expected number of columns.  This provides an extra
     check against somehow getting out of sync with the data.
    </para>
________________________________________________________-->
    <para>
     如果一个域计数字不是 -1 也不是期望的列数，读取者应该报告错误。
     这提供了一种针对某种数据不同步的额外检查。
    </para>
<!-- pgdoc-cn_end sig_en=703c4524d571817fbdb58225002f5719 -->
   </refsect3>
  </refsect2>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d sig_cn_org=None source=14.1 
  <title>Examples</title>
________________________________________________________-->
  <title>示例</title>
<!-- pgdoc-cn_end sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d -->

<!-- pgdoc-cn_start sig_en=37c0109947ccdd8d22683cd302bd8074 sig_cn_org=None source=14.1 
  <para>
   The following example copies a table to the client
   using the vertical bar (<literal>|</literal>) as the field delimiter:
<programlisting>
COPY country TO STDOUT (DELIMITER '|');
</programlisting>
  </para>
________________________________________________________-->
  <para>
   下面的例子使用竖线（<literal>|</literal>）作为域定界符把一个表复制到客户端：
<programlisting>
COPY country TO STDOUT (DELIMITER '|');
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=37c0109947ccdd8d22683cd302bd8074 -->

<!-- pgdoc-cn_start sig_en=2cb5481911a6bd6ff873e3981fe141a2 sig_cn_org=None source=14.1 
  <para>
   To copy data from a file into the <literal>country</literal> table:
<programlisting>
COPY country FROM '/usr1/proj/bray/sql/country_data';
</programlisting>
  </para>
________________________________________________________-->
  <para>
   从一个文件中复制数据到<literal>country</literal>表中：
<programlisting>
COPY country FROM '/usr1/proj/bray/sql/country_data';
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=2cb5481911a6bd6ff873e3981fe141a2 -->

<!-- pgdoc-cn_start sig_en=9edda51a390510baec36c49d27c10944 sig_cn_org=None source=14.1 
  <para>
   To copy into a file just the countries whose names start with 'A':
<programlisting>
COPY (SELECT * FROM country WHERE country_name LIKE 'A%') TO '/usr1/proj/bray/sql/a_list_countries.copy';
</programlisting>
  </para>
________________________________________________________-->
  <para>
   只把名称以 'A' 开头的国家复制到一个文件中：
<programlisting>
COPY (SELECT * FROM country WHERE country_name LIKE 'A%') TO '/usr1/proj/bray/sql/a_list_countries.copy';
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=9edda51a390510baec36c49d27c10944 -->

<!-- pgdoc-cn_start sig_en=4eac62a8b7a109fbcb670e0e583a12ad sig_cn_org=None source=14.1 
  <para>
   To copy into a compressed file, you can pipe the output through an external
   compression program:
<programlisting>
COPY country TO PROGRAM 'gzip > /usr1/proj/bray/sql/country_data.gz';
</programlisting>
  </para>
________________________________________________________-->
  <para>
   要复制到一个压缩文件中，你可以用管道把输出导到一个外部压缩程序：
<programlisting>
COPY country TO PROGRAM 'gzip > /usr1/proj/bray/sql/country_data.gz';
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=4eac62a8b7a109fbcb670e0e583a12ad -->

<!-- pgdoc-cn_start sig_en=6390b25a811174bab3346c6c14a5025a sig_cn_org=None source=14.1 
  <para>
   Here is a sample of data suitable for copying into a table from
   <literal>STDIN</literal>:
<programlisting>
AF      AFGHANISTAN
AL      ALBANIA
DZ      ALGERIA
ZM      ZAMBIA
ZW      ZIMBABWE
</programlisting>
   Note that the white space on each line is actually a tab character.
  </para>
________________________________________________________-->
  <para>
   这里是一个适合于从<literal>STDIN</literal>复制到表中的数据：
<programlisting>
AF      AFGHANISTAN
AL      ALBANIA
DZ      ALGERIA
ZM      ZAMBIA
ZW      ZIMBABWE
</programlisting>
   注意每一行上的空白实际是一个制表符。
  </para>
<!-- pgdoc-cn_end sig_en=6390b25a811174bab3346c6c14a5025a -->

<!-- pgdoc-cn_start sig_en=85ef25829c6fb9fc7fcf4caaab0e41bb sig_cn_org=None source=14.1 
  <para>
   The following is the same data, output in binary format.
   The data is shown after filtering through the
   Unix utility <command>od -c</command>. The table has three columns;
   the first has type <type>char(2)</type>, the second has type <type>text</type>,
   and the third has type <type>integer</type>. All the rows have a null value
   in the third column.
<programlisting>
0000000   P   G   C   O   P   Y  \n 377  \r  \n  \0  \0  \0  \0  \0  \0
0000020  \0  \0  \0  \0 003  \0  \0  \0 002   A   F  \0  \0  \0 013   A
0000040   F   G   H   A   N   I   S   T   A   N 377 377 377 377  \0 003
0000060  \0  \0  \0 002   A   L  \0  \0  \0 007   A   L   B   A   N   I
0000100   A 377 377 377 377  \0 003  \0  \0  \0 002   D   Z  \0  \0  \0
0000120 007   A   L   G   E   R   I   A 377 377 377 377  \0 003  \0  \0
0000140  \0 002   Z   M  \0  \0  \0 006   Z   A   M   B   I   A 377 377
0000160 377 377  \0 003  \0  \0  \0 002   Z   W  \0  \0  \0  \b   Z   I
0000200   M   B   A   B   W   E 377 377 377 377 377 377
</programlisting></para>
________________________________________________________-->
  <para>
   下面是用二进制格式输出的相同数据。该数据是用 Unix 工具
   <command>od -c</command>过滤后显示的。该表具有三列，
   第一列类型是<type>char(2)</type>，第二列类型是<type>text</type>，
   第三列类型是<type>integer</type>。所有行在第三列都是空值。
<programlisting>
0000000   P   G   C   O   P   Y  \n 377  \r  \n  \0  \0  \0  \0  \0  \0
0000020  \0  \0  \0  \0 003  \0  \0  \0 002   A   F  \0  \0  \0 013   A
0000040   F   G   H   A   N   I   S   T   A   N 377 377 377 377  \0 003
0000060  \0  \0  \0 002   A   L  \0  \0  \0 007   A   L   B   A   N   I
0000100   A 377 377 377 377  \0 003  \0  \0  \0 002   D   Z  \0  \0  \0
0000120 007   A   L   G   E   R   I   A 377 377 377 377  \0 003  \0  \0
0000140  \0 002   Z   M  \0  \0  \0 006   Z   A   M   B   I   A 377 377
0000160 377 377  \0 003  \0  \0  \0 002   Z   W  \0  \0  \0  \b   Z   I
0000200   M   B   A   B   W   E 377 377 377 377 377 377
</programlisting></para>
<!-- pgdoc-cn_end sig_en=85ef25829c6fb9fc7fcf4caaab0e41bb -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=b38d493f3c2d2d5d9a7a49d257da9811 sig_cn_org=None source=14.1 
  <title>Compatibility</title>
________________________________________________________-->
  <title>兼容性</title>
<!-- pgdoc-cn_end sig_en=b38d493f3c2d2d5d9a7a49d257da9811 -->

<!-- pgdoc-cn_start sig_en=d35a3cc534a2cff9fdfbfbfd4658f9bd sig_cn_org=None source=14.1 
  <para>
   There is no <command>COPY</command> statement in the SQL standard.
  </para>
________________________________________________________-->
  <para>
   SQL 标准中没有<command>COPY</command>语句。
  </para>
<!-- pgdoc-cn_end sig_en=d35a3cc534a2cff9fdfbfbfd4658f9bd -->

<!-- pgdoc-cn_start sig_en=ccc5bea6b81a522f9a1cef6b0efbb3b7 sig_cn_org=None source=14.1 
  <para>
   The following syntax was used before <productname>PostgreSQL</productname>
   version 9.0 and is still supported:

<synopsis>
COPY <replaceable class="parameter">table_name</replaceable> [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ]
    FROM { '<replaceable class="parameter">filename</replaceable>' | STDIN }
    [ [ WITH ]
          [ BINARY ]
          [ DELIMITER [ AS ] '<replaceable class="parameter">delimiter_character</replaceable>' ]
          [ NULL [ AS ] '<replaceable class="parameter">null_string</replaceable>' ]
          [ CSV [ HEADER ]
                [ QUOTE [ AS ] '<replaceable class="parameter">quote_character</replaceable>' ]
                [ ESCAPE [ AS ] '<replaceable class="parameter">escape_character</replaceable>' ]
                [ FORCE NOT NULL <replaceable class="parameter">column_name</replaceable> [, ...] ] ] ]

COPY { <replaceable class="parameter">table_name</replaceable> [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ] | ( <replaceable class="parameter">query</replaceable> ) }
    TO { '<replaceable class="parameter">filename</replaceable>' | STDOUT }
    [ [ WITH ]
          [ BINARY ]
          [ DELIMITER [ AS ] '<replaceable class="parameter">delimiter_character</replaceable>' ]
          [ NULL [ AS ] '<replaceable class="parameter">null_string</replaceable>' ]
          [ CSV [ HEADER ]
                [ QUOTE [ AS ] '<replaceable class="parameter">quote_character</replaceable>' ]
                [ ESCAPE [ AS ] '<replaceable class="parameter">escape_character</replaceable>' ]
                [ FORCE QUOTE { <replaceable class="parameter">column_name</replaceable> [, ...] | * } ] ] ]
</synopsis>

   Note that in this syntax, <literal>BINARY</literal> and <literal>CSV</literal> are
   treated as independent keywords, not as arguments of a <literal>FORMAT</literal>
   option.
  </para>
________________________________________________________-->
  <para>
   下列语法用于<productname>PostgreSQL</productname> 9.0 之前的版本，
   并且仍然被支持：

<synopsis>
COPY <replaceable class="parameter">table_name</replaceable> [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ]
    FROM { '<replaceable class="parameter">filename</replaceable>' | STDIN }
    [ [ WITH ]
          [ BINARY ]
          [ DELIMITER [ AS ] '<replaceable class="parameter">delimiter_character</replaceable>' ]
          [ NULL [ AS ] '<replaceable class="parameter">null_string</replaceable>' ]
          [ CSV [ HEADER ]
                [ QUOTE [ AS ] '<replaceable class="parameter">quote_character</replaceable>' ]
                [ ESCAPE [ AS ] '<replaceable class="parameter">escape_character</replaceable>' ]
                [ FORCE NOT NULL <replaceable class="parameter">column_name</replaceable> [, ...] ] ] ]

COPY { <replaceable class="parameter">table_name</replaceable> [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ] | ( <replaceable class="parameter">query</replaceable> ) }
    TO { '<replaceable class="parameter">filename</replaceable>' | STDOUT }
    [ [ WITH ]
          [ BINARY ]
          [ DELIMITER [ AS ] '<replaceable class="parameter">delimiter_character</replaceable>' ]
          [ NULL [ AS ] '<replaceable class="parameter">null_string</replaceable>' ]
          [ CSV [ HEADER ]
                [ QUOTE [ AS ] '<replaceable class="parameter">quote_character</replaceable>' ]
                [ ESCAPE [ AS ] '<replaceable class="parameter">escape_character</replaceable>' ]
                [ FORCE QUOTE { <replaceable class="parameter">column_name</replaceable> [, ...] | * } ] ] ]
</synopsis>

   注意在这种语法中，<literal>BINARY</literal>和<literal>CSV</literal>被视作独立的关键词，
   而不是<literal>FORMAT</literal>选项的参数。
  </para>
<!-- pgdoc-cn_end sig_en=ccc5bea6b81a522f9a1cef6b0efbb3b7 -->

<!-- pgdoc-cn_start sig_en=1285cc1eb1ba3fbb843ac7268da28b0e sig_cn_org=None source=14.1 
  <para>
   The following syntax was used before <productname>PostgreSQL</productname>
   version 7.3 and is still supported:

<synopsis>
COPY [ BINARY ] <replaceable class="parameter">table_name</replaceable>
    FROM { '<replaceable class="parameter">filename</replaceable>' | STDIN }
    [ [USING] DELIMITERS '<replaceable class="parameter">delimiter_character</replaceable>' ]
    [ WITH NULL AS '<replaceable class="parameter">null_string</replaceable>' ]

COPY [ BINARY ] <replaceable class="parameter">table_name</replaceable>
    TO { '<replaceable class="parameter">filename</replaceable>' | STDOUT }
    [ [USING] DELIMITERS '<replaceable class="parameter">delimiter_character</replaceable>' ]
    [ WITH NULL AS '<replaceable class="parameter">null_string</replaceable>' ]
</synopsis></para>
________________________________________________________-->
  <para>
   下列语法用于<productname>PostgreSQL</productname> 7.3 之前的版本，
   并且仍然被支持：

<synopsis>
COPY [ BINARY ] <replaceable class="parameter">table_name</replaceable>
    FROM { '<replaceable class="parameter">filename</replaceable>' | STDIN }
    [ [USING] DELIMITERS '<replaceable class="parameter">delimiter_character</replaceable>' ]
    [ WITH NULL AS '<replaceable class="parameter">null_string</replaceable>' ]

COPY [ BINARY ] <replaceable class="parameter">table_name</replaceable>
    TO { '<replaceable class="parameter">filename</replaceable>' | STDOUT }
    [ [USING] DELIMITERS '<replaceable class="parameter">delimiter_character</replaceable>' ]
    [ WITH NULL AS '<replaceable class="parameter">null_string</replaceable>' ]
</synopsis></para>
<!-- pgdoc-cn_end sig_en=1285cc1eb1ba3fbb843ac7268da28b0e -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=8b7cc214676b443e6527e3d6bf054420 sig_cn_org=None source=14.1 
  <title>See Also</title>
________________________________________________________-->
  <title>另见</title>
<!-- pgdoc-cn_end sig_en=8b7cc214676b443e6527e3d6bf054420 -->

  <simplelist type="inline">
   <member><xref linkend="copy-progress-reporting"/></member>
  </simplelist>
 </refsect1>
</refentry>
