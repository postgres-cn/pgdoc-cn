<!--
doc/src/sgml/ref/merge.sgml
PostgreSQL documentation
-->

<refentry id="sql-merge">
<!-- pgdoc-cn_start sig_en=b302792a0c11f5df3eac6de40aede7c7 sig_cn_org=e9fd58fcf1c24f83f8624e372dfe6362 source=15.7 
 <indexterm zone="sql-merge">
  <primary>MERGE</primary>
 </indexterm>
________________________________________________________-->
 <indexterm zone="sql-merge">
  <primary>MERGE</primary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=b302792a0c11f5df3eac6de40aede7c7 -->

 <refmeta>
  <refentrytitle>MERGE</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

<!-- pgdoc-cn_start sig_en=8650c9505c33d8a3aa14aab799d6b6a1 sig_cn_org=49dd53d0bcd41f99c48ef5ab13453e04 source=15.7 
 <refnamediv>
  <refname>MERGE</refname>
  <refpurpose>conditionally insert, update, or delete rows of a table</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>MERGE</refname>
  <refpurpose>有条件地插入、更新或删除表中的行</refpurpose>
</refnamediv>
<!-- pgdoc-cn_end sig_en=8650c9505c33d8a3aa14aab799d6b6a1 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=1e60c9b3427dc4770db081d87044cea6 sig_cn_org=1e60c9b3427dc4770db081d87044cea6 source=15.7 
<synopsis>
[ WITH <replaceable class="parameter">with_query</replaceable> [, ...] ]
MERGE INTO [ ONLY ] <replaceable class="parameter">target_table_name</replaceable> [ * ] [ [ AS ] <replaceable class="parameter">target_alias</replaceable> ]
USING <replaceable class="parameter">data_source</replaceable> ON <replaceable class="parameter">join_condition</replaceable>
<replaceable class="parameter">when_clause</replaceable> [...]

<phrase>where <replaceable class="parameter">data_source</replaceable> is:</phrase>

{ [ ONLY ] <replaceable class="parameter">source_table_name</replaceable> [ * ] | ( <replaceable class="parameter">source_query</replaceable> ) } [ [ AS ] <replaceable class="parameter">source_alias</replaceable> ]

<phrase>and <replaceable class="parameter">when_clause</replaceable> is:</phrase>

{ WHEN MATCHED [ AND <replaceable class="parameter">condition</replaceable> ] THEN { <replaceable class="parameter">merge_update</replaceable> | <replaceable class="parameter">merge_delete</replaceable> | DO NOTHING } |
  WHEN NOT MATCHED [ AND <replaceable class="parameter">condition</replaceable> ] THEN { <replaceable class="parameter">merge_insert</replaceable> | DO NOTHING } }

<phrase>and <replaceable class="parameter">merge_insert</replaceable> is:</phrase>

INSERT [( <replaceable class="parameter">column_name</replaceable> [, ...] )]
[ OVERRIDING { SYSTEM | USER } VALUE ]
{ VALUES ( { <replaceable class="parameter">expression</replaceable> | DEFAULT } [, ...] ) | DEFAULT VALUES }

<phrase>and <replaceable class="parameter">merge_update</replaceable> is:</phrase>

UPDATE SET { <replaceable class="parameter">column_name</replaceable> = { <replaceable class="parameter">expression</replaceable> | DEFAULT } |
             ( <replaceable class="parameter">column_name</replaceable> [, ...] ) = [ ROW ] ( { <replaceable class="parameter">expression</replaceable> | DEFAULT } [, ...] ) |
             ( <replaceable class="parameter">column_name</replaceable> [, ...] ) = ( <replaceable class="parameter">sub-SELECT</replaceable> )
           } [, ...]

<phrase>and <replaceable class="parameter">merge_delete</replaceable> is:</phrase>

DELETE
</synopsis>
________________________________________________________-->
<synopsis>
[ WITH <replaceable class="parameter">with_query</replaceable> [, ...] ]
MERGE INTO [ ONLY ] <replaceable class="parameter">target_table_name</replaceable> [ * ] [ [ AS ] <replaceable class="parameter">target_alias</replaceable> ]
USING <replaceable class="parameter">data_source</replaceable> ON <replaceable class="parameter">join_condition</replaceable>
<replaceable class="parameter">when_clause</replaceable> [...]

<phrase>where <replaceable class="parameter">data_source</replaceable> is:</phrase>

{ [ ONLY ] <replaceable class="parameter">source_table_name</replaceable> [ * ] | ( <replaceable class="parameter">source_query</replaceable> ) } [ [ AS ] <replaceable class="parameter">source_alias</replaceable> ]

<phrase>and <replaceable class="parameter">when_clause</replaceable> is:</phrase>

{ WHEN MATCHED [ AND <replaceable class="parameter">condition</replaceable> ] THEN { <replaceable class="parameter">merge_update</replaceable> | <replaceable class="parameter">merge_delete</replaceable> | DO NOTHING } |
  WHEN NOT MATCHED [ AND <replaceable class="parameter">condition</replaceable> ] THEN { <replaceable class="parameter">merge_insert</replaceable> | DO NOTHING } }

<phrase>and <replaceable class="parameter">merge_insert</replaceable> is:</phrase>

INSERT [( <replaceable class="parameter">column_name</replaceable> [, ...] )]
[ OVERRIDING { SYSTEM | USER } VALUE ]
{ VALUES ( { <replaceable class="parameter">expression</replaceable> | DEFAULT } [, ...] ) | DEFAULT VALUES }

<phrase>and <replaceable class="parameter">merge_update</replaceable> is:</phrase>

UPDATE SET { <replaceable class="parameter">column_name</replaceable> = { <replaceable class="parameter">expression</replaceable> | DEFAULT } |
             ( <replaceable class="parameter">column_name</replaceable> [, ...] ) = [ ROW ] ( { <replaceable class="parameter">expression</replaceable> | DEFAULT } [, ...] ) |
             ( <replaceable class="parameter">column_name</replaceable> [, ...] ) = ( <replaceable class="parameter">sub-SELECT</replaceable> )
           } [, ...]

<phrase>and <replaceable class="parameter">merge_delete</replaceable> is:</phrase>

DELETE
</synopsis>
<!-- pgdoc-cn_end sig_en=1e60c9b3427dc4770db081d87044cea6 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=4c8edecd4772b3b25dbf0e373dec9f38 sig_cn_org=9e7297491a58b3133a06311b48271d0f source=15.7 
  <para>
   <command>MERGE</command> performs actions that modify rows in the
   target table identified as <replaceable class="parameter">target_table_name</replaceable>,
   using the <replaceable class="parameter">data_source</replaceable>.
   <command>MERGE</command> provides a single <acronym>SQL</acronym>
   statement that can conditionally <command>INSERT</command>,
   <command>UPDATE</command> or <command>DELETE</command> rows, a task
   that would otherwise require multiple procedural language statements.
  </para>
________________________________________________________-->
  <para>
   <command>MERGE</command>执行修改目标表中被标识为<replaceable class="parameter">target_table_name</replaceable>的行的操作，
   使用<replaceable class="parameter">data_source</replaceable>。
   <command>MERGE</command>提供了一个单一的<acronym>SQL</acronym>语句，可以有条件地<command>INSERT</command>、
   <command>UPDATE</command>或<command>DELETE</command>行，这是一项原本需要多个过程语言语句的任务。
</para>
<!-- pgdoc-cn_end sig_en=4c8edecd4772b3b25dbf0e373dec9f38 -->

<!-- pgdoc-cn_start sig_en=176c08ce23c64bfd83e1b4f37d62d6eb sig_cn_org=20f52408c7f2e74f976dd64794d66e91 source=15.7 
  <para>
   First, the <command>MERGE</command> command performs a join
   from <replaceable class="parameter">data_source</replaceable> to
   the target table
   producing zero or more candidate change rows.  For each candidate change
   row, the status of <literal>MATCHED</literal> or <literal>NOT MATCHED</literal>
   is set just once, after which <literal>WHEN</literal> clauses are evaluated
   in the order specified.  For each candidate change row, the first clause to
   evaluate as true is executed.  No more than one <literal>WHEN</literal>
   clause is executed for any candidate change row.
  </para>
________________________________________________________-->
  <para>
   首先，<command>MERGE</command>命令执行从<replaceable class="parameter">data_source</replaceable>到目标表的连接，
   生成零个或多个候选更改行。对于每个候选更改行，<literal>MATCHED</literal>或<literal>NOT MATCHED</literal>的状态
   仅设置一次，之后按指定顺序评估<literal>WHEN</literal>子句。对于每个候选更改行，第一个评估为真的子句将被执行。
   对于任何候选更改行，不会执行多于一个<literal>WHEN</literal>子句。
</para>
<!-- pgdoc-cn_end sig_en=176c08ce23c64bfd83e1b4f37d62d6eb -->

<!-- pgdoc-cn_start sig_en=f16a3fc6082f78090cc51b0870e302d0 sig_cn_org=32739b96a681ce6237e49881df9e9660 source=15.7 
  <para>
   <command>MERGE</command> actions have the same effect as
   regular <command>UPDATE</command>, <command>INSERT</command>, or
   <command>DELETE</command> commands of the same names. The syntax of
   those commands is different, notably that there is no <literal>WHERE</literal>
   clause and no table name is specified.  All actions refer to the
   target table,
   though modifications to other tables may be made using triggers.
  </para>
________________________________________________________-->
  <para>
   <command>MERGE</command> 操作与常规的 <command>UPDATE</command>、<command>INSERT</command> 或 <command>DELETE</command> 命令具有相同的效果。
   这些命令的语法不同，特别是没有 <literal>WHERE</literal> 子句，也没有指定表名。
   所有操作都是针对目标表的，尽管可以使用触发器对其他表进行修改。
</para>
<!-- pgdoc-cn_end sig_en=f16a3fc6082f78090cc51b0870e302d0 -->

<!-- pgdoc-cn_start sig_en=97a1dcd2fd6a7639199ab4d8108d11b1 sig_cn_org=88b2de4c66f0e05287968f8d64227aac source=15.7 
  <para>
   When <literal>DO NOTHING</literal> is specified, the source row is
   skipped. Since actions are evaluated in their specified order, <literal>DO
   NOTHING</literal> can be handy to skip non-interesting source rows before
   more fine-grained handling.
  </para>
________________________________________________________-->
  <para>
   当指定<literal>DO NOTHING</literal>时，源行将被跳过。由于操作按照它们指定的顺序进行评估，
   <literal>DO NOTHING</literal>可以很方便地跳过不感兴趣的源行，然后再进行更精细的处理。
</para>
<!-- pgdoc-cn_end sig_en=97a1dcd2fd6a7639199ab4d8108d11b1 -->

<!-- pgdoc-cn_start sig_en=bc96899a8ec41a07a3dd581b8dbba4cc sig_cn_org=a62f7590635a996760ef8c1c978c5502 source=15.7 
  <para>
   There is no separate <literal>MERGE</literal> privilege.
   If you specify an update action, you must have the
   <literal>UPDATE</literal> privilege on the column(s)
   of the target table
   that are referred to in the <literal>SET</literal> clause.
   If you specify an insert action, you must have the <literal>INSERT</literal>
   privilege on the target table.
   If you specify a delete action, you must have the <literal>DELETE</literal>
   privilege on the target table.
   If you specify a <literal>DO NOTHING</literal> action, you must have
   the <literal>SELECT</literal> privilege on at least one column
   of the target table.
   You will also need <literal>SELECT</literal> privilege on any column(s)
   of the <replaceable class="parameter">data_source</replaceable> and
   of the target table referred to
   in any <literal>condition</literal> (including <literal>join_condition</literal>)
   or <literal>expression</literal>.
   Privileges are tested once at statement start and are checked
   whether or not particular <literal>WHEN</literal> clauses are executed.
  </para>
________________________________________________________-->
  <para>
   没有单独的<literal>MERGE</literal>权限。
   如果您指定了更新操作，您必须拥有目标表中在<literal>SET</literal>子句中引用的列的<literal>UPDATE</literal>权限。
   如果您指定了插入操作，您必须拥有目标表的<literal>INSERT</literal>权限。
   如果您指定了删除操作，您必须拥有目标表的<literal>DELETE</literal>权限。
   如果您指定了<literal>DO NOTHING</literal>操作，您必须至少拥有目标表中一列的<literal>SELECT</literal>权限。
   您还需要对<replaceable class="parameter">data_source</replaceable>和目标表中在任何<literal>condition</literal>
   （包括<literal>join_condition</literal>）或<literal>expression</literal>中引用的任何列拥有<literal>SELECT</literal>权限。
   权限在语句开始时进行一次测试，并在执行特定<literal>WHEN</literal>子句时进行检查。
</para>
<!-- pgdoc-cn_end sig_en=bc96899a8ec41a07a3dd581b8dbba4cc -->

<!-- pgdoc-cn_start sig_en=a44778cdeecf2599841306dcdd1ba3b5 sig_cn_org=4bf0a04e840fc2c4631db9f6c15da70d source=15.7 
  <para>
   <command>MERGE</command> is not supported if the
   target table is a
   materialized view, foreign table, or if it has any
   rules defined on it.
  </para>
________________________________________________________-->
  <para>
   <command>MERGE</command>不支持如果目标表是一个
   物化视图、外部表，或者如果它有任何
   在其上定义的规则。
</para>
<!-- pgdoc-cn_end sig_en=a44778cdeecf2599841306dcdd1ba3b5 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=55f21f3bddee6a8d223aa24ab57d80dc sig_cn_org=None source=14.1 
  <title>Parameters</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=55f21f3bddee6a8d223aa24ab57d80dc -->

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">with_query</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=f3424a4628e23ccb71e308ddb5183fdf sig_cn_org=5f951b6020197d4a52817aabe7aa29f6 source=15.7 
     <para>
      The <literal>WITH</literal> clause allows you to specify one or more
      subqueries that can be referenced by name in the <command>MERGE</command>
      query. See <xref linkend="queries-with"/> and <xref linkend="sql-select"/>
      for details.  Note that <literal>WITH RECURSIVE</literal> is not supported
      by <command>MERGE</command>.
     </para>
________________________________________________________-->
     <para>
      <literal>WITH</literal>子句允许您指定一个或多个子查询，这些子查询可以在<command>MERGE</command>查询中通过名称引用。
      有关详细信息，请参见<xref linkend="queries-with"/>和<xref linkend="sql-select"/>。请注意，<literal>WITH RECURSIVE</literal>不受<command>MERGE</command>支持。
     </para>
<!-- pgdoc-cn_end sig_en=f3424a4628e23ccb71e308ddb5183fdf -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">target_table_name</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=18d3523217f688534cfd0d7d66336432 sig_cn_org=e27abdc3269000b5c5c0b254f3950401 source=15.7 
     <para>
      The name (optionally schema-qualified) of the target table to merge into.
      If <literal>ONLY</literal> is specified before the table name, matching
      rows are updated or deleted in the named table only.  If
      <literal>ONLY</literal> is not specified, matching rows are also updated
      or deleted in any tables inheriting from the named table.  Optionally,
      <literal>*</literal> can be specified after the table name to explicitly
      indicate that descendant tables are included.  The
      <literal>ONLY</literal> keyword and <literal>*</literal> option do not
      affect insert actions, which always insert into the named table only.
     </para>
________________________________________________________-->
     <para>
      要合并的目标表的名称（可选模式限定符）。如果在表名之前指定<literal>ONLY</literal>，
      则仅在指定的表中更新或删除匹配的行。如果未指定<literal>ONLY</literal>，
      则匹配的行也会在任何继承自指定表的表中更新或删除。可选地，
      可以在表名后指定<literal>*</literal>以明确表示包括后代表。关键字
      <literal>ONLY</literal>和<literal>*</literal>选项不影响插入操作，
      插入操作始终仅插入到指定的表中。
     </para>
<!-- pgdoc-cn_end sig_en=18d3523217f688534cfd0d7d66336432 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">target_alias</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=5967248ba3338ad5d4f5febf639172f8 sig_cn_org=5d35128e8e6a374c0d7f029c5f2e7ccb source=15.7 
     <para>
      A substitute name for the target table. When an alias is
      provided, it completely hides the actual name of the table.  For
      example, given <literal>MERGE INTO foo AS f</literal>, the remainder of the
      <command>MERGE</command> statement must refer to this table as
      <literal>f</literal> not <literal>foo</literal>.
     </para>
________________________________________________________-->
     <para>
      目标表的替代名称。当提供别名时，它完全隐藏了表的实际名称。例如，给定<literal>MERGE INTO foo AS f</literal>，
      <command>MERGE</command>语句的其余部分必须将此表称为<literal>f</literal>而不是<literal>foo</literal>。
</para>
<!-- pgdoc-cn_end sig_en=5967248ba3338ad5d4f5febf639172f8 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">source_table_name</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=96c01f127d7939d80b542fd9f4ec4a90 sig_cn_org=73a29c4a750521d77b9312d4a23dc26e source=15.7 
     <para>
      The name (optionally schema-qualified) of the source table, view, or
      transition table.  If <literal>ONLY</literal> is specified before the
      table name, matching rows are included from the named table only.  If
      <literal>ONLY</literal> is not specified, matching rows are also included
      from any tables inheriting from the named table.  Optionally,
      <literal>*</literal> can be specified after the table name to explicitly
      indicate that descendant tables are included.
     </para>
________________________________________________________-->
     <para>
      源表、视图或过渡表的名称（可选模式限定）。如果在表名之前指定了<literal>ONLY</literal>，
      则仅包括来自指定表的匹配行。如果未指定<literal>ONLY</literal>，则还将包括来自继承自指定表的任何表的匹配行。
      可选地，可以在表名后指定<literal>*</literal>，以明确指示包括后代表。
     </para>
<!-- pgdoc-cn_end sig_en=96c01f127d7939d80b542fd9f4ec4a90 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">source_query</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=a85585d2132b6d99ab058d82743e826f sig_cn_org=6f679a4d277e1aa7b788c9de3dd110b1 source=15.7 
     <para>
      A query (<command>SELECT</command> statement or <command>VALUES</command>
      statement) that supplies the rows to be merged into the
      target table.
      Refer to the <xref linkend="sql-select"/>
      statement or <xref linkend="sql-values"/>
      statement for a description of the syntax.
     </para>
________________________________________________________-->
     <para>
      一个查询（<command>SELECT</command>语句或<command>VALUES</command>语句），
      用于提供要合并到目标表中的行。
      参考<xref linkend="sql-select"/>语句或<xref linkend="sql-values"/>语句，
      了解语法的描述。
</para>
<!-- pgdoc-cn_end sig_en=a85585d2132b6d99ab058d82743e826f -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">source_alias</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=8591134d8bc9eff37d771e7e13759035 sig_cn_org=d5d9904d9726973fc7f632465803fb46 source=15.7 
     <para>
      A substitute name for the data source. When an alias is
      provided, it completely hides the actual name of the table or the fact
      that a query was issued.
     </para>
________________________________________________________-->
     <para>
      数据源的替代名称。当提供别名时，它完全隐藏了表的实际名称或发出查询的事实。
     </para>
<!-- pgdoc-cn_end sig_en=8591134d8bc9eff37d771e7e13759035 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">join_condition</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=60c9e6e3ad7af0a2211d82cbbdfc7af3 sig_cn_org=8847b6dddc71130ba3e23303b7da6e44 source=15.7 
     <para>
      <replaceable class="parameter">join_condition</replaceable> is
      an expression resulting in a value of type
      <type>boolean</type> (similar to a <literal>WHERE</literal>
      clause) that specifies which rows in the
      <replaceable class="parameter">data_source</replaceable>
      match rows in the target table.
     </para>
________________________________________________________-->
     <para>
      <replaceable class="parameter">join_condition</replaceable>是一个表达式，其结果为<type>boolean</type>
	  类型（类似于<literal>WHERE</literal>子句），指定了<replaceable class="parameter">data_source</replaceable>
	  中的哪些行与目标表中的行匹配。
     </para>
<!-- pgdoc-cn_end sig_en=60c9e6e3ad7af0a2211d82cbbdfc7af3 -->
     <warning>
<!-- pgdoc-cn_start sig_en=3c078176d9e88caec7cc2597a6dba1ae sig_cn_org=e07f9092cee7fb826d6176939eb033d0 source=15.7 
      <para>
       Only columns from the target table
       that attempt to match <replaceable class="parameter">data_source</replaceable>
       rows should appear in <replaceable class="parameter">join_condition</replaceable>.
       <replaceable class="parameter">join_condition</replaceable> subexpressions that
       only reference the target table's
       columns can affect which action is taken, often in surprising ways.
      </para>
________________________________________________________-->
      <para>
       只有来自目标表的列，尝试匹配<replaceable class="parameter">data_source</replaceable>
       行的列应出现在<replaceable class="parameter">join_condition</replaceable>中。
       只引用目标表列的<replaceable class="parameter">join_condition</replaceable>子表达式
       可以影响采取的操作，通常以令人惊讶的方式。
      </para>
<!-- pgdoc-cn_end sig_en=3c078176d9e88caec7cc2597a6dba1ae -->
     </warning>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">when_clause</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=e9244f6230246c98156e279f3944b072 sig_cn_org=508c4598d6205fbdc48a09500c90cd9f source=15.7 
     <para>
      At least one <literal>WHEN</literal> clause is required.
     </para>
________________________________________________________-->
     <para>
      至少需要一个<literal>WHEN</literal>子句。
     </para>
<!-- pgdoc-cn_end sig_en=e9244f6230246c98156e279f3944b072 -->
<!-- pgdoc-cn_start sig_en=8d7c0b1e0c370d0b87286230f22eefb8 sig_cn_org=84210dade9c4129cc7dfcd9546c9871a source=15.7 
     <para>
      If the <literal>WHEN</literal> clause specifies <literal>WHEN MATCHED</literal>
      and the candidate change row matches a row in the
      target table,
      the <literal>WHEN</literal> clause is executed if the
      <replaceable class="parameter">condition</replaceable> is
      absent or it evaluates to <literal>true</literal>.
     </para>
________________________________________________________-->
     <para>
      如果<literal>WHEN</literal>子句指定为<literal>WHEN MATCHED</literal>，
      并且候选更改行匹配目标表中的一行，
      如果<replaceable class="parameter">condition</replaceable>不存在或评估为<literal>true</literal>，
      则执行<literal>WHEN</literal>子句。
     </para>
<!-- pgdoc-cn_end sig_en=8d7c0b1e0c370d0b87286230f22eefb8 -->
<!-- pgdoc-cn_start sig_en=7d75aea33ac186f4406512660cda007f sig_cn_org=ee5e5741d36c3ff2b57351808f115116 source=15.7 
     <para>
      Conversely, if the <literal>WHEN</literal> clause specifies
      <literal>WHEN NOT MATCHED</literal>
      and the candidate change row does not match a row in the
      target table,
      the <literal>WHEN</literal> clause is executed if the
      <replaceable class="parameter">condition</replaceable> is
      absent or it evaluates to <literal>true</literal>.
     </para>
________________________________________________________-->
     <para>
      相反，如果<literal>WHEN</literal>子句指定<literal>WHEN NOT MATCHED</literal>，
      并且候选更改行与目标表中的行不匹配，
      则如果<replaceable class="parameter">condition</replaceable>不存在或评估为<literal>true</literal>，
      则执行<literal>WHEN</literal>子句。
     </para>
<!-- pgdoc-cn_end sig_en=7d75aea33ac186f4406512660cda007f -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">condition</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=343f173e3898b6d8ea2042286a00232b sig_cn_org=bb2c69493b627467c2efa0615dfa9af0 source=15.7 
     <para>
      An expression that returns a value of type <type>boolean</type>.
      If this expression for a <literal>WHEN</literal> clause
      returns <literal>true</literal>, then the action for that clause
      is executed for that row.
     </para>
________________________________________________________-->
     <para>
      返回一个<type>boolean</type>类型值的表达式。
      如果<literal>WHEN</literal>子句的表达式返回<literal>true</literal>，
      那么该子句的操作将对该行执行。
</para>
<!-- pgdoc-cn_end sig_en=343f173e3898b6d8ea2042286a00232b -->
<!-- pgdoc-cn_start sig_en=b5f369acc2e2bd03815b7425be704ea8 sig_cn_org=8fcfd975bb992499c97bd6cb0f2646fd source=15.7 
     <para>
      A condition on a <literal>WHEN MATCHED</literal> clause can refer to columns
      in both the source and the target relations. A condition on a
      <literal>WHEN NOT MATCHED</literal> clause can only refer to columns from
      the source relation, since by definition there is no matching target row.
      Only the system attributes from the target table are accessible.
     </para>
________________________________________________________-->
     <para>
      在<literal>WHEN MATCHED</literal>子句上的条件可以引用源关系和目标关系中的列。
      在<literal>WHEN NOT MATCHED</literal>子句上的条件只能引用源关系中的列，因为根据定义，
      没有匹配的目标行。只有目标表中的系统属性是可访问的。
     </para>
<!-- pgdoc-cn_end sig_en=b5f369acc2e2bd03815b7425be704ea8 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">merge_insert</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=0619f8cfd9ad7876db514f68f14ed154 sig_cn_org=7c41fe1501713c30158c7b26e30850a5 source=15.7 
     <para>
      The specification of an <literal>INSERT</literal> action that inserts
      one row into the target table.
      The target column names can be listed in any order. If no list of
      column names is given at all, the default is all the columns of the
      table in their declared order.
     </para>
________________________________________________________-->
     <para>
      <literal>INSERT</literal>操作的规范是将一行插入目标表中。
      目标列名可以以任何顺序列出。如果根本没有列名列表，
      则默认为表中所有列按其声明的顺序。
</para>
<!-- pgdoc-cn_end sig_en=0619f8cfd9ad7876db514f68f14ed154 -->
<!-- pgdoc-cn_start sig_en=54c93e407f5312490ec9a39ae60aba0c sig_cn_org=f581e4451471da87d123f994710bb52a source=15.7 
     <para>
      Each column not present in the explicit or implicit column list will be
      filled with a default value, either its declared default value
      or null if there is none.
     </para>
________________________________________________________-->
     <para>
      每个未在显式或隐式列列表中出现的列都将填充默认值，要么是其声明的默认值，要么是null（如果没有默认值）。
     </para>
<!-- pgdoc-cn_end sig_en=54c93e407f5312490ec9a39ae60aba0c -->
<!-- pgdoc-cn_start sig_en=1ff4889c33696a95a11a14f67d89be71 sig_cn_org=1ee1261759bd9814591ad546b5739ac6 source=15.7 
     <para>
      If the target table
      is a partitioned table, each row is routed to the appropriate partition
      and inserted into it.
      If the target table
      is a partition, an error will occur if any input row violates the
      partition constraint.
     </para>
________________________________________________________-->
     <para>
      如果目标表是一个分区表，每一行将被路由到相应的分区并插入其中。
      如果目标表是一个分区，如果任何输入行违反了分区约束，将会发生错误。
     </para>
<!-- pgdoc-cn_end sig_en=1ff4889c33696a95a11a14f67d89be71 -->
<!-- pgdoc-cn_start sig_en=5e223513a25a38ffdfee57c6c6b59c08 sig_cn_org=039d8eda7cb215f1f0268d01216b9fa1 source=15.7 
     <para>
      Column names may not be specified more than once.
      <command>INSERT</command> actions cannot contain sub-selects.
     </para>
________________________________________________________-->
     <para>
      列名不能被指定超过一次。
      <command>INSERT</command> 操作不能包含子查询。
     </para>
<!-- pgdoc-cn_end sig_en=5e223513a25a38ffdfee57c6c6b59c08 -->
<!-- pgdoc-cn_start sig_en=73da32d2f7b5b3b8f4862a863f4aed24 sig_cn_org=38118d4bf20d3c81504b252f5ce43050 source=15.7 
     <para>
      Only one <literal>VALUES</literal> clause can be specified.
      The <literal>VALUES</literal> clause can only refer to columns from
      the source relation, since by definition there is no matching target row.
     </para>
________________________________________________________-->
     <para>
      只能指定一个<literal>VALUES</literal>子句。
      <literal>VALUES</literal>子句只能引用源关系中的列，因为根据定义，没有匹配的目标行。
</para>
<!-- pgdoc-cn_end sig_en=73da32d2f7b5b3b8f4862a863f4aed24 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">merge_update</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=738a1df91ae99e6cd36a7577dd3e9625 sig_cn_org=553922b9735991c86c40a256b9bae6ca source=15.7 
     <para>
      The specification of an <literal>UPDATE</literal> action that updates
      the current row of the target table.
      Column names may not be specified more than once.
     </para>
________________________________________________________-->
     <para>
      指定一个<literal>UPDATE</literal>操作，更新目标表的当前行。
      列名不能被指定超过一次。
</para>
<!-- pgdoc-cn_end sig_en=738a1df91ae99e6cd36a7577dd3e9625 -->
<!-- pgdoc-cn_start sig_en=4b17cc19df05c2dd12c2263e01f1046a sig_cn_org=4a6ceed1ecf8ccbe644a05afac9fe2f5 source=15.7 
     <para>
      Neither a table name nor a <literal>WHERE</literal> clause are allowed.
     </para>
________________________________________________________-->
     <para>
      表名和<literal>WHERE</literal>子句都不允许。
     </para>
<!-- pgdoc-cn_end sig_en=4b17cc19df05c2dd12c2263e01f1046a -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">merge_delete</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=70406d68b2a685d278c9f0a88d155b70 sig_cn_org=f3511e927f722bb445d36e6dfe626b48 source=15.7 
     <para>
      Specifies a <literal>DELETE</literal> action that deletes the current row
      of the target table.
      Do not include the table name or any other clauses, as you would normally
      do with a <xref linkend="sql-delete"/> command.
     </para>
________________________________________________________-->
     <para>
      指定一个<literal>DELETE</literal>操作，用于删除目标表的当前行。
      不要包括表名或其他子句，就像您通常使用<xref linkend="sql-delete"/>命令一样。
</para>
<!-- pgdoc-cn_end sig_en=70406d68b2a685d278c9f0a88d155b70 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">column_name</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=18f1072888877abc152cbb0bb1b7408f sig_cn_org=78889cab26019910ba897b8469e9d6fb source=15.7 
     <para>
      The name of a column in the target table.  The column name
      can be qualified with a subfield name or array subscript, if
      needed.  (Inserting into only some fields of a composite
      column leaves the other fields null.)
      Do not include the table's name in the specification
      of a target column.
     </para>
________________________________________________________-->
     <para>
      目标表中的列名。如果需要，列名可以带有子字段名或数组下标。
      （仅向复合列的某些字段插入数据会使其他字段为空。）
      在指定目标列时不要包含表名。
</para>
<!-- pgdoc-cn_end sig_en=18f1072888877abc152cbb0bb1b7408f -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OVERRIDING SYSTEM VALUE</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=0b2978ad0c1b9de418c957fab1dc577d sig_cn_org=0d96ee3d05516fa89f5f423a54e55287 source=15.7 
     <para>
      Without this clause, it is an error to specify an explicit value
      (other than <literal>DEFAULT</literal>) for an identity column defined
      as <literal>GENERATED ALWAYS</literal>.  This clause overrides that
      restriction.
     </para>
________________________________________________________-->
     <para>
      没有这个子句，为一个定义为<literal>GENERATED ALWAYS</literal>的标识列指定一个显式值
      （除了<literal>DEFAULT</literal>之外）是一个错误。这个子句覆盖了该限制。
     </para>
<!-- pgdoc-cn_end sig_en=0b2978ad0c1b9de418c957fab1dc577d -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OVERRIDING USER VALUE</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=394e82cc0455214a4c3a2a6f793469b3 sig_cn_org=e141d0cdca0556ade34cf8e3bbdc35ef source=15.7 
     <para>
      If this clause is specified, then any values supplied for identity
      columns defined as <literal>GENERATED BY DEFAULT</literal> are ignored
      and the default sequence-generated values are applied.
     </para>
________________________________________________________-->
     <para>
      如果指定了此子句，则会忽略为定义为<literal>GENERATED BY DEFAULT</literal>的标识列提供的任何值，
      并应用默认的序列生成的值。
     </para>
<!-- pgdoc-cn_end sig_en=394e82cc0455214a4c3a2a6f793469b3 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DEFAULT VALUES</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=f85999db7c80c0a8478be92cec9a06a9 sig_cn_org=26440a3219d3c76064bed5458338a6d0 source=15.7 
     <para>
      All columns will be filled with their default values.
      (An <literal>OVERRIDING</literal> clause is not permitted in this
      form.)
     </para>
________________________________________________________-->
     <para>
      所有列将填充其默认值。
      (在此形式中不允许使用<literal>OVERRIDING</literal>子句。)
</para>
<!-- pgdoc-cn_end sig_en=f85999db7c80c0a8478be92cec9a06a9 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">expression</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=641b071b1421c8d3c509d592aacc0c8d sig_cn_org=9040c97b226c4e1c64afc2b5c933d1ac source=15.7 
     <para>
      An expression to assign to the column.  If used in a
      <literal>WHEN MATCHED</literal> clause, the expression can use values
      from the original row in the target table, and values from the
      <replaceable class="parameter">data_source</replaceable> row.
      If used in a <literal>WHEN NOT MATCHED</literal> clause, the
      expression can use values from the
      <replaceable class="parameter">data_source</replaceable> row.
     </para>
________________________________________________________-->
     <para>
      要分配给列的表达式。如果在<literal>WHEN MATCHED</literal>子句中使用，
      表达式可以使用目标表中原始行的值，以及<replaceable class="parameter">data_source</replaceable>行中的值。
      如果在<literal>WHEN NOT MATCHED</literal>子句中使用，表达式可以使用
      <replaceable class="parameter">data_source</replaceable>行中的值。
</para>
<!-- pgdoc-cn_end sig_en=641b071b1421c8d3c509d592aacc0c8d -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DEFAULT</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=20a71526f413e1e1b39fdc314004535a sig_cn_org=ca8ef080bd3768e2fda227c04d98973e source=15.7 
     <para>
      Set the column to its default value (which will be <literal>NULL</literal>
      if no specific default expression has been assigned to it).
     </para>
________________________________________________________-->
     <para>
      将列设置为其默认值（如果没有为其分配特定的默认表达式，则将为<literal>NULL</literal>）。
     </para>
<!-- pgdoc-cn_end sig_en=20a71526f413e1e1b39fdc314004535a -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">sub-SELECT</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=fa67ac39da2241c378aaeca81b60dded sig_cn_org=246338ac85172234ce5994aa5d44fafd source=15.7 
     <para>
      A <literal>SELECT</literal> sub-query that produces as many output columns
      as are listed in the parenthesized column list preceding it.  The
      sub-query must yield no more than one row when executed.  If it
      yields one row, its column values are assigned to the target columns;
      if it yields no rows, NULL values are assigned to the target columns.
      The sub-query can refer to values from the original row in the target table,
      and values from the <replaceable class="parameter">data_source</replaceable>
      row.
     </para>
________________________________________________________-->
     <para>
      一个<literal>SELECT</literal>子查询，产生与其前面括号中列出的列数相同的输出列。
      当执行时，子查询必须产生不超过一行。如果产生一行，则将其列值分配给目标列；
      如果没有产生行，则将NULL值分配给目标列。子查询可以引用目标表中原始行的值，
      以及<replaceable class="parameter">data_source</replaceable>行的值。
</para>
<!-- pgdoc-cn_end sig_en=fa67ac39da2241c378aaeca81b60dded -->
    </listitem>
   </varlistentry>

  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=83a929047ae9374bbfd2aa827d90c66a sig_cn_org=None source=14.1 
  <title>Outputs</title>
________________________________________________________-->
  <title>输出</title>
<!-- pgdoc-cn_end sig_en=83a929047ae9374bbfd2aa827d90c66a -->

<!-- pgdoc-cn_start sig_en=d1e933cd436a0c52c542c105d12cb6d5 sig_cn_org=b8709938d4174a3d18b18bf75bcb13f0 source=15.7 
  <para>
   On successful completion, a <command>MERGE</command> command returns a command
   tag of the form
<screen>
MERGE <replaceable class="parameter">total_count</replaceable>
</screen>
   The <replaceable class="parameter">total_count</replaceable> is the total
   number of rows changed (whether inserted, updated, or deleted).
   If <replaceable class="parameter">total_count</replaceable> is 0, no rows
   were changed in any way.
  </para>
________________________________________________________-->
  <para>
   在成功完成后，<command>MERGE</command>命令返回一个形式为
<screen>
MERGE <replaceable class="parameter">total_count</replaceable>
</screen>
   <replaceable class="parameter">total_count</replaceable>是更改的总行数（无论是插入、更新还是删除）。
   如果<replaceable class="parameter">total_count</replaceable>为0，则没有任何行发生更改。
</para>
<!-- pgdoc-cn_end sig_en=d1e933cd436a0c52c542c105d12cb6d5 -->

 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 sig_cn_org=None source=14.1 
  <title>Notes</title>
________________________________________________________-->
  <title>注解</title>
<!-- pgdoc-cn_end sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 -->

<!-- pgdoc-cn_start sig_en=7ebf7c887589b1aebd1bc5a7a656b0a8 sig_cn_org=754f6b99b69304625c31f8ae322f3694 source=15.7 
  <para>
   The following steps take place during the execution of
   <command>MERGE</command>.
    <orderedlist>
     <listitem>
      <para>
       Perform any <literal>BEFORE STATEMENT</literal> triggers for all
       actions specified, whether or not their <literal>WHEN</literal>
       clauses match.
      </para>
     </listitem>
     <listitem>
      <para>
       Perform a join from source to target table.
       The resulting query will be optimized normally and will produce
       a set of candidate change rows. For each candidate change row,
       <orderedlist>
        <listitem>
         <para>
          Evaluate whether each row is <literal>MATCHED</literal> or
          <literal>NOT MATCHED</literal>.
         </para>
        </listitem>
        <listitem>
         <para>
          Test each <literal>WHEN</literal> condition in the order
          specified until one returns true.
         </para>
        </listitem>
        <listitem>
         <para>
          When a condition returns true, perform the following actions:
          <orderedlist>
           <listitem>
            <para>
             Perform any <literal>BEFORE ROW</literal> triggers that fire
             for the action's event type.
            </para>
           </listitem>
           <listitem>
            <para>
             Perform the specified action, invoking any check constraints on the
             target table.
            </para>
           </listitem>
           <listitem>
            <para>
             Perform any <literal>AFTER ROW</literal> triggers that fire for
             the action's event type.
            </para>
           </listitem>
          </orderedlist></para>
        </listitem>
       </orderedlist></para>
     </listitem>
     <listitem>
      <para>
       Perform any <literal>AFTER STATEMENT</literal> triggers for actions
       specified, whether or not they actually occur.  This is similar to the
       behavior of an <command>UPDATE</command> statement that modifies no rows.
      </para>
     </listitem>
    </orderedlist>
   In summary, statement triggers for an event type (say,
   <command>INSERT</command>) will be fired whenever we
   <emphasis>specify</emphasis> an action of that kind.
   In contrast, row-level triggers will fire only for the specific event type
   being <emphasis>executed</emphasis>.
   So a <command>MERGE</command> command might fire statement triggers for both
   <command>UPDATE</command> and <command>INSERT</command>, even though only
   <command>UPDATE</command> row triggers were fired.
  </para>
________________________________________________________-->
  <para>
   在执行<command>MERGE</command>期间，以下步骤将发生。
    <orderedlist>
     <listitem>
      <para>
       为所有指定的操作执行任何<literal>BEFORE STATEMENT</literal>触发器，无论其<literal>WHEN</literal>子句是否匹配。
      </para>
     </listitem>
     <listitem>
      <para>
       从源表到目标表执行连接。生成的查询将按正常方式优化，并将产生一组候选更改行。对于每个候选更改行，
       <orderedlist>
        <listitem>
         <para>
          评估每行是否<literal>MATCHED</literal>或<literal>NOT MATCHED</literal>。
         </para>
        </listitem>
        <listitem>
         <para>
          按指定顺序测试每个<literal>WHEN</literal>条件，直到有一个返回true。
         </para>
        </listitem>
        <listitem>
         <para>
          当条件返回true时，执行以下操作：
          <orderedlist>
           <listitem>
            <para>
             为事件类型触发的操作执行任何<literal>BEFORE ROW</literal>触发器。
            </para>
           </listitem>
           <listitem>
            <para>
             执行指定的操作，调用目标表上的任何检查约束。
            </para>
           </listitem>
           <listitem>
            <para>
             为事件类型触发的操作执行任何<literal>AFTER ROW</literal>触发器。
            </para>
           </listitem>
          </orderedlist></para>
        </listitem>
       </orderedlist></para>
     </listitem>
     <listitem>
      <para>
       为指定的操作执行任何<literal>AFTER STATEMENT</literal>触发器，无论它们是否实际发生。这类似于修改零行的<command>UPDATE</command>语句的行为。
      </para>
     </listitem>
    </orderedlist>
   总之，事件类型（比如，<command>INSERT</command>）的语句触发器将在我们<emphasis>指定</emphasis>该类型的操作时触发。
   相反，行级触发器仅对正在<emphasis>执行</emphasis>的特定事件类型触发。
   因此，<command>MERGE</command>命令可能会触发<command>UPDATE</command>和<command>INSERT</command>的语句触发器，即使只有<command>UPDATE</command>行触发器被触发。
  </para>
<!-- pgdoc-cn_end sig_en=7ebf7c887589b1aebd1bc5a7a656b0a8 -->

<!-- pgdoc-cn_start sig_en=b72b49636c5d27dad64f36a32aebabe5 sig_cn_org=b5d99e1e08b8a5fae3436c520db9f5c3 source=15.7 
  <para>
   You should ensure that the join produces at most one candidate change row
   for each target row.  In other words, a target row shouldn't join to more
   than one data source row.  If it does, then only one of the candidate change
   rows will be used to modify the target row; later attempts to modify the
   row will cause an error.
   This can also occur if row triggers make changes to the target table
   and the rows so modified are then subsequently also modified by
   <command>MERGE</command>.
   If the repeated action is an <command>INSERT</command>, this will
   cause a uniqueness violation, while a repeated <command>UPDATE</command>
   or <command>DELETE</command> will cause a cardinality violation; the
   latter behavior is required by the <acronym>SQL</acronym> standard.
   This differs from historical <productname>PostgreSQL</productname>
   behavior of joins in <command>UPDATE</command> and
   <command>DELETE</command> statements where second and subsequent
   attempts to modify the same row are simply ignored.
  </para>
________________________________________________________-->
  <para>
   您应确保连接最多为每个目标行生成一个候选更改行。换句话说，目标行不应连接到多个数据源行。
   如果连接到多个数据源行，则只会使用一个候选更改行来修改目标行；稍后尝试修改该行将导致错误。
   如果行触发器对目标表进行更改，然后对所修改的行进行<command>MERGE</command>的修改，也会发生这种情况。
   如果重复的操作是<command>INSERT</command>，这将导致唯一性违规，而重复的<command>UPDATE</command>或<command>DELETE</command>将导致基数违规；后者是<acronym>SQL</acronym>标准所要求的行为。
   这与历史上<productname>PostgreSQL</productname>在<command>UPDATE</command>和<command>DELETE</command>语句中对连接的行为不同，后续尝试修改相同行将被简单地忽略。
</para>
<!-- pgdoc-cn_end sig_en=b72b49636c5d27dad64f36a32aebabe5 -->

<!-- pgdoc-cn_start sig_en=f185d1de98efaf08b543f1e3263750ac sig_cn_org=f4149f400b905eb1e468ad5166c0dd9c source=15.7 
  <para>
   If a <literal>WHEN</literal> clause omits an <literal>AND</literal>
   sub-clause, it becomes the final reachable clause of that
   kind (<literal>MATCHED</literal> or <literal>NOT MATCHED</literal>).
   If a later <literal>WHEN</literal> clause of that kind
   is specified it would be provably unreachable and an error is raised.
   If no final reachable clause is specified of either kind, it is
   possible that no action will be taken for a candidate change row.
  </para>
________________________________________________________-->
  <para>
   如果<literal>WHEN</literal>子句省略了一个<literal>AND</literal>子子句，它将成为该种类
   (<literal>MATCHED</literal>或<literal>NOT MATCHED</literal>)的最终可达子句。
   如果稍后指定了该种类的<literal>WHEN</literal>子句，它将被证明是不可达的，并引发错误。
   如果没有指定任何一种最终可达子句，可能不会对候选更改行执行任何操作。
</para>
<!-- pgdoc-cn_end sig_en=f185d1de98efaf08b543f1e3263750ac -->

<!-- pgdoc-cn_start sig_en=267faaf9f4fbc551986a2d199499c1fe sig_cn_org=0814df80fc64ae374ca83dea94b5fcf6 source=15.7 
  <para>
   The order in which rows are generated from the data source is
   indeterminate by default.
   A <replaceable class="parameter">source_query</replaceable> can be
   used to specify a consistent ordering, if required, which might be
   needed to avoid deadlocks between concurrent transactions.
  </para>
________________________________________________________-->
  <para>
   从数据源生成行的顺序默认情况下是不确定的。
   如果需要，可以使用<replaceable class="parameter">source_query</replaceable>来指定一致的排序，
   这可能需要避免并发事务之间的死锁。
</para>
<!-- pgdoc-cn_end sig_en=267faaf9f4fbc551986a2d199499c1fe -->

<!-- pgdoc-cn_start sig_en=188490148aa59e31c79b7acf753857b5 sig_cn_org=3939f7ba9de0d3974543a64f59367f36 source=15.7 
  <para>
   There is no <literal>RETURNING</literal> clause with
   <command>MERGE</command>.  Actions of <command>INSERT</command>,
   <command>UPDATE</command> and <command>DELETE</command> cannot contain
   <literal>RETURNING</literal> or <literal>WITH</literal> clauses.
  </para>
________________________________________________________-->
  <para>
   在<command>MERGE</command>中没有<literal>RETURNING</literal>子句。
   <command>INSERT</command>，<command>UPDATE</command>和<command>DELETE</command>的操作不能包含<literal>RETURNING</literal>或<literal>WITH</literal>子句。
</para>
<!-- pgdoc-cn_end sig_en=188490148aa59e31c79b7acf753857b5 -->

<!-- pgdoc-cn_start sig_en=7739c683136cd13cb673c91803e41fc8 sig_cn_org=96d9dc677348fefbb3253724b443d06d source=15.7 
  <para>
   When <command>MERGE</command> is run concurrently with other commands
   that modify the target table, the usual transaction isolation rules
   apply; see <xref linkend="transaction-iso"/> for an explanation
   on the behavior at each isolation level.
   You may also wish to consider using <command>INSERT ... ON CONFLICT</command>
   as an alternative statement which offers the ability to run an
   <command>UPDATE</command> if a concurrent <command>INSERT</command>
   occurs.  There are a variety of differences and restrictions between
   the two statement types and they are not interchangeable.
  </para>
________________________________________________________-->
  <para>
   当<command>MERGE</command>与修改目标表的其他命令同时运行时，通常的事务隔离规则适用；
   请参阅<xref linkend="transaction-iso"/>以了解每个隔离级别的行为。
   您可能还希望考虑使用<command>INSERT ... ON CONFLICT</command>作为一种替代语句，
   它提供了在并发<command>INSERT</command>发生时运行<command>UPDATE</command>的能力。
   这两种语句类型之间存在各种差异和限制，它们不能互换使用。
</para>
<!-- pgdoc-cn_end sig_en=7739c683136cd13cb673c91803e41fc8 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d sig_cn_org=None source=14.1 
  <title>Examples</title>
________________________________________________________-->
  <title>示例</title>
<!-- pgdoc-cn_end sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d -->

<!-- pgdoc-cn_start sig_en=1e64e5c1a0c8648b896b8f4edfd60afd sig_cn_org=de5f2ce18d613f7055d78971942d8f3f source=15.7 
  <para>
   Perform maintenance on <literal>customer_accounts</literal> based
   upon new <literal>recent_transactions</literal>.

<programlisting>
MERGE INTO customer_account ca
USING recent_transactions t
ON t.customer_id = ca.customer_id
WHEN MATCHED THEN
  UPDATE SET balance = balance + transaction_value
WHEN NOT MATCHED THEN
  INSERT (customer_id, balance)
  VALUES (t.customer_id, t.transaction_value);
</programlisting>
  </para>
________________________________________________________-->
  <para>
   对<literal>customer_accounts</literal>进行基于新<literal>recent_transactions</literal>的维护。

<programlisting>
MERGE INTO customer_account ca
USING recent_transactions t
ON t.customer_id = ca.customer_id
WHEN MATCHED THEN
  UPDATE SET balance = balance + transaction_value
WHEN NOT MATCHED THEN
  INSERT (customer_id, balance)
  VALUES (t.customer_id, t.transaction_value);
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=1e64e5c1a0c8648b896b8f4edfd60afd -->

<!-- pgdoc-cn_start sig_en=a98e34cd6c7149059ddd38be0d38f8ed sig_cn_org=ea09ce3dfb053956cdac9a1328bb0361 source=15.7 
  <para>
   Notice that this would be exactly equivalent to the following
   statement because the <literal>MATCHED</literal> result does not change
   during execution.

<programlisting>
MERGE INTO customer_account ca
USING (SELECT customer_id, transaction_value FROM recent_transactions) AS t
ON t.customer_id = ca.customer_id
WHEN MATCHED THEN
  UPDATE SET balance = balance + transaction_value
WHEN NOT MATCHED THEN
  INSERT (customer_id, balance)
  VALUES (t.customer_id, t.transaction_value);
</programlisting>
  </para>
________________________________________________________-->
  <para>
   注意，这与以下语句完全等效，因为<literal>MATCHED</literal>结果在执行过程中不会改变。

<programlisting>
MERGE INTO customer_account ca
USING (SELECT customer_id, transaction_value FROM recent_transactions) AS t
ON t.customer_id = ca.customer_id
WHEN MATCHED THEN
  UPDATE SET balance = balance + transaction_value
WHEN NOT MATCHED THEN
  INSERT (customer_id, balance)
  VALUES (t.customer_id, t.transaction_value);
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=a98e34cd6c7149059ddd38be0d38f8ed -->

<!-- pgdoc-cn_start sig_en=272600c475fd22f6d6a0851822562c56 sig_cn_org=507d7a4a7e0d781bd63ee331ab63055b source=15.7 
  <para>
   Attempt to insert a new stock item along with the quantity of stock. If
   the item already exists, instead update the stock count of the existing
   item. Don't allow entries that have zero stock.
<programlisting>
MERGE INTO wines w
USING wine_stock_changes s
ON s.winename = w.winename
WHEN NOT MATCHED AND s.stock_delta > 0 THEN
  INSERT VALUES(s.winename, s.stock_delta)
WHEN MATCHED AND w.stock + s.stock_delta > 0 THEN
  UPDATE SET stock = w.stock + s.stock_delta
WHEN MATCHED THEN
  DELETE;
</programlisting>

   The <literal>wine_stock_changes</literal> table might be, for example, a
   temporary table recently loaded into the database.
  </para>
________________________________________________________-->
  <para>
   尝试插入一个新的库存项目以及库存数量。如果该项目已经存在，则更新现有项目的库存计数。不允许库存为零的条目。
<programlisting>
MERGE INTO wines w
USING wine_stock_changes s
ON s.winename = w.winename
WHEN NOT MATCHED AND s.stock_delta > 0 THEN
  INSERT VALUES(s.winename, s.stock_delta)
WHEN MATCHED AND w.stock + s.stock_delta > 0 THEN
  UPDATE SET stock = w.stock + s.stock_delta
WHEN MATCHED THEN
  DELETE;
</programlisting>

   <literal>wine_stock_changes</literal>表可能是最近加载到数据库中的临时表。
</para>
<!-- pgdoc-cn_end sig_en=272600c475fd22f6d6a0851822562c56 -->

 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=b38d493f3c2d2d5d9a7a49d257da9811 sig_cn_org=None source=14.1 
  <title>Compatibility</title>
________________________________________________________-->
  <title>兼容性</title>
<!-- pgdoc-cn_end sig_en=b38d493f3c2d2d5d9a7a49d257da9811 -->
<!-- pgdoc-cn_start sig_en=0530f38745e651d1820c7fb31c0dc4fb sig_cn_org=7013f3a3fd0e485f73dc3b9201b0e870 source=15.7 
   <para>
    This command conforms to the <acronym>SQL</acronym> standard.
  </para>
________________________________________________________-->
   <para>
    这个命令符合<acronym>SQL</acronym>标准。
  </para>
<!-- pgdoc-cn_end sig_en=0530f38745e651d1820c7fb31c0dc4fb -->
<!-- pgdoc-cn_start sig_en=bae95193e42f2ce24fe9f470c9cbb86d sig_cn_org=bb17607d3e6869d0d928e7eb088680e2 source=15.7 
   <para>
    The <literal>WITH</literal> clause and <literal>DO NOTHING</literal>
    action are extensions to the <acronym>SQL</acronym> standard.
  </para>
________________________________________________________-->
   <para>
    <literal>WITH</literal>子句和<literal>DO NOTHING</literal>操作是<acronym>SQL</acronym>标准的扩展。
  </para>
<!-- pgdoc-cn_end sig_en=bae95193e42f2ce24fe9f470c9cbb86d -->
 </refsect1>
</refentry>
