<!-- doc/src/sgml/ref/pgbench.sgml -->

<refentry id="pgbench">
<!--==========================orignal english content==========================
 <indexterm zone="pgbench">
  <primary>pgbench</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="pgbench">
  <primary>pgbench</primary>
 </indexterm>

<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle><application>pgbench</application></refentrytitle>
  <manvolnum>1</manvolnum>
  <refmiscinfo>Application</refmiscinfo>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle><application>pgbench</application></refentrytitle>
  <manvolnum>1</manvolnum>
  <refmiscinfo>Application</refmiscinfo>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>pgbench</refname>
  <refpurpose>run a benchmark test on <productname>PostgreSQL</productname></refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>pgbench</refname>
  <refpurpose>在<productname>PostgreSQL</productname>上运行一个基准测试</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<!--==========================orignal english content==========================
  <cmdsynopsis>
   <command>pgbench</command>
   <arg choice="plain"><option>-i</option></arg>
   <arg rep="repeat"><replaceable>option</replaceable></arg>
   <arg choice="opt"><replaceable>dbname</replaceable></arg>
  </cmdsynopsis>
____________________________________________________________________________-->
  <cmdsynopsis>
   <command>pgbench</command>
   <arg choice="plain"><option>-i</option></arg>
   <arg rep="repeat"><replaceable>option</replaceable></arg>
   <arg choice="opt"><replaceable>dbname</replaceable></arg>
  </cmdsynopsis>
<!--==========================orignal english content==========================
  <cmdsynopsis>
   <command>pgbench</command>
   <arg rep="repeat"><replaceable>option</replaceable></arg>
   <arg choice="opt"><replaceable>dbname</replaceable></arg>
  </cmdsynopsis>
____________________________________________________________________________-->
  <cmdsynopsis>
   <command>pgbench</command>
   <arg rep="repeat"><replaceable>option</replaceable></arg>
   <arg choice="opt"><replaceable>dbname</replaceable></arg>
  </cmdsynopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>
<!--==========================orignal english content==========================
 <para>
  <application>pgbench</application> is a simple program for running benchmark
  tests on <productname>PostgreSQL</productname>.  It runs the same sequence of SQL
  commands over and over, possibly in multiple concurrent database sessions,
  and then calculates the average transaction rate (transactions per second).
  By default, <application>pgbench</application> tests a scenario that is
  loosely based on TPC-B, involving five <command>SELECT</command>,
  <command>UPDATE</command>, and <command>INSERT</command> commands per transaction.
  However, it is easy to test other cases by writing your own transaction
  script files.
 </para>
____________________________________________________________________________-->
 <para>
  <application>pgbench</application>是一种在<productname>PostgreSQL</productname>上运行基准测试的简单程序。它可能在并发的数据库会话中一遍一遍地运行相同序列的 SQL 命令，并且计算平均事务率（每秒的事务数）。默认情况下，<application>pgbench</application>会测试一种基于 TPC-B 但是要更宽松的场景，其中在每个事务中涉及五个<command>SELECT</command>、<command>UPDATE</command>以及<command>INSERT</command>命令。但是，通过编写自己的事务脚本文件很容易用来测试其他情况。
 </para>

<!--==========================orignal english content==========================
 <para>
  Typical output from <application>pgbench</application> looks like:

<screen>
transaction type: &lt;builtin: TPC-B (sort of)&gt;
scaling factor: 10
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
tps = 85.184871 (including connections establishing)
tps = 85.296346 (excluding connections establishing)
</screen>

  The first six lines report some of the most important parameter
  settings.  The next line reports the number of transactions completed
  and intended (the latter being just the product of number of clients
  and number of transactions per client); these will be equal unless the run
  failed before completion.  (In <option>-T</option> mode, only the actual
  number of transactions is printed.)
  The last two lines report the number of transactions per second,
  figured with and without counting the time to start database sessions.
 </para>
____________________________________________________________________________-->
 <para>
  <application>pgbench</application>的典型输出像这样：

<screen>
transaction type: &lt;builtin: TPC-B (sort of)&gt;
scaling factor: 10
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
tps = 85.184871 (including connections establishing)
tps = 85.296346 (excluding connections establishing)
</screen>

  前六行报告一些最重要的参数设置。接下来的行报告完成的事务数以及预期的事务数（后者就是客户端数量与每个客户端事务数的乘积），除非运行在完成之前失败，这些值应该是相等的（在<option>-T</option>模式中，只有实际的事务数会被打印出来）。最后两行报告每秒的事务数，分别代表包括和不包括开始数据库会话所花时间的情况。
 </para>

<!--==========================orignal english content==========================
  <para>
   The default TPC-B-like transaction test requires specific tables to be
   set up beforehand.  <application>pgbench</application> should be invoked with
   the <option>-i</option> (initialize) option to create and populate these
   tables.  (When you are testing a custom script, you don't need this
   step, but will instead need to do whatever setup your test needs.)
   Initialization looks like:

<programlisting>
pgbench -i <optional> <replaceable>other-options</replaceable> </optional> <replaceable>dbname</replaceable>
</programlisting>

   where <replaceable>dbname</replaceable> is the name of the already-created
   database to test in.  (You may also need <option>-h</option>,
   <option>-p</option>, and/or <option>-U</option> options to specify how to
   connect to the database server.)
  </para>
____________________________________________________________________________-->
  <para>
   默认的类 TPC-B 事务测试要求预先设置好特定的表。可以使用<option>-i</option>（初始化）选项调用<application>pgbench</application>来创建并且填充这些表（当你在测试一个自定义脚本时，你不需要这一步，但是需要按你自己的测试需要做一些设置工作）。初始化类似这样：

<programlisting>
pgbench -i <optional> <replaceable>other-options</replaceable> </optional> <replaceable>dbname</replaceable>
</programlisting>

   其中<replaceable>dbname</replaceable>是要在其中进行测试的预先创建好的数据库的名称（你可能还需要<option>-h</option>、<option>-p</option>或<option>-U</option>选项来指定如何连接到数据库服务器）。
  </para>

  <caution>
<!--==========================orignal english content==========================
   <para>
    <literal>pgbench -i</literal> creates four tables <structname>pgbench_accounts</structname>,
    <structname>pgbench_branches</structname>, <structname>pgbench_history</structname>, and
    <structname>pgbench_tellers</structname>,
    destroying any existing tables of these names.
    Be very careful to use another database if you have tables having these
    names!
   </para>
____________________________________________________________________________-->
   <para>
    <literal>pgbench -i</literal>会创建四个表<structname>pgbench_accounts</structname>、
    <structname>pgbench_branches</structname>、<structname>pgbench_history</structname>以及<structname>pgbench_tellers</structname>，如果同名表已经存在会被先删除。如果你已经有同名表，一定注意要使用另一个数据库！
   </para>
  </caution>

<!--==========================orignal english content==========================
  <para>
   At the default <quote>scale factor</quote> of 1, the tables initially
   contain this many rows:
<screen>
table                   # of rows
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
pgbench_branches        1
pgbench_tellers         10
pgbench_accounts        100000
pgbench_history         0
</screen>
   You can (and, for most purposes, probably should) increase the number
   of rows by using the <option>-s</option> (scale factor) option.  The
   <option>-F</option> (fillfactor) option might also be used at this point.
  </para>
____________________________________________________________________________-->
  <para>
   在默认的情况下<quote>比例因子</quote>为 1，这些表初始包含的行数为：
<screen>
table                   # of rows
---------------------------------
pgbench_branches        1
pgbench_tellers         10
pgbench_accounts        100000
pgbench_history         0
</screen>
   你可以使用<option>-s</option>（比例因子）选项增加行的数量。<option>-F</option>（填充因子）选项也可以在这里使用。
  </para>

<!--==========================orignal english content==========================
  <para>
   Once you have done the necessary setup, you can run your benchmark
   with a command that doesn't include <option>-i</option>, that is

<programlisting>
pgbench <optional> <replaceable>options</replaceable> </optional> <replaceable>dbname</replaceable>
</programlisting>

   In nearly all cases, you'll need some options to make a useful test.
   The most important options are <option>-c</option> (number of clients),
   <option>-t</option> (number of transactions), <option>-T</option> (time limit),
   and <option>-f</option> (specify a custom script file).
   See below for a full list.
  </para>
____________________________________________________________________________-->
  <para>
   一旦你完成了必要的设置，你就可以用不包括<option>-i</option>的命令运行基准，也就是：

<programlisting>
pgbench <optional> <replaceable>options</replaceable> </optional> <replaceable>dbname</replaceable>
</programlisting>

   在近乎所有的情况中，你将需要一些选项来做一次有用的测试。最重要的选项是<option>-c</option>（客户端数量）、
   <option>-t</option>（事务数量）、<option>-T</option>（时间限制）以及<option>-f</option>（指定一个自定义脚本文件）。完整的列表见下文。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Options</title>
____________________________________________________________________________-->
  <title>选项</title>

<!--==========================orignal english content==========================
  <para>
   The following is divided into three subsections.  Different options are
   used during database initialization and while running benchmarks, but some
   options are useful in both cases.
  </para>
____________________________________________________________________________-->
  <para>
   下面分成三个部分。数据库初始化期间使用的选项和运行基准时会使用不同的选项，但也有一些选项在两种情况下都使用。
  </para>

 <refsect2 id="pgbench-init-options">
<!--==========================orignal english content==========================
  <title>Initialization Options</title>
____________________________________________________________________________-->
  <title>初始化选项</title>

<!--==========================orignal english content==========================
   <para>
    <application>pgbench</application> accepts the following command-line
    initialization arguments:

    <variablelist>

     <varlistentry>
      <term><option>-i</option></term>
      <term><option>-&minus;initialize</option></term>
      <listitem>
       <para>
        Required to invoke initialization mode.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-I <replaceable>init_steps</replaceable></option></term>
      <term><option>-&minus;init-steps=<replaceable>init_steps</replaceable></option></term>
      <listitem>
       <para>
        Perform just a selected set of the normal initialization steps.
        <replaceable>init_steps</replaceable> specifies the
        initialization steps to be performed, using one character per step.
        Each step is invoked in the specified order.
        The default is <literal>dtgvp</literal>.
        The available steps are:

        <variablelist>
         <varlistentry>
          <term><literal>d</literal> (Drop)</term>
          <listitem>
           <para>
            Drop any existing <application>pgbench</application> tables.
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term><literal>t</literal> (create Tables)</term>
          <listitem>
           <para>
            Create the tables used by the
            standard <application>pgbench</application> scenario, namely
            <structname>pgbench_accounts</structname>,
            <structname>pgbench_branches</structname>,
            <structname>pgbench_history</structname>, and
            <structname>pgbench_tellers</structname>.
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term><literal>g</literal> (Generate data)</term>
          <listitem>
           <para>
            Generate data and load it into the standard tables,
            replacing any data already present.
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term><literal>v</literal> (Vacuum)</term>
          <listitem>
           <para>
            Invoke <command>VACUUM</command> on the standard tables.
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term><literal>p</literal> (create Primary keys)</term>
          <listitem>
           <para>
            Create primary key indexes on the standard tables.
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
         <term><literal>f</literal> (create Foreign keys)</term>
          <listitem>
           <para>
            Create foreign key constraints between the standard tables.
            (Note that this step is not performed by default.)
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-F</option> <replaceable>fillfactor</replaceable></term>
      <term><option>-&minus;fillfactor=</option><replaceable>fillfactor</replaceable></term>
      <listitem>
       <para>
        Create the <structname>pgbench_accounts</structname>,
        <structname>pgbench_tellers</structname> and
        <structname>pgbench_branches</structname> tables with the given fillfactor.
        Default is 100.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-n</option></term>
      <term><option>-&minus;no-vacuum</option></term>
      <listitem>
       <para>
        Perform no vacuuming during initialization.
        (This option suppresses the <literal>v</literal> initialization step,
        even if it was specified in <option>-I</option>.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-q</option></term>
      <term><option>-&minus;quiet</option></term>
      <listitem>
       <para>
        Switch logging to quiet mode, producing only one progress message per 5
        seconds. The default logging prints one message each 100000 rows, which
        often outputs many lines per second (especially on good hardware).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-s</option> <replaceable>scale_factor</replaceable></term>
      <term><option>-&minus;scale=</option><replaceable>scale_factor</replaceable></term>
      <listitem>
       <para>
        Multiply the number of rows generated by the scale factor.
        For example, <literal>-s 100</literal> will create 10,000,000 rows
        in the <structname>pgbench_accounts</structname> table. Default is 1.
        When the scale is 20,000 or larger, the columns used to
        hold account identifiers (<structfield>aid</structfield> columns)
        will switch to using larger integers (<type>bigint</type>),
        in order to be big enough to hold the range of account
        identifiers.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-&minus;foreign-keys</option></term>
      <listitem>
       <para>
        Create foreign key constraints between the standard tables.
        (This option adds the <literal>f</literal> step to the initialization
        step sequence, if it is not already present.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-&minus;index-tablespace=<replaceable>index_tablespace</replaceable></option></term>
      <listitem>
       <para>
        Create indexes in the specified tablespace, rather than the default
        tablespace.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-&minus;tablespace=<replaceable>tablespace</replaceable></option></term>
      <listitem>
       <para>
        Create tables in the specified tablespace, rather than the default
        tablespace.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-&minus;unlogged-tables</option></term>
      <listitem>
       <para>
        Create all tables as unlogged tables, rather than permanent tables.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    <application>pgbench</application>接受下列命令行初始化参数：

    <variablelist>

     <varlistentry>
      <term><option>-i</option></term>
      <term><option>--initialize</option></term>
      <listitem>
       <para>
        要求调用初始化模式。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-I <replaceable>init_steps</replaceable></option></term>
      <term><option>--init-steps=<replaceable>init_steps</replaceable></option></term>
      <listitem>
       <para>
        只执行选出的一组普通初始化步骤。<replaceable>init_steps</replaceable>指定要被执行的初始化步骤，每一个步骤使用一个字符代表。每一个步骤都以指定的顺序被调用。默认是<literal>dtgvp</literal>。可用的步骤是：

        <variablelist>
         <varlistentry>
          <term><literal>d</literal>（删除）</term>
          <listitem>
           <para>
            删除任何已有的<application>pgbench</application>表。
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term><literal>t</literal>（创建表）</term>
          <listitem>
           <para>
            创建标准<application>pgbench</application>场景使用的表，即<structname>pgbench_accounts</structname>、<structname>pgbench_branches</structname>、<structname>pgbench_history</structname>以及<structname>pgbench_tellers</structname>。
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term><literal>g</literal>（生成数据）</term>
          <listitem>
           <para>
            生成数据并且装入到标准的表中，替换掉已经存在的任何数据。
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term><literal>v</literal>（清理）</term>
          <listitem>
           <para>
            在标准的表上调用<command>VACUUM</command>。
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term><literal>p</literal>（创建主键）</term>
          <listitem>
           <para>
            在标准的表上创建主键索引。
           </para>
          </listitem>
         </varlistentry>
         <varlistentry>
         <term><literal>f</literal>（创建外键）</term>
          <listitem>
           <para>
            在标准的表之间创建外键约束（注意这一步默认不会被执行）。
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-F</option> <replaceable>fillfactor</replaceable></term>
      <term><option>--fillfactor=</option><replaceable>fillfactor</replaceable></term>
      <listitem>
       <para>
        用给定的填充因子创建表<structname>pgbench_accounts</structname>、<structname>pgbench_tellers</structname>以及<structname>pgbench_branches</structname>。默认是100。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-n</option></term>
      <term><option>--no-vacuum</option></term>
      <listitem>
       <para>
        在初始化期间不执行清理（这个选项会抑制<literal>v</literal>初始化步骤，即便在<option>-I</option>中指定了该步骤）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-q</option></term>
      <term><option>--quiet</option></term>
      <listitem>
       <para>
        把记录切换到安静模式，只是每 5 秒产生一个进度消息。默认的记录会每 100000 行打印一个消息，这经常会在每秒钟输出很多行（特别是在好的硬件上）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-s</option> <replaceable>scale_factor</replaceable></term>
      <term><option>--scale=</option><replaceable>scale_factor</replaceable></term>
      <listitem>
       <para>
        将生成的行数乘以比例因子。例如，<literal>-s 100</literal>将在<structname>pgbench_accounts</structname>表中创建 10,000,000 行。默认为 1。当比例为 20,000 或更高时，用来保存账号标识符的列（<structfield>aid</structfield>列）将切换到使用更大的整数（<type>bigint</type>），这样才能足以保存账号标识符。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--foreign-keys</option></term>
      <listitem>
       <para>
        在标准的表之间创建外键约束（如果<literal>f</literal>在初始化步骤序列中不存在，这个选项会把它加入）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--index-tablespace=<replaceable>index_tablespace</replaceable></option></term>
      <listitem>
       <para>
        在指定的表空间而不是默认表空间中创建索引。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--tablespace=<replaceable>tablespace</replaceable></option></term>
      <listitem>
       <para>
        在指定的表空间而不是默认表空间中创建表。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--unlogged-tables</option></term>
      <listitem>
       <para>
        把所有的表创建为非日志记录表而不是永久表。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

 </refsect2>

 <refsect2 id="pgbench-run-options">
<!--==========================orignal english content==========================
  <title>Benchmarking Options</title>
____________________________________________________________________________-->
  <title>基准选项</title>

<!--==========================orignal english content==========================
   <para>
    <application>pgbench</application> accepts the following command-line
    benchmarking arguments:

    <variablelist>
     <varlistentry>
      <term><option>-b</option> <replaceable>scriptname[@weight]</replaceable></term>
      <term><option>-&minus;builtin</option>=<replaceable>scriptname[@weight]</replaceable></term>
      <listitem>
       <para>
        Add the specified built-in script to the list of executed scripts.
        An optional integer weight after <literal>@</literal> allows to adjust the
        probability of drawing the script.  If not specified, it is set to 1.
        Available built-in scripts are: <literal>tpcb-like</literal>,
        <literal>simple-update</literal> and <literal>select-only</literal>.
        Unambiguous prefixes of built-in names are accepted.
        With special name <literal>list</literal>, show the list of built-in scripts
        and exit immediately.
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><option>-c</option> <replaceable>clients</replaceable></term>
      <term><option>-&minus;client=</option><replaceable>clients</replaceable></term>
      <listitem>
       <para>
        Number of clients simulated, that is, number of concurrent database
        sessions.  Default is 1.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-C</option></term>
      <term><option>-&minus;connect</option></term>
      <listitem>
       <para>
        Establish a new connection for each transaction, rather than
        doing it just once per client session.
        This is useful to measure the connection overhead.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-d</option></term>
      <term><option>-&minus;debug</option></term>
      <listitem>
       <para>
        Print debugging output.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-D</option> <replaceable>varname</replaceable><literal>=</literal><replaceable>value</replaceable></term>
      <term><option>-&minus;define=</option><replaceable>varname</replaceable><literal>=</literal><replaceable>value</replaceable></term>
      <listitem>
       <para>
        Define a variable for use by a custom script (see below).
        Multiple <option>-D</option> options are allowed.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-f</option> <replaceable>filename[@weight]</replaceable></term>
      <term><option>-&minus;file=</option><replaceable>filename[@weight]</replaceable></term>
      <listitem>
       <para>
        Add a transaction script read from <replaceable>filename</replaceable> to
        the list of executed scripts.
        An optional integer weight after <literal>@</literal> allows to adjust the
        probability of drawing the test.
        See below for details.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-j</option> <replaceable>threads</replaceable></term>
      <term><option>-&minus;jobs=</option><replaceable>threads</replaceable></term>
      <listitem>
       <para>
        Number of worker threads within <application>pgbench</application>.
        Using more than one thread can be helpful on multi-CPU machines.
        Clients are distributed as evenly as possible among available threads.
        Default is 1.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-l</option></term>
      <term><option>-&minus;log</option></term>
      <listitem>
       <para>
        Write information about each transaction to a log file.
        See below for details.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-L</option> <replaceable>limit</replaceable></term>
      <term><option>-&minus;latency-limit=</option><replaceable>limit</replaceable></term>
      <listitem>
       <para>
        Transactions that last more than <replaceable>limit</replaceable> milliseconds
        are counted and reported separately, as <firstterm>late</firstterm>.
       </para>
       <para>
        When throttling is used (<option>-&minus;rate=...</option>), transactions that
        lag behind schedule by more than <replaceable>limit</replaceable> ms, and thus
        have no hope of meeting the latency limit, are not sent to the server
        at all. They are counted and reported separately as
        <firstterm>skipped</firstterm>.
       </para>
       </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-M</option> <replaceable>querymode</replaceable></term>
      <term><option>-&minus;protocol=</option><replaceable>querymode</replaceable></term>
      <listitem>
       <para>
        Protocol to use for submitting queries to the server:
          <itemizedlist>
           <listitem>
            <para><literal>simple</literal>: use simple query protocol.</para>
           </listitem>
           <listitem>
            <para><literal>extended</literal>: use extended query protocol.</para>
           </listitem>
           <listitem>
            <para><literal>prepared</literal>: use extended query protocol with prepared statements.</para>
           </listitem>
          </itemizedlist>

        In the <literal>prepared</literal> mode, <application>pgbench</application>
        reuses the parse analysis result starting from the second query
        iteration, so <application>pgbench</application> runs faster
        than in other modes.
       </para>
       <para>
        The default is simple query protocol.  (See <xref linkend="protocol"/>
        for more information.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-n</option></term>
      <term><option>-&minus;no-vacuum</option></term>
      <listitem>
       <para>
        Perform no vacuuming before running the test.
        This option is <emphasis>necessary</emphasis>
        if you are running a custom test scenario that does not include
        the standard tables <structname>pgbench_accounts</structname>,
        <structname>pgbench_branches</structname>, <structname>pgbench_history</structname>, and
        <structname>pgbench_tellers</structname>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-N</option></term>
      <term><option>-&minus;skip-some-updates</option></term>
      <listitem>
       <para>
        Run built-in simple-update script.
        Shorthand for <option>-b simple-update</option>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-P</option> <replaceable>sec</replaceable></term>
      <term><option>-&minus;progress=</option><replaceable>sec</replaceable></term>
      <listitem>
       <para>
        Show progress report every <replaceable>sec</replaceable> seconds.  The report
        includes the time since the beginning of the run, the TPS since the
        last report, and the transaction latency average and standard
        deviation since the last report.  Under throttling (<option>-R</option>),
        the latency is computed with respect to the transaction scheduled
        start time, not the actual transaction beginning time, thus it also
        includes the average schedule lag time.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-r</option></term>
      <term><option>-&minus;report-latencies</option></term>
      <listitem>
       <para>
        Report the average per-statement latency (execution time from the
        perspective of the client) of each command after the benchmark
        finishes.  See below for details.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-R</option> <replaceable>rate</replaceable></term>
      <term><option>-&minus;rate=</option><replaceable>rate</replaceable></term>
      <listitem>
       <para>
        Execute transactions targeting the specified rate instead of running
        as fast as possible (the default).  The rate is given in transactions
        per second.  If the targeted rate is above the maximum possible rate,
        the rate limit won't impact the results.
       </para>
       <para>
        The rate is targeted by starting transactions along a
        Poisson-distributed schedule time line.  The expected start time
        schedule moves forward based on when the client first started, not
        when the previous transaction ended.  That approach means that when
        transactions go past their original scheduled end time, it is
        possible for later ones to catch up again.
       </para>
       <para>
        When throttling is active, the transaction latency reported at the
        end of the run is calculated from the scheduled start times, so it
        includes the time each transaction had to wait for the previous
        transaction to finish. The wait time is called the schedule lag time,
        and its average and maximum are also reported separately. The
        transaction latency with respect to the actual transaction start time,
        i.e. the time spent executing the transaction in the database, can be
        computed by subtracting the schedule lag time from the reported
        latency.
       </para>

       <para>
        If <option>-&minus;latency-limit</option> is used together with <option>-&minus;rate</option>,
        a transaction can lag behind so much that it is already over the
        latency limit when the previous transaction ends, because the latency
        is calculated from the scheduled start time. Such transactions are
        not sent to the server, but are skipped altogether and counted
        separately.
       </para>

       <para>
        A high schedule lag time is an indication that the system cannot
        process transactions at the specified rate, with the chosen number of
        clients and threads. When the average transaction execution time is
        longer than the scheduled interval between each transaction, each
        successive transaction will fall further behind, and the schedule lag
        time will keep increasing the longer the test run is. When that
        happens, you will have to reduce the specified transaction rate.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-s</option> <replaceable>scale_factor</replaceable></term>
      <term><option>-&minus;scale=</option><replaceable>scale_factor</replaceable></term>
      <listitem>
       <para>
        Report the specified scale factor in <application>pgbench</application>'s
        output.  With the built-in tests, this is not necessary; the
        correct scale factor will be detected by counting the number of
        rows in the <structname>pgbench_branches</structname> table.
        However, when testing only custom benchmarks (<option>-f</option> option),
        the scale factor will be reported as 1 unless this option is used.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-S</option></term>
      <term><option>-&minus;select-only</option></term>
      <listitem>
       <para>
        Run built-in select-only script.
        Shorthand for <option>-b select-only</option>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-t</option> <replaceable>transactions</replaceable></term>
      <term><option>-&minus;transactions=</option><replaceable>transactions</replaceable></term>
      <listitem>
       <para>
        Number of transactions each client runs.  Default is 10.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-T</option> <replaceable>seconds</replaceable></term>
      <term><option>-&minus;time=</option><replaceable>seconds</replaceable></term>
      <listitem>
       <para>
        Run the test for this many seconds, rather than a fixed number of
        transactions per client. <option>-t</option> and
        <option>-T</option> are mutually exclusive.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-v</option></term>
      <term><option>-&minus;vacuum-all</option></term>
      <listitem>
       <para>
        Vacuum all four standard tables before running the test.
        With neither <option>-n</option> nor <option>-v</option>, <application>pgbench</application> will vacuum the
        <structname>pgbench_tellers</structname> and <structname>pgbench_branches</structname>
        tables, and will truncate <structname>pgbench_history</structname>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-&minus;aggregate-interval=<replaceable>seconds</replaceable></option></term>
      <listitem>
       <para>
        Length of aggregation interval (in seconds).  May be used only
        with <option>-l</option> option.  With this option, the log contains
        per-interval summary data, as described below.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-&minus;log-prefix=<replaceable>prefix</replaceable></option></term>
      <listitem>
       <para>
        Set the filename prefix for the log files created by
        <option>-&minus;log</option>.  The default is <literal>pgbench_log</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-&minus;progress-timestamp</option></term>
      <listitem>
       <para>
        When showing progress (option <option>-P</option>), use a timestamp
        (Unix epoch) instead of the number of seconds since the
        beginning of the run.  The unit is in seconds, with millisecond
        precision after the dot.
        This helps compare logs generated by various tools.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-&minus;random-seed=</option><replaceable>SEED</replaceable></term>
      <listitem>
       <para>
        Set random generator seed.  Seeds the system random number generator,
        which then produces a sequence of initial generator states, one for
        each thread.
        Values for <replaceable>SEED</replaceable> may be:
        <literal>time</literal> (the default, the seed is based on the current time),
        <literal>rand</literal> (use a strong random source, failing if none
        is available), or an unsigned decimal integer value.
        The random generator is invoked explicitly from a pgbench script
        (<literal>random...</literal> functions) or implicitly (for instance option
        <option>-&minus;rate</option> uses it to schedule transactions).
        When explicitly set, the value used for seeding is shown on the terminal.
        Any value allowed for <replaceable>SEED</replaceable> may also be
        provided through the environment variable
        <literal>PGBENCH_RANDOM_SEED</literal>.
        To ensure that the provided seed impacts all possible uses, put this option
        first or use the environment variable.
      </para>
      <para>
        Setting the seed explicitly allows to reproduce a <command>pgbench</command>
        run exactly, as far as random numbers are concerned.
        As the random state is managed per thread, this means the exact same
        <command>pgbench</command> run for an identical invocation if there is one
        client per thread and there are no external or data dependencies.
        From a statistical viewpoint reproducing runs exactly is a bad idea because
        it can hide the performance variability or improve performance unduly,
        e.g. by hitting the same pages as a previous run.
        However, it may also be of great help for debugging, for instance
        re-running a tricky case which leads to an error.
        Use wisely.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-&minus;sampling-rate=<replaceable>rate</replaceable></option></term>
      <listitem>
       <para>
        Sampling rate, used when writing data into the log, to reduce the
        amount of log generated. If this option is given, only the specified
        fraction of transactions are logged. 1.0 means all transactions will
        be logged, 0.05 means only 5% of the transactions will be logged.
       </para>
       <para>
        Remember to take the sampling rate into account when processing the
        log file. For example, when computing TPS values, you need to multiply
        the numbers accordingly (e.g. with 0.01 sample rate, you'll only get
        1/100 of the actual TPS).
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    <application>pgbench</application>接受下列命令行基准参数：

    <variablelist>
     <varlistentry>
      <term><option>-b</option> <replaceable>scriptname[@weight]</replaceable></term>
      <term><option>--builtin</option>=<replaceable>scriptname[@weight]</replaceable></term>
      <listitem>
       <para>
        把指定的内建脚本加入到要执行的脚本列表中。<literal>@</literal>之后是一个可选的整数权重，它允许调节抽取该脚本的可能性。如果没有指定，它会被设置为 1。可用的内建脚本有：<literal>tpcb-like</literal>、<literal>simple-update</literal>和<literal>select-only</literal>。这里也接受内建名称无歧义的前缀缩写。如果用上特殊的名字<literal>list</literal>，将会显示内建脚本的列表并且立刻退出。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-c</option> <replaceable>clients</replaceable></term>
      <term><option>--client=</option><replaceable>clients</replaceable></term>
      <listitem>
       <para>
        模拟的客户端数量，也就是并发数据库会话数量。默认为 1。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-C</option></term>
      <term><option>--connect</option></term>
      <listitem>
       <para>
        为每一个事务建立一个新连接，而不是只为每个客户端会话建立一个连接。这对于度量连接开销有用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-d</option></term>
      <term><option>--debug</option></term>
      <listitem>
       <para>
        打印调试输出。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-D</option> <replaceable>varname</replaceable><literal>=</literal><replaceable>value</replaceable></term>
      <term><option>--define=</option><replaceable>varname</replaceable><literal>=</literal><replaceable>value</replaceable></term>
      <listitem>
       <para>
        定义一个由自定义脚本（见下文）使用的变量。允许多个<option>-D</option>选项。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-f</option> <replaceable>filename[@weight]</replaceable></term>
      <term><option>--file=</option><replaceable>filename[@weight]</replaceable></term>
      <listitem>
       <para>
        把一个从<replaceable>filename</replaceable>读到的事务脚本加入到被执行的脚本列表中。<literal>@</literal>后面是一个可选的整数权重，它允许调节抽取该测试的可能性。详见下文。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-j</option> <replaceable>threads</replaceable></term>
      <term><option>--jobs=</option><replaceable>threads</replaceable></term>
      <listitem>
       <para>
        <application>pgbench</application>中的工作者线程数量。在多 CPU 机器上使用多于一个线程会有用。客户端会尽可能均匀地分布到可用的线程上。默认为 1。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-l</option></term>
      <term><option>--log</option></term>
      <listitem>
       <para>
        把与每一个事务相关的信息写到一个日志文件中。详见下文。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-L</option> <replaceable>limit</replaceable></term>
      <term><option>--latency-limit=</option><replaceable>limit</replaceable></term>
      <listitem>
       <para>
        对持续超过<replaceable>limit</replaceable>毫秒的事务进行独立的计数和报告，
        这些事务被认为是<firstterm>迟到（late）</firstterm>了的事务。
       </para>
       <para>
        在使用限流措施时（<option>--rate=...</option>），滞后于计划超过
        <replaceable>limit</replaceable>毫秒并且因此没有希望满足延迟限制的事务根本
        不会被发送给服务器。这些事务被认为是<firstterm>被跳过（skipped）</firstterm>
        的事务，它们会被单独计数并且报告。
       </para>
       </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-M</option> <replaceable>querymode</replaceable></term>
      <term><option>--protocol=</option><replaceable>querymode</replaceable></term>
      <listitem>
       <para>
        要用来提交查询到服务器的协议：
          <itemizedlist>
           <listitem>
            <para><literal>simple</literal>：使用简单查询协议。</para>
           </listitem>
           <listitem>
            <para><literal>extended</literal>使用扩展查询协议。</para>
           </listitem>
           <listitem>
            <para><literal>prepared</literal>：使用带预备语句的扩展查询语句。</para>
           </listitem>
          </itemizedlist>

        在<literal>prepared</literal>模式中，<application>pgbench</application>重用从第二次查询迭代开始的语法分析结果，因此<application>pgbench</application>运行速度比其他模式快。
       </para>
       <para>
        默认是简单查询协议（详见<xref linkend="protocol"/>）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-n</option></term>
      <term><option>--no-vacuum</option></term>
      <listitem>
       <para>
        在运行测试前不进行清理。如果你在运行一个不包括标准的表<structname>pgbench_accounts</structname>、
        <structname>pgbench_branches</structname>、<structname>pgbench_history</structname>和
        <structname>pgbench_tellers</structname>的自定义测试场景时，这个选项是<emphasis>必需的</emphasis>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-N</option></term>
      <term><option>--skip-some-updates</option></term>
      <listitem>
       <para>
        运行内建的简单更新脚本。这是<option>-b simple-update</option>的简写。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-P</option> <replaceable>sec</replaceable></term>
      <term><option>--progress=</option><replaceable>sec</replaceable></term>
      <listitem>
       <para>
        每<replaceable>sec</replaceable>秒显示进度报告。该报告包括运行了多长时间、从上次报告以来的 tps 以及从上次报告以来事务延迟的平均值和标准偏差。如果低于限流值（<option>-R</option>），延迟会相对于事务预定的开始时间（而不是实际的事务开始时间）计算，因此其中也包括了平均调度延迟时间。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-r</option></term>
      <term><option>--report-latencies</option></term>
      <listitem>
       <para>
        在基准结束后，报告平均的每个命令的每语句等待时间（从客户端的角度来说是执行时间）。详见下文。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-R</option> <replaceable>rate</replaceable></term>
      <term><option>--rate=</option><replaceable>rate</replaceable></term>
      <listitem>
       <para>
        按照指定的速率执行事务而不是尽可能快地执行（默认行为）。该速率
        以 tps（每秒事务数）形式给定。如果目标速率高于最大可能速率，则
        该速率限制不会影响结果。
       </para>
       <para>
        该速率的目标是按照一条泊松分布的调度时间线开始事务。期望的开始
        时间表会基于客户端第一次开始的时间（而不是上一个事务结束的时
        间）前移。这种方法意味着当事务超过它们的原定结束时间时，更迟的
        那些有机会再次追赶上来。
       </para>
       <para>
        当限流措施被激活时，运行结束时报告的事务延迟是从预订的开始时间计
        算而来的，因此它包括每一个事务不得不等待前一个事务结束所花的时
        间。该等待时间被称作调度延迟时间，并且它的平均值和最大值也会被
        单独报告。关于实际事务开始时间的事务延迟（即在数据库中执行事务
        所花的时间）可以用报告的延迟减去调度延迟时间计算得到。
       </para>

       <para>
        如果把<option>--latency-limit</option>和<option>--rate</option>一起使用，
        当一个事务在前一个事务结束时已经超过了延迟限制时，它可能会滞后
        非常多，因为延迟是从计划的开始时间计算得来。这类事务不会被发送
        给服务器，而是一起被跳过并且被单独计数。
       </para>

       <para>
        一个高的调度延迟时间表示系统无法用选定的客户端和线程数按照指定
        的速率处理事务。当平均的事务执行时间超过每个事务之间的调度间隔
        时，每一个后续事务将会落后更多，并且随着测试运行时间越长，调度
        延迟时间将持续增加。发生这种情况时，你将不得不降低指定的事务速率。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-s</option> <replaceable>scale_factor</replaceable></term>
      <term><option>--scale=</option><replaceable>scale_factor</replaceable></term>
      <listitem>
       <para>
        在<application>pgbench</application>的输出中报告指定的比例因子。对于内建测试，这并非必需；正确的比例因子将通过对<structname>pgbench_branches</structname>表中的行计数来检测。不过，当只测试自定义基准（<option>-f</option>选项）时，比例因子将被报告为 1（除非使用了这个选项）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-S</option></term>
      <term><option>--select-only</option></term>
      <listitem>
       <para>
        执行内建的只有选择的脚本。是<option>-b select-only</option>简写形式。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-t</option> <replaceable>transactions</replaceable></term>
      <term><option>--transactions=</option><replaceable>transactions</replaceable></term>
      <listitem>
       <para>
        每个客户端运行的事务数量。默认为 10。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-T</option> <replaceable>seconds</replaceable></term>
      <term><option>--time=</option><replaceable>seconds</replaceable></term>
      <listitem>
       <para>
        运行测试这么多秒，而不是为每个客户端运行固定数量的事务。<option>-t</option>和<option>-T</option>是互斥的。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-v</option></term>
      <term><option>--vacuum-all</option></term>
      <listitem>
       <para>
        在运行测试前清理所有四个标准的表。在没有用<option>-n</option>以及<option>-v</option>时，
        <application>pgbench</application>将清理<structname>pgbench_tellers</structname>
        和<structname>pgbench_branches</structname>表，并且截断<structname>pgbench_history</structname>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--aggregate-interval=<replaceable>seconds</replaceable></option></term>
      <listitem>
       <para>
        聚集区间的长度（单位是秒）。仅可以与<option>-l</option>选项一起使用。通过这个选项，日志会包含针对每个区间的概要数据，如下文所述。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--log-prefix=<replaceable>prefix</replaceable></option></term>
      <listitem>
       <para>
        设置<option>--log</option>创建的日志文件的文件名前缀。默认是<literal>pgbench_log</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--progress-timestamp</option></term>
      <listitem>
       <para>
        当显示进度（选项<option>-P</option>）时，使用一个时间戳（Unix 时间）取代从运行开始的秒数。单位是秒，在小数点后是毫秒精度。这可以有助于比较多种工具生成的日志。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--random-seed=</option><replaceable>SEED</replaceable></term>
      <listitem>
       <para>
        设置随机数生成器种子。为系统的随机数生成器提供种子，然后随机数生成器会产生一个初始生成器状态序列，每一个线程一个状态。<replaceable>SEED</replaceable>的值可以是：<literal>time</literal>（默认值，种子基于当前时间）、<literal>rand</literal>（使用一种强随机源，如果没有可用的源则失败）或者一个无符号十进制整数值。一个pgbench脚本中会显式（<literal>random...</literal>函数）地或者隐式地（如<option>--rate</option>使用随机数生成器调度事务）调用随机数生成器。在被明确设置时，用作种子的值会显示在终端上。
        还可以通过环境变量<literal>PGBENCH_RANDOM_SEED</literal>提供用于<replaceable>SEED</replaceable>的值。为了确保所提供的种子影响所有可能的使用，把这个选项放在第一位或者使用环境变量。
      </para>
      <para>
        明确地设置种子允许准确地再生一个<command>pgbench</command>运行，对随机数而言。因为随机状态是针对每个线程管理，这意味着如果每一个线程有一个客户端并且没有外部或者数据依赖，则对于一个相同的调用就会有完全相同的<command>pgbench</command>运行。从一种统计的角度来看，再生运行不是什么好主意，因为它能隐藏性能可变性或者不正当地改进性能，即通过命中前一次运行的相同页面来改进性能。不过，它也可以对调试起到很大帮助作用，例如重新运行一种导致错误的棘手用例。请善用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--sampling-rate=<replaceable>rate</replaceable></option></term>
      <listitem>
       <para>
        采样率，在写入数据到日志时被用来减少日志产生的数量。如果给出这个选项，只有指定比例的事务被记录。1.0 表示所有事务都将被记录，0.05 表示只有 5% 的事务会被记录。
       </para>
       <para>
        在处理日志文件时，记得要考虑这个采样率。例如，当计算TPS值时，你需要相应地乘以这个数字（例如，采样率是 0.01，你将只能得到实际TPS的 1/100）。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

 </refsect2>

 <refsect2 id="pgbench-common-options">
<!--==========================orignal english content==========================
  <title>Common Options</title>
____________________________________________________________________________-->
  <title>普通选项</title>

<!--==========================orignal english content==========================
   <para>
    <application>pgbench</application> accepts the following command-line
    common arguments:

    <variablelist>

     <varlistentry>
      <term><option>-h</option> <replaceable>hostname</replaceable></term>
      <term><option>-&minus;host=</option><replaceable>hostname</replaceable></term>
      <listitem>
       <para>
        The database server's host name
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-p</option> <replaceable>port</replaceable></term>
      <term><option>-&minus;port=</option><replaceable>port</replaceable></term>
      <listitem>
       <para>
        The database server's port number
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-U</option> <replaceable>login</replaceable></term>
      <term><option>-&minus;username=</option><replaceable>login</replaceable></term>
      <listitem>
       <para>
        The user name to connect as
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-V</option></term>
      <term><option>-&minus;version</option></term>
      <listitem>
       <para>
        Print the <application>pgbench</application> version and exit.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-?</option></term>
      <term><option>-&minus;help</option></term>
      <listitem>
       <para>
        Show help about <application>pgbench</application> command line
        arguments, and exit.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    <application>pgbench</application>接受下列命令行普通参数：

    <variablelist>

     <varlistentry>
      <term><option>-h</option> <replaceable>hostname</replaceable></term>
      <term><option>--host=</option><replaceable>hostname</replaceable></term>
      <listitem>
       <para>
        数据库服务器的主机名
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-p</option> <replaceable>port</replaceable></term>
      <term><option>--port=</option><replaceable>port</replaceable></term>
      <listitem>
       <para>
        数据库服务器的端口号
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-U</option> <replaceable>login</replaceable></term>
      <term><option>--username=</option><replaceable>login</replaceable></term>
      <listitem>
       <para>
        要作为哪个用户连接
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-V</option></term>
      <term><option>--version</option></term>
      <listitem>
       <para>
        打印<application>pgbench</application>版本并退出。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-?</option></term>
      <term><option>--help</option></term>
      <listitem>
       <para>
        显示有关<application>pgbench</application>命令行参数的信息，并且退出。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

 </refsect2>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Exit Status</title>
____________________________________________________________________________-->
  <title>Exit Status</title>

<!--==========================orignal english content==========================
  <para>
   A successful run will exit with status 0.  Exit status 1 indicates static
   problems such as invalid command-line options.  Errors during the run such
   as database errors or problems in the script will result in exit status 2.
   In the latter case, <application>pgbench</application> will print partial
   results.
  </para>
____________________________________________________________________________-->
  <para>
   成功运行将以状态0退出。 退出状态为1表示静态问题，如无效的命令行选项。
   运行过程中的错误，例如数据库错误或脚本中的问题将导致退出状态为2。
   在后一种情况下，<application>pgbench</application>将打印部分结果。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Notes</title>
____________________________________________________________________________-->
  <title>注解</title>

 <refsect2>
<!--==========================orignal english content==========================
  <title>What Is the <quote>Transaction</quote> Actually Performed in <application>pgbench</application>?</title>
____________________________________________________________________________-->
  <title>在<application>pgbench</application>中实际执行的<quote>事务</quote>是什么？</title>

<!--==========================orignal english content==========================
  <para>
   <application>pgbench</application> executes test scripts chosen randomly
   from a specified list.
   They include built-in scripts with <option>-b</option> and
   user-provided custom scripts with <option>-f</option>.
   Each script may be given a relative weight specified after a
   <literal>@</literal> so as to change its drawing probability.
   The default weight is <literal>1</literal>.
   Scripts with a weight of <literal>0</literal> are ignored.
 </para>
____________________________________________________________________________-->
  <para>
   <application>pgbench</application>执行从指定列表中随机选中的测试脚本。它们包括带有<option>-b</option>的内建脚本和带有<option>-f</option>的用户提供的自定义脚本。每一个脚本可以在其后用<literal>@</literal>指定一个相对权重，这样可以更改该脚本的抽取概率。默认权重是<literal>1</literal>。权重为<literal>0</literal>的脚本会被忽略。
 </para>

<!--==========================orignal english content==========================
  <para>
   The default built-in transaction script (also invoked with <option>-b tpcb-like</option>)
   issues seven commands per transaction over randomly chosen <literal>aid</literal>,
   <literal>tid</literal>, <literal>bid</literal> and <literal>delta</literal>.
   The scenario is inspired by the TPC-B benchmark, but is not actually TPC-B,
   hence the name.
  </para>
____________________________________________________________________________-->
  <para>
   默认的内建事务脚本（也会被<option>-b tpcb-like</option>调用）会在每个事务上发出七个从<literal>aid</literal>、<literal>tid</literal>、<literal>bid</literal>和<literal>delta</literal>中随机选择的命令。该场景来自于 TPC-B 基准，但并不是真正的 TPC-B，只是名字像而已。
  </para>

  <orderedlist>
   <listitem><!--==========================orignal english content==========================
<para><literal>BEGIN;</literal></para>
____________________________________________________________________________-->
<!--==========================orignal english content==========================
<para><literal>BEGIN;</literal></para>
____________________________________________________________________________-->
<para><literal>BEGIN;</literal></para></listitem>
   <listitem><!--==========================orignal english content==========================
<para><literal>UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;</literal></para>
____________________________________________________________________________-->
<!--==========================orignal english content==========================
<para><literal>UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;</literal></para>
____________________________________________________________________________-->
<para><literal>UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;</literal></para></listitem>
   <listitem><!--==========================orignal english content==========================
<para><literal>SELECT abalance FROM pgbench_accounts WHERE aid = :aid;</literal></para>
____________________________________________________________________________-->
<!--==========================orignal english content==========================
<para><literal>SELECT abalance FROM pgbench_accounts WHERE aid = :aid;</literal></para>
____________________________________________________________________________-->
<para><literal>SELECT abalance FROM pgbench_accounts WHERE aid = :aid;</literal></para></listitem>
   <listitem><!--==========================orignal english content==========================
<para><literal>UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;</literal></para>
____________________________________________________________________________-->
<!--==========================orignal english content==========================
<para><literal>UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;</literal></para>
____________________________________________________________________________-->
<para><literal>UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;</literal></para></listitem>
   <listitem><!--==========================orignal english content==========================
<para><literal>UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;</literal></para>
____________________________________________________________________________-->
<!--==========================orignal english content==========================
<para><literal>UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;</literal></para>
____________________________________________________________________________-->
<para><literal>UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;</literal></para></listitem>
   <listitem><!--==========================orignal english content==========================
<para><literal>INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);</literal></para>
____________________________________________________________________________-->
<!--==========================orignal english content==========================
<para><literal>INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);</literal></para>
____________________________________________________________________________-->
<para><literal>INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);</literal></para></listitem>
   <listitem><!--==========================orignal english content==========================
<para><literal>END;</literal></para>
____________________________________________________________________________-->
<!--==========================orignal english content==========================
<para><literal>END;</literal></para>
____________________________________________________________________________-->
<para><literal>END;</literal></para></listitem>
  </orderedlist>

<!--==========================orignal english content==========================
  <para>
   If you select the <literal>simple-update</literal> built-in (also <option>-N</option>),
   steps 4 and 5 aren't included in the transaction.
   This will avoid update contention on these tables, but
   it makes the test case even less like TPC-B.
  </para>
____________________________________________________________________________-->
  <para>
   如果选择<literal>simple-update</literal>内建脚本（还有<option>-N</option>），第 4 和 5 步不会被包括在事务中。这将避免更新那些表中的内容，但是它会让该测试用例更不像 TPC-B。
  </para>

<!--==========================orignal english content==========================
  <para>
   If you select the <literal>select-only</literal> built-in (also <option>-S</option>),
   only the <command>SELECT</command> is issued.
  </para>
____________________________________________________________________________-->
  <para>
   如果选择<literal>select-only</literal>内建脚本（还有<option>-S</option>），只会发出<command>SELECT</command>。
  </para>
 </refsect2>

 <refsect2>
<!--==========================orignal english content==========================
  <title>Custom Scripts</title>
____________________________________________________________________________-->
  <title>自定义脚本</title>

<!--==========================orignal english content==========================
  <para>
   <application>pgbench</application> has support for running custom
   benchmark scenarios by replacing the default transaction script
   (described above) with a transaction script read from a file
   (<option>-f</option> option).  In this case a <quote>transaction</quote>
   counts as one execution of a script file.
  </para>
____________________________________________________________________________-->
  <para>
   <application>pgbench</application>支持通过从一个文件中（<option>-f</option>选项）读取事务脚本替换默认的事务脚本（如上文所述）来运行自定义的基准场景。在这种情况中，一个<quote>事务</quote>就是一个脚本文件的一次执行。
  </para>

<!--==========================orignal english content==========================
  <para>
   A script file contains one or more SQL commands terminated by
   semicolons.  Empty lines and lines beginning with
   <literal>-&minus;</literal> are ignored.  Script files can also contain
   <quote>meta commands</quote>, which are interpreted by <application>pgbench</application>
   itself, as described below.
  </para>
____________________________________________________________________________-->
  <para>
   脚本文件包含一个或者多个被分号终结的 SQL 命令。空行以及以<literal>--</literal>开始的行会被忽略。脚本文件也可以包含<quote>元命令</quote>，它会由<application>pgbench</application>自身解释，详见下文。
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    Before <productname>PostgreSQL</productname> 9.6, SQL commands in script files
    were terminated by newlines, and so they could not be continued across
    lines.  Now a semicolon is <emphasis>required</emphasis> to separate consecutive
    SQL commands (though a SQL command does not need one if it is followed
    by a meta command).  If you need to create a script file that works with
    both old and new versions of <application>pgbench</application>, be sure to write
    each SQL command on a single line ending with a semicolon.
   </para>
____________________________________________________________________________-->
   <para>
    在<productname>PostgreSQL</productname> 9.6 之前，脚本文件中的 SQL 命令被新行终结，因此命令不能跨行。现在<emphasis>需要</emphasis>分号来分隔连续的 SQL 命令（如果 SQL 命令后面跟着一个元命令则不需要一个分号）。如果需要创建一个能在新旧版本<application>pgbench</application>下工作的脚本文件，要确保把每个 SQL 命令写在一个由分号终结的行中。
   </para>
  </note>

<!--==========================orignal english content==========================
  <para>
   There is a simple variable-substitution facility for script files.
   Variable names must consist of letters (including non-Latin letters),
   digits, and underscores.
   Variables can be set by the command-line <option>-D</option> option,
   explained above, or by the meta commands explained below.
   In addition to any variables preset by <option>-D</option> command-line options,
   there are a few variables that are preset automatically, listed in
   <xref linkend="pgbench-automatic-variables"/>. A value specified for these
   variables using <option>-D</option> takes precedence over the automatic presets.
   Once set, a variable's
   value can be inserted into a SQL command by writing
   <literal>:</literal><replaceable>variablename</replaceable>.  When running more than
   one client session, each session has its own set of variables.
   <application>pgbench</application> supports up to 255 variable uses in one
   statement.
  </para>
____________________________________________________________________________-->
  <para>
   对脚本文件有一种简单的变量替换功能。变量名必须由字母（包括非拉丁字母）、数字以及下划线构成。如上所述，变量可以用命令行的
   <option>-D</option>选项设置，或者按下文所说的使用元命令设置。
   除了用<option>-D</option>命令行选项预先设置的任何变量之外，
   还有一些被自动预先设置的变量，它们被列在
   <xref linkend="pgbench-automatic-variables"/>中。一个用<option>-D</option>
   为这些变量值指定的值会优先于自动的预设值。
   一旦被设置，可以在 SQL 命令中写<literal>:</literal><replaceable>variablename</replaceable>
   来插入一个变量的值。当运行多于一个客户端会话时，每一个会话拥有它自己的变量集合。
   <application>pgbench</application>在一个语句中支持使用多达255个变量。
   </para>
  
  <table id="pgbench-automatic-variables">
<!--==========================orignal english content==========================
    <title>Automatic Variables</title>
____________________________________________________________________________-->
    <title>自动变量</title>
    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Variable</entry>
       <entry>Description</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>变量</entry>
       <entry>简介</entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry> <literal>client_id</literal> </entry>
       <entry>unique number identifying the client session (starts from zero)</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry> <literal>client_id</literal> </entry>
       <entry>标识客户端会话的唯一编号（从零开始）</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry> <literal>default_seed</literal> </entry>
       <entry>seed used in hash functions by default</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry> <literal>default_seed</literal> </entry>
       <entry>默认在哈希函数中使用的种子</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry> <literal>random_seed</literal> </entry>
       <entry>random generator seed (unless overwritten with <option>-D</option>)</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry> <literal>random_seed</literal> </entry>
       <entry>随机数生成器种子（除非用<option>-D</option>重载）</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry> <literal>scale</literal> </entry>
       <entry>current scale factor</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry> <literal>scale</literal> </entry>
       <entry>当前的缩放因子</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
   Script file meta commands begin with a backslash (<literal>\</literal>) and
   normally extend to the end of the line, although they can be continued
   to additional lines by writing backslash-return.
   Arguments to a meta command are separated by white space.
   These meta commands are supported:
  </para>
____________________________________________________________________________-->
  <para>
   脚本文件元命令以反斜线（<literal>\</literal>）开始并且通常延伸到行的末尾，不过它们也能够通过写一个反斜线回车继续到额外行。一个元命令和它的参数用空白分隔。支持的元命令是：
  </para>

  <variablelist>
   <varlistentry id='pgbench-metacommand-gset'>
<!--==========================orignal english content==========================
    <term>
     <literal>\gset [<replaceable>prefix</replaceable>]</literal>
    </term>
____________________________________________________________________________-->
    <term>
     <literal>\gset [<replaceable>prefix</replaceable>]</literal>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      This command may be used to end SQL queries, taking the place of the
      terminating semicolon (<literal>;</literal>).
     </para>
____________________________________________________________________________-->
     <para>
      此命令可以用于结束 SQL 查询，代替终止分号 (<literal>;</literal>)。
     </para>

<!--==========================orignal english content==========================
     <para>
      When this command is used, the preceding SQL query is expected to
      return one row, the columns of which are stored into variables named after
      column names, and prefixed with <replaceable>prefix</replaceable> if provided.
     </para>
____________________________________________________________________________-->
     <para>
      当使用此命令时，前面的 SQL 查询预期返回一行，存储变量名的列在列名后面，如果已经提供的话，则以<replaceable>prefix</replaceable>作为前缀。
     </para>

<!--==========================orignal english content==========================
     <para>
      The following example puts the final account balance from the first query
      into variable <replaceable>abalance</replaceable>, and fills variables
      <replaceable>p_two</replaceable> and <replaceable>p_three</replaceable>
      with integers from the third query.
      The result of the second query is discarded.
<programlisting>
UPDATE pgbench_accounts
  SET abalance = abalance + :delta
  WHERE aid = :aid
  RETURNING abalance \gset
-&minus; compound of two queries
SELECT 1 \;
SELECT 2 AS two, 3 AS three \gset p_
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      下面的示例将第一个查询中的最终帐户余额放入变量<replaceable>abalance</replaceable>，
      并且用第三个查询中的整数填充变量<replaceable>p_two</replaceable>和<replaceable>p_three</replaceable>。
      第二个查询的结果将被丢弃。
<programlisting>
UPDATE pgbench_accounts
  SET abalance = abalance + :delta
  WHERE aid = :aid
  RETURNING abalance \gset
-- compound of two queries
SELECT 1 \;
SELECT 2 AS two, 3 AS three \gset p_
</programlisting>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>\if</literal> <replaceable class="parameter">expression</replaceable></term>
____________________________________________________________________________-->
    <term><literal>\if</literal> <replaceable class="parameter">expression</replaceable></term>
<!--==========================orignal english content==========================
    <term><literal>\elif</literal> <replaceable class="parameter">expression</replaceable></term>
____________________________________________________________________________-->
    <term><literal>\elif</literal> <replaceable class="parameter">expression</replaceable></term>
<!--==========================orignal english content==========================
    <term><literal>\else</literal></term>
____________________________________________________________________________-->
    <term><literal>\else</literal></term>
<!--==========================orignal english content==========================
    <term><literal>\endif</literal></term>
____________________________________________________________________________-->
    <term><literal>\endif</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      This group of commands implements nestable conditional blocks,
      similarly to <literal>psql</literal>'s <xref linkend="psql-metacommand-if"/>.
      Conditional expressions are identical to those with <literal>\set</literal>,
      with non-zero values interpreted as true.
     </para>
____________________________________________________________________________-->
     <para>
      这一组命令实现了可嵌套的条件块，类似于<literal>psql</literal>的<xref linkend="psql-metacommand-if"/>。条件表达式与<literal>\set</literal>的相同，非零值会被解释为真。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id='pgbench-metacommand-set'>
<!--==========================orignal english content==========================
    <term>
     <literal>\set <replaceable>varname</replaceable> <replaceable>expression</replaceable></literal>
    </term>
____________________________________________________________________________-->
    <term>
     <literal>\set <replaceable>varname</replaceable> <replaceable>expression</replaceable></literal>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Sets variable <replaceable>varname</replaceable> to a value calculated
      from <replaceable>expression</replaceable>.
      The expression may contain the <literal>NULL</literal> constant,
      Boolean constants <literal>TRUE</literal> and <literal>FALSE</literal>,
      integer constants such as <literal>5432</literal>,
      double constants such as <literal>3.14159</literal>,
      references to variables <literal>:</literal><replaceable>variablename</replaceable>,
      <link linkend="pgbench-builtin-operators">operators</link>
      with their usual SQL precedence and associativity,
      <link linkend="pgbench-builtin-functions">function calls</link>,
      SQL <link linkend="functions-case"><token>CASE</token> generic conditional
      expressions</link> and parentheses.
     </para>
____________________________________________________________________________-->
     <para>
      设置变量<replaceable>varname</replaceable>为一个从<replaceable>expression</replaceable>计算出的值。该表达式可以包含<literal>NULL</literal>常量、布尔常量<literal>TRUE</literal>和<literal>FALSE</literal>、<literal>5432</literal>这样的整数常量、<literal>3.14159</literal>这样的double常量、对变量的引用<literal>:</literal><replaceable>variablename</replaceable>、
      <link linkend="pgbench-builtin-operators">操作符</link>（保持它们通常的SQL优先级和结合性）、<link linkend="pgbench-builtin-functions">函数调用</link>、
      SQL <link linkend="functions-case"><token>CASE</token>一般条件表达式</link>以及括号。
     </para>

<!--==========================orignal english content==========================
     <para>
      Functions and most operators return <literal>NULL</literal> on
      <literal>NULL</literal> input.
     </para>
____________________________________________________________________________-->
     <para>
      函数和大部分操作符在<literal>NULL</literal>输入上会返回<literal>NULL</literal>。
     </para>

<!--==========================orignal english content==========================
     <para>
      For conditional purposes, non zero numerical values are
      <literal>TRUE</literal>, zero numerical values and <literal>NULL</literal>
      are <literal>FALSE</literal>.
     </para>
____________________________________________________________________________-->
     <para>
      对于条件目的，非零数字值是<literal>TRUE</literal>，数字零值以及<literal>NULL</literal>是<literal>FALSE</literal>。
     </para>

<!--==========================orignal english content==========================
     <para>
      Too large or small integer and double constants, as well as
      integer arithmetic operators (<literal>+</literal>,
      <literal>-</literal>, <literal>*</literal> and <literal>/</literal>)
      raise errors on overflows.
     </para>
____________________________________________________________________________-->
     <para>
      太大或太小的整数和双常量，以及整数算术运算符（<literal>+</literal>,<literal>-</literal>, <literal>*</literal> 和 <literal>/</literal>）会引发溢出错误。
     </para>

<!--==========================orignal english content==========================
     <para>
      When no final <token>ELSE</token> clause is provided to a
      <token>CASE</token>, the default value is <literal>NULL</literal>.
     </para>
____________________________________________________________________________-->
     <para>
      在没有为<token>CASE</token>提供最终的<token>ELSE</token>子句时，默认值是<literal>NULL</literal>。
     </para>

<!--==========================orignal english content==========================
     <para>
      Examples:
<programlisting>
\set ntellers 10 * :scale
\set aid (1021 * random(1, 100000 * :scale)) % \
           (100000 * :scale) + 1
\set divx CASE WHEN :x &lt;&gt; 0 THEN :y/:x ELSE NULL END
</programlisting></para>
____________________________________________________________________________-->
     <para>
      示例：
<programlisting>
\set ntellers 10 * :scale
\set aid (1021 * random(1, 100000 * :scale)) % \
           (100000 * :scale) + 1
\set divx CASE WHEN :x &lt;&gt; 0 THEN :y/:x ELSE NULL END
</programlisting></para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term>
     <literal>\sleep <replaceable>number</replaceable> [ us | ms | s ]</literal>
    </term>
____________________________________________________________________________-->
    <term>
     <literal>\sleep <replaceable>number</replaceable> [ us | ms | s ]</literal>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Causes script execution to sleep for the specified duration in
      microseconds (<literal>us</literal>), milliseconds (<literal>ms</literal>) or seconds
      (<literal>s</literal>).  If the unit is omitted then seconds are the default.
      <replaceable>number</replaceable> can be either an integer constant or a
      <literal>:</literal><replaceable>variablename</replaceable> reference to a variable
      having an integer value.
     </para>
____________________________________________________________________________-->
     <para>
      导致脚本执行休眠指定的时间，时间的单位可以是微妙（<literal>us</literal>）、毫秒（<literal>ms</literal>）或者秒（<literal>s</literal>）。如果单位被忽略，则秒是默认值。<replaceable>number</replaceable>要么是一个整数常量，要么是一个引用了具有整数值的变量的<literal>:</literal><replaceable>variablename</replaceable>。
     </para>

<!--==========================orignal english content==========================
     <para>
      Example:
<programlisting>
\sleep 10 ms
</programlisting></para>
____________________________________________________________________________-->
     <para>
      例子：
<programlisting>
\sleep 10 ms
</programlisting></para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term>
     <literal>\setshell <replaceable>varname</replaceable> <replaceable>command</replaceable> [ <replaceable>argument</replaceable> ... ]</literal>
    </term>
____________________________________________________________________________-->
    <term>
     <literal>\setshell <replaceable>varname</replaceable> <replaceable>command</replaceable> [ <replaceable>argument</replaceable> ... ]</literal>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Sets variable <replaceable>varname</replaceable> to the result of the shell command
      <replaceable>command</replaceable> with the given <replaceable>argument</replaceable>(s).
      The command must return an integer value through its standard output.
     </para>
____________________________________________________________________________-->
     <para>
      用给定的<replaceable>argument</replaceable>设置变量<replaceable>varname</replaceable>为 shell 命令<replaceable>command</replaceable>的结果。该命令必须通过它的标准输出返回一个整数值。
     </para>

<!--==========================orignal english content==========================
     <para>
      <replaceable>command</replaceable> and each <replaceable>argument</replaceable> can be either
      a text constant or a <literal>:</literal><replaceable>variablename</replaceable> reference
      to a variable. If you want to use an <replaceable>argument</replaceable> starting
      with a colon, write an additional colon at the beginning of
      <replaceable>argument</replaceable>.
     </para>
____________________________________________________________________________-->
     <para>
      <replaceable>command</replaceable>和每个<replaceable>argument</replaceable>要么是一个文本常量，要么是一个引用了一个变量的<literal>:</literal><replaceable>variablename</replaceable>。如果你想要使用以冒号开始的<replaceable>argument</replaceable>，在<replaceable>argument</replaceable>的开头写一个额外的冒号。
     </para>

<!--==========================orignal english content==========================
     <para>
      Example:
<programlisting>
\setshell variable_to_be_assigned command literal_argument :variable ::literal_starting_with_colon
</programlisting></para>
____________________________________________________________________________-->
     <para>
      例子：
<programlisting>
\setshell variable_to_be_assigned command literal_argument :variable ::literal_starting_with_colon
</programlisting></para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term>
     <literal>\shell <replaceable>command</replaceable> [ <replaceable>argument</replaceable> ... ]</literal>
    </term>
____________________________________________________________________________-->
    <term>
     <literal>\shell <replaceable>command</replaceable> [ <replaceable>argument</replaceable> ... ]</literal>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Same as <literal>\setshell</literal>, but the result of the command
      is discarded.
     </para>
____________________________________________________________________________-->
     <para>
      与<literal>\setshell</literal>相同，但是结果被抛弃。
     </para>

<!--==========================orignal english content==========================
     <para>
      Example:
<programlisting>
\shell command literal_argument :variable ::literal_starting_with_colon
</programlisting></para>
____________________________________________________________________________-->
     <para>
      例子：
<programlisting>
\shell command literal_argument :variable ::literal_starting_with_colon
</programlisting></para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect2>

 <refsect2 id="pgbench-builtin-operators">
<!--==========================orignal english content==========================
  <title>Built-in Operators</title>
____________________________________________________________________________-->
  <title>内建操作符</title>

<!--==========================orignal english content==========================
  <para>
   The arithmetic, bitwise, comparison and logical operators listed in
   <xref linkend="pgbench-operators"/> are built into <application>pgbench</application>
   and may be used in expressions appearing in
   <link linkend="pgbench-metacommand-set"><literal>\set</literal></link>.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="pgbench-operators"/>中列举的算数、按位、比较以及逻辑操作符都被编译到了<application>pgbench</application>中并且可以被用于<link linkend="pgbench-metacommand-set"><literal>\set</literal></link>中出现的表达式中。
  </para>

  <table id="pgbench-operators">
<!--==========================orignal english content==========================
   <title>pgbench Operators by Increasing Precedence</title>
____________________________________________________________________________-->
   <title>按优先级升序排列的pgbench操作符</title>
   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Operator</entry>
      <entry>Description</entry>
      <entry>Example</entry>
      <entry>Result</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>操作符</entry>
      <entry>简介</entry>
      <entry>示例</entry>
      <entry>结果</entry>
     </row>
    </thead>
    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>OR</literal></entry>
      <entry>logical or</entry>
      <entry><literal>5 or 0</literal></entry>
      <entry><literal>TRUE</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>OR</literal></entry>
      <entry>逻辑或</entry>
      <entry><literal>5 or 0</literal></entry>
      <entry><literal>TRUE</literal></entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>AND</literal></entry>
      <entry>logical and</entry>
      <entry><literal>3 and 0</literal></entry>
      <entry><literal>FALSE</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>AND</literal></entry>
      <entry>逻辑与</entry>
      <entry><literal>3 and 0</literal></entry>
      <entry><literal>FALSE</literal></entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>NOT</literal></entry>
      <entry>logical not</entry>
      <entry><literal>not false</literal></entry>
      <entry><literal>TRUE</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>NOT</literal></entry>
      <entry>逻辑非</entry>
      <entry><literal>not false</literal></entry>
      <entry><literal>TRUE</literal></entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>IS [NOT] (NULL|TRUE|FALSE)</literal></entry>
      <entry>value tests</entry>
      <entry><literal>1 is null</literal></entry>
      <entry><literal>FALSE</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>IS [NOT] (NULL|TRUE|FALSE)</literal></entry>
      <entry>值测试</entry>
      <entry><literal>1 is null</literal></entry>
      <entry><literal>FALSE</literal></entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>ISNULL|NOTNULL</literal></entry>
      <entry>null tests</entry>
      <entry><literal>1 notnull</literal></entry>
      <entry><literal>TRUE</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ISNULL|NOTNULL</literal></entry>
      <entry>空测试</entry>
      <entry><literal>1 notnull</literal></entry>
      <entry><literal>TRUE</literal></entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>=</literal></entry>
      <entry>is equal</entry>
      <entry><literal>5 = 4</literal></entry>
      <entry><literal>FALSE</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>=</literal></entry>
      <entry>等于</entry>
      <entry><literal>5 = 4</literal></entry>
      <entry><literal>FALSE</literal></entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>&lt;&gt;</literal></entry>
      <entry>is not equal</entry>
      <entry><literal>5 &lt;&gt; 4</literal></entry>
      <entry><literal>TRUE</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>&lt;&gt;</literal></entry>
      <entry>不等于</entry>
      <entry><literal>5 &lt;&gt; 4</literal></entry>
      <entry><literal>TRUE</literal></entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>!=</literal></entry>
      <entry>is not equal</entry>
      <entry><literal>5 != 5</literal></entry>
      <entry><literal>FALSE</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>!=</literal></entry>
      <entry>不等于</entry>
      <entry><literal>5 != 5</literal></entry>
      <entry><literal>FALSE</literal></entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>&lt;</literal></entry>
      <entry>lower than</entry>
      <entry><literal>5 &lt; 4</literal></entry>
      <entry><literal>FALSE</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>&lt;</literal></entry>
      <entry>小于</entry>
      <entry><literal>5 &lt; 4</literal></entry>
      <entry><literal>FALSE</literal></entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>&lt;=</literal></entry>
      <entry>lower or equal</entry>
      <entry><literal>5 &lt;= 4</literal></entry>
      <entry><literal>FALSE</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>&lt;=</literal></entry>
      <entry>小于等于</entry>
      <entry><literal>5 &lt;= 4</literal></entry>
      <entry><literal>FALSE</literal></entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>&gt;</literal></entry>
      <entry>greater than</entry>
      <entry><literal>5 &gt; 4</literal></entry>
      <entry><literal>TRUE</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>&gt;</literal></entry>
      <entry>大于</entry>
      <entry><literal>5 &gt; 4</literal></entry>
      <entry><literal>TRUE</literal></entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>&gt;=</literal></entry>
      <entry>greater or equal</entry>
      <entry><literal>5 &gt;= 4</literal></entry>
      <entry><literal>TRUE</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>&gt;=</literal></entry>
      <entry>大于等于</entry>
      <entry><literal>5 &gt;= 4</literal></entry>
      <entry><literal>TRUE</literal></entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>|</literal></entry>
      <entry>integer bitwise OR</entry>
      <entry><literal>1 | 2</literal></entry>
      <entry><literal>3</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>|</literal></entry>
      <entry>整数按位OR</entry>
      <entry><literal>1 | 2</literal></entry>
      <entry><literal>3</literal></entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>#</literal></entry>
      <entry>integer bitwise XOR</entry>
      <entry><literal>1 # 3</literal></entry>
      <entry><literal>2</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>#</literal></entry>
      <entry>整数按位XOR</entry>
      <entry><literal>1 # 3</literal></entry>
      <entry><literal>2</literal></entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>&amp;</literal></entry>
      <entry>integer bitwise AND</entry>
      <entry><literal>1 &amp; 3</literal></entry>
      <entry><literal>1</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>&amp;</literal></entry>
      <entry>整数按位AND</entry>
      <entry><literal>1 &amp; 3</literal></entry>
      <entry><literal>1</literal></entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>~</literal></entry>
      <entry>integer bitwise NOT</entry>
      <entry><literal>~ 1</literal></entry>
      <entry><literal>-2</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>~</literal></entry>
      <entry>整数按位NOT</entry>
      <entry><literal>~ 1</literal></entry>
      <entry><literal>-2</literal></entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>&lt;&lt;</literal></entry>
      <entry>integer bitwise shift left</entry>
      <entry><literal>1 &lt;&lt; 2</literal></entry>
      <entry><literal>4</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>&lt;&lt;</literal></entry>
      <entry>整数按位左移</entry>
      <entry><literal>1 &lt;&lt; 2</literal></entry>
      <entry><literal>4</literal></entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>&gt;&gt;</literal></entry>
      <entry>integer bitwise shift right</entry>
      <entry><literal>8 &gt;&gt; 2</literal></entry>
      <entry><literal>2</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>&gt;&gt;</literal></entry>
      <entry>整数按位右移</entry>
      <entry><literal>8 &gt;&gt; 2</literal></entry>
      <entry><literal>2</literal></entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>+</literal></entry>
      <entry>addition</entry>
      <entry><literal>5 + 4</literal></entry>
      <entry><literal>9</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>+</literal></entry>
      <entry>加</entry>
      <entry><literal>5 + 4</literal></entry>
      <entry><literal>9</literal></entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>-</literal></entry>
      <entry>subtraction</entry>
      <entry><literal>3 - 2.0</literal></entry>
      <entry><literal>1.0</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>-</literal></entry>
      <entry>减</entry>
      <entry><literal>3 - 2.0</literal></entry>
      <entry><literal>1.0</literal></entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>*</literal></entry>
      <entry>multiplication</entry>
      <entry><literal>5 * 4</literal></entry>
      <entry><literal>20</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>*</literal></entry>
      <entry>乘</entry>
      <entry><literal>5 * 4</literal></entry>
      <entry><literal>20</literal></entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>/</literal></entry>
      <entry>division (integer truncates the results)</entry>
      <entry><literal>5 / 3</literal></entry>
      <entry><literal>1</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>/</literal></entry>
      <entry>除（整数会截断结果）</entry>
      <entry><literal>5 / 3</literal></entry>
      <entry><literal>1</literal></entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>%</literal></entry>
      <entry>modulo</entry>
      <entry><literal>3 % 2</literal></entry>
      <entry><literal>1</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>%</literal></entry>
      <entry>取模</entry>
      <entry><literal>3 % 2</literal></entry>
      <entry><literal>1</literal></entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>-</literal></entry>
      <entry>opposite</entry>
      <entry><literal>- 2.0</literal></entry>
      <entry><literal>-2.0</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>-</literal></entry>
      <entry>取负</entry>
      <entry><literal>- 2.0</literal></entry>
      <entry><literal>-2.0</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </refsect2>

 <refsect2 id="pgbench-builtin-functions">
<!--==========================orignal english content==========================
  <title>Built-In Functions</title>
____________________________________________________________________________-->
  <title>内建函数</title>

<!--==========================orignal english content==========================
  <para>
   The functions listed in <xref linkend="pgbench-functions"/> are built
   into <application>pgbench</application> and may be used in expressions appearing in
   <link linkend="pgbench-metacommand-set"><literal>\set</literal></link>.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="pgbench-functions"/>中列出的函数被编译在<application>pgbench</application>中，并且可能被用在出现于<link linkend="pgbench-metacommand-set"><literal>\set</literal></link>的表达式中。
  </para>

   <!-- list pgbench functions in alphabetical order -->
   <table id="pgbench-functions">
<!--==========================orignal english content==========================
    <title>pgbench Functions</title>
____________________________________________________________________________-->
    <title>pgbench 函数</title>
    <tgroup cols="5">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Function</entry>
       <entry>Return Type</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Result</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>函数</entry>
       <entry>返回类型</entry>
       <entry>简介</entry>
       <entry>例子</entry>
       <entry>结果</entry>
      </row>
     </thead>
     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>abs(<replaceable>a</replaceable>)</function></literal></entry>
       <entry>same as <replaceable>a</replaceable></entry>
       <entry>absolute value</entry>
       <entry><literal>abs(-17)</literal></entry>
       <entry><literal>17</literal></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>abs(<replaceable>a</replaceable>)</function></literal></entry>
       <entry>和<replaceable>a</replaceable>相同</entry>
       <entry>绝对值</entry>
       <entry><literal>abs(-17)</literal></entry>
       <entry><literal>17</literal></entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>debug(<replaceable>a</replaceable>)</function></literal></entry>
       <entry>same as <replaceable>a</replaceable> </entry>
       <entry>print <replaceable>a</replaceable> to <systemitem>stderr</systemitem>,
        and return <replaceable>a</replaceable></entry>
       <entry><literal>debug(5432.1)</literal></entry>
       <entry><literal>5432.1</literal></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>debug(<replaceable>a</replaceable>)</function></literal></entry>
       <entry>和<replaceable>a</replaceable>相同</entry>
       <entry>把<replaceable>a</replaceable>打印到<systemitem>stderr</systemitem>，并且返回<replaceable>a</replaceable></entry>
       <entry><literal>debug(5432.1)</literal></entry>
       <entry><literal>5432.1</literal></entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>double(<replaceable>i</replaceable>)</function></literal></entry>
       <entry>double</entry>
       <entry>cast to double</entry>
       <entry><literal>double(5432)</literal></entry>
       <entry><literal>5432.0</literal></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>double(<replaceable>i</replaceable>)</function></literal></entry>
       <entry>double</entry>
       <entry>造型成double</entry>
       <entry><literal>double(5432)</literal></entry>
       <entry><literal>5432.0</literal></entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>exp(<replaceable>x</replaceable>)</function></literal></entry>
       <entry>double</entry>
       <entry>exponential</entry>
       <entry><literal>exp(1.0)</literal></entry>
       <entry><literal>2.718281828459045</literal></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>exp(<replaceable>x</replaceable>)</function></literal></entry>
       <entry>double</entry>
       <entry>指数</entry>
       <entry><literal>exp(1.0)</literal></entry>
       <entry><literal>2.718281828459045</literal></entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>greatest(<replaceable>a</replaceable> [, <replaceable>...</replaceable> ] )</function></literal></entry>
       <entry>double if any <replaceable>a</replaceable> is double, else integer</entry>
       <entry>largest value among arguments</entry>
       <entry><literal>greatest(5, 4, 3, 2)</literal></entry>
       <entry><literal>5</literal></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>greatest(<replaceable>a</replaceable> [, <replaceable>...</replaceable> ] )</function></literal></entry>
       <entry>如果任何<replaceable>a</replaceable>是double则为double，否则为integer</entry>
       <entry>参数中的最大值</entry>
       <entry><literal>greatest(5, 4, 3, 2)</literal></entry>
       <entry><literal>5</literal></entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>hash(<replaceable>a</replaceable> [, <replaceable>seed</replaceable> ] )</function></literal></entry>
       <entry>integer</entry>
       <entry>alias for <literal>hash_murmur2()</literal></entry>
       <entry><literal>hash(10, 5432)</literal></entry>
       <entry><literal>-5817877081768721676</literal></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>hash(<replaceable>a</replaceable> [, <replaceable>seed</replaceable> ] )</function></literal></entry>
       <entry>integer</entry>
       <entry><literal>hash_murmur2()</literal>的别名</entry>
       <entry><literal>hash(10, 5432)</literal></entry>
       <entry><literal>-5817877081768721676</literal></entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>hash_fnv1a(<replaceable>a</replaceable> [, <replaceable>seed</replaceable> ] )</function></literal></entry>
       <entry>integer</entry>
       <entry><ulink url="https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function">FNV-1a hash</ulink></entry>
       <entry><literal>hash_fnv1a(10, 5432)</literal></entry>
       <entry><literal>-7793829335365542153</literal></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>hash_fnv1a(<replaceable>a</replaceable> [, <replaceable>seed</replaceable> ] )</function></literal></entry>
       <entry>integer</entry>
       <entry><ulink url="https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function">FNV-1a hash</ulink></entry>
       <entry><literal>hash_fnv1a(10, 5432)</literal></entry>
       <entry><literal>-7793829335365542153</literal></entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>hash_murmur2(<replaceable>a</replaceable> [, <replaceable>seed</replaceable> ] )</function></literal></entry>
       <entry>integer</entry>
       <entry><ulink url="https://en.wikipedia.org/wiki/MurmurHash">MurmurHash2 hash</ulink></entry>
       <entry><literal>hash_murmur2(10, 5432)</literal></entry>
       <entry><literal>-5817877081768721676</literal></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>hash_murmur2(<replaceable>a</replaceable> [, <replaceable>seed</replaceable> ] )</function></literal></entry>
       <entry>integer</entry>
       <entry><ulink url="https://en.wikipedia.org/wiki/MurmurHash">MurmurHash2 hash</ulink></entry>
       <entry><literal>hash_murmur2(10, 5432)</literal></entry>
       <entry><literal>-5817877081768721676</literal></entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>int(<replaceable>x</replaceable>)</function></literal></entry>
       <entry>integer</entry>
       <entry>cast to int</entry>
       <entry><literal>int(5.4 + 3.8)</literal></entry>
       <entry><literal>9</literal></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>int(<replaceable>x</replaceable>)</function></literal></entry>
       <entry>integer</entry>
       <entry>造型成int</entry>
       <entry><literal>int(5.4 + 3.8)</literal></entry>
       <entry><literal>9</literal></entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>least(<replaceable>a</replaceable> [, <replaceable>...</replaceable> ] )</function></literal></entry>
       <entry>double if any <replaceable>a</replaceable> is double, else integer</entry>
       <entry>smallest value among arguments</entry>
       <entry><literal>least(5, 4, 3, 2.1)</literal></entry>
       <entry><literal>2.1</literal></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>least(<replaceable>a</replaceable> [, <replaceable>...</replaceable> ] )</function></literal></entry>
       <entry>如果任何<replaceable>a</replaceable>是double则为double，否则为integer</entry>
       <entry>参数中的最小值</entry>
       <entry><literal>least(5, 4, 3, 2.1)</literal></entry>
       <entry><literal>2.1</literal></entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>ln(<replaceable>x</replaceable>)</function></literal></entry>
       <entry>double</entry>
       <entry>natural logarithm</entry>
       <entry><literal>ln(2.718281828459045)</literal></entry>
       <entry><literal>1.0</literal></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>ln(<replaceable>x</replaceable>)</function></literal></entry>
       <entry>double</entry>
       <entry>自然对数</entry>
       <entry><literal>ln(2.718281828459045)</literal></entry>
       <entry><literal>1.0</literal></entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>mod(<replaceable>i</replaceable>, <replaceable>j</replaceable>)</function></literal></entry>
       <entry>integer</entry>
       <entry>modulo</entry>
       <entry><literal>mod(54, 32)</literal></entry>
       <entry><literal>22</literal></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>mod(<replaceable>i</replaceable>, <replaceable>j</replaceable>)</function></literal></entry>
       <entry>integer</entry>
       <entry>取模</entry>
       <entry><literal>mod(54, 32)</literal></entry>
       <entry><literal>22</literal></entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pi()</function></literal></entry>
       <entry>double</entry>
       <entry>value of the constant PI</entry>
       <entry><literal>pi()</literal></entry>
       <entry><literal>3.14159265358979323846</literal></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pi()</function></literal></entry>
       <entry>double</entry>
       <entry>常量PI的值</entry>
       <entry><literal>pi()</literal></entry>
       <entry><literal>3.14159265358979323846</literal></entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pow(<replaceable>x</replaceable>, <replaceable>y</replaceable>)</function>, <function>power(<replaceable>x</replaceable>, <replaceable>y</replaceable>)</function></literal></entry>
       <entry>double</entry>
       <entry>exponentiation</entry>
       <entry><literal>pow(2.0, 10)</literal>, <literal>power(2.0, 10)</literal></entry>
       <entry><literal>1024.0</literal></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pow(<replaceable>x</replaceable>, <replaceable>y</replaceable>)</function>, <function>power(<replaceable>x</replaceable>, <replaceable>y</replaceable>)</function></literal></entry>
       <entry>double</entry>
       <entry>求幂</entry>
       <entry><literal>pow(2.0, 10)</literal>, <literal>power(2.0, 10)</literal></entry>
       <entry><literal>1024.0</literal></entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>random(<replaceable>lb</replaceable>, <replaceable>ub</replaceable>)</function></literal></entry>
       <entry>integer</entry>
       <entry>uniformly-distributed random integer in <literal>[lb, ub]</literal></entry>
       <entry><literal>random(1, 10)</literal></entry>
       <entry>an integer between <literal>1</literal> and <literal>10</literal></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>random(<replaceable>lb</replaceable>, <replaceable>ub</replaceable>)</function></literal></entry>
       <entry>integer</entry>
       <entry><literal>[lb, ub]</literal>中均匀分布的随机整数</entry>
       <entry><literal>random(1, 10)</literal></entry>
       <entry><literal>1</literal>和<literal>10</literal>之间的一个整数</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>random_exponential(<replaceable>lb</replaceable>, <replaceable>ub</replaceable>, <replaceable>parameter</replaceable>)</function></literal></entry>
       <entry>integer</entry>
       <entry>exponentially-distributed random integer in <literal>[lb, ub]</literal>,
              see below</entry>
       <entry><literal>random_exponential(1, 10, 3.0)</literal></entry>
       <entry>an integer between <literal>1</literal> and <literal>10</literal></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>random_exponential(<replaceable>lb</replaceable>, <replaceable>ub</replaceable>, <replaceable>parameter</replaceable>)</function></literal></entry>
       <entry>integer</entry>
       <entry><literal>[lb, ub]</literal>中指数分布的随机整数，见下文</entry>
       <entry><literal>random_exponential(1, 10, 3.0)</literal></entry>
       <entry><literal>1</literal>和<literal>10</literal>之间的一个整数</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>random_gaussian(<replaceable>lb</replaceable>, <replaceable>ub</replaceable>, <replaceable>parameter</replaceable>)</function></literal></entry>
       <entry>integer</entry>
       <entry>Gaussian-distributed random integer in <literal>[lb, ub]</literal>,
              see below</entry>
       <entry><literal>random_gaussian(1, 10, 2.5)</literal></entry>
       <entry>an integer between <literal>1</literal> and <literal>10</literal></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>random_gaussian(<replaceable>lb</replaceable>, <replaceable>ub</replaceable>, <replaceable>parameter</replaceable>)</function></literal></entry>
       <entry>integer</entry>
       <entry><literal>[lb, ub]</literal>中高斯分布的随机整数，见下文</entry>
       <entry><literal>random_gaussian(1, 10, 2.5)</literal></entry>
       <entry><literal>1</literal>和<literal>10</literal>之间的一个整数</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>random_zipfian(<replaceable>lb</replaceable>, <replaceable>ub</replaceable>, <replaceable>parameter</replaceable>)</function></literal></entry>
       <entry>integer</entry>
       <entry>Zipfian-distributed random integer in <literal>[lb, ub]</literal>,
              see below</entry>
       <entry><literal>random_zipfian(1, 10, 1.5)</literal></entry>
       <entry>an integer between <literal>1</literal> and <literal>10</literal></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>random_zipfian(<replaceable>lb</replaceable>, <replaceable>ub</replaceable>, <replaceable>parameter</replaceable>)</function></literal></entry>
       <entry>integer</entry>
       <entry><literal>[lb, ub]</literal>中Zipfian分布的随机整数，见下文</entry>
       <entry><literal>random_zipfian(1, 10, 1.5)</literal></entry>
       <entry><literal>1</literal>和<literal>10</literal>之间的一个整数</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>sqrt(<replaceable>x</replaceable>)</function></literal></entry>
       <entry>double</entry>
       <entry>square root</entry>
       <entry><literal>sqrt(2.0)</literal></entry>
       <entry><literal>1.414213562</literal></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>sqrt(<replaceable>x</replaceable>)</function></literal></entry>
       <entry>double</entry>
       <entry>平方根</entry>
       <entry><literal>sqrt(2.0)</literal></entry>
       <entry><literal>1.414213562</literal></entry>
      </row>
     </tbody>
     </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    The <literal>random</literal> function generates values using a uniform
    distribution, that is all the values are drawn within the specified
    range with equal probability. The <literal>random_exponential</literal>,
    <literal>random_gaussian</literal> and <literal>random_zipfian</literal>
    functions require an additional double parameter which determines the precise
    shape of the distribution.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>random</literal>函数使用均匀分布生成值，即所有的值都以相等的概率从指定的范围中抽出。<literal>random_exponential</literal>、<literal>random_gaussian</literal>以及<literal>random_zipfian</literal>函数要求一个额外的 double 参数，它决定分布的精确形状。
   </para>

   <itemizedlist>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      For an exponential distribution, <replaceable>parameter</replaceable>
      controls the distribution by truncating a quickly-decreasing
      exponential distribution at <replaceable>parameter</replaceable>, and then
      projecting onto integers between the bounds.
      To be precise, with
<literallayout>
f(x) = exp(-parameter * (x - min) / (max - min + 1)) / (1 - exp(-parameter))
</literallayout>
      Then value <replaceable>i</replaceable> between <replaceable>min</replaceable> and
      <replaceable>max</replaceable> inclusive is drawn with probability:
      <literal>f(i) - f(i + 1)</literal>.
     </para>
____________________________________________________________________________-->
     <para>
      对于指数分布，<replaceable>parameter</replaceable>通过在<replaceable>parameter</replaceable>处截断一个快速下降的指数分布来控制分布，然后投影到边界之间的整数上。确切地来说，
<literallayout>
f(x) = exp(-parameter * (x - min) / (max - min + 1)) / (1 - exp(-parameter))
</literallayout>
      然后<replaceable>min</replaceable>和<replaceable>max</replaceable>之间（包括两者）的值<replaceable>i</replaceable>会被以概率<literal>f(i) - f(i + 1)</literal>抽出。
     </para>

<!--==========================orignal english content==========================
     <para>
      Intuitively, the larger the <replaceable>parameter</replaceable>, the more
      frequently values close to <replaceable>min</replaceable> are accessed, and the
      less frequently values close to <replaceable>max</replaceable> are accessed.
      The closer to 0 <replaceable>parameter</replaceable> is, the flatter (more
      uniform) the access distribution.
      A crude approximation of the distribution is that the most frequent 1%
      values in the range, close to <replaceable>min</replaceable>, are drawn
      <replaceable>parameter</replaceable>% of the time.
      The <replaceable>parameter</replaceable> value must be strictly positive.
     </para>
____________________________________________________________________________-->
     <para>
      直观上，<replaceable>parameter</replaceable>越大，接近<replaceable>min</replaceable>的值会被越频繁地访问，并且接近<replaceable>max</replaceable>的值会被越少访问。<replaceable>parameter</replaceable>越接近 0，访问分布会越平坦（更均匀）。该分布的粗近似值是范围中当时被抽取 <replaceable>parameter</replaceable>% 次接近<replaceable>min</replaceable>的最频繁的 1% 值。<replaceable>parameter</replaceable>值必须严格为正。
     </para>
    </listitem>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      For a Gaussian distribution, the interval is mapped onto a standard
      normal distribution (the classical bell-shaped Gaussian curve) truncated
      at <literal>-parameter</literal> on the left and <literal>+parameter</literal>
      on the right.
      Values in the middle of the interval are more likely to be drawn.
      To be precise, if <literal>PHI(x)</literal> is the cumulative distribution
      function of the standard normal distribution, with mean <literal>mu</literal>
      defined as <literal>(max + min) / 2.0</literal>, with
<literallayout>
f(x) = PHI(2.0 * parameter * (x - mu) / (max - min + 1)) /
       (2.0 * PHI(parameter) - 1)
</literallayout>
      then value <replaceable>i</replaceable> between <replaceable>min</replaceable> and
      <replaceable>max</replaceable> inclusive is drawn with probability:
      <literal>f(i + 0.5) - f(i - 0.5)</literal>.
      Intuitively, the larger the <replaceable>parameter</replaceable>, the more
      frequently values close to the middle of the interval are drawn, and the
      less frequently values close to the <replaceable>min</replaceable> and
      <replaceable>max</replaceable> bounds. About 67% of values are drawn from the
      middle <literal>1.0 / parameter</literal>, that is a relative
      <literal>0.5 / parameter</literal> around the mean, and 95% in the middle
      <literal>2.0 / parameter</literal>, that is a relative
      <literal>1.0 / parameter</literal> around the mean; for instance, if
      <replaceable>parameter</replaceable> is 4.0, 67% of values are drawn from the
      middle quarter (1.0 / 4.0) of the interval (i.e. from
      <literal>3.0 / 8.0</literal> to <literal>5.0 / 8.0</literal>) and 95% from
      the middle half (<literal>2.0 / 4.0</literal>) of the interval (second and third
      quartiles). The minimum allowed <replaceable>parameter</replaceable>
      value is 2.0.
     </para>
____________________________________________________________________________-->
     <para>
      对于高斯分布，区间被映射到一个在左边<literal>-parameter</literal>和右边<literal>+parameter</literal>截断的标准正态分布（经典钟型高斯曲线）。区间中间的值更可能被抽到。准确地说，如果<literal>PHI(x)</literal>是标准正态分布的累计分布函数，均值<literal>mu</literal>定义为<literal>(max + min) / 2.0</literal>，有
<literallayout>
f(x) = PHI(2.0 * parameter * (x - mu) / (max - min + 1)) /
       (2.0 * PHI(parameter) - 1)
</literallayout>
      则<replaceable>min</replaceable>和<replaceable>max</replaceable>（包括两者）之间的值<replaceable>i</replaceable>被抽出的概率是：<literal>f(i + 0.5) - f(i - 0.5)</literal>。直观上，<replaceable>parameter</replaceable>越大，靠近区间终端的值会被越频繁地抽出，并且靠近上下界两端的值会被更少抽出。大约 67% 的值会被从中间<literal>1.0 / parameter</literal>的地方抽出，即均值周围<literal>0.5 / parameter</literal>的地方。并且 95% 的值会被从中间<literal>2.0 / parameter</literal>的地方抽出，即均值周围<literal>1.0 / parameter</literal>的地方。例如，如果<replaceable>parameter</replaceable>是 4.0，67% 的值会被从该区间的中间四分之一（1.0 / 4.0）抽出（即从<literal>3.0 / 8.0</literal>到<literal>5.0 / 8.0</literal>）。并且 95% 的值会从该区间的中间一半（<literal>2.0 / 4.0</literal>）抽出（第二和第三四分位）。最小允许的<replaceable>parameter</replaceable>值为 2.0。
     </para>
    </listitem>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      <literal>random_zipfian</literal> generates a bounded Zipfian
      distribution.
      <replaceable>parameter</replaceable> defines how skewed the distribution
      is. The larger the <replaceable>parameter</replaceable>, the more
      frequently values closer to the beginning of the interval are drawn.
      The distribution is such that, assuming the range starts from 1,
      the ratio of the probability of drawing <replaceable>k</replaceable>
      versus drawing <replaceable>k+1</replaceable> is
      <literal>((<replaceable>k</replaceable>+1)/<replaceable>k</replaceable>)**<replaceable>parameter</replaceable></literal>.
      For example, <literal>random_zipfian(1, ..., 2.5)</literal> produces
      the value <literal>1</literal> about <literal>(2/1)**2.5 =
      5.66</literal> times more frequently than <literal>2</literal>, which
      itself is produced <literal>(3/2)**2.5 = 2.76</literal> times more
      frequently than <literal>3</literal>, and so on.
     </para>
____________________________________________________________________________-->
     <para>
      <literal>random_zipfian</literal>生成一个有界的Zipfian分布。
      <replaceable>parameter</replaceable>定义该分布有多么倾斜。<replaceable>parameter</replaceable>越大，绘制越接近间隔开头的值越频繁。
      分布是这样的，假设范围从1开始，绘制<replaceable>k</replaceable>与绘制<replaceable>k+1</replaceable>的概率之比为
     <literal>((<replaceable>k</replaceable>+1)/<replaceable>k</replaceable>)**<replaceable>parameter</replaceable></literal>。
     例如，<literal>random_zipfian(1, ..., 2.5)</literal>生成值<literal>1</literal>大约<literal>(2/1)**2.5 =
      5.66</literal>次，比<literal> 2 </literal>更频繁，它本身被产生<literal>(3/2)**2.5 = 2.76</literal>次，
      比<literal>3</literal>更频繁，依此类推。
     </para>
<!--==========================orignal english content==========================
     <para>
      <application>pgbench</application>'s implementation is based on
      "Non-Uniform Random Variate Generation", Luc Devroye, p. 550-551,
      Springer 1986.  Due to limitations of that algorithm,
      the <replaceable>parameter</replaceable> value is restricted to
      the range [1.001, 1000].
     </para>
____________________________________________________________________________-->
     <para>
      <application>pgbench</application>的实现是基于"Non-Uniform Random Variate Generation", Luc Devroye, p. 550-551,Springer 1986。
      由于该算法的限制，<replaceable>parameter</replaceable>值限制范围为[1.001, 1000]。
     </para>
    </listitem>
   </itemizedlist>

<!--==========================orignal english content==========================
  <para>
    Hash functions <literal>hash</literal>, <literal>hash_murmur2</literal> and
    <literal>hash_fnv1a</literal> accept an input value and an optional seed parameter.
    In case the seed isn't provided the value of <literal>:default_seed</literal>
    is used, which is initialized randomly unless set by the command-line
    <literal>-D</literal> option. Hash functions can be used to scatter the
    distribution of random functions such as <literal>random_zipfian</literal> or
    <literal>random_exponential</literal>. For instance, the following pgbench
    script simulates possible real world workload typical for social media and
    blogging platforms where few accounts generate excessive load:

<programlisting>
\set r random_zipfian(0, 100000000, 1.07)
\set k abs(hash(:r)) % 1000000
</programlisting>

    In some cases several distinct distributions are needed which don't correlate
    with each other and this is when implicit seed parameter comes in handy:

<programlisting>
\set k1 abs(hash(:r, :default_seed + 123)) % 1000000
\set k2 abs(hash(:r, :default_seed + 321)) % 1000000
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
    哈希函数<literal>hash</literal>、<literal>hash_murmur2</literal>以及<literal>hash_fnv1a</literal>接受一个输入值和一个可选的种子参数。在没有提供种子的情况下，会使用<literal>:default_seed</literal>的值，该变量会被随机地初始化，除非用命令行的<literal>-D</literal> 选项重载。哈希函数可以被用于分散<literal>random_zipfian</literal>或<literal>random_exponential</literal>这样的随机函数的分布。例如，下列pgbench脚本模拟了社交媒体和博客平台上很常见的真实负载，其中少数账号产生了过量的负载：

<programlisting>
\set r random_zipfian(0, 100000000, 1.07)
\set k abs(hash(:r)) % 1000000
</programlisting>

    在一些情况中需要几个不同的分布，它们彼此之间不相关并且隐式的随机数参数在此时就能派上用场：

<programlisting>
\set k1 abs(hash(:r, :default_seed + 123)) % 1000000
\set k2 abs(hash(:r, :default_seed + 321)) % 1000000
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   As an example, the full definition of the built-in TPC-B-like
   transaction is:

<programlisting>
\set aid random(1, 100000 * :scale)
\set bid random(1, 1 * :scale)
\set tid random(1, 10 * :scale)
\set delta random(-5000, 5000)
BEGIN;
UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
END;
</programlisting>

   This script allows each iteration of the transaction to reference
   different, randomly-chosen rows.  (This example also shows why it's
   important for each client session to have its own variables &mdash;
   otherwise they'd not be independently touching different rows.)
  </para>
____________________________________________________________________________-->
  <para>
   作为一个例子，内建的类 TPC-B 事务的全部定义是：

<programlisting>
\set aid random(1, 100000 * :scale)
\set bid random(1, 1 * :scale)
\set tid random(1, 10 * :scale)
\set delta random(-5000, 5000)
BEGIN;
UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
END;
</programlisting>

   这个脚本允许该事务的每一次迭代能够引用不同的、被随机选择的行（这个例子也展示了为什么让每一个客户端会话有其自己的变量很重要 &mdash; 否则它们不会独立地接触不同的行）。
  </para>

 </refsect2>

 <refsect2>
<!--==========================orignal english content==========================
  <title>Per-Transaction Logging</title>
____________________________________________________________________________-->
  <title>对每个事务做日志</title>

<!--==========================orignal english content==========================
  <para>
   With the <option>-l</option> option (but without
   the <option>-&minus;aggregate-interval</option> option),
   <application>pgbench</application> writes information about each transaction
   to a log file.  The log file will be named
   <filename><replaceable>prefix</replaceable>.<replaceable>nnn</replaceable></filename>,
   where <replaceable>prefix</replaceable> defaults to <literal>pgbench_log</literal>, and
   <replaceable>nnn</replaceable> is the PID of the
   <application>pgbench</application> process.
   The prefix can be changed by using the <option>-&minus;log-prefix</option> option.
   If the <option>-j</option> option is 2 or higher, so that there are multiple
   worker threads, each will have its own log file. The first worker will
   use the same name for its log file as in the standard single worker case.
   The additional log files for the other workers will be named
   <filename><replaceable>prefix</replaceable>.<replaceable>nnn</replaceable>.<replaceable>mmm</replaceable></filename>,
   where <replaceable>mmm</replaceable> is a sequential number for each worker starting
   with 1.
  </para>
____________________________________________________________________________-->
  <para>
   通过<option>-l</option>选项（但是没有<option>--aggregate-interval</option>选项），<application>pgbench</application>把关于每个事务的信息写入到一个日志文件。该日志文件将被命名为<filename><replaceable>prefix</replaceable>.<replaceable>nnn</replaceable></filename>，其中<replaceable>prefix</replaceable>默认为<literal>pgbench_log</literal>，而<replaceable>nnn</replaceable>是<application>pgbench</application>进程的PID。前缀可以用<option>--log-prefix</option>选项更改。如果<option>-j</option>选项是2或者更高（有多个工作者线程），那么每一个工作者线程将会有它自己的日志文件。第一个工作者的日志文件的命名将和标准的单工作者情况相同。其他工作者的额外日志文件将被命名为<filename><replaceable>prefix</replaceable>.<replaceable>nnn</replaceable>.<replaceable>mmm</replaceable></filename>，其中<replaceable>mmm</replaceable>是每个工作者的一个序列号，这种序列号从1开始编。
  </para>

<!--==========================orignal english content==========================
  <para>
   The format of the log is:

<synopsis>
<replaceable>client_id</replaceable> <replaceable>transaction_no</replaceable> <replaceable>time</replaceable> <replaceable>script_no</replaceable> <replaceable>time_epoch</replaceable> <replaceable>time_us</replaceable> <optional> <replaceable>schedule_lag</replaceable> </optional>
</synopsis>

   where
   <replaceable>client_id</replaceable> indicates which client session ran the transaction,
   <replaceable>transaction_no</replaceable> counts how many transactions have been
   run by that session,
   <replaceable>time</replaceable> is the total elapsed transaction time in microseconds,
   <replaceable>script_no</replaceable> identifies which script file was used (useful when
   multiple scripts were specified with <option>-f</option> or <option>-b</option>),
   and <replaceable>time_epoch</replaceable>/<replaceable>time_us</replaceable> are a
   Unix-epoch time stamp and an offset
   in microseconds (suitable for creating an ISO 8601
   time stamp with fractional seconds) showing when
   the transaction completed.
   The <replaceable>schedule_lag</replaceable> field is the difference between the
   transaction's scheduled start time, and the time it actually started, in
   microseconds. It is only present when the <option>-&minus;rate</option> option is used.
   When both <option>-&minus;rate</option> and <option>-&minus;latency-limit</option> are used,
   the <replaceable>time</replaceable> for a skipped transaction will be reported as
   <literal>skipped</literal>.
  </para>
____________________________________________________________________________-->
  <para>
   日志的格式是：

<synopsis>
<replaceable>client_id</replaceable> <replaceable>transaction_no</replaceable> <replaceable>time</replaceable> <replaceable>script_no</replaceable> <replaceable>time_epoch</replaceable> <replaceable>time_us</replaceable> <optional> <replaceable>schedule_lag</replaceable> </optional>
</synopsis>

   其中<replaceable>client_id</replaceable>表示哪个客户端会话运行该事务，<replaceable>transaction_no</replaceable>是那个会话已经运行了多少个事务的计数，<replaceable>time</replaceable>是以微秒计的总共用掉的事务时间，<replaceable>script_no</replaceable>标识了要使用哪个脚本文件（当用<option>-f</option>或者<option>-b</option>指定多个脚本时有用），而<replaceable>time_epoch</replaceable>/<replaceable>time_us</replaceable>是一个 Unix 纪元格式的时间戳以及一个显示事务完成时间的以微秒计的偏移量（适合于创建一个带有分数秒的 ISO 8601 时间戳）。 域<replaceable>schedule_lag</replaceable>是事务的预定开始时间和实际开始时间之间的差别，以微秒计。只有使用<option>--rate</option>选项时它才存在。当<option>--rate</option>和<option>--latency-limit</option>同时被使用时， 一个被跳过的事务的<replaceable>time</replaceable>会被报告为<literal>skipped</literal>。
  </para>

<!--==========================orignal english content==========================
  <para>
   Here is a snippet of a log file generated in a single-client run:
<screen>
0 199 2241 0 1175850568 995598
0 200 2465 0 1175850568 998079
0 201 2513 0 1175850569 608
0 202 2038 0 1175850569 2663
</screen>

   Another example with <literal>-&minus;rate=100</literal>
   and <literal>-&minus;latency-limit=5</literal> (note the additional
   <replaceable>schedule_lag</replaceable> column):
<screen>
0 81 4621 0 1412881037 912698 3005
0 82 6173 0 1412881037 914578 4304
0 83 skipped 0 1412881037 914578 5217
0 83 skipped 0 1412881037 914578 5099
0 83 4722 0 1412881037 916203 3108
0 84 4142 0 1412881037 918023 2333
0 85 2465 0 1412881037 919759 740
</screen>
   In this example, transaction 82 was late, because its latency (6.173 ms) was
   over the 5 ms limit. The next two transactions were skipped, because they
   were already late before they were even started.
  </para>
____________________________________________________________________________-->
  <para>
   这里是在单个客户端运行中生成的一个日志文件的片段：
<screen>
0 199 2241 0 1175850568 995598
0 200 2465 0 1175850568 998079
0 201 2513 0 1175850569 608
0 202 2038 0 1175850569 2663
</screen>
   
   另一个例子使用的是<literal>--rate=100</literal>以及<literal>--latency-limit=5</literal>（注意额外的
   <replaceable>schedule_lag</replaceable>列）：
<screen>
0 81 4621 0 1412881037 912698 3005
0 82 6173 0 1412881037 914578 4304
0 83 skipped 0 1412881037 914578 5217
0 83 skipped 0 1412881037 914578 5099
0 83 4722 0 1412881037 916203 3108
0 84 4142 0 1412881037 918023 2333
0 85 2465 0 1412881037 919759 740
</screen>
   在这个例子中，事务 82 迟到了，因为它的延迟（6.173 ms）超过了 
   5 ms 限制。接下来的两个事务被跳过，因为它们在开始之前就已经迟到了。
  </para>

<!--==========================orignal english content==========================
  <para>
   When running a long test on hardware that can handle a lot of transactions,
   the log files can become very large.  The <option>-&minus;sampling-rate</option> option
   can be used to log only a random sample of transactions.
  </para>
____________________________________________________________________________-->
  <para>
   在能够处理大量事务的硬件上运行一次长时间的测试时，日志文件可能变得非常大。<option>--sampling-rate</option>选项能被用来只记录事务的一个随机采样。
  </para>
 </refsect2>

 <refsect2>
<!--==========================orignal english content==========================
  <title>Aggregated Logging</title>
____________________________________________________________________________-->
  <title>聚合的日志记录</title>

<!--==========================orignal english content==========================
  <para>
   With the <option>-&minus;aggregate-interval</option> option, a different
   format is used for the log files:

<synopsis>
<replaceable>interval_start</replaceable> <replaceable>num_transactions</replaceable> <replaceable>sum_latency</replaceable> <replaceable>sum_latency_2</replaceable> <replaceable>min_latency</replaceable> <replaceable>max_latency</replaceable> <optional> <replaceable>sum_lag</replaceable> <replaceable>sum_lag_2</replaceable> <replaceable>min_lag</replaceable> <replaceable>max_lag</replaceable> <optional> <replaceable>skipped</replaceable> </optional> </optional>
</synopsis>

   where
   <replaceable>interval_start</replaceable> is the start of the interval (as a Unix
   epoch time stamp),
   <replaceable>num_transactions</replaceable> is the number of transactions
   within the interval,
   <replaceable>sum_latency</replaceable> is the sum of the transaction
   latencies within the interval,
   <replaceable>sum_latency_2</replaceable> is the sum of squares of the
   transaction latencies within the interval,
   <replaceable>min_latency</replaceable> is the minimum latency within the interval,
   and
   <replaceable>max_latency</replaceable> is the maximum latency within the interval.
   The next fields,
   <replaceable>sum_lag</replaceable>, <replaceable>sum_lag_2</replaceable>, <replaceable>min_lag</replaceable>,
   and <replaceable>max_lag</replaceable>, are only present if the <option>-&minus;rate</option>
   option is used.
   They provide statistics about the time each transaction had to wait for the
   previous one to finish, i.e. the difference between each transaction's
   scheduled start time and the time it actually started.
   The very last field, <replaceable>skipped</replaceable>,
   is only present if the <option>-&minus;latency-limit</option> option is used, too.
   It counts the number of transactions skipped because they would have
   started too late.
   Each transaction is counted in the interval when it was committed.
  </para>
____________________________________________________________________________-->
  <para>
   通过<option>--aggregate-interval</option>选项，日志文件会使用一种不同的格式：

<synopsis>
<replaceable>interval_start</replaceable> <replaceable>num_transactions</replaceable> <replaceable>sum_latency</replaceable> <replaceable>sum_latency_2</replaceable> <replaceable>min_latency</replaceable> <replaceable>max_latency</replaceable> <optional> <replaceable>sum_lag</replaceable> <replaceable>sum_lag_2</replaceable> <replaceable>min_lag</replaceable> <replaceable>max_lag</replaceable> <optional> <replaceable>skipped</replaceable> </optional> </optional>
</synopsis>

   其中<replaceable>interval_start</replaceable>是区间的开始（作为一个Unix纪元的时间戳）、<replaceable>num_transactions</replaceable>是该区间中的事务数、<replaceable>sum_latency</replaceable>是该区间中事务时延的总量、<replaceable>sum_latency_2</replaceable>是该区间中事务时延的平方和、<replaceable>min_latency</replaceable>是该区间中的最小时延、<replaceable>max_latency</replaceable>是该区间中的最大时延。接下来的字段<replaceable>sum_lag</replaceable>、<replaceable>sum_lag_2</replaceable>、<replaceable>min_lag</replaceable>以及<replaceable>max_lag</replaceable>只有在使用<option>--rate</option>选项时才存在。它们提供每个事务要等待前一个事务完成所花的时间的统计信息，即每个事务的计划启动时间与实际启动时间之间的差值。最后一个字段<replaceable>skipped</replaceable>只有在使用<option>--latency-limit</option>选项时才存在。它对因为启动过完被跳过的事务进行计数。每一个事务被计入在其提交时的区间中。
  </para>

<!--==========================orignal english content==========================
  <para>
   Here is some example output:
<screen>
1345828501 5601 1542744 483552416 61 2573
1345828503 7884 1979812 565806736 60 1479
1345828505 7208 1979422 567277552 59 1391
1345828507 7685 1980268 569784714 60 1398
1345828509 7073 1979779 573489941 236 1411
</screen></para>
____________________________________________________________________________-->
  <para>
   这里是一些输出示例：
<screen>
1345828501 5601 1542744 483552416 61 2573
1345828503 7884 1979812 565806736 60 1479
1345828505 7208 1979422 567277552 59 1391
1345828507 7685 1980268 569784714 60 1398
1345828509 7073 1979779 573489941 236 1411
</screen></para>

<!--==========================orignal english content==========================
  <para>
   Notice that while the plain (unaggregated) log file shows which script
   was used for each transaction, the aggregated log does not. Therefore if
   you need per-script data, you need to aggregate the data on your own.
  </para>
____________________________________________________________________________-->
  <para>
   注意虽然纯（非聚合）日志文件显示为每个事务使用了哪个脚本，但聚合日志却不包含索引。因此如果你需要针对每个脚本的数据，你需要自行聚合数据。
  </para>

 </refsect2>

 <refsect2>
<!--==========================orignal english content==========================
  <title>Per-Statement Latencies</title>
____________________________________________________________________________-->
  <title>每语句延迟</title>

<!--==========================orignal english content==========================
  <para>
   With the <option>-r</option> option, <application>pgbench</application> collects
   the elapsed transaction time of each statement executed by every
   client.  It then reports an average of those values, referred to
   as the latency for each statement, after the benchmark has finished.
  </para>
____________________________________________________________________________-->
  <para>
   通过<option>-r</option>选项，<application>pgbench</application>收集每一个客户端执行的每一个语句花费的事务时间。然后在基准完成后，它会报告这些值的平均值，作为每个语句的延迟。
  </para>

<!--==========================orignal english content==========================
  <para>
   For the default script, the output will look similar to this:
<screen>
starting vacuum...end.
transaction type: &lt;builtin: TPC-B (sort of)&gt;
scaling factor: 1
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
latency average = 15.844 ms
latency stddev = 2.715 ms
tps = 618.764555 (including connections establishing)
tps = 622.977698 (excluding connections establishing)
statement latencies in milliseconds:
        0.002  \set aid random(1, 100000 * :scale)
        0.005  \set bid random(1, 1 * :scale)
        0.002  \set tid random(1, 10 * :scale)
        0.001  \set delta random(-5000, 5000)
        0.326  BEGIN;
        0.603  UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
        0.454  SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
        5.528  UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
        7.335  UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
        0.371  INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
        1.212  END;
</screen>
  </para>
____________________________________________________________________________-->
  <para>
   对于默认脚本，输出看起来会像这样：
<screen>
starting vacuum...end.
transaction type: &lt;builtin: TPC-B (sort of)&gt;
scaling factor: 1
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
latency average = 15.844 ms
latency stddev = 2.715 ms
tps = 618.764555 (including connections establishing)
tps = 622.977698 (excluding connections establishing)
statement latencies in milliseconds:
        0.002  \set aid random(1, 100000 * :scale)
        0.005  \set bid random(1, 1 * :scale)
        0.002  \set tid random(1, 10 * :scale)
        0.001  \set delta random(-5000, 5000)
        0.326  BEGIN;
        0.603  UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
        0.454  SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
        5.528  UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
        7.335  UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
        0.371  INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
        1.212  END;
</screen>
  </para>

<!--==========================orignal english content==========================
  <para>
   If multiple script files are specified, the averages are reported
   separately for each script file.
  </para>
____________________________________________________________________________-->
  <para>
   如果指定了多个脚本文件，会为每一个脚本文件单独报告平均值。
  </para>

<!--==========================orignal english content==========================
  <para>
   Note that collecting the additional timing information needed for
   per-statement latency computation adds some overhead.  This will slow
   average execution speed and lower the computed TPS.  The amount
   of slowdown varies significantly depending on platform and hardware.
   Comparing average TPS values with and without latency reporting enabled
   is a good way to measure if the timing overhead is significant.
  </para>
____________________________________________________________________________-->
  <para>
   注意为每个语句的延迟计算收集额外的时间信息会增加一些负荷。这将拖慢平均执行速度并且降低计算出的 TPS。降低的总量会很显著地依赖于平台和硬件。对比使用和不适用延迟报告时的平均 TPS 值是评估时间开销是否明显的好方法。
  </para>
 </refsect2>

 <refsect2>
<!--==========================orignal english content==========================
  <title>Good Practices</title>
____________________________________________________________________________-->
  <title>良好的做法</title>

<!--==========================orignal english content==========================
  <para>
   It is very easy to use <application>pgbench</application> to produce completely
   meaningless numbers.  Here are some guidelines to help you get useful
   results.
  </para>
____________________________________________________________________________-->
  <para>
   很容易使用<application>pgbench</application>产生完全没有意义的数字。这里有一些指导可以帮你得到有用的结果。
  </para>

<!--==========================orignal english content==========================
  <para>
   In the first place, <emphasis>never</emphasis> believe any test that runs
   for only a few seconds.  Use the <option>-t</option> or <option>-T</option> option
   to make the run last at least a few minutes, so as to average out noise.
   In some cases you could need hours to get numbers that are reproducible.
   It's a good idea to try the test run a few times, to find out if your
   numbers are reproducible or not.
  </para>
____________________________________________________________________________-->
  <para>
   排在第一位的是，<emphasis>永远不要</emphasis>相信任何只运行了几秒的测试。使用<option>-t</option>或<option>-T</option>选项让运行持续至少几分钟，这样可以用平均值去掉噪声。在一些情况中，你可能需要数小时来得到能重现的数字。多运行几次测试是一个好主意，这样可以看看你的数字是不是可以重现。
  </para>

<!--==========================orignal english content==========================
  <para>
   For the default TPC-B-like test scenario, the initialization scale factor
   (<option>-s</option>) should be at least as large as the largest number of
   clients you intend to test (<option>-c</option>); else you'll mostly be
   measuring update contention.  There are only <option>-s</option> rows in
   the <structname>pgbench_branches</structname> table, and every transaction wants to
   update one of them, so <option>-c</option> values in excess of <option>-s</option>
   will undoubtedly result in lots of transactions blocked waiting for
   other transactions.
  </para>
____________________________________________________________________________-->
  <para>
   对于默认的类 TPC-B 测试场景，初始化的比例因子（<option>-s</option>）应该至少和你想要测试的最大客户端数量一样大（<option>-c</option>），否则你将主要在度量更新争夺。在<structname>pgbench_branches</structname>表中只有<option>-s</option>行，并且每个事务都想更新其中之一，因此<option>-c</option>值超过<option>-s</option>将毫无疑问地导致大量事务被阻塞来等待其他事务。
  </para>

<!--==========================orignal english content==========================
  <para>
   The default test scenario is also quite sensitive to how long it's been
   since the tables were initialized: accumulation of dead rows and dead space
   in the tables changes the results.  To understand the results you must keep
   track of the total number of updates and when vacuuming happens.  If
   autovacuum is enabled it can result in unpredictable changes in measured
   performance.
  </para>
____________________________________________________________________________-->
  <para>
   默认的测试场景也对表被初始化了多久非常敏感：表中死亡行和死亡空间的累积会改变结果。要理解结果，你必须跟踪更新的总数以及何时发生清理。如果开启了自动清理，它可能会在度量的性能上产生不可预估的改变。
  </para>

<!--==========================orignal english content==========================
  <para>
   A limitation of <application>pgbench</application> is that it can itself become
   the bottleneck when trying to test a large number of client sessions.
   This can be alleviated by running <application>pgbench</application> on a different
   machine from the database server, although low network latency will be
   essential.  It might even be useful to run several <application>pgbench</application>
   instances concurrently, on several client machines, against the same
   database server.
  </para>
____________________________________________________________________________-->
  <para>
   <application>pgbench</application>的一个限制是在尝试测试大量客户端会话时，它自身可能成为瓶颈。这可以通过在数据库服务器之外的一台机器上运行<application>pgbench</application>来缓解，不过必须是具有低网络延迟的机器。甚至可以在多个客户端机器上针对同一个数据库服务器并发地运行多个<application>pgbench</application>实例。
  </para>
 </refsect2>
 <refsect2>
<!--==========================orignal english content==========================
  <title>Security</title>
____________________________________________________________________________-->
  <title>安全性</title>

<!--==========================orignal english content==========================
  <para>
    If untrusted users have access to a database that has not adopted a
    <link linkend="ddl-schemas-patterns">secure schema usage pattern</link>,
    do not run <application>pgbench</application> in that
    database.  <application>pgbench</application> uses unqualified names and
    does not manipulate the search path.
  </para>
____________________________________________________________________________-->
  <para>
    如果不可信用户能够访问没有采用<link linkend="ddl-schemas-patterns">安全方案使用模式</link>的数据库，不要在那个数据库中运行<application>pgbench</application>。<application>pgbench</application>使用非限定名称并且不会操纵搜索路径。
  </para>
 </refsect2>
 </refsect1>
</refentry>
