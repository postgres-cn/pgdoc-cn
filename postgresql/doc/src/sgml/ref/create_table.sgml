<!--
doc/src/sgml/ref/create_table.sgml
PostgreSQL documentation
-->

<refentry id="SQL-CREATETABLE">
 <refmeta>
  <refentrytitle>CREATE TABLE</refentrytitle>
  <manvolnum>7</manvolnum>
  <!--
<refmiscinfo>SQL - Language Statements</refmiscinfo>
-->
<refmiscinfo>SQL - 语句</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE TABLE</refname>
  <!--
  <refpurpose>define a new table</refpurpose>
  -->
  <refpurpose>定义一个新表</refpurpose>
 </refnamediv>

 <indexterm zone="sql-createtable">
  <primary>CREATE TABLE</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <replaceable class="PARAMETER">table_name</replaceable> ( [
  { <replaceable class="PARAMETER">column_name</replaceable> <replaceable class="PARAMETER">data_type</replaceable> [ COLLATE <replaceable>collation</replaceable> ] [ <replaceable class="PARAMETER">column_constraint</replaceable> [ ... ] ]
    | <replaceable>table_constraint</replaceable>
    | LIKE <replaceable>source_table</replaceable> [ <replaceable>like_option</replaceable> ... ] }
    [, ... ]
] )
[ INHERITS ( <replaceable>parent_table</replaceable> [, ... ] ) ]
[ WITH ( <replaceable class="PARAMETER">storage_parameter</replaceable> [= <replaceable class="PARAMETER">value</replaceable>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <replaceable class="PARAMETER">tablespace_name</replaceable> ]

CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <replaceable class="PARAMETER">table_name</replaceable>
    OF <replaceable class="PARAMETER">type_name</replaceable> [ (
  { <replaceable class="PARAMETER">column_name</replaceable> WITH OPTIONS [ <replaceable class="PARAMETER">column_constraint</replaceable> [ ... ] ]
    | <replaceable>table_constraint</replaceable> }
    [, ... ]
) ]
[ WITH ( <replaceable class="PARAMETER">storage_parameter</replaceable> [= <replaceable class="PARAMETER">value</replaceable>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <replaceable class="PARAMETER">tablespace_name</replaceable> ]

<!--
 <phrase>where <replaceable class="PARAMETER">column_constraint</replaceable> is:</phrase>
 -->
 <phrase>这里的<replaceable class="PARAMETER">column_constraint</replaceable>是:</phrase>

[ CONSTRAINT <replaceable class="PARAMETER">constraint_name</replaceable> ]
{ NOT NULL |
  NULL |
  CHECK ( <replaceable class="PARAMETER">expression</replaceable> ) [ NO INHERIT ] |
  DEFAULT <replaceable>default_expr</replaceable> |
  UNIQUE <replaceable class="PARAMETER">index_parameters</replaceable> |
  PRIMARY KEY <replaceable class="PARAMETER">index_parameters</replaceable> |
  REFERENCES <replaceable class="PARAMETER">reftable</replaceable> [ ( <replaceable class="PARAMETER">refcolumn</replaceable> ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]
    [ ON DELETE <replaceable class="parameter">action</replaceable> ] [ ON UPDATE <replaceable class="parameter">action</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<!--
 <phrase>and <replaceable class="PARAMETER">table_constraint</replaceable> is:</phrase>
 -->
 <phrase>而<replaceable class="PARAMETER">table_constraint</replaceable>是:</phrase>

[ CONSTRAINT <replaceable class="PARAMETER">constraint_name</replaceable> ]
{ CHECK ( <replaceable class="PARAMETER">expression</replaceable> ) [ NO INHERIT ] |
  UNIQUE ( <replaceable class="PARAMETER">column_name</replaceable> [, ... ] ) <replaceable class="PARAMETER">index_parameters</replaceable> |
  PRIMARY KEY ( <replaceable class="PARAMETER">column_name</replaceable> [, ... ] ) <replaceable class="PARAMETER">index_parameters</replaceable> |
  EXCLUDE [ USING <replaceable class="parameter">index_method</replaceable> ] ( <replaceable class="parameter">exclude_element</replaceable> WITH <replaceable class="parameter">operator</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> [ WHERE ( <replaceable class="parameter">predicate</replaceable> ) ] |
  FOREIGN KEY ( <replaceable class="PARAMETER">column_name</replaceable> [, ... ] ) REFERENCES <replaceable class="PARAMETER">reftable</replaceable> [ ( <replaceable class="PARAMETER">refcolumn</replaceable> [, ... ] ) ]
    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE <replaceable class="parameter">action</replaceable> ] [ ON UPDATE <replaceable class="parameter">action</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<!--
 <phrase>and <replaceable class="PARAMETER">like_option</replaceable> is:</phrase>
 -->
 <phrase><replaceable class="PARAMETER">like_option</replaceable>是:</phrase>

{ INCLUDING | EXCLUDING } { DEFAULTS | CONSTRAINTS | INDEXES | STORAGE | COMMENTS | ALL }

<!--
 <phrase><replaceable class="PARAMETER">index_parameters</replaceable> in <literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal>, and <literal>EXCLUDE</literal> constraints are:</phrase>
 -->
 <phrase>在<literal>UNIQUE</literal>、<literal>PRIMARY KEY</literal>和
 <literal>EXCLUDE</literal>约束中的<replaceable class="PARAMETER">index_parameters</replaceable>是:</phrase>

[ WITH ( <replaceable class="PARAMETER">storage_parameter</replaceable> [= <replaceable class="PARAMETER">value</replaceable>] [, ... ] ) ]
[ USING INDEX TABLESPACE <replaceable class="PARAMETER">tablespace_name</replaceable> ]

<phrase><replaceable class="PARAMETER">exclude_element</replaceable> in an <literal>EXCLUDE</literal> constraint is:</phrase>

{ <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ <replaceable class="parameter">opclass</replaceable> ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ]
</synopsis>

 </refsynopsisdiv>

 <refsect1 id="SQL-CREATETABLE-description">
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <command>CREATE TABLE</command> will create a new, initially empty table
   in the current database. The table will be owned by the user issuing the
   command.
  </para>
-->
<para>
<command>CREATE TABLE</command>在当前数据库创建一个新的空白表。
该表将由发出此命令的用户所拥有。
</para>

  <!--
<para>
   If a schema name is given (for example, <literal>CREATE TABLE
   myschema.mytable ...</>) then the table is created in the specified
   schema.  Otherwise it is created in the current schema.  Temporary
   tables exist in a special schema, so a schema name cannot be given
   when creating a temporary table.  The name of the table must be
   distinct from the name of any other table, sequence, index, view,
   or foreign table in the same schema.
  </para>
-->
<para>
如果给出了模式名(比如<literal>CREATE TABLE myschema.mytable ...</>)，
那么在指定的模式中创建表，否则在当前模式中创建。临时表存在于一个特殊的模式里，
因此创建临时表的时候不能指定模式名。表名字必需在同一模式中的其它表、
序列、索引、视图或外部表名字中唯一。
</para>

  <!--
<para>
   <command>CREATE TABLE</command> also automatically creates a data
   type that represents the composite type corresponding
   to one row of the table.  Therefore, tables cannot have the same
   name as any existing data type in the same schema.
  </para>
-->
<para>
<command>CREATE TABLE</command>还自动创建一个与该表的行对应的复合数据类型。
因此，表不能和同模式中的现有数据类型同名。
</para>

  <!--
<para>
   The optional constraint clauses specify constraints (tests) that
   new or updated rows must satisfy for an insert or update operation
   to succeed.  A constraint is an SQL object that helps define the
   set of valid values in the table in various ways.
  </para>
-->
<para>
可选的约束子句声明约束，新行或者更新的行必须满足这些约束才能成功插入或更新。
约束是一个 SQL 对象，它以多种方式协助在表上定义有效数值的集合。
</para>

  <!--
<para>
   There are two ways to define constraints: table constraints and
   column constraints.  A column constraint is defined as part of a
   column definition.  A table constraint definition is not tied to a
   particular column, and it can encompass more than one column.
   Every column constraint can also be written as a table constraint;
   a column constraint is only a notational convenience for use when the
   constraint only affects one column.
  </para>
-->
<para>
定义约束有两种方法：表约束和列约束。列约束是作为一个列定义的一部分定义的。
而表约束并不和某个列绑在一起，它可以作用于多个列上。每个列约束也可以写成表约束；
如果某个约束只影响一个列，那么列约束只是符号上的简洁方式而已。
</para>

  <!--
<para>
   To be able to create a table, you must have <literal>USAGE</literal>
   privilege on all column types or the type in the <literal>OF</literal>
   clause, respectively.
  </para>
-->
<para>
要能创建一个表，你必须分别在所有列类型或<literal>OF</literal>
子句的类型上有<literal>USAGE</literal>权限。
</para>
 </refsect1>

 <refsect1>
  <!--
<title>Parameters</title>
-->
<title>参数</title>

  <variablelist>

   <varlistentry>
    <!--
<term><literal>TEMPORARY</> or <literal>TEMP</></term>
-->
<term><literal>TEMPORARY</> 或 <literal>TEMP</></term>
    <listitem>
     <!--
<para>
      If specified, the table is created as a temporary table.
      Temporary tables are automatically dropped at the end of a
      session, or optionally at the end of the current transaction
      (see <literal>ON COMMIT</literal> below).  Existing permanent
      tables with the same name are not visible to the current session
      while the temporary table exists, unless they are referenced
      with schema-qualified names. Any indexes created on a temporary
      table are automatically temporary as well.
     </para>
-->
<para>
如果声明了，则创建为临时表。临时表在会话结束或(可选)当前事务的结尾
(参阅下面的<literal>ON COMMIT</literal>)自动删除。除非用模式修饰的名字引用，
否则现有的同名永久表在临时表存在期间，在本会话过程中是不可见的。
任何在临时表上创建的索引也都会被自动删除。
</para>

     <!--
<para>
      The <link linkend="autovacuum">autovacuum daemon</link> cannot
      access and therefore cannot vacuum or analyze temporary tables.
      For this reason, appropriate vacuum and analyze operations should be
      performed via session SQL commands.  For example, if a temporary
      table is going to be used in complex queries, it is wise to run
      <command>ANALYZE</> on the temporary table after it is populated.
     </para>
-->
<para>
<link linkend="autovacuum">自动清理进程</link>不能访问，因此不能清理或分析临时表。
由于这个原因，适当的清理和分析操作应该通过会话SQL命令来执行。例如，
如果一个临时表用于复杂查询中，那么在填充临时表之后在临时表上运行
<command>ANALYZE</>是明智的。
</para>

     <!--
<para>
      Optionally, <literal>GLOBAL</literal> or <literal>LOCAL</literal>
      can be written before <literal>TEMPORARY</> or <literal>TEMP</>.
      This presently makes no difference in <productname>PostgreSQL</>
      and is deprecated; see
      <xref linkend="sql-createtable-compatibility"
      endterm="sql-createtable-compatibility-title">.
     </para>
-->
<para>
可以选择在<literal>TEMPORARY</>或<literal>TEMP</>前面放上<literal>GLOBAL</literal>
或<literal>LOCAL</literal>。不过这目前对<productname>PostgreSQL</>来说没有任何区别，
并且已经废弃了；可以参阅<xref linkend="sql-createtable-compatibility"
      endterm="sql-createtable-compatibility-title">。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>UNLOGGED</></term>
    <listitem>
     <!--
<para>
      If specified, the table is created as an unlogged table.  Data written
      to unlogged tables is not written to the write-ahead log (see <xref
      linkend="wal">), which makes them considerably faster than ordinary
      tables.  However, they are not crash-safe: an unlogged table is
      automatically truncated after a crash or unclean shutdown.  The contents
      of an unlogged table are also not replicated to standby servers.
      Any indexes created on an unlogged table are automatically unlogged as
      well.
     </para>
-->
<para>
如果指定了，则表作为非日志表来创建。写入到非日志表中的数据并不写入预写式日志
（参阅<xref linkend="wal">），这使得他们比普通表快的多。不过，
他们不是崩溃安全的：一个非日志表在崩溃或不清理关机之后被自动截断。
非日志表的内容也不复制到备用服务器。任何在非日志表上创建的索引也自动是非日志的。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>IF NOT EXISTS</></term>
    <listitem>
     <!--
<para>
      Do not throw an error if a relation with the same name already exists.
      A notice is issued in this case.  Note that there is no guarantee that
      the existing relation is anything like the one that would have been
      created.
     </para>
-->
<para>
如果同名的关系已经存在，那么不要抛出一个错误。在这种情况下发出一个通知。
请注意，不保证已经存在的关系和要创建的关系相像。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">table_name</replaceable></term>
    <listitem>
     <!--
<para>
      The name (optionally schema-qualified) of the table to be created.
     </para>
-->
<para>
要创建的表的名字(可以用模式修饰)
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OF <replaceable class="PARAMETER">type_name</replaceable></literal></term>
    <listitem>
     <!--
<para>
      Creates a <firstterm>typed table</firstterm>, which takes its
      structure from the specified composite type (name optionally
      schema-qualified).  A typed table is tied to its type; for
      example the table will be dropped if the type is dropped
      (with <literal>DROP TYPE ... CASCADE</literal>).
     </para>
-->
<para>
创建一个<firstterm>类型化的表</firstterm>，它的结构来自指定的复合类型
（名字可以有模式修饰）。一个类型化的表绑定到它的类型；
例如，如果类型被删除（使用<literal>DROP TYPE ... CASCADE</literal>），
则该表也将被删除。
</para>

     <!--
<para>
      When a typed table is created, then the data types of the
      columns are determined by the underlying composite type and are
      not specified by the <literal>CREATE TABLE</literal> command.
      But the <literal>CREATE TABLE</literal> command can add defaults
      and constraints to the table and can specify storage parameters.
     </para>
-->
<para>
当类型化的表被创建时，字段的数据类型取决于底层复合类型，
而不是通过<literal>CREATE TABLE</literal>命令指定。
但是<literal>CREATE TABLE</literal>命令可以给表添加缺省和约束，
并且可以指定存储参数。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">column_name</replaceable></term>
    <listitem>
     <!--
<para>
      The name of a column to be created in the new table.
     </para>
-->
<para>
在新表中要创建的字段名字。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">data_type</replaceable></term>
    <listitem>
     <!--
<para>
      The data type of the column. This can include array
      specifiers. For more information on the data types supported by
      <productname>PostgreSQL</productname>, refer to <xref
      linkend="datatype">.
     </para>
-->
<para>
该字段的数据类型。它可以包括数组说明符。有关<productname>PostgreSQL</productname>
支持的数据类型的更多信息，请参考<xref linkend="datatype">。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>COLLATE <replaceable>collation</replaceable></literal></term>
    <listitem>
     <!--
<para>
      The <literal>COLLATE</> clause assigns a collation to
      the column (which must be of a collatable data type).
      If not specified, the column data type's default collation is used.
     </para>
-->
<para>
<literal>COLLATE</>给字段（必须是可排序的数据类型）分配一个排序规则。
如果没有指定，则使用字段数据类型的缺省排序。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>INHERITS ( <replaceable>parent_table</replaceable> [, ... ] )</literal></term>
    <listitem>
     <!--
<para>
      The optional <literal>INHERITS</> clause specifies a list of
      tables from which the new table automatically inherits all
      columns.
     </para>
-->
<para>
可选的<literal>INHERITS</>子句声明一系列的表，新表自动从这一系列表中继承所有字段。
</para>

     <!--
<para>
      Use of <literal>INHERITS</> creates a persistent relationship
      between the new child table and its parent table(s).  Schema
      modifications to the parent(s) normally propagate to children
      as well, and by default the data of the child table is included in
      scans of the parent(s).
     </para>
-->
<para>
使用<literal>INHERITS</>将在新的子表和其父表之间创建一个永久的关系。
对父表结构的修改通常也会传播到子表。缺省时，扫描父表的时候也会扫描子表。
</para>

     <!--
<para>
      If the same column name exists in more than one parent
      table, an error is reported unless the data types of the columns
      match in each of the parent tables.  If there is no conflict,
      then the duplicate columns are merged to form a single column in
      the new table.  If the column name list of the new table
      contains a column name that is also inherited, the data type must
      likewise match the inherited column(s), and the column
      definitions are merged into one.  If the
      new table explicitly specifies a default value for the column,
      this default overrides any defaults from inherited declarations
      of the column.  Otherwise, any parents that specify default
      values for the column must all specify the same default, or an
      error will be reported.
     </para>
-->
<para>
如果在多个父表中存在同名字段，那么就会报告一个错误，
除非这些字段的数据类型在每个父表里都是匹配的。如果没有冲突，
那么重复的字段在新表中融合成一个字段。如果列出的新表字段名和继承字段同名，
那么它的数据类型也必须和继承字段匹配，并且这些字段定义会融合成一个。
如果新表为该字段明确声明了缺省值，那么此缺省值将覆盖任何继承字段的缺省值。
否则，该字段的所有父字段缺省值都必须相同，否则就会报错。
</para>

     <!--
<para><literal>CHECK</> constraints are merged in essentially the same way as
      columns: if multiple parent tables and/or the new table definition
      contain identically-named <literal>CHECK</> constraints, these
      constraints must all have the same check expression, or an error will be
      reported.  Constraints having the same name and expression will
      be merged into one copy.  A constraint marked <literal>NO INHERIT</> in a
      parent will not be considered.  Notice that an unnamed <literal>CHECK</>
      constraint in the new table will never be merged, since a unique name
      will always be chosen for it.
     </para>
-->
<para>
<literal>CHECK</>约束本质上以和字段一样的方式合并：如果多个父表和/或新表的定义包含相同名字的
<literal>CHECK</>约束，那么这些约束必须都有相同的检查表达式，否则会报告一个错误。
有相同名字和表达式的约束将合并到一个。在父表中标记为<literal>NO INHERIT</>
的约束将不被考虑。请注意，新表中未命名的<literal>CHECK</>约束将永远不被合并，
因为它将永远都有一个唯一的名字。
</para>

     <!--
<para>
      Column <literal>STORAGE</> settings are also copied from parent tables.
     </para>
-->
<para>
字段<literal>STORAGE</>设置也从父表中拷贝。
</para>

    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>LIKE <replaceable>source_table</replaceable> [ <replaceable>like_option</replaceable> ... ]</literal></term>
    <listitem>
     <!--
<para>
      The <literal>LIKE</literal> clause specifies a table from which
      the new table automatically copies all column names, their data types,
      and their not-null constraints.
     </para>
-->
<para>
<literal>LIKE</literal>子句声明一个表，
新表自动从这个表里面继承所有字段名及其数据类型和非空约束。
</para>
     <!--
<para>
      Unlike <literal>INHERITS</literal>, the new table and original table
      are completely decoupled after creation is complete.  Changes to the
      original table will not be applied to the new table, and it is not
      possible to include data of the new table in scans of the original
      table.
     </para>
-->
<para>
和<literal>INHERITS</literal>不同，新表与原来的表之间在创建动作完毕之后是完全无关的。
在源表做的任何修改都不会传播到新表中，并且也不可能在扫描源表的时候包含新表的数据。
</para>
     <!--
<para>
      Default expressions for the copied column definitions will only be
      copied if <literal>INCLUDING DEFAULTS</literal> is specified.  The
      default behavior is to exclude default expressions, resulting in the
      copied columns in the new table having null defaults.
     </para>
-->
<para>
字段缺省表达式只有在声明了<literal>INCLUDING DEFAULTS</literal>之后才会包含进来。
缺省是不包含缺省表达式的，结果是新表中所有字段的缺省值都是 NULL 。
</para>
     <!--
<para>
      Not-null constraints are always copied to the new table.
      <literal>CHECK</literal> constraints will be copied only if
      <literal>INCLUDING CONSTRAINTS</literal> is specified.
      Indexes, <literal>PRIMARY KEY</>, and <literal>UNIQUE</> constraints
      on the original table will be created on the new table only if the
      <literal>INCLUDING INDEXES</literal> clause is specified.
      No distinction is made between column constraints and table
      constraints.
     </para>
-->
<para>
非空约束将总是复制到新表中，<literal>CHECK</literal>约束则仅在指定了
<literal>INCLUDING CONSTRAINTS</literal>的时候才复制。源表上的索引、
<literal>PRIMARY KEY</>和<literal>UNIQUE</>约束仅在指定了
<literal>INCLUDING INDEXES</literal>子句的时候才在新表上创建。
此规则同时适用于表约束和列约束。
</para>
     <!--
<para><literal>STORAGE</> settings for the copied column definitions will only
      be copied if <literal>INCLUDING STORAGE</literal> is specified.  The
      default behavior is to exclude <literal>STORAGE</> settings, resulting
      in the copied columns in the new table having type-specific default
      settings.  For more on <literal>STORAGE</> settings, see
      <xref linkend="storage-toast">.
     </para>
-->
<para>
拷贝字段定义的<literal>STORAGE</>设置只在声明了<literal>INCLUDING STORAGE</literal>
的时候才拷贝。缺省是不包括<literal>STORAGE</>设置的，
结果是新表中的拷贝字段有特定类型的缺省设置。关于<literal>STORAGE</>
设置的更多信息，请参阅<xref linkend="storage-toast">。
</para>
     <!--
<para>
      Comments for the copied columns, constraints, and indexes
      will only be copied if <literal>INCLUDING COMMENTS</literal>
      is specified. The default behavior is to exclude comments, resulting in
      the copied columns and constraints in the new table having no comments.
     </para>
-->
<para>
拷贝字段、约束和索引的注释只在声明了<literal>INCLUDING COMMENTS</literal>
的时候拷贝。缺省是不包含注释的，结果是新表中拷贝的字段和约束没有注释。
</para>
     <!--
<para><literal>INCLUDING ALL</literal> is an abbreviated form of
      <literal>INCLUDING DEFAULTS INCLUDING CONSTRAINTS INCLUDING INDEXES INCLUDING STORAGE INCLUDING COMMENTS</literal>.
     </para>
-->
<para>
<literal>INCLUDING ALL</literal>是<literal>INCLUDING DEFAULTS INCLUDING CONSTRAINTS INCLUDING INDEXES INCLUDING STORAGE INCLUDING COMMENTS</literal>
的一个简写形式。
</para>
     <!--
<para>
      Note also that unlike <literal>INHERITS</literal>, columns and
      constraints copied by <literal>LIKE</> are not merged with similarly
      named columns and constraints.
      If the same name is specified explicitly or in another
      <literal>LIKE</literal> clause, an error is signaled.
     </para>
-->
<para>
请注意，和<literal>INHERITS</literal>不同，通过<literal>LIKE</>
拷贝的列和约束并不使用相同的名字进行融合。
如果明确的指定了相同的名字或者在另外一个<literal>LIKE</literal>子句中，那么将会报错。
</para>
     <!--
<para>
      The <literal>LIKE</literal> clause can also be used to copy columns from
      views, foreign tables, or composite types.  Inapplicable options (e.g., <literal>INCLUDING
      INDEXES</literal> from a view) are ignored.
     </para>
-->
<para>
<literal>LIKE</literal>子句也可以用来从视图、外表或复合类型中拷贝字段。
不适用的选项（如，从一个视图中<literal>INCLUDING INDEXES</literal>）都被忽略。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CONSTRAINT <replaceable class="PARAMETER">constraint_name</replaceable></literal></term>
    <listitem>
     <!--
<para>
      An optional name for a column or table constraint.  If the
      constraint is violated, the constraint name is present in error messages,
      so constraint names like <literal>col must be positive</> can be used
      to communicate helpful constraint information to client applications.
      (Double-quotes are needed to specify constraint names that contain spaces.)
      If a constraint name is not specified, the system generates a name.
     </para>
-->
<para>
可选的列约束或表约束的名字。如果约束本身是非法的，那么其名字将会出现在错误消息中，
因此像<literal>col must be positive</>这样的名字可以表达有用的约束信息。
如果约束名中含有空格则必须用双引号界定。如果没有指定约束名，那么系统将会自动生成一个名字。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NOT NULL</></term>
    <listitem>
     <!--
<para>
      The column is not allowed to contain null values.
     </para>
-->
<para>
字段不允许包含 NULL 值
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NULL</></term>
    <listitem>
     <!--
<para>
      The column is allowed to contain null values. This is the default.
     </para>
-->
<para>
字段允许包含 NULL 值，这是缺省。
</para>

     <!--
<para>
      This clause is only provided for compatibility with
      non-standard SQL databases.  Its use is discouraged in new
      applications.
     </para>
-->
<para>
这个子句的存在只是为和那些非标准 SQL 数据库兼容。不建议在新应用中使用它。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CHECK ( <replaceable class="PARAMETER">expression</replaceable> ) [ NO INHERIT ] </literal></term>
    <listitem>
     <!--
<para>
      The <literal>CHECK</> clause specifies an expression producing a
      Boolean result which new or updated rows must satisfy for an
      insert or update operation to succeed.  Expressions evaluating
      to TRUE or UNKNOWN succeed.  Should any row of an insert or
      update operation produce a FALSE result an error exception is
      raised and the insert or update does not alter the database.  A
      check constraint specified as a column constraint should
      reference that column's value only, while an expression
      appearing in a table constraint can reference multiple columns.
     </para>
-->
<para>
<literal>CHECK</>约束声明一个生成布尔结果的表达式，
每次将要插入的新行或者将要被更新的行必须使表达式结果为真或未知才能成功，
否则会抛出一个异常并且不会修改数据库。
声明为字段约束的检查约束应该只引用该字段的数值，
而在表约束里出现的表达式可以引用多个字段。
</para>

     <!--
<para>
      Currently, <literal>CHECK</literal> expressions cannot contain
      subqueries nor refer to variables other than columns of the
      current row.
     </para>
-->
<para>
目前，<literal>CHECK</literal>表达式不能包含子查询也不能引用除当前行字段之外的变量。
</para>

     <!--
<para>
      A constraint marked with <literal>NO INHERIT</> will not propagate to
      child tables.
     </para>
-->
<para>
用<literal>NO INHERIT</>标记的约束将不会传递到子表中去。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DEFAULT
    <replaceable>default_expr</replaceable></literal></term>
    <listitem>
     <!--
<para>
      The <literal>DEFAULT</> clause assigns a default data value for
      the column whose column definition it appears within.  The value
      is any variable-free expression (subqueries and cross-references
      to other columns in the current table are not allowed).  The
      data type of the default expression must match the data type of the
      column.
     </para>
-->
<para>
<literal>DEFAULT</>子句给字段指定缺省值。该数值可以是任何不含变量的表达式
(不允许使用子查询和对本表中的其它字段的交叉引用)。
缺省表达式的数据类型必须和字段类型匹配。
</para>

     <!--
<para>
      The default expression will be used in any insert operation that
      does not specify a value for the column.  If there is no default
      for a column, then the default is null.
     </para>
-->
<para>
缺省表达式将被用于任何未声明该字段数值的插入操作。
如果没有指定缺省值则缺省值为 NULL 。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>UNIQUE</> (column constraint)</term>
    <term><literal>UNIQUE ( <replaceable class="PARAMETER">column_name</replaceable> [, ... ] )</> (table constraint)</term>

    <listitem>
     <!--
<para>
      The <literal>UNIQUE</literal> constraint specifies that a
      group of one or more columns of a table can contain
      only unique values. The behavior of the unique table constraint
      is the same as that for column constraints, with the additional
      capability to span multiple columns.
     </para>
-->
<para>
<literal>UNIQUE</literal>约束表示表里的一个或多个字段的组合必须在全表范围内唯一。
唯一约束的行为和列约束一样，只不过多了跨多行的能力。
</para>

     <!--
<para>
      For the purpose of a unique constraint, null values are not
      considered equal.
     </para>
-->
<para>
对于唯一约束而言，NULL 被认为是互不相等的。
</para>

     <!--
<para>
      Each unique table constraint must name a set of columns that is
      different from the set of columns named by any other unique or
      primary key constraint defined for the table.  (Otherwise it
      would just be the same constraint listed twice.)
     </para>
-->
<para>
每个唯一约束都必须给其使用的字段集合赋予一个与其它唯一约束都不同的名字，
并且也不能和主键约束的名字相同，否则就被认为是同样的约束写了两次。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>PRIMARY KEY</> (column constraint)</term>
    <term><literal>PRIMARY KEY ( <replaceable class="PARAMETER">column_name</replaceable> [, ... ] )</> (table constraint)</term>
    <listitem>
     <!--
<para>
      The primary key constraint specifies that a column or columns of a table
      can contain only unique (non-duplicate), nonnull values.
      Technically, <literal>PRIMARY KEY</literal> is merely a
      combination of <literal>UNIQUE</> and <literal>NOT NULL</>, but
      identifying a set of columns as primary key also provides
      metadata about the design of the schema, as a primary key
      implies that other tables
      can rely on this set of columns as a unique identifier for rows.
     </para>
-->
<para>
主键约束表明表中的一个或者一些字段只能包含唯一(不重复)的非 NULL 值。
从技术上讲，<literal>PRIMARY KEY</literal>只是<literal>UNIQUE</>
和<literal>NOT NULL</>的组合，不过把一套字段标识为主键同时也体现了模式设计的元数据，
因为主键意味着可以拿这套字段用做行的唯一标识。
</para>

     <!--
<para>
      Only one primary key can be specified for a table, whether as a
      column constraint or a table constraint.
     </para>
-->
<para>
一个表只能声明一个主键，不管是作为字段约束还是表约束。
</para>

     <!--
<para>
      The primary key constraint should name a set of columns that is
      different from other sets of columns named by any unique
      constraint defined for the same table.
     </para>
-->
<para>
主键约束使用的字段集合应该与其它唯一约束都不同。
</para>
    </listitem>
   </varlistentry>

   <varlistentry id="SQL-CREATETABLE-EXCLUDE">
    <term><literal>EXCLUDE [ USING <replaceable class="parameter">index_method</replaceable> ] ( <replaceable class="parameter">exclude_element</replaceable> WITH <replaceable class="parameter">operator</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> [ WHERE ( <replaceable class="parameter">predicate</replaceable> ) ]</literal></term>
    <listitem>
     <!--
<para>
      The <literal>EXCLUDE</> clause defines an exclusion
      constraint, which guarantees that if
      any two rows are compared on the specified column(s) or
      expression(s) using the specified operator(s), not all of these
      comparisons will return <literal>TRUE</>.  If all of the
      specified operators test for equality, this is equivalent to a
      <literal>UNIQUE</> constraint, although an ordinary unique constraint
      will be faster.  However, exclusion constraints can specify
      constraints that are more general than simple equality.
      For example, you can specify a constraint that
      no two rows in the table contain overlapping circles
      (see <xref linkend="datatype-geometric">) by using the
      <literal>&amp;&amp;</> operator.
     </para>
-->
<para>
<literal>EXCLUDE</>子句定义一个排除约束，保证了两个行在指定的字段或使用指定操作符的表达式上比较时，
并不都返回<literal>TRUE</>。如果所有指定的操作符测试都相等，
那么就等同于<literal>UNIQUE</>约束，尽管一个普通的唯一约束会更快速。
不过，排除约束可以指定比简单相等更普通的约束。例如，
你可以通过使用<literal>&amp;&amp;</>操作符指定一个约束，
在一个表中没有两个行包含重叠的圆圈(参阅<xref linkend="datatype-geometric">)。
</para>

     <!--
<para>
      Exclusion constraints are implemented using
      an index, so each specified operator must be associated with an
      appropriate operator class
      (see <xref linkend="indexes-opclass">) for the index access
      method <replaceable>index_method</>.
      The operators are required to be commutative.
      Each <replaceable class="parameter">exclude_element</replaceable>
      can optionally specify an operator class and/or ordering options;
      these are described fully under
      <xref linkend="sql-createindex">.
     </para>
-->
<para>
排除约束是使用索引实现的，所以每个指定的操作符都必须和索引访问方法的一个合适的操作符类
（参阅<xref linkend="indexes-opclass">）相关。要求操作符是可交换的。
每个<replaceable class="parameter">exclude_element</replaceable>
可以指定一个操作符类和/或排序选项；这些在<xref linkend="sql-createindex">中有充分的描述。
</para>

     <!--
<para>
      The access method must support <literal>amgettuple</> (see <xref
      linkend="indexam">); at present this means <acronym>GIN</>
      cannot be used.  Although it's allowed, there is little point in using
      B-tree or hash indexes with an exclusion constraint, because this
      does nothing that an ordinary unique constraint doesn't do better.
      So in practice the access method will always be <acronym>GiST</> or
      <acronym>SP-GiST</>.
     </para>
-->
<para>
访问方法必须支持<literal>amgettuple</> (参阅<xref linkend="indexam">)；
目前，这意味着不能使用<acronym>GIN</>。尽管允许使用，
但是在排除约束中使用B-tree或哈希索引没什么意义，
因为一个普通唯一约束做的更好。所以实际中，访问方法总是<acronym>GiST</>
或<acronym>SP-GiST</>。
</para>

     <!--
<para>
      The <replaceable class="parameter">predicate</> allows you to specify an
      exclusion constraint on a subset of the table; internally this creates a
      partial index. Note that parentheses are required around the predicate.
     </para>
-->
<para>
<replaceable class="parameter">predicate</>允许在表的子集上声明一个排除约束；
在内部这创建了一个部分索引。请注意，谓语需要有括号包围。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>REFERENCES <replaceable class="parameter">reftable</replaceable> [ ( <replaceable class="parameter">refcolumn</replaceable> ) ] [ MATCH <replaceable class="parameter">matchtype</replaceable> ] [ ON DELETE <replaceable class="parameter">action</replaceable> ] [ ON UPDATE <replaceable class="parameter">action</replaceable> ]</literal> (column constraint)</term>

   <term><literal>FOREIGN KEY ( <replaceable class="parameter">column_name</replaceable> [, ... ] )
    REFERENCES <replaceable class="parameter">reftable</replaceable> [ ( <replaceable class="parameter">refcolumn</replaceable> [, ... ] ) ]
    [ MATCH <replaceable class="parameter">matchtype</replaceable> ]
    [ ON DELETE <replaceable class="parameter">action</replaceable> ]
    [ ON UPDATE <replaceable class="parameter">action</replaceable> ]</literal>
    (table constraint)</term>

    <listitem>
     <!--
<para>
      These clauses specify a foreign key constraint, which requires
      that a group of one or more columns of the new table must only
      contain values that match values in the referenced
      column(s) of some row of the referenced table.  If the <replaceable
      class="parameter">refcolumn</replaceable> list is omitted, the
      primary key of the <replaceable class="parameter">reftable</replaceable>
      is used.  The referenced columns must be the columns of a non-deferrable
      unique or primary key constraint in the referenced table.  Note that
      foreign key constraints cannot be defined between temporary tables and
      permanent tables.
     </para>
-->
<para>
这些子句声明一个外键约束，外键约束要求新表中一列或多列组成的组应该只包含
匹配被参考的表中对应字段中的值。如果省略<replaceable
      class="parameter">refcolumn</replaceable>，则使用
<replaceable class="parameter">reftable</replaceable>的主键。
被参考字段必须是被参考表中的唯一字段或者主键。请注意，
不能在临时表和永久表之间定义外键约束。
</para>

     <!--
<para>
      A value inserted into the referencing column(s) is matched against the
      values of the referenced table and referenced columns using the
      given match type.  There are three match types: <literal>MATCH
      FULL</>, <literal>MATCH PARTIAL</>, and <literal>MATCH
      SIMPLE</literal> (which is the default).  <literal>MATCH
      FULL</> will not allow one column of a multicolumn foreign key
      to be null unless all foreign key columns are null; if they are all
      null, the row is not required to have a match in the referenced table.
      <literal>MATCH SIMPLE</literal> allows any of the foreign key columns
      to be null; if any of them are null, the row is not required to have a
      match in the referenced table.
      <literal>MATCH PARTIAL</> is not yet implemented.
      (Of course, <literal>NOT NULL</> constraints can be applied to the
      referencing column(s) to prevent these cases from arising.)
     </para>
-->
<para>
向参考字段插入的数值将使用给出的匹配类型与被参考表中被参考列的数值进行匹配。
有三种匹配类型：<literal>MATCH FULL</>, <literal>MATCH PARTIAL</>,
<literal>MATCH SIMPLE</literal>(缺省)。<literal>MATCH FULL</>
不允许一个多字段外键的字段为 NULL ，除非所有外键字段都为 NULL；
如果都是NULL，那么该行在引用的表中不需要有匹配。<literal>MATCH SIMPLE</literal>
允许任意外键字段为 NULL；如果都是NULL，那么该行在引用的表中不需要有匹配。
<literal>MATCH PARTIAL</>目前尚未实现。（当然，<literal>NOT NULL</>
约束可以应用于引用字段，以阻止这些情况的发生。）
</para>

     
<para>
<!-- 
      In addition, when the data in the referenced columns is changed,
      certain actions are performed on the data in this table's
      columns.  The <literal>ON DELETE</literal> clause specifies the
      action to perform when a referenced row in the referenced table is
      being deleted.  Likewise, the <literal>ON UPDATE</literal>
      clause specifies the action to perform when a referenced column
      in the referenced table is being updated to a new value. If the
      row is updated, but the referenced column is not actually
      changed, no action is done. Referential actions other than the
      <literal>NO ACTION</literal> check cannot be deferred, even if
      the constraint is declared deferrable. There are the following possible
      actions for each clause: 
-->
另外，当被参考字段中的数据改变的时候，那么将对本表的字段中的数据执行某种操作。
<literal>ON DELETE</literal>子句声明当被参考表中的被参考行被删除的时候要执行的操作。
类似的，<literal>ON UPDATE</literal>子句声明被参考表中被参考字段更新为新值的时候要执行的动作。
如果该行被更新，但被参考的字段实际上没有变化，那么就不会有任何动作。
除了<literal>NO ACTION</literal>检查之外的其他参考动作都不能推迟，
即使该约束声明为可推迟也是如此。下面是每个子句的可能动作：

      <variablelist>
       <varlistentry>
        <term><literal>NO ACTION</literal></term>
        <listitem>
<!--
         <para>
          Produce an error indicating that the deletion or update
          would create a foreign key constraint violation.
          If the constraint is deferred, this
          error will be produced at constraint check time if there still
          exist any referencing rows.  This is the default action.
         </para>
-->
<para>
生成一个错误，表明删除或更新将产生一个违反外键约束的动作。
如果该约束是可推迟的，并且如果还存在任何引用行，那么这个错误将在检查约束的时候生成。
这是缺省动作。
</para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>RESTRICT</literal></term>
        <listitem>
         <!--
<para>
          Produce an error indicating that the deletion or update
          would create a foreign key constraint violation.
          This is the same as <literal>NO ACTION</literal> except that
          the check is not deferrable.
         </para>
-->
<para>
生成一个表明删除或更新将导致违反外键约束的错误。
和<literal>NO ACTION</literal>一样，只是动作不可推迟。
</para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>CASCADE</literal></term>
        <listitem>
         <!--
<para>
          Delete any rows referencing the deleted row, or update the
          values of the referencing column(s) to the new values of the
          referenced columns, respectively.
         </para>
-->
<para>
删除任何引用了被删除行的行，或者分别把引用行的字段值更新为被参考字段的新数值。
</para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>SET NULL</literal></term>
        <listitem>
         <!--
<para>
          Set the referencing column(s) to null.
         </para>
-->
<para>
把引用行设置为 NULL 。
</para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>SET DEFAULT</literal></term>
        <listitem>
         <!--
<para>
          Set the referencing column(s) to their default values.
          (There must be a row in the referenced table matching the default
          values, if they are not null, or the operation will fail.)
         </para>
-->
<para>
把引用字段设置为它们的缺省值。（如果他们为非空，那么被引用的表中必须有一行匹配缺省值，
否则该操作将会失败。）
</para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>

     <!--
<para>
      If the referenced column(s) are changed frequently, it might be wise to
      add an index to the referencing column(s) so that referential actions
      associated with the foreign key constraint can be performed more
      efficiently.
     </para>
-->
<para>
如果被参考字段经常更新，那么给引用字段增加一个索引可能是合适的，
这样与外键约束相关联的引用动作可以更有效地执行。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DEFERRABLE</literal></term>
    <term><literal>NOT DEFERRABLE</literal></term>
    <listitem>
     <!--
<para>
      This controls whether the constraint can be deferred.  A
      constraint that is not deferrable will be checked immediately
      after every command.  Checking of constraints that are
      deferrable can be postponed until the end of the transaction
      (using the <xref linkend="sql-set-constraints"> command).
      <literal>NOT DEFERRABLE</literal> is the default.
      Currently, only <literal>UNIQUE</>, <literal>PRIMARY KEY</>,
      <literal>EXCLUDE</>, and
      <literal>REFERENCES</> (foreign key) constraints accept this
      clause.  <literal>NOT NULL</> and <literal>CHECK</> constraints are not
      deferrable.
     </para>
-->
<para>
这两个关键字设置该约束是否可推迟。一个不可推迟的约束将在每条命令之后马上检查。
可推迟约束可以推迟到事务结尾使用<xref linkend="sql-set-constraints">命令检查。
缺省是<literal>NOT DEFERRABLE</literal>。目前，只有<literal>UNIQUE</>、
<literal>PRIMARY KEY</>、<literal>EXCLUDE</>和<literal>REFERENCES</>（外键）
约束接受这个子句。<literal>NOT NULL</>和<literal>CHECK</>约束都是不可推迟的。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>INITIALLY IMMEDIATE</literal></term>
    <term><literal>INITIALLY DEFERRED</literal></term>
    <listitem>
     <!--
<para>
      If a constraint is deferrable, this clause specifies the default
      time to check the constraint.  If the constraint is
      <literal>INITIALLY IMMEDIATE</literal>, it is checked after each
      statement. This is the default.  If the constraint is
      <literal>INITIALLY DEFERRED</literal>, it is checked only at the
      end of the transaction.  The constraint check time can be
      altered with the <xref linkend="sql-set-constraints"> command.
     </para>
-->
<para>
如果约束是可推迟的，那么这个子句声明检查约束的缺省时间。
如果约束是<literal>INITIALLY IMMEDIATE</literal>(缺省)，
那么每条语句之后就立即检查它。如果约束是<literal>INITIALLY DEFERRED</literal>，
那么只有在事务结尾才检查它。约束检查的时间可以用
<xref linkend="sql-set-constraints">命令修改。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>WITH ( <replaceable class="PARAMETER">storage_parameter</replaceable> [= <replaceable class="PARAMETER">value</replaceable>] [, ... ] )</literal></term>
    <listitem>
     <!--
<para>
      This clause specifies optional storage parameters for a table or index;
      see <xref linkend="sql-createtable-storage-parameters"
      endterm="sql-createtable-storage-parameters-title"> for more
      information.  The <literal>WITH</> clause for a
      table can also include <literal>OIDS=TRUE</> (or just <literal>OIDS</>)
      to specify that rows of the new table
      should have OIDs (object identifiers) assigned to them, or
      <literal>OIDS=FALSE</> to specify that the rows should not have OIDs.
      If <literal>OIDS</> is not specified, the default setting depends upon
      the <xref linkend="guc-default-with-oids"> configuration parameter.
      (If the new table inherits from any tables that have OIDs, then
      <literal>OIDS=TRUE</> is forced even if the command says
      <literal>OIDS=FALSE</>.)
     </para>
-->
<para>
这个子句为表或索引指定一个可选的存储参数，参见<xref linkend="sql-createtable-storage-parameters"
      endterm="sql-createtable-storage-parameters-title">获取更多信息。
用于表的<literal>WITH</>子句还可以包含<literal>OIDS=TRUE</>或单独的
<literal>OIDS</>来指定给新表中的每一行都分配一个 OID(对象标识符)，
或者<literal>OIDS=FALSE</>表示不分配 OID 。如果没有指定<literal>OIDS</>
默认行为取决于<xref linkend="guc-default-with-oids">配置参数。
如果新表是从有 OID 的表继承而来，那么即使明确指定<literal>OIDS=FALSE</>
也将强制按照<literal>OIDS=TRUE</>执行。
</para>

     <!--
<para>
      If <literal>OIDS=FALSE</literal> is specified or implied, the new
      table does not store OIDs and no OID will be assigned for a row inserted
      into it. This is generally considered worthwhile, since it
      will reduce OID consumption and thereby postpone the wraparound
      of the 32-bit OID counter. Once the counter wraps around, OIDs
      can no longer be assumed to be unique, which makes them
      considerably less useful. In addition, excluding OIDs from a
      table reduces the space required to store the table on disk by
      4 bytes per row (on most machines), slightly improving performance.
     </para>
-->
<para>
如果明确或隐含的指定了<literal>OIDS=FALSE</literal>，新表将不会存储 OID ，
也不会为插入的行分配 OID 。这将减小 OID 的开销并因此延缓了 32-bit OID 
计数器的循环。因为一旦计数器发生循环之后 OID 将不能被视为唯一，
这将大大降低 OID 的实用性。另外，
排除了 OID 的表也为每条记录减小了 4 字节的存储空间（在大多数机器上），
从而可以稍微提升一些性能。
</para>

     <!--
<para>
      To remove OIDs from a table after it has been created, use <xref
      linkend="sql-altertable">.
     </para>
-->
<para>
可以使用<xref linkend="sql-altertable">从已有的表中删除 OID 列。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>WITH OIDS</></term>
    <term><literal>WITHOUT OIDS</></term>
    <listitem>
     <!--
<para>
      These are obsolescent syntaxes equivalent to <literal>WITH (OIDS)</>
      and <literal>WITH (OIDS=FALSE)</>, respectively.  If you wish to give
      both an <literal>OIDS</> setting and storage parameters, you must use
      the <literal>WITH ( ... )</> syntax; see above.
     </para>
-->
<para>
这些是被废弃的、分别等价于<literal>WITH (OIDS)</>和<literal>WITH (OIDS=FALSE)</>
的语法。如果想同时给出<literal>OIDS</>设置和存储参数，必须使用
<literal>WITH ( ... )</>语法；见上文。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ON COMMIT</literal></term>
    <listitem>
     
<para>
<!-- 
      The behavior of temporary tables at the end of a transaction
      block can be controlled using <literal>ON COMMIT</literal>.
      The three options are:
 -->
可以使用<literal>ON COMMIT</literal>控制临时表在事务块结尾的行为。
这三个选项是：
      <variablelist>
       <varlistentry>
        <term><literal>PRESERVE ROWS</literal></term>
        <listitem>
<!--
         <para>
          No special action is taken at the ends of transactions.
          This is the default behavior.
         </para>
-->
<para>
在事务的结尾不采取任何特别的动作，这是缺省。
</para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>DELETE ROWS</literal></term>
        <listitem>
         <!--
<para>
          All rows in the temporary table will be deleted at the end
          of each transaction block.  Essentially, an automatic <xref
          linkend="sql-truncate"> is done
          at each commit.
         </para>
-->
<para>
在每个事务块的结尾都删除临时表中的所有行。
本质上是在每次提交事务后自动执行一个<xref linkend="sql-truncate">命令。
</para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>DROP</literal></term>
        <listitem>
         <!--
<para>
          The temporary table will be dropped at the end of the current
          transaction block.
         </para>
-->
<para>
在当前事务块的结尾删除临时表。
</para>
        </listitem>
       </varlistentry>
      </variablelist></para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>TABLESPACE <replaceable class="PARAMETER">tablespace_name</replaceable></literal></term>
    <listitem>
     <!--
<para>
      The <replaceable class="PARAMETER">tablespace_name</replaceable> is the name
      of the tablespace in which the new table is to be created.
      If not specified,
      <xref linkend="guc-default-tablespace"> is consulted, or
      <xref linkend="guc-temp-tablespaces"> if the table is temporary.
     </para>
-->
<para>
指定新表将要在<replaceable class="PARAMETER">tablespace_name</replaceable>
表空间内创建。如果没有声明，将使用<xref linkend="guc-default-tablespace">，
如果该表为临时表，那么将使用<xref linkend="guc-temp-tablespaces">。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>USING INDEX TABLESPACE <replaceable class="PARAMETER">tablespace_name</replaceable></literal></term>
    <listitem>
     <!--
<para>
      This clause allows selection of the tablespace in which the index
      associated with a <literal>UNIQUE</literal>, <literal>PRIMARY
      KEY</literal>, or <literal>EXCLUDE</> constraint will be created.
      If not specified,
      <xref linkend="guc-default-tablespace"> is consulted, or
      <xref linkend="guc-temp-tablespaces"> if the table is temporary.
     </para>
-->
<para>
这个子句允许选择与一个<literal>UNIQUE</literal>、<literal>PRIMARY KEY</literal>
或<literal>EXCLUDE</>约束相关的索引创建时所在的表空间。如果没有声明，
将使用<xref linkend="guc-default-tablespace">，
如果该表为临时表，那么将使用<xref linkend="guc-temp-tablespaces">。
</para>
    </listitem>
   </varlistentry>

  </variablelist>

  <refsect2 id="SQL-CREATETABLE-storage-parameters">
   <!--
   <title id="SQL-CREATETABLE-storage-parameters-title">Storage Parameters</title>
   -->
   <title id="SQL-CREATETABLE-storage-parameters-title">存储参数</title>

 <indexterm zone="sql-createtable-storage-parameters">
  <!--
  <primary>storage parameters</primary>
  -->
  <primary>存储参数</primary>
 </indexterm>

   <!--
<para>
    The <literal>WITH</> clause can specify <firstterm>storage parameters</>
    for tables, and for indexes associated with a <literal>UNIQUE</literal>,
    <literal>PRIMARY KEY</literal>, or <literal>EXCLUDE</> constraint.
    Storage parameters for
    indexes are documented in <xref linkend="SQL-CREATEINDEX">.
    The storage parameters currently
    available for tables are listed below.  For each parameter, unless noted,
    there is an additional parameter with the same name prefixed with
    <literal>toast.</literal>, which can be used to control the behavior of the
    table's secondary <acronym>TOAST</> table, if any
    (see <xref linkend="storage-toast"> for more information about TOAST).
    Note that the TOAST table inherits the
    <literal>autovacuum_*</literal> values from its parent table, if there are
    no <literal>toast.autovacuum_*</literal> settings set.
   </para>
-->
<para>
<literal>WITH</>子句可以为表指定<firstterm>存储参数</>，并在索引上创建
<literal>UNIQUE</literal>、<literal>PRIMARY KEY</literal>或<literal>EXCLUDE</>
约束。用于索引的存储参数在<xref linkend="SQL-CREATEINDEX">里面描述。
目前可以在表上使用的存储参数在下面列出。对于每个参数，除非指明了，
有一个额外的参数是相同的名字加上<literal>toast.</literal>前缀，
可以用来控制表的次要<acronym>TOAST</>表的行为，如果有
(参阅<xref linkend="storage-toast">获取更多关于TOAST的信息)。
请注意，TOAST表从它的父表中继承<literal>autovacuum_*</literal>值，
如果没有设置<literal>toast.autovacuum_*</literal>设置。
</para>

   <variablelist>

   <varlistentry>
    <term><literal>fillfactor</> (<type>integer</>)</term>
    <listitem>
     <!--
<para>
      The fillfactor for a table is a percentage between 10 and 100.
      100 (complete packing) is the default.  When a smaller fillfactor
      is specified, <command>INSERT</> operations pack table pages only
      to the indicated percentage; the remaining space on each page is
      reserved for updating rows on that page.  This gives <command>UPDATE</>
      a chance to place the updated copy of a row on the same page as the
      original, which is more efficient than placing it on a different page.
      For a table whose entries are never updated, complete packing is the
      best choice, but in heavily updated tables smaller fillfactors are
      appropriate.  This parameter cannot be set for TOAST tables.
     </para>
-->
<para>
一个表的填充因子(fillfactor)是一个介于 10 和 100 之间的百分数。
100(完全填充)是默认值。如果指定了较小的填充因子，<command>INSERT</>
操作仅按照填充因子指定的百分率填充表页。每个页上的剩余空间将用于在该页上更新行，
这就使得<command>UPDATE</>有机会在同一页上放置同一条记录的新版本，
这比把新版本放置在其它页上更有效。对于一个从不更新的表将填充因子设为 100 
是最佳选择，但是对于频繁更新的表，较小的填充因子则更加有效。
这个参数不能为TOAST表设置。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>autovacuum_enabled</>, <literal>toast.autovacuum_enabled</literal> (<type>boolean</>)</term>
    <listitem>
     <!--
<para>
     Enables or disables the autovacuum daemon on a particular table.
     If true, the autovacuum daemon will initiate a <command>VACUUM</> operation
     on a particular table when the number of updated or deleted tuples exceeds
     <literal>autovacuum_vacuum_threshold</> plus
     <literal>autovacuum_vacuum_scale_factor</> times the number of live tuples
     currently estimated to be in the relation.
     Similarly, it will initiate an <command>ANALYZE</> operation when the
     number of inserted, updated or deleted tuples exceeds
     <literal>autovacuum_analyze_threshold</> plus
     <literal>autovacuum_analyze_scale_factor</> times the number of live tuples
     currently estimated to be in the relation.
     If false, this table will not be autovacuumed, except to prevent
     transaction Id wraparound. See <xref linkend="vacuum-for-wraparound"> for
     more about wraparound prevention.
     Observe that this variable inherits its value from the <xref
     linkend="guc-autovacuum"> setting.
     </para>
-->
<para>
在一个特别的表上启用或禁用自动清理守护进程。如果为真，
当更新或删除的元组的数量超过<literal>autovacuum_vacuum_threshold</>
加上<literal>autovacuum_vacuum_scale_factor</>倍的当前关系中评估的活动的元组时，
自动清理守护进程将在一个特定的表上发起一个<command>VACUUM</>操作。
相似的，当插入、更新或删除的元组的数量超过<literal>autovacuum_analyze_threshold</>
加上<literal>autovacuum_analyze_scale_factor</>倍的当前关系中评估的活动的元组时，
自动清理守护进程将发起一个<command>ANALYZE</>操作。如果为假，
这个表将不被自动清理，除了防止事务Id循环。参阅<xref linkend="vacuum-for-wraparound">
获取更多关于预防循环的信息。注意，这个变量从<xref linkend="guc-autovacuum">
设置中继承值。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>autovacuum_vacuum_threshold</>, <literal>toast.autovacuum_vacuum_threshold</literal> (<type>integer</>)</term>
    <listitem>
     <!--
<para>
     Minimum number of updated or deleted tuples before initiate a
     <command>VACUUM</> operation on a particular table.
     </para>
-->
<para>
在一个特定的表上发起<command>VACUUM</>操作之前，更新或删除的元组的最小值。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>autovacuum_vacuum_scale_factor</>, <literal>toast.autovacuum_vacuum_scale_factor</literal> (<type>float4</>)</term>
    <listitem>
     <!--
<para>
     Multiplier for <structfield>reltuples</> to add to
     <literal>autovacuum_vacuum_threshold</>.
     </para>
-->
<para>
添加到<literal>autovacuum_vacuum_threshold</>的<structfield>reltuples</>的乘数。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>autovacuum_analyze_threshold</> (<type>integer</>)</term>
    <listitem>
     <!--
<para>
     Minimum number of inserted, updated, or deleted tuples before initiate an
     <command>ANALYZE</> operation on a particular table.
     </para>
-->
<para>
在一个特定的表上发起<command>ANALYZE</>操作之前，插入、更新或删除的元组的最小值。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>autovacuum_analyze_scale_factor</> (<type>float4</>)</term>
    <listitem>
     <!--
<para>
     Multiplier for <structfield>reltuples</> to add to
     <literal>autovacuum_analyze_threshold</>.
     </para>
-->
<para>
添加到<literal>autovacuum_analyze_threshold</>的<structfield>reltuples</>乘数。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>autovacuum_vacuum_cost_delay</>, <literal>toast.autovacuum_vacuum_cost_delay</literal> (<type>integer</>)</term>
    <listitem>
     <!--
<para>
     Custom <xref linkend="guc-autovacuum-vacuum-cost-delay"> parameter.
     </para>
-->
<para>
自定义<xref linkend="guc-autovacuum-vacuum-cost-delay">参数。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>autovacuum_vacuum_cost_limit</>, <literal>toast.autovacuum_vacuum_cost_limit</literal> (<type>integer</>)</term>
    <listitem>
     <!--
<para>
     Custom <xref linkend="guc-autovacuum-vacuum-cost-limit"> parameter.
     </para>
-->
<para>
自定义<xref linkend="guc-autovacuum-vacuum-cost-limit">参数。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>autovacuum_freeze_min_age</>, <literal>toast.autovacuum_freeze_min_age</literal> (<type>integer</>)</term>
    <listitem>
     <!--
<para>
     Custom <xref linkend="guc-vacuum-freeze-min-age"> parameter. Note that
     autovacuum will ignore attempts to set a per-table
     <literal>autovacuum_freeze_min_age</> larger than the half system-wide
     <xref linkend="guc-autovacuum-freeze-max-age"> setting.
     </para>
-->
<para>
自定义<xref linkend="guc-autovacuum-vacuum-cost-limit">参数。请注意，
自动清理将忽略设置一个每表<literal>autovacuum_freeze_min_age</>
大于半个系统范围的<xref linkend="guc-autovacuum-freeze-max-age">设置的尝试。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>autovacuum_freeze_max_age</>, <literal>toast.autovacuum_freeze_max_age</literal> (<type>integer</>)</term>
    <listitem>
     <!--
<para>
     Custom <xref linkend="guc-autovacuum-freeze-max-age"> parameter. Note that
     autovacuum will ignore attempts to set a per-table
     <literal>autovacuum_freeze_max_age</> larger than the system-wide setting
     (it can only be set smaller). Note that while you can set
     <literal>autovacuum_freeze_max_age</> very small, or even zero, this is
     usually unwise since it will force frequent vacuuming.
     </para>
-->
<para>
自定义<xref linkend="guc-autovacuum-freeze-max-age">参数。请注意，
自动清理将忽略设置一个每表<literal>autovacuum_freeze_max_age</>
大于系统范围的设置的尝试（它只能设置的较小一些）。注意，
你可以将<literal>autovacuum_freeze_max_age</>设置的非常小，甚至为零，
这通常是不明智的，因为它将强制频繁的清理。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>autovacuum_freeze_table_age</literal>, <literal>toast.autovacuum_freeze_table_age</literal> (<type>integer</type>)</term>
    <listitem>
     <!--
<para>
      Custom <xref linkend="guc-vacuum-freeze-table-age"> parameter.
     </para>
-->
<para>
自定义<xref linkend="guc-vacuum-freeze-table-age">参数。
</para>
    </listitem>
   </varlistentry>

   </variablelist>

  </refsect2>
 </refsect1>

 <refsect1 id="SQL-CREATETABLE-notes">
  <!--
<title>Notes</title>
-->
<title>注意</title>

    <!--
<para>
     Using OIDs in new applications is not recommended: where
     possible, using a <literal>SERIAL</literal> or other sequence
     generator as the table's primary key is preferred. However, if
     your application does make use of OIDs to identify specific
     rows of a table, it is recommended to create a unique constraint
     on the <structfield>oid</> column of that table, to ensure that
     OIDs in the table will indeed uniquely identify rows even after
     counter wraparound.  Avoid assuming that OIDs are unique across
     tables; if you need a database-wide unique identifier, use the
     combination of <structfield>tableoid</> and row OID for the
     purpose.
    </para>
-->
<para>
不建议在新应用中使用 OID ，可能情况下，更好的选择是使用一个<literal>SERIAL</literal>
或者其它序列发生器做表的主键。如果一个应用使用了 OID 标识表中的特定行，
那么建议在该表的<structfield>oid</>字段上创建一个唯一约束，
以确保该表的 OID 即使在计数器循环之后也是唯一的。
如果你需要一个整个数据库范围的唯一标识，那么就要避免假设 OID 是跨表唯一的，
你可以用<structfield>tableoid</>和行 OID 的组合来实现这个目的。
</para>

    <tip>
     <!--
<para>
      The use of <literal>OIDS=FALSE</literal> is not recommended
      for tables with no primary key, since without either an OID or a
      unique data key, it is difficult to identify specific rows.
     </para>
-->
<para>
对那些没有主键的表，不建议使用<literal>OIDS=FALSE</literal>，
因为如果既没有 OID 又没有唯一数据字段，那么就很难标识特定的行。
</para>
    </tip>

    <!--
<para>
     <productname>PostgreSQL</productname> automatically creates an
     index for each unique constraint and primary key constraint to
     enforce uniqueness.  Thus, it is not necessary to create an
     index explicitly for primary key columns.  (See <xref
     linkend="sql-createindex"> for more information.)
    </para>
-->
<para>
<productname>PostgreSQL</productname>
自动为每个唯一约束和主键约束创建一个索引以确保其唯一性。因此，
不必为主键字段明确的创建索引。参阅<xref linkend="sql-createindex">获取更多信息。
</para>

    <!--
<para>
     Unique constraints and primary keys are not inherited in the
     current implementation.  This makes the combination of
     inheritance and unique constraints rather dysfunctional.
    </para>
-->
<para>
唯一约束和主键在目前的实现里是不能继承的。
如果把继承和唯一约束组合在一起会导致无法运转。
</para>

    <!--
<para>
     A table cannot have more than 1600 columns.  (In practice, the
     effective limit is usually lower because of tuple-length constraints.)
    </para>
-->
<para>
一个表不能超过 1600 个字段。实际的限制比这个更低，因为还有元组长度限制。
</para>

 </refsect1>


 <refsect1 id="SQL-CREATETABLE-examples">
  <!--
<title>Examples</title>
-->
<title>例子</title>

  
<para>
<!--
   Create table <structname>films</> and table
   <structname>distributors</>:
-->
创建<structname>films</>和<structname>distributors</>表：
<programlisting>
CREATE TABLE films (
    code        char(5) CONSTRAINT firstkey PRIMARY KEY,
    title       varchar(40) NOT NULL,
    did         integer NOT NULL,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute
);

CREATE TABLE distributors (
     did    integer PRIMARY KEY DEFAULT nextval('serial'),
     name   varchar(40) NOT NULL CHECK (name &lt;&gt; '')
);
</programlisting>
  </para>

<para>
<!--
   Create a table with a 2-dimensional array:
-->
创建一个带有 2 维数组的表：
<programlisting>
CREATE TABLE array_int (
    vector  int[][]
);
</programlisting>
  </para>
  
<para>
<!--
   Define a unique table constraint for the table
   <literal>films</literal>.  Unique table constraints can be defined
   on one or more columns of the table:
-->
为表<literal>films</literal>定义一个唯一表约束。
唯一表约束可以在表的一个或多个字段上定义：
<programlisting>
CREATE TABLE films (
    code        char(5),
    title       varchar(40),
    did         integer,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute,
    CONSTRAINT production UNIQUE(date_prod)
);
</programlisting>
  </para>

<para>
<!--
   Define a check column constraint:
-->
定义一个检查列约束：
<programlisting>
CREATE TABLE distributors (
    did     integer CHECK (did &gt; 100),
    name    varchar(40)
);
</programlisting>
  </para>

<para>
<!--
   Define a check table constraint:
-->
定义一个检查表约束：
<programlisting>
CREATE TABLE distributors (
    did     integer,
    name    varchar(40)
    CONSTRAINT con1 CHECK (did &gt; 100 AND name &lt;&gt; '')
);
</programlisting>
  </para>

<para>
<!--
   Define a primary key table constraint for the table
   <structname>films</>:
-->
为表<structname>films</>定义一个主键表约束。
<programlisting>
CREATE TABLE films (
    code        char(5),
    title       varchar(40),
    did         integer,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute,
    CONSTRAINT code_title PRIMARY KEY(code,title)
);
</programlisting>
  </para>
  
<para>
<!--
   Define a primary key constraint for table
   <structname>distributors</>.  The following two examples are
   equivalent, the first using the table constraint syntax, the second
   the column constraint syntax:
-->
为表<structname>distributors</>定义一个主键约束。下面两个例子是等效的，
第一个例子使用了表约束语法，第二个使用了列约束语法。
<programlisting>
CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    PRIMARY KEY(did)
);

CREATE TABLE distributors (
    did     integer PRIMARY KEY,
    name    varchar(40)
);
</programlisting>
  </para>

<para>
<!--
   Assign a literal constant default value for the column
   <literal>name</literal>, arrange for the default value of column
   <literal>did</literal> to be generated by selecting the next value
   of a sequence object, and make the default value of
   <literal>modtime</literal> be the time at which the row is
   inserted:
-->
下面这个例子给字段<literal>name</literal>赋予了一个文本常量缺省值，
并且将字段<literal>did</literal>的缺省值安排为通过选择序列对象的下一个值生成。
<literal>modtime</literal>的缺省值将是该行插入的时间戳。
<programlisting>
CREATE TABLE distributors (
    name      varchar(40) DEFAULT 'Luso Films',
    did       integer DEFAULT nextval('distributors_serial'),
    modtime   timestamp DEFAULT current_timestamp
);
</programlisting>
  </para>

<para>
<!--
   Define two <literal>NOT NULL</> column constraints on the table
   <classname>distributors</classname>, one of which is explicitly
   given a name:
-->
在表<classname>distributors</classname>上定义两个<literal>NOT NULL</>列约束，
其中之一明确给出了名字：
<programlisting>
CREATE TABLE distributors (
    did     integer CONSTRAINT no_null NOT NULL,
    name    varchar(40) NOT NULL
);
</programlisting>
    </para>

    
<para>
<!--
     Define a unique constraint for the <literal>name</literal> column:
-->
为<literal>name</literal>字段定义一个唯一约束：
<programlisting>
CREATE TABLE distributors (
    did     integer,
    name    varchar(40) UNIQUE
);
</programlisting>
<!-- 
     The same, specified as a table constraint:
 -->
 相同的，声明为一个表约束：
<programlisting>
CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    UNIQUE(name)
);
</programlisting>
  </para>

<para>
<!--
   Create the same table, specifying 70% fill factor for both the table
   and its unique index:
-->
创建同样的表，并为表以及唯一索引指定 70% 填充率：
<programlisting>
CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    UNIQUE(name) WITH (fillfactor=70)
)
WITH (fillfactor=70);
</programlisting>
  </para>
   
<para>
<!--
   Create table <structname>circles</> with an exclusion
   constraint that prevents any two circles from overlapping:
-->
创建一个带有排除约束的表<structname>circles</>，
阻止任意两个圆重叠：
<programlisting>
CREATE TABLE circles (
    c circle,
    EXCLUDE USING gist (c WITH &amp;&amp;)
);
</programlisting>
  </para>

<para>
<!--
   Create table <structname>cinemas</> in tablespace <structname>diskvol1</>:
-->
在表空间<structname>diskvol1</>里创建<structname>cinemas</>表：
<programlisting>
CREATE TABLE cinemas (
        id serial,
        name text,
        location text
) TABLESPACE diskvol1;
</programlisting>
  </para>

<para>
<!--
   Create a composite type and a typed table:
-->
创建一个复合类型和类型化的表：
<programlisting>
CREATE TYPE employee_type AS (name text, salary numeric);

CREATE TABLE employees OF employee_type (
    PRIMARY KEY (name),
    salary WITH OPTIONS DEFAULT 1000
);
</programlisting></para>
 </refsect1>

 <refsect1 id="SQL-CREATETABLE-compatibility">
  <!--
  <title id="SQL-CREATETABLE-compatibility-title">Compatibility</title>
  -->
  <title id="SQL-CREATETABLE-compatibility-title">兼容性</title>

  <!--
<para>
   The <command>CREATE TABLE</command> command conforms to the
   <acronym>SQL</acronym> standard, with exceptions listed below.
  </para>
-->
<para>
<command>CREATE TABLE</command>遵循<acronym>SQL</acronym>标准，
一些例外情况在下面列出。
</para>

  <refsect2>
   <!--
   <title>Temporary Tables</title>
   -->
   <title>临时表</title>

   <!--
<para>
    Although the syntax of <literal>CREATE TEMPORARY TABLE</literal>
    resembles that of the SQL standard, the effect is not the same.  In the
    standard,
    temporary tables are defined just once and automatically exist (starting
    with empty contents) in every session that needs them.
    <productname>PostgreSQL</productname> instead
    requires each session to issue its own <literal>CREATE TEMPORARY
    TABLE</literal> command for each temporary table to be used.  This allows
    different sessions to use the same temporary table name for different
    purposes, whereas the standard's approach constrains all instances of a
    given temporary table name to have the same table structure.
   </para>
-->
<para>
尽管<literal>CREATE TEMPORARY TABLE</literal>的语法和 SQL 标准的类似，但是效果是不同的。
在标准里，临时表只是定义一次并且从空内容开始自动存在于任何需要它们的会话中。
<productname>PostgreSQL</productname>要求每个会话为它们使用的每个临时表发出它们自己的
<literal>CREATE TEMPORARY TABLE</literal>命令。
这样就允许不同的会话将相同的临时表名字用于不同的目的，
而标准的实现方法则把一个临时表名字约束为具有相同的表结构。
</para>

   <!--
<para>
    The standard's definition of the behavior of temporary tables is
    widely ignored.  <productname>PostgreSQL</productname>'s behavior
    on this point is similar to that of several other SQL databases.
   </para>
-->
<para>
标准定义的临时表的行为被广泛地忽略了。<productname>PostgreSQL</productname>
在这方面上的行为类似于许多其它 SQL 数据库系统。
</para>

   <!--
<para>
    The SQL standard also distinguishes between global and local temporary
    tables, where a local temporary table has a separate set of contents for
    each SQL module within each session, though its definition is still shared
    across sessions.  Since <productname>PostgreSQL</productname> does not
    support SQL modules, this distinction is not relevant in
    <productname>PostgreSQL</productname>.
   </para>
-->
<para>
SQL标准也区分全局和局部临时表，局部临时表对于每个会话中的每个SQL模块都有一个单独的内容设置，
虽然它的定义仍然在会话中共享。因为<productname>PostgreSQL</productname>
不支持SQL模块，所以这个差别在<productname>PostgreSQL</productname>不相关。
</para>

   <!--
<para>
    For compatibility's sake, <productname>PostgreSQL</productname> will
    accept the <literal>GLOBAL</literal> and <literal>LOCAL</literal> keywords
    in a temporary table declaration, but they currently have no effect.
    Use of these keywords is discouraged, since future versions of
    <productname>PostgreSQL</productname> might adopt a more
    standard-compliant interpretation of their meaning.
   </para>
-->
<para>
出于兼容考虑，<productname>PostgreSQL</productname>将接受临时表声明中的
<literal>GLOBAL</literal>和<literal>LOCAL</literal>关键字，但是他们没有任何作用。
不建议使用这些关键字，因为<productname>PostgreSQL</productname>
的未来版本可能采取更加标准兼容的它们的含义。
</para>

   <!--
<para>
    The <literal>ON COMMIT</literal> clause for temporary tables
    also resembles the SQL standard, but has some differences.
    If the <literal>ON COMMIT</> clause is omitted, SQL specifies that the
    default behavior is <literal>ON COMMIT DELETE ROWS</>.  However, the
    default behavior in <productname>PostgreSQL</productname> is
    <literal>ON COMMIT PRESERVE ROWS</literal>.  The <literal>ON COMMIT
    DROP</literal> option does not exist in SQL.
   </para>
-->
<para>
临时表的<literal>ON COMMIT</literal>子句也类似于 SQL 标准，但是有些区别。
如果忽略了<literal>ON COMMIT</literal>子句，SQL 标准声明缺省的行为是
<literal>ON COMMIT DELETE ROWS</>。但是<productname>PostgreSQL</productname>
里的缺省行为是<literal>ON COMMIT PRESERVE ROWS</literal>。
在 SQL 标准里不存在<literal>ON COMMIT DROP</literal>选项。
</para>
  </refsect2>

  <refsect2>
   <!--
   <title>Non-deferred Uniqueness Constraints</title>
   -->
   <title>非延迟的唯一性约束</title>

   <!--
<para>
    When a <literal>UNIQUE</> or <literal>PRIMARY KEY</> constraint is
    not deferrable, <productname>PostgreSQL</productname> checks for
    uniqueness immediately whenever a row is inserted or modified.
    The SQL standard says that uniqueness should be enforced only at
    the end of the statement; this makes a difference when, for example,
    a single command updates multiple key values.  To obtain
    standard-compliant behavior, declare the constraint as
    <literal>DEFERRABLE</> but not deferred (i.e., <literal>INITIALLY
    IMMEDIATE</>).  Be aware that this can be significantly slower than
    immediate uniqueness checking.
   </para>
-->
<para>
当<literal>UNIQUE</>或<literal>PRIMARY KEY</>约束是不可延迟的时，
当插入或修改一个行时，<productname>PostgreSQL</productname>
立即检查唯一性。SQL标准说唯一约束应该只在语句的结尾强制执行；
这使得它和<productname>PostgreSQL</productname>不同，例如，
一个命令更新多个键值。要获得标准兼容的行为，声明该约束为
<literal>DEFERRABLE</>但是不能延迟（也就是说，<literal>INITIALLY IMMEDIATE</>）。
要知道，这会比立即检查唯一性要慢的多。
</para>
  </refsect2>

  <refsect2>
   <!--
   <title>Column Check Constraints</title>
   -->
   <title>列检查约束</title>

   <!--
<para>
    The SQL standard says that <literal>CHECK</> column constraints
    can only refer to the column they apply to; only <literal>CHECK</>
    table constraints can refer to multiple columns.
    <productname>PostgreSQL</productname> does not enforce this
    restriction; it treats column and table check constraints alike.
   </para>
-->
<para>
SQL 标准说<literal>CHECK</>列约束只能引用他们作用的字段；
只有<literal>CHECK</>表约束才能引用多个字段。<productname>PostgreSQL</productname>
并不强制这个限制；它把字段和表约束看作相同的东西。
</para>
  </refsect2>

  <refsect2>
   <!--
   <title><literal>EXCLUDE</literal> Constraint</title>
   -->
   <title><literal>EXCLUDE</literal> 约束</title>

   <!--
<para>
    The <literal>EXCLUDE</> constraint type is a
    <productname>PostgreSQL</productname> extension.
   </para>
-->
<para>
<literal>EXCLUDE</>约束类型是一个<productname>PostgreSQL</productname>扩展。
</para>
  </refsect2>

  <refsect2>
   <!--
   <title><literal>NULL</literal> <quote>Constraint</quote></title>
   -->
   <title><literal>NULL</literal> <quote>约束</quote></title>

   <!--
<para>
    The <literal>NULL</> <quote>constraint</quote> (actually a
    non-constraint) is a <productname>PostgreSQL</productname>
    extension to the SQL standard that is included for compatibility with some
    other database systems (and for symmetry with the <literal>NOT
    NULL</literal> constraint).  Since it is the default for any
    column, its presence is simply noise.
   </para>
-->
<para>
<literal>NULL</> <quote>约束</quote>(实际上不是约束)是
<productname>PostgreSQL</productname>对 SQL 标准的扩展，
包括它是为了和其它一些数据库系统兼容以及为了和<literal>NOT NULL</literal>
约束对称。因为它是任何字段的缺省，所以它的出现是没有意义的。
</para>
  </refsect2>

  <refsect2>
   <!-- 
   <title>Inheritance</title>
   -->
   <title>继承</title>

   <!--
<para>
    Multiple inheritance via the <literal>INHERITS</literal> clause is
    a <productname>PostgreSQL</productname> language extension.
    SQL:1999 and later define single inheritance using a
    different syntax and different semantics.  SQL:1999-style
    inheritance is not yet supported by
    <productname>PostgreSQL</productname>.
   </para>
-->
<para>
通过<literal>INHERITS</literal>子句的多重继承是<productname>PostgreSQL</productname>
语言的扩展。SQL:1999 及以后的标准使用不同的语法和语义定义了单继承。
SQL:1999风格的继承还没有在<productname>PostgreSQL</productname>中实现。
</para>
  </refsect2>

  <refsect2>
   <!--
   <title>Zero-column Tables</title>
   -->
   <title>零字段表</title>

   <!--
<para>
    <productname>PostgreSQL</productname> allows a table of no columns
    to be created (for example, <literal>CREATE TABLE foo();</>).  This
    is an extension from the SQL standard, which does not allow zero-column
    tables.  Zero-column tables are not in themselves very useful, but
    disallowing them creates odd special cases for <command>ALTER TABLE
    DROP COLUMN</>, so it seems cleaner to ignore this spec restriction.
   </para>
-->
<para>
<productname>PostgreSQL</productname>允许创建没有字段的表(比如
<literal>CREATE TABLE foo();</>)。这是对 SQL 标准的扩展，
标准不允许存在零字段表。零字段表本身没什么用，
但是禁止他们会给<command>ALTER TABLE DROP COLUMN</>带来很奇怪的情况，
所以，这个时候忽视标准的限制概念非常清楚。
</para>
  </refsect2>

  <refsect2>
   <!-- 
   <title><literal>WITH</> Clause</title>
   -->
   <title><literal>WITH</> 子句</title>

   <!--
<para>
    The <literal>WITH</> clause is a <productname>PostgreSQL</productname>
    extension; neither storage parameters nor OIDs are in the standard.
   </para>
-->
<para>
<literal>WITH</>子句是<productname>PostgreSQL</productname>的扩展，同样，
存储参数和 OID 也是扩展。
</para>
  </refsect2>

  <refsect2>
   <!--
   <title>Tablespaces</title>
   -->
   <title>表空间</title>

   <!--
<para>
    The <productname>PostgreSQL</productname> concept of tablespaces is not
    part of the standard.  Hence, the clauses <literal>TABLESPACE</literal>
    and <literal>USING INDEX TABLESPACE</literal> are extensions.
   </para>
-->
<para>
<productname>PostgreSQL</productname>的表空间概念不是标准的东西。
因此<literal>TABLESPACE</literal>和<literal>USING INDEX TABLESPACE</literal>都是扩展。
</para>
  </refsect2>

  <refsect2>
   <!-- 
   <title>Typed Tables</title>
   -->
   <title>类型化的表</title>

   <!--
<para>
    Typed tables implement a subset of the SQL standard.  According to
    the standard, a typed table has columns corresponding to the
    underlying composite type as well as one other column that is
    the <quote>self-referencing column</quote>.  PostgreSQL does not
    support these self-referencing columns explicitly, but the same
    effect can be had using the OID feature.
   </para>
-->
<para>
类型化的表实现了SQL标准的一个子集。根据标准，
类型化的表有对应于底层复合类型和一个其他的<quote>自我参考字段</quote>。
PostgreSQL没有明确支持这些自我参考字段，但是相同的效果可以使用OID特性达到。
</para>
  </refsect2>
 </refsect1>


 <refsect1>
  <!--
<title>See Also</title>
-->
<title>又见</title>

  <simplelist type="inline">
   <member><xref linkend="sql-altertable"></member>
   <member><xref linkend="sql-droptable"></member>
   <member><xref linkend="sql-createtableas"></member>
   <member><xref linkend="sql-createtablespace"></member>
   <member><xref linkend="sql-createtype"></member>
  </simplelist>
 </refsect1>
</refentry>
