<!--
doc/src/sgml/ref/create_table.sgml
PostgreSQL documentation
-->

<refentry id="SQL-CREATETABLE">
 <indexterm zone="sql-createtable">
  <primary>CREATE TABLE</primary>
 </indexterm>
 
 <refmeta>
  <refentrytitle>CREATE TABLE</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - 语言语句</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE TABLE</refname>
  <refpurpose>定义一个新表</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <replaceable class="PARAMETER">table_name</replaceable> ( [
  { <replaceable class="PARAMETER">column_name</replaceable> <replaceable class="PARAMETER">data_type</replaceable> [ COLLATE <replaceable>collation</replaceable> ] [ <replaceable class="PARAMETER">column_constraint</replaceable> [ ... ] ]
    | <replaceable>table_constraint</replaceable>
    | LIKE <replaceable>source_table</replaceable> [ <replaceable>like_option</replaceable> ... ] }
    [, ... ]
] )
[ INHERITS ( <replaceable>parent_table</replaceable> [, ... ] ) ]
[ WITH ( <replaceable class="PARAMETER">storage_parameter</replaceable> [= <replaceable class="PARAMETER">value</replaceable>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <replaceable class="PARAMETER">tablespace_name</replaceable> ]

CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <replaceable class="PARAMETER">table_name</replaceable>
    OF <replaceable class="PARAMETER">type_name</replaceable> [ (
  { <replaceable class="PARAMETER">column_name</replaceable> WITH OPTIONS [ <replaceable class="PARAMETER">column_constraint</replaceable> [ ... ] ]
    | <replaceable>table_constraint</replaceable> }
    [, ... ]
) ]
[ WITH ( <replaceable class="PARAMETER">storage_parameter</replaceable> [= <replaceable class="PARAMETER">value</replaceable>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <replaceable class="PARAMETER">tablespace_name</replaceable> ]

<phrase>其中 <replaceable class="PARAMETER">column_constraint</replaceable> 是：</phrase>

[ CONSTRAINT <replaceable class="PARAMETER">constraint_name</replaceable> ]
{ NOT NULL |
  NULL |
  CHECK ( <replaceable class="PARAMETER">expression</replaceable> ) [ NO INHERIT ] |
  DEFAULT <replaceable>default_expr</replaceable> |
  UNIQUE <replaceable class="PARAMETER">index_parameters</replaceable> |
  PRIMARY KEY <replaceable class="PARAMETER">index_parameters</replaceable> |
  REFERENCES <replaceable class="PARAMETER">reftable</replaceable> [ ( <replaceable class="PARAMETER">refcolumn</replaceable> ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]
    [ ON DELETE <replaceable class="parameter">action</replaceable> ] [ ON UPDATE <replaceable class="parameter">action</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<phrase><replaceable class="PARAMETER">table_constraint</replaceable> 是：</phrase>

[ CONSTRAINT <replaceable class="PARAMETER">constraint_name</replaceable> ]
{ CHECK ( <replaceable class="PARAMETER">expression</replaceable> ) [ NO INHERIT ] |
  UNIQUE ( <replaceable class="PARAMETER">column_name</replaceable> [, ... ] ) <replaceable class="PARAMETER">index_parameters</replaceable> |
  PRIMARY KEY ( <replaceable class="PARAMETER">column_name</replaceable> [, ... ] ) <replaceable class="PARAMETER">index_parameters</replaceable> |
  EXCLUDE [ USING <replaceable class="parameter">index_method</replaceable> ] ( <replaceable class="parameter">exclude_element</replaceable> WITH <replaceable class="parameter">operator</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> [ WHERE ( <replaceable class="parameter">predicate</replaceable> ) ] |
  FOREIGN KEY ( <replaceable class="PARAMETER">column_name</replaceable> [, ... ] ) REFERENCES <replaceable class="PARAMETER">reftable</replaceable> [ ( <replaceable class="PARAMETER">refcolumn</replaceable> [, ... ] ) ]
    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE <replaceable class="parameter">action</replaceable> ] [ ON UPDATE <replaceable class="parameter">action</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<phrase><replaceable class="PARAMETER">like_option</replaceable> 是：</phrase>

{ INCLUDING | EXCLUDING } { DEFAULTS | CONSTRAINTS | INDEXES | STORAGE | COMMENTS | ALL }

<literal>UNIQUE</literal>、<literal>PRIMARY KEY</literal>以及<literal>EXCLUDE</literal>约束中的<phrase><replaceable class="PARAMETER">index_parameters</replaceable>是：</phrase>

[ WITH ( <replaceable class="PARAMETER">storage_parameter</replaceable> [= <replaceable class="PARAMETER">value</replaceable>] [, ... ] ) ]
[ USING INDEX TABLESPACE <replaceable class="PARAMETER">tablespace_name</replaceable> ]

一个<literal>EXCLUDE</literal>约束中的<phrase><replaceable class="PARAMETER">exclude_element</replaceable>是：</phrase>

{ <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ <replaceable class="parameter">opclass</replaceable> ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ]
</synopsis>

 </refsynopsisdiv>

 <refsect1 id="SQL-CREATETABLE-description">
  <title>描述</title>

  <para>
   <command>CREATE TABLE</command>将在当前数据库中创建一个新的、初始为空的表。该表将由发出该命令的用户所拥有。
  </para>

  <para>
   如果给定了一个模式名（例如<literal>CREATE TABLE myschema.mytable ...</>），那么该表被创建在指定的模式中。否则它被创建在当前模式中。临时表存在于一个特殊的模式中，因此在创建一个临时表时不能给定一个模式名。该表的名称必须与同一个模式中的任何其他表、序列、索引、视图或外部表的名称区分开。
  </para>

  <para>
   <command>CREATE TABLE</command>也会自动地创建一个数据类型来表示对应于该表一行的组合类型。因此，表不能用同一个模式中任何已有数据类型的名称。
  </para>

  <para>
   可选的约束子句指定一个插入或更新操作要成功，新的或更新过的行必须满足的约束（测试）。一个约束是一个 SQL 对象，它帮助以多种方式定义表中的合法值集合。
  </para>

  <para>
   有两种方式来定义约束：表约束和列约束。一个列约束会作为列定义的一部分定义。一个表约束定义不与一个特定列绑定，并且它可以包含多于一个列。每一个列约束也可以被写作一个表约束，列约束只是一种当约束只影响一列时方便书写的记号习惯。
  </para>

  <para>
   要能创建一个表，你必须分别具有所有列类型或<literal>OF</literal>子句中类型的<literal>USAGE</literal>特权。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <variablelist>

   <varlistentry id="SQL-CREATETABLE-TEMPORARY">
    <term><literal>TEMPORARY</> or <literal>TEMP</></term>
    <listitem>
     <para>
      如果指定，该表被创建为一个临时表。临时表会被在会话结束时自动被删除，或者也可以选择在当前事务结束时删除（见下文的<literal>ON COMMIT</literal>）。当临时表存在时，已有的同名持久表将对于当前会话不可见，不过可以使用模式限定的名称进行引用。在一个临时表上创建的任何索引也自动地变为临时的。
     </para>

     <para>
      <link linkend="autovacuum">自动清理守护进程</link>不能访问并且因此也不能清理或分析临时表。由于这个原因，应该通过会话的 SQL 命令执行合适的清理和分析操作。例如，如果一个临时表将要被用于复杂的查询，最好在把它填充完毕后在其上运行<command>ANALYZE</>。
     </para>

     <para>
      可以选择将<literal>GLOBAL</literal>或<literal>LOCAL</literal>写在<literal>TEMPORARY</>或<literal>TEMP</>的前面。这当前在<productname>PostgreSQL</>中没有区别并且已被废弃，见<xref linkend="sql-createtable-compatibility" endterm="sql-createtable-compatibility-title">。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="SQL-CREATETABLE-UNLOGGED">
    <term><literal>UNLOGGED</></term>
    <listitem>
     <para>
      如果指定，该表被创建为一个不受日志记录的表。被写入到不做日志的表中的数据不会被写到预写式日志中（见<xref linkend="wal">），这让它们比普通表快非常多。不过，它们在崩溃时是不安全的：一个不做日志的表在一次崩溃或非干净关闭之后会被自动地截断。一个不做日志的表中的内容也不会被复制到后备服务器中。在一个不做日志的表上创建的任何索引也会自动地不被日志记录。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>IF NOT EXISTS</></term>
    <listitem>
     <para>
      如果一个同名关系已经存在，不要抛出一个错误。在这种情况下会发出一个提示。注意这不保证现有的关系是和将要被创建的表相似的东西。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">table_name</replaceable></term>
    <listitem>
     <para>
      要被创建的表名（可以选择用模式限定）。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OF <replaceable class="PARAMETER">type_name</replaceable></literal></term>
    <listitem>
     <para>
      创建一个<firstterm>类型化的表</firstterm>，它的结构取自于指定的组合类型（名字可以选择用模式限定）。一个类型化的表和它的类型绑定在一起，例如如果类型被删除，该表也将被删除（用<literal>DROP TYPE ... CASCADE</literal>）。
     </para>

     <para>
      当一个类型化的表被创建时，列的数据类型由底层的组合类型决定而没有在<literal>CREATE TABLE</literal>命令中直接指定。但是<literal>CREATE TABLE</literal>命令可以对表增加默认值和约束，并且可以指定存储参数。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">column_name</replaceable></term>
    <listitem>
     <para>
      要在新表中创建的一列的名称。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">data_type</replaceable></term>
    <listitem>
     <para>
      该列的数据类型。这可以包括数组说明符。更多关于<productname>PostgreSQL</productname>支持的数据类型，请参考<xref linkend="datatype">。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>COLLATE <replaceable>collation</replaceable></literal></term>
    <listitem>
     <para>
      <literal>COLLATE</>子句为该列（必须是一种可排序数据类型）赋予一个排序规则。如果没有指定，将使用该列数据类型的默认排序规则。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>INHERITS ( <replaceable>parent_table</replaceable> [, ... ] )</literal></term>
    <listitem>
     <para>
      可选的<literal>INHERITS</>子句指定一个表的列表，新表将从其中自动地继承所有列。
     </para>

     <para>
      <literal>INHERITS</>的使用在新的子表和它的父表之间创建一种持久的关系。对于父表的模式修改通常也会传播到子表，并且默认情况下子表的数据会被包括在对父表的扫描中。
     </para>

     <para>
      如果在多个父表中存在同名的列，除非父表中每一个这种列的数据类型都能匹配，否则会报告一个错误。如果没有冲突，那么重复列会被融合来形成新表中的一个单一列。如果新表中的列名列表包含一个也是继承而来的列名，该数据类型必须也匹配继承的列，并且列定义会被融合成一个。如果新表显式地为列指定了任何默认值，这个默认值将覆盖来自该列继承声明中的默认值。否则，任何父表都必须为该列指定相同的默认值，或者会报告一个错误。
     </para>

     <para><literal>CHECK</>约束本质上也采用和列相同的方式被融合：如果多个父表或者新表定义中包含相同的命名<literal>CHECK</>约束，这些约束必须全部具有相同的检查表达式，否则将报告一个错误。具有相同名称和表达式的约束将被融合成一份拷贝。一个父表中的被标记为<literal>NO INHERIT</>的约束将不会被考虑。注意新表中一个未命名的<literal>CHECK</>约束将永远不会被融合，因为那样总是会为它选择一个唯一的名字。
     </para>

     <para>
      列的<literal>STORAGE</>设置也会从父表复制过来。
     </para>

    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>LIKE <replaceable>source_table</replaceable> [ <replaceable>like_option</replaceable> ... ]</literal></term>
    <listitem>
     <para>
      <literal>LIKE</literal>指定新表将从哪一个表自动地复制所有的列名、数据类型以及它们的非空约束。
     </para>
     <para>
      和<literal>INHERITS</literal>不同，新表和原始表在创建完成之后是完全分离的。对原始表的更改将不会被应用到新表，并且不可能在原始表的扫描中包括新表的数据。
     </para>
     <para>
      复制而来的列定义的默认值表达式将只有在
      <literal>INCLUDING DEFAULTS</literal>被指定时才会复制。
      调用数据库修改函数（如<function>nextval</>）的默认值会
      在原始表和新表之间创建一个链接。默认行为是排除默认值表达式，
      导致新表中复制而来的列的默认值是空值。
     </para>
     <para>
      非空约束总是会被复制到新表。<literal>CHECK</literal>约束只有在<literal>INCLUDING CONSTRAINTS</literal>被指定时才会被复制。只有<literal>INCLUDING INDEXES</literal>子句被指定时，原始表上的索引、<literal>PRIMARY KEY</>以及<literal>UNIQUE</>约束才会被创建在新表上。列约束和表约束之间没有区别对待。
     </para>
     <para>只有<literal>INCLUDING STORAGE</literal>被指定时，复制而来的列定义的<literal>STORAGE</>设置才会被复制。默认行为会排除<literal>STORAGE</>设置，导致新表中复制而来的列具有与类型相关的默认设置。更多关于<literal>STORAGE</>设置的信息，请见<xref linkend="storage-toast">。
     </para>
     <para>
      只有<literal>INCLUDING COMMENTS</literal>被指定时，复制而来的列、约束和索引的注释才会被拷贝。默认行为是排除注释，这导致新表中复制而来的列和约束没有注释。
     </para>
     <para><literal>INCLUDING ALL</literal>是
      <literal>INCLUDING DEFAULTS INCLUDING CONSTRAINTS INCLUDING INDEXES INCLUDING STORAGE INCLUDING COMMENTS</literal>的简写形式。
     </para>
     <para>
      还要注意和<literal>INHERITS</literal>不同，用<literal>LIKE</>拷贝的列和约束不会和相似的命名列及约束融合。如果显式指定了相同的名称或者在另一个<literal>LIKE</>子句中指定了相同的名称，将会发出一个错误。
     </para>
     <para>
      <literal>LIKE</literal>子句也能被用来从视图、外部表或组合类型拷贝列。不适合的选项（例如来自视图的<literal>INCLUDING INDEXES</literal>）会被忽略。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CONSTRAINT <replaceable class="PARAMETER">constraint_name</replaceable></literal></term>
    <listitem>
     <para>
      一个列约束或表约束的可选名称。如果该约束被违背，约束名将会出现在错误消息中，这样类似<literal>列必须为正</>的约束名可以用来与客户端应用沟通有用的约束信息（指定包含空格的约束名时需要用到双引号）。如果没有指定约束名，系统将生成一个。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NOT NULL</></term>
    <listitem>
     <para>
      该列不允许包含空值。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NULL</></term>
    <listitem>
     <para>
      该列允许包含空值。这是默认情况。
     </para>

     <para>
      这个子句只是提供与非标准 SQL 数据库的兼容。在新的应用中不推荐使用。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CHECK ( <replaceable class="PARAMETER">expression</replaceable> ) [ NO INHERIT ] </literal></term>
    <listitem>
     <para>
      <literal>CHECK</>指定一个产生布尔结果的表达式，一个插入或更新操作要想成功，其中新的或被更新的行必须满足该表达式。计算出 TRUE 或 UNKNOWN 的表达式就会成功。只要任何一个插入或更新操作的行产生了 FALSE 结果，将报告一个错误异常并且插入或更新不会修改数据库。一个被作为列约束指定的检查约束只应该引用该列的值，而一个出现在表约束中的表达式可以引用多列。
     </para>

     <para>
      当前，<literal>CHECK</literal>表达式不能包含子查询，
      也不能引用当前行的列之外的变量。可以引用系统列
      <literal>tableoid</literal>，但不能引用其他系统列。
     </para>

     <para>
      一个被标记为<literal>NO INHERIT</>的约束将不会传播到子表。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DEFAULT
    <replaceable>default_expr</replaceable></literal></term>
    <listitem>
     <para>
      <literal>DEFAULT</>子句为出现在其定义中的列赋予一个默认数据。该值是可以使用变量的表达式（不允许用子查询和对其他列的交叉引用）。默认值表达式的数据类型必须匹配列的数据类型。
     </para>

     <para>
      默认值表达式将被用在任何没有为该列指定值的插入操作中。如果一列没有默认值，那么默认值为空值。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>UNIQUE</> （列约束）</term>
    <term><literal>UNIQUE ( <replaceable class="PARAMETER">column_name</replaceable> [, ... ] )</> （表约束）</term>

    <listitem>
     <para>
      <literal>UNIQUE</literal>约束指定一个表中的一列或多列组成的组包含唯一的值。唯一表约束的行为与列约束的行为相同，只是表约束能够跨越多列。
     </para>

     <para>
      对于一个唯一约束的目的来说，空值不被认为是相等的。
     </para>

     <para>
      每一个唯一表约束必须命名一个列的集合，并且它与该表上任何其他唯一或主键约束所命名的列集合都不相同（否则它将是一个被列举了两次的约束）。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>PRIMARY KEY</> （列约束）</term>
    <term><literal>PRIMARY KEY ( <replaceable class="PARAMETER">column_name</replaceable> [, ... ] )</> （表约束）</term>
    <listitem>
     <para>
      主键约束指定一个表中的一列或多列组成的组包含唯一的、不为空的值。技术上，<literal>PRIMARY KEY</literal>只是<literal>UNIQUE</>和<literal>NOT NULL</>的一个组合，但是将一组列标识为主键也提供了关于模式设计的元数据，因为一个主键蕴含着其他表可以依靠这一组列作为行的一个唯一标识符。
     </para>

     <para>
      对一个表只能指定一个主键，可以作为一个列约束或一个表约束。
     </para>

     <para>
      主键约束应当命名一个列的集合，并且它与相同表上任何其他唯一约束所命名的列集合都不相同。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="SQL-CREATETABLE-EXCLUDE">
    <term><literal>EXCLUDE [ USING <replaceable class="parameter">index_method</replaceable> ] ( <replaceable class="parameter">exclude_element</replaceable> WITH <replaceable class="parameter">operator</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> [ WHERE ( <replaceable class="parameter">predicate</replaceable> ) ]</literal></term>
    <listitem>
     <para>
      <literal>EXCLUDE</>子句定一个排除约束，它保证如果任意两行在指定列或表达式上使用指定操作符进行比较，不是所有的比较都将会返回<literal>TRUE</>。如果所有指定的操作符都测试相等，这就等价于一个<literal>UNIQUE</>约束，尽管一个普通的唯一约束将更快。不过，排除约束能够指定比简单相等更通用的约束。例如，你可以使用<literal>&amp;&amp;</>操作符指定一个约束，要求表中没有两行包含相互覆盖的圆（见 <xref linkend="datatype-geometric">）。
     </para>

     <para>
      排除约束使用一个索引实现，这样每一个指定的操作符必须与用于索引访问方法<replaceable>index_method</>的一个适当的操作符类（见<xref linkend="indexes-opclass">）相关联。操作符被要求是交换的。每一个<replaceable class="parameter">exclude_element</replaceable>可以选择性地指定一个操作符类或者顺序选项，这些在<xref linkend="sql-createindex">中有完整描述。
     </para>

     <para>
      访问方法必须支持<literal>amgettuple</>（见<xref
      linkend="indexam">），目前这意味着<acronym>GIN</>无法使用。尽管允许，但是在一个排除约束中使用 B-树或哈希索引没有意义，因为它无法做得比一个普通唯一索引更出色。因此在实践中访问方法将总是<acronym>GiST</>或<acronym>SP-GiST</>。
     </para>

     <para>
      <replaceable class="parameter">predicate</>允许你在该表的一个子集上指定一个排除约束。在内部这会创建一个部分索引。注意在为此周围的圆括号是必须的。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>REFERENCES <replaceable class="parameter">reftable</replaceable> [ ( <replaceable class="parameter">refcolumn</replaceable> ) ] [ MATCH <replaceable class="parameter">matchtype</replaceable> ] [ ON DELETE <replaceable class="parameter">action</replaceable> ] [ ON UPDATE <replaceable class="parameter">action</replaceable> ]</literal> （列约束）</term>

   <term><literal>FOREIGN KEY ( <replaceable class="parameter">column_name</replaceable> [, ... ] )
    REFERENCES <replaceable class="parameter">reftable</replaceable> [ ( <replaceable class="parameter">refcolumn</replaceable> [, ... ] ) ]
    [ MATCH <replaceable class="parameter">matchtype</replaceable> ]
    [ ON DELETE <replaceable class="parameter">action</replaceable> ]
    [ ON UPDATE <replaceable class="parameter">action</replaceable> ]</literal>
    （表约束）</term>

    <listitem>
     <para>
      这些子句指定一个外键约束，它要求新表的一列或一个列的组必须只包含能匹配被引用表的某个行在被引用列上的值。如果<replaceable class="parameter">refcolumn</replaceable>列表被忽略，将使用<replaceable class="parameter">reftable</replaceable>的主键。被引用列必须是被引用表中一个非可延迟唯一约束或主键约束的列。注意外键约束不能在临时表和永久表之间定义。
     </para>

     <para>
      被插入到引用列的一个值会使用给定的匹配类型与被引用表的值进行匹配。有三种匹配类型：<literal>MATCH FULL</>、<literal>MATCH PARTIAL</>以及<literal>MATCH SIMPLE</literal>（这是默认值）。  <literal>MATCH FULL</>将不允许一个多列外键中的一列为空，除非所有外键列都是空；如果它们都是空，则不要求该行在被引用表中有一个匹配。<literal>MATCH SIMPLE</literal>允许任意外键列为空，如果任一为空，则不要求该行在被引用表中有一个匹配。<literal>MATCH PARTIAL</>现在还没有被实现（当然，<literal>NOT NULL</>约束能被应用在引用列上来组织这些情况发生）。
     </para>

     <para>
      另外，当被引用列中的数据被改变时，在这个表的列中的数据上可以执行特定的动作。<literal>ON DELETE</literal>指定当被引用表中一个被引用行被删除时要执行的动作。同样，<literal>ON UPDATE</literal>指定当被引用表中一个被引用列被更新为新值时要执行的动作。如果该行被更新，但是被引用列并没有被实际改变，不会做任何动作。除了<literal>NO ACTION</literal>检查之外的引用动作不能被延迟，即便该约束被声明为可延迟的。对每一个子句可能有以下动作：

      <variablelist>
       <varlistentry>
        <term><literal>NO ACTION</literal></term>
        <listitem>
         <para>
          产生一个错误指示删除或更新将会导致一个外键约束违背。如果该约束被延迟，并且仍存在引用行，这个错误将在约束检查时被产生。这是默认动作。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>RESTRICT</literal></term>
        <listitem>
         <para>
          产生一个错误指示删除或更新将会导致一个外键约束违背。这个动作与<literal>NO ACTION</literal>形同，不过该检查不是可延迟的。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>CASCADE</literal></term>
        <listitem>
         <para>
          删除任何引用被删除行的行，或者把引用列的值更新为被引用列的新值。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>SET NULL</literal></term>
        <listitem>
         <para>
          将引用列设置为空。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>SET DEFAULT</literal></term>
        <listitem>
         <para>
          设置引用列为它们的默认值（如果该默认值非空，在被引用表中必须有一行匹配该默认值，否则该操作将会失败）。
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>

     <para>
      如果被引用列被频繁地更改，最好在引用列上加上一个索引，这样与外键约束相关的引用动作能够更高效地被执行。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DEFERRABLE</literal></term>
    <term><literal>NOT DEFERRABLE</literal></term>
    <listitem>
     <para>
      这个子句控制该约束是否能被延迟。一个不可延迟的约束将在每一次命令后立刻被检查。可延迟约束的检查将被推迟到事务结束时进行（使用<xref linkend="sql-set-constraints">命令）。<literal>NOT DEFERRABLE</literal>是默认值。当前，只有<literal>UNIQUE</>、<literal>PRIMARY KEY</>、<literal>EXCLUDE</>以及<literal>REFERENCES</>（外键）约束接受这个子句。<literal>NOT NULL</>以及<literal>CHECK</>约束是不可延迟的。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>INITIALLY IMMEDIATE</literal></term>
    <term><literal>INITIALLY DEFERRED</literal></term>
    <listitem>
     <para>
      如果一个约束是可延迟的，这个子句指定检查该约束的默认时间。如果该约束是<literal>INITIALLY IMMEDIATE</literal>，它会在每一个语句之后被检查。这是默认值。如果该约束是<literal>INITIALLY DEFERRED</literal>，它只会在事务结束时被检查。约束检查时间可以用<xref linkend="sql-set-constraints">命令修改。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>WITH ( <replaceable class="PARAMETER">storage_parameter</replaceable> [= <replaceable class="PARAMETER">value</replaceable>] [, ... ] )</literal></term>
    <listitem>
     <para>
      这个子句为一个表或索引指定可选的存储参数，详见<xref linkend="sql-createtable-storage-parameters"       endterm="sql-createtable-storage-parameters-title">。一个表的<literal>WITH</>子句还可以包括<literal>OIDS=TRUE</>（或者只包括<literal>OIDS</>）来指定新表的行应该具有被分配的 OID（对象标识符），或者包括<literal>OIDS=FALSE</>来指定新表的行不具有 OID。如果没有指定<literal>OIDS</>，默认设置取决于<xref linkend="guc-default-with-oids">配置参数（如果新表是从任何具有 OID 的表继承而来，那么即使该命令要求<literal>OIDS=FALSE</>也会强制使用<literal>OIDS=TRUE</>）。
     </para>

     <para>
      如果指定或者蕴含了<literal>OIDS=FALSE</literal>，新表就不会存储 OID 并且对插入其中的一个新行不会分配 OID。这通常值得考虑，因为它将减少 OID 消耗并且因而推迟 32 为 OID 计数器的回卷。一旦计数器回卷，OID 就不再能被假定为唯一，这就使它们不那么有用了。另外，从一个表中排除 OID 可以减少存储该表所需的磁盘空间，减少的量是每行减少 4 字节（在大部分机器上），这也略微提高了性能。
     </para>

     <para>
      要在表被创建后从中移除 OID，使用<xref linkend="sql-altertable">.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>WITH OIDS</></term>
    <term><literal>WITHOUT OIDS</></term>
    <listitem>
     <para>
      这些语法已被荒废，它们分别等效于<literal>WITH (OIDS)</>和<literal>WITH (OIDS=FALSE)</>。如果你希望同时给出一个<literal>OIDS</>设置和存储参数，你必须使用<literal>WITH ( ... )</>语法，见上文。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ON COMMIT</literal></term>
    <listitem>
     <para>
      临时表在一个事务块结束时的行为由<literal>ON COMMIT</literal>控制。三种选项是：

      <variablelist>
       <varlistentry>
        <term><literal>PRESERVE ROWS</literal></term>
        <listitem>
         <para>
          在事务结束时不采取特殊的动作。这是默认行为。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>DELETE ROWS</literal></term>
        <listitem>
         <para>
          在每一个事务块结束时将删除临时表中的所有行。实质上，在每一次提交时会完成一次自动的<xref linkend="sql-truncate">。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>DROP</literal></term>
        <listitem>
         <para>
          在当前事务块结束时将删除临时表。
         </para>
        </listitem>
       </varlistentry>
      </variablelist></para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>TABLESPACE <replaceable class="PARAMETER">tablespace_name</replaceable></literal></term>
    <listitem>
     <para>
      <replaceable class="PARAMETER">tablespace_name</replaceable>是新表要创建于其中的表空间名称。如果没有指定，将参考<xref linkend="guc-default-tablespace">，或者如果表是临时的则参考<xref linkend="guc-temp-tablespaces">。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>USING INDEX TABLESPACE <replaceable class="PARAMETER">tablespace_name</replaceable></literal></term>
    <listitem>
     <para>
      这个子句允许选择与一个<literal>UNIQUE</literal>、<literal>PRIMARY KEY</literal>或者<literal>EXCLUDE</>约束相关的索引将被创建在哪个表空间中。如果没有指定，将参考<xref linkend="guc-default-tablespace">，或者如果表是临时的则参考<xref linkend="guc-temp-tablespaces">。
     </para>
    </listitem>
   </varlistentry>

  </variablelist>

  <refsect2 id="SQL-CREATETABLE-storage-parameters">
   <title id="SQL-CREATETABLE-storage-parameters-title">存储参数</title>

 <indexterm zone="sql-createtable-storage-parameters">
  <primary>存储参数</primary>
 </indexterm>

   <para>
    <literal>WITH</>子句能够为表或与一个<literal>UNIQUE</literal>、<literal>PRIMARY KEY</literal>或者<literal>EXCLUDE</>约束相关的索引指定<firstterm>存储参数</>。用于索引的存储参数已经在<xref linkend="SQL-CREATEINDEX">中介绍过。当前可用于表的存储参数在下文中列出。对于每一个参数，除非特别注明，都有一个名字带有<literal>toast.</literal>前缀的附加参数，它能被用来控制该表的二级<acronym>TOAST</>表（如果存在）的行为（关于 TOAST 详见<xref linkend="storage-toast">）。注意 TOAST 表的<literal>toast.autovacuum_*</literal>如果没有被设置，它将从其父表继承<literal>autovacuum_*</literal>值。
   </para>

   <variablelist>

   <varlistentry>
    <term><literal>fillfactor</> (<type>integer</>)</term>
    <listitem>
     <para>
      一个表的填充因子是一个 10 到 100 之间的百分数。100（完全填满）是默认值。当一个较小的填充因子被指定时，<command>INSERT</>操作会把表页面只填满到指定的百分比，每个页面上剩余的空间被保留给该页上行的更新。这就让<command>UPDATE</>有机会把一行的已更新版本放在与其原始版本相同的页面上，这比把它放在一个不同的页面上效率更高。对于一个项从来不会被更新的表来说，完全填满是最好的选择，但是在更新繁重的表上则较小的填充因子更合适。这个参数不能对 TOAST 表设置。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>autovacuum_enabled</>, <literal>toast.autovacuum_enabled</literal> (<type>boolean</>)</term>
    <listitem>
     <para>
     在一个特定表上启用或禁用自动清理守护进程。如果为真，当被更新或删除元组超过<literal>autovacuum_vacuum_threshold</>加上<literal>autovacuum_vacuum_scale_factor</>乘以当前估算出的关系中活元组数，自动清理守护进程将在特定表上发起一次<command>VACUUM</>操作。相似地，当被插入、更新或删除的元组超过<literal>autovacuum_analyze_threshold</>加上<literal>autovacuum_analyze_scale_factor</>乘以当前估算出的关系中活元组数，自动清理守护进程将发起一次<command>ANALYZE</>操作。如果为假，这个表将不会被自动清理，除非为了阻止事务 Id 回卷。关于阻止回卷，请参考<xref linkend="vacuum-for-wraparound">。注意这个变量会从<xref linkend="guc-autovacuum">设置中继承它的值。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>autovacuum_vacuum_threshold</>, <literal>toast.autovacuum_vacuum_threshold</literal> (<type>integer</>)</term>
    <listitem>
     <para>
     在特定表上发起一次<command>VACUUM</>操作之前最小的被更新或删除元组数。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>autovacuum_vacuum_scale_factor</>, <literal>toast.autovacuum_vacuum_scale_factor</literal> (<type>float4</>)</term>
    <listitem>
     <para>
     用来把<structfield>reltuples</>加到<literal>autovacuum_vacuum_threshold</>之上的乘数。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>autovacuum_analyze_threshold</> (<type>integer</>)</term>
    <listitem>
     <para>
     在特定表上发起一次<command>ANALYZE</>操作之前最小的被插入、更新或删除元组数。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>autovacuum_analyze_scale_factor</> (<type>float4</>)</term>
    <listitem>
     <para>
     用来把<structfield>reltuples</>加到<literal>autovacuum_analyze_threshold</>之上的乘数。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>autovacuum_vacuum_cost_delay</>, <literal>toast.autovacuum_vacuum_cost_delay</literal> (<type>integer</>)</term>
    <listitem>
     <para>
     自定义的<xref linkend="guc-autovacuum-vacuum-cost-delay">参数。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>autovacuum_vacuum_cost_limit</>, <literal>toast.autovacuum_vacuum_cost_limit</literal> (<type>integer</>)</term>
    <listitem>
     <para>
     自定义的<xref linkend="guc-autovacuum-vacuum-cost-limit">参数。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>autovacuum_freeze_min_age</>, <literal>toast.autovacuum_freeze_min_age</literal> (<type>integer</>)</term>
    <listitem>
     <para>
     自定义的<xref linkend="guc-vacuum-freeze-min-age">参数。注意自动清理将忽略将一个针对每个表的<literal>autovacuum_freeze_min_age</>设置得大于系统范围<xref linkend="guc-autovacuum-freeze-max-age">设置一半的尝试。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>autovacuum_freeze_max_age</>, <literal>toast.autovacuum_freeze_max_age</literal> (<type>integer</>)</term>
    <listitem>
     <para>
     自定义的<xref linkend="guc-autovacuum-freeze-max-age">参数。注意自动清理将忽略将一个针对每个表的<literal>autovacuum_freeze_max_age</>设置的大于系统范围设置的尝试（它只能被设置的更小）。注意虽然你能将<literal>autovacuum_freeze_max_age</>设置成很小甚至为零，但是这通常是不明智的，因为它将强制频繁的清理。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>autovacuum_freeze_table_age</literal>, <literal>toast.autovacuum_freeze_table_age</literal> (<type>integer</type>)</term>
    <listitem>
     <para>
      自定义的<xref linkend="guc-vacuum-freeze-table-age">参数。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>autovacuum_multixact_freeze_min_age</literal>, <literal>toast.autovacuum_multixact_freeze_min_age</literal> (<type>integer</type>)</term>
    <listitem>
     <para>
      自定义的<xref linkend="guc-vacuum-multixact-freeze-min-age">参数。注意自动清理将忽略将一个针对每个表的<literal>autovacuum_multixact_freeze_min_age</>设置的大于系统范围<xref linkend="guc-autovacuum-multixact-freeze-max-age">设置的尝试。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>autovacuum_multixact_freeze_max_age</literal>, <literal>toast.autovacuum_multixact_freeze_max_age</literal> (<type>integer</type>)</term>
    <listitem>
     <para>
      自定义的<xref linkend="guc-autovacuum-multixact-freeze-max-age">参数。注意自动清理将忽略将一个针对每个表的<literal>autovacuum_multixact_freeze_max_age</>设置的大于系统范围设置的尝试（它只能被设置的更小）。注意虽然你能将<literal>autovacuum_multixact_freeze_max_age</>设置成很小甚至为零，但是这通常是不明智的，因为它将强制频繁的清理。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>autovacuum_multixact_freeze_table_age</literal>, <literal>toast.autovacuum_multixact_freeze_table_age</literal> (<type>integer</type>)</term>
    <listitem>
     <para>
      自定义的<xref linkend="guc-vacuum-multixact-freeze-table-age">参数。
     </para>
    </listitem>
   </varlistentry>
   
   <varlistentry>
    <term><literal>user_catalog_table</literal> (<type>boolean</type>)</term>
    <listitem>
     <para>
      声明表作为一个额外的目录表，例如用于逻辑复制的目的。详见
      <xref linkend="logicaldecoding-capabilities">。
     </para>
    </listitem>
   </varlistentry>

   </variablelist>

  </refsect2>
 </refsect1>

 <refsect1 id="SQL-CREATETABLE-notes">
  <title>注解</title>

    <para>
     我们不推荐在新应用中使用 OID：在可能要用到的地方，使用一个<literal>SERIAL</literal>或者其他序列生成器作为表的主键会更好。不过，如果你的应用确实需要用到 OID 来标识一个表的特定行，我们推荐在表的<structfield>oid</>列上创建一个唯一约束，来确保表中的 OID 在计数器回卷后能唯一标识行。如果你需要一个数据库范围的唯一标识符，要避免假定 OID 在表之间也是唯一的，应该用<structfield>tableoid</>和行 OID 的组合来实现该目的。
    </para>

    <tip>
     <para>
      我们不推荐对没有主键的表使用<literal>OIDS=FALSE</literal>，因为没有 OID 或 唯一数据键，就很难标识特定的行。
     </para>
    </tip>

    <para>
     <productname>PostgreSQL</productname>为每一个唯一约束和主键约束创建一个索引来强制唯一性。因此，没有必要显式地为主键列创建一个索引（详见<xref linkend="sql-createindex">）。
    </para>

    <para>
     在当前的实现中，唯一约束和主键不会被继承。这使得继承和唯一约束的组合相当不正常。
    </para>

    <para>
     一个表不能有超过 1600 列（实际上，由于元组长度限制，有效的限制通常更低）。
    </para>

 </refsect1>


 <refsect1 id="SQL-CREATETABLE-examples">
  <title>例子</title>

  <para>
   创建表<structname>films</>和表<structname>distributors</>：

<programlisting>
CREATE TABLE films (
    code        char(5) CONSTRAINT firstkey PRIMARY KEY,
    title       varchar(40) NOT NULL,
    did         integer NOT NULL,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute
);

CREATE TABLE distributors (
     did    integer PRIMARY KEY DEFAULT nextval('serial'),
     name   varchar(40) NOT NULL CHECK (name &lt;&gt; '')
);
</programlisting>
  </para>

  <para>
   创建有一个二维数组的表：

<programlisting>
CREATE TABLE array_int (
    vector  int[][]
);
</programlisting>
  </para>

  <para>
   为表<literal>films</literal>定义一个唯一表约束。唯一表约束能够被定义在表的一列或多列上：

<programlisting>
CREATE TABLE films (
    code        char(5),
    title       varchar(40),
    did         integer,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute,
    CONSTRAINT production UNIQUE(date_prod)
);
</programlisting>
  </para>

  <para>
   定义一个列检查约束：

<programlisting>
CREATE TABLE distributors (
    did     integer CHECK (did &gt; 100),
    name    varchar(40)
);
</programlisting>
  </para>

  <para>
   定义一个表检查约束：

<programlisting>
CREATE TABLE distributors (
    did     integer,
    name    varchar(40)
    CONSTRAINT con1 CHECK (did &gt; 100 AND name &lt;&gt; '')
);
</programlisting>
  </para>

  <para>
   为表<structname>films</>定义一个主键表约束：

<programlisting>
CREATE TABLE films (
    code        char(5),
    title       varchar(40),
    did         integer,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute,
    CONSTRAINT code_title PRIMARY KEY(code,title)
);
</programlisting>
  </para>

  <para>
   为表<structname>distributors</>定义一个主键约束。下面的两个例子是等价的，第一个使用表约束语法，第二个使用列约束语法：

<programlisting>
CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    PRIMARY KEY(did)
);

CREATE TABLE distributors (
    did     integer PRIMARY KEY,
    name    varchar(40)
);
</programlisting>
  </para>

  <para>
   为列<literal>name</literal>赋予一个文字常量默认值，安排列<literal>did</literal>的默认值是从一个序列对象中选择下一个值产生，并且让<literal>modtime</literal>的默认值是该行被插入的时间：

<programlisting>
CREATE TABLE distributors (
    name      varchar(40) DEFAULT 'Luso Films',
    did       integer DEFAULT nextval('distributors_serial'),
    modtime   timestamp DEFAULT current_timestamp
);
</programlisting>
  </para>

  <para>
   在表<classname>distributors</classname>上定义两个<literal>NOT NULL</>列约束，其中之一被显式给定了一个名称：

<programlisting>
CREATE TABLE distributors (
    did     integer CONSTRAINT no_null NOT NULL,
    name    varchar(40) NOT NULL
);
</programlisting>
    </para>

    <para>
     为<literal>name</literal>列定义一个唯一约束：

<programlisting>
CREATE TABLE distributors (
    did     integer,
    name    varchar(40) UNIQUE
);
</programlisting>

     同样的唯一约束用表约束指定：

<programlisting>
CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    UNIQUE(name)
);
</programlisting>
  </para>

  <para>
   创建相同的表，指定表和它的唯一索引指定 70% 的填充因子：

<programlisting>
CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    UNIQUE(name) WITH (fillfactor=70)
)
WITH (fillfactor=70);
</programlisting>
  </para>

  <para>
   创建表<structname>circles</>，带有一个排除约束阻止任意两个圆重叠：

<programlisting>
CREATE TABLE circles (
    c circle,
    EXCLUDE USING gist (c WITH &amp;&amp;)
);
</programlisting>
  </para>

  <para>
   在表空间<structname>diskvol1</>中创建表<structname>cinemas</>：

<programlisting>
CREATE TABLE cinemas (
        id serial,
        name text,
        location text
) TABLESPACE diskvol1;
</programlisting>
  </para>

  <para>
   创建一个组合类型以及一个类型化的表：
<programlisting>
CREATE TYPE employee_type AS (name text, salary numeric);

CREATE TABLE employees OF employee_type (
    PRIMARY KEY (name),
    salary WITH OPTIONS DEFAULT 1000
);
</programlisting></para>
 </refsect1>

 <refsect1 id="SQL-CREATETABLE-compatibility">
  <title id="SQL-CREATETABLE-compatibility-title">兼容性</title>

  <para>
   <command>CREATE TABLE</command>命令遵从<acronym>SQL</acronym>标准，除了以下例外。
  </para>

  <refsect2>
   <title>临时表</title>

   <para>
    尽管<literal>CREATE TEMPORARY TABLE</literal>的语法很像 SQL 标准的语法，但事实是并不相同。在标准中，临时表只需要被定义一次并且会自动地存在（从空内容开始）于需要它们的每一个会话中。<productname>PostgreSQL</productname>则要求每一个会话为每一个要用的临时表发出它自己的<literal>CREATE TEMPORARY TABLE</literal>命令。这允许不同的会话为不同的目的使用相同的临时表名，而标准的方法约束一个给定临时表名的所有实例都必须具有相同的表结构。
   </para>

   <para>
    标准中对于临时表行为的定义被广泛地忽略了。<productname>PostgreSQL</productname>在这一点上的行为和多种其他 SQL 数据库是相似的。
   </para>

   <para>
    SQL 标准也区分全局和局部临时表，其中一个局部临时表为每一个会话中的每一个 SQL 模块具有一个独立的内容集合，但是它的定义仍然是多个会话共享的。因为<productname>PostgreSQL</productname>不支持 SQL 模块，这种区别与<productname>PostgreSQL</productname>无关。
   </para>

   <para>
    为了兼容性目的，<productname>PostgreSQL</productname>将在临时表声明中接受<literal>GLOBAL</literal>和<literal>LOCAL</literal>关键词，但是它们当前没有效果。我们不鼓励使用这些关键词，因为未来版本的<productname>PostgreSQL</productname>可能采用一种更兼容标准的（对它们含义的）解释。
   </para>

   <para>
    临时表的<literal>ON COMMIT</literal>子句也和 SQL 标准相似，但是有一些不同。如果忽略<literal>ON COMMIT</>子句，SQL 指定默认行为是<literal>ON COMMIT DELETE ROWS</>。但是，<productname>PostgreSQL</productname>中的默认行为是<literal>ON COMMIT PRESERVE ROWS</literal>。SQL 中不存在<literal>ON COMMIT DROP</literal>选项。
   </para>
  </refsect2>

  <refsect2>
   <title>非延迟唯一性约束</title>

   <para>
    但一个<literal>UNIQUE</>或<literal>PRIMARY KEY</>约束是非可延迟的，只要一个行被插入或修改，<productname>PostgreSQL</productname>就会立即检查唯一性。SQL 标准指出只有在语句结束时才应该强制唯一性。当一个单一命令更新多个键值时，这两者是不同的。要得到兼容标准的行为，将该约束声明为<literal>DEFERRABLE</>但是不延迟（即<literal>INITIALLY IMMEDIATE</>）。注意这可能要显著地慢于立即唯一性检查。
   </para>
  </refsect2>

  <refsect2>
   <title>列检查约束</title>

   <para>
    SQL 标准指出<literal>CHECK</>列约束只能引用它们应用到的列，只有<literal>CHECK</>表约束能够引用多列。<productname>PostgreSQL</productname>并没有强制这个限制，它同样处理列检查约束和表检查约束。
   </para>
  </refsect2>

  <refsect2>
   <title><literal>EXCLUDE</literal> 约束</title>

   <para>
    <literal>EXCLUDE</>约束类型是一种<productname>PostgreSQL</productname>扩展。
   </para>
  </refsect2>

  <refsect2>
   <title><literal>NULL</literal> <quote>约束</quote></title>

   <para>
    <literal>NULL</> <quote>约束</quote>（实际上是一个非约束）是一个<productname>PostgreSQL</productname>对 SQL 标准的扩展，它也被包括（以及对称的<literal>NOT NULL</literal>约束）在一些其他的数据库系统中以实现兼容性。因为它是任意列的默认值，它的存在就像噪声一样。
   </para>
  </refsect2>

  <refsect2>
   <title>继承</title>

   <para>
    通过<literal>INHERITS</literal>子句的多继承是一种<productname>PostgreSQL</productname>的语言扩展。SQL:1999 以及之后的标准使用一种不同的语法和不同的语义定义了单继承。SQL:1999-风格的继承还没有被<productname>PostgreSQL</productname>。
   </para>
  </refsect2>

  <refsect2>
   <title>零列表</title>

   <para>
    <productname>PostgreSQL</productname>允许创建一个没有列的表（例如<literal>CREATE TABLE foo();</>）。这是一个对于 SQL 标准的扩展，它不允许零列表。零列表本身并不是很有用，但是不允许它们会为<command>ALTER TABLE DROP COLUMN</>带来奇怪的特殊情况，因此忽略这种规则限制看起来更加整洁。
   </para>
  </refsect2>

  <refsect2>
   <title><literal>WITH</>子句</title>

   <para>
    <literal>WITH</>子句是一个<productname>PostgreSQL</productname>扩展，存储参数和 OID 都不在标准中。
   </para>
  </refsect2>

  <refsect2>
   <title>表空间</title>

   <para>
    <productname>PostgreSQL</productname>的表空间概念不是标准的一部分。因此，子句<literal>TABLESPACE</literal>和<literal>USING INDEX TABLESPACE</literal>是扩展。
   </para>
  </refsect2>

  <refsect2>
   <title>类型化的表</title>

   <para>
    类型化的表实现了 SQL 标准的一个子集。根据标准，一个类型化的表具有与底层组合类型相对应的列，以及其他的<quote>自引用列</quote>。PostgreSQL 不显式支持这些自引用列，但是可以使用 OID 特性获得相同的效果。
   </para>
  </refsect2>
 </refsect1>


 <refsect1>
  <title>参见</title>

  <simplelist type="inline">
   <member><xref linkend="sql-altertable"></member>
   <member><xref linkend="sql-droptable"></member>
   <member><xref linkend="sql-createtableas"></member>
   <member><xref linkend="sql-createtablespace"></member>
   <member><xref linkend="sql-createtype"></member>
  </simplelist>
 </refsect1>
</refentry>
