<!--
doc/src/sgml/ref/create_table.sgml
PostgreSQL documentation
-->

<refentry id="SQL-CREATETABLE">
<!--==========================orignal english content==========================
 <indexterm zone="sql-createtable">
  <primary>CREATE TABLE</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="sql-createtable">
  <primary>CREATE TABLE</primary>
 </indexterm>
 
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>CREATE TABLE</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>CREATE TABLE</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - 语言语句</refmiscinfo>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>CREATE TABLE</refname>
  <refpurpose>define a new table</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>CREATE TABLE</refname>
  <refpurpose>定义一个新表</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <replaceable class="PARAMETER">table_name</replaceable> ( [
  { <replaceable class="PARAMETER">column_name</replaceable> <replaceable class="PARAMETER">data_type</replaceable> [ COLLATE <replaceable>collation</replaceable> ] [ <replaceable class="PARAMETER">column_constraint</replaceable> [ ... ] ]
    | <replaceable>table_constraint</replaceable>
    | LIKE <replaceable>source_table</replaceable> [ <replaceable>like_option</replaceable> ... ] }
    [, ... ]
] )
[ INHERITS ( <replaceable>parent_table</replaceable> [, ... ] ) ]
[ PARTITION BY { RANGE | LIST } ( { <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">opclass</replaceable> ] [, ... ] ) ]
[ WITH ( <replaceable class="PARAMETER">storage_parameter</replaceable> [= <replaceable class="PARAMETER">value</replaceable>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <replaceable class="PARAMETER">tablespace_name</replaceable> ]

CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <replaceable class="PARAMETER">table_name</replaceable>
    OF <replaceable class="PARAMETER">type_name</replaceable> [ (
  { <replaceable class="PARAMETER">column_name</replaceable> [ WITH OPTIONS ] [ <replaceable class="PARAMETER">column_constraint</replaceable> [ ... ] ]
    | <replaceable>table_constraint</replaceable> }
    [, ... ]
) ]
[ PARTITION BY { RANGE | LIST } ( { <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">opclass</replaceable> ] [, ... ] ) ]
[ WITH ( <replaceable class="PARAMETER">storage_parameter</replaceable> [= <replaceable class="PARAMETER">value</replaceable>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <replaceable class="PARAMETER">tablespace_name</replaceable> ]

CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <replaceable class="PARAMETER">table_name</replaceable>
    PARTITION OF <replaceable class="PARAMETER">parent_table</replaceable> [ (
  { <replaceable class="PARAMETER">column_name</replaceable> [ WITH OPTIONS ] [ <replaceable class="PARAMETER">column_constraint</replaceable> [ ... ] ]
    | <replaceable>table_constraint</replaceable> }
    [, ... ]
) ] FOR VALUES <replaceable class="PARAMETER">partition_bound_spec</replaceable>
[ PARTITION BY { RANGE | LIST } ( { <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">opclass</replaceable> ] [, ... ] ) ]
[ WITH ( <replaceable class="PARAMETER">storage_parameter</replaceable> [= <replaceable class="PARAMETER">value</replaceable>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <replaceable class="PARAMETER">tablespace_name</replaceable> ]

<phrase>where <replaceable class="PARAMETER">column_constraint</replaceable> is:</phrase>

[ CONSTRAINT <replaceable class="PARAMETER">constraint_name</replaceable> ]
{ NOT NULL |
  NULL |
  CHECK ( <replaceable class="PARAMETER">expression</replaceable> ) [ NO INHERIT ] |
  DEFAULT <replaceable>default_expr</replaceable> |
  GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <replaceable>sequence_options</replaceable> ) ] |
  UNIQUE <replaceable class="PARAMETER">index_parameters</replaceable> |
  PRIMARY KEY <replaceable class="PARAMETER">index_parameters</replaceable> |
  REFERENCES <replaceable class="PARAMETER">reftable</replaceable> [ ( <replaceable class="PARAMETER">refcolumn</replaceable> ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]
    [ ON DELETE <replaceable class="parameter">action</replaceable> ] [ ON UPDATE <replaceable class="parameter">action</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<phrase>and <replaceable class="PARAMETER">table_constraint</replaceable> is:</phrase>

[ CONSTRAINT <replaceable class="PARAMETER">constraint_name</replaceable> ]
{ CHECK ( <replaceable class="PARAMETER">expression</replaceable> ) [ NO INHERIT ] |
  UNIQUE ( <replaceable class="PARAMETER">column_name</replaceable> [, ... ] ) <replaceable class="PARAMETER">index_parameters</replaceable> |
  PRIMARY KEY ( <replaceable class="PARAMETER">column_name</replaceable> [, ... ] ) <replaceable class="PARAMETER">index_parameters</replaceable> |
  EXCLUDE [ USING <replaceable class="parameter">index_method</replaceable> ] ( <replaceable class="parameter">exclude_element</replaceable> WITH <replaceable class="parameter">operator</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> [ WHERE ( <replaceable class="parameter">predicate</replaceable> ) ] |
  FOREIGN KEY ( <replaceable class="PARAMETER">column_name</replaceable> [, ... ] ) REFERENCES <replaceable class="PARAMETER">reftable</replaceable> [ ( <replaceable class="PARAMETER">refcolumn</replaceable> [, ... ] ) ]
    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE <replaceable class="parameter">action</replaceable> ] [ ON UPDATE <replaceable class="parameter">action</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<phrase>and <replaceable class="PARAMETER">like_option</replaceable> is:</phrase>

{ INCLUDING | EXCLUDING } { DEFAULTS | CONSTRAINTS | IDENTITY | INDEXES | STORAGE | COMMENTS | ALL }

<phrase>and <replaceable class="PARAMETER">partition_bound_spec</replaceable> is:</phrase>

IN ( { <replaceable class="PARAMETER">numeric_literal</replaceable> | <replaceable class="PARAMETER">string_literal</replaceable> | NULL } [, ...] ) |
FROM ( { <replaceable class="PARAMETER">numeric_literal</replaceable> | <replaceable class="PARAMETER">string_literal</replaceable> | MINVALUE | MAXVALUE } [, ...] )
  TO ( { <replaceable class="PARAMETER">numeric_literal</replaceable> | <replaceable class="PARAMETER">string_literal</replaceable> | MINVALUE | MAXVALUE } [, ...] )

<phrase><replaceable class="PARAMETER">index_parameters</replaceable> in <literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal>, and <literal>EXCLUDE</literal> constraints are:</phrase>

[ WITH ( <replaceable class="PARAMETER">storage_parameter</replaceable> [= <replaceable class="PARAMETER">value</replaceable>] [, ... ] ) ]
[ USING INDEX TABLESPACE <replaceable class="PARAMETER">tablespace_name</replaceable> ]

<phrase><replaceable class="PARAMETER">exclude_element</replaceable> in an <literal>EXCLUDE</literal> constraint is:</phrase>

{ <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ <replaceable class="parameter">opclass</replaceable> ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ]
</synopsis>
____________________________________________________________________________-->
<synopsis>
CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <replaceable class="PARAMETER">table_name</replaceable> ( [
  { <replaceable class="PARAMETER">column_name</replaceable> <replaceable class="PARAMETER">data_type</replaceable> [ COLLATE <replaceable>collation</replaceable> ] [ <replaceable class="PARAMETER">column_constraint</replaceable> [ ... ] ]
    | <replaceable>table_constraint</replaceable>
    | LIKE <replaceable>source_table</replaceable> [ <replaceable>like_option</replaceable> ... ] }
    [, ... ]
] )
[ INHERITS ( <replaceable>parent_table</replaceable> [, ... ] ) ]
[ PARTITION BY { RANGE | LIST } ( { <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">opclass</replaceable> ] [, ... ] ) ]
[ WITH ( <replaceable class="PARAMETER">storage_parameter</replaceable> [= <replaceable class="PARAMETER">value</replaceable>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <replaceable class="PARAMETER">tablespace_name</replaceable> ]

CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <replaceable class="PARAMETER">table_name</replaceable>
    OF <replaceable class="PARAMETER">type_name</replaceable> [ (
  { <replaceable class="PARAMETER">column_name</replaceable> [ WITH OPTIONS ] [ <replaceable class="PARAMETER">column_constraint</replaceable> [ ... ] ]
    | <replaceable>table_constraint</replaceable> }
    [, ... ]
) ]
[ PARTITION BY { RANGE | LIST } ( { <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">opclass</replaceable> ] [, ... ] ) ]
[ WITH ( <replaceable class="PARAMETER">storage_parameter</replaceable> [= <replaceable class="PARAMETER">value</replaceable>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <replaceable class="PARAMETER">tablespace_name</replaceable> ]

CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <replaceable class="PARAMETER">table_name</replaceable>
    PARTITION OF <replaceable class="PARAMETER">parent_table</replaceable> [ (
  { <replaceable class="PARAMETER">column_name</replaceable> [ WITH OPTIONS ] [ <replaceable class="PARAMETER">column_constraint</replaceable> [ ... ] ]
    | <replaceable>table_constraint</replaceable> }
    [, ... ]
) ] FOR VALUES <replaceable class="PARAMETER">partition_bound_spec</replaceable>
[ PARTITION BY { RANGE | LIST } ( { <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">opclass</replaceable> ] [, ... ] ) ]
[ WITH ( <replaceable class="PARAMETER">storage_parameter</replaceable> [= <replaceable class="PARAMETER">value</replaceable>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <replaceable class="PARAMETER">tablespace_name</replaceable> ]

<phrase>其中 <replaceable class="PARAMETER">column_constraint</replaceable> 是：</phrase>

[ CONSTRAINT <replaceable class="PARAMETER">constraint_name</replaceable> ]
{ NOT NULL |
  NULL |
  CHECK ( <replaceable class="PARAMETER">expression</replaceable> ) [ NO INHERIT ] |
  DEFAULT <replaceable>default_expr</replaceable> |
  GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <replaceable>sequence_options</replaceable> ) ] |
  UNIQUE <replaceable class="PARAMETER">index_parameters</replaceable> |
  PRIMARY KEY <replaceable class="PARAMETER">index_parameters</replaceable> |
  REFERENCES <replaceable class="PARAMETER">reftable</replaceable> [ ( <replaceable class="PARAMETER">refcolumn</replaceable> ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]
    [ ON DELETE <replaceable class="parameter">action</replaceable> ] [ ON UPDATE <replaceable class="parameter">action</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<phrase><replaceable class="PARAMETER">table_constraint</replaceable> 是：</phrase>

[ CONSTRAINT <replaceable class="PARAMETER">constraint_name</replaceable> ]
{ CHECK ( <replaceable class="PARAMETER">expression</replaceable> ) [ NO INHERIT ] |
  UNIQUE ( <replaceable class="PARAMETER">column_name</replaceable> [, ... ] ) <replaceable class="PARAMETER">index_parameters</replaceable> |
  PRIMARY KEY ( <replaceable class="PARAMETER">column_name</replaceable> [, ... ] ) <replaceable class="PARAMETER">index_parameters</replaceable> |
  EXCLUDE [ USING <replaceable class="parameter">index_method</replaceable> ] ( <replaceable class="parameter">exclude_element</replaceable> WITH <replaceable class="parameter">operator</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> [ WHERE ( <replaceable class="parameter">predicate</replaceable> ) ] |
  FOREIGN KEY ( <replaceable class="PARAMETER">column_name</replaceable> [, ... ] ) REFERENCES <replaceable class="PARAMETER">reftable</replaceable> [ ( <replaceable class="PARAMETER">refcolumn</replaceable> [, ... ] ) ]
    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE <replaceable class="parameter">action</replaceable> ] [ ON UPDATE <replaceable class="parameter">action</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<phrase><replaceable class="PARAMETER">like_option</replaceable> 是：</phrase>

{ INCLUDING | EXCLUDING } { DEFAULTS | CONSTRAINTS | IDENTITY | INDEXES | STORAGE | COMMENTS | ALL }

<phrase><replaceable class="PARAMETER">partition_bound_spec</replaceable> 是:</phrase>

IN ( { <replaceable class="PARAMETER">numeric_literal</replaceable> | <replaceable class="PARAMETER">string_literal</replaceable> | NULL } [, ...] ) |
FROM ( { <replaceable class="PARAMETER">numeric_literal</replaceable> | <replaceable class="PARAMETER">string_literal</replaceable> | MINVALUE | MAXVALUE } [, ...] )
  TO ( { <replaceable class="PARAMETER">numeric_literal</replaceable> | <replaceable class="PARAMETER">string_literal</replaceable> | MINVALUE | MAXVALUE } [, ...] )

<literal>UNIQUE</literal>、<literal>PRIMARY KEY</literal>以及<literal>EXCLUDE</literal>约束中的<phrase><replaceable class="PARAMETER">index_parameters</replaceable>是：</phrase>

[ WITH ( <replaceable class="PARAMETER">storage_parameter</replaceable> [= <replaceable class="PARAMETER">value</replaceable>] [, ... ] ) ]
[ USING INDEX TABLESPACE <replaceable class="PARAMETER">tablespace_name</replaceable> ]

一个<literal>EXCLUDE</literal>约束中的<phrase><replaceable class="PARAMETER">exclude_element</replaceable>是：</phrase>

{ <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ <replaceable class="parameter">opclass</replaceable> ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ]
</synopsis>

 </refsynopsisdiv>

 <refsect1 id="SQL-CREATETABLE-description">
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <command>CREATE TABLE</command> will create a new, initially empty table
   in the current database. The table will be owned by the user issuing the
   command.
  </para>
____________________________________________________________________________-->
  <para>
   <command>CREATE TABLE</command>将在当前数据库中创建一个新的、初始为空的表。该表将由发出该命令的用户所拥有。
  </para>

<!--==========================orignal english content==========================
  <para>
   If a schema name is given (for example, <literal>CREATE TABLE
   myschema.mytable ...</>) then the table is created in the specified
   schema.  Otherwise it is created in the current schema.  Temporary
   tables exist in a special schema, so a schema name cannot be given
   when creating a temporary table.  The name of the table must be
   distinct from the name of any other table, sequence, index, view,
   or foreign table in the same schema.
  </para>
____________________________________________________________________________-->
  <para>
   如果给定了一个模式名（例如<literal>CREATE TABLE myschema.mytable ...</>），那么该表被创建在指定的模式中。否则它被创建在当前模式中。临时表存在于一个特殊的模式中，因此在创建一个临时表时不能给定一个模式名。该表的名称必须与同一个模式中的任何其他表、序列、索引、视图或外部表的名称区分开。
  </para>

<!--==========================orignal english content==========================
  <para>
   <command>CREATE TABLE</command> also automatically creates a data
   type that represents the composite type corresponding
   to one row of the table.  Therefore, tables cannot have the same
   name as any existing data type in the same schema.
  </para>
____________________________________________________________________________-->
  <para>
   <command>CREATE TABLE</command>也会自动地创建一个数据类型来表示对应于该表一行的组合类型。因此，表不能用同一个模式中任何已有数据类型的名称。
  </para>

<!--==========================orignal english content==========================
  <para>
   The optional constraint clauses specify constraints (tests) that
   new or updated rows must satisfy for an insert or update operation
   to succeed.  A constraint is an SQL object that helps define the
   set of valid values in the table in various ways.
  </para>
____________________________________________________________________________-->
  <para>
   可选的约束子句指定一个插入或更新操作要成功，新的或更新过的行必须满足的约束（测试）。一个约束是一个 SQL 对象，它帮助以多种方式定义表中的合法值集合。
  </para>

<!--==========================orignal english content==========================
  <para>
   There are two ways to define constraints: table constraints and
   column constraints.  A column constraint is defined as part of a
   column definition.  A table constraint definition is not tied to a
   particular column, and it can encompass more than one column.
   Every column constraint can also be written as a table constraint;
   a column constraint is only a notational convenience for use when the
   constraint only affects one column.
  </para>
____________________________________________________________________________-->
  <para>
   有两种方式来定义约束：表约束和列约束。一个列约束会作为列定义的一部分定义。一个表约束定义不与一个特定列绑定，并且它可以包含多于一个列。每一个列约束也可以被写作一个表约束，列约束只是一种当约束只影响一列时方便书写的记号习惯。
  </para>

<!--==========================orignal english content==========================
  <para>
   To be able to create a table, you must have <literal>USAGE</literal>
   privilege on all column types or the type in the <literal>OF</literal>
   clause, respectively.
  </para>
____________________________________________________________________________-->
  <para>
   要能创建一个表，你必须分别具有所有列类型或<literal>OF</literal>子句中类型的<literal>USAGE</literal>特权。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Parameters</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>

   <varlistentry id="SQL-CREATETABLE-TEMPORARY">
<!--==========================orignal english content==========================
    <term><literal>TEMPORARY</> or <literal>TEMP</></term>
____________________________________________________________________________-->
    <term><literal>TEMPORARY</> or <literal>TEMP</></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      If specified, the table is created as a temporary table.
      Temporary tables are automatically dropped at the end of a
      session, or optionally at the end of the current transaction
      (see <literal>ON COMMIT</literal> below).  Existing permanent
      tables with the same name are not visible to the current session
      while the temporary table exists, unless they are referenced
      with schema-qualified names. Any indexes created on a temporary
      table are automatically temporary as well.
     </para>
____________________________________________________________________________-->
     <para>
      如果指定，该表被创建为一个临时表。临时表会被在会话结束时自动被删除，或者也可以选择在当前事务结束时删除（见下文的<literal>ON COMMIT</literal>）。当临时表存在时，已有的同名持久表将对于当前会话不可见，不过可以使用模式限定的名称进行引用。在一个临时表上创建的任何索引也自动地变为临时的。
     </para>

<!--==========================orignal english content==========================
     <para>
      The <link linkend="autovacuum">autovacuum daemon</link> cannot
      access and therefore cannot vacuum or analyze temporary tables.
      For this reason, appropriate vacuum and analyze operations should be
      performed via session SQL commands.  For example, if a temporary
      table is going to be used in complex queries, it is wise to run
      <command>ANALYZE</> on the temporary table after it is populated.
     </para>
____________________________________________________________________________-->
     <para>
      <link linkend="autovacuum">自动清理守护进程</link>不能访问并且因此也不能清理或分析临时表。由于这个原因，应该通过会话的 SQL 命令执行合适的清理和分析操作。例如，如果一个临时表将要被用于复杂的查询，最好在把它填充完毕后在其上运行<command>ANALYZE</>。
     </para>

<!--==========================orignal english content==========================
     <para>
      Optionally, <literal>GLOBAL</literal> or <literal>LOCAL</literal>
      can be written before <literal>TEMPORARY</> or <literal>TEMP</>.
      This presently makes no difference in <productname>PostgreSQL</>
      and is deprecated; see
      <xref linkend="sql-createtable-compatibility"
      endterm="sql-createtable-compatibility-title">.
     </para>
____________________________________________________________________________-->
     <para>
      可以选择将<literal>GLOBAL</literal>或<literal>LOCAL</literal>写在<literal>TEMPORARY</>或<literal>TEMP</>的前面。这当前在<productname>PostgreSQL</>中没有区别并且已被废弃，见<xref linkend="sql-createtable-compatibility" endterm="sql-createtable-compatibility-title">。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="SQL-CREATETABLE-UNLOGGED">
<!--==========================orignal english content==========================
    <term><literal>UNLOGGED</></term>
____________________________________________________________________________-->
    <term><literal>UNLOGGED</></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      If specified, the table is created as an unlogged table.  Data written
      to unlogged tables is not written to the write-ahead log (see <xref
      linkend="wal">), which makes them considerably faster than ordinary
      tables.  However, they are not crash-safe: an unlogged table is
      automatically truncated after a crash or unclean shutdown.  The contents
      of an unlogged table are also not replicated to standby servers.
      Any indexes created on an unlogged table are automatically unlogged as
      well.
     </para>
____________________________________________________________________________-->
     <para>
      如果指定，该表被创建为一个不受日志记录的表。被写入到不做日志的表中的数据不会被写到预写式日志中（见<xref linkend="wal">），这让它们比普通表快非常多。不过，它们在崩溃时是不安全的：一个不做日志的表在一次崩溃或非干净关闭之后会被自动地截断。一个不做日志的表中的内容也不会被复制到后备服务器中。在一个不做日志的表上创建的任何索引也会自动地不被日志记录。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>IF NOT EXISTS</></term>
____________________________________________________________________________-->
    <term><literal>IF NOT EXISTS</></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Do not throw an error if a relation with the same name already exists.
      A notice is issued in this case.  Note that there is no guarantee that
      the existing relation is anything like the one that would have been
      created.
     </para>
____________________________________________________________________________-->
     <para>
      如果一个同名关系已经存在，不要抛出一个错误。在这种情况下会发出一个提示。注意这不保证现有的关系是和将要被创建的表相似的东西。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="PARAMETER">table_name</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="PARAMETER">table_name</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The name (optionally schema-qualified) of the table to be created.
     </para>
____________________________________________________________________________-->
     <para>
      要被创建的表名（可以选择用模式限定）。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>OF <replaceable class="PARAMETER">type_name</replaceable></literal></term>
____________________________________________________________________________-->
    <term><literal>OF <replaceable class="PARAMETER">type_name</replaceable></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Creates a <firstterm>typed table</firstterm>, which takes its
      structure from the specified composite type (name optionally
      schema-qualified).  A typed table is tied to its type; for
      example the table will be dropped if the type is dropped
      (with <literal>DROP TYPE ... CASCADE</literal>).
     </para>
____________________________________________________________________________-->
     <para>
      创建一个<firstterm>类型化的表</firstterm>，它的结构取自于指定的组合类型（名字可以选择用模式限定）。一个类型化的表和它的类型绑定在一起，例如如果类型被删除，该表也将被删除（用<literal>DROP TYPE ... CASCADE</literal>）。
     </para>

<!--==========================orignal english content==========================
     <para>
      When a typed table is created, then the data types of the
      columns are determined by the underlying composite type and are
      not specified by the <literal>CREATE TABLE</literal> command.
      But the <literal>CREATE TABLE</literal> command can add defaults
      and constraints to the table and can specify storage parameters.
     </para>
____________________________________________________________________________-->
     <para>
      当一个类型化的表被创建时，列的数据类型由底层的组合类型决定而没有在<literal>CREATE TABLE</literal>命令中直接指定。但是<literal>CREATE TABLE</literal>命令可以对表增加默认值和约束，并且可以指定存储参数。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry id="SQL-CREATETABLE-PARTITION">
<!--==========================orignal english content==========================
    <term><literal>PARTITION OF <replaceable class="PARAMETER">parent_table</replaceable> FOR VALUES <replaceable class="PARAMETER">partition_bound_spec</replaceable></literal></term>
____________________________________________________________________________-->
    <term><literal>PARTITION OF <replaceable class="PARAMETER">parent_table</replaceable> FOR VALUES <replaceable class="PARAMETER">partition_bound_spec</replaceable></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Creates the table as a <firstterm>partition</firstterm> of the specified
      parent table.
     </para>
____________________________________________________________________________-->
     <para>
      将表创建为指定父表的<firstterm>分区</firstterm>。
     </para>

<!--==========================orignal english content==========================
     <para>
      The <replaceable class="PARAMETER">partition_bound_spec</replaceable>
      must correspond to the partitioning method and partition key of the
      parent table, and must not overlap with any existing partition of that
      parent.  The form with <literal>IN</> is used for list partitioning,
      while the form with <literal>FROM</> and <literal>TO</> is used for
      range partitioning.
     </para>
____________________________________________________________________________-->
     <para>
      <replaceable class="PARAMETER">partition_bound_spec</replaceable>
	  必须对应于父表的分区方法和分区键，并且必须不能与该父表的任何现有分区重叠。
	  形式用于列表分区，<literal>FROM</>和<literal>TO</>形式用于范围分区。
     </para>

<!--==========================orignal english content==========================
     <para>
      Each of the values specified in
      the <replaceable class="PARAMETER">partition_bound_spec</> is
      a literal, <literal>NULL</literal>, <literal>MINVALUE</literal>, or
      <literal>MAXVALUE</literal>.  Each literal value must be either a
      numeric constant that is coercible to the corresponding partition key
      column's type, or a string literal that is valid input for that type.
     </para>
____________________________________________________________________________-->
     <para>
      在<replaceable class="PARAMETER">partition_bound_spec</>
	  中指定的每个值都是一个文字、<literal>NULL</literal>、<literal>MINVALUE</literal>
	  或<literal>MAXVALUE</literal>。每个文字值必须是可对相应的分区键列类型强制的数字常量，
	  或者是该类型的有效输入的字符串文字。
     </para>

<!--==========================orignal english content==========================
     <para>
      When creating a list partition, <literal>NULL</literal> can be
      specified to signify that the partition allows the partition key
      column to be null.  However, there cannot be more than one such
      list partition for a given parent table.  <literal>NULL</literal>
      cannot be specified for range partitions.
     </para>
____________________________________________________________________________-->
     <para>
      在创建列表分区时，可以指定<literal>NULL</literal>来表示分区允许分区键列为空。
	  但是，给定父表不能有多于一个这样的列表分区。无法为范围分区指定
	  <literal>NULL</literal>。
     </para>

<!--==========================orignal english content==========================
     <para>
      When creating a range partition, the lower bound specified with
      <literal>FROM</literal> is an inclusive bound, whereas the upper
      bound specified with <literal>TO</literal> is an exclusive bound.
      That is, the values specified in the <literal>FROM</literal> list
      are valid values of the corresponding partition key columns for this
      partition, whereas those in the <literal>TO</literal> list are
      not.  Note that this statement must be understood according to the
      rules of row-wise comparison (<xref linkend="row-wise-comparison">).
      For example, given <literal>PARTITION BY RANGE (x,y)</>, a partition
      bound <literal>FROM (1, 2) TO (3, 4)</literal>
      allows <literal>x=1</> with any <literal>y&gt;=2</>,
      <literal>x=2</> with any non-null <literal>y</>,
      and <literal>x=3</> with any <literal>y&lt;4</>.
     </para>
____________________________________________________________________________-->
     <para>
      创建范围分区时，由<literal>FROM</literal>指定的下限是一个包含范围，
	  而用<literal>TO</literal>指定的上限是排除范围。也就是说，
	  在<literal>FROM</literal>列表中指定的值是该分区的相应分区键列的有效值，
	  而<literal>TO</literal>列表中的值不是。请注意，
	  必须根据按行比较的规则来理解此语句（<xref linkend="row-wise-comparison">）。
	  例如，给定<literal>PARTITION BY RANGE (x,y)</>，分区范围
	  <literal>FROM (1, 2) TO (3, 4)</literal>允许<literal>x=1</>与任何<literal>y&gt;=2</>，
	  <literal>x=2</>与任何非空<literal>y</>，和<literal>x=3</>与任何<literal>y&lt;4</>。
     </para>

<!--==========================orignal english content==========================
     <para>
      The special values <literal>MINVALUE</> and <literal>MAXVALUE</>
      may be used when creating a range partition to indicate that there
      is no lower or upper bound on the column's value. For example, a
      partition defined using <literal>FROM (MINVALUE) TO (10)</> allows
      any values less than 10, and a partition defined using
      <literal>FROM (10) TO (MAXVALUE)</> allows any values greater than
      or equal to 10.
     </para>
____________________________________________________________________________-->
     <para>
      在创建范围分区以指示列值没有下限或上限时，可以使用特殊值<literal>MINVALUE</>
	  和<literal>MAXVALUE</>。例如，使用<literal>FROM (MINVALUE) TO (10)</>
	  定义的分区允许任何小于10的值，并且使用<literal>FROM (10) TO (MAXVALUE)</>
	  定义的分区允许任何大于或等于10的值。
     </para>

<!--==========================orignal english content==========================
     <para>
      When creating a range partition involving more than one column, it
      can also make sense to use <literal>MAXVALUE</> as part of the lower
      bound, and <literal>MINVALUE</> as part of the upper bound. For
      example, a partition defined using
      <literal>FROM (0, MAXVALUE) TO (10, MAXVALUE)</> allows any rows
      where the first partition key column is greater than 0 and less than
      or equal to 10. Similarly, a partition defined using
      <literal>FROM ('a', MINVALUE) TO ('b', MINVALUE)</> allows any rows
      where the first partition key column starts with "a".
     </para>
____________________________________________________________________________-->
     <para>
      创建涉及多个列的范围分区时，将<literal>MAXVALUE</>作为下限的一部分并将
	  <literal>MINVALUE</>作为上限的一部分也是有意义的。例如，使用
	  <literal>FROM (0, MAXVALUE) TO (10, MAXVALUE)</>
	  定义的分区允许第一个分区键列大于0且小于或等于10的任何行。类似地，
	  使用<literal>FROM ('a', MINVALUE) TO ('b', MINVALUE)</>定义的分区
	  允许第一个分区键列以"a"开头的任何行。
     </para>

<!--==========================orignal english content==========================
     <para>
      Note that if <literal>MINVALUE</> or <literal>MAXVALUE</> is used for
      one column of a partitioning bound, the same value must be used for all
      subsequent columns.  For example, <literal>(10, MINVALUE, 0)</> is not
      a valid bound; you should write <literal>(10, MINVALUE, MINVALUE)</>.
     </para>
____________________________________________________________________________-->
     <para>
      请注意，如果<literal>MINVALUE</>或<literal>MAXVALUE</>用于分区边界的一列，
	  则必须为所有后续列使用相同的值。例如，<literal>(10, MINVALUE, 0)</>
	  不是有效的边界；你应该写<literal>(10, MINVALUE, MINVALUE)</>。
     </para>

<!--==========================orignal english content==========================
     <para>
      Also note that some element types, such as <literal>timestamp</>,
      have a notion of "infinity", which is just another value that can
      be stored. This is different from <literal>MINVALUE</> and
      <literal>MAXVALUE</>, which are not real values that can be stored,
      but rather they are ways of saying that the value is unbounded.
      <literal>MAXVALUE</> can be thought of as being greater than any
      other value, including "infinity" and <literal>MINVALUE</> as being
      less than any other value, including "minus infinity". Thus the range
      <literal>FROM ('infinity') TO (MAXVALUE)</> is not an empty range; it
      allows precisely one value to be stored &mdash; "infinity".
     </para>
____________________________________________________________________________-->
     <para>
      还要注意，某些元素类型，如<literal>timestamp</>，具有“无穷”的概念，
	  这只是另一个可以存储的值。这与<literal>MINVALUE</>和<literal>MAXVALUE</>不同，
	  它们不是可以存储的实际值，而是它们表示值无界的方式。<literal>MAXVALUE</> 
	  可以被认为比任何其他值（包括“无穷”）都大的值，<literal>MINVALUE</>
	  可以被认为是比任何其他值（包括“负无穷”）都小的值。因此，
	  范围<literal>FROM ('infinity') TO (MAXVALUE)</>不是空的范围；
	  它只允许存储一个值&mdash; "infinity"。
     </para>

<!--==========================orignal english content==========================
     <para>
      A partition must have the same column names and types as the partitioned
      table to which it belongs.  If the parent is specified <literal>WITH
      OIDS</literal> then all partitions must have OIDs; the parent's OID
      column will be inherited by all partitions just like any other column.
      Modifications to the column names or types of a partitioned table, or
      the addition or removal of an OID column, will automatically propagate
      to all partitions.  <literal>CHECK</> constraints will be inherited
      automatically by every partition, but an individual partition may specify
      additional <literal>CHECK</> constraints; additional constraints with
      the same name and condition as in the parent will be merged with the
      parent constraint.  Defaults may be specified separately for each
      partition.
     </para>
____________________________________________________________________________-->
     <para>
      分区必须与其所属的分区表的字段名和类型相同。如果父表声明为<literal>WITH
      OIDS</literal>那么所有的分区必须具有OID；父表的OID字段和其他字段一样被所有分区继承。
	  对分区表字段名或类型的修改，或者OID字段的添加或删除，将自动传播到所有分区。
	  <literal>CHECK</>约束将自动被每一个分区继承，但是单独的分区可以指定额外的
	  <literal>CHECK</>约束；与父表相同名称和条件的额外约束将被父表约束合并。
	  可以为每个分区分别指定默认值。
     </para>

<!--==========================orignal english content==========================
     <para>
      Rows inserted into a partitioned table will be automatically routed to
      the correct partition.  If no suitable partition exists, an error will
      occur.  Also, if updating a row in a given partition would require it
      to move to another partition due to new partition key values, an error
      will occur.
     </para>
____________________________________________________________________________-->
     <para>
      插入分区表中的行将自动路由到正确的分区。如果不存在合适的分区，则会发生错误。
	  另外，如果更新给定分区中的行由于新的分区键值而要求它移动到另一分区，则会发生错误。
     </para>

<!--==========================orignal english content==========================
     <para>
      Operations such as TRUNCATE which normally affect a table and all of its
      inheritance children will cascade to all partitions, but may also be
      performed on an individual partition.  Note that dropping a partition
      with <literal>DROP TABLE</literal> requires taking an <literal>ACCESS
      EXCLUSIVE</literal> lock on the parent table.
     </para>
____________________________________________________________________________-->
     <para>
      像TRUNCATE这样的操作通常会影响一个表及其所有继承子级，这些操作将级联到所有分区，
	  但也可能在单个分区上执行。请注意，使用<literal>DROP TABLE</literal>
	  删除分区需要在父表上采用<literal>ACCESS EXCLUSIVE</literal>锁。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="PARAMETER">column_name</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="PARAMETER">column_name</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The name of a column to be created in the new table.
     </para>
____________________________________________________________________________-->
     <para>
      要在新表中创建的一列的名称。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="PARAMETER">data_type</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="PARAMETER">data_type</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The data type of the column. This can include array
      specifiers. For more information on the data types supported by
      <productname>PostgreSQL</productname>, refer to <xref
      linkend="datatype">.
     </para>
____________________________________________________________________________-->
     <para>
      该列的数据类型。这可以包括数组说明符。更多关于<productname>PostgreSQL</productname>支持的数据类型，请参考<xref linkend="datatype">。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>COLLATE <replaceable>collation</replaceable></literal></term>
____________________________________________________________________________-->
    <term><literal>COLLATE <replaceable>collation</replaceable></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The <literal>COLLATE</> clause assigns a collation to
      the column (which must be of a collatable data type).
      If not specified, the column data type's default collation is used.
     </para>
____________________________________________________________________________-->
     <para>
      <literal>COLLATE</>子句为该列（必须是一种可排序数据类型）赋予一个排序规则。如果没有指定，将使用该列数据类型的默认排序规则。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>INHERITS ( <replaceable>parent_table</replaceable> [, ... ] )</literal></term>
____________________________________________________________________________-->
    <term><literal>INHERITS ( <replaceable>parent_table</replaceable> [, ... ] )</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The optional <literal>INHERITS</> clause specifies a list of
      tables from which the new table automatically inherits all
      columns.  Parent tables can be plain tables or foreign tables.
     </para>
____________________________________________________________________________-->
     <para>
      可选的<literal>INHERITS</>子句指定一个表的列表，新表将从其中自动地继承所有列。父表可以是普通表或者外部表。
     </para>

<!--==========================orignal english content==========================
     <para>
      Use of <literal>INHERITS</> creates a persistent relationship
      between the new child table and its parent table(s).  Schema
      modifications to the parent(s) normally propagate to children
      as well, and by default the data of the child table is included in
      scans of the parent(s).
     </para>
____________________________________________________________________________-->
     <para>
      <literal>INHERITS</>的使用在新的子表和它的父表之间创建一种持久的关系。对于父表的模式修改通常也会传播到子表，并且默认情况下子表的数据会被包括在对父表的扫描中。
     </para>

<!--==========================orignal english content==========================
     <para>
      If the same column name exists in more than one parent
      table, an error is reported unless the data types of the columns
      match in each of the parent tables.  If there is no conflict,
      then the duplicate columns are merged to form a single column in
      the new table.  If the column name list of the new table
      contains a column name that is also inherited, the data type must
      likewise match the inherited column(s), and the column
      definitions are merged into one.  If the
      new table explicitly specifies a default value for the column,
      this default overrides any defaults from inherited declarations
      of the column.  Otherwise, any parents that specify default
      values for the column must all specify the same default, or an
      error will be reported.
     </para>
____________________________________________________________________________-->
     <para>
      如果在多个父表中存在同名的列，除非父表中每一个这种列的数据类型都能匹配，否则会报告一个错误。如果没有冲突，那么重复列会被融合来形成新表中的一个单一列。如果新表中的列名列表包含一个也是继承而来的列名，该数据类型必须也匹配继承的列，并且列定义会被融合成一个。如果新表显式地为列指定了任何默认值，这个默认值将覆盖来自该列继承声明中的默认值。否则，任何父表都必须为该列指定相同的默认值，或者会报告一个错误。
     </para>

<!--==========================orignal english content==========================
     <para>
      <literal>CHECK</> constraints are merged in essentially the same way as
      columns: if multiple parent tables and/or the new table definition
      contain identically-named <literal>CHECK</> constraints, these
      constraints must all have the same check expression, or an error will be
      reported.  Constraints having the same name and expression will
      be merged into one copy.  A constraint marked <literal>NO INHERIT</> in a
      parent will not be considered.  Notice that an unnamed <literal>CHECK</>
      constraint in the new table will never be merged, since a unique name
      will always be chosen for it.
     </para>
____________________________________________________________________________-->
     <para>
      <literal>CHECK</>约束本质上也采用和列相同的方式被融合：如果多个父表或者新表定义中包含相同的命名<literal>CHECK</>约束，这些约束必须全部具有相同的检查表达式，否则将报告一个错误。具有相同名称和表达式的约束将被融合成一份拷贝。一个父表中的被标记为<literal>NO INHERIT</>的约束将不会被考虑。注意新表中一个未命名的<literal>CHECK</>约束将永远不会被融合，因为那样总是会为它选择一个唯一的名字。
     </para>

<!--==========================orignal english content==========================
     <para>
      Column <literal>STORAGE</> settings are also copied from parent tables.
     </para>
____________________________________________________________________________-->
     <para>
      列的<literal>STORAGE</>设置也会从父表复制过来。
     </para>
<!--==========================orignal english content==========================
     <para>
      If a column in the parent table is an identity column, that property is
      not inherited.  A column in the child table can be declared identity
      column if desired.
     </para>
____________________________________________________________________________-->
     <para>
      如果父表中的列是标识列，那么该属性不会被继承。如果需要，
	  可以将子表中的列声明为标识列。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>PARTITION BY { RANGE | LIST } ( { <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ <replaceable class="parameter">opclass</replaceable> ] [, ...] ) </literal></term>
____________________________________________________________________________-->
    <term><literal>PARTITION BY { RANGE | LIST } ( { <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ <replaceable class="parameter">opclass</replaceable> ] [, ...] ) </literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The optional <literal>PARTITION BY</literal> clause specifies a strategy
      of partitioning the table.  The table thus created is called a
      <firstterm>partitioned</firstterm> table.  The parenthesized list of
      columns or expressions forms the <firstterm>partition key</firstterm>
      for the table.  When using range partitioning, the partition key can
      include multiple columns or expressions (up to 32, but this limit can be
      altered when building <productname>PostgreSQL</productname>), but for
      list partitioning, the partition key must consist of a single column or
      expression.  If no B-tree operator class is specified when creating a
      partitioned table, the default B-tree operator class for the datatype will
      be used.  If there is none, an error will be reported.
     </para>
____________________________________________________________________________-->
     <para>
      可选的<literal>PARTITION BY</literal>子句指定了对表进行分区的策略。
	  这样创建的表称为<firstterm>分区</firstterm>表。
	  带括号的列或表达式列表形成表的<firstterm>分区键</firstterm>。
	  使用范围分区时，分区键可以包含多个列或表达式（最多32个，但在构建
	  <productname>PostgreSQL</productname>时可以更改此限制），但对于列表分区，
	  分区键必须由单个列或表达式组成。如果在创建分区表时未指定B树操作符类，
	  则将使用该数据类型的默认B树操作符类。如果没有，则会报告错误。
     </para>

<!--==========================orignal english content==========================
     <para>
      A partitioned table is divided into sub-tables (called partitions),
      which are created using separate <literal>CREATE TABLE</> commands.
      The partitioned table is itself empty.  A data row inserted into the
      table is routed to a partition based on the value of columns or
      expressions in the partition key.  If no existing partition matches
      the values in the new row, an error will be reported.
     </para>
____________________________________________________________________________-->
     <para>
      分区表被分成多个子表（称为分区），它们是使用单独的<literal>CREATE TABLE</>命令创建的。
	  分区表本身是空的。插入到表中的数据行将根据分区键中的列或表达式的值路由到分区。
	  如果没有现有的分区与新行中的值匹配，则会报告错误。
     </para>

<!--==========================orignal english content==========================
     <para>
      Partitioned tables do not support <literal>UNIQUE</literal>,
      <literal>PRIMARY KEY</literal>, <literal>EXCLUDE</literal>, or
      <literal>FOREIGN KEY</literal> constraints; however, you can define
      these constraints on individual partitions.
     </para>
____________________________________________________________________________-->
     <para>
      分区表不支持<literal>UNIQUE</literal>、
      <literal>PRIMARY KEY</literal>、<literal>EXCLUDE</literal>或
      <literal>FOREIGN KEY</literal>约束；不过，可以在单个分区中定义这些约束。
     </para>

    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>LIKE <replaceable>source_table</replaceable> [ <replaceable>like_option</replaceable> ... ]</literal></term>
____________________________________________________________________________-->
    <term><literal>LIKE <replaceable>source_table</replaceable> [ <replaceable>like_option</replaceable> ... ]</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The <literal>LIKE</literal> clause specifies a table from which
      the new table automatically copies all column names, their data types,
      and their not-null constraints.
     </para>
____________________________________________________________________________-->
     <para>
      <literal>LIKE</literal>指定新表将从哪一个表自动地复制所有的列名、数据类型以及它们的非空约束。
     </para>
<!--==========================orignal english content==========================
     <para>
      Unlike <literal>INHERITS</literal>, the new table and original table
      are completely decoupled after creation is complete.  Changes to the
      original table will not be applied to the new table, and it is not
      possible to include data of the new table in scans of the original
      table.
     </para>
____________________________________________________________________________-->
     <para>
      和<literal>INHERITS</literal>不同，新表和原始表在创建完成之后是完全分离的。对原始表的更改将不会被应用到新表，并且不可能在原始表的扫描中包括新表的数据。
     </para>
<!--==========================orignal english content==========================
     <para>
      Default expressions for the copied column definitions will be copied
      only if <literal>INCLUDING DEFAULTS</literal> is specified.  The
      default behavior is to exclude default expressions, resulting in the
      copied columns in the new table having null defaults.
      Note that copying defaults that call database-modification functions,
      such as <function>nextval</>, may create a functional linkage between
      the original and new tables.
     </para>
____________________________________________________________________________-->
     <para>
      只有<literal>INCLUDING DEFAULTS</literal>被指定时，被拷贝的列定义的默认表达式才会被拷贝。默认的行为是排除默认表达式，导致新表中被拷贝过来的列的默认值为空值。注意，如果拷贝的默认值调用了数据库修改函数（如<function>nextval</>），则可能在原始表和新表之间创建功能联系。
     </para>
<!--==========================orignal english content==========================
     <para>
      Any identity specifications of copied column definitions will only be
      copied if <literal>INCLUDING IDENTITY</literal> is specified.  A new
      sequence is created for each identity column of the new table, separate
      from the sequences associated with the old table.
     </para>
____________________________________________________________________________-->
     <para>
      仅在声明了<literal>INCLUDING IDENTITY</literal>的情况下拷贝复制字段定义的标识声明。
	  为新表的每个标识列创建一个新的序列，与旧表相关的序列区分开。
     </para>
<!--==========================orignal english content==========================
     <para>
      Not-null constraints are always copied to the new table.
      <literal>CHECK</literal> constraints will be copied only if
      <literal>INCLUDING CONSTRAINTS</literal> is specified.
      No distinction is made between column constraints and table
      constraints.
     </para>
____________________________________________________________________________-->
     <para>
      非空约束总是会被复制到新表。<literal>CHECK</literal>约束只有在<literal>INCLUDING CONSTRAINTS</literal>被指定时才会被复制。列约束和表约束之间没有区别对待。
     </para>
<!--==========================orignal english content==========================
     <para>
      Indexes, <literal>PRIMARY KEY</>, <literal>UNIQUE</>,
      and <literal>EXCLUDE</> constraints on the original table will be
      created on the new table only if <literal>INCLUDING INDEXES</literal>
      is specified.  Names for the new indexes and constraints are
      chosen according to the default rules, regardless of how the originals
      were named.  (This behavior avoids possible duplicate-name failures for
      the new indexes.)
     </para>
____________________________________________________________________________-->
     <para>
      只有<literal>INCLUDING INDEXES</literal>被指定时，原始表上的索引、<literal>PRIMARY KEY</>、<literal>UNIQUE</>以及<literal>EXCLUDE</>约束将被创建在新表上。新索引和约束的名称将根据默认规则选定，而不管原始的名称如何（这种行为可以避免新索引重名导致的失败）。
     </para>
<!--==========================orignal english content==========================
     <para>
      <literal>STORAGE</> settings for the copied column definitions will be
      copied only if <literal>INCLUDING STORAGE</literal> is specified.  The
      default behavior is to exclude <literal>STORAGE</> settings, resulting
      in the copied columns in the new table having type-specific default
      settings.  For more on <literal>STORAGE</> settings, see
      <xref linkend="storage-toast">.
     </para>
____________________________________________________________________________-->
     <para>只有<literal>INCLUDING STORAGE</literal>被指定时，复制而来的列定义的<literal>STORAGE</>设置才会被复制。默认行为会排除<literal>STORAGE</>设置，导致新表中复制而来的列具有与类型相关的默认设置。更多关于<literal>STORAGE</>设置的信息，请见<xref linkend="storage-toast">。
     </para>
<!--==========================orignal english content==========================
     <para>
      Comments for the copied columns, constraints, and indexes
      will be copied only if <literal>INCLUDING COMMENTS</literal>
      is specified. The default behavior is to exclude comments, resulting in
      the copied columns and constraints in the new table having no comments.
     </para>
____________________________________________________________________________-->
     <para>
      只有<literal>INCLUDING COMMENTS</literal>被指定时，复制而来的列、约束和索引的注释才会被拷贝。默认行为是排除注释，这导致新表中复制而来的列和约束没有注释。
     </para>
<!--==========================orignal english content==========================
     <para>
      <literal>INCLUDING ALL</literal> is an abbreviated form of
      <literal>INCLUDING DEFAULTS INCLUDING IDENTITY INCLUDING CONSTRAINTS INCLUDING INDEXES INCLUDING STORAGE INCLUDING COMMENTS</literal>.
     </para>
____________________________________________________________________________-->
     <para><literal>INCLUDING ALL</literal>是
      <literal>INCLUDING DEFAULTS INCLUDING IDENTITY INCLUDING CONSTRAINTS INCLUDING INDEXES INCLUDING STORAGE INCLUDING COMMENTS</literal>的简写形式。
     </para>
<!--==========================orignal english content==========================
     <para>
      Note that unlike <literal>INHERITS</literal>, columns and
      constraints copied by <literal>LIKE</> are not merged with similarly
      named columns and constraints.
      If the same name is specified explicitly or in another
      <literal>LIKE</literal> clause, an error is signaled.
     </para>
____________________________________________________________________________-->
     <para>
      注意和<literal>INHERITS</literal>不同，用<literal>LIKE</>拷贝的列和约束不会和相似的命名列及约束融合。如果显式指定了相同的名称或者在另一个<literal>LIKE</>子句中指定了相同的名称，将会发出一个错误。
     </para>
<!--==========================orignal english content==========================
     <para>
      The <literal>LIKE</literal> clause can also be used to copy column
      definitions from views, foreign tables, or composite types.
      Inapplicable options (e.g., <literal>INCLUDING INDEXES</literal> from
      a view) are ignored.
     </para>
____________________________________________________________________________-->
     <para>
      <literal>LIKE</literal>子句也能被用来从视图、外部表或组合类型拷贝列定义。不适合的选项（例如来自视图的<literal>INCLUDING INDEXES</literal>）会被忽略。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>CONSTRAINT <replaceable class="PARAMETER">constraint_name</replaceable></literal></term>
____________________________________________________________________________-->
    <term><literal>CONSTRAINT <replaceable class="PARAMETER">constraint_name</replaceable></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      An optional name for a column or table constraint.  If the
      constraint is violated, the constraint name is present in error messages,
      so constraint names like <literal>col must be positive</> can be used
      to communicate helpful constraint information to client applications.
      (Double-quotes are needed to specify constraint names that contain spaces.)
      If a constraint name is not specified, the system generates a name.
     </para>
____________________________________________________________________________-->
     <para>
      一个列约束或表约束的可选名称。如果该约束被违背，约束名将会出现在错误消息中，这样类似<literal>列必须为正</>的约束名可以用来与客户端应用沟通有用的约束信息（指定包含空格的约束名时需要用到双引号）。如果没有指定约束名，系统将生成一个。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>NOT NULL</></term>
____________________________________________________________________________-->
    <term><literal>NOT NULL</></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The column is not allowed to contain null values.
     </para>
____________________________________________________________________________-->
     <para>
      该列不允许包含空值。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>NULL</></term>
____________________________________________________________________________-->
    <term><literal>NULL</></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The column is allowed to contain null values. This is the default.
     </para>
____________________________________________________________________________-->
     <para>
      该列允许包含空值。这是默认情况。
     </para>

<!--==========================orignal english content==========================
     <para>
      This clause is only provided for compatibility with
      non-standard SQL databases.  Its use is discouraged in new
      applications.
     </para>
____________________________________________________________________________-->
     <para>
      这个子句只是提供与非标准 SQL 数据库的兼容。在新的应用中不推荐使用。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>CHECK ( <replaceable class="PARAMETER">expression</replaceable> ) [ NO INHERIT ] </literal></term>
____________________________________________________________________________-->
    <term><literal>CHECK ( <replaceable class="PARAMETER">expression</replaceable> ) [ NO INHERIT ] </literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The <literal>CHECK</> clause specifies an expression producing a
      Boolean result which new or updated rows must satisfy for an
      insert or update operation to succeed.  Expressions evaluating
      to TRUE or UNKNOWN succeed.  Should any row of an insert or
      update operation produce a FALSE result, an error exception is
      raised and the insert or update does not alter the database.  A
      check constraint specified as a column constraint should
      reference that column's value only, while an expression
      appearing in a table constraint can reference multiple columns.
     </para>
____________________________________________________________________________-->
     <para>
      <literal>CHECK</>指定一个产生布尔结果的表达式，一个插入或更新操作要想成功，其中新的或被更新的行必须满足该表达式。计算出 TRUE 或 UNKNOWN 的表达式就会成功。只要任何一个插入或更新操作的行产生了 FALSE 结果，将报告一个错误异常并且插入或更新不会修改数据库。一个被作为列约束指定的检查约束只应该引用该列的值，而一个出现在表约束中的表达式可以引用多列。
     </para>

<!--==========================orignal english content==========================
     <para>
      Currently, <literal>CHECK</literal> expressions cannot contain
      subqueries nor refer to variables other than columns of the
      current row.  The system column <literal>tableoid</literal>
      may be referenced, but not any other system column.
     </para>
____________________________________________________________________________-->
     <para>
      当前，<literal>CHECK</literal>表达式不能包含子查询，也不能引用当前行的列之外的变量。可以引用系统列<literal>tableoid</literal>，但不能引用其他系统列。
     </para>

<!--==========================orignal english content==========================
     <para>
      A constraint marked with <literal>NO INHERIT</> will not propagate to
      child tables.
     </para>
____________________________________________________________________________-->
     <para>
      一个被标记为<literal>NO INHERIT</>的约束将不会传播到子表。
     </para>
     
<!--==========================orignal english content==========================
     <para>
      When a table has multiple <literal>CHECK</literal> constraints,
      they will be tested for each row in alphabetical order by name,
      after checking <literal>NOT NULL</> constraints.
      (<productname>PostgreSQL</> versions before 9.5 did not honor any
      particular firing order for <literal>CHECK</literal> constraints.)
     </para>
____________________________________________________________________________-->
     <para>
      当一个表有多个<literal>CHECK</literal>约束时，检查完<literal>NOT NULL</>约束后，对于每一行会以它们名称的字母表顺序来进行检查（版本 9.5 之前的<productname>PostgreSQL</>对于<literal>CHECK</literal>约束不遵从任何特定的引发顺序）。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>DEFAULT
    <replaceable>default_expr</replaceable></literal></term>
____________________________________________________________________________-->
    <term><literal>DEFAULT
    <replaceable>default_expr</replaceable></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The <literal>DEFAULT</> clause assigns a default data value for
      the column whose column definition it appears within.  The value
      is any variable-free expression (subqueries and cross-references
      to other columns in the current table are not allowed).  The
      data type of the default expression must match the data type of the
      column.
     </para>
____________________________________________________________________________-->
     <para>
      <literal>DEFAULT</>子句为出现在其定义中的列赋予一个默认数据。该值是可以使用变量的表达式（不允许用子查询和对其他列的交叉引用）。默认值表达式的数据类型必须匹配列的数据类型。
     </para>

<!--==========================orignal english content==========================
     <para>
      The default expression will be used in any insert operation that
      does not specify a value for the column.  If there is no default
      for a column, then the default is null.
     </para>
____________________________________________________________________________-->
     <para>
      默认值表达式将被用在任何没有为该列指定值的插入操作中。如果一列没有默认值，那么默认值为空值。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <replaceable>sequence_options</replaceable> ) ]</literal></term>
____________________________________________________________________________-->
    <term><literal>GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <replaceable>sequence_options</replaceable> ) ]</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      This clause creates the column as an <firstterm>identity
      column</firstterm>.  It will have an implicit sequence attached to it
      and the column in new rows will automatically have values from the
      sequence assigned to it.
     </para>
____________________________________________________________________________-->
     <para>
      该子句将列创建为<firstterm>标识列</firstterm>。
	  它将拥有一个隐式序列附加到它，并且新行中的列将自动从分配给它的序列中获取值。
     </para>

<!--==========================orignal english content==========================
     <para>
      The clauses <literal>ALWAYS</literal> and <literal>BY DEFAULT</literal>
      determine how the sequence value is given precedence over a
      user-specified value in an <command>INSERT</command> statement.
      If <literal>ALWAYS</literal> is specified, a user-specified value is
      only accepted if the <command>INSERT</command> statement
      specifies <literal>OVERRIDING SYSTEM VALUE</literal>.  If <literal>BY
      DEFAULT</literal> is specified, then the user-specified value takes
      precedence.  See <xref linkend="sql-insert"> for details.  (In
      the <command>COPY</command> command, user-specified values are always
      used regardless of this setting.)
     </para>
____________________________________________________________________________-->
     <para>
      子句<literal>ALWAYS</literal>和<literal>BY DEFAULT</literal>确定在
	  <command>INSERT</command>语句中，序列值如何优先于用户指定的值。
	  如果指定了<literal>ALWAYS</literal>，则只有在<command>INSERT</command>
	  语句指定<literal>OVERRIDING SYSTEM VALUE</literal>时才接受用户指定的值。
	  如果指定了<literal>BY DEFAULT</literal>，则用户指定的值优先。
	  有关详细信息，请参见<xref linkend="sql-insert">。
	  （在<command>COPY</command>命令中，无论此设置如何，都始终使用用户指定的值。）
     </para>

<!--==========================orignal english content==========================
     <para>
      The optional <replaceable>sequence_options</replaceable> clause can be
      used to override the options of the sequence.
      See <xref linkend="sql-createsequence"> for details.
     </para>
____________________________________________________________________________-->
     <para>
      可选的<replaceable>sequence_options</replaceable>子句可用于覆盖序列的选项。
	  有关详细信息，请参见<xref linkend="sql-createsequence">。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>UNIQUE</> (column constraint)</term>
____________________________________________________________________________-->
    <term><literal>UNIQUE</> （列约束）</term>
<!--==========================orignal english content==========================
    <term><literal>UNIQUE ( <replaceable class="PARAMETER">column_name</replaceable> [, ... ] )</> (table constraint)</term>
____________________________________________________________________________-->
    <term><literal>UNIQUE ( <replaceable class="PARAMETER">column_name</replaceable> [, ... ] )</> （表约束）</term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      The <literal>UNIQUE</literal> constraint specifies that a
      group of one or more columns of a table can contain
      only unique values. The behavior of the unique table constraint
      is the same as that for column constraints, with the additional
      capability to span multiple columns.
     </para>
____________________________________________________________________________-->
     <para>
      <literal>UNIQUE</literal>约束指定一个表中的一列或多列组成的组包含唯一的值。唯一表约束的行为与列约束的行为相同，只是表约束能够跨越多列。
     </para>

<!--==========================orignal english content==========================
     <para>
      For the purpose of a unique constraint, null values are not
      considered equal.
     </para>
____________________________________________________________________________-->
     <para>
      对于一个唯一约束的目的来说，空值不被认为是相等的。
     </para>

<!--==========================orignal english content==========================
     <para>
      Each unique table constraint must name a set of columns that is
      different from the set of columns named by any other unique or
      primary key constraint defined for the table.  (Otherwise it
      would just be the same constraint listed twice.)
     </para>
____________________________________________________________________________-->
     <para>
      每一个唯一表约束必须命名一个列的集合，并且它与该表上任何其他唯一或主键约束所命名的列集合都不相同（否则它将是一个被列举了两次的约束）。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>PRIMARY KEY</> (column constraint)</term>
____________________________________________________________________________-->
    <term><literal>PRIMARY KEY</> （列约束）</term>
<!--==========================orignal english content==========================
    <term><literal>PRIMARY KEY ( <replaceable class="PARAMETER">column_name</replaceable> [, ... ] )</> (table constraint)</term>
____________________________________________________________________________-->
    <term><literal>PRIMARY KEY ( <replaceable class="PARAMETER">column_name</replaceable> [, ... ] )</> （表约束）</term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The <literal>PRIMARY KEY</> constraint specifies that a column or
      columns of a table can contain only unique (non-duplicate), nonnull
      values. Only one primary key can be specified for a table, whether as a
      column constraint or a table constraint.
     </para>
____________________________________________________________________________-->
     <para>
      <literal>PRIMARY KEY</>约束指定表的一个或者多个列只能包含唯一（不重复）、非空的值。一个表上只能指定一个主键，可以作为列约束或表约束。
     </para>

<!--==========================orignal english content==========================
     <para>
      The primary key constraint should name a set of columns that is
      different from the set of columns named by any unique
      constraint defined for the same table.  (Otherwise, the unique
      constraint is redundant and will be discarded.)
     </para>
____________________________________________________________________________-->
     <para>
      主键约束所涉及的列集合应该不同于同一个表上定义的任何唯一约束的列集合（否则，该唯一约束是多余的并且会被丢弃）。
     </para>

<!--==========================orignal english content==========================
     <para>
      <literal>PRIMARY KEY</literal> enforces the same data constraints as
      a combination of <literal>UNIQUE</> and <literal>NOT NULL</>, but
      identifying a set of columns as the primary key also provides metadata
      about the design of the schema, since a primary key implies that other
      tables can rely on this set of columns as a unique identifier for rows.
     </para>
____________________________________________________________________________-->
     <para>
      <literal>PRIMARY KEY</literal>强制的数据约束可以看成是<literal>UNIQUE</>和<literal>NOT NULL</>的组合，不过把一组列标识为主键也为模式设计提供了元数据，因为主键标识其他表可以依赖这一个列集合作为行的唯一标识符。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="SQL-CREATETABLE-EXCLUDE">
<!--==========================orignal english content==========================
    <term><literal>EXCLUDE [ USING <replaceable class="parameter">index_method</replaceable> ] ( <replaceable class="parameter">exclude_element</replaceable> WITH <replaceable class="parameter">operator</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> [ WHERE ( <replaceable class="parameter">predicate</replaceable> ) ]</literal></term>
____________________________________________________________________________-->
    <term><literal>EXCLUDE [ USING <replaceable class="parameter">index_method</replaceable> ] ( <replaceable class="parameter">exclude_element</replaceable> WITH <replaceable class="parameter">operator</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> [ WHERE ( <replaceable class="parameter">predicate</replaceable> ) ]</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The <literal>EXCLUDE</> clause defines an exclusion
      constraint, which guarantees that if
      any two rows are compared on the specified column(s) or
      expression(s) using the specified operator(s), not all of these
      comparisons will return <literal>TRUE</>.  If all of the
      specified operators test for equality, this is equivalent to a
      <literal>UNIQUE</> constraint, although an ordinary unique constraint
      will be faster.  However, exclusion constraints can specify
      constraints that are more general than simple equality.
      For example, you can specify a constraint that
      no two rows in the table contain overlapping circles
      (see <xref linkend="datatype-geometric">) by using the
      <literal>&amp;&amp;</> operator.
     </para>
____________________________________________________________________________-->
     <para>
      <literal>EXCLUDE</>子句定一个排除约束，它保证如果任意两行在指定列或表达式上使用指定操作符进行比较，不是所有的比较都将会返回<literal>TRUE</>。如果所有指定的操作符都测试相等，这就等价于一个<literal>UNIQUE</>约束，尽管一个普通的唯一约束将更快。不过，排除约束能够指定比简单相等更通用的约束。例如，你可以使用<literal>&amp;&amp;</>操作符指定一个约束，要求表中没有两行包含相互覆盖的圆（见 <xref linkend="datatype-geometric">）。
     </para>

<!--==========================orignal english content==========================
     <para>
      Exclusion constraints are implemented using
      an index, so each specified operator must be associated with an
      appropriate operator class
      (see <xref linkend="indexes-opclass">) for the index access
      method <replaceable>index_method</>.
      The operators are required to be commutative.
      Each <replaceable class="parameter">exclude_element</replaceable>
      can optionally specify an operator class and/or ordering options;
      these are described fully under
      <xref linkend="sql-createindex">.
     </para>
____________________________________________________________________________-->
     <para>
      排除约束使用一个索引实现，这样每一个指定的操作符必须与用于索引访问方法<replaceable>index_method</>的一个适当的操作符类（见<xref linkend="indexes-opclass">）相关联。操作符被要求是交换的。每一个<replaceable class="parameter">exclude_element</replaceable>可以选择性地指定一个操作符类或者顺序选项，这些在<xref linkend="sql-createindex">中有完整描述。
     </para>

<!--==========================orignal english content==========================
     <para>
      The access method must support <literal>amgettuple</> (see <xref
      linkend="indexam">); at present this means <acronym>GIN</>
      cannot be used.  Although it's allowed, there is little point in using
      B-tree or hash indexes with an exclusion constraint, because this
      does nothing that an ordinary unique constraint doesn't do better.
      So in practice the access method will always be <acronym>GiST</> or
      <acronym>SP-GiST</>.
     </para>
____________________________________________________________________________-->
     <para>
      访问方法必须支持<literal>amgettuple</>（见<xref linkend="indexam">），目前这意味着<acronym>GIN</>无法使用。尽管允许，但是在一个排除约束中使用 B-树或哈希索引没有意义，因为它无法做得比一个普通唯一索引更出色。因此在实践中访问方法将总是<acronym>GiST</>或<acronym>SP-GiST</>。
     </para>

<!--==========================orignal english content==========================
     <para>
      The <replaceable class="parameter">predicate</> allows you to specify an
      exclusion constraint on a subset of the table; internally this creates a
      partial index. Note that parentheses are required around the predicate.
     </para>
____________________________________________________________________________-->
     <para>
      <replaceable class="parameter">predicate</>允许你在该表的一个子集上指定一个排除约束。在内部这会创建一个部分索引。注意在为此周围的圆括号是必须的。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>REFERENCES <replaceable class="parameter">reftable</replaceable> [ ( <replaceable class="parameter">refcolumn</replaceable> ) ] [ MATCH <replaceable class="parameter">matchtype</replaceable> ] [ ON DELETE <replaceable class="parameter">action</replaceable> ] [ ON UPDATE <replaceable class="parameter">action</replaceable> ]</literal> (column constraint)</term>
____________________________________________________________________________-->
    <term><literal>REFERENCES <replaceable class="parameter">reftable</replaceable> [ ( <replaceable class="parameter">refcolumn</replaceable> ) ] [ MATCH <replaceable class="parameter">matchtype</replaceable> ] [ ON DELETE <replaceable class="parameter">action</replaceable> ] [ ON UPDATE <replaceable class="parameter">action</replaceable> ]</literal> （列约束）</term>

<!--==========================orignal english content==========================
   <term><literal>FOREIGN KEY ( <replaceable class="parameter">column_name</replaceable> [, ... ] )
    REFERENCES <replaceable class="parameter">reftable</replaceable> [ ( <replaceable class="parameter">refcolumn</replaceable> [, ... ] ) ]
    [ MATCH <replaceable class="parameter">matchtype</replaceable> ]
    [ ON DELETE <replaceable class="parameter">action</replaceable> ]
    [ ON UPDATE <replaceable class="parameter">action</replaceable> ]</literal>
    (table constraint)</term>
____________________________________________________________________________-->
   <term><literal>FOREIGN KEY ( <replaceable class="parameter">column_name</replaceable> [, ... ] )
    REFERENCES <replaceable class="parameter">reftable</replaceable> [ ( <replaceable class="parameter">refcolumn</replaceable> [, ... ] ) ]
    [ MATCH <replaceable class="parameter">matchtype</replaceable> ]
    [ ON DELETE <replaceable class="parameter">action</replaceable> ]
    [ ON UPDATE <replaceable class="parameter">action</replaceable> ]</literal>
    （表约束）</term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      These clauses specify a foreign key constraint, which requires
      that a group of one or more columns of the new table must only
      contain values that match values in the referenced
      column(s) of some row of the referenced table.  If the <replaceable
      class="parameter">refcolumn</replaceable> list is omitted, the
      primary key of the <replaceable class="parameter">reftable</replaceable>
      is used.  The referenced columns must be the columns of a non-deferrable
      unique or primary key constraint in the referenced table.  The user
      must have <literal>REFERENCES</> permission on the referenced table
      (either the whole table, or the specific referenced columns).
      Note that foreign key constraints cannot be defined between temporary
      tables and permanent tables.
     </para>
____________________________________________________________________________-->
     <para>
      这些子句指定一个外键约束，它要求新表的一列或一个列的组必须只包含能匹配被引用表的某个行在被引用列上的值。如果<replaceable class="parameter">refcolumn</replaceable>列表被忽略，将使用<replaceable class="parameter">reftable</replaceable>的主键。被引用列必须是被引用表中一个非可延迟唯一约束或主键约束的列。
	  用户必须在被引用的表（或整个表或特定的引用列）上拥有<literal>REFERENCES</>权限。
	  注意外键约束不能在临时表和永久表之间定义。
     </para>

<!--==========================orignal english content==========================
     <para>
      A value inserted into the referencing column(s) is matched against the
      values of the referenced table and referenced columns using the
      given match type.  There are three match types: <literal>MATCH
      FULL</>, <literal>MATCH PARTIAL</>, and <literal>MATCH
      SIMPLE</literal> (which is the default).  <literal>MATCH
      FULL</> will not allow one column of a multicolumn foreign key
      to be null unless all foreign key columns are null; if they are all
      null, the row is not required to have a match in the referenced table.
      <literal>MATCH SIMPLE</literal> allows any of the foreign key columns
      to be null; if any of them are null, the row is not required to have a
      match in the referenced table.
      <literal>MATCH PARTIAL</> is not yet implemented.
      (Of course, <literal>NOT NULL</> constraints can be applied to the
      referencing column(s) to prevent these cases from arising.)
     </para>
____________________________________________________________________________-->
     <para>
      被插入到引用列的一个值会使用给定的匹配类型与被引用表的值进行匹配。有三种匹配类型：<literal>MATCH FULL</>、<literal>MATCH PARTIAL</>以及<literal>MATCH SIMPLE</literal>（这是默认值）。  <literal>MATCH FULL</>将不允许一个多列外键中的一列为空，除非所有外键列都是空；如果它们都是空，则不要求该行在被引用表中有一个匹配。<literal>MATCH SIMPLE</literal>允许任意外键列为空，如果任一为空，则不要求该行在被引用表中有一个匹配。<literal>MATCH PARTIAL</>现在还没有被实现（当然，<literal>NOT NULL</>约束能被应用在引用列上来组织这些情况发生）。
     </para>

<!--==========================orignal english content==========================
     <para>
      In addition, when the data in the referenced columns is changed,
      certain actions are performed on the data in this table's
      columns.  The <literal>ON DELETE</literal> clause specifies the
      action to perform when a referenced row in the referenced table is
      being deleted.  Likewise, the <literal>ON UPDATE</literal>
      clause specifies the action to perform when a referenced column
      in the referenced table is being updated to a new value. If the
      row is updated, but the referenced column is not actually
      changed, no action is done. Referential actions other than the
      <literal>NO ACTION</literal> check cannot be deferred, even if
      the constraint is declared deferrable. There are the following possible
      actions for each clause:

      <variablelist>
       <varlistentry>
        <term><literal>NO ACTION</literal></term>
        <listitem>
         <para>
          Produce an error indicating that the deletion or update
          would create a foreign key constraint violation.
          If the constraint is deferred, this
          error will be produced at constraint check time if there still
          exist any referencing rows.  This is the default action.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>RESTRICT</literal></term>
        <listitem>
         <para>
          Produce an error indicating that the deletion or update
          would create a foreign key constraint violation.
          This is the same as <literal>NO ACTION</literal> except that
          the check is not deferrable.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>CASCADE</literal></term>
        <listitem>
         <para>
          Delete any rows referencing the deleted row, or update the
          values of the referencing column(s) to the new values of the
          referenced columns, respectively.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>SET NULL</literal></term>
        <listitem>
         <para>
          Set the referencing column(s) to null.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>SET DEFAULT</literal></term>
        <listitem>
         <para>
          Set the referencing column(s) to their default values.
          (There must be a row in the referenced table matching the default
          values, if they are not null, or the operation will fail.)
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
____________________________________________________________________________-->
     <para>
      另外，当被引用列中的数据被改变时，在这个表的列中的数据上可以执行特定的动作。<literal>ON DELETE</literal>指定当被引用表中一个被引用行被删除时要执行的动作。同样，<literal>ON UPDATE</literal>指定当被引用表中一个被引用列被更新为新值时要执行的动作。如果该行被更新，但是被引用列并没有被实际改变，不会做任何动作。除了<literal>NO ACTION</literal>检查之外的引用动作不能被延迟，即便该约束被声明为可延迟的。对每一个子句可能有以下动作：

      <variablelist>
       <varlistentry>
        <term><literal>NO ACTION</literal></term>
        <listitem>
         <para>
          产生一个错误指示删除或更新将会导致一个外键约束违背。如果该约束被延迟，并且仍存在引用行，这个错误将在约束检查时被产生。这是默认动作。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>RESTRICT</literal></term>
        <listitem>
         <para>
          产生一个错误指示删除或更新将会导致一个外键约束违背。这个动作与<literal>NO ACTION</literal>形同，不过该检查不是可延迟的。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>CASCADE</literal></term>
        <listitem>
         <para>
          删除任何引用被删除行的行，或者把引用列的值更新为被引用列的新值。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>SET NULL</literal></term>
        <listitem>
         <para>
          将引用列设置为空。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>SET DEFAULT</literal></term>
        <listitem>
         <para>
          设置引用列为它们的默认值（如果该默认值非空，在被引用表中必须有一行匹配该默认值，否则该操作将会失败）。
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>

<!--==========================orignal english content==========================
     <para>
      If the referenced column(s) are changed frequently, it might be wise to
      add an index to the referencing column(s) so that referential actions
      associated with the foreign key constraint can be performed more
      efficiently.
     </para>
____________________________________________________________________________-->
     <para>
      如果被引用列被频繁地更改，最好在引用列上加上一个索引，这样与外键约束相关的引用动作能够更高效地被执行。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>DEFERRABLE</literal></term>
____________________________________________________________________________-->
    <term><literal>DEFERRABLE</literal></term>
<!--==========================orignal english content==========================
    <term><literal>NOT DEFERRABLE</literal></term>
____________________________________________________________________________-->
    <term><literal>NOT DEFERRABLE</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      This controls whether the constraint can be deferred.  A
      constraint that is not deferrable will be checked immediately
      after every command.  Checking of constraints that are
      deferrable can be postponed until the end of the transaction
      (using the <xref linkend="sql-set-constraints"> command).
      <literal>NOT DEFERRABLE</literal> is the default.
      Currently, only <literal>UNIQUE</>, <literal>PRIMARY KEY</>,
      <literal>EXCLUDE</>, and
      <literal>REFERENCES</> (foreign key) constraints accept this
      clause.  <literal>NOT NULL</> and <literal>CHECK</> constraints are not
      deferrable.  Note that deferrable constraints cannot be used as
      conflict arbitrators in an <command>INSERT</command> statement that
      includes an <literal>ON CONFLICT DO UPDATE</> clause.
     </para>
____________________________________________________________________________-->
     <para>
      这个子句控制该约束是否能被延迟。一个不可延迟的约束将在每一次命令后立刻被检查。可延迟约束的检查将被推迟到事务结束时进行（使用<xref linkend="sql-set-constraints">命令）。<literal>NOT DEFERRABLE</literal>是默认值。当前，只有<literal>UNIQUE</>、<literal>PRIMARY KEY</>、<literal>EXCLUDE</>以及<literal>REFERENCES</>（外键）约束接受这个子句。<literal>NOT NULL</>以及<literal>CHECK</>约束是不可延迟的。注意在包括<literal>ON CONFLICT DO UPDATE</>子句的<command>INSERT</command>语句中，可延迟约束不能被用作冲突裁判者。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>INITIALLY IMMEDIATE</literal></term>
____________________________________________________________________________-->
    <term><literal>INITIALLY IMMEDIATE</literal></term>
<!--==========================orignal english content==========================
    <term><literal>INITIALLY DEFERRED</literal></term>
____________________________________________________________________________-->
    <term><literal>INITIALLY DEFERRED</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      If a constraint is deferrable, this clause specifies the default
      time to check the constraint.  If the constraint is
      <literal>INITIALLY IMMEDIATE</literal>, it is checked after each
      statement. This is the default.  If the constraint is
      <literal>INITIALLY DEFERRED</literal>, it is checked only at the
      end of the transaction.  The constraint check time can be
      altered with the <xref linkend="sql-set-constraints"> command.
     </para>
____________________________________________________________________________-->
     <para>
      如果一个约束是可延迟的，这个子句指定检查该约束的默认时间。如果该约束是<literal>INITIALLY IMMEDIATE</literal>，它会在每一个语句之后被检查。这是默认值。如果该约束是<literal>INITIALLY DEFERRED</literal>，它只会在事务结束时被检查。约束检查时间可以用<xref linkend="sql-set-constraints">命令修改。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>WITH ( <replaceable class="PARAMETER">storage_parameter</replaceable> [= <replaceable class="PARAMETER">value</replaceable>] [, ... ] )</literal></term>
____________________________________________________________________________-->
    <term><literal>WITH ( <replaceable class="PARAMETER">storage_parameter</replaceable> [= <replaceable class="PARAMETER">value</replaceable>] [, ... ] )</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      This clause specifies optional storage parameters for a table or index;
      see <xref linkend="sql-createtable-storage-parameters"
      endterm="sql-createtable-storage-parameters-title"> for more
      information.  The <literal>WITH</> clause for a
      table can also include <literal>OIDS=TRUE</> (or just <literal>OIDS</>)
      to specify that rows of the new table
      should have OIDs (object identifiers) assigned to them, or
      <literal>OIDS=FALSE</> to specify that the rows should not have OIDs.
      If <literal>OIDS</> is not specified, the default setting depends upon
      the <xref linkend="guc-default-with-oids"> configuration parameter.
      (If the new table inherits from any tables that have OIDs, then
      <literal>OIDS=TRUE</> is forced even if the command says
      <literal>OIDS=FALSE</>.)
     </para>
____________________________________________________________________________-->
     <para>
      这个子句为一个表或索引指定可选的存储参数，详见<xref linkend="sql-createtable-storage-parameters"       endterm="sql-createtable-storage-parameters-title">。一个表的<literal>WITH</>子句还可以包括<literal>OIDS=TRUE</>（或者只包括<literal>OIDS</>）来指定新表的行应该具有被分配的 OID（对象标识符），或者包括<literal>OIDS=FALSE</>来指定新表的行不具有 OID。如果没有指定<literal>OIDS</>，默认设置取决于<xref linkend="guc-default-with-oids">配置参数（如果新表是从任何具有 OID 的表继承而来，那么即使该命令要求<literal>OIDS=FALSE</>也会强制使用<literal>OIDS=TRUE</>）。
     </para>

<!--==========================orignal english content==========================
     <para>
      If <literal>OIDS=FALSE</literal> is specified or implied, the new
      table does not store OIDs and no OID will be assigned for a row inserted
      into it. This is generally considered worthwhile, since it
      will reduce OID consumption and thereby postpone the wraparound
      of the 32-bit OID counter. Once the counter wraps around, OIDs
      can no longer be assumed to be unique, which makes them
      considerably less useful. In addition, excluding OIDs from a
      table reduces the space required to store the table on disk by
      4 bytes per row (on most machines), slightly improving performance.
     </para>
____________________________________________________________________________-->
     <para>
      如果指定或者蕴含了<literal>OIDS=FALSE</literal>，新表就不会存储 OID 并且对插入其中的一个新行不会分配 OID。这通常值得考虑，因为它将减少 OID 消耗并且因而推迟 32 为 OID 计数器的回卷。一旦计数器回卷，OID 就不再能被假定为唯一，这就使它们不那么有用了。另外，从一个表中排除 OID 可以减少存储该表所需的磁盘空间，减少的量是每行减少 4 字节（在大部分机器上），这也略微提高了性能。
     </para>

<!--==========================orignal english content==========================
     <para>
      To remove OIDs from a table after it has been created, use <xref
      linkend="sql-altertable">.
     </para>
____________________________________________________________________________-->
     <para>
      要在表被创建后从中移除 OID，使用<xref linkend="sql-altertable">.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>WITH OIDS</></term>
____________________________________________________________________________-->
    <term><literal>WITH OIDS</></term>
<!--==========================orignal english content==========================
    <term><literal>WITHOUT OIDS</></term>
____________________________________________________________________________-->
    <term><literal>WITHOUT OIDS</></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      These are obsolescent syntaxes equivalent to <literal>WITH (OIDS)</>
      and <literal>WITH (OIDS=FALSE)</>, respectively.  If you wish to give
      both an <literal>OIDS</> setting and storage parameters, you must use
      the <literal>WITH ( ... )</> syntax; see above.
     </para>
____________________________________________________________________________-->
     <para>
      这些语法已被荒废，它们分别等效于<literal>WITH (OIDS)</>和<literal>WITH (OIDS=FALSE)</>。如果你希望同时给出一个<literal>OIDS</>设置和存储参数，你必须使用<literal>WITH ( ... )</>语法，见上文。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>ON COMMIT</literal></term>
____________________________________________________________________________-->
    <term><literal>ON COMMIT</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The behavior of temporary tables at the end of a transaction
      block can be controlled using <literal>ON COMMIT</literal>.
      The three options are:

      <variablelist>
       <varlistentry>
        <term><literal>PRESERVE ROWS</literal></term>
        <listitem>
         <para>
          No special action is taken at the ends of transactions.
          This is the default behavior.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>DELETE ROWS</literal></term>
        <listitem>
         <para>
          All rows in the temporary table will be deleted at the end
          of each transaction block.  Essentially, an automatic <xref
          linkend="sql-truncate"> is done
          at each commit.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>DROP</literal></term>
        <listitem>
         <para>
          The temporary table will be dropped at the end of the current
          transaction block.
         </para>
        </listitem>
       </varlistentry>
      </variablelist></para>
____________________________________________________________________________-->
     <para>
      临时表在一个事务块结束时的行为由<literal>ON COMMIT</literal>控制。三种选项是：

      <variablelist>
       <varlistentry>
        <term><literal>PRESERVE ROWS</literal></term>
        <listitem>
         <para>
          在事务结束时不采取特殊的动作。这是默认行为。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>DELETE ROWS</literal></term>
        <listitem>
         <para>
          在每一个事务块结束时将删除临时表中的所有行。实质上，在每一次提交时会完成一次自动的<xref linkend="sql-truncate">。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>DROP</literal></term>
        <listitem>
         <para>
          在当前事务块结束时将删除临时表。
         </para>
        </listitem>
       </varlistentry>
      </variablelist></para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>TABLESPACE <replaceable class="PARAMETER">tablespace_name</replaceable></literal></term>
____________________________________________________________________________-->
    <term><literal>TABLESPACE <replaceable class="PARAMETER">tablespace_name</replaceable></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The <replaceable class="PARAMETER">tablespace_name</replaceable> is the name
      of the tablespace in which the new table is to be created.
      If not specified,
      <xref linkend="guc-default-tablespace"> is consulted, or
      <xref linkend="guc-temp-tablespaces"> if the table is temporary.
     </para>
____________________________________________________________________________-->
     <para>
      <replaceable class="PARAMETER">tablespace_name</replaceable>是新表要创建于其中的表空间名称。如果没有指定，将参考<xref linkend="guc-default-tablespace">，或者如果表是临时的则参考<xref linkend="guc-temp-tablespaces">。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>USING INDEX TABLESPACE <replaceable class="PARAMETER">tablespace_name</replaceable></literal></term>
____________________________________________________________________________-->
    <term><literal>USING INDEX TABLESPACE <replaceable class="PARAMETER">tablespace_name</replaceable></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      This clause allows selection of the tablespace in which the index
      associated with a <literal>UNIQUE</literal>, <literal>PRIMARY
      KEY</literal>, or <literal>EXCLUDE</> constraint will be created.
      If not specified,
      <xref linkend="guc-default-tablespace"> is consulted, or
      <xref linkend="guc-temp-tablespaces"> if the table is temporary.
     </para>
____________________________________________________________________________-->
     <para>
      这个子句允许选择与一个<literal>UNIQUE</literal>、<literal>PRIMARY KEY</literal>或者<literal>EXCLUDE</>约束相关的索引将被创建在哪个表空间中。如果没有指定，将参考<xref linkend="guc-default-tablespace">，或者如果表是临时的则参考<xref linkend="guc-temp-tablespaces">。
     </para>
    </listitem>
   </varlistentry>

  </variablelist>

  <refsect2 id="SQL-CREATETABLE-storage-parameters">
<!--==========================orignal english content==========================
   <title id="SQL-CREATETABLE-storage-parameters-title">Storage Parameters</title>
____________________________________________________________________________-->
   <title id="SQL-CREATETABLE-storage-parameters-title">存储参数</title>

<!--==========================orignal english content==========================
 <indexterm zone="sql-createtable-storage-parameters">
  <primary>storage parameters</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="sql-createtable-storage-parameters">
  <primary>存储参数</primary>
 </indexterm>

<!--==========================orignal english content==========================
   <para>
    The <literal>WITH</> clause can specify <firstterm>storage parameters</>
    for tables, and for indexes associated with a <literal>UNIQUE</literal>,
    <literal>PRIMARY KEY</literal>, or <literal>EXCLUDE</> constraint.
    Storage parameters for
    indexes are documented in <xref linkend="SQL-CREATEINDEX">.
    The storage parameters currently
    available for tables are listed below.  For many of these parameters, as
    shown, there is an additional parameter with the same name prefixed with
    <literal>toast.</literal>, which controls the behavior of the
    table's secondary <acronym>TOAST</> table, if any
    (see <xref linkend="storage-toast"> for more information about TOAST).
    If a table parameter value is set and the
    equivalent <literal>toast.</literal> parameter is not, the TOAST table
    will use the table's parameter value.
    Specifying these parameters for partitioned tables is not supported,
    but you may specify them for individual leaf partitions.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>WITH</>子句能够为表或与一个<literal>UNIQUE</literal>、<literal>PRIMARY KEY</literal>或者<literal>EXCLUDE</>约束相关的索引指定<firstterm>存储参数</>。用于索引的存储参数已经在<xref linkend="SQL-CREATEINDEX">中介绍过。当前可用于表的存储参数在下文中列出。如下文所示，对于很多这类参数，都有一个名字带有<literal>toast.</literal>前缀的附加参数，它能被用来控制该表的二级<acronym>TOAST</>表（如果存在）的行为（关于 TOAST 详见<xref linkend="storage-toast">）。如果一个表的参数值被设置但是相应的<literal>toast.</literal>参数没有被设置，那么 TOAST 表将使用该表的参数值。
	不支持为分区表指定这些参数，但可以为单个叶子分区指定它们。
   </para>

   <variablelist>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>fillfactor</> (<type>integer</>)</term>
____________________________________________________________________________-->
    <term><literal>fillfactor</> (<type>integer</>)</term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The fillfactor for a table is a percentage between 10 and 100.
      100 (complete packing) is the default.  When a smaller fillfactor
      is specified, <command>INSERT</> operations pack table pages only
      to the indicated percentage; the remaining space on each page is
      reserved for updating rows on that page.  This gives <command>UPDATE</>
      a chance to place the updated copy of a row on the same page as the
      original, which is more efficient than placing it on a different page.
      For a table whose entries are never updated, complete packing is the
      best choice, but in heavily updated tables smaller fillfactors are
      appropriate.  This parameter cannot be set for TOAST tables.
     </para>
____________________________________________________________________________-->
     <para>
      一个表的填充因子是一个 10 到 100 之间的百分数。100（完全填满）是默认值。当一个较小的填充因子被指定时，<command>INSERT</>操作会把表页面只填满到指定的百分比，每个页面上剩余的空间被保留给该页上行的更新。这就让<command>UPDATE</>有机会把一行的已更新版本放在与其原始版本相同的页面上，这比把它放在一个不同的页面上效率更高。对于一个项从来不会被更新的表来说，完全填满是最好的选择，但是在更新繁重的表上则较小的填充因子更合适。这个参数不能对 TOAST 表设置。
     </para>
    </listitem>
   </varlistentry>
   
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>parallel_workers</> (<type>integer</>)</term>
____________________________________________________________________________-->
    <term><literal>parallel_workers</> (<type>integer</>)</term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      This sets the number of workers that should be used to assist a parallel
      scan of this table.  If not set, the system will determine a value based
      on the relation size.  The actual number of workers chosen by the planner
      may be less, for example due to
      the setting of <xref linkend="guc-max-worker-processes">.
     </para>
____________________________________________________________________________-->
     <para>
      这个参数设置应该被用来辅助对这个表并行扫描的工作者数量。如果没有设置这个参数，系统将基于关系的尺寸来决定一个值。规划器实际选择的工作者数量可能会少于这个参数，例如<xref linkend="guc-max-worker-processes">的设置较小就是一种可能的原因。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>autovacuum_enabled</>, <literal>toast.autovacuum_enabled</literal> (<type>boolean</>)</term>
____________________________________________________________________________-->
    <term><literal>autovacuum_enabled</>, <literal>toast.autovacuum_enabled</literal> (<type>boolean</>)</term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
     Enables or disables the autovacuum daemon for a particular table.
     If true, the autovacuum daemon will perform automatic <command>VACUUM</>
     and/or <command>ANALYZE</> operations on this table following the rules
     discussed in <xref linkend="autovacuum">.
     If false, this table will not be autovacuumed, except to prevent
     transaction ID wraparound. See <xref linkend="vacuum-for-wraparound"> for
     more about wraparound prevention.
     Note that the autovacuum daemon does not run at all (except to prevent
     transaction ID wraparound) if the <xref linkend="guc-autovacuum">
     parameter is false; setting individual tables' storage parameters does
     not override that.  Therefore there is seldom much point in explicitly
     setting this storage parameter to <literal>true</>, only
     to <literal>false</>.
     </para>
____________________________________________________________________________-->
     <para>
     为一个特定的表启用或者禁用自动清理守护进程。如果为真，自动清理守护进程将遵照<xref linkend="autovacuum">中讨论的规则在这个表上执行自动的<command>VACUUM</>或者<command>ANALYZE</>操作。如果为假，这个表不会被自动清理，不过为了阻止事务 ID 回卷时还是会对它进行自动的清理。有关回卷阻止请见<xref linkend="vacuum-for-wraparound">。如果<xref linkend="guc-autovacuum">参数为假，自动清理守护进程根本就不会运行（除非为了阻止事务 ID 回卷），设置独立的表存储参数也不会覆盖这个设置。因此显式地将这个存储参数设置为<literal>true</>很少有大的意义，只有设置为<literal>false</>才更有用。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>autovacuum_vacuum_threshold</>, <literal>toast.autovacuum_vacuum_threshold</literal> (<type>integer</>)</term>
____________________________________________________________________________-->
    <term><literal>autovacuum_vacuum_threshold</>, <literal>toast.autovacuum_vacuum_threshold</literal> (<type>integer</>)</term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Per-table value for <xref linkend="guc-autovacuum-vacuum-threshold">
      parameter.
     </para>
____________________________________________________________________________-->
     <para>
     <xref linkend="guc-autovacuum-vacuum-threshold">参数对于每个表的值。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>autovacuum_vacuum_scale_factor</>, <literal>toast.autovacuum_vacuum_scale_factor</literal> (<type>float4</>)</term>
____________________________________________________________________________-->
    <term><literal>autovacuum_vacuum_scale_factor</>, <literal>toast.autovacuum_vacuum_scale_factor</literal> (<type>float4</>)</term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Per-table value for <xref linkend="guc-autovacuum-vacuum-scale-factor">
      parameter.
     </para>
____________________________________________________________________________-->
     <para>
     <xref linkend="guc-autovacuum-vacuum-scale-factor">参数对于每个表的值。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>autovacuum_analyze_threshold</> (<type>integer</>)</term>
____________________________________________________________________________-->
    <term><literal>autovacuum_analyze_threshold</> (<type>integer</>)</term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Per-table value for <xref linkend="guc-autovacuum-analyze-threshold">
      parameter.
     </para>
____________________________________________________________________________-->
     <para>
     <xref linkend="guc-autovacuum-analyze-threshold">参数对于每个表的值。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>autovacuum_analyze_scale_factor</> (<type>float4</>)</term>
____________________________________________________________________________-->
    <term><literal>autovacuum_analyze_scale_factor</> (<type>float4</>)</term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Per-table value for <xref linkend="guc-autovacuum-analyze-scale-factor">
      parameter.
     </para>
____________________________________________________________________________-->
     <para>
     <xref linkend="guc-autovacuum-analyze-scale-factor">参数对于每个表的值。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>autovacuum_vacuum_cost_delay</>, <literal>toast.autovacuum_vacuum_cost_delay</literal> (<type>integer</>)</term>
____________________________________________________________________________-->
    <term><literal>autovacuum_vacuum_cost_delay</>, <literal>toast.autovacuum_vacuum_cost_delay</literal> (<type>integer</>)</term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Per-table value for <xref linkend="guc-autovacuum-vacuum-cost-delay">
      parameter.
     </para>
____________________________________________________________________________-->
     <para>
     <xref linkend="guc-autovacuum-vacuum-cost-delay">参数对于每个表的值。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>autovacuum_vacuum_cost_limit</>, <literal>toast.autovacuum_vacuum_cost_limit</literal> (<type>integer</>)</term>
____________________________________________________________________________-->
    <term><literal>autovacuum_vacuum_cost_limit</>, <literal>toast.autovacuum_vacuum_cost_limit</literal> (<type>integer</>)</term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Per-table value for <xref linkend="guc-autovacuum-vacuum-cost-limit">
      parameter.
     </para>
____________________________________________________________________________-->
     <para>
     <xref linkend="guc-autovacuum-vacuum-cost-limit">参数对于每个表的值。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>autovacuum_freeze_min_age</>, <literal>toast.autovacuum_freeze_min_age</literal> (<type>integer</>)</term>
____________________________________________________________________________-->
    <term><literal>autovacuum_freeze_min_age</>, <literal>toast.autovacuum_freeze_min_age</literal> (<type>integer</>)</term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Per-table value for <xref linkend="guc-vacuum-freeze-min-age">
      parameter.  Note that autovacuum will ignore
      per-table <literal>autovacuum_freeze_min_age</> parameters that are
      larger than half the
      system-wide <xref linkend="guc-autovacuum-freeze-max-age"> setting.
     </para>
____________________________________________________________________________-->
     <para>
     <xref linkend="guc-vacuum-freeze-min-age">参数对于每个表的值。注意自动清理将忽略超过系统范围<xref linkend="guc-autovacuum-freeze-max-age">参数一半的针对每个表的<literal>autovacuum_freeze_min_age</>参数。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>autovacuum_freeze_max_age</>, <literal>toast.autovacuum_freeze_max_age</literal> (<type>integer</>)</term>
____________________________________________________________________________-->
    <term><literal>autovacuum_freeze_max_age</>, <literal>toast.autovacuum_freeze_max_age</literal> (<type>integer</>)</term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Per-table value for <xref linkend="guc-autovacuum-freeze-max-age">
      parameter.  Note that autovacuum will ignore
      per-table <literal>autovacuum_freeze_max_age</> parameters that are
      larger than the system-wide setting (it can only be set smaller).
     </para>
____________________________________________________________________________-->
     <para>
     <xref linkend="guc-autovacuum-freeze-max-age">参数对于每个表的值。注意自动清理将忽略超过系统范围参数（只能被设置得较小）一半的针对每个表的<literal>autovacuum_freeze_max_age</>参数。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>autovacuum_freeze_table_age</literal>, <literal>toast.autovacuum_freeze_table_age</literal> (<type>integer</type>)</term>
____________________________________________________________________________-->
    <term><literal>autovacuum_freeze_table_age</literal>, <literal>toast.autovacuum_freeze_table_age</literal> (<type>integer</type>)</term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Per-table value for <xref linkend="guc-vacuum-freeze-table-age">
      parameter.
     </para>
____________________________________________________________________________-->
     <para>
      <xref linkend="guc-vacuum-freeze-table-age">参数对于每个表的值。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>autovacuum_multixact_freeze_min_age</literal>, <literal>toast.autovacuum_multixact_freeze_min_age</literal> (<type>integer</type>)</term>
____________________________________________________________________________-->
    <term><literal>autovacuum_multixact_freeze_min_age</literal>, <literal>toast.autovacuum_multixact_freeze_min_age</literal> (<type>integer</type>)</term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Per-table value for <xref linkend="guc-vacuum-multixact-freeze-min-age">
      parameter.  Note that autovacuum will ignore
      per-table <literal>autovacuum_multixact_freeze_min_age</> parameters
      that are larger than half the
      system-wide <xref linkend="guc-autovacuum-multixact-freeze-max-age">
      setting.
     </para>
____________________________________________________________________________-->
     <para>
      <xref linkend="guc-vacuum-multixact-freeze-min-age">参数对于每个表的值。注意自动清理将忽略超过系统范围<xref linkend="guc-autovacuum-multixact-freeze-max-age">参数一半的针对每个表的<literal>autovacuum_multixact_freeze_min_age</>参数。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>autovacuum_multixact_freeze_max_age</literal>, <literal>toast.autovacuum_multixact_freeze_max_age</literal> (<type>integer</type>)</term>
____________________________________________________________________________-->
    <term><literal>autovacuum_multixact_freeze_max_age</literal>, <literal>toast.autovacuum_multixact_freeze_max_age</literal> (<type>integer</type>)</term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Per-table value
      for <xref linkend="guc-autovacuum-multixact-freeze-max-age"> parameter.
      Note that autovacuum will ignore
      per-table <literal>autovacuum_multixact_freeze_max_age</> parameters
      that are larger than the system-wide setting (it can only be set
      smaller).
     </para>
____________________________________________________________________________-->
     <para>
      <xref linkend="guc-autovacuum-multixact-freeze-max-age">参数对于每个表的值。注意自动清理将忽略超过系统范围参数（只能被设置得较小）一半的针对每个表的<literal>autovacuum_multixact_freeze_max_age</>参数。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>autovacuum_multixact_freeze_table_age</literal>, <literal>toast.autovacuum_multixact_freeze_table_age</literal> (<type>integer</type>)</term>
____________________________________________________________________________-->
    <term><literal>autovacuum_multixact_freeze_table_age</literal>, <literal>toast.autovacuum_multixact_freeze_table_age</literal> (<type>integer</type>)</term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Per-table value
      for <xref linkend="guc-vacuum-multixact-freeze-table-age"> parameter.
     </para>
____________________________________________________________________________-->
     <para>
      <xref linkend="guc-vacuum-multixact-freeze-table-age">参数对于每个表的值。
     </para>
    </listitem>
   </varlistentry>
   
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>log_autovacuum_min_duration</literal>, <literal>toast.log_autovacuum_min_duration</literal> (<type>integer</type>)</term>
____________________________________________________________________________-->
    <term><literal>log_autovacuum_min_duration</literal>, <literal>toast.log_autovacuum_min_duration</literal> (<type>integer</type>)</term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Per-table value for <xref linkend="guc-log-autovacuum-min-duration">
      parameter.
     </para>
____________________________________________________________________________-->
     <para>
      <xref linkend="guc-log-autovacuum-min-duration">参数对于每个表的值。
     </para>
    </listitem>
   </varlistentry>
   
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>user_catalog_table</literal> (<type>boolean</type>)</term>
____________________________________________________________________________-->
    <term><literal>user_catalog_table</literal> (<type>boolean</type>)</term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Declare the table as an additional catalog table for purposes of
      logical replication. See
      <xref linkend="logicaldecoding-capabilities"> for details.
      This parameter cannot be set for TOAST tables.
     </para>
____________________________________________________________________________-->
     <para>
      声明该表是一个用于逻辑复制目的的额外的目录表。详见<xref linkend="logicaldecoding-capabilities">。不能对 TOAST 表设置这个参数。
     </para>
    </listitem>
   </varlistentry>

   </variablelist>

  </refsect2>
 </refsect1>

 <refsect1 id="SQL-CREATETABLE-notes">
<!--==========================orignal english content==========================
  <title>Notes</title>
____________________________________________________________________________-->
  <title>注解</title>

<!--==========================orignal english content==========================
    <para>
     Using OIDs in new applications is not recommended: where
     possible, using an identity column or other sequence
     generator as the table's primary key is preferred. However, if
     your application does make use of OIDs to identify specific
     rows of a table, it is recommended to create a unique constraint
     on the <structfield>oid</> column of that table, to ensure that
     OIDs in the table will indeed uniquely identify rows even after
     counter wraparound.  Avoid assuming that OIDs are unique across
     tables; if you need a database-wide unique identifier, use the
     combination of <structfield>tableoid</> and row OID for the
     purpose.
    </para>
____________________________________________________________________________-->
    <para>
     我们不推荐在新应用中使用 OID：在可能要用到的地方，使用一个标识列或者其他序列生成器作为表的主键会更好。不过，如果你的应用确实需要用到 OID 来标识一个表的特定行，我们推荐在表的<structfield>oid</>列上创建一个唯一约束，来确保表中的 OID 在计数器回卷后能唯一标识行。如果你需要一个数据库范围的唯一标识符，要避免假定 OID 在表之间也是唯一的，应该用<structfield>tableoid</>和行 OID 的组合来实现该目的。
    </para>

    <tip>
<!--==========================orignal english content==========================
     <para>
      The use of <literal>OIDS=FALSE</literal> is not recommended
      for tables with no primary key, since without either an OID or a
      unique data key, it is difficult to identify specific rows.
     </para>
____________________________________________________________________________-->
     <para>
      我们不推荐对没有主键的表使用<literal>OIDS=FALSE</literal>，因为没有 OID 或 唯一数据键，就很难标识特定的行。
     </para>
    </tip>

<!--==========================orignal english content==========================
    <para>
     <productname>PostgreSQL</productname> automatically creates an
     index for each unique constraint and primary key constraint to
     enforce uniqueness.  Thus, it is not necessary to create an
     index explicitly for primary key columns.  (See <xref
     linkend="sql-createindex"> for more information.)
    </para>
____________________________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>为每一个唯一约束和主键约束创建一个索引来强制唯一性。因此，没有必要显式地为主键列创建一个索引（详见<xref linkend="sql-createindex">）。
    </para>

<!--==========================orignal english content==========================
    <para>
     Unique constraints and primary keys are not inherited in the
     current implementation.  This makes the combination of
     inheritance and unique constraints rather dysfunctional.
    </para>
____________________________________________________________________________-->
    <para>
     在当前的实现中，唯一约束和主键不会被继承。这使得继承和唯一约束的组合相当不正常。
    </para>

<!--==========================orignal english content==========================
    <para>
     A table cannot have more than 1600 columns.  (In practice, the
     effective limit is usually lower because of tuple-length constraints.)
    </para>
____________________________________________________________________________-->
    <para>
     一个表不能有超过 1600 列（实际上，由于元组长度限制，有效的限制通常更低）。
    </para>

 </refsect1>


 <refsect1 id="SQL-CREATETABLE-examples">
<!--==========================orignal english content==========================
  <title>Examples</title>
____________________________________________________________________________-->
  <title>例子</title>

<!--==========================orignal english content==========================
  <para>
   Create table <structname>films</> and table
   <structname>distributors</>:

<programlisting>
CREATE TABLE films (
    code        char(5) CONSTRAINT firstkey PRIMARY KEY,
    title       varchar(40) NOT NULL,
    did         integer NOT NULL,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute
);

CREATE TABLE distributors (
     did    integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
     name   varchar(40) NOT NULL CHECK (name &lt;&gt; '')
);
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   创建表<structname>films</>和表<structname>distributors</>：

<programlisting>
CREATE TABLE films (
    code        char(5) CONSTRAINT firstkey PRIMARY KEY,
    title       varchar(40) NOT NULL,
    did         integer NOT NULL,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute
);

CREATE TABLE distributors (
     did    integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
     name   varchar(40) NOT NULL CHECK (name &lt;&gt; '')
);
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Create a table with a 2-dimensional array:

<programlisting>
CREATE TABLE array_int (
    vector  int[][]
);
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   创建有一个二维数组的表：

<programlisting>
CREATE TABLE array_int (
    vector  int[][]
);
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Define a unique table constraint for the table
   <literal>films</literal>.  Unique table constraints can be defined
   on one or more columns of the table:

<programlisting>
CREATE TABLE films (
    code        char(5),
    title       varchar(40),
    did         integer,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute,
    CONSTRAINT production UNIQUE(date_prod)
);
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   为表<literal>films</literal>定义一个唯一表约束。唯一表约束能够被定义在表的一列或多列上：

<programlisting>
CREATE TABLE films (
    code        char(5),
    title       varchar(40),
    did         integer,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute,
    CONSTRAINT production UNIQUE(date_prod)
);
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Define a check column constraint:

<programlisting>
CREATE TABLE distributors (
    did     integer CHECK (did &gt; 100),
    name    varchar(40)
);
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   定义一个列检查约束：

<programlisting>
CREATE TABLE distributors (
    did     integer CHECK (did &gt; 100),
    name    varchar(40)
);
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Define a check table constraint:

<programlisting>
CREATE TABLE distributors (
    did     integer,
    name    varchar(40)
    CONSTRAINT con1 CHECK (did &gt; 100 AND name &lt;&gt; '')
);
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   定义一个表检查约束：

<programlisting>
CREATE TABLE distributors (
    did     integer,
    name    varchar(40)
    CONSTRAINT con1 CHECK (did &gt; 100 AND name &lt;&gt; '')
);
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Define a primary key table constraint for the table
   <structname>films</>:

<programlisting>
CREATE TABLE films (
    code        char(5),
    title       varchar(40),
    did         integer,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute,
    CONSTRAINT code_title PRIMARY KEY(code,title)
);
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   为表<structname>films</>定义一个主键表约束：

<programlisting>
CREATE TABLE films (
    code        char(5),
    title       varchar(40),
    did         integer,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute,
    CONSTRAINT code_title PRIMARY KEY(code,title)
);
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Define a primary key constraint for table
   <structname>distributors</>.  The following two examples are
   equivalent, the first using the table constraint syntax, the second
   the column constraint syntax:

<programlisting>
CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    PRIMARY KEY(did)
);

CREATE TABLE distributors (
    did     integer PRIMARY KEY,
    name    varchar(40)
);
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   为表<structname>distributors</>定义一个主键约束。下面的两个例子是等价的，第一个使用表约束语法，第二个使用列约束语法：

<programlisting>
CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    PRIMARY KEY(did)
);

CREATE TABLE distributors (
    did     integer PRIMARY KEY,
    name    varchar(40)
);
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Assign a literal constant default value for the column
   <literal>name</literal>, arrange for the default value of column
   <literal>did</literal> to be generated by selecting the next value
   of a sequence object, and make the default value of
   <literal>modtime</literal> be the time at which the row is
   inserted:

<programlisting>
CREATE TABLE distributors (
    name      varchar(40) DEFAULT 'Luso Films',
    did       integer DEFAULT nextval('distributors_serial'),
    modtime   timestamp DEFAULT current_timestamp
);
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   为列<literal>name</literal>赋予一个文字常量默认值，安排列<literal>did</literal>的默认值是从一个序列对象中选择下一个值产生，并且让<literal>modtime</literal>的默认值是该行被插入的时间：

<programlisting>
CREATE TABLE distributors (
    name      varchar(40) DEFAULT 'Luso Films',
    did       integer DEFAULT nextval('distributors_serial'),
    modtime   timestamp DEFAULT current_timestamp
);
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Define two <literal>NOT NULL</> column constraints on the table
   <classname>distributors</classname>, one of which is explicitly
   given a name:

<programlisting>
CREATE TABLE distributors (
    did     integer CONSTRAINT no_null NOT NULL,
    name    varchar(40) NOT NULL
);
</programlisting>
    </para>
____________________________________________________________________________-->
  <para>
   在表<classname>distributors</classname>上定义两个<literal>NOT NULL</>列约束，其中之一被显式给定了一个名称：

<programlisting>
CREATE TABLE distributors (
    did     integer CONSTRAINT no_null NOT NULL,
    name    varchar(40) NOT NULL
);
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     Define a unique constraint for the <literal>name</literal> column:

<programlisting>
CREATE TABLE distributors (
    did     integer,
    name    varchar(40) UNIQUE
);
</programlisting>

     The same, specified as a table constraint:

<programlisting>
CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    UNIQUE(name)
);
</programlisting>
  </para>
____________________________________________________________________________-->
    <para>
     为<literal>name</literal>列定义一个唯一约束：

<programlisting>
CREATE TABLE distributors (
    did     integer,
    name    varchar(40) UNIQUE
);
</programlisting>

     同样的唯一约束用表约束指定：

<programlisting>
CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    UNIQUE(name)
);
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Create the same table, specifying 70% fill factor for both the table
   and its unique index:

<programlisting>
CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    UNIQUE(name) WITH (fillfactor=70)
)
WITH (fillfactor=70);
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   创建相同的表，指定表和它的唯一索引指定 70% 的填充因子：

<programlisting>
CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    UNIQUE(name) WITH (fillfactor=70)
)
WITH (fillfactor=70);
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Create table <structname>circles</> with an exclusion
   constraint that prevents any two circles from overlapping:

<programlisting>
CREATE TABLE circles (
    c circle,
    EXCLUDE USING gist (c WITH &amp;&amp;)
);
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   创建表<structname>circles</>，带有一个排除约束阻止任意两个圆重叠：

<programlisting>
CREATE TABLE circles (
    c circle,
    EXCLUDE USING gist (c WITH &amp;&amp;)
);
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Create table <structname>cinemas</> in tablespace <structname>diskvol1</>:

<programlisting>
CREATE TABLE cinemas (
        id serial,
        name text,
        location text
) TABLESPACE diskvol1;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   在表空间<structname>diskvol1</>中创建表<structname>cinemas</>：

<programlisting>
CREATE TABLE cinemas (
        id serial,
        name text,
        location text
) TABLESPACE diskvol1;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Create a composite type and a typed table:
<programlisting>
CREATE TYPE employee_type AS (name text, salary numeric);

CREATE TABLE employees OF employee_type (
    PRIMARY KEY (name),
    salary WITH OPTIONS DEFAULT 1000
);
</programlisting></para>
____________________________________________________________________________-->
  <para>
   创建一个组合类型以及一个类型化的表：
<programlisting>
CREATE TYPE employee_type AS (name text, salary numeric);

CREATE TABLE employees OF employee_type (
    PRIMARY KEY (name),
    salary WITH OPTIONS DEFAULT 1000
);
</programlisting></para>

<!--==========================orignal english content==========================
  <para>
   Create a range partitioned table:
<programlisting>
CREATE TABLE measurement (
    logdate         date not null,
    peaktemp        int,
    unitsales       int
) PARTITION BY RANGE (logdate);
</programlisting></para>
____________________________________________________________________________-->
  <para>
   创建一个范围分区表：
<programlisting>
CREATE TABLE measurement (
    logdate         date not null,
    peaktemp        int,
    unitsales       int
) PARTITION BY RANGE (logdate);
</programlisting></para>

<!--==========================orignal english content==========================
  <para>
   Create a range partitioned table with multiple columns in the partition key:
<programlisting>
CREATE TABLE measurement_year_month (
    logdate         date not null,
    peaktemp        int,
    unitsales       int
) PARTITION BY RANGE (EXTRACT(YEAR FROM logdate), EXTRACT(MONTH FROM logdate));
</programlisting></para>
____________________________________________________________________________-->
  <para>
   创建在分区键中具有多个列的范围分区表：
<programlisting>
CREATE TABLE measurement_year_month (
    logdate         date not null,
    peaktemp        int,
    unitsales       int
) PARTITION BY RANGE (EXTRACT(YEAR FROM logdate), EXTRACT(MONTH FROM logdate));
</programlisting></para>

<!--==========================orignal english content==========================
  <para>
   Create a list partitioned table:
<programlisting>
CREATE TABLE cities (
    city_id      bigserial not null,
    name         text not null,
    population   bigint
) PARTITION BY LIST (left(lower(name), 1));
</programlisting></para>
____________________________________________________________________________-->
  <para>
   创建列表分区表：
<programlisting>
CREATE TABLE cities (
    city_id      bigserial not null,
    name         text not null,
    population   bigint
) PARTITION BY LIST (left(lower(name), 1));
</programlisting></para>

<!--==========================orignal english content==========================
  <para>
   Create partition of a range partitioned table:
<programlisting>
CREATE TABLE measurement_y2016m07
    PARTITION OF measurement (
    unitsales DEFAULT 0
) FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');
</programlisting></para>
____________________________________________________________________________-->
  <para>
   创建范围分区表的分区：
<programlisting>
CREATE TABLE measurement_y2016m07
    PARTITION OF measurement (
    unitsales DEFAULT 0
) FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');
</programlisting></para>

<!--==========================orignal english content==========================
  <para>
   Create a few partitions of a range partitioned table with multiple
   columns in the partition key:
<programlisting>
CREATE TABLE measurement_ym_older
    PARTITION OF measurement_year_month
    FOR VALUES FROM (MINVALUE, MINVALUE) TO (2016, 11);

CREATE TABLE measurement_ym_y2016m11
    PARTITION OF measurement_year_month
    FOR VALUES FROM (2016, 11) TO (2016, 12);

CREATE TABLE measurement_ym_y2016m12
    PARTITION OF measurement_year_month
    FOR VALUES FROM (2016, 12) TO (2017, 01);

CREATE TABLE measurement_ym_y2017m01
    PARTITION OF measurement_year_month
    FOR VALUES FROM (2017, 01) TO (2017, 02);
</programlisting></para>
____________________________________________________________________________-->
  <para>
   使用分区键中的多个列创建范围分区表的几个分区：
<programlisting>
CREATE TABLE measurement_ym_older
    PARTITION OF measurement_year_month
    FOR VALUES FROM (MINVALUE, MINVALUE) TO (2016, 11);

CREATE TABLE measurement_ym_y2016m11
    PARTITION OF measurement_year_month
    FOR VALUES FROM (2016, 11) TO (2016, 12);

CREATE TABLE measurement_ym_y2016m12
    PARTITION OF measurement_year_month
    FOR VALUES FROM (2016, 12) TO (2017, 01);

CREATE TABLE measurement_ym_y2017m01
    PARTITION OF measurement_year_month
    FOR VALUES FROM (2017, 01) TO (2017, 02);
</programlisting></para>

<!--==========================orignal english content==========================
  <para>
   Create partition of a list partitioned table:
<programlisting>
CREATE TABLE cities_ab
    PARTITION OF cities (
    CONSTRAINT city_id_nonzero CHECK (city_id != 0)
) FOR VALUES IN ('a', 'b');
</programlisting></para>
____________________________________________________________________________-->
  <para>
   创建列表分区表的分区：
<programlisting>
CREATE TABLE cities_ab
    PARTITION OF cities (
    CONSTRAINT city_id_nonzero CHECK (city_id != 0)
) FOR VALUES IN ('a', 'b');
</programlisting></para>

<!--==========================orignal english content==========================
  <para>
   Create partition of a list partitioned table that is itself further
   partitioned and then add a partition to it:
<programlisting>
CREATE TABLE cities_ab
    PARTITION OF cities (
    CONSTRAINT city_id_nonzero CHECK (city_id != 0)
) FOR VALUES IN ('a', 'b') PARTITION BY RANGE (population);

CREATE TABLE cities_ab_10000_to_100000
    PARTITION OF cities_ab FOR VALUES FROM (10000) TO (100000);
</programlisting></para>
____________________________________________________________________________-->
  <para>
   创建本身是分区的列表分区表的分区，然后向其添加分区：
<programlisting>
CREATE TABLE cities_ab
    PARTITION OF cities (
    CONSTRAINT city_id_nonzero CHECK (city_id != 0)
) FOR VALUES IN ('a', 'b') PARTITION BY RANGE (population);

CREATE TABLE cities_ab_10000_to_100000
    PARTITION OF cities_ab FOR VALUES FROM (10000) TO (100000);
</programlisting></para>
 </refsect1>

 <refsect1 id="SQL-CREATETABLE-compatibility">
<!--==========================orignal english content==========================
  <title id="SQL-CREATETABLE-compatibility-title">Compatibility</title>
____________________________________________________________________________-->
  <title id="SQL-CREATETABLE-compatibility-title">兼容性</title>

<!--==========================orignal english content==========================
  <para>
   The <command>CREATE TABLE</command> command conforms to the
   <acronym>SQL</acronym> standard, with exceptions listed below.
  </para>
____________________________________________________________________________-->
  <para>
   <command>CREATE TABLE</command>命令遵从<acronym>SQL</acronym>标准，除了以下例外。
  </para>

  <refsect2>
<!--==========================orignal english content==========================
   <title>Temporary Tables</title>
____________________________________________________________________________-->
   <title>临时表</title>

<!--==========================orignal english content==========================
   <para>
    Although the syntax of <literal>CREATE TEMPORARY TABLE</literal>
    resembles that of the SQL standard, the effect is not the same.  In the
    standard,
    temporary tables are defined just once and automatically exist (starting
    with empty contents) in every session that needs them.
    <productname>PostgreSQL</productname> instead
    requires each session to issue its own <literal>CREATE TEMPORARY
    TABLE</literal> command for each temporary table to be used.  This allows
    different sessions to use the same temporary table name for different
    purposes, whereas the standard's approach constrains all instances of a
    given temporary table name to have the same table structure.
   </para>
____________________________________________________________________________-->
   <para>
    尽管<literal>CREATE TEMPORARY TABLE</literal>的语法很像 SQL 标准的语法，但事实是并不相同。在标准中，临时表只需要被定义一次并且会自动地存在（从空内容开始）于需要它们的每一个会话中。<productname>PostgreSQL</productname>则要求每一个会话为每一个要用的临时表发出它自己的<literal>CREATE TEMPORARY TABLE</literal>命令。这允许不同的会话为不同的目的使用相同的临时表名，而标准的方法约束一个给定临时表名的所有实例都必须具有相同的表结构。
   </para>

<!--==========================orignal english content==========================
   <para>
    The standard's definition of the behavior of temporary tables is
    widely ignored.  <productname>PostgreSQL</productname>'s behavior
    on this point is similar to that of several other SQL databases.
   </para>
____________________________________________________________________________-->
   <para>
    标准中对于临时表行为的定义被广泛地忽略了。<productname>PostgreSQL</productname>在这一点上的行为和多种其他 SQL 数据库是相似的。
   </para>

<!--==========================orignal english content==========================
   <para>
    The SQL standard also distinguishes between global and local temporary
    tables, where a local temporary table has a separate set of contents for
    each SQL module within each session, though its definition is still shared
    across sessions.  Since <productname>PostgreSQL</productname> does not
    support SQL modules, this distinction is not relevant in
    <productname>PostgreSQL</productname>.
   </para>
____________________________________________________________________________-->
   <para>
    SQL 标准也区分全局和局部临时表，其中一个局部临时表为每一个会话中的每一个 SQL 模块具有一个独立的内容集合，但是它的定义仍然是多个会话共享的。因为<productname>PostgreSQL</productname>不支持 SQL 模块，这种区别与<productname>PostgreSQL</productname>无关。
   </para>

<!--==========================orignal english content==========================
   <para>
    For compatibility's sake, <productname>PostgreSQL</productname> will
    accept the <literal>GLOBAL</literal> and <literal>LOCAL</literal> keywords
    in a temporary table declaration, but they currently have no effect.
    Use of these keywords is discouraged, since future versions of
    <productname>PostgreSQL</productname> might adopt a more
    standard-compliant interpretation of their meaning.
   </para>
____________________________________________________________________________-->
   <para>
    为了兼容性目的，<productname>PostgreSQL</productname>将在临时表声明中接受<literal>GLOBAL</literal>和<literal>LOCAL</literal>关键词，但是它们当前没有效果。我们不鼓励使用这些关键词，因为未来版本的<productname>PostgreSQL</productname>可能采用一种更兼容标准的（对它们含义的）解释。
   </para>

<!--==========================orignal english content==========================
   <para>
    The <literal>ON COMMIT</literal> clause for temporary tables
    also resembles the SQL standard, but has some differences.
    If the <literal>ON COMMIT</> clause is omitted, SQL specifies that the
    default behavior is <literal>ON COMMIT DELETE ROWS</>.  However, the
    default behavior in <productname>PostgreSQL</productname> is
    <literal>ON COMMIT PRESERVE ROWS</literal>.  The <literal>ON COMMIT
    DROP</literal> option does not exist in SQL.
   </para>
____________________________________________________________________________-->
   <para>
    临时表的<literal>ON COMMIT</literal>子句也和 SQL 标准相似，但是有一些不同。如果忽略<literal>ON COMMIT</>子句，SQL 指定默认行为是<literal>ON COMMIT DELETE ROWS</>。但是，<productname>PostgreSQL</productname>中的默认行为是<literal>ON COMMIT PRESERVE ROWS</literal>。SQL 中不存在<literal>ON COMMIT DROP</literal>选项。
   </para>
  </refsect2>

  <refsect2>
<!--==========================orignal english content==========================
   <title>Non-deferred Uniqueness Constraints</title>
____________________________________________________________________________-->
   <title>非延迟唯一性约束</title>

<!--==========================orignal english content==========================
   <para>
    When a <literal>UNIQUE</> or <literal>PRIMARY KEY</> constraint is
    not deferrable, <productname>PostgreSQL</productname> checks for
    uniqueness immediately whenever a row is inserted or modified.
    The SQL standard says that uniqueness should be enforced only at
    the end of the statement; this makes a difference when, for example,
    a single command updates multiple key values.  To obtain
    standard-compliant behavior, declare the constraint as
    <literal>DEFERRABLE</> but not deferred (i.e., <literal>INITIALLY
    IMMEDIATE</>).  Be aware that this can be significantly slower than
    immediate uniqueness checking.
   </para>
____________________________________________________________________________-->
   <para>
    但一个<literal>UNIQUE</>或<literal>PRIMARY KEY</>约束是非可延迟的，只要一个行被插入或修改，<productname>PostgreSQL</productname>就会立即检查唯一性。SQL 标准指出只有在语句结束时才应该强制唯一性。当一个单一命令更新多个键值时，这两者是不同的。要得到兼容标准的行为，将该约束声明为<literal>DEFERRABLE</>但是不延迟（即<literal>INITIALLY IMMEDIATE</>）。注意这可能要显著地慢于立即唯一性检查。
   </para>
  </refsect2>

  <refsect2>
<!--==========================orignal english content==========================
   <title>Column Check Constraints</title>
____________________________________________________________________________-->
   <title>列检查约束</title>

<!--==========================orignal english content==========================
   <para>
    The SQL standard says that <literal>CHECK</> column constraints
    can only refer to the column they apply to; only <literal>CHECK</>
    table constraints can refer to multiple columns.
    <productname>PostgreSQL</productname> does not enforce this
    restriction; it treats column and table check constraints alike.
   </para>
____________________________________________________________________________-->
   <para>
    SQL 标准指出<literal>CHECK</>列约束只能引用它们应用到的列，只有<literal>CHECK</>表约束能够引用多列。<productname>PostgreSQL</productname>并没有强制这个限制，它同样处理列检查约束和表检查约束。
   </para>
  </refsect2>

  <refsect2>
<!--==========================orignal english content==========================
   <title><literal>EXCLUDE</literal> Constraint</title>
____________________________________________________________________________-->
   <title><literal>EXCLUDE</literal> 约束</title>

<!--==========================orignal english content==========================
   <para>
    The <literal>EXCLUDE</> constraint type is a
    <productname>PostgreSQL</productname> extension.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>EXCLUDE</>约束类型是一种<productname>PostgreSQL</productname>扩展。
   </para>
  </refsect2>

  <refsect2>
<!--==========================orignal english content==========================
   <title><literal>NULL</literal> <quote>Constraint</quote></title>
____________________________________________________________________________-->
   <title><literal>NULL</literal> <quote>约束</quote></title>

<!--==========================orignal english content==========================
   <para>
    The <literal>NULL</> <quote>constraint</quote> (actually a
    non-constraint) is a <productname>PostgreSQL</productname>
    extension to the SQL standard that is included for compatibility with some
    other database systems (and for symmetry with the <literal>NOT
    NULL</literal> constraint).  Since it is the default for any
    column, its presence is simply noise.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>NULL</> <quote>约束</quote>（实际上是一个非约束）是一个<productname>PostgreSQL</productname>对 SQL 标准的扩展，它也被包括（以及对称的<literal>NOT NULL</literal>约束）在一些其他的数据库系统中以实现兼容性。因为它是任意列的默认值，它的存在就像噪声一样。
   </para>
  </refsect2>

  <refsect2>
<!--==========================orignal english content==========================
   <title>Inheritance</title>
____________________________________________________________________________-->
   <title>继承</title>

<!--==========================orignal english content==========================
   <para>
    Multiple inheritance via the <literal>INHERITS</literal> clause is
    a <productname>PostgreSQL</productname> language extension.
    SQL:1999 and later define single inheritance using a
    different syntax and different semantics.  SQL:1999-style
    inheritance is not yet supported by
    <productname>PostgreSQL</productname>.
   </para>
____________________________________________________________________________-->
   <para>
    通过<literal>INHERITS</literal>子句的多继承是一种<productname>PostgreSQL</productname>的语言扩展。SQL:1999 以及之后的标准使用一种不同的语法和不同的语义定义了单继承。SQL:1999-风格的继承还没有被<productname>PostgreSQL</productname>。
   </para>
  </refsect2>

  <refsect2>
<!--==========================orignal english content==========================
   <title>Zero-column Tables</title>
____________________________________________________________________________-->
   <title>零列表</title>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</productname> allows a table of no columns
    to be created (for example, <literal>CREATE TABLE foo();</>).  This
    is an extension from the SQL standard, which does not allow zero-column
    tables.  Zero-column tables are not in themselves very useful, but
    disallowing them creates odd special cases for <command>ALTER TABLE
    DROP COLUMN</>, so it seems cleaner to ignore this spec restriction.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>允许创建一个没有列的表（例如<literal>CREATE TABLE foo();</>）。这是一个对于 SQL 标准的扩展，它不允许零列表。零列表本身并不是很有用，但是不允许它们会为<command>ALTER TABLE DROP COLUMN</>带来奇怪的特殊情况，因此忽略这种规则限制看起来更加整洁。
   </para>
  </refsect2>

  <refsect2>
<!--==========================orignal english content==========================
   <title>Multiple Identity Columns</title>
____________________________________________________________________________-->
   <title>多个标识列</title>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</productname> allows a table to have more than one
    identity column.  The standard specifies that a table can have at most one
    identity column.  This is relaxed mainly to give more flexibility for
    doing schema changes or migrations.  Note that
    the <command>INSERT</command> command supports only one override clause
    that applies to the entire statement, so having multiple identity columns
    with different behaviors is not well supported.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>允许一个表拥有多个标识列。
	该标准指定一个表最多只能有一个标识列。这主要是为了给模式更改或迁移提供更大的灵活性。
	请注意，<command>INSERT</command>命令仅支持一个适用于整个语句的覆盖子句，
	因此不支持具有不同行为的多个标识列。
   </para>
  </refsect2>
  
  <refsect2>
<!--==========================orignal english content==========================
   <title><literal>LIKE</> Clause</title>
____________________________________________________________________________-->
   <title><literal>LIKE</> 子句</title>

<!--==========================orignal english content==========================
   <para>
    While a <literal>LIKE</> clause exists in the SQL standard, many of the
    options that <productname>PostgreSQL</productname> accepts for it are not
    in the standard, and some of the standard's options are not implemented
    by <productname>PostgreSQL</productname>.
   </para>
____________________________________________________________________________-->
   <para>
    虽然 SQL 标准中有一个<literal>LIKE</>子句，但是<productname>PostgreSQL</productname>接受的很多<literal>LIKE</>子句选项却不在标准中，并且有些标准中的选项也没有被<productname>PostgreSQL</productname>实现。
   </para>
  </refsect2>

  <refsect2>
<!--==========================orignal english content==========================
   <title><literal>WITH</> Clause</title>
____________________________________________________________________________-->
   <title><literal>WITH</>子句</title>

<!--==========================orignal english content==========================
   <para>
    The <literal>WITH</> clause is a <productname>PostgreSQL</productname>
    extension; neither storage parameters nor OIDs are in the standard.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>WITH</>子句是一个<productname>PostgreSQL</productname>扩展，存储参数和 OID 都不在标准中。
   </para>
  </refsect2>

  <refsect2>
<!--==========================orignal english content==========================
   <title>Tablespaces</title>
____________________________________________________________________________-->
   <title>表空间</title>

<!--==========================orignal english content==========================
   <para>
    The <productname>PostgreSQL</productname> concept of tablespaces is not
    part of the standard.  Hence, the clauses <literal>TABLESPACE</literal>
    and <literal>USING INDEX TABLESPACE</literal> are extensions.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>的表空间概念不是标准的一部分。因此，子句<literal>TABLESPACE</literal>和<literal>USING INDEX TABLESPACE</literal>是扩展。
   </para>
  </refsect2>

  <refsect2>
<!--==========================orignal english content==========================
   <title>Typed Tables</title>
____________________________________________________________________________-->
   <title>类型化的表</title>

<!--==========================orignal english content==========================
   <para>
    Typed tables implement a subset of the SQL standard.  According to
    the standard, a typed table has columns corresponding to the
    underlying composite type as well as one other column that is
    the <quote>self-referencing column</quote>.  PostgreSQL does not
    support these self-referencing columns explicitly, but the same
    effect can be had using the OID feature.
   </para>
____________________________________________________________________________-->
   <para>
    类型化的表实现了 SQL 标准的一个子集。根据标准，一个类型化的表具有与底层组合类型相对应的列，以及其他的<quote>自引用列</quote>。PostgreSQL 不显式支持这些自引用列，但是可以使用 OID 特性获得相同的效果。
   </para>
  </refsect2>

  <refsect2>
<!--==========================orignal english content==========================
   <title><literal>PARTITION BY</> Clause</title>
____________________________________________________________________________-->
   <title><literal>PARTITION BY</> 子句</title>

<!--==========================orignal english content==========================
   <para>
    The <literal>PARTITION BY</> clause is a
    <productname>PostgreSQL</productname> extension.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>PARTITION BY</>子句是<productname>PostgreSQL</productname>的一个扩展。
   </para>
  </refsect2>

  <refsect2>
<!--==========================orignal english content==========================
   <title><literal>PARTITION OF</> Clause</title>
____________________________________________________________________________-->
   <title><literal>PARTITION OF</> 子句</title>

<!--==========================orignal english content==========================
   <para>
    The <literal>PARTITION OF</> clause is a
    <productname>PostgreSQL</productname> extension.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>PARTITION OF</>子句<productname>PostgreSQL</productname>的一个扩展。
   </para>
  </refsect2>

  </refsect1>


 <refsect1>
<!--==========================orignal english content==========================
  <title>See Also</title>
____________________________________________________________________________-->
  <title>参见</title>

  <simplelist type="inline">
   <member><xref linkend="sql-altertable"></member>
   <member><xref linkend="sql-droptable"></member>
   <member><xref linkend="sql-createtableas"></member>
   <member><xref linkend="sql-createtablespace"></member>
   <member><xref linkend="sql-createtype"></member>
  </simplelist>
 </refsect1>
</refentry>
