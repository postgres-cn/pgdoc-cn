<!--
doc/src/sgml/ref/select.sgml
PostgreSQL documentation
-->

<refentry id="SQL-SELECT">
 <indexterm zone="sql-select">
  <primary>SELECT</primary>
 </indexterm>

 <indexterm zone="sql-select">
  <primary>TABLE command</primary>
 </indexterm>

 <indexterm zone="sql-select">
  <primary>WITH</primary>
  <secondary>in SELECT</secondary>
 </indexterm>

 <refmeta>
  <refentrytitle>SELECT</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>SELECT</refname>
  <refname>TABLE</refname>
  <refname>WITH</refname>
  <refpurpose>从一个表或视图检索行</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
[ WITH [ RECURSIVE ] <replaceable class="parameter">with_query</replaceable> [, ...] ]
SELECT [ ALL | DISTINCT [ ON ( <replaceable class="parameter">expression</replaceable> [, ...] ) ] ]
    [ * | <replaceable class="parameter">expression</replaceable> [ [ AS ] <replaceable class="parameter">output_name</replaceable> ] [, ...] ]
    [ FROM <replaceable class="parameter">from_item</replaceable> [, ...] ]
    [ WHERE <replaceable class="parameter">condition</replaceable> ]
    [ GROUP BY <replaceable class="parameter">expression</replaceable> [, ...] ]
    [ HAVING <replaceable class="parameter">condition</replaceable> [, ...] ]
    [ WINDOW <replaceable class="parameter">window_name</replaceable> AS ( <replaceable class="parameter">window_definition</replaceable> ) [, ...] ]
    [ { UNION | INTERSECT | EXCEPT } [ ALL | DISTINCT ] <replaceable class="parameter">select</replaceable> ]
    [ ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC | USING <replaceable class="parameter">operator</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...] ]
    [ LIMIT { <replaceable class="parameter">count</replaceable> | ALL } ]
    [ OFFSET <replaceable class="parameter">start</replaceable> [ ROW | ROWS ] ]
    [ FETCH { FIRST | NEXT } [ <replaceable class="parameter">count</replaceable> ] { ROW | ROWS } ONLY ]
    [ FOR { UPDATE | NO KEY UPDATE | SHARE | KEY SHARE } [ OF <replaceable class="parameter">table_name</replaceable> [, ...] ] [ NOWAIT ] [...] ]

<phrase>where <replaceable class="parameter">from_item</replaceable> can be one of:</phrase>

    [ ONLY ] <replaceable class="parameter">table_name</replaceable> [ * ] [ [ AS ] <replaceable class="parameter">alias</replaceable> [ ( <replaceable class="parameter">column_alias</replaceable> [, ...] ) ] ]
    [ LATERAL ] ( <replaceable class="parameter">select</replaceable> ) [ AS ] <replaceable class="parameter">alias</replaceable> [ ( <replaceable class="parameter">column_alias</replaceable> [, ...] ) ]
    <replaceable class="parameter">with_query_name</replaceable> [ [ AS ] <replaceable class="parameter">alias</replaceable> [ ( <replaceable class="parameter">column_alias</replaceable> [, ...] ) ] ]
    [ LATERAL ] <replaceable class="parameter">function_name</replaceable> ( [ <replaceable class="parameter">argument</replaceable> [, ...] ] )
                [ WITH ORDINALITY ] [ [ AS ] <replaceable class="parameter">alias</replaceable> [ ( <replaceable class="parameter">column_alias</replaceable> [, ...] ) ] ]
    [ LATERAL ] <replaceable class="parameter">function_name</replaceable> ( [ <replaceable class="parameter">argument</replaceable> [, ...] ] ) [ AS ] <replaceable class="parameter">alias</replaceable> ( <replaceable class="parameter">column_definition</replaceable> [, ...] )
    [ LATERAL ] <replaceable class="parameter">function_name</replaceable> ( [ <replaceable class="parameter">argument</replaceable> [, ...] ] ) AS ( <replaceable class="parameter">column_definition</replaceable> [, ...] )
    [ LATERAL ] ROWS FROM( <replaceable class="parameter">function_name</replaceable> ( [ <replaceable class="parameter">argument</replaceable> [, ...] ] ) [ AS ( <replaceable class="parameter">column_definition</replaceable> [, ...] ) ] [, ...] )
                [ WITH ORDINALITY ] [ [ AS ] <replaceable class="parameter">alias</replaceable> [ ( <replaceable class="parameter">column_alias</replaceable> [, ...] ) ] ]
    <replaceable class="parameter">from_item</replaceable> [ NATURAL ] <replaceable class="parameter">join_type</replaceable> <replaceable class="parameter">from_item</replaceable> [ ON <replaceable class="parameter">join_condition</replaceable> | USING ( <replaceable class="parameter">join_column</replaceable> [, ...] ) ]

<phrase>and <replaceable class="parameter">with_query</replaceable> is:</phrase>

    <replaceable class="parameter">with_query_name</replaceable> [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ] AS ( <replaceable class="parameter">select</replaceable> | <replaceable class="parameter">values</replaceable> | <replaceable class="parameter">insert</replaceable> | <replaceable class="parameter">update</replaceable> | <replaceable class="parameter">delete</replaceable> )

TABLE [ ONLY ] <replaceable class="parameter">table_name</replaceable> [ * ]
</synopsis>

 </refsynopsisdiv>

 <refsect1>
  <title>描述</title>

  <para>
   <command>SELECT</command>从零或更多表中检索行。
   <command>SELECT</command>的通常处理如下：

   <orderedlist>
    <listitem>
     <para>
      <literal>WITH</literal>列表中的所有查询都会被计算。这些查询实际
      充当了在<literal>FROM</literal>列表中可以引用的临时表。在
      <literal>FROM</literal>中被引用多次的<literal>WITH</literal>查
      询只会被计算一次（见下文的
      <xref linkend="sql-with" endterm="sql-with-title">）。
     </para>
    </listitem>

    <listitem>
     <para>
      <literal>FROM</literal>列表中的所有元素都会被计算（
      <literal>FROM</literal>中的每一个元素都是一个真实表或者虚拟表）。
      如果在<literal>FROM</literal>列表中指定了多于一个元素，它们会被
      交叉连接在一起（见下文的
      <xref linkend="sql-from" endterm="sql-from-title">）。
     </para>
    </listitem>

    <listitem>
     <para>
      如果指定了<literal>WHERE</literal>子句，所有不满足该条件的行都会
      被从输出中消除（见下文的<xref linkend="sql-where"
      endterm="sql-where-title">）。
     </para>
    </listitem>

    <listitem>
     <para>
      如果指定了<literal>GROUP BY</literal>子句或者如果有聚集函数，输出
      会被组合成由在一个或者多个值上匹配的行构成的分组，并且在其上计算聚
      集函数的结果。如果出现了<literal>HAVING</literal>子句，它会消除不
      满足给定条件的分组（见下文的
      <xref linkend="sql-groupby" endterm="sql-groupby-title">以及
      <xref linkend="sql-having" endterm="sql-having-title">）。
     </para>
    </listitem>

    <listitem>
     <para>
      对于每一个被选中的行或者行组，会使用<command>SELECT</command>
      输出表达式计算实际的输出行（见下文的
      <xref linkend="sql-select-list" endterm="sql-select-list-title">）。
     </para>
    </listitem>

    <listitem>
     <para><literal>SELECT DISTINCT</literal>从结果中消除重复的行。
      <literal>SELECT DISTINCT ON</literal>消除在所有指定表达式上匹
      配的行。<literal>SELECT ALL</literal>（默认）将返回所有候选行，
      包括重复的行（见下文的<xref linkend="sql-distinct"
      endterm="sql-distinct-title">）。
     </para>
    </listitem>

    <listitem>
     <para>
      通过使用操作符<literal>UNION</literal>、
      <literal>INTERSECT</literal>和<literal>EXCEPT</literal>，多于
      一个<command>SELECT</command>语句的输出可以被整合形成
      一个结果集。<literal>UNION</literal>操作符返回位于一个或者两
      个结果集中的全部行。<literal>INTERSECT</literal>操作符返回同时
      位于两个结果集中的所有行。<literal>EXCEPT</literal>操作符返回
      位于第一个结果集但不在第二个结果集中的行。在所有三种情况下，
      重复行都会被消除（除非指定<literal>ALL</literal>）。可以增加噪
      声词<literal>DISTINCT</>来显式地消除重复行。注意虽然
      <literal>ALL</literal>是<command>SELECT</>自身的默认行为，
      但这里<literal>DISTINCT</>是默认行为（见下文的
      <xref linkend="sql-union" endterm="sql-union-title">、<xref
      linkend="sql-intersect" endterm="sql-intersect-title">以及
      <xref linkend="sql-except" endterm="sql-except-title">）。
     </para>
    </listitem>

    <listitem>
     <para>
      如果指定了<literal>ORDER BY</literal>子句，被返回的行会以指定的
      顺序排序。如果没有给定<literal>ORDER BY</literal>，系统会以能最
      快产生行的顺序返回它们（见下文的
      <xref linkend="sql-orderby" endterm="sql-orderby-title">）。
     </para>
    </listitem>

    <listitem>
     <para>
      如果指定了<literal>LIMIT</literal>（或<literal>FETCH FIRST</literal>）
      或者<literal>OFFSET</literal>子句，<command>SELECT</command>
      语句只返回结果行的一个子集（见下文的<xref
      linkend="sql-limit" endterm="sql-limit-title">）。
     </para>
    </listitem>

    <listitem>
     <para>
      如果指定了<literal>FOR UPDATE</>、
      <literal>FOR NO KEY UPDATE</literal>、
      <literal>FOR SHARE</literal>
      或者<literal>FOR KEY SHARE</literal>，
      <command>SELECT</command>语句会把被选中的行锁定而不让并发
      更新访问它们（见下文的<xref linkend="sql-for-update-share"
      endterm="sql-for-update-share-title">）。
     </para>
    </listitem>
   </orderedlist>
  </para>

  <para>
   你必须拥有在一个<command>SELECT</>命令中使用的每一列上的
   <literal>SELECT</literal>特权。<literal>FOR NO KEY UPDATE</>、
   <literal>FOR UPDATE</literal>、
   <literal>FOR SHARE</literal>或者<literal>FOR KEY SHARE</literal>
   还要求（对这样选中的每一个表至少一列的）<literal>UPDATE</literal>
   特权。
  </para>
 </refsect1>

 <refsect1>
  <title>参数</title>

  <refsect2 id="SQL-WITH">
   <title id="sql-with-title"><literal>WITH</literal> 子句</title>

   <para>
    <literal>WITH</literal>子句允许你指定一个或者多个在主查询中可以
    其名称引用的子查询。在主查询期间子查询实际扮演了临时表或者视图
    的角色。每一个子查询都可以是一个<command>SELECT</command>、
    <command>TABLE</>、<command>VALUES</command>、
    <command>INSERT</command>、
    <command>UPDATE</command>或者
    <command>DELETE</command>语句。在<literal>WITH</>中书写
    一个数据修改语句（<command>INSERT</command>、
    <command>UPDATE</command>或者
    <command>DELETE</command>）时，通常要包括一个
    <literal>RETURNING</>子句。构成被主查询读取的临时表的是
    <literal>RETURNING</>的输出，而<emphasis>不是</>该语句修改的
    底层表。如果省略<literal>RETURNING</>，该语句仍会被执行，但是它
    不会产生输出，因此它不能作为一个表从主查询引用。
   </para>

   <para>
    对于每一个<literal>WITH</literal>查询，都必须指定一个名称（无需模
    式限定）。可选地，可以指定一个列名列表。如果省略该列表，会从该子查
    询中推导列名。
   </para>

   <para>
    如果指定了<literal>RECURSIVE</literal>，则允许一个
    <command>SELECT</command>子查询使用名称引用自身。
    这样一个子查询的形式必须是
<synopsis>
<replaceable class="parameter">non_recursive_term</replaceable> UNION [ ALL | DISTINCT ] <replaceable class="parameter">recursive_term</replaceable>
</synopsis>
    其中递归自引用必须出现在<literal>UNION</>的右手边。每个
    查询中只允许一个递归自引用。不支持递归数据修改语句，但是
    可以在一个数据查询语句中使用一个递归
    <command>SELECT</command>查询的结果。例子可见
    <xref linkend="queries-with">。
   </para>

   <para>
    <literal>RECURSIVE</literal>的另一个效果是
    <literal>WITH</literal>查询不需要被排序：一个查询可以引用另一个
    在列表中比它靠后的查询（不过，循环引用或者互递归没有实现）。
    如果没有<literal>RECURSIVE</literal>，<literal>WITH</literal>
    查询只能引用在<literal>WITH</literal>列表中位置更前面的兄弟
    <literal>WITH</literal>查询。
   </para>

   <para>
    <literal>WITH</literal>查询的一个关键特性是，对主查询的每次
    查询它们都只计算一次，即使该主查询引用它们多次也是如此。特别
    是，不管主查询读取数据修改语句的多少输出，数据修改语句都被保
    证仅执行一次。
   </para>

   <para>
    主查询以及<literal>WITH</literal>查询全部（理论上）在同一时间
    被执行。这意味着从该查询的任何部分都无法看到
    <literal>WITH</literal>中的一个数据修改语句的效果，不过可以读
    取其<literal>RETURNING</>输出。如果两个这样的数据修改语句
    尝试修改相同的行，结果将无法确定。
   </para>

   <para>
    更多信息请见<xref linkend="queries-with">。
   </para>
  </refsect2>

  <refsect2 id="SQL-FROM">
   <title id="sql-from-title"><literal>FROM</literal> 子句</title>

   <para>
    <literal>FROM</literal>子句为<command>SELECT</command>
    指定一个或者更多源表。如果指定了多个源表，结果将是所有源表的
    笛卡尔积（交叉连接）。但是通常会增加限定条件（通过
    <literal>WHERE</>）来把返回的行限制为该笛卡尔积的一个小子集。
   </para>

   <para>
    <literal>FROM</literal>子句可以包含下列元素：

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">table_name</replaceable></term>
      <listitem>
       <para>
        一个现有表或视图的名称（可以是模式限定的）。如果在表名前指定了
        <literal>ONLY</>，则只会扫描该表。如果没有指定
        <literal>ONLY</>，该表及其所有后代表（如果有）都会被扫描。可
        选地，可以在表名后指定<literal>*</>来显式地指示包括后代表。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">alias</replaceable></term>
      <listitem>
       <para>
        一个包含别名的<literal>FROM</>项的替代名称。别名被用于
        让书写简洁或者消除自连接中的混淆（其中同一个表会被扫描多
        次）。当提供一个别名时，表或者函数的实际名称会被隐藏。例
        如，给定<literal>FROM foo AS f</>，
        <command>SELECT</command>的剩余部分就必须以
        <literal>f</>而不是<literal>foo</>来引用这个
        <literal>FROM</>项。如果写了一个别名，还可以写一个列别
        名列表来为该表的一个或者多个列提供替代名称。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">select</replaceable></term>
      <listitem>
       <para>
        一个子-<command>SELECT</command>可以出现在
        <literal>FROM</literal>子句中。这就好像把它的输出创建为一个
        存在于该<command>SELECT</command>命令期间的临时表。注意
        子-<command>SELECT</command>必须用圆括号包围，并且
        <emphasis>必须</emphasis>为它提供一个别名。也可以在这里
        使用一个<xref linkend="sql-values">命令。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">with_query_name</replaceable></term>
      <listitem>
       <para>
        可以通过写一个<literal>WITH</>查询的名称来引用它，就好像
        该查询的名称是一个表名（实际上，该<literal>WITH</>查询会
        为主查询隐藏任何具有相同名称的真实表。如果必要，你可以使用
        带模式限定的方式以相同的名称来引用真实表）。可以像表一样，
        以同样的方式提供一个别名。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">function_name</replaceable></term>
      <listitem>
       <para>
        函数调用可以出现在<literal>FROM</literal>子句中（对于返回结果
        集合的函数特别有用，但是可以使用任何函数）。这就好像把该函数的
        输出创建为一个存在于该<command>SELECT</command>命令期
        间的临时表。当为该函数调用增加可选的
        <command>WITH ORDINALITY</command>子句时，会在该函数
        的输出列之后追加一个新的列来为每一行编号。
       </para>

       <para>
        可以用和表一样的方式提供一个别名。如果写了一个别名，还可以写一个
        列别名列表来为该函数的组合返回类型的一个或者多个属性提供替代名称，
        包括由<literal>ORDINALITY</literal>（如果有）增加的新列。
       </para>

       <para>
        通过把多个函数调用包围在<literal>ROWS FROM( ... )</>中可以把它们
        整合在单个<literal>FROM</>-子句项中。这样一个项的输出是把每一个
        函数的第一行串接起来，然后是每个函数的第二行，以此类推。如果有些
        函数产生的行比其他函数少，则在缺失数据的地方放上 NULL，这样被返回
        的总行数总是和产生最多行的函数一样。
       </para>

      <para>
        如果函数被定义为返回<type>record</>数据类型，那么必须出现一个
        别名或者关键词<literal>AS</>，后面跟上形为
        <literal>( <replaceable
        class="parameter">column_name</replaceable> <replaceable
        class="parameter">data_type</replaceable> <optional>, ...
        </>)</literal>的列定义列表。列定义列表必须匹配该函数返回的列的实际
        数量和类型。
       </para>

       <para>
        在使用<literal>ROWS FROM( ... )</>语法时，如果函数之一要求一个列
        定义列表，最好把该列定义列表放在<literal>ROWS FROM( ... )</>中该
        函数的调用之后。当且仅当正好只有一个函数并且没有
        <literal>WITH ORDINALITY</>子句时，才能把列定义列表放在
        <literal>ROWS FROM( ... )</>结构后面。
       </para>

       <para>
        要把<literal>ORDINALITY</literal>和列定义列表一起使用，你必须使用
        <literal>ROWS FROM( ... )</>语法，并且把列定义列表放在
        <literal>ROWS FROM( ... )</>里面。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">join_type</replaceable></term>
      <listitem>
       <para>
        <itemizedlist>
         <listitem>
          <para><literal>[ INNER ] JOIN</literal></para>
         </listitem>
         <listitem>
          <para><literal>LEFT [ OUTER ] JOIN</literal></para>
         </listitem>
         <listitem>
          <para><literal>RIGHT [ OUTER ] JOIN</literal></para>
         </listitem>
         <listitem>
          <para><literal>FULL [ OUTER ] JOIN</literal></para>
         </listitem>
         <listitem>
          <para><literal>CROSS JOIN</literal></para>
         </listitem>
        </itemizedlist>
        之一。

        对于<literal>INNER</>和<literal>OUTER</>连接类型，必须指定
        一个连接条件，即
        <literal>NATURAL</>、<literal>ON <replaceable
        class="parameter">join_condition</replaceable></literal>或者
        <literal>USING (<replaceable
        class="parameter">join_column</replaceable> [, ...])</literal>
        之一（只能有一种）。其含义见下文。对于
        <literal>CROSS JOIN</literal>，上述子句不能出现。
       </para>

       <para>
        一个<literal>JOIN</literal>子句联合两个<literal>FROM</>项（
        为了方便我们称之为<quote>表</>，尽管实际上它们可以是任何类型
        的<literal>FROM</>项）。如有必要可以使用圆括号确定嵌套的顺序。
        在没有圆括号时，<literal>JOIN</literal>会从左至右嵌套。在任何情
        况下，<literal>JOIN</literal>的联合比分隔<literal>FROM</>-列表
        项的逗号更强。
       </para>

       <para><literal>CROSS JOIN</>和<literal>INNER JOIN</literal>
       会产生简单的笛卡尔积，也就是与在<literal>FROM</>的顶层列出两个
       表得到的结果相同，但是要用连接条件（如果有）约束该结果。
        <literal>CROSS JOIN</>与<literal>INNER JOIN ON
        (TRUE)</>等效，也就是说条件不会移除任何行。这些连接类型只是一种
        记号上的方便，因为没有什么是你用纯粹的<literal>FROM</>和
        <literal>WHERE</>能做而它们不能做的。
       </para>

       <para><literal>LEFT OUTER JOIN</>返回被限制过的笛卡尔积
       中的所有行（即所有通过了其连接条件的组合行），外加左手表中
       没有相应的通过了连接条件的右手行的每一行的拷贝。通过在右手
       列中插入空值，这种左手行会被扩展为连接表的完整行。注意在决
       定哪些行匹配时，只考虑<literal>JOIN</>子句自身的条件。之后
       才应用外条件。
       </para>

       <para>
        相反，<literal>RIGHT OUTER JOIN</>返回所有连接行，外加每
        一个没有匹配上的右手行（在左端用空值扩展）。这只是为了记号
        上的方便，因为你可以通过交换左右表把它转换成一个<literal>LEFT
        OUTER JOIN</>。
       </para>

       <para><literal>FULL OUTER JOIN</>返回所有连接行，外加每
       一个没有匹配上的左手行（在右端用空值扩展），再外加每一个没有
       匹配上的右手行（在左端用空值扩展）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ON <replaceable class="parameter">join_condition</replaceable></literal></term>
      <listitem>
       <para><replaceable class="parameter">join_condition</replaceable>
       是一个会得到<type>boolean</type>类型值的表达式（类似于一个
       <literal>WHERE</literal>子句），它说明一次连接中哪些行被认为
       相匹配。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>USING ( <replaceable class="parameter">join_column</replaceable> [, ...] )</literal></term>
      <listitem>
       <para>
        形式<literal>USING ( a, b, ... )</literal>的子句是
        <literal>ON left_table.a = right_table.a AND
        left_table.b = right_table.b ...</literal>的简写。还有，
        <literal>USING</>表示每一对相等列中只有一个会被
        包括在连接输出中。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NATURAL</literal></term>
      <listitem>
       <para><literal>NATURAL</literal>是列出在两个表中所有具有
       相同名称的列的<literal>USING</>的简写。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>LATERAL</literal></term>
      <listitem>
       <para>
        <literal>LATERAL</literal>关键词可以放在一个
        子-<command>SELECT</command> <literal>FROM</>项前面。这允许该
        子-<command>SELECT</command>引用<literal>FROM</>列表中在它之
        前的<literal>FROM</>项的列（如果没有<literal>LATERAL</literal>，每一
        个子-<command>SELECT</command>会被独立计算并且因此不能交叉引用
        任何其他的<literal>FROM</>项）。
       </para>

       <para><literal>LATERAL</literal>也可以放在一个函数调用
        <literal>FROM</>项前面，但是在这种情况下它只是一个噪声
        词，因为在任何情况下函数表达式都可以引用在它之前的
        <literal>FROM</>项。
       </para>

       <para>
        <literal>LATERAL</literal>项可以出现在<literal>FROM</>列表
        顶层，或者一个<literal>JOIN</>中。在后一种情况中，它也可以引
        用其作为右手端的<literal>JOIN</>左手端上的任何项。
       </para>

       <para>
        当一个<literal>FROM</>项包含<literal>LATERAL</literal>交叉引用
        时，计算会如此进行：对提供被交叉引用列的<literal>FROM</>项的每
        一行或者提供那些列的多个<literal>FROM</>项的每一个行集，使用该
        行或者行集的那些列值计算<literal>LATERAL</literal>项。结果行会与
        计算得到它们的行进行通常的连接。对来自哪些列的源表的每一行或者行
        集都会重复这样的步骤。
       </para>

       <para>
        列的源表必须以<literal>INNER</>或者<literal>LEFT</>的方式连接到
        <literal>LATERAL</literal>项，否则就没有用于为
        <literal>LATERAL</literal>项计算每一个行集的良定行集。尽管
        <literal><replaceable>X</> RIGHT JOIN
        LATERAL <replaceable>Y</></literal>这样的结构在语法上是合法的，
        但实际上不允许用于在<replaceable>Y</>中引用
        <replaceable>X</>。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </refsect2>

  <refsect2 id="SQL-WHERE">
   <title id="sql-where-title"><literal>WHERE</literal> 子句</title>

   <para>
    可选的<literal>WHERE</literal>子句的形式
<synopsis>
WHERE <replaceable class="parameter">condition</replaceable>
</synopsis>
    其中<replaceable class="parameter">condition</replaceable>
    是任一计算得到<type>布尔</type>类型结果的表达式。任何不满足
    这个条件的行都会从输出中被消除。如果用一行的实际值替换其中的
    变量引用后，该表达式返回真，则该行符合条件。
   </para>
  </refsect2>

  <refsect2 id="SQL-GROUPBY">
   <title id="sql-groupby-title"><literal>GROUP BY</literal> 子句</title>

   <para>
    可选的<literal>GROUP BY</literal>子句的形式
<synopsis>
GROUP BY <replaceable class="parameter">expression</replaceable> [, ...]
</synopsis>
   </para>

   <para>
    <literal>GROUP BY</literal>将会把所有被选择的行中共享相同分组表达式
    值的那些行压缩成一个行。<replaceable
    class="parameter">expression</replaceable>可以是输入列名、输出列
    （<command>SELECT</command>列表项）的名称或序号或者由输入列
    值构成的任意表达式。在出现歧义时，<literal>GROUP BY</literal>名称
    将被解释为输入列名而不是输出列名。
   </para>

   <para>
    聚集函数（如果使用）会在组成每一个分组的所有行上进行计算，从而为每
    一个分组产生一个单独的值（如果有聚集函数但是没有
    <literal>GROUP BY</literal>子句，则查询会被当成是由所有选中行构成
    的一个单一分组）。传递给每一个聚集函数的行集合可以通过在聚集函数调
    用附加一个<literal>FILTER</literal>子句来进一步过滤，详见
    <xref linkend="syntax-aggregates">。当存在一个
    <literal>FILTER</literal>子句时，只有那些匹配它的行才会被包括在该聚
    集函数的输入中。
   </para>

   <para>
    当存在<literal>GROUP BY</literal>子句或者任何聚集函数时，
    <command>SELECT</command>列表表达式不能引用非分组列（除非它
    出现在聚集函数中或者它函数依赖于分组列），因为这样做会导致返回
    非分组列的值时会有多种可能的值。如果分组列是包含非分组列的表的主键（
    或者主键的子集），则存在函数依赖。
   </para>

   <para>
    记住所有的聚集函数都是在<literal>HAVING</>子句或者
    <literal>SELECT</>列表中的任何<quote>标量</>表达式之前被计算。
    这意味着一个<literal>CASE</>表达式不能被用来跳过一个聚集表达式的
    计算，见<xref linkend="syntax-express-eval">。
   </para>

   <para>
    当前，<literal>FOR NO KEY UPDATE</>、<literal>FOR UPDATE</>、
    <literal>FOR SHARE</>和<literal>FOR KEY SHARE</>不能和
    <literal>GROUP BY</literal>一起指定。
   </para>
  </refsect2>

  <refsect2 id="SQL-HAVING">
   <title id="sql-having-title"><literal>HAVING</literal> 子句</title>

   <para>
    可选的<literal>HAVING</literal>子句的形式
<synopsis>
HAVING <replaceable class="parameter">condition</replaceable>
</synopsis>
    其中<replaceable class="parameter">condition</replaceable>与
    <literal>WHERE</literal>子句中指定的条件相同。
   </para>

   <para>
    <literal>HAVING</literal>消除不满足该条件的分组行。
    <literal>HAVING</literal>与<literal>WHERE</literal>不同：
    <literal>WHERE</literal>会在应用<literal>GROUP
    BY</literal>之前过滤个体行，而<literal>HAVING</literal>过滤由
    <literal>GROUP BY</literal>创建的分组行。
    <replaceable class="parameter">condition</replaceable>中引用
    的每一个列必须无歧义地引用一个分组列（除非该引用出现在一个聚集
    函数中或者该非分组列函数依赖于分组列。
   </para>

   <para>
    即使没有<literal>GROUP BY</>子句，<literal>HAVING</literal>
    的存在也会把一个查询转变成一个分组查询。这和查询中包含聚集函数但没有
    <literal>GROUP BY</>子句时的情况相同。所有被选择的行都被认为是一个
    单一分组，并且<command>SELECT</command>列表和
    <literal>HAVING</literal>子句只能引用聚集函数中的表列。如果该
    <literal>HAVING</literal>条件为真，这样一个查询将会发出一个单一行；
    否则不返回行。
   </para>

   <para>
    当前，<literal>FOR NO KEY UPDATE</>、<literal>FOR UPDATE</>、
    <literal>FOR SHARE</>和<literal>FOR KEY SHARE</>不能与
    <literal>HAVING</literal>一起指定。
   </para>
  </refsect2>

  <refsect2 id="SQL-WINDOW">
   <title id="sql-window-title"><literal>WINDOW</literal> 子句</title>

   <para>
    可选的<literal>WINDOW</literal>子句的形式
<synopsis>
WINDOW <replaceable class="parameter">window_name</replaceable> AS ( <replaceable class="parameter">window_definition</replaceable> ) [, ...]
</synopsis>
    其中<replaceable class="parameter">window_name</replaceable>
    是一个可以从<literal>OVER</>子句或者后续窗口定义中引用的名称。
    <replaceable class="parameter">window_definition</replaceable>是
<synopsis>
[ <replaceable class="parameter">existing_window_name</replaceable> ]
[ PARTITION BY <replaceable class="parameter">expression</replaceable> [, ...] ]
[ ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC | USING <replaceable class="parameter">operator</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...] ]
[ <replaceable class="parameter">frame_clause</replaceable> ]
</synopsis>
   </para>

   <para>
    如果指定了一个<replaceable class="parameter">existing_window_name</replaceable>，
    它必须引用<literal>WINDOW</>列表中一个更早出现的项。新窗口将从
    该项中复制它的划分子句以及排序子句（如果有）。在这种情况下，新窗口
    不能指定它自己的<literal>PARTITION BY</>子句，并且它只能在被复制
    窗口没有<literal>ORDER BY</>的情况下指定该子句。新窗口总是使用它
    自己的帧子句，被复制的窗口不必指定一个帧子句。
   </para>

   <para>
    The elements of the <literal>PARTITION BY</>列表元素的解释以
    <xref linkend="sql-groupby" endterm="sql-groupby-title">元素的方式
    进行，不过它们总是简单表达式并且绝不能是输出列的名称或编号。另一个区
    别是这些表达式可以包含聚集函数调用，而这在常规<literal>GROUP BY</>
    子句中是不被允许的。它们被允许的原因是窗口是出现在分组和聚集之后的。
   </para>

   <para>
    类似地，<literal>ORDER BY</>列表元素的解释也以
    <xref linkend="sql-orderby" endterm="sql-orderby-title">元素的方式进行，
    不过该表达式总是被当做简单表达式并且绝不会是输出列的名称或编号。
   </para>

   <para>
    可选的<replaceable class="parameter">frame_clause</>为依赖帧的窗口函数
    定义<firstterm>窗口帧</>（并非所有窗口函数都依赖于帧）。窗口帧是查询中
    每一样（称为<firstterm>当前行</>）的相关行的集合。 
    <replaceable class="parameter">frame_clause</>可以是

<synopsis>
{ RANGE | ROWS } <replaceable>frame_start</>
{ RANGE | ROWS } BETWEEN <replaceable>frame_start</> AND <replaceable>frame_end</>
</synopsis>

    之一，其中<replaceable>frame_start</>和<replaceable>frame_end</>可以是

<synopsis>
UNBOUNDED PRECEDING
<replaceable>value</replaceable> PRECEDING
CURRENT ROW
<replaceable>value</replaceable> FOLLOWING
UNBOUNDED FOLLOWING
</synopsis>

    之一。如果省略<replaceable>frame_end</>，它会被默认为<literal>CURRENT
    ROW</>。限制是：
    <replaceable>frame_start</>不能是<literal>UNBOUNDED FOLLOWING</>，
    <replaceable>frame_end</>不能是<literal>UNBOUNDED PRECEDING</>，
    并且<replaceable>frame_end</>的选择在上面的列表中不能早于
    <replaceable>frame_start</>的选择 &mdash; 例如
    <literal>RANGE BETWEEN CURRENT ROW AND <replaceable>value</>
    PRECEDING</literal>是不被允许的。
   </para>

   <para>
    默认的帧选项是<literal>RANGE UNBOUNDED PRECEDING</>，它和
    <literal>RANGE BETWEEN UNBOUNDED PRECEDING AND
    CURRENT ROW</>相同。它把帧设置为从分区开始直到当前行的最后一个同级行（被
    <literal>ORDER BY</>认为等价于当前行的行或者在没有
    <literal>ORDER BY</>时的所有行）的所有行。通常，
    <literal>UNBOUNDED PRECEDING</>表示从分区第一行开始的帧，类似地
    <literal>UNBOUNDED FOLLOWING</>表示以分区最后一行结束的帧（不考虑
    <literal>RANGE</>或<literal>ROWS</>模式）。在<literal>ROWS</>模式中，
     <literal>CURRENT ROW</>表示以当前行开始或者结束的帧。而在
    <literal>RANGE</>模式中它表示当前行在<literal>ORDER BY</>排序中的第一个
    或者最后一个同级行开始或者结束的帧。
    <replaceable>value</> <literal>PRECEDING</>和
    <replaceable>value</> <literal>FOLLOWING</>情况当前只在
    <literal>ROWS</>模式中被允许。它们表示当前行之前或者之后相隔那么多行的
    那一行会开始或者结束帧。<replaceable>value</replaceable>必须是一个不包含
    任何变量、聚集函数或者窗口函数的整数表达式。该值不能是空值或者负值，但是可
    以是零，为零时将会选择当前行本身。
   </para>

   <para>
    注意如果<literal>ORDER BY</>排序没有把行唯一地排序，<literal>ROWS</>
    选项可能产生无法预测的结果。<literal>RANGE</>选项被设计来确保在
    <literal>ORDER BY</>排序中同级的行被同样对待，所有同级行将会在同一个帧内。
   </para>

   <para>
    <literal>WINDOW</literal>子句的目的是指定出现在查询的
    <xref linkend="sql-select-list" endterm="sql-select-list-title">或
    <xref linkend="sql-orderby" endterm="sql-orderby-title">中的
    <firstterm>窗口函数</>的行为。这些函数可以在它们的
    <literal>OVER</>子句中用名称引用<literal>WINDOW</literal>
    子句项。不过，<literal>WINDOW</literal>子句项不是必须被引用。
    如果在查询中没有用到它，它会被简单地忽略。可以使用根本没有任何
    <literal>WINDOW</literal>子句的窗口函数，因为窗口函数调用可
    以直接在其<literal>OVER</>子句中指定它的窗口定义。不过，当多
    个窗口函数都需要相同的窗口定义时，
    <literal>WINDOW</literal>子句能够减少输入。
   </para>

   <para>
    当前，<literal>FOR NO KEY UPDATE</>、<literal>FOR UPDATE</>、
    <literal>FOR SHARE</>和<literal>FOR KEY SHARE</>不能和
    <literal>WINDOW</literal>一起被指定。
   </para>

   <para>
    窗口函数的详细描述在
    <xref linkend="tutorial-window">、
    <xref linkend="syntax-window-functions">以及
    <xref linkend="queries-window">中。
   </para>
  </refsect2>

  <refsect2 id="sql-select-list">
   <title id="sql-select-list-title"><command>SELECT</command> 列表</title>

   <para>
    <command>SELECT</command>列表（位于关键词
    <literal>SELECT</>和<literal>FROM</>之间）指定构成
    <command>SELECT</command>语句输出行的表达式。这些表达式
    可以（并且通常确实会）引用<literal>FROM</>子句中计算得到的列。
   </para>

   <para>
    正如在表中一样，<command>SELECT</command>的每一个输出列都有一个名称。
    在一个简单的<command>SELECT</command>中，这个名称只是被用来标记要显
    示的列，但是当<command>SELECT</>是一个大型查询的一个子查询时，大型查询
    会把该名称看做子查询产生的虚表的列名。要指定用于输出列的名称，在该列的表达式
    后面写上
    <literal>AS</> <replaceable class="parameter">output_name</replaceable>（
    你可以省略<literal>AS</literal>，但只能在期望的输出名称不匹配任何
    <productname>PostgreSQL</productname>关键词（见<xref
    linkend="sql-keywords-appendix">）时省略。为了避免和未来增加的关键词冲突，
    推荐总是写上<literal>AS</literal>或者用双引号引用输出名称）。如果你不指定列名，
    <productname>PostgreSQL</productname>会自动选择一个名称。如果列的表达式
    是一个简单的列引用，那么被选择的名称就和该列的名称相同。在使用函数或者类型名称
    的更复杂的情况中，系统可能会生成诸如
    <literal>?column?</literal>之类的名称。
   </para>

   <para>
    一个输出列的名称可以被用来在<literal>ORDER BY</>以及
    <literal>GROUP BY</>子句中引用该列的值，但是不能用于
    <literal>WHERE</>和<literal>HAVING</>子句（在其中
    必须写出表达式）。
   </para>

   <para>
    可以在输出列表中写<literal>*</literal>来取代表达式，它是被选中
    行的所有列的一种简写方式。还可以写
    <literal><replaceable
    class="parameter">table_name</replaceable>.*</literal>，它
    是只来自那个表的所有列的简写形式。在这些情况中无法用
    <literal>AS</>指定新的名称，输出行的名称将和表列的名称相同。
   </para>
  </refsect2>

  <refsect2 id="sql-distinct">
   <title id="sql-distinct-title"><literal>DISTINCT</literal> 子句</title>

   <para>
    如果指定了<literal>SELECT DISTINCT</>，所有重复的行会被从结果
    集中移除（为每一组重复的行保留一行）。<literal>SELECT ALL</>则
    指定相反的行为：所有行都会被保留，这也是默认情况。
   </para>

   <para>
    <literal>SELECT DISTINCT ON ( <replaceable
    class="parameter">expression</replaceable> [, ...] )</literal>
    只保留在给定表达式上计算相等的行集合中的第一行。
    <literal>DISTINCT ON</literal>表达式使用和
    <literal>ORDER BY</>相同的规则（见上文）解释。注意，除非用
    <literal>ORDER BY</>来确保所期望的行出现在第一位，每一个集
    合的<quote>第一行</quote>是不可预测的。例如：
<programlisting>
SELECT DISTINCT ON (location) location, time, report
    FROM weather_reports
    ORDER BY location, time DESC;
</programlisting>
    为每个地点检索最近的天气报告。但是如果我们不使用
    <literal>ORDER BY</>来强制对每个地点的时间值进行降序排序，
    我们为每个地点得到的报告的时间可能是无法预测的。
   </para>

   <para>
    <literal>DISTINCT ON</>表达式必须匹配最左边的
    <literal>ORDER BY</>表达式。<literal>ORDER BY</>子句通常
    将包含额外的表达式，这些额外的表达式用于决定在每一个
    <literal>DISTINCT ON</>分组内行的优先级。
   </para>

   <para>
    当前，<literal>FOR NO KEY UPDATE</>、<literal>FOR UPDATE</>、
    <literal>FOR SHARE</>和<literal>FOR KEY SHARE</>不能和
    <literal>DISTINCT</literal>一起使用。
   </para>
  </refsect2>

  <refsect2 id="SQL-UNION">
   <title id="sql-union-title"><literal>UNION</literal> 子句</title>

   <para>
    <literal>UNION</literal>子句具有下面的形式：
<synopsis>
<replaceable class="parameter">select_statement</replaceable> UNION [ ALL | DISTINCT ] <replaceable class="parameter">select_statement</replaceable>
</synopsis><replaceable class="parameter">select_statement</replaceable>
    是任何没有<literal>ORDER BY</>、<literal>LIMIT</>、
    <literal>FOR NO KEY UPDATE</>、<literal>FOR UPDATE</literal>、
    <literal>FOR SHARE</literal>和<literal>FOR KEY SHARE</literal>子句的
    <command>SELECT</command>语句（如果子表达式被包围在圆括号内，
    <literal>ORDER BY</>和<literal>LIMIT</>可以被附着到其上。如果没有
    圆括号，这些子句将被应用到<literal>UNION</literal>的结果而不是右手边
    的表达式上）。
   </para>

   <para>
    <literal>UNION</literal>操作符计算所涉及的
    <command>SELECT</command>语句所返回的行的并集。如果一行
    至少出现在两个结果集中的一个内，它就会在并集中。作为
    <literal>UNION</literal>两个操作数的
    <command>SELECT</command>语句必须产生相同数量的列并且
    对应位置上的列必须具有兼容的数据类型。
   </para>

   <para>
    <literal>UNION</>的结果不会包含重复行，除非指定了
    <literal>ALL</>选项。<literal>ALL</>会阻止消除重复（因此，
    <literal>UNION ALL</>通常显著地快于<literal>UNION</>，
    尽量使用<literal>ALL</>）。可以写<literal>DISTINCT</>来
    显式地指定消除重复行的行为。
   </para>

   <para>
    除非用圆括号指定计算顺序，
    同一个<command>SELECT</command>语句中的多个
    <literal>UNION</>操作符会从左至右计算。
   </para>

   <para>
    当前，<literal>FOR NO KEY UPDATE</>、<literal>FOR UPDATE</>、
    <literal>FOR SHARE</>和
    <literal>FOR KEY SHARE</>不能用于<literal>UNION</>结果或者
    <literal>UNION</>的任何输入。
   </para>
  </refsect2>

  <refsect2 id="SQL-INTERSECT">
   <title id="sql-intersect-title"><literal>INTERSECT</literal> 子句</title>

   <para>
    <literal>INTERSECT</literal>子句具有下面的形式：
<synopsis>
<replaceable class="parameter">select_statement</replaceable> INTERSECT [ ALL | DISTINCT ] <replaceable class="parameter">select_statement</replaceable>
</synopsis><replaceable class="parameter">select_statement</replaceable>
    是任何没有<literal>ORDER
    BY</>, <literal>LIMIT</>、<literal>FOR NO KEY UPDATE</>、<literal>FOR UPDATE</literal>、
    <literal>FOR SHARE</literal>以及<literal>FOR KEY SHARE</>子句的
    <command>SELECT</command>语句。
   </para>

   <para>
    <literal>INTERSECT</literal>操作符计算所涉及的
    <command>SELECT</command>语句返回的行的交集。如果
    一行同时出现在两个结果集中，它就在交集中。
   </para>

   <para>
    <literal>INTERSECT</>的结果不会包含重复行，除非指定了
    <literal>ALL</>选项。如果有<literal>ALL</>，一个在左表中有
    <replaceable>m</>次重复并且在右表中有<replaceable>n</>
    次重复的行将会在结果中出现
    min(<replaceable>m</>,<replaceable>n</>) 次。
    <literal>DISTINCT</>可以写<literal>DISTINCT</>来
    显式地指定消除重复行的行为。
   </para>

   <para>
    除非用圆括号指定计算顺序，
    同一个<command>SELECT</command>语句中的多个
    <literal>INTERSECT</>操作符会从左至右计算。
    <literal>INTERSECT</literal>的优先级比
    <literal>UNION</literal>更高。也就是说，
    <literal>A UNION B INTERSECT
    C</literal>将被读成<literal>A UNION (B INTERSECT
    C)</literal>。
   </para>

   <para>
    当前，<literal>FOR NO KEY UPDATE</>、<literal>FOR UPDATE</>、
    <literal>FOR SHARE</>和
    <literal>FOR KEY SHARE</>不能用于<literal>INTERSECT</>结果或者
    <literal>INTERSECT</>的任何输入。
   </para>
  </refsect2>

  <refsect2 id="SQL-EXCEPT">
   <title id="sql-except-title"><literal>EXCEPT</literal> 子句</title>

   <para>
    <literal>EXCEPT</literal>子句具有下面的形式：
<synopsis>
<replaceable class="parameter">select_statement</replaceable> EXCEPT [ ALL | DISTINCT ] <replaceable class="parameter">select_statement</replaceable>
</synopsis><replaceable class="parameter">select_statement</replaceable>
    是任何没有<literal>ORDER
    BY</>、<literal>LIMIT</>、<literal>FOR NO KEY UPDATE</>、<literal>FOR UPDATE</literal>、
    <literal>FOR SHARE</literal>以及<literal>FOR KEY SHARE</>子句的
    <command>SELECT</command>语句。
   </para>

   <para>
    <literal>EXCEPT</literal>操作符计算位于左
    <command>SELECT</command>语句的结果中但不在右
    <command>SELECT</command>语句结果中的行集合。
   </para>

   <para>
    <literal>EXCEPT</>的结果不会包含重复行，除非指定了
    <literal>ALL</>选项。如果有<literal>ALL</>，一个在左表中有
    <replaceable>m</>次重复并且在右表中有
    <replaceable>n</>次重复的行将会在结果集中出现
    max(<replaceable>m</>-<replaceable>n</>,0) 次。
    <literal>DISTINCT</>可以写<literal>DISTINCT</>来
    显式地指定消除重复行的行为。
   </para>

   <para>
    除非用圆括号指定计算顺序，
    同一个<command>SELECT</command>语句中的多个
    <literal>EXCEPT</>操作符会从左至右计算。
    <literal>EXCEPT</literal>的优先级与
    <literal>UNION</literal>相同。
   </para>

   <para>
    当前，<literal>FOR NO KEY UPDATE</>、<literal>FOR UPDATE</>、
    <literal>FOR SHARE</>和
    <literal>FOR KEY SHARE</>不能用于<literal>EXCEPT</>结果或者
    <literal>EXCEPT</>的任何输入。
   </para>
  </refsect2>

  <refsect2 id="SQL-ORDERBY">
   <title id="sql-orderby-title"><literal>ORDER BY</literal> 子句</title>

   <para>
    可选的<literal>ORDER BY</literal>子句的形式如下：
<synopsis>
ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC | USING <replaceable class="parameter">operator</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...]
</synopsis>
    <literal>ORDER BY</literal>子句导致结果行被按照指定的表达式排序。
    如果两行按照最左边的表达式是相等的，则会根据下一个表达式比较它们，
    依次类推。如果按照所有指定的表达式它们都是相等的，则它们被返回的
    顺序取决于实现。
   </para>

   <para>
    每一个<replaceable class="parameter">expression</replaceable>
    可以是输出列（<command>SELECT</command>列表项）的名称或
    者序号，它也可以是由输入列值构成的任意表达式。
   </para>

   <para>
    序号指的是输出列的顺序（从左至右）位置。这种特性可以为不具有唯一
    名称的列定义一个顺序。这不是绝对必要的，因为总是可以使用
    <literal>AS</>子句为输出列赋予一个名称。
   </para>

   <para>
    也可以在<literal>ORDER BY</literal>子句中使用任意表达式，包括没
    有出现在<command>SELECT</command>输出列表中的列。因此，
    下面的语句是合法的：
<programlisting>
SELECT name FROM distributors ORDER BY code;
</programlisting>
    这种特性的一个限制是一个应用在<literal>UNION</>、
    <literal>INTERSECT</>或<literal>EXCEPT</>子句结果上的
    <literal>ORDER BY</>只能指定输出列名称或序号，但不能指定表达式。
   </para>

   <para>
    如果一个<literal>ORDER BY</>表达式是一个既匹配输出列名称又匹配
    输入列名称的简单名称，<literal>ORDER BY</>将把它解读成输出列名
    称。这与在同样情况下<literal>GROUP BY</>会做出的选择相反。这种
    不一致是为了与 SQL 标准兼容。
   </para>

   <para>
    可以为<literal>ORDER BY</>子句中的任何表达式之后增加关键词
    <literal>ASC</>（上升）<literal>DESC</>（下降）。如果没有指定，
    <literal>ASC</>被假定为默认值。或者，可以在<literal>USING</>
    子句中指定一个特定的排序操作符名称。一个排序操作符必须是某个
    B-树操作符族的小于或者大于成员。<literal>ASC</>通常等价于
    <literal>USING &lt;</>而<literal>DESC</>通常等价于
    <literal>USING &gt;</>（但是一种用户定义数据类型的创建者可以
    准确地定义默认排序顺序是什么，并且它可能会对应于其他名称的操作符）。
   </para>

   <para>
    如果指定<literal>NULLS LAST</>，空值会排在非空值之后；如果指定
    <literal>NULLS FIRST</>，空值会排在非空值之前。如果都没有指定，
    在指定或者隐含<literal>ASC</>时的默认行为是<literal>NULLS LAST</>，
    而指定或者隐含<literal>DESC</>时的默认行为是
    <literal>NULLS FIRST</>（因此，默认行为是空值大于非空值）。
    当指定<literal>USING</>时，默认的空值顺序取决于该操作符是否为
    小于或者大于操作符。
   </para>

   <para>
    注意顺序选项只应用到它们所跟随的表达式上。例如
    <literal>ORDER BY x, y DESC</>和
    <literal>ORDER BY x DESC, y DESC</>是不同的。
   </para>

   <para>
    字符串数据会被根据引用到被排序列上的排序规则排序。根据需要可以通过在
    <replaceable class="parameter">expression</replaceable>中包括一个
    <literal>COLLATE</>子句来覆盖，例如
    <literal>ORDER BY mycolumn COLLATE "en_US"</>。更多信息请见
    <xref linkend="sql-syntax-collate-exprs">和
    <xref linkend="collation">。
   </para>
  </refsect2>

  <refsect2 id="SQL-LIMIT">
   <title id="sql-limit-title"><literal>LIMIT</literal> 子句</title>

   <para>
    <literal>LIMIT</literal>子句由两个独立的子句构成：
<synopsis>
LIMIT { <replaceable class="parameter">count</replaceable> | ALL }
OFFSET <replaceable class="parameter">start</replaceable>
</synopsis>
    <replaceable class="parameter">count</replaceable>指定要返回
    的最大行数，而<replaceable class="parameter">start</replaceable>
    指定在返回行之前要跳过的行数。在两者都被指定时，在开始计算要返回的
    <replaceable class="parameter">count</replaceable>行之前会跳过
    <replaceable class="parameter">start</replaceable>行。
   </para>

   <para>
    如果<replaceable class="parameter">count</replaceable>表达式计算
    为 NULL，它会被当成<literal>LIMIT ALL</>，即没有限制。如果
    <replaceable class="parameter">start</replaceable>计算为
    NULL，它会被当作<literal>OFFSET 0</>。
   </para>

   <para>
    SQL:2008 引入了一种不同的语法来达到相同的结果，
    <productname>PostgreSQL</>也支持它：
<synopsis>
OFFSET <replaceable class="parameter">start</replaceable> { ROW | ROWS }
FETCH { FIRST | NEXT } [ <replaceable class="parameter">count</replaceable> ] { ROW | ROWS } ONLY
</synopsis>
    在这种语法中，要在<replaceable class="parameter">start</>或者
    <replaceable class="parameter">count</replaceable>中写任何除
    简单整型常量之外的东西，都必须在其外包裹上圆括号。如果在一个
    <literal>FETCH</>子句中省略
    <replaceable class="parameter">count</>，它的默认值为 1。
    <literal>ROW</literal>和<literal>ROWS</literal>以及
    <literal>FIRST</literal>和<literal>NEXT</literal>是噪声，它们不影响
    这些子句的效果。根据标准，如果都存在，<literal>OFFSET</literal>子句
    必须出现在<literal>FETCH</literal>子句之前。但是
    <productname>PostgreSQL</>更宽松，它允许两种顺序。
   </para>

   <para>
    在使用<literal>LIMIT</>时，用一个<literal>ORDER BY</>子句把
    结果行约束到一个唯一顺序是个好办法。否则你讲得到该查询结果行的
    一个不可预测的子集 &mdash; 你可能要求从第 10 到第 20 行，但是在
    什么顺序下的第 10 到第 20 呢？除非指定<literal>ORDER BY</>，你
    是不知道顺序的。
   </para>

   <para>
    查询规划器在生成一个查询计划时会考虑<literal>LIMIT</>，因此
    根据你使用的<literal>LIMIT</>和<literal>OFFSET</>，你很可能
    得到不同的计划（得到不同的行序）。所以，使用不同的
    <literal>LIMIT</>/<literal>OFFSET</>值来选择一个查询结果的
    不同子集<emphasis>将会给出不一致的结果</emphasis>，除非你
    用<literal>ORDER BY</>强制一种可预测的结果顺序。这不是一个
    缺陷，它是 SQL 不承诺以任何特定顺序（除非使用
    <literal>ORDER BY</>来约束顺序）给出一个查询结果这一事实造
    成的必然后果。
   </para>

   <para>
    如果没有一个<literal>ORDER BY</>来强制选择一个确定的子集，
    重复执行同样的<literal>LIMIT</>查询甚至可能会返回一个表中行
    的不同子集。同样，这也不是一种缺陷，再这样一种情况下也无法
    保证结果的确定性。
   </para>
  </refsect2>

  <refsect2 id="SQL-FOR-UPDATE-SHARE">
   <title id="sql-for-update-share-title">锁定子句</title>

   <para>
    <literal>FOR UPDATE</>、<literal>FOR NO KEY UPDATE</>、
    <literal>FOR SHARE</>和<literal>FOR KEY SHARE</>
    是<firstterm>锁定子句</>，它们影响<literal>SELECT</>
    把行从表中取得时如何对它们加锁。
   </para>

   <para>
    锁定子句的一般形式：

<synopsis>
FOR <replaceable>lock_strength</> [ OF <replaceable class="parameter">table_name</replaceable> [, ...] ] [ NOWAIT ]
</synopsis>

    其中<replaceable>lock_strength</>可以是

<synopsis>
UPDATE
NO KEY UPDATE
SHARE
KEY SHARE
</synopsis>
   之一。
   </para>

   <para>
    更多关于每一种行级锁模式的信息可见
    <xref linkend="locking-rows">。
   </para>

   <para>
    要防止该操作等待其他事务提交，可使用<literal>NOWAIT</>
    选项。在使用<literal>NOWAIT</>时，如果一个被选择的行不能
    马上被锁定，该语句会报告一个错误而不是等待。注意
    <literal>NOWAIT</>只适用于行级锁 &mdash; 已经请求的
    <literal>ROW SHARE</literal>表级锁仍然会以普通的方式被
    取得（见<xref linkend="mvcc">）。如果你需要不等待而取得
    表级锁，可以先使用带有<literal>NOWAIT</>选项的
    <xref linkend="sql-lock">。
   </para>

   <para>
    如果在一个锁定子句中提到了特定的表，则只有来自于那些表的
    行会被锁定，任何<command>SELECT</command>中用到的
    其他表还是被简单地照常读取。一个没有表列表的锁定子句会影响
    该语句中用到的所有表。如果一个锁定子句被应用到一个视图或者
    子查询，它会影响在该视图或子查询中用到的所有表。不过，这些
    子句不适用于主查询引用的<literal>WITH</>查询。如果你希望
    在一个<literal>WITH</>查询中发生行锁定，应该在该
    <literal>WITH</>查询内指定一个锁定子句。
   </para>

   <para>
    如果有必要对不同的表指定不同的锁定行为，可以写多个锁定子句。
    如果同一个表在多于一个锁定子句中被提到（或者被隐式的影响到），
    那么会按照所指定的最强的锁定行为来处理它。类似地，如果在任何
    影响一个表的子句中指定了<literal>NOWAIT</>，就会按照
    <literal>NOWAIT</>的行为来处理该表。
   </para>

   <para>
    如果被返回的行无法清晰地与表中的行保持一致，则不能使用锁定子句。
    例如锁定子句不能与聚集一起使用。
   </para>

   <para>
    当一个锁定子句出现在一个<command>SELECT</>查询的顶层时，
    被锁定的行正好就是该查询返回的行。在连接查询的情况下，被锁定
    的行是那些对返回的连接行有贡献的行。此外，自该查询的快照起满足
    查询条件的行将被锁定，如果它们在该快照后被更新并且不再满足
    查询条件，它们将不会被返回。如果使用了<literal>LIMIT</>，只要
    已经返回的行数满足了限制，锁定就会停止（但注意被
    <literal>OFFSET</>跳过的行将被锁定）。类似地，如果在一个游标
    的查询中使用锁定子句，只有被该游标实际取出或者跳过的行才将被
    锁定。
   </para>

   <para>
    当一个锁定子句出现在一个子-<command>SELECT</>中时，被锁定
    行是那些该子查询返回给外层查询的行。这些被锁定的行的数量可能比
    从子查询自身的角度看到的要少，因为来自外层查询的条件可能会被用
    来优化子查询的执行。例如：
<programlisting>
SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss WHERE col1 = 5;
</programlisting>
    将只锁定具有<literal>col1 = 5</>的行（虽然在子查询中并没有写上
    该条件）。
   </para>

  <para>
   早前的发行无法维持一个被之后的保存点升级的锁。例如，这段代码：
<programlisting>
BEGIN;
SELECT * FROM mytable WHERE key = 1 FOR UPDATE;
SAVEPOINT s;
UPDATE mytable SET ... WHERE key = 1;
ROLLBACK TO s;
</programlisting>
   在<command>ROLLBACK TO</>之后将无法维持
   <literal>FOR UPDATE</>锁。在 9.3 中已经修复这个问题。
  </para>

  <caution>
   <para>
    一个运行在<literal>READ
    COMMITTED</literal>事务隔离级别并且使用<literal>ORDER
    BY</literal>和锁定子句的<command>SELECT</>命令有可能返回无序的行。
    这是因为<literal>ORDER BY</>会被首先应用。该命令对结果排序，但是可能
    接着在尝试获得一个或者多个行上的锁时阻塞。一旦<literal>SELECT</>解除
    阻塞，某些排序列值可能已经被修改，从而导致那些行变成无序的（尽管它们根
    据原始列值是有序的）。根据需要，可以通过在子查询中放置
    <literal>FOR UPDATE/SHARE</literal>来解决之一问题，例如
<programlisting>
SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss ORDER BY column1;
</programlisting>
    注意这将导致锁定<structname>mytable</>的所有行，而顶层的
    <literal>FOR UPDATE</>只会锁定实际被返回的行。这可能会导致显著的
    性能差异，特别是把<literal>ORDER BY</>与<literal>LIMIT</>或者其他
    限制组合使用时。因此只有在并发更新排序列并且要求严格的排序结果时才推
    荐使用这种技术。
   </para>

   <para>
    在<literal>REPEATABLE READ</literal>或者<literal>SERIALIZABLE</literal>
    事务隔离级别上这可能导致一个序列化失败（<literal>SQLSTATE</literal>
    是<literal>'40001'</literal>），因此在这些隔离级别下不可能收到无序行。
   </para>
  </caution>
  </refsect2>

  <refsect2 id="SQL-TABLE">
   <title><literal>TABLE</literal> 命令</title>

   <para>
    命令
<programlisting>
TABLE <replaceable class="parameter">name</replaceable>
</programlisting>
    等价于
<programlisting>
SELECT * FROM <replaceable class="parameter">name</replaceable>
</programlisting>
    它可以被用作一个顶层命令，或者用在复杂查询中以节省空间。只有
    <literal>WITH</>、
    <literal>UNION</>、<literal>INTERSECT</>、<literal>EXCEPT</>、
    <literal>ORDER BY</>、<literal>LIMIT</>、<literal>OFFSET</>、
    <literal>FETCH</>以及<literal>FOR</>锁定子句可以用于
    <command>TABLE</>。不能使用<literal>WHERE</>子句和任何形式
    的聚集。
   </para>
  </refsect2>
 </refsect1>

 <refsect1>
  <title>示例</title>

  <para>
   把表<literal>films</literal>与表
   <literal>distributors</literal>连接：

<programlisting>
SELECT f.title, f.did, d.name, f.date_prod, f.kind
    FROM distributors d, films f
    WHERE f.did = d.did

       title       | did |     name     | date_prod  |   kind
-------------------+-----+--------------+------------+----------
 The Third Man     | 101 | British Lion | 1949-12-23 | Drama
 The African Queen | 101 | British Lion | 1951-08-11 | Romantic
 ...
</programlisting>
  </para>

  <para>
   要对所有电影的<literal>len</literal>列求和并且用
   <literal>kind</literal>对结果分组：

<programlisting>
SELECT kind, sum(len) AS total FROM films GROUP BY kind;

   kind   | total
----------+-------
 Action   | 07:34
 Comedy   | 02:58
 Drama    | 14:28
 Musical  | 06:42
 Romantic | 04:38
</programlisting>
  </para>

  <para>
   要对所有电影的<literal>len</literal>列求和、对结果按照
   <literal>kind</literal>分组并且显示总长小于 5 小时的分组：

<programlisting>
SELECT kind, sum(len) AS total
    FROM films
    GROUP BY kind
    HAVING sum(len) &lt; interval '5 hours';

   kind   | total
----------+-------
 Comedy   | 02:58
 Romantic | 04:38
</programlisting>
  </para>

  <para>
   下面两个例子都是根据第二列（<literal>name</literal>）的内容来排序结果：

<programlisting>
SELECT * FROM distributors ORDER BY name;
SELECT * FROM distributors ORDER BY 2;

 did |       name
-----+------------------
 109 | 20th Century Fox
 110 | Bavaria Atelier
 101 | British Lion
 107 | Columbia
 102 | Jean Luc Godard
 113 | Luso films
 104 | Mosfilm
 103 | Paramount
 106 | Toho
 105 | United Artists
 111 | Walt Disney
 112 | Warner Bros.
 108 | Westward
</programlisting>
  </para>

  <para>
   接下来的例子展示了如何得到表<literal>distributors</literal>和
   <literal>actors</literal>的并集，把结果限制为那些在每个表中以
   字母 W 开始的行。只想要可区分的行，因此省略了关键词
   <literal>ALL</literal>。

<programlisting>
distributors:               actors:
 did |     name              id |     name
-----+--------------        ----+----------------
 108 | Westward               1 | Woody Allen
 111 | Walt Disney            2 | Warren Beatty
 112 | Warner Bros.           3 | Walter Matthau
 ...                         ...

SELECT distributors.name
    FROM distributors
    WHERE distributors.name LIKE 'W%'
UNION
SELECT actors.name
    FROM actors
    WHERE actors.name LIKE 'W%';

      name
----------------
 Walt Disney
 Walter Matthau
 Warner Bros.
 Warren Beatty
 Westward
 Woody Allen
</programlisting>
  </para>

  <para>
   这个例子展示了如何在<literal>FROM</>子句中使用函数，
   分别使用和不使用列定义列表：

<programlisting>
CREATE FUNCTION distributors(int) RETURNS SETOF distributors AS $$
    SELECT * FROM distributors WHERE did = $1;
$$ LANGUAGE SQL;

SELECT * FROM distributors(111);
 did |    name
-----+-------------
 111 | Walt Disney

CREATE FUNCTION distributors_2(int) RETURNS SETOF record AS $$
    SELECT * FROM distributors WHERE did = $1;
$$ LANGUAGE SQL;

SELECT * FROM distributors_2(111) AS (f1 int, f2 text);
 f1  |     f2
-----+-------------
 111 | Walt Disney
</programlisting>
  </para>

  <para>
   这里是带有增加的序数列的函数的例子：

<programlisting>
SELECT * FROM unnest(ARRAY['a','b','c','d','e','f']) WITH ORDINALITY;
 unnest | ordinality
--------+----------
 a      |        1
 b      |        2
 c      |        3
 d      |        4
 e      |        5
 f      |        6
(6 rows)
</programlisting>
  </para>

  <para>
   这个例子展示了如何使用简单的<literal>WITH</>子句：

<programlisting>
WITH t AS (
    SELECT random() as x FROM generate_series(1, 3)
  )
SELECT * FROM t
UNION ALL
SELECT * FROM t

         x          
--------------------
  0.534150459803641
  0.520092216785997
 0.0735620250925422
  0.534150459803641
  0.520092216785997
 0.0735620250925422
</programlisting>

   注意该<literal>WITH</>查询只被计算一次，这样我们得到的两个
   集合具有相同的三个随机值。
  </para>

  <para>
   这个例子使用<literal>WITH RECURSIVE</literal>从一个只显示
   直接下属的表中寻找雇员 Mary
   的所有下属（直接的或者间接的）以及他们的间接层数：

<programlisting>
WITH RECURSIVE employee_recursive(distance, employee_name, manager_name) AS (
    SELECT 1, employee_name, manager_name
    FROM employee
    WHERE manager_name = 'Mary'
  UNION ALL
    SELECT er.distance + 1, e.employee_name, e.manager_name
    FROM employee_recursive er, employee e
    WHERE er.employee_name = e.manager_name
  )
SELECT distance, employee_name FROM employee_recursive;
</programlisting>

   注意这种递归查询的典型形式：一个初始条件，后面跟着
   <literal>UNION</literal>，然后是查询的递归部分。要确保
   查询的递归部分最终将不返回任何行，否则该查询将无限循环（
   更多例子见<xref linkend="queries-with">）。
  </para>

  <para>
   这个例子使用<literal>LATERAL</>为<structname>manufacturers</>
   表的每一行应用一个集合返回函数<function>get_product_names()</>：

<programlisting>
SELECT m.name AS mname, pname
FROM manufacturers m, LATERAL get_product_names(m.id) pname;
</programlisting>

    当前没有任何产品的制造商不会出现在结果中，因为这是一个内连接。
    如果我们希望把这类制造商的名称包括在结果中，我们可以：

<programlisting>
SELECT m.name AS mname, pname
FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true;
</programlisting></para>
 </refsect1>

 <refsect1>
  <title>兼容性</title>

  <para>
   当然，<command>SELECT</command>语句是兼容 SQL 标准的。
   但是也有一些扩展和缺失的特性。
  </para>

  <refsect2>
   <title>省略的<literal>FROM</literal>子句</title>

   <para>
    <productname>PostgreSQL</productname>允许我们省略
    <literal>FROM</literal>子句。一种简单的使用是计算简单表达式
    的结果：
<programlisting>
SELECT 2+2;

 ?column?
----------
        4
</programlisting>
    某些其他<acronym>SQL</acronym>数据库需要引入一个假的
    单行表放在该<command>SELECT</command>的
    <literal>FROM</literal>子句中才能做到这一点。
   </para>

   <para>
    注意，如果没有指定一个<literal>FROM</literal>子句，该查询
    就不能引用任何数据库表。例如，下面的查询是非法的：
<programlisting>
SELECT distributors.* WHERE distributors.name = 'Westward';
</programlisting>
    <productname>PostgreSQL</productname>在 8.1 之前的发行
    会接受这种形式的查询，并且为该查询引用的每一个表在
    <literal>FROM</literal>子句中隐式增加一个项。现在已经不再允许
    这样做。
   </para>
  </refsect2>

  <refsect2>
   <title>空<literal>SELECT</literal>列表</title>

   <para>
    <literal>SELECT</literal>之后的输出表达式列表可以为空，
    这会产生一个零列的结果表。对 SQL 标准来说这不是合法的
    语法。<productname>PostgreSQL</productname>允许
    它是为了与允许零列表保持一致。不过在使用
    <literal>DISTINCT</>时不允许空列表。
   </para>
  </refsect2>

  <refsect2>
   <title>省略<literal>AS</literal>关键词</title>

   <para>
    在 SQL 标准中，只要新列名是一个合法的列名（就是说与任何保留关键词不同），
    就可以省略输出列名之前的可选关键词<literal>AS</>。
    <productname>PostgreSQL</productname>要稍微严格些：只要新列名匹配
    任何关键词（保留或者非保留）就需要<literal>AS</>。推荐的习惯是使用
    <literal>AS</>或者带双引号的输出列名来防止与未来增加的关键词可能的冲突。
   </para>

   <para>
    在<literal>FROM</literal>项中，标准和
    <productname>PostgreSQL</productname>都允许省略非保留
    关键词别名之前的<literal>AS</>。但是由于语法的歧义，这无法
    用于输出列名。
   </para>
  </refsect2>

  <refsect2>
   <title><literal>ONLY</literal>和继承</title>

   <para>
    在书写<literal>ONLY</literal>时，SQL 标准要求在表名周围加上圆括号，例如
    <literal>SELECT * FROM ONLY
    (tab1), ONLY (tab2) WHERE ...</literal>。<productname>PostgreSQL</>
    认为这些圆括号是可选的。
   </para>

   <para>
    <productname>PostgreSQL</>允许写一个拖尾的<literal>*</>来
    显式指定包括子表的非-<literal>ONLY</literal>行为。而标准则不允许
    这样。
   </para>

   <para>
    （这些点同等地适用于所有支持<literal>ONLY</literal>选项的 SQL 命令）。
   </para>
  </refsect2>

  <refsect2>
   <title><literal>FROM</literal>中的函数调用</title>

   <para>
    <productname>PostgreSQL</productname>允许一个函数调用被直接写作
    <literal>FROM</>列表的一个成员。在 SQL 标准中，有必要把这样一个函数
    调用包裹在一个子-<command>SELECT</command>中。也就是说，语法
    <literal>FROM <replaceable>func</>(...) <replaceable>alias</></literal>
    近似等价于
    <literal>FROM LATERAL (SELECT <replaceable>func</>(...)) <replaceable>alias</></literal>。
    注意该<literal>LATERAL</>被认为是隐式的，这是因为标准对于
    <literal>FROM</>中的一个<literal>UNNEST()</>项要求
    <literal>LATERAL</>语义。<productname>PostgreSQL</productname>会把
    <literal>UNNEST()</>和其他集合返回函数同样对待。
   </para>
  </refsect2>

  <refsect2>
   <title><literal>GROUP BY</literal>和<literal>ORDER BY</literal>可用的名字空间</title>

   <para>
    在 SQL-92 标准中，一个<literal>ORDER BY</literal>子句只能使用输出
    列名或者序号，而一个<literal>GROUP BY</literal>子句只能使用基于输
    入列名的表达式。<productname>PostgreSQL</productname>扩展了
    这两种子句以允许它们使用其他的选择（但如果有歧义时还是使用标准的
    解释）。<productname>PostgreSQL</productname>也允许两种子句
    指定任意表达式。注意出现在一个表达式中的名称将总是被当做输入列名而
    不是输出列名。
   </para>

   <para>
    SQL:1999 及其后的标准使用了一种略微不同的定义，它并不完全向后兼容
    SQL-92。不过，在大部分的情况下，
    <productname>PostgreSQL</productname>会以与 SQL:1999 相同的
    方式解释<literal>ORDER BY</literal>或<literal>GROUP
    BY</literal>表达式。
   </para>
  </refsect2>

  <refsect2>
   <title>函数依赖</title>

   <para>
    只有当一个表的主键被包括在<literal>GROUP BY</>列表中时，
    <productname>PostgreSQL</productname>才识别函数依赖（允许
    从<literal>GROUP BY</>中省略列）。SQL 标准指定了应该要识别
    的额外情况。
   </para>
  </refsect2>

  <refsect2>
   <title><literal>WINDOW</literal>子句限制</title>

   <para>
    SQL 标准为窗口的<replaceable class="parameter">frame_clause</>提供了额外的选项。
    <productname>PostgreSQL</productname>当前只支持上面列出的选项。
   </para>
  </refsect2>

  <refsect2>
   <title><literal>LIMIT</literal>和<literal>OFFSET</literal></title>

   <para>
    <literal>LIMIT</literal>和<literal>OFFSET</literal>子句是
    <productname>PostgreSQL</productname>-特有的语法，在
    <productname>MySQL</productname>也被使用。SQL:2008 标准已经
    引入了具有相同功能的子句<literal>OFFSET ... FETCH {FIRST|NEXT}
    ...</literal>（如上文
    <xref linkend="sql-limit" endterm="sql-limit-title">中所示）。这种语法
    也被<productname>IBM DB2</productname>使用（
    <productname>Oracle</productname>编写的应用常常使用自动生成的
    <literal>rownum</literal>列来实现这些子句的效果，这在 PostgreSQL 
    中是没有的）。
   </para>
  </refsect2>

  <refsect2>
   <title><literal>FOR NO KEY UPDATE</>、<literal>FOR UPDATE</>、<literal>FOR SHARE</>、<literal>FOR KEY SHARE</></title>

   <para>
    尽管 SQL 标准中出现了<literal>FOR UPDATE</>，但标准只允许它作为
    <command>DECLARE CURSOR</>的一个选项。
    <productname>PostgreSQL</productname>允许它出现在任何
    <command>SELECT</>查询以及子-<command>SELECT</>中，但这是
    一种扩展。<literal>FOR NO KEY UPDATE</>、<literal>FOR SHARE</>
    以及<literal>FOR KEY SHARE</>变体以及<literal>NOWAIT</>选项没有
    在标准中出现。
   </para>
  </refsect2>

  <refsect2>
   <title><literal>WITH</>中的数据修改语句</title>

   <para>
    <productname>PostgreSQL</productname>允许把<command>INSERT</>、
    <command>UPDATE</>以及<command>DELETE</>用作<literal>WITH</>
    查询。这在 SQL 标准中是找不到的。
   </para>
  </refsect2>

  <refsect2>
   <title>非标准子句</title>

   <para>
    <literal>DISTINCT ON ( ... )</literal>是 SQL 标准的扩展。
   </para>

   <para>
    <literal>ROWS FROM( ... )</>是 SQL 标准的扩展。
   </para>
  </refsect2>
 </refsect1>
</refentry>
