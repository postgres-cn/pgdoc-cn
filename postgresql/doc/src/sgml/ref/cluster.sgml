<!--
doc/src/sgml/ref/cluster.sgml
PostgreSQL documentation
-->

<refentry id="SQL-CLUSTER">
<!--==========================orignal english content==========================
 <indexterm zone="sql-cluster">
  <primary>CLUSTER</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="sql-cluster">
  <primary>CLUSTER</primary>
 </indexterm>

<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>CLUSTER</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>CLUSTER</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>CLUSTER</refname>
  <refpurpose>cluster a table according to an index</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>CLUSTER</refname>
  <refpurpose>根据一个索引聚簇一个表</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
CLUSTER [VERBOSE] <replaceable class="PARAMETER">table_name</replaceable> [ USING <replaceable class="PARAMETER">index_name</replaceable> ]
CLUSTER [VERBOSE]
</synopsis>
____________________________________________________________________________-->
<synopsis>
CLUSTER [VERBOSE] <replaceable class="PARAMETER">table_name</replaceable> [ USING <replaceable class="PARAMETER">index_name</replaceable> ]
CLUSTER [VERBOSE]
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <command>CLUSTER</command> instructs <productname>PostgreSQL</productname>
   to cluster the table specified
   by <replaceable class="parameter">table_name</replaceable>
   based on the index specified by
   <replaceable class="parameter">index_name</replaceable>. The index must
   already have been defined on
   <replaceable class="parameter">table_name</replaceable>.
  </para>
____________________________________________________________________________-->
  <para>
   <command>CLUSTER</command>指示<productname>PostgreSQL</productname>
   基于<replaceable class="parameter">index_name</replaceable>
   所指定的索引来聚簇
   <replaceable class="parameter">table_name</replaceable>
   所指定的表。该索引必须已经定义在
   <replaceable class="parameter">table_name</replaceable>上。
  </para>

<!--==========================orignal english content==========================
  <para>
   When a table is clustered, it is physically reordered
   based on the index information. Clustering is a one-time operation:
   when the table is subsequently updated, the changes are
   not clustered.  That is, no attempt is made to store new or
   updated rows according to their index order.  (If one wishes, one can
   periodically recluster by issuing the command again.  Also, setting
   the table's <literal>fillfactor</literal> storage parameter to less than
   100% can aid in preserving cluster ordering during updates, since updated
   rows are kept on the same page if enough space is available there.)
  </para>
____________________________________________________________________________-->
  <para>
   当一个表被聚簇时，会基于索引信息对它进行物理上的排序。聚簇是一种
   一次性的操作：当表后续被更新时，更改没有被聚簇。也就是说，不会尝
   试根据新行或者被更新行的索引顺序来存储它们（如果想这样做，可以周
   期性地通过发出该命令重新聚簇。还有，把表的
   <literal>fillfactor</literal>存储参数设置为小于 100% 有助于在更
   新期间保持聚簇顺序，因为如果空间足够会把被更新行保留在同一个页面
   中）。
  </para>

<!--==========================orignal english content==========================
  <para>
   When a table is clustered, <productname>PostgreSQL</productname>
   remembers which index it was clustered by.  The form
   <command>CLUSTER <replaceable class="parameter">table_name</replaceable></command>
   reclusters the table using the same index as before.  You can also
   use the <literal>CLUSTER</literal> or <literal>SET WITHOUT CLUSTER</literal>
   forms of <xref linkend="SQL-ALTERTABLE"> to set the index to be used for
   future cluster operations, or to clear any previous setting.
  </para>
____________________________________________________________________________-->
  <para>
   当一个表被更新时，<productname>PostgreSQL</productname>
   会记住它是按照哪个索引聚簇的。形式
   <command>CLUSTER <replaceable class="parameter">table_name</replaceable></command>
   会使用前面所用的同一个索引对表重新聚簇。你也可以使用
   <literal>CLUSTER</literal>或者<xref linkend="SQL-ALTERTABLE">
   的<literal>SET WITHOUT CLUSTER</literal>形式把索引设置为可用于
   未来的聚簇操作，或者清除任何之前的设置。
  </para>

<!--==========================orignal english content==========================
  <para>
   <command>CLUSTER</command> without any parameter reclusters all the
   previously-clustered tables in the current database that the calling user
   owns, or all such tables if called by a superuser.  This
   form of <command>CLUSTER</command> cannot be executed inside a transaction
   block.
  </para>
____________________________________________________________________________-->
  <para>
   不带任何参数的<command>CLUSTER</command>会重新聚簇调用用
   户所拥有的当前数据库中已经被聚簇过的表（如果是超级用户调用，则是
   所有已被聚簇过的表）。这种形式的
   <command>CLUSTER</command>不能在一个事务块内执行。
  </para>

<!--==========================orignal english content==========================
  <para>
   When a table is being clustered, an <literal>ACCESS
   EXCLUSIVE</literal> lock is acquired on it. This prevents any other
   database operations (both reads and writes) from operating on the
   table until the <command>CLUSTER</command> is finished.
  </para>
____________________________________________________________________________-->
  <para>
   当一个表被聚簇时，会在其上要求一个<literal>ACCESS
   EXCLUSIVE</literal>锁。这会阻止任何其他数据库操作（包括读和写）
   在<command>CLUSTER</command>结束前在该表上操作。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Parameters</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="PARAMETER">table_name</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="PARAMETER">table_name</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The name (possibly schema-qualified) of a table.
     </para>
____________________________________________________________________________-->
     <para>
      一个表的名称（可能是模式限定的）。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="PARAMETER">index_name</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="PARAMETER">index_name</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The name of an index.
     </para>
____________________________________________________________________________-->
     <para>
      一个索引的名称。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>VERBOSE</literal></term>
____________________________________________________________________________-->
    <term><literal>VERBOSE</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Prints a progress report as each table is clustered.
     </para>
____________________________________________________________________________-->
     <para>
      在每一个表被聚簇时打印一个进度报告。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Notes</title>
____________________________________________________________________________-->
  <title>注解</title>

<!--==========================orignal english content==========================
   <para>
    In cases where you are accessing single rows randomly
    within a table, the actual order of the data in the
    table is unimportant. However, if you tend to access some
    data more than others, and there is an index that groups
    them together, you will benefit from using <command>CLUSTER</command>.
    If you are requesting a range of indexed values from a table, or a
    single indexed value that has multiple rows that match,
    <command>CLUSTER</command> will help because once the index identifies the
    table page for the first row that matches, all other rows
    that match are probably already on the same table page,
    and so you save disk accesses and speed up the query.
   </para>
____________________________________________________________________________-->
   <para>
    在随机访问一个表中的行时，表中数据的实际顺序是无关紧要的。
    不过，如果你想要更多地访问其中一些数据，并且有一个索引把它
    们分组在一起，使用<command>CLUSTER</command>就会带
    来好处。如果你从一个表中要求一个范围的被索引值或者多行都匹
    配的一个单一值，<command>CLUSTER</command>就会有所
    帮助，因为一旦该索引标识出了第一个匹配行所在的表页，所有其
    他匹配行很可能就在同一个表页中，并且因此节省了磁盘访问并且
    提高了查询速度。
   </para>

<!--==========================orignal english content==========================
   <para>
    <command>CLUSTER</> can re-sort the table using either an index scan
    on the specified index, or (if the index is a b-tree) a sequential
    scan followed by sorting.  It will attempt to choose the method that
    will be faster, based on planner cost parameters and available statistical
    information.
   </para>
____________________________________________________________________________-->
   <para>
    <command>CLUSTER</>可以使用指定索引上的一次索引扫描
    或者遵循排序的一次顺序扫描（如果索引是 B 树）对表重新排序。
    它将会基于规划器代价参数以及可用的统计信息来选择较快的方法。
   </para>

<!--==========================orignal english content==========================
   <para>
    When an index scan is used, a temporary copy of the table is created that
    contains the table data in the index order.  Temporary copies of each
    index on the table are created as well.  Therefore, you need free space on
    disk at least equal to the sum of the table size and the index sizes.
   </para>
____________________________________________________________________________-->
   <para>
    在使用索引扫描时，会创建该表的一份临时拷贝，其中包含按索引顺序
    排列的表数据。该表上每一个索引的临时拷贝也会被创建。因此，在磁
    盘上需要至少等于表尺寸加上索引尺寸的综合的空闲空间。
   </para>

<!--==========================orignal english content==========================
   <para>
    When a sequential scan and sort is used, a temporary sort file is
    also created, so that the peak temporary space requirement is as much
    as double the table size, plus the index sizes.  This method is often
    faster than the index scan method, but if the disk space requirement is
    intolerable, you can disable this choice by temporarily setting <xref
    linkend="guc-enable-sort"> to <literal>off</>.
   </para>
____________________________________________________________________________-->
   <para>
    在使用顺序扫描以及排序时，也会创建一个临时排序文件，因此临时空
    间需求的峰值也就是表尺寸的两倍外加索引尺寸。这种方法通常比索引
    扫描方法更快，但是如果磁盘空间需求是不能接受的，你可以通过临时
    地把<xref linkend="guc-enable-sort">设置为<literal>off</>来禁
    用这种选择。
   </para>

<!--==========================orignal english content==========================
   <para>
    It is advisable to set <xref linkend="guc-maintenance-work-mem"> to
    a reasonably large value (but not more than the amount of RAM you can
    dedicate to the <command>CLUSTER</> operation) before clustering.
   </para>
____________________________________________________________________________-->
   <para>
    建议在聚簇前把<xref linkend="guc-maintenance-work-mem">设
    置为一个合理地比较大的值（但是不能超过你可以用于
    <command>CLUSTER</>操作的 RAM 容量）。
   </para>

<!--==========================orignal english content==========================
   <para>
    Because the planner records statistics about the ordering of
    tables, it is advisable to run <xref linkend="sql-analyze">
    on the newly clustered table.
    Otherwise, the planner might make poor choices of query plans.
   </para>
____________________________________________________________________________-->
   <para>
    因为规划器会记录有关表顺序的统计信息，建议在新近被聚簇的表上
    运行<xref linkend="sql-analyze">。否则，规划器可能会产生很差
    的查询计划。
   </para>

<!--==========================orignal english content==========================
   <para>
    Because <command>CLUSTER</command> remembers which indexes are clustered,
    one can cluster the tables one wants clustered manually the first time,
    then set up a periodic maintenance script that executes
    <command>CLUSTER</> without any parameters, so that the desired tables
    are periodically reclustered.
   </para>
____________________________________________________________________________-->
   <para>
    因为<command>CLUSTER</command>会记住哪些索引被聚簇，
    我们可以第一次手动聚簇想要聚簇的表，然后设置一个定期运行的维护
    脚本，其中执行不带任何参数的<command>CLUSTER</>，这样那些
    表就会被周期性地重新聚簇。
   </para>

 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Examples</title>
____________________________________________________________________________-->
  <title>示例</title>

<!--==========================orignal english content==========================
  <para>
   Cluster the table <literal>employees</literal> on the basis of
   its index <literal>employees_ind</literal>:
<programlisting>
CLUSTER employees USING employees_ind;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   基于索引<literal>employees_ind</literal>聚簇表
   <literal>employees</literal>：
<programlisting>
CLUSTER employees USING employees_ind;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Cluster the <literal>employees</literal> table using the same
   index that was used before:
<programlisting>
CLUSTER employees;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   使用之前用过的同一个索引聚簇<literal>employees</literal>表：
<programlisting>
CLUSTER employees;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Cluster all tables in the database that have previously been clustered:
<programlisting>
CLUSTER;
</programlisting></para>
____________________________________________________________________________-->
  <para>
   对数据库中以前被聚簇过的所有表进行聚簇：
<programlisting>
CLUSTER;
</programlisting></para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Compatibility</title>
____________________________________________________________________________-->
  <title>兼容性</title>

<!--==========================orignal english content==========================
  <para>
   There is no <command>CLUSTER</command> statement in the SQL standard.
  </para>
____________________________________________________________________________-->
  <para>
   在 SQL 标准中没有<command>CLUSTER</command>语句。
  </para>

<!--==========================orignal english content==========================
  <para>
   The syntax
<synopsis>
CLUSTER <replaceable class="PARAMETER">index_name</replaceable> ON <replaceable class="PARAMETER">table_name</replaceable>
</synopsis>
  is also supported for compatibility with pre-8.3 <productname>PostgreSQL</>
  versions.
  </para>
____________________________________________________________________________-->
  <para>
   为了兼容 8.3 之前的<productname>PostgreSQL</>版本，
<synopsis>
CLUSTER <replaceable class="PARAMETER">index_name</replaceable> ON <replaceable class="PARAMETER">table_name</replaceable>
</synopsis>语法也被支持。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>See Also</title>
____________________________________________________________________________-->
  <title>另见</title>

  <simplelist type="inline">
   <member><xref linkend="app-clusterdb"></member>
  </simplelist>
 </refsect1>
</refentry>
