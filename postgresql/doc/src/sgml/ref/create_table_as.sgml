<!--
doc/src/sgml/ref/create_table_as.sgml
PostgreSQL documentation
-->

<refentry id="sql-createtableas">
<!--==========================orignal english content==========================
 <indexterm zone="sql-createtableas">
  <primary>CREATE TABLE AS</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="sql-createtableas">
  <primary>CREATE TABLE AS</primary>
 </indexterm>

<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>CREATE TABLE AS</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>CREATE TABLE AS</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>CREATE TABLE AS</refname>
  <refpurpose>define a new table from the results of a query</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>CREATE TABLE AS</refname>
  <refpurpose>从一个查询的结果创建一个新表</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <replaceable>table_name</replaceable>
    [ (<replaceable>column_name</replaceable> [, ...] ) ]
    [ USING <replaceable class="parameter">method</replaceable> ]
    [ WITH ( <replaceable class="parameter">storage_parameter</replaceable> [= <replaceable class="parameter">value</replaceable>] [, ... ] ) | WITHOUT OIDS ]
    [ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
    [ TABLESPACE <replaceable class="parameter">tablespace_name</replaceable> ]
    AS <replaceable>query</replaceable>
    [ WITH [ NO ] DATA ]
</synopsis>
____________________________________________________________________________-->
<synopsis>
CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <replaceable>table_name</replaceable>
    [ (<replaceable>column_name</replaceable> [, ...] ) ]
    [ USING <replaceable class="parameter">method</replaceable> ]
    [ WITH ( <replaceable class="parameter">storage_parameter</replaceable> [= <replaceable class="parameter">value</replaceable>] [, ... ] ) | WITHOUT OIDS ]
    [ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
    [ TABLESPACE <replaceable class="parameter">tablespace_name</replaceable> ]
    AS <replaceable>query</replaceable>
    [ WITH [ NO ] DATA ]
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <command>CREATE TABLE AS</command> creates a table and fills it
   with data computed by a <command>SELECT</command> command.
   The table columns have the
   names and data types associated with the output columns of the
   <command>SELECT</command> (except that you can override the column
   names by giving an explicit list of new column names).
  </para>
____________________________________________________________________________-->
  <para>
   <command>CREATE TABLE AS</command>创建一个表，并且用
   由一个<command>SELECT</command>命令计算出来的数据填充
   该表。该表的列具有和<command>SELECT</command>的输出列
   相关的名称和数据类型（不过可以通过给出一个显式的新列名列表来覆
   盖这些列名）。
  </para>

<!--==========================orignal english content==========================
  <para>
   <command>CREATE TABLE AS</command> bears some resemblance to
   creating a view, but it is really quite different: it creates a new
   table and evaluates the query just once to fill the new table
   initially.  The new table will not track subsequent changes to the
   source tables of the query.  In contrast, a view re-evaluates its
   defining <command>SELECT</command> statement whenever it is
   queried.
  </para>
____________________________________________________________________________-->
  <para>
   <command>CREATE TABLE AS</command>和创建一个视图有些
   相似，但是实际上非常不同：它会创建一个新表并且只计算该查询一次
   用来初始填充新表。这个新表将不会跟踪该查询源表的后续变化。相反，
   一个视图只要被查询，它的定义<command>SELECT</command>
   语句就会被重新计算。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Parameters</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>GLOBAL</literal> or <literal>LOCAL</literal></term>
____________________________________________________________________________-->
    <term><literal>GLOBAL</literal>或者<literal>LOCAL</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Ignored for compatibility.  Use of these keywords is deprecated;
      refer to <xref linkend="sql-createtable"/> for details.
     </para>
____________________________________________________________________________-->
     <para>
      为兼容性而忽略。不推荐使用这些关键词，详见
      <xref linkend="sql-createtable"/>。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>TEMPORARY</literal> or <literal>TEMP</literal></term>
____________________________________________________________________________-->
    <term><literal>TEMPORARY</literal>或者<literal>TEMP</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      If specified, the table is created as a temporary table.
      Refer to <xref linkend="sql-createtable"/> for details.
     </para>
____________________________________________________________________________-->
     <para>
      如果被指定，该表会被创建为一个临时表。详见
      <xref linkend="sql-createtable"/>。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>UNLOGGED</literal></term>
____________________________________________________________________________-->
    <term><literal>UNLOGGED</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      If specified, the table is created as an unlogged table.
      Refer to <xref linkend="sql-createtable"/> for details.
     </para>
____________________________________________________________________________-->
     <para>
      如果被指定，该表会被创建为一个不做日志的表。详见
      <xref linkend="sql-createtable"/>。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>IF NOT EXISTS</literal></term>
____________________________________________________________________________-->
    <term><literal>IF NOT EXISTS</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Do not throw an error if a relation with the same name already exists.
      A notice is issued in this case. Refer to <xref linkend="sql-createtable"/>
      for details.
     </para>
____________________________________________________________________________-->
     <para>
      如果已经存在一个同名的关系时不要抛出错误。这种情况下会发出一个
      提示。详见<xref linkend="sql-createtable"/>。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable>table_name</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable>table_name</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The name (optionally schema-qualified) of the table to be created.
     </para>
____________________________________________________________________________-->
     <para>
      要创建的表的名称（可以被模式限定）。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable>column_name</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable>column_name</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The name of a column in the new table.  If column names are not
      provided, they are taken from the output column names of the query.
     </para>
____________________________________________________________________________-->
     <para>
      新表中一列的名称。如果没有提供列名，会从查询的输出列名中得到。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>USING <replaceable class="parameter">method</replaceable></literal></term>
____________________________________________________________________________-->
    <term><literal>USING <replaceable class="parameter">method</replaceable></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      This optional clause specifies the table access method to use to store
      the contents for the new table; the method needs be an access method of
      type <literal>TABLE</literal>. See <xref linkend="tableam"/> for more
      information.  If this option is not specified, the default table access
      method is chosen for the new table. See <xref
      linkend="guc-default-table-access-method"/> for more information.
     </para>
____________________________________________________________________________-->
     <para>
      这个可选的子句指定了用于存储新表内容的表访问方法；该方法需要是一个类型 <literal>TABLE</literal>的访问方法。详见<xref linkend="tableam"/>。
      如果没有指定这个选项，则选择新表的默认表访问方法。详见<xref linkend="guc-default-table-access-method"/>。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>WITH ( <replaceable class="parameter">storage_parameter</replaceable> [= <replaceable class="parameter">value</replaceable>] [, ... ] )</literal></term>
____________________________________________________________________________-->
    <term><literal>WITH ( <replaceable class="parameter">storage_parameter</replaceable> [= <replaceable class="parameter">value</replaceable>] [, ... ] )</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      This clause specifies optional storage parameters for the new table;
      see <xref linkend="sql-createtable-storage-parameters"/> in the
      <xref linkend="sql-createtable"/> documentation for more
      information.   For backward-compatibility the <literal>WITH</literal>
      clause for a table can also include <literal>OIDS=FALSE</literal> to
      specify that rows of the new table should contain no OIDs (object
      identifiers), <literal>OIDS=TRUE</literal> is not supported anymore.
     </para>
____________________________________________________________________________-->
     <para>
      这个子句为新表指定可选的存储参数，详见<xref linkend="sql-createtable"/>的
      <xref linkend="sql-createtable-storage-parameters"/>。
      为了向后兼容，表的<literal>WITH</literal>子句也能包含<literal>OIDS=FALSE</literal>来指定新表的行将不包含OID（对象标识符）。<literal>OIDS=TRUE</literal>不再支持。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>WITHOUT OIDS</literal></term>
____________________________________________________________________________-->
    <term><literal>WITHOUT OIDS</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      This is backward-compatible syntax for declaring a table
      <literal>WITHOUT OIDS</literal>, creating a table <literal>WITH
      OIDS</literal> is not supported anymore.
     </para>
____________________________________________________________________________-->
     <para>
      这是向后兼容的语法，用于声明表<literal>WITHOUT OIDS</literal>，创建表<literal>WITH OIDS</literal>不再被支持。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>ON COMMIT</literal></term>
____________________________________________________________________________-->
    <term><literal>ON COMMIT</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The behavior of temporary tables at the end of a transaction
      block can be controlled using <literal>ON COMMIT</literal>.
      The three options are:

      <variablelist>
       <varlistentry>
        <term><literal>PRESERVE ROWS</literal></term>
        <listitem>
         <para>
          No special action is taken at the ends of transactions.
          This is the default behavior.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>DELETE ROWS</literal></term>
        <listitem>
         <para>
          All rows in the temporary table will be deleted at the end
          of each transaction block.  Essentially, an automatic <xref
          linkend="sql-truncate"/> is done
          at each commit.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>DROP</literal></term>
        <listitem>
         <para>
          The temporary table will be dropped at the end of the current
          transaction block.
         </para>
        </listitem>
       </varlistentry>
      </variablelist></para>
____________________________________________________________________________-->
     <para>
      临时表在事务块结束时的行为可以用<literal>ON COMMIT</literal>
      控制。三个选项是：

      <variablelist>
       <varlistentry>
        <term><literal>PRESERVE ROWS</literal></term>
        <listitem>
         <para>
          在事务结束时不采取特殊的动作。这是默认行为。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>DELETE ROWS</literal></term>
        <listitem>
         <para>
          在每一个事务块结束时临时表中的所有行都将被删除。本质上，
          在每次提交时会完成一次自动的<xref
          linkend="sql-truncate"/>。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>DROP</literal></term>
        <listitem>
         <para>
          在当前事务块结束时将删掉临时表。
         </para>
        </listitem>
       </varlistentry>
      </variablelist></para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>TABLESPACE <replaceable class="parameter">tablespace_name</replaceable></literal></term>
____________________________________________________________________________-->
    <term><literal>TABLESPACE <replaceable class="parameter">tablespace_name</replaceable></literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The <replaceable class="parameter">tablespace_name</replaceable> is the name
      of the tablespace in which the new table is to be created.
      If not specified,
      <xref linkend="guc-default-tablespace"/> is consulted, or
      <xref linkend="guc-temp-tablespaces"/> if the table is temporary.
     </para>
____________________________________________________________________________-->
     <para>
      <replaceable class="parameter">tablespace_name</replaceable>
      是要在其中创建新表的表空间名称。如果没有指定，将会查询
      <xref linkend="guc-default-tablespace"/>，临时表会查询
      <xref linkend="guc-temp-tablespaces"/>。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable>query</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable>query</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      A <xref linkend="sql-select"/>, <link
      linkend="sql-table">TABLE</link>, or <xref linkend="sql-values"/>
      command, or an <xref linkend="sql-execute"/> command that runs a
      prepared <command>SELECT</command>, <command>TABLE</command>, or
      <command>VALUES</command> query.
     </para>
____________________________________________________________________________-->
     <para>
      一个<xref linkend="sql-select"/>、<link
      linkend="sql-table">TABLE</link>或者<xref linkend="sql-values"/>
      命令，或者是一个运行准备好的<command>SELECT</command>、
      <command>TABLE</command>或者
      <command>VALUES</command>查询的<xref linkend="sql-execute"/>命令。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>WITH [ NO ] DATA</literal></term>
____________________________________________________________________________-->
    <term><literal>WITH [ NO ] DATA</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      This clause specifies whether or not the data produced by the query
      should be copied into the new table.  If not, only the table structure
      is copied.  The default is to copy the data.
     </para>
____________________________________________________________________________-->
     <para>
      这个子句指定查询产生的数据是否应该被复制到新表中。如果不是，只有
      表结构会被复制。默认是复制数据。
     </para>
    </listitem>
   </varlistentry>

  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Notes</title>
____________________________________________________________________________-->
  <title>注解</title>

<!--==========================orignal english content==========================
  <para>
   This command is functionally similar to <xref
   linkend="sql-selectinto"/>, but it is
   preferred since it is less likely to be confused with other uses of
   the <command>SELECT INTO</command> syntax. Furthermore, <command>CREATE
   TABLE AS</command> offers a superset of the functionality offered
   by <command>SELECT INTO</command>.
  </para>
____________________________________________________________________________-->
  <para>
   这个命令在功能上类似于<xref linkend="sql-selectinto"/>，但是它更好，
   因为不太可能被<command>SELECT INTO</command>语法的其他使用混淆。更
   进一步，<command>CREATE TABLE AS</command>提供了
   <command>SELECT INTO</command>的功能的一个超集。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Examples</title>
____________________________________________________________________________-->
  <title>示例</title>

<!--==========================orignal english content==========================
  <para>
   Create a new table <literal>films_recent</literal> consisting of only
   recent entries from the table <literal>films</literal>:

<programlisting>
CREATE TABLE films_recent AS
  SELECT * FROM films WHERE date_prod &gt;= '2002-01-01';
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   创建一个新表<literal>films_recent</literal>，它只由表
   <literal>films</literal>中最近的项组成：

<programlisting>
CREATE TABLE films_recent AS
  SELECT * FROM films WHERE date_prod &gt;= '2002-01-01';
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To copy a table completely, the short form using
   the <literal>TABLE</literal> command can also be used:

<programlisting>
CREATE TABLE films2 AS
  TABLE films;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   要完全地复制一个表，也可以使用<literal>TABLE</literal>命令的
   简短形式：

<programlisting>
CREATE TABLE films2 AS
  TABLE films;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Create a new temporary table <literal>films_recent</literal>, consisting of
   only recent entries from the table <literal>films</literal>, using a
   prepared statement.  The new table will be dropped at commit:

<programlisting>
PREPARE recentfilms(date) AS
  SELECT * FROM films WHERE date_prod &gt; $1;
CREATE TEMP TABLE films_recent ON COMMIT DROP AS
  EXECUTE recentfilms('2002-01-01');
</programlisting></para>
____________________________________________________________________________-->
  <para>
   用一个预备语句创建一个新的临时表<literal>films_recent</literal>，
   它仅由表<literal>films</literal>中最近的项组成，使用准备好的声明。新表将在提交时被丢弃：

<programlisting>
PREPARE recentfilms(date) AS
  SELECT * FROM films WHERE date_prod &gt; $1;
CREATE TEMP TABLE films_recent ON COMMIT DROP AS
  EXECUTE recentfilms('2002-01-01');
</programlisting></para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Compatibility</title>
____________________________________________________________________________-->
  <title>兼容性</title>

<!--==========================orignal english content==========================
  <para>
   <command>CREATE TABLE AS</command> conforms to the <acronym>SQL</acronym>
   standard.  The following are nonstandard extensions:

   <itemizedlist spacing="compact">
    <listitem>
     <para>
      The standard requires parentheses around the subquery clause; in
      <productname>PostgreSQL</productname>, these parentheses are
      optional.
     </para>
    </listitem>

    <listitem>
     <para>
      In the standard, the <literal>WITH [ NO ] DATA</literal> clause
      is required; in PostgreSQL it is optional.
     </para>
    </listitem>

    <listitem>
     <para><productname>PostgreSQL</productname> handles temporary tables in a way
      rather different from the standard; see
      <xref linkend="sql-createtable"/>
      for details.
     </para>
    </listitem>

    <listitem>
     <para>
      The <literal>WITH</literal> clause is a <productname>PostgreSQL</productname>
      extension; storage parameters are not in the standard.
     </para>
    </listitem>

    <listitem>
     <para>
      The <productname>PostgreSQL</productname> concept of tablespaces is not
      part of the standard.  Hence, the clause <literal>TABLESPACE</literal>
      is an extension.
     </para>
    </listitem>
   </itemizedlist></para>
____________________________________________________________________________-->
  <para>
   <command>CREATE TABLE AS</command>符合
   <acronym>SQL</acronym>标准。下面的是非标准扩展：

   <itemizedlist spacing="compact">
    <listitem>
     <para>
      标准要求在子查询子句周围有圆括号，在
      <productname>PostgreSQL</productname>中这些圆括号是可选的。
     </para>
    </listitem>

    <listitem>
     <para>
      在标准中，<literal>WITH [ NO ] DATA</literal>子句是必要的，而
      PostgreSQL 中是可选的。
     </para>
    </listitem>

    <listitem>
     <para><productname>PostgreSQL</productname>处理临时表的方式和标准不同。
     详见<xref linkend="sql-createtable"/>。
     </para>
    </listitem>

    <listitem>
     <para>
      <literal>WITH</literal>子句是一种
      <productname>PostgreSQL</productname>扩展，
      标准中没有存储参数。
     </para>
    </listitem>

    <listitem>
     <para>
      <productname>PostgreSQL</productname>的表空间概念是标准的
      一部分。因此，子句<literal>TABLESPACE</literal>是一种扩展。
     </para>
    </listitem>
   </itemizedlist></para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>See Also</title>
____________________________________________________________________________-->
  <title>另见</title>

  <simplelist type="inline">
   <member><xref linkend="sql-creatematerializedview"/></member>
   <member><xref linkend="sql-createtable"/></member>
   <member><xref linkend="sql-execute"/></member>
   <member><xref linkend="sql-select"/></member>
   <member><xref linkend="sql-selectinto"/></member>
   <member><xref linkend="sql-values"/></member>
  </simplelist>
 </refsect1>

</refentry>
