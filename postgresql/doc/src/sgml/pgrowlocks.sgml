<!-- doc/src/sgml/pgrowlocks.sgml -->

<sect1 id="pgrowlocks" xreflabel="pgrowlocks">
 <title>pgrowlocks</title>

 <indexterm zone="pgrowlocks">
  <primary>pgrowlocks</primary>
 </indexterm>

 <para>
  <filename>pgrowlocks</filename>模块提供了一个函数来显示一个指定表的行锁定信息。
 </para>

 <sect2>
  <title>概述</title>

  <indexterm>
   <primary>pgrowlocks</primary>
  </indexterm>

<synopsis>
pgrowlocks(text) 返回 setof record
</synopsis>

  <para>
   参数是一个表的名称。结果是一个记录集合，其中每一行对应表中一个被锁定的行。输出列如<xref linkend="pgrowlocks-columns">所示。
  </para>

  <table id="pgrowlocks-columns">
   <title><function>pgrowlocks</> 输出列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>locked_row</structfield></entry>
      <entry><type>tid</type></entry>
      <entry>被锁定行的元组 ID（TID）</entry>
     </row>
     <row>
      <entry><structfield>locker</structfield></entry>
      <entry><type>xid</type></entry>
      <entry>持锁者的事务 ID，如果是多事务则为多事务 ID</entry>
     </row>
     <row>
      <entry><structfield>multi</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>如果持锁者是一个多事务，则为真</entry>
     </row>
     <row>
      <entry><structfield>xids</structfield></entry>
      <entry><type>xid[]</type></entry>
      <entry>持锁者的事务 ID（如果是多事务则多于一个）</entry>
     </row>
     <row>
      <entry><structfield>lock_type</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry>持锁者的锁模式（如果是多事务则多于一个），是一个<literal>Key Share</>、<literal>Share</>、<literal>For No Key Update</>、<literal>No Key Update</>、<literal>For Update</>、<literal>Update</>组成的数组。</entry>
     </row>

     <row>
      <entry><structfield>pids</structfield></entry>
      <entry><type>integer[]</type></entry>
      <entry>锁定后端的进程 ID（如果是多事务则多于一个）</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   <function>pgrowlocks</function>会为目标表加<literal>AccessShareLock</>并且一个一个读取每一行来收集行的锁定信息。这对于一个大表不是很快。注意：
  </para>

  <orderedlist>
   <listitem>
    <para>
    如果表被其他人整体加上了排他锁，<function>pgrowlocks</function>将被阻塞。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>pgrowlocks</function>不保证能产生一个自我一致的快照。在它执行期间，有可能加上一个新行锁，也有可能有旧行锁被释放。
    </para>
   </listitem>
  </orderedlist>

  <para>
   <function>pgrowlocks</function>不显示被锁定行的内容。如果你想同时查看行内容，你可以这样做：

<programlisting>
SELECT * FROM accounts AS a, pgrowlocks('accounts') AS p
  WHERE p.locked_row = a.ctid;
</programlisting>

   不过要注意，这样一个查询将非常低效。
  </para>
 </sect2>

 <sect2>
  <title>样例输出</title>

<screen>
test=# SELECT * FROM pgrowlocks('t1');
 locked_row | lock_type | locker | multi |   xids    |     pids
------------+-----------+--------+-------+-----------+---------------
      (0,1) | Shared    |     19 | t     | {804,805} | {29066,29068}
      (0,2) | Shared    |     19 | t     | {804,805} | {29066,29068}
      (0,3) | Exclusive |    804 | f     | {804}     | {29066}
      (0,4) | Exclusive |    804 | f     | {804}     | {29066}
(4 rows)
</screen>
 </sect2>

 <sect2>
  <title>作者</title>

  <para>
   Tatsuo Ishii
  </para>
 </sect2>

</sect1>
