<!-- doc/src/sgml/high-availability.sgml -->

<chapter id="high-availability">
<!--==========================orignal english content==========================
 <title>High Availability, Load Balancing, and Replication</title>
____________________________________________________________________________-->
 <title>高可用、负载均衡和复制</title>

<!--==========================orignal english content==========================
 <indexterm><primary>high availability</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>高可用</primary></indexterm>
<!--==========================orignal english content==========================
 <indexterm><primary>failover</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>failover</primary></indexterm>
<!--==========================orignal english content==========================
 <indexterm><primary>replication</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>复制</primary></indexterm>
<!--==========================orignal english content==========================
 <indexterm><primary>load balancing</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>负载均衡</primary></indexterm>
<!--==========================orignal english content==========================
 <indexterm><primary>clustering</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>clustering</primary></indexterm>
<!--==========================orignal english content==========================
 <indexterm><primary>data partitioning</primary></indexterm>
____________________________________________________________________________-->
 <indexterm><primary>数据分区</primary></indexterm>

<!--==========================orignal english content==========================
 <para>
  Database servers can work together to allow a second server to
  take over quickly if the primary server fails (high
  availability), or to allow several computers to serve the same
  data (load balancing).  Ideally, database servers could work
  together seamlessly.  Web servers serving static web pages can
  be combined quite easily by merely load-balancing web requests
  to multiple machines.  In fact, read-only database servers can
  be combined relatively easily too.  Unfortunately, most database
  servers have a read/write mix of requests, and read/write servers
  are much harder to combine.  This is because though read-only
  data needs to be placed on each server only once, a write to any
  server has to be propagated to all servers so that future read
  requests to those servers return consistent results.
 </para>
____________________________________________________________________________-->
 <para>
  数据库服务器可以一起工作，这样如果主要的服务器失效则允许一个第二服务器快速接手它的任务（高可用性），或者可以允许多个计算机提供相同的数据（负载均衡）。理想情况下，数据库服务器能够无缝地一起工作。提供静态网页服务的网页服务器可以非常容易地通过把网页请求均衡到多个机器来组合。事实上，只读的数据库服务器也可以相对容易地组合起来。不幸的是，大部分数据库服务器收到的请求是读/写混合的，并且读/写服务器更难于组合。这是因为尽管只读数据只需要在每台服务器上放置一次，但对于任意服务器的一次写动作却必须被传播给所有的服务器，这样才能保证未来对于那些服务器的读请求能返回一致的结果。
 </para>

<!--==========================orignal english content==========================
 <para>
  This synchronization problem is the fundamental difficulty for
  servers working together.  Because there is no single solution
  that eliminates the impact of the sync problem for all use cases,
  there are multiple solutions.  Each solution addresses this
  problem in a different way, and minimizes its impact for a specific
  workload.
 </para>
____________________________________________________________________________-->
 <para>
  这种同步问题是服务器一起工作的最根本的困难。因为没有单一解决方案能够消除该同步问题对所有用例的影响。有多种解决方案，每一种方案都以一种不同的方式提出了这个问题，并且对于一种特定的负载最小化了该问题所产生的影响。
 </para>

<!--==========================orignal english content==========================
 <para>
  Some solutions deal with synchronization by allowing only one
  server to modify the data.  Servers that can modify data are
  called read/write, <firstterm>master</firstterm> or <firstterm>primary</firstterm> servers.
  Servers that track changes in the primary are called <firstterm>standby</firstterm>
  or <firstterm>secondary</firstterm> servers. A standby server that cannot be connected
  to until it is promoted to a primary server is called a <firstterm>warm
  standby</firstterm> server, and one that can accept connections and serves read-only
  queries is called a <firstterm>hot standby</firstterm> server.
 </para>
____________________________________________________________________________-->
 <para>
  某些方案通过只允许一台服务器修改数据来处理同步。能修改数据的服务器被称为读/写、<firstterm>主控</firstterm>或<firstterm>主要</firstterm>服务器。跟踪主控机中改变的服务器被称为<firstterm>后备</firstterm>或<firstterm>次级</firstterm>服务器。如果一台后备服务器只有被提升为一台主控服务器后才能被连接，它被称为一台<firstterm>温后备</firstterm>服务器，而一台总是能够接受连接并且提供只读查询的后备服务器被称为一台<firstterm>热后备</firstterm>服务器。
 </para>

<!--==========================orignal english content==========================
 <para>
  Some solutions are synchronous,
  meaning that a data-modifying transaction is not considered
  committed until all servers have committed the transaction.  This
  guarantees that a failover will not lose any data and that all
  load-balanced servers will return consistent results no matter
  which server is queried. In contrast, asynchronous solutions allow some
  delay between the time of a commit and its propagation to the other servers,
  opening the possibility that some transactions might be lost in
  the switch to a backup server, and that load balanced servers
  might return slightly stale results.  Asynchronous communication
  is used when synchronous would be too slow.
 </para>
____________________________________________________________________________-->
 <para>
  某些方案是同步的，即一个数据修改事务只有到所有服务器都提交了该事务之后才被认为是提交成功。这保证了一次故障转移不会丢失任何数据并且所有负载均衡的服务器将返回一致的结果（不管哪台服务器被查询）。相反，异步的方案允许在一次提交和它被传播到其他服务器之间有一些延迟，这产生了切换到一个备份服务器时丢失某些事务的可能性，并且负载均衡的服务器可能会返回略微陈旧的结果。当同步通信可能很慢时，可以使用异步通信。
 </para>

<!--==========================orignal english content==========================
 <para>
  Solutions can also be categorized by their granularity.  Some solutions
  can deal only with an entire database server, while others allow control
  at the per-table or per-database level.
 </para>
____________________________________________________________________________-->
 <para>
  方案也可以按照它们的粒度进行分类。某些方案只能处理一整个数据库服务器，而其他的允许在每个表或每个数据库的级别上进行控制。
 </para>

<!--==========================orignal english content==========================
 <para>
  Performance must be considered in any choice.  There is usually a
  trade-off between functionality and
  performance.  For example, a fully synchronous solution over a slow
  network might cut performance by more than half, while an asynchronous
  one might have a minimal performance impact.
 </para>
____________________________________________________________________________-->
 <para>
  在任何选择中，都必须考虑性能。通常在功能和性能之间都存在着权衡。例如，在一个低速网络上的一种完全同步的方案可能使性能减少超过一半，而一种异步的方案产生的性能影响可能是最小的。
 </para>

<!--==========================orignal english content==========================
 <para>
  The remainder of this section outlines various failover, replication,
  and load balancing solutions.
 </para>
____________________________________________________________________________-->
 <para>
  本节的剩余部分勾勒了多种故障转移、复制和负载均衡方案。
 </para>

 <sect1 id="different-replication-solutions">
<!--==========================orignal english content==========================
 <title>Comparison of Different Solutions</title>
____________________________________________________________________________-->
 <title>不同方案的比较</title>

 <variablelist>

  <varlistentry>
<!--==========================orignal english content==========================
   <term>Shared Disk Failover</term>
____________________________________________________________________________-->
   <term>共享磁盘故障转移</term>
   <listitem>

<!--==========================orignal english content==========================
    <para>
     Shared disk failover avoids synchronization overhead by having only one
     copy of the database.  It uses a single disk array that is shared by
     multiple servers.  If the main database server fails, the standby server
     is able to mount and start the database as though it were recovering from
     a database crash.  This allows rapid failover with no data loss.
    </para>
____________________________________________________________________________-->
    <para>
     共享磁盘故障转移避免了只使用一份数据库拷贝带来的同步开销。它使用一个由多个服务器共享的单一磁盘阵列。如果主数据库服务器失效，后备服务器则可以挂载并启动数据库，就好像它从一次数据库崩溃中恢复过来了。这是一种快速的故障转移，并且不存在数据丢失。
    </para>

<!--==========================orignal english content==========================
    <para>
     Shared hardware functionality is common in network storage devices.
     Using a network file system is also possible, though care must be
     taken that the file system has full <acronym>POSIX</acronym> behavior (see <xref
     linkend="creating-cluster-nfs"/>).  One significant limitation of this
     method is that if the shared disk array fails or becomes corrupt, the
     primary and standby servers are both nonfunctional.  Another issue is
     that the standby server should never access the shared storage while
     the primary server is running.
    </para>
____________________________________________________________________________-->
    <para>
     共享硬件功能在网络存储设备中很常见。也可以使用一个网络文件系统，但是要注意的是该文件系统应具有完全的<acronym>POSIX</acronym>行为（见<xref linkend="creating-cluster-nfs"/>）。这种方法的一个重大限制是如果共享磁盘阵列失效或损坏，主要和后备服务器都会变得无法工作。另一个问题是在主要服务器运行时，后备服务器永远不能访问共享存储。
    </para>

   </listitem>
  </varlistentry>

  <varlistentry>
<!--==========================orignal english content==========================
   <term>File System (Block Device) Replication</term>
____________________________________________________________________________-->
   <term>文件系统（块设备）复制</term>
   <listitem>

<!--==========================orignal english content==========================
    <para>
     A modified version of shared hardware functionality is file system
     replication, where all changes to a file system are mirrored to a file
     system residing on another computer.  The only restriction is that
     the mirroring must be done in a way that ensures the standby server
     has a consistent copy of the file system &mdash; specifically, writes
     to the standby must be done in the same order as those on the primary.
     <productname>DRBD</productname> is a popular file system replication solution
     for Linux.
    </para>
____________________________________________________________________________-->
    <para>
     共享硬件功能的一种修改版本是文件系统复制，在其中对一个文件系统的所有改变会被镜像到位于另一台计算机上的一个文件系统。唯一的限制是该镜像过程必须能保证后备服务器有一份该文件系统的一致的拷贝 &mdash; 特别是对后备服务器的写入必须按照主控机上相同的顺序进行。<productname>DRBD</productname>是用于 Linux 的一种流行的文件系统复制方案。
    </para>

<!--
https://forge.continuent.org/pipermail/sequoia/2006-November/004070.html

Oracle RAC is a shared disk approach and just send cache invalidations
to other nodes but not actual data. As the disk is shared, data is
only committed once to disk and there is a distributed locking
protocol to make nodes agree on a serializable transactional order.
-->

   </listitem>
  </varlistentry>

  <varlistentry>
<!--==========================orignal english content==========================
   <term>Write-Ahead Log Shipping</term>
____________________________________________________________________________-->
   <term>预写式日志传送</term>
   <listitem>

<!--==========================orignal english content==========================
    <para>
     Warm and hot standby servers can be kept current by reading a
     stream of write-ahead log (<acronym>WAL</acronym>)
     records.  If the main server fails, the standby contains
     almost all of the data of the main server, and can be quickly
     made the new primary database server.  This can be synchronous or
     asynchronous and can only be done for the entire database server.
    </para>
____________________________________________________________________________-->
    <para>
     温备和热备服务器能够通过读取一个预写式日志（<acronym>WAL</acronym>）记录的流来保持为当前状态。如果主服务器失效，后备服务器拥有主服务器的几乎所有数据，并且能够快速地被变成新的主数据库服务器。这可以是同步的或异步的，并且只能用于整个数据库服务器。
    </para>
<!--==========================orignal english content==========================
    <para>
     A standby server can be implemented using file-based log shipping
     (<xref linkend="warm-standby"/>) or streaming replication (see
     <xref linkend="streaming-replication"/>), or a combination of both. For
     information on hot standby, see <xref linkend="hot-standby"/>.
    </para>
____________________________________________________________________________-->
    <para>
     可以使用基于文件的日志传送（<xref linkend="warm-standby"/>）、流复制（见<xref linkend="streaming-replication"/>）或两者的组合来实现一个后备服务器。关于热备的信息可见<xref linkend="hot-standby"/>。
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
<!--==========================orignal english content==========================
   <term>Logical Replication</term>
____________________________________________________________________________-->
   <term>逻辑复制</term>
   <listitem>
<!--==========================orignal english content==========================
    <para>
     Logical replication allows a database server to send a stream of data
     modifications to another server.  <productname>PostgreSQL</productname>
     logical replication constructs a stream of logical data modifications
     from the WAL.  Logical replication allows replication of data changes on
     a per-table basis.  In addition, a server that is publishing its own
     changes can also subscribe to changes from another server, allowing data
     to flow in multiple directions.  For more information on logical
     replication, see <xref linkend="logical-replication"/>.  Through the
     logical decoding interface (<xref linkend="logicaldecoding"/>),
     third-party extensions can also provide similar functionality.
    </para>
____________________________________________________________________________-->
    <para>
     逻辑复制允许数据库服务器发送数据更新流给另一台服务器。<productname>PostgreSQL</productname>逻辑复制从WAL构建出逻辑数据更新流。逻辑复制允许您逐个表复制数据更改。此外，发布数据更新的服务器可以同时订阅其他服务器的更改，从而允许数据在多个方向流动。有关逻辑复制的更多信息，请参考 <xref linkend="logical-replication"/>。通过逻辑解码接口 (<xref linkend="logicaldecoding"/>)，第三方扩展也能提供类似的功能。
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
<!--==========================orignal english content==========================
   <term>Trigger-Based Primary-Standby Replication</term>
____________________________________________________________________________-->
   <term>基于触发器的主-备复制</term>
   <listitem>

<!--==========================orignal english content==========================
    <para>
     A trigger-based replication setup typically funnels data modification
     queries to a designated primary server. Operating on a per-table basis,
     the primary server sends data changes (typically) asynchronously to the
     standby servers.  Standby servers can answer queries while the primary is
     running, and may allow some local data changes or write activity.  This
     form of replication is often used for offloading large analytical or data
     warehouse queries.
    </para>
____________________________________________________________________________-->
    <para>
     基于触发器的复制通常会将修改数据的查询发送到指定的主服务器。它在逐个表的基础上工作，主服务器（通常）将数据更改异步发送到备用服务器。
     主服务器运行时，备用服务器可以响应查询，并执行本地数据修改或写入操作。这种形式的复制通常用于减轻大数据分析型平台或者数据仓库查询负荷。
    </para>

<!--==========================orignal english content==========================
    <para>
     <productname>Slony-I</productname> is an example of this type of
     replication, with per-table granularity, and support for multiple standby
     servers.  Because it updates the standby server asynchronously (in
     batches), there is possible data loss during fail over.
    </para>
____________________________________________________________________________-->
    <para>
     <productname>Slony-I</productname>是这种复制类型的一个例子。它使用表粒度，并且支持多个后备服务器。因为它会异步更新后备服务器（批量），在故障转移时可能会有数据丢失。
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
<!--==========================orignal english content==========================
   <term>SQL-Based Replication Middleware</term>
____________________________________________________________________________-->
   <term>基于SQL的复制中间件</term>
   <listitem>

<!--==========================orignal english content==========================
    <para>
     With SQL-based replication middleware, a program intercepts
     every SQL query and sends it to one or all servers.  Each server
     operates independently.  Read-write queries must be sent to all servers,
     so that every server receives any changes.  But read-only queries can be
     sent to just one server, allowing the read workload to be distributed
     among them.
    </para>
____________________________________________________________________________-->
    <para>
     通过基于SQL的复制中间件，一个程序拦截每一个 SQL 查询并把它发送给一个或所有服务器。每一个服务器独立地操作。读写查询必须被发送给所有服务器，这样每一个服务器都能接收到任何修改。但只读查询可以被只发送给一个服务器，这样允许读负载在服务器之间分布。
    </para>

<!--==========================orignal english content==========================
    <para>
     If queries are simply broadcast unmodified, functions like
     <function>random()</function>, <function>CURRENT_TIMESTAMP</function>, and
     sequences can have different values on different servers.
     This is because each server operates independently, and because
     SQL queries are broadcast rather than actual data changes.  If
     this is unacceptable, either the middleware or the application
     must determine such values from a single source and then use those
     values in write queries.  Care must also be taken that all
     transactions either commit or abort on all servers, perhaps
     using two-phase commit (<xref linkend="sql-prepare-transaction"/>
     and <xref linkend="sql-commit-prepared"/>).
     <productname>Pgpool-II</productname> and <productname>Continuent Tungsten</productname>
     are examples of this type of replication.
    </para>
____________________________________________________________________________-->
    <para>如果查询未经修改发送，则函数的<function>random()</function>随机值和<function>CURRENT_TIMESTAMP</function>函数的当前时间和序列值可能因不同服务器而异。
    因为每个服务器独立运行，并且它发送 SQL 查询而没有真正的更改数据。如果这是不可接受的，那么中间件或应用程序必须从单一服务器源确定此类值，并将结果用于写入查询。
    还必须注意确保所有服务器在提交或中止事务时都是相同的。这将涉及使用 两阶段提交（<xref linkend="sql-prepare-transaction"/>和<xref linkend="sql-commit-prepared"/> ）。
    <productname>Pgpool-II</productname>和<productname>Continuent Tungsten</productname>就是这种复制的例子。
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
<!--==========================orignal english content==========================
   <term>Asynchronous Multimaster Replication</term>
____________________________________________________________________________-->
   <term>异步多主控机复制</term>
   <listitem>

<!--==========================orignal english content==========================
    <para>
     For servers that are not regularly connected or have slow
     communication links, like laptops or
     remote servers, keeping data consistent among servers is a
     challenge.  Using asynchronous multimaster replication, each
     server works independently, and periodically communicates with
     the other servers to identify conflicting transactions.  The
     conflicts can be resolved by users or conflict resolution rules.
     Bucardo is an example of this type of replication.
    </para>
____________________________________________________________________________-->
    <para>
     对于不会被定期连接或通讯链路较慢的服务器，如笔记本或远程服务器，保持服务器间的数据一致是一个挑战。通过使用异步的多主控机复制，每一个服务器独立工作并且定期与其他服务器通信来确定冲突的事务。这些冲突可以由用户或冲突解决规则来解决。Bucardo 是这种复制类型的一个例子。
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
<!--==========================orignal english content==========================
   <term>Synchronous Multimaster Replication</term>
____________________________________________________________________________-->
   <term>同步多主控机复制</term>
   <listitem>

<!--==========================orignal english content==========================
    <para>
     In synchronous multimaster replication, each server can accept
     write requests, and modified data is transmitted from the
     original server to every other server before each transaction
     commits.  Heavy write activity can cause excessive locking and
     commit delays, leading to poor performance.  Read requests can
     be sent to any server.  Some implementations use shared disk
     to reduce the communication overhead.  Synchronous multimaster
     replication is best for mostly read workloads, though its big
     advantage is that any server can accept write requests &mdash;
     there is no need to partition workloads between primary and
     standby servers, and because the data changes are sent from one
     server to another, there is no problem with non-deterministic
     functions like <function>random()</function>.
    </para>
____________________________________________________________________________-->
    <para>
     在同步多主控机复制中，每一个服务器能够接受写请求，并且在每一个事务提交之前，被修改的数据会被从原始服务器传送给每一个其他服务器。繁重的写活动可能导致过多的锁定和提交延迟，进而导致很差的性能。读请求可以被发送给任意服务器。某些实现使用共享磁盘来减少通信负荷。同步多主控机复制主要对于读负载最好，尽管它的大优点是任意服务器都能接受写请求 &mdash; 没有必要在主服务器和后备服务器之间划分负载，并且因为数据修改被从一个服务器发送到另一个服务器，不会有非确定函数（如<function>random()</function>）的问题。
    </para>

<!--==========================orignal english content==========================
    <para>
     <productname>PostgreSQL</productname> does not offer this type of replication,
     though <productname>PostgreSQL</productname> two-phase commit (<xref
     linkend="sql-prepare-transaction"/> and <xref
     linkend="sql-commit-prepared"/>)
     can be used to implement this in application code or middleware.
    </para>
____________________________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>不提供这种复制类型，尽管在应用代码或中间件中可以使用<productname>PostgreSQL</productname>的两阶段提交（<xref linkend="sql-prepare-transaction"/>和<xref linkend="sql-commit-prepared"/>）来实现这种复制。
    </para>
   </listitem>
  </varlistentry>

 </variablelist>

<!--==========================orignal english content==========================
 <para>
  <xref linkend="high-availability-matrix"/> summarizes
  the capabilities of the various solutions listed above.
 </para>
____________________________________________________________________________-->
 <para>
  <xref linkend="high-availability-matrix"/>总结了上述多种方案的能力。
 </para>

 <table id="high-availability-matrix">
<!--==========================orignal english content==========================
  <title>High Availability, Load Balancing, and Replication Feature Matrix</title>
____________________________________________________________________________-->
  <title>高可用、负载均衡和复制特性矩阵</title>
  <tgroup cols="9">
   <colspec colname="col1" colwidth="1.1*"/>
   <colspec colname="col2" colwidth="1*"/>
   <colspec colname="col3" colwidth="1*"/>
   <colspec colname="col4" colwidth="1*"/>
   <colspec colname="col5" colwidth="1*"/>
   <colspec colname="col6" colwidth="1*"/>
   <colspec colname="col7" colwidth="1*"/>
   <colspec colname="col8" colwidth="1*"/>
   <colspec colname="col9" colwidth="1*"/>
   <thead>
<!--==========================orignal english content==========================
    <row>
     <entry>Feature</entry>
     <entry>Shared Disk</entry>
     <entry>File System Repl.</entry>
     <entry>Write-Ahead Log Shipping</entry>
     <entry>Logical Repl.</entry>
     <entry>Trigger-&zwsp;Based Repl.</entry>
     <entry>SQL Repl. Middle-ware</entry>
     <entry>Async. MM Repl.</entry>
     <entry>Sync. MM Repl.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry>特性</entry>
     <entry>共享磁盘</entry>
     <entry>文件系统复制</entry>
     <entry>预写式日志传送</entry>
     <entry>逻辑复制</entry>
     <entry>基于触发器的复制</entry>
     <entry>SQL复制中间件</entry>
     <entry>异步多主控机复制</entry>
     <entry>同步多主控机复制</entry>
    </row>
   </thead>

   <tbody>

<!--==========================orignal english content==========================
    <row>
     <entry>Popular examples</entry>
     <entry align="center">NAS</entry>
     <entry align="center">DRBD</entry>
     <entry align="center">built-in streaming repl.</entry>
     <entry align="center">built-in logical repl., pglogical</entry>
     <entry align="center">Londiste, Slony</entry>
     <entry align="center">pgpool-II</entry>
     <entry align="center">Bucardo</entry>
     <entry align="center"></entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry>常用的示例</entry>
     <entry align="center">NAS</entry>
     <entry align="center">DRBD</entry>
     <entry align="center">内建流复制</entry>
     <entry align="center">内建逻辑复制，pglogical</entry>
     <entry align="center">Londiste，Slony</entry>
     <entry align="center">pgpool-II</entry>
     <entry align="center">Bucardo</entry>
     <entry align="center"></entry>
    </row>

<!--==========================orignal english content==========================
    <row>
     <entry>Comm. method</entry>
     <entry align="center">shared disk</entry>
     <entry align="center">disk blocks</entry>
     <entry align="center">WAL</entry>
     <entry align="center">logical decoding</entry>
     <entry align="center">table rows</entry>
     <entry align="center">SQL</entry>
     <entry align="center">table rows</entry>
     <entry align="center">table rows and row locks</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry>通信方法</entry>
     <entry align="center">共享磁盘</entry>
     <entry align="center">磁盘块</entry>
     <entry align="center">WAL</entry>
     <entry align="center">逻辑解码</entry>
     <entry align="center">表行</entry>
     <entry align="center">SQL</entry>
     <entry align="center">表行</entry>
     <entry align="center">表行和行锁</entry>
    </row>

<!--==========================orignal english content==========================
    <row>
     <entry>No special hardware required</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry>不要求特殊硬件</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
    </row>

<!--==========================orignal english content==========================
    <row>
     <entry>Allows multiple primary servers</entry>
     <entry align="center"></entry>
     <entry align="center"></entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry>允许多个主控机服务器</entry>
     <entry align="center"></entry>
     <entry align="center"></entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
    </row>

<!--==========================orignal english content==========================
    <row>
     <entry>No overhead on primary</entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center"></entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry>无主服务器负载</entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center"></entry>
    </row>

<!--==========================orignal english content==========================
    <row>
     <entry>No waiting for multiple servers</entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">with sync off</entry>
     <entry align="center">with sync off</entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry>不等待多个服务器</entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">with sync off</entry>
     <entry align="center">with sync off</entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
    </row>

<!--==========================orignal english content==========================
    <row>
     <entry>Primary failure will never lose data</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">with sync on</entry>
     <entry align="center">with sync on</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry>主控机失效将永不丢失数据</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">with sync on</entry>
     <entry align="center">with sync on</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
    </row>

<!--==========================orignal english content==========================
    <row>
     <entry>Replicas accept read-only queries</entry>
     <entry align="center"></entry>
     <entry align="center"></entry>
     <entry align="center">with hot standby</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry>复制体接受只读查询</entry>
     <entry align="center"></entry>
     <entry align="center"></entry>
     <entry align="center">with hot</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
    </row>

<!--==========================orignal english content==========================
    <row>
     <entry>Per-table granularity</entry>
     <entry align="center"></entry>
     <entry align="center"></entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry>每个表粒度</entry>
     <entry align="center"></entry>
     <entry align="center"></entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
    </row>

<!--==========================orignal english content==========================
    <row>
     <entry>No conflict resolution necessary</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry>不需要冲突解决</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
    </row>

   </tbody>
  </tgroup>
 </table>

<!--==========================orignal english content==========================
 <para>
  There are a few solutions that do not fit into the above categories:
 </para>
____________________________________________________________________________-->
 <para>
  有一些方案不适合上述的类别：
 </para>

 <variablelist>

  <varlistentry>
<!--==========================orignal english content==========================
   <term>Data Partitioning</term>
____________________________________________________________________________-->
   <term>数据分区</term>
   <listitem>

<!--==========================orignal english content==========================
    <para>
     Data partitioning splits tables into data sets.  Each set can
     be modified by only one server.  For example, data can be
     partitioned by offices, e.g., London and Paris, with a server
     in each office.  If queries combining London and Paris data
     are necessary, an application can query both servers, or
     primary/standby replication can be used to keep a read-only copy
     of the other office's data on each server.
    </para>
____________________________________________________________________________-->
    <para>
     数据分区将表分开成数据集。每个集合只能被一个服务器修改。例如，数据可以根据办公室划分，如伦敦和巴黎，每一个办公室有一个服务器。如果查询有必要组合伦敦和巴黎的数据，一个应用可以查询两个服务器，或者可以使用主/备复制来在每一台服务器上保持其他办公室数据的一个只读拷贝。
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
<!--==========================orignal english content==========================
   <term>Multiple-Server Parallel Query Execution</term>
____________________________________________________________________________-->
   <term>多服务器并行查询执行</term>
   <listitem>

<!--==========================orignal english content==========================
    <para>
     Many of the above solutions allow multiple servers to handle multiple
     queries, but none allow a single query to use multiple servers to
     complete faster.  This solution allows multiple servers to work
     concurrently on a single query.  It is usually accomplished by
     splitting the data among servers and having each server execute its
     part of the query and return results to a central server where they
     are combined and returned to the user. This can be implemented using the
     <productname>PL/Proxy</productname> tool set.
    </para>
____________________________________________________________________________-->
    <para>
     上述的很多方案允许多个服务器来处理多个查询，但是没有一个允许一个单一查询使用多个服务器来更快完成。
     这种方案允许多个服务器在一个单一查询上并发工作。
     这通常通过把数据在服务器之间划分并且让每一个服务器执行该查询中属于它的部分，然后将结果返回给一个中心服务器，由它整合结果并发回给用户。
     这也可以使用<productname>PL/Proxy</productname>工具集来实现这种方案。
    </para>

   </listitem>
  </varlistentry>

 </variablelist>

<!--==========================orignal english content==========================
  <para>
   It should also be noted that because <productname>PostgreSQL</productname>
   is open source and easily extended, a number of companies have
   taken <productname>PostgreSQL</productname> and created commercial
   closed-source solutions with unique failover, replication, and load
   balancing capabilities.  These are not discussed here.
  </para>
____________________________________________________________________________-->
  <para>
   还需要注意的是由于<productname>PostgreSQL</productname>是开源的并且易于扩展，许多公司已经采用<productname>PostgreSQL</productname>并创建了具有独特的故障转移、复制和负载平衡功能的商业闭源解决方案。这里不讨论这些。
  </para>

 </sect1>


 <sect1 id="warm-standby">
<!--==========================orignal english content==========================
 <title>Log-Shipping Standby Servers</title>
____________________________________________________________________________-->
 <title>日志传送后备服务器</title>


<!--==========================orignal english content==========================
  <para>
   Continuous archiving can be used to create a <firstterm>high
   availability</firstterm> (HA) cluster configuration with one or more
   <firstterm>standby servers</firstterm> ready to take over operations if the
   primary server fails. This capability is widely referred to as
   <firstterm>warm standby</firstterm> or <firstterm>log shipping</firstterm>.
  </para>
____________________________________________________________________________-->
  <para>
   连续归档可以被用来创建一个<firstterm>高可用性</firstterm>（HA）集群配置，其中有一个或多个<firstterm>后备服务器</firstterm>随时准备在主服务器失效时接管操作。这种能力被广泛地称为<firstterm>温备</firstterm>或<firstterm>日志传送</firstterm>。
  </para>

<!--==========================orignal english content==========================
  <para>
   The primary and standby server work together to provide this capability,
   though the servers are only loosely coupled. The primary server operates
   in continuous archiving mode, while each standby server operates in
   continuous recovery mode, reading the WAL files from the primary. No
   changes to the database tables are required to enable this capability,
   so it offers low administration overhead compared to some other
   replication solutions. This configuration also has relatively low
   performance impact on the primary server.
  </para>
____________________________________________________________________________-->
  <para>
   主服务器和后备服务器一起工作来提供这种能力，但这些服务器只是松散地组织在一起。主服务器在连续归档模式下操作，而每一个后备服务器在连续恢复模式下操作并且持续从主服务器读取 WAL 文件。要启用这种能力不需要对数据库表做任何改动，因此它相对于其他复制方案降低了管理开销。这种配置对主服务器的性能影响也相对较低。
  </para>

<!--==========================orignal english content==========================
  <para>
   Directly moving WAL records from one database server to another
   is typically described as log shipping. <productname>PostgreSQL</productname>
   implements file-based log shipping by transferring WAL records
   one file (WAL segment) at a time. WAL files (16MB) can be
   shipped easily and cheaply over any distance, whether it be to an
   adjacent system, another system at the same site, or another system on
   the far side of the globe. The bandwidth required for this technique
   varies according to the transaction rate of the primary server.
   Record-based log shipping is more granular and streams WAL changes
   incrementally over a network connection (see <xref
   linkend="streaming-replication"/>).
  </para>
____________________________________________________________________________-->
  <para>
   直接从一个数据库服务器移动 WAL 记录到另一台服务器通常被描述为日志传送。<productname>PostgreSQL</productname>通过一次一文件（WAL 段）的 WAL 记录传输实现了基于文件的日志传送。不管 WAL 文件（16 MB）要被送到一个临近的系统、同一站点的另一个系统或是在地球遥远的另一端的一个系统上，它都可以在任何距离上被简单和便宜地传送。这种技术所需的带宽取根据主服务器的事务率而变化。基于记录的日志传送具有更细的粒度并且能够在网络连接上以流的方式增量传递 WAL 的改变（见<xref linkend="streaming-replication"/>）。
  </para>

<!--==========================orignal english content==========================
  <para>
   It should be noted that log shipping is asynchronous, i.e., the WAL
   records are shipped after transaction commit. As a result, there is a
   window for data loss should the primary server suffer a catastrophic
   failure; transactions not yet shipped will be lost.  The size of the
   data loss window in file-based log shipping can be limited by use of the
   <varname>archive_timeout</varname> parameter, which can be set as low
   as a few seconds.  However such a low setting will
   substantially increase the bandwidth required for file shipping.
   Streaming replication (see <xref linkend="streaming-replication"/>)
   allows a much smaller window of data loss.
  </para>
____________________________________________________________________________-->
  <para>
   需要注意的是日志传送是异步的，即 WAL 记录是在事务提交后才被传送。正因为如此，在一个窗口期内如果主服务器发生灾难性的失效则会导致数据丢失，还没有被传送的事务将会被丢失。基于文件的日志传送中这个数据丢失窗口的尺寸可以通过使用参数<varname>archive_timeout</varname>进行限制，它可以被设置成低至数秒。但是这样低的设置大体上会增加文件传送所需的带宽。流复制（见<xref linkend="streaming-replication"/>）允许更小的数据丢失窗口。
  </para>

<!--==========================orignal english content==========================
  <para>
   Recovery performance is sufficiently good that the standby will
   typically be only moments away from full
   availability once it has been activated. As a result, this is called
   a warm standby configuration which offers high
   availability. Restoring a server from an archived base backup and
   rollforward will take considerably longer, so that technique only
   offers a solution for disaster recovery, not high availability.
   A standby server can also be used for read-only queries, in which case
   it is called a Hot Standby server. See <xref linkend="hot-standby"/> for
   more information.
  </para>
____________________________________________________________________________-->
  <para>
   这种配置的恢复性能是足够好的，后备服务器在被激活后通常只有片刻就可以到达完全可用。因此，这被称为一种提供高可用性的温备配置。从一个已归档的基础备份恢复一个服务器并且前滚将需要较长时间，因此该技术只提供了灾难恢复的一种方案，而不适合于高可用性。一台后备服务器也可以被用于只读查询，在这种情况下它被称为一台热备服务器。更多信息请见<xref linkend="hot-standby"/>。
  </para>

<!--==========================orignal english content==========================
  <indexterm zone="high-availability">
   <primary>warm standby</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="high-availability">
   <primary>温备</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm zone="high-availability">
   <primary>PITR standby</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="high-availability">
   <primary>PITR standby</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm zone="high-availability">
   <primary>standby server</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="high-availability">
   <primary>后备服务器</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm zone="high-availability">
   <primary>log shipping</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="high-availability">
   <primary>日志传送</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm zone="high-availability">
   <primary>witness server</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="high-availability">
   <primary>witness server</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm zone="high-availability">
   <primary>STONITH</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="high-availability">
   <primary>STONITH</primary>
  </indexterm>

  <sect2 id="standby-planning">
<!--==========================orignal english content==========================
   <title>Planning</title>
____________________________________________________________________________-->
   <title>规划</title>

<!--==========================orignal english content==========================
   <para>
    It is usually wise to create the primary and standby servers
    so that they are as similar as possible, at least from the
    perspective of the database server.  In particular, the path names
    associated with tablespaces will be passed across unmodified, so both
    primary and standby servers must have the same mount paths for
    tablespaces if that feature is used.  Keep in mind that if
    <xref linkend="sql-createtablespace"/>
    is executed on the primary, any new mount point needed for it must
    be created on the primary and all standby servers before the command
    is executed. Hardware need not be exactly the same, but experience shows
    that maintaining two identical systems is easier than maintaining two
    dissimilar ones over the lifetime of the application and system.
    In any case the hardware architecture must be the same &mdash; shipping
    from, say, a 32-bit to a 64-bit system will not work.
   </para>
____________________________________________________________________________-->
   <para>
    创建主服务器和后备服务器通常是明智的，因此它们可以尽可能相似，至少从数据库服务器的角度来看是这样。特别地，与表空间相关的路径名将被未经修改地传递，因此如果该特性被使用，主、备服务器必须对表空间具有完全相同的挂载路径。记住如果<xref linkend="sql-createtablespace"/>在主服务器上被执行，在命令被执行前，它所需要的任何新挂载点必须在主服务器和所有后备服务器上先创建好。硬件不需要完全相同，但是经验显示，在应用和系统的生命期内维护两个相同的系统比维护两个不相似的系统更容易。在任何情况下硬件架构必须相同 &mdash; 从一个 32 位系统传送到一个 64 位系统将不会工作。
   </para>

<!--==========================orignal english content==========================
   <para>
    In general, log shipping between servers running different major
    <productname>PostgreSQL</productname> release
    levels is not possible. It is the policy of the PostgreSQL Global
    Development Group not to make changes to disk formats during minor release
    upgrades, so it is likely that running different minor release levels
    on primary and standby servers will work successfully. However, no
    formal support for that is offered and you are advised to keep primary
    and standby servers at the same release level as much as possible.
    When updating to a new minor release, the safest policy is to update
    the standby servers first &mdash; a new minor release is more likely
    to be able to read WAL files from a previous minor release than vice
    versa.
   </para>
____________________________________________________________________________-->
   <para>
    通常，不能在两个运行着不同主版本<productname>PostgreSQL</productname>的服务器之间传送日志。PostgreSQL 全球开发组的策略是不在次版本升级中改变磁盘格式，因此在主服务器和后备服务器上运行不同次版本将会成功地工作。不过，在这方面并没有提供正式的支持，因此我们建议让主备服务器上运行的版本尽可能相同。当升级到一个新的次版本时，最安全的策略是先升级后备服务器 &mdash; 一个新的次版本发行更可能兼容从前一个次版本读取 WAL 文件。
   </para>

  </sect2>

  <sect2 id="standby-server-operation" xreflabel="Standby Server Operation">
<!--==========================orignal english content==========================
   <title>Standby Server Operation</title>
____________________________________________________________________________-->
   <title>后备服务器操作</title>

<!--==========================orignal english content==========================
   <para>
    A server enters standby mode if a
    <anchor id="file-standby-signal" xreflabel="standby.signal"/>
    <filename>standby.signal</filename>
    <indexterm><primary><filename>standby.signal</filename></primary></indexterm>
    file exists in the data directory when the server is started.
   </para>
____________________________________________________________________________-->
   <para>
    服务器启动时，数据目录中存在<anchor id="file-standby-signal" xreflabel="standby.signal"/>
    <filename>standby.signal</filename>
    <indexterm><primary><filename>standby.signal</filename></primary></indexterm>文件，服务器进入standby模式。
   </para>
<!--==========================orignal english content==========================
   <para>
    In standby mode, the server continuously applies WAL received from the
    primary server. The standby server can read WAL from a WAL archive
    (see <xref linkend="guc-restore-command"/>) or directly from the primary
    over a TCP connection (streaming replication). The standby server will
    also attempt to restore any WAL found in the standby cluster's
    <filename>pg_wal</filename> directory. That typically happens after a server
    restart, when the standby replays again WAL that was streamed from the
    primary before the restart, but you can also manually copy files to
    <filename>pg_wal</filename> at any time to have them replayed.
   </para>
____________________________________________________________________________-->
   <para>
    在后备模式中，服务器持续地应用从主控服务器接收到的 WAL。后备服务器可以从一个 WAL 归档（<xref linkend="guc-restore-command"/>）或者通过一个 TCP 连接直接从主控机（流复制）读取 WAL。后备服务器将也尝试恢复在后备集簇的<filename>pg_wal</filename>目录中找到的 WAL。那通常在一次数据库重启后发生，那时后备机将在重启之前重播从主控机流过来的 WAL，但是你也可以在任何时候手动拷贝文件到<filename>pg_wal</filename>让它们被重播。
   </para>

<!--==========================orignal english content==========================
   <para>
    At startup, the standby begins by restoring all WAL available in the
    archive location, calling <varname>restore_command</varname>. Once it
    reaches the end of WAL available there and <varname>restore_command</varname>
    fails, it tries to restore any WAL available in the <filename>pg_wal</filename> directory.
    If that fails, and streaming replication has been configured, the
    standby tries to connect to the primary server and start streaming WAL
    from the last valid record found in archive or <filename>pg_wal</filename>. If that fails
    or streaming replication is not configured, or if the connection is
    later disconnected, the standby goes back to step 1 and tries to
    restore the file from the archive again. This loop of retries from the
    archive, <filename>pg_wal</filename>, and via streaming replication goes on until the server
    is stopped or failover is triggered by a trigger file.
   </para>
____________________________________________________________________________-->
   <para>
    在启动时，后备机通过恢复归档位置所有可用的 WAL 来开始，这称为<varname>restore_command</varname>。一旦它到达那里可用的 WAL 的末尾并且<varname>restore_command</varname>失败，它会尝试恢复<filename>pg_wal</filename>目录中可用的任何 WAL。如果那也失败并且流复制已被配置，后备机会尝试连接到主服务器并且从在归档或<filename>pg_wal</filename>中找到的最后一个可用记录开始流式传送 WAL。如果那失败并且没有配置流复制，或者该连接后来断开，后备机会返回到步骤 1 并且尝试再次从归档里的文件恢复。这种尝试归档、<filename>pg_wal</filename>和流复制的循环会一直重复知道服务器停止或者一个触发器文件触发了故障转移。
   </para>

<!--==========================orignal english content==========================
   <para>
    Standby mode is exited and the server switches to normal operation
    when <command>pg_ctl promote</command> is run,
    <function>pg_promote()</function> is called, or a trigger file is found
    (<varname>promote_trigger_file</varname>). Before failover,
    any WAL immediately available in the archive or in <filename>pg_wal</filename> will be
    restored, but no attempt is made to connect to the primary.
   </para>
____________________________________________________________________________-->
   <para>
    当<command>pg_ctl promote</command>被运行，<function>pg_promote()</function>被调用，或一个触发器文件被找到（<varname>promote_trigger_file</varname>），后备模式会退出并且服务器会切换到普通操作。
    在故障转移之前，在归档或<filename>pg_wal</filename>中立即可用的任何 WAL 将被恢复，但不会尝试连接到主控机。
   </para>
  </sect2>

  <sect2 id="preparing-primary-for-standby">
<!--==========================orignal english content==========================
   <title>Preparing the Primary for Standby Servers</title>
____________________________________________________________________________-->
   <title>为后备服务器准备主控机</title>

<!--==========================orignal english content==========================
   <para>
    Set up continuous archiving on the primary to an archive directory
    accessible from the standby, as described
    in <xref linkend="continuous-archiving"/>. The archive location should be
    accessible from the standby even when the primary is down, i.e., it should
    reside on the standby server itself or another trusted server, not on
    the primary server.
   </para>
____________________________________________________________________________-->
   <para>
    如<xref linkend="continuous-archiving"/>中所述，在主服务器上设置连续归档到一个后备服务器可访问的归档目录。即使主服务器垮掉该归档位置也应当是后备服务器可访问的，即它应当位于后备服务器本身或者另一个可信赖的服务器，而不是位于主控服务器上。
   </para>

<!--==========================orignal english content==========================
   <para>
    If you want to use streaming replication, set up authentication on the
    primary server to allow replication connections from the standby
    server(s); that is, create a role and provide a suitable entry or
    entries in <filename>pg_hba.conf</filename> with the database field set to
    <literal>replication</literal>.  Also ensure <varname>max_wal_senders</varname> is set
    to a sufficiently large value in the configuration file of the primary
    server. If replication slots will be used,
    ensure that <varname>max_replication_slots</varname> is set sufficiently
    high as well.
   </para>
____________________________________________________________________________-->
   <para>
    如果你想要使用流复制，在主服务器上设置认证来允许来自后备服务器的复制连接。即创建一个角色并且在<filename>pg_hba.conf</filename>中提供一个或多个数据库域被设置为<literal>replication</literal>的项。还要保证在主服务器的配置文件中<varname>max_wal_senders</varname>被设置为足够大的值。如果要使用复制槽，请确保<varname>max_replication_slots</varname>也被设置得足够高。
   </para>

<!--==========================orignal english content==========================
   <para>
    Take a base backup as described in <xref linkend="backup-base-backup"/>
    to bootstrap the standby server.
   </para>
____________________________________________________________________________-->
   <para>
    按<xref linkend="backup-base-backup"/>所述取得一个基础备份来引导后备服务器。
   </para>
  </sect2>

  <sect2 id="standby-server-setup">
<!--==========================orignal english content==========================
   <title>Setting Up a Standby Server</title>
____________________________________________________________________________-->
   <title>建立一个后备服务器</title>

<!--==========================orignal english content==========================
   <para>
    To set up the standby server, restore the base backup taken from primary
    server (see <xref linkend="backup-pitr-recovery"/>). Create a file
    <link linkend="file-standby-signal"><filename>standby.signal</filename></link><indexterm><primary>standby.signal</primary></indexterm>
    in the standby's cluster data
    directory. Set <xref linkend="guc-restore-command"/> to a simple command to copy files from
    the WAL archive. If you plan to have multiple standby servers for high
    availability purposes, make sure that <varname>recovery_target_timeline</varname> is set to
    <literal>latest</literal> (the default), to make the standby server follow the timeline change
    that occurs at failover to another standby.
   </para>
____________________________________________________________________________-->
   <para>
    要建立后备服务器，恢复从主服务器取得的基础备份（<xref linkend="backup-pitr-recovery"/>）。在后备服务器的集簇数据目录中创建一个文件<link linkend="file-standby-signal"><filename>standby.signal</filename></link><indexterm><primary>standby.signal</primary></indexterm>。将<xref linkend="guc-restore-command"/>设置为一个从 WAL 归档中复制文件的简单命令。
    如果你计划为了高可用性目的建立多个后备服务器，确认<varname>recovery_target_timeline</varname>被设置为<literal>latest</literal> (默认)来使得该后备服务器遵循发生在故障转移到另一个后备服务器之后发生的时间线改变。
   </para>

   <note>
<!--==========================orignal english content==========================
     <para>
     <xref linkend="guc-restore-command"/> should return immediately
     if the file does not exist; the server will retry the command again if
     necessary.
    </para>
____________________________________________________________________________-->
     <para>
     <xref linkend="guc-restore-command"/>应该立即返回，如果必要该服务器将再次尝试该命令。
    </para>
   </note>

<!--==========================orignal english content==========================
   <para>
     If you want to use streaming replication, fill in
     <xref linkend="guc-primary-conninfo"/> with a libpq connection string, including
     the host name (or IP address) and any additional details needed to
     connect to the primary server. If the primary needs a password for
     authentication, the password needs to be specified in
     <xref linkend="guc-primary-conninfo"/> as well.
   </para>
____________________________________________________________________________-->
   <para>
     如果你想要使用流复制，在<xref linkend="guc-primary-conninfo"/>中填入一个 libpq 连接字符串，其中包括主机名（或 IP 地址）和连接到主服务器所需的任何附加细节。如果主服务器需要一个口令用于认证，口令也应该被指定在<xref linkend="guc-primary-conninfo"/>中。
   </para>

<!--==========================orignal english content==========================
   <para>
    If you're setting up the standby server for high availability purposes,
    set up WAL archiving, connections and authentication like the primary
    server, because the standby server will work as a primary server after
    failover.
   </para>
____________________________________________________________________________-->
   <para>
    如果你正在为高性能目的建立后备服务器，像主服务器一样建立 WAL 归档、连接和认证，因为在故障转移后该后备服务器将作为一个主服务器工作。
   </para>

<!--==========================orignal english content==========================
   <para>
    If you're using a WAL archive, its size can be minimized using the <xref
    linkend="guc-archive-cleanup-command"/> parameter to remove files that are no
    longer required by the standby server.
    The <application>pg_archivecleanup</application> utility is designed specifically to
    be used with <varname>archive_cleanup_command</varname> in typical single-standby
    configurations, see <xref linkend="pgarchivecleanup"/>.
    Note however, that if you're using the archive for backup purposes, you
    need to retain files needed to recover from at least the latest base
    backup, even if they're no longer needed by the standby.
   </para>
____________________________________________________________________________-->
   <para>
    如果你正在使用一个 WAL 归档，可以使用<xref linkend="guc-archive-cleanup-command"/>参数来移除后备服务器不再需要的文件，这样可以最小化 WAL 归档的尺寸。<application>pg_archivecleanup</application>工具被特别设计为在典型单一后备配置下与<varname>archive_cleanup_command</varname>共同使用，见<xref linkend="pgarchivecleanup"/>。不过要注意，如果你正在为备份目的使用归档，有一些文件即使后备服务器不再需要你也需要保留它们，它们被用来从至少最后一个基础备份恢复。
   </para>

<!--==========================orignal english content==========================
   <para>
    A simple example of configuration is:
<programlisting>
primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass options=''-c wal_sender_timeout=5000'''
restore_command = 'cp /path/to/archive/%f %p'
archive_cleanup_command = 'pg_archivecleanup /path/to/archive %r'
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    配置的一个简单例子是：
<programlisting>
primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass options=''-c wal_sender_timeout=5000'''
restore_command = 'cp /path/to/archive/%f %p'
archive_cleanup_command = 'pg_archivecleanup /path/to/archive %r'
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    You can have any number of standby servers, but if you use streaming
    replication, make sure you set <varname>max_wal_senders</varname> high enough in
    the primary to allow them to be connected simultaneously.
   </para>
____________________________________________________________________________-->
   <para>
    你可以有任意数量的后备服务器，但是如果你使用流复制，确保你在主服务器上将<varname>max_wal_senders</varname>设置得足够高，这样可以允许它们能同时连接。
   </para>

  </sect2>

  <sect2 id="streaming-replication">
<!--==========================orignal english content==========================
   <title>Streaming Replication</title>
____________________________________________________________________________-->
   <title>流复制</title>

<!--==========================orignal english content==========================
   <indexterm zone="high-availability">
    <primary>Streaming Replication</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="high-availability">
    <primary>流复制</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    Streaming replication allows a standby server to stay more up-to-date
    than is possible with file-based log shipping. The standby connects
    to the primary, which streams WAL records to the standby as they're
    generated, without waiting for the WAL file to be filled.
   </para>
____________________________________________________________________________-->
   <para>
    流复制允许一台后备服务器比使用基于文件的日志传送更能保持为最新的状态。后备服务器连接到主服务器，主服务器则在 WAL 记录产生时即将它们以流式传送给后备服务器而不必等到 WAL 文件被填充。
   </para>

<!--==========================orignal english content==========================
   <para>
    Streaming replication is asynchronous by default
    (see <xref linkend="synchronous-replication"/>), in which case there is
    a small delay between committing a transaction in the primary and the
    changes becoming visible in the standby. This delay is however much
    smaller than with file-based log shipping, typically under one second
    assuming the standby is powerful enough to keep up with the load. With
    streaming replication, <varname>archive_timeout</varname> is not required to
    reduce the data loss window.
   </para>
____________________________________________________________________________-->
   <para>
    默认情况下流复制是异步的（见<xref linkend="synchronous-replication"/>），在这种情况下主服务器上提交一个事务与该变化在后备服务器上变得可见之间存在短暂的延迟。不过这种延迟比基于文件的日志传送方式中要小得多，在后备服务器的能力足以跟得上负载的前提下延迟通常低于一秒。在流复制中，不需要<varname>archive_timeout</varname>来缩减数据丢失窗口。
   </para>

<!--==========================orignal english content==========================
   <para>
    If you use streaming replication without file-based continuous
    archiving, the server might recycle old WAL segments before the standby
    has received them.  If this occurs, the standby will need to be
    reinitialized from a new base backup.  You can avoid this by setting
    <varname>wal_keep_size</varname> to a value large enough to ensure that
    WAL segments are not recycled too early, or by configuring a replication
    slot for the standby.  If you set up a WAL archive that's accessible from
    the standby, these solutions are not required, since the standby can
    always use the archive to catch up provided it retains enough segments.
   </para>
____________________________________________________________________________-->
   <para>
    如果你使用的流复制没有基于文件的连续归档，该服务器可能在后备机收到 WAL 段之
    前回收这些旧的 WAL 段。如果发生这种情况，后备机将需要重新从一个新的基础备
    份初始化。通过设置<varname>wal_keep_size</varname>为一个足够高的值来确保旧
    的 WAL 段不会被太早重用或者为后备机配置一个复制槽，可以避免发生这种情况。如
    果设置了一个后备机可以访问的 WAL 归档，就不需要这些解决方案，因为该归档可以
    为后备机保留足够的段，后备机总是可以使用该归档来追赶主控机。
   </para>

<!--==========================orignal english content==========================
   <para>
    To use streaming replication, set up a file-based log-shipping standby
    server as described in <xref linkend="warm-standby"/>. The step that
    turns a file-based log-shipping standby into streaming replication
    standby is setting the <varname>primary_conninfo</varname> setting
    to point to the primary server. Set
    <xref linkend="guc-listen-addresses"/> and authentication options
    (see <filename>pg_hba.conf</filename>) on the primary so that the standby server
    can connect to the <literal>replication</literal> pseudo-database on the primary
    server (see <xref linkend="streaming-replication-authentication"/>).
   </para>
____________________________________________________________________________-->
   <para>
    要使用流复制，按<xref linkend="warm-standby"/>所述建立一个基于文件的日志传送后备服务器。将一个基于文件日志传送后备服务器转变成流复制后备服务器的步骤是把<filename>recovery.conf</filename>文件中的设置以指向主服务器。设置主服务器上的<xref linkend="guc-listen-addresses"/>和认证选项（见<filename>pg_hba.conf</filename>），这样后备服务器可以连接到主服务器上的伪数据库<literal>replication</literal>（见<xref linkend="streaming-replication-authentication"/>）。
   </para>

<!--==========================orignal english content==========================
   <para>
    On systems that support the keepalive socket option, setting
    <xref linkend="guc-tcp-keepalives-idle"/>,
    <xref linkend="guc-tcp-keepalives-interval"/> and
    <xref linkend="guc-tcp-keepalives-count"/> helps the primary promptly
    notice a broken connection.
   </para>
____________________________________________________________________________-->
   <para>
    在支持 keepalive 套接字选项的系统上，设置<xref linkend="guc-tcp-keepalives-idle"/>、<xref linkend="guc-tcp-keepalives-interval"/>和<xref linkend="guc-tcp-keepalives-count"/>有助于主服务器迅速地注意到一个断开的连接。
   </para>

<!--==========================orignal english content==========================
   <para>
    Set the maximum number of concurrent connections from the standby servers
    (see <xref linkend="guc-max-wal-senders"/> for details).
   </para>
____________________________________________________________________________-->
   <para>
    设置来自后备服务器的并发连接的最大数目（详见<xref linkend="guc-max-wal-senders"/>）。
   </para>

<!--==========================orignal english content==========================
   <para>
    When the standby is started and <varname>primary_conninfo</varname> is set
    correctly, the standby will connect to the primary after replaying all
    WAL files available in the archive. If the connection is established
    successfully, you will see a <literal>walreceiver</literal> in the standby, and
    a corresponding <literal>walsender</literal> process in the primary.
   </para>
____________________________________________________________________________-->
   <para>
    当后备服务器被启动并且<varname>primary_conninfo</varname>被正确设置，后备服务器将在重放完归档中所有可用的 WAL 文件之后连接到主服务器。
    如果连接被成功建立，你将在后备服务器中看到一个 <literal>walreceiver</literal>，并且在主服务器中有一个相应的 <literal>walsender</literal> 进程。
   </para>

   <sect3 id="streaming-replication-authentication">
<!--==========================orignal english content==========================
    <title>Authentication</title>
____________________________________________________________________________-->
    <title>认证</title>
<!--==========================orignal english content==========================
    <para>
     It is very important that the access privileges for replication be set up
     so that only trusted users can read the WAL stream, because it is
     easy to extract privileged information from it.  Standby servers must
     authenticate to the primary as an account that has the
     <literal>REPLICATION</literal> privilege or a superuser. It is
     recommended to create a dedicated user account with
     <literal>REPLICATION</literal> and <literal>LOGIN</literal>
     privileges for replication. While <literal>REPLICATION</literal>
     privilege gives very high permissions, it does not allow the user to
     modify any data on the primary system, which the
     <literal>SUPERUSER</literal> privilege does.
    </para>
____________________________________________________________________________-->
    <para>
     设置好用于复制的访问权限非常重要，这样只有受信的用户可以读取 WAL 流，因为很容易从 WAL 流中抽取出需要特权才能访问的信息。
     后备服务器必须作为一个具有<literal>REPLICATION</literal>特权的账户或一个超级用户来向主服务器认证。
     推荐为复制创建一个专用的具有<literal>REPLICATION</literal>和<literal>LOGIN</literal>特权的用户账户。
     虽然<literal>REPLICATION</literal>特权给出了非常高的权限，但它不允许用户修改主系统上的任何数据，而<literal>SUPERUSER</literal>特权则可以。
    </para>

<!--==========================orignal english content==========================
    <para>
     Client authentication for replication is controlled by a
     <filename>pg_hba.conf</filename> record specifying <literal>replication</literal> in the
     <replaceable>database</replaceable> field. For example, if the standby is running on
     host IP <literal>192.168.1.100</literal> and the account name for replication
     is <literal>foo</literal>, the administrator can add the following line to the
     <filename>pg_hba.conf</filename> file on the primary:

<programlisting>
# Allow the user "foo" from host 192.168.1.100 to connect to the primary
# as a replication standby if the user's password is correctly supplied.
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    replication     foo             192.168.1.100/32        md5
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     复制的客户端认证由一个在<replaceable>database</replaceable>域中指定<literal>replication</literal>的<filename>pg_hba.conf</filename>记录控制。例如，如果后备服务器运行在主机 IP <literal>192.168.1.100</literal>并且用于复制的账户名为<literal>foo</literal>，管理员可以在主服务器上向<filename>pg_hba.conf</filename>文件增加下列行：

<programlisting>
# 允许来自 192.168.1.100 的用户 "foo" 在提供了正确的口令时作为一个
# 复制后备机连接到主控机。
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    replication     foo             192.168.1.100/32        md5
</programlisting>
    </para>
<!--==========================orignal english content==========================
    <para>
     The host name and port number of the primary, connection user name,
     and password are specified in the <xref linkend="guc-primary-conninfo"/>.
     The password can also be set in the <filename>~/.pgpass</filename> file on the
     standby (specify <literal>replication</literal> in the <replaceable>database</replaceable>
     field).
     For example, if the primary is running on host IP <literal>192.168.1.50</literal>,
     port <literal>5432</literal>, the account name for replication is
     <literal>foo</literal>, and the password is <literal>foopass</literal>, the administrator
     can add the following line to the <filename>postgresql.conf</filename> file on the
     standby:

<programlisting>
# The standby connects to the primary that is running on host 192.168.1.50
# and port 5432 as the user "foo" whose password is "foopass".
primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass'
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     主服务器的主机名和端口号、连接用户名和口令在<xref linkend="guc-primary-conninfo"/>中指定。在后备服务器上还可以在<filename>~/.pgpass</filename>文件中设置口令（在<replaceable>database</replaceable>域中指定<literal>replication</literal>）。例如，如果主服务器运行在主机 IP <literal>192.168.1.50</literal>、端口<literal>5432</literal>上，并且口令为<literal>foopass</literal>，管理员可以在后备服务器的<filename>postgresql.conf</filename>文件中增加下列行：

<programlisting>
# 后备机要连接到的主控机运行在主机 192.168.1.50 上，
# 端口号是 5432，连接所用的用户名是 "foo"，口令是 "foopass"。
primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass'
</programlisting>
    </para>
   </sect3>

   <sect3 id="streaming-replication-monitoring">
<!--==========================orignal english content==========================
    <title>Monitoring</title>
____________________________________________________________________________-->
    <title>监控</title>
<!--==========================orignal english content==========================
    <para>
     An important health indicator of streaming replication is the amount
     of WAL records generated in the primary, but not yet applied in the
     standby. You can calculate this lag by comparing the current WAL write
     location on the primary with the last WAL location received by the
     standby. These locations can be retrieved using
     <function>pg_current_wal_lsn</function> on the primary and
     <function>pg_last_wal_receive_lsn</function> on the standby,
     respectively (see <xref linkend="functions-admin-backup-table"/> and
     <xref linkend="functions-recovery-info-table"/> for details).
     The last WAL receive location in the standby is also displayed in the
     process status of the WAL receiver process, displayed using the
     <command>ps</command> command (see <xref linkend="monitoring-ps"/> for details).
    </para>
____________________________________________________________________________-->
    <para>
     流复制的一个重要健康指标是在主服务器上产生但还没有在后备服务器上应用的 WAL 记录数。你可以通过比较主服务器上的当前 WAL 写位置和后备服务器接收到的最后一个 WAL 位置来计算这个滞后量。这些位置分别可以用主服务器上的<function>pg_current_wal_lsn</function>和后备服务器上的<function>pg_last_wal_receive_lsn</function>来检索（详见<xref linkend="functions-admin-backup-table"/>和<xref linkend="functions-recovery-info-table"/>）。后备服务器的最后 WAL 接收位置也被显示在 WAL 接收者进程的进程状态中，即使用<command>ps</command>命令显示的状态（详见<xref linkend="monitoring-ps"/>）。
    </para>
<!--==========================orignal english content==========================
    <para>
     You can retrieve a list of WAL sender processes via the
     <link linkend="monitoring-pg-stat-replication-view"><structname>
     pg_stat_replication</structname></link> view. Large differences between
     <function>pg_current_wal_lsn</function> and the view's <literal>sent_lsn</literal> field
     might indicate that the primary server is under heavy load, while
     differences between <literal>sent_lsn</literal> and
     <function>pg_last_wal_receive_lsn</function> on the standby might indicate
     network delay, or that the standby is under heavy load.
    </para>
____________________________________________________________________________-->
    <para>
     你可以通过<link linkend="monitoring-pg-stat-replication-view"><structname>pg_stat_replication</structname></link>视图检索 WAL 发送者进程的列表。
     <function>pg_current_wal_lsn</function>与<literal>sent_lsn</literal>域之间的巨大差异表示主服务器承受着巨大的负载，而<literal>sent_lsn</literal>和后备服务器上<function>pg_last_wal_receive_lsn</function>之间的差异可能表示网络延迟或者后备服务器正承受着巨大的负载。
    </para>
<!--==========================orignal english content==========================
    <para>
     On a hot standby, the status of the WAL receiver process can be retrieved
     via the <link linkend="monitoring-pg-stat-wal-receiver-view">
     <structname>pg_stat_wal_receiver</structname></link> view.  A large
     difference between <function>pg_last_wal_replay_lsn</function> and the
     view's <literal>flushed_lsn</literal> indicates that WAL is being
     received faster than it can be replayed.
    </para>
____________________________________________________________________________-->
    <para>
     在一台热后备上，WAL接收者进程的状态可以通过<link linkend="monitoring-pg-stat-wal-receiver-view">
     <structname>pg_stat_wal_receiver</structname></link>视图检索到。
     <function>pg_last_wal_replay_lsn</function>和该视图的<literal>flushed_lsn</literal>的差别表示WAL的接收速度大于它被重放的速度。
    </para>
   </sect3>
  </sect2>

  <sect2 id="streaming-replication-slots">
<!--==========================orignal english content==========================
   <title>Replication Slots</title>
____________________________________________________________________________-->
   <title>复制槽</title>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>replication slot</primary>
    <secondary>streaming replication</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>复制槽</primary>
    <secondary>流复制</secondary>
   </indexterm>
<!--==========================orignal english content==========================
   <para>
    Replication slots provide an automated way to ensure that the primary does
    not remove WAL segments until they have been received by all standbys,
    and that the primary does not remove rows which could cause a
    <link linkend="hot-standby-conflict">recovery conflict</link> even when the
    standby is disconnected.
   </para>
____________________________________________________________________________-->
   <para>
    复制槽提供了一种自动化的方法来确保主控机在所有的后备机收到 WAL 段
    之前不会移除它们，并且主控机也不会移除可能导致<link linkend="hot-standby-conflict">
    恢复冲突</link>的行，即使后备机断开也是如此。
   </para>
<!--==========================orignal english content==========================
   <para>
    In lieu of using replication slots, it is possible to prevent the removal
    of old WAL segments using <xref linkend="guc-wal-keep-size"/>, or by
    storing the segments in an archive using
    <xref linkend="guc-archive-command"/>.
    However, these methods often result in retaining more WAL segments than
    required, whereas replication slots retain only the number of segments
    known to be needed.  On the other hand, replication slots can retain so
    many WAL segments that they fill up the space allocated
    for <literal>pg_wal</literal>;
    <xref linkend="guc-max-slot-wal-keep-size"/> limits the size of WAL files
    retained by replication slots.
   </para>
____________________________________________________________________________-->
   <para>
    作为复制槽的替代，也可以使用<xref linkend="guc-wal-keep-size"/>阻止移除旧的 WAL 段，或者使用<xref linkend="guc-archive-command"/>把段保存在一个归档中。
    不过，这些方法常常会导致保留的 WAL 段比需要的更多，而复制槽只保留已知所需要的段。
    另一方面，复制槽可以保留很多的WAL段以至于它们填满了分配给<literal>pg_wal</literal>的空间；
    <xref linkend="guc-max-slot-wal-keep-size"/>限制复制槽所保留的WAL文件的大小。
   </para>
<!--==========================orignal english content==========================
   <para>
    Similarly, <xref linkend="guc-hot-standby-feedback"/>
    and <xref linkend="guc-vacuum-defer-cleanup-age"/> provide protection against
    relevant rows being removed by vacuum, but the former provides no
    protection during any time period when the standby is not connected,
    and the latter often needs to be set to a high value to provide adequate
    protection.  Replication slots overcome these disadvantages.
   </para>
____________________________________________________________________________-->
   <para>
    类似地，<xref linkend="guc-hot-standby-feedback"/>和
    <xref linkend="guc-vacuum-defer-cleanup-age"/>保护了相关行不被 vacuum
    移除，但是前者在后备机断开期间无法提供保护，而后者则需要被设置为一个很高
    的值已提供足够的保护。复制槽克服了这些缺点。
   </para>
   <sect3 id="streaming-replication-slots-manipulation">
<!--==========================orignal english content==========================
    <title>Querying and Manipulating Replication Slots</title>
____________________________________________________________________________-->
    <title>查询和操纵复制槽</title>
<!--==========================orignal english content==========================
    <para>
     Each replication slot has a name, which can contain lower-case letters,
     numbers, and the underscore character.
    </para>
____________________________________________________________________________-->
    <para>
     每个复制槽都有一个名字，名字可以包含小写字母、数字和下划线字符。
    </para>
<!--==========================orignal english content==========================
    <para>
     Existing replication slots and their state can be seen in the
     <link linkend="view-pg-replication-slots"><structname>pg_replication_slots</structname></link>
     view.
    </para>
____________________________________________________________________________-->
    <para>
     已有的复制槽和它们的状态可以在
     <link linkend="view-pg-replication-slots"><structname>pg_replication_slots</structname></link>
     视图中看到。
    </para>
<!--==========================orignal english content==========================
    <para>
     Slots can be created and dropped either via the streaming replication
     protocol (see <xref linkend="protocol-replication"/>) or via SQL
     functions (see <xref linkend="functions-replication"/>).
    </para>
____________________________________________________________________________-->
    <para>
     槽可以通过流复制协议（见<xref linkend="protocol-replication"/>）
     或者 SQL 函数（见<xref linkend="functions-replication"/>）创建并且移除。
    </para>
   </sect3>
   <sect3 id="streaming-replication-slots-config">
<!--==========================orignal english content==========================
    <title>Configuration Example</title>
____________________________________________________________________________-->
    <title>配置实例</title>
<!--==========================orignal english content==========================
    <para>
     You can create a replication slot like this:
<programlisting>
postgres=# SELECT * FROM pg_create_physical_replication_slot('node_a_slot');
  slot_name  | lsn
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-
 node_a_slot |

postgres=# SELECT slot_name, slot_type, active FROM pg_replication_slots;
  slot_name  | slot_type | active 
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;
 node_a_slot | physical  | f
(1 row)
</programlisting>
     To configure the standby to use this slot, <varname>primary_slot_name</varname>
     should be configured on the standby. Here is a simple example:
<programlisting>
primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass'
primary_slot_name = 'node_a_slot'
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     你可以这样创建一个复制槽：
<programlisting>
postgres=# SELECT * FROM pg_create_physical_replication_slot('node_a_slot');
  slot_name  | lsn
-------------+-----
 node_a_slot |

postgres=# SELECT slot_name, slot_type, active FROM pg_replication_slots;
  slot_name  | slot_type | active 
-------------+-----------+--------
 node_a_slot | physical  | f
(1 row)
</programlisting>
     要配置后备机使用这个槽，在后备机中应该配置<varname>primary_slot_name</varname>。这里是一个简单的例子：
<programlisting>

primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass'
primary_slot_name = 'node_a_slot'
</programlisting>
    </para>
   </sect3>
  </sect2>

  <sect2 id="cascading-replication">
<!--==========================orignal english content==========================
   <title>Cascading Replication</title>
____________________________________________________________________________-->
   <title>级联复制</title>

<!--==========================orignal english content==========================
   <indexterm zone="high-availability">
    <primary>Cascading Replication</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="high-availability">
    <primary>级联复制</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The cascading replication feature allows a standby server to accept replication
    connections and stream WAL records to other standbys, acting as a relay.
    This can be used to reduce the number of direct connections to the primary
    and also to minimize inter-site bandwidth overheads.
   </para>
____________________________________________________________________________-->
   <para>
    级联复制特性允许一台后备服务器接收复制连接并且把 WAL 记录流式传送给其他后备服务器，就像一个转发器一样。这可以被用来减小对于主控机的直接连接数并且使得站点间的带宽开销最小化。
   </para>

<!--==========================orignal english content==========================
   <para>
    A standby acting as both a receiver and a sender is known as a cascading
    standby.  Standbys that are more directly connected to the primary are known
    as upstream servers, while those standby servers further away are downstream
    servers.  Cascading replication does not place limits on the number or
    arrangement of downstream servers, though each standby connects to only
    one upstream server which eventually links to a single primary server.
   </para>
____________________________________________________________________________-->
   <para>
    一台同时扮演着接收者和发送者角色的后备服务器被称为一台级联后备服务器。“更直接”（通过更少的级联后备服务器）连接到主控机的后备服务器被称为上游服务器，而那些离得更远的后备服务器被称为下游服务器。级联复制并没有对下游服务器的数量或布置设定限制。
   </para>

<!--==========================orignal english content==========================
   <para>
    A cascading standby sends not only WAL records received from the
    primary but also those restored from the archive. So even if the replication
    connection in some upstream connection is terminated, streaming replication
    continues downstream for as long as new WAL records are available.
   </para>
____________________________________________________________________________-->
   <para>
    一台级联后备服务器不仅仅发送从主控机接收到的 WAL 记录，还要发送那些从归档中恢复的记录。因此即使某些上游连接中的复制连接被中断，只要还有新的 WAL 记录可用，下游的流复制都会继续下去。
   </para>

<!--==========================orignal english content==========================
   <para>
    Cascading replication is currently asynchronous. Synchronous replication
    (see <xref linkend="synchronous-replication"/>) settings have no effect on
    cascading replication at present.
   </para>
____________________________________________________________________________-->
   <para>
    级联复制目前是异步的。同步复制（见<xref linkend="synchronous-replication"/>）设置当前对级联复制无影响。
   </para>

<!--==========================orignal english content==========================
   <para>
    Hot Standby feedback propagates upstream, whatever the cascaded arrangement.
   </para>
____________________________________________________________________________-->
   <para>
    不管在什么样的级联布置中，热备反馈都会向上游传播。
   </para>

<!--==========================orignal english content==========================
   <para>
    If an upstream standby server is promoted to become the new primary, downstream
    servers will continue to stream from the new primary if
    <varname>recovery_target_timeline</varname> is set to <literal>'latest'</literal> (the default).
   </para>
____________________________________________________________________________-->
   <para>
    如果一台上游后备服务器被提升为新的主控机，且下游服务器的<varname>recovery_target_timeline</varname>被设置成<literal>'latest'</literal>(默认)，下游服务器将继续从新的主控机得到流。
   </para>

<!--==========================orignal english content==========================
   <para>
    To use cascading replication, set up the cascading standby so that it can
    accept replication connections (that is, set
    <xref linkend="guc-max-wal-senders"/> and <xref linkend="guc-hot-standby"/>,
    and configure
    <link linkend="auth-pg-hba-conf">host-based authentication</link>).
    You will also need to set <varname>primary_conninfo</varname> in the downstream
    standby to point to the cascading standby.
   </para>
____________________________________________________________________________-->
   <para>
    要使用级联复制，要建立级联后备服务器让它能够接受复制连接（即设置<xref linkend="guc-max-wal-senders"/>和<xref linkend="guc-hot-standby"/>，并且配置<link linkend="auth-pg-hba-conf">基于主机的认证</link>）。你还将需要设置下游后备服务器中的<varname>primary_conninfo</varname>指向级联后备服务器。
   </para>
  </sect2>

  <sect2 id="synchronous-replication">
<!--==========================orignal english content==========================
   <title>Synchronous Replication</title>
____________________________________________________________________________-->
   <title>同步复制</title>

<!--==========================orignal english content==========================
   <indexterm zone="high-availability">
    <primary>Synchronous Replication</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="high-availability">
    <primary>同步复制</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</productname> streaming replication is asynchronous by
    default. If the primary server
    crashes then some transactions that were committed may not have been
    replicated to the standby server, causing data loss. The amount
    of data loss is proportional to the replication delay at the time of
    failover.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>流复制默认是异步的。如果主服务器崩溃，则某些已被提交的事务可能还没有被复制到后备服务器，这会导致数据丢失。数据的丢失量与故障转移时的复制延迟成比例。
   </para>

<!--==========================orignal english content==========================
   <para>
    Synchronous replication offers the ability to confirm that all changes
    made by a transaction have been transferred to one or more synchronous
    standby servers. This extends that standard level of durability
    offered by a transaction commit. This level of protection is referred
    to as 2-safe replication in computer science theory, and group-1-safe
    (group-safe and 1-safe) when <varname>synchronous_commit</varname> is set to
    <literal>remote_write</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    同步复制能够保证一个事务的所有修改都能被传送到一台或者多台同步后备服务器。这扩大了由一次事务提交所提供的标准持久化级别。在计算机科学理论中这种保护级别被称为 2-safe 复制。而当<varname>synchronous_commit</varname>被设置为<literal>remote_write</literal>时，则是 group-1-safe （group-safe 和 1-safe）。
   </para>

<!--==========================orignal english content==========================
   <para>
    When requesting synchronous replication, each commit of a
    write transaction will wait until confirmation is
    received that the commit has been written to the write-ahead log on disk
    of both the primary and standby server. The only possibility that data
    can be lost is if both the primary and the standby suffer crashes at the
    same time. This can provide a much higher level of durability, though only
    if the sysadmin is cautious about the placement and management of the two
    servers.  Waiting for confirmation increases the user's confidence that the
    changes will not be lost in the event of server crashes but it also
    necessarily increases the response time for the requesting transaction.
    The minimum wait time is the round-trip time between primary to standby.
   </para>
____________________________________________________________________________-->
   <para>
    在请求同步复制时，一个写事务的每次提交将一直等待，直到收到一个确认表明该提交在主服务器和后备服务器上都已经被写入到磁盘上的预写式日志中。数据会被丢失的唯一可能性是主服务器和后备服务器在同一时间都崩溃。这可以提供更高级别的持久性，尽管只有系统管理员要关系两台服务器的放置和管理。等待确认提高了用户对于修改不会丢失的信心，但是同时也不必要地增加了对请求事务的响应时间。最小等待时间是在主服务器和后备服务器之间的来回时间。
   </para>

<!--==========================orignal english content==========================
   <para>
    Read-only transactions and transaction rollbacks need not wait for
    replies from standby servers. Subtransaction commits do not wait for
    responses from standby servers, only top-level commits. Long
    running actions such as data loading or index building do not wait
    until the very final commit message. All two-phase commit actions
    require commit waits, including both prepare and commit.
   </para>
____________________________________________________________________________-->
   <para>
    只读事务和事务回滚不需要等待后备服务器的回复。子事务提交也不需要等待后备服务器的响应，只有顶层提交才需要等待。长时间运行的动作（如数据载入或索引构建）不会等待最后的提交消息。所有两阶段提交动作要求提交等待，包括预备和提交。
   </para>

<!--==========================orignal english content==========================
   <para>
    A synchronous standby can be a physical replication standby or a logical
    replication subscriber.  It can also be any other physical or logical WAL
    replication stream consumer that knows how to send the appropriate
    feedback messages.  Besides the built-in physical and logical replication
    systems, this includes special programs such
    as <command>pg_receivewal</command> and <command>pg_recvlogical</command>
    as well as some third-party replication systems and custom programs.
    Check the respective documentation for details on synchronous replication
    support.
   </para>
____________________________________________________________________________-->
   <para>
    同步后备可以是物理复制后备或者是逻辑复制订阅者。它还可以是任何其他物理或者逻辑WAL复制流的消费者，它懂得如何发送恰当的反馈消息。除内建的物理和逻辑复制系统之外，还包括<command>pg_receivewal</command>和<command>pg_recvlogical</command>之类的特殊程序，以及一些第三方复制系统和定制程序。同步复制支持的细节请查看相应的文档。
   </para>

   <sect3 id="synchronous-replication-config">
<!--==========================orignal english content==========================
    <title>Basic Configuration</title>
____________________________________________________________________________-->
    <title>基本配置</title>

<!--==========================orignal english content==========================
   <para>
    Once streaming replication has been configured, configuring synchronous
    replication requires only one additional configuration step:
    <xref linkend="guc-synchronous-standby-names"/> must be set to
    a non-empty value.  <varname>synchronous_commit</varname> must also be set to
    <literal>on</literal>, but since this is the default value, typically no change is
    required.  (See <xref linkend="runtime-config-wal-settings"/> and
    <xref linkend="runtime-config-replication-primary"/>.)
    This configuration will cause each commit to wait for
    confirmation that the standby has written the commit record to durable
    storage.
    <varname>synchronous_commit</varname> can be set by individual
    users, so it can be configured in the configuration file, for particular
    users or databases, or dynamically by applications, in order to control
    the durability guarantee on a per-transaction basis.
   </para>
____________________________________________________________________________-->
   <para>
    一旦流复制已经被配置，配置同步复制就只需要一个额外的配置步骤：<xref linkend="guc-synchronous-standby-names"/>必须被设置为一个非空值。<varname>synchronous_commit</varname>也必须被设置为<literal>on</literal>，但由于这是默认值，通常不需要改变（见<xref linkend="runtime-config-wal-settings"/>和<xref linkend="runtime-config-replication-primary"/>）。这样的配置将导致每一次提交都等待确认消息，以保证后备服务器已经将提交记录写入到持久化存储中。<varname>synchronous_commit</varname>可以由个体用户设置，因此它可以在配置文件中配置、可以为特定用户或数据库配置或者由应用动态配置，这样可以在一种每事务基础上控制持久性保证。
   </para>

<!--==========================orignal english content==========================
   <para>
    After a commit record has been written to disk on the primary, the
    WAL record is then sent to the standby. The standby sends reply
    messages each time a new batch of WAL data is written to disk, unless
    <varname>wal_receiver_status_interval</varname> is set to zero on the standby.
    In the case that <varname>synchronous_commit</varname> is set to
    <literal>remote_apply</literal>, the standby sends reply messages when the commit
    record is replayed, making the transaction visible.
    If the standby is chosen as a synchronous standby, according to the setting
    of <varname>synchronous_standby_names</varname> on the primary, the reply
    messages from that standby will be considered along with those from other
    synchronous standbys to decide when to release transactions waiting for
    confirmation that the commit record has been received. These parameters
    allow the administrator to specify which standby servers should be
    synchronous standbys. Note that the configuration of synchronous
    replication is mainly on the primary. Named standbys must be directly
    connected to the primary; the primary knows nothing about downstream
    standby servers using cascaded replication.
   </para>
____________________________________________________________________________-->
   <para>
    在一个提交记录已经在主服务器上被写入到磁盘后，WAL 记录接着被发送到后备服务器。每次一批新的 WAL 数据被写入到磁盘后，后备服务器会发送回复消息，除非在后备服务器上<varname>wal_receiver_status_interval</varname>被设置为零。如果<varname>synchronous_commit</varname>被设置为<literal>remote_apply</literal>，当提交记录被重放时后备服务器会发送回应消息，这会让该事务变得可见。如果根据主服务器的<varname>synchronous_standby_names</varname>设置选中该后备服务器作为一个同步后备，将会根据来自该后备服务器和其他同步后备的回应消息来决定何时释放正在等待确认提交记录被收到的事务。这些参数允许管理员指定哪些后备服务器应该是同步后备。注意同步复制的配置主要在主控机上。命名的后备服务器必须直接连接到主控机，主控机对使用级联复制的下游后备服务器一无所知。
   </para>

<!--==========================orignal english content==========================
   <para>
    Setting <varname>synchronous_commit</varname> to <literal>remote_write</literal> will
    cause each commit to wait for confirmation that the standby has received
    the commit record and written it out to its own operating system, but not
    for the data to be flushed to disk on the standby.  This
    setting provides a weaker guarantee of durability than <literal>on</literal>
    does: the standby could lose the data in the event of an operating system
    crash, though not a <productname>PostgreSQL</productname> crash.
    However, it's a useful setting in practice
    because it can decrease the response time for the transaction.
    Data loss could only occur if both the primary and the standby crash and
    the database of the primary gets corrupted at the same time.
   </para>
____________________________________________________________________________-->
   <para>
    将<varname>synchronous_commit</varname>设置为<literal>remote_write</literal>将导致每次提交都等待后备服务器已经接收提交记录并将它写出到其自身所在的操作系统的确认，但并非等待数据都被刷出到后备服务器上的磁盘。这种设置提供了比<literal>on</literal>要弱一点的持久性保障：在一次操作系统崩溃事件中后备服务器可能丢失数据，尽管它不是一次<productname>PostgreSQL</productname>崩溃。不过，在实际中它是一种有用的设置，因为它可以减少事务的响应时间。只有当主服务器和后备服务器都崩溃并且主服务器的数据库同时被损坏的情况下，数据丢失才会发生。
   </para>

<!--==========================orignal english content==========================
   <para>
    Setting <varname>synchronous_commit</varname> to <literal>remote_apply</literal> will
    cause each commit to wait until the current synchronous standbys report
    that they have replayed the transaction, making it visible to user
    queries.  In simple cases, this allows for load balancing with causal
    consistency.
   </para>
____________________________________________________________________________-->
   <para>
    把<varname>synchronous_commit</varname>设置为<literal>remote_apply</literal>将导致每一次提交都会等待，直到当前的同步后备服务器报告说它们已经重放了该事务，这样就会使该事务对用户查询可见。在简单的情况下，这为带有因果一致性的负载均衡留出了余地。
   </para>

<!--==========================orignal english content==========================
   <para>
    Users will stop waiting if a fast shutdown is requested.  However, as
    when using asynchronous replication, the server will not fully
    shutdown until all outstanding WAL records are transferred to the currently
    connected standby servers.
   </para>
____________________________________________________________________________-->
   <para>
    如果请求一次快速关闭，用户将停止等待。不过，在使用异步复制时，在所有未解决的 WAL 记录被传输到当前连接的后备服务器之前，服务器将不会完全关闭。
   </para>

   </sect3>

   <sect3 id="synchronous-replication-multiple-standbys">
<!--==========================orignal english content==========================
    <title>Multiple Synchronous Standbys</title>
____________________________________________________________________________-->
    <title>多个同步后备</title>

<!--==========================orignal english content==========================
   <para>
    Synchronous replication supports one or more synchronous standby servers;
    transactions will wait until all the standby servers which are considered
    as synchronous confirm receipt of their data. The number of synchronous
    standbys that transactions must wait for replies from is specified in
    <varname>synchronous_standby_names</varname>. This parameter also specifies
    a list of standby names and the method (<literal>FIRST</literal> and
    <literal>ANY</literal>) to choose synchronous standbys from the listed ones.
   </para>
____________________________________________________________________________-->
   <para>
    同步复制支持一个或者更多个同步后备服务器，事务将会等待，直到所有同步后备服务器都确认收到了它们的数据为止。事务必须等待其回复的同步后备的数量由<varname>synchronous_standby_names</varname>指定。这个参数还指定一个后备服务器名称及方法（<literal>FIRST</literal>和<literal>ANY</literal>）的列表来从列出的后备中选取同步后备。
   </para>
<!--==========================orignal english content==========================
   <para>
    The method <literal>FIRST</literal> specifies a priority-based synchronous
    replication and makes transaction commits wait until their WAL records are
    replicated to the requested number of synchronous standbys chosen based on
    their priorities. The standbys whose names appear earlier in the list are
    given higher priority and will be considered as synchronous. Other standby
    servers appearing later in this list represent potential synchronous
    standbys. If any of the current synchronous standbys disconnects for
    whatever reason, it will be replaced immediately with the
    next-highest-priority standby.
   </para>
____________________________________________________________________________-->
   <para>
    方法<literal>FIRST</literal>指定一种基于优先的同步复制并且让事务提交等待，直到它们的WAL记录被复制到基于优先级选中的所要求数量的同步后备上为止。在列表中出现较早的后备被给予较高的优先级，并且将被考虑为同步后备。其他在这个列表中位置靠后的后备服务器表示可能的同步后备。如果任何当前的同步后备由于任何原因断开连接，它将立刻被下一个最高优先级的后备所替代。
   </para>
<!--==========================orignal english content==========================
   <para>
    An example of <varname>synchronous_standby_names</varname> for
    a priority-based multiple synchronous standbys is:
<programlisting>
synchronous_standby_names = 'FIRST 2 (s1, s2, s3)'
</programlisting>
    In this example, if four standby servers <literal>s1</literal>, <literal>s2</literal>,
    <literal>s3</literal> and <literal>s4</literal> are running, the two standbys
    <literal>s1</literal> and <literal>s2</literal> will be chosen as synchronous standbys
    because their names appear early in the list of standby names.
    <literal>s3</literal> is a potential synchronous standby and will take over
    the role of synchronous standby when either of <literal>s1</literal> or
    <literal>s2</literal> fails. <literal>s4</literal> is an asynchronous standby since
    its name is not in the list.
   </para>
____________________________________________________________________________-->
   <para>
    基于优先的多同步后备的<varname>synchronous_standby_names</varname>示例为：
<programlisting>
synchronous_standby_names = 'FIRST 2 (s1, s2, s3)'
</programlisting>
    在这个例子中，如果有四个后备服务器<literal>s1</literal>、<literal>s2</literal>、<literal>s3</literal>和<literal>s4</literal>在运行，两个后备服务器<literal>s1</literal>和<literal>s2</literal>将被选中为同步后备，因为它们出现在后备服务器名称列表的前部。<literal>s3</literal>是一个潜在的同步后备，当<literal>s1</literal>或<literal>s2</literal>中的任何一个失效， 它就会取而代之。<literal>s4</literal>则是一个异步后备因为它的名字不在列表中。
   </para>
<!--==========================orignal english content==========================
   <para>
    The method <literal>ANY</literal> specifies a quorum-based synchronous
    replication and makes transaction commits wait until their WAL records
    are replicated to <emphasis>at least</emphasis> the requested number of
    synchronous standbys in the list.
   </para>
____________________________________________________________________________-->
   <para>
    方法<literal>ANY</literal>指定一种基于规定数量的同步复制并且让事务提交等待，直到它们的WAL记录<emphasis>至少</emphasis>被复制到列表中所要求数量的同步后备上为止。
   </para>
<!--==========================orignal english content==========================
   <para>
    An example of <varname>synchronous_standby_names</varname> for
    a quorum-based multiple synchronous standbys is:
<programlisting>
synchronous_standby_names = 'ANY 2 (s1, s2, s3)'
</programlisting>
    In this example, if four standby servers <literal>s1</literal>, <literal>s2</literal>,
    <literal>s3</literal> and <literal>s4</literal> are running, transaction commits will
    wait for replies from at least any two standbys of <literal>s1</literal>,
    <literal>s2</literal> and <literal>s3</literal>. <literal>s4</literal> is an asynchronous
    standby since its name is not in the list.
   </para>
____________________________________________________________________________-->
   <para>
    <varname>synchronous_standby_names</varname>的基于规定数量的多同步后备的例子：
<programlisting>
synchronous_standby_names = 'ANY 2 (s1, s2, s3)'
</programlisting>
    在这个例子中，如果有四台后备服务器<literal>s1</literal>、<literal>s2</literal>、<literal>s3</literal>以及<literal>s4</literal>正在运行，事务提交将会等待来自至少其中任意两台后备服务器的回复。<literal>s4</literal>是一台异步后备，因为它的名字不在该列表中。
   </para>
<!--==========================orignal english content==========================
   <para>
    The synchronous states of standby servers can be viewed using
    the <structname>pg_stat_replication</structname> view.
   </para>
____________________________________________________________________________-->
   <para>
    后备服务器的同步状态可以使用<structname>pg_stat_replication</structname>视图查看。
   </para>
   </sect3>

   <sect3 id="synchronous-replication-performance">
<!--==========================orignal english content==========================
    <title>Planning for Performance</title>
____________________________________________________________________________-->
    <title>性能规划</title>

<!--==========================orignal english content==========================
   <para>
    Synchronous replication usually requires carefully planned and placed
    standby servers to ensure applications perform acceptably. Waiting
    doesn't utilize system resources, but transaction locks continue to be
    held until the transfer is confirmed. As a result, incautious use of
    synchronous replication will reduce performance for database
    applications because of increased response times and higher contention.
   </para>
____________________________________________________________________________-->
   <para>
    同步复制通常要求仔细地规划和放置后备服务器来保证应用能令人满意地工作。等待并不利用系统资源，但是事务锁会持续保持直到传输被确认。其结果是，不小心使用同步复制将由于响应时间增加以及较高的争用率而降低数据库应用的性能。
   </para>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</productname> allows the application developer
    to specify the durability level required via replication. This can be
    specified for the system overall, though it can also be specified for
    specific users or connections, or even individual transactions.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>允许应用开发者通过复制来指定所要求的持久性级别。这可以为整个系统指定，不过它也能够为特定的用户或连接指定，甚至还可以为单个事务指定。
   </para>

<!--==========================orignal english content==========================
   <para>
    For example, an application workload might consist of:
    10% of changes are important customer details, while
    90% of changes are less important data that the business can more
    easily survive if it is lost, such as chat messages between users.
   </para>
____________________________________________________________________________-->
   <para>
    例如，一个应用的载荷的组成可能是这样：10% 的改变是重要的客户详情，而 90% 的改变是不太重要的数据，即使它们丢失业务也比较容易容忍（例如用户间的聊天消息）。
   </para>

<!--==========================orignal english content==========================
   <para>
    With synchronous replication options specified at the application level
    (on the primary) we can offer synchronous replication for the most
    important changes, without slowing down the bulk of the total workload.
    Application level options are an important and practical tool for allowing
    the benefits of synchronous replication for high performance applications.
   </para>
____________________________________________________________________________-->
   <para>
    通过在应用级别（在主服务器上）指定的同步复制选项，我们可以为大部分重要的改变提供同步复制，并且不会拖慢整体的载荷。应用级别选项是使高性能应用享受同步复制的一种重要和实用的工具。
   </para>

<!--==========================orignal english content==========================
   <para>
    You should consider that the network bandwidth must be higher than
    the rate of generation of WAL data.
   </para>
____________________________________________________________________________-->
   <para>
    你应该认为网络带宽必须比 WAL 数据的产生率高。
   </para>

   </sect3>

   <sect3 id="synchronous-replication-ha">
<!--==========================orignal english content==========================
    <title>Planning for High Availability</title>
____________________________________________________________________________-->
    <title>高可用性规划</title>

<!--==========================orignal english content==========================
   <para>
    <varname>synchronous_standby_names</varname> specifies the number and
    names of synchronous standbys that transaction commits made when
    <varname>synchronous_commit</varname> is set to <literal>on</literal>,
    <literal>remote_apply</literal> or <literal>remote_write</literal> will wait for
    responses from. Such transaction commits may never be completed
    if any one of synchronous standbys should crash.
   </para>
____________________________________________________________________________-->
   <para>
    当<varname>synchronous_commit</varname>被设置为<literal>on</literal>、<literal>remote_apply</literal>或者<literal>remote_write</literal>时， <varname>synchronous_standby_names</varname>指定产生的事务提交要等待其回应的同步后备的数量和名称。如果任一同步后备崩溃，这类事务提交可能无法完成。
   </para>

<!--==========================orignal english content==========================
   <para>
    The best solution for high availability is to ensure you keep as many
    synchronous standbys as requested. This can be achieved by naming multiple
    potential synchronous standbys using <varname>synchronous_standby_names</varname>.
   </para>
____________________________________________________________________________-->
   <para>
    高可用的最佳方案是确保有所要求数量的同步后备。这可以通过使用<varname>synchronous_standby_names</varname>指定多个潜在后备服务器来实现。
   </para>

<!--==========================orignal english content==========================
   <para>
    In a priority-based synchronous replication, the standbys whose names
    appear earlier in the list will be used as synchronous standbys.
    Standbys listed after these will take over the role of synchronous standby
    if one of current ones should fail.
   </para>
____________________________________________________________________________-->
   <para>
    在基于优先的同步复制中，出现在该列表前部的后备服务器将被用作同步后备。后面的后备服务器将在当前同步后备服务器失效时取而代之。
   </para>

<!--==========================orignal english content==========================
   <para>
    In a quorum-based synchronous replication, all the standbys appearing
    in the list will be used as candidates for synchronous standbys.
    Even if one of them should fail, the other standbys will keep performing
    the role of candidates of synchronous standby.
   </para>
____________________________________________________________________________-->
   <para>
    在基于规定数量的同步复制中，所有出现在该列表中的后备服务器都将被用作同步后备的候选。即使其中的一个失效，其他后备仍将继续担任候选同步后备的角色。
   </para>

<!--==========================orignal english content==========================
   <para>
    When a standby first attaches to the primary, it will not yet be properly
    synchronized. This is described as <literal>catchup</literal> mode. Once
    the lag between standby and primary reaches zero for the first time
    we move to real-time <literal>streaming</literal> state.
    The catch-up duration may be long immediately after the standby has
    been created. If the standby is shut down, then the catch-up period
    will increase according to the length of time the standby has been down.
    The standby is only able to become a synchronous standby
    once it has reached <literal>streaming</literal> state.
    This state can be viewed using
    the <structname>pg_stat_replication</structname> view.
   </para>
____________________________________________________________________________-->
   <para>
    当一台后备服务器第一次附加到主服务器时，它将处于一种还没有正确同步的状态。这被描述为<literal>追赶</literal>模式。一旦后备服务器和主服务器之间的迟滞第一次变成零，我们就来到了实时的<literal>流式</literal>状态。在后备服务器被创建之后的很长一段时间内可能都是追赶模式。如果后备服务器被关闭，则追赶周期将被增加，增加量由后备服务器被关闭的时间长度决定。只有当后备服务器到达<literal>流式</literal>状态后，它才能成为一台同步后备。这种状态可以使用<structname>pg_stat_replication</structname>视图查看。
   </para>

<!--==========================orignal english content==========================
   <para>
    If primary restarts while commits are waiting for acknowledgment, those
    waiting transactions will be marked fully committed once the primary
    database recovers.
    There is no way to be certain that all standbys have received all
    outstanding WAL data at time of the crash of the primary. Some
    transactions may not show as committed on the standby, even though
    they show as committed on the primary. The guarantee we offer is that
    the application will not receive explicit acknowledgment of the
    successful commit of a transaction until the WAL data is known to be
    safely received by all the synchronous standbys.
   </para>
____________________________________________________________________________-->
   <para>
    如果在提交正在等待确认时主服务器重启，那些正在等待的事务将在主数据库恢复时被标记为完全提交。没有办法确认所有后备服务器已经收到了在主服务器崩溃时所有还未处理的 WAL 数据。某些事务可能不会在后备服务器上显示为已提交，即使它们在主服务器上显示为已提交。我们提供的保证是：在 WAL 数据已经被所有后备服务器安全地收到之前，应用将不会收到一个事务成功提交的显式确认。
   </para>

<!--==========================orignal english content==========================
   <para>
    If you really cannot keep as many synchronous standbys as requested
    then you should decrease the number of synchronous standbys that
    transaction commits must wait for responses from
    in <varname>synchronous_standby_names</varname> (or disable it) and
    reload the configuration file on the primary server.
   </para>
____________________________________________________________________________-->
   <para>
    如果实在无法保持所要求数量的同步后备，那么应该减少<varname>synchronous_standby_names</varname>中指定的事务提交应该等待其回应的同步后备的数量（或者禁用），并且在主服务器上重载配置文件。
   </para>

<!--==========================orignal english content==========================
   <para>
    If the primary is isolated from remaining standby servers you should
    fail over to the best candidate of those other remaining standby servers.
   </para>
____________________________________________________________________________-->
   <para>
    如果主服务器与剩下的后备服务器是隔离的，你应当故障转移到那些其他剩余后备服务器中的最佳候选者上。
   </para>

<!--==========================orignal english content==========================
   <para>
    If you need to re-create a standby server while transactions are
    waiting, make sure that the commands pg_start_backup() and
    pg_stop_backup() are run in a session with
    <varname>synchronous_commit</varname> = <literal>off</literal>, otherwise those
    requests will wait forever for the standby to appear.
   </para>
____________________________________________________________________________-->
   <para>
    如果在事务等待时你需要重建一台后备服务器，确保命令 pg_start_backup() 和 pg_stop_backup() 被运行在一个<varname>synchronous_commit</varname> = <literal>off</literal>的会话中，否则那些请求将永远等待后备服务器出现。
   </para>

   </sect3>
  </sect2>

  <sect2 id="continuous-archiving-in-standby">
<!--==========================orignal english content==========================
   <title>Continuous Archiving in Standby</title>
____________________________________________________________________________-->
   <title>在后备机上连续归档</title>

<!--==========================orignal english content==========================
   <indexterm>
     <primary>continuous archiving</primary>
     <secondary>in standby</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
     <primary>continuous archiving</primary>
     <secondary>in standby</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
     When continuous WAL archiving is used in a standby, there are two
     different scenarios: the WAL archive can be shared between the primary
     and the standby, or the standby can have its own WAL archive. When
     the standby has its own WAL archive, set <varname>archive_mode</varname>
     to <literal>always</literal>, and the standby will call the archive
     command for every WAL segment it receives, whether it's by restoring
     from the archive or by streaming replication. The shared archive can
     be handled similarly, but the <varname>archive_command</varname> must
     test if the file being archived exists already, and if the existing file
     has identical contents. This requires more care in the
     <varname>archive_command</varname>, as it must
     be careful to not overwrite an existing file with different contents,
     but return success if the exactly same file is archived twice. And
     all that must be done free of race conditions, if two servers attempt
     to archive the same file at the same time.
   </para>
____________________________________________________________________________-->
   <para>
     当在一个后备机上使用连续归档时，有两种不同的情景：WAL 归档在主服务器
     和后备机之间共享，或者后备机有自己的 WAL 归档。当后备机拥有其自身的
     WAL 归档时，将<varname>archive_mode</varname>设置为
     <literal>always</literal>，后备机将在收到每个 WAL 段时调用归档命令，
     不管它是从归档恢复还是使用流复制恢复。共享归档可以类似地处理，但是
     <varname>archive_command</varname>必须测试要被归档的文件是否
     已经存在，以及现有的文件是否有相同的内容。这要求
     <varname>archive_command</varname>中有更多处理，因为它必须当心
     不要覆盖具有不同内容的已有文件，但是如果完全相同的文件被归档两次时
     应返回成功。并且如果两个服务器尝试同时归档同一个文件，所有这些都必须
     在没有竞争情况的前提下完成。
   </para>

<!--==========================orignal english content==========================
   <para>
     If <varname>archive_mode</varname> is set to <literal>on</literal>, the
     archiver is not enabled during recovery or standby mode. If the standby
     server is promoted, it will start archiving after the promotion, but
     will not archive any WAL or timeline history files that
     it did not generate itself. To get a complete
     series of WAL files in the archive, you must ensure that all WAL is
     archived, before it reaches the standby. This is inherently true with
     file-based log shipping, as the standby can only restore files that
     are found in the archive, but not if streaming replication is enabled.
     When a server is not in recovery mode, there is no difference between
     <literal>on</literal> and <literal>always</literal> modes.
   </para>
____________________________________________________________________________-->
   <para>
     如果<varname>archive_mode</varname>被设置为<literal>on</literal>，归档器在恢复或者后备模式中无法启用。
     如果后备服务器被提升，它将在被提升后开始归档，但是它将不会归档任何不是它自身产生的 WAL或时间线历史文件。
     要在归档中得到完整的一系列 WAL 文件，你必须确保所有 WAL 在到达后备机之前都被归档。
     对于基于文件的日志传输来说天然就是这样，因为后备机只能恢复在归档中找到的文件，而启用了流复制时则不是这样。
     当一台服务器不在恢复模式中时，在<literal>on</literal>和<literal>always</literal>模式之间没有差别。
   </para>
  </sect2>
  </sect1>

  <sect1 id="warm-standby-failover">
<!--==========================orignal english content==========================
   <title>Failover</title>
____________________________________________________________________________-->
   <title>故障转移</title>

<!--==========================orignal english content==========================
   <para>
    If the primary server fails then the standby server should begin
    failover procedures.
   </para>
____________________________________________________________________________-->
   <para>
    如果主服务器失效，则后备服务器应该开始故障转移过程。
   </para>

<!--==========================orignal english content==========================
   <para>
    If the standby server fails then no failover need take place. If the
    standby server can be restarted, even some time later, then the recovery
    process can also be restarted immediately, taking advantage of
    restartable recovery. If the standby server cannot be restarted, then a
    full new standby server instance should be created.
   </para>
____________________________________________________________________________-->
   <para>
    如果后备服务器失效，则不会有故障转移发生。如果后备服务器可以被重启（即使晚一点），由于可重启恢复的优势，那么恢复处理也能被立即重启。如果后备服务器不能被重启，则一个全新的后备服务器实例应该被创建。
   </para>

<!--==========================orignal english content==========================
   <para>
    If the primary server fails and the standby server becomes the
    new primary, and then the old primary restarts, you must have
    a mechanism for informing the old primary that it is no longer the primary. This is
    sometimes known as <acronym>STONITH</acronym> (Shoot The Other Node In The Head), which is
    necessary to avoid situations where both systems think they are the
    primary, which will lead to confusion and ultimately data loss.
   </para>
____________________________________________________________________________-->
   <para>
    如果主服务器失效并且后备服务器成为了新的主服务器，那么接下来旧的主服务器重启后，你必须有一种机制来通知旧的主服务器不再成为主服务器。有些时候这被称为<acronym>STONITH</acronym>（Shoot The Other Node In The Head，关闭其他节点），这对于避免出现两个系统都认为它们是主服务器的情况非常必要，那种情况将导致混乱并且最终导致数据丢失。
   </para>

<!--==========================orignal english content==========================
   <para>
    Many failover systems use just two systems, the primary and the standby,
    connected by some kind of heartbeat mechanism to continually verify the
    connectivity between the two and the viability of the primary. It is
    also possible to use a third system (called a witness server) to prevent
    some cases of inappropriate failover, but the additional complexity
    might not be worthwhile unless it is set up with sufficient care and
    rigorous testing.
   </para>
____________________________________________________________________________-->
   <para>
    很多故障转移系统仅使用两个系统，主系统和后备系统，它们由某种心跳机制连接来持续验证两者之间的连接性和主系统的可用性。也可能会使用第三个系统（称为目击者服务器）来防止某些不当故障转移的情况，但是除非非常小心地建立它并且经过了严格地测试，额外的复杂度可能会使该工作得不偿失。
   </para>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</productname> does not provide the system
    software required to identify a failure on the primary and notify
    the standby database server.  Many such tools exist and are well
    integrated with the operating system facilities required for
    successful failover, such as IP address migration.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>并不提供在主服务器上标识失败并且通知后备数据库服务器所需的系统软件。现在已有很多这样的工具并且很好地与成功的故障转移所需的操作系统功能整合在一起，例如 IP 地址迁移。
   </para>

<!--==========================orignal english content==========================
   <para>
    Once failover to the standby occurs, there is only a
    single server in operation. This is known as a degenerate state.
    The former standby is now the primary, but the former primary is down
    and might stay down.  To return to normal operation, a standby server
    must be recreated,
    either on the former primary system when it comes up, or on a third,
    possibly new, system. The <xref linkend="app-pgrewind"/> utility can be
    used to speed up this process on large clusters.
    Once complete, the primary and standby can be
    considered to have switched roles. Some people choose to use a third
    server to provide backup for the new primary until the new standby
    server is recreated,
    though clearly this complicates the system configuration and
    operational processes.
   </para>
____________________________________________________________________________-->
   <para>
    一旦发生到后备服务器的故障转移，就只有单一的一台服务器在操作。这被称为一种退化状态。之前的后备服务器现在是主服务器，但之前的主服务器处于关闭并且可能一直保持关闭。要回到正常的操作，一个后备服务器必须被重建，要么在之前的主系统起来时使用它重建，要么使用第三台（可能是全新的）服务器来重建。在大型集簇上，<xref linkend="app-pgrewind"/>功能可以被用来加速这个过程。一旦完成，主服务器和后备服务器可以被认为是互换了角色。某些人选择使用第三台服务器来为新的主服务器提供备份，直到新的后备服务器被重建，不过显然这会使得系统配置和操作处理更复杂。
   </para>

<!--==========================orignal english content==========================
   <para>
    So, switching from primary to standby server can be fast but requires
    some time to re-prepare the failover cluster. Regular switching from
    primary to standby is useful, since it allows regular downtime on
    each system for maintenance. This also serves as a test of the
    failover mechanism to ensure that it will really work when you need it.
    Written administration procedures are advised.
   </para>
____________________________________________________________________________-->
   <para>
    因此，从主服务器切换到后备服务器可以很快，但是要求一些时间来重新准备故障转移集群。从主服务器到后备服务器的常规切换是有用的，因为它允许每个系统有常规的关闭时间来进行维护。这也可以作为一种对故障转移机制的测试，以保证在你需要它时它真地能够工作。我们推荐写一些管理过程来做这些事情。
   </para>

<!--==========================orignal english content==========================
   <para>
    To trigger failover of a log-shipping standby server, run
    <command>pg_ctl promote</command>, call <function>pg_promote()</function>,
    or create a trigger file with the file name and path specified by the
    <varname>promote_trigger_file</varname>. If you're planning to use
    <command>pg_ctl promote</command> or to call
    <function>pg_promote()</function> to fail over,
    <varname>promote_trigger_file</varname> is not required. If you're
    setting up the reporting servers that are only used to offload read-only
    queries from the primary, not for high availability purposes, you don't
    need to promote it.
   </para>
____________________________________________________________________________-->
   <para>
    要触发一台日志传送后备服务器的故障转移，运行<command>pg_ctl promote</command>，调用 <function>pg_promote()</function>，或者创建一个触发器文件，其文件名和路径由<varname>promote_trigger_file</varname>设置指定。
    如果你正在规划使用<command>pg_ctl promote</command>或调用<function>pg_promote()</function>以进行故障转移，<varname>promote_trigger_file</varname>就不是必要的。
    如果你正在建立只用于从主服务器分流只读查询而不是高可用性目的的报告服务器，你不需要提升它。
   </para>
  </sect1>

 <sect1 id="hot-standby">
<!--==========================orignal english content==========================
  <title>Hot Standby</title>
____________________________________________________________________________-->
  <title>热备</title>

<!--==========================orignal english content==========================
  <indexterm zone="high-availability">
   <primary>Hot Standby</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="high-availability">
   <primary>热备</primary>
  </indexterm>

<!--==========================orignal english content==========================
   <para>
    Hot Standby is the term used to describe the ability to connect to
    the server and run read-only queries while the server is in archive
    recovery or standby mode. This
    is useful both for replication purposes and for restoring a backup
    to a desired state with great precision.
    The term Hot Standby also refers to the ability of the server to move
    from recovery through to normal operation while users continue running
    queries and/or keep their connections open.
   </para>
____________________________________________________________________________-->
   <para>
    术语热备用来描述处于归档恢复或后备模式中的服务器连接到服务器并运行只读查询的能力。这有助于复制目的以及以高精度恢复一个备份到一个期望的状态。术语热备也指服务器从恢复转移到正常操作而用户能继续运行查询并且保持其连接打开的能力。
   </para>

<!--==========================orignal english content==========================
   <para>
    Running queries in hot standby mode is similar to normal query operation,
    though there are several usage and administrative differences
    explained below.
   </para>
____________________________________________________________________________-->
   <para>
    在热备模式中运行查询与正常查询操作相似，尽管如下所述存在一些用法和管理上的区别。
   </para>

  <sect2 id="hot-standby-users">
<!--==========================orignal english content==========================
   <title>User's Overview</title>
____________________________________________________________________________-->
   <title>用户概览</title>

<!--==========================orignal english content==========================
   <para>
    When the <xref linkend="guc-hot-standby"/> parameter is set to true on a
    standby server, it will begin accepting connections once the recovery has
    brought the system to a consistent state.  All such connections are
    strictly read-only; not even temporary tables may be written.
   </para>
____________________________________________________________________________-->
   <para>
    当<xref linkend="guc-hot-standby"/>参数在一台后备服务器上被设置为真时，一旦恢复将系统带到一个一致的状态它将开始接受连接。所有这些连接都被限制为只读，甚至临时表都不能被写入。
   </para>

<!--==========================orignal english content==========================
   <para>
    The data on the standby takes some time to arrive from the primary server
    so there will be a measurable delay between primary and standby. Running the
    same query nearly simultaneously on both primary and standby might therefore
    return differing results. We say that data on the standby is
    <firstterm>eventually consistent</firstterm> with the primary.  Once the
    commit record for a transaction is replayed on the standby, the changes
    made by that transaction will be visible to any new snapshots taken on
    the standby.  Snapshots may be taken at the start of each query or at the
    start of each transaction, depending on the current transaction isolation
    level.  For more details, see <xref linkend="transaction-iso"/>.
   </para>
____________________________________________________________________________-->
   <para>
    后备服务器上的数据需要一些时间从主服务器到达后备服务器，因此在主服务器和后备服务器之间将有一段可以度量的延迟。近乎同时在主服务器和后备服务器上运行相同的查询可能因此而返回不同的结果。我们说后备服务器上的数据与主服务器是<firstterm>最终一致</firstterm>的。一旦一个事务的提交记录在后备服务器上被重播，那个事务所作的修改将对后备服务器上所有新取得的快照可见。快照可以在每个查询或每个事务的开始时取得，这取决于当前的事务隔离级别。详见<xref linkend="transaction-iso"/>。
   </para>

<!--==========================orignal english content==========================
   <para>
    Transactions started during hot standby may issue the following commands:

    <itemizedlist>
     <listitem>
      <para>
       Query access: <command>SELECT</command>, <command>COPY TO</command>
      </para>
     </listitem>
     <listitem>
      <para>
       Cursor commands: <command>DECLARE</command>, <command>FETCH</command>, <command>CLOSE</command>
      </para>
     </listitem>
     <listitem>
      <para>
       Settings: <command>SHOW</command>, <command>SET</command>, <command>RESET</command>
      </para>
     </listitem>
     <listitem>
      <para>
       Transaction management commands:
        <itemizedlist>
         <listitem>
          <para>
           <command>BEGIN</command>, <command>END</command>, <command>ABORT</command>, <command>START TRANSACTION</command>
          </para>
         </listitem>
         <listitem>
          <para>
           <command>SAVEPOINT</command>, <command>RELEASE</command>, <command>ROLLBACK TO SAVEPOINT</command>
          </para>
         </listitem>
         <listitem>
          <para>
           <command>EXCEPTION</command> blocks and other internal subtransactions
          </para>
         </listitem>
        </itemizedlist>
      </para>
     </listitem>
     <listitem>
      <para>
       <command>LOCK TABLE</command>, though only when explicitly in one of these modes:
       <literal>ACCESS SHARE</literal>, <literal>ROW SHARE</literal> or <literal>ROW EXCLUSIVE</literal>.
      </para>
     </listitem>
     <listitem>
      <para>
       Plans and resources: <command>PREPARE</command>, <command>EXECUTE</command>,
       <command>DEALLOCATE</command>, <command>DISCARD</command>
      </para>
     </listitem>
     <listitem>
      <para>
       Plugins and extensions: <command>LOAD</command>
      </para>
     </listitem>
     <listitem>
      <para>
       <command>UNLISTEN</command>
      </para>
     </listitem>
    </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    在热备期间开始的事务可能发出下列命令：

    <itemizedlist>
     <listitem>
      <para>
       查询访问: <command>SELECT</command>、<command>COPY TO</command>
      </para>
     </listitem>
     <listitem>
      <para>
       游标命令: <command>DECLARE</command>、<command>FETCH</command>、<command>CLOSE</command>
      </para>
     </listitem>
     <listitem>
      <para>
       设置: <command>SHOW</command>、<command>SET</command>、<command>RESET</command>
      </para>
     </listitem>
     <listitem>
      <para>
       事务管理命令:
        <itemizedlist>
         <listitem>
          <para>
           <command>BEGIN</command>、<command>END</command>、<command>ABORT</command>、<command>START TRANSACTION</command>
          </para>
         </listitem>
         <listitem>
          <para>
           <command>SAVEPOINT</command>、<command>RELEASE</command>、<command>ROLLBACK TO SAVEPOINT</command>
          </para>
         </listitem>
         <listitem>
          <para>
           <command>EXCEPTION</command>块或其他内部子事务
          </para>
         </listitem>
        </itemizedlist>
      </para>
     </listitem>
     <listitem>
      <para>
       <command>LOCK TABLE</command>，不过只在下列模式之一中明确发出：
       <literal>ACCESS SHARE</literal>、<literal>ROW SHARE</literal> 或 <literal>ROW EXCLUSIVE</literal>.
      </para>
     </listitem>
     <listitem>
      <para>
       计划和资源: <command>PREPARE</command>、<command>EXECUTE</command>、
       <command>DEALLOCATE</command>、<command>DISCARD</command>
      </para>
     </listitem>
     <listitem>
      <para>
       插件和扩展: <command>LOAD</command>
      </para>
     </listitem>
     <listitem>
      <para>
       <command>UNLISTEN</command>
      </para>
     </listitem>
    </itemizedlist>
   </para>

<!--==========================orignal english content==========================
   <para>
    Transactions started during hot standby will never be assigned a
    transaction ID and cannot write to the system write-ahead log.
    Therefore, the following actions will produce error messages:

    <itemizedlist>
     <listitem>
      <para>
       Data Manipulation Language (DML): <command>INSERT</command>,
       <command>UPDATE</command>, <command>DELETE</command>, <command>COPY FROM</command>,
       <command>TRUNCATE</command>.
       Note that there are no allowed actions that result in a trigger
       being executed during recovery.  This restriction applies even to
       temporary tables, because table rows cannot be read or written without
       assigning a transaction ID, which is currently not possible in a
       Hot Standby environment.
      </para>
     </listitem>
     <listitem>
      <para>
       Data Definition Language (DDL): <command>CREATE</command>,
       <command>DROP</command>, <command>ALTER</command>, <command>COMMENT</command>.
       This restriction applies even to temporary tables, because carrying
       out these operations would require updating the system catalog tables.
      </para>
     </listitem>
     <listitem>
      <para>
       <command>SELECT ... FOR SHARE | UPDATE</command>, because row locks cannot be
       taken without updating the underlying data files.
      </para>
     </listitem>
     <listitem>
      <para>
       Rules on <command>SELECT</command> statements that generate DML commands.
      </para>
     </listitem>
     <listitem>
      <para>
       <command>LOCK</command> that explicitly requests a mode higher than <literal>ROW EXCLUSIVE MODE</literal>.
      </para>
     </listitem>
     <listitem>
      <para>
       <command>LOCK</command> in short default form, since it requests <literal>ACCESS EXCLUSIVE MODE</literal>.
      </para>
     </listitem>
     <listitem>
      <para>
       Transaction management commands that explicitly set non-read-only state:
        <itemizedlist>
         <listitem>
          <para>
            <command>BEGIN READ WRITE</command>,
            <command>START TRANSACTION READ WRITE</command>
          </para>
         </listitem>
         <listitem>
          <para>
            <command>SET TRANSACTION READ WRITE</command>,
            <command>SET SESSION CHARACTERISTICS AS TRANSACTION READ WRITE</command>
          </para>
         </listitem>
         <listitem>
          <para>
           <command>SET transaction_read_only = off</command>
          </para>
         </listitem>
        </itemizedlist>
      </para>
     </listitem>
     <listitem>
      <para>
       Two-phase commit commands: <command>PREPARE TRANSACTION</command>,
       <command>COMMIT PREPARED</command>, <command>ROLLBACK PREPARED</command>
       because even read-only transactions need to write WAL in the
       prepare phase (the first phase of two phase commit).
      </para>
     </listitem>
     <listitem>
      <para>
       Sequence updates: <function>nextval()</function>, <function>setval()</function>
      </para>
     </listitem>
     <listitem>
      <para>
       <command>LISTEN</command>, <command>NOTIFY</command>
      </para>
     </listitem>
    </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    在热备期间开始的事务将不会被分配一个事务 ID 并且不能被写入到系统的预写式日志。因此，下列动作将产生错误消息：

    <itemizedlist>
     <listitem>
      <para>
       数据操纵语言（DML）: <command>INSERT</command>、
       <command>UPDATE</command>、<command>DELETE</command>、<command>COPY FROM</command>、
       <command>TRUNCATE</command>。注意不允许在恢复期间导致一个触发器被执行的动作。这个限制甚至被应用到临时表，因为不分配事务 ID 表行就不能被读或写，而当前不可能在一个热备环境中分配事务 ID。
      </para>
     </listitem>
     <listitem>
      <para>
       数据定义语言（DDL）: <command>CREATE</command>、
       <command>DROP</command>、<command>ALTER</command>、<command>COMMENT</command>。这个限制甚至被应用到临时表，因为执行这些操作会要求更新系统目录表。
      </para>
     </listitem>
     <listitem>
      <para>
       <command>SELECT ... FOR SHARE | UPDATE</command>，因为不更新底层数据文件就无法取得行锁。
      </para>
     </listitem>
     <listitem>
      <para>
       <command>SELECT</command>语句上的能产生 DML 命令的规则。
      </para>
     </listitem>
     <listitem>
      <para>
        显式请求一个高于<literal>ROW EXCLUSIVE MODE</literal>的模式的<command>LOCK</command>。
      </para>
     </listitem>
     <listitem>
      <para>
       默认短形式的<command>LOCK</command>，因为它请求<literal>ACCESS EXCLUSIVE MODE</literal>。
      </para>
     </listitem>
     <listitem>
      <para>
       显式设置非只读状态的事务管理命令：
        <itemizedlist>
         <listitem>
          <para>
            <command>BEGIN READ WRITE</command>,
            <command>START TRANSACTION READ WRITE</command>
          </para>
         </listitem>
         <listitem>
          <para>
            <command>SET TRANSACTION READ WRITE</command>,
            <command>SET SESSION CHARACTERISTICS AS TRANSACTION READ WRITE</command>
          </para>
         </listitem>
         <listitem>
          <para>
           <command>SET transaction_read_only = off</command>
          </para>
         </listitem>
        </itemizedlist>
      </para>
     </listitem>
     <listitem>
      <para>
       两阶段提交命令: <command>PREPARE TRANSACTION</command>、
       <command>COMMIT PREPARED</command>、<command>ROLLBACK PREPARED</command>，因为即使只读事务也需要在准备阶段（两阶段提交中的第一个阶段）写 WAL。
      </para>
     </listitem>
     <listitem>
      <para>
       序列更新 : <function>nextval()</function>、<function>setval()</function>
      </para>
     </listitem>
     <listitem>
      <para>
       <command>LISTEN</command>,<command>NOTIFY</command>
      </para>
     </listitem>
    </itemizedlist>
   </para>

<!--==========================orignal english content==========================
   <para>
    In normal operation, <quote>read-only</quote> transactions are allowed to
    use <command>LISTEN</command> and <command>NOTIFY</command>,
    so Hot Standby sessions operate under slightly tighter
    restrictions than ordinary read-only sessions.  It is possible that some
    of these restrictions might be loosened in a future release.
   </para>
____________________________________________________________________________-->
   <para>
    在正常操作中，<quote>只读</quote>事务被允许使用<command>LISTEN</command>和<command>NOTIFY</command>，因此热备会话在比普通只读会话更紧一点的限制下操作。这些限制中的某些可能会在一个未来的发行中被放松。
   </para>

<!--==========================orignal english content==========================
   <para>
    During hot standby, the parameter <varname>transaction_read_only</varname> is always
    true and may not be changed.  But as long as no attempt is made to modify
    the database, connections during hot standby will act much like any other
    database connection.  If failover or switchover occurs, the database will
    switch to normal processing mode.  Sessions will remain connected while the
    server changes mode.  Once hot standby finishes, it will be possible to
    initiate read-write transactions (even from a session begun during
    hot standby).
   </para>
____________________________________________________________________________-->
   <para>
    在热备期间，参数<varname>transaction_read_only</varname>总是为真并且不可以被改变。但是只要不尝试修改数据库，热备期间的连接工作起来更像其他数据库连接。如果发生故障转移或切换，该数据库将切换到正常处理模式。当服务器改变模式时会话将保持连接。一旦热备结束，它将可以发起读写事务（即使是一个在热备期间启动的会话）。
   </para>

<!--==========================orignal english content==========================
     <para>
    Users can determine whether hot standby is currently active for their
    session by issuing <command>SHOW in_hot_standby</command>.
    (In server versions before 14, the <varname>in_hot_standby</varname>
    parameter did not exist; a workable substitute method for older servers
    is <command>SHOW transaction_read_only</command>.)  In addition, a set of
    functions (<xref linkend="functions-recovery-info-table"/>) allow users to
    access information about the standby server. These allow you to write
    programs that are aware of the current state of the database. These
    can be used to monitor the progress of recovery, or to allow you to
    write complex programs that restore the database to particular states.
   </para>
____________________________________________________________________________-->
     <para>
    用户可以通过<command>SHOW in_hot_standby</command>来检查hot standby会话是否是活跃的 (在服务器版本 14 之前该参数<varname>in_hot_standby</varname>不存在。对于更早版本的服务器，可行的替代方法是 <command>SHOW transaction_read_only</command>。)  此外， 还有一些函数
     (<xref linkend="functions-recovery-info-table"/>) 允许用户访问有关备用服务器的信息。 它们允许您编写程序来识别数据库当前的状态。用于监控恢复进度， 或者您可以编写复杂的程序将数据库恢复到特定状态。
   </para>
  </sect2>

  <sect2 id="hot-standby-conflict">
<!--==========================orignal english content==========================
   <title>Handling Query Conflicts</title>
____________________________________________________________________________-->
   <title>处理查询冲突</title>

<!--==========================orignal english content==========================
   <para>
    The primary and standby servers are in many ways loosely connected. Actions
    on the primary will have an effect on the standby. As a result, there is
    potential for negative interactions or conflicts between them. The easiest
    conflict to understand is performance: if a huge data load is taking place
    on the primary then this will generate a similar stream of WAL records on the
    standby, so standby queries may contend for system resources, such as I/O.
   </para>
____________________________________________________________________________-->
   <para>
    主服务器和后备服务器在多方面都松散地连接在一起。主服务器上的动作将在后备服务器上产生效果。结果是在它们之间有潜在的负作用或冲突。最容易理解的冲突是性能：如果在主服务器上发生一次大数据量的载入，那么着将在后备服务器上产生一个相似的 WAL 记录流，因而后备服务器查询可能要竞争系统资源（例如 I/O）。
   </para>

<!--==========================orignal english content==========================
   <para>
    There are also additional types of conflict that can occur with Hot Standby.
    These conflicts are <emphasis>hard conflicts</emphasis> in the sense that queries
    might need to be canceled and, in some cases, sessions disconnected to resolve them.
    The user is provided with several ways to handle these
    conflicts. Conflict cases include:

      <itemizedlist>
       <listitem>
        <para>
         Access Exclusive locks taken on the primary server, including both
         explicit <command>LOCK</command> commands and various <acronym>DDL</acronym>
         actions, conflict with table accesses in standby queries.
        </para>
       </listitem>
       <listitem>
        <para>
         Dropping a tablespace on the primary conflicts with standby queries
         using that tablespace for temporary work files.
        </para>
       </listitem>
       <listitem>
        <para>
         Dropping a database on the primary conflicts with sessions connected
         to that database on the standby.
        </para>
       </listitem>
       <listitem>
        <para>
         Application of a vacuum cleanup record from WAL conflicts with
         standby transactions whose snapshots can still <quote>see</quote> any of
         the rows to be removed.
        </para>
       </listitem>
       <listitem>
        <para>
         Application of a vacuum cleanup record from WAL conflicts with
         queries accessing the target page on the standby, whether or not
         the data to be removed is visible.
        </para>
       </listitem>
      </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    随着热备发生的还可能有其他类型的冲突。对于可能需要被取消的查询和（某些情况中）解决它们的已断开会话来说，这些冲突是<emphasis>硬冲突</emphasis>。用户可以用几种方式来处理这种冲突。冲突情况包括：

      <itemizedlist>
       <listitem>
        <para>
         在主服务器上取得了访问排他锁（包括显式<command>LOCK</command>命令和多种<acronym>DDL</acronym>动作）与后备查询中的表访问冲突。
        </para>
       </listitem>
       <listitem>
        <para>
         在主服务器上删除一个表空间与使用该表空间存储临时工作文件的后备查询冲突。
        </para>
       </listitem>
       <listitem>
        <para>
         在主服务器上删除一个数据库与在后备服务器上连接到该数据库的会话冲突。
        </para>
       </listitem>
       <listitem>
        <para>
         从 WAL 清除记录的应用与快照仍能<quote>看见</quote>任意要被移除的行的后备事务冲突。
        </para>
       </listitem>
       <listitem>
        <para>
         从 WAL 清除记录的应用与在后备服务器上访问该目标页的查询冲突，不管要被移除的数据是否为可见。
        </para>
       </listitem>
      </itemizedlist>
   </para>

<!--==========================orignal english content==========================
   <para>
    On the primary server, these cases simply result in waiting; and the
    user might choose to cancel either of the conflicting actions.  However,
    on the standby there is no choice: the WAL-logged action already occurred
    on the primary so the standby must not fail to apply it.  Furthermore,
    allowing WAL application to wait indefinitely may be very undesirable,
    because the standby's state will become increasingly far behind the
    primary's.  Therefore, a mechanism is provided to forcibly cancel standby
    queries that conflict with to-be-applied WAL records.
   </para>
____________________________________________________________________________-->
   <para>
    在主服务器上，这些情况仅仅会导致等待；并且用户可以选择取消这些冲突动作中间的一个。但是，在后备服务器上则没有选择：已被 WAL 记录的动作已经在主服务器上发生，那么后备服务器不能在应用它时失败。此外，允许 WAL 应用无限等待是非常不可取的，因为后备服务器的状态将变得逐渐远远落后于主服务器的状态。因此，提供了一种机制来强制性地取消与要被应用的 WAL 记录冲突的后备查询。
   </para>

<!--==========================orignal english content==========================
   <para>
    An example of the problem situation is an administrator on the primary
    server running <command>DROP TABLE</command> on a table that is currently being
    queried on the standby server.  Clearly the standby query cannot continue
    if the <command>DROP TABLE</command> is applied on the standby. If this situation
    occurred on the primary, the <command>DROP TABLE</command> would wait until the
    other query had finished. But when <command>DROP TABLE</command> is run on the
    primary, the primary doesn't have information about what queries are
    running on the standby, so it will not wait for any such standby
    queries. The WAL change records come through to the standby while the
    standby query is still running, causing a conflict.  The standby server
    must either delay application of the WAL records (and everything after
    them, too) or else cancel the conflicting query so that the <command>DROP
    TABLE</command> can be applied.
   </para>
____________________________________________________________________________-->
   <para>
    该问题情形的一个例子是主服务器上的一位管理员在一个表上运行<command>DROP TABLE</command>，而该表正在后备服务器上被查询。如果<command>DROP TABLE</command>被应用在后备服务器上，很明显该后备查询不能继续。如果这种情况在主服务器上发生，<command>DROP TABLE</command>将等待直到其他查询结束。但是当<command>DROP TABLE</command>被运行在主服务器上，主服务器没有关于运行在后备服务器上查询的信息，因此它将不会等待任何这样的后备查询。WAL 改变记录在后备查询还在运行时来到后备服务器上，导致一个冲突。后备服务器必须要么延迟 WAL 记录的应用（还有它们之后的任何事情），要么取消冲突查询这样<command>DROP TABLE</command>可以被应用。
   </para>

<!--==========================orignal english content==========================
   <para>
    When a conflicting query is short, it's typically desirable to allow it to
    complete by delaying WAL application for a little bit; but a long delay in
    WAL application is usually not desirable.  So the cancel mechanism has
    parameters, <xref linkend="guc-max-standby-archive-delay"/> and <xref
    linkend="guc-max-standby-streaming-delay"/>, that define the maximum
    allowed delay in WAL application.  Conflicting queries will be canceled
    once it has taken longer than the relevant delay setting to apply any
    newly-received WAL data.  There are two parameters so that different delay
    values can be specified for the case of reading WAL data from an archive
    (i.e., initial recovery from a base backup or <quote>catching up</quote> a
    standby server that has fallen far behind) versus reading WAL data via
    streaming replication.
   </para>
____________________________________________________________________________-->
   <para>
    当一个冲突查询很短时，我们通常期望能延迟 WAL 应用一小会儿让它完成；但是在 WAL 应用中的一段长的延迟通常是不受欢迎的。因此取消机制有参数，<xref linkend="guc-max-standby-archive-delay"/>和<xref linkend="guc-max-standby-streaming-delay"/>，它们定义了在 WAL 应用中的最大允许延迟。当应用任何新收到的 WAL 数据花费了超过相关延迟设置值时，冲突查询将被取消。设立两个参数是为了对从一个归档读取 WAL 数据（即来自一个基础备份的初始恢复或者<quote>追赶</quote>一个已经落后很远的后备服务器）和通过流复制读取 WAL数据的两种情况指定不同的延迟值。
   </para>

<!--==========================orignal english content==========================
   <para>
    In a standby server that exists primarily for high availability, it's
    best to set the delay parameters relatively short, so that the server
    cannot fall far behind the primary due to delays caused by standby
    queries.  However, if the standby server is meant for executing
    long-running queries, then a high or even infinite delay value may be
    preferable.  Keep in mind however that a long-running query could
    cause other sessions on the standby server to not see recent changes
    on the primary, if it delays application of WAL records.
   </para>
____________________________________________________________________________-->
   <para>
    在一台后备服务器上这主要是为了该可用性而存在，最好把延迟参数设置得比较短，这样服务器不会由于后备查询导致的延迟落后主服务器太远。但是，如果该后备服务器是位了执行长时间运行的查询，则一个较高甚至无限的延迟值更好。但是记住一个长时间运行的查询延迟了 WAL 记录的应用，它可能导致后备服务器上的其他会话无法看到主服务器上最近的改变。
   </para>

<!--==========================orignal english content==========================
   <para>
    Once the delay specified by <varname>max_standby_archive_delay</varname> or
    <varname>max_standby_streaming_delay</varname> has been exceeded, conflicting
    queries will be canceled.  This usually results just in a cancellation
    error, although in the case of replaying a <command>DROP DATABASE</command>
    the entire conflicting session will be terminated.  Also, if the conflict
    is over a lock held by an idle transaction, the conflicting session is
    terminated (this behavior might change in the future).
   </para>
____________________________________________________________________________-->
   <para>
    一旦<varname>max_standby_archive_delay</varname>或<varname>max_standby_streaming_delay</varname>指定的延迟被超越，冲突查询将被取消。这通常仅导致一个取消错误，尽管在重放一个<command>DROP DATABASE</command>的情况下整个冲突会话都将被中断。另外，如果冲突发生在一个被空闲事务持有的锁上，该冲突会话会被中断（这种行为可能在未来被改变）。
   </para>

<!--==========================orignal english content==========================
   <para>
    Canceled queries may be retried immediately (after beginning a new
    transaction, of course).  Since query cancellation depends on
    the nature of the WAL records being replayed, a query that was
    canceled may well succeed if it is executed again.
   </para>
____________________________________________________________________________-->
   <para>
    被取消的查询可能会立即被重试（当然是在开始一个新的事务后）。因为查询取消依赖于 WAL 记录被重放的本质，如果一个被取消的查询被再次执行，它可能会很好地成功完成。
   </para>

<!--==========================orignal english content==========================
   <para>
    Keep in mind that the delay parameters are compared to the elapsed time
    since the WAL data was received by the standby server.  Thus, the grace
    period allowed to any one query on the standby is never more than the
    delay parameter, and could be considerably less if the standby has already
    fallen behind as a result of waiting for previous queries to complete, or
    as a result of being unable to keep up with a heavy update load.
   </para>
____________________________________________________________________________-->
   <para>
    记住延迟参数是从 WAL 数据被后备服务器收到后流逝的时间。因此，留给后备服务器上任何一个查询的宽限期从不会超过延迟参数，并且如果后备服务器已经由于等待之前的查询完成而落后或者因为过重的更新负载而无法跟上主服务器，宽限期可能会更少。
   </para>

<!--==========================orignal english content==========================
   <para>
    The most common reason for conflict between standby queries and WAL replay
    is <quote>early cleanup</quote>.  Normally, <productname>PostgreSQL</productname> allows
    cleanup of old row versions when there are no transactions that need to
    see them to ensure correct visibility of data according to MVCC rules.
    However, this rule can only be applied for transactions executing on the
    primary.  So it is possible that cleanup on the primary will remove row
    versions that are still visible to a transaction on the standby.
   </para>
____________________________________________________________________________-->
   <para>
    在后备查询和 WAL 重播之间发生冲突的最常见原因是<quote>过早清除</quote>。正常地，<productname>PostgreSQL</productname>允许在没有事务需要看到旧行版本时对它们进行清除，这样可以保证根据 MVCC 规则的正确的数据可见性。不过，这个规则只能被应用于执行在主控机上的事务。因此有可能主控机上的清除会移除对一个后备服务器事务还可见的行版本。
   </para>

<!--==========================orignal english content==========================
   <para>
    Experienced users should note that both row version cleanup and row version
    freezing will potentially conflict with standby queries. Running a manual
    <command>VACUUM FREEZE</command> is likely to cause conflicts even on tables with
    no updated or deleted rows.
   </para>
____________________________________________________________________________-->
   <para>
    有经验的用户应当注意行版本清除和行版本冻结都可能与后备查询冲突。即便在一个没有被更新或被删除行的表上运行一次手工<command>VACUUM FREEZE</command>也可能导致冲突。
   </para>

<!--==========================orignal english content==========================
   <para>
    Users should be clear that tables that are regularly and heavily updated
    on the primary server will quickly cause cancellation of longer running
    queries on the standby. In such cases the setting of a finite value for
    <varname>max_standby_archive_delay</varname> or
    <varname>max_standby_streaming_delay</varname> can be considered similar to
    setting <varname>statement_timeout</varname>.
   </para>
____________________________________________________________________________-->
   <para>
    用户应当清楚，主服务器上被正常和重度更新的表将快速地导致后备服务器上长时间运行的查询被取消。在这样的情况下，<varname>max_standby_archive_delay</varname>或<varname>max_standby_streaming_delay</varname>的有限制设置可以被视作<varname>statement_timeout</varname>设置。
   </para>

<!--==========================orignal english content==========================
   <para>
    Remedial possibilities exist if the number of standby-query cancellations
    is found to be unacceptable.  The first option is to set the parameter
    <varname>hot_standby_feedback</varname>, which prevents <command>VACUUM</command> from
    removing recently-dead rows and so cleanup conflicts do not occur.
    If you do this, you
    should note that this will delay cleanup of dead rows on the primary,
    which may result in undesirable table bloat. However, the cleanup
    situation will be no worse than if the standby queries were running
    directly on the primary server, and you are still getting the benefit of
    off-loading execution onto the standby.
    If standby servers connect and disconnect frequently, you
    might want to make adjustments to handle the period when
    <varname>hot_standby_feedback</varname> feedback is not being provided.
    For example, consider increasing <varname>max_standby_archive_delay</varname>
    so that queries are not rapidly canceled by conflicts in WAL archive
    files during disconnected periods.  You should also consider increasing
    <varname>max_standby_streaming_delay</varname> to avoid rapid cancellations
    by newly-arrived streaming WAL entries after reconnection.
   </para>
____________________________________________________________________________-->
   <para>
    如果发现后备查询取消的数量不可接受，还是有补救的可能。第一种选项是设置参数
    <varname>hot_standby_feedback</varname>，它阻止<command>VACUUM</command>
    移除最近死亡的元组并且因此清除冲突不会产生。如果你这样做，你应当
    注意这将使主服务器上的死亡元组清除被延迟，这可能会导致不希望发生
    的表膨胀。不过，清除的情况不会比在主服务器上直接运行后备查询时更糟，
    并且你仍然能够享受将执行分流到后备服务器的好处。如果后备服务器频繁地连接和
    断开，你可能想要做些调整来处理无法提供<varname>hot_standby_feedback</varname>
    反馈的时期。例如，考虑增加<varname>max_standby_archive_delay</varname>，这样
    在断开连接的期间查询就不会快速地被 WAL 归档文件中的冲突取消。你也应该考虑
    增加<varname>max_standby_streaming_delay</varname>来避免重新连接后新到达的流
    WAL 项导致的快速取消。
   </para>

<!--==========================orignal english content==========================
   <para>
    Another option is to increase <xref linkend="guc-vacuum-defer-cleanup-age"/>
    on the primary server, so that dead rows will not be cleaned up as quickly
    as they normally would be.  This will allow more time for queries to
    execute before they are canceled on the standby, without having to set
    a high <varname>max_standby_streaming_delay</varname>.  However it is
    difficult to guarantee any specific execution-time window with this
    approach, since <varname>vacuum_defer_cleanup_age</varname> is measured in
    transactions executed on the primary server.
   </para>
____________________________________________________________________________-->
   <para>
    另一个选项是增加主服务器上的<xref linkend="guc-vacuum-defer-cleanup-age"/>，这样死亡行不会像平常那么快地被清理。这将允许在后备服务器上的查询能在被取消前有更多时间执行，并且不需要设置一个很高的<varname>max_standby_streaming_delay</varname>。但是，这种方法很难保证任何指定的执行时间窗口，因为<varname>vacuum_defer_cleanup_age</varname>是用主服务器上被执行的事务数来衡量的。
   </para>

<!--==========================orignal english content==========================
   <para>
    The number of query cancels and the reason for them can be viewed using
    the <structname>pg_stat_database_conflicts</structname> system view on the standby
    server. The <structname>pg_stat_database</structname> system view also contains
    summary information.
   </para>
____________________________________________________________________________-->
   <para>
    查询取消的数量和原因可以使用后备服务器上的<structname>pg_stat_database_conflicts</structname>系统视图查看。<structname>pg_stat_database</structname>系统视图也包含汇总信息。
   </para>
<!--==========================orignal english content==========================
   <para>
    Users can control whether a log message is produced when WAL replay is waiting
    longer than <varname>deadlock_timeout</varname> for conflicts. This
    is controlled by the <xref linkend="guc-log-recovery-conflict-waits"/> parameter.
   </para>
____________________________________________________________________________-->
   <para>
    当 WAL 重放由于冲突而需要比<varname>deadlock_timeout</varname>更长时间时，用户可以控制是否打印日志消息。由参数 <xref linkend="guc-log-recovery-conflict-waits"/> 控制。
   </para>
  </sect2>

  <sect2 id="hot-standby-admin">
<!--==========================orignal english content==========================
   <title>Administrator's Overview</title>
____________________________________________________________________________-->
   <title>管理员概览</title>

<!--==========================orignal english content==========================
   <para>
    If <varname>hot_standby</varname> is <literal>on</literal> in <filename>postgresql.conf</filename>
    (the default value) and there is a
    <link linkend="file-standby-signal"><filename>standby.signal</filename></link><indexterm><primary>standby.signal</primary><secondary>for hot standby</secondary></indexterm>
    file present, the server will run in Hot Standby mode.
    However, it may take some time for Hot Standby connections to be allowed,
    because the server will not accept connections until it has completed
    sufficient recovery to provide a consistent state against which queries
    can run.  During this period,
    clients that attempt to connect will be refused with an error message.
    To confirm the server has come up, either loop trying to connect from
    the application, or look for these messages in the server logs:

<programlisting>
LOG:  entering standby mode

... then some time later ...

LOG:  consistent recovery state reached
LOG:  database system is ready to accept read-only connections
</programlisting>

    Consistency information is recorded once per checkpoint on the primary.
    It is not possible to enable hot standby when reading WAL
    written during a period when <varname>wal_level</varname> was not set to
    <literal>replica</literal> or <literal>logical</literal> on the primary.  Reaching
    a consistent state can also be delayed in the presence of both of these
    conditions:

      <itemizedlist>
       <listitem>
        <para>
         A write transaction has more than 64 subtransactions
        </para>
       </listitem>
       <listitem>
        <para>
         Very long-lived write transactions
        </para>
       </listitem>
      </itemizedlist>

    If you are running file-based log shipping ("warm standby"), you might need
    to wait until the next WAL file arrives, which could be as long as the
    <varname>archive_timeout</varname> setting on the primary.
   </para>
____________________________________________________________________________-->
   <para>
    如果<varname>hot_standby</varname>在<filename>postgresql.conf</filename>中被设置为<literal>on</literal>并且存在一个<link linkend="file-standby-signal"><filename>standby.signal</filename></link><indexterm><primary>standby.signal</primary><secondary>热备</secondary></indexterm>文件，服务器将运行在热备模式。但是，可能需要一些时间来允许热备连接，因为在服务器完成足够的恢复来为查询提供一个一致的状态之前，它将不会接受连接。在此期间，尝试连接的客户端将被一个错误消息拒绝。要确认服务器已经可连接，要么循环地从应用尝试连接，要么在服务器日志中查找这些消息：

<programlisting>
LOG:  entering standby mode

... then some time later ...

LOG:  consistent recovery state reached
LOG:  database system is ready to accept read only connections
</programlisting>

    在主服务器上，一旦创建一个检查点，一致性信息就被记录下来。当读取在特定时段（当在主服务器上<varname>wal_level</varname>没有被设置为<literal>replica</literal>或者<literal>logical</literal>的期间）产生的 WAL 时无法启用热备。在同时存在这些条件时，到达一个一致状态也会被延迟：

      <itemizedlist>
       <listitem>
        <para>
         一个写事务有超过 64 个子事务
        </para>
       </listitem>
       <listitem>
        <para>
         生存时间非常长的写事务
        </para>
       </listitem>
      </itemizedlist>

    如果你正在运行基于文件的日志传送（“温备”），你可能需要等到下一个 WAL 文件到达，这可能和主服务器上的<varname>archive_timeout</varname>设置一样长。
   </para>

<!--==========================orignal english content==========================
   <para>
    The settings of some parameters determine the size of shared memory for
    tracking transaction IDs, locks, and prepared transactions.  These shared
    memory structures must be no smaller on a standby than on the primary in
    order to ensure that the standby does not run out of shared memory during
    recovery.  For example, if the primary had used a prepared transaction but
    the standby had not allocated any shared memory for tracking prepared
    transactions, then recovery could not continue until the standby's
    configuration is changed.  The parameters affected are:

      <itemizedlist>
       <listitem>
        <para>
         <varname>max_connections</varname>
        </para>
       </listitem>
       <listitem>
        <para>
         <varname>max_prepared_transactions</varname>
        </para>
       </listitem>
       <listitem>
        <para>
         <varname>max_locks_per_transaction</varname>
        </para>
       </listitem>
       <listitem>
        <para>
         <varname>max_wal_senders</varname>
        </para>
       </listitem>
       <listitem>
        <para>
         <varname>max_worker_processes</varname>
        </para>
       </listitem>
      </itemizedlist>

    The easiest way to ensure this does not become a problem is to have these
    parameters set on the standbys to values equal to or greater than on the
    primary.  Therefore, if you want to increase these values, you should do
    so on all standby servers first, before applying the changes to the
    primary server.  Conversely, if you want to decrease these values, you
    should do so on the primary server first, before applying the changes to
    all standby servers.  Keep in mind that when a standby is promoted, it
    becomes the new reference for the required parameter settings for the
    standbys that follow it.  Therefore, to avoid this becoming a problem
    during a switchover or failover, it is recommended to keep these settings
    the same on all standby servers.
   </para>
____________________________________________________________________________-->
   <para>
    设置几个参数可确定用于跟踪事务ID、锁和预备事务的共享内存大小。备用服务器上的设置必须大于或等于主服务器上的设置，以确保在恢复过程中不会耗尽共享内存。例如，如果主数据库正在执行预备事务，而备用数据库没有获取共享内存来跟踪预备事务，则备用数据库将无法继续恢复，直到配置更改。受影响的参数是：
      <itemizedlist>
       <listitem>
        <para>
         <varname>max_connections</varname>
        </para>
       </listitem>
       <listitem>
        <para>
         <varname>max_prepared_transactions</varname>
        </para>
       </listitem>
       <listitem>
        <para>
         <varname>max_locks_per_transaction</varname>
        </para>
       </listitem>
       <listitem>
        <para>
         <varname>max_wal_senders</varname>
        </para>
       </listitem>
       <listitem>
        <para>
         <varname>max_worker_processes</varname>
        </para>
       </listitem>
      </itemizedlist>
    确保这不是问题的可靠方法是使备用数据库上的这些参数的值等于或大于主数据库上的值。因此，如果您想增加这些值，您应该先更改备用服务器上的设置，然后再更改主服务器上的设置。相反，如果要减小这些值，则应先更改主服务器上的设置，然后再更改备用服务器上的设置。请记住，当一个备用数据库被提升时，它会成为后续备用数据库所需参数设置的新基准。因此，最好在所有备用服务器上保持这些设置相同，这样在切换/故障转移期间就不会出现问题。
   </para>

<!--==========================orignal english content==========================
   <para>
    The WAL tracks changes to these parameters on the
    primary.  If a hot standby processes WAL that indicates that the current
    value on the primary is higher than its own value, it will log a warning
    and pause recovery, for example:
<screen>
WARNING:  hot standby is not possible because of insufficient parameter settings
DETAIL:  max_connections = 80 is a lower setting than on the primary server, where its value was 100.
LOG:  recovery has paused
DETAIL:  If recovery is unpaused, the server will shut down.
HINT:  You can then restart the server after making the necessary configuration changes.
</screen>
    At that point, the settings on the standby need to be updated and the
    instance restarted before recovery can continue.  If the standby is not a
    hot standby, then when it encounters the incompatible parameter change, it
    will shut down immediately without pausing, since there is then no value
    in keeping it up.
   </para>
____________________________________________________________________________-->
   <para>
   WAL 跟踪主节点上这些参数的变化。如果热备处理一个 WAL，表明主节点当前值大于备用数据库上的值，它将记录一个警告并中止恢复。例如:
<screen>
WARNING：由于参数设置不足，无法进行热备
详细信息：max_connections = 80 的设置低于主服务器上的设置，其值为 100。
LOG：恢复已暂停
详细信息：如果恢复未暂停，服务器将关闭。
提示：您可以在进行必要的配置更改后重新启动服务器。
</screen>
    此时，您应该更改备库设置并重新启动实例以继续恢复。如果备库不是热备，不兼容的参数更改将立即将其关闭而不会暂停。因为这样继续开机没有意义。
   </para>

<!--==========================orignal english content==========================
   <para>
    It is important that the administrator select appropriate settings for
    <xref linkend="guc-max-standby-archive-delay"/> and <xref
    linkend="guc-max-standby-streaming-delay"/>.  The best choices vary
    depending on business priorities.  For example if the server is primarily
    tasked as a High Availability server, then you will want low delay
    settings, perhaps even zero, though that is a very aggressive setting. If
    the standby server is tasked as an additional server for decision support
    queries then it might be acceptable to set the maximum delay values to
    many hours, or even -1 which means wait forever for queries to complete.
   </para>
____________________________________________________________________________-->
   <para>
    管理员为<xref linkend="guc-max-standby-archive-delay"/>和<xref linkend="guc-max-standby-streaming-delay"/>选择适当的设置很重要。最好的选择取决于业务的优先级。例如如果服务器主要的任务是作为高可用服务器，那么你将想要低延迟设置，甚至是零（尽管它是一个非常激进的设置）。如果后备服务器的任务是作为一个用于决策支持查询的额外服务器，那么将其最大延迟值设置为很多小时甚至 -1 （表示无限等待）可能都是可以接受的。
   </para>

<!--==========================orignal english content==========================
   <para>
    Transaction status "hint bits" written on the primary are not WAL-logged,
    so data on the standby will likely re-write the hints again on the standby.
    Thus, the standby server will still perform disk writes even though
    all users are read-only; no changes occur to the data values
    themselves.  Users will still write large sort temporary files and
    re-generate relcache info files, so no part of the database
    is truly read-only during hot standby mode.
    Note also that writes to remote databases using
    <application>dblink</application> module, and other operations outside the
    database using PL functions will still be possible, even though the
    transaction is read-only locally.
   </para>
____________________________________________________________________________-->
   <para>
    在主服务器上写出的事务状态 "hint bits" 是不被 WAL 记录的，因此后备服务器上的数据将可能重新写出该提示。这样，即使所有用户都是只读的，后备服务器仍将执行磁盘写操作；但数据值本身并没有发生改变。用户将仍写出大的排序临时文件并且重新生成 relcache 信息文件，这样在热备模式中数据库没有哪个部分是真正只读的。还要注意使用<application>dblink</application>模块写到远程数据库以及其他使用 PL 函数位于数据库之外的操作仍将可用，即使该事务是本地只读的。
   </para>

<!--==========================orignal english content==========================
   <para>
    The following types of administration commands are not accepted
    during recovery mode:

      <itemizedlist>
       <listitem>
        <para>
         Data Definition Language (DDL): e.g., <command>CREATE INDEX</command>
        </para>
       </listitem>
       <listitem>
        <para>
         Privilege and Ownership: <command>GRANT</command>, <command>REVOKE</command>,
         <command>REASSIGN</command>
        </para>
       </listitem>
       <listitem>
        <para>
         Maintenance commands: <command>ANALYZE</command>, <command>VACUUM</command>,
         <command>CLUSTER</command>, <command>REINDEX</command>
        </para>
       </listitem>
      </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    在恢复模式期间，下列类型的管理命令是不被接受的：

      <itemizedlist>
       <listitem>
        <para>
         数据定义语言（DDL）: e.g., <command>CREATE INDEX</command>
        </para>
       </listitem>
       <listitem>
        <para>
         特权和所有权: <command>GRANT</command>, <command>REVOKE</command>,
        </para>
       </listitem>
       <listitem>
        <para>
         维护命令: <command>ANALYZE</command>, <command>VACUUM</command>,<command>CLUSTER</command>, <command>REINDEX</command>
        </para>
       </listitem>
      </itemizedlist>
   </para>

<!--==========================orignal english content==========================
   <para>
    Again, note that some of these commands are actually allowed during
    "read only" mode transactions on the primary.
   </para>
____________________________________________________________________________-->
   <para>
    注意这些命令中的某些实际上在主服务器上的“只读”模式事务期间是被允许的。
   </para>

<!--==========================orignal english content==========================
   <para>
    As a result, you cannot create additional indexes that exist solely
    on the standby, nor statistics that exist solely on the standby.
    If these administration commands are needed, they should be executed
    on the primary, and eventually those changes will propagate to the
    standby.
   </para>
____________________________________________________________________________-->
   <para>
    结果是，你无法创建只存在于后备服务器上的额外索引以及统计信息。如果需要这些管理命令，它们应该在主服务器上被执行，并且最后那些改变将被传播到后备服务器。
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>pg_cancel_backend()</function>
    and <function>pg_terminate_backend()</function> will work on user backends,
    but not the Startup process, which performs
    recovery. <structname>pg_stat_activity</structname> does not show
    recovering transactions as active. As a result,
    <structname>pg_prepared_xacts</structname> is always empty during
    recovery. If you wish to resolve in-doubt prepared transactions, view
    <literal>pg_prepared_xacts</literal> on the primary and issue commands to
    resolve transactions there or resolve them after the end of recovery.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_cancel_backend()</function>和<function>pg_terminate_backend()</function>将在用户后端上工作，而不是执行恢复的 Startup 进程。<structname>pg_stat_activity</structname>不会为 Startup 进程显示一个项，也不会把恢复事务显示为活动。结果是在恢复期间<structname>pg_prepared_xacts</structname>总是为空。如果你希望解决不能确定的预备事务，查看主服务器上的<literal>pg_prepared_xacts</literal>并且发出命令来解决那里的事务或者在恢复结束后来解决它们。
   </para>

<!--==========================orignal english content==========================
   <para>
    <structname>pg_locks</structname> will show locks held by backends,
    as normal. <structname>pg_locks</structname> also shows
    a virtual transaction managed by the Startup process that owns all
    <literal>AccessExclusiveLocks</literal> held by transactions being replayed by recovery.
    Note that the Startup process does not acquire locks to
    make database changes, and thus locks other than <literal>AccessExclusiveLocks</literal>
    do not show in <structname>pg_locks</structname> for the Startup
    process; they are just presumed to exist.
   </para>
____________________________________________________________________________-->
   <para>
    和平常一样，<structname>pg_locks</structname>将显示被后端持有的锁。<structname>pg_locks</structname>也会显示一个由 Startup 进程管理的虚拟事务，它拥有被恢复重播的事务所持有的所有<literal>AccessExclusiveLocks</literal>。注意 Startup 进程不请求锁来做数据库更改，并且因此对于 Startup 进程除<literal>AccessExclusiveLocks</literal>之外的锁不显示在<structname>pg_locks</structname>中，它们仅被假定存在。
   </para>

<!--==========================orignal english content==========================
   <para>
    The <productname>Nagios</productname> plugin <productname>check_pgsql</productname> will
    work, because the simple information it checks for exists.
    The <productname>check_postgres</productname> monitoring script will also work,
    though some reported values could give different or confusing results.
    For example, last vacuum time will not be maintained, since no
    vacuum occurs on the standby.  Vacuums running on the primary
    do still send their changes to the standby.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>Nagios</productname>的插件<productname>check_pgsql</productname>将可以工作，因为它检查的简单信息是存在的。<productname>check_postgres</productname>监控脚本也将能工作，尽管某些被报告的值可能给出不同或者混乱的结果。例如，上一次清理时间将不会被维护，因为在后备服务器上不会发生清理。在主服务器上运行的清理仍会把它们的改变发送给后备服务器。
   </para>

<!--==========================orignal english content==========================
   <para>
    WAL file control commands will not work during recovery,
    e.g., <function>pg_start_backup</function>, <function>pg_switch_wal</function> etc.
   </para>
____________________________________________________________________________-->
   <para>
    WAL 文件控制命令在恢复期间将不会工作，如<function>pg_start_backup</function>、<function>pg_switch_wal</function>等。
   </para>

<!--==========================orignal english content==========================
   <para>
    Dynamically loadable modules work, including <structname>pg_stat_statements</structname>.
   </para>
____________________________________________________________________________-->
   <para>
    可动态载入的模块可以工作，包括<structname>pg_stat_statements</structname>。
   </para>

<!--==========================orignal english content==========================
   <para>
    Advisory locks work normally in recovery, including deadlock detection.
    Note that advisory locks are never WAL logged, so it is impossible for
    an advisory lock on either the primary or the standby to conflict with WAL
    replay. Nor is it possible to acquire an advisory lock on the primary
    and have it initiate a similar advisory lock on the standby. Advisory
    locks relate only to the server on which they are acquired.
   </para>
____________________________________________________________________________-->
   <para>
    咨询锁在恢复期间工作正常，包括死锁检测。注意咨询锁从来都不会被 WAL 记录，因此在主服务器或后备服务器上一个咨询锁不可能会与 WAL 重播发生冲突。也不可能会在主服务器上获得一个咨询锁并且在后备服务器上开始一个相似的咨询锁。咨询锁只与它们被取得的那个服务器相关。
   </para>

<!--==========================orignal english content==========================
   <para>
    Trigger-based replication systems such as <productname>Slony</productname>,
    <productname>Londiste</productname> and <productname>Bucardo</productname> won't run on the
    standby at all, though they will run happily on the primary server as
    long as the changes are not sent to standby servers to be applied.
    WAL replay is not trigger-based so you cannot relay from the
    standby to any system that requires additional database writes or
    relies on the use of triggers.
   </para>
____________________________________________________________________________-->
   <para>
    基于触发器的复制系统（如<productname>Slony</productname>、<productname>Londiste</productname>和<productname>Bucardo</productname>）将根本不会运行在后备服务器上，然而只要改变不被发送到要被应用的后备服务器，它们将在主服务器上运行得很好。WAL 重播不是基于触发器的，因此你不能用后备服务器接替任何需要额外数据库写操作或依赖触发器使用的系统。
   </para>

<!--==========================orignal english content==========================
   <para>
    New OIDs cannot be assigned, though some <acronym>UUID</acronym> generators may still
    work as long as they do not rely on writing new status to the database.
   </para>
____________________________________________________________________________-->
   <para>
    新的 OID 不能被分配，然而某些<acronym>UUID</acronym>生成器仍然能工作，只要它们不依赖于向数据库写新的状态。
   </para>

<!--==========================orignal english content==========================
   <para>
    Currently, temporary table creation is not allowed during read-only
    transactions, so in some cases existing scripts will not run correctly.
    This restriction might be relaxed in a later release. This is
    both an SQL Standard compliance issue and a technical issue.
   </para>
____________________________________________________________________________-->
   <para>
    当前，在只读事务期间不允许创建临时表，因此在某些情况中现有的脚本将不会正确运行。这个限制可能会在稍后的发行中被放松。这既是一个 SQL 标准符合问题也是一个技术问题。
   </para>

<!--==========================orignal english content==========================
   <para>
    <command>DROP TABLESPACE</command> can only succeed if the tablespace is empty.
    Some standby users may be actively using the tablespace via their
    <varname>temp_tablespaces</varname> parameter. If there are temporary files in the
    tablespace, all active queries are canceled to ensure that temporary
    files are removed, so the tablespace can be removed and WAL replay
    can continue.
   </para>
____________________________________________________________________________-->
   <para>
    只有在表空间为空时<command>DROP TABLESPACE</command>才能成功。某些后备服务器用户可能正在通过他们的<varname>temp_tablespaces</varname>参数使用该表空间。如果在该表空间中有临时文件，所有活动查询将被取消来保证临时文件被移除，这样该表空间可以被移除并且 WAL 重播可以继续。
   </para>

<!--==========================orignal english content==========================
   <para>
    Running <command>DROP DATABASE</command> or <command>ALTER DATABASE ... SET
    TABLESPACE</command> on the primary
    will generate a WAL entry that will cause all users connected to that
    database on the standby to be forcibly disconnected. This action occurs
    immediately, whatever the setting of
    <varname>max_standby_streaming_delay</varname>. Note that
    <command>ALTER DATABASE ... RENAME</command> does not disconnect users, which
    in most cases will go unnoticed, though might in some cases cause a
    program confusion if it depends in some way upon database name.
   </para>
____________________________________________________________________________-->
   <para>
    在主服务器上运行<command>DROP DATABASE</command>或<command>ALTER DATABASE ... SET TABLESPACE</command>将产生一个 WAL 项，它将导致所有连接到后备服务器上那个数据库的用户被强制地断开连接。这个动作会立即发生，不管<varname>max_standby_streaming_delay</varname>的设置是什么。注意<command>ALTER DATABASE ... RENAME</command>不会断开用户，这在大部分情况中不会有提示，然而如果它依赖某种基于数据库名的方法，在某些情况中会导致程序混乱。
   </para>

<!--==========================orignal english content==========================
   <para>
    In normal (non-recovery) mode, if you issue <command>DROP USER</command> or <command>DROP ROLE</command>
    for a role with login capability while that user is still connected then
    nothing happens to the connected user &mdash; they remain connected. The user cannot
    reconnect however. This behavior applies in recovery also, so a
    <command>DROP USER</command> on the primary does not disconnect that user on the standby.
   </para>
____________________________________________________________________________-->
   <para>
    在普通（非恢复）模式中，如果你为具有登录能力的角色发出<command>DROP USER</command>或<command>DROP ROLE</command>，而该用户仍然连接着，则对已连接用户不会发生任何事情 - 他们保持连接。但是用户不能重新连接。这种行为也适用于恢复，因此在主服务器上的一次<command>DROP USER</command>不会使后备服务器上的用户断开。
   </para>

<!--==========================orignal english content==========================
   <para>
    The statistics collector is active during recovery. All scans, reads, blocks,
    index usage, etc., will be recorded normally on the standby. Replayed
    actions will not duplicate their effects on primary, so replaying an
    insert will not increment the Inserts column of pg_stat_user_tables.
    The stats file is deleted at the start of recovery, so stats from primary
    and standby will differ; this is considered a feature, not a bug.
   </para>
____________________________________________________________________________-->
   <para>
    在恢复期间统计收集器是活动的。所有扫描、读、阻塞、索引使用等将在后备服务器上被正常的记录。被重播的动作将不会重复它们在主服务器上的效果，因此重播一个插入将不会导致pg_stat_user_tables的 Inserts 列上的递增。在恢复的开始 stats 文件会被删除，因此来自主服务器和后备服务器的 stats 将不同；这被认为是一种特性而不是缺陷。
   </para>

<!--==========================orignal english content==========================
   <para>
    Autovacuum is not active during recovery.  It will start normally at the
    end of recovery.
   </para>
____________________________________________________________________________-->
   <para>
    在恢复期间自动清理不是活动的。它将在恢复末尾正常启动。
   </para>

<!--==========================orignal english content==========================
   <para>
    The checkpointer process and the background writer process are active during
    recovery. The checkpointer process will perform restartpoints (similar to
    checkpoints on the primary) and the background writer process will perform
    normal block cleaning activities. This can include updates of the hint bit
    information stored on the standby server.
    The <command>CHECKPOINT</command> command is accepted during recovery,
    though it performs a restartpoint rather than a new checkpoint.
   </para>
____________________________________________________________________________-->
   <para>
    检查点进程和后台写入进程在恢复期间是活动状态的。检查点进程将执行重启动点（与主服务器上的检查点相似），后台写入进程将执行正常的块清理活动。	
    这可以包括存储在后备服务器上的提示位信息的更新。在恢复期间，<command>CHECKPOINT</command>命令会被接受，然而它会执行一个重启点而不是一个新的检查点。
   </para>
  </sect2>

  <sect2 id="hot-standby-parameters">
<!--==========================orignal english content==========================
   <title>Hot Standby Parameter Reference</title>
____________________________________________________________________________-->
   <title>热备参数参考</title>

<!--==========================orignal english content==========================
   <para>
    Various parameters have been mentioned above in
    <xref linkend="hot-standby-conflict"/> and
    <xref linkend="hot-standby-admin"/>.
   </para>
____________________________________________________________________________-->
   <para>
    多个参数已经在<xref linkend="hot-standby-conflict"/>和<xref linkend="hot-standby-admin"/>中提到过。
   </para>

<!--==========================orignal english content==========================
   <para>
    On the primary, parameters <xref linkend="guc-wal-level"/> and
    <xref linkend="guc-vacuum-defer-cleanup-age"/> can be used.
    <xref linkend="guc-max-standby-archive-delay"/> and
    <xref linkend="guc-max-standby-streaming-delay"/> have no effect if set on
    the primary.
   </para>
____________________________________________________________________________-->
   <para>
    在主服务器上，可以使用参数<xref linkend="guc-wal-level"/>和<xref linkend="guc-vacuum-defer-cleanup-age"/>。在主服务器上设置<xref linkend="guc-max-standby-archive-delay"/>和<xref linkend="guc-max-standby-streaming-delay"/>不会产生效果。
   </para>

<!--==========================orignal english content==========================
   <para>
    On the standby, parameters <xref linkend="guc-hot-standby"/>,
    <xref linkend="guc-max-standby-archive-delay"/> and
    <xref linkend="guc-max-standby-streaming-delay"/> can be used.
    <xref linkend="guc-vacuum-defer-cleanup-age"/> has no effect
    as long as the server remains in standby mode, though it will
    become relevant if the standby becomes primary.
   </para>
____________________________________________________________________________-->
   <para>
    在主服务器上，可以使用参数<xref linkend="guc-hot-standby"/>、<xref linkend="guc-max-standby-archive-delay"/>和<xref linkend="guc-max-standby-streaming-delay"/>。只要服务器保持在后备模式<xref linkend="guc-vacuum-defer-cleanup-age"/>就没有效果，然而当后备服务器变成主服务器时它将变得相关。
   </para>
  </sect2>

  <sect2 id="hot-standby-caveats">
<!--==========================orignal english content==========================
   <title>Caveats</title>
____________________________________________________________________________-->
   <title>警告</title>

<!--==========================orignal english content==========================
   <para>
    There are several limitations of Hot Standby.
    These can and probably will be fixed in future releases:

  <itemizedlist>
   <listitem>
    <para>
     Full knowledge of running transactions is required before snapshots
     can be taken. Transactions that use large numbers of subtransactions
     (currently greater than 64) will delay the start of read-only
     connections until the completion of the longest running write transaction.
     If this situation occurs, explanatory messages will be sent to the server log.
    </para>
   </listitem>
   <listitem>
    <para>
     Valid starting points for standby queries are generated at each
     checkpoint on the primary. If the standby is shut down while the primary
     is in a shutdown state, it might not be possible to re-enter Hot Standby
     until the primary is started up, so that it generates further starting
     points in the WAL logs.  This situation isn't a problem in the most
     common situations where it might happen. Generally, if the primary is
     shut down and not available anymore, that's likely due to a serious
     failure that requires the standby being converted to operate as
     the new primary anyway.  And in situations where the primary is
     being intentionally taken down, coordinating to make sure the standby
     becomes the new primary smoothly is also standard procedure.
    </para>
   </listitem>
   <listitem>
    <para>
     At the end of recovery, <literal>AccessExclusiveLocks</literal> held by prepared transactions
     will require twice the normal number of lock table entries. If you plan
     on running either a large number of concurrent prepared transactions
     that normally take <literal>AccessExclusiveLocks</literal>, or you plan on having one
     large transaction that takes many <literal>AccessExclusiveLocks</literal>, you are
     advised to select a larger value of <varname>max_locks_per_transaction</varname>,
     perhaps as much as twice the value of the parameter on
     the primary server. You need not consider this at all if
     your setting of <varname>max_prepared_transactions</varname> is 0.
    </para>
   </listitem>
   <listitem>
    <para>
     The Serializable transaction isolation level is not yet available in hot
     standby.  (See <xref linkend="xact-serializable"/> and
     <xref linkend="serializable-consistency"/> for details.)
     An attempt to set a transaction to the serializable isolation level in
     hot standby mode will generate an error.
    </para>
   </listitem>
  </itemizedlist>

   </para>
____________________________________________________________________________-->
   <para>
    热备有一些限制。这些限制很可能在未来的发行中被修复：

  <itemizedlist>
   <listitem>
    <para>
     在能够取得快照之前，需要正在运行的事务的完整知识。使用大量子事务（目前指超过 64 个）的事务将延迟只读连接的启动，直到最长的运行着的写事务完成。如果发生这种情况，说明消息将被发送到服务器日志。
    </para>
   </listitem>
   <listitem>
    <para>
     主服务器上的每一个检查点将产生用于后备查询的可用启动点。如果后备服务器在主控机处于关闭状态时被关闭，就没有办法在主服务器启动之前重新进入热后备，因此它在 WAL 日志中产生一个进一步启动点。这种情况在它可能发生的大部分常见情况中不是一个问题。通常，如果主服务器被关闭并且不再可用，这可能是由于某种严重错误要求后备服务器被转变成为一个新的主服务器来操作。并且在主服务器被故意关闭的情况下，协调保证后备服务器平滑地过渡为新的主服务器也是一种标准过程。
    </para>
   </listitem>
   <listitem>
    <para>
     在恢复尾声，由预备事务持有的<literal>AccessExclusiveLocks</literal>将要求两倍的正常锁表项。如果你计划运行大量并发的通常要求<literal>AccessExclusiveLocks</literal>的预备事务，或者你计划运行一个需要很多<literal>AccessExclusiveLocks</literal>的大型事务，我们建议你为<varname>max_locks_per_transaction</varname>选择一个更大的值，也许是主服务器上该参数值的两倍。如果你的<varname>max_prepared_transactions</varname>设置为 0，你根本不需要考虑这个问题。
    </para>
   </listitem>
   <listitem>
    <para>
     可序列化事务隔离级别目前在热备中不可用（详见<xref linkend="xact-serializable"/>和<xref linkend="serializable-consistency"/>）。尝试在热备模式中将一个事务设置为可序列化隔离级别将产生一个错误。
    </para>
   </listitem>
  </itemizedlist>

   </para>
  </sect2>

 </sect1>

</chapter>
