<!-- doc/src/sgml/xindex.sgml -->

<sect1 id="xindex">
 <!--
 <title>Interfacing Extensions To Indexes</title>
 -->
 <title>扩展索引接口</title>

 <indexterm zone="xindex">
  <!-- 
  <primary>index</primary>
  <secondary>for user-defined data type</secondary>
  -->
  <primary>索引</primary>
  <secondary>用户定义数据类型</secondary>
 </indexterm>

  <!--
<para>
   The procedures described thus far let you define new types, new
   functions, and new operators. However, we cannot yet define an
   index on a column of a new data type.  To do this, we must define an
   <firstterm>operator class</> for the new data type.  Later in this
   section, we will illustrate this concept in an example: a new
   operator class for the B-tree index method that stores and sorts
   complex numbers in ascending absolute value order.
  </para>
-->
<para>
到目前为止描述的过程可以让你定义一个新类型、新函数、新操作符。但是，
还不能在一个新数据类型的字段上面定义一个索引。为了达到这个目的，
必须为新数据类型定义一个<firstterm>操作符类</>。下面将使用一个真实的例子来描述操作符类：
一个用于 B-tree 访问方法的新操作符类，它保存复数并按照绝对值递增的顺序排序。
</para>

  <!--
<para>
   Operator classes can be grouped into <firstterm>operator families</>
   to show the relationships between semantically compatible classes.
   When only a single data type is involved, an operator class is sufficient,
   so we'll focus on that case first and then return to operator families.
  </para>
-->
<para>
操作符类可以分类到<firstterm>操作符族</>，用以显示语义兼容的类之间的关系。
当只包含一个数据类型时，一个操作符类就足够了，所以我们首先关注这种情况，
然后再转到操作符族。
</para>

 <sect2 id="xindex-opclass">
  <!--
  <title>Index Methods and Operator Classes</title>
  -->
  <title>索引方法和操作符类</title>

  <!--
<para>
   The <classname>pg_am</classname> table contains one row for every
   index method (internally known as access method).  Support for
   regular access to tables is built into
   <productname>PostgreSQL</productname>, but all index methods are
   described in <classname>pg_am</classname>.  It is possible to add a
   new index method by defining the required interface routines and
   then creating a row in <classname>pg_am</classname> &mdash; but that is
   beyond the scope of this chapter (see <xref linkend="indexam">).
  </para>
-->
<para>
<classname>pg_am</classname>表为每个索引方法(内部称作访问方法)都包含一条记录。
对表的普通访问方法支持内建于<productname>PostgreSQL</productname> ，
但所有索引方法在<classname>pg_am</classname>里都有描述。
可以通过定义要求的接口过程并在<classname>pg_am</classname>
里创建一个新行的办法增加一个索引访问方法，不过这些些远远超出了本章的内容
(参阅<xref linkend="indexam">)。
</para>

  <!--
<para>
   The routines for an index method do not directly know anything
   about the data types that the index method will operate on.
   Instead, an <firstterm>operator
   class</><indexterm><primary>operator class</></indexterm>
   identifies the set of operations that the index method needs to use
   to work with a particular data type.  Operator classes are so
   called because one thing they specify is the set of
   <literal>WHERE</>-clause operators that can be used with an index
   (i.e., can be converted into an index-scan qualification).  An
   operator class can also specify some <firstterm>support
   procedures</> that are needed by the internal operations of the
   index method, but do not directly correspond to any
   <literal>WHERE</>-clause operator that can be used with the index.
  </para>
-->
<para>
一个索引方法的过程并不直接知道任何该索引方法将要操作的数据类型的信息。
而是<firstterm>操作符类</><indexterm><primary>操作符类</></indexterm>
表明索引方法在操作特定数据类型的时候需要使用的操作集合。
操作符类的名称的由来是因为它们声明是一种索引可以使用的<literal>WHERE</>
子句的操作符集(也就是可以转化成一个索引扫描条件)。
一个操作符类也可以声明一些索引方法需要的内部操作的<firstterm>支持过程</>，
但是它们并不直接和可以与索引一起使用的<literal>WHERE</>子句操作符相关。
</para>

  <!--
<para>
   It is possible to define multiple operator classes for the same
   data type and index method.  By doing this, multiple
   sets of indexing semantics can be defined for a single data type.
   For example, a B-tree index requires a sort ordering to be defined
   for each data type it works on.
   It might be useful for a complex-number data type
   to have one B-tree operator class that sorts the data by complex
   absolute value, another that sorts by real part, and so on.
   Typically, one of the operator classes will be deemed most commonly
   useful and will be marked as the default operator class for that
   data type and index method.
  </para>
-->
<para>
可以为同一个数据类型和索引方法定义多个操作符类。这么做的结果是，
可以为一种数据类型定义多套索引语义。比如，
一个 B-tree 索引要求为它操作的每种数据类型定义一个排序顺序。
对于一个复数数据类型而言，有一个通过复数绝对值对数据排序的 B-tree 操作符类可能会有用，
还有一个是用实部排序，等等。通常其中一个操作符类会被认为最常用的，
并且被标记为该数据类型和索引方法的缺省操作符类。
</para>

  <!--
<para>
   The same operator class name
   can be used for several different index methods (for example, both B-tree
   and hash index methods have operator classes named
   <literal>int4_ops</literal>), but each such class is an independent
   entity and must be defined separately.
  </para>
-->
<para>
同样的操作符类名字可以用于多种不同的索引方法(比如 B-tree 和 Hash 访问方法都有叫
<literal>int4_ops</literal>的操作符类)，但是每个这样的表都是一个独立的实体，必须分别定义。。
</para>
 </sect2>

 <sect2 id="xindex-strategies">
  <!--
  <title>Index Method Strategies</title>
  -->
  <title>索引方法策略</title>

  <!--
<para>
   The operators associated with an operator class are identified by
   <quote>strategy numbers</>, which serve to identify the semantics of
   each operator within the context of its operator class.
   For example, B-trees impose a strict ordering on keys, lesser to greater,
   and so operators like <quote>less than</> and <quote>greater than or equal
   to</> are interesting with respect to a B-tree.
   Because
   <productname>PostgreSQL</productname> allows the user to define operators,
   <productname>PostgreSQL</productname> cannot look at the name of an operator
   (e.g., <literal>&lt;</> or <literal>&gt;=</>) and tell what kind of
   comparison it is.  Instead, the index method defines a set of
   <quote>strategies</>, which can be thought of as generalized operators.
   Each operator class specifies which actual operator corresponds to each
   strategy for a particular data type and interpretation of the index
   semantics.
  </para>
-->
<para>
和一种操作符类相关联的操作符是通过<quote>策略号</>标识的，
策略号用于标识每种操作符在它的操作符类环境里的语义。比如，B-tree 对键字有严格的排序要求，
小于到大于，因此，像<quote>小于</>和<quote>大于或等于</>这样的操作符都是 B-tree 所感兴趣的。
因为<productname>PostgreSQL</productname>允许用户定义操作符，<productname>PostgreSQL</productname>
无法仅通过查看操作符的名字(比如<literal>&lt;</>或<literal>&gt;=</>)就明白它进行的比较是什么。
实际上，索引方法定义了一套<quote>策略</>，它可以看作一般性的操作符。
每种操作符类显示对于特定数据类型而言，是哪种实际操作符对应每种策略以及解释索引的语义。
</para>

  <!--
<para>
   The B-tree index method defines five strategies, shown in <xref
   linkend="xindex-btree-strat-table">.
  </para>
-->
<para>
B-tree 索引定义了五种策略。在<xref linkend="xindex-btree-strat-table">中显示。
</para>

   <table tocentry="1" id="xindex-btree-strat-table">
    <!--
<title>B-tree Strategies</title>
-->
<title>B-tree 策略</title>
    <tgroup cols="2">
     <thead>
      <row>
       <!--
   <entry>Operation</entry>
       <entry>Strategy Number</entry>
   -->
   <entry>操作</entry>
       <entry>策略号</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <!-- 
   <entry>less than</entry>
   -->
   <entry>小于</entry>
       <entry>1</entry>
      </row>
      <row>
       <!-- 
   <entry>less than or equal</entry>
   -->
   <entry>小于或等于</entry>
       <entry>2</entry>
      </row>
      <row>
       <!--
   <entry>equal</entry>
   -->
   <entry>等于</entry>
       <entry>3</entry>
      </row>
      <row>
       <!--
   <entry>greater than or equal</entry>
   -->
   <entry>大于或等于</entry>
       <entry>4</entry>
      </row>
      <row>
       <!--
   <entry>greater than</entry>
   -->
   <entry>大于</entry>
       <entry>5</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <!--
<para>
   Hash indexes support only equality comparisons, and so they use only one
   strategy, shown in <xref linkend="xindex-hash-strat-table">.
  </para>
-->
<para>
Hash 索引只支持平等的比较，因此它们只定义了一个策略，
在<xref linkend="xindex-hash-strat-table">里显示。
</para>

   <table tocentry="1" id="xindex-hash-strat-table">
    <!--
<title>Hash Strategies</title>
-->
<title>Hash 策略</title>
    <tgroup cols="2">
     <thead>
      <row>
       <!-- 
   <entry>Operation</entry>
       <entry>Strategy Number</entry>
   -->
   <entry>操作</entry>
       <entry>策略号</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <!--
   <entry>equal</entry>
   -->
   <entry>等于</entry>
       <entry>1</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <!--
<para>
   GiST indexes are more flexible: they do not have a fixed set of
   strategies at all.  Instead, the <quote>consistency</> support routine
   of each particular GiST operator class interprets the strategy numbers
   however it likes.  As an example, several of the built-in GiST index
   operator classes index two-dimensional geometric objects, providing
   the <quote>R-tree</> strategies shown in
   <xref linkend="xindex-rtree-strat-table">.  Four of these are true
   two-dimensional tests (overlaps, same, contains, contained by);
   four of them consider only the X direction; and the other four
   provide the same tests in the Y direction.
  </para>
-->
<para>
GiST 索引甚至更加灵活：它们根本就没有固定的策略集。实际上，
是每个特定 GiST 操作符类的<quote>一致性</>支持过程解释策略号是什么样子。作为示例，
有几个内置的 GiST 索引操作符类索引二维几何对象，提供<xref linkend="xindex-rtree-strat-table">
中所示的<quote>R-tree</>策略。其中的四个是两维测试(重叠、相同、包含、包含于)；
四个只考虑 x 坐标、四个对 y 坐标进行同样测试。
</para>

   <table tocentry="1" id="xindex-rtree-strat-table">
    <!--
<title>GiST Two-Dimensional <quote>R-tree</> Strategies</title>
-->
<title>GiST 两维<quote>R-tree</>策略</title>
    <tgroup cols="2">
     <thead>
      <row>
       <!--
   <entry>Operation</entry>
       <entry>Strategy Number</entry> 
   -->
   <entry>操作</entry>
       <entry>策略号</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <!-- 
   <entry>strictly left of</entry>
   -->
   <entry>严格地在...左边</entry>
       <entry>1</entry>
      </row>
      <row>
       <!--
   <entry>does not extend to right of</entry>
   -->
   <entry>不扩展到...右边</entry>
       <entry>2</entry>
      </row>
      <row>
       <!--
   <entry>overlaps</entry>
   -->
   <entry>重叠</entry>
       <entry>3</entry>
      </row>
      <row>
       <!--
   <entry>does not extend to left of</entry>
   -->
   <entry>不延伸到...左边</entry>
       <entry>4</entry>   
      </row>
      <row>
       <!--
   <entry>strictly right of</entry>
   -->
   <entry>严格地在...右边</entry>
       <entry>5</entry>
      </row>
      <row>
       <!-- 
   <entry>same</entry>
   -->
   <entry>相同</entry>
       <entry>6</entry>
      </row>
      <row>
       <!-- 
   <entry>contains</entry>
   -->
   <entry>包含</entry>
       <entry>7</entry>
      </row>
      <row>
       <!--
   <entry>contained by</entry>
   -->
   <entry>包含于</entry>
       <entry>8</entry>
      </row>
      <row>
       <!--
   <entry>does not extend above</entry>
   -->
   <entry>不扩展到...上面</entry>
       <entry>9</entry>
      </row>
      <row>
       <!-- 
   <entry>strictly below</entry>
   -->
   <entry>严格地在...下面</entry>
       <entry>10</entry>
      </row>
      <row>
       <!--
   <entry>strictly above</entry>
   -->
   <entry>严格地在...上面</entry>
       <entry>11</entry>
      </row>
      <row>
       <!--
   <entry>does not extend below</entry>
   -->
   <entry>不扩展到...下面</entry>
       <entry>12</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <!--
<para>
   SP-GiST indexes are similar to GiST indexes in flexibility: they don't have
   a fixed set of strategies. Instead the support routines of each operator
   class interpret the strategy numbers according to the operator class's
   definition. As an example, the strategy numbers used by the built-in
   operator classes for points are shown in <xref
   linkend="xindex-spgist-point-strat-table">.
  </para>
-->
<para>
SP-GiST索引在灵活性方面与 GiST 索引类似：它们都没有一个固定的策略集，
而是由每个操作符类的支持过程根据操作符类的定义来解释策略号。作为示例，
<xref linkend="xindex-spgist-point-strat-table">显示了内置的点操作符类使用的策略号。
</para>

   <table tocentry="1" id="xindex-spgist-point-strat-table">
    <!-- 
<title>SP-GiST Point Strategies</title>
-->
<title>SP-GiST 点策略</title>
    <tgroup cols="2">
     <thead>
      <row>
       <!--
   <entry>Operation</entry>
       <entry>Strategy Number</entry>
   -->
   <entry>操作</entry>
       <entry>策略号</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <!-- 
   <entry>strictly left of</entry>
   -->
   <entry>严格在左边</entry>
       <entry>1</entry>
      </row>
      <row>
       <!-- 
   <entry>strictly right of</entry>
   -->
   <entry>严格在右边</entry>
       <entry>5</entry>
      </row>
      <row>
       <!--
   <entry>same</entry>
   -->
   <entry>相同</entry>
       <entry>6</entry>
      </row>
      <row>
       <!--
   <entry>contained by</entry>
   -->
   <entry>包含</entry>
       <entry>8</entry>
      </row>
      <row>
       <!--
   <entry>strictly below</entry>
   -->
   <entry>严格在下面</entry>
       <entry>10</entry>
      </row>
      <row>
       <!-- 
   <entry>strictly above</entry>
   -->
   <entry>严格在上面</entry>
       <entry>11</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <!--
<para>
   GIN indexes are similar to GiST and SP-GiST indexes, in that they don't
   have a fixed set of strategies either. Instead the support routines of
   each operator class interpret the strategy numbers according to the
   operator class's definition. As an example, the strategy numbers used by
   the built-in operator classes for arrays are shown in
   <xref linkend="xindex-gin-array-strat-table">.
  </para>
-->
<para>
GIN 索引与 GiST 索引和SP-GiST 索引类似：它们都没有一个固定的策略集，
而是由每个操作符类的支持过程根据操作符类的定义来解释策略号。作为示例，
<xref linkend="xindex-gin-array-strat-table">显示了内置的数组操作符类使用的策略号。
</para>

   <table tocentry="1" id="xindex-gin-array-strat-table">
    <!--
<title>GIN Array Strategies</title>
-->
<title>GIN 数组策略</title>
    <tgroup cols="2">
     <thead>
      <row>
       <!--
   <entry>Operation</entry>
       <entry>Strategy Number</entry>
   -->
   <entry>操作</entry>
       <entry>策略号</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <!--
   <entry>overlap</entry>
   -->
   <entry>重叠</entry>
       <entry>1</entry>
      </row>
      <row>
       <!--
   <entry>contains</entry> 
   -->
   <entry>包含</entry>
       <entry>2</entry>
      </row>
      <row>
       <!-- 
   <entry>is contained by</entry>
   -->
   <entry>包含于</entry>
       <entry>3</entry>
      </row>
      <row>
       <!--
   <entry>equal</entry>
   -->
   <entry>相等</entry>
       <entry>4</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <!--
<para>
   Notice that all the operators listed above return Boolean values.  In
   practice, all operators defined as index method search operators must
   return type <type>boolean</type>, since they must appear at the top
   level of a <literal>WHERE</> clause to be used with an index.
   (Some index access methods also support <firstterm>ordering operators</>,
   which typically don't return Boolean values; that feature is discussed
   in <xref linkend="xindex-ordering-ops">.)
  </para>
-->
<para>
请注意，所有上述操作符都返回布尔值。实际上，所有定义为索引方法搜索操作符的操作符都必须返回
<type>boolean</type>类型，因为它们必须出现在一个<literal>WHERE</>子句的顶层，
这样才能被一个索引使用。（某些索引访问方法也支持<firstterm>顺序操作符</>，
它们通常不反悔Boolean值；这个特征在<xref linkend="xindex-ordering-ops">里讨论。）
</para>
 </sect2>

 <sect2 id="xindex-support">
  <!--
  <title>Index Method Support Routines</title>
  -->
  <title>索引方法支持过程</title>

  <!--
<para>
   Strategies aren't usually enough information for the system to figure
   out how to use an index.  In practice, the index methods require
   additional support routines in order to work. For example, the B-tree
   index method must be able to compare two keys and determine whether one
   is greater than, equal to, or less than the other.  Similarly, the
   hash index method must be able to compute hash codes for key values.
   These operations do not correspond to operators used in qualifications in
   SQL commands;  they are administrative routines used by
   the index methods, internally.
  </para>
-->
<para>
有时候，策略的信息还不足以让系统决定如何使用某个索引。在实际中，
索引方法需要附加的一些过程来保证正常工作。例如，
B-tree 索引方法必须能够比较两个键字以决定其中一个是大于、等于、还是小于另外一个。
类似的还有 Hash 索引方法必须能够在键值上计算散列值。
这些操作和 SQL 命令条件里使用的操作符并不对应；它们是在内部被索引方法使用的管理过程。
</para>

  <!--
<para>
   Just as with strategies, the operator class identifies which specific
   functions should play each of these roles for a given data type and
   semantic interpretation.  The index method defines the set
   of functions it needs, and the operator class identifies the correct
   functions to use by assigning them to the <quote>support function numbers</>
   specified by the index method.
  </para>
-->
<para>
就像策略一样，操作符类声明在一定的数据类型和语义解释的条件下，
哪个特定函数对应这些角色中的哪一个。索引方法声明它需要的函数集，
而操作符类通过给它们赋予通过索引方法指定的<quote>支持函数编号</>来标识要正确使用的函数。
</para>

  <!--
<para>
   B-trees require a single support function, and allow a second one to be
   supplied at the operator class author's option, as shown in <xref
   linkend="xindex-btree-support-table">.
  </para>
-->
<para>
B-tree 需要一个支持函数，并且允许在操作符类作者的选项中提供第二个，
就像<xref linkend="xindex-btree-support-table">里显示的那样。
</para>

   <table tocentry="1" id="xindex-btree-support-table">
    <!-- 
<title>B-tree Support Functions</title>
-->
<title>B-tree 支持函数</title>
    <tgroup cols="2">
     <thead>
      <row>
       <!--
   <entry>Function</entry>
       <entry>Support Number</entry>
   -->
   <entry>函数</entry>
       <entry>支持号</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <!--
Compare two keys and return an integer less than zero, zero, or
        greater than zero, indicating whether the first key is less than,
        equal to, or greater than the second
-->
比较两个键字并且返回一个小于、等于、大于零的整数，标识第一个键字小于、
等于、大于第二个键字。
       </entry>
       <entry>1</entry>
      </row>
      <row>
       <entry>
        <!--
Return the addresses of C-callable sort support function(s),
        as documented in <filename>utils/sortsupport.h</> (optional)
-->
返回C-callable排序支持函数的地址，记录在<filename>utils/sortsupport.h</>（可选）
       </entry>
       <entry>2</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <!--
<para>
   Hash indexes require one support function, shown in <xref
   linkend="xindex-hash-support-table">.
  </para>
-->
<para>
Hash 索引也需要一个支持函数，在<xref linkend="xindex-hash-support-table">里显示。
</para>

   <table tocentry="1" id="xindex-hash-support-table">
    <!-- 
<title>Hash Support Functions</title>
-->
<title>Hash 支持函数</title>
    <tgroup cols="2">
     <thead>
      <row>
       <!--
   <entry>Function</entry>
       <entry>Support Number</entry>
   -->
   <entry>函数</entry>
       <entry>支持号</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <!-- 
   <entry>Compute the hash value for a key</entry>
   -->
   <entry>为一个键字计算散列值</entry>
       <entry>1</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <!--
<para>
   GiST indexes require seven support functions, with an optional eighth, as
   shown in <xref linkend="xindex-gist-support-table">.
   (For more information see <xref linkend="GiST">.)
  </para>
-->
<para>
GiST 索引需要七种支持函数，和一个可选的函数，在<xref linkend="xindex-gist-support-table">里显示。
（更多信息请参考<xref linkend="GiST">。）
</para>

   <table tocentry="1" id="xindex-gist-support-table">
    <!--
<title>GiST Support Functions</title>
-->
<title>GiST 支持函数</title>
    <tgroup cols="3">
     <thead>
      <row>
       <!--
   <entry>Function</entry>
       <entry>Description</entry>
       <entry>Support Number</entry>
   -->
   <entry>函数</entry>
       <entry>描述</entry>
       <entry>支持号</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><function>consistent</></entry>
       <!--
   <entry>determine whether key satisfies the
        query qualifier</entry>
-->
<entry>检测键是否满足查询限定符</entry>
       <entry>1</entry>
      </row>
      <row>
       <entry><function>union</></entry>
       <!-- 
   <entry>compute union of a set of keys</entry>
   -->
   <entry>计算一套键的联合</entry>
       <entry>2</entry>
      </row>
      <row>
       <entry><function>compress</></entry>
       <!--
   <entry>compute a compressed representation of a key or value
        to be indexed</entry>
-->
<entry>计算已索引键或值的压缩结果</entry>
       <entry>3</entry>
      </row>
      <row>
       <entry><function>decompress</></entry>
       <!--
   <entry>compute a decompressed representation of a
        compressed key</entry>
-->
<entry>计算已压缩键的解压结果</entry>
       <entry>4</entry>
      </row>
      <row>
       <entry><function>penalty</></entry>
       <!-- 
   <entry>compute penalty for inserting new key into subtree
       with given subtree's key</entry>
   -->
   <entry>计算使用给定的子树的键向子树中插入新键的性能恶化(penalty）</entry>
       <entry>5</entry>
      </row>
      <row>
       <entry><function>picksplit</></entry>
       <!--
   <entry>determine which entries of a page are to be moved
       to the new page and compute the union keys for resulting pages</entry>
   -->
   <entry>检测页面中的哪个项将被移动到新页面并为结果页计算联合键</entry>
       <entry>6</entry>
      </row>
      <row>
       <entry><function>equal</></entry>
       <!--
   <entry>compare two keys and return true if they are equal</entry>
   -->
   <entry>比较两个键并在相等时返回真</entry>
       <entry>7</entry>
      </row>
      <row>
       <entry><function>distance</></entry>
       <!--
   <entry>determine distance from key to query value (optional)</entry>
   -->
   <entry>确定键到查询值的距离（可选）</entry>
       <entry>8</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <!--
<para>
   SP-GiST indexes require five support functions, as
   shown in <xref linkend="xindex-spgist-support-table">.
   (For more information see <xref linkend="SPGiST">.)
  </para>
-->
<para>
SP-GiST索引需要五种支持函数，显示在<xref linkend="xindex-spgist-support-table">中。
（更多信息请参阅<xref linkend="SPGiST">。）
</para>

   <table tocentry="1" id="xindex-spgist-support-table">
    <!--
<title>SP-GiST Support Functions</title>
-->
<title>SP-GiST 支持函数</title>
    <tgroup cols="3">
     <thead>
      <row>
       <!--
   <entry>Function</entry>
       <entry>Description</entry>
       <entry>Support Number</entry>
   -->
   <entry>函数</entry>
       <entry>描述</entry>
       <entry>支持号</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><function>config</></entry>
       <!--
   <entry>provide basic information about the operator class</entry>
   -->
   <entry>提供操作符类的基本信息</entry>
       <entry>1</entry>
      </row>
      <row>
       <entry><function>choose</></entry>
       <!--
   <entry>determine how to insert a new value into an inner tuple</entry>
   -->
   <entry>确定如何将一个新值插入一个内在的元组</entry>
       <entry>2</entry>
      </row>
      <row>
       <entry><function>picksplit</></entry>
       <!-- 
   <entry>determine how to partition a set of values</entry>
   -->
   <entry>确定如何分区一组值</entry>
       <entry>3</entry>
      </row>
      <row>
       <entry><function>inner_consistent</></entry>
       <!--
   <entry>determine which sub-partitions need to be searched for a
        query</entry>
-->
<entry>确定哪个子分区需要为一个查询搜索</entry>
       <entry>4</entry>
      </row>
      <row>
       <entry><function>leaf_consistent</></entry>
       <!--
   <entry>determine whether key satisfies the
        query qualifier</entry>
-->
<entry>确定哪个键满足查询条件</entry>
       <entry>5</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <!--
<para>
   GIN indexes require four support functions, with an optional fifth, as
   shown in <xref linkend="xindex-gin-support-table">.
   (For more information see <xref linkend="GIN">.)
  </para>
-->
<para>
GIN 索引需要四种支持函数，和一个可选的函数，在<xref linkend="xindex-gin-support-table">里显示。
（更多信息请参阅<xref linkend="GIN">。）
</para>

   <table tocentry="1" id="xindex-gin-support-table">
    <!--
<title>GIN Support Functions</title>
-->
<title>GIN 支持函数</title>
    <tgroup cols="3">
     <thead>
      <row>
       <!--
   <entry>Function</entry>
       <entry>Description</entry>
       <entry>Support Number</entry>
   -->
   <entry>函数</entry>
       <entry>描述</entry>
       <entry>支持号</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><function>compare</></entry>
       <entry>
        <!--
compare two keys and return an integer less than zero, zero,
        or greater than zero, indicating whether the first key is less than,
        equal to, or greater than the second
-->
比较两个键并返回一个小于、等于、大于零的整数，标识第一个键小于、等于、大于第二个键。
       </entry>
       <entry>1</entry>
      </row>
      <row>
       <entry><function>extractValue</></entry>
       <!-- 
   <entry>extract keys from a value to be indexed</entry>
   -->
   <entry>从将被索引的值中抽取键</entry>
       <entry>2</entry>
      </row>
      <row>
       <entry><function>extractQuery</></entry>
       <!--
   <entry>extract keys from a query condition</entry>
   -->
   <entry>从查询条件中抽取键</entry>
       <entry>3</entry>
      </row>
      <row>
       <entry><function>consistent</></entry>
       <!--
   <entry>determine whether value matches query condition</entry>
   -->
   <entry>检测值是否匹配查询条件</entry>
       <entry>4</entry>
      </row>
      <row>
       <entry><function>comparePartial</></entry>
       <entry>
        <!--
compare partial key from
        query and key from index, and return an integer less than zero, zero,
        or greater than zero, indicating whether GIN should ignore this index
        entry, treat the entry as a match, or stop the index scan (optional)
-->
比较部分来自查询的键和来自索引的键，并返回一个小于、等于、大于零的整数，
标识是否GIN应该忽略这个索引项，将这个项视为一个匹配，或停止索引扫描（可选）。
       </entry>
       <entry>5</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <!--
<para>
   Unlike search operators, support functions return whichever data
   type the particular index method expects; for example in the case
   of the comparison function for B-trees, a signed integer.  The number
   and types of the arguments to each support function are likewise
   dependent on the index method.  For B-tree and hash the comparison and
   hashing support functions take the same input data types as do the
   operators included in the operator class, but this is not the case for
   most GiST, SP-GiST, and GIN support functions.
  </para>
-->
<para>
和搜索操作符不同，支持函数返回特定索引方法预期的数据类型，比如在 B-tree 的情况下，
返回一个有符号整数。每个支持函数的参数的数字和类型也取决于索引方法。
对于B-tree和hash的比较，散列支持函数接受相同的输入数据类型，同样操作符也包含在操作符类里，
但是大多数GiST, SP-GiST, 和GIN 支持函数不是这样的。
</para>
 </sect2>

 <sect2 id="xindex-example">
  <!--
  <title>An Example</title>
  -->
  <title>例子</title>

  <!--
<para>
   Now that we have seen the ideas, here is the promised example of
   creating a new operator class.
   (You can find a working copy of this example in
   <filename>src/tutorial/complex.c</filename> and
   <filename>src/tutorial/complex.sql</filename> in the source
   distribution.)
   The operator class encapsulates
   operators that sort complex numbers in absolute value order, so we
   choose the name <literal>complex_abs_ops</literal>.  First, we need
   a set of operators.  The procedure for defining operators was
   discussed in <xref linkend="xoper">.  For an operator class on
   B-trees, the operators we require are:

   <itemizedlist spacing="compact">
    <listitem><simpara>absolute-value less-than (strategy 1)</></>
    <listitem><simpara>absolute-value less-than-or-equal (strategy 2)</></>
    <listitem><simpara>absolute-value equal (strategy 3)</></>
    <listitem><simpara>absolute-value greater-than-or-equal (strategy 4)</></>
    <listitem><simpara>absolute-value greater-than (strategy 5)</></>
   </itemizedlist>
  </para>
-->
<para>
既然已经了解了这些概念，那么现在就来看一个创建新操作符类的例子。你可以在源代码的
<filename>src/tutorial/complex.c</filename>和<filename>src/tutorial/complex.sql</filename>
中找到这里讲述的例子。操作符类封装了那些以绝对值顺序对复数排序的操作符，这样就可以选择
<literal>complex_abs_ops</literal>这个名字。首先，需要一个操作符集合。
用于定义操作符的过程已经在<xref linkend="xoper">讨论过了。对这个用于 B-tree 的操作符类，
需要的操作符是：
<itemizedlist spacing="compact">
    <listitem><simpara>绝对值 小于 (策略 1)</></>
    <listitem><simpara>绝对值 小于等于 (策略 2)</></>
    <listitem><simpara>绝对值 等于 (策略 3)</></>
    <listitem><simpara>绝对值 大于等于 (策略 4)</></>
    <listitem><simpara>绝对值 大于 (策略 5)</></>
   </itemizedlist>
</para>
  
<para>
<!--
   The least error-prone way to define a related set of comparison operators
   is to write the B-tree comparison support function first, and then write the
   other functions as one-line wrappers around the support function.  This
   reduces the odds of getting inconsistent results for corner cases.
   Following this approach, we first write:
-->
定义一组相关的比较操作符最不容易出错的方法是首先写出 B-tree 比较支持函数，
然后再写出其它封装了支持函数的单行函数。这就减少了某些情况下导致不一致结果的机会。
根据这个指引，首先写出：
<programlisting><![CDATA[
#define Mag(c)  ((c)->x*(c)->x + (c)->y*(c)->y)

static int
complex_abs_cmp_internal(Complex *a, Complex *b)
{
    double      amag = Mag(a),
                bmag = Mag(b);

    if (amag < bmag)
        return -1;
    if (amag > bmag)
        return 1;
    return 0;
}
]]>
</programlisting>
<!--
   Now the less-than function looks like:
-->
现在，小于函数看起来像这样：
<programlisting><![CDATA[
PG_FUNCTION_INFO_V1(complex_abs_lt);

Datum
complex_abs_lt(PG_FUNCTION_ARGS)
{
    Complex    *a = (Complex *) PG_GETARG_POINTER(0);
    Complex    *b = (Complex *) PG_GETARG_POINTER(1);

    PG_RETURN_BOOL(complex_abs_cmp_internal(a, b) < 0);
}
]]>
</programlisting>
<!-- 
   The other four functions differ only in how they compare the internal
   function's result to zero.
-->
其它四个函数的不同之处仅在它们如何将内部函数的结果与零比较。
  </para>
  
<para>
<!--
   Next we declare the functions and the operators based on the functions
   to SQL:
-->
下一步，基于 SQL 函数声明函数和操作符：
<programlisting>
CREATE FUNCTION complex_abs_lt(complex, complex) RETURNS bool
    AS '<replaceable>filename</replaceable>', 'complex_abs_lt'
    LANGUAGE C IMMUTABLE STRICT;

CREATE OPERATOR &lt; (
   leftarg = complex, rightarg = complex, procedure = complex_abs_lt,
   commutator = &gt; , negator = &gt;= ,
   restrict = scalarltsel, join = scalarltjoinsel
);
</programlisting>
<!-- 
   It is important to specify the correct commutator and negator operators,
   as well as suitable restriction and join selectivity
   functions, otherwise the optimizer will be unable to make effective
   use of the index.  Note that the less-than, equal, and
   greater-than cases should use different selectivity functions. 
-->
指定正确的交换器和"非"操作符以及适当的限制和连接选择性函数都是非常重要的，
否则优化器将无法有效地利用索引。请注意，小于、等于、
大于三种情况下应该使用不同的选择性函数。
  </para>
  
<para>
<!--
   Other things worth noting are happening here:
-->
其它几个值得注意的问题：
  <itemizedlist>
   <listitem>
<!-- 
    <para>
     There can only be one operator named, say, <literal>=</literal>
     and taking type <type>complex</type> for both operands.  In this
     case we don't have any other operator <literal>=</literal> for
     <type>complex</type>, but if we were building a practical data
     type we'd probably want <literal>=</literal> to be the ordinary
     equality operation for complex numbers (and not the equality of
     the absolute values).  In that case, we'd need to use some other
     operator name for <function>complex_abs_eq</>.
    </para>
 -->
<para>
只可以有一个已命名操作符 <literal>=</literal>把<type>complex</type>类型做为其两个操作数。
这种情况下没有其它用于<type>complex</type>的<literal>=</literal>操作符，
但是如果要制作一个实用的数据类型，可能需要<literal>=</literal>做为复数的普通等于操作。
这种情况下，可能需要使用一些其它操作符名称来命名<function>complex_abs_eq</>。
</para>
   </listitem>

   <listitem>
    <!--
<para>
     Although <productname>PostgreSQL</productname> can cope with
     functions having the same SQL name as long as they have different
     argument data types, C can only cope with one global function
     having a given name.  So we shouldn't name the C function
     something simple like <filename>abs_eq</filename>.  Usually it's
     a good practice to include the data type name in the C function
     name, so as not to conflict with functions for other data types.
    </para>
-->
<para>
尽管<productname>PostgreSQL</productname>可以处理 SQL 名字相同的函数，
只要它们的输入数据类型不同，而 C 只能处理一个具有给定名称的全局过程。
因此不能把 C 函数命名为像<filename>abs_eq</filename>这样简单的名字。
通常在 C 函数名里面包含数据类型名称是一个好习惯，这样就不会和用于其它数据类型的函数冲突。
</para>
   </listitem>

   <listitem>
    <!--
<para>
     We could have made the SQL name
     of the function <filename>abs_eq</filename>, relying on
     <productname>PostgreSQL</productname> to distinguish it by
     argument data types from any other SQL function of the same name.
     To keep the example simple, we make the function have the same
     names at the C level and SQL level.
    </para>
-->
<para>
可以制作名为<filename>abs_eq</filename>的 SQL 函数，依靠<productname>PostgreSQL</productname>
通过输入数据类型的不同来区分任何其它同名 SQL 函数。为了令例子简单，
做的函数在 C 层次和 SQL 层次都有相同的名称。
</para>
   </listitem>
  </itemizedlist>
  </para>
  
<para>
<!--
   The next step is the registration of the support routine required
   by B-trees.  The example C code that implements this is in the same
   file that contains the operator functions.  This is how we declare
   the function:
-->
下一步是注册 B-tree 需要的"支持过程"。实现这个例子的 C 代码在包含操作符函数的同一个文件中，
下面是定义函数的方法：
<programlisting>
CREATE FUNCTION complex_abs_cmp(complex, complex)
    RETURNS integer
    AS '<replaceable>filename</replaceable>'
    LANGUAGE C IMMUTABLE STRICT;
</programlisting>
  </para>
  
<para>
<!--
   Now that we have the required operators and support routine,
   we can finally create the operator class:
-->
既然已经有了需要的操作符和支持过程，就可以最后创建这个操作符类了：
<programlisting><![CDATA[
CREATE OPERATOR CLASS complex_abs_ops
    DEFAULT FOR TYPE complex USING btree AS
        OPERATOR        1       < ,
        OPERATOR        2       <= ,
        OPERATOR        3       = ,
        OPERATOR        4       >= ,
        OPERATOR        5       > ,
        FUNCTION        1       complex_abs_cmp(complex, complex);
]]>
</programlisting>
  </para>

  <!--
<para>
   And we're done!  It should now be possible to create
   and use B-tree indexes on <type>complex</type> columns.
  </para>
-->
<para>
这样就完成了！现在可以在一个<type>complex</type>列上创建和使用 B-tree 索引了。
</para>

  <!--
<para>
   We could have written the operator entries more verbosely, as in:
<programlisting>
        OPERATOR        1       &lt; (complex, complex) ,
</programlisting>
   but there is no need to do so when the operators take the same data type
   we are defining the operator class for.
  </para>
-->
<para>
可以把操作符记录写得更冗余一些，像：
<programlisting>
        OPERATOR        1       &lt; (complex, complex) ,
</programlisting>
但是如果该操作符接受的数据类型是定义的操作符类处理的东西，那就没必要这么做。
</para>

  <!--
<para>
   The above example assumes that you want to make this new operator class the
   default B-tree operator class for the <type>complex</type> data type.
   If you don't, just leave out the word <literal>DEFAULT</>.
  </para>
-->
<para>
上面的例子假设你想把这个新操作符类作为<type>complex</type>数据类型的缺省 B-tree 操作符类。
如果你不想这么做，只要去掉关键字<literal>DEFAULT</>即可。
</para>
 </sect2>

 <sect2 id="xindex-opfamily">
  <!--
  <title>Operator Classes and Operator Families</title>
  -->
  <title>操作符类和操作符族</title>

  <!--
<para>
   So far we have implicitly assumed that an operator class deals with
   only one data type.  While there certainly can be only one data type in
   a particular index column, it is often useful to index operations that
   compare an indexed column to a value of a different data type.  Also,
   if there is use for a cross-data-type operator in connection with an
   operator class, it is often the case that the other data type has a
   related operator class of its own.  It is helpful to make the connections
   between related classes explicit, because this can aid the planner in
   optimizing SQL queries (particularly for B-tree operator classes, since
   the planner contains a great deal of knowledge about how to work with them).
  </para>
-->
<para>
到目前为止我们都隐含的假定一个操作符类只能处理一种数据类型。
虽然每个索引字段都只能是单独一种数据类型，
但是使用索引操作符来比较一个已索引字段和一个不同类型的值常常很有用处。
如果有用于与一个操作符类连接的交叉数据类型操作符，通常是其他数据类型有他自己的相关的操作符类。
这对于在相关的类之间明确的建立连接是有帮助的，因为这可以帮助规划器优化SQL查询
（尤其对于B-tree操作符类，因为规划器包含大量的关于如果处理这些问题的信息）。
</para>

  <!--
<para>
   To handle these needs, <productname>PostgreSQL</productname>
   uses the concept of an <firstterm>operator
   family</><indexterm><primary>operator family</></indexterm>.
   An operator family contains one or more operator classes, and can also
   contain indexable operators and corresponding support functions that
   belong to the family as a whole but not to any single class within the
   family.  We say that such operators and functions are <quote>loose</>
   within the family, as opposed to being bound into a specific class.
   Typically each operator class contains single-data-type operators
   while cross-data-type operators are loose in the family.
  </para>
-->
<para>
为了处理这种需求，<productname>PostgreSQL</productname>使用<firstterm>操作符族</><indexterm>
<primary>操作符族</></indexterm>的概念。一个操作符族包含一个或多个操作符类，
也可以包含可索引的操作符和对应的支持函数，作为一个整体属于这个族，但不是这个族中的任何一个类。
我们说这样的操作符和函数是<quote>松散</>在族里的，而不是被绑定到一个特定的类。
通常每个操作符类包含一个数据类型操作符，而交叉数据类型操作符是散落在族里的。
</para>

  <!--
<para>
   All the operators and functions in an operator family must have compatible
   semantics, where the compatibility requirements are set by the index
   method.  You might therefore wonder why bother to single out particular
   subsets of the family as operator classes; and indeed for many purposes
   the class divisions are irrelevant and the family is the only interesting
   grouping.  The reason for defining operator classes is that they specify
   how much of the family is needed to support any particular index.
   If there is an index using an operator class, then that operator class
   cannot be dropped without dropping the index &mdash; but other parts of
   the operator family, namely other operator classes and loose operators,
   could be dropped.  Thus, an operator class should be specified to contain
   the minimum set of operators and functions that are reasonably needed
   to work with an index on a specific data type, and then related but
   non-essential operators can be added as loose members of the operator
   family.
  </para>
-->
<para>
所有在一个操作符族里的操作符和函数必须有兼容的语法，兼容性需求是通过索引方法设置的。
你可能想知道为什么费心的挑选出特别的族的子集作为操作符类；
并且甚至为了多种目的类的区分是不相关的，族只对分组感兴趣。
定义操作符类的原因是指定多少族需要支持任何特定的索引。如果有一个索引使用一个操作符类，
然后操作符类不能在不删除索引的情况下被删除，但是操作符族的其他部分，
即其他操作符类和松散的操作符可以被删除。因此，一个操作符类应该被指定包含最少的操作符和函数，
应该是在一个特定数据类型上索引工作所需要的适当的操作符和函数，
然后相关的但非重要的操作符可以作为松散的操作符族成员添加。
</para>
  
<para>
<!--
   As an example, <productname>PostgreSQL</productname> has a built-in
   B-tree operator family <literal>integer_ops</>, which includes operator
   classes <literal>int8_ops</>, <literal>int4_ops</>, and
   <literal>int2_ops</> for indexes on <type>bigint</> (<type>int8</>),
   <type>integer</> (<type>int4</>), and <type>smallint</> (<type>int2</>)
   columns respectively.  The family also contains cross-data-type comparison
   operators allowing any two of these types to be compared, so that an index
   on one of these types can be searched using a comparison value of another
   type.  The family could be duplicated by these definitions:
-->
作为一个例子，<productname>PostgreSQL</productname>有一个内置的B-tree操作符族<literal>integer_ops</>，
它包含操作符类<literal>int8_ops</>， <literal>int4_ops</>和<literal>int2_ops</>，
分别对 <type>bigint</> (<type>int8</>),  <type>integer</> (<type>int4</>), 和 <type>smallint</> (<type>int2</>)
字段索引。也包含交叉数据类型比较操作符，允许其中的任意两种类型进行比较，
所以任意其中一种类型上的索引可以使用其他类型的比较值被搜索到。
族可以通过下面的定义复制：
<!--
<programlisting><![CDATA[
CREATE OPERATOR FAMILY integer_ops USING btree;

CREATE OPERATOR CLASS int8_ops
DEFAULT FOR TYPE int8 USING btree FAMILY integer_ops AS
  &#045;- standard int8 comparisons
  OPERATOR 1 < ,
  OPERATOR 2 <= ,
  OPERATOR 3 = ,
  OPERATOR 4 >= ,
  OPERATOR 5 > ,
  FUNCTION 1 btint8cmp(int8, int8) ,
  FUNCTION 2 btint8sortsupport(internal) ;

CREATE OPERATOR CLASS int4_ops
DEFAULT FOR TYPE int4 USING btree FAMILY integer_ops AS
  &#045;- standard int4 comparisons
  OPERATOR 1 < ,
  OPERATOR 2 <= ,
  OPERATOR 3 = ,
  OPERATOR 4 >= ,
  OPERATOR 5 > ,
  FUNCTION 1 btint4cmp(int4, int4) ,
  FUNCTION 2 btint4sortsupport(internal) ;

CREATE OPERATOR CLASS int2_ops
DEFAULT FOR TYPE int2 USING btree FAMILY integer_ops AS
  &#045;- standard int2 comparisons
  OPERATOR 1 < ,
  OPERATOR 2 <= ,
  OPERATOR 3 = ,
  OPERATOR 4 >= ,
  OPERATOR 5 > ,
  FUNCTION 1 btint2cmp(int2, int2) ,
  FUNCTION 2 btint2sortsupport(internal) ;

ALTER OPERATOR FAMILY integer_ops USING btree ADD
  &#045;- cross-type comparisons int8 vs int2
  OPERATOR 1 < (int8, int2) ,
  OPERATOR 2 <= (int8, int2) ,
  OPERATOR 3 = (int8, int2) ,
  OPERATOR 4 >= (int8, int2) ,
  OPERATOR 5 > (int8, int2) ,
  FUNCTION 1 btint82cmp(int8, int2) ,

  &#045;- cross-type comparisons int8 vs int4
  OPERATOR 1 < (int8, int4) ,
  OPERATOR 2 <= (int8, int4) ,
  OPERATOR 3 = (int8, int4) ,
  OPERATOR 4 >= (int8, int4) ,
  OPERATOR 5 > (int8, int4) ,
  FUNCTION 1 btint84cmp(int8, int4) ,

  &#045;- cross-type comparisons int4 vs int2
  OPERATOR 1 < (int4, int2) ,
  OPERATOR 2 <= (int4, int2) ,
  OPERATOR 3 = (int4, int2) ,
  OPERATOR 4 >= (int4, int2) ,
  OPERATOR 5 > (int4, int2) ,
  FUNCTION 1 btint42cmp(int4, int2) ,

  &#045;- cross-type comparisons int4 vs int8
  OPERATOR 1 < (int4, int8) ,
  OPERATOR 2 <= (int4, int8) ,
  OPERATOR 3 = (int4, int8) ,
  OPERATOR 4 >= (int4, int8) ,
  OPERATOR 5 > (int4, int8) ,
  FUNCTION 1 btint48cmp(int4, int8) ,

  &#045;- cross-type comparisons int2 vs int8
  OPERATOR 1 < (int2, int8) ,
  OPERATOR 2 <= (int2, int8) ,
  OPERATOR 3 = (int2, int8) ,
  OPERATOR 4 >= (int2, int8) ,
  OPERATOR 5 > (int2, int8) ,
  FUNCTION 1 btint28cmp(int2, int8) ,

  &#045;- cross-type comparisons int2 vs int4
  OPERATOR 1 < (int2, int4) ,
  OPERATOR 2 <= (int2, int4) ,
  OPERATOR 3 = (int2, int4) ,
  OPERATOR 4 >= (int2, int4) ,
  OPERATOR 5 > (int2, int4) ,
  FUNCTION 1 btint24cmp(int2, int4) ;
]]>
</programlisting>
-->
<programlisting><![CDATA[
CREATE OPERATOR FAMILY integer_ops USING btree;

CREATE OPERATOR CLASS int8_ops
DEFAULT FOR TYPE int8 USING btree FAMILY integer_ops AS
  -- 标准 int8 比较
  OPERATOR 1 < ,
  OPERATOR 2 <= ,
  OPERATOR 3 = ,
  OPERATOR 4 >= ,
  OPERATOR 5 > ,
  FUNCTION 1 btint8cmp(int8, int8) ,
  FUNCTION 2 btint8sortsupport(internal) ;

CREATE OPERATOR CLASS int4_ops
DEFAULT FOR TYPE int4 USING btree FAMILY integer_ops AS
  -- 标准 int4 比较
  OPERATOR 1 < ,
  OPERATOR 2 <= ,
  OPERATOR 3 = ,
  OPERATOR 4 >= ,
  OPERATOR 5 > ,
  FUNCTION 1 btint4cmp(int4, int4) ,
  FUNCTION 2 btint4sortsupport(internal) ;

CREATE OPERATOR CLASS int2_ops
DEFAULT FOR TYPE int2 USING btree FAMILY integer_ops AS
  --标准 int2 比较
  OPERATOR 1 < ,
  OPERATOR 2 <= ,
  OPERATOR 3 = ,
  OPERATOR 4 >= ,
  OPERATOR 5 > ,
  FUNCTION 1 btint2cmp(int2, int2) ,
  FUNCTION 2 btint2sortsupport(internal) ;

ALTER OPERATOR FAMILY integer_ops USING btree ADD
  -- 交叉类型比较 int8 对 int2
  OPERATOR 1 < (int8, int2) ,
  OPERATOR 2 <= (int8, int2) ,
  OPERATOR 3 = (int8, int2) ,
  OPERATOR 4 >= (int8, int2) ,
  OPERATOR 5 > (int8, int2) ,
  FUNCTION 1 btint82cmp(int8, int2) ,

  -- 交叉类型比较 int8 对 int4
  OPERATOR 1 < (int8, int4) ,
  OPERATOR 2 <= (int8, int4) ,
  OPERATOR 3 = (int8, int4) ,
  OPERATOR 4 >= (int8, int4) ,
  OPERATOR 5 > (int8, int4) ,
  FUNCTION 1 btint84cmp(int8, int4) ,

  -- 交叉类型比较 int4 对 int2
  OPERATOR 1 < (int4, int2) ,
  OPERATOR 2 <= (int4, int2) ,
  OPERATOR 3 = (int4, int2) ,
  OPERATOR 4 >= (int4, int2) ,
  OPERATOR 5 > (int4, int2) ,
  FUNCTION 1 btint42cmp(int4, int2) ,

  -- 交叉类型比较 int4 对 int8
  OPERATOR 1 < (int4, int8) ,
  OPERATOR 2 <= (int4, int8) ,
  OPERATOR 3 = (int4, int8) ,
  OPERATOR 4 >= (int4, int8) ,
  OPERATOR 5 > (int4, int8) ,
  FUNCTION 1 btint48cmp(int4, int8) ,

  -- 交叉类型比较 int2 对 int8
  OPERATOR 1 < (int2, int8) ,
  OPERATOR 2 <= (int2, int8) ,
  OPERATOR 3 = (int2, int8) ,
  OPERATOR 4 >= (int2, int8) ,
  OPERATOR 5 > (int2, int8) ,
  FUNCTION 1 btint28cmp(int2, int8) ,

  -- 交叉类型比较 int2 对 int4
  OPERATOR 1 < (int2, int4) ,
  OPERATOR 2 <= (int2, int4) ,
  OPERATOR 3 = (int2, int4) ,
  OPERATOR 4 >= (int2, int4) ,
  OPERATOR 5 > (int2, int4) ,
  FUNCTION 1 btint24cmp(int2, int4) ;
]]>
</programlisting>
<!-- 
   Notice that this definition <quote>overloads</> the operator strategy and
   support function numbers: each number occurs multiple times within the
   family.  This is allowed so long as each instance of a
   particular number has distinct input data types.  The instances that have
   both input types equal to an operator class's input type are the
   primary operators and support functions for that operator class,
   and in most cases should be declared as part of the operator class rather
   than as loose members of the family.
-->
需要注意的是，这里的定义<quote>重载</>了操作符策略和支持函数号：每个号在族内多次发生。
只要每个数字的实例都有不同输入数据类型就都是允许的。输入类型都等于操作符类的输入类型的实例是主操作符，
并且支持该操作符类的函数，在大多数情况下应该被声明为操作符类的一部分，而不是该族内的松散成员。
  </para>

  <!--
<para>
   In a B-tree operator family, all the operators in the family must sort
   compatibly, meaning that the transitive laws hold across all the data types
   supported by the family: <quote>if A = B and B = C, then A = C</>,
   and <quote>if A &lt; B and B &lt; C, then A &lt; C</>.  Moreover, implicit
   or binary coercion casts between types represented in the operator family
   must not change the associated sort ordering.  For each
   operator in the family there must be a support function having the same
   two input data types as the operator.  It is recommended that a family be
   complete, i.e., for each combination of data types, all operators are
   included.  Each operator class should include just the non-cross-type
   operators and support function for its data type.
  </para>
-->
<para>
在一个B-tree操作符族内，所有的操作符都必须适当的排序，意味着传递法保存所有该族支持的数据类型：
<quote>if A = B and B = C, then A = C</>,和<quote>if A &lt; B and B &lt; C, then A &lt; C</>。
此外，代表操作符族的类型间的隐式的或二进制强制转换必须不能改变相关的排序次序。
族内的每个操作符必须有一个支持的函数，这个函数有和操作符相同的两个输入数据类型。
建议一个族是完整的，也就是，对于每个数据类型的组合，所有的操作符都包括了。
每个操作符类应该只包含非交叉类型操作符和它的数据类型的支持函数。
</para>

  <!--
<para>
   To build a multiple-data-type hash operator family, compatible hash
   support functions must be created for each data type supported by the
   family.  Here compatibility means that the functions are guaranteed to
   return the same hash code for any two values that are considered equal
   by the family's equality operators, even when the values are of different
   types.  This is usually difficult to accomplish when the types have
   different physical representations, but it can be done in some cases.
   Furthermore, casting a value from one data type represented in the operator
   family to another data type also represented in the operator family via
   an implicit or binary coercion cast must not change the computed hash value.
   Notice that there is only one support function per data type, not one
   per equality operator.  It is recommended that a family be complete, i.e.,
   provide an equality operator for each combination of data types.
   Each operator class should include just the non-cross-type equality
   operator and the support function for its data type.
  </para>
-->
<para>
要建立一个多数据类型散列操作符族，必须为每个该族支持的数据类型创建兼容的散列支持函数。
这里的兼容意味着函数保证对两个通过族的相等运算符认为相等的两个值返回相同的散列码，
甚至两个值属于不容的类型时也是。当类型有不同的物理表示时这通常是很难完成的，
但是在某些情况下是可以做到的。更多的，通过隐式的或二进制强制转换，
转换一个操作符族中的数据类型的值到另一个同样在操作符族中的数据类型，
必须不能改变计算散列值。注意每个数据类型只有一个支持函数，而不是每个相等操作符。
建议一个族是完整的，也就是，对于每个数据类型的组合都提供一个相等操作符。
每个操作符类应该只包含非交叉类型相等操作符和它的数据类型的支持函数。
</para>

  <!--
<para>
   GiST, SP-GiST, and GIN indexes do not have any explicit notion of
   cross-data-type operations.  The set of operators supported is just
   whatever the primary support functions for a given operator class can
   handle.
  </para>
-->
<para>
GiST, SP-GiST, 和 GIN索引对于交叉数据类型操作符没有任何明确的概念。
支持的操作符集对于可以处理的给定的操作符类只是主要的支持函数。
</para>

  <note>
   <!--
<para>
    Prior to <productname>PostgreSQL</productname> 8.3, there was no concept
    of operator families, and so any cross-data-type operators intended to be
    used with an index had to be bound directly into the index's operator
    class.  While this approach still works, it is deprecated because it
    makes an index's dependencies too broad, and because the planner can
    handle cross-data-type comparisons more effectively when both data types
    have operators in the same operator family.
   </para>
-->
<para>
在<productname>PostgreSQL</productname> 8.3之前，没有操作符族的概念，
因此任何试图和索引一起使用的交叉数据类型操作符必须直接绑定到索引的操作符类里面。
虽然这种方法仍然有效，但是已经弃用了，因为它使得索引的依赖太过广泛，
并且因为当数据类型都有操作符在相同的操作符族内时，规划器可以更有效的处理交叉数据类型比较。
</para>
  </note>
 </sect2>

 <sect2 id="xindex-opclass-dependencies">
  <!--
  <title>System Dependencies on Operator Classes</title>
  -->
  <title>操作符类的系统相关性</title>

   <indexterm>
    <!-- 
<primary>ordering operator</primary>
-->
<primary>顺序操作符</primary>
   </indexterm>

  <!--
<para>
   <productname>PostgreSQL</productname> uses operator classes to infer the
   properties of operators in more ways than just whether they can be used
   with indexes.  Therefore, you might want to create operator classes
   even if you have no intention of indexing any columns of your data type.
  </para>
-->
<para>
除了是否可以用于索引外，<productname>PostgreSQL</productname>还有多种途径使用操作符类来推断操作符性质。
因此，即使并不打算为你自定义的数据类型在任何字段上建立索引，你可能还是希望创建操作符类。
</para>

  <!--
<para>
   In particular, there are SQL features such as <literal>ORDER BY</> and
   <literal>DISTINCT</> that require comparison and sorting of values.
   To implement these features on a user-defined data type,
   <productname>PostgreSQL</productname> looks for the default B-tree operator
   class for the data type.  The <quote>equals</> member of this operator
   class defines the system's notion of equality of values for
   <literal>GROUP BY</> and <literal>DISTINCT</>, and the sort ordering
   imposed by the operator class defines the default <literal>ORDER BY</>
   ordering.
  </para>
-->
<para>
特别是诸如<literal>ORDER BY</>和<literal>DISTINCT</>之类需要对值进行比较和排序的 SQL 特性。
要在自定义的数据类型上实现这些特性，<productname>PostgreSQL</productname>
将会为该类型查找默认的 B-tree 操作符类。该操作符类中的<quote>equals</>
成员为<literal>GROUP BY</>和<literal>DISTINCT</>定义了相等的概念，
同时操作符类的排序顺序定义了默认的<literal>ORDER BY</>排序。
</para>

  <!--
<para>
   Comparison of arrays of user-defined types also relies on the semantics
   defined by the default B-tree operator class.
  </para>
-->
<para>
用户自定义类型数组的比较同样也依赖于默认 B-tree 操作符类定义的语意。
</para>

  <!--
<para>
   If there is no default B-tree operator class for a data type, the system
   will look for a default hash operator class.  But since that kind of
   operator class only provides equality, in practice it is only enough
   to support array equality.
  </para>
-->
<para>
如果对于某个数据类型不存在默认 B-tree 操作符类，那么系统将会自动寻找默认的 Hash 操作符类。
但因为 Hash 操作符类仅仅提供相等比较，所以在实践中它仅能用于数组的相等性测试。
</para>

  <!--
<para>
   When there is no default operator class for a data type, you will get
   errors like <quote>could not identify an ordering operator if you
   try to use these SQL features with the data type.
  </para>
-->
<para>
如果某个数据类型不存在任何缺省操作符类，你就会在使用该 SQL 特性时得到一个类似
<quote>could not identify an ordering operator</>的错误。
</para>

   <note>
    <!--
<para>
     In <productname>PostgreSQL</productname> versions before 7.4,
     sorting and grouping operations would implicitly use operators named
     <literal>=</>, <literal>&lt;</>, and <literal>&gt;</>.  The new
     behavior of relying on default operator classes avoids having to make
     any assumption about the behavior of operators with particular names.
    </para>
-->
<para>
<productname>PostgreSQL</productname> 7.4 以前，排序和分组操作隐含使用名为<literal>=</>,
 <literal>&lt;</>,<literal>&gt;</>的操作符。新的依赖默认操作符类的行为避免了对任何特定操作符名的行为的假定。
</para>
   </note>

  <!--
<para>
   Another important point is that an operator that
   appears in a hash operator family is a candidate for hash joins,
   hash aggregation, and related optimizations.  The hash operator family
   is essential here since it identifies the hash function(s) to use.
  </para>
-->
<para>
另一点重要的是一个在hash操作符族中的操作符是hash连接，hash聚合和相关优化的候选。
hash操作符族在这里是重要的，因为它标志要使用的hash函数。
</para>
 </sect2>

 <sect2 id="xindex-ordering-ops">
  <!--
  <title>Ordering Operators</title>
  -->
  <title>排序操作符</title>
  
<para>
<!--
   Some index access methods (currently, only GiST) support the concept of
   <firstterm>ordering operators</>.  What we have been discussing so far
   are <firstterm>search operators</>.  A search operator is one for which
   the index can be searched to find all rows satisfying
   <literal>WHERE</>
   <replaceable>indexed_column</>
   <replaceable>operator</>
   <replaceable>constant</>.
   Note that nothing is promised about the order in which the matching rows
   will be returned.  In contrast, an ordering operator does not restrict the
   set of rows that can be returned, but instead determines their order.
   An ordering operator is one for which the index can be scanned to return
   rows in the order represented by
   <literal>ORDER BY</>
   <replaceable>indexed_column</>
   <replaceable>operator</>
   <replaceable>constant</>.
   The reason for defining ordering operators that way is that it supports
   nearest-neighbor searches, if the operator is one that measures distance.
   For example, a query like
-->
一些索引访问方法（当前只有GIST）支持<firstterm>排序操作符</>的概念。
我们当前已经讨论过的是<firstterm>搜索操作符</>。搜索操作符是可以搜索索引找到所有满足
<literal>WHERE</> <replaceable>indexed_column</> <replaceable>operator</> <replaceable>constant</>的行。
注意，不保证将要返回的匹配行的顺序。相反的，排序操作符不限制要返回的行集，
但是决定它们的顺序。排序操作符是可以扫描索引以<literal>ORDER BY</> <replaceable>indexed_column</> 
 <replaceable>operator</> <replaceable>constant</>的顺序返回行。
这种方式定义排序操作符的原因是支持最近搜索，如果操作符是测量距离。例如，像这样的查询
<programlisting><![CDATA[
SELECT * FROM places ORDER BY location <-> point '(101,456)' LIMIT 10;
]]>
</programlisting>
<!-- 
   finds the ten places closest to a given target point.  A GiST index
   on the location column can do this efficiently because
   <literal>&lt;-&gt;</> is an ordering operator. 
-->
找到一个距离给定目标点最近的点。在location字段上的GIST索引可以有效地做到这点，
因为<literal>&lt;-&gt;</>是一个排序操作符。
  </para>
  
<para>
<!--
   While search operators have to return Boolean results, ordering operators
   usually return some other type, such as float or numeric for distances.
   This type is normally not the same as the data type being indexed.
   To avoid hard-wiring assumptions about the behavior of different data
   types, the definition of an ordering operator is required to name
   a B-tree operator family that specifies the sort ordering of the result
   data type.  As was stated in the previous section, B-tree operator families
   define <productname>PostgreSQL</productname>'s notion of ordering, so
   this is a natural representation.  Since the point <literal>&lt;-&gt;</>
   operator returns <type>float8</>, it could be specified in an operator
   class creation command like this:
-->
当搜索操作符必须返回布尔结果时，排序操作符通常返回一些其他类型，如float或numeric。
这种类型通常不同于被索引的类型。为了避免关于不同数据类型行为的硬链接的假设，
排序操作符的定义需要命名一个B-tree操作符族，声明结果数据类型的排序次序。
就像前一节中阐明的，B-tree操作符族定义<productname>PostgreSQL</productname>的排序概念，
所以这是一个自然的表示。因为point <literal>&lt;-&gt;</>操作符返回<type>float8</>，
可以在一个操作符类的创建命令中指定，像这样：
<programlisting><![CDATA[
OPERATOR 15    <-> (point, point) FOR ORDER BY float_ops
]]>
</programlisting>
<!--
    where <literal>float_ops</> is the built-in operator family that includes
   operations on <type>float8</>.  This declaration states that the index
   is able to return rows in order of increasing values of the
   <literal>&lt;-&gt;</> operator.
-->
这里的<literal>float_ops</>是包含<type>float8</>操作的内建操作符族。
这个说明声明了索引可以以<literal>&lt;-&gt;</>操作符的增值的顺序返回行。
  </para>
 </sect2>

 <sect2 id="xindex-opclass-features">
  <!-- 
  <title>Special Features of Operator Classes</title>
  -->
  <title>操作符类的特殊特性</title>

  <!--
<para>
   There are two special features of operator classes that we have
   not discussed yet, mainly because they are not useful
   with the most commonly used index methods.
  </para>
-->
<para>
还有两种操作符类的特殊特性没有讨论，主要是因为它们对于大多数常用的索引方法并不非常有用。
</para>
  
<para>
<!--
   Normally, declaring an operator as a member of an operator class
   (or family) means that the index method can retrieve exactly the set of rows
   that satisfy a <literal>WHERE</> condition using the operator.  For example:
-->
通常，把一个操作符声明为一个操作符类（或族）
的成员意味着索引方法可以使用该操作符检索满足<literal>WHERE</>条件的行集合。比如：
<programlisting>
SELECT * FROM table WHERE integer_column &lt; 4;
</programlisting>
<!-- 
   can be satisfied exactly by a B-tree index on the integer column.
   But there are cases where an index is useful as an inexact guide to
   the matching rows.  For example, if a GiST index stores only bounding boxes
   for geometric objects, then it cannot exactly satisfy a <literal>WHERE</>
   condition that tests overlap between nonrectangular objects such as
   polygons.  Yet we could use the index to find objects whose bounding
   box overlaps the bounding box of the target object, and then do the
   exact overlap test only on the objects found by the index.  If this
   scenario applies, the index is said to be <quote>lossy</> for the
   operator.  Lossy index searches are implemented by having the index
   method return a <firstterm>recheck</> flag when a row might or might
   not really satisfy the query condition.  The core system will then
   test the original query condition on the retrieved row to see whether
   it should be returned as a valid match.  This approach works if
   the index is guaranteed to return all the required rows, plus perhaps
   some additional rows, which can be eliminated by performing the original
   operator invocation.  The index methods that support lossy searches
   (currently, GiST, SP-GiST and GIN) allow the support functions of individual
   operator classes to set the recheck flag, and so this is essentially an
   operator-class feature. 
-->
可以由一个建立在整数字段上的 B-tree 索引精确地满足。但是有时候会有这样的现像：
索引是用作匹配数据行的并不精确的指向。比如，如果一个 GiST 索引只为几何对象存储周界的方块，
那么它就无法精确地满足两个非方形对象(比如多边形)之间是否覆盖的<literal>WHERE</>条件测试。
但是可以使用这个索引找出那些周界方块和目标对象的周界方块重合的对象，
然后只在索引找到的对象上做精确的重合测试。如果这种情形可以通过，那就说索引对操作符是<quote>松散的</>，
松散索引搜索通过当一个行可能或可能不真正满足查询条件时使索引方法返回一个<firstterm>recheck</>
标识来实施。核心系统将然后在检索的行上测试原始的查询条件，以查看是否应该作为一个合法的匹配返回。
如果索引保证返回所有要求的行加上一些附加的行，那么这种方法就可行，
这些额外的行就可以通过执行最初的操作符调用消除。支持松散搜索的索引方法（当前是GiST, SP-GiST 和 GIN）
允许个别的操作符类的支持函数设置recheck标识，所以这是本质上的一个操作符类特征。
  </para>
  
<para>
<!--
   Consider again the situation where we are storing in the index only
   the bounding box of a complex object such as a polygon.  In this
   case there's not much value in storing the whole polygon in the index
   entry &mdash; we might as well store just a simpler object of type
   <type>box</>.  This situation is expressed by the <literal>STORAGE</>
   option in <command>CREATE OPERATOR CLASS</>: we'd write something like:
-->
再考虑只在索引中存储复杂对象(比如多边形)的周界方块的情形。
这种情况下在索引条目里存储整个多边形没有太多的数值(也可以只存储更简单的<type>box</>类型对象)。
这种情形由<command>CREATE OPERATOR CLASS</>里的<literal>STORAGE</>选项存储。可以写类似这样的东西：
<programlisting>
CREATE OPERATOR CLASS polygon_ops
    DEFAULT FOR TYPE polygon USING gist AS
        ...
        STORAGE box;
</programlisting>
<!-- 
   At present, only the GiST and GIN index methods support a
   <literal>STORAGE</> type that's different from the column data type.
   The GiST <function>compress</> and <function>decompress</> support
   routines must deal with data-type conversion when <literal>STORAGE</>
   is used.  In GIN, the <literal>STORAGE</> type identifies the type of
   the <quote>key</> values, which normally is different from the type
   of the indexed column &mdash; for example, an operator class for
   integer-array columns might have keys that are just integers.  The
   GIN <function>extractValue</> and <function>extractQuery</> support
   routines are responsible for extracting keys from indexed values.
-->
目前，只有 GiST 和 GIN 索引方法支持与字段数据类型不同的<literal>STORAGE</>类型。
GiST <function>compress</> 和 <function>decompress</> 支持过程在使用
<literal>STORAGE</>的时候必须处理数据类型转换。对于 GIN 来说，<literal>STORAGE</>
类型标识了<quote>键</>值的类型，它通常与索引字段的类型不同。比如，
一个用于整数数组字段的操作符类可能正好有整数类型的键。GIN <function>extractValue</>
和<function>extractQuery</>支持过程负责从已索引的值抽取键字。
  </para>
 </sect2>

</sect1>
