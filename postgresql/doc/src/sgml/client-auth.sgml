<!-- doc/src/sgml/client-auth.sgml -->

<chapter id="client-authentication">
 <!-- 
 <title>Client Authentication</title> 
 -->
 <title>客户端认证</title>

 <indexterm zone="client-authentication">
  <!-- 
  <primary>client authentication</primary> 
  -->
  <primary>客户端认证</primary>
 </indexterm>

 <!--
<para>
  When a client application connects to the database server, it
  specifies which <productname>PostgreSQL</productname> database user name it
  wants to connect as, much the same way one logs into a Unix computer
  as a particular user. Within the SQL environment the active database
  user name determines access privileges to database objects &mdash; see
  <xref linkend="user-manag"> for more information. Therefore, it is
  essential to restrict which database users can connect.
 </para>
-->
<para>
当客户端与数据库服务器连接时，它将声明以哪个<productname>PostgreSQL</productname>
数据库用户身份进行连接，就像我们登录一台 Unix 计算机一样。在 SQL 环境里，
活动的数据库用户名决定数据库对象的各种访问权限(参阅 <xref linkend="user-manag">)。
因此，实际上我们要限制的是用户可以连接的数据库。
</para>

 <note>
  <!--
<para>
   As explained in <xref linkend="user-manag">,
   <productname>PostgreSQL</productname> actually does privilege
   management in terms of <quote>roles</>.  In this chapter, we
   consistently use <firstterm>database user</> to mean <quote>role with the
   <literal>LOGIN</> privilege</quote>.
  </para>
-->
<para>
如<xref linkend="user-manag">里解释的那样，<productname>PostgreSQL</productname>
实际上用<quote>角色</>的概念管理权限。在本章里，我们用<firstterm>数据库用户</>表示
<quote>带有<literal>LOGIN</>权限的角色</quote>。
</para>
 </note>

 <!--
<para>
  <firstterm>Authentication</firstterm> is the process by which the
  database server establishes the identity of the client, and by
  extension determines whether the client application (or the user
  who runs the client application) is permitted to connect with the
  database user name that was requested.
 </para>
-->
<para>
<firstterm>认证</firstterm>是数据库服务器识别客户端的过程。它通过一些手段判断是否允许此客户端
(或者运行这个客户端的用户)与它所声明的数据库用户名进行绑定。
</para>

 <!--
<para>
  <productname>PostgreSQL</productname> offers a number of different
  client authentication methods. The method used to authenticate a
  particular client connection can be selected on the basis of
  (client) host address, database, and user.
 </para>
-->
<para>
<productname>PostgreSQL</productname>提供多种不同的客户端认证方式。这些方式用来认证特定的客户端连接，
可以基于(客户端)的主机地址、数据库、用户选择认证方法。
</para>

 <!--
<para>
  <productname>PostgreSQL</productname> database user names are logically
  separate from user names of the operating system in which the server
  runs. If all the users of a particular server also have accounts on
  the server's machine, it makes sense to assign database user names
  that match their operating system user names. However, a server that
  accepts remote connections might have many database users who have no local
  operating system
  account, and in such cases there need be no connection between
  database user names and OS user names.
 </para>
-->
<para>
<productname>PostgreSQL</productname>数据库用户名在逻辑上是和服务器运行的操作系统用户名相互独立的。
如果某个服务器的所有用户在那台服务器机器上也有帐号，那么给数据库用户赋与操作系统用户名是有意义的。
不过，一个接收远程访问的服务器很有可能有许多没有本地操作系统帐号的用户，
因而在这种情况下数据库用户和操作系统用户名之间不必有任何联系。
</para>

 <sect1 id="auth-pg-hba-conf">
  <!-- 
  <title>The <filename>pg_hba.conf</filename> File</title> 
  -->
  <title><filename>pg_hba.conf</filename>文件</title>

  <indexterm zone="auth-pg-hba-conf">
   <primary>pg_hba.conf</primary>
  </indexterm>

  <!--
<para>
   Client authentication is controlled by a configuration file,
   which traditionally is named
   <filename>pg_hba.conf</filename> and is stored in the database
   cluster's data directory.
   (<acronym>HBA</> stands for host-based authentication.) A default
   <filename>pg_hba.conf</filename> file is installed when the data
   directory is initialized by <command>initdb</command>.  It is
   possible to place the authentication configuration file elsewhere,
   however; see the <xref linkend="guc-hba-file"> configuration parameter.
  </para>
-->
<para>
客户端认证是由一个配置文件(通常名为<filename>pg_hba.conf</filename>)控制的，
它存放在数据库集群的数据目录里。<acronym>HBA</>的意思是"host-based authentication"，
也就是基于主机的认证。在<command>initdb</command>初始化数据目录的时候，
它会安装一个缺省的<filename>pg_hba.conf</filename>文件。不过我们也可以把认证配置文件放在其它地方；
参阅<xref linkend="guc-hba-file">配置参数。
</para>

  <!--
<para>
   The general format of the <filename>pg_hba.conf</filename> file is
   a set of records, one per line. Blank lines are ignored, as is any
   text after the <literal>#</literal> comment character.
   Records cannot be continued across lines.
   A record is made
   up of a number of fields which are separated by spaces and/or tabs.
   Fields can contain white space if the field value is double-quoted.
   Quoting one of the keywords in a database, user, or address field (e.g.,
   <literal>all</> or <literal>replication</>) makes the word lose its special
   meaning, and just match a database, user, or host with that name.
  </para>
-->
<para>
<filename>pg_hba.conf</filename>文件的常用格式是一组记录，每行一条。空白行将被忽略，
井号<literal>#</literal>开头的注释也被忽略。记录不能跨行存在。
一条记录是由若干用空格和/或制表符分隔的字段组成。如果字段用引号包围，那么它可以包含空白。
在数据库、用户或地址文件中引用一个关键词（如，<literal>all</> 或 <literal>replication</>）
使这个词失去它的特殊含义，只是用这个名字匹配一个数据库、用户或主机。
</para>

  <!--
<para>
   Each record specifies a connection type, a client IP address range
   (if relevant for the connection type), a database name, a user name,
   and the authentication method to be used for connections matching
   these parameters. The first record with a matching connection type,
   client address, requested database, and user name is used to perform
   authentication. There is no <quote>fall-through</> or
   <quote>backup</>: if one record is chosen and the authentication
   fails, subsequent records are not considered. If no record matches,
   access is denied.
  </para>
-->
<para>
每条记录声明一种连接类型、一个客户端 IP 地址范围(如果和连接类型相关的话)、
一个数据库名、一个用户名字、对匹配这些参数的连接使用的认证方法。第一条匹配连接类型、
客户端地址、连接请求的数据库名和用户名的记录将用于执行认证。这个处理过程没有
<quote>跨越</>或者<quote>回头</>的说法：如果选择了一条记录而且认证失败，
那么将不再考虑后面的记录。如果没有匹配的记录，那么访问将被拒绝。
</para>
  
<para>
<!--
   A record can have one of the seven formats
-->
每条记录可以是下面七种格式之一：
<synopsis>
local      <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
host       <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>address</replaceable>  <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostssl    <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>address</replaceable>  <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostnossl  <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>address</replaceable>  <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
host       <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>IP-address</replaceable>  <replaceable>IP-mask</replaceable>  <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostssl    <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>IP-address</replaceable>  <replaceable>IP-mask</replaceable>  <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostnossl  <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>IP-address</replaceable>  <replaceable>IP-mask</replaceable>  <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
</synopsis>
   <!-- 
   The meaning of the fields is as follows: 
   -->
   各个字段的含义如下：

   <variablelist>
    <varlistentry>
     <term><literal>local</literal></term>
     <listitem>
      <para>
      <!-- 
  This record matches connection attempts using Unix-domain
       sockets.  Without a record of this type, Unix-domain socket
       connections are disallowed. 
   -->
这条记录匹配企图通过 Unix 域套接字进行的连接。没有这种类型的记录，就不允许 Unix 域套接字的连接。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>host</literal></term>
     <listitem>
      <!--
<para>
       This record matches connection attempts made using TCP/IP.
       <literal>host</literal> records match either
       <acronym>SSL</acronym> or non-<acronym>SSL</acronym> connection
       attempts.
      </para>
-->
<para>
这条记录匹配企图通过 TCP/IP 进行的连接。<literal>host</literal>记录匹配
<acronym>SSL</acronym>和非<acronym>SSL</acronym>的连接请求。
</para>
     <note>
      <!--
<para>
       Remote TCP/IP connections will not be possible unless
       the server is started with an appropriate value for the
       <xref linkend="guc-listen-addresses"> configuration parameter,
       since the default behavior is to listen for TCP/IP connections
       only on the local loopback address <literal>localhost</>.
      </para>
-->
<para>
除非服务器带着合适的<xref linkend="guc-listen-addresses">配置参数值启动，
否则将不可能进行远程的 TCP/IP 连接，因为缺省的行为是只监听本地自环地址<literal>localhost</>的连接。
</para>
     </note>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>hostssl</literal></term>
     <listitem>
      <!--
<para>
       This record matches connection attempts made using TCP/IP,
       but only when the connection is made with <acronym>SSL</acronym>
       encryption.
      </para>
-->
<para>
这条记录匹配企图使用 TCP/IP 的 SSL 连接。但必须是使用<acronym>SSL</acronym>加密的连接。
</para>

      <!--
<para>
       To make use of this option the server must be built with
       <acronym>SSL</acronym> support. Furthermore,
       <acronym>SSL</acronym> must be enabled at server start time
       by setting the <xref linkend="guc-ssl"> configuration parameter (see
       <xref linkend="ssl-tcp"> for more information).
      </para>
-->
<para>
要使用这个选项，编译服务器的时候必须打开<acronym>SSL</acronym>支持。
而且在服务器启动的时候必须打开<xref linkend="guc-ssl">配置选项(参阅<xref linkend="ssl-tcp">)。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>hostnossl</literal></term>
     <listitem>
      <!--
<para>
       This record type has the opposite behavior of <literal>hostssl</>;
       it only matches connection attempts made over
       TCP/IP that do not use <acronym>SSL</acronym>.
      </para>
-->
<para>
这条记录与<literal>hostssl</>行为相反：它只匹配那些在 TCP/IP 上不使用<acronym>SSL</acronym>的连接请求。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>database</replaceable></term>
     <listitem>
      <!--
<para>
       Specifies which database name(s) this record matches.  The value
       <literal>all</literal> specifies that it matches all databases.
       The value <literal>sameuser</> specifies that the record
       matches if the requested database has the same name as the
       requested user.  The value <literal>samerole</> specifies that
       the requested user must be a member of the role with the same
       name as the requested database.  (<literal>samegroup</> is an
       obsolete but still accepted spelling of <literal>samerole</>.)
       Superusers are not considered to be members of a role for the
       purposes of <literal>samerole</> unless they are explicitly
       members of the role, directly or indirectly, and not just by
       virtue of being a superuser.
       The value <literal>replication</> specifies that the record
       matches if a replication connection is requested (note that
       replication connections do not specify any particular database).
       Otherwise, this is the name of
       a specific <productname>PostgreSQL</productname> database.
       Multiple database names can be supplied by separating them with
       commas.  A separate file containing database names can be specified by
       preceding the file name with <literal>@</>.
      </para>
-->
<para>
声明记录所匹配的数据库名称。值 <literal>all</literal>表明该记录匹配所有数据库，
值<literal>sameuser</>表示如果被请求的数据库和请求的用户同名，则匹配。
值<literal>samerole</>表示请求的用户必须是一个与数据库同名的角色中的成员。
(<literal>samegroup</>是一个已经废弃了，但目前仍然被接受的<literal>samerole</>同义词。)
对<literal>samerole</>来说，不认为超级用户是角色的一个成员，除非他们明确的是角色的成员，
直接的或间接的，并且不只是由于超级用户。值<literal>replication</>表示如果请求一个复制链接，
则匹配（注意复制链接不表示任何特定的数据库）。在其它情况里，这就是一个特定的
<productname>PostgreSQL</productname>数据库名字。可以通过用逗号分隔的方法声明多个数据库，
也可以通过前缀<literal>@</>来声明一个包含数据库名的文件。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>user</replaceable></term>
     <listitem>
      <!--
<para>
       Specifies which database user name(s) this record
       matches. The value <literal>all</literal> specifies that it
       matches all users.  Otherwise, this is either the name of a specific
       database user, or a group name preceded by <literal>+</>.
       (Recall that there is no real distinction between users and groups
       in <productname>PostgreSQL</>; a <literal>+</> mark really means
       <quote>match any of the roles that are directly or indirectly members
       of this role</>, while a name without a <literal>+</> mark matches
       only that specific role.) For this purpose, a superuser is only
       considered to be a member of a role if they are explicitly a member
       of the role, directly or indirectly, and not just by virtue of
       being a superuser.
       Multiple user names can be supplied by separating them with commas.
       A separate file containing user names can be specified by preceding the
       file name with <literal>@</>.
      </para>
-->
<para>
为这条记录声明所匹配的数据库用户。值<literal>all</literal>表明它匹配于所有用户。否则，
它就是特定数据库用户的名字或者是一个前缀<literal>+</>的组名称。请注意，
在<productname>PostgreSQL</>里，用户和组没有真正的区别，<literal>+</>实际上只是意味着
<quote>匹配任何直接或者间接属于这个角色的成员</>，而没有<literal>+</>记号的名字只匹配指定的角色。
为此，超级用户如果明确是角色的成员，也只算是一个角色的成员，直接的或间接的，而不只是由于超级用户。
多个用户名可以通过用逗号分隔的方法声明。一个包含用户名的文件可以通过在文件名前面前缀
<literal>@</>来声明。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>address</replaceable></term>
     <listitem>
      <!--
<para>
       Specifies the client machine address(es) that this record
       matches.  This field can contain either a host name, an IP
       address range, or one of the special key words mentioned below.
      </para>
-->
<para>
声明这条记录匹配的客户端机器地址。这个文件可以包含主机名、IP地址范围或下面提到的特殊关键字之一。
</para>

      <!--
<para>
       An IP address range is specified using standard numeric notation
       for the range's starting address, then a slash (<literal>/</literal>)
       and a <acronym>CIDR</> mask length.  The mask
       length indicates the number of high-order bits of the client
       IP address that must match.  Bits to the right of this should
       be zero in the given IP address.
       There must not be any white space between the IP address, the
       <literal>/</literal>, and the CIDR mask length.
      </para>
-->
<para>
 IP 地址范围用标准的范围起始地址数字符号、斜线(<literal>/</literal>)和一个
 <acronym>CIDR</>掩码长度声明。
 掩码长度表示客户端 IP 地址必须匹配的高位二进制位数。在给出的 IP 地址里，
 这个长度的右边的二进制位应该为零。在 IP 地址、<literal>/</literal>、
 CIDR 掩码长度之间不能有空白。
</para>

      <!--
<para>
       Typical examples of an IPv4 address range specified this way are
       <literal>172.20.143.89/32</literal> for a single host, or
       <literal>172.20.143.0/24</literal> for a small network, or
       <literal>10.6.0.0/16</literal> for a larger one.
       An IPv6 address range might look like <literal>::1/128</literal>
       for a single host (in this case the IPv6 loopback address) or
       <literal>fe80::7a31:c1ff:0000:0000/96</literal> for a small
       network.
       <literal>0.0.0.0/0</literal> represents all
       IPv4 addresses, and <literal>::0/0</literal> represents
       all IPv6 addresses.
       To specify a single host, use a mask length of 32 for IPv4 or
       128 for IPv6.  In a network address, do not omit trailing zeroes.
      </para>
-->
<para>
典型的这种方式指定的IPv4地址范围举例：<literal>172.20.143.89/32</literal>表示一个主机，
<literal>172.20.143.0/24</literal>表示一个小子网，<literal>10.6.0.0/16</literal>
表示一个大子网。IPv6地址范围的主机看起来像<literal>::1/128</literal>
（这种情况下是IPv6的回调地址），<literal>fe80::7a31:c1ff:0000:0000/96</literal>
表示一个小子网。<literal>0.0.0.0/0</literal>代表所有IPv4地址，
<literal>::0/0</literal>代表所有IPv6地址。要声明单个主机，
给 IPv4 地址声明掩码长度 32 ，给 IPv6 地址声明 128 。
不要在地址中省略结尾的 0 。
</para>

      <!--
<para>
       An entry given in IPv4 format will match only IPv4 connections,
       and an entry given in IPv6 format will match only IPv6 connections,
       even if the represented address is in the IPv4-in-IPv6 range.
       Note that entries in IPv6 format will be rejected if the system's
       C library does not have support for IPv6 addresses.
      </para>
-->
<para>
以 IPv4 格式给出的记录将只能匹配 IPv4 连接，
一个以 IPv6 格式给出的记录将只匹配 IPv6 连接，
即使对应的地址在 IPv4-in-IPv6 范围内。请注意如果系统的 C 库不支持 IPv6 地址，
那么 IPv6 的格式将被拒绝。
</para>

      <!--
<para>
       You can also write <literal>all</literal> to match any IP address,
       <literal>samehost</literal> to match any of the server's own IP
       addresses, or <literal>samenet</literal> to match any address in any
       subnet that the server is directly connected to.
      </para>
-->
<para>
你也可以写<literal>all</literal>来匹配所有IP地址，<literal>samehost</literal>
来匹配任意服务器IP地址，或<literal>samenet</literal>来匹配任何服务器直接连接到的子网的任意地址。
</para>

      <!--
<para>
       If a host name is specified (anything that is not an IP address
       range or a special key word is treated as a host name),
       that name is compared with the result of a reverse name
       resolution of the client's IP address (e.g., reverse DNS
       lookup, if DNS is used).  Host name comparisons are case
       insensitive.  If there is a match, then a forward name
       resolution (e.g., forward DNS lookup) is performed on the host
       name to check whether any of the addresses it resolves to are
       equal to the client's IP address.  If both directions match,
       then the entry is considered to match.  (The host name that is
       used in <filename>pg_hba.conf</filename> should be the one that
       address-to-name resolution of the client's IP address returns,
       otherwise the line won't be matched.  Some host name databases
       allow associating an IP address with multiple host names, but
       the operating system will only return one host name when asked
       to resolve an IP address.)
      </para>
-->
<para>
如果指定了主机名（不是IP地址范围或看做主机名对待的特殊关键字），
那么该名称与客户端IP地址进行反向名称解析的结果进行比较（例如，如果使用了DNS，
那么是反向DNS查找）。主机名的比较是大小写无关的。如果有一个匹配，
那么正向名称解析（例如，正向DNS查找）在主机名上执行，以检查是否有解析的地址等于客户端IP地址。
如果双向都匹配，那么这个条目被认为是匹配的。（在<filename>pg_hba.conf</filename>
中使用的主机名应该是客户端IP地址返回的地址到名称（address-to-name）解析的那个，
否则这行将不被匹配。某些主机名数据库允许一个IP地址关联多个主机名，
但是当要求解析一个IP地址时，操作系统将只返回一个主机名。）
</para>

      <!--
<para>
       A host name specification that starts with a dot
       (<literal>.</literal>) matches a suffix of the actual host
       name.  So <literal>.example.com</literal> would match
       <literal>foo.example.com</literal> (but not just
       <literal>example.com</literal>).
      </para>
-->
<para>
主机名规范以一个点(<literal>.</literal>)开头，匹配一个实际主机名后缀。
所以<literal>.example.com</literal>将匹配<literal>foo.example.com</literal>
（但不只是<literal>example.com</literal>）。
</para>

      <!--
<para>
       When host names are specified
       in <filename>pg_hba.conf</filename>, you should make sure that
       name resolution is reasonably fast.  It can be of advantage to
       set up a local name resolution cache such
       as <command>nscd</command>.  Also, you may wish to enable the
       configuration parameter <varname>log_hostname</varname> to see
       the client's host name instead of the IP address in the log.
      </para>
-->
<para>
当主机名在<filename>pg_hba.conf</filename>中指定时，你应该确保那个名字解析是相当快的。
它将比建立一个本地名字解析缓存（如<command>nscd</command>）有优势。同样，
你可能希望启用配置参数<varname>log_hostname</varname>来查看客户端主机名，而不是日志中的IP地址。
</para>

<!-- 
      <para>
       This field only applies to <literal>host</literal>,
       <literal>hostssl</literal>, and <literal>hostnossl</> records.
      </para>
-->
<para>
这些字段只适用于<literal>host</literal>,<literal>hostssl</literal>和<literal>hostnossl</>记录。
</para>


      <sidebar>
       <!--
<para>
        Users sometimes wonder why host names are handled
        in this seemingly complicated way, with two name resolutions
        including a reverse lookup of the client's IP address.  This
        complicates use of the feature in case the client's reverse DNS
        entry is not set up or yields some undesirable host name.
        It is done primarily for efficiency: this way, a connection attempt
        requires at most two resolver lookups, one reverse and one forward.
        If there is a resolver problem with some address, it becomes only
        that client's problem.  A hypothetical alternative
        implementation that only did forward lookups would have to
        resolve every host name mentioned in
        <filename>pg_hba.conf</filename> during every connection attempt.
        That could be quite slow if many names are listed.
        And if there is a resolver problem with one of the host names,
        it becomes everyone's problem.
       </para>
-->
<para>
用户有时会想知道为什么主机名用这个看起来复杂的方式处理，
因为需要两个包含反向查找客户端的IP地址的名字解析。
使用这个复杂的特性是为了防止客户端反向DNS项没有设置或者产生一些不受欢迎的主机名。
它主要是为了效率：这种方式，一个连接尝试请求最多需要两次解析查找，
一次反向一次正向。如果有一个解析器对于某些地址有问题，那仅仅是客户端的问题。
一种假想的替代实现是只做前向查找，这种方法不得不在每一次连接尝试时解析
<filename>pg_hba.conf</filename>中提到的每一个主机名。
如果列出了很多主机名，那么将会相当的慢。并且如果其中一个主机名有解析问题，
那么所有主机名都会有问题。
</para>

       <!--
<para>
        Also, a reverse lookup is necessary to implement the suffix
        matching feature, because the actual client host name needs to
        be known in order to match it against the pattern.
       </para>
-->
<para>
另外，要实现后缀匹配功能必须要一个反向查找，因为实际客户端主机名需要是已知的，为了它对模式匹配。
</para>

       <!--
<para>
        Note that this behavior is consistent with other popular
        implementations of host name-based access control, such as the
        Apache HTTP Server and TCP Wrappers.
       </para>
-->
<para>
请注意，这个行为与其他受欢迎的主机基于名称访问控制的实现是一致的，比如Apache HTTP Server 和 TCP Wrappers。
</para>
      </sidebar>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>IP-address</replaceable></term>
     <term><replaceable>IP-mask</replaceable></term>
     <listitem>
      <!--
<para>
       These two fields can be used as an alternative to the
       <replaceable>IP-address</><literal>/</><replaceable>mask-length</>
       notation.  Instead of
       specifying the mask length, the actual mask is specified in a
       separate column. For example, <literal>255.0.0.0</> represents an IPv4
       CIDR mask length of 8, and <literal>255.255.255.255</> represents a
       CIDR mask length of 32.
      </para>
-->
<para>
这两个字段可以用作<replaceable>IP-address</><literal>/</><replaceable>mask-length</>
表示法的替补。它不是声明掩码的长度，
而是在另外一个字段里声明实际的掩码。比如，<literal>255.0.0.0</>表示 IPv4 CIDR 掩码长度 8 ，
而<literal>255.255.255.255</>表示 CIDR 掩码长度 32 。
</para>

      <!--
<para>
       These fields only apply to <literal>host</literal>,
       <literal>hostssl</literal>, and <literal>hostnossl</> records.
      </para>
-->
<para>
这些字段只适用于<literal>host</literal>,<literal>hostssl</literal>,<literal>hostnossl</>记录。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>auth-method</replaceable></term>
     <listitem>
      
<para>
<!--
       Specifies the authentication method to use when a connection matches
       this record. The possible choices are summarized here; details
       are in <xref linkend="auth-methods">.
-->
声明连接匹配这条记录的时候使用的认证方法。可能的选择在下面简介，
详细情况在<xref linkend="auth-methods">中介绍。
       <variablelist>
        <varlistentry>
         <term><literal>trust</></term>
         <listitem>
         <para>
<!-- 
          Allow the connection unconditionally. This method
          allows anyone that can connect to the
          <productname>PostgreSQL</productname> database server to login as
          any <productname>PostgreSQL</productname> user they wish,
          without the need for a password or any other authentication.  See <xref
          linkend="auth-trust"> for details. 
-->
无条件地允许连接。这个方法允许任何可以与<productname>PostgreSQL</productname>
数据库服务器连接的用户以他们期望的任意<productname>PostgreSQL</productname>
数据库用户身份进行连接，而不需要口令或任何其他认证。参阅<xref linkend="auth-trust">获取细节。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>reject</></term>
        <listitem>
         <!--
<para>
          Reject the connection unconditionally. This is useful for
          <quote>filtering out</> certain hosts from a group, for example a
          <literal>reject</> line could block a specific host from connecting,
          while a later line allows the remaining hosts in a specific
          network to connect.
         </para>
-->
<para>
无条件地拒绝连接。常用于从一个组中<quote>过滤</>某些主机，例如，
一个<literal>拒绝</>行能够从连接中锁定一个指定的主机，而稍后的行允许指定网络中的剩余的主机连接。
</para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>md5</></term>
        <listitem>
         <!--
<para>
          Require the client to supply a double-MD5-hashed password for
          authentication.
          See <xref linkend="auth-password"> for details.
         </para>
-->
<para>
要求客户端提供一个双重MD5散列的口令进行认证。参阅<xref linkend="auth-password">获取细节。
</para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>password</></term>
        <listitem>
         <!--
<para>
          Require the client to supply an unencrypted password for
          authentication.
          Since the password is sent in clear text over the
          network, this should not be used on untrusted networks.
          See <xref linkend="auth-password"> for details.
         </para>
-->
<para>
要求客户端提供一个未加密的口令进行认证。因为口令是以明文形式在网络上传递的，
所以我们不应该在不安全的网络上使用这个方式。参阅<xref linkend="auth-password">获取细节。
</para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>gss</></term>
        <listitem>
         <!--
<para>
          Use GSSAPI to authenticate the user. This is only
          available for TCP/IP connections. See <xref
          linkend="gssapi-auth"> for details.
         </para>
-->
<para>
使用GSSAPI认证用户。这只能用于TCP/IP连接。参阅<xref linkend="gssapi-auth">获取细节。
</para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>sspi</></term>
        <listitem>
         <!--
<para>
          Use SSPI to authenticate the user. This is only
          available on Windows. See <xref
          linkend="sspi-auth"> for details.
         </para>
-->
<para>
使用SSPI认证用户。这只能在Windows上使用。参阅<xref linkend="sspi-auth">获取细节。
</para>
        </listitem>
       </varlistentry>

        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>ident</></term>
        <listitem>
         <!--
<para>
          Obtain the operating system user name of the client
          by contacting the ident server on the client
          and check if it matches the requested database user name.
          Ident authentication can only be used on TCP/IP
          connections. When specified for local connections, peer
          authentication will be used instead.
          See <xref linkend="auth-ident"> for details.
         </para>
-->
<para>
获取客户的操作系统名然后检查该用户是否匹配要求的数据库用户名，
方法是用户的身份通过与运行在客户端上的 ident 服务器连接进行判断的。
Ident认证只在进行TCP/IP连接的时候才能用。当指定本地连接时，将使用peer认证。
参阅<xref linkend="auth-ident">获取细节。
</para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>peer</></term>
        <listitem>
         <!--
<para>
          Obtain the client's operating system user name from the operating
          system and check if it matches the requested database user name.
          This is only available for local connections.
          See <xref linkend="auth-peer"> for details.
         </para>
-->
<para>
为操作系统获取客户端操作系统用户名，并检查该用户是否匹配要求的数据库用户名。
该方法只适用于本地连接。参阅<xref linkend="auth-peer">获取细节。
</para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>ldap</></term>
        <listitem>
         <!--
<para>
          Authenticate using an <acronym>LDAP</> server. See <xref
          linkend="auth-ldap"> for details.
         </para>
-->
<para>
使用<acronym>LDAP</>服务器进行认证。参阅<xref linkend="auth-ldap">获取细节。
</para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>radius</></term>
        <listitem>
         <!--
<para>
          Authenticate using a RADIUS server. See <xref
          linkend="auth-radius"> for details.
         </para>
-->
<para>
使用RADIUS服务器进行认证，参阅<xref linkend="auth-radius">获取细节。
</para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>cert</></term>
        <listitem>
         <!--
<para>
          Authenticate using SSL client certificates. See
          <xref linkend="auth-cert"> for details.
         </para>
-->
<para>
使用SSL客户端证书进行认证。参阅<xref linkend="auth-cert">获取细节。
</para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>pam</></term>
        <listitem>
         <!--
<para>
          Authenticate using the Pluggable Authentication Modules
          (PAM) service provided by the operating system.  See <xref
          linkend="auth-pam"> for details.
         </para>
-->
<para>
使用操作系统提供的可插入认证模块服务(PAM)来认证。参阅<xref linkend="auth-pam">获取细节。
</para>
        </listitem>
       </varlistentry>
      </variablelist>

      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>auth-options</replaceable></term>
     <listitem>
      <!--
<para>
       After the <replaceable>auth-method</> field, there can be field(s) of
       the form <replaceable>name</><literal>=</><replaceable>value</> that
       specify options for the authentication method. Details about which
       options are available for which authentication methods appear below.
      </para>
-->
<para>
在<replaceable>auth-method</>字段之后，字段格式可以是<replaceable>name</><literal>=</><replaceable>value</>，
指定认证方法的选项。关于哪个选项可用于哪个认证方法的详情在下面描述。
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <!--
<para>
   Files included by <literal>@</> constructs are read as lists of names,
   which can be separated by either whitespace or commas.  Comments are
   introduced by <literal>#</literal>, just as in
   <filename>pg_hba.conf</filename>, and nested <literal>@</> constructs are
   allowed.  Unless the file name following <literal>@</> is an absolute
   path, it is taken to be relative to the directory containing the
   referencing file.
  </para>
-->
<para>
用<literal>@</>构造包含的文件是当作一列名字读取的，这些名字可以用空白或者逗号分隔。
注释用<literal>#</literal>引入，就像在<filename>pg_hba.conf</filename>里那样，
允许嵌套<literal>@</>构造。除非跟在<literal>@</>后面的文件名是一个绝对路径，
否则被当作与该文件所在目录相对的路径。
</para>

  <!--
<para>
   Since the <filename>pg_hba.conf</filename> records are examined
   sequentially for each connection attempt, the order of the records is
   significant. Typically, earlier records will have tight connection
   match parameters and weaker authentication methods, while later
   records will have looser match parameters and stronger authentication
   methods. For example, one might wish to use <literal>trust</>
   authentication for local TCP/IP connections but require a password for
   remote TCP/IP connections. In this case a record specifying
   <literal>trust</> authentication for connections from 127.0.0.1 would
   appear before a record specifying password authentication for a wider
   range of allowed client IP addresses.
  </para>
-->
<para>
因为认证时系统是为每个连接请求顺序检查<filename>pg_hba.conf</filename>里的记录的，
所以这些记录的顺序是非常关键的。通常，靠前的记录有比较严的连接匹配参数和比较弱的认证方法，
而靠后的记录有比较松的匹配参数和比较严的认证方法。比如，我们一般都希望对本地 TCP/IP 连接使用
<literal>trust</>认证，而对远端的 TCP/IP 连接要求口令。在这种情况下我们将<literal>trust</>
认证方法用于来自 127.0.0.1 的连接，这条记录将出现在允许更广泛的客户端 IP 地址的使用口令认证的记录前面。
</para>

  <!--
<para>
   The <filename>pg_hba.conf</filename> file is read on start-up and when
   the main server process receives a
   <systemitem>SIGHUP</systemitem><indexterm><primary>SIGHUP</primary></indexterm>
   signal. If you edit the file on an
   active system, you will need to signal the postmaster
   (using <literal>pg_ctl reload</> or <literal>kill -HUP</>) to make it
   re-read the file.
  </para>
-->
<para>
在启动和主服务器进程收到<systemitem>SIGHUP</systemitem><indexterm><primary>SIGHUP</primary></indexterm>
信号的时候，系统都会重新装载<filename>pg_hba.conf</filename>文件。
如果你在活跃的系统上编辑了该文件，就必须通知主服务器(使用<literal>pg_ctl reload</>
或<literal>kill -HUP</>)重新加载该文件。
</para>

  <tip>
   <!--
<para>
    To connect to a particular database, a user must not only pass the
    <filename>pg_hba.conf</filename> checks, but must have the
    <literal>CONNECT</> privilege for the database.  If you wish to
    restrict which users can connect to which databases, it's usually
    easier to control this by granting/revoking <literal>CONNECT</> privilege
    than to put the rules in <filename>pg_hba.conf</filename> entries.
   </para>
-->
<para>
一个用户要想成功连接到特定的数据库，不仅需要通过<filename>pg_hba.conf</filename>的检查，
还必须要有该数据库上的<literal>CONNECT</>权限。如果希望限制哪些用户能够连接到哪些数据库，
赋予/撤销<literal>CONNECT</>权限通常比在<filename>pg_hba.conf</filename>中设置规则简单。
</para>
  </tip>

  <!--
<para>
   Some examples of <filename>pg_hba.conf</filename> entries are shown in
   <xref linkend="example-pg-hba.conf">. See the next section for details on the
   different authentication methods.
  </para>
-->
<para>
<xref linkend="example-pg-hba.conf">里是<filename>pg_hba.conf</filename>记录的一些例子。
阅读下文理解不同认证方法的细节。
</para>

   <example id="example-pg-hba.conf">
    <!-- 
<title>Example <filename>pg_hba.conf</filename> Entries</title> 
-->
<title><filename>pg_hba.conf</filename>记录的例子</title>
<programlisting>
<!-- 
# Allow any user on the local system to connect to any database with
# any database user name using Unix-domain sockets (the default for local
# connections).
-->

# 允许在本机上的任何用户使用 Unix 域套接字(本地连接的缺省)
# 以任何数据库用户身份连接任何数据库
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
local   all             all                                     trust

<!-- 
# The same using local loopback TCP/IP connections.
-->
# 和上面相同，但是使用的是回环的(loopback)TCP/IP 连接
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             127.0.0.1/32            trust

<!-- 
# The same as the previous line, but using a separate netmask column 
-->
# 和上面一行相同，但是用的是独立的子网掩码字段
#
# TYPE  DATABASE        USER            IP-ADDRESS      IP-MASK             METHOD
host    all             all             127.0.0.1       255.255.255.255     trust

<!-- 
# The same over IPv6. 
-->
# 在IPv6上相同。
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             ::1/128                 trust

<!-- 
# The same using a host name (would typically cover both IPv4 and IPv6). 
-->
# 和上面相同，但是使用一个主机名（通常包括IPv4 和 IPv6）。
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             localhost               trust

<!-- 
# Allow any user from any host with IP address 192.168.93.x to connect
# to database "postgres" as the same user name that ident reports for
# the connection (typically the operating system user name). 
-->
# 允许 IP 地址为 192.168.93.x 的任何主机与 "postgres" 数据库相连，
# 用与他们在自己的主机上相同 ident 的用户名标识他自己(通常是他的操作系统用户名)
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    postgres        all             192.168.93.0/24         ident

<!-- 
# Allow any user from host 192.168.12.10 to connect to database
# "postgres" if the user's password is correctly supplied. 
-->
# 允许来自主机 192.168.12.10 的用户提供了正确的口令之后与 "postgres" 数据库连接。
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    postgres        all             192.168.12.10/32        md5

<!-- 
# Allow any user from hosts in the example.com domain to connect to
# any database if the user's password is correctly supplied.
 -->
# 允许来自在example.com域里的主机的用户在提供了正确的口令之后与任意数据库连接。
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             .example.com            md5

<!-- 
# In the absence of preceding "host" lines, these two lines will
# reject all connections from 192.168.54.1 (since that entry will be
# matched first), but allow GSSAPI connections from anywhere else
# on the Internet.  The zero mask causes no bits of the host IP
# address to be considered, so it matches any host. 
-->
# 如果前面没有其它 "host" 行，那么下面两行将拒绝所有来自 192.168.54.1 的连接请求(因为前面的记录先匹配)。
# 但是允许来自互联网上其它任何地方的有效的 GSSAPI 认证的连接。
# 零掩码引起不考虑主机 IP 的任何位。因此它匹配任何主机。
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             192.168.54.1/32         reject
host    all             all             0.0.0.0/0               gss

<!-- 
# Allow users from 192.168.x.x hosts to connect to any database, if
# they pass the ident check.  If, for example, ident says the user is
# "bryanh" and he requests to connect as PostgreSQL user "guest1", the
# connection is allowed if there is an entry in pg_ident.conf for map
# "omicron" that says "bryanh" is allowed to connect as "guest1". 
-->
# 允许来自 192.168.x.x 的任何用户与任意数据库连接，只要他们通过 ident 检查。
# 但如果 ident 说该用户是 "bryanh" 且他要求以 PostgreSQL 用户 "guest1" 连接，
# 那么只有在 pg_ident.conf 里有 "omicron" 的映射说 "bryanh" 允许以 "guest1" 进行连接时才真正可以进行连接。
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             192.168.0.0/16          ident map=omicron

<!-- 
# If these are the only three lines for local connections, they will
# allow local users to connect only to their own databases (databases
# with the same name as their database user name) except for administrators
# and members of role "support", who can connect to all databases.  The file
# $PGDATA/admins contains a list of names of administrators.  Passwords
# are required in all cases. 
-->
# 如果下面是用于本地连接的仅有的三行，那么它们将允许本地用户只和同名数据库连接。
# 只有管理员和 "support" 角色里的成员例外，他们可以连接到任何数据库。
# $PGDATA/admins 文件列出了那些允许与所有数据库连接的用户名。
# 在所有情况下都需要口令。
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
local   sameuser        all                                     md5
local   all             @admins                                 md5
local   all             +support                                md5

<!-- 
# The last two lines above can be combined into a single line: 
-->
# 上面最后两行可以合起来写成一行
local   all             @admins,+support                        md5

<!-- 
# The database column can also use lists and file names: 
-->
# 数据库字段也可以使用列表和文件名：
local   db1,db2,@demodbs  all                                   md5
</programlisting>
   </example>
 </sect1>

 <sect1 id="auth-username-maps">
  <!-- 
  <title>User Name Maps</title> 
  -->
  <title>用户名映射</title>

  <indexterm zone="auth-username-maps">
   <!-- 
   <primary>User name maps</primary> 
   -->
   <primary>用户名映射</primary>
  </indexterm>

  <!--
<para>
   When using an external authentication system like Ident or GSSAPI,
   the name of the operating system user that initiated the connection
   might not be the same as the database user he needs to connect as.
   In this case, a user name map can be applied to map the operating system
   user name to a database user.  To use user name mapping, specify
   <literal>map</literal>=<replaceable>map-name</replaceable>
   in the options field in <filename>pg_hba.conf</filename>. This option is
   supported for all authentication methods that receive external user names.
   Since different mappings might be needed for different connections,
   the name of the map to be used is specified in the
   <replaceable>map-name</replaceable> parameter in <filename>pg_hba.conf</filename>
   to indicate which map to use for each individual connection.
  </para>
-->
<para>
当使用像Ident 或 GSSAPI这样的外部认证系统时，发起连接的操作系统用户名可能与他需要连接的数据库用户是不同的。
在这种情况下，用户名映射可用于映射操作系统用户名到数据库用户。要使用用户名映射，在<filename>pg_hba.conf</filename>
中的选项中指定<literal>map</literal>=<replaceable>map-name</replaceable>。这个选项支持所有接受外部用户名的认证方法。
因为不同的映射可能需要不同的连接，使用的映射名在<filename>pg_hba.conf</filename>中的<replaceable>map-name</replaceable>
参数中指定，表示为每个独立的连接使用哪个映射。
</para>

  
<para>
<!--
   User name maps are defined in the ident map file, which by default is named
   <filename>pg_ident.conf</><indexterm><primary>pg_ident.conf</primary></indexterm>
   and is stored in the
   cluster's data directory.  (It is possible to place the map file
   elsewhere, however; see the <xref linkend="guc-ident-file">
   configuration parameter.)
   The ident map file contains lines of the general form:
-->
用户名映射在身份映射文件中定义，缺省名为<filename>pg_ident.conf</><indexterm><primary>pg_ident.conf</primary></indexterm>
并且缺省存储在集群的数据目录中。（不过，我们也可以把映射文件放在其它地方；参阅<xref linkend="guc-ident-file">配置参数。）
身份映射文件包含的下面通用的格式：
<synopsis>
<replaceable>map-name</> <replaceable>system-username</> <replaceable>database-username</>
</synopsis>
<!-- 
   Comments and whitespace are handled in the same way as in
   <filename>pg_hba.conf</>.  The
   <replaceable>map-name</> is an arbitrary name that will be used to
   refer to this mapping in <filename>pg_hba.conf</filename>. The other
   two fields specify an operating system user name and a matching
   database user name. The same <replaceable>map-name</> can be
   used repeatedly to specify multiple user-mappings within a single map. 
-->
注释和空白与<filename>pg_hba.conf</>文件里的一样处理。<replaceable>map-name</>
是将要用于在<filename>pg_hba.conf</filename>中引用这个映射的任意名称。
另外两个字段声明操作系统用户名和匹配的数据库用户名。同一个<replaceable>map-name</>
可以在一个映射中多次使用来声明多个用户映射。
对一个操作系统用户可以映射为多少个数据库用户没有限制，反之亦然。
  </para>

  <!--
<para>
   There is no restriction regarding how many database users a given
   operating system user can correspond to, nor vice versa.  Thus, entries
   in a map should be thought of as meaning <quote>this operating system
   user is allowed to connect as this database user</quote>, rather than
   implying that they are equivalent.  The connection will be allowed if
   there is any map entry that pairs the user name obtained from the
   external authentication system with the database user name that the
   user has requested to connect as.
  </para>
-->
<para>
对一个给定的操作系统用户可以映射为多少个数据库用户没有限制，反之亦然。
因此，映射中的记录应该被认为是意为<quote>这个操作系统用户被允许作为这个数据库用户连接</quote>，
而不是意味着他们是相等的。如果有那对用户名的任意映射记录从带有那个用户请求连接的数据库用户名的外部认证系统获得，
那么这个连接将被允许。
</para>
  
<para>
<!--
   If the <replaceable>system-username</> field starts with a slash (<literal>/</>),
   the remainder of the field is treated as a regular expression.
   (See <xref linkend="posix-syntax-details"> for details of
   <productname>PostgreSQL</>'s regular expression syntax.)  The regular
   expression can include a single capture, or parenthesized subexpression,
   which can then be referenced in the <replaceable>database-username</>
   field as <literal>\1</> (backslash-one).  This allows the mapping of
   multiple user names in a single line, which is particularly useful for
   simple syntax substitutions.  For example, these entries
-->
如果<replaceable>system-username</>字段以一个反斜杠(<literal>/</>)开始，
那么该字段的剩余部分被作为一个规则表达式对待。（参阅<xref linkend="posix-syntax-details">
获取关于<productname>PostgreSQL</>规则表达式语法的细节。）规则表达式可以包含一个捕获，
或括号的子表达式，然后可以在<replaceable>database-username</>字段中作为<literal>\1</> (backslash-one)引用。
这允许多用户名的映射在一行中，这对于简单的语法替换特别有用。例如，这些记录：
<programlisting>
mymap   /^(.*)@mydomain\.com$      \1
mymap   /^(.*)@otherdomain\.com$   guest
</programlisting>
<!-- 
   will remove the domain part for users with system user names that end with
   <literal>@mydomain.com</>, and allow any user whose system name ends with
   <literal>@otherdomain.com</> to log in as <literal>guest</>.
-->
将为带有系统用户名的以<literal>@mydomain.com</>结尾的用户删除域部分，
并且允许系统名以<literal>@otherdomain.com</>结尾的任意用户作为<literal>guest</>登录。
  </para>

  <tip>
   <!--
<para>
    Keep in mind that by default, a regular expression can match just part of
    a string.  It's usually wise to use <literal>^</> and <literal>$</>, as
    shown in the above example, to force the match to be to the entire
    system user name.
   </para>
-->
<para>
记住，缺省的，一个规则表达式只可以匹配字符串的一部分。使用<literal>^</>和<literal>$</>通常是明智的，
就像上面例子所示，来迫使匹配成为整个系统用户名。
</para>
  </tip>

  <!--
<para>
   The <filename>pg_ident.conf</filename> file is read on start-up and
   when the main server process receives a
   <systemitem>SIGHUP</systemitem><indexterm><primary>SIGHUP</primary></indexterm>
   signal. If you edit the file on an
   active system, you will need to signal the postmaster
   (using <literal>pg_ctl reload</> or <literal>kill -HUP</>) to make it
   re-read the file.
  </para>
-->
<para>
在系统启动和主服务器收到一个<systemitem>SIGHUP</systemitem><indexterm><primary>SIGHUP</primary></indexterm>
信号的时候会读取<filename>pg_ident.conf</filename>文件。如果你在一台活跃的系统上编辑该文件，
那么你需要给主服务器发信号(使用<literal>pg_ctl reload</>或<literal>kill -HUP</>)令其重新读取该文件。
</para>

  <!--
<para>
   A <filename>pg_ident.conf</filename> file that could be used in
   conjunction with the <filename>pg_hba.conf</> file in <xref
   linkend="example-pg-hba.conf"> is shown in <xref
   linkend="example-pg-ident.conf">. In this example, anyone
   logged in to a machine on the 192.168 network that does not have the
   operating system user name <literal>bryanh</>, <literal>ann</>, or
   <literal>robert</> would not be granted access. Unix user
   <literal>robert</> would only be allowed access when he tries to
   connect as <productname>PostgreSQL</> user <literal>bob</>, not
   as <literal>robert</> or anyone else. <literal>ann</> would
   only be allowed to connect as <literal>ann</>. User
   <literal>bryanh</> would be allowed to connect as either
   <literal>bryanh</> or as <literal>guest1</>.
  </para>
-->
<para>
<xref linkend="example-pg-ident.conf">里是一个可以和在<xref linkend="example-pg-hba.conf">
里面演示的<filename>pg_hba.conf</>文件配合使用的<filename>pg_ident.conf</filename>文件。
在这个例子的设置里，任何登录到 192.168 网络里的机器的用户，如果用户名不是<literal>bryanh</>,
 <literal>ann</>, <literal>robert</> 就不能获准访问。Unix 用户<literal>robert</>只有在试图以
<productname>PostgreSQL</>用户<literal>bob</>身份连接时才允许访问，而不能是<literal>robert</>
或其它什么身份。<literal>ann</>将只允许以<literal>ann</>的身份连接。用户<literal>bryanh</>
允许以他自己的<literal>bryanh</>身份或者作为<literal>guest1</>进行连接。
</para>

  <example id="example-pg-ident.conf">
   <!-- 
   <title>An Example <filename>pg_ident.conf</> File</title> 
   -->
   <title>一个<filename>pg_ident.conf</>文件例子</title>
<programlisting>
# MAPNAME       SYSTEM-USERNAME         PG-USERNAME

omicron         bryanh                  bryanh
omicron         ann                     ann
<!-- 
# bob has user name robert on these machines 
-->
# bob 在这台机器上的用户名是 robert
omicron         robert                  bob
<!-- 
# bryanh can also connect as guest1 
-->
# bryanh也可以以 guest1 身份连接
omicron         bryanh                  guest1
</programlisting>
  </example>
 </sect1>

 <sect1 id="auth-methods">
  <!-- 
  <title>Authentication Methods</title> 
  -->
  <title>认证方法</title>
  <!--
<para>
   The following subsections describe the authentication methods in more detail.
  </para>
-->
<para>
下面的小节更详细地描述认证方法。
</para>

  <sect2 id="auth-trust">
   <!-- 
   <title>Trust Authentication</title> 
   -->
   <title>信任认证</title>

   <!--
<para>
    When <literal>trust</> authentication is specified,
    <productname>PostgreSQL</productname> assumes that anyone who can
    connect to the server is authorized to access the database with
    whatever database user name they specify (even superuser names).
    Of course, restrictions made in the <literal>database</> and
    <literal>user</> columns still apply.
    This method should only be used when there is adequate
    operating-system-level protection on connections to the server.
   </para>
-->
<para>
如果声明了<literal>trust</>认证模式，<productname>PostgreSQL</productname>
就假设任何可以连接到服务器的人都可以以任何他声明的数据库用户名(甚至超级用户名)连接。
当然，在<literal>database</>和<literal>user</>字段里面的限制仍然适用。
这个方法应该用于那些在连接到服务器已经有足够操作系统层次保护的环境里。
</para>

   <!--
<para>
    <literal>trust</> authentication is appropriate and very
    convenient for local connections on a single-user workstation.  It
    is usually <emphasis>not</> appropriate by itself on a multiuser
    machine.  However, you might be able to use <literal>trust</> even
    on a multiuser machine, if you restrict access to the server's
    Unix-domain socket file using file-system permissions.  To do this, set the
    <varname>unix_socket_permissions</varname> (and possibly
    <varname>unix_socket_group</varname>) configuration parameters as
    described in <xref linkend="runtime-config-connection">.  Or you
    could set the <varname>unix_socket_directories</varname>
    configuration parameter to place the socket file in a suitably
    restricted directory.
   </para>
-->
<para>
<literal>trust</>认证对于单用户工作站的本地连接是非常合适和方便的。
通常它本身并<emphasis>不</>适用于多用户环境的机器。不过，即使在多用户的机器上，
你也可以使用<literal>trust</>，只要你利用文件系统权限限制了对服务器的 Unix 域套接字文件的访问。
要做这些限制，你可以设置<varname>unix_socket_permissions</varname>参数(以及可能还有
<varname>unix_socket_group</varname>)，就像<xref linkend="runtime-config-connection">里描述的那样。
或者你可以设置<varname>unix_socket_directories</varname>，把 Unix 域套接字文件放在一个经过恰当限制的目录里。
</para>

   <!--
<para>
    Setting file-system permissions only helps for Unix-socket connections.
    Local TCP/IP connections are not restricted by file-system permissions.
    Therefore, if you want to use file-system permissions for local security,
    remove the <literal>host ... 127.0.0.1 ...</> line from
    <filename>pg_hba.conf</>, or change it to a
    non-<literal>trust</> authentication method.
   </para>
-->
<para>
设置文件系统权限只能帮助 Unix 套接字连接，它不会限制本地 TCP/IP 连接。因此，
如果你想利用文件系统权限来控制本地安全，那么删除<filename>pg_hba.conf</>文件中的
<literal>host ... 127.0.0.1 ...</>行，或者把它改为一个非<literal>trust</>的认证方法。
</para>

   <!--
<para>
    <literal>trust</> authentication is only suitable for TCP/IP connections
    if you trust every user on every machine that is allowed to connect
    to the server by the <filename>pg_hba.conf</> lines that specify
    <literal>trust</>.  It is seldom reasonable to use <literal>trust</>
    for any TCP/IP connections other than those from <systemitem>localhost</> (127.0.0.1).
   </para>
-->
<para>
<literal>trust</>认证模式只适合 TCP/IP 连接，只有在你信任那些<literal>trust</>
行上所有机器中的所有用户的时候才是合适的。
很少有理由使用<literal>trust</>作为任何除来自<systemitem>localhost</> (127.0.0.1)
以外的 TCP/IP 连接的认证方式。
</para>

  </sect2>

  <sect2 id="auth-password">
   <!-- 
   <title>Password Authentication</title> 
   -->
   <title>口令认证</title>

   <indexterm>
    <primary>MD5</>
   </indexterm>
   <indexterm>
    <!-- 
<primary>password</primary>
    <secondary>authentication</secondary> 
-->
<primary>口令</primary>
    <secondary>认证</secondary>
   </indexterm>

   <!--
<para>
    The password-based authentication methods are <literal>md5</>
    and <literal>password</>. These methods operate
    similarly except for the way that the password is sent across the
    connection, namely MD5-hashed and clear-text respectively.
   </para>
-->
<para>
以口令为基础的认证方法包括<literal>md5</>,<literal>password</>。这些方法操作上非常类似，
只不过口令通过连接传送的方法不同：分别是MD5 散列、明文。
</para>

   <!--
<para>
    If you are at all concerned about password
    <quote>sniffing</> attacks then <literal>md5</> is preferred.
    Plain <literal>password</> should always be avoided if possible.
    However, <literal>md5</> cannot be used with the <xref
    linkend="guc-db-user-namespace"> feature.  If the connection is
    protected by SSL encryption then <literal>password</> can be used
    safely (though SSL certificate authentication might be a better
    choice if one is depending on using SSL).
   </para>
-->
<para>
如果你担心口令被<quote>窃听</>，那么<literal>md5</>比较合适。
应该尽可能避免使用<literal>password</>。然而，<literal>md5</>不能和
<xref linkend="guc-db-user-namespace">功能一起使用。如果连接通过SSL加密保护，
那么<literal>password</>可以安全的使用（尽管如果一个用户依赖于使用SSL，
SSL证书认证可能是一个更好的选择。）
</para>

   <!--
<para>
    <productname>PostgreSQL</productname> database passwords are
    separate from operating system user passwords. The password for
    each database user is stored in the <literal>pg_authid</> system
    catalog. Passwords can be managed with the SQL commands
    <xref linkend="sql-createuser"> and
    <xref linkend="sql-alterrole">,
    e.g., <userinput>CREATE USER foo WITH PASSWORD 'secret'</userinput>.
    If no password has been set up for a user, the stored password
    is null and password authentication will always fail for that user.
   </para>
-->
<para>
<productname>PostgreSQL</productname>数据库口令与任何操作系统用户口令无关。
各个数据库用户的口令是存储在<literal>pg_authid</>系统表里面。
口令可以用 SQL 语言命令<xref linkend="sql-createuser">和<xref linkend="sql-alterrole">
等管理(比如<userinput>CREATE USER foo WITH PASSWORD 'secret'</userinput>。
如果没有明确设置口令，那么存储的口令是空并且该用户的口令认证总会失败。
</para>

  </sect2>

  <sect2 id="gssapi-auth">
   <!-- 
   <title>GSSAPI Authentication</title> 
   -->
   <title>GSSAPI 认证</title>

   <indexterm zone="gssapi-auth">
    <primary>GSSAPI</primary>
   </indexterm>

   <!--
<para>
    <productname>GSSAPI</productname> is an industry-standard protocol
    for secure authentication defined in RFC 2743.
    <productname>PostgreSQL</productname> supports
    <productname>GSSAPI</productname> with <productname>Kerberos</productname>
    authentication according to RFC 1964. <productname>GSSAPI</productname>
    provides automatic authentication (single sign-on) for systems
    that support it. The authentication itself is secure, but the
    data sent over the database connection will be sent unencrypted unless
    <acronym>SSL</acronym> is used.
   </para>
-->
<para>
<productname>GSSAPI</productname>是为了在RFC 2743中定义的安全认证的一个工业标准协议。
<productname>PostgreSQL</productname>根据RFC 1964支持<productname>GSSAPI</productname>
和<productname>Kerberos</productname>认证一起使用。<productname>GSSAPI</productname>
为支持它的系统提供自动身份验证（单点登录）。身份验证本身是安全的，
但是数据在数据连接时的传送将会是未加密的，除非使用了<acronym>SSL</acronym>。
</para>

   <!--
<para>
    GSSAPI support has to be enabled when <productname>PostgreSQL</> is built;
    see <xref linkend="installation"> for more information.
   </para>
-->
<para>
GSSAPI支持在<productname>PostgreSQL</>编译时必须打开；参阅<xref linkend="installation">获取更多信息。
</para>

   <!--
<para>
    When <productname>GSSAPI</productname> uses
    <productname>Kerberos</productname>, it uses a standard principal
    in the format
    <literal><replaceable>servicename</>/<replaceable>hostname</>@<replaceable>realm</></literal>.
    The PostgreSQL server will accept any principal that is included in the keytab used by
    the server, but care needs to be taken to specify the correct principal details when
    making the connection from the client using the <literal>krbsrvname</> connection parameter. (See

    also <xref linkend="libpq-paramkeywords">.) The installation default can be
    changed from the default <literal>postgres</literal> at build time using
    <literal>./configure &#045;-with-krb-srvnam=</><replaceable>whatever</>.
    In most environments,
    this parameter never needs to be changed.     
    Some Kerberos implementations might require a different service name,
    such as Microsoft Active Directory which requires the service name
    to be in upper case (<literal>POSTGRES</literal>).
   </para>
-->
<para>
当<productname>GSSAPI</productname>使用<productname>Kerberos</productname>时，
它使用一个标准主体格式<literal><replaceable>servicename</>/<replaceable>hostname</>@<replaceable>realm</></literal>。
PostgreSQL服务器将接受任何包含在服务器使用的keytab中的主体，
但是需要注意的是，在使用<literal>krbsrvname</>连接参数从客户端标记连接时，
要指定正确的主要细节。(又见<xref linkend="libpq-paramkeywords">)。
编译的时候，可以把安装时的缺省<literal>postgres</literal>修改掉，方法是使用
<literal>./configure --with-krb-srvnam=</><replaceable>whatever</>。在大多数情况下，
我们不需要修改这个参数。有些 Kerberos 实现还可能要求其它的服务名，
比如 Microsoft Active Directory 就要求服务名必须是大写的(<literal>POSTGRES</literal>)。
</para>

   <!--
<para>
    <replaceable>hostname</> is the fully qualified host name of the
    server machine. The service principal's realm is the preferred realm
    of the server machine.
   </para>
-->
<para>
<replaceable>hostname</> 是服务器的全限定主机名。服务主的领域就是主机的首选领域。
</para>

   <!--
<para>
    Client principals must have their <productname>PostgreSQL</> database user
    name as their first component, for example
    <literal>pgusername@realm</>.  Alternatively, you can use a user name
    mapping to map from the first component of the principal name to the
    database user name.  By default, the realm of the client is
    not checked by <productname>PostgreSQL</>. If you have cross-realm
    authentication enabled and need to verify the realm, use the
    <literal>krb_realm</> parameter, or enable <literal>include_realm</>
    and use user name mapping to check the realm.
   </para>
-->
<para>
客户主自己必须用它们自己的<productname>PostgreSQL</>用户名作为第一个部件，
比如<literal>pgusername@realm</>。或者，你可以使用一个用户名映射来从主名的第一个部件到数据库用户名映射。
缺省的，<productname>PostgreSQL</>没有检查客户的域；因此如果你打开了跨域的认证，并且需要验证这个域，
那么使用<literal>krb_realm</>参数或者打开<literal>include_realm</>并使用用户名映射来检查这个域。
</para>

   <!--
<para>
    Make sure that your server keytab file is readable (and preferably
    only readable) by the <productname>PostgreSQL</productname> server
    account.  (See also <xref linkend="postgres-user">.) The location
    of the key file is specified by the <xref
    linkend="guc-krb-server-keyfile"> configuration
    parameter. The default is
    <filename>/usr/local/pgsql/etc/krb5.keytab</> (or whatever
    directory was specified as <varname>sysconfdir</> at build time).
    For security reasons, it is recommended to use a separate keytab
    just for the <productname>PostgreSQL</productname> server rather
    than opening up permissions on the system keytab file.
   </para>
-->
<para>
确认服务器的密钥表文件是可以被<productname>PostgreSQL</productname>服务器帐户读取
(最好就是只读的)。(又见<xref linkend="postgres-user">。)密钥文件(keytab)的位置是用配置参数
<xref linkend="guc-krb-server-keyfile">声明的。缺省是<filename>/usr/local/pgsql/etc/krb5.keytab</>
(或者任何在编译的时候声明为<varname>sysconfdir</>的目录)。
出于安全原因，建议为<productname>PostgreSQL</productname>
服务器使用一个单独的keytab，而不是在系统keytab文件中开放权限。
</para>

  
<para>
 <!--
    The keytab file is generated by the Kerberos software; see the
    Kerberos documentation for details. The following example is
   for MIT-compatible Kerberos 5 implementations:
-->
密钥表文件(keytab)是在 Kerberos 软件里生成的，参阅 Kerberos 文档获取细节。
下面的例子是可以用于 MIT 兼容的 Kerberos 5 实现：
<screen>
<prompt>kadmin% </><userinput>ank -randkey postgres/server.my.domain.org</>
<prompt>kadmin% </><userinput>ktadd -k krb5.keytab postgres/server.my.domain.org</>
</screen>
   </para>

   <!--
<para>
    When connecting to the database make sure you have a ticket for a
    principal matching the requested database user name. For example, for
    database user name <literal>fred</>, principal
    <literal>fred@EXAMPLE.COM</> would be able to connect. To also allow
    principal <literal>fred/users.example.com@EXAMPLE.COM</>, use a user name
    map, as described in <xref linkend="auth-username-maps">.
   </para>
-->
<para>
在和数据库连接的时候，请确保自己对每个主都拥有一张匹配所请求的数据库用户名的门票。
比如，对于数据库用户<literal>fred</>，主<literal>fred@EXAMPLE.COM</>将能够连接。
为了也允许主<literal>fred/users.example.com@EXAMPLE.COM</>，使用一个用户名映射，
在<xref linkend="auth-username-maps">中描述。
</para>

<para>
<!--
    The following configuration options are supported for <productname>GSSAPI</productname>:
-->
<productname>GSSAPI</productname>支持下列的配置选项：
    <variablelist>
     <varlistentry>
      <term><literal>include_realm</literal></term>
      <listitem>
       <!-- 
   <para>
        If set to 1, the realm name from the authenticated user
        principal is included in the system user name that's passed through
        user name mapping (<xref linkend="auth-username-maps">). This is
        the recommended configuration as, otherwise, it is impossible to
        differentiate users with the same username who are from different
        realms.  The default for this parameter is 0 (meaning to not include
        the realm in the system user name) but may change to 1 in a future
        version of <productname>PostgreSQL</productname>.  Users can set it
        explicitly to avoid any issues when upgrading.
       </para> 
   -->
<para>
如果设置为1，通过身份验证的用户主的域名包含在通过用户名映射的系统用户名中(<xref linkend="auth-username-maps">)。
这是推荐的配置，否则，它不可能区分开来自不同领域的同名用户。
这个参数的缺省值是0（意味着在系统用户名中不包括该域），
但是在将来的<productname>PostgreSQL</productname>版本中可以改变为1。
用户可以明确的设置它以避免升级时遇到问题。
</para> 
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <!--
<para>
        Allows for mapping between system and database user names. See
        <xref linkend="auth-username-maps"> for details.  For a GSSAPI/Kerberos
        principal, such as <literal>username@EXAMPLE.COM</literal> (or, less
        commonly, <literal>username/hostbased@EXAMPLE.COM</literal>), the
        default user name used for mapping is
        <literal>username</literal> (or <literal>username/hostbased</literal>,
        respectively), unless <literal>include_realm</literal> has been set to
        1 (as recommended, see above), in which case
        <literal>username@EXAMPLE.COM</literal> (or
        <literal>username/hostbased@EXAMPLE.COM</literal>)
        is what is seen as the system username when mapping.
       </para>
-->
<para>
允许在系统和数据库用户名之间映射。参阅<xref linkend="auth-username-maps">获取细节。
对于一个GSSAPI/Kerberos，比如<literal>username@EXAMPLE.COM</literal>
（或者用的较少的<literal>username/hostbased@EXAMPLE.COM</literal>），
用于映射的缺省用户名是<literal>username</literal>
（或者<literal>username/hostbased</literal>），除非
<literal>include_realm</literal>已经设置成了1（就像推荐的那样，见上文），
这种情况下在映射时将<literal>username@EXAMPLE.COM</literal>
（或者<literal>username/hostbased@EXAMPLE.COM</literal>）看做系统用户名。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>krb_realm</literal></term>
      <listitem>
       <!--
<para>
        Sets the realm to match user principal names against. If this parameter
        is set, only users of that realm will be accepted.  If it is not set,
        users of any realm can connect, subject to whatever user name mapping
        is done.
       </para>
-->
<para>
设置域以匹配用户主名称。如果设置了这个参数，那么只接受那个域中的用户。如果没有设置，
那么任何域中的用户都可以连接，使无论什么用户名映射都完成。
</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="sspi-auth">
   <!-- 
   <title>SSPI Authentication</title> 
   -->
   <title>SSPI 认证</title>

   <indexterm zone="sspi-auth">
    <primary>SSPI</primary>
   </indexterm>

   <!--
<para>
    <productname>SSPI</productname> is a <productname>Windows</productname>
    technology for secure authentication with single sign-on.
    <productname>PostgreSQL</productname> will use SSPI in
    <literal>negotiate</literal> mode, which will use
    <productname>Kerberos</productname> when possible and automatically
    fall back to <productname>NTLM</productname> in other cases.
    <productname>SSPI</productname> authentication only works when both
    server and client are running <productname>Windows</productname>,
    or, on non-Windows platforms, when <productname>GSSAPI</productname>
    is available.
   </para>
-->
<para>
<productname>SSPI</productname>是单点登录安全身份验证的一个<productname>Windows</productname>技术。
<productname>PostgreSQL</productname>将在<literal>negotiate</literal>模式下使用SSPI，
当可能时将使用<productname>Kerberos</productname>并且在其他情况下会自动回滚至<productname>NTLM</productname>。
<productname>SSPI</productname>认证只当服务器和客户端都运行<productname>Windows</productname>时工作，
否则，在非Windows平台上，<productname>GSSAPI</productname>是可用的。
</para>

   <!--
<para>
    When using <productname>Kerberos</productname> authentication,
    <productname>SSPI</productname> works the same way
    <productname>GSSAPI</productname> does; see <xref linkend="gssapi-auth">
    for details.
   </para>
-->
<para>
当使用<productname>Kerberos</productname>认证时，<productname>SSPI</productname>以和<productname>GSSAPI</productname>
一样的方式工作；参阅<xref linkend="gssapi-auth">获取详细信息。
</para>

   
<para>
<!--    The following configuration options are supported for <productname>SSPI</productname>:
-->
<productname>SSPI</productname>支持下列的配置选项：
    <variablelist>

     <varlistentry>
      <term><literal>include_realm</literal></term>
      <listitem>
<!-- 
       <para>
        If set to 1, the realm name from the authenticated user
        principal is included in the system user name that's passed through
        user name mapping (<xref linkend="auth-username-maps">). This is
        the recommended configuration as, otherwise, it is impossible to
        differentiate users with the same username who are from different
        realms.  The default for this parameter is 0 (meaning to not include
        the realm in the system user name) but may change to 1 in a future
        version of <productname>PostgreSQL</productname>.  Users can set it
        explicitly to avoid any issues when upgrading.
       </para>
 -->
<para>
如果设置为1，通过身份验证的用户主的域名包含在通过用户名映射的系统用户名中(<xref linkend="auth-username-maps">)。
这是推荐的配置，否则，它不可能区分开来自不同领域的同名用户。
这个参数的缺省值是0（意味着在系统用户名中不包括该域），
但是在将来的<productname>PostgreSQL</productname>版本中可以改变为1。
用户可以明确的设置它以避免升级时遇到问题。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <!--
<para>
        Allows for mapping between system and database user names. See
        <xref linkend="auth-username-maps"> for details.  For a SSPI/Kerberos
        principal, such as <literal>username@EXAMPLE.COM</literal> (or, less
        commonly, <literal>username/hostbased@EXAMPLE.COM</literal>), the
        default user name used for mapping is
        <literal>username</literal> (or <literal>username/hostbased</literal>,
        respectively), unless <literal>include_realm</literal> has been set to
        1 (as recommended, see above), in which case
        <literal>username@EXAMPLE.COM</literal> (or
        <literal>username/hostbased@EXAMPLE.COM</literal>)
        is what is seen as the system username when mapping.
       </para>
-->
<para>
允许在系统和数据库用户名之间映射。参阅<xref linkend="auth-username-maps">获取细节。
对于一个GSSAPI/Kerberos，比如<literal>username@EXAMPLE.COM</literal>
（或者用的较少的<literal>username/hostbased@EXAMPLE.COM</literal>），
用于映射的缺省用户名是<literal>username</literal>
（或者<literal>username/hostbased</literal>），除非
<literal>include_realm</literal>已经设置成了1（就像推荐的那样，见上文），
这种情况下在映射时将<literal>username@EXAMPLE.COM</literal>
（或者<literal>username/hostbased@EXAMPLE.COM</literal>）看做系统用户名。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>krb_realm</literal></term>
      <listitem>
       <!--
<para>
        Sets the realm to match user principal names against. If this parameter
        is set, only users of that realm will be accepted.  If it is not set,
        users of any realm can connect, subject to whatever user name mapping
        is done.
       </para>
-->
<para>
设置域以匹配用户主名称。如果设置了这个参数，那么只接受那个域中的用户。如果没有设置，
那么任何域中的用户都可以连接，使无论什么用户名映射都完成。
</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="auth-ident">
   <!-- 
   <title>Ident Authentication</title> 
   -->
   <title>Ident 认证</title>

   <indexterm>
    <primary>ident</primary>
   </indexterm>

   <!--
<para>
    The ident authentication method works by obtaining the client's
    operating system user name from an ident server and using it as
    the allowed database user name (with an optional user name mapping).
    This is only supported on TCP/IP connections.
   </para>
-->
<para>
ident 认证方法是通过从一个ident服务器获取客户端的操作系统用户名，
并使用它作为允许的数据库用户名（带有一个可选的用户名映射）。
只在TCP/IP连接上支持。
</para>

   <note>
    <!--
<para>
     When ident is specified for a local (non-TCP/IP) connection,
     peer authentication (see <xref linkend="auth-peer">) will be
     used instead.
    </para>
-->
<para>
当ident指定为本地连接（非TCP/IP）时，将使用peer的认证（参阅<xref linkend="auth-peer">）。
</para>
   </note>

   
<para>
<!--
    The following configuration options are supported for <productname>ident</productname>:
-->
<productname>ident</productname>支持下列的配置选项：
    <variablelist>
     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
<!-- 
       <para>
        Allows for mapping between system and database user names. See
        <xref linkend="auth-username-maps"> for details.
       </para>
 -->
<para>
允许在系统和数据库用户名之间映射。参阅<xref linkend="auth-username-maps">获取详细信息。
</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <!--
<para>
    The <quote>Identification Protocol</quote> is described in
    RFC 1413. Virtually every Unix-like
    operating system ships with an ident server that listens on TCP
    port 113 by default. The basic functionality of an ident server
    is to answer questions like <quote>What user initiated the
    connection that goes out of your port <replaceable>X</replaceable>
    and connects to my port <replaceable>Y</replaceable>?</quote>.
    Since <productname>PostgreSQL</> knows both <replaceable>X</> and
    <replaceable>Y</> when a physical connection is established, it
    can interrogate the ident server on the host of the connecting
    client and can theoretically determine the operating system user
    for any given connection.
   </para>
-->
<para>
<quote>Identification Protocol</quote>(标识协议)在 RFC 1413 里面描述。
实际上每个类 Unix 的操作系统都带着一个缺省时侦听 113 端口的身份服务器。
身份服务器的基本功能是回答类似这样的问题：<quote>是什么用户从你的端口
<replaceable>X</replaceable>初始化出来连接到我的端口<replaceable>Y</replaceable>上来了?</quote>。
因为在建立起物理连接后，<productname>PostgreSQL</>既知道<replaceable>X</>也知道<replaceable>Y</>，
因此它可以询问运行尝试连接的客户端的主机，并且理论上可以判断发起连接的操作系统用户。
</para>

   
<para>
<!--
    The drawback of this procedure is that it depends on the integrity
    of the client: if the client machine is untrusted or compromised,
    an attacker could run just about any program on port 113 and
    return any user name he chooses. This authentication method is
    therefore only appropriate for closed networks where each client
    machine is under tight control and where the database and system
    administrators operate in close contact. In other words, you must
    trust the machine running the ident server.
    Heed the warning:
-->
这样做的缺点是它取决于客户端的完整性：如果客户端不可信或者被盗用，
那么攻击者可以在 113 端口上运行任何程序并且返回他们选择的任何用户。
这个认证方法只适用于封闭的网络，
这样的网络里的每台客户机都处于严密的控制下并且数据库和操作系统管理员可以比较方便地联系上。
换句话说，你必须信任运行身份(ident)服务的机器。下面是警告：
    <blockquote>
     <attribution>RFC 1413</attribution>
<!-- 
     <para>
      The Identification Protocol is not intended as an authorization
      or access control protocol.
     </para>
 -->
<para>
身份标识协议并不适用于认证或者访问控制协议。
</para>
    </blockquote>
   </para>

   <!--
<para>
    Some ident servers have a nonstandard option that causes the returned
    user name to be encrypted, using a key that only the originating
    machine's administrator knows.  This option <emphasis>must not</> be
    used when using the ident server with <productname>PostgreSQL</>,
    since <productname>PostgreSQL</> does not have any way to decrypt the
    returned string to determine the actual user name.
   </para>
-->
<para>
有些身份服务器有一个非标准的选项，导致返回的用户名是加密的，
使用的是只有原机器的管理员知道的一个密钥。在与<productname>PostgreSQL</>配合使用身份认证的时候，
你<emphasis>一定不能</>使用这个选项，因为<productname>PostgreSQL</>
没有任何方法对返回的字符串进行解密以获取实际的用户名。
</para>
  </sect2>

  <sect2 id="auth-peer">
   <!-- 
   <title>Peer Authentication</title> 
   -->
   <title>Peer 认证</title>

   <indexterm>
    <primary>peer</primary>
   </indexterm>

   <!--
<para>
    The peer authentication method works by obtaining the client's
    operating system user name from the kernel and using it as the
    allowed database user name (with optional user name mapping). This
    method is only supported on local connections.
   </para>
-->
<para>
peer认证方法通过从内核获得客户端的操作系统用户名和使用它作为允许的数据库用户名
（使用可选的用户名映射）工作。这个方法只支持本地连接。
</para>

   
<para>
<!--
    The following configuration options are supported for <productname>peer</productname>:
 -->
<productname>peer</productname>支持下列的配置选项：
 <variablelist>
     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
<!-- 
       <para>
        Allows for mapping between system and database user names. See
        <xref linkend="auth-username-maps"> for details.
       </para>
 -->
<para>
允许在系统和数据库用户名之间映射。参阅<xref linkend="auth-username-maps">获取详细信息。
</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <!--
<para>
    Peer authentication is only available on operating systems providing
    the <function>getpeereid()</> function, the <symbol>SO_PEERCRED</symbol>
    socket parameter, or similar mechanisms.  Currently that includes
    <systemitem class="osname">Linux</>,
    most flavors of <systemitem class="osname">BSD</> including
    <systemitem class="osname">OS X</>,
    and <systemitem class="osname">Solaris</systemitem>.
   </para>
-->
<para>
Peer认证只能在提供<function>getpeereid()</>函数、<symbol>SO_PEERCRED</symbol>
套接字参数或类似的机制的操作系统上适用，目前包括<systemitem class="osname">Linux</>、
大多数包含<systemitem class="osname">OS X</>的<systemitem class="osname">BSD</>
和<systemitem class="osname">Solaris</systemitem>。
</para>

  </sect2>

  <sect2 id="auth-ldap">
   <!-- 
   <title>LDAP Authentication</title> 
   -->
   <title>LDAP 认证</title>

   <indexterm zone="auth-ldap">
    <primary>LDAP</primary>
   </indexterm>

   <!--
<para>
    This authentication method operates similarly to
    <literal>password</literal> except that it uses LDAP
    as the password verification method. LDAP is used only to validate
    the user name/password pairs. Therefore the user must already
    exist in the database before LDAP can be used for
    authentication.
  </para>
-->
<para>
这个认证方法操作起来类似<literal>password</literal>，只不过它使用 LDAP 作为密码验证机制。
LDAP 只用于验证用户名/口令对。因此，在使用 LDAP 进行认证之前，用户必须已经存在于数据库里。
</para>

   <!--
<para>
    LDAP authentication can operate in two modes. In the first mode,
    which we will call the simple bind mode,
    the server will bind to the distinguished name constructed as
    <replaceable>prefix</> <replaceable>username</> <replaceable>suffix</>.
    Typically, the <replaceable>prefix</> parameter is used to specify
    <literal>cn=</>, or <replaceable>DOMAIN</><literal>\</> in an Active
    Directory environment.  <replaceable>suffix</> is used to specify the
    remaining part of the DN in a non-Active Directory environment.
   </para>
-->
<para>
LDAP认证可以在两种模式操作。在第一种模式，我们将调用简单的绑定模式，
服务器将绑定到以<replaceable>prefix</> <replaceable>username</> <replaceable>suffix</>
构造的识别名(Distinguished Name)上。通常<replaceable>prefix</>
参数用于在活动目录环境中指定<literal>cn=</>或<replaceable>DOMAIN</><literal>\</>。
<replaceable>suffix</>用来在非活动目录环境中指定DN的剩余部分。
</para>

   <!--
<para>
    In the second mode, which we will call the search+bind mode,
    the server first binds to the LDAP directory with
    a fixed user name and password, specified with <replaceable>ldapbinddn</>
    and <replaceable>ldapbindpasswd</>, and performs a search for the user trying
    to log in to the database. If no user and password is configured, an
    anonymous bind will be attempted to the directory. The search will be
    performed over the subtree at <replaceable>ldapbasedn</>, and will try to
    do an exact match of the attribute specified in
    <replaceable>ldapsearchattribute</>.
    Once the user has been found in
    this search, the server disconnects and re-binds to the directory as
    this user, using the password specified by the client, to verify that the
    login is correct. This mode is the same as that used by LDAP authentication
    schemes in other software, such as Apache mod_authnz_ldap and pam_ldap.
    This method allows for significantly more flexibility
    in where the user objects are located in the directory, but will cause
    two separate connections to the LDAP server to be made.
  </para>
-->
<para>
在第二种模式中，我们将调用搜索+绑定模式，服务器首先绑定到LDAP目录上，带有固定用户名和密码，
用<replaceable>ldapbinddn</>和<replaceable>ldapbindpasswd</>指定，并且为试图登陆到数据库的用户执行一次搜索。
如果没有配置用户名和密码，将试图对这个目录进行匿名绑定。将对在<replaceable>ldapbasedn</>
的子树执行搜索，并且将试图对<replaceable>ldapsearchattribute</>指定的属性做一个准确匹配。
一旦在这个目录中发现了用户，服务器断开并且重新作为这个用户绑定到目录，使用客户端指定的密码，
以验证登陆是正确的。这个模式和在其他软件使用的LDAP认证模式相同，例如Apache mod_authnz_ldap 和 pam_ldap。
这种方法允许在目录中的用户对象有很大的灵活性，但是将导致两个独立的连接到LDAP服务器。
</para>

   
<para>
<!--
    The following configuration options are used in both modes:
-->
下列的配置选项在两种模式下都使用：
    <variablelist>
     <varlistentry>
      <term><literal>ldapserver</literal></term>
      <listitem>
<!-- 
       <para>
        Names or IP addresses of LDAP servers to connect to. Multiple
        servers may be specified, separated by spaces.
       </para>
 -->
<para>
连接到的LDAP服务器的名字或IP地址。可能指定多个服务器，用空格分开。
</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapport</literal></term>
      <listitem>
       <!--
<para>
        Port number on LDAP server to connect to. If no port is specified,
        the LDAP library's default port setting will be used.
       </para>
-->
<para>
连接到的LDAP服务器的端口号。如果没有指定端口，将使用LDAP库缺省端口。
</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldaptls</literal></term>
      <listitem>
       <!--
<para>
        Set to 1 to make the connection between PostgreSQL and the
        LDAP server use TLS encryption. Note that this only encrypts
        the traffic to the LDAP server &mdash; the connection to the client
        will still be unencrypted unless SSL is used.
       </para>
-->
<para>
设置为1以使PostgreSQL和LDAP服务器之间的连接使用TLS加密。注意这只加密去往LDAP服务器的流量，
也就是连接到客户端将仍然是未加密的，除非使用了SSL。
</para>
      </listitem>
     </varlistentry>
    </variablelist>

    <!-- 
The following options are used in simple bind mode only: 
-->
下列的选项只在简单绑定模式中使用：
    <variablelist>
     <varlistentry>
      <term><literal>ldapprefix</literal></term>
      <listitem>
       <!--
<para>
        String to prepend to the user name when forming the DN to bind as,
        when doing simple bind authentication.
       </para>
-->
<para>
当做简单的绑定认证，绑定到DN时，前缀到用户名的字符串。
</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapsuffix</literal></term>
      <listitem>
       <!--
<para>
        String to append to the user name when forming the DN to bind as,
        when doing simple bind authentication.
       </para>
-->
<para>
当做简单的绑定认证，绑定到DN时，附加到用户名的字符串。
</para>
      </listitem>
     </varlistentry>
    </variablelist>

    <!-- 
The following options are used in search+bind mode only: 
-->
下列的选项只在搜索+绑定模式中使用：
    <variablelist>
     <varlistentry>
      <term><literal>ldapbasedn</literal></term>
      <listitem>
       <!--
<para>
        Root DN to begin the search for the user in, when doing search+bind
        authentication.
       </para>
-->
<para>
当做搜索+绑定认证时，为用户开始搜索的根DN。
</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapbinddn</literal></term>
      <listitem>
       <!--
<para>
        DN of user to bind to the directory with to perform the search when
        doing search+bind authentication.
       </para>
-->
<para>
当做搜索+绑定认证时，绑定到目录并执行搜索的用户的DN。
</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapbindpasswd</literal></term>
      <listitem>
       <!--
<para>
        Password for user to bind to the directory with to perform the search
        when doing search+bind authentication.
       </para>
-->
<para>
当做搜索+绑定认证时，绑定到目录并执行搜索的用户的密码。
</para>
      </listitem>
      </varlistentry>
      <varlistentry>
       <term><literal>ldapsearchattribute</literal></term>
       <listitem>
        <!--
<para>
         Attribute to match against the user name in the search when doing
         search+bind authentication.  If no attribute is specified, the
         <literal>uid</> attribute will be used.
        </para>
-->
<para>
当做搜索+绑定认证时，在搜索中匹配用户名的属性。如果没有指定属性，将使用<literal>uid</>属性。
</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><literal>ldapurl</literal></term>
       <listitem>
        
<para>
<!--
         An RFC 4516 LDAP URL.  This is an alternative way to write some of the
         other LDAP options in a more compact and standard form.  The format is
-->
一个RFC 4516 LDAP URL。这是一个在更紧凑和标准的形式中写入一些其他LDAP选项的可选择的方式。
格式是
<synopsis>
ldap://<replaceable>host</replaceable>[:<replaceable>port</replaceable>]/<replaceable>basedn</replaceable>[?[<replaceable>attribute</replaceable>][?[<replaceable>scope</replaceable>]]]
</synopsis>
<!-- 
         <replaceable>scope</replaceable> must be one
         of <literal>base</literal>, <literal>one</literal>, <literal>sub</literal>,
         typically the latter.  Only one attribute is used, and some other
         components of standard LDAP URLs such as filters and extensions are
         not supported. 
-->
<replaceable>scope</replaceable>必须是<literal>base</literal>, <literal>one</literal>, 
<literal>sub</literal>之一，通常是最后一个。只使用一个属性，
一些其他的标准LDAP URL的组成部分比如filters和extensions是不支持的。
        </para>

        <!--
<para>
         For non-anonymous binds, <literal>ldapbinddn</literal>
         and <literal>ldapbindpasswd</literal> must be specified as separate
         options.
        </para>
-->
<para>
对于非匿名的绑定， <literal>ldapbinddn</literal>和<literal>ldapbindpasswd</literal>
必须作为独立的选项声明。
</para>

        <!--
<para>
         To use encrypted LDAP connections, the <literal>ldaptls</literal>
         option has to be used in addition to <literal>ldapurl</literal>.
         The <literal>ldaps</literal> URL scheme (direct SSL connection) is not
         supported.
        </para>
-->
<para>
要使用加密的LDAP连接，除了<literal>ldapurl</literal>，必须使用<literal>ldaptls</literal>选项。
不支持<literal>ldaps</literal> URL模式(直接SSL连接）。
</para>

        <!--
<para>
         LDAP URLs are currently only supported with OpenLDAP, not on Windows.
        </para>
-->
<para>
LDAP URL当前只支持OpenLDAP，不是在Windows上。
</para>
       </listitem>
      </varlistentry>
    </variablelist>
   </para>

   <!--
<para>
    It is an error to mix configuration options for simple bind with options
    for search+bind.
   </para>
-->
<para>
混合简单绑定和搜索+绑定的配置选项是错误的。
</para>

   
<para>
<!--
    Here is an example for a simple-bind LDAP configuration:
-->
这里是简单绑定LDAP配置的一个例子：
<programlisting>
host ... ldap ldapserver=ldap.example.net ldapprefix="cn=" ldapsuffix=", dc=example, dc=net"
</programlisting>
<!-- 
    When a connection to the database server as database
    user <literal>someuser</literal> is requested, PostgreSQL will attempt to
    bind to the LDAP server using the DN <literal>cn=someuser, dc=example,
    dc=net</literal> and the password provided by the client.  If that connection
    succeeds, the database access is granted. 
-->
当要求一个到数据库服务器的连接作为数据库用户<literal>someuser</literal>时，
PostgreSQL将试图使用DN <literal>cn=someuser, dc=example, dc=net</literal>绑定到LDAP服务器，
并且密码由客户端提供。如果那个连接成功了，那么就同意数据库访问。
   </para>

   
<para>
<!--
    Here is an example for a search+bind configuration:
-->
这里是搜索+绑定配置的一个例子：
<programlisting>
host ... ldap ldapserver=ldap.example.net ldapbasedn="dc=example, dc=net" ldapsearchattribute=uid
</programlisting>
<!-- 
    When a connection to the database server as database
    user <literal>someuser</literal> is requested, PostgreSQL will attempt to
    bind anonymously (since <literal>ldapbinddn</literal> was not specified) to
    the LDAP server, perform a search for <literal>(uid=someuser)</literal>
    under the specified base DN.  If an entry is found, it will then attempt to
    bind using that found information and the password supplied by the client.
    If that second connection succeeds, the database access is granted. 
-->
当要求一个到数据库服务器的连接作为数据库用户<literal>someuser</literal>时，
PostgreSQL将试图匿名（因为没有指定<literal>ldapbinddn</literal>）绑定到LDAP服务器，
为<literal>(uid=someuser)</literal>在指定的基础DN下执行一个搜索。如果发现一条记录，
它将试图使用发现的信息和客户端提供的密码绑定。如果第二个链接成功，那么就同意数据库访问。
   </para>
   
<para>
<!--
    Here is the same search+bind configuration written as a URL:
-->
这是相同的搜索+绑定配置，写作一个URL：
<programlisting>
host ... ldap lapurl="ldap://ldap.example.net/dc=example,dc=net?uid?sub"
</programlisting>
<!-- 
    Some other software that supports authentication against LDAP uses the
    same URL format, so it will be easier to share the configuration. 
-->
一些其他支持LDAP认证的软件使用相同的URL格式，所以它将更容易共享配置。
   </para>

   <tip>
    <!--
<para>
     Since LDAP often uses commas and spaces to separate the different
     parts of a DN, it is often necessary to use double-quoted parameter
     values when configuring LDAP options, as shown in the examples.
    </para>
-->
<para>
因为LDAP经常使用逗号和空格来分开DN的不同部分，所以当配置LDAP选项时，
通常需要使用双引号参数值，就像例子中所示的一样。
</para>
   </tip>

  </sect2>

  <sect2 id="auth-radius">
   <!-- 
   <title>RADIUS Authentication</title> 
   -->
   <title>RADIUS 认证</title>

   <indexterm zone="auth-radius">
    <primary>RADIUS</primary>
   </indexterm>

   <!--
<para>
    This authentication method operates similarly to
    <literal>password</literal> except that it uses RADIUS
    as the password verification method. RADIUS is used only to validate
    the user name/password pairs. Therefore the user must already
    exist in the database before RADIUS can be used for
    authentication.
   </para>
-->
<para>
这个认证方法操作起来类似<literal>password</literal>，只不过它使用RADIUS作为密码验证方法。
RADIUS只用于验证用户名/口令对。因此，在使用RADIUS进行认证之前，用户必须已经存在于数据库里。
</para>

   <!--
<para>
    When using RADIUS authentication, an Access Request message will be sent
    to the configured RADIUS server. This request will be of type
    <literal>Authenticate Only</literal>, and include parameters for
    <literal>user name</>, <literal>password</> (encrypted) and
    <literal>NAS Identifier</>. The request will be encrypted using
    a secret shared with the server. The RADIUS server will respond to
    this server with either <literal>Access Accept</> or
    <literal>Access Reject</>. There is no support for RADIUS accounting.
   </para>
-->
<para>
当使用RADIUS认证时，一个访问请求信息将发送到已配置好的RADIUS服务器。
这个请求将会是类型<literal>Authenticate Only</literal>，并且包含参数
<literal>user name</>, <literal>password</> (加密的) 和 <literal>NAS Identifier</>。
这个请求将使用一个和服务器秘密共享的加密。RADIUS服务器将以<literal>Access Accept</>
或<literal>Access Reject</>响应这个服务器。不支持RADIUS账户。
</para>

   
<para>
<!--
    The following configuration options are supported for RADIUS:
-->
RADIUS支持下列的配置选项：
     <variablelist>
      <varlistentry>
       <term><literal>radiusserver</literal></term>
       <listitem>
<!-- 
        <para>
         The name or IP address of the RADIUS server to connect to.
         This parameter is required.
        </para>
 -->
<para>
连接到的RADIUS服务器的名字或IP地址。这个参数是必需的。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>radiussecret</literal></term>
       <listitem>
        
<para>
<!--
         The shared secret used when talking securely to the RADIUS
         server. This must have exactly the same value on the PostgreSQL
         and RADIUS servers. It is recommended that this be a string of
         at least 16 characters. This parameter is required.
-->
当安全的和RADIUS服务器对话时使用的共享秘钥。在PostgreSQL和RADIUS服务器上必须有完全相同的值。
建议至少为16个字符的字符串。这个参数是必需的。
         <note>
<!-- 
         <para>
          The encryption vector used will only be cryptographically
          strong if <productname>PostgreSQL</> is built with support for
          <productname>OpenSSL</>. In other cases, the transmission to the
          RADIUS server should only be considered obfuscated, not secured, and
          external security measures should be applied if necessary.
         </para>
 -->
<para>
如果<productname>PostgreSQL</>编译支持<productname>OpenSSL</>，那么加密向量将只被强大的加密使用。
在其他情况下，到RADIUS服务器的传输应该只被认为是混淆的，不是安全的，并且必要时应该采用外部安全措施。
</para>
         </note>
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>radiusport</literal></term>
       <listitem>
        <!--
<para>
         The port number on the RADIUS server to connect to. If no port
         is specified, the default port <literal>1812</> will be used.
        </para>
-->
<para>
连接到的RADIUS服务器的端口号。如果没有指定端口，将使用缺省的端口<literal>1812</>。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>radiusidentifier</literal></term>
       <listitem>
        <!--
<para>
         The string used as <literal>NAS Identifier</> in the RADIUS
         requests. This parameter can be used as a second parameter
         identifying for example which database user the user is attempting
         to authenticate as, which can be used for policy matching on
         the RADIUS server. If no identifier is specified, the default
         <literal>postgresql</> will be used.
        </para>
-->
<para>
在RADIUS请求中作为<literal>NAS Identifier</>使用的字符串。这个参数可以用作第二个参数标识，
比如用户试图作为哪个数据库用户验证，哪个可以用来在RADIUS服务器上政策匹配。
如果没有指定标识符，将使用缺省的<literal>postgresql</>。
</para>
       </listitem>
      </varlistentry>

     </variablelist>
   </para>
  </sect2>

  <sect2 id="auth-cert">
   <!-- 
   <title>Certificate Authentication</title> 
   -->
   <title>证书认证</title>

   <indexterm zone="auth-cert">
    <!-- 
<primary>Certificate</primary> 
-->
<primary>证书</primary>
   </indexterm>

   <!--
<para>
    This authentication method uses SSL client certificates to perform
    authentication. It is therefore only available for SSL connections.
    When using this authentication method, the server will require that
    the client provide a valid certificate. No password prompt will be sent
    to the client. The <literal>cn</literal> (Common Name) attribute of the
    certificate
    will be compared to the requested database user name, and if they match
    the login will be allowed.  User name mapping can be used to allow
    <literal>cn</literal> to be different from the database user name.
   </para>
-->
<para>
这个认证方法使用SSL证书来执行认证。因此只适用于SSL连接。当使用这个认证方法时，
服务器将请求客户端提供一个有效的证书。没有密码提示发送给客户端。
证书的<literal>cn</literal> (Common Name) 属性将与请求的数据库用户名比较，
如果它们匹配，登陆将被允许。用户名映射可以用来允许<literal>cn</literal>不同于数据库用户名。
</para>

   
<para>
 <!--
 The following configuration options are supported for SSL certificate
    authentication:
-->
SSL证书认证支持下列的配置选项：
    <variablelist>
     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
<!-- 
       <para>
        Allows for mapping between system and database user names. See
        <xref linkend="auth-username-maps"> for details.
       </para>
 -->
<para>
允许在系统和数据库用户名之间映射。参阅<xref linkend="auth-username-maps">获取详细信息。
</para>
      </listitem>
     </varlistentry>
    </variablelist>
  </para>
  </sect2>

  <sect2 id="auth-pam">
   <!-- 
   <title>PAM Authentication</title> 
   -->
   <title>PAM 认证</title>

   <indexterm zone="auth-pam">
    <primary>PAM</primary>
   </indexterm>

   <!--
<para>
    This authentication method operates similarly to
    <literal>password</literal> except that it uses PAM (Pluggable
    Authentication Modules) as the authentication mechanism. The
    default PAM service name is <literal>postgresql</literal>.
    PAM is used only to validate user name/password pairs.
    Therefore the user must already exist in the database before PAM
    can be used for authentication.  For more information about
    PAM, please read the <ulink url="http://www.kernel.org/pub/linux/libs/pam/">
    <productname>Linux-PAM</> Page</ulink>.
   </para>
-->
<para>
这个认证方法操作起来类似<literal>password</literal>，只不过它使用 PAM 
(Pluggable Authentication Modules)作为认证机制。缺省的 PAM 服务名是<literal>postgresql</literal>。
PAM 只用于验证用户名/口令对。因此，在使用 PAM 进行认证之前，用户必须已经存在于数据库里。
有关 PAM 的更多信息，请阅读<ulink url="http://www.kernel.org/pub/linux/libs/pam/"> <productname>Linux-PAM</>页面</ulink>。
</para>

   
<para>
<!--
    The following configuration options are supported for PAM:
-->
PAM支持下列的配置选项：
    <variablelist>
     <varlistentry>
      <term><literal>pamservice</literal></term>
      <listitem>
<!-- 
       <para>
        PAM service name.
       </para>
 -->
<para>
PAM服务名。
</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <note>
    <!--
<para>
     If PAM is set up to read <filename>/etc/shadow</>, authentication
     will fail because the PostgreSQL server is started by a non-root
     user.  However, this is not an issue when PAM is configured to use
     LDAP or other authentication methods.
    </para>
-->
<para>
如果PAM设置为读取<filename>/etc/shadow</>，那么将验证失败，因为PostgreSQL服务器是通过非root用户启动的。
然而，当PAM设置为使用LDAP或其他认证方法时将不是一个问题。
</para>
   </note>
  </sect2>
 </sect1>

  <sect1 id="client-authentication-problems">
   <!-- 
   <title>Authentication Problems</title> 
   -->
   <title>用户认证</title>

   <!--
<para>
    Authentication failures and related problems generally
    manifest themselves through error messages like the following:
   </para>
-->
<para>
认证失败以及相关的问题通常由类似下面的错误消息表白。
</para>

   
<para>
<programlisting>
FATAL:  no pg_hba.conf entry for host "123.123.123.123", user "andym", database "testdb"
</programlisting>
<!--
    This is what you are most likely to get if you succeed in contacting
    the server, but it does not want to talk to you. As the message
    suggests, the server refused the connection request because it found
    no matching entry in its <filename>pg_hba.conf</filename>
    configuration file.
-->
这条消息出现的最大可能是你已经连接了服务器，但它不愿意和你说话。
就像消息自己表示的那样，服务器拒绝了连接请求，因为它没有在它的<filename>pg_hba.conf</filename>
配置文件里找到匹配的记录。
   </para>

  
<para>
<programlisting>
FATAL:  password authentication failed for user "andym"
</programlisting>
 <!--
 Messages like this indicate that you contacted the server, and it is
    willing to talk to you, but not until you pass the authorization
    method specified in the <filename>pg_hba.conf</filename> file. Check
    the password you are providing, or check your Kerberos or ident
    software if the complaint mentions one of those authentication
    types.
-->
这样的消息表示你连接了服务器，并且它也愿意和你交谈，但是你必须通过
<filename>pg_hba.conf</filename>文件里声明的认证方法。检查你提交的口令，
或者如果错误消息提到这些 Kerberos 或 IDENT 认证类型时检查这些软件。
   </para>

   
<para>
<programlisting>
FATAL:  user "andym" does not exist
</programlisting>
<!--
    The indicated database user name was not found.
-->
这是表示数据库用户不存在的。
   </para>

   
<para>
<programlisting>
FATAL:  database "testdb" does not exist
</programlisting>
<!--
    The database you are trying to connect to does not exist. Note that
    if you do not specify a database name, it defaults to the database
    user name, which might or might not be the right thing.
-->
你试图连接的数据库不存在。请注意如果你没有声明数据库名，缺省是数据库用户名，
这可能正确也可能不正确。
   </para>

   <tip>
   <!--
<para>
    The server log might contain more information about an
    authentication failure than is reported to the client. If you are
    confused about the reason for a failure, check the server log.
   </para>
-->
<para>
请注意服务器日志可能包含比报告给客户端的更多的有关认证失败的信息。
如果你被失败的原因搞糊涂了，那么请检查服务器日志。
</para>
   </tip>
  </sect1>

 </chapter>
