<!-- doc/src/sgml/client-auth.sgml -->

<chapter id="client-authentication">
 <title>客户端认证</title>

 <indexterm zone="client-authentication">
  <primary>客户端认证</primary>
 </indexterm>

 <para>
  当一个客户端应用连接一个数据库服务器时，它将指定以哪个<productname>PostgreSQL</productname> 数据库用户名连接，就像我们以一个特定用户登录一台 Unix 计算机一样。在 SQL 环境中，活动的数据库用户名决定对数据库对象的访问权限 &mdash; 详见<xref linkend="user-manag">。因此，它本质上是哪些数据库用户可以连接。
 </para>

 <note>
  <para>
   如<xref linkend="user-manag">中所释，<productname>PostgreSQL</productname>实际上以<quote>角色</>来进行权限管理。在本章中，我们用<firstterm>数据库用户</>表示<quote>拥有<literal>LOGIN</>权限的角色</quote>。
  </para>
 </note>

 <para>
  <firstterm>认证</firstterm>是数据库服务器建立客户端身份的过程，并且服务器决定客户端应用（或者运行客户端应用的用户）是否被允许以请求的数据库用户名来连接。
 </para>

 <para>
  <productname>PostgreSQL</productname>提供多种不同的客户端认证方式。被用来认证一个特定客户端连接的方法可以基于（客户端）主机地址、数据库和用户来选择。
 </para>

 <para>
  <productname>PostgreSQL</productname>数据库用户名在逻辑上是和服务器运行的操作系统中的用户名相互独立的。如果一个特定服务器的所有用户在那台服务器的机器上也有帐号，那么分配与操作系统用户名匹配的数据库用户名是有意义的。不过，一个接受远程连接的服务器可能有许多没有本地操作系统帐号的用户，并且在这种情况下数据库用户和操作系统用户名之间不必有任何联系。
 </para>

 <sect1 id="auth-pg-hba-conf">
  <title><filename>pg_hba.conf</filename>文件</title>

  <indexterm zone="auth-pg-hba-conf">
   <primary>pg_hba.conf</primary>
  </indexterm>

  <para>
   客户端认证是由一个配置文件（通常名为<filename>pg_hba.conf</filename>并被存放在数据库集簇目录中）控制（<acronym>HBA</>表示基于主机的认证）。在<command>initdb</command>初始化数据目录时，它会安装一个默认的<filename>pg_hba.conf</filename>文件。不过我们也可以把认证配置文件放在其它地方； 参阅<xref linkend="guc-hba-file">配置参数。
  </para>

  <para>
   <filename>pg_hba.conf</filename>文件的常用格式是一组记录，每行一条。空白行将被忽略， <literal>#</literal>注释字符后面的任何文本也被忽略。记录不能跨行。一条记录由若干用空格
   和/或制表符分隔的域组成。如果域值用双引号包围，那么它可以包含空白。在数据库、用户或地址域中
   引用一个关键字（例如，<literal>all</>或<literal>replication</>）将使该词失去其特殊
   含义，并且只是匹配一个有该名字的数据库、用户或主机。
  </para>

  <para>
   每条记录指定一种连接类型、一个客户端 IP 地址范围（如果和连接类型相关）、一个数据库名、一个用户名以及对匹配这些参数的连接使用的认证方法。第一条匹配连接类型、客户端地址、连接请求的数据库和用户名的记录将被用于执行认证。这个过程没有<quote>落空</>或者<quote>后备</>的说法：如果选择了一条记录而且认证失败，那么将不再考虑后面的记录。如果没有匹配的记录，那么访问将被拒绝。
  </para>

  <para>
   记录可以是下面七种格式之一：
<synopsis>
local      <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
host       <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>address</replaceable>  <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostssl    <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>address</replaceable>  <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostnossl  <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>address</replaceable>  <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
host       <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>IP-address</replaceable>  <replaceable>IP-mask</replaceable>  <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostssl    <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>IP-address</replaceable>  <replaceable>IP-mask</replaceable>  <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostnossl  <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>IP-address</replaceable>  <replaceable>IP-mask</replaceable>  <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
</synopsis>
   各个域的含义如下：

   <variablelist>
    <varlistentry>
     <term><literal>local</literal></term>
     <listitem>
      <para>
       这条记录匹配企图使用 Unix 域套接字的连接。如果没有这种类型的记录，就不允许 Unix 域套接字连接。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>host</literal></term>
     <listitem>
      <para>
       这条记录匹配企图使用 TCP/IP 建立的连接。<literal>host</literal>记录匹配<acronym>SSL</acronym>和非<acronym>SSL</acronym>的连接尝试。
      </para>
     <note>
      <para>
       除非服务器带着合适的<xref linkend="guc-listen-addresses">配置参数值启动，否则将不可能进行远程的 TCP/IP 连接，因为默认的行为是只监听在本地环回地址<literal>localhost</>上的 TCP/IP 连接。
      </para>
     </note>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>hostssl</literal></term>
     <listitem>
      <para>
       这条记录匹配企图使用 TCP/IP 建立的连接，但必须是使用<acronym>SSL</acronym>加密的连接。
      </para>

      <para>
       要使用这个选项，编译服务器的时候必须打开<acronym>SSL</acronym>支持。此外，在服务器启动的时候必须通过设置<xref linkend="guc-ssl">配置参数（详见<xref linkend="ssl-tcp">）打开<acronym>SSL</acronym>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>hostnossl</literal></term>
     <listitem>
      <para>
       这条记录的行为与<literal>hostssl</>相反；它只匹配那些在 TCP/IP上不使用<acronym>SSL</acronym>的连接企图。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>database</replaceable></term>
     <listitem>
      <para>
       指定记录所匹配的数据库名称。值<literal>all</literal>指定该记录匹配所有数据库。值 <literal>sameuser</>指定如果被请求的数据库和请求的用户同名，则匹配。值<literal>samerole</>指定请求的用户必须是一个与数据库同名的角色中的成员（<literal>samegroup</>是一个已经废弃了，但目前仍然被接受的<literal>samerole</>同义词）。对于一个用于<literal>samerole</>目的的角色，超级用户不会被考虑为其中的成员，除非它们是该角色的显式成员（直接或间接），而不是由于超级用户的原因。值<literal>replication</>指定如果一个复制连接被请求则该记录匹配（注意复制连接不指定任何特定的数据库）。在其它情况里，这就是一个特定的<productname>PostgreSQL</productname>数据库名字。可以通过用逗号分隔的方法指定多个数据库，也可以通过在文件名前面放<literal>@</>来指定一个包含数据库名的文件。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>user</replaceable></term>
     <listitem>
      <para>
       指定这条记录匹配哪些数据库用户名。值<literal>all</literal>指定它匹配所有用户。否则，它要么是一个特定数据库用户的名字或者是一个有前导<literal>+</>的组名称（回想一下，在<productname>PostgreSQL</>里，用户和组没有真正的区别，<literal>+</>实际表示<quote>匹配这个角色的任何直接或间接成员角色</>，而没有<literal>+</>记号的名字只匹配指定的角色）。出于这个目的，如果超级用户显式的是一个角色的成员（直接或间接），那么超级用户将只被认为是该角色的一个成员而不是作为一个超级用户。多个用户名可以通过用逗号分隔的方法提供。一个包含用户名的文件可以通过在文件名前面加上<literal>@</>来指定。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>address</replaceable></term>
     <listitem>
      <para>
       指定这个记录匹配的客户端机器地址。这个域可以包含一个主机名、一个 IP 地址范围或下文提到的特殊关键字之一。
      </para>

      <para>
       一个 IP 地址范围以该范围的开始地址的标准数字记号指定，然后是一个斜线（<literal>/</literal>）
       和一个<acronym>CIDR</>掩码长度。掩码长度表示客户端 IP 地址必须匹配的高序二进制位位数。在给出的 IP 地址中，这个长度的右边的二进制位必须为零。 在 IP 地址、<literal>/</literal>和 CIDR 掩码长度之间不能有空白。
      </para>

      <para>
       这种方法指定一个 IPv4 地址范围的典型例子是：
       <literal>172.20.143.89/32</literal>用于一个主机，
       <literal>172.20.143.0/24</literal>用于一个小型网络，
       <literal>10.6.0.0/16</literal>用于一个大型网络。
       一个单主机的 IPv6 地址范围看起来像这样：<literal>::1/128</literal>（IPv6 回环地址），
       一个小型网络的 IPv6 地址范围则类似于：<literal>fe80::7a31:c1ff:0000:0000/96</literal>。
       <literal>0.0.0.0/0</literal>表示所有 IPv4 地址，并且<literal>::0/0</literal>表示所有 IPv6 地址。要指定一个单一主机，IPv4 用一个长度为 32 的 CIDR 掩码或者 IPv6 用
       长度为 128 的 CIDR 掩码。在一个网络地址中，不要省略结尾的零。
      </para>

      <para>
       一个以 IPv4 格式给出的项将只匹配 IPv4 连接并且一个以 IPv6 格式给出的项将只匹配 IPv6 连接，即使对应的地址在 IPv4-in-IPv6 范围内。请注意如果系统的 C 库不支持 IPv6 地址，那么 IPv6 格式中的项将被拒绝。
      </para>

      <para>
       你也可以写<literal>all</literal>来匹配任何 IP 地址、写<literal>samehost</literal>来匹配任何本服务器自身的 IP 地址或者写<literal>samenet</literal>来匹配本服务器直接连接到的任意子网的任意地址。
      </para>

      <para>
       若果指定了一个主机名（任何除 IP 地址单位或特殊关键字之外的都被作为主机名处理），
       该名称会与客户端的 IP 地址的反向名字解析（例如使用 DNS 时的反向 DNS 查找）结果进行比较。主机名比较是大小写敏感的。如果匹配上，那么将在主机名上执行一次正向名字解析（例如正向 DNS 查找）来检查它解析到的任何地址是否等于客户端的 IP 地址。如果两个方向都匹配，则该项被认为匹配（<filename>pg_hba.conf</filename>中使用的主机名应该是客户端 IP 地址的地址到名字解析返回的结果，否则该行将不会匹配。某些主机名数据库允许将一个 IP 地址关联多个主机名，但是当被要求解析一个 IP 地址时，操作系统将只返回一个主机名）。
      </para>

      <para>
       一个以点号（<literal>.</literal>）开始的主机名声明匹配实际主机名的后缀。因此<literal>.example.com</literal>将匹配<literal>foo.example.com</literal>（但不匹配<literal>example.com</literal>）。
      </para>

      <para>
       当主机名在<filename>pg_hba.conf</filename>中被指定时，你应该保证名字解析很快。建立一个类似<command>nscd</command>的本地名字解析缓存是一种不错的选择。另外，你可能希望启用配置参数<varname>log_hostname</varname>来在日志中查看客户端的主机名而不是 IP 地址。
      </para>

      <para>
       这个域只适用于<literal>host</literal>、
       <literal>hostssl</literal>和<literal>hostnossl</>记录。
      </para>

      <sidebar>
       <para>
        用户有时候会疑惑为什么这样处理的主机名看起来很复杂，因为需要两次名字解析（包括一次
        客户端 IP 地址的反向查找）。在客户端的反向 DNS 项没有建立或者得到某些意料之外的主机
        名的情况下，这种方式会让该特性的使用变得复杂。这样做主要是为了效率：通过这种方式，一次
        连接尝试要求最多两次解析器查找，一次逆向以及一次正向。如果有一个解析器对于该地址有问
        题，这仅仅是客户端的问题。一种假想的替代实现是只做前向查找，这种方法不得不在每一次连接
        尝试期间解析<filename>pg_hba.conf</filename>中提到的每一个主机名。如果列出了很多
        名称，这就会很慢。并且如果主机名之一有解析器问题，它会变成所有人的问题。
       </para>

       <para>
        另外，一次反向查找也是实现后缀匹配特性所需的，因为需要知道实际的客户端主机名来与模式进行匹配。
       </para>

       <para>
        注意这种行为与其他流行的基于主机名的访问控制实现相一致，例如 Apache HTTP Server 和 TCP Wrappers。
       </para>
      </sidebar>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>IP-address</replaceable></term>
     <term><replaceable>IP-mask</replaceable></term>
     <listitem>
      <para>
       这两个域可以被用作<replaceable>IP-address</><literal>/</>
       <replaceable>mask-length</>记号法的替代方案。和指定掩码长度不同，实际的掩码被指
       定在一个单独的列中。例如，<literal>255.0.0.0</>表示 IPv4 CIDR 掩码长度 8，而<literal>255.255.255.255</>表示 CIDR 掩码长度 32。
      </para>

      <para>
       这些域只适用于<literal>host</literal>、<literal>hostssl</literal>和<literal>hostnossl</>记录。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>auth-method</replaceable></term>
     <listitem>
      <para>
       指定当一个连接匹配这个记录时，要使用的认证方法。下面对可能的选择做了概述，详见<xref linkend="auth-methods">。

       <variablelist>
        <varlistentry>
         <term><literal>trust</></term>
         <listitem>
         <para>
          无条件地允许连接。这种方法允许任何可以与<productname>PostgreSQL</productname>数据库服务器连接的用户以他们期望的任意<productname>PostgreSQL</productname>数据库用户身份登入，而不需要口令或者其他任何认证。详见<xref linkend="auth-trust">。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>reject</></term>
        <listitem>
         <para>
          无条件地拒绝连接。这有助于从一个组中<quote>过滤出</>特定主机，例如一个<literal>reject</>行可以阻塞一个特定的主机连接，而后面一行允许一个特定网络中的其余主机进行连接。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>md5</></term>
        <listitem>
         <para>
          要求客户端提供一个双重 MD5 加密的口令进行认证。详见<xref linkend="auth-password">。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>password</></term>
        <listitem>
         <para>
          要求客户端提供一个未加密的口令进行认证。因为口令是以明文形式在网络上发送的，所以我们不应该在不可信的网络上使用这种方式。详见<xref linkend="auth-password">。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>gss</></term>
        <listitem>
         <para>
          用 GSSAPI 认证用户。只对 TCP/IP 连接可用。详见<xref linkend="gssapi-auth">。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>sspi</></term>
        <listitem>
         <para>
          用 SSPI 来认证用户。只在 Windows 上可用。详见<xref linkend="sspi-auth">。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>ident</></term>
        <listitem>
         <para>
          通过联系客户端的 ident 服务器获取客户端的操作系统名，并且检查它是否匹配被请求的数据库用户名。Ident 认证只能在 TCIP/IP 连接上使用。当为本地连接指定这种认证方式时，将用 peer 认证来替代。详见<xref linkend="auth-ident">。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>peer</></term>
        <listitem>
         <para>
          从操作系统获得客户端的操作系统用户，并且检查它是否匹配被请求的数据库用户名。这只对本地连接可用。详见<xref linkend="auth-peer">。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>ldap</></term>
        <listitem>
         <para>
          使用<acronym>LDAP</>服务器认证。详见<xref linkend="auth-ldap">。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>radius</></term>
        <listitem>
         <para>
          用 RADIUS 服务器认证。详见<xref linkend="auth-radius">。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>cert</></term>
        <listitem>
         <para>
          使用 SSL 客户端证书认证。详见<xref linkend="auth-cert">。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>pam</></term>
        <listitem>
         <para>
          使用操作系统提供的可插入认证模块服务（PAM）认证。详见<xref linkend="auth-pam">。
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>auth-options</replaceable></term>
     <listitem>
      <para>
       在<replaceable>auth-method</>域的后面，可以是形如<replaceable>name</><literal>=</><replaceable>value</>的域，它们指定认证方法的选项。关于哪些认证方法可以用哪些选项的细节请见下文。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   用<literal>@</>结构包括的文件被读作一个名字列表，它们可以用空白或者逗号分隔。注释用<literal>#</literal>引入，就像在<filename>pg_hba.conf</filename>中那样，并且允许嵌套<literal>@</>结构。除非跟在<literal>@</>后面的文件名是一个绝对路径， 文件名都被认为是相对于包含引用文件的目录。
  </para>

  <para>
   因为每一次连接尝试都会顺序地检查<filename>pg_hba.conf</filename>记录，所以这些记录的顺序是非常关键的。通常，靠前的记录有比较严的连接匹配参数和比较弱的认证方法，而靠后的记录有比较松的匹配参数和比较强的认证方法。 例如，我们希望对本地 TCP/IP 连接使用<literal>trust</>认证，而对远程 TCP/IP 连接要求口令。在这种情况下为来自于 127.0.0.1 的连接指定<literal>trust</>认证的记录将出现在为一个更宽范围的客户端 IP 地址指定口令认证的记录前面。
  </para>

  <para>
   在启动以及主服务器进程收到<systemitem>SIGHUP</systemitem><indexterm><primary>SIGHUP</primary></indexterm>信号时，<filename>pg_hba.conf</filename>文件会被读取。 如果你在活动的系统上编辑了该文件，你将需要通知 postmaster（使用<literal>pg_ctl reload</>或<literal>kill -HUP</>）重新读取该文件。
  </para>

  <tip>
   <para>
    要连接到一个特定数据库，一个用户必须不仅要通过<filename>pg_hba.conf</filename>检查，还必须要有该数据库上的<literal>CONNECT</>权限。如果你希望限制哪些用户能够连接到哪些数据库，授予/撤销<literal>CONNECT</>权限通常比在<filename>pg_hba.conf</filename>项中设置规则简单。
   </para>
  </tip>

  <para>
   <xref linkend="example-pg-hba.conf">中展示了<filename>pg_hba.conf</filename>项的一些例子。不同认证方法的详情请见下一节。
  </para>

   <example id="example-pg-hba.conf">
    <title>示例 <filename>pg_hba.conf</filename> 项</title>
<programlisting>
# 允许本地系统上的任何用户
# 通过 Unix 域套接字以任意
# 数据库用户名连接到任意数据库
#（本地连接的默认值）。
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
local   all             all                                     trust

# 相同的规则，但是使用本地环回 TCP/IP 连接。
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             127.0.0.1/32            trust

# 和前一行相同，但是使用了一个独立的掩码列
#
# TYPE  DATABASE        USER            IP-ADDRESS      IP-MASK             METHOD
host    all             all             127.0.0.1       255.255.255.255     trust

# IPv6 上相同的规则
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             ::1/128                 trust

# 使用主机名的相同规则（通常同时覆盖 IPv4 和 IPv6）。
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             localhost               trust

# 允许来自任意具有 IP 地址
# 192.168.93.x 的主机上任意
# 用户以 ident 为该连接所
# 报告的相同用户名连接到
# 数据库 "postgres"
#（通常是操作系统用户名）。
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    postgres        all             192.168.93.0/24         ident

# 如果用户的口令被正确提供，
# 允许来自主机 192.168.12.10
# 的任意用户连接到数据库 "postgres"。
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    postgres        all             192.168.12.10/32        md5

# 如果用户的口令被正确提供，
# 允许 example.com 中主机上
# 的任意用户连接到任意数据库。
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             .example.com            md5

# 如果没有前面的 "host" 行，这两
# 行将拒绝所有来自 192.168.54.1
# 的连接（因为那些项将首先被匹配），
# 但是允许来自互联网其他任何地方的
# GSSAPI 连接。零掩码导致主机
# IP 地址中的所有位都不会被考虑，
# 因此它匹配任意主机。
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             192.168.54.1/32         reject
host    all             all             0.0.0.0/0               gss

# 允许来自 192.168.x.x 主机的用户
# 连接到任意数据库，如果它们能够
# 通过 ident 检查。例如，假设 ident
# 说用户是 "bryanh" 并且他要求以
# PostgreSQL 用户 "guest1" 连接，
# 如果在 pg_ident.conf 有一个映射
# "omicron" 的选项说 "bryanh" 被
# 允许以 "guest1" 连接，则该连接将被允许。
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             192.168.0.0/16          ident map=omicron

# 如果这些是本地连接的唯一三行，
# 它们将允许本地用户只连接到它们
# 自己的数据库（与其数据库用户名
# 同名的数据库），不过管理员和角
# 色 "support" 的成员除外（它们可
# 以连接到所有数据库）。文件
# $PGDATA/admins 包含一个管理员
# 名字的列表。在所有情况下都要求口令。
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
local   sameuser        all                                     md5
local   all             @admins                                 md5
local   all             +support                                md5

# 上面的最后两行可以被整合为一行：
local   all             @admins,+support                        md5

# 数据库列也可以用列表和文件名：
local   db1,db2,@demodbs  all                                   md5
</programlisting>
   </example>
 </sect1>

 <sect1 id="auth-username-maps">
  <title>用户名映射</title>

  <indexterm zone="auth-username-maps">
   <primary>用户名映射</primary>
  </indexterm>

  <para>
   当使用像 Ident 或者 GSSAPI 外部认证系统时，发起连接的操作系统用户名可能不同于他要使用的数据库用户。在这种情况下，一个用户名映射可被用来把操作系统用户名映射到数据库用户。要使用用户名映射，在<filename>pg_hba.conf</filename>的选项域指定<literal>map</literal>=<replaceable>map-name</replaceable>。此选项支持所有接收外部用户名的认证方法。由于不同的连接可能需要不同的映射，在<filename>pg_hba.conf</filename>中的<replaceable>map-name</replaceable>参数中指定要被使用的映射名，用以指示哪个映射用于每个个体连接。
  </para>

  <para>
   用户名映射定义在 ident 映射文件中，默认情况下它被命名为<filename>pg_ident.conf</><indexterm><primary>pg_ident.conf</primary></indexterm>并被存储在集簇的数据目录中（不过，可以把该映射文件放在其他地方，见<xref linkend="guc-ident-file">配置参数）。ident 映射文件包含的行的一般格式：
<synopsis>
<replaceable>map-name</> <replaceable>system-username</> <replaceable>database-username</>
</synopsis>
   以在<filename>pg_hba.conf</>中同样的方式处理注释和空白。<replaceable>map-name</>是一个任意名称，它将被用于在<filename>pg_hba.conf</filename>中引用该映射。其他两个域指定一个操作系统用户名和一个匹配的数据库用户名。相同的<replaceable>map-name</>可以被反复地用在同一个映射中指定多个用户映射。
  </para>
  <para>
   对于一个给定操作系统用户可以对应多少个数据库用户没有限制，反之亦然。因此，一个映射中的项应该被看成意味着<quote>这个操作系统用户被允许作为这个数据库用户连接</quote>，而不是按时它们等价。如果有任何映射项把从外部认证系统获得的用户名和用户要求的数据库用户名配对，该连接将被允许。
  </para>
  <para>
   如果<replaceable>system-username</>域以一个斜线（<literal>/</>）开始，域的剩余部分被当做一个正则表达式（<productname>PostgreSQL</>的正则表达式语法详见<xref linkend="posix-syntax-details">）。正则表达式可以包括一个单一的捕获，或圆括号子表达式，然后它可以在<replaceable>database-username</>域中以<literal>\1</>（反斜线一）被引用。这允许在单个行中多个用户名的映射，这特别有助于简单的语法替换。例如，这些项
<programlisting>
mymap   /^(.*)@mydomain\.com$      \1
mymap   /^(.*)@otherdomain\.com$   guest
</programlisting>
   将为用户移除以<literal>@mydomain.com</>结束的系统用户名的域部分，以及允许系统名以<literal>@otherdomain.com</>结束的任意用户作为<literal>guest</>登入。
  </para>

  <tip>
   <para>
    记住在默认情况下，一个正则表达式可以只匹配字符串的一部分。如上例所示，使用<literal>^</>和<literal>$</>来强制匹配整个系统用户名通常是明智的。
   </para>
  </tip>

  <para>
   在启动以及主服务器进程收到<systemitem>SIGHUP</systemitem><indexterm><primary>SIGHUP</primary></indexterm>信号时，<filename>pg_ident.conf</filename>文件会被读取。 如果你在活动的系统上编辑了该文件，你将需要通知 postmaster（使用<literal>pg_ctl reload</>或<literal>kill -HUP</>）重新读取该文件。
  </para>

  <para>
   <xref linkend="example-pg-ident.conf">中展示了一个可以联合<filename>pg_hba.conf</>文件（<xref linkend="example-pg-hba.conf">）使用的<filename>pg_ident.conf</filename>文件。在这个例子中，对于任何登入到 192.168 网络上的一台机器的用户， 如果该用户没有操作系统用户名<literal>bryanh</>、<literal>ann</>或<literal>robert</>，则他不会被授予访问权限。只有当 Unix 用户<literal>robert</>尝试作为<productname>PostgreSQL</>用户<literal>bob</>（而不是作为<literal>robert</>或其他人）连接时，他才被允许访问。<literal>ann</>只被允许作为<literal>ann</>连接。用户<literal>bryanh</>被允许以<literal>bryanh</>或者<literal>guest1</>连接。
  </para>

  <example id="example-pg-ident.conf">
   <title>一个示例 <filename>pg_ident.conf</> 文件</title>
<programlisting>
# MAPNAME       SYSTEM-USERNAME         PG-USERNAME

omicron         bryanh                  bryanh
omicron         ann                     ann
# bob 在这些机器上有用户名 robert
omicron         robert                  bob
# bryanh 也可以作为 guest1 连接
omicron         bryanh                  guest1
</programlisting>
  </example>
 </sect1>

 <sect1 id="auth-methods">
  <title>认证方法</title>
  <para>
   下列小节更详细地描述认证方法。
  </para>

  <sect2 id="auth-trust">
   <title>信任认证</title>

   <para>
    当<literal>trust</>认证被指定时，<productname>PostgreSQL</productname>假设任何可以连接到服务器的人都被授权使用他们指定的任何数据库用户名（即使是超级用户）访问数据库。当然，在<literal>database</>和 <literal>user</>列中设置的限制仍然适用。只有当在操作系统层对进入服务器的连接有足够保护时，才应该使用这种方法。
   </para>

   <para>
    <literal>trust</>认证对于单用户工作站的本地连接是非常合适和方便的。通常它本身<emphasis>不</>适用于一台多用户机器。不过，只要你利用文件系统权限限制了对服务器的 Unix 域套接字文件的访问，即使在多用户机器上，你也可以使用<literal>trust</>。 要做这些限制，你可以设置<xref linkend="runtime-config-connection">中描述的<varname>unix_socket_permissions</varname>配置参数（可能还有<varname>unix_socket_group</varname>）。 或者你可以设置<varname>unix_socket_directories</varname>配置参数来把 Unix 域套接字文件放在一个经过恰当限制的目录中。
   </para>

   <para>
    设置文件系统权限只能有助于 Unix 套接字连接。本地 TCP/IP 连接不会被文件系统权限限制。因此，如果你想利用文件系统权限来控制本地安全，那么从<filename>pg_hba.conf</>中移除<literal>host ... 127.0.0.1 ...</>行，或者把它改为一个非<literal>trust</>认证方法。
   </para>

   <para>
    如果通过指定<literal>trust</>的<filename>pg_hba.conf</>行让你信任每一个被允许连接到服务器的机器上的用户，<literal>trust</>认证只适合 TCP/IP 连接。为任何不是来自<systemitem>localhost</>（127.0.0.1）的 TCP/IP 连接使用<literal>trust</>很少是合理的。
   </para>

  </sect2>

  <sect2 id="auth-password">
   <title>口令认证</title>

   <indexterm>
    <primary>MD5</>
   </indexterm>
   <indexterm>
    <primary>口令</primary>
    <secondary>认证</secondary>
   </indexterm>

   <para>
    基于口令的认证方法是<literal>md5</>和<literal>password</>。这些方法操作上非常类似，只不过通过连接发送口令的方法不同：即分别是 MD5 哈希以及明文。
   </para>

   <para>
    如果你担心口令<quote>嗅探</>攻击，那么<literal>md5</>比较合适。应总是尽量避免使用简单的<literal>password</>。不过，<literal>md5</>不能和<xref linkend="guc-db-user-namespace">特性一起使用。如果连接受 SSL 加密保护，那么<literal>password</>可以被安全地使用（尽管如果在使用 SSL，SSL 证书认证可能是一种更好的选择）。
   </para>

   <para>
    <productname>PostgreSQL</productname>数据库口令独立于操作系统用户口令。每个数据库用户的口令被存储在<literal>pg_authid</>系统目录中。口令可以用 SQL 命令<xref linkend="sql-createuser">和<xref linkend="sql-alterrole">管理，例如<userinput>CREATE USER foo WITH PASSWORD 'secret'</userinput>。如果没有为一个用户设置口令，那么存储的口令为空并且对该用户的口令认证总会失败。
   </para>

  </sect2>

  <sect2 id="gssapi-auth">
   <title>GSSAPI 认证</title>

   <indexterm zone="gssapi-auth">
    <primary>GSSAPI</primary>
   </indexterm>

   <para>
    <productname>GSSAPI</productname>是用于 RFC 2743 中定义的安全认证的一个工业标准协议。<productname>PostgreSQL</productname>根据 RFC 1964 支持带<productname>Kerberos</productname>认证的<productname>GSSAPI</productname>。<productname>GSSAPI</productname>为支持它的系统提供自动认证（单点登录）。认证本身是安全的，但通过数据库连接发送的数据将不被加密，除非使用<acronym>SSL</acronym>。
   </para>

   <para>
    当编译<productname>PostgreSQL</>时，GSSAPI 支持必须被启用，详见<xref linkend="installation">。
   </para>

   <para>
    当<productname>GSSAPI</productname>使用<productname>Kerberos</productname>时，
    它会使用格式为
    <literal><replaceable>servicename</>/<replaceable>hostname</>@<replaceable>realm</></literal>的标准原则。
    PostgreSQL服务器将接受该服务器所使用的 keytab 中包括的任何原则，但是在从使用
    <literal>krbsrvname</>连接参数的客户端建立连接时要注意指定正确的原则细节（另见
    <xref linkend="libpq-paramkeywords">）。安装的默认值<literal>postgres</literal>
    可以在编译时使用
    <literal>./configure --with-krb-srvnam=</><replaceable>其他值</>修改。
    在大部分的环境中，这个参数从不需要被更改。某些 Kerberos 实现可能要求一个不同的服务名，
    例如 Microsoft Active Directory 要求服务名是大写形式（<literal>POSTGRES</literal>）。
   </para>
   <para>
    <replaceable>hostname</>是服务器机器的被完全限定的主机名。服务原则的领域是该服务器机器
    的首选领域。
   </para>

    <para>
    客户端的原则可以映射到使用<filename>pg_ident.conf</>的
    不同的<productname>PostgreSQL</>数据库用户名。
    例如<literal>pgusername@realm</>映射到<literal>pgusername</>。   
    或者，你可以使用完整的<literal>username@realm</>
    原则作为<productname>PostgreSQL</>中无任何映射的角色名。
   </para>

   <para>
     <productname>PostgreSQL</>也支持参数从原则中删除域。此方法支持向后兼容，
     但是强烈反对这么做，因为它不能区分具有相同用户名但来自不同域的不同用户。
     为了启用这个功能，设置<literal>include_realm</>为0。
     对于简单单一领域安装，<literal>include_realm</>结合
    <literal>krb_realm</>参数（检查提供的域准确匹配<literal>krb_realm</literal>参数值）是安全的，
    但相比较<filename>pg_ident.conf</>中声明显式映射是不可选的。
   </para>
   

   <para>
    确认你的服务器的 keytab 文件是可以被<productname>PostgreSQL</productname>服务器帐
    户读取的（最好是只读的） (又见<xref linkend="postgres-user">）。密钥文件的位置由配置
    参数<xref linkend="guc-krb-server-keyfile">指定。默认是<filename>/usr/local/pgsql/etc/krb5.keytab</>（或者任何在编译的时候作为<varname>sysconfdir</>的目录）。
    出于安全原因，推荐对<productname>PostgreSQL</productname>服务器使用一个独立
    的 keytab而不是开放系统 keytab 文件的权限。
   </para>
   <para>
    keytab 文件由 Kerberos 软件生成，详见 Kerberos 文档。下面是 MIT 兼容的 Kerberos 5 实现的例子：
<screen>
<prompt>kadmin% </><userinput>ank -randkey postgres/server.my.domain.org</>
<prompt>kadmin% </><userinput>ktadd -k krb5.keytab postgres/server.my.domain.org</>
</screen>
   </para>

   <para>
    当连接到数据库时，确保你有一个匹配被请求数据库用户名的 principal 的票据。例如，对于数据库用户名<literal>fred</>，principal  <literal>fred@EXAMPLE.COM</>将能够连接。要也允许 principal <literal>fred/users.example.com@EXAMPLE.COM</>，可使用一个用户名映射，如<xref linkend="auth-username-maps">中所述。
   </para>

   <para>
    下列被支持的配置选项用于<productname>GSSAPI</productname>：
    <variablelist>
     <varlistentry>
      <term><literal>include_realm</literal></term>
      <listitem>
       <para>
        如果被设置为0，来自于被认证用户原则的
        领域名在通过用户名映射(<xref linkend="auth-username-maps">)传递之前被剥离。    
        不鼓励这样做，它主要用于向后兼容，因为在多领域环境中是不安全的，
        除非也使用<literal>krb_realm</literal>。
        建议用户留下include_realm设置为缺省（1）并且在<filename>pg_ident.conf</>中提供显式映射。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        允许在系统和数据库用户名之间的映射。详见<xref linkend="auth-username-maps">。
        对于一个GSSAPI/Kerberos原则，例如<literal>username@EXAMPLE.COM</literal>
        （或者更不常见的<literal>username/hostbased@EXAMPLE.COM</literal>），
        用于映射的默认用户名会是<literal>username@EXAMPLE.COM</literal> (或者
        <literal>username/hostbased@EXAMPLE.COM</literal>，分别的)，
        除非<literal>include_realm</literal>被设置为0，
        在这种情况下 <literal>username</literal> 
        (或者<literal>username/hostbased</literal>)是映射时见到的系统用户名。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>krb_realm</literal></term>
      <listitem>
       <para>
        设置领域为对用户 principal 名进行匹配的范围。
        如果这个参数被设置，只有那个领域的用户将被接受。
        如果它没有被设置，任何领域的用户都能连接，服从任何已完成的用户名映射。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="sspi-auth">
   <title>SSPI 认证</title>

   <indexterm zone="sspi-auth">
    <primary>SSPI</primary>
   </indexterm>

   <para>
    <productname>SSPI</productname>是一种用于带单点登录的安全认证的<productname>Windows</productname>技术。 <productname>PostgreSQL</productname>在<literal>negotiate</literal>模式中将使用 SSPI，它在可能的情况下使用<productname>Kerberos</productname>并在其他情况下自动降回到<productname>NTLM</productname>。只有在服务器和客户端都运行着<productname>Windows</productname>时，<productname>SSPI</productname>才能工作。或者在非 Windows 平台上<productname>GSSAPI</productname>可用时，<productname>SSPI</productname>也能工作。
   </para>

   <para>
    当使用<productname>Kerberos</productname>认证时，<productname>SSPI</productname>和<productname>GSSAPI</productname>的工作方式相同，详见<xref linkend="gssapi-auth">。
   </para>

   <para>
    下列被支持的配置选项用于<productname>SSPI</productname>：
    <variablelist>

     <varlistentry>
      <term><literal>include_realm</literal></term>
      <listitem>
       <para>
        如果被设置为0，来自于被认证用户原则的
        领域名在通过用户名映射(<xref linkend="auth-username-maps">)传递之前被剥离。    
        不鼓励这样做，它主要用于向后兼容，因为在多领域环境中是不安全的，
        除非也使用<literal>krb_realm</literal>。
        建议用户留下include_realm设置为缺省（1）
        并且在<filename>pg_ident.conf</>中提供显式映射。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        允许在系统和数据库用户名之间的映射。详见<xref linkend="auth-username-maps">。
        对于一个GSSAPI/Kerberos原则，例如<literal>username@EXAMPLE.COM</literal>
        （或者更不常见的<literal>username/hostbased@EXAMPLE.COM</literal>），
        用于映射的默认用户名是<literal>username@EXAMPLE.COM</literal> (或者
        <literal>username/hostbased@EXAMPLE.COM</literal>，分别的)，除非
        <literal>include_realm</literal>被设置为0，在这种情况下
        <literal>username</literal>(或者<literal>username/hostbased</literal>)是映射时见到的系统用户名。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>krb_realm</literal></term>
      <listitem>
       <para>
        设置领域为对用户 principal 名进行匹配的范围。如果这个参数被设置，只有那个领域的用户将被接受。如果它没有被设置，任何领域的用户都能连接，服从任何已完成的用户名映射。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="auth-ident">
   <title>Ident 认证</title>

   <indexterm>
    <primary>ident</primary>
   </indexterm>

   <para>
    ident 认证方法通过从一个 ident 服务器获得客户端的操作系统用户名并且用它作为被允许的数据库用户名（和可选的用户名映射）来工作。它只在 TCP/IP 连接上支持。
   </para>

   <note>
    <para>
     当为一个本地（非 TCP/IP）连接指定 ident 时，将实际使用 peer 认证（见<xref linkend="auth-peer">）。
    </para>
   </note>

   <para>
    下列被支持的配置选项用于<productname>ident</productname>：
    <variablelist>
     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        允许系统和数据库用户名之间的映射。详见<xref linkend="auth-username-maps">。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    <quote>Identification Protocol（标识协议）</quote>在 RFC 1413 中描述。实际上每个类 Unix 操作系统都带着一个默认监听 TCP 113 端口的 ident 服务器。ident 服务器的基本功能是回答类似这样的问题：<quote>哪个用户从你的端口<replaceable>X</replaceable>发起了连接并且连到了我的端口<replaceable>Y</replaceable>？</quote> 。因为当一个物理连接被建立后，<productname>PostgreSQL</>既知道<replaceable>X</replaceable>也知道<replaceable>Y</replaceable>， 所以它可以询问尝试连接的客户端主机上的 ident 服务器并且在理论上可以判断任意给定连接的操作系统用户。
   </para>

   <para>
    这个过程的缺点是它依赖于客户端的完整性：如果客户端机器不可信或者被攻破，攻击者可能在 113 端口上运行任何程序并且返回他选择的任何用户。因此这种认证方法只适用于封闭的网络， 这样的网络中的每台客户端机器都处于严密的控制下并且数据库和操作系统管理员操作时可以方便地联系。换句话说，你必须信任运行 ident 服务器的机器。注意这样的警告：
    <blockquote>
     <attribution>RFC 1413</attribution>
     <para>
      标识协议的本意不是作为一种认证或访问控制协议。
     </para>
    </blockquote>
   </para>

   <para>
    有些 ident 服务器有一个非标准的选项，它导致返回的用户名是被加密的，使用的是只有原机器管理员知道的一个密钥。当与<productname>PostgreSQL</>配合使用 ident 服务器时，<emphasis>一定不要</>使用这个选项，因为<productname>PostgreSQL</>没有任何方法对返回的字符串进行解密以获取实际的用户名。
   </para>
  </sect2>

  <sect2 id="auth-peer">
   <title>Peer 认证</title>

   <indexterm>
    <primary>peer</primary>
   </indexterm>

   <para>
    Peer 认证方法通过从内核获得客户端的操作系统用户名并把它用作被允许的数据库用户名（和可选的用户名映射）来工作。这种方法只在本地连接上支持。
   </para>

   <para>
    下列被支持的配置选项用于<productname>peer</productname>：
    <variablelist>
     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        允许在系统和数据库用户名之间的映射。详见<xref linkend="auth-username-maps">。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    Peer 认证只在提供<function>getpeereid()</>函数、<symbol>SO_PEERCRED</symbol>套接字参数或相似机制的操作系统上可用。这些 OS 当前包括<systemitem class="osname">Linux</>、大部分的<systemitem class="osname">BSD</>包括<systemitem class="osname">OS X</>以及<systemitem class="osname">Solaris</systemitem>。
   </para>

  </sect2>

  <sect2 id="auth-ldap">
   <title>LDAP 认证</title>

   <indexterm zone="auth-ldap">
    <primary>LDAP</primary>
   </indexterm>

   <para>
    这种认证方法操作起来类似于<literal>password</literal>， 只不过它使用 LDAP 作为密码验证方法。LDAP 只被用于验证用户名/口令对。因此，在使用 LDAP 进行认证之前，用户必须已经存在于数据库中。
   </para>

   <para>
    LDAP 认证可以在两种模式下操作。在第一种模式中（我们将称之为简单绑定模式），服务器将绑定到构造成<replaceable>prefix</> <replaceable>username</> <replaceable>suffix</>的可区分名称。通常，<replaceable>prefix</>参数被用于指定 <literal>cn=</>或者一个活动录环境中的<replaceable>DOMAIN</><literal>\</>。<replaceable>suffix</>被用来指定非活动目录环境中的DN的剩余部分。
   </para>

   <para>
    在第二种模式中（我们将称之为搜索与绑定模式），服务器首先用一个固定的用户名和密码（用<replaceable>ldapbinddn</>和<replaceable>ldapbindpasswd</>指定）绑定到 LDAP 目录 ，并为试图登入该数据库的用户执行一次搜索。如果没有配置用户名和密码， 将尝试一次匿名绑定到目录。搜索将在位于<replaceable>ldapbasedn</>的子树上被执行，并将尝试做一次<replaceable>ldapsearchattribute</>中指定属性的精确匹配。一旦在这次搜索中找到用户，服务器断开并且作为这个用户重新绑定到目录，使用由客户端指定的口令来验证登录是正确的。
    这种模式与在其他软件中的 LDAP 认证所使用的相同，
    例如 Apache <literal>mod_authnz_ldap</literal>和<literal>pam_ldap</literal>。
    这种方法允许位于目录中用户对象的更大灵活性，但是会导致建立两个到 LDAP 服务器的独立连接。
   </para>

   <para>
    下列配置选项被用于两种模式：
    <variablelist>
     <varlistentry>
      <term><literal>ldapserver</literal></term>
      <listitem>
       <para>
        要连接的 LDAP 服务器的名称或 IP 地址。可以指定多个服务器，用空格分隔。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapport</literal></term>
      <listitem>
       <para>
        要连接的 LDAP 服务器的端口号。如果没有指定端口，LDAP 库的默认端口设置将被使用。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldaptls</literal></term>
      <listitem>
       <para>
        设置为 1 以使 PostgreSQL 和 LDAP 服务器之间的连接使用 TLS 加密。请注意，这里仅加密到 LDAP 服务器的流量 &mdash; 到客户端的连接将不被加密，除非使用 SSL。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    下列选项只被用于简单绑定模式：
    <variablelist>
     <varlistentry>
      <term><literal>ldapprefix</literal></term>
      <listitem>
       <para>
        当做简单绑定认证时，前置到用户名形成要用于绑定的 DN 的字符串。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapsuffix</literal></term>
      <listitem>
       <para>
        当做简单绑定认证时，前置到用户名形成要用于绑定的 DN 的字符串。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    下列选项只被用于搜索与绑定模式：
    <variablelist>
     <varlistentry>
      <term><literal>ldapbasedn</literal></term>
      <listitem>
       <para>
        当做搜索与绑定认证时，开始搜索用户的根 DN。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapbinddn</literal></term>
      <listitem>
       <para>
        当做搜索与绑定认证时，用户要绑定到目录开始执行搜索的 DN。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapbindpasswd</literal></term>
      <listitem>
       <para>
        当做搜索与绑定认证时，用户用于绑定到目录开始执行搜索的口令。
       </para>
      </listitem>
      </varlistentry>
      <varlistentry>
       <term><literal>ldapsearchattribute</literal></term>
       <listitem>
        <para>
         当做搜索与绑定认证时，在搜索中用来与用户名匹配的属性。如果没有指定属性，将会使用<literal>uid</>属性。
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><literal>ldapurl</literal></term>
       <listitem>
        <para>
         一个 RFC 4516 LDAP URL。这是一种用更紧凑和标准的形式书写某些其他 LDAP 选项的可选方法。格式是
<synopsis>
ldap://<replaceable>host</replaceable>[:<replaceable>port</replaceable>]/<replaceable>basedn</replaceable>[?[<replaceable>attribute</replaceable>][?[<replaceable>scope</replaceable>]]]
</synopsis>
         <replaceable>scope</replaceable>必须是<literal>base</literal>、<literal>one</literal>、<literal>sub</literal>之一，通常是后者。只有一个属性会被使用，并且某些标准 LDAP URL 的其他部件（如过滤器和扩展）不被支持。
        </para>

        <para>
         对于非匿名绑定，<literal>ldapbinddn</literal>和<literal>ldapbindpasswd</literal>必须被指定为独立选项。
        </para>

        <para>
         要使用加密的 LDAP 连接，在<literal>ldapurl</literal>之外还必须使用<literal>ldaptls</literal>选项。<literal>ldaps</literal> URL 模式（直接 SSL 连接）不被支持。
        </para>

        <para>
         LDAP URL 当前只支持 OpenLDAP，而不支持 Windows。
        </para>
       </listitem>
      </varlistentry>
    </variablelist>
   </para>

   <para>
    将简单绑定的选项中混合用于搜索与绑定的选项是一种错误。
   </para>

   <para>
    这里是一个简单绑定 LDAP 配置的例子：
<programlisting>
host ... ldap ldapserver=ldap.example.net ldapprefix="cn=" ldapsuffix=", dc=example, dc=net"
</programlisting>
    当请求一个作为数据库用户<literal>someuser</literal>到数据库服务器的连接时，PostgreSQL 将尝试使用<literal>cn=someuser, dc=example, dc=net</literal>和客户端提供的口令来绑定到 LDAP 服务器。如果那个连接成功，将被授予数据库访问。
   </para>

   <para>
    这里是一个搜索与绑定配置的例子：
<programlisting>
host ... ldap ldapserver=ldap.example.net ldapbasedn="dc=example, dc=net" ldapsearchattribute=uid
</programlisting>
    当请求一个作为数据库用户<literal>someuser</literal>到数据库服务器的连接时，PostgreSQL 将尝试匿名绑定（因为没有指定<literal>ldapbinddn</literal>）到 LDAP 服务器，在指定的基础 DN 下执行一次对于<literal>(uid=someuser)</literal>的搜索。如果找到一个项，则它将尝试使用找到的信息和客户端提供的口令进行绑定。如果第二个连接成功，将被授予数据库访问。
   </para>

   <para>
    这里是被写成一个 URL 的相同搜索与绑定配置：
<programlisting>
host ... ldap ldapurl="ldap://ldap.example.net/dc=example,dc=net?uid?sub"
</programlisting>
    一些支持根据 LDAP 认证的其他软件使用相同的 URL 格式，因此很容易共享该配置。
   </para>

   <tip>
    <para>
     如例子中所示，由于 LDAP 通常使用逗号和空格来分割一个 DN 的不同部分，在配置 LDAP 选项时通常有必要使用双引号包围的参数值。
    </para>
   </tip>

  </sect2>

  <sect2 id="auth-radius">
   <title>RADIUS 认证</title>

   <indexterm zone="auth-radius">
    <primary>RADIUS</primary>
   </indexterm>

   <para>
    这种认证方法的操作类似于<literal>password</literal>，不过它使用 RADIUS 作为密码验证方式。RADIUS 只被用于验证 用户名/密码对。因此，在 RADIUS 能被用于认证之前，用户必须已经存在于数据库中。
   </para>

   <para>
    当使用 RADIUS 认证时，一个访问请求消息将被发送到配置好的 RADIUS 服务器。这一请求将是<literal>Authenticate Only</literal>类型，并且包含参数<literal>user name</>、<literal>password</>（加密的）和<literal>NAS Identifier</>。该请求将使用一个与服务器共享的密钥加密。RADIUS 服务器将对这个服务器响应<literal>Access Accept</>或者<literal>Access Reject</>。不支持RADIUS accounting。
   </para>

   <para>
    下列被支持的配置选项用于 RADIUS：
     <variablelist>
      <varlistentry>
       <term><literal>radiusserver</literal></term>
       <listitem>
        <para>
         连接到 RADIUS 服务器的名称或IP地址。此参数是必需的。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>radiussecret</literal></term>
       <listitem>
        <para>
         和 RADIUS 服务器秘密交谈时会用到共享密钥。这在 PostgreSQL 和 RADIUS 服务器之间必须有完全相同的值。我们推荐用一个至少 16 个字符的字符串。这个参数是必需的。
         <note>
         <para>
          如果<productname>PostgreSQL</>编译为支持<productname>OpenSSL</>，所用的加密向量将只是强密码。在其他情况下，到 RADIUS 服务器的传输应该被视为应该被视为被混淆的、不安全的。如有必要，应采用外部安全措施。
         </para>
         </note>
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>radiusport</literal></term>
       <listitem>
        <para>
         用于连接到 RADIUS 服务器的端口号。如果没有指定端口，则使用默认端口<literal>1812</>。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>radiusidentifier</literal></term>
       <listitem>
        <para>
         在 RADIUS 请求中字符串被用作<literal>NAS Identifier</>。 这个参数可以被用作第二个参数标识例如该用户试图以哪个数据库用户进行认证，它可以被用于 RADIUS 服务器上的策略匹配。如果没有指定标识符，默认使用<literal>postgresql</>。
        </para>
       </listitem>
      </varlistentry>

     </variablelist>
   </para>
  </sect2>

  <sect2 id="auth-cert">
   <title>证书认证</title>

   <indexterm zone="auth-cert">
    <primary>证书</primary>
   </indexterm>

   <para>
    这种认证方法使用 SSL 客户端证书执行认证。因此，它只适用于 SSL 连接。当使用这种认证方法时，服务器将要求客户端提供一个有效的证书。不会有密码提示将被发送到客户端。证书的<literal>cn</literal>（通用名）属性将与被请求的数据库用户名进行比较，并且如果匹配将允许登录。用户名映射可以被用来允许<literal>cn</literal>与数据库用户名不同。
   </para>

   <para>
    下列被支持的配置选项用于 SSL 证书认证：
    <variablelist>
     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        允许在系统和数据库用户名之间的映射。详见<xref linkend="auth-username-maps">。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="auth-pam">
   <title>PAM 认证</title>

   <indexterm zone="auth-pam">
    <primary>PAM</primary>
   </indexterm>

   <para>
    这种认证方法操作起来类似<literal>password</literal>， 只不过它使用 PAM （插入式验证模块）作为认证机制。默认的 PAM 服务名是<literal>postgresql</literal>。PAM 只被用于验证用户名/口令对。因此，在使用 PAM 进行认证之前，用户必须已经存在于数据库中。有关 PAM 的更多信息，请阅读<ulink url="http://www.kernel.org/pub/linux/libs/pam/">
    <productname>Linux-PAM</> 页面</ulink>.
   </para>

   <para>
    下列被支持的配置选项用于 PAM：
    <variablelist>
     <varlistentry>
      <term><literal>pamservice</literal></term>
      <listitem>
       <para>
        PAM服务名称。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <note>
    <para>
     如果 PAM 被设置为读取<filename>/etc/shadow</>，认证将会失败，因为 PostgreSQL 服务器是由一个非 root 用户启动 。然而，当 PAM 被配置为使用 LDAP 或其他认证验证方法时这就不是一个问题。
    </para>
   </note>
  </sect2>
 </sect1>

  <sect1 id="client-authentication-problems">
   <title>认证问题</title>

   <para>
    认证失败以及相关的问题通常由类似下面的错误消息显示：
   </para>

   <para>
<programlisting>
FATAL:  no pg_hba.conf entry for host "123.123.123.123", user "andym", database "testdb"
</programlisting>
    这条消息最可能出现的情况是你成功地联系了服务器，但它不愿意和你说话。就像消息本身所建议的，服务器拒绝了连接请求，因为它没有在其<filename>pg_hba.conf</filename>配置文件里找到匹配项。
   </para>

   <para>
<programlisting>
FATAL:  password authentication failed for user "andym"
</programlisting>
    这样的消息表示你联系了服务器，并且它也愿意和你交谈，但是你必须通过<filename>pg_hba.conf</filename>文件中指定的认证方法。检查你提供的口令，或者如果错误消息提到了 Kerberos 或 ident 认证类型，检查那些软件。
   </para>

   <para>
<programlisting>
FATAL:  user "andym" does not exist
</programlisting>
    指示的数据库用户没有被找到。
   </para>

   <para>
<programlisting>
FATAL:  database "testdb" does not exist
</programlisting>
    你试图连接的数据库不存在。请注意如果你没有声明数据库名，默认会用数据库用户名作为数据库名，这可能正确也可能不正确。
   </para>

   <tip>
   <para>
    服务器日志可能包含比报告给客户端的更多的有关认证失败的信息。如果你为失败的原因而困惑，那么请检查服务器日志。
   </para>
   </tip>
  </sect1>

 </chapter>
