<!-- doc/src/sgml/catalogs.sgml -->
<!--
 Documentation of the system catalogs, directed toward PostgreSQL developers
 -->

<chapter id="catalogs">
 <title>系统目录</title>

  <para>
   系统目录是关系型数据库存放模式元数据的地方，比如表和列的信息，以及内部统计信息等。<productname>PostgreSQL</productname>的系统目录就是普通表。你可以删除并重建这些表、增加列、插入和更新数值， 然后彻底把你的系统搞垮。 通常情况下，我们不应该手工修改系统目录，总有SQL命令可以做这些事情。（例如，<command>CREATE DATABASE</command>向 <structname>pg_database</structname>表插入一行 &mdash; 并且实际上在磁盘上创建该数据库。） 有几种特别深奥的操作例外，比如增加索引访问方法。
  </para>

 <sect1 id="catalogs-overview">
  <title>概述</title>

  <para>
   <xref linkend="catalog-table">列出了系统目录。 每个目录更详细的文档见后文。
  </para>

  <para>
   大多数系统目录都是在数据库创建的过程中从模版数据库中拷贝过来的， 因此都是数据库相关的。少数目录在物理上是在一个集簇的所有数据库间中共享的，这些将在每一个目录单独的描述中介绍。
  </para>

  <table id="catalog-table">
   <title>系统目录</title>

   <tgroup cols="2">
    <thead>
     <row>
      <entry>目录名</entry>
      <entry>用途</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><link linkend="catalog-pg-aggregate"><structname>pg_aggregate</structname></link></entry>
      <entry>聚集函数</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-am"><structname>pg_am</structname></link></entry>
      <entry>索引访问方法</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-amop"><structname>pg_amop</structname></link></entry>
      <entry>访问方法操作符</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-amproc"><structname>pg_amproc</structname></link></entry>
      <entry>访问方法支持过程</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-attrdef"><structname>pg_attrdef</structname></link></entry>
      <entry>列默认值</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link></entry>
      <entry>表列(<quote>属性</quote>)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link></entry>
      <entry>认证标识符（角色）</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-auth-members"><structname>pg_auth_members</structname></link></entry>
      <entry>认证标识符成员关系</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-cast"><structname>pg_cast</structname></link></entry>
      <entry>转换（数据类型转换）</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-class"><structname>pg_class</structname></link></entry>
      <entry>表、索引、序列、视图 （<quote>关系</quote>）</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-collation"><structname>pg_collation</structname></link></entry>
      <entry>排序规则（locale信息）</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-constraint"><structname>pg_constraint</structname></link></entry>
      <entry>检查约束、唯一约束、主键约束、外键约束</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-conversion"><structname>pg_conversion</structname></link></entry>
      <entry>编码转换信息</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-database"><structname>pg_database</structname></link></entry>
      <entry>本数据库集簇中的数据库</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-db-role-setting"><structname>pg_db_role_setting</structname></link></entry>
      <entry>每角色和每数据库的设置</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-default-acl"><structname>pg_default_acl</structname></link></entry>
      <entry>对象类型的默认权限</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-depend"><structname>pg_depend</structname></link></entry>
      <entry>数据库对象间的依赖</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-description"><structname>pg_description</structname></link></entry>
      <entry>数据库对象上的描述或注释</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-enum"><structname>pg_enum</structname></link></entry>
      <entry>枚举标签和值定义</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-event-trigger"><structname>pg_event_trigger</structname></link></entry>
      <entry>事件触发器</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-extension"><structname>pg_extension</structname></link></entry>
      <entry>已安装扩展</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-foreign-data-wrapper"><structname>pg_foreign_data_wrapper</structname></link></entry>
      <entry>外部数据包装器定义</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-foreign-server"><structname>pg_foreign_server</structname></link></entry>
      <entry>外部服务器定义</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-foreign-table"><structname>pg_foreign_table</structname></link></entry>
      <entry>外部表信息</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-index"><structname>pg_index</structname></link></entry>
      <entry>索引信息</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-inherits"><structname>pg_inherits</structname></link></entry>
      <entry>表继承层次</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-language"><structname>pg_language</structname></link></entry>
      <entry>编写函数的语言</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-largeobject"><structname>pg_largeobject</structname></link></entry>
      <entry>大对象的数据页</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-largeobject-metadata"><structname>pg_largeobject_metadata</structname></link></entry>
      <entry>大对象的元数据</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link></entry>
      <entry>模式</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link></entry>
      <entry>访问方法操作符类</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link></entry>
      <entry>操作符</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link></entry>
      <entry>访问方法操作符族</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-pltemplate"><structname>pg_pltemplate</structname></link></entry>
      <entry>过程语言的模板数据</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link></entry>
      <entry>函数和过程</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-range"><structname>pg_range</structname></link></entry>
      <entry>范围类型的信息</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-rewrite"><structname>pg_rewrite</structname></link></entry>
      <entry>查询重写规则</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-replication-slots"><structname>pg_replication_slots</structname></link></entry>
      <entry>复制槽信息</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-seclabel"><structname>pg_seclabel</structname></link></entry>
      <entry>数据库对象上的安全标签</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-shdepend"><structname>pg_shdepend</structname></link></entry>
      <entry>共享对象上的依赖</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-shdescription"><structname>pg_shdescription</structname></link></entry>
      <entry>共享对象上的注释</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-shseclabel"><structname>pg_shseclabel</structname></link></entry>
      <entry>共享数据库对象上的安全标签</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-statistic"><structname>pg_statistic</structname></link></entry>
      <entry>规划器统计</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link></entry>
      <entry>本数据库集簇内的表空间</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-trigger"><structname>pg_trigger</structname></link></entry>
      <entry>触发器</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-ts-config"><structname>pg_ts_config</structname></link></entry>
      <entry>文本搜索配置</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-ts-config-map"><structname>pg_ts_config_map</structname></link></entry>
      <entry>文本搜索配置的记号映射</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-ts-dict"><structname>pg_ts_dict</structname></link></entry>
      <entry>文本搜索字典</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-ts-parser"><structname>pg_ts_parser</structname></link></entry>
      <entry>文本搜索分析器</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-ts-template"><structname>pg_ts_template</structname></link></entry>
      <entry>文本搜索模板</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-type"><structname>pg_type</structname></link></entry>
      <entry>数据类型</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-user-mapping"><structname>pg_user_mapping</structname></link></entry>
      <entry>将用户映射到外部服务器</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-aggregate">
  <title><structname>pg_aggregate</structname></title>

  <indexterm zone="catalog-pg-aggregate">
   <primary>pg_aggregate</primary>
  </indexterm>

  <para>
   目录<structname>pg_aggregate</structname>存储关于聚集函数的信息。聚集函数是对一个数值集合（典型的是每个匹配查询条件的行中的同一个列的值） 进行操作的函数，它返回从这些值中计算出的一个数值。 典型的聚集函数是 <function>sum</function>、<function>count</function>和<function>max</function>。<structname>pg_aggregate</structname>里的每个项都是一个<structname>pg_proc</structname>项的扩展。<structname>pg_proc</structname>项记载该聚集的名字、输入和输出数据类型，以及其他一些和普通函数类似的信息。
  </para>

  <table>
   <title><structname>pg_aggregate</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>aggfnoid</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>聚集函数在<structname>pg_proc</structname>中的OID</entry>
     </row>
     <row>
      <entry><structfield>aggkind</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>聚集类型：
       <literal>n</literal>表示<quote>普通</>聚集，
       <literal>o</literal>表示<quote>有序集</>聚集，或者
       <literal>h</literal>表示<quote>假想集</>聚集
      </entry>
     </row>
     <row>
      <entry><structfield>aggnumdirectargs</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>一个有序集或者假想集聚集的直接（非聚集）参数的数量，一个可变数组算作一个参数。
       如果等于<structfield>pronargs</>，该聚集必定是可变的并且该可变数组描述聚集参数以
       及最终直接参数。对于普通聚集总是为零。</entry>
     </row>
     <row>
      <entry><structfield>aggtransfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>转移函数</entry>
     </row>
     <row>
      <entry><structfield>aggfinalfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>最终函数（如果没有则为0）</entry>
     </row>
     <row>
      <entry><structfield>aggmtransfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>用于移动聚集模式的向前转移函数（如果没有就为零）</entry>
     </row>
     <row>
      <entry><structfield>aggminvtransfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>用于移动聚集模式的反向转移函数（如果没有就为零）</entry>
     </row>
     <row>
      <entry><structfield>aggmfinalfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>用于移动聚集模式的最终函数（如果没有就为零）</entry>
     </row>
     <row>
      <entry><structfield>aggfinalextra</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>为真则向
      <structfield>aggfinalfn</structfield>传递额外的哑参数</entry>
     </row>
     <row>
      <entry><structfield>aggmfinalextra</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>为真则向
      <structfield>aggmfinalfn</structfield>传递额外的哑参数</entry>
     </row>
     <row>
      <entry><structfield>aggsortop</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>相关联的排序操作符（如果没有则为0）</entry>
     </row>
     <row>
      <entry><structfield>aggtranstype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>聚集函数的内部转移（状态）数据的数据类型</entry>
     </row>
     <row>
      <entry><structfield>aggtransspace</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>转移状态数据的近似平均尺寸（字节），或者为零表示使用一个默认估算值</entry>
     </row>
     <row>
      <entry><structfield>aggmtranstype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>聚集函数用于移动聚集欧氏的内部转移（状态）数据的数据类型（如果没有则为零）</entry>
     </row>
     <row>
      <entry><structfield>aggmtransspace</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>转移状态数据的近似平均尺寸（字节），或者为零表示使用一个默认估算值</entry>
     </row>
     <row>
      <entry><structfield>agginitval</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       转移状态的初始值。这是一个文本域，它包含初始值的外部字符串表现形式。如果这个域为空，则转移状态值从空值开始。
      </entry>
     </row>
     <row>
      <entry><structfield>aggminitval</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       用于移动聚集模式的转移状态初值。这是一个文本域，它包含了以其文本字符串形式表达的初值。
       如果这个域为空，则转移状态值从空值开始。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   新的聚集函数可通过<xref linkend="sql-createaggregate">命令注册。更多关于编写聚集函数以及转移函数的含义等信息请参见<xref linkend="xaggr">。
  </para>

 </sect1>


 <sect1 id="catalog-pg-am">
  <title><structname>pg_am</structname></title>

  <indexterm zone="catalog-pg-am">
   <primary>pg_am</primary>
  </indexterm>

  <para>
   目录<structname>pg_am</structname>存储有关索引访问方法的信息。系统支持的每种索引访问方法在这个目录中都有一行。这个目录的内容在<xref linkend="indexam">中详细讨论。
  </para>

  <table>
   <title><structname>pg_am</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符（隐藏属性，必须被显式选择才会显示）</entry>
     </row>

     <row>
      <entry><structfield>amname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>访问方法的名字</entry>
     </row>

     <row>
      <entry><structfield>amstrategies</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>这个访问方法的操作符策略个数，如果访问方法不具有一个固定的操作符策略集合则为0</entry>
     </row>

     <row>
      <entry><structfield>amsupport</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>这个访问方法的支持例程个数</entry>
     </row>

     <row>
      <entry><structfield>amcanorder</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>这个访问方法是否支持按照被索引列值排序的排序扫描？</entry>
     </row>

     <row>
      <entry><structfield>amcanorderbyop</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>这个访问方法是否支持按照被索引列上一个操作符结果排序的排序扫描？</entry>
     </row>

     <row>
      <entry><structfield>amcanbackward</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>这个访问方法是否支持反向扫描？</entry>
     </row>

     <row>
      <entry><structfield>amcanunique</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>这个访问方法是否支持唯一索引？</entry>
     </row>

     <row>
      <entry><structfield>amcanmulticol</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>这个访问方法是否支持多列索引？</entry>
     </row>

     <row>
      <entry><structfield>amoptionalkey</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>这个访问方法是否支持在第一个索引列上没有任何约束的扫描？</entry>
     </row>

     <row>
      <entry><structfield>amsearcharray</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>这个访问方法是否支持<literal>ScalarArrayOpExpr</>搜索？</entry>
     </row>

     <row>
      <entry><structfield>amsearchnulls</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>这个访问方法是否支持<literal>IS NULL</>/<literal>NOT NULL</>搜索？</entry>
     </row>

     <row>
      <entry><structfield>amstorage</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>索引存储数据类型能否和列数据类型不同？</entry>
     </row>

     <row>
      <entry><structfield>amclusterable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>这种类型的索引能否被聚簇？</entry>
     </row>

     <row>
      <entry><structfield>ampredlocks</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>这种类型的索引能否管理细粒度谓词锁？</entry>
     </row>

     <row>
      <entry><structfield>amkeytype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>在索引中排序的数据的类型，如果不是一种固定类型则为0</entry>
     </row>

     <row>
      <entry><structfield>aminsert</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry><quote>插入元组</quote>函数</entry>
     </row>

     <row>
      <entry><structfield>ambeginscan</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry><quote>准备索引扫描</quote>函数</entry>
     </row>

     <row>
      <entry><structfield>amgettuple</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry><quote>下一个可用元组</quote>函数，如果没有则为0</entry>
     </row>

     <row>
      <entry><structfield>amgetbitmap</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry><quote>获取所有可用元组</quote>函数，如果没有则为0</entry>
     </row>

     <row>
      <entry><structfield>amrescan</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry><quote>（重新）开始索引扫描</quote>函数</entry>
     </row>

     <row>
      <entry><structfield>amendscan</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry><quote>索引扫描后清理</quote>函数</entry>
     </row>

     <row>
      <entry><structfield>ammarkpos</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry><quote>标记当前扫描位置</quote>函数</entry>
     </row>

     <row>
      <entry><structfield>amrestrpos</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry><quote>恢复被标记的扫描位置</quote>函数</entry>
     </row>

     <row>
      <entry><structfield>ambuild</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry><quote>构建新索引</quote>函数</entry>
     </row>

     <row>
      <entry><structfield>ambuildempty</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry><quote>构建空索引</quote>函数</entry>
     </row>

     <row>
      <entry><structfield>ambulkdelete</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>批量删除函数</entry>
     </row>

     <row>
      <entry><structfield>amvacuumcleanup</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>后-<command>VACUUM</command>清理函数</entry>
     </row>

     <row>
      <entry><structfield>amcanreturn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>用于检测索引是否支持“只用索引”扫描的函数，如果没有则为0</entry>
     </row>

     <row>
      <entry><structfield>amcostestimate</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>用于估计一个索引扫描开销的函数</entry>
     </row>

     <row>
      <entry><structfield>amoptions</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>用于分析和验证索引的<structfield>reloptions</>的函数</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-amop">
  <title><structname>pg_amop</structname></title>

  <indexterm zone="catalog-pg-amop">
   <primary>pg_amop</primary>
  </indexterm>

  <para>
   目录<structname>pg_amop</structname>存储关于与访问方法操作符族相关的操作符信息。对于一个操作符族中的每一个成员即操作符都在这个目录中有一行。一个成员可以是一个<firstterm>搜索</>操作符或者一个<firstterm>ordering</>操作符。一个操作符可以出现在多个族中，但在同一个组中既不能出现在多个搜索位置也不能出现在多个排序位置（虽然不太可能出现，但是允许一个操作符同时用于搜索和排序目的）。
  </para>

  <table>
   <title><structname>pg_amop</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符（隐藏属性，必须被显式选择才会显示）</entry>
     </row>

     <row>
      <entry><structfield>amopfamily</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>.oid</literal></entry>
      <entry>这个项所在的操作符族</entry>
     </row>

     <row>
      <entry><structfield>amoplefttype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>操作符的左手输入数据类型</entry>
     </row>

     <row>
      <entry><structfield>amoprighttype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>操作符的右手输入数据类型</entry>
     </row>

     <row>
      <entry><structfield>amopstrategy</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>操作符策略号</entry>
     </row>

     <row>
      <entry><structfield>amoppurpose</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>操作符目的，<literal>s</>表示搜索，<literal>o</>表示排序</entry>
     </row>

     <row>
      <entry><structfield>amopopr</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>操作符的OID</entry>
     </row>

     <row>
      <entry><structfield>amopmethod</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-am"><structname>pg_am</structname></link>.oid</literal></entry>
      <entry>使用此操作符族的索引访问方法</entry>
     </row>

     <row>
      <entry><structfield>amopsortfamily</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>.oid</literal></entry>
      <entry>如果是一个排序操作符，该项会根据这个 B树操作符族排序，如果是一个搜索操作符则为0</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   一个<quote>搜索</>操作符项意味着该操作符族的一个索引可以被搜索来查找所有满足如下条件的行：
   <literal>WHERE</>
   <replaceable>indexed_column</>
   <replaceable>operator</>
   <replaceable>constant</>。
   显然，这样的一个操作符必须返回<type>boolean</type>，且它的左手输入类型必须匹配索引列的数据类型。
  </para>

  <para>
   一个<quote>排序</>操作符项意味着该操作符族的一个索引可以被扫描来返回以如下顺序排列的行：
   <literal>ORDER BY</>
   <replaceable>indexed_column</>
   <replaceable>operator</>
   <replaceable>constant</>。
   这样一个操作符能够返回任何可排序数据类型，尽管它的左手输入类型必须匹配索引列的数据类型。
   <literal>ORDER BY</>的准确语义由<structfield>amopsortfamily</structfield>列指定，它必须引用一个适合于操作符结果类型的B树操作符族。
  </para>

  <note>
   <para>
    目前，一个排序操作符的排序顺序被假设为其引用的操作符族的默认值，即<literal>ASC NULLS LAST</>。未来可能会通过增加额外的列来显式地指定排序选项。
   </para>
  </note>

  <para>
   一个项的<structfield>amopmethod</>必须和它所包含的操作符族的<structname>opfmethod</>相匹配（这里包括<structfield>amopmethod</>是一个为了性能原因而故意对目录结构做的反规范化）。此外，<structfield>amoplefttype</>和<structfield>amoprighttype</>也必须匹配被引用的<structname>pg_operator</>项的<structfield>oprleft</>和<structfield>oprright</>域。
  </para>

 </sect1>


 <sect1 id="catalog-pg-amproc">
  <title><structname>pg_amproc</structname></title>

  <indexterm zone="catalog-pg-amproc">
   <primary>pg_amproc</primary>
  </indexterm>

  <para>
   目录<structname>pg_amproc</structname>存储关于访问方法操作符族相关的支持过程。属于一个操作符族的每一个支持过程在这个目录中都有一行。
  </para>

  <table>
   <title><structname>pg_amproc</structname>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符（隐藏属性，必须被显式选择才会显示）</entry>
     </row>

     <row>
      <entry><structfield>amprocfamily</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>.oid</literal></entry>
      <entry>使用这个项的操作符族</entry>
     </row>

     <row>
      <entry><structfield>amproclefttype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>相关操作符的左手输入数据类型</entry>
     </row>

     <row>
      <entry><structfield>amprocrighttype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>相关操作符的右手输入数据类型</entry>
     </row>

     <row>
      <entry><structfield>amprocnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>支持过程编号</entry>
     </row>

     <row>
      <entry><structfield>amproc</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>过程的OID</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   <structfield>amproclefttype</>和<structfield>amprocrighttype</>列的通常解释是它们标识了一个特定支持过程所支持的操作符的左右输入类型。对于某些访问方法它们和支持过程本身的输入数据类型相匹配，而对其他的则不会匹配。对于一个索引有一个<quote>默认</>支持过程的概念，这些支持过程的<structfield>amproclefttype</>和<structfield>amprocrighttype</>都等于索引操作符类的<structfield>opcintype</>。
  </para>

 </sect1>


 <sect1 id="catalog-pg-attrdef">
  <title><structname>pg_attrdef</structname></title>

  <indexterm zone="catalog-pg-attrdef">
   <primary>pg_attrdef</primary>
  </indexterm>

  <para>
   <structname>pg_attrdef</structname>存储列的默认值。列的主要信息存储在<structname>pg_attribute</structname>（见下文）。只有那些显式指定了一个默认值的列（在表创建时或列增加时）才会在这个目录中有一个项。
  </para>

  <table>
   <title><structname>pg_attrdef</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符（隐藏属性，必须被显式选择才会显示）</entry>
     </row>

     <row>
      <entry><structfield>adrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>该列所属的表</entry>
     </row>

     <row>
      <entry><structfield>adnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>列号</entry>
     </row>

     <row>
      <entry><structfield>adbin</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>列默认值的内部表示</entry>
     </row>

     <row>
      <entry><structfield>adsrc</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>默认值的人类可读的表示</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

   <para>
    <structfield>adsrc</structfield>列的存在是有历史原因的，并且最好不要被使用，因为它不能跟踪可能导致默认值表现形式的外部变化。如果要显示默认值，反编译<structfield>adbin</structfield>列（例如使用<function>pg_get_expr</>）是一种更好的方法。
   </para>

 </sect1>


 <sect1 id="catalog-pg-attribute">
  <title><structname>pg_attribute</structname></title>

  <indexterm zone="catalog-pg-attribute">
   <primary>pg_attribute</primary>
  </indexterm>

  <para>
   目录<structname>pg_attribute</structname>存储有关表列的信息。数据库中的每一个表的每一个列都恰好在<structname>pg_attribute</structname>中有一行。（这其中也会有索引的属性项，并且事实上所有具有<structname>pg_class</structname>项的对象在这里都有属性项）
   entries.)
  </para>

  <para>
   术语属性等同于列，这里使用它只是出于历史原因。
  </para>

  <table>
   <title><structname>pg_attribute</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>attrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>列所属的表</entry>
     </row>

     <row>
      <entry><structfield>attname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>列名</entry>
     </row>

     <row>
      <entry><structfield>atttypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>列的数据类型</entry>
     </row>

     <row>
      <entry><structfield>attstattarget</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       <structfield>attstattarget</structfield>控制由<xref linkend="sql-analyze">对此列收集的统计信息的细节层次。0值表示不会收集任何统计信息。一个负值则说明直接使用系统默认的目标。正值的确切含义取决于数据类型。对于标量数据类型，<structfield>attstattarget</structfield>既是要收集的<quote>最常见值</quote>的目标号，也是要创建的柱状图容器的目标号。
      </entry>
     </row>

     <row>
      <entry><structfield>attlen</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       本列类型的<literal>pg_type.typlen</literal>一个拷贝
      </entry>
     </row>

     <row>
      <entry><structfield>attnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       列的编号。一般列从1开始向上编号。系统列（如<structfield>oid</structfield>）则拥有（任意）负值编号。
      </entry>
     </row>

     <row>
      <entry><structfield>attndims</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       如果该列是一个数组类型，这里就是其维度数；否则为0。（在目前一个数组的维度数并不被强制，因此任何非零值都能有效地表明<quote>这是一个数组</>。）
      </entry>
     </row>

     <row>
      <entry><structfield>attcacheoff</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       在存储中总是为-1，但是当被载入到一个内存中的行描述符后，这里可能会被更新为属性在行内的偏移
      </entry>
     </row>

     <row>
      <entry><structfield>atttypmod</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       <structfield>atttypmod</structfield>记录了在表创建时提供的类型相关数据（例如一个<type>varchar</type>列的最大长度）。它会被传递给类型相关的输入函数和长度强制函数。对于那些不需要<structfield>atttypmod</>的类型，这个值通常总是为-1。
      </entry>
     </row>

     <row>
      <entry><structfield>attbyval</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       该列类型的<literal>pg_type.typbyval</>的一个拷贝
      </entry>
     </row>

     <row>
      <entry><structfield>attstorage</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       通常是该列类型的<literal>pg_type.typstorage</>的一个拷贝。对于可TOAST的数据类型，这可以在列创建后被修改以控制存储策略。
      </entry>
     </row>

     <row>
      <entry><structfield>attalign</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       该列类型的<literal>pg_type.typalign</>的一个拷贝
      </entry>
     </row>

     <row>
      <entry><structfield>attnotnull</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       这表示一个非空约束。可以通过修改该列来启用和禁用该约束。
      </entry>
     </row>

     <row>
      <entry><structfield>atthasdef</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       该列有一个默认值，在此情况下在<structname>pg_attrdef</structname>目录中会有一个对应项来真正记录默认值。
      </entry>
     </row>

     <row>
      <entry><structfield>attisdropped</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       该列被删除且不再有效。一个删除的列仍然物理存在于表中，但是会被分析器忽略并因此无法通过SQL访问。
      </entry>
     </row>

     <row>
      <entry><structfield>attislocal</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       该列是由关系本地定义的。注意一个列可以同时是本地定义和继承的。
      </entry>
     </row>

     <row>
      <entry><structfield>attinhcount</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       该列的直接祖先的编号。一个具有非零编号祖先的列不能被删除或者重命名。
      </entry>
     </row>

     <row>
      <entry><structfield>attcollation</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-collation"><structname>pg_collation</structname></link>.oid</literal></entry>
      <entry>
       该列被定义的排序规则，如果该列不是一个可排序数据类型则为0。
      </entry>
     </row>

     <row>
      <entry><structfield>attacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       列级访问权限
      </entry>
     </row>

     <row>
      <entry><structfield>attoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       属性级选项，以<quote>keyword=value</>形式的字符串
      </entry>
     </row>

     <row>
      <entry><structfield>attfdwoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       属性级的外部数据包装器选项，以<quote>keyword=value</>形式的字符串
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   在一个被删除的列的<structname>pg_attribute</structname>的项中，<structfield>atttypid</structfield>被重置为0，但<structfield>attlen</structfield>以及其他从<structname>pg_type</>拷贝的域仍然有效。这种安排用于处理一种情况，即被删除列的数据类型后来被删除，并且因此不再有相应的<structname>pg_type</>行。<structfield>attlen</structfield>和其他域可以被用来解释表的一行的内容。
  </para>
 </sect1>


 <sect1 id="catalog-pg-authid">
  <title><structname>pg_authid</structname></title>

  <indexterm zone="catalog-pg-authid">
   <primary>pg_authid</primary>
  </indexterm>

  <para>
   目录<structname>pg_authid</structname>包含关于数据库授权标识符（角色）的信息。角色把<quote>用户</>和<quote>组</>的概念包含在内。一个用户实际上就是一个<structfield>rolcanlogin</>标志被设置的角色。任何角色（不管<structfield>rolcanlogin</>设置与否）都能够把其他角色作为成员，参见<link linkend="catalog-pg-auth-members"><structname>pg_auth_members</structname></link>。
  </para>

  <para>
   由于这个目录包含口令，它不能是公共可读的。<link linkend="view-pg-roles"><structname>pg_roles</structname></link>是在<structname>pg_authid</structname>上的一个公共可读视图，它隐去了口令域。
  </para>

  <para>
   <xref linkend="user-manag">包含关于用户和权限管理的详细信息。
  </para>

  <para>
   由于用户标识符是集簇范围的，<structname>pg_authid</structname>在一个集簇的所有数据库之间共享：在一个集簇中只有一份<structname>pg_authid</structname>拷贝，而不是每个数据库一份。
  </para>

  <table>
   <title><structname>pg_authid</>的列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名字</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>行标识符（隐藏属性，必须被显式选择才会显示）</entry>
     </row>

     <row>
      <entry><structfield>rolname</structfield></entry>
      <entry><type>name</type></entry>
      <entry>角色名</entry>
     </row>

     <row>
      <entry><structfield>rolsuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>角色是否拥有超级用户权限</entry>
     </row>

     <row>
      <entry><structfield>rolinherit</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>如果本角色是另一个角色的成员，本角色是否自动另一个角色的权限</entry>
     </row>

     <row>
      <entry><structfield>rolcreaterole</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>角色是否能创建更多角色</entry>
     </row>

     <row>
      <entry><structfield>rolcreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>角色是否能创建数据库</entry>
     </row>

     <row>
      <entry><structfield>rolcatupdate</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>
       角色是否能直接更新系统目录。（如果这一列不为真，即便是一个超级用户也不能更新系统目录）
      </entry>
     </row>

     <row>
      <entry><structfield>rolcanlogin</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>
       角色是否能登录。即该角色是否能够作为初始会话授权标识符
      </entry>
     </row>

     <row>
      <entry><structfield>rolreplication</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>
       角色是否为一个复制角色。即角色能否开启流复制（参见<xref linkend="streaming-replication">）并使用<function>pg_start_backup</>和<function>pg_stop_backup</>设定和复原系统备份模式
      </entry>
     </row>

     <row>
      <entry><structfield>rolconnlimit</structfield></entry>
      <entry><type>int4</type></entry>
      <entry>
       对于可以登录的角色，本列设置该角色可以同时发起最大连接数。-1表示无限制。
      </entry>
     </row>

     <row>
      <entry><structfield>rolpassword</structfield></entry>
      <entry><type>text</type></entry>
      <entry>
       口令（可能被加密），如果没有则为空。如果口令被加密，本列将以字符串<literal>md5</>开始，后接一个32字符的16进制MD5哈希值。这个MD5哈希值将是用户口令与用户名的串接。例如，如果用户<literal>joe</>的口令是<literal>xyzzy</>，<productname>PostgreSQL</>将存储<literal>xyzzyjoe</>的MD5哈希值。不遵循这一格式的口令将被假定为未加密。
      </entry>
     </row>

     <row>
      <entry><structfield>rolvaliduntil</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry>口令过期时间（只用于口令鉴定），如果永不过期则为空</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-auth-members">
  <title><structname>pg_auth_members</structname></title>

  <indexterm zone="catalog-pg-auth-members">
   <primary>pg_auth_members</primary>
  </indexterm>

  <para>
   目录<structname>pg_auth_members</structname>展示了角色之间的成员关系。允许任何无环的关系集合。
  </para>

  <para>
   由于用户标识符是集簇范围的，<structname>pg_auth_members</structname>在一个集簇的所有数据库之间共享：在一个集簇中只有一份<structname>pg_auth_members</structname>拷贝，而不是每个数据库一份。
  </para>

  <table>
   <title><structname>pg_auth_members</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>roleid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>拥有成员的角色的ID</entry>
     </row>

     <row>
      <entry><structfield>member</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry><structfield>roleid</>的成员角色的ID</entry>
     </row>

     <row>
      <entry><structfield>grantor</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>授权此成员关系的角色的ID</entry>
     </row>

     <row>
      <entry><structfield>admin_option</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>如果<structfield>member</>能把<structfield>roleid</>的成员关系授予他人，则为真</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-cast">
  <title><structname>pg_cast</structname></title>

  <indexterm zone="catalog-pg-cast">
   <primary>pg_cast</primary>
  </indexterm>

  <para>
   目录<structname>pg_cast</structname>存储数据类型转换路径，包括内建的和用户定义的类型。
  </para>

  <para>
   需要注意的是，<structname>pg_cast</structname>并不表示系统知道如何执行的所有类型转换，它只包括哪些不能从某些普通规则推导出的转换。例如，一个域及其基类型之间的转换并未显式地在<structname>pg_cast</structname>中展示。另一个重要的例外是<quote>自动 I/O转换造型</>，它们通过数据类型自己的I/O函数来转换成（或者转换自）<type>text</>或其他字符串类型，这些转换也没有显式地在<structname>pg_cast</structname>中表示。
  </para>

  <table>
   <title><structname>pg_cast</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符（隐藏属性，必须被显式选择才会显示）</entry>
     </row>

     <row>
      <entry><structfield>castsource</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>源数据类型的OID</entry>
     </row>

     <row>
      <entry><structfield>casttarget</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>目标数据类型的OID</entry>
     </row>

     <row>
      <entry><structfield>castfunc</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       执行该转换的函数的OID。如果该转换方法不需要一个函数则存储0。
      </entry>
     </row>

     <row>
      <entry><structfield>castcontext</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       指示该转换能被调用的环境。
       <literal>e</>表示仅能作为一个显式转换（使用<literal>CAST</>或<literal>::</>语法）。
       <literal>a</>表示在赋值给目标列时隐式调用， 和显式调用一样。
       <literal>i</>表示在表达式中隐式调用，和其他转换一样。
      </entry>
     </row>
     <row>
      <entry><structfield>castmethod</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       指示转换如何被执行。
       <literal>f</>表明使用<structfield>castfunc</>中指定的函数。
       <literal>i</>表明使用输入/输出函数。
       <literal>b</>表明该类型是二进制可转换的，因此不需要转换。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   在<structname>pg_cast</structname>里列出的类型转换函数必须总是以转换的源类型作为它的第一个参数类型， 并且返回转换的目标类型作为它的结果类型。一个类型转换函数最多有三个参数。 如果出现了第二个参数，必须是<type>integer</>类型；它接受与目标类型关联的修饰词， 如果没有，就是 -1。如果出现了第三个参数，那么必须是<type>boolean</>类型； 如果该类型转换是一种明确的转换，那么它接受<literal>true</>，否则接受<literal>false</>。
  </para>

  <para>
   在<structname>pg_cast</structname>里创建一条源类型和目标类型相同的记录是合理的， 只要相关联的函数接受多过一个参数。这样的记录代表<quote>长度转换函数</>， 它们把该类型的值转换为对特定的类型合法的值。
  </para>

  <para>
   如果一个<structname>pg_cast</structname>的项有着不同的原类型和目标类型， 并且有一个接收多于一个参数的函数，那么它会在一个步骤中完成从一种类型到另外一种类型的转换并应用一个长度转换。如果没有这样的项，使用一个类型修改器的转换涉及两个步骤， 一个是在数据类型之间转换，另外一个是应用修改器。
  </para>
 </sect1>

 <sect1 id="catalog-pg-class">
  <title><structname>pg_class</structname></title>

  <indexterm zone="catalog-pg-class">
   <primary>pg_class</primary>
  </indexterm>

  <para>
   目录<structname>pg_class</structname>记录表和几乎所有具有列或者像表的东西。这包括索引（但还要参见<structname>pg_index</structname>）、序列、视图、物化视图、组合类型和TOAST表，参见<structfield>relkind</>。下面，当我们提及所有这些类型的对象时我们使用<quote>关系</quote>。并非所有列对于所有关系类型都有意义。
  </para>

  <table>
   <title><structname>pg_class</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符（隐藏属性，必须被显式选择才会显示）</entry>
     </row>

     <row>
      <entry><structfield>relname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>表、索引、视图等的名字</entry>
     </row>

     <row>
      <entry><structfield>relnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       包含该关系的名字空间的OID
      </entry>
     </row>

     <row>
      <entry><structfield>reltype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       可能存在的表行类型所对应数据类型的OID（对索引为0，索引没有<structname>pg_type</>项）
      </entry>
     </row>

     <row>
      <entry><structfield>reloftype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       对于有类型的表，为底层组合类型的OID，对于其他所有关系为0
      </entry>
     </row>

     <row>
      <entry><structfield>relowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>关系的拥有者</entry>
     </row>

     <row>
      <entry><structfield>relam</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-am"><structname>pg_am</structname></link>.oid</literal></entry>
      <entry>如果这是一个索引，表示索引使用的访问方法（B树、哈希等）</entry>
     </row>

     <row>
      <entry><structfield>relfilenode</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>该关系的磁盘文件的名字，0表示这是一个<quote>映射</>关系，其磁盘文件名取决于低层状态</entry>
     </row>

     <row>
      <entry><structfield>reltablespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.oid</literal></entry>
      <entry>
       该关系所存储的表空间。如果为0，使用数据库的默认表空间。（如果关系无磁盘文件时无意义）
      </entry>
     </row>

     <row>
      <entry><structfield>relpages</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       该表磁盘表示的尺寸，以页面计（页面尺寸为<symbol>BLCKSZ</symbol>）。这只是一个由规划器使用的估计值。它被<command>VACUUM</command>、<command>ANALYZE</command>以及一些DDL命令（如<command>CREATE INDEX</command>）所更新。
      </entry>
     </row>

     <row>
      <entry><structfield>reltuples</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>
       表中的行数。这只是一个由规划器使用的估计值。它被<command>VACUUM</command>、<command>ANALYZE</command>以及一些DDL命令（如<command>CREATE INDEX</command>）所更新。
      </entry>
     </row>

     <row>
      <entry><structfield>relallvisible</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       在表的可见性映射表中被标记为全可见的页数。这只是一个由规划器使用的估计值。它被<command>VACUUM</command>、<command>ANALYZE</command>以及一些DDL命令（如<command>CREATE INDEX</command>）所更新。
      </entry>
     </row>

     <row>
      <entry><structfield>reltoastrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       与该表相关联的TOAST表的OID，如果没有则为0。TOAST表将大属性<quote>线外</quote>存储在一个二级表中。
      </entry>
     </row>

     <row>
      <entry><structfield>relhasindex</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       如果这是一个表并且其上建有（或最近建有）索引则为真
      </entry>
     </row>

     <row>
      <entry><structfield>relisshared</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       如果该表在集簇中的所有数据库间共享则为真。只有某些系统目录（如<structname>pg_database</structname>）是共享的。
      </entry>
     </row>

     <row>
      <entry><structfield>relpersistence</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <literal>p</> = 永久表，<literal>u</> = 无日志表，
       <literal>t</> = 临时表
      </entry>
     </row>

     <row>
      <entry><structfield>relkind</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <literal>r</> = 普通表，<literal>i</> = 索引，
       <literal>S</> = 序列，<literal>v</> = 视图，
       <literal>m</> = 物化视图，
       <literal>c</> = 组合类型，<literal>t</> = TOAST表，
       <literal>f</> = 外部表
      </entry>
     </row>

     <row>
      <entry><structfield>relnatts</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       关系中用户列的数目（系统列不计算在内）。在<structname>pg_attribute</structname>中必须有这么多对应的项。另请参阅<literal>pg_attribute.attnum</literal>。
      </entry>
     </row>

     <row>
      <entry><structfield>relchecks</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       表上<literal>CHECK</>约束的数目，参见<link linkend="catalog-pg-constraint"><structname>pg_constraint</structname></link>目录
      </entry>
     </row>

     <row>
      <entry><structfield>relhasoids</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       如果为关系的每一行生成一个OID则为真
      </entry>
     </row>

     <row>
      <entry><structfield>relhaspkey</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       如果表有（或曾有）一个主键则为真
      </entry>
     </row>

     <row>
      <entry><structfield>relhasrules</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       如果表有（或曾有）规则则为真，参见
       <link linkend="catalog-pg-rewrite"><structname>pg_rewrite</structname></link>目录
      </entry>
     </row>

     <row>
      <entry><structfield>relhastriggers</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       如果表有（或曾有）触发器则为真，参见
       <link linkend="catalog-pg-trigger"><structname>pg_trigger</structname></link>目录
      </entry>
     </row>

     <row>
      <entry><structfield>relhassubclass</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>如果表有（或曾有）任何继承子女则为真</entry>
     </row>

     <row>
      <entry><structfield>relispopulated</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>如果表已被填充则为真（对于所有关系该列都为真，但对于某些物化视图却不是）</entry>
     </row>

     <row>
      <entry><structfield>relreplident</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       用来为行形成<quote>replica identity</>的列：
       <literal>d</> = 默认 (主键，如果存在),
       <literal>n</> = 无,
       <literal>f</> = 所有列
       <literal>i</> = 索引的<structfield>indisreplident</structfield>被设置或者为默认
      </entry>
     </row>

     <row>
      <entry><structfield>relfrozenxid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       在此之前的所有事务ID在表中已经被替换为一个永久的（<quote>冻结的</>) 事务ID。这用于跟踪表是否需要被清理，以便阻止事务ID回卷或者允许<literal>pg_clog</>被收缩。如果该关系不是一个表则为0（<symbol>InvalidTransactionId</symbol>）。
      </entry>
     </row>

     <row>
      <entry><structfield>relminmxid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       在此之前的多事务ID在表中已经被替换为一个事务ID。这被用于跟踪表是否需要被清理，以阻止
       多事务ID回卷或者允许<literal>pg_multixact</>被收缩。如果关系不是一个表则
       为0（<symbol>InvalidMultiXactId</symbol>）。
      </entry>
     </row>

     <row>
      <entry><structfield>relacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       访问权限，更多信息参见
       <xref linkend="sql-grant">和
       <xref linkend="sql-revoke">
      </entry>
     </row>

     <row>
      <entry><structfield>reloptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       访问方法相关的选项，以<quote>keyword=value</>字符串形式
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_class</>中的一些逻辑标志被以一种懒惰的方式维护：在正确状态时它们被保证为真，但是当条件不再为真时它们并不会被立刻重置为假。例如，<structfield>relhasindex</>由<command>CREATE INDEX</command>设置，但它从不会被<command>DROP INDEX</command>清除。作为替代，<command>VACUUM</command>会在找到无索引表后清除其<structfield>relhasindex</>。这种安排避免了竞争条件并且提高了并发性。
  </para>
 </sect1>

 <sect1 id="catalog-pg-collation">
  <title><structname>pg_collation</structname></title>

  <indexterm zone="catalog-pg-collation">
   <primary>pg_collation</primary>
  </indexterm>

  <para>
   目录<structname>pg_collation</structname>描述了可用的排序规则，其本质是从一个SQL名字到操作系统locale分类的映射。更多信息参见<xref linkend="collation">。
  </para>

  <table>
   <title><structname>pg_collation</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符（隐藏属性，必须被显式选择才会显示）</entry>
     </row>

     <row>
      <entry><structfield>collname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>排序规则名字（在每一个名字空间和编码中唯一）</entry>
     </row>

     <row>
      <entry><structfield>collnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       包含该排序规则的名字空间的OID
      </entry>
     </row>

     <row>
      <entry><structfield>collowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>排序规则的拥有者</entry>
     </row>

     <row>
      <entry><structfield>collencoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>该排序规则可应用的编码，-1表示它可用于任何编码</entry>
     </row>

     <row>
      <entry><structfield>collcollate</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>该排序规则对象的<symbol>LC_COLLATE</></entry>
     </row>

     <row>
      <entry><structfield>collctype</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>该排序规则对象的<symbol>LC_CTYPE</></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   注意在这个目录中的唯一键是（<structfield>collname</>、
   <structfield>collencoding</>、 <structfield>collnamespace</>）， 不仅仅是（<structfield>collname</>，<structfield>collnamespace</>）。
   所有<structfield>collencoding</>不等于当前数据库编码或-1的编码规则通常都会被<productname>PostgreSQL</productname>忽略，且禁止创建和<structfield>collencoding</> = -1的项重名的项。因此使用一个受限的SQL名字（<replaceable>schema</>.<replaceable>name</>）来标识一个排序规则是足够的，即使这根据目录定义是不唯一的。以这种方式定义这个目录的原因是<application>initdb</>会在集簇初始化时使用系统上所有可用的locale填充这个目录，所以它必须能够为所有可能在集簇中使用的编码保持项。
  </para>

  <para>
   在<literal>template0</>数据库中，创建与数据库编码不匹配的编码是有用的，因为它们可以匹配后面从<literal>template0</>克隆的数据库的编码。这在目前必须手动完成。
  </para>
 </sect1>

 <sect1 id="catalog-pg-constraint">
  <title><structname>pg_constraint</structname></title>

  <indexterm zone="catalog-pg-constraint">
   <primary>pg_constraint</primary>
  </indexterm>

  <para>
   目录<structname>pg_constraint</structname>存储表上的检查、主键、唯一、外键和排他约束（列约束也不会被特殊对待。每一个列约束都等同于某种表约束。）。非空约束不在这里，而是在<structname>pg_attribute</>目录中表示。
  </para>

  <para>
   用户定义的约束触发器（使用<command>CREATE CONSTRAINT
   TRIGGER</>创建）也会在这个表中产生一项。
  </para>

  <para>
   域上的检查约束也存储在这里。
  </para>

  <table>
   <title><structname>pg_constraint</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符（隐藏属性，必须被显式选择才会显示）</entry>
     </row>

     <row>
      <entry><structfield>conname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>约束名字（不需要唯一！）</entry>
     </row>

     <row>
      <entry><structfield>connamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       包含此约束的名字空间的OID
      </entry>
     </row>

     <row>
      <entry><structfield>contype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
        <literal>c</> = 检查约束，
        <literal>f</> = 外键约束，
        <literal>p</> = 主键约束，
        <literal>u</> = 唯一约束，
        <literal>t</> = 约束触发器，
        <literal>x</> = 排他约束
      </entry>
     </row>

     <row>
      <entry><structfield>condeferrable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>该约束是否能被延迟？</entry>
     </row>

     <row>
      <entry><structfield>condeferred</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>该约束是否默认被延迟？</entry>
     </row>

     <row>
      <entry><structfield>convalidated</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>此约束是否被验证过？当前对于外键和检查约束只能是假</entry>
     </row>

     <row>
      <entry><structfield>conrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>该约束所在的表，如果不是表约束则为0</entry>
     </row>

     <row>
      <entry><structfield>contypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>该约束所在的域，如果不是域约束则为0</entry>
     </row>

     <row>
      <entry><structfield>conindid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>如果该约束是唯一、主键、外键或排他约束，此列表示支持此约束的索引，否则为0</entry>
     </row>

     <row>
      <entry><structfield>confrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>如果此约束是一个外键约束，此列为被引用的表，否则为0</entry>
     </row>

     <row>
      <entry><structfield>confupdtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>外键更新动作代码：
            <literal>a</> = 无动作，
            <literal>r</> = 限制，
            <literal>c</> = 级联，
            <literal>n</> = 置空，
            <literal>d</> = 置为默认值
          </entry>
     </row>

     <row>
      <entry><structfield>confdeltype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>外键删除动作代码：
            <literal>a</> = 无动作，
            <literal>r</> = 限制，
            <literal>c</> = 级联，
            <literal>n</> = 置空，
            <literal>d</> = 置为默认值
          </entry>
     </row>

     <row>
      <entry><structfield>confmatchtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>外键匹配类型：
            <literal>f</> = 完全，
            <literal>p</> = 部分，
            <literal>s</> = 简单
          </entry>
     </row>

     <row>
      <entry><structfield>conislocal</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       此约束是定义在关系本地。注意一个约束可以同时是本地定义和继承。
      </entry>
     </row>

     <row>
      <entry><structfield>coninhcount</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       此约束的直接继承祖先数目。一个此列非零的约束不能被删除或重命名。
      </entry>
     </row>

     <row>
      <entry><structfield>connoinherit</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       为真表示此约束被定义在关系本地。它是一个不可继承约束。
      </entry>
     </row>

     <row>
      <entry><structfield>conkey</structfield></entry>
      <entry><type>int2[]</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</></entry>
      <entry>如果是一个表约束（包括外键但不包括约束触发器），此列是被约束列的列表</entry>
     </row>

     <row>
      <entry><structfield>confkey</structfield></entry>
      <entry><type>int2[]</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</></entry>
      <entry>如果是一个外键，此列是被引用列的列表</entry>
     </row>

     <row>
      <entry><structfield>conpfeqop</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</></entry>
      <entry>如果是一个外键，此列是用于PK = FK比较的等值操作符的列表</entry>
     </row>

     <row>
      <entry><structfield>conppeqop</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</></entry>
      <entry>如果是一个外键，此列是用于PK = PK比较的等值操作符的列表</entry>
     </row>

     <row>
      <entry><structfield>conffeqop</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</></entry>
      <entry>如果是一个外键，此列是用于FK = FK比较的等值操作符的列表</entry>
     </row>

     <row>
      <entry><structfield>conexclop</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</></entry>
      <entry>如果是一个排他约束，此列是没列排他操作符的列表</entry>
     </row>

     <row>
      <entry><structfield>conbin</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>如果是一个检查约束，此列是表达式的一个内部表示</entry>
     </row>

     <row>
      <entry><structfield>consrc</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>如果是一个检查约束，此列是表达式的一个人类可读的表示</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   在一个排他约束的情况中， <structfield>conkey</structfield>只对约束元素是单一列引用时有用。对于其他情况，<structfield>conkey</structfield>为0且必须查阅相关索引来发现被约束的表达式（<structfield>conkey</structfield>因此和<structname>pg_index</>.<structfield>indkey</>具有相同的内容）。
  </para>

  <note>
   <para>
    当被引用对象改变时，<structfield>consrc</structfield>不能被更新。例如，它不跟踪列的重命名。最好使用<function>pg_get_constraintdef()</>来抽取一个检查约束的定义，而不是依赖这个域。
   </para>
  </note>

  <note>
   <para>
    <literal>pg_class.relchecks</literal>需要和每个关系在此目录中的检查约束数量保持一致。
   </para>
  </note>
 </sect1>


 <sect1 id="catalog-pg-conversion">
  <title><structname>pg_conversion</structname></title>

  <indexterm zone="catalog-pg-conversion">
   <primary>pg_conversion</primary>
  </indexterm>

  <para>
   目录<structname>pg_conversion</structname>描述编码转换过程。更多信息参见<xref linkend="sql-createconversion">。
  </para>

  <table>
   <title><structname>pg_conversion</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符（隐藏属性，必须被显式选择才会显示）</entry>
     </row>

     <row>
      <entry><structfield>conname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>转换的名字（在一个名字空间内唯一）</entry>
     </row>

     <row>
      <entry><structfield>connamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       包含此转换的名字空间的OID
      </entry>
     </row>

     <row>
      <entry><structfield>conowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>转换的拥有者</entry>
     </row>

     <row>
      <entry><structfield>conforencoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>源编码ID</entry>
     </row>

     <row>
      <entry><structfield>contoencoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>目标编码ID</entry>
     </row>

     <row>
      <entry><structfield>conproc</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>转换过程</entry>
     </row>

     <row>
      <entry><structfield>condefault</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>如果这是默认转换则为真</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="catalog-pg-database">
  <title><structname>pg_database</structname></title>

  <indexterm zone="catalog-pg-database">
   <primary>pg_database</primary>
  </indexterm>

  <para>
   目录<structname>pg_database</structname>存储有关可用数据库的信息。数据库通过<xref
   linkend="sql-createdatabase">命令创建。
   更多关于其参数的信息请查阅<xref linkend="managing-databases">。
  </para>

  <para>
   和大部分系统目录不同，<structname>pg_database</structname>是在集簇的所有数据库之间共享的：在一个集簇中只有一份<structname>pg_database</structname>拷贝，而不是每个数据库一份。
  </para>

  <table>
   <title><structname>pg_database</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符（隐藏属性，必须被显式选择才会显示）</entry>
     </row>

     <row>
      <entry><structfield>datname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>数据库名字</entry>
     </row>

     <row>
      <entry><structfield>datdba</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>数据库的拥有者，通常是创建它的用户</entry>
     </row>

     <row>
      <entry><structfield>encoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>此数据库的字符编码的编号（<function>pg_encoding_to_char()</function>可将此编号转换成编码的名字）</entry>
     </row>

     <row>
      <entry><structfield>datcollate</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>此数据库的LC_COLLATE</entry>
     </row>

     <row>
      <entry><structfield>datctype</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>此数据库的LC_CTYPE</entry>
     </row>

     <row>
      <entry><structfield>datistemplate</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       如果为真，则此数据库可被任何具有<literal>CREATEDB</>特权的用户克隆；如果为假，则只有
       超级用户或者该数据库的属主能够克隆它。
      </entry>
     </row>

     <row>
      <entry><structfield>datallowconn</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       如果为假则没有人能连接到这个数据库。这可以用来保护<literal>template0</>数据库不被修改。
      </entry>
     </row>

     <row>
      <entry><structfield>datconnlimit</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       设置能够连接到这个数据库的最大并发连接数。-1表示没有限制。
      </entry>
     </row>

     <row>
      <entry><structfield>datlastsysoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>
       数据库中最后一个系统OID，对<application>pg_dump</application>特别有用
      </entry>
     </row>

     <row>
      <entry><structfield>datfrozenxid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       在此之前的所有事务ID在数据库中已经被替换为一个永久的（<quote>冻结的</>) 事务ID。这用于跟踪数据库是否需要被清理，以便组织事务ID回环或者允许<literal>pg_clog</>被收缩。它是此数据库中所有表的<structname>pg_class</>.<structfield>relfrozenxid</>值的最小值。
      </entry>
     </row>

     <row>
      <entry><structfield>datminmxid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       在此之前的所有多事务ID在数据库中已经被替换为一个事务ID。这用于跟踪数据库是否需要被
       清理，以便组织事务ID回环或者允许<literal>pg_multixact</>被收缩。它是此数据库中
       所有表的<structname>pg_class</>.<structfield>relminmxid</>值的最小值。
      </entry>
     </row>

     <row>
      <entry><structfield>dattablespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.oid</literal></entry>
      <entry>
       此数据库的默认表空间。在此数据库中，所有<structname>pg_class</>.<structfield>reltablespace</>为0的表都将被存储在这个表空间中，尤其是非共享系统目录都会在其中。
      </entry>
     </row>

     <row>
      <entry><structfield>datacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       访问权限，更多信息参见
       <xref linkend="sql-grant">和
       <xref linkend="sql-revoke">
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-db-role-setting">
  <title><structname>pg_db_role_setting</structname></title>

  <indexterm zone="catalog-pg-db-role-setting">
   <primary>pg_db_role_setting</primary>
  </indexterm>

  <para>
   目录 <structname>pg_db_role_setting</structname>为每一个角色和数据库组合记录被设置到运行时配置变量的默认值。
  </para>

  <para>
   和大部分系统目录不同，<structname>pg_db_role_setting</structname>是在集簇的所有数据库之间共享的：在一个集簇中只有一份<structname>pg_db_role_setting</structname>拷贝，而不是每个数据库一份。
  </para>

  <table>
   <title><structname>pg_db_role_setting</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>setdatabase</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <entry>此设置可用的数据库OID，如果不与具体数据库相关则为0</entry>
     </row>

     <row>
      <entry><structfield>setrole</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>此设置可用的角色OID，如果不与具体角色相关则为0</entry>
     </row>

     <row>
      <entry><structfield>setconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>运行时配置变量的默认值</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-default-acl">
  <title><structname>pg_default_acl</structname></title>

  <indexterm zone="catalog-pg-default-acl">
   <primary>pg_default_acl</primary>
  </indexterm>

  <para>
   目录<structname>pg_default_acl</>存储要被分配给新创建对象的初始权限。
  </para>

  <table>
   <title><structname>pg_default_acl</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符（隐藏属性，必须被显式选择才会显示）</entry>
     </row>

     <row>
      <entry><structfield>defaclrole</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>与此项相关的角色的OID</entry>
     </row>

     <row>
      <entry><structfield>defaclnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>与此项相关的名字空间的OID，如果没有则为0</entry>
     </row>

     <row>
      <entry><structfield>defaclobjtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       此项适合的对象类型：
       <literal>r</> = 关系（表、视图），
       <literal>S</> = 序列，
       <literal>f</> = 函数，
       <literal>T</> = 类型
      </entry>
     </row>

     <row>
      <entry><structfield>defaclacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       此类对象在创建时应用有的访问权限
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   一个<structname>pg_default_acl</>项展示了要分配给属于一个指定用户的对象的初始权限。当前有两类项：<structfield>defaclnamespace</> = 0的<quote>全局</>项和引用一个特殊模式的<quote>每模式</>项。如果一个全局项存在，则它<emphasis>重载</>该对象类型的普通hard-wired默认权限。一个每模式项如果存在，表示权限将被<emphasis>加入到</>全局或hard-wired默认权限中。
  </para>

  <para>
   注意当在另一个表中的一个ACL项为空时，它用来表示其对象的hard-wired默认权限，而<emphasis>不是</>当时可能在<structname>pg_default_acl</>中的任何权限。只有在对象创建期间才会查阅<structname>pg_default_acl</>。
  </para>

 </sect1>


 <sect1 id="catalog-pg-depend">
  <title><structname>pg_depend</structname></title>

  <indexterm zone="catalog-pg-depend">
   <primary>pg_depend</primary>
  </indexterm>

  <para>
   目录<structname>pg_depend</structname>记录数据库对象之间的依赖关系。这些信息允许<command>DROP</>命令查找必须被<command>DROP CASCADE</>删除的其他对象，或者在<command>DROP
   RESTRICT</>情况下阻止删除。
  </para>

  <para>
   另请参阅<link linkend="catalog-pg-shdepend"><structname>pg_shdepend</structname></link>，它对在一个数据库集簇中共享的对象之间的依赖提供了相似的功能。
  </para>

  <table>
   <title><structname>pg_depend</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>classid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>依赖对象所在的系统目录OID</entry>
     </row>

     <row>
      <entry><structfield>objid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>any OID column</entry>
      <entry>指定依赖对象的OID</entry>
     </row>

     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       对于一个表列，这里是列号（<structfield>objid</>和<structfield>classid</>指表本身）。对于所有其他对象类型，此列为0。
      </entry>
     </row>

     <row>
      <entry><structfield>refclassid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>被引用对象所在的系统目录的OID</entry>
     </row>

     <row>
      <entry><structfield>refobjid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>any OID column</entry>
      <entry>指定被引用对象的OID</entry>
     </row>

     <row>
      <entry><structfield>refobjsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       对于一个表列，这里是列号（<structfield>refobjid</>和<structfield>refclassid</>指表本身）。对于所有其他对象类型，此列为0。
      </entry>
     </row>

     <row>
      <entry><structfield>deptype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       定义此依赖关系语义的一个代码，见文本
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   在所有情况下，一个<structname>pg_depend</structname>项表明被引用对象不能在没有删除其依赖对象的情况下被删除。但是，其中也有多种依赖类型，由<structfield>deptype</>标识：

   <variablelist>
    <varlistentry>
     <term><symbol>DEPENDENCY_NORMAL</> (<literal>n</>)</term>
     <listitem>
      <para>
       在独立创建的对象之间的一个普通关系。依赖对象可以在不影响被依赖对象的情况下被删除。被引用对象只能通过指定<literal>CASCADE</>被删除，在这种情况下依赖对象也会被删除。 例子：一个表列对于其数据类型有一个普通依赖。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_AUTO</> (<literal>a</>)</term>
     <listitem>
      <para>
       依赖对象可以被独立于被依赖对象删除，且应该在被引用对象被删除时自动被删除（不管在<literal>RESTRICT</>或<literal>CASCADE</>模式）。例子：一个表上的一个命名约束应该被设置为自动依赖于表，这样在表被删除后它也会消失。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_INTERNAL</> (<literal>i</>)</term>
     <listitem>
      <para>
       依赖对象作为被引用对象创建过程的一部分被创建，并且只是其内部实现的一部分。一个依赖对象的<command>DROP</>会被直接拒绝（作为替代，我们将告诉用户发出一个针对被引用对象的<command>DROP</>）。不管是否指定<command>CASCADE</>，一个被引用对象的<command>DROP</>将被传播来删除其依赖对象。例子：一个用于强制外键约束的触发器将被设置为内部依赖于其约束的<structname>pg_constraint</>项。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_EXTENSION</> (<literal>e</>)</term>
     <listitem>
      <para>
       依赖对象是作为<firstterm>扩展</>的被引用对象的一个成员（参见<link linkend="catalog-pg-extension"><structname>pg_extension</structname></link>）。依赖对象可以通过被引用对象上的<command>DROP EXTENSION</>来删除。在功能上，这种依赖类型和一个内部依赖的作用相同，其存在只是为了清晰和简化<application>pg_dump</>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_PIN</> (<literal>p</>)</term>
     <listitem>
      <para>
       没有依赖对象，这种类型的项是一个信号，用于说明系统本身依赖于被引用对象，并且该对象永远不能被删除。这种类型的项只能被<command>initdb</command>创建。而此种项的依赖对象的列都为0。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   在未来可能会需要其他依赖类型。
  </para>

 </sect1>


 <sect1 id="catalog-pg-description">
  <title><structname>pg_description</structname></title>

  <indexterm zone="catalog-pg-description">
   <primary>pg_description</primary>
  </indexterm>

  <para>
   目录<structname>pg_description</>存储对每一个数据库对象可选的描述（注释）。描述可以通过<xref linkend="sql-comment">操作，并可使用<application>psql</application>的<literal>\d</literal>命令查看。在<structname>pg_description</structname>的初始内容中提供了很多内建系统对象的描述。
  </para>

  <para>
   参见<link linkend="catalog-pg-shdescription"><structname>pg_shdescription</structname></link>，它对在一个数据库集簇中共享的对象的描述提供了相似的功能。
  </para>

  <table>
   <title><structname>pg_description</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>any OID column</entry>
      <entry>描述所属对象的OID</entry>
     </row>

     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>对象所述的系统目录的OID</entry>
     </row>

     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       对于一个表列上的一个注释，这里是列号（<structfield>objoid</>和<structfield>classoid</>指表本身）。对所有其他对象类型，此列为0。
      </entry>
     </row>

     <row>
      <entry><structfield>description</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>作为该对象描述的任意文本</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-enum">
  <title><structname>pg_enum</structname></title>

  <indexterm zone="catalog-pg-enum">
   <primary>pg_enum</primary>
  </indexterm>

  <para>
   <structname>pg_enum</structname>目录包含每一个枚举类型的项，其中包括了值和标签。一个给定枚举值的内部表示实际上是它在<structname>pg_enum</structname>中的相关行的OID。
  </para>

  <table>
   <title><structname>pg_enum</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符（隐藏属性，必须被显式选择才会显示）</entry>
     </row>

     <row>
      <entry><structfield>enumtypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>包含此枚举值的<structname>pg_type</>项的OID</entry>
     </row>

     <row>
      <entry><structfield>enumsortorder</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>此枚举值在其枚举类型中的排序位置</entry>
     </row>

     <row>
      <entry><structfield>enumlabel</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>此枚举值的文本标签</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_enum</structname>行的OID值遵循一种特殊的规则：即OID的数值被保证按照其枚举类型的排序顺序进行排序。即如果两个偶数OID属于同一枚举类型，较小的OID必然具有较小的<structfield>enumsortorder</structfield>值。奇数OID值不需要遵循排序顺序。这种规则使得枚举比较例程在很多常见情况下可以避免系统目录查找。创建和修改枚举类型的例程将尝试尽可能地为枚举值分配偶数OID。
  </para>

  <para>
   当一个枚举类型被创建后，其成员会被分配排序位置1..<replaceable>n</>。但后面增加的成员可能会被分配负值或者分数值的<structfield>enumsortorder</structfield>。对于这些值的唯一要求是它们必须被正确地排序且和保持唯一。
  </para>
 </sect1>


 <sect1 id="catalog-pg-event-trigger">
  <title><structname>pg_event_trigger</structname></title>

  <indexterm zone="catalog-pg-event-trigger">
   <primary>pg_event_trigger</primary>
  </indexterm>

  <para>
   目录<structname>pg_event_trigger</structname>存储事件触发器。更多信息参见<xref linkend="event-triggers">。
  </para>

  <table>
   <title><structname>pg_event_trigger</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>evtname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>触发器名（必须唯一）</entry>
     </row>

     <row>
      <entry><structfield>evtevent</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>此触发器触发的事件的标识符</entry>
     </row>

     <row>
      <entry><structfield>evtowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>事件触发器的拥有者</entry>
     </row>

     <row>
      <entry><structfield>evtfoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>将被调用的函数</entry>
     </row>

     <row>
      <entry><structfield>evtenabled</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       控制事件触发器触发的<xref linkend="guc-session-replication-role">模式。
       <literal>O</> = 触发器在<quote>origin</>和<quote>local</>模式触发，
       <literal>D</> = 触发器被禁用，
       <literal>R</> = 触发器在<quote>replica</>模式触发，
       <literal>A</> = 触发器总是触发。
      </entry>
     </row>

     <row>
      <entry><structfield>evttags</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
        此触发器将触发的命令标签。如果为空，此触发器的触发不受命令标签的限制。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-extension">
  <title><structname>pg_extension</structname></title>

  <indexterm zone="catalog-pg-extension">
   <primary>pg_extension</primary>
  </indexterm>

  <para>
   目录<structname>pg_extension</structname>存储有关已安装扩展的信息。有关扩展的细节请参见<xref linkend="extend-extensions">。
  </para>

  <table>
   <title><structname>pg_extension</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符（隐藏属性，必须被显式选择才会显示）</entry>
     </row>

     <row>
      <entry><structfield>extname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>扩展的名字</entry>
     </row>

     <row>
      <entry><structfield>extowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>扩展的拥有者</entry>
     </row>

     <row>
      <entry><structfield>extnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>包含此扩展的导出对象的模式</entry>
     </row>

     <row>
      <entry><structfield>extrelocatable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>如果扩展可被重定位到另一个模式则为真</entry>
     </row>

     <row>
      <entry><structfield>extversion</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>扩展的版本名字</entry>
     </row>

     <row>
      <entry><structfield>extconfig</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>扩展的配置表的<type>regclass</>项的OID数组，如果没有配置表则为<literal>NULL</></entry>
     </row>

     <row>
      <entry><structfield>extcondition</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>扩展的配置表的<literal>WHERE</>子句过滤条件的数组，如果没有则为<literal>NULL</></entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   注意和大部分具有一个<quote>namespace</>列的模式不同，<structfield>extnamespace</structfield>不是用来表示扩展属于该模式。扩展的名字从不用模式进行限定。<structfield>extnamespace</structfield>表明该模式包含了该扩展的大部分或全部对象。如果<structfield>extrelocatable</structfield>为真，则该模式事实上必须包含属于此扩展的全部模式限定的对象。
  </para>
 </sect1>


 <sect1 id="catalog-pg-foreign-data-wrapper">
  <title><structname>pg_foreign_data_wrapper</structname></title>

  <indexterm zone="catalog-pg-foreign-data-wrapper">
   <primary>pg_foreign_data_wrapper</primary>
  </indexterm>

  <para>
   目录<structname>pg_foreign_data_wrapper</structname>存储外部数据包装器定义。外部数据包装器是一种访问位于外部服务器上数据的机制。
  </para>

  <table>
   <title><structname>pg_foreign_data_wrapper</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符（隐藏属性，必须被显式选择才会显示）</entry>
     </row>

     <row>
      <entry><structfield>fdwname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>外部数据包装器的名字</entry>
     </row>

     <row>
      <entry><structfield>fdwowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>外部数据包装器的拥有者</entry>
     </row>

     <row>
      <entry><structfield>fdwhandler</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       指一个负责为外部数据包装器提供执行例程的处理函数。如果没有提供处理函数则为0
      </entry>
     </row>

     <row>
      <entry><structfield>fdwvalidator</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       指一个负责检查传给外部数据包装器的选项的有效性的验证函数，包括外部服务器选项以及使用外部数据包装器的用户映射。如果没有提供验证函数则为0
      </entry>
     </row>

     <row>
      <entry><structfield>fdwacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       访问权限，详见<xref linkend="sql-grant">和<xref linkend="sql-revoke">
      </entry>
     </row>

     <row>
      <entry><structfield>fdwoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       外部数据包装器特定选项，以<quote>keyword=value</>字符串形式
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-foreign-server">
  <title><structname>pg_foreign_server</structname></title>

  <indexterm zone="catalog-pg-foreign-server">
   <primary>pg_foreign_server</primary>
  </indexterm>

  <para>
   目录<structname>pg_foreign_server</structname>存储外部服务器定义。外部服务器定义了外部数据的来源，例如一个远程服务器。外部服务器通过外部数据包装器来访问。
  </para>

  <table>
   <title><structname>pg_foreign_server</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符（隐藏属性，必须被显式选择才会显示）</entry>
     </row>

     <row>
      <entry><structfield>srvname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>外部服务器的名字</entry>
     </row>

     <row>
      <entry><structfield>srvowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>外部服务器的拥有者</entry>
     </row>

     <row>
      <entry><structfield>srvfdw</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-foreign-data-wrapper"><structname>pg_foreign_data_wrapper</structname></link>.oid</literal></entry>
      <entry>此外部服务器的外部数据包装器的OID</entry>
     </row>

     <row>
      <entry><structfield>srvtype</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>服务器的类型（可选）</entry>
     </row>

     <row>
      <entry><structfield>srvversion</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>服务器的版本（可选）</entry>
     </row>

     <row>
      <entry><structfield>srvacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       访问权限，详见<xref linkend="sql-grant">和<xref linkend="sql-revoke">
      </entry>
     </row>

     <row>
      <entry><structfield>srvoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       外部服务器特定选项，以<quote>keyword=value</>字符串形式
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-foreign-table">
  <title><structname>pg_foreign_table</structname></title>

  <indexterm zone="catalog-pg-foreign-table">
   <primary>pg_foreign_table</primary>
  </indexterm>

  <para>
   目录<structname>pg_foreign_table</structname>包含关于外部表的辅助信息。一个外部表和普通表一样，主要由一个<structname>pg_class</structname>项表示。它的<structname>pg_foreign_table</structname>项包含外部表所特有的信息。
  </para>

  <table>
   <title><structname>pg_foreign_table</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>ftrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>外部表的<structname>pg_class</>项的OID</entry>
     </row>

     <row>
      <entry><structfield>ftserver</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-foreign-server"><structname>pg_foreign_server</structname></link>.oid</literal></entry>
      <entry>外部表所在的外部服务器的OID</entry>
     </row>

     <row>
      <entry><structfield>ftoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       外部表选项，以<quote>keyword=value</>字符串形式
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-index">
  <title><structname>pg_index</structname></title>

  <indexterm zone="catalog-pg-index">
   <primary>pg_index</primary>
  </indexterm>

  <para>
   目录<structname>pg_index</structname>包含关于索引的部分信息。其他信息大部分在<structname>pg_class</structname>中。
  </para>

  <table>
   <title><structname>pg_index</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>indexrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>此索引的<structname>pg_class</>项的OID</entry>
     </row>

     <row>
      <entry><structfield>indrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>此索引的基表的<structname>pg_class</>项的OID</entry>
     </row>

     <row>
      <entry><structfield>indnatts</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>索引中的列数（与<literal>pg_class.relnatts</literal>重复）</entry>
     </row>

     <row>
      <entry><structfield>indisunique</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>表示是否为唯一索引</entry>
     </row>

     <row>
      <entry><structfield>indisprimary</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>表示索引是否表示表的主键（如果此列为真，<structfield>indisunique</>也总是为真）</entry>
     </row>

     <row>
      <entry><structfield>indisexclusion</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>表示索引是否支持一个排他约束</entry>
     </row>

     <row>
      <entry><structfield>indimmediate</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>表示唯一性检查是否在插入时立即被执行（如果<structfield>indisunique</>为假，此列无关）</entry>
     </row>

     <row>
      <entry><structfield>indisclustered</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>如果为真，表示表最后以此索引进行了聚簇</entry>
     </row>

     <row>
      <entry><structfield>indisvalid</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       如果为真，此索引当前可以用于查询。为假表示此索引可能不完整：它肯定还在被<command>INSERT</>/<command>UPDATE</>操作所修改，但它不能安全地被用于查询。如果索引是唯一索引，唯一性属性也不能被保证。
      </entry>
     </row>

     <row>
      <entry><structfield>indcheckxmin</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       如果为真，直到此<structname>pg_index</>行的<structfield>xmin</>低于查询的<symbol>TransactionXmin</symbol>视界之前，查询都不能使用此索引，因为表可能包含具有它们可见的不相容行的损坏HOT链
      </entry>
     </row>

     <row>
      <entry><structfield>indisready</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       如果为真，表示此索引当前可以用于插入。为假表示索引必须被<command>INSERT</>/<command>UPDATE</>操作忽略。
      </entry>
     </row>

     <row>
      <entry><structfield>indislive</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       如果为假，索引正处于被删除过程中，并且必须被所有处理忽略（包括HOT安全的决策）
      </entry>
     </row>

     <row>
      <entry><structfield>indisreplident</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       如果为真，这个索引被选择为使用<command>ALTER TABLE ... REPLICA IDENTITY USING INDEX
       ...</>的<quote>replica identity</>
      </entry>
     </row>

     <row>
      <entry><structfield>indkey</structfield></entry>
      <entry><type>int2vector</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>
       这是一个<structfield>indnatts</structfield>值的数组，它表示了此索引索引的表列。例如一个<literal>1 3</literal>值可能表示表的第一和第三列组成了索引的键。数组中的一个0表示对应的索引属性是一个在表列上的表达式，而不是一个简单的列引用。
      </entry>
     </row>

     <row>
      <entry><structfield>indcollation</structfield></entry>
      <entry><type>oidvector</type></entry>
      <entry><literal><link linkend="catalog-pg-collation"><structname>pg_collation</structname></link>.oid</literal></entry>
      <entry>
       对于索引键中的每一列，这里包含了用于该索引的排序规则的OID。
      </entry>
     </row>

     <row>
      <entry><structfield>indclass</structfield></entry>
      <entry><type>oidvector</type></entry>
      <entry><literal><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.oid</literal></entry>
      <entry>
       对于索引键中的每一列，这里包含了要使用的操作符类的OID。详见<link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>。
      </entry>
     </row>

     <row>
      <entry><structfield>indoption</structfield></entry>
      <entry><type>int2vector</type></entry>
      <entry></entry>
      <entry>
       这是一个<structfield>indnatts</structfield>值的数组，用于存储每列的标志位。位的意义由索引的访问方法定义。
      </entry>
     </row>

     <row>
      <entry><structfield>indexprs</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>
       非简单列引用索引属性的表达式树（以<function>nodeToString()</function>形式）。对于<structfield>indkey</>中每一个为0的项，这个列表中都有一个元素。如果所有的索引属性都是简单引用，此列为空。
      </entry>
     </row>

     <row>
      <entry><structfield>indpred</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>
       部分索引谓词的表达式树（以<function>nodeToString()</function>形式）。如果不是部分索引，此列为空。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-inherits">
  <title><structname>pg_inherits</structname></title>

  <indexterm zone="catalog-pg-inherits">
   <primary>pg_inherits</primary>
  </indexterm>

  <para>
   目录<structname>pg_inherits</>记录有关表继承层次的信息。数据库中每一个直接孩子表在这里都有一项（非直接继承可以通过顺着项构成的链来决定）。
  </para>

  <table>
   <title><structname>pg_inherits</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>inhrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       孩子表的OID
      </entry>
     </row>

     <row>
      <entry><structfield>inhparent</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       父表的OID
      </entry>
     </row>

     <row>
      <entry><structfield>inhseqno</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       如果一个孩子表有多于一个直接父表（多继承），这个数字说明了继承列被排列的顺序。计数从1开始。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-language">
  <title><structname>pg_language</structname></title>

  <indexterm zone="catalog-pg-language">
   <primary>pg_language</primary>
  </indexterm>

  <para>
   目录<structname>pg_language</structname>注册了可用于编写函数或存储过程的语言。
   更多关于语言处理器的信息请参阅<xref linkend="sql-createlanguage">和<xref linkend="xplang">。
  </para>

  <table>
   <title><structname>pg_language</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符（隐藏属性，必须被显式选择才会显示）</entry>
     </row>

     <row>
      <entry><structfield>lanname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>语言的名字</entry>
     </row>

     <row>
      <entry><structfield>lanowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>语言的拥有者</entry>
     </row>

     <row>
      <entry><structfield>lanispl</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       内部语言为假（如<acronym>SQL</acronym>），用户定义语言为真。当前，<application>pg_dump</application>仍然使用这个列来决定要转储哪些语言，但在未来这可能会被一种不同的机制所取代。
      </entry>
     </row>

     <row>
      <entry><structfield>lanpltrusted</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       为真表示这是一种可信的语言，即它被相信不会向普通SQL执行环境之外的任何东西授予权限。只有超级用户可以在非可信语言中创建函数。</entry>
     </row>

     <row>
      <entry><structfield>lanplcallfoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       对于非内部语言，此列引用语言处理器，它是一个特殊函数负责执行所有用这种语言编写的函数
      </entry>
     </row>

     <row>
      <entry><structfield>laninline</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       此列引用一个负责执行<quote>内联</>匿名代码块的函数（<xref linkend="sql-do"> 块）。如果不支持内联块则为0。
      </entry>
     </row>

     <row>
      <entry><structfield>lanvalidator</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       此列引用一个负责在函数创建时对其进行语法和可用性检查的语言验证函数。如果没有提供验证器则为0。
      </entry>
     </row>

     <row>
      <entry><structfield>lanacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       访问权限，详情参见<xref linkend="sql-grant">和<xref linkend="sql-revoke">
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-largeobject">
  <title><structname>pg_largeobject</structname></title>

  <indexterm zone="catalog-pg-largeobject">
   <primary>pg_largeobject</primary>
  </indexterm>

  <para>
   目录<structname>pg_largeobject</structname>保存构成<quote>大对象</quote>的数据。一个大对象在被创建时会被分配一个OID。每个大对象被分解成段或<quote>页</>，以便小到可以被方便地作为行存储在<structname>pg_largeobject</structname>中。每页中的数据量被定义为<symbol>LOBLKSIZE</>（目前是<literal>BLCKSZ/4</>或是2 kB）。
  </para>

  <para>
   在<productname>PostgreSQL</> 9.0之前，大对象没有相关的权限结构。作为结果，<structname>pg_largeobject</structname>是公共可读的并且可以用来获得系统中所有大对象的OID（和内容）。但现在不是这样了，可使用<link linkend="catalog-pg-largeobject-metadata"><structname>pg_largeobject_metadata</></link>来获得大对象OID的列表。
  </para>

  <table>
   <title><structname>pg_largeobject</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>loid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-largeobject-metadata"><structname>pg_largeobject_metadata</structname></link>.oid</literal></entry>
      <entry>包含此页的大对象的标识符</entry>
     </row>

     <row>
      <entry><structfield>pageno</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>此页在它所属大对象中的页号（从0开始计）</entry>
     </row>

     <row>
      <entry><structfield>data</structfield></entry>
      <entry><type>bytea</type></entry>
      <entry></entry>
      <entry>
       实际存储在大对象中的数据。它从不会超过<symbol>LOBLKSIZE</>字节，也可能更少。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_largeobject</structname>的每一行保存一个大对象的一个页的数据，从对象内部的字节偏移量（<literal>pageno * LOBLKSIZE</>）开始。现在的实现允许稀疏存储：页面可能丢失，并且可能比<literal>LOBLKSIZE</>字节短（即便不是最后一页）。一个大对象中丢失的区域会被读出为0。
  </para>

 </sect1>

 <sect1 id="catalog-pg-largeobject-metadata">
  <title><structname>pg_largeobject_metadata</structname></title>

  <indexterm zone="catalog-pg-largeobject-metadata">
   <primary>pg_largeobject_metadata</primary>
  </indexterm>

  <para>
   目录<structname>pg_largeobject_metadata</structname>保持着与大对象有关的元数据。真正的大对象数据被存储在<link linkend="catalog-pg-largeobject"><structname>pg_largeobject</></link>中。
  </para>

  <table>
   <title><structname>pg_largeobject_metadata</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符（隐藏属性，必须被显式选择才会显示）</entry>
     </row>

     <row>
      <entry><structfield>lomowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>大对象的拥有者</entry>
     </row>

     <row>
      <entry><structfield>lomacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       访问权限，详见<xref linkend="sql-grant">和<xref linkend="sql-revoke">
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-namespace">
  <title><structname>pg_namespace</structname></title>

  <indexterm zone="catalog-pg-namespace">
   <primary>pg_namespace</primary>
  </indexterm>

  <para>
   目录<structname>pg_namespace</>存储名字空间。名字空间是SQL模式之下的结构：每个名字空间拥有一个独立的表、类型等的集合，且其中没有名字冲突。
  </para>

  <table>
   <title><structname>pg_namespace</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符（隐藏属性，必须被显式选择才会显示）</entry>
     </row>

     <row>
      <entry><structfield>nspname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>名字空间的名字</entry>
     </row>

     <row>
      <entry><structfield>nspowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>名字空间的拥有者</entry>
     </row>

     <row>
      <entry><structfield>nspacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       访问权限，详见<xref linkend="sql-grant">和<xref linkend="sql-revoke">
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-opclass">
  <title><structname>pg_opclass</structname></title>

  <indexterm zone="catalog-pg-opclass">
   <primary>pg_opclass</primary>
  </indexterm>

  <para>
   目录<structname>pg_opclass</structname>定义索引访问方法的操作符类。每一个操作符类定义了一种特定数据类型和一种特定索引访问方法的索引列的语义。一个操作符类实际上指定了一个特定的操作符族可以用于一个特定可索引列数据类型。该族中可用于索引列的操作符能够接受该列的数据类型作为它们的左输入。
  </para>

  <para>
   操作符类详见<xref linkend="xindex">。
  </para>

  <table>
   <title><structname>pg_opclass</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符（隐藏属性，必须被显式选择才会显示）</entry>
     </row>

     <row>
      <entry><structfield>opcmethod</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-am"><structname>pg_am</structname></link>.oid</literal></entry>
      <entry>操作符类所属的索引访问方法</entry>
     </row>

     <row>
      <entry><structfield>opcname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>操作符类的名称</entry>
     </row>

     <row>
      <entry><structfield>opcnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>操作符类所属的名字空间</entry>
     </row>

     <row>
      <entry><structfield>opcowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>操作符类的拥有者</entry>
     </row>

     <row>
      <entry><structfield>opcfamily</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>.oid</literal></entry>
      <entry>包含此操作符类的操作符族</entry>
     </row>

     <row>
      <entry><structfield>opcintype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>操作符类索引的数据类型</entry>
     </row>

     <row>
      <entry><structfield>opcdefault</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>如果此操作符类为<structfield>opcintype</>的默认值则为真</entry>
     </row>

     <row>
      <entry><structfield>opckeytype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>存储在索引中的数据的类型，如果值为0表示与<structfield>opcintype</>相同</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   一个操作符类的<structfield>opcmethod</>必须匹配包含它的操作符族的<structname>opfmethod</>。而且，对于任何给定的<structname>opcmethod</>和<structname>opcintype</>组合，只有不超过一个<structname>pg_opclass</structname>行的<structname>opcdefault</>值为真。
  </para>

 </sect1>


 <sect1 id="catalog-pg-operator">
  <title><structname>pg_operator</structname></title>

  <indexterm zone="catalog-pg-operator">
   <primary>pg_operator</primary>
  </indexterm>

  <para>
   目录<structname>pg_operator</>存储关于操作符的信息。详见<xref linkend="sql-createoperator">和<xref linkend="xoper">。
  </para>

  <table>
   <title><structname>pg_operator</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符（隐藏属性，必须被显式选择才会显示）</entry>
     </row>

     <row>
      <entry><structfield>oprname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>操作符的名称</entry>
     </row>

     <row>
      <entry><structfield>oprnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       操作符所属的名字空间的OID
      </entry>
     </row>

     <row>
      <entry><structfield>oprowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>操作符的拥有者</entry>
     </row>

     <row>
      <entry><structfield>oprkind</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <literal>b</> = 中缀 (<quote>并</quote>), <literal>l</> = 前缀
       (<quote>左</quote>), <literal>r</> = 后缀 (<quote>右</quote>)
      </entry>
     </row>

     <row>
      <entry><structfield>oprcanmerge</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>该操作符是否支持归并连接</entry>
     </row>

     <row>
      <entry><structfield>oprcanhash</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>该操作符是否支持哈希连接</entry>
     </row>

     <row>
      <entry><structfield>oprleft</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>左操作数类型</entry>
     </row>

     <row>
      <entry><structfield>oprright</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>右操作数类型</entry>
     </row>

     <row>
      <entry><structfield>oprresult</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>结果类型</entry>
     </row>

     <row>
      <entry><structfield>oprcom</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>该操作符的交换子（如果存在）</entry>
     </row>

     <row>
      <entry><structfield>oprnegate</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>该操作符的否定（如果存在）</entry>
     </row>

     <row>
      <entry><structfield>oprcode</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>实现该操作符的函数</entry>
     </row>

     <row>
      <entry><structfield>oprrest</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>该操作符的限制选择度估算函数</entry>
     </row>

     <row>
      <entry><structfield>oprjoin</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>该操作符的连接选择度估算函数</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   未用的列包含零值。例如，一个前缀操作符的<structfield>oprleft</structfield>为0。
  </para>

 </sect1>


 <sect1 id="catalog-pg-opfamily">
  <title><structname>pg_opfamily</structname></title>

  <indexterm zone="catalog-pg-opfamily">
   <primary>pg_opfamily</primary>
  </indexterm>

  <para>
   目录<structname>pg_opfamily</structname>定义了操作符族。每一个操作符族是操作符和相关支持例程的集合，支持例程用于实现一个特定索引访问方法的语义。此外，按照访问方法指定的某种方式，一个族内的操作符都是<quote>兼容的</>。操作符族概念允许在索引中使用跨数据类型操作符，并可以使用访问方法语义的知识推导出。
  </para>

  <para>
   操作符族最终在<xref linkend="xindex">中描述。
  </para>

  <table>
   <title><structname>pg_opfamily</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符（隐藏属性，必须被显式选择才会显示）</entry>
     </row>

     <row>
      <entry><structfield>opfmethod</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-am"><structname>pg_am</structname></link>.oid</literal></entry>
      <entry>操作符族适用的索引访问方法</entry>
     </row>

     <row>
      <entry><structfield>opfname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>操作符族的名字</entry>
     </row>

     <row>
      <entry><structfield>opfnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>操作符族所属的名字空间</entry>
     </row>

     <row>
      <entry><structfield>opfowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>操作符族的拥有者</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   定义操作符族的主要信息不在它的<structname>pg_opfamily</structname>行，而是在相关的<link linkend="catalog-pg-amop"><structname>pg_amop</structname></link>、<link linkend="catalog-pg-amproc"><structname>pg_amproc</structname></link>和<link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>行中。
  </para>

 </sect1>


 <sect1 id="catalog-pg-pltemplate">
  <title><structname>pg_pltemplate</structname></title>

  <indexterm zone="catalog-pg-pltemplate">
   <primary>pg_pltemplate</primary>
  </indexterm>

  <para>
   目录<structname>pg_pltemplate</structname>存储了过程语言的<quote>模板</>信息。一个语言的模板允许我们在一个特定数据库中以一个简单的<command>CREATE LANGUAGE</>命令创建语言，而不需要指定实现细节。
  </para>

  <para>
   和大部分系统目录不同，<structname>pg_pltemplate</structname>是在集簇的所有数据库之间共享的：在一个集簇中只有一份<structname>pg_pltemplate</structname>拷贝，而不是每个数据库一份。这使得在每个需要的数据库中都可以访问该信息。
  </para>

  <table>
   <title><structname>pg_pltemplate</>的列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>tmplname</structfield></entry>
      <entry><type>name</type></entry>
      <entry>该模板适用的语言名字</entry>
     </row>

     <row>
      <entry><structfield>tmpltrusted</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>如果语言被认为是可信的则为真</entry>
     </row>

     <row>
      <entry><structfield>tmpldbacreate</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>如果语言可以被一个数据库拥有者创建则为真</entry>
     </row>

     <row>
      <entry><structfield>tmplhandler</structfield></entry>
      <entry><type>text</type></entry>
      <entry>调用处理函数的名字</entry>
     </row>

     <row>
      <entry><structfield>tmplinline</structfield></entry>
      <entry><type>text</type></entry>
      <entry>匿名阻塞处理函数的名字，如果没有则为空</entry>
     </row>

     <row>
      <entry><structfield>tmplvalidator</structfield></entry>
      <entry><type>text</type></entry>
      <entry>验证函数的名字，如果没有则为空</entry>
     </row>

     <row>
      <entry><structfield>tmpllibrary</structfield></entry>
      <entry><type>text</type></entry>
      <entry>实现语言的共享库的路径</entry>
     </row>

     <row>
      <entry><structfield>tmplacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry>模板的访问权限（并未真正使用）</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   目前任何命令都不能操纵过程语言模板。要改变内建信息，超级用户必须使用普通的<command>INSERT</command>、<command>DELETE</command>或<command>UPDATE</command>命令修改该表。
  </para>

  <note>
   <para>
    在<productname>PostgreSQL</productname>的某个未来版本的发布中，<structname>pg_pltemplate</>很有可能会被移除，而这些关于过程语言的知识可能会保持在它们相应的扩展安装脚本中。
   </para>
  </note>

 </sect1>


 <sect1 id="catalog-pg-proc">
  <title><structname>pg_proc</structname></title>

  <indexterm zone="catalog-pg-proc">
   <primary>pg_proc</primary>
  </indexterm>

  <para>
   目录<structname>pg_proc</>存储关于函数（或过程）的信息。详见<xref linkend="sql-createfunction">和<xref linkend="xfunc">。
  </para>

  <para>
   该表也包含了聚集函数的数据。如果<structfield>proisagg</structfield>为真，在<structfield>pg_aggregate</structfield>中应该有一个相匹配的行。
  </para>

  <table>
   <title><structname>pg_proc</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符（隐藏属性，必须被显式选择才会显示）</entry>
     </row>

     <row>
      <entry><structfield>proname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>函数的名字</entry>
     </row>

     <row>
      <entry><structfield>pronamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       函数所属的名字空间的OID
      </entry>
     </row>

     <row>
      <entry><structfield>proowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>函数的拥有者</entry>
     </row>

     <row>
      <entry><structfield>prolang</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-language"><structname>pg_language</structname></link>.oid</literal></entry>
      <entry>实现语言或该函数的调用接口</entry>
     </row>

     <row>
      <entry><structfield>procost</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>估计的执行代价（以<xref linkend="guc-cpu-operator-cost">为单位），如果<structfield>proretset</>为真，这是每行返回的代价</entry>
     </row>

     <row>
      <entry><structfield>prorows</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>估计的结果行数量（如果<structfield>proretset</>为假，该值为0）</entry>
     </row>

     <row>
      <entry><structfield>provariadic</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>可变数组参数的元素的数据类型，如果函数没有可变参数则为0</entry>
     </row>

     <row>
      <entry><structfield>protransform</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>调用该函数时可以通过此列指定的函数来简化（见<xref linkend="xfunc-transform-functions">）</entry>
     </row>

     <row>
      <entry><structfield>proisagg</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>函数是否为一个聚集函数</entry>
     </row>

     <row>
      <entry><structfield>proiswindow</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>函数是否为一个窗口函数</entry>
     </row>

     <row>
      <entry><structfield>prosecdef</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>函数是一个安全性定义者（即，一个<quote>setuid</>函数）</entry>
     </row>

     <row>
      <entry><structfield>proleakproof</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       该函数没有副作用。除了通过返回值，没有关于参数的信息被传播。任何会抛出基于其参数值的错误信息的函数都不是泄露验证的。
      </entry>
     </row>

     <row>
      <entry><structfield>proisstrict</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       当任意调用函数为空时，函数是否会返回空值。在那种情况下函数实际上根本不会被调用。非<quote>strict</quote>函数必须准备好处理空值输入。
      </entry>
     </row>

     <row>
      <entry><structfield>proretset</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>函数是否返回一个集合（即，指定数据类型的多个值）</entry>
     </row>

     <row>
      <entry><structfield>provolatile</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <structfield>provolatile</structfield>说明函数是仅仅只依赖于它的输入参数，还是会被外部因素影响。值<literal>i</literal>表示<quote>不变的</>函数，它对于相同的输入总是输出相同的结果。值<literal>s</literal>表示<quote>稳定的</>函数，它的结果（对于固定输入）在一次扫描内不会变化。值<literal>v</literal>表示<quote>不稳定的</>函数，它的结果在任何时候都可能变化（使用<literal>v</literal>页表示函数具有副作用，所以对它们的调用无法得到优化）
      </entry>
     </row>

     <row>
      <entry><structfield>pronargs</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>输入参数的个数</entry>
     </row>

     <row>
      <entry><structfield>pronargdefaults</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>具有默认值的参数个数</entry>
     </row>

     <row>
      <entry><structfield>prorettype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>返回值的数据类型</entry>
     </row>

     <row>
      <entry><structfield>proargtypes</structfield></entry>
      <entry><type>oidvector</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       一个函数参数的数据类型的数组。这只包括输入参数（含<literal>INOUT</literal>和<literal>VARIADIC</>参数），因此也表现了函数的调用特征。
      </entry>
     </row>

     <row>
      <entry><structfield>proallargtypes</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       一个函数参数的数据类型的数组。这包括所有参数（含<literal>OUT</literal>和<literal>INOUT</literal>参数）。但是，如果所有参数都是<literal>IN</literal>参数，这个域将为空。注意下标是从1开始 ，然而由于历史原因<structfield>proargtypes</>的下标是从0开始。
      </entry>
     </row>

     <row>
      <entry><structfield>proargmodes</structfield></entry>
      <entry><type>char[]</type></entry>
      <entry></entry>
      <entry>
        一个函数参数的模式的数组。编码为：
        <literal>i</literal>表示<literal>IN</>参数 ，
        <literal>o</literal>表示<literal>OUT</>参数，
        <literal>b</literal>表示<literal>INOUT</>参数，
        <literal>v</literal>表示<literal>VARIADIC</>参数，
        <literal>t</literal>表示<literal>TABLE</>参数。
        如果所有的参数都是<literal>IN</literal>参数，这个域为空。注意这里的下标对应着<structfield>proallargtypes</>而不是<structfield>proargtypes</>中的位置。
      </entry>
     </row>

     <row>
      <entry><structfield>proargnames</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
        一个函数参数的名字的数组。没有名字的参数在数组中设置为空字符串。如果没有一个参数有名字，这个域为空。注意这里的下标对应着<structfield>proallargtypes</>而不是<structfield>proargtypes</>中的位置。
      </entry>
     </row>

     <row>
      <entry><structfield>proargdefaults</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>
       默认值的表达式树（按照<function>nodeToString()</function>的表现方式）。这是一个<structfield>pronargdefaults</>元素的列表，对应于最后<replaceable>N</>个<emphasis>input</>参数（即最后<replaceable>N</>个<structfield>proargtypes</>位置）。如果没有一个参数具有默认值，这个域为空。
      </entry>
     </row>

     <row>
      <entry><structfield>prosrc</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       这个域告诉函数处理者如何调用该函数。它可能是针对解释型语言的真实源码、一个符号链接、一个文件名或任何其他东西，这取决于实现语言/调用习惯。
      </entry>
     </row>

     <row>
      <entry><structfield>probin</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       关于如何调用函数的附加信息。其解释是与语言相关的。
      </entry>
     </row>

     <row>
      <entry><structfield>proconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>函数对于运行时配置变量的本地设置值</entry>
     </row>

     <row>
      <entry><structfield>proacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       访问权限，详见<xref linkend="sql-grant">和<xref linkend="sql-revoke">
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   对于编译好的函数，包括内建的和动态载入的，<structfield>prosrc</structfield>包含了函数的C语言名字（链接符号）。对于所有其他已知的语言类型，<structfield>prosrc</structfield>包含函数的源码文本。除了对于动态载入的C函数之外，<structfield>probin</structfield>是不被使用的。对于动态载入的C函数，它给定了包含该函数的共享库文件的名称。
  </para>

 </sect1>

 <sect1 id="catalog-pg-range">
  <title><structname>pg_range</structname></title>

  <indexterm zone="catalog-pg-range">
   <primary>pg_range</primary>
  </indexterm>

  <para>
   目录<structname>pg_range</structname>存储关于范围类型的信息。它是类型在<link linkend="catalog-pg-type"><structname>pg_type</structname></link>中项的补充。
  </para>

  <table>
   <title><structname>pg_range</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>rngtypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>范围类型的OID</entry>
     </row>

     <row>
      <entry><structfield>rngsubtype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>该范围类型的元素类型（子类型）的OID</entry>
     </row>

     <row>
      <entry><structfield>rngcollation</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-collation"><structname>pg_collation</structname></link>.oid</literal></entry>
      <entry>用于范围比较的排序规则的OID，如果没有则为0</entry>
     </row>

     <row>
      <entry><structfield>rngsubopc</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.oid</literal></entry>
      <entry>用于范围比较的子类型的操作符类的OID</entry>
     </row>

     <row>
      <entry><structfield>rngcanonical</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>将一个范围值转换为规范形式的函数的OID，如果没有则为0</entry>
     </row>

     <row>
      <entry><structfield>rngsubdiff</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>以<type>双精度</type>返回两个元素值不同的函数的OID，如果没有则为0</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   <structfield>rngsubopc</> （加上<structfield>rngcollation</>，如果元素类型是可排序的）决定了被该范围类型所使用的排序顺序。<structfield>rngcanonical</>用于离散类型的元素类型。<structfield>rngsubdiff</>是可选的，但是提供它可以提高范围类型上的GiST索引性能。
  </para>

 </sect1>

 <sect1 id="catalog-pg-rewrite">
  <title><structname>pg_rewrite</structname></title>

  <indexterm zone="catalog-pg-rewrite">
   <primary>pg_rewrite</primary>
  </indexterm>

  <para>
   目录<structname>pg_rewrite</structname>存储对于表和视图的重写规则。
  </para>

  <table>
   <title><structname>pg_rewrite</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符（隐藏属性，必须被显式选择才会显示）</entry>
     </row>

     <row>
      <entry><structfield>rulename</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>规则名称</entry>
     </row>

     <row>
      <entry><structfield>ev_class</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>使用该规则的表</entry>
     </row>

     <row>
      <entry><structfield>ev_type</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       使用该规则的事件类型：1 = <command>SELECT</>，2 =
       <command>UPDATE</>，3 = <command>INSERT</>，4 =
       <command>DELETE</>
      </entry>
     </row>

     <row>
      <entry><structfield>ev_enabled</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       控制在哪种<xref linkend="guc-session-replication-role">模式中触发该规则。
       <literal>O</> = 规则在<quote>origin</>和<quote>local</>模式触发，
       <literal>D</> = 规则被禁用，
       <literal>R</> = 规则在<quote>replica</>模式触发，
       <literal>A</> = 规则总是被触发。
      </entry>
     </row>

     <row>
      <entry><structfield>is_instead</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>为真表示是一个<literal>INSTEAD</literal>规则</entry>
     </row>

     <row>
      <entry><structfield>ev_qual</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>
       规则条件的表达式树（按照<function>nodeToString()</function>的表现形式）
      </entry>
     </row>

     <row>
      <entry><structfield>ev_action</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>
       规则动作的查询树（按照<function>nodeToString()</function>的表现形式）
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <para>
    如果一个表在这个目录中有任何规则，<literal>pg_class.relhasrules</literal>必须为真。
   </para>
  </note>

 </sect1>

 <sect1 id="catalog-pg-replication-slots">
  <title><structname>pg_replication_slots</structname></title>

  <indexterm zone="catalog-pg-replication-slots">
   <primary>pg_replication_slots</primary>
  </indexterm>

  <para>
   <structname>pg_replication_slots</structname>视图提供了当前存在于数据库集簇上的所
   有复制槽的列表，其中也包括复制槽的当前状态。
  </para>

  <para>
   更多关于复制槽的信息，请见
   <xref linkend="streaming-replication-slots">和<xref linkend="logicaldecoding">。
  </para>

  <table>

   <title><structname>pg_replication_slots</structname>列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>slot_name</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>一个唯一的、集簇范围内的复制槽标识符</entry>
     </row>

     <row>
      <entry><structfield>plugin</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>包含这个逻辑槽正在使用的输出插件的共享对象基础名称，这个列对于物理槽为空值。</entry>
     </row>

     <row>
      <entry><structfield>slot_type</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>槽类型 - <literal>physical</>（物理）或者<literal>logical</>（逻辑）</entry>
     </row>

     <row>
      <entry><structfield>datoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <entry>与这个槽相关的数据库的OID，或者为空值。只有逻辑槽具有相关的数据库。</entry>
     </row>

     <row>
      <entry><structfield>database</structfield></entry>
      <entry><type>text</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.datname</literal></entry>
      <entry>与这个槽相关的数据库的名称，或者为空值。只有逻辑槽具有相关的数据库。</entry>
     </row>

     <row>
      <entry><structfield>active</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry></entry>
      <entry>如果这个槽当前正在被使用则为真</entry>
     </row>

     <row>
      <entry><structfield>xmin</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>这个槽要需要数据库保留的最旧事务。
      <literal>VACUUM</literal>不能移除被其后续事务删除的元组。
      </entry>
     </row>

     <row>
      <entry><structfield>catalog_xmin</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>这个槽要需要数据库保留的影响系统目录的最旧事务。
      <literal>VACUUM</literal>不能移除被其后续事务删除的目录元组。
      </entry>
     </row>

     <row>
      <entry><structfield>restart_lsn</structfield></entry>
      <entry><type>pg_lsn</type></entry>
      <entry></entry>
      <entry>可能仍被这个槽的消费者要求的最旧WAL地址（<literal>LSN</literal>），
      并且因此不会在检查点期间自动被移除。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-seclabel">
  <title><structname>pg_seclabel</structname></title>

  <indexterm zone="catalog-pg-seclabel">
   <primary>pg_seclabel</primary>
  </indexterm>

  <para>
   目录<structname>pg_seclabel</structname>存储数据库对象上的安全标签。安全标签可以通过<xref linkend="sql-security-label">命令操纵。简单的查看安全标签方法请见<xref linkend="view-pg-seclabels">。
  </para>

  <para>
   同时请见<link linkend="catalog-pg-shseclabel"><structname>pg_shseclabel</structname></link>，它对集簇共享的数据库对象的安全标签执行相似的功能。
  </para>

  <table>
   <title><structname>pg_seclabel</structname>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>any OID column</entry>
      <entry>该安全标签依附的对象的OID</entry>
     </row>

     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>该对象所出现的系统目录的OID</entry>
     </row>

     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       对于一个在表列上的安全标签，这将是列号（<structfield>objoid</>和<structfield>classoid</>指表本身）。对于所有其他对象类型，本列为0。
      </entry>
     </row>

     <row>
      <entry><structfield>provider</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>与该标签相关的标签提供者。</entry>
     </row>

     <row>
      <entry><structfield>label</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>应用于该对象的安全标签。</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-shdepend">
  <title><structname>pg_shdepend</structname></title>

  <indexterm zone="catalog-pg-shdepend">
   <primary>pg_shdepend</primary>
  </indexterm>

  <para>
   目录<structname>pg_shdepend</structname>记录数据库对象和共享对象之间的依赖关系，例如角色。这些信息使得<productname>PostgreSQL</productname>可以确保对象在被删除时没有被其他对象引用。
  </para>

  <para>
   另请参阅<link linkend="catalog-pg-depend"><structname>pg_depend</structname></link>，它对单个数据库中对象之间的依赖提供了相似的功能。  </para>

  <para>
   与大部分其他系统目录不同，<structname>pg_shdepend</structname>在整个集簇的所有数据库之间共享：在每一个集簇中只有一个<structname>pg_shdepend</structname>的拷贝，而不是每个数据库一份。
  </para>

  <table>
   <title><structname>pg_shdepend</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>dbid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <entry>依赖者对象所在的数据库OID，如果是一个共享对象则值为0</entry>
     </row>

     <row>
      <entry><structfield>classid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>依赖者对象所在的系统目录的OID</entry>
     </row>

     <row>
      <entry><structfield>objid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>任意OID列</entry>
      <entry>依赖者对象的OID</entry>
     </row>

     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       对于一个表列，这将是列号（<structfield>objid</>和<structfield>classid</>指向表本身）。对于所有其他对象类型，该列值为0。
      </entry>
     </row>

     <row>
      <entry><structfield>refclassid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>被引用对象所在的系统目录的OID（必须是一个共享的目录）</entry>
     </row>

     <row>
      <entry><structfield>refobjid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>任意OID列</entry>
      <entry>被引用对象的OID</entry>
     </row>

     <row>
      <entry><structfield>deptype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       定义该依赖关系的特定语义的代码，见表后的说明
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   在所有情况下，一个<structname>pg_shdepend</structname>项表明被引用对象不能在没有删除其依赖对象的情况下被删除。但是，其中也有多种依赖类型，由<structfield>deptype</>标识：

   <variablelist>
    <varlistentry>
     <term><symbol>SHARED_DEPENDENCY_OWNER</> (<literal>o</>)</term>
     <listitem>
      <para>
       被引用对象（必须是一个角色）是依赖对象的拥有者。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SHARED_DEPENDENCY_ACL</> (<literal>a</>)</term>
     <listitem>
      <para>
       被引用对象（必须是一个角色）在依赖对象的ACL（访问控制列表，即权限列表）中被提到。 (不会为对象的拥有者创建一个<symbol>SHARED_DEPENDENCY_ACL</>项，因为拥有者将会有一个<symbol>SHARED_DEPENDENCY_OWNER</>项。）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SHARED_DEPENDENCY_PIN</> (<literal>p</>)</term>
     <listitem>
      <para>
       没有依赖对象，这种类型的项是一个信号，用来指示系统本身依赖于被引用对象，并且因此该对象必须永远不能被删除。这种类型的项只能被<command>initdb</command>创建。这种项中关于依赖对象的列值都为0。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   未来可能会需要其他的依赖类型。特别要注意的是在当前定义中只支持角色作为被引用对象。
  </para>

 </sect1>

 <sect1 id="catalog-pg-shdescription">
  <title><structname>pg_shdescription</structname></title>

  <indexterm zone="catalog-pg-shdescription">
   <primary>pg_shdescription</primary>
  </indexterm>

  <para>
   目录<structname>pg_shdescription</structname>存储共享数据库对象的可选描述（注释）。描述可以通过<xref linkend="sql-comment">命令操作，并且可以使用<application>psql</application>的<literal>\d</literal>命令来查看。
  </para>

  <para>
   另请参阅<link linkend="catalog-pg-description"><structname>pg_description</structname></link>，它对单个数据库中对象之间的依赖提供了相似的功能。
  </para>

  <para>
   与大部分其他系统目录不同，<structname>pg_shdescription</structname>在整个集簇的所有数据库之间共享：在每一个集簇中只有一个<structname>pg_shdescription</structname>的拷贝，而不是每个数据库一份。
  </para>

  <table>
   <title><structname>pg_shdescription</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>任意OID列</entry>
      <entry>该描述所属的对象的OID</entry>
     </row>

     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>该对象所在系统目录的OID</entry>
     </row>

     <row>
      <entry><structfield>description</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>作为该对象描述的任意文本</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="catalog-pg-shseclabel">
  <title><structname>pg_shseclabel</structname></title>

  <indexterm zone="catalog-pg-shseclabel">
   <primary>pg_shseclabel</primary>
  </indexterm>

  <para>
   目录<structname>pg_shseclabel</structname>存储共享数据库对象上的安全标签。安全标签可以通过<xref linkend="sql-security-label">命令操纵。更简单的查看安全标签的方式请见<xref linkend="view-pg-seclabels">。
  </para>

  <para>
   另请参阅<link linkend="catalog-pg-seclabel"><structname>pg_seclabel</structname></link>，它对单个数据库中对象的安全标签提供了相似的功能。
  </para>

  <para>
   与大部分其他系统目录不同，<structname>pg_shseclabel</structname>在整个集簇的所有数据库之间共享：在每一个集簇中只有一个<structname>pg_shseclabel</structname>的拷贝，而不是每个数据库一份。
  </para>

  <table>
   <title><structname>pg_shseclabel</structname>的列</title>
   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>任意OID列</entry>
      <entry>该安全标签所属对象的OID</entry>
     </row>
     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>对象所属系统目录的OID</entry>
     </row>
     <row>
      <entry><structfield>provider</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>与此标签关联的标签提供者</entry>
     </row>
     <row>
      <entry><structfield>label</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>应用到该对象的安全标签</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-statistic">
  <title><structname>pg_statistic</structname></title>

  <indexterm zone="catalog-pg-statistic">
   <primary>pg_statistic</primary>
  </indexterm>

  <para>
   目录<structname>pg_statistic</structname>存储关于数据库内容的统计数据。其中的项由<xref linkend="sql-analyze">创建，并随后由查询规划器使用。注意所有的统计数据生来就是近似的，即使它刚刚被更新。
  </para>

  <para>
   通常对于一个已经被分析过的表列，在本目录中存在一个<structfield>stainherit</> = <literal>false</>的项。如果该表具有继承的后代，第二个具有<structfield>stainherit</> = <literal>true</>的项也会被创建。该行表示列在继承树上的统计数据，即在<literal>SELECT <replaceable>column</> FROM <replaceable>table</>*</literal>中看到的统计数据，而<structfield>stainherit</> = <literal>false</>的行表示<literal>SELECT <replaceable>column</> FROM ONLY <replaceable>table</></literal>的结果。
  </para>

  <para>
   <structname>pg_statistic</structname>也存储关于索引表达式值的统计数据，就好像它们是真正的数据列，但在这种情况中<structfield>starelid</structfield>指索引。对一个普通非表达式索引列不会创建项，因为它将是底层表列的项的冗余。当前，索引表达式的项都具有<structfield>stainherit</> = <literal>false</>。
  </para>

  <para>
   因为不同类型的统计信息适用于不同类型的数据， <structname>pg_statistic</structname> 被设计成不太在意自己存储的是什么类型的统计。 只有极为常用的统计信息（比如NULL的含量）才在<structname>pg_statistic</structname>里给予专用的字段。 其它所有东西都存储在<quote>槽位</quote>中，而槽位是一组相关的列， 它们的内容用槽位中的一个列里的代码表示。 更详细的信息请参阅 <filename>src/include/catalog/pg_statistic.h</filename>。
  </para>

  <para>
   <structname>pg_statistic</structname>不应该是公共可读的，因为即使是一个表内容的统计性信息也可能被认为是敏感的（例子：一个薪水列的最大和最小值可能是非常有趣的）。<link linkend="view-pg-stats"><structname>pg_stats</structname></link>是<structname>pg_statistic</structname>上的一个公共可读的视图，它只会显示出当前用户可读的表的信息。
  </para>

  <table>
   <title><structname>pg_statistic</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>starelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>被描述列所属的表或索引</entry>
     </row>

     <row>
      <entry><structfield>staattnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>被描述列的编号</entry>
     </row>

     <row>
      <entry><structfield>stainherit</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>如果为真，统计包含了继承后代的列而不仅仅是指定关系的列</entry>
     </row>

     <row>
      <entry><structfield>stanullfrac</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>列的项为空的比例</entry>
     </row>

     <row>
      <entry><structfield>stawidth</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>非空项的平均存储宽度，以字节计</entry>
     </row>

     <row>
      <entry><structfield>stadistinct</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>列中非空唯一值的数目。一个大于零的值是唯一值的真正数目。一个小于零的值是表中行数的乘数的负值；例如，值平均出现两次的一个列可以表示为<structfield>stadistinct</> = -0.5。一个0值表示唯一值的数目未知。
      </entry>
     </row>

     <row>
      <entry><structfield>stakind<replaceable>N</></structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       一个代码，它表示存储在该<structname>pg_statistic</structname>行中第<replaceable>N</>个<quote>槽位</quote>的统计类型。
      </entry>
     </row>

     <row>
      <entry><structfield>staop<replaceable>N</></structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>
       一个用于生成这些存储在第<replaceable>N</>个<quote>槽位</quote>的统计信息的操作符。 比如，一个柱面图槽位会用<literal>&lt;</literal>操作符，该操作符定义了该数据的排序顺序。
      </entry>
     </row>

     <row>
      <entry><structfield>stanumbers<replaceable>N</></structfield></entry>
      <entry><type>float4[]</type></entry>
      <entry></entry>
      <entry>
       第<replaceable>N</>个<quote>槽位</quote>的类型的数值类型统计， 如果该槽位不涉及数值类型则为NULL
      </entry>
     </row>

     <row>
      <entry><structfield>stavalues<replaceable>N</></structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>
        第<replaceable>N</>个<quote>槽位</quote>的类型的列值，如果该槽位类型不存储任何数据值则为 NULL。 每个数组的元素值实际上都是指定列的数据类型或者是一个相关类型（如数组元素类型）， 因此，除了把这些列的类型定义成<type>anyarray</>之外别无他法。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-tablespace">
  <title><structname>pg_tablespace</structname></title>

  <indexterm zone="catalog-pg-tablespace">
   <primary>pg_tablespace</primary>
  </indexterm>

  <para>
   目录<structname>pg_tablespace</structname>存储关于可用表空间的信息。表可以被放置在特定表空间中以实现磁盘布局的管理。
  </para>

  <para>
   与大部分其他系统目录不同，<structname>pg_tablespace</structname>在整个集簇的所有数据库之间共享：在每一个集簇中只有一个<structname>pg_tablespace</structname>的拷贝，而不是每个数据库一份。
  </para>

  <table>
   <title><structname>pg_tablespace</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符（隐藏属性，必须被显式选择才会显示）</entry>
     </row>

     <row>
      <entry><structfield>spcname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>表空间名</entry>
     </row>

     <row>
      <entry><structfield>spcowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>表空间的拥有者，通常是创建它的用户</entry>
     </row>

     <row>
      <entry><structfield>spcacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       访问权限，详见<xref linkend="sql-grant">和<xref linkend="sql-revoke">
      </entry>
     </row>

     <row>
      <entry><structfield>spcoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       表空间级别的选项，形如<quote>keyword=value</>的字符串
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-trigger">
  <title><structname>pg_trigger</structname></title>

  <indexterm zone="catalog-pg-trigger">
   <primary>pg_trigger</primary>
  </indexterm>

  <para>
   目录<structname>pg_trigger</structname>存储表和视图上的触发器。详见<xref linkend="sql-createtrigger">。
  </para>

  <table>
   <title><structname>pg_trigger</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符（隐藏属性，必须被显式选择才会显示）</entry>
     </row>

     <row>
      <entry><structfield>tgrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>触发器所在的表</entry>
     </row>

     <row>
      <entry><structfield>tgname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>触发器名（在同一个表的触发器中必须唯一）</entry>
     </row>

     <row>
      <entry><structfield>tgfoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>要被触发器调用的函数</entry>
     </row>

     <row>
      <entry><structfield>tgtype</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>触发器触发条件的位掩码</entry>
     </row>

     <row>
      <entry><structfield>tgenabled</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       控制触发器在<xref linkend="guc-session-replication-role">模式中的触发。
       <literal>O</> = 触发器在<quote>origin</>和<quote>local</>模式触发，
       <literal>D</> = 触发器被禁用，
       <literal>R</> = 触发器在<quote>replica</>模式触发，
       <literal>A</> = 触发器总是触发。
      </entry>
     </row>

     <row>
      <entry><structfield>tgisinternal</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>为真表示触发器是内部生成的（通常是为了强制由<structfield>tgconstraint</>指定的约束）</entry>
     </row>

     <row>
      <entry><structfield>tgconstrrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>被一个引用完整性约束引用的表</entry>
     </row>

     <row>
      <entry><structfield>tgconstrindid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>支持一个唯一、主键、引用完整性约束或者排除约束的索引</entry>
     </row>

     <row>
      <entry><structfield>tgconstraint</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-constraint"><structname>pg_constraint</structname></link>.oid</literal></entry>
      <entry>可能存在的与触发器相关的<structname>pg_constraint</>项</entry>
     </row>

     <row>
      <entry><structfield>tgdeferrable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>如果约束触发器可推迟则为真</entry>
     </row>

     <row>
      <entry><structfield>tginitdeferred</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>如果约束触发器初始可推迟则为真</entry>
     </row>

     <row>
      <entry><structfield>tgnargs</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>传递给触发器函数的参数字符串个数</entry>
     </row>

     <row>
      <entry><structfield>tgattr</structfield></entry>
      <entry><type>int2vector</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>如果触发器是列限定的，这里存放列号；否则这是一个空数组</entry>
     </row>

     <row>
      <entry><structfield>tgargs</structfield></entry>
      <entry><type>bytea</type></entry>
      <entry></entry>
      <entry>传递给触发器的参数字符串，每一个都以NULL结尾</entry>
     </row>

     <row>
      <entry><structfield>tgqual</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>触发器<literal>WHEN</>条件的表达式树（以<function>nodeToString()</function>的表现形式），如果没有则为空</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   当前，列限定触发器只被<literal>UPDATE</>事件支持，因此<structfield>tgattr</>只用于这种事件类型。<structfield>tgtype</structfield>页可以包含用于其他事件类型的位，但其他事件类型是表范围的触发器且会忽略<structfield>tgattr</>。
  </para>

  <note>
   <para>
    当<structfield>tgconstraint</>非零时，<structfield>tgconstrrelid</>、<structfield>tgconstrindid</>、<structfield>tgdeferrable</>和<structfield>tginitdeferred</>与被引用的<structname>pg_constraint</>项有很大的冗余。但是，存在将一个不可延迟触发器关联到一个可延迟约束的可能性：外键约束可以有一些可延迟和一些不可延迟触发器。
   </para>
  </note>

  <note>
   <para>
    如果一个关系在本目录中拥有任何触发器，其<literal>pg_class.relhastriggers</literal>必须为真。
   </para>
  </note>

 </sect1>


 <sect1 id="catalog-pg-ts-config">
  <title><structname>pg_ts_config</structname></title>

  <indexterm zone="catalog-pg-ts-config">
   <primary>pg_ts_config</primary>
  </indexterm>

  <para>
   <structname>pg_ts_config</structname>目录包含表示文本搜索配置的选项。一个配置指定了一个特定的文本搜索分析器和一个用于分析器输出记号的字典列表。分析器由<structname>pg_ts_config</structname>项展现，而记号到字典的映射则由<link
   linkend="catalog-pg-ts-config-map"><structname>pg_ts_config_map</structname></link>中的辅助项定义。
  </para>

  <para>
   <productname>PostgreSQL</productname>的文本搜索特性在<xref linkend="textsearch">中有更详尽的描述。
  </para>

  <table>
   <title><structname>pg_ts_config</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符（隐藏属性，必须被显式选择才会显示）</entry>
     </row>

     <row>
      <entry><structfield>cfgname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>文本搜索配置名</entry>
     </row>

     <row>
      <entry><structfield>cfgnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       包含该配置的名字空间的OID
      </entry>
     </row>

     <row>
      <entry><structfield>cfgowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>配置的拥有者</entry>
     </row>

     <row>
      <entry><structfield>cfgparser</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-ts-parser"><structname>pg_ts_parser</structname></link>.oid</literal></entry>
      <entry>该配置的文本搜索分析器的OID</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-ts-config-map">
  <title><structname>pg_ts_config_map</structname></title>

  <indexterm zone="catalog-pg-ts-config-map">
   <primary>pg_ts_config_map</primary>
  </indexterm>

  <para>
   <structname>pg_ts_config_map</structname>目录包含的项展示了对于每一个文本搜索配置的每一种输出记号类型，有哪些文本搜索字典可供查询以及以何种顺序。
  </para>

  <para>
   <productname>PostgreSQL</productname>的文本搜索特性在<xref linkend="textsearch">中有更详尽的描述。
  </para>

  <table>
   <title><structname>pg_ts_config_map</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>mapcfg</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-ts-config"><structname>pg_ts_config</structname></link>.oid</literal></entry>
      <entry>拥有该映射项的<structname>pg_ts_config</>项的OID</entry>
     </row>

     <row>
      <entry><structfield>maptokentype</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>一种由配置的分析器送出的记号类型</entry>
     </row>

     <row>
      <entry><structfield>mapseqno</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>查询该项的顺序（<structfield>mapseqno</>值小的优先）</entry>
     </row>

     <row>
      <entry><structfield>mapdict</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-ts-dict"><structname>pg_ts_dict</structname></link>.oid</literal></entry>
      <entry>查询的文本搜索字典的OID</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-ts-dict">
  <title><structname>pg_ts_dict</structname></title>

  <indexterm zone="catalog-pg-ts-dict">
   <primary>pg_ts_dict</primary>
  </indexterm>

  <para>
   <structname>pg_ts_dict</structname>目录包含定义文本搜索字典的项。一个字典依赖于一个文本搜索模板，它指定了所有需要的函数实现，字典本身则为模板支持的用户可设置参数提供值。这种分工允许无权限的用户创建字典。参数由一个文本串<structfield>dictinitoption</>定义，其格式和意义随着模板而变化。
  </para>

  <para>
   <productname>PostgreSQL</productname>的文本搜索特性在<xref linkend="textsearch">中有更详尽的描述。
  </para>

  <table>
   <title><structname>pg_ts_dict</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符（隐藏属性，必须被显式选择才会显示）</entry>
     </row>

     <row>
      <entry><structfield>dictname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>文本搜索字典名</entry>
     </row>

     <row>
      <entry><structfield>dictnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       包含该字典的名字空间OID
      </entry>
     </row>

     <row>
      <entry><structfield>dictowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>字典的拥有者</entry>
     </row>

     <row>
      <entry><structfield>dicttemplate</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-ts-template"><structname>pg_ts_template</structname></link>.oid</literal></entry>
      <entry>该字典的文本搜索模板的OID</entry>
     </row>

     <row>
      <entry><structfield>dictinitoption</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>模板的初始化选项串</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-ts-parser">
  <title><structname>pg_ts_parser</structname></title>

  <indexterm zone="catalog-pg-ts-parser">
   <primary>pg_ts_parser</primary>
  </indexterm>

  <para>
   <structname>pg_ts_parser</structname>目录包含定义文本搜索分析器的项。一个分析器负责将输入文本分割成词位并为每一个词位分配一个记号类型。由于一个分析器必须用C语言级别的函数实现，创建新分析器的工作只限于数据库的超级用户。
  </para>

  <para>
   <productname>PostgreSQL</productname>的文本搜索特性在<xref linkend="textsearch">中有更详尽的描述。
  </para>

  <table>
   <title><structname>pg_ts_parser</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符（隐藏属性，必须被显式选择才会显示）</entry>
     </row>

     <row>
      <entry><structfield>prsname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>文本搜索分析器的名字</entry>
     </row>

     <row>
      <entry><structfield>prsnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       包含此分析器的名字空间的OID
      </entry>
     </row>

     <row>
      <entry><structfield>prsstart</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>分析器启动函数的OID</entry>
     </row>

     <row>
      <entry><structfield>prstoken</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>分析器的下一记号函数的OID</entry>
     </row>

     <row>
      <entry><structfield>prsend</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>分析器的关闭函数的OID</entry>
     </row>

     <row>
      <entry><structfield>prsheadline</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>分析器的大标题函数的OID</entry>
     </row>

     <row>
      <entry><structfield>prslextype</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>分析器的词汇类型函数的OID</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-ts-template">
  <title><structname>pg_ts_template</structname></title>

  <indexterm zone="catalog-pg-ts-template">
   <primary>pg_ts_template</primary>
  </indexterm>

  <para>
   <structname>pg_ts_template</structname>目录包含定义文本搜索模板的项。一个模板是一类文本搜索字典的实现骨架。由于一个模板必须用C语言级别的函数实现，新模板的创建只限于数据库超级用户。
  </para>

  <para>
   <productname>PostgreSQL</productname>的文本搜索特性在<xref linkend="textsearch">中有更详尽的描述。
  </para>

  <table>
   <title><structname>pg_ts_template</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符（隐藏属性，必须被显式选择才会显示）</entry>
     </row>

     <row>
      <entry><structfield>tmplname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>文本搜索模板的名字</entry>
     </row>

     <row>
      <entry><structfield>tmplnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       包含此模板的名字空间的OID
      </entry>
     </row>

     <row>
      <entry><structfield>tmplinit</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>模板的初始化函数的OID</entry>
     </row>

     <row>
      <entry><structfield>tmpllexize</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>模板的词汇化函数的OID</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-type">
  <title><structname>pg_type</structname></title>

  <indexterm zone="catalog-pg-type">
   <primary>pg_type</primary>
  </indexterm>

  <para>
   目录<structname>pg_type</structname>存储有关数据类型的信息。基类和枚举类型（标度类型）使用<xref linkend="sql-createtype">创建，而域使用<xref linkend="sql-createdomain">创建。数据库中的每一个表都会有一个自动创建的组合类型，用于表示表的行结构。也可以使用<command>CREATE TYPE AS</command>创建组合类型。
  </para>

  <table>
   <title><structname>pg_type</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符（隐藏属性，必须被显式选择才会显示）</entry>
     </row>

     <row>
      <entry><structfield>typname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>数据类型的名字</entry>
     </row>

     <row>
      <entry><structfield>typnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       包含此类型的名字空间的OID
      </entry>
     </row>

     <row>
      <entry><structfield>typowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>类型的拥有者</entry>
     </row>

     <row>
      <entry><structfield>typlen</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       对于一个固定尺寸的类型，<structfield>typlen</structfield>是该类型内部表示的字节数。对于一个变长类型，<structfield>typlen</structfield>为负值。-1表示一个<quote>varlena</>类型（具有长度字），-2表示一个以空值结尾的C字符串。
      </entry>
     </row>

     <row>
      <entry><structfield>typbyval</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <structfield>typbyval</structfield>判断内部例程传递这个类型的数值时是通过传值还是传引用。如果<structfield>typlen</structfield>不是1、2或4（或者在Datum为8字节的机器上为8），因此<structfield>typbyval</structfield>最好是假。变长类型总是传引用。注意即使长度允许传值， <structfield>typbyval</structfield>也可以为假。
      </entry>
     </row>

     <row>
      <entry><structfield>typtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <structfield>typtype</structfield>可以是：
       <literal>b</literal>表示一个基类，
       <literal>c</literal>表示一个组合类型（例如一个表的行类型），
       <literal>d</literal>表示一个域，
       <literal>e</literal>表示一个枚举类型，
       <literal>p</literal>表示一个伪类型，或
       <literal>r</literal>表示一个范围类型。
       另请参阅<structfield>typrelid</structfield>和<structfield>typbasetype</structfield>.
      </entry>
     </row>

     <row>
      <entry><structfield>typcategory</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <structfield>typcategory</structfield>是一种任意的数据类型分类，它被分析器用来决定哪种隐式转换<quote>更好</>。参见<xref linkend="catalog-typcategory-table">。
      </entry>
     </row>

     <row>
      <entry><structfield>typispreferred</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       如果此类型在它的<structfield>typcategory</structfield>中是一个更好的转换目标，此列为真
      </entry>
     </row>

     <row>
      <entry><structfield>typisdefined</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       如果此类型已被定义则为真，如果此类型只是一个表示还未定义类型的占位符则为假。当<structfield>typisdefined</structfield>为假，除了类型名字、名字空间和OID之外什么都不能被依赖。
      </entry>
     </row>

     <row>
      <entry><structfield>typdelim</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       在分析数组输入时，分隔两个此类型值的字符。注意该分隔符是与数组元素数据类型相关联的， 而不是和数组的数据类型关联。
      </entry>
     </row>

     <row>
      <entry><structfield>typrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       如果这是一个复合类型（见<structfield>typtype</structfield>）， 那么这个列指向<structname>pg_class</structname>中定义对应表的项（对于自由存在的复合类型，<structname>pg_class</structname>项并不表示一个表，但不管怎样该类型的<structname>pg_attribute</structname>项需要链接到它）。对非复合类型此列为零。
      </entry>
     </row>

     <row>
      <entry><structfield>typelem</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       如果<structfield>typelem</structfield>不为0，则它标识<structname>pg_type</structname>里面的另外一行。 当前类型可以被加上下标得到一个值为类型<structfield>typelem</structfield>的数组来描述。 一个<quote>真的</quote>数组类型是变长的（<structfield>typlen</structfield> = -1），但是一些定长的（<structfield>typlen</structfield> &gt; 0）类型也拥有非零的<structfield>typelem</structfield>，比如<type>name</type>和<type>point</type>。 如果一个定长类型拥有一个<structfield>typelem</structfield>， 则它的内部形式必须是某个<structfield>typelem</structfield>数据类型的值，不能有其它数据。变长数组类型有一个由该数组子例程定义的头。
      </entry>
     </row>

     <row>
      <entry><structfield>typarray</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       如果<structfield>typarray</structfield>不是0，则它标识<structname>pg_type</structname>中的另一行，这一行是一个将此类型作为元素的<quote>真的</quote>数组类型
      </entry>
     </row>

     <row>
      <entry><structfield>typinput</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>输入转换函数（文本格式）</entry>
     </row>

     <row>
      <entry><structfield>typoutput</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>输出转换函数（文本格式）</entry>
     </row>

     <row>
      <entry><structfield>typreceive</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>输入转换函数（二进制格式），如果没有则为0</entry>
     </row>

     <row>
      <entry><structfield>typsend</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>输出转换函数（二进制格式），如果没有则为0</entry>
     </row>

     <row>
      <entry><structfield>typmodin</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>类型修改器输入函数，如果类型没有提供修改器则为0</entry>
     </row>

     <row>
      <entry><structfield>typmodout</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>类型修改器输出函数，如果类型没有提供修改器则为0</entry>
     </row>

     <row>
      <entry><structfield>typanalyze</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>自定义<command>ANALYZE</command>函数，0表示使用标准函数</entry>
     </row>

     <row>
      <entry><structfield>typalign</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry><para>

       <structfield>typalign</structfield>是当存储此类型值时要求的对齐性质。它应用于磁盘存储以及该值在 <productname>PostgreSQL</>内部的大多数表现形式。 如果数值是连续存放的，比如在磁盘上的一个完整行，在这种类型的数据前会插入填充，这样它就可以按照指定边界存储。 对齐引用是该序列中第一个数据的开头。对齐引用是序列中第一个数据的开始。
      </para>

      <para>
       可能的值有：
       <itemizedlist>
        <listitem>
         <para><literal>c</> = <type>char</type>对齐，即不需要对齐。</para>
        </listitem>
        <listitem>
         <para><literal>s</> = <type>short</type>对齐（在大部分机器上为2字节）。</para>
        </listitem>
        <listitem>
         <para><literal>i</> = <type>int</type>对齐（在大部分机器上为4字节）。</para>
        </listitem>
        <listitem>
         <para><literal>d</> = <type>double</type>对齐（在很多机器上为8字节，但绝不是全部）。</para>
        </listitem>
       </itemizedlist>
      </para><note>
       <para>
        对于系统表中使用的类型，很关键的是，<structname>pg_type</structname>中定义的尺寸和对齐方式要和编译器在表示表行的结构中布局列的方式保持一致。
       </para>
      </note></entry>
     </row>

     <row>
      <entry><structfield>typstorage</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry><para>
       如果一个变长类型（<structfield>typlen</structfield> = -1）可被TOAST，<structfield>typstorage</structfield>说明这种类型的列应采取的默认策略。可能的值是：
       <itemizedlist>
        <listitem>
         <para><literal>p</>：值必须平面存储。</para>
        </listitem>
        <listitem>
         <para>
          <literal>e</>：值可以被存储在一个<quote>二级</quote>关系（如果有，见<literal>pg_class.reltoastrelid</literal>）。
         </para>
        </listitem>
        <listitem>
         <para><literal>m</>：值可以被压缩线内存储。</para>
        </listitem>
        <listitem>
         <para><literal>x</>：值可以被压缩线内存储或存储在<quote>二级</quote>存储。</para>
        </listitem>
       </itemizedlist>
       注意<literal>m</>列也可以被移动到二级存储，但只能是作为最后一种方案（<literal>e</>和<literal>x</>列会先被移动）。
      </para></entry>
     </row>

     <row>
      <entry><structfield>typnotnull</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry><para>
       <structfield>typnotnull</structfield>表示类型上的一个非空约束。只用于域。
      </para></entry>
     </row>

     <row>
      <entry><structfield>typbasetype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry><para>
       如果这是一个域（见<structfield>typtype</structfield>），则<structfield>typbasetype</structfield>标识这个域基于的类。如果此类不是一个域则为0。
      </para></entry>
     </row>

     <row>
      <entry><structfield>typtypmod</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry><para>
       域使用<structfield>typtypmod</structfield>来记录被应用于它们基类型的<literal>typmod</>（如果基类型不使用<literal>typmod</>，则为-1）。如果此类型不是一个域则为-1。
      </para></entry>
     </row>

     <row>
      <entry><structfield>typndims</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry><para>
       对于一个数组上的域，<structfield>typndims</structfield>是数组维度数（即，<structfield>typbasetype</>是一个数组类型）。除数组类型上的域之外的类型的此列为0。
       </para></entry>
     </row>

     <row>
      <entry><structfield>typcollation</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-collation"><structname>pg_collation</structname></link>.oid</literal></entry>
      <entry><para>
       <structfield>typcollation</structfield>指定此类型的排序规则。如果类型不支持排序规则，此列为0。一个支持排序规则的基类型此列值为<symbol>DEFAULT_COLLATION_OID</symbol>。如果一个可排序类型上的域被指定了一个排序规则，该域可能使用某些其他排序规则OID。
      </para></entry>
     </row>

     <row>
      <entry><structfield>typdefaultbin</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry><para>
       如果<structfield>typdefaultbin</>为非空，那么它是 该类型默认表达式的<function>nodeToString()</function>表现形式。这个列只用于域。
      </para></entry>
     </row>

     <row>
      <entry><structfield>typdefault</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry><para>
       如果某类型没有相关默认值，那么<structfield>typdefault</>为空。如果<structfield>typdefaultbin</>不为空， 那么<structfield>typdefault</>必须包含一个<structfield>typdefaultbin</>所指的默认表达式的人类可读的版本。 如果<structfield>typdefaultbin</>为空但<structfield>typdefault</>不为空，则<structfield>typdefault</>是该类型默认值的外部表现形式， 它可以被交给该类型的输入转换器来产生一个常量。
      </para></entry>
     </row>

     <row>
      <entry><structfield>typacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       访问权限，另请参阅<xref linkend="sql-grant">和<xref linkend="sql-revoke">
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   <xref linkend="catalog-typcategory-table">列出了<structfield>typcategory</>的系统定义值。任何未来对此列表的增加都将是大写ASCII字母。所有其他ASCII字符都保留给用户定义的类别。
  </para>

  <table id="catalog-typcategory-table">
   <title><structfield>typcategory</>编码</title>

   <tgroup cols="2">
    <thead>
     <row>
      <entry>编码</entry>
      <entry>类别</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>A</literal></entry>
      <entry>数组类型</entry>
     </row>
     <row>
      <entry><literal>B</literal></entry>
      <entry>布尔类型</entry>
     </row>
     <row>
      <entry><literal>C</literal></entry>
      <entry>组合类型</entry>
     </row>
     <row>
      <entry><literal>D</literal></entry>
      <entry>日期/时间类型</entry>
     </row>
     <row>
      <entry><literal>E</literal></entry>
      <entry>枚举类型</entry>
     </row>
     <row>
      <entry><literal>G</literal></entry>
      <entry>几何类型</entry>
     </row>
     <row>
      <entry><literal>I</literal></entry>
      <entry>网络地址类型</entry>
     </row>
     <row>
      <entry><literal>N</literal></entry>
      <entry>数字类型</entry>
     </row>
     <row>
      <entry><literal>P</literal></entry>
      <entry>伪类型</entry>
     </row>
     <row>
      <entry><literal>R</literal></entry>
      <entry>范围类型</entry>
     </row>
     <row>
      <entry><literal>S</literal></entry>
      <entry>字符串类型</entry>
     </row>
     <row>
      <entry><literal>T</literal></entry>
      <entry>时间间隔类型</entry>
     </row>
     <row>
      <entry><literal>U</literal></entry>
      <entry>用户定义类型</entry>
     </row>
     <row>
      <entry><literal>V</literal></entry>
      <entry>位串类型</entry>
     </row>
     <row>
      <entry><literal>X</literal></entry>
      <entry><type>位置</>类型</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-user-mapping">
  <title><structname>pg_user_mapping</structname></title>

  <indexterm zone="catalog-pg-user-mapping">
   <primary>pg_user_mapping</primary>
  </indexterm>

  <para>
   目录<structname>pg_user_mapping</structname>存储从本地用户到远程的映射。对这个目录的访问对普通用户有限制，可使用视图<link linkend="view-pg-user-mappings"><structname>pg_user_mappings</structname></link>替代。
  </para>

  <table>
   <title><structname>pg_user_mapping</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符（隐藏属性，必须被显式选择才会显示）</entry>
     </row>

     <row>
      <entry><structfield>umuser</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>将要被映射的本地角色的OID，如果用户映射是公共的则为0</entry>
     </row>

     <row>
      <entry><structfield>umserver</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-foreign-server"><structname>pg_foreign_server</structname></link>.oid</literal></entry>
      <entry>
       包含此映射的外部服务器的OID
      </entry>
     </row>

     <row>
      <entry><structfield>umoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       用户映射相关选项，以<quote>keyword=value</>字符串形式
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="views-overview">
  <title>System Views</title>

  <para>
   除系统目录外，<productname>PostgreSQL</productname>提供了一些内建视图。一些系统视图为系统目录上一些常用查询提供了便利的访问。其他视图提供了对内部服务器状态的访问。
  </para>

  <para>
   信息模式（<xref linkend="information-schema">）提供了一组可供选择的视图，它和系统视图在功能上有所重叠。由于信息模式是SQL标准，而这里描述的视图是<productname>PostgreSQL</productname>特有的，如果信息模式能提供你所需要的信息，通常最好使用它。
  </para>

  <para>
   <xref linkend="view-table">列出了这里描述的系统视图。每一个视图的详细文档都在后文中。还有一些附加视图用于提供对于统计收集器结果的访问，它们在<xref linkend="monitoring-stats-views-table">中描述。
  </para>

  <para>
   除了特别注明的，所有这里描述的视图都是只读的。
  </para>

  <table id="view-table">
   <title>系统视图</title>

   <tgroup cols="2">
    <thead>
     <row>
      <entry>视图名字</entry>
      <entry>用途</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><link linkend="view-pg-available-extensions"><structname>pg_available_extensions</structname></link></entry>
      <entry>可用的扩展</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-available-extension-versions"><structname>pg_available_extension_versions</structname></link></entry>
      <entry>所有版本的扩展</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-cursors"><structname>pg_cursors</structname></link></entry>
      <entry>打开的游标</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-group"><structname>pg_group</structname></link></entry>
      <entry>数据库用户组</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-indexes"><structname>pg_indexes</structname></link></entry>
      <entry>索引</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-locks"><structname>pg_locks</structname></link></entry>
      <entry>当前保持的锁</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-matviews"><structname>pg_matviews</structname></link></entry>
      <entry>物化视图</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-prepared-statements"><structname>pg_prepared_statements</structname></link></entry>
      <entry>预备好的语句</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-prepared-xacts"><structname>pg_prepared_xacts</structname></link></entry>
      <entry>预备好的事务</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-roles"><structname>pg_roles</structname></link></entry>
      <entry>数据库角色</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-rules"><structname>pg_rules</structname></link></entry>
      <entry>规则</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-seclabels"><structname>pg_seclabels</structname></link></entry>
      <entry>安全标签</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-settings"><structname>pg_settings</structname></link></entry>
      <entry>参数设置</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-shadow"><structname>pg_shadow</structname></link></entry>
      <entry>数据库用户</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-stats"><structname>pg_stats</structname></link></entry>
      <entry>规划器统计信息</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-tables"><structname>pg_tables</structname></link></entry>
      <entry>表</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-timezone-abbrevs"><structname>pg_timezone_abbrevs</structname></link></entry>
      <entry>时区简写</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-timezone-names"><structname>pg_timezone_names</structname></link></entry>
      <entry>时区名字</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-user"><structname>pg_user</structname></link></entry>
      <entry>数据库用户</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-user-mappings"><structname>pg_user_mappings</structname></link></entry>
      <entry>用户映射</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-views"><structname>pg_views</structname></link></entry>
      <entry>视图</entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="view-pg-available-extensions">
  <title><structname>pg_available_extensions</structname></title>

  <indexterm zone="view-pg-available-extensions">
   <primary>pg_available_extensions</primary>
  </indexterm>

  <para>
   <structname>pg_available_extensions</structname>视图列出了可用于安装的扩展。参见<link linkend="catalog-pg-extension"><structname>pg_extension</structname></link>目录，它显示当前已安装的扩展。
  </para>

  <table>
   <title><structname>pg_available_extensions</>的列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名字</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>name</type></entry>
      <entry>扩展名</entry>
     </row>

     <row>
      <entry><structfield>default_version</structfield></entry>
      <entry><type>text</type></entry>
      <entry>默认版本的名字，如果没有指定则为<literal>NULL</literal></entry>
     </row>

     <row>
      <entry><structfield>installed_version</structfield></entry>
      <entry><type>text</type></entry>
      <entry>当前已安装的扩展版本，如果没有安装则为<literal>NULL</literal></entry>
     </row>

     <row>
      <entry><structfield>comment</structfield></entry>
      <entry><type>text</type></entry>
      <entry>来自于扩展的控制文件的注释字符串</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_available_extensions</structname>视图是只读的。
  </para>
 </sect1>

 <sect1 id="view-pg-available-extension-versions">
  <title><structname>pg_available_extension_versions</structname></title>

  <indexterm zone="view-pg-available-extension-versions">
   <primary>pg_available_extension_versions</primary>
  </indexterm>

  <para>
   <structname>pg_available_extension_versions</structname>视图列出了可用于安装的指定扩展版本。参见<link linkend="catalog-pg-extension"><structname>pg_extension</structname></link>目录，它显示当前已安装的扩展。
  </para>

  <table>
   <title><structname>pg_available_extension_versions</>的列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名字</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>name</type></entry>
      <entry>扩展名</entry>
     </row>

     <row>
      <entry><structfield>version</structfield></entry>
      <entry><type>text</type></entry>
      <entry>版本名</entry>
     </row>

     <row>
      <entry><structfield>installed</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>如果此版本的扩展当前已安装则为真</entry>
     </row>

     <row>
      <entry><structfield>superuser</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>如果只有超级用户被允许安装此扩展则为真</entry>
     </row>

     <row>
      <entry><structfield>relocatable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>如果扩展能被重定位到另一个模式则为真</entry>
     </row>

     <row>
      <entry><structfield>schema</structfield></entry>
      <entry><type>name</type></entry>
      <entry>此扩展必须被安装到的模式名，如果此扩展是部分或者全部可以重定位的，此列为<literal>NULL</literal></entry>
     </row>

     <row>
      <entry><structfield>requires</structfield></entry>
      <entry><type>name[]</type></entry>
      <entry>先决条件扩展的名字，如果没有则为<literal>NULL</literal></entry>
     </row>

     <row>
      <entry><structfield>comment</structfield></entry>
      <entry><type>text</type></entry>
      <entry>来自于扩展的控制文件的注释字符串</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_available_extension_versions</structname>视图是只读的。
  </para>
 </sect1>

 <sect1 id="view-pg-cursors">
  <title><structname>pg_cursors</structname></title>

  <indexterm zone="view-pg-cursors">
   <primary>pg_cursors</primary>
  </indexterm>

  <para>
   <structname>pg_cursors</structname>视图列出了当前可用的游标。游标可以以几种方式定义：
   <itemizedlist>
    <listitem>
     <para>
      通过SQL中的<xref linkend="sql-declare">语句
     </para>
    </listitem>

    <listitem>
     <para>
      通过前端/后端协议中的绑定消息，如<xref linkend="protocol-flow-ext-query">中所描述的
     </para>
    </listitem>

    <listitem>
     <para>
      通过服务器编程接口（SPI），如<xref linkend="spi-interface">中所描述的
     </para>
    </listitem>
   </itemizedlist>

   <structname>pg_cursors</structname>视图显示由任何这些方式创建的游标。视图只存在于定义它们的事务期间，除非声明了<literal>WITH HOLD</literal>。因此非保持游标只在它们的创建事务结束前存在于这个视图中。

   <note>
    <para>
     视图用于在内部实现<productname>PostgreSQL</>的某些部件，例如过程语言。因此，<structname>pg_cursors</>视图可能包括那些不是由用户显式创建的游标。
    </para>
   </note>
  </para>

  <table>
   <title><structname>pg_cursors</>的列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名字</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <entry>游标名</entry>
     </row>

     <row>
      <entry><structfield>statement</structfield></entry>
      <entry><type>text</type></entry>
      <entry>提交用于定义此游标的查询语句</entry>
     </row>

     <row>
      <entry><structfield>is_holdable</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>
       如果游标是可保持的（即，它可以在其定义事务提交后被访问）则为<literal>真</literal>，否则为<literal>否</literal>
       </entry>
     </row>

     <row>
      <entry><structfield>is_binary</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>
       如果游标被声明为<literal>BINARY</literal>则为<literal>真</literal>，否则为<literal>假</literal>
       </entry>
     </row>

     <row>
      <entry><structfield>is_scrollable</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>
       如果游标是可滚动的（即，允许以一种非顺序的方式检索行）则为<literal>真</>，否则为<literal>假</literal>
       </entry>
     </row>

     <row>
      <entry><structfield>creation_time</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry>游标被声明的时间</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_cursors</structname>视图是只读的。
  </para>

 </sect1>

 <sect1 id="view-pg-group">
  <title><structname>pg_group</structname></title>

  <indexterm zone="view-pg-group">
   <primary>pg_group</primary>
  </indexterm>

  <para>
   视图<structname>pg_group</structname>为向后兼容而存在：它模拟了存在于<productname>PostgreSQL</productname> 8.1之前版本中的一个目录。它显式所有角色的名称和未被标记<structfield>rolcanlogin</>的成员，它是被用做组的角色集合的近似。
  </para>

  <table>
   <title><structname>pg_group</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>groname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>组名</entry>
     </row>

     <row>
      <entry><structfield>grosysid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>组ID</entry>
     </row>

     <row>
      <entry><structfield>grolist</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>包含此组中角色ID的一个数组</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-indexes">
  <title><structname>pg_indexes</structname></title>

  <indexterm zone="view-pg-indexes">
   <primary>pg_indexes</primary>
  </indexterm>

  <para>
   视图<structname>pg_indexes</structname>提供对于数据库中每一个索引信息的访问。
  </para>

  <table>
   <title><structname>pg_indexes</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>包含表和索引的模式名</entry>
     </row>
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>此索引的基表的名字</entry>
     </row>
     <row>
      <entry><structfield>indexname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>索引名</entry>
     </row>
     <row>
      <entry><structfield>tablespace</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.spcname</literal></entry>
      <entry>包含索引的表空间名（如果是数据库的默认值则为空）</entry>
     </row>
     <row>
      <entry><structfield>indexdef</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>索引定义（<command>CREATE INDEX</command>命令的重构）</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-locks">
  <title><structname>pg_locks</structname></title>

  <indexterm zone="view-pg-locks">
   <primary>pg_locks</primary>
  </indexterm>

  <para>
   视图<structname>pg_locks</structname>提供了数据库服务器上打开事务中保持的锁的信息。更多锁的讨论参见<xref linkend="mvcc">。
  </para>

  <para>
   <structname>pg_locks</structname>中对每一个活动可锁对象、请求锁模式和相关事务的组合都有一行。因此，如果多个事务持有或者正在等待一个可锁对象上的锁，同一个可锁对象可能出现很多次。但是，一个当前没有被锁的对象根本不会出现。
  </para>

  <para>
   有多种不同类型的可锁对象：整个关系（如表）、关系的单个页、关系的单个元组、事务ID（包括虚拟和永久ID）和普通数据库对象（由类OID和对象OID标识，和<structname>pg_description</structname>或<structname>pg_depend</structname>中的相同方式）。扩展一个关系的权力也被表示为一个独立的可锁对象。<quote>咨询</>锁可以具有用户定义的意义。
  </para>

  <table>
   <title><structname>pg_locks</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>locktype</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       可锁对象的类型：
       <literal>relation</>,
       <literal>extend</>,
       <literal>page</>,
       <literal>tuple</>,
       <literal>transactionid</>,
       <literal>virtualxid</>,
       <literal>object</>,
       <literal>userlock</>, or
       <literal>advisory</>
      </entry>
     </row>
     <row>
      <entry><structfield>database</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <entry>
       锁目标存在的数据库的OID，如果目标是一个共享对象则为0，如果目标是一个事务ID则为空
      </entry>
     </row>
     <row>
      <entry><structfield>relation</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       作为锁目标的关系的OID，如果目标不是一个关系或者只是关系的一部分则此列为空
      </entry>
     </row>
     <row>
      <entry><structfield>page</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>
       作为锁目标的页在关系中的页号，如果目标不是一个关系页或元组则此列为空
      </entry>
     </row>
     <row>
      <entry><structfield>tuple</structfield></entry>
      <entry><type>smallint</type></entry>
      <entry></entry>
      <entry>
       作为锁目标的元组在页中的元组号，如果目标不是一个元组则此列为空
      </entry>
     </row>
     <row>
      <entry><structfield>virtualxid</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       作为锁目标的事务虚拟ID，如果目标不是一个虚拟事务ID则此列为空
      </entry>
     </row>
     <row>
      <entry><structfield>transactionid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       作为锁目标的事务ID，如果目标不是一个事务ID则此列为空ID
      </entry>
     </row>
     <row>
      <entry><structfield>classid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       包含锁目标的系统目录的OID，如果目标不是一个普通数据库对象则此列为空
      </entry>
     </row>
     <row>
      <entry><structfield>objid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>任意OID列</entry>
      <entry>
       锁目标在它的系统目录中的OID，如果目标不是一个普通数据库对象则为空
      </entry>
     </row>
     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>smallint</type></entry>
      <entry></entry>
      <entry>
       锁的目标列号（<structfield>classid</>和<structfield>objid</>指表本身），如果目标是某种其他普通数据库对象则此列为0，如果目标不是一个普通数据库对象则此列为空
      </entry>
     </row>
     <row>
      <entry><structfield>virtualtransaction</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       保持这个锁或者正在等待这个锁的事务的虚拟ID
      </entry>
     </row>
     <row>
      <entry><structfield>pid</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>
       保持这个锁或者正在等待这个锁的服务器进程的PID，如果此锁被一个预备事务所持有则此列为空
      </entry>
     </row>
     <row>
      <entry><structfield>mode</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>此进程已持有或者希望持有的锁模式（参见<xref linkend="locking-tables">和<xref linkend="xact-serializable">）</entry>
     </row>
     <row>
      <entry><structfield>granted</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry></entry>
      <entry>如果锁已授予则为真，如果锁被等待则为假</entry>
     </row>
     <row>
      <entry><structfield>fastpath</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry></entry>
      <entry>如果锁通过快速路径获得则为真，通过主锁表获得则为假</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   一个行的<structfield>granted</structfield>为真表示一个被指定事务持有的锁。为假表示该事务当前正在等待获取这个锁，这意味着某个其他事务正持有同一个可锁对象上的一个冲突锁。等待中的事务将一直休眠直到其他锁被释放（或者一个死锁状态被检测到）。一个单一事务在同一时间只能等待最多一个锁。
  </para>

  <para>
   每个事务在其生存周期内都持有一个在其虚拟事务ID上的排他锁。如果一个永久ID被分配给事务（通常发生在事务改变数据库状态时），它也会持有一个在其永久事务ID上的排他锁直到它结束。当一个事务发现它需要等待另一个事务，它也会尝试获取其他事务ID上的共享锁（不管是虚拟还是永久ID，视情况而定）。这只有当其他进程终止并释放其锁后才会成功。
  </para>

  <para>
   尽管元组是一种可锁对象，关于行级锁的信息被存储在磁盘而不是内存中，因此行级锁通常不在这个视图中出现。如果一个事务正在等待一个行级锁，它通常在这个视图中出现，并且表示形式为正在等待已持有该行级锁的永久事务ID上的锁。
  </para>

  <para>
   咨询锁可以在由一个单一<type>bigint</type>值或两个整形值构成的键上获取。一个<type>bigint</type>键被显示为其高位部分在<structfield>classid</>列中，低位部分在<structfield>objid</>列中，并且<structfield>objsubid</>等于1。原来的<type>bigint</type>值可以使用表达式<literal>(classid::bigint &lt;&lt; 32) | objid::bigint</literal>重组。整形键被显示为第一个键在<structfield>classid</>列中，第二个键在<structfield>objid</>列中，并且<structfield>objsubid</>等于2。键的实际意义由用户决定。咨询锁是每一个数据库的本地锁，所以<structfield>database</>列对于一个咨询锁没有意义。
  </para>

  <para>
   <structname>pg_locks</structname>提供了一个对于整个数据集簇中所有锁的全局视图，而不仅仅是与当前数据库相关的锁。尽管它的<structfield>relation</structfield>列可以被连接到<structname>pg_class</>.<structfield>oid</>来标识被锁关系，但这种方法只有在关系属于当前数据库（<structfield>database</structfield>列是当前数据库OID或者0的锁对应的关系）的情况下才会得到正确的结果。
  </para>

  <para>
   <structfield>pid</structfield>列可以被连接到
   <link
   linkend="pg-stat-activity-view"><structname>pg_stat_activity</structname></link>视图的<structfield>pid</structfield>列来得到持有或等待持有每一个锁的会话的信息。
   例如
<programlisting>
SELECT * FROM pg_locks pl LEFT JOIN pg_stat_activity psa
    ON pl.pid = psa.pid;
</programlisting>
   另外，如果正在使用预备事务，<structfield>virtualtransaction</>列可以被连接到<link
   linkend="view-pg-prepared-xacts"><structname>pg_prepared_xacts</structname></link>视图的<structfield>transaction</structfield>列来得到持有该锁的预备事务的信息（一个预备事务不可能正在等待一个锁，但它在运行中会一直持有已获得的锁）。
   例如：
<programlisting>
SELECT * FROM pg_locks pl LEFT JOIN pg_prepared_xacts ppx
    ON pl.virtualtransaction = '-1/' || ppx.transaction;
</programlisting>
  </para>

  <para>
   <structname>pg_locks</structname>视图显示来自于普通锁管理器和谓词锁管理器的数据，它们是独立的系统。此外，普通锁管理器把它的锁分为普通锁和<firstterm>快速路径</>锁。这些数据并不被保证是完全一致的。当视图被查询时，快速路径锁上的数据（<structfield>fastpath</> = <literal>true</>）会被一次性从每一个后端收集起来，且并不冻结整个锁管理器的状态。因此有可能某些锁在上述信息被收集的过程中被获得或者释放。注意，不管怎样这些锁是已知不会和任何当前正在发生的锁冲突。在所有后端已经查询了快速路径锁后，普通锁管理器的剩余部分被作为一个单元锁住，并且所有剩余锁的一个一致快照被作为一个原子动作收集。在解锁普通锁管理器后，谓词锁管理器也被类似地锁住并且所有谓词锁被作为一个原子动作收集。因此，在快速路径锁这种特殊情况下，每一个锁管理器会传递一个一致的结果组。但由于我们并不会同时锁上两个锁管理器，  在我们询问完普通锁管理器后或者询问谓词锁管理器之前，锁可以被获得或者释放。
  </para>

  <para>
   如果对此视图频繁地访问，对普通或者谓词锁管理器加锁可能会对数据库性能产生一定影响。虽然这些锁只会在最少的时间内被保持（足以从锁管理器获得数据），但这无法完全消除可能产生的性能影响。
  </para>

 </sect1>

 <sect1 id="view-pg-matviews">
  <title><structname>pg_matviews</structname></title>

  <indexterm zone="view-pg-matviews">
   <primary>pg_matviews</primary>
  </indexterm>

  <indexterm zone="view-pg-matviews">
   <primary>materialized views</primary>
  </indexterm>

  <para>
   视图<structname>pg_matviews</structname>提供了关于数据库中每一个物化视图的信息。
  </para>

  <table>
   <title><structname>pg_matviews</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>包含物化视图的模式的名字</entry>
     </row>
     <row>
      <entry><structfield>matviewname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>物化视图的名字</entry>
     </row>
     <row>
      <entry><structfield>matviewowner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>物化视图拥有者的名字</entry>
     </row>
     <row>
      <entry><structfield>tablespace</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.spcname</literal></entry>
      <entry>包含物化视图的表空间名（如使用数据库默认表空间则为空）</entry>
     </row>
     <row>
      <entry><structfield>hasindexes</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry></entry>
      <entry>如果物化视图有（或者最近有过）任何索引，则此列为真</entry>
     </row>
     <row>
      <entry><structfield>ispopulated</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry></entry>
      <entry>如果物化视图当前已被填充，则此列为真</entry>
     </row>
     <row>
      <entry><structfield>definition</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>物化视图的定义（一个重构的<command>SELECT</command>查询）</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-prepared-statements">
  <title><structname>pg_prepared_statements</structname></title>

  <indexterm zone="view-pg-prepared-statements">
   <primary>pg_prepared_statements</primary>
  </indexterm>

  <para>
   <structname>pg_prepared_statements</structname>视图显示在当前会话中可用的所有预备语句。关于预备语句详见<xref linkend="sql-prepare">。
  </para>

  <para>
   <structname>pg_prepared_statements</structname>为每一个预备语句包含一行。当一个新的预备语句被创建时在此视图中会增加一行，反之当一个预备语句被释放时在此视图中会删除一行（例如，通过<xref linkend="sql-deallocate">命令）。
  </para>

  <table>
   <title><structname>pg_prepared_statements</>的列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名字</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <entry>
       预备语句的标识符
      </entry>
     </row>
     <row>
      <entry><structfield>statement</structfield></entry>
      <entry><type>text</type></entry>
      <entry>
       客户端提交用于创建此预备语句的查询语句。对于通过SQL创建的预备语句，这里是由客户端提交的<command>PREPARE</command>语句。对于通过前端/后端协议创建的预备语句，这里是预备语句本身的文本。
      </entry>
     </row>
     <row>
      <entry><structfield>prepare_time</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry>
       预备语句被创建的时间
      </entry>
     </row>
     <row>
      <entry><structfield>parameter_types</structfield></entry>
      <entry><type>regtype[]</type></entry>
      <entry>
       预备语句期望的参数类型，以一个<type>regtype</type>数组的形式。这个数组中一个元素所对应的OID可通过将<type>regtype</type>值转换为<type>oid</type>获得。
      </entry>
     </row>
     <row>
      <entry><structfield>from_sql</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>
       如果预备语句通过SQL语句<command>PREPARE</command>创建，则为<literal>真</literal>；如果预备语句通过前端/后端协议创建，则为<literal>假</literal>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_prepared_statements</structname>视图为只读。
  </para>
 </sect1>

 <sect1 id="view-pg-prepared-xacts">
  <title><structname>pg_prepared_xacts</structname></title>

  <indexterm zone="view-pg-prepared-xacts">
   <primary>pg_prepared_xacts</primary>
  </indexterm>

  <para>
   视图<structname>pg_prepared_xacts</structname>显示关于两阶段提交（详见<xref linkend="sql-prepare-transaction">）的当前准备好事务的信息。
  </para>

  <para>
   <structname>pg_prepared_xacts</structname>为每一个预备事务包含一行。当事务被提交或回滚时，相应的项将被移除。
  </para>

  <table>
   <title><structname>pg_prepared_xacts</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>transaction</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       预备事务的数字事务标识符
      </entry>
     </row>
     <row>
      <entry><structfield>gid</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       分配给事务的全局标识符
      </entry>
     </row>
     <row>
      <entry><structfield>prepared</structfield></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry></entry>
      <entry>
       此事务为提交准备好的时间
      </entry>
     </row>
     <row>
      <entry><structfield>owner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>
       执行此事务的用户名
      </entry>
     </row>
     <row>
      <entry><structfield>database</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.datname</literal></entry>
      <entry>
       执行此事务所在数据库的名字
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   当<structname>pg_prepared_xacts</structname>视图被访问时，内部事务管理器数据结构被暂时地锁住，并为视图的显示产生一个副本。这确保了视图中是一组一致的结果，并且不会阻塞普通操作。不管怎样，当此视图被频繁访问时，会对数据库性能有所影响。
  </para>

 </sect1>

 <sect1 id="view-pg-roles">
  <title><structname>pg_roles</structname></title>

  <indexterm zone="view-pg-roles">
   <primary>pg_roles</primary>
  </indexterm>

  <para>
   视图<structname>pg_roles</structname>提供了关于数据库角色的信息。这是<link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>的一个公共可读视图，它隐去了口令域。
  </para>

  <para>
   此视图显示了低层表的OID列，因为需要它来和其他目录做连接。
  </para>

  <table>
   <title><structname>pg_roles</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>rolname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>角色名</entry>
     </row>

     <row>
      <entry><structfield>rolsuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>角色是否具有超级用户权限？</entry>
     </row>

     <row>
      <entry><structfield>rolinherit</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>如果此角色是另一个角色的成员，角色是否能自动继承另一个角色的权限？</entry>
     </row>

     <row>
      <entry><structfield>rolcreaterole</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>角色能否创建更多角色？</entry>
     </row>

     <row>
      <entry><structfield>rolcreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>角色能否创建数据库？</entry>
     </row>

     <row>
      <entry><structfield>rolcatupdate</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       角色能否直接更新系统目录？（如果此列不为真，即便是超级用户也不能更新）
      </entry>
     </row>

     <row>
      <entry><structfield>rolcanlogin</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       角色是否能登录？即此角色能否被作为初始会话授权标识符？
      </entry>
     </row>

     <row>
      <entry><structfield>rolreplication</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       角色是否为一个复制角色？即此角色能否开启流复制（见<xref linkend="streaming-replication">）并使用<function>pg_start_backup</>和<function>pg_stop_backup</>设置/取消系统备份模式
      </entry>
     </row>

     <row>
      <entry><structfield>rolconnlimit</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       对于一个可登录的角色，这里设置角色可以发起的最大并发连接数。-1表示无限制。
      </entry>
     </row>

     <row>
      <entry><structfield>rolpassword</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>不是口令（看起来是<literal>********</>）</entry>
     </row>

     <row>
      <entry><structfield>rolvaliduntil</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry></entry>
      <entry>口令失效时间（只用于口令认证），如果永不失效则为空</entry>
     </row>

     <row>
      <entry><structfield>rolconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>运行时配置变量的角色特定默认值</entry>
     </row>

     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>角色的ID</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-rules">
  <title><structname>pg_rules</structname></title>

  <indexterm zone="view-pg-rules">
   <primary>pg_rules</primary>
  </indexterm>

  <para>
   视图<structname>pg_rules</structname>提供对查询重写规则的信息访问。
  </para>

  <table>
   <title><structname>pg_rules</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>包含表的模式名</entry>
     </row>
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>规则适用的表名</entry>
     </row>
     <row>
      <entry><structfield>rulename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-rewrite"><structname>pg_rewrite</structname></link>.rulename</literal></entry>
      <entry>规则名</entry>
     </row>
     <row>
      <entry><structfield>definition</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>规则定义（创建命令的重构）</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_rules</>视图排除了视图和物化视图的<literal>ON SELECT</>规则，它们可以在<structname>pg_views</>和<structname>pg_matviews</>中找到。
  </para>

 </sect1>

 <sect1 id="view-pg-seclabels">
  <title><structname>pg_seclabels</structname></title>

  <indexterm zone="view-pg-seclabels">
   <primary>pg_seclabels</primary>
  </indexterm>

  <para>
   视图<structname>pg_seclabels</structname>提供对安全标签的信息访问。它是<link linkend="catalog-pg-seclabel"><structname>pg_seclabel</></>目录的一个便于查询的版本。
  </para>

  <table>
   <title><structname>pg_seclabels</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>any OID column</entry>
      <entry>安全标签所属对象的OID</entry>
     </row>
     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>对象出现的系统目录的OID</entry>
     </row>
     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       对于一个表列上的安全标签，这里是列号（<structfield>objoid</>和<structfield>classoid</>指表本身）。对于所有其他对象类型，此列为0。
      </entry>
     </row>
     <row>
      <entry><structfield>objtype</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
         此标签应用的对象类型，以文本方式。
      </entry>
     </row>
     <row>
      <entry><structfield>objnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       如果适用，为此对象的名字空间的OID；否则为空。
      </entry>
     </row>
     <row>
      <entry><structfield>objname</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       此标签应用的对象名，以文本形式。
      </entry>
     </row>
     <row>
      <entry><structfield>provider</structfield></entry>
      <entry><type>text</type></entry>
      <entry><literal><link linkend="catalog-pg-seclabel"><structname>pg_seclabel</structname></link>.provider</literal></entry>
      <entry>与此标签相关的标签提供者。</entry>
     </row>
     <row>
      <entry><structfield>label</structfield></entry>
      <entry><type>text</type></entry>
      <entry><literal><link linkend="catalog-pg-seclabel"><structname>pg_seclabel</structname></link>.label</literal></entry>
      <entry>应用于此对象的安全标签。</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="view-pg-settings">
  <title><structname>pg_settings</structname></title>

  <indexterm zone="view-pg-settings">
   <primary>pg_settings</primary>
  </indexterm>

  <para>
   视图<structname>pg_settings</structname>提供了对服务器上运行时参数的访问。它本质上是<xref linkend="sql-show">和<xref linkend="sql-set">命令的可替换接口。它还提供了<command>SHOW</>不能提供的关于每一个参数的一些现实，例如最大值和最小值。
  </para>

  <table>
   <title><structname>pg_settings</>的列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名字</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <entry>运行时配置参数名</entry>
     </row>
     <row>
      <entry><structfield>setting</structfield></entry>
      <entry><type>text</type></entry>
      <entry>参数的当前值</entry>
     </row>
     <row>
      <entry><structfield>unit</structfield></entry>
      <entry><type>text</type></entry>
      <entry>参数的隐式单元</entry>
     </row>
     <row>
      <entry><structfield>category</structfield></entry>
      <entry><type>text</type></entry>
      <entry>参数的逻辑组</entry>
     </row>
     <row>
      <entry><structfield>short_desc</structfield></entry>
      <entry><type>text</type></entry>
      <entry>参数的简短描述</entry>
     </row>
     <row>
      <entry><structfield>extra_desc</structfield></entry>
      <entry><type>text</type></entry>
      <entry>附加的参数的详细描述</entry>
     </row>
     <row>
      <entry><structfield>context</structfield></entry>
      <entry><type>text</type></entry>
      <entry>要求设置此参数值的上下文</entry>
     </row>
     <row>
      <entry><structfield>vartype</structfield></entry>
      <entry><type>text</type></entry>
      <entry>参数类型（<literal>bool</>、<literal>enum</>、
       <literal>integer</>、<literal>real</>或<literal>string</>）
      </entry>
     </row>
     <row>
      <entry><structfield>source</structfield></entry>
      <entry><type>text</type></entry>
      <entry>当前参数值的来源</entry>
     </row>
     <row>
      <entry><structfield>min_val</structfield></entry>
      <entry><type>text</type></entry>
      <entry>参数的最小允许值（对非数字值为空）</entry>
     </row>
     <row>
      <entry><structfield>max_val</structfield></entry>
      <entry><type>text</type></entry>
      <entry>参数的最大允许值（对非数字值为空）</entry>
     </row>
     <row>
      <entry><structfield>enumvals</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry>一个枚举参数的允许值（对非数字值为空）</entry>
     </row>
     <row>
      <entry><structfield>boot_val</structfield></entry>
      <entry><type>text</type></entry>
      <entry>如果参数没有被别的其他设置，此列为在服务器启动时设定的参数值</entry>
     </row>
     <row>
      <entry><structfield>reset_val</structfield></entry>
      <entry><type>text</type></entry>
      <entry>在当前会话中，<command>RESET</command>将会设置的参数值</entry>
     </row>
     <row>
      <entry><structfield>sourcefile</structfield></entry>
      <entry><type>text</type></entry>
      <entry>当前值所在的配置文件（如果值是从配置文件之外的其他来源设置的，或者被一个非超级用户查看时，此列为空）；当在配置文件中使用<literal>include</>指令时有用</entry>
     </row>
     <row>
      <entry><structfield>sourceline</structfield></entry>
      <entry><type>integer</type></entry>
      <entry>当前值在配置文件中的行号（如果值是从配置文件之外的其他来源设置的，或者被一个非超级用户查看时，此列为空）
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   对于<structfield>context</structfield>有多种可能的取值。为了降低改变设置的难度，它们是：
  </para>

  <variablelist>
   <varlistentry>
    <term><literal>internal</literal></term>
    <listitem>
     <para>
      这些设置不能被直接修改，它们反映了内部决定的值。某些可能在使用不同配置选项重建系统时或者改变<command>initdb</command>的选项时可以调整。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>postmaster</literal></term>
    <listitem>
     <para>
      这些设置只能在服务器启动时应用，因此任何修改都需要重启服务器。这些设置的值通常都存储在<filename>postgresql.conf</filename>文件中，或者在启动服务器时通过命令行传递。当然，具有更低<structfield>context</structfield>类型的设置也可以在服务器启动时间被设置。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>sighup</literal></term>
    <listitem>
     <para>
      对于这些设置的修改可以在<filename>postgresql.conf</filename>中完成并且不需要重启服务器。发送一个<systemitem>SIGHUP</systemitem>信号给postmaster会导致它重新读取<filename>postgresql.conf</filename>并应用修改。Postmaster将会把<systemitem>SIGHUP</systemitem>信号传递给它的孩子进程，这样它们也会获得新的值。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>backend</literal></term>
    <listitem>
     <para>
      对于这些设置的修改可以在<filename>postgresql.conf</filename>中完成并且不需要重启服务器。它们也可以在一个连接请求包（例如，通过<application>libpq</>的<literal>PGOPTIONS</>环境变量）中为一个特定会话设置 。然而，这些设置在会话启动后永不变化。如果你在<filename>postgresql.conf</filename>中修改它们，可以向postmaster发送一个<systemitem>SIGHUP</systemitem>信号让它重读<filename>postgresql.conf</filename>。新值只会影响后续启动的会话。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>superuser</literal></term>
    <listitem>
     <para>
      这些设置可以从<filename>postgresql.conf</filename>设置，或者在会话中用<command>SET</>命令设置。仅当没有通过<command>SET</>设置会话本地值时，<filename>postgresql.conf</filename>中的改变才会影响现有的会话。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>user</literal></term>
    <listitem>
     <para>
      这些设置可以从<filename>postgresql.conf</filename>设置，或者在会话中用<command>SET</>命令设置。任何用户都被允许修改它的会话本地值。仅当没有通过<command>SET</>设置会话本地值时，<filename>postgresql.conf</filename>中的改变才会影响现有的会话。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   更多关于修改这些参数的方法的信息请见<xref linkend="config-setting">。
  </para>

  <para>
   <structname>pg_settings</structname>视图不能被插入或者从中删除，但是它可以被更新。在<structname>pg_settings</structname>的一行上的一个<command>UPDATE</command>等价于在该参数上执行一个<xref linkend="sql-set">命令。修改将只会影响当前会话使用的值。如果一个<command>UPDATE</command>在一个后来中断的事务中被发出，<command>UPDATE</command>命令的效果也会随着事务的回滚而消失。一旦所在的事务被提交，效果将一直保持到会话结束，除非有其他<command>UPDATE</command>或   <command>SET</command>重新修改它。
  </para>

 </sect1>

 <sect1 id="view-pg-shadow">
  <title><structname>pg_shadow</structname></title>

  <indexterm zone="view-pg-shadow">
   <primary>pg_shadow</primary>
  </indexterm>

  <para>
   视图<structname>pg_shadow</structname>的存在是为了向后兼容：它模拟了在<productname>PostgreSQL</productname>版本8.1之前的一个系统目录。它显示<link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>中所有被标记为<structfield>rolcanlogin</>的角色的属性。
  </para>

  <para>
   由于这个表包含口令，所以不能是公众可读的，这也是采用<structname>pg_shadow</structname>这个名字的原因。
   而<link linkend="view-pg-user"><structname>pg_user</structname></link>是<structname>pg_shadow</structname>上的一个公共可读视图，它屏蔽了口令域。
  </para>

  <table>
   <title><structname>pg_shadow</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>usename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>用户名</entry>
     </row>

     <row>
      <entry><structfield>usesysid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>用户的ID</entry>
     </row>

     <row>
      <entry><structfield>usecreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>用户能否创建数据库</entry>
     </row>

     <row>
      <entry><structfield>usesuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>用户是否为一个超级用户</entry>
     </row>

     <row>
      <entry><structfield>usecatupd</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       用户能否更新系统目录（如果此列为假，即使是一个超级用户也不能更新）。
      </entry>
     </row>

     <row>
      <entry><structfield>userepl</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       用户能否开启流复制并将系统设置或者取消备份模式。
      </entry>
     </row>

     <row>
      <entry><structfield>passwd</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>口令（可能被加密），如果没有则为空。关于加密口令如何存储请参见<link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>。</entry>
     </row>

     <row>
      <entry><structfield>valuntil</structfield></entry>
      <entry><type>abstime</type></entry>
      <entry></entry>
      <entry>口令过期时间（仅用于口令认证）</entry>
     </row>

     <row>
      <entry><structfield>useconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>运行时配置变量的会话默认值</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-stats">
  <title><structname>pg_stats</structname></title>

  <indexterm zone="view-pg-stats">
   <primary>pg_stats</primary>
  </indexterm>

  <para>
   视图<structname>pg_stats</structname>提供对存储在<link
   linkend="catalog-pg-statistic"><structname>pg_statistic</structname></link>目录中信息的访问。此视图能访问<structname>pg_statistic</structname>行是有限制的，可访问行所对应的表必须是用户有读权限的。因此让所有用户都可以读此视图是安全的。
  </para>

  <para>
   <structname>pg_stats</structname>也被设计为能以更适合阅读的格式显示底层目录的信息&mdash; 但代价是只要为<structname>pg_statistic</structname>定义了新的槽类型，就必须要扩展此视图的模式。
  </para>

  <table>
   <title><structname>pg_stats</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>包含表的模式名</entry>
     </row>

     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>表名</entry>
     </row>

     <row>
      <entry><structfield>attname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attname</literal></entry>
      <entry>被此行描述的列名</entry>
     </row>

     <row>
      <entry><structfield>inherited</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>如果为真，表示此行包括继承子列，不仅仅是指定表中的值</entry>
     </row>

     <row>
      <entry><structfield>null_frac</structfield></entry>
      <entry><type>real</type></entry>
      <entry></entry>
      <entry>列项中为空的比例</entry>
     </row>

     <row>
      <entry><structfield>avg_width</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>列项的平均字节宽度</entry>
     </row>

     <row>
      <entry><structfield>n_distinct</structfield></entry>
      <entry><type>real</type></entry>
      <entry></entry>
      <entry>
       如果大于零，表示列中可区分值的估计个数。如果小于零，是可区分值个数除以行数的负值（当<command>ANALYZE</>认为可区分值的数量会随着表增长而增加时采用负值的形式，而如果认为列具有固定数量的可选值时采用正值的形式）。例如，-1表示一个唯一列，即其中可区分值的个数等于行数。
      </entry>
     </row>

     <row>
      <entry><structfield>most_common_vals</structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>
       列中最常用值的一个列表（如果没有任何一个值看起来比其他值更常用，此列为空）
      </entry>
     </row>

     <row>
      <entry><structfield>most_common_freqs</structfield></entry>
      <entry><type>real[]</type></entry>
      <entry></entry>
      <entry>
       最常用值的频率列表，即每一个常用值的出现次数除以总行数（如果<structfield>most_common_vals</structfield>为空，则此列为空）
      </entry>
     </row>

     <row>
      <entry><structfield>histogram_bounds</structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>
       将列值划分成大小接近的组的值列表。如果存在<structfield>most_common_vals</>，其中的值会被直方图计算所忽略（如果列类型没有一个<literal>&lt;</>操作符或者<structfield>most_common_vals</>等于整个值集合，则此列为空）
      </entry>
     </row>

     <row>
      <entry><structfield>correlation</structfield></entry>
      <entry><type>real</type></entry>
      <entry></entry>
      <entry>
       物理行顺序和列值逻辑顺序之间的统计关联。其范围从-1到+1。当值接近-1或+1时，在列上的一个索引扫描被认为比值接近0时的代价更低，因为这种情况减少了对磁盘的随机访问（如果列数据类型不具有一个<literal>&lt;</>操作符，则此列为空）
      </entry>
     </row>

     <row>
      <entry><structfield>most_common_elems</structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>
       在列值中，最经常出现的非空元素列表（对标度类型为空）
      </entry>
     </row>

     <row>
      <entry><structfield>most_common_elem_freqs</structfield></entry>
      <entry><type>real[]</type></entry>
      <entry></entry>
      <entry>
       最常用元素值的频度列表，即含有至少一个给定值实例的行的分数。在每个元素的频度之后有二至三个附加值，它们是每个元素频度的最小和最大值，以及可选的空元素的频度（如果<structfield>most_common_elems</structfield>为空，则此列为空）
      </entry>
     </row>

     <row>
      <entry><structfield>elem_count_histogram</structfield></entry>
      <entry><type>real[]</type></entry>
      <entry></entry>
      <entry>
       在列值中可区分非空元素值计数的一个直方图，后面跟随可区分非空元素的平均数（对于标度类型为空）
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   在数组域中项的最大数目可以使用<command>ALTER TABLE SET STATISTICS</>命令控制，或者设置<xref linkend="guc-default-statistics-target">运行时参数从全局上进行控制
  </para>

 </sect1>

 <sect1 id="view-pg-tables">
  <title><structname>pg_tables</structname></title>

  <indexterm zone="view-pg-tables">
   <primary>pg_tables</primary>
  </indexterm>

  <para>
   视图<structname>pg_tables</structname>提供对数据库中每个表的信息的访问。
  </para>

  <table>
   <title><structname>pg_tables</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>包含表的模式名</entry>
     </row>
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>表名</entry>
     </row>
     <row>
      <entry><structfield>tableowner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>表拥有者的名字</entry>
     </row>
     <row>
      <entry><structfield>tablespace</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.spcname</literal></entry>
      <entry>包含表的表空间的名字（如果使用数据库的默认表空间，此列为空）</entry>
     </row>
     <row>
      <entry><structfield>hasindexes</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relhasindex</literal></entry>
      <entry>如果表有（或最近有过）任何索引，此列为真</entry>
     </row>
     <row>
      <entry><structfield>hasrules</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relhasrules</literal></entry>
      <entry>如果表有（或曾经有过）规则，此列为真</entry>
     </row>
     <row>
      <entry><structfield>hastriggers</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relhastriggers</literal></entry>
      <entry>如果表有（或者曾经有过）触发器，此列为真</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-timezone-abbrevs">
  <title><structname>pg_timezone_abbrevs</structname></title>

  <indexterm zone="view-pg-timezone-abbrevs">
   <primary>pg_timezone_abbrevs</primary>
  </indexterm>

  <para>
   视图<structname>pg_timezone_abbrevs</structname>提供了对当前被时间输入例程识别的时区缩写的列表。当<xref linkend="guc-timezone-abbreviations">运行时参数被修改，此视图的内容会发生变化。
  </para>

  <table>
   <title><structname>pg_timezone_abbrevs</>的列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名字</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>abbrev</structfield></entry>
      <entry><type>text</type></entry>
      <entry>时区缩写</entry>
     </row>
     <row>
      <entry><structfield>utc_offset</structfield></entry>
      <entry><type>interval</type></entry>
      <entry>相对于UTC的偏移（正值表示格林威治东部）</entry>
     </row>
     <row>
      <entry><structfield>is_dst</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>如果这是一个夏令时缩写，则为真</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-timezone-names">
  <title><structname>pg_timezone_names</structname></title>

  <indexterm zone="view-pg-timezone-names">
   <primary>pg_timezone_names</primary>
  </indexterm>

  <para>
   视图<structname>pg_timezone_names</structname>提供了一个被<command>SET TIMEZONE</>识别的时区名字的列表，以及它们的相关缩写、UTC偏移和夏令时状态（从技术上来说，<productname>PostgreSQL</productname>使用<acronym>UT1</>而不是UTC是因为闰秒没有被处理）。和<link
   linkend="view-pg-timezone-abbrevs"><structname>pg_timezone_abbrevs</structname></link>中展示的缩写不同，这里很多名字隐含了一组夏令时转换日期规则。因此，相关信息在本地DST边界间变化。所显示的信息基于<function>CURRENT_TIMESTAMP</>的当前值计算得来。
  </para>

  <table>
   <title><structname>pg_timezone_names</>的列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名字</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <entry>时区名</entry>
     </row>
     <row>
      <entry><structfield>abbrev</structfield></entry>
      <entry><type>text</type></entry>
      <entry>时区缩写</entry>
     </row>
     <row>
      <entry><structfield>utc_offset</structfield></entry>
      <entry><type>interval</type></entry>
      <entry>相对于UTC的偏移（正值表示格林威治东部）</entry>
     </row>
     <row>
      <entry><structfield>is_dst</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>如果当前保持为夏令时则为真</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-user">
  <title><structname>pg_user</structname></title>

  <indexterm zone="view-pg-user">
   <primary>pg_user</primary>
  </indexterm>

  <para>
   视图<structname>pg_user</structname>提供关于数据库用户的信息。这是<link linkend="view-pg-shadow"><structname>pg_shadow</structname></link>的一个公共可读的视图，它消除了口令域。
  </para>

  <table>
   <title><structname>pg_user</>的列</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>名字</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>usename</structfield></entry>
      <entry><type>name</type></entry>
      <entry>用户名</entry>
     </row>

     <row>
      <entry><structfield>usesysid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>用户的ID</entry>
     </row>

     <row>
      <entry><structfield>usecreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>用户是否能创建数据库</entry>
     </row>

     <row>
      <entry><structfield>usesuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>用户是否为超级用户</entry>
     </row>

     <row>
      <entry><structfield>usecatupd</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>
       用户是否能更新系统目录（除非此列为真，即使一个超级用户也不能更新系统目录）。
      </entry>
     </row>

     <row>
      <entry><structfield>userepl</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>
       用户能否开启流复制以及将系统转入/转出备份模式。
      </entry>
     </row>

     <row>
      <entry><structfield>passwd</structfield></entry>
      <entry><type>text</type></entry>
      <entry>不是口令（总是显示为<literal>********</>）</entry>
     </row>

     <row>
      <entry><structfield>valuntil</structfield></entry>
      <entry><type>abstime</type></entry>
      <entry>口令过期时间（只用于口令认证）</entry>
     </row>

     <row>
      <entry><structfield>useconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry>运行时配置变量的会话默认值</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-user-mappings">
  <title><structname>pg_user_mappings</structname></title>

  <indexterm zone="view-pg-user-mappings">
   <primary>pg_user_mappings</primary>
  </indexterm>

  <para>
   视图<structname>pg_user_mappings</structname>提供有关用户映射的信息。这是<link linkend="catalog-pg-user-mapping"><structname>pg_user_mapping</structname></link>的一个公共可读视图，它对无权使用的用户省去了选项域。
  </para>

  <table>
   <title><structname>pg_user_mappings</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>umid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-user-mapping"><structname>pg_user_mapping</structname></link>.oid</literal></entry>
      <entry>用户映射的OID</entry>
     </row>

     <row>
      <entry><structfield>srvid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-foreign-server"><structname>pg_foreign_server</structname></link>.oid</literal></entry>
      <entry>
       包含该映射的外部服务器的OID
      </entry>
     </row>

     <row>
      <entry><structfield>srvname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-foreign-server"><structname>pg_foreign_server</structname></link>.srvname</literal></entry>
      <entry>
       外部服务器名
      </entry>
     </row>

     <row>
      <entry><structfield>umuser</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>将被映射的本地角色的OID，如果用户映射是公共的则为0</entry>
     </row>

     <row>
      <entry><structfield>usename</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>将被映射的本地用户名</entry>
     </row>

     <row>
      <entry><structfield>umoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       用户映射指定选项，以<quote>keyword=value</>字符串的形式，如果当前用户为外部服务器的所有者则为空
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="view-pg-views">
  <title><structname>pg_views</structname></title>

  <indexterm zone="view-pg-views">
   <primary>pg_views</primary>
  </indexterm>

  <para>
   视图<structname>pg_views</structname>提供了数据库中每个视图的信息。
  </para>

  <table>
   <title><structname>pg_views</>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>包含视图的模式名</entry>
     </row>
     <row>
      <entry><structfield>viewname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>视图名称</entry>
     </row>
     <row>
      <entry><structfield>viewowner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>视图拥有者的名字</entry>
     </row>
     <row>
      <entry><structfield>definition</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>视图定义（一个重构的<command>SELECT</command>查询）</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

</chapter>
