<!-- doc/src/sgml/catalogs.sgml -->
<!--
 Documentation of the system catalogs, directed toward PostgreSQL developers
 -->

<chapter id="catalogs">
<!--==========================orignal english content==========================
 <title>System Catalogs</title>
____________________________________________________________________________-->
 <title>系统目录</title>

<!--==========================orignal english content==========================
  <para>
   The system catalogs are the place where a relational database
   management system stores schema metadata, such as information about
   tables and columns, and internal bookkeeping information.
   <productname>PostgreSQL</productname>'s system catalogs are regular
   tables.  You can drop and recreate the tables, add columns, insert
   and update values, and severely mess up your system that way.
   Normally, one should not change the system catalogs by hand, there
   are normally SQL commands to do that.  (For example, <command>CREATE
   DATABASE</command> inserts a row into the
   <structname>pg_database</structname> catalog &mdash; and actually
   creates the database on disk.)  There are some exceptions for
   particularly esoteric operations, but many of those have been made
   available as SQL commands over time, and so the need for direct manipulation
   of the system catalogs is ever decreasing.
  </para>
____________________________________________________________________________-->
  <para>
   系统目录是关系型数据库存放模式元数据的地方，比如表和列的信息，以及内部统计信息等。<productname>PostgreSQL</productname>的系统目录就是普通表。你可以删除并重建这些表、增加列、插入和更新数值， 然后彻底把你的系统搞垮。 通常情况下，我们不应该手工修改系统目录，通常有SQL命令可以做这些事情。（例如，<command>CREATE DATABASE</command>向 <structname>pg_database</structname>表插入一行 &mdash; 并且实际上在磁盘上创建该数据库。）。 有几种特别深奥的操作例外，但是随着时间的流逝其中的很多也可以用 SQL 命令来完成，因此对系统目录直接修改的需求也越来越小。
  </para>

 <sect1 id="catalogs-overview">
<!--==========================orignal english content==========================
  <title>Overview</title>
____________________________________________________________________________-->
  <title>概述</title>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="catalog-table"/> lists the system catalogs.
   More detailed documentation of each catalog follows below.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="catalog-table"/>列出了系统目录。 每个目录更详细的文档见后文。
  </para>

<!--==========================orignal english content==========================
  <para>
   Most system catalogs are copied from the template database during
   database creation and are thereafter database-specific. A few
   catalogs are physically shared across all databases in a cluster;
   these are noted in the descriptions of the individual catalogs.
  </para>
____________________________________________________________________________-->
  <para>
   大多数系统目录都是在数据库创建的过程中从模版数据库中拷贝过来的， 因此都是数据库相关的。少数目录在物理上是在一个集簇的所有数据库间中共享的，这些将在每一个目录单独的描述中介绍。
  </para>

  <table id="catalog-table">
<!--==========================orignal english content==========================
   <title>System Catalogs</title>
____________________________________________________________________________-->
   <title>系统目录</title>

   <tgroup cols="2">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Catalog Name</entry>
      <entry>Purpose</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>目录名</entry>
      <entry>用途</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-aggregate"><structname>pg_aggregate</structname></link></entry>
      <entry>aggregate functions</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-aggregate"><structname>pg_aggregate</structname></link></entry>
      <entry>聚集函数</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-am"><structname>pg_am</structname></link></entry>
      <entry>relation access methods</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-am"><structname>pg_am</structname></link></entry>
      <entry>关系访问方法</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-amop"><structname>pg_amop</structname></link></entry>
      <entry>access method operators</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-amop"><structname>pg_amop</structname></link></entry>
      <entry>访问方法操作符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-amproc"><structname>pg_amproc</structname></link></entry>
      <entry>access method support functions</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-amproc"><structname>pg_amproc</structname></link></entry>
      <entry>访问方法支持函数</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-attrdef"><structname>pg_attrdef</structname></link></entry>
      <entry>column default values</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-attrdef"><structname>pg_attrdef</structname></link></entry>
      <entry>列默认值</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link></entry>
      <entry>table columns (<quote>attributes</quote>)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link></entry>
      <entry>表列(<quote>属性</quote>)</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link></entry>
      <entry>authorization identifiers (roles)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link></entry>
      <entry>认证标识符（角色）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-auth-members"><structname>pg_auth_members</structname></link></entry>
      <entry>authorization identifier membership relationships</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-auth-members"><structname>pg_auth_members</structname></link></entry>
      <entry>认证标识符成员关系</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-cast"><structname>pg_cast</structname></link></entry>
      <entry>casts (data type conversions)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-cast"><structname>pg_cast</structname></link></entry>
      <entry>转换（数据类型转换）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-class"><structname>pg_class</structname></link></entry>
      <entry>tables, indexes, sequences, views (<quote>relations</quote>)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-class"><structname>pg_class</structname></link></entry>
      <entry>表、索引、序列、视图 （<quote>关系</quote>）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-collation"><structname>pg_collation</structname></link></entry>
      <entry>collations (locale information)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-collation"><structname>pg_collation</structname></link></entry>
      <entry>排序规则（locale信息）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-constraint"><structname>pg_constraint</structname></link></entry>
      <entry>check constraints, unique constraints, primary key constraints, foreign key constraints</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-constraint"><structname>pg_constraint</structname></link></entry>
      <entry>检查约束、唯一约束、主键约束、外键约束</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-conversion"><structname>pg_conversion</structname></link></entry>
      <entry>encoding conversion information</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-conversion"><structname>pg_conversion</structname></link></entry>
      <entry>编码转换信息</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-database"><structname>pg_database</structname></link></entry>
      <entry>databases within this database cluster</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-database"><structname>pg_database</structname></link></entry>
      <entry>本数据库集簇中的数据库</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-db-role-setting"><structname>pg_db_role_setting</structname></link></entry>
      <entry>per-role and per-database settings</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-db-role-setting"><structname>pg_db_role_setting</structname></link></entry>
      <entry>每角色和每数据库的设置</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-default-acl"><structname>pg_default_acl</structname></link></entry>
      <entry>default privileges for object types</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-default-acl"><structname>pg_default_acl</structname></link></entry>
      <entry>对象类型的默认权限</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-depend"><structname>pg_depend</structname></link></entry>
      <entry>dependencies between database objects</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-depend"><structname>pg_depend</structname></link></entry>
      <entry>数据库对象间的依赖</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-description"><structname>pg_description</structname></link></entry>
      <entry>descriptions or comments on database objects</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-description"><structname>pg_description</structname></link></entry>
      <entry>数据库对象上的描述或注释</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-enum"><structname>pg_enum</structname></link></entry>
      <entry>enum label and value definitions</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-enum"><structname>pg_enum</structname></link></entry>
      <entry>枚举标签和值定义</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-event-trigger"><structname>pg_event_trigger</structname></link></entry>
      <entry>event triggers</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-event-trigger"><structname>pg_event_trigger</structname></link></entry>
      <entry>事件触发器</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-extension"><structname>pg_extension</structname></link></entry>
      <entry>installed extensions</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-extension"><structname>pg_extension</structname></link></entry>
      <entry>已安装扩展</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-foreign-data-wrapper"><structname>pg_foreign_data_wrapper</structname></link></entry>
      <entry>foreign-data wrapper definitions</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-foreign-data-wrapper"><structname>pg_foreign_data_wrapper</structname></link></entry>
      <entry>外部数据包装器定义</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-foreign-server"><structname>pg_foreign_server</structname></link></entry>
      <entry>foreign server definitions</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-foreign-server"><structname>pg_foreign_server</structname></link></entry>
      <entry>外部服务器定义</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-foreign-table"><structname>pg_foreign_table</structname></link></entry>
      <entry>additional foreign table information</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-foreign-table"><structname>pg_foreign_table</structname></link></entry>
      <entry>外部表信息</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-index"><structname>pg_index</structname></link></entry>
      <entry>additional index information</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-index"><structname>pg_index</structname></link></entry>
      <entry>索引信息</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-inherits"><structname>pg_inherits</structname></link></entry>
      <entry>table inheritance hierarchy</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-inherits"><structname>pg_inherits</structname></link></entry>
      <entry>表继承层次</entry>
     </row>
     
<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-init-privs"><structname>pg_init_privs</structname></link></entry>
      <entry>object initial privileges</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-init-privs"><structname>pg_init_privs</structname></link></entry>
      <entry>对象初始特权</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-language"><structname>pg_language</structname></link></entry>
      <entry>languages for writing functions</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-language"><structname>pg_language</structname></link></entry>
      <entry>编写函数的语言</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-largeobject"><structname>pg_largeobject</structname></link></entry>
      <entry>data pages for large objects</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-largeobject"><structname>pg_largeobject</structname></link></entry>
      <entry>大对象的数据页</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-largeobject-metadata"><structname>pg_largeobject_metadata</structname></link></entry>
      <entry>metadata for large objects</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-largeobject-metadata"><structname>pg_largeobject_metadata</structname></link></entry>
      <entry>大对象的元数据</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link></entry>
      <entry>schemas</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link></entry>
      <entry>模式</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link></entry>
      <entry>access method operator classes</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link></entry>
      <entry>访问方法操作符类</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link></entry>
      <entry>operators</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link></entry>
      <entry>操作符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link></entry>
      <entry>access method operator families</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link></entry>
      <entry>访问方法操作符族</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-partitioned-table"><structname>pg_partitioned_table</structname></link></entry>
      <entry>information about partition key of tables</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-partitioned-table"><structname>pg_partitioned_table</structname></link></entry>
      <entry>表的分区键的信息</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-pltemplate"><structname>pg_pltemplate</structname></link></entry>
      <entry>template data for procedural languages</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-pltemplate"><structname>pg_pltemplate</structname></link></entry>
      <entry>过程语言的模板数据</entry>
     </row>
     
<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-policy"><structname>pg_policy</structname></link></entry>
      <entry>row-security policies</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-policy"><structname>pg_policy</structname></link></entry>
      <entry>行安全策略</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link></entry>
      <entry>functions and procedures</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link></entry>
      <entry>函数和过程</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-publication"><structname>pg_publication</structname></link></entry>
      <entry>publications for logical replication</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-publication"><structname>pg_publication</structname></link></entry>
      <entry>用于逻辑复制的发布</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-publication-rel"><structname>pg_publication_rel</structname></link></entry>
      <entry>relation to publication mapping</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-publication-rel"><structname>pg_publication_rel</structname></link></entry>
      <entry>发布映射的关系</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-range"><structname>pg_range</structname></link></entry>
      <entry>information about range types</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-range"><structname>pg_range</structname></link></entry>
      <entry>范围类型的信息</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-replication-origin"><structname>pg_replication_origin</structname></link></entry>
      <entry>registered replication origins</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-replication-origin"><structname>pg_replication_origin</structname></link></entry>
      <entry>已注册的复制源</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-rewrite"><structname>pg_rewrite</structname></link></entry>
      <entry>query rewrite rules</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-rewrite"><structname>pg_rewrite</structname></link></entry>
      <entry>查询重写规则</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-seclabel"><structname>pg_seclabel</structname></link></entry>
      <entry>security labels on database objects</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-seclabel"><structname>pg_seclabel</structname></link></entry>
      <entry>数据库对象上的安全标签</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-sequence"><structname>pg_sequence</structname></link></entry>
      <entry>information about sequences</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-sequence"><structname>pg_sequence</structname></link></entry>
      <entry>有关序列的信息</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-shdepend"><structname>pg_shdepend</structname></link></entry>
      <entry>dependencies on shared objects</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-shdepend"><structname>pg_shdepend</structname></link></entry>
      <entry>共享对象上的依赖</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-shdescription"><structname>pg_shdescription</structname></link></entry>
      <entry>comments on shared objects</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-shdescription"><structname>pg_shdescription</structname></link></entry>
      <entry>共享对象上的注释</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-shseclabel"><structname>pg_shseclabel</structname></link></entry>
      <entry>security labels on shared database objects</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-shseclabel"><structname>pg_shseclabel</structname></link></entry>
      <entry>共享数据库对象上的安全标签</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-statistic"><structname>pg_statistic</structname></link></entry>
      <entry>planner statistics</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-statistic"><structname>pg_statistic</structname></link></entry>
      <entry>规划器统计</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-statistic-ext"><structname>pg_statistic_ext</structname></link></entry>
      <entry>extended planner statistics (definition)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-statistic-ext"><structname>pg_statistic_ext</structname></link></entry>
      <entry>扩展的规划器统计信息（定义）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-statistic-ext-data"><structname>pg_statistic_ext_data</structname></link></entry>
      <entry>extended planner statistics (built statistics)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-statistic-ext-data"><structname>pg_statistic_ext_data</structname></link></entry>
      <entry>扩展的规划器统计信息（已构建的统计信息）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-subscription"><structname>pg_subscription</structname></link></entry>
      <entry>logical replication subscriptions</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-subscription"><structname>pg_subscription</structname></link></entry>
      <entry>逻辑复制订阅</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-subscription-rel"><structname>pg_subscription_rel</structname></link></entry>
      <entry>relation state for subscriptions</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-subscription-rel"><structname>pg_subscription_rel</structname></link></entry>
      <entry>订阅的关系状态</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link></entry>
      <entry>tablespaces within this database cluster</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link></entry>
      <entry>本数据库集簇内的表空间</entry>
     </row>
     
<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-transform"><structname>pg_transform</structname></link></entry>
      <entry>transforms (data type to procedural language conversions)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-transform"><structname>pg_transform</structname></link></entry>
      <entry>转换（将数据类型转换为过程语言需要的形式）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-trigger"><structname>pg_trigger</structname></link></entry>
      <entry>triggers</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-trigger"><structname>pg_trigger</structname></link></entry>
      <entry>触发器</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-ts-config"><structname>pg_ts_config</structname></link></entry>
      <entry>text search configurations</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-ts-config"><structname>pg_ts_config</structname></link></entry>
      <entry>文本搜索配置</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-ts-config-map"><structname>pg_ts_config_map</structname></link></entry>
      <entry>text search configurations' token mappings</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-ts-config-map"><structname>pg_ts_config_map</structname></link></entry>
      <entry>文本搜索配置的记号映射</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-ts-dict"><structname>pg_ts_dict</structname></link></entry>
      <entry>text search dictionaries</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-ts-dict"><structname>pg_ts_dict</structname></link></entry>
      <entry>文本搜索字典</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-ts-parser"><structname>pg_ts_parser</structname></link></entry>
      <entry>text search parsers</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-ts-parser"><structname>pg_ts_parser</structname></link></entry>
      <entry>文本搜索分析器</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-ts-template"><structname>pg_ts_template</structname></link></entry>
      <entry>text search templates</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-ts-template"><structname>pg_ts_template</structname></link></entry>
      <entry>文本搜索模板</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-type"><structname>pg_type</structname></link></entry>
      <entry>data types</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-type"><structname>pg_type</structname></link></entry>
      <entry>数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="catalog-pg-user-mapping"><structname>pg_user_mapping</structname></link></entry>
      <entry>mappings of users to foreign servers</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="catalog-pg-user-mapping"><structname>pg_user_mapping</structname></link></entry>
      <entry>将用户映射到外部服务器</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-aggregate">
<!--==========================orignal english content==========================
  <title><structname>pg_aggregate</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_aggregate</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-aggregate">
   <primary>pg_aggregate</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-aggregate">
   <primary>pg_aggregate</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_aggregate</structname> stores information about
   aggregate functions.  An aggregate function is a function that
   operates on a set of values (typically one column from each row
   that matches a query condition) and returns a single value computed
   from all these values.  Typical aggregate functions are
   <function>sum</function>, <function>count</function>, and
   <function>max</function>.  Each entry in
   <structname>pg_aggregate</structname> is an extension of an entry
   in <structname>pg_proc</structname>.  The <structname>pg_proc</structname>
   entry carries the aggregate's name, input and output data types, and
   other information that is similar to ordinary functions.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_aggregate</structname>存储关于聚集函数的信息。聚集函数是对一个数值集合（典型的是每个匹配查询条件的行中的同一个列的值） 进行操作的函数，它返回从这些值中计算出的一个数值。 典型的聚集函数是 <function>sum</function>、<function>count</function>和<function>max</function>。<structname>pg_aggregate</structname>里的每个项都是一个<structname>pg_proc</structname>项的扩展。<structname>pg_proc</structname>项记载该聚集的名字、输入和输出数据类型，以及其他一些和普通函数类似的信息。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_aggregate</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_aggregate</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>aggfnoid</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry><structname>pg_proc</structname> OID of the aggregate function</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>aggfnoid</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>聚集函数在<structname>pg_proc</structname>中的OID</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>aggkind</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>Aggregate kind:
       <literal>n</literal> for <quote>normal</quote> aggregates,
       <literal>o</literal> for <quote>ordered-set</quote> aggregates, or
       <literal>h</literal> for <quote>hypothetical-set</quote> aggregates
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>aggkind</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>聚集类型：
       <literal>n</literal>表示<quote>普通</quote>聚集，
       <literal>o</literal>表示<quote>有序集</quote>聚集，或者
       <literal>h</literal>表示<quote>假想集</quote>聚集
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>aggnumdirectargs</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Number of direct (non-aggregated) arguments of an ordered-set or
       hypothetical-set aggregate, counting a variadic array as one argument.
       If equal to <structfield>pronargs</structfield>, the aggregate must be variadic
       and the variadic array describes the aggregated arguments as well as
       the final direct arguments.
       Always zero for normal aggregates.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>aggnumdirectargs</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>一个有序集或者假想集聚集的直接（非聚集）参数的数量，一个可变数组算作一个参数。
       如果等于<structfield>pronargs</structfield>，该聚集必定是可变的并且该可变数组描述聚集参数以
       及最终直接参数。对于普通聚集总是为零。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>aggtransfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Transition function</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>aggtransfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>转移函数</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>aggfinalfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Final function (zero if none)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>aggfinalfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>最终函数（如果没有就为零）</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>aggcombinefn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Combine function (zero if none)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>aggcombinefn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>结合函数（如果没有就为零）</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>aggserialfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Serialization function (zero if none)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>aggserialfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>序列化函数（如果没有就为零）</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>aggdeserialfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Deserialization function (zero if none)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>aggdeserialfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>反序列化函数（如果没有就为零）</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>aggmtransfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Forward transition function for moving-aggregate mode (zero if none)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>aggmtransfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>用于移动聚集模式的向前转移函数（如果没有就为零）</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>aggminvtransfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Inverse transition function for moving-aggregate mode (zero if none)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>aggminvtransfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>用于移动聚集模式的反向转移函数（如果没有就为零）</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>aggmfinalfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Final function for moving-aggregate mode (zero if none)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>aggmfinalfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>用于移动聚集模式的最终函数（如果没有就为零）</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>aggfinalextra</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True to pass extra dummy arguments to <structfield>aggfinalfn</structfield></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>aggfinalextra</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>为真则向
      <structfield>aggfinalfn</structfield>传递额外的哑参数</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>aggmfinalextra</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True to pass extra dummy arguments to <structfield>aggmfinalfn</structfield></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>aggmfinalextra</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>为真则向
      <structfield>aggmfinalfn</structfield>传递额外的哑参数</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>aggfinalmodify</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>Whether <structfield>aggfinalfn</structfield> modifies the
       transition state value:
       <literal>r</literal> if it is read-only,
       <literal>s</literal> if the <structfield>aggtransfn</structfield>
       cannot be applied after the <structfield>aggfinalfn</structfield>, or
       <literal>w</literal> if it writes on the value
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>aggfinalmodify</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry><structfield>aggfinalfn</structfield>是否修改传递状态值：
       如果是只读则为<literal>r</literal>，
       如果不能在<structfield>aggfinalfn</structfield>之后应用<structfield>aggtransfn</structfield>则为<literal>s</literal>，
       如果它修改该值则为<literal>w</literal>
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>aggmfinalmodify</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>Like <structfield>aggfinalmodify</structfield>, but for
       the <structfield>aggmfinalfn</structfield>
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>aggmfinalmodify</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>和<structfield>aggfinalmodify</structfield>类似，但是用于<structfield>aggmfinalfn</structfield>
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>aggsortop</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>Associated sort operator (zero if none)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>aggsortop</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>相关联的排序操作符（如果没有则为0）</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>aggtranstype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Data type of the aggregate function's internal transition (state) data</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>aggtranstype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>聚集函数的内部转移（状态）数据的数据类型</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>aggtransspace</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Approximate average size (in bytes) of the transition state
       data, or zero to use a default estimate</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>aggtransspace</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>转移状态数据的近似平均尺寸（字节），或者为零表示使用一个默认估算值</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>aggmtranstype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Data type of the aggregate function's internal transition (state)
       data for moving-aggregate mode (zero if none)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>aggmtranstype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>聚集函数用于移动聚集欧氏的内部转移（状态）数据的数据类型（如果没有则为零）</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>aggmtransspace</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Approximate average size (in bytes) of the transition state data
       for moving-aggregate mode, or zero to use a default estimate</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>aggmtransspace</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>转移状态数据的近似平均尺寸（字节），或者为零表示使用一个默认估算值</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>agginitval</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       The initial value of the transition state.  This is a text
       field containing the initial value in its external string
       representation.  If this field is null, the transition state
       value starts out null.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>agginitval</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       转移状态的初始值。这是一个文本域，它包含初始值的外部字符串表现形式。如果这个域为空，则转移状态值从空值开始。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>aggminitval</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       The initial value of the transition state for moving-aggregate mode.
       This is a text field containing the initial value in its external
       string representation.  If this field is null, the transition state
       value starts out null.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>aggminitval</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       用于移动聚集模式的转移状态初值。这是一个文本域，它包含了以其文本字符串形式表达的初值。
       如果这个域为空，则转移状态值从空值开始。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   New aggregate functions are registered with the <xref
   linkend="sql-createaggregate"/>
   command.  See <xref linkend="xaggr"/> for more information about
   writing aggregate functions and the meaning of the transition
   functions, etc.
  </para>
____________________________________________________________________________-->
  <para>
   新的聚集函数可通过<xref linkend="sql-createaggregate"/>命令注册。更多关于编写聚集函数以及转移函数的含义等信息请参见<xref linkend="xaggr"/>。
  </para>

 </sect1>


 <sect1 id="catalog-pg-am">
<!--==========================orignal english content==========================
  <title><structname>pg_am</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_am</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-am">
   <primary>pg_am</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-am">
   <primary>pg_am</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_am</structname> stores information about
   relation access methods.  There is one row for each access method supported
   by the system.
   Currently, only tables and indexes have access methods. The requirements for table
   and index access methods are discussed in detail in <xref linkend="tableam"/> and
   <xref linkend="indexam"/> respectively.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_am</structname>存储关于关系访问方法的信息。系统支持的每种访问方法在这个目录中都有一行。目前只有表和索引拥有访问方法。表和索引访问方法的需求分别在<xref linkend="tableam"/>和<xref linkend="indexam"/>中详细讨论。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_am</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_am</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Row identifier</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>amname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the access method</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>amname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>访问方法的名字</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>amhandler</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       OID of a handler function that is responsible for supplying information
       about the access method
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>amhandler</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       负责提供有关该访问方法信息的处理器函数的 OID
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>amtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <literal>t</literal> = table (including materialized views),
       <literal>i</literal> = index. 
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>amtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <literal>t</literal> = 表(包括物化视图),
       <literal>i</literal> = 索引.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  
  <note>
<!--==========================orignal english content==========================
   <para>
    Before <productname>PostgreSQL</productname> 9.6, <structname>pg_am</structname>
    contained many additional columns representing properties of index access
    methods.  That data is now only directly visible at the C code level.
    However, <function>pg_index_column_has_property()</function> and related
    functions have been added to allow SQL queries to inspect index access
    method properties; see <xref linkend="functions-info-catalog-table"/>.
   </para>
____________________________________________________________________________-->
   <para>
    在<productname>PostgreSQL</productname> 9.6 之前，<structname>pg_am</structname>包含很多额外的列以表示索引访问方法的性质。那些数据现在只有在 C 代码级别才是直接可见的。不过，系统中增加了<function>pg_index_column_has_property()</function>和一些相关函数来允许 SQL 查询检查索引访问方法的性质，请见<xref linkend="functions-info-catalog-table"/>。
   </para>
  </note>

 </sect1>


 <sect1 id="catalog-pg-amop">
<!--==========================orignal english content==========================
  <title><structname>pg_amop</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_amop</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-amop">
   <primary>pg_amop</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-amop">
   <primary>pg_amop</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_amop</structname> stores information about
   operators associated with access method operator families.  There is one
   row for each operator that is a member of an operator family.  A family
   member can be either a <firstterm>search</firstterm> operator or an
   <firstterm>ordering</firstterm> operator.  An operator
   can appear in more than one family, but cannot appear in more than one
   search position nor more than one ordering position within a family.
   (It is allowed, though unlikely, for an operator to be used for both
   search and ordering purposes.)
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_amop</structname>存储关于与访问方法操作符族相关的操作符信息。对于一个操作符族中的每一个成员即操作符都在这个目录中有一行。一个成员可以是一个<firstterm>搜索</firstterm>操作符或者一个<firstterm>排序</firstterm>操作符。一个操作符可以出现在多个族中，但在同一个组中既不能出现在多个搜索位置也不能出现在多个排序位置（虽然不太可能出现，但是允许一个操作符同时用于搜索和排序目的）。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_amop</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_amop</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Row identifier</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>amopfamily</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>.oid</literal></entry>
      <entry>The operator family this entry is for</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>amopfamily</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>.oid</literal></entry>
      <entry>这个项所在的操作符族</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>amoplefttype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Left-hand input data type of operator</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>amoplefttype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>操作符的左手输入数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>amoprighttype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Right-hand input data type of operator</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>amoprighttype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>操作符的右手输入数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>amopstrategy</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Operator strategy number</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>amopstrategy</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>操作符策略号</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>amoppurpose</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>Operator purpose, either <literal>s</literal> for search or
       <literal>o</literal> for ordering</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>amoppurpose</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>操作符目的，<literal>s</literal>表示搜索，<literal>o</literal>表示排序</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>amopopr</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>OID of the operator</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>amopopr</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>操作符的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>amopmethod</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-am"><structname>pg_am</structname></link>.oid</literal></entry>
      <entry>Index access method operator family is for</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>amopmethod</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-am"><structname>pg_am</structname></link>.oid</literal></entry>
      <entry>使用此操作符族的索引访问方法</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>amopsortfamily</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>.oid</literal></entry>
      <entry>The B-tree operator family this entry sorts according to, if an
       ordering operator; zero if a search operator</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>amopsortfamily</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>.oid</literal></entry>
      <entry>如果是一个排序操作符，该项会根据这个 B树操作符族排序，如果是一个搜索操作符则为0</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   A <quote>search</quote> operator entry indicates that an index of this operator
   family can be searched to find all rows satisfying
   <literal>WHERE</literal>
   <replaceable>indexed_column</replaceable>
   <replaceable>operator</replaceable>
   <replaceable>constant</replaceable>.
   Obviously, such an operator must return <type>boolean</type>, and its left-hand input
   type must match the index's column data type.
  </para>
____________________________________________________________________________-->
  <para>
   一个<quote>搜索</quote>操作符项意味着该操作符族的一个索引可以被搜索来查找所有满足如下条件的行：
   <literal>WHERE</literal>
   <replaceable>indexed_column</replaceable>
   <replaceable>operator</replaceable>
   <replaceable>constant</replaceable>。
   显然，这样的一个操作符必须返回<type>boolean</type>，且它的左手输入类型必须匹配索引列的数据类型。
  </para>

<!--==========================orignal english content==========================
  <para>
   An <quote>ordering</quote> operator entry indicates that an index of this
   operator family can be scanned to return rows in the order represented by
   <literal>ORDER BY</literal>
   <replaceable>indexed_column</replaceable>
   <replaceable>operator</replaceable>
   <replaceable>constant</replaceable>.
   Such an operator could return any sortable data type, though again
   its left-hand input type must match the index's column data type.
   The exact semantics of the <literal>ORDER BY</literal> are specified by the
   <structfield>amopsortfamily</structfield> column, which must reference
   a B-tree operator family for the operator's result type.
  </para>
____________________________________________________________________________-->
  <para>
   一个<quote>排序</quote>操作符项意味着该操作符族的一个索引可以被扫描来返回以如下顺序排列的行：
   <literal>ORDER BY</literal>
   <replaceable>indexed_column</replaceable>
   <replaceable>operator</replaceable>
   <replaceable>constant</replaceable>。
   这样一个操作符能够返回任何可排序数据类型，尽管它的左手输入类型必须匹配索引列的数据类型。
   <literal>ORDER BY</literal>的准确语义由<structfield>amopsortfamily</structfield>列指定，它必须引用一个适合于操作符结果类型的B树操作符族。
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    At present, it's assumed that the sort order for an ordering operator
    is the default for the referenced operator family, i.e., <literal>ASC NULLS
    LAST</literal>.  This might someday be relaxed by adding additional columns
    to specify sort options explicitly.
   </para>
____________________________________________________________________________-->
   <para>
    目前，一个排序操作符的排序顺序被假设为其引用的操作符族的默认值，即<literal>ASC NULLS LAST</literal>。未来可能会通过增加额外的列来显式地指定排序选项。
   </para>
  </note>

<!--==========================orignal english content==========================
  <para>
   An entry's <structfield>amopmethod</structfield> must match the
   <structname>opfmethod</structname> of its containing operator family (including
   <structfield>amopmethod</structfield> here is an intentional denormalization of the
   catalog structure for performance reasons).  Also,
   <structfield>amoplefttype</structfield> and <structfield>amoprighttype</structfield> must match
   the <structfield>oprleft</structfield> and <structfield>oprright</structfield> fields of the
   referenced <structname>pg_operator</structname> entry.
  </para>
____________________________________________________________________________-->
  <para>
   一个项的<structfield>amopmethod</structfield>必须和它所包含的操作符族的<structname>opfmethod</structname>相匹配（这里包括<structfield>amopmethod</structfield>是一个为了性能原因而故意对目录结构做的反规范化）。此外，<structfield>amoplefttype</structfield>和<structfield>amoprighttype</structfield>也必须匹配被引用的<structname>pg_operator</structname>项的<structfield>oprleft</structfield>和<structfield>oprright</structfield>域。
  </para>

 </sect1>


 <sect1 id="catalog-pg-amproc">
<!--==========================orignal english content==========================
  <title><structname>pg_amproc</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_amproc</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-amproc">
   <primary>pg_amproc</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-amproc">
   <primary>pg_amproc</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_amproc</structname> stores information about
   support functions associated with access method operator families.  There
   is one row for each support function belonging to an operator family.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_amproc</structname>存储关于访问方法操作符族相关的支持函数。属于一个操作符族的每一个支持函数在这个目录中都有一行。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_amproc</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_amproc</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Row identifier</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>amprocfamily</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>.oid</literal></entry>
      <entry>The operator family this entry is for</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>amprocfamily</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>.oid</literal></entry>
      <entry>使用这个项的操作符族</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>amproclefttype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Left-hand input data type of associated operator</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>amproclefttype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>相关操作符的左手输入数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>amprocrighttype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Right-hand input data type of associated operator</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>amprocrighttype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>相关操作符的右手输入数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>amprocnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Support function number</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>amprocnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>支持过程编号</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>amproc</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID of the function</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>amproc</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>过程的OID</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   The usual interpretation of the
   <structfield>amproclefttype</structfield> and <structfield>amprocrighttype</structfield> fields
   is that they identify the left and right input types of the operator(s)
   that a particular support function supports.  For some access methods
   these match the input data type(s) of the support function itself, for
   others not.  There is a notion of <quote>default</quote> support functions for
   an index, which are those with <structfield>amproclefttype</structfield> and
   <structfield>amprocrighttype</structfield> both equal to the index operator class's
   <structfield>opcintype</structfield>.
  </para>
____________________________________________________________________________-->
  <para>
   <structfield>amproclefttype</structfield>和<structfield>amprocrighttype</structfield>列的通常解释是它们标识了一个特定支持过程所支持的操作符的左右输入类型。对于某些访问方法它们和支持过程本身的输入数据类型相匹配，而对其他的则不会匹配。对于一个索引有一个<quote>默认</quote>支持过程的概念，这些支持过程的<structfield>amproclefttype</structfield>和<structfield>amprocrighttype</structfield>都等于索引操作符类的<structfield>opcintype</structfield>。
  </para>

 </sect1>


 <sect1 id="catalog-pg-attrdef">
<!--==========================orignal english content==========================
  <title><structname>pg_attrdef</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_attrdef</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-attrdef">
   <primary>pg_attrdef</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-attrdef">
   <primary>pg_attrdef</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_attrdef</structname> stores column default
   values.  The main information about columns is stored in
   <link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.
   Only columns for which a default value has been explicitly set will have
   an entry here.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_attrdef</structname>存储列的默认值。列的主要信息存储在<structname>pg_attribute</structname>。只有那些显式指定了一个默认值的列才会在这个目录中有一个项。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_attrdef</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_attrdef</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Row identifier</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>adrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The table this column belongs to</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>adrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>该列所属的表</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>adnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>The number of the column</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>adnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>列号</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>adbin</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>The column default value, in <function>nodeToString()</function>
      representation.  Use <literal>pg_get_expr(adbin, adrelid)</literal> to
      convert it to an SQL expression.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>adbin</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>列的默认值，以<function>nodeToString()</function>表示。用<literal>pg_get_expr(adbin, adrelid)</literal>将其转换为SQL表达式。</entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-attribute">
<!--==========================orignal english content==========================
  <title><structname>pg_attribute</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_attribute</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-attribute">
   <primary>pg_attribute</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-attribute">
   <primary>pg_attribute</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_attribute</structname> stores information about
   table columns.  There will be exactly one
   <structname>pg_attribute</structname> row for every column in every
   table in the database.  (There will also be attribute entries for
   indexes, and indeed all objects that have <structname>pg_class</structname>
   entries.)
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_attribute</structname>存储有关表列的信息。数据库中的每一个表的每一个列都恰好在<structname>pg_attribute</structname>中有一行。（这其中也会有索引的属性项，并且事实上所有具有<structname>pg_class</structname>项的对象在这里都有属性项）
   entries.)
  </para>

<!--==========================orignal english content==========================
  <para>
   The term attribute is equivalent to column and is used for
   historical reasons.
  </para>
____________________________________________________________________________-->
  <para>
   术语属性等同于列，这里使用它只是出于历史原因。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_attribute</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_attribute</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>attrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The table this column belongs to</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>attrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>列所属的表</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>attname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>The column name</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>attname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>列名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>atttypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>The data type of this column</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>atttypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>列的数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>attstattarget</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       <structfield>attstattarget</structfield> controls the level of detail
       of statistics accumulated for this column by
       <xref linkend="sql-analyze"/>.
       A zero value indicates that no statistics should be collected.
       A negative value says to use the system default statistics target.
       The exact meaning of positive values is data type-dependent.
       For scalar data types, <structfield>attstattarget</structfield>
       is both the target number of <quote>most common values</quote>
       to collect, and the target number of histogram bins to create.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>attstattarget</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       <structfield>attstattarget</structfield>控制由<xref linkend="sql-analyze"/>对此列收集的统计信息的细节层次。0值表示不会收集任何统计信息。一个负值则说明直接使用系统默认的目标。正值的确切含义取决于数据类型。对于标量数据类型，<structfield>attstattarget</structfield>既是要收集的<quote>最常见值</quote>的目标号，也是要创建的柱状图容器的目标号。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>attlen</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       A copy of <literal>pg_type.typlen</literal> of this column's
       type
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>attlen</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       本列类型的<literal>pg_type.typlen</literal>一个拷贝
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>attnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       The number of the column.  Ordinary columns are numbered from 1
       up.  System columns, such as <structfield>ctid</structfield>,
       have (arbitrary) negative numbers.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>attnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       列的编号。一般列从1开始向上编号。系统列（如<structfield>ctid</structfield>）则拥有（任意）负值编号。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>attndims</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Number of dimensions, if the column is an array type; otherwise 0.
       (Presently, the number of dimensions of an array is not enforced,
       so any nonzero value effectively means <quote>it's an array</quote>.)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>attndims</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       如果该列是一个数组类型，这里就是其维度数；否则为0。（在目前一个数组的维度数并不被强制，因此任何非零值都能有效地表明<quote>这是一个数组</quote>。）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>attcacheoff</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Always -1 in storage, but when loaded into a row descriptor
       in memory this might be updated to cache the offset of the attribute
       within the row
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>attcacheoff</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       在存储中总是为-1，但是当被载入到一个内存中的行描述符后，这里可能会被更新为属性在行内的偏移
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>atttypmod</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       <structfield>atttypmod</structfield> records type-specific data
       supplied at table creation time (for example, the maximum
       length of a <type>varchar</type> column).  It is passed to
       type-specific input functions and length coercion functions.
       The value will generally be -1 for types that do not need <structfield>atttypmod</structfield>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>atttypmod</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       <structfield>atttypmod</structfield>记录了在表创建时提供的类型相关数据（例如一个<type>varchar</type>列的最大长度）。它会被传递给类型相关的输入函数和长度强制函数。对于那些不需要<structfield>atttypmod</structfield>的类型，这个值通常总是为-1。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>attbyval</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       A copy of <literal>pg_type.typbyval</literal> of this column's type
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>attbyval</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       该列类型的<literal>pg_type.typbyval</literal>的一个拷贝
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>attstorage</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Normally a copy of <literal>pg_type.typstorage</literal> of this
       column's type.  For TOAST-able data types, this can be altered
       after column creation to control storage policy.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>attstorage</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       通常是该列类型的<literal>pg_type.typstorage</literal>的一个拷贝。对于可TOAST的数据类型，这可以在列创建后被修改以控制存储策略。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>attalign</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       A copy of <literal>pg_type.typalign</literal> of this column's type
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>attalign</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       该列类型的<literal>pg_type.typalign</literal>的一个拷贝
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>attnotnull</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       This represents a not-null constraint.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>attnotnull</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       这表示一个非空约束。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>atthasdef</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       This column has a default expression or generation expression, in which
       case there will be a corresponding entry in the
       <structname>pg_attrdef</structname> catalog that actually defines the
       expression.  (Check <structfield>attgenerated</structfield> to
       determine whether this is a default or a generation expression.)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>atthasdef</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
      该列有一个默认表达式或生成的表达式，在此情况下在<structname>pg_attrdef</structname>目录中会有一个对应项来真正定义该表达式。（检查<structfield>attgenerated</structfield>以确定是默认还是生成的表达式。）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>atthasmissing</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       This column has a value which is used where the column is entirely
       missing from the row, as happens when a column is added with a
       non-volatile <literal>DEFAULT</literal> value after the row is created.
       The actual value used is stored in the
       <structfield>attmissingval</structfield> column.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>atthasmissing</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       该列在行中完全缺失时会用到这个列的值，如果在行创建之后增加一个有非易失<literal>DEFAULT</literal>值的列，就会发生这种情况。实际使用的值被存放在<structfield>attmissingval</structfield>列中。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>attidentity</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       If a zero byte (<literal>''</literal>), then not an identity column.
       Otherwise, <literal>a</literal> = generated
       always, <literal>d</literal> = generated by default.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>attidentity</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       如果是一个零字节（<literal>''</literal>），则不是一个标识列。否则，<literal>a</literal> = 总是生成，<literal>d</literal> = 默认生成。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>attgenerated</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       If a zero byte (<literal>''</literal>), then not a generated column.
       Otherwise, <literal>s</literal> = stored.  (Other values might be added
       in the future.)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>attgenerated</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       如果为零字节(<literal>''</literal>)，则不是生成的列。否则，<literal>s</literal> = stored。（将来可能会添加其他值。）
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>attisdropped</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       This column has been dropped and is no longer valid.  A dropped
       column is still physically present in the table, but is
       ignored by the parser and so cannot be accessed via SQL.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>attisdropped</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       该列被删除且不再有效。一个删除的列仍然物理存在于表中，但是会被分析器忽略并因此无法通过SQL访问。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>attislocal</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       This column is defined locally in the relation.  Note that a column can
       be locally defined and inherited simultaneously.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>attislocal</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       该列是由关系本地定义的。注意一个列可以同时是本地定义和继承的。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>attinhcount</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       The number of direct ancestors this column has.  A column with a
       nonzero number of ancestors cannot be dropped nor renamed.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>attinhcount</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       该列的直接祖先的编号。一个具有非零编号祖先的列不能被删除或者重命名。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>attcollation</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-collation"><structname>pg_collation</structname></link>.oid</literal></entry>
      <entry>
       The defined collation of the column, or zero if the column is
       not of a collatable data type.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>attcollation</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-collation"><structname>pg_collation</structname></link>.oid</literal></entry>
      <entry>
       该列被定义的排序规则，如果该列不是一个可排序数据类型则为0。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>attacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       Column-level access privileges, if any have been granted specifically
       on this column
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>attacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       列级访问权限
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>attoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       Attribute-level options, as <quote>keyword=value</quote> strings
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>attoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       属性级选项，以<quote>keyword=value</quote>形式的字符串
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>attfdwoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       Attribute-level foreign data wrapper options, as <quote>keyword=value</quote> strings
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>attfdwoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       属性级的外部数据包装器选项，以<quote>keyword=value</quote>形式的字符串
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>attmissingval</structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>
       This column has a one element array containing the value used when the
       column is entirely missing from the row, as happens when the column is
       added with a non-volatile <literal>DEFAULT</literal> value after the
       row is created.  The value is only used when
       <structfield>atthasmissing</structfield> is true.  If there is no value
       the column is null.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>attmissingval</structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>
       这个列中是一个含有一个元素的数组，其中的值被用于该列在行中完全缺失时，如果在行创建之后增加一个有非易失<literal>DEFAULT</literal>值的列，就会发生这种情况。只有当<structfield>atthasmissing</structfield>为真时才使用这个值。如果没有值则该列为空。
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   In a dropped column's <structname>pg_attribute</structname> entry,
   <structfield>atttypid</structfield> is reset to zero, but
   <structfield>attlen</structfield> and the other fields copied from
   <structname>pg_type</structname> are still valid.  This arrangement is needed
   to cope with the situation where the dropped column's data type was
   later dropped, and so there is no <structname>pg_type</structname> row anymore.
   <structfield>attlen</structfield> and the other fields can be used
   to interpret the contents of a row of the table.
  </para>
____________________________________________________________________________-->
  <para>
   在一个被删除的列的<structname>pg_attribute</structname>的项中，<structfield>atttypid</structfield>被重置为0，但<structfield>attlen</structfield>以及其他从<structname>pg_type</structname>拷贝的域仍然有效。这种安排用于处理一种情况，即被删除列的数据类型后来被删除，并且因此不再有相应的<structname>pg_type</structname>行。<structfield>attlen</structfield>和其他域可以被用来解释表的一行的内容。
  </para>
 </sect1>


 <sect1 id="catalog-pg-authid">
<!--==========================orignal english content==========================
  <title><structname>pg_authid</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_authid</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-authid">
   <primary>pg_authid</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-authid">
   <primary>pg_authid</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_authid</structname> contains information about
   database authorization identifiers (roles).  A role subsumes the concepts
   of <quote>users</quote> and <quote>groups</quote>.  A user is essentially just a
   role with the <structfield>rolcanlogin</structfield> flag set.  Any role (with or
   without <structfield>rolcanlogin</structfield>) can have other roles as members; see
   <link linkend="catalog-pg-auth-members"><structname>pg_auth_members</structname></link>.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_authid</structname>包含关于数据库授权标识符（角色）的信息。角色把<quote>用户</quote>和<quote>组</quote>的概念包含在内。一个用户实际上就是一个<structfield>rolcanlogin</structfield>标志被设置的角色。任何角色（不管<structfield>rolcanlogin</structfield>设置与否）都能够把其他角色作为成员，参见<link linkend="catalog-pg-auth-members"><structname>pg_auth_members</structname></link>。
  </para>

<!--==========================orignal english content==========================
  <para>
   Since this catalog contains passwords, it must not be publicly readable.
   <link linkend="view-pg-roles"><structname>pg_roles</structname></link>
   is a publicly readable view on
   <structname>pg_authid</structname> that blanks out the password field.
  </para>
____________________________________________________________________________-->
  <para>
   由于这个目录包含口令，它不能是公共可读的。<link linkend="view-pg-roles"><structname>pg_roles</structname></link>是在<structname>pg_authid</structname>上的一个公共可读视图，它隐去了口令域。
  </para>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="user-manag"/> contains detailed information about user and
   privilege management.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="user-manag"/>包含关于用户和权限管理的详细信息。
  </para>

<!--==========================orignal english content==========================
  <para>
   Because user identities are cluster-wide,
   <structname>pg_authid</structname>
   is shared across all databases of a cluster: there is only one
   copy of <structname>pg_authid</structname> per cluster, not
   one per database.
  </para>
____________________________________________________________________________-->
  <para>
   由于用户标识符是集簇范围的，<structname>pg_authid</structname>在一个集簇的所有数据库之间共享：在一个集簇中只有一份<structname>pg_authid</structname>拷贝，而不是每个数据库一份。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_authid</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_authid</structname>的列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名字</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>Row identifier</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>行标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>rolname</structfield></entry>
      <entry><type>name</type></entry>
      <entry>Role name</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>rolname</structfield></entry>
      <entry><type>name</type></entry>
      <entry>角色名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>rolsuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>Role has superuser privileges</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>rolsuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>角色是否拥有超级用户权限</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>rolinherit</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>Role automatically inherits privileges of roles it is a
       member of</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>rolinherit</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>如果本角色是另一个角色的成员，本角色是否自动另一个角色的权限</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>rolcreaterole</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>Role can create more roles</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>rolcreaterole</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>角色是否能创建更多角色</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>rolcreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>Role can create databases</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>rolcreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>角色是否能创建数据库</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>rolcanlogin</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>
       Role can log in. That is, this role can be given as the initial
       session authorization identifier
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>rolcanlogin</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>
       角色是否能登录。即该角色是否能够作为初始会话授权标识符
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>rolreplication</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>
       Role is a replication role. A replication role can initiate replication
       connections and create and drop replication slots.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>rolreplication</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>
       角色是一个复制角色。复制角色可以启动复制连接并且创建和删除复制槽。
      </entry>
     </row>
     
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>rolbypassrls</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>
       Role bypasses every row level security policy, see
       <xref linkend="ddl-rowsecurity"/> for more information.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>rolbypassrls</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>
       角色是否可以绕过所有的行级安全性策略，详见
       <xref linkend="ddl-rowsecurity"/>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>rolconnlimit</structfield></entry>
      <entry><type>int4</type></entry>
      <entry>
       For roles that can log in, this sets maximum number of concurrent
       connections this role can make.  -1 means no limit.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>rolconnlimit</structfield></entry>
      <entry><type>int4</type></entry>
      <entry>
       对于可以登录的角色，本列设置该角色可以同时发起最大连接数。-1表示无限制。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>rolpassword</structfield></entry>
      <entry><type>text</type></entry>
      <entry>
       Password (possibly encrypted); null if none. The format depends
       on the form of encryption used.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>rolpassword</structfield></entry>
      <entry><type>text</type></entry>
      <entry>
       口令（可能被加密过），如果没有口令则为空。格式取决于使用的加密方法的形式。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>rolvaliduntil</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry>Password expiry time (only used for password authentication);
       null if no expiration</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>rolvaliduntil</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry>口令过期时间（只用于口令鉴定），如果永不过期则为空</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   For an MD5 encrypted password, <structfield>rolpassword</structfield>
   column will begin with the string <literal>md5</literal> followed by a
   32-character hexadecimal MD5 hash. The MD5 hash will be of the user's
   password concatenated to their user name. For example, if user
   <literal>joe</literal> has password <literal>xyzzy</literal>, <productname>PostgreSQL</productname>
   will store the md5 hash of <literal>xyzzyjoe</literal>.
  </para>
____________________________________________________________________________-->
  <para>
   对于一个MD5加密的口令，<structfield>rolpassword</structfield>列将由字符串<literal>md5</literal>后面跟上一个32字符的十六进制MD5哈希值构成。MD5哈希值将是该用户的口令串接上它们的用户名。例如，如果用户<literal>joe</literal>的口令是<literal>xyzzy</literal>，则<productname>PostgreSQL</productname>将存储<literal>xyzzyjoe</literal>的md5哈希。
  </para>

<!--==========================orignal english content==========================
  <para>
   If the password is encrypted with SCRAM-SHA-256, it has the format:
<synopsis>
SCRAM-SHA-256$<replaceable>&lt;iteration count&gt;</replaceable>:<replaceable>&lt;salt&gt;</replaceable>$<replaceable>&lt;StoredKey&gt;</replaceable>:<replaceable>&lt;ServerKey&gt;</replaceable>
</synopsis>
   where <replaceable>salt</replaceable>, <replaceable>StoredKey</replaceable> and
   <replaceable>ServerKey</replaceable> are in Base64 encoded format. This format is
   the same as that specified by RFC 5803.
  </para>
____________________________________________________________________________-->
  <para>
   如果口令采用SCRAM-SHA-256加密，它的格式是：
<synopsis>
SCRAM-SHA-256$<replaceable>&lt;iteration count&gt;</replaceable>:<replaceable>&lt;salt&gt;</replaceable>$<replaceable>&lt;StoredKey&gt;</replaceable>:<replaceable>&lt;ServerKey&gt;</replaceable>
</synopsis>
   其中<replaceable>salt</replaceable>、<replaceable>StoredKey</replaceable>和<replaceable>ServerKey</replaceable>是Base64编码格式。这种格式与RFC 5803说明的格式相同。
  </para>

<!--==========================orignal english content==========================
  <para>
    A password that does not follow either of those formats is assumed to be
    unencrypted.
  </para>
____________________________________________________________________________-->
  <para>
    不遵守上述格式的口令被假定为未加密。
  </para>
 </sect1>


 <sect1 id="catalog-pg-auth-members">
<!--==========================orignal english content==========================
  <title><structname>pg_auth_members</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_auth_members</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-auth-members">
   <primary>pg_auth_members</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-auth-members">
   <primary>pg_auth_members</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_auth_members</structname> shows the membership
   relations between roles.  Any non-circular set of relationships is allowed.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_auth_members</structname>展示了角色之间的成员关系。允许任何无环的关系集合。
  </para>

<!--==========================orignal english content==========================
  <para>
   Because user identities are cluster-wide,
   <structname>pg_auth_members</structname>
   is shared across all databases of a cluster: there is only one
   copy of <structname>pg_auth_members</structname> per cluster, not
   one per database.
  </para>
____________________________________________________________________________-->
  <para>
   由于用户标识符是集簇范围的，<structname>pg_auth_members</structname>在一个集簇的所有数据库之间共享：在一个集簇中只有一份<structname>pg_auth_members</structname>拷贝，而不是每个数据库一份。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_auth_members</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_auth_members</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>roleid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>ID of a role that has a member</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>roleid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>拥有成员的角色的ID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>member</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>ID of a role that is a member of <structfield>roleid</structfield></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>member</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry><structfield>roleid</structfield>的成员角色的ID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>grantor</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>ID of the role that granted this membership</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>grantor</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>授权此成员关系的角色的ID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>admin_option</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if <structfield>member</structfield> can grant membership in
       <structfield>roleid</structfield> to others</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>admin_option</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>如果<structfield>member</structfield>能把<structfield>roleid</structfield>的成员关系授予他人，则为真</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-cast">
<!--==========================orignal english content==========================
  <title><structname>pg_cast</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_cast</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-cast">
   <primary>pg_cast</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-cast">
   <primary>pg_cast</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_cast</structname> stores data type conversion
   paths, both built-in and user-defined.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_cast</structname>存储数据类型转换路径，包括内建的和用户定义的类型。
  </para>

<!--==========================orignal english content==========================
  <para>
   It should be noted that <structname>pg_cast</structname> does not represent
   every type conversion that the system knows how to perform; only those that
   cannot be deduced from some generic rule.  For example, casting between a
   domain and its base type is not explicitly represented in
   <structname>pg_cast</structname>.  Another important exception is that
   <quote>automatic I/O conversion casts</quote>, those performed using a data
   type's own I/O functions to convert to or from <type>text</type> or other
   string types, are not explicitly represented in
   <structname>pg_cast</structname>.
  </para>
____________________________________________________________________________-->
  <para>
   需要注意的是，<structname>pg_cast</structname>并不表示系统知道如何执行的所有类型转换，它只包括哪些不能从某些普通规则推导出的转换。例如，一个域及其基类型之间的转换并未显式地在<structname>pg_cast</structname>中展示。另一个重要的例外是<quote>自动 I/O转换造型</quote>，它们通过数据类型自己的I/O函数来转换成（或者转换自）<type>text</type>或其他字符串类型，这些转换也没有显式地在<structname>pg_cast</structname>中表示。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_cast</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_cast</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Row identifier</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>castsource</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>OID of the source data type</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>castsource</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>源数据类型的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>casttarget</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>OID of the target data type</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>casttarget</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>目标数据类型的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>castfunc</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       The OID of the function to use to perform this cast.  Zero is
       stored if the cast method doesn't require a function.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>castfunc</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       执行该转换的函数的OID。如果该转换方法不需要一个函数则存储0。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>castcontext</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Indicates what contexts the cast can be invoked in.
       <literal>e</literal> means only as an explicit cast (using
       <literal>CAST</literal> or <literal>::</literal> syntax).
       <literal>a</literal> means implicitly in assignment
       to a target column, as well as explicitly.
       <literal>i</literal> means implicitly in expressions, as well as the
       other cases.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>castcontext</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       指示该转换能被调用的环境。
       <literal>e</literal>表示仅能作为一个显式转换（使用<literal>CAST</literal>或<literal>::</literal>语法）。
       <literal>a</literal>表示在赋值给目标列时隐式调用， 和显式调用一样。
       <literal>i</literal>表示在表达式中隐式调用，和其他转换一样。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>castmethod</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Indicates how the cast is performed.
       <literal>f</literal> means that the function specified in the <structfield>castfunc</structfield> field is used.
       <literal>i</literal> means that the input/output functions are used.
       <literal>b</literal> means that the types are binary-coercible, thus no conversion is required.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>castmethod</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       指示转换如何被执行。
       <literal>f</literal>表明使用<structfield>castfunc</structfield>中指定的函数。
       <literal>i</literal>表明使用输入/输出函数。
       <literal>b</literal>表明该类型是二进制可转换的，因此不需要转换。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   The cast functions listed in <structname>pg_cast</structname> must
   always take the cast source type as their first argument type, and
   return the cast destination type as their result type.  A cast
   function can have up to three arguments.  The second argument,
   if present, must be type <type>integer</type>; it receives the type
   modifier associated with the destination type, or -1
   if there is none.  The third argument,
   if present, must be type <type>boolean</type>; it receives <literal>true</literal>
   if the cast is an explicit cast, <literal>false</literal> otherwise.
  </para>
____________________________________________________________________________-->
  <para>
   在<structname>pg_cast</structname>里列出的类型转换函数必须总是以转换的源类型作为它的第一个参数类型， 并且返回转换的目标类型作为它的结果类型。一个类型转换函数最多有三个参数。 如果出现了第二个参数，必须是<type>integer</type>类型；它接受与目标类型关联的修饰词， 如果没有，就是 -1。如果出现了第三个参数，那么必须是<type>boolean</type>类型； 如果该类型转换是一种明确的转换，那么它接受<literal>true</literal>，否则接受<literal>false</literal>。
  </para>

<!--==========================orignal english content==========================
  <para>
   It is legitimate to create a <structname>pg_cast</structname> entry
   in which the source and target types are the same, if the associated
   function takes more than one argument.  Such entries represent
   <quote>length coercion functions</quote> that coerce values of the type
   to be legal for a particular type modifier value.
  </para>
____________________________________________________________________________-->
  <para>
   在<structname>pg_cast</structname>里创建一条源类型和目标类型相同的记录是合理的， 只要相关联的函数接受多过一个参数。这样的记录代表<quote>长度转换函数</quote>， 它们把该类型的值转换为对特定的类型合法的值。
  </para>

<!--==========================orignal english content==========================
  <para>
   When a <structname>pg_cast</structname> entry has different source and
   target types and a function that takes more than one argument, it
   represents converting from one type to another and applying a length
   coercion in a single step.  When no such entry is available, coercion
   to a type that uses a type modifier involves two steps, one to
   convert between data types and a second to apply the modifier.
  </para>
____________________________________________________________________________-->
  <para>
   如果一个<structname>pg_cast</structname>的项有着不同的原类型和目标类型， 并且有一个接收多于一个参数的函数，那么它会在一个步骤中完成从一种类型到另外一种类型的转换并应用一个长度转换。如果没有这样的项，使用一个类型修改器的转换涉及两个步骤， 一个是在数据类型之间转换，另外一个是应用修改器。
  </para>
 </sect1>

 <sect1 id="catalog-pg-class">
<!--==========================orignal english content==========================
  <title><structname>pg_class</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_class</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-class">
   <primary>pg_class</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-class">
   <primary>pg_class</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_class</structname> catalogs tables and most
   everything else that has columns or is otherwise similar to a
   table.  This includes indexes (but see also
   <structname>pg_index</structname>), sequences (but see also
   <structname>pg_sequence</structname>), views, materialized
   views, composite types, and TOAST tables; see <structfield>relkind</structfield>.
   Below, when we mean all of these
   kinds of objects we speak of <quote>relations</quote>.  Not all
   columns are meaningful for all relation types.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_class</structname>记录表和几乎所有具有列或者像表的东西。这包括索引（但还要参见<structname>pg_index</structname>）、序列（但还要参见<structname>pg_sequence</structname>）、视图、物化视图、组合类型和TOAST表，参见<structfield>relkind</structfield>。下面，当我们提及所有这些类型的对象时我们使用<quote>关系</quote>。并非所有列对于所有关系类型都有意义。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_class</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_class</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Row identifier</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>relname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the table, index, view, etc.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>relname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>表、索引、视图等的名字</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>relnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       The OID of the namespace that contains this relation
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>relnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       包含该关系的名字空间的OID
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>reltype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       The OID of the data type that corresponds to this table's row type,
       if any (zero for indexes, which have no <structname>pg_type</structname> entry)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>reltype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       可能存在的表行类型所对应数据类型的OID（对索引为0，索引没有<structname>pg_type</structname>项）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>reloftype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       For typed tables, the OID of the underlying composite type,
       zero for all other relations
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>reloftype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       对于有类型的表，为底层组合类型的OID，对于其他所有关系为0
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>relowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Owner of the relation</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>relowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>关系的拥有者</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>relam</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-am"><structname>pg_am</structname></link>.oid</literal></entry>
      <entry>
       If this is a table or an index, the access method used (heap,
       B-tree, hash, etc.)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>relam</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-am"><structname>pg_am</structname></link>.oid</literal></entry>
      <entry>如果这是一个表或者索引，表示索引使用的访问方法（堆、B树、哈希等）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>relfilenode</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Name of the on-disk file of this relation; zero means this
       is a <quote>mapped</quote> relation whose disk file name is determined
       by low-level state</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>relfilenode</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>该关系的磁盘文件的名字，0表示这是一个<quote>映射</quote>关系，其磁盘文件名取决于低层状态</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>reltablespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.oid</literal></entry>
      <entry>
       The tablespace in which this relation is stored.  If zero,
       the database's default tablespace is implied.  (Not meaningful
       if the relation has no on-disk file.)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>reltablespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.oid</literal></entry>
      <entry>
       该关系所存储的表空间。如果为0，使用数据库的默认表空间。（如果关系无磁盘文件时无意义）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>relpages</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Size of the on-disk representation of this table in pages (of size
       <symbol>BLCKSZ</symbol>).  This is only an estimate used by the
       planner.  It is updated by <command>VACUUM</command>,
       <command>ANALYZE</command>, and a few DDL commands such as
       <command>CREATE INDEX</command>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>relpages</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       该表磁盘表示的尺寸，以页面计（页面尺寸为<symbol>BLCKSZ</symbol>）。这只是一个由规划器使用的估计值。它被<command>VACUUM</command>、<command>ANALYZE</command>以及一些DDL命令（如<command>CREATE INDEX</command>）所更新。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>reltuples</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>
       Number of live rows in the table.  This is only an estimate used by
       the planner.  It is updated by <command>VACUUM</command>,
       <command>ANALYZE</command>, and a few DDL commands such as
       <command>CREATE INDEX</command>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>reltuples</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>
       表中的存活行数。这只是一个由规划器使用的估计值。它被<command>VACUUM</command>、<command>ANALYZE</command>以及一些DDL命令（如<command>CREATE INDEX</command>）所更新。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>relallvisible</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Number of pages that are marked all-visible in the table's
       visibility map.  This is only an estimate used by the
       planner.  It is updated by <command>VACUUM</command>,
       <command>ANALYZE</command>, and a few DDL commands such as
       <command>CREATE INDEX</command>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>relallvisible</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       在表的可见性映射表中被标记为全可见的页数。这只是一个由规划器使用的估计值。它被<command>VACUUM</command>、<command>ANALYZE</command>以及一些DDL命令（如<command>CREATE INDEX</command>）所更新。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>reltoastrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       OID of the TOAST table associated with this table, 0 if none.  The
       TOAST table stores large attributes <quote>out of line</quote> in a
       secondary table.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>reltoastrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       与该表相关联的TOAST表的OID，如果没有则为0。TOAST表将大属性<quote>线外</quote>存储在一个二级表中。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>relhasindex</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       True if this is a table and it has (or recently had) any indexes
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>relhasindex</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       如果这是一个表并且其上建有（或最近建有）索引则为真
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>relisshared</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       True if this table is shared across all databases in the cluster.  Only
       certain system catalogs (such as <structname>pg_database</structname>)
       are shared.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>relisshared</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       如果该表在集簇中的所有数据库间共享则为真。只有某些系统目录（如<structname>pg_database</structname>）是共享的。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>relpersistence</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <literal>p</literal> = permanent table, <literal>u</literal> = unlogged table,
       <literal>t</literal> = temporary table
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>relpersistence</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <literal>p</literal> = 永久表，<literal>u</literal> = 无日志表，
       <literal>t</literal> = 临时表
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>relkind</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <literal>r</literal> = ordinary table,
       <literal>i</literal> = index,
       <literal>S</literal> = sequence,
       <literal>t</literal> = TOAST table,
       <literal>v</literal> = view,
       <literal>m</literal> = materialized view,
       <literal>c</literal> = composite type,
       <literal>f</literal> = foreign table,
       <literal>p</literal> = partitioned table,
       <literal>I</literal> = partitioned index
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>relkind</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <literal>r</literal> = 普通表，
       <literal>i</literal> = 索引，
       <literal>S</literal> = 序列，
       <literal>t</literal> = TOAST表，
       <literal>v</literal> = 视图，
       <literal>m</literal> = 物化视图，
       <literal>c</literal> = 组合类型，
       <literal>f</literal> = 外部表，
       <literal>p</literal> = 分区表，
       <literal>I</literal> = 分区索引
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>relnatts</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Number of user columns in the relation (system columns not
       counted).  There must be this many corresponding entries in
       <structname>pg_attribute</structname>.  See also
       <literal>pg_attribute.attnum</literal>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>relnatts</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       关系中用户列的数目（系统列不计算在内）。在<structname>pg_attribute</structname>中必须有这么多对应的项。另请参阅<literal>pg_attribute.attnum</literal>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>relchecks</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Number of <literal>CHECK</literal> constraints on the table; see
       <link linkend="catalog-pg-constraint"><structname>pg_constraint</structname></link> catalog
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>relchecks</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       表上<literal>CHECK</literal>约束的数目，参见<link linkend="catalog-pg-constraint"><structname>pg_constraint</structname></link>目录
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>relhasrules</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       True if table has (or once had) rules; see
       <link linkend="catalog-pg-rewrite"><structname>pg_rewrite</structname></link> catalog
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>relhasrules</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       如果表有（或曾有）规则则为真，参见
       <link linkend="catalog-pg-rewrite"><structname>pg_rewrite</structname></link>目录
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>relhastriggers</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       True if table has (or once had) triggers; see
       <link linkend="catalog-pg-trigger"><structname>pg_trigger</structname></link> catalog
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>relhastriggers</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       如果表有（或曾有）触发器则为真，参见
       <link linkend="catalog-pg-trigger"><structname>pg_trigger</structname></link>目录
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>relhassubclass</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       True if table or index has (or once had) any inheritance children
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>relhassubclass</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
      如果表或者索引有（或曾有）任何继承子女则为真
      </entry>
     </row>
     
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>relrowsecurity</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       True if table has row level security enabled; see
       <link linkend="catalog-pg-policy"><structname>pg_policy</structname></link> catalog
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>relrowsecurity</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       如果表上启用了行级安全性则为真，参见
       <link linkend="catalog-pg-policy"><structname>pg_policy</structname></link>目录
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>relforcerowsecurity</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       True if row level security (when enabled) will also apply to table owner; see
       <link linkend="catalog-pg-policy"><structname>pg_policy</structname></link> catalog
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>relforcerowsecurity</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       如果行级安全性（启用时）也适用于表拥有者则为真，参见
       <link linkend="catalog-pg-policy"><structname>pg_policy</structname></link>目录
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>relispopulated</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if relation is populated (this is true for all
       relations other than some materialized views)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>relispopulated</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>如果表已被填充则为真（对于所有关系该列都为真，但对于某些物化视图却不是）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>relreplident</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Columns used to form <quote>replica identity</quote> for rows:
       <literal>d</literal> = default (primary key, if any),
       <literal>n</literal> = nothing,
       <literal>f</literal> = all columns
       <literal>i</literal> = index with <structfield>indisreplident</structfield> set, or default
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>relreplident</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       用来为行形成<quote>replica identity</quote>的列：
       <literal>d</literal> = 默认 (主键，如果存在),
       <literal>n</literal> = 无,
       <literal>f</literal> = 所有列
       <literal>i</literal> = 索引的<structfield>indisreplident</structfield>被设置或者为默认
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>relispartition</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if table or index is a partition</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>relispartition</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>如果表或索引是一个分区，则为真</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>relrewrite</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       For new relations being written during a DDL operation that requires a
       table rewrite, this contains the OID of the original relation;
       otherwise 0.  That state is only visible internally; this field should
       never contain anything other than 0 for a user-visible relation.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>relrewrite</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       对于在要求表重写的DDL操作期间被写入的新关系，这个域包含原始关系的OID，否则为0。那种状态仅在内部可见，对于一个用户可见的关系这个域应该从不包含不是0的值。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>relfrozenxid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       All transaction IDs before this one have been replaced with a permanent
       (<quote>frozen</quote>) transaction ID in this table.  This is used to track
       whether the table needs to be vacuumed in order to prevent transaction
       ID wraparound or to allow <literal>pg_xact</literal> to be shrunk.  Zero
       (<symbol>InvalidTransactionId</symbol>) if the relation is not a table.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>relfrozenxid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       在此之前的所有事务ID在表中已经被替换为一个永久的（<quote>冻结的</quote>) 事务ID。这用于跟踪表是否需要被清理，以便阻止事务ID回卷或者允许<literal>pg_xact</literal>被收缩。如果该关系不是一个表则为0（<symbol>InvalidTransactionId</symbol>）。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>relminmxid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       All multixact IDs before this one have been replaced by a
       transaction ID in this table.  This is used to track
       whether the table needs to be vacuumed in order to prevent multixact ID
       wraparound or to allow <literal>pg_multixact</literal> to be shrunk.  Zero
       (<symbol>InvalidMultiXactId</symbol>) if the relation is not a table.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>relminmxid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       在此之前的多事务ID在表中已经被替换为一个事务ID。这被用于跟踪表是否需要被清理，以阻止
       多事务ID回卷或者允许<literal>pg_multixact</literal>被收缩。如果关系不是一个表则
       为0（<symbol>InvalidMultiXactId</symbol>）。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>relacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       Access privileges; see <xref linkend="ddl-priv"/> for details
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>relacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       访问权限，更多信息参见<xref linkend="ddl-priv"/>
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>reloptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       Access-method-specific options, as <quote>keyword=value</quote> strings
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>reloptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       访问方法相关的选项，以<quote>keyword=value</quote>字符串形式
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>relpartbound</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>
       If table is a partition (see <structfield>relispartition</structfield>),
       internal representation of the partition bound
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>relpartbound</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>
       如果表示一个分区（见<structfield>relispartition</structfield>），分区边界的内部表达
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   Several of the Boolean flags in <structname>pg_class</structname> are maintained
   lazily: they are guaranteed to be true if that's the correct state, but
   may not be reset to false immediately when the condition is no longer
   true.  For example, <structfield>relhasindex</structfield> is set by
   <command>CREATE INDEX</command>, but it is never cleared by
   <command>DROP INDEX</command>.  Instead, <command>VACUUM</command> clears
   <structfield>relhasindex</structfield> if it finds the table has no indexes.  This
   arrangement avoids race conditions and improves concurrency.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_class</structname>中的一些逻辑标志被以一种懒惰的方式维护：在正确状态时它们被保证为真，但是当条件不再为真时它们并不会被立刻重置为假。例如，<structfield>relhasindex</structfield>由<command>CREATE INDEX</command>设置，但它从不会被<command>DROP INDEX</command>清除。作为替代，<command>VACUUM</command>会在找到无索引表后清除其<structfield>relhasindex</structfield>。这种安排避免了竞争条件并且提高了并发性。
  </para>
 </sect1>

 <sect1 id="catalog-pg-collation">
<!--==========================orignal english content==========================
  <title><structname>pg_collation</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_collation</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-collation">
   <primary>pg_collation</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-collation">
   <primary>pg_collation</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_collation</structname> describes the
   available collations, which are essentially mappings from an SQL
   name to operating system locale categories.
   See <xref linkend="collation"/> for more information.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_collation</structname>描述了可用的排序规则，其本质是从一个SQL名字到操作系统locale分类的映射。更多信息参见<xref linkend="collation"/>。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_collation</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_collation</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Row identifier</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>collname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Collation name (unique per namespace and encoding)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>collname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>排序规则名字（在每一个名字空间和编码中唯一）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>collnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       The OID of the namespace that contains this collation
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>collnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       包含该排序规则的名字空间的OID
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>collowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Owner of the collation</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>collowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>排序规则的拥有者</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>collprovider</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>Provider of the collation: <literal>d</literal> = database
       default, <literal>c</literal> = libc, <literal>i</literal> = icu</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>collprovider</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>排序规则的提供者：<literal>d</literal> = 数据库默认，<literal>c</literal> = libc，<literal>i</literal> = icu</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>collisdeterministic</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Is the collation deterministic?</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>collisdeterministic</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>排序规则是确定性的吗？</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>collencoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Encoding in which the collation is applicable, or -1 if it
       works for any encoding</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>collencoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>该排序规则可应用的编码，-1表示它可用于任何编码</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>collcollate</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry><symbol>LC_COLLATE</symbol> for this collation object</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>collcollate</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>该排序规则对象的<symbol>LC_COLLATE</symbol></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>collctype</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry><symbol>LC_CTYPE</symbol> for this collation object</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>collctype</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>该排序规则对象的<symbol>LC_CTYPE</symbol></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>collversion</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       Provider-specific version of the collation.  This is recorded when the
       collation is created and then checked when it is used, to detect
       changes in the collation definition that could lead to data corruption.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>collversion</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       排序规则的提供者相关的版本。这是在排序规则创建时记录下来的，并且在使用排序规则时会被检查以检测可能导致数据损坏的排序规则定义的改变。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   Note that the unique key on this catalog is (<structfield>collname</structfield>,
   <structfield>collencoding</structfield>, <structfield>collnamespace</structfield>) not just
   (<structfield>collname</structfield>, <structfield>collnamespace</structfield>).
   <productname>PostgreSQL</productname> generally ignores all
   collations that do not have <structfield>collencoding</structfield> equal to
   either the current database's encoding or -1, and creation of new entries
   with the same name as an entry with <structfield>collencoding</structfield> = -1
   is forbidden.  Therefore it is sufficient to use a qualified SQL name
   (<replaceable>schema</replaceable>.<replaceable>name</replaceable>) to identify a collation,
   even though this is not unique according to the catalog definition.
   The reason for defining the catalog this way is that
   <application>initdb</application> fills it in at cluster initialization time with
   entries for all locales available on the system, so it must be able to
   hold entries for all encodings that might ever be used in the cluster.
  </para>
____________________________________________________________________________-->
  <para>
   注意在这个目录中的唯一键是（<structfield>collname</structfield>、
   <structfield>collencoding</structfield>、 <structfield>collnamespace</structfield>）， 不仅仅是（<structfield>collname</structfield>，<structfield>collnamespace</structfield>）。
   所有<structfield>collencoding</structfield>不等于当前数据库编码或-1的编码规则通常都会被<productname>PostgreSQL</productname>忽略，且禁止创建和<structfield>collencoding</structfield> = -1的项重名的项。因此使用一个受限的SQL名字（<replaceable>schema</replaceable>.<replaceable>name</replaceable>）来标识一个排序规则是足够的，即使这根据目录定义是不唯一的。以这种方式定义这个目录的原因是<application>initdb</application>会在集簇初始化时使用系统上所有可用的locale填充这个目录，所以它必须能够为所有可能在集簇中使用的编码保持项。
  </para>

<!--==========================orignal english content==========================
  <para>
   In the <literal>template0</literal> database, it could be useful to create
   collations whose encoding does not match the database encoding,
   since they could match the encodings of databases later cloned from
   <literal>template0</literal>.  This would currently have to be done manually.
  </para>
____________________________________________________________________________-->
  <para>
   在<literal>template0</literal>数据库中，创建与数据库编码不匹配的编码是有用的，因为它们可以匹配后面从<literal>template0</literal>克隆的数据库的编码。这在目前必须手动完成。
  </para>
 </sect1>

 <sect1 id="catalog-pg-constraint">
<!--==========================orignal english content==========================
  <title><structname>pg_constraint</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_constraint</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-constraint">
   <primary>pg_constraint</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-constraint">
   <primary>pg_constraint</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_constraint</structname> stores check, primary
   key, unique, foreign key, and exclusion constraints on tables.
   (Column constraints are not treated specially.  Every column constraint is
   equivalent to some table constraint.)
   Not-null constraints are represented in the <structname>pg_attribute</structname>
   catalog, not here.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_constraint</structname>存储表上的检查、主键、唯一、外键和排他约束（列约束也不会被特殊对待。每一个列约束都等同于某种表约束。）。非空约束不在这里，而是在<structname>pg_attribute</structname>目录中表示。
  </para>

<!--==========================orignal english content==========================
  <para>
   User-defined constraint triggers (created with <command>CREATE CONSTRAINT
   TRIGGER</command>) also give rise to an entry in this table.
  </para>
____________________________________________________________________________-->
  <para>
   用户定义的约束触发器（使用<command>CREATE CONSTRAINT TRIGGER</command>创建）也会在这个表中产生一项。
  </para>

<!--==========================orignal english content==========================
  <para>
   Check constraints on domains are stored here, too.
  </para>
____________________________________________________________________________-->
  <para>
   域上的检查约束也存储在这里。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_constraint</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_constraint</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Row identifier</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>conname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Constraint name (not necessarily unique!)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>conname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>约束名字（不需要唯一！）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>connamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       The OID of the namespace that contains this constraint
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>connamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       包含此约束的名字空间的OID
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>contype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
        <literal>c</literal> = check constraint,
        <literal>f</literal> = foreign key constraint,
        <literal>p</literal> = primary key constraint,
        <literal>u</literal> = unique constraint,
        <literal>t</literal> = constraint trigger,
        <literal>x</literal> = exclusion constraint
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>contype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
        <literal>c</literal> = 检查约束，
        <literal>f</literal> = 外键约束，
        <literal>p</literal> = 主键约束，
        <literal>u</literal> = 唯一约束，
        <literal>t</literal> = 约束触发器，
        <literal>x</literal> = 排他约束
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>condeferrable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Is the constraint deferrable?</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>condeferrable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>该约束是否能被延迟？</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>condeferred</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Is the constraint deferred by default?</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>condeferred</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>该约束是否默认被延迟？</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>convalidated</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Has the constraint been validated?
       Currently, can only be false for foreign keys and CHECK constraints</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>convalidated</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>此约束是否被验证过？当前对于外键和检查约束只能是假</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>conrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The table this constraint is on; 0 if not a table constraint</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>conrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>该约束所在的表，如果不是表约束则为0</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>contypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>The domain this constraint is on; 0 if not a domain constraint</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>contypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>该约束所在的域，如果不是域约束则为0</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>conindid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The index supporting this constraint, if it's a unique, primary
       key, foreign key, or exclusion constraint; else 0</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>conindid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>如果该约束是唯一、主键、外键或排他约束，此列表示支持此约束的索引，否则为0</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>conparentid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-constraint"><structname>pg_constraint</structname></link>.oid</literal></entry>
      <entry>The corresponding constraint in the parent partitioned table,
       if this is a constraint in a partition; else 0</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>conparentid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-constraint"><structname>pg_constraint</structname></link>.oid</literal></entry>
      <entry>如果这是一个分区中的约束，则是父分区表中对应的约束；否则为0</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>confrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>If a foreign key, the referenced table; else 0</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>confrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>如果此约束是一个外键约束，此列为被引用的表，否则为0</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>confupdtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>Foreign key update action code:
            <literal>a</literal> = no action,
            <literal>r</literal> = restrict,
            <literal>c</literal> = cascade,
            <literal>n</literal> = set null,
            <literal>d</literal> = set default
          </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>confupdtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>外键更新动作代码：
            <literal>a</literal> = 无动作，
            <literal>r</literal> = 限制，
            <literal>c</literal> = 级联，
            <literal>n</literal> = 置空，
            <literal>d</literal> = 置为默认值
          </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>confdeltype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>Foreign key deletion action code:
            <literal>a</literal> = no action,
            <literal>r</literal> = restrict,
            <literal>c</literal> = cascade,
            <literal>n</literal> = set null,
            <literal>d</literal> = set default
          </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>confdeltype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>外键删除动作代码：
            <literal>a</literal> = 无动作，
            <literal>r</literal> = 限制，
            <literal>c</literal> = 级联，
            <literal>n</literal> = 置空，
            <literal>d</literal> = 置为默认值
          </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>confmatchtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>Foreign key match type:
            <literal>f</literal> = full,
            <literal>p</literal> = partial,
            <literal>s</literal> = simple
          </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>confmatchtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>外键匹配类型：
            <literal>f</literal> = 完全，
            <literal>p</literal> = 部分，
            <literal>s</literal> = 简单
          </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>conislocal</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       This constraint is defined locally for the relation.  Note that a
       constraint can be locally defined and inherited simultaneously.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>conislocal</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       此约束是定义在关系本地。注意一个约束可以同时是本地定义和继承。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>coninhcount</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       The number of direct inheritance ancestors this constraint has.
       A constraint with
       a nonzero number of ancestors cannot be dropped nor renamed.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>coninhcount</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       此约束的直接继承祖先数目。一个此列非零的约束不能被删除或重命名。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>connoinherit</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       This constraint is defined locally for the relation.  It is a
       non-inheritable constraint.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>connoinherit</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       为真表示此约束被定义在关系本地。它是一个不可继承约束。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>conkey</structfield></entry>
      <entry><type>int2[]</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>If a table constraint (including foreign keys, but not constraint
       triggers), list of the constrained columns</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>conkey</structfield></entry>
      <entry><type>int2[]</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>如果是一个表约束（包括外键但不包括约束触发器），此列是被约束列的列表</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>confkey</structfield></entry>
      <entry><type>int2[]</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>If a foreign key, list of the referenced columns</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>confkey</structfield></entry>
      <entry><type>int2[]</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>如果是一个外键，此列是被引用列的列表</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>conpfeqop</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>If a foreign key, list of the equality operators for PK = FK comparisons</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>conpfeqop</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>如果是一个外键，此列是用于PK = FK比较的等值操作符的列表</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>conppeqop</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>If a foreign key, list of the equality operators for PK = PK comparisons</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>conppeqop</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>如果是一个外键，此列是用于PK = PK比较的等值操作符的列表</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>conffeqop</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>If a foreign key, list of the equality operators for FK = FK comparisons</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>conffeqop</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>如果是一个外键，此列是用于FK = FK比较的等值操作符的列表</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>conexclop</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>If an exclusion constraint, list of the per-column exclusion operators</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>conexclop</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>如果是一个排他约束，此列是没列排他操作符的列表</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>conbin</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>If a check constraint, an internal representation of the
      expression.  (It's recommended to use
      <function>pg_get_constraintdef()</function> to extract the definition of
      a check constraint.)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>conbin</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>如果是一个检查约束，此列是表达式的一个内部表示。建议使用 <function>pg_get_constraintdef()</function>提取检查约束的定义。</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   In the case of an exclusion constraint, <structfield>conkey</structfield>
   is only useful for constraint elements that are simple column references.
   For other cases, a zero appears in <structfield>conkey</structfield>
   and the associated index must be consulted to discover the expression
   that is constrained.  (<structfield>conkey</structfield> thus has the
   same contents as <structname>pg_index</structname>.<structfield>indkey</structfield> for the
   index.)
  </para>
____________________________________________________________________________-->
  <para>
   在一个排他约束的情况中， <structfield>conkey</structfield>只对约束元素是单一列引用时有用。对于其他情况，<structfield>conkey</structfield>为0且必须查阅相关索引来发现被约束的表达式（<structfield>conkey</structfield>因此和<structname>pg_index</structname>.<structfield>indkey</structfield>具有相同的内容）。
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    <literal>pg_class.relchecks</literal> needs to agree with the
    number of check-constraint entries found in this table for each
    relation.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>pg_class.relchecks</literal>需要和每个关系在此目录中的检查约束数量保持一致。
   </para>
  </note>
 </sect1>


 <sect1 id="catalog-pg-conversion">
<!--==========================orignal english content==========================
  <title><structname>pg_conversion</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_conversion</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-conversion">
   <primary>pg_conversion</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-conversion">
   <primary>pg_conversion</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_conversion</structname> describes
   encoding conversion functions.  See <xref linkend="sql-createconversion"/>
   for more information.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_conversion</structname>描述编码转换函数。更多信息参见<xref linkend="sql-createconversion"/>。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_conversion</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_conversion</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Row identifier</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>conname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Conversion name (unique within a namespace)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>conname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>转换的名字（在一个名字空间内唯一）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>connamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       The OID of the namespace that contains this conversion
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>connamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       包含此转换的名字空间的OID
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>conowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Owner of the conversion</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>conowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>转换的拥有者</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>conforencoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Source encoding ID</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>conforencoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>源编码ID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>contoencoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Destination encoding ID</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>contoencoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>目标编码ID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>conproc</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Conversion function</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>conproc</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>转换函数</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>condefault</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if this is the default conversion</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>condefault</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>如果这是默认转换则为真</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="catalog-pg-database">
<!--==========================orignal english content==========================
  <title><structname>pg_database</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_database</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-database">
   <primary>pg_database</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-database">
   <primary>pg_database</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_database</structname> stores information about
   the available databases.  Databases are created with the <xref
   linkend="sql-createdatabase"/> command.
   Consult <xref linkend="managing-databases"/> for details about the meaning
   of some of the parameters.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_database</structname>存储有关可用数据库的信息。数据库通过<xref linkend="sql-createdatabase"/>命令创建。
   更多关于其参数的信息请查阅<xref linkend="managing-databases"/>。
  </para>

<!--==========================orignal english content==========================
  <para>
   Unlike most system catalogs, <structname>pg_database</structname>
   is shared across all databases of a cluster: there is only one
   copy of <structname>pg_database</structname> per cluster, not
   one per database.
  </para>
____________________________________________________________________________-->
  <para>
   和大部分系统目录不同，<structname>pg_database</structname>是在集簇的所有数据库之间共享的：在一个集簇中只有一份<structname>pg_database</structname>拷贝，而不是每个数据库一份。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_database</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_database</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Row identifier</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>datname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Database name</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>datname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>数据库名字</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>datdba</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Owner of the database, usually the user who created it</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>datdba</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>数据库的拥有者，通常是创建它的用户</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>encoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Character encoding for this database
          (<function>pg_encoding_to_char()</function> can translate
           this number to the encoding name)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>encoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>此数据库的字符编码的编号（<function>pg_encoding_to_char()</function>可将此编号转换成编码的名字）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>datcollate</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>LC_COLLATE for this database</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>datcollate</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>此数据库的LC_COLLATE</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>datctype</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>LC_CTYPE for this database</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>datctype</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>此数据库的LC_CTYPE</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>datistemplate</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       If true, then this database can be cloned by
       any user with <literal>CREATEDB</literal> privileges;
       if false, then only superusers or the owner of
       the database can clone it.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>datistemplate</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       如果为真，则此数据库可被任何具有<literal>CREATEDB</literal>特权的用户克隆；如果为假，则只有
       超级用户或者该数据库的属主能够克隆它。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>datallowconn</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       If false then no one can connect to this database.  This is
       used to protect the <literal>template0</literal> database from being altered.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>datallowconn</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       如果为假则没有人能连接到这个数据库。这可以用来保护<literal>template0</literal>数据库不被修改。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>datconnlimit</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Sets maximum number of concurrent connections that can be made
       to this database.  -1 means no limit.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>datconnlimit</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       设置能够连接到这个数据库的最大并发连接数。-1表示没有限制。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>datlastsysoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>
       Last system OID in the database; useful
       particularly to <application>pg_dump</application>
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>datlastsysoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>
       数据库中最后一个系统OID，对<application>pg_dump</application>特别有用
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>datfrozenxid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       All transaction IDs before this one have been replaced with a permanent
       (<quote>frozen</quote>) transaction ID in this database.  This is used to
       track whether the database needs to be vacuumed in order to prevent
       transaction ID wraparound or to allow <literal>pg_xact</literal> to be shrunk.
       It is the minimum of the per-table
       <structname>pg_class</structname>.<structfield>relfrozenxid</structfield> values.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>datfrozenxid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       在此之前的所有事务ID在数据库中已经被替换为一个永久的（<quote>冻结的</quote>) 事务ID。这用于跟踪数据库是否需要被清理，以便组织事务ID回环或者允许<literal>pg_xact</literal>被收缩。它是此数据库中所有表的<structname>pg_class</structname>.<structfield>relfrozenxid</structfield>值的最小值。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>datminmxid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       All multixact IDs before this one have been replaced with a
       transaction ID in this database.  This is used to
       track whether the database needs to be vacuumed in order to prevent
       multixact ID wraparound or to allow <literal>pg_multixact</literal> to be shrunk.
       It is the minimum of the per-table
       <structname>pg_class</structname>.<structfield>relminmxid</structfield> values.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>datminmxid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       在此之前的所有多事务ID在数据库中已经被替换为一个事务ID。这用于跟踪数据库是否需要被
       清理，以便组织事务ID回环或者允许<literal>pg_multixact</literal>被收缩。它是此数据库中
       所有表的<structname>pg_class</structname>.<structfield>relminmxid</structfield>值的最小值。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>dattablespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.oid</literal></entry>
      <entry>
       The default tablespace for the database.
       Within this database, all tables for which
       <structname>pg_class</structname>.<structfield>reltablespace</structfield> is zero
       will be stored in this tablespace; in particular, all the non-shared
       system catalogs will be there.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>dattablespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.oid</literal></entry>
      <entry>
       此数据库的默认表空间。在此数据库中，所有<structname>pg_class</structname>.<structfield>reltablespace</structfield>为0的表都将被存储在这个表空间中，尤其是非共享系统目录都会在其中。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>datacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       Access privileges; see <xref linkend="ddl-priv"/> for details
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>datacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       访问权限，更多信息参见<xref linkend="ddl-priv"/>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-db-role-setting">
<!--==========================orignal english content==========================
  <title><structname>pg_db_role_setting</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_db_role_setting</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-db-role-setting">
   <primary>pg_db_role_setting</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-db-role-setting">
   <primary>pg_db_role_setting</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_db_role_setting</structname> records the default
   values that have been set for run-time configuration variables,
   for each role and database combination.
  </para>
____________________________________________________________________________-->
  <para>
   目录 <structname>pg_db_role_setting</structname>为每一个角色和数据库组合记录被设置到运行时配置变量的默认值。
  </para>

<!--==========================orignal english content==========================
  <para>
   Unlike most system catalogs, <structname>pg_db_role_setting</structname>
   is shared across all databases of a cluster: there is only one
   copy of <structname>pg_db_role_setting</structname> per cluster, not
   one per database.
  </para>
____________________________________________________________________________-->
  <para>
   和大部分系统目录不同，<structname>pg_db_role_setting</structname>是在集簇的所有数据库之间共享的：在一个集簇中只有一份<structname>pg_db_role_setting</structname>拷贝，而不是每个数据库一份。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_db_role_setting</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_db_role_setting</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>setdatabase</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <entry>The OID of the database the setting is applicable to, or zero if not database-specific</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>setdatabase</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <entry>此设置可用的数据库OID，如果不与具体数据库相关则为0</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>setrole</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>The OID of the role the setting is applicable to, or zero if not role-specific</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>setrole</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>此设置可用的角色OID，如果不与具体角色相关则为0</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>setconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>Defaults for run-time configuration variables</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>setconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>运行时配置变量的默认值</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-default-acl">
<!--==========================orignal english content==========================
  <title><structname>pg_default_acl</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_default_acl</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-default-acl">
   <primary>pg_default_acl</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-default-acl">
   <primary>pg_default_acl</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_default_acl</structname> stores initial
   privileges to be assigned to newly created objects.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_default_acl</structname>存储要被分配给新创建对象的初始权限。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_default_acl</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_default_acl</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Row identifier</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>defaclrole</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>The OID of the role associated with this entry</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>defaclrole</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>与此项相关的角色的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>defaclnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>The OID of the namespace associated with this entry,
       or 0 if none</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>defaclnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>与此项相关的名字空间的OID，如果没有则为0</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>defaclobjtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Type of object this entry is for:
       <literal>r</literal> = relation (table, view),
       <literal>S</literal> = sequence,
       <literal>f</literal> = function,
       <literal>T</literal> = type,
       <literal>n</literal> = schema
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>defaclobjtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       此项适合的对象类型：
       <literal>r</literal> = 关系（表、视图），
       <literal>S</literal> = 序列，
       <literal>f</literal> = 函数，
       <literal>T</literal> = 类型，
       <literal>n</literal> = 方案
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>defaclacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       Access privileges that this type of object should have on creation
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>defaclacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       此类对象在创建时应用有的访问权限
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   A <structname>pg_default_acl</structname> entry shows the initial privileges to
   be assigned to an object belonging to the indicated user.  There are
   currently two types of entry: <quote>global</quote> entries with
   <structfield>defaclnamespace</structfield> = 0, and <quote>per-schema</quote> entries
   that reference a particular schema.  If a global entry is present then
   it <emphasis>overrides</emphasis> the normal hard-wired default privileges
   for the object type.  A per-schema entry, if present, represents privileges
   to be <emphasis>added to</emphasis> the global or hard-wired default privileges.
  </para>
____________________________________________________________________________-->
  <para>
   一个<structname>pg_default_acl</structname>项展示了要分配给属于一个指定用户的对象的初始权限。当前有两类项：<structfield>defaclnamespace</structfield> = 0的<quote>全局</quote>项和引用一个特殊模式的<quote>每方案</quote>项。如果一个全局项存在，则它<emphasis>重载</emphasis>该对象类型的普通hard-wired默认权限。一个每模式项如果存在，表示权限将被<emphasis>加入到</emphasis>全局或hard-wired默认权限中。
  </para>

<!--==========================orignal english content==========================
  <para>
   Note that when an ACL entry in another catalog is null, it is taken
   to represent the hard-wired default privileges for its object,
   <emphasis>not</emphasis> whatever might be in <structname>pg_default_acl</structname>
   at the moment.  <structname>pg_default_acl</structname> is only consulted during
   object creation.
  </para>
____________________________________________________________________________-->
  <para>
   注意当在另一个表中的一个ACL项为空时，它用来表示其对象的hard-wired默认权限，而<emphasis>不是</emphasis>当时可能在<structname>pg_default_acl</structname>中的任何权限。只有在对象创建期间才会查阅<structname>pg_default_acl</structname>。
  </para>

 </sect1>


 <sect1 id="catalog-pg-depend">
<!--==========================orignal english content==========================
  <title><structname>pg_depend</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_depend</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-depend">
   <primary>pg_depend</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-depend">
   <primary>pg_depend</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_depend</structname> records the dependency
   relationships between database objects.  This information allows
   <command>DROP</command> commands to find which other objects must be dropped
   by <command>DROP CASCADE</command> or prevent dropping in the <command>DROP
   RESTRICT</command> case.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_depend</structname>记录数据库对象之间的依赖关系。这些信息允许<command>DROP</command>命令查找必须被<command>DROP CASCADE</command>删除的其他对象，或者在<command>DROP RESTRICT</command>情况下阻止删除。
  </para>

<!--==========================orignal english content==========================
  <para>
   See also <link linkend="catalog-pg-shdepend"><structname>pg_shdepend</structname></link>,
   which performs a similar function for dependencies involving objects
   that are shared across a database cluster.
  </para>
____________________________________________________________________________-->
  <para>
   另请参阅<link linkend="catalog-pg-shdepend"><structname>pg_shdepend</structname></link>，它对在一个数据库集簇中共享的对象之间的依赖提供了相似的功能。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_depend</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_depend</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>classid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The OID of the system catalog the dependent object is in</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>classid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>依赖对象所在的系统目录OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>objid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>any OID column</entry>
      <entry>The OID of the specific dependent object</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>objid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>任意OID列</entry>
      <entry>指定依赖对象的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       For a table column, this is the column number (the
       <structfield>objid</structfield> and <structfield>classid</structfield> refer to the
       table itself).  For all other object types, this column is
       zero.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       对于一个表列，这里是列号（<structfield>objid</structfield>和<structfield>classid</structfield>指表本身）。对于所有其他对象类型，此列为0。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>refclassid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The OID of the system catalog the referenced object is in</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>refclassid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>被引用对象所在的系统目录的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>refobjid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>any OID column</entry>
      <entry>The OID of the specific referenced object</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>refobjid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>任意OID列</entry>
      <entry>指定被引用对象的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>refobjsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       For a table column, this is the column number (the
       <structfield>refobjid</structfield> and <structfield>refclassid</structfield> refer
       to the table itself).  For all other object types, this column
       is zero.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>refobjsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       对于一个表列，这里是列号（<structfield>refobjid</structfield>和<structfield>refclassid</structfield>指表本身）。对于所有其他对象类型，此列为0。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>deptype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       A code defining the specific semantics of this dependency relationship; see text
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>deptype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       定义此依赖关系语义的一个代码，见文本
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   In all cases, a <structname>pg_depend</structname> entry indicates that the
   referenced object cannot be dropped without also dropping the dependent
   object.  However, there are several subflavors identified by
   <structfield>deptype</structfield>:

   <variablelist>
    <varlistentry>
     <term><symbol>DEPENDENCY_NORMAL</symbol> (<literal>n</literal>)</term>
     <listitem>
      <para>
       A normal relationship between separately-created objects.  The
       dependent object can be dropped without affecting the
       referenced object.  The referenced object can only be dropped
       by specifying <literal>CASCADE</literal>, in which case the dependent
       object is dropped, too.  Example: a table column has a normal
       dependency on its data type.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_AUTO</symbol> (<literal>a</literal>)</term>
     <listitem>
      <para>
       The dependent object can be dropped separately from the
       referenced object, and should be automatically dropped
       (regardless of <literal>RESTRICT</literal> or <literal>CASCADE</literal>
       mode) if the referenced object is dropped.  Example: a named
       constraint on a table is made auto-dependent on the table, so
       that it will go away if the table is dropped.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_INTERNAL</symbol> (<literal>i</literal>)</term>
     <listitem>
      <para>
       The dependent object was created as part of creation of the
       referenced object, and is really just a part of its internal
       implementation.  A direct <command>DROP</command> of the dependent
       object will be disallowed outright (we'll tell the user to issue
       a <command>DROP</command> against the referenced object, instead).
       A <command>DROP</command> of the referenced object will result in
       automatically dropping the dependent object
       whether <literal>CASCADE</literal> is specified or not.  If the
       dependent object has to be dropped due to a dependency on some other
       object being removed, its drop is converted to a drop of the referenced
       object, so that <literal>NORMAL</literal> and <literal>AUTO</literal>
       dependencies of the dependent object behave much like they were
       dependencies of the referenced object.
       Example: a view's <literal>ON SELECT</literal> rule is made
       internally dependent on the view, preventing it from being dropped
       while the view remains.  Dependencies of the rule (such as tables it
       refers to) act as if they were dependencies of the view.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_PARTITION_PRI</symbol> (<literal>P</literal>)</term>
     <term><symbol>DEPENDENCY_PARTITION_SEC</symbol> (<literal>S</literal>)</term>
     <listitem>
      <para>
       The dependent object was created as part of creation of the
       referenced object, and is really just a part of its internal
       implementation; however, unlike <literal>INTERNAL</literal>,
       there is more than one such referenced object.  The dependent object
       must not be dropped unless at least one of these referenced objects
       is dropped; if any one is, the dependent object should be dropped
       whether or not <literal>CASCADE</literal> is specified.  Also
       unlike <literal>INTERNAL</literal>, a drop of some other object
       that the dependent object depends on does not result in automatic
       deletion of any partition-referenced object.  Hence, if the drop
       does not cascade to at least one of these objects via some other
       path, it will be refused.  (In most cases, the dependent object
       shares all its non-partition dependencies with at least one
       partition-referenced object, so that this restriction does not
       result in blocking any cascaded delete.)
       Primary and secondary partition dependencies behave identically
       except that the primary dependency is preferred for use in error
       messages; hence, a partition-dependent object should have one
       primary partition dependency and one or more secondary partition
       dependencies.
       Note that partition dependencies are made in addition to, not
       instead of, any dependencies the object would normally have.  This
       simplifies <command>ATTACH/DETACH PARTITION</command> operations:
       the partition dependencies need only be added or removed.
       Example: a child partitioned index is made partition-dependent
       on both the partition table it is on and the parent partitioned
       index, so that it goes away if either of those is dropped, but
       not otherwise.  The dependency on the parent index is primary,
       so that if the user tries to drop the child partitioned index,
       the error message will suggest dropping the parent index instead
       (not the table).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_EXTENSION</symbol> (<literal>e</literal>)</term>
     <listitem>
      <para>
       The dependent object is a member of the <firstterm>extension</firstterm> that is
       the referenced object (see
       <link linkend="catalog-pg-extension"><structname>pg_extension</structname></link>).
       The dependent object can be dropped only via
       <command>DROP EXTENSION</command> on the referenced object.
       Functionally this dependency type acts the same as
       an <literal>INTERNAL</literal> dependency, but it's kept separate for
       clarity and to simplify <application>pg_dump</application>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_AUTO_EXTENSION</symbol> (<literal>x</literal>)</term>
     <listitem>
      <para>
       The dependent object is not a member of the extension that is the
       referenced object (and so it should not be ignored
       by <application>pg_dump</application>), but it cannot function
       without the extension and should be auto-dropped if the extension is.
       The dependent object may be dropped on its own as well.
       Functionally this dependency type acts the same as
       an <literal>AUTO</literal> dependency, but it's kept separate for
       clarity and to simplify <application>pg_dump</application>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_PIN</symbol> (<literal>p</literal>)</term>
     <listitem>
      <para>
       There is no dependent object; this type of entry is a signal
       that the system itself depends on the referenced object, and so
       that object must never be deleted.  Entries of this type are
       created only by <command>initdb</command>.  The columns for the
       dependent object contain zeroes.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   Other dependency flavors might be needed in future.
  </para>

  <para>
   Note that it's quite possible for two objects to be linked by more than
   one <structname>pg_depend</structname> entry.  For example, a child
   partitioned index would have both a partition-type dependency on its
   associated partition table, and an auto dependency on each column of
   that table that it indexes.  This sort of situation expresses the union
   of multiple dependency semantics.  A dependent object can be dropped
   without <literal>CASCADE</literal> if any of its dependencies satisfies
   its condition for automatic dropping.  Conversely, all the
   dependencies' restrictions about which objects must be dropped together
   must be satisfied.
  </para>

____________________________________________________________________________-->
  <para>
   在所有情况下，一个<structname>pg_depend</structname>项表明被引用对象不能在没有删除其依赖对象的情况下被删除。但是，其中也有多种依赖类型，由<structfield>deptype</structfield>标识：

   <variablelist>
    <varlistentry>
     <term><symbol>DEPENDENCY_NORMAL</symbol> (<literal>n</literal>)</term>
     <listitem>
      <para>
       在独立创建的对象之间的一个普通关系。依赖对象可以在不影响被依赖对象的情况下被删除。被引用对象只能通过指定<literal>CASCADE</literal>被删除，在这种情况下依赖对象也会被删除。 例子：一个表列对于其数据类型有一个普通依赖。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_AUTO</symbol> (<literal>a</literal>)</term>
     <listitem>
      <para>
       依赖对象可以被独立于被依赖对象删除，且应该在被引用对象被删除时自动被删除（不管在<literal>RESTRICT</literal>或<literal>CASCADE</literal>模式）。例子：一个表上的一个命名约束应该被设置为自动依赖于表，这样在表被删除后它也会消失。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_INTERNAL</symbol> (<literal>i</literal>)</term>
     <listitem>
      <para>
       依赖对象作为被引用对象创建过程的一部分被创建，并且只是其内部实现的一部分。不允许直接<command>DROP</command>所依赖的对象（而是告诉用户对引用对象发出<command>DROP</command>操作）。无论是否指定了<literal>CASCADE</literal>，<command>DROP</command>被引用的对象都将导致自动删除从属对象。如果由于删除了对某些其他对象的依赖关系而不得不删除依赖对象，则其删除将转换为对所引用对象的删除，因此依赖对象的<literal>NORMAL</literal>和<literal>AUTO</literal>依赖关系的行为就像它们是所引用对象的依赖关系。示例：视图的<literal>ON SELECT</literal>规则使其在内部依赖于视图，以防止在视图保留时将其删除。规则的依赖关系（例如它引用的表）就好像他们是视图的依赖关系。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_PARTITION_PRI</symbol> (<literal>P</literal>)</term>
     <term><symbol>DEPENDENCY_PARTITION_SEC</symbol> (<literal>S</literal>)</term>
     <listitem>
      <para>
       依赖对象被作为被引用对象创建过程的一部分创建，并且确实是其内部实现的一部分。但是，不像<literal>INTERNAL</literal>，有多个这样的引用对象。除非删除了这些引用对象中的至少一个对象，否则不得删除依赖对象；如果其中任何一个被删除，则不管是否指定了<literal>CASCADE</literal>，都应删除依赖对象。也不像<literal>INTERNAL</literal>，依赖对象所依赖的某些其他对象的删除不会导致任何分区引用的对象的自动删除。因此，如果删除没有通过其他路径级联到这些对象中的至少一个，它会被拒绝。（大多数情况下，依赖对象与至少一个分区引用对象共享所有非分区的依赖关系，因此此限制不会导致阻止任何级联的删除。）主分区和辅助分区的依赖关系表现相同，除了主分区依赖关系倾向用于错误消息；因此，分区相关的对象应该有一个主分区依赖关系和一个或多个辅助分区依赖关系。注意到分区依赖关系是任何对象所正常拥有的依赖关系的补充，而不是替代。这简化了<command>ATTACH/DETACH PARTITION</command>操作：只要添加或删除分区的依赖关系。例如：子分区索引与其所基于的分区表和父分区索引是分区相关的，因此只要其中一个删除，则子分区索引就消失，否则，就不消失。父索引上的依赖关系是主要的，故如果用户试图删除子分区索引，错误消息反而会建议删除父索引（不是表）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_EXTENSION</symbol> (<literal>e</literal>)</term>
     <listitem>
      <para>
       依赖对象是作为<firstterm>扩展</firstterm>的被引用对象的一个成员（参见<link linkend="catalog-pg-extension"><structname>pg_extension</structname></link>）。依赖对象可以通过被引用对象上的<command>DROP EXTENSION</command>来删除。在功能上，这种依赖类型和一个<literal>INTERNAL</literal>依赖的作用相同，其存在只是为了清晰和简化<application>pg_dump</application>。
      </para>
     </listitem>
    </varlistentry>
    
    <varlistentry>
     <term><symbol>DEPENDENCY_AUTO_EXTENSION</symbol> (<literal>x</literal>)</term>
     <listitem>
      <para>
       依赖对象不是作为被引用对象的扩展的成员（因此不应该被<application>pg_dump</application>忽略），但是没有该扩展它又无法工作，因此如果删除了扩展，则该依赖对象应自动删除。该依赖对象也可以独立删除。功能上，该依赖关系类型与<literal>AUTO</literal>依赖相同，但是为了清晰起见和简化<application>pg_dump</application>，将其分开。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_PIN</symbol> (<literal>p</literal>)</term>
     <listitem>
      <para>
       没有依赖对象，这种类型的项是一个信号，用于说明系统本身依赖于被引用对象，并且该对象永远不能被删除。这种类型的项只能被<command>initdb</command>创建。而此种项的依赖对象的列都为0。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   在未来可能会需要其他依赖类型。
  </para>

  <para>
   要注意的是，两个对象很有可能由不止一个<structname>pg_depend</structname>条目来链接。例如子分区索引有一个依赖于其关联的分区表的分区类型的依赖关系和依赖于该表索引的每一列的自动依赖关系。此类情形表示多重依赖关系语义的并集，依赖对象的删除可以没有<literal>CASCADE</literal>，如果其任一依赖关系满足自动删除的条件。相反地，关于哪些对象必须一起删除的所有依赖关系的限制必须满足。
  </para>

 </sect1>


 <sect1 id="catalog-pg-description">
<!--==========================orignal english content==========================
  <title><structname>pg_description</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_description</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-description">
   <primary>pg_description</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-description">
   <primary>pg_description</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_description</structname> stores optional descriptions
   (comments) for each database object.  Descriptions can be manipulated
   with the <xref linkend="sql-comment"/> command and viewed with
   <application>psql</application>'s <literal>\d</literal> commands.
   Descriptions of many built-in system objects are provided in the initial
   contents of <structname>pg_description</structname>.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_description</structname>存储对每一个数据库对象可选的描述（注释）。描述可以通过<xref linkend="sql-comment"/>操作，并可使用<application>psql</application>的<literal>\d</literal>命令查看。在<structname>pg_description</structname>的初始内容中提供了很多内建系统对象的描述。
  </para>

<!--==========================orignal english content==========================
  <para>
   See also <link linkend="catalog-pg-shdescription"><structname>pg_shdescription</structname></link>,
   which performs a similar function for descriptions involving objects that
   are shared across a database cluster.
  </para>
____________________________________________________________________________-->
  <para>
   参见<link linkend="catalog-pg-shdescription"><structname>pg_shdescription</structname></link>，它对在一个数据库集簇中共享的对象的描述提供了相似的功能。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_description</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_description</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>any OID column</entry>
      <entry>The OID of the object this description pertains to</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>任意OID列</entry>
      <entry>描述所属对象的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The OID of the system catalog this object appears in</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>对象所述的系统目录的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       For a comment on a table column, this is the column number (the
       <structfield>objoid</structfield> and <structfield>classoid</structfield> refer to
       the table itself).  For all other object types, this column is
       zero.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       对于一个表列上的一个注释，这里是列号（<structfield>objoid</structfield>和<structfield>classoid</structfield>指表本身）。对所有其他对象类型，此列为0。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>description</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Arbitrary text that serves as the description of this object</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>description</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>作为该对象描述的任意文本</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-enum">
<!--==========================orignal english content==========================
  <title><structname>pg_enum</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_enum</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-enum">
   <primary>pg_enum</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-enum">
   <primary>pg_enum</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_enum</structname> catalog contains entries
   showing the values and labels for each enum type. The
   internal representation of a given enum value is actually the OID
   of its associated row in <structname>pg_enum</structname>.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_enum</structname>目录包含每一个枚举类型的项，其中包括了值和标签。一个给定枚举值的内部表示实际上是它在<structname>pg_enum</structname>中的相关行的OID。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_enum</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_enum</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Row identifier</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>enumtypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>The OID of the <structname>pg_type</structname> entry owning this enum value</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>enumtypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>包含此枚举值的<structname>pg_type</structname>项的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>enumsortorder</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>The sort position of this enum value within its enum type</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>enumsortorder</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>此枚举值在其枚举类型中的排序位置</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>enumlabel</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>The textual label for this enum value</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>enumlabel</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>此枚举值的文本标签</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   The OIDs for <structname>pg_enum</structname> rows follow a special
   rule: even-numbered OIDs are guaranteed to be ordered in the same way
   as the sort ordering of their enum type.  That is, if two even OIDs
   belong to the same enum type, the smaller OID must have the smaller
   <structfield>enumsortorder</structfield> value.  Odd-numbered OID values
   need bear no relationship to the sort order.  This rule allows the
   enum comparison routines to avoid catalog lookups in many common cases.
   The routines that create and alter enum types attempt to assign even
   OIDs to enum values whenever possible.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_enum</structname>行的OID值遵循一种特殊的规则：即OID的数值被保证按照其枚举类型的排序顺序进行排序。即如果两个偶数OID属于同一枚举类型，较小的OID必然具有较小的<structfield>enumsortorder</structfield>值。奇数OID值不需要遵循排序顺序。这种规则使得枚举比较例程在很多常见情况下可以避免系统目录查找。创建和修改枚举类型的例程将尝试尽可能地为枚举值分配偶数OID。
  </para>

<!--==========================orignal english content==========================
  <para>
   When an enum type is created, its members are assigned sort-order
   positions 1..<replaceable>n</replaceable>.  But members added later might be given
   negative or fractional values of <structfield>enumsortorder</structfield>.
   The only requirement on these values is that they be correctly
   ordered and unique within each enum type.
  </para>
____________________________________________________________________________-->
  <para>
   当一个枚举类型被创建后，其成员会被分配排序位置1..<replaceable>n</replaceable>。但后面增加的成员可能会被分配负值或者分数值的<structfield>enumsortorder</structfield>。对于这些值的唯一要求是它们必须被正确地排序且和保持唯一。
  </para>
 </sect1>


 <sect1 id="catalog-pg-event-trigger">
<!--==========================orignal english content==========================
  <title><structname>pg_event_trigger</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_event_trigger</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-event-trigger">
   <primary>pg_event_trigger</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-event-trigger">
   <primary>pg_event_trigger</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_event_trigger</structname> stores event triggers.
   See <xref linkend="event-triggers"/> for more information.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_event_trigger</structname>存储事件触发器。更多信息参见<xref linkend="event-triggers"/>。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_event_trigger</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_event_trigger</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>evtname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Trigger name (must be unique)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>evtname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>触发器名（必须唯一）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>evtevent</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Identifies the event for which this trigger fires</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>evtevent</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>此触发器触发的事件的标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>evtowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Owner of the event trigger</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>evtowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>事件触发器的拥有者</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>evtfoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>The function to be called</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>evtfoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>将被调用的函数</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>evtenabled</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Controls in which <xref linkend="guc-session-replication-role"/> modes
       the event trigger fires.
       <literal>O</literal> = trigger fires in <quote>origin</quote> and <quote>local</quote> modes,
       <literal>D</literal> = trigger is disabled,
       <literal>R</literal> = trigger fires in <quote>replica</quote> mode,
       <literal>A</literal> = trigger fires always.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>evtenabled</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       控制事件触发器触发的<xref linkend="guc-session-replication-role"/>模式。
       <literal>O</literal> = 触发器在<quote>origin</quote>和<quote>local</quote>模式触发，
       <literal>D</literal> = 触发器被禁用，
       <literal>R</literal> = 触发器在<quote>replica</quote>模式触发，
       <literal>A</literal> = 触发器总是触发。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>evttags</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
        Command tags for which this trigger will fire.  If NULL, the firing
        of this trigger is not restricted on the basis of the command tag.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>evttags</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
        此触发器将触发的命令标签。如果为空，此触发器的触发不受命令标签的限制。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-extension">
<!--==========================orignal english content==========================
  <title><structname>pg_extension</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_extension</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-extension">
   <primary>pg_extension</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-extension">
   <primary>pg_extension</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_extension</structname> stores information
   about the installed extensions.  See <xref linkend="extend-extensions"/>
   for details about extensions.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_extension</structname>存储有关已安装扩展的信息。有关扩展的细节请参见<xref linkend="extend-extensions"/>。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_extension</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_extension</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Row identifier</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>extname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the extension</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>extname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>扩展的名字</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>extowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Owner of the extension</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>extowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>扩展的拥有者</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>extnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>Schema containing the extension's exported objects</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>extnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>包含此扩展的导出对象的模式</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>extrelocatable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if extension can be relocated to another schema</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>extrelocatable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>如果扩展可被重定位到另一个模式则为真</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>extversion</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Version name for the extension</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>extversion</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>扩展的版本名字</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>extconfig</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>Array of <type>regclass</type> OIDs for the extension's configuration
       table(s), or <literal>NULL</literal> if none</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>extconfig</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>扩展的配置表的<type>regclass</type>项的OID数组，如果没有配置表则为<literal>NULL</literal></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>extcondition</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>Array of <literal>WHERE</literal>-clause filter conditions for the
       extension's configuration table(s), or <literal>NULL</literal> if none</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>extcondition</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>扩展的配置表的<literal>WHERE</literal>子句过滤条件的数组，如果没有则为<literal>NULL</literal></entry>
     </row>

    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   Note that unlike most catalogs with a <quote>namespace</quote> column,
   <structfield>extnamespace</structfield> is not meant to imply
   that the extension belongs to that schema.  Extension names are never
   schema-qualified.  Rather, <structfield>extnamespace</structfield>
   indicates the schema that contains most or all of the extension's
   objects.  If <structfield>extrelocatable</structfield> is true, then
   this schema must in fact contain all schema-qualifiable objects
   belonging to the extension.
  </para>
____________________________________________________________________________-->
  <para>
   注意和大部分具有一个<quote>namespace</quote>列的模式不同，<structfield>extnamespace</structfield>不是用来表示扩展属于该模式。扩展的名字从不用模式进行限定。<structfield>extnamespace</structfield>表明该模式包含了该扩展的大部分或全部对象。如果<structfield>extrelocatable</structfield>为真，则该模式事实上必须包含属于此扩展的全部模式限定的对象。
  </para>
 </sect1>


 <sect1 id="catalog-pg-foreign-data-wrapper">
<!--==========================orignal english content==========================
  <title><structname>pg_foreign_data_wrapper</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_foreign_data_wrapper</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-foreign-data-wrapper">
   <primary>pg_foreign_data_wrapper</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-foreign-data-wrapper">
   <primary>pg_foreign_data_wrapper</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_foreign_data_wrapper</structname> stores
   foreign-data wrapper definitions.  A foreign-data wrapper is the
   mechanism by which external data, residing on foreign servers, is
   accessed.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_foreign_data_wrapper</structname>存储外部数据包装器定义。外部数据包装器是一种访问位于外部服务器上数据的机制。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_foreign_data_wrapper</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_foreign_data_wrapper</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Row identifier</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>fdwname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the foreign-data wrapper</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>fdwname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>外部数据包装器的名字</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>fdwowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Owner of the foreign-data wrapper</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>fdwowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>外部数据包装器的拥有者</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>fdwhandler</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       References a handler function that is responsible for
       supplying execution routines for the foreign-data wrapper.
       Zero if no handler is provided
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>fdwhandler</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       指一个负责为外部数据包装器提供执行例程的处理函数。如果没有提供处理函数则为0
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>fdwvalidator</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       References a validator function that is responsible for
       checking the validity of the options given to the
       foreign-data wrapper, as well as options for foreign servers and user
       mappings using the foreign-data wrapper.  Zero if no validator
       is provided
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>fdwvalidator</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       指一个负责检查传给外部数据包装器的选项的有效性的验证函数，包括外部服务器选项以及使用外部数据包装器的用户映射。如果没有提供验证函数则为0
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>fdwacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       Access privileges; see <xref linkend="ddl-priv"/> for details
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>fdwacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       访问权限，详见<xref linkend="ddl-priv"/>
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>fdwoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       Foreign-data wrapper specific options, as <quote>keyword=value</quote> strings
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>fdwoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       外部数据包装器特定选项，以<quote>keyword=value</quote>字符串形式
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-foreign-server">
<!--==========================orignal english content==========================
  <title><structname>pg_foreign_server</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_foreign_server</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-foreign-server">
   <primary>pg_foreign_server</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-foreign-server">
   <primary>pg_foreign_server</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_foreign_server</structname> stores
   foreign server definitions.  A foreign server describes a source
   of external data, such as a remote server.  Foreign
   servers are accessed via foreign-data wrappers.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_foreign_server</structname>存储外部服务器定义。外部服务器定义了外部数据的来源，例如一个远程服务器。外部服务器通过外部数据包装器来访问。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_foreign_server</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_foreign_server</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Row identifier</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>srvname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the foreign server</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>srvname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>外部服务器的名字</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>srvowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Owner of the foreign server</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>srvowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>外部服务器的拥有者</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>srvfdw</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-foreign-data-wrapper"><structname>pg_foreign_data_wrapper</structname></link>.oid</literal></entry>
      <entry>OID of the foreign-data wrapper of this foreign server</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>srvfdw</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-foreign-data-wrapper"><structname>pg_foreign_data_wrapper</structname></link>.oid</literal></entry>
      <entry>此外部服务器的外部数据包装器的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>srvtype</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Type of the server (optional)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>srvtype</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>服务器的类型（可选）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>srvversion</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Version of the server (optional)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>srvversion</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>服务器的版本（可选）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>srvacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       Access privileges; see <xref linkend="ddl-priv"/> for details
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>srvacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       访问权限，详见<xref linkend="ddl-priv"/>
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>srvoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       Foreign server specific options, as <quote>keyword=value</quote> strings
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>srvoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       外部服务器特定选项，以<quote>keyword=value</quote>字符串形式
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-foreign-table">
<!--==========================orignal english content==========================
  <title><structname>pg_foreign_table</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_foreign_table</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-foreign-table">
   <primary>pg_foreign_table</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-foreign-table">
   <primary>pg_foreign_table</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_foreign_table</structname> contains
   auxiliary information about foreign tables.  A foreign table is
   primarily represented by a <structname>pg_class</structname> entry,
   just like a regular table.  Its <structname>pg_foreign_table</structname>
   entry contains the information that is pertinent only to foreign tables
   and not any other kind of relation.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_foreign_table</structname>包含关于外部表的辅助信息。一个外部表和普通表一样，主要由一个<structname>pg_class</structname>项表示。它的<structname>pg_foreign_table</structname>项包含外部表所特有的信息。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_foreign_table</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_foreign_table</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>ftrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>OID of the <structname>pg_class</structname> entry for this foreign table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>ftrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>外部表的<structname>pg_class</structname>项的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>ftserver</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-foreign-server"><structname>pg_foreign_server</structname></link>.oid</literal></entry>
      <entry>OID of the foreign server for this foreign table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>ftserver</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-foreign-server"><structname>pg_foreign_server</structname></link>.oid</literal></entry>
      <entry>外部表所在的外部服务器的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>ftoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       Foreign table options, as <quote>keyword=value</quote> strings
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>ftoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       外部表选项，以<quote>keyword=value</quote>字符串形式
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-index">
<!--==========================orignal english content==========================
  <title><structname>pg_index</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_index</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-index">
   <primary>pg_index</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-index">
   <primary>pg_index</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_index</structname> contains part of the information
   about indexes.  The rest is mostly in
   <structname>pg_class</structname>.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_index</structname>包含关于索引的部分信息。其他信息大部分在<structname>pg_class</structname>中。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_index</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_index</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>indexrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The OID of the <structname>pg_class</structname> entry for this index</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>indexrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>此索引的<structname>pg_class</structname>项的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>indrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The OID of the <structname>pg_class</structname> entry for the table this index is for</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>indrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>此索引的基表的<structname>pg_class</structname>项的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>indnatts</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>The total number of columns in the index (duplicates
      <literal>pg_class.relnatts</literal>); this number includes both key and included attributes</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>indnatts</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>索引中的总列数（与<literal>pg_class.relnatts</literal>重复），这个数目包括键和被包括的属性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>indnkeyatts</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>The number of <firstterm>key columns</firstterm> in the index,
       not counting any <firstterm>included columns</firstterm>, which are
       merely stored and do not participate in the index semantics</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>indnkeyatts</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>索引中<firstterm>键列</firstterm>的编号，不计入任何的<firstterm>内含列</firstterm>，它们只是被存储但不参与索引的语义</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>indisunique</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>If true, this is a unique index</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>indisunique</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>表示是否为唯一索引</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>indisprimary</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>If true, this index represents the primary key of the table
      (<structfield>indisunique</structfield> should always be true when this is true)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>indisprimary</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>表示索引是否表示表的主键（如果此列为真，<structfield>indisunique</structfield>也总是为真）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>indisexclusion</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>If true, this index supports an exclusion constraint</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>indisexclusion</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>表示索引是否支持一个排他约束</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>indimmediate</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>If true, the uniqueness check is enforced immediately on
       insertion
       (irrelevant if <structfield>indisunique</structfield> is not true)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>indimmediate</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>表示唯一性检查是否在插入时立即被执行（如果<structfield>indisunique</structfield>为假，此列无关）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>indisclustered</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>If true, the table was last clustered on this index</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>indisclustered</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>如果为真，表示表最后以此索引进行了聚簇</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>indisvalid</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       If true, the index is currently valid for queries.  False means the
       index is possibly incomplete: it must still be modified by
       <command>INSERT</command>/<command>UPDATE</command> operations, but it cannot safely
       be used for queries. If it is unique, the uniqueness property is not
       guaranteed true either.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>indisvalid</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       如果为真，此索引当前可以用于查询。为假表示此索引可能不完整：它肯定还在被<command>INSERT</command>/<command>UPDATE</command>操作所修改，但它不能安全地被用于查询。如果索引是唯一索引，唯一性属性也不能被保证。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>indcheckxmin</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       If true, queries must not use the index until the <structfield>xmin</structfield>
       of this <structname>pg_index</structname> row is below their <symbol>TransactionXmin</symbol>
       event horizon, because the table may contain broken HOT chains with
       incompatible rows that they can see
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>indcheckxmin</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       如果为真，直到此<structname>pg_index</structname>行的<structfield>xmin</structfield>低于查询的<symbol>TransactionXmin</symbol>视界之前，查询都不能使用此索引，因为表可能包含具有它们可见的不相容行的损坏HOT链
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>indisready</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       If true, the index is currently ready for inserts.  False means the
       index must be ignored by <command>INSERT</command>/<command>UPDATE</command>
       operations.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>indisready</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       如果为真，表示此索引当前可以用于插入。为假表示索引必须被<command>INSERT</command>/<command>UPDATE</command>操作忽略。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>indislive</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       If false, the index is in process of being dropped, and should be
       ignored for all purposes (including HOT-safety decisions)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>indislive</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       如果为假，索引正处于被删除过程中，并且必须被所有处理忽略（包括HOT安全的决策）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>indisreplident</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       If true this index has been chosen as <quote>replica identity</quote>
       using <command>ALTER TABLE ... REPLICA IDENTITY USING INDEX
       ...</command>
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>indisreplident</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       如果为真，这个索引被选择为使用<command>ALTER TABLE ... REPLICA IDENTITY USING INDEX ...</command>的<quote>replica identity</quote>
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>indkey</structfield></entry>
      <entry><type>int2vector</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>
       This is an array of <structfield>indnatts</structfield> values that
       indicate which table columns this index indexes.  For example a value
       of <literal>1 3</literal> would mean that the first and the third table
       columns make up the index entries.  Key columns come before non-key
       (included) columns.  A zero in this array indicates that the
       corresponding index attribute is an expression over the table columns,
       rather than a simple column reference.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>indkey</structfield></entry>
      <entry><type>int2vector</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>
       这是一个<structfield>indnatts</structfield>值的数组，它表示了此索引索引的表列。例如一个<literal>1 3</literal>值可能表示表的第一和第三列组成了索引项。键列出现在非键（内含）列前面。数组中的一个0表示对应的索引属性是一个在表列上的表达式，而不是一个简单的列引用。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>indcollation</structfield></entry>
      <entry><type>oidvector</type></entry>
      <entry><literal><link linkend="catalog-pg-collation"><structname>pg_collation</structname></link>.oid</literal></entry>
      <entry>
       For each column in the index key
       (<structfield>indnkeyatts</structfield> values), this contains the OID
       of the collation to use for the index, or zero if the column is not of
       a collatable data type.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>indcollation</structfield></entry>
      <entry><type>oidvector</type></entry>
      <entry><literal><link linkend="catalog-pg-collation"><structname>pg_collation</structname></link>.oid</literal></entry>
      <entry>
       对于索引键（<structfield>indnkeyatts</structfield>值）中的每一列，这包含要用于该索引的排序规则的OID，如果该列不是一种可排序数据类型则为零。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>indclass</structfield></entry>
      <entry><type>oidvector</type></entry>
      <entry><literal><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.oid</literal></entry>
      <entry>
       For each column in the index key
       (<structfield>indnkeyatts</structfield> values), this contains the OID
       of the operator class to use.  See
       <link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link> for details.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>indclass</structfield></entry>
      <entry><type>oidvector</type></entry>
      <entry><literal><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.oid</literal></entry>
      <entry>
       对于索引键中的每一列（<structfield>indnkeyatts</structfield>值），这里包含了要使用的操作符类的OID。详见<link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>indoption</structfield></entry>
      <entry><type>int2vector</type></entry>
      <entry></entry>
      <entry>
       This is an array of <structfield>indnkeyatts</structfield> values that
       store per-column flag bits.  The meaning of the bits is defined by
       the index's access method.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>indoption</structfield></entry>
      <entry><type>int2vector</type></entry>
      <entry></entry>
      <entry>
       这是一个<structfield>indnkeyatts</structfield>值的数组，用于存储每列的标志位。位的意义由索引的访问方法定义。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>indexprs</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>
       Expression trees (in <function>nodeToString()</function>
       representation) for index attributes that are not simple column
       references.  This is a list with one element for each zero
       entry in <structfield>indkey</structfield>.  Null if all index attributes
       are simple references.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>indexprs</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>
       非简单列引用索引属性的表达式树（以<function>nodeToString()</function>形式）。对于<structfield>indkey</structfield>中每一个为0的项，这个列表中都有一个元素。如果所有的索引属性都是简单引用，此列为空。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>indpred</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>
       Expression tree (in <function>nodeToString()</function>
       representation) for partial index predicate.  Null if not a
       partial index.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>indpred</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>
       部分索引谓词的表达式树（以<function>nodeToString()</function>形式）。如果不是部分索引，此列为空。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-inherits">
<!--==========================orignal english content==========================
  <title><structname>pg_inherits</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_inherits</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-inherits">
   <primary>pg_inherits</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-inherits">
   <primary>pg_inherits</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_inherits</structname> records information about
   table inheritance hierarchies.  There is one entry for each direct
   parent-child table relationship in the database.  (Indirect inheritance can be determined
   by following chains of entries.)
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_inherits</structname>记录有关表继承层次的信息。数据库中每一个直接父子关系在这里都有一项（非直接继承可以通过顺着项构成的链来决定）。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_inherits</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_inherits</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>inhrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       The OID of the child table
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>inhrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       孩子表的OID
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>inhparent</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       The OID of the parent table
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>inhparent</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       父表的OID
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>inhseqno</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       If there is more than one direct parent for a child table (multiple
       inheritance), this number tells the order in which the
       inherited columns are to be arranged.  The count starts at 1.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>inhseqno</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       如果一个孩子表有多于一个直接父表（多继承），这个数字说明了继承列被排列的顺序。计数从1开始。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>
 
 <sect1 id="catalog-pg-init-privs">
<!--==========================orignal english content==========================
  <title><structname>pg_init_privs</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_init_privs</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-init-privs">
   <primary>pg_init_privs</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-init-privs">
   <primary>pg_init_privs</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_init_privs</structname> records information about
   the initial privileges of objects in the system.  There is one entry
   for each object in the database which has a non-default (non-NULL)
   initial set of privileges.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_init_privs</structname>记录系统中对象的初始特权。数据库中每一个具有非默认（非-NULL）初始特权集合的对象都有一个条目在其中。
  </para>

<!--==========================orignal english content==========================
  <para>
   Objects can have initial privileges either by having those privileges set
   when the system is initialized (by <application>initdb</application>) or when the
   object is created during a <command>CREATE EXTENSION</command> and the
   extension script sets initial privileges using the <command>GRANT</command>
   system.  Note that the system will automatically handle recording of the
   privileges during the extension script and that extension authors need
   only use the <command>GRANT</command> and <command>REVOKE</command>
   statements in their script to have the privileges recorded.  The
   <literal>privtype</literal> column indicates if the initial privilege was
   set by <application>initdb</application> or during a
   <command>CREATE EXTENSION</command> command.
  </para>
____________________________________________________________________________-->
  <para>
   对象可以在系统初始化（<application>initdb</application>）时获得其初始特权，也可以在<command>CREATE EXTENSION</command>期间创建该对象并且在扩展脚本中用<command>GRANT</command>来设置对象的初始特权。注意系统将自动处理扩展脚本执行期间对特权的记录，扩展的作者们只需要在他们的脚本中使用<command>GRANT</command>以及<command>REVOKE</command>语句以便特权被记录下来。<literal>privtype</literal>列表示初始特权是被<application>initdb</application>设置还是在一次<command>CREATE EXTENSION</command>命令期间被设置。
  </para>

<!--==========================orignal english content==========================
  <para>
   Objects which have initial privileges set by <application>initdb</application> will
   have entries where <literal>privtype</literal> is
   <literal>'i'</literal>, while objects which have initial privileges set
   by <command>CREATE EXTENSION</command> will have entries where
   <literal>privtype</literal> is <literal>'e'</literal>.
  </para>
____________________________________________________________________________-->
  <para>
   具有被<application>initdb</application>设置的初始特权的对象的条目中<literal>privtype</literal>是<literal>'i'</literal>，而具有被<command>CREATE EXTENSION</command>设置的初始特权的对象的条目中<literal>privtype</literal>为<literal>'e'</literal>。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_init_privs</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_init_privs</structname>列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>any OID column</entry>
      <entry>The OID of the specific object</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>任何 OID 列</entry>
      <entry>指定对象的 OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The OID of the system catalog the object is in</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>对象所在的系统目录的 OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       For a table column, this is the column number (the
       <structfield>objoid</structfield> and <structfield>classoid</structfield> refer to the
       table itself).  For all other object types, this column is
       zero.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       对于一个表列，这里是列编号（<structfield>objoid</structfield>和<structfield>classoid</structfield>指向表本身）。对于所有其他对象类型，这列为零。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>privtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       A code defining the type of initial privilege of this object; see text
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>privtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       定义这个对象初始特权类型的代码，见文字说明
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>initprivs</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       The initial access privileges; see
       <xref linkend="ddl-priv"/> for details
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>initprivs</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       初始的访问权限，详见<xref linkend="ddl-priv"/>
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="catalog-pg-language">
<!--==========================orignal english content==========================
  <title><structname>pg_language</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_language</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-language">
   <primary>pg_language</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-language">
   <primary>pg_language</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_language</structname> registers
   languages in which you can write functions or stored procedures.
   See <xref linkend="sql-createlanguage"/>
   and <xref linkend="xplang"/> for more information about language handlers.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_language</structname>注册了可用于编写函数或存储过程的语言。
   更多关于语言处理器的信息请参阅<xref linkend="sql-createlanguage"/>和<xref linkend="xplang"/>。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_language</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_language</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Row identifier</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>lanname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the language</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>lanname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>语言的名字</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>lanowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Owner of the language</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>lanowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>语言的拥有者</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>lanispl</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       This is false for internal languages (such as
       <acronym>SQL</acronym>) and true for user-defined languages.
       Currently, <application>pg_dump</application> still uses this
       to determine which languages need to be dumped, but this might be
       replaced by a different mechanism in the future.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>lanispl</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       内部语言为假（如<acronym>SQL</acronym>），用户定义语言为真。当前，<application>pg_dump</application>仍然使用这个列来决定要转储哪些语言，但在未来这可能会被一种不同的机制所取代。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>lanpltrusted</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       True if this is a trusted language, which means that it is believed
       not to grant access to anything outside the normal SQL execution
       environment.  Only superusers can create functions in untrusted
       languages.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>lanpltrusted</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       为真表示这是一种可信的语言，即它被相信不会向普通SQL执行环境之外的任何东西授予权限。只有超级用户可以在非可信语言中创建函数。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>lanplcallfoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       For noninternal languages this references the language
       handler, which is a special function that is responsible for
       executing all functions that are written in the particular
       language
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>lanplcallfoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       对于非内部语言，此列引用语言处理器，它是一个特殊函数负责执行所有用这种语言编写的函数
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>laninline</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       This references a function that is responsible for executing
       <quote>inline</quote> anonymous code blocks
       (<xref linkend="sql-do"/> blocks).
       Zero if inline blocks are not supported.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>laninline</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       此列引用一个负责执行<quote>内联</quote>匿名代码块的函数（<xref linkend="sql-do"/> 块）。如果不支持内联块则为0。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>lanvalidator</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       This references a language validator function that is responsible
       for checking the syntax and validity of new functions when they
       are created.  Zero if no validator is provided.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>lanvalidator</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       此列引用一个负责在函数创建时对其进行语法和可用性检查的语言验证函数。如果没有提供验证器则为0。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>lanacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       Access privileges; see <xref linkend="ddl-priv"/> for details
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>lanacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       访问权限，详情参见<xref linkend="ddl-priv"/>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-largeobject">
<!--==========================orignal english content==========================
  <title><structname>pg_largeobject</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_largeobject</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-largeobject">
   <primary>pg_largeobject</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-largeobject">
   <primary>pg_largeobject</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_largeobject</structname> holds the data making up
   <quote>large objects</quote>.  A large object is identified by an OID
   assigned when it is created.  Each large object is broken into
   segments or <quote>pages</quote> small enough to be conveniently stored as rows
   in <structname>pg_largeobject</structname>.
   The amount of data per page is defined to be <symbol>LOBLKSIZE</symbol> (which is currently
   <literal>BLCKSZ/4</literal>, or typically 2 kB).
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_largeobject</structname>保存构成<quote>大对象</quote>的数据。一个大对象在被创建时会被分配一个OID。每个大对象被分解成段或<quote>页</quote>，以便小到可以被方便地作为行存储在<structname>pg_largeobject</structname>中。每页中的数据量被定义为<symbol>LOBLKSIZE</symbol>（目前是<literal>BLCKSZ/4</literal>或是2 kB）。
  </para>

<!--==========================orignal english content==========================
  <para>
   Prior to <productname>PostgreSQL</productname> 9.0, there was no permission structure
   associated with large objects.  As a result,
   <structname>pg_largeobject</structname> was publicly readable and could be
   used to obtain the OIDs (and contents) of all large objects in the system.
   This is no longer the case; use
   <link linkend="catalog-pg-largeobject-metadata"><structname>pg_largeobject_metadata</structname></link>
   to obtain a list of large object OIDs.
  </para>
____________________________________________________________________________-->
  <para>
   在<productname>PostgreSQL</productname> 9.0之前，大对象没有相关的权限结构。作为结果，<structname>pg_largeobject</structname>是公共可读的并且可以用来获得系统中所有大对象的OID（和内容）。但现在不是这样了，可使用<link linkend="catalog-pg-largeobject-metadata"><structname>pg_largeobject_metadata</structname></link>来获得大对象OID的列表。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_largeobject</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_largeobject</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>loid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-largeobject-metadata"><structname>pg_largeobject_metadata</structname></link>.oid</literal></entry>
      <entry>Identifier of the large object that includes this page</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>loid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-largeobject-metadata"><structname>pg_largeobject_metadata</structname></link>.oid</literal></entry>
      <entry>包含此页的大对象的标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>pageno</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Page number of this page within its large object
      (counting from zero)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>pageno</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>此页在它所属大对象中的页号（从0开始计）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>data</structfield></entry>
      <entry><type>bytea</type></entry>
      <entry></entry>
      <entry>
       Actual data stored in the large object.
       This will never be more than <symbol>LOBLKSIZE</symbol> bytes and might be less.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>data</structfield></entry>
      <entry><type>bytea</type></entry>
      <entry></entry>
      <entry>
       实际存储在大对象中的数据。它从不会超过<symbol>LOBLKSIZE</symbol>字节，也可能更少。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   Each row of <structname>pg_largeobject</structname> holds data
   for one page of a large object, beginning at
   byte offset (<literal>pageno * LOBLKSIZE</literal>) within the object.  The implementation
   allows sparse storage: pages might be missing, and might be shorter than
   <literal>LOBLKSIZE</literal> bytes even if they are not the last page of the object.
   Missing regions within a large object read as zeroes.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_largeobject</structname>的每一行保存一个大对象的一个页的数据，从对象内部的字节偏移量（<literal>pageno * LOBLKSIZE</literal>）开始。现在的实现允许稀疏存储：页面可能丢失，并且可能比<literal>LOBLKSIZE</literal>字节短（即便不是最后一页）。一个大对象中丢失的区域会被读出为0。
  </para>

 </sect1>

 <sect1 id="catalog-pg-largeobject-metadata">
<!--==========================orignal english content==========================
  <title><structname>pg_largeobject_metadata</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_largeobject_metadata</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-largeobject-metadata">
   <primary>pg_largeobject_metadata</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-largeobject-metadata">
   <primary>pg_largeobject_metadata</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_largeobject_metadata</structname>
   holds metadata associated with large objects.  The actual large object
   data is stored in
   <link linkend="catalog-pg-largeobject"><structname>pg_largeobject</structname></link>.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_largeobject_metadata</structname>保持着与大对象有关的元数据。真正的大对象数据被存储在<link linkend="catalog-pg-largeobject"><structname>pg_largeobject</structname></link>中。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_largeobject_metadata</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_largeobject_metadata</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Row identifier</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>lomowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Owner of the large object</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>lomowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>大对象的拥有者</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>lomacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       Access privileges; see <xref linkend="ddl-priv"/> for details
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>lomacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       访问权限，详见<xref linkend="ddl-priv"/>
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-namespace">
<!--==========================orignal english content==========================
  <title><structname>pg_namespace</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_namespace</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-namespace">
   <primary>pg_namespace</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-namespace">
   <primary>pg_namespace</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_namespace</structname> stores namespaces.
   A namespace is the structure underlying SQL schemas: each namespace
   can have a separate collection of relations, types, etc. without name
   conflicts.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_namespace</structname>存储名字空间。名字空间是SQL模式之下的结构：每个名字空间拥有一个独立的表、类型等的集合，且其中没有名字冲突。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_namespace</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_namespace</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Row identifier</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>nspname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the namespace</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>nspname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>名字空间的名字</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>nspowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Owner of the namespace</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>nspowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>名字空间的拥有者</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>nspacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       Access privileges; see <xref linkend="ddl-priv"/> for details
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>nspacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       访问权限，详见<xref linkend="ddl-priv"/>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-opclass">
<!--==========================orignal english content==========================
  <title><structname>pg_opclass</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_opclass</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-opclass">
   <primary>pg_opclass</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-opclass">
   <primary>pg_opclass</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_opclass</structname> defines
   index access method operator classes.  Each operator class defines
   semantics for index columns of a particular data type and a particular
   index access method.  An operator class essentially specifies that a
   particular operator family is applicable to a particular indexable column
   data type.  The set of operators from the family that are actually usable
   with the indexed column are whichever ones accept the column's data type
   as their left-hand input.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_opclass</structname>定义索引访问方法的操作符类。每一个操作符类定义了一种特定数据类型和一种特定索引访问方法的索引列的语义。一个操作符类实际上指定了一个特定的操作符族可以用于一个特定可索引列数据类型。该族中可用于索引列的操作符能够接受该列的数据类型作为它们的左输入。
  </para>

<!--==========================orignal english content==========================
  <para>
   Operator classes are described at length in <xref linkend="xindex"/>.
  </para>
____________________________________________________________________________-->
  <para>
   操作符类详见<xref linkend="xindex"/>。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_opclass</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_opclass</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Row identifier</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>opcmethod</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-am"><structname>pg_am</structname></link>.oid</literal></entry>
      <entry>Index access method operator class is for</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>opcmethod</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-am"><structname>pg_am</structname></link>.oid</literal></entry>
      <entry>操作符类所属的索引访问方法</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>opcname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of this operator class</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>opcname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>操作符类的名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>opcnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>Namespace of this operator class</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>opcnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>操作符类所属的名字空间</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>opcowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Owner of the operator class</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>opcowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>操作符类的拥有者</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>opcfamily</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>.oid</literal></entry>
      <entry>Operator family containing the operator class</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>opcfamily</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>.oid</literal></entry>
      <entry>包含此操作符类的操作符族</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>opcintype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Data type that the operator class indexes</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>opcintype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>操作符类索引的数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>opcdefault</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if this operator class is the default for <structfield>opcintype</structfield></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>opcdefault</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>如果此操作符类为<structfield>opcintype</structfield>的默认值则为真</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>opckeytype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Type of data stored in index, or zero if same as <structfield>opcintype</structfield></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>opckeytype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>存储在索引中的数据的类型，如果值为0表示与<structfield>opcintype</structfield>相同</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   An operator class's <structfield>opcmethod</structfield> must match the
   <structname>opfmethod</structname> of its containing operator family.
   Also, there must be no more than one <structname>pg_opclass</structname>
   row having <structname>opcdefault</structname> true for any given combination of
   <structname>opcmethod</structname> and <structname>opcintype</structname>.
  </para>
____________________________________________________________________________-->
  <para>
   一个操作符类的<structfield>opcmethod</structfield>必须匹配包含它的操作符族的<structname>opfmethod</structname>。而且，对于任何给定的<structname>opcmethod</structname>和<structname>opcintype</structname>组合，只有不超过一个<structname>pg_opclass</structname>行的<structname>opcdefault</structname>值为真。
  </para>

 </sect1>


 <sect1 id="catalog-pg-operator">
<!--==========================orignal english content==========================
  <title><structname>pg_operator</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_operator</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-operator">
   <primary>pg_operator</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-operator">
   <primary>pg_operator</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_operator</structname> stores information about operators.
   See <xref linkend="sql-createoperator"/>
   and <xref linkend="xoper"/> for more information.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_operator</structname>存储关于操作符的信息。详见<xref linkend="sql-createoperator"/>和<xref linkend="xoper"/>。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_operator</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_operator</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Row identifier</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oprname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the operator</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oprname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>操作符的名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oprnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       The OID of the namespace that contains this operator
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oprnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       操作符所属的名字空间的OID
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oprowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Owner of the operator</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oprowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>操作符的拥有者</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oprkind</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <literal>b</literal> = infix (<quote>both</quote>), <literal>l</literal> = prefix
       (<quote>left</quote>), <literal>r</literal> = postfix (<quote>right</quote>)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oprkind</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <literal>b</literal> = 中缀 (<quote>并</quote>), <literal>l</literal> = 前缀
       (<quote>左</quote>), <literal>r</literal> = 后缀 (<quote>右</quote>)
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oprcanmerge</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>This operator supports merge joins</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oprcanmerge</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>该操作符是否支持归并连接</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oprcanhash</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>This operator supports hash joins</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oprcanhash</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>该操作符是否支持哈希连接</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oprleft</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Type of the left operand</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oprleft</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>左操作数类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oprright</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Type of the right operand</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oprright</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>右操作数类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oprresult</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Type of the result</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oprresult</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>结果类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oprcom</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>Commutator of this operator, if any</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oprcom</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>该操作符的交换子（如果存在）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oprnegate</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>Negator of this operator, if any</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oprnegate</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>该操作符的否定（如果存在）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oprcode</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Function that implements this operator</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oprcode</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>实现该操作符的函数</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oprrest</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Restriction selectivity estimation function for this operator</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oprrest</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>该操作符的限制选择度估算函数</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oprjoin</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Join selectivity estimation function for this operator</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oprjoin</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>该操作符的连接选择度估算函数</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   Unused column contain zeroes. For example, <structfield>oprleft</structfield>
   is zero for a prefix operator.
  </para>
____________________________________________________________________________-->
  <para>
   未用的列包含零值。例如，一个前缀操作符的<structfield>oprleft</structfield>为0。
  </para>

 </sect1>


 <sect1 id="catalog-pg-opfamily">
<!--==========================orignal english content==========================
  <title><structname>pg_opfamily</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_opfamily</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-opfamily">
   <primary>pg_opfamily</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-opfamily">
   <primary>pg_opfamily</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_opfamily</structname> defines operator families.
   Each operator family is a collection of operators and associated
   support routines that implement the semantics specified for a particular
   index access method.  Furthermore, the operators in a family are all
   <quote>compatible</quote>, in a way that is specified by the access method.
   The operator family concept allows cross-data-type operators to be used
   with indexes and to be reasoned about using knowledge of access method
   semantics.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_opfamily</structname>定义了操作符族。每一个操作符族是操作符和相关支持例程的集合，支持例程用于实现一个特定索引访问方法的语义。此外，按照访问方法指定的某种方式，一个族内的操作符都是<quote>兼容的</quote>。操作符族概念允许在索引中使用跨数据类型操作符，并可以使用访问方法语义的知识推导出。
  </para>

<!--==========================orignal english content==========================
  <para>
   Operator families are described at length in <xref linkend="xindex"/>.
  </para>
____________________________________________________________________________-->
  <para>
   操作符族最终在<xref linkend="xindex"/>中描述。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_opfamily</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_opfamily</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Row identifier/entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>opfmethod</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-am"><structname>pg_am</structname></link>.oid</literal></entry>
      <entry>Index access method operator family is for</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>opfmethod</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-am"><structname>pg_am</structname></link>.oid</literal></entry>
      <entry>操作符族适用的索引访问方法</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>opfname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of this operator family</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>opfname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>操作符族的名字</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>opfnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>Namespace of this operator family</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>opfnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>操作符族所属的名字空间</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>opfowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Owner of the operator family</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>opfowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>操作符族的拥有者</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   The majority of the information defining an operator family is not in its
   <structname>pg_opfamily</structname> row, but in the associated rows in
   <link linkend="catalog-pg-amop"><structname>pg_amop</structname></link>,
   <link linkend="catalog-pg-amproc"><structname>pg_amproc</structname></link>,
   and
   <link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.
  </para>
____________________________________________________________________________-->
  <para>
   定义操作符族的主要信息不在它的<structname>pg_opfamily</structname>行，而是在相关的<link linkend="catalog-pg-amop"><structname>pg_amop</structname></link>、<link linkend="catalog-pg-amproc"><structname>pg_amproc</structname></link>和<link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>行中。
  </para>

 </sect1>

 <sect1 id="catalog-pg-partitioned-table">
<!--==========================orignal english content==========================
  <title><structname>pg_partitioned_table</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_partitioned_table</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-partitioned-table">
   <primary>pg_partitioned_table</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-partitioned-table">
   <primary>pg_partitioned_table</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_partitioned_table</structname> stores
   information about how tables are partitioned.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_partitioned_table</structname>存放有关表如何被分区的信息。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_partitioned_table</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_partitioned_table</structname>列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>partrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The OID of the <structname>pg_class</structname> entry for this partitioned table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>partrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>这个分区表的<structname>pg_class</structname>项的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>partstrat</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Partitioning strategy; <literal>h</literal> = hash partitioned table,
       <literal>l</literal> = list partitioned table, <literal>r</literal> = range partitioned table
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>partstrat</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       分区策略；<literal>h</literal> = 哈希分区表，<literal>l</literal> = 列表分区表，<literal>r</literal> = 范围分区表
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>partnatts</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>The number of columns in partition key</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>partnatts</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>分区键中的列数</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>partdefid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       The OID of the <structname>pg_class</structname> entry for the default partition
       of this partitioned table, or zero if this partitioned table does not
       have a default partition.
     </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>partdefid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       这个分区表的默认分区的<structname>pg_class</structname>项的OID，如果这个分区表没有默认分区则为零。
     </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>partattrs</structfield></entry>
      <entry><type>int2vector</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>
       This is an array of <structfield>partnatts</structfield> values that
       indicate which table columns are part of the partition key.  For
       example, a value of <literal>1 3</literal> would mean that the first
       and the third table columns make up the partition key.  A zero in this
       array indicates that the corresponding partition key column is an
       expression, rather than a simple column reference.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>partattrs</structfield></entry>
      <entry><type>int2vector</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>
       这是一个长度为<structfield>partnatts</structfield>值的数组，它指示哪些表列是分区键的组成部分。例如，值<literal>1 3</literal>表示第一个和第三个表列组成了分区键。这个数组中的零表示对应的分区键列是一个表达式而不是简单的列引用。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>partclass</structfield></entry>
      <entry><type>oidvector</type></entry>
      <entry><literal><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.oid</literal></entry>
      <entry>
       For each column in the partition key, this contains the OID of the
       operator class to use.  See
       <link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link> for details.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>partclass</structfield></entry>
      <entry><type>oidvector</type></entry>
      <entry><literal><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.oid</literal></entry>
      <entry>
       对于分区键中的每一个列，这个域包含要使用的操作符类的OID。详见<link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>partcollation</structfield></entry>
      <entry><type>oidvector</type></entry>
      <entry><literal><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.oid</literal></entry>
      <entry>
       For each column in the partition key, this contains the OID of the
       collation to use for partitioning, or zero if the column is not
       of a collatable data type.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>partcollation</structfield></entry>
      <entry><type>oidvector</type></entry>
      <entry><literal><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.oid</literal></entry>
      <entry>
       对于分区键中的每一个列，这个域包含要用于分区的排序规则的OID，如果该列不是一种可排序数据类型则为零。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>partexprs</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>
       Expression trees (in <function>nodeToString()</function>
       representation) for partition key columns that are not simple column
       references.  This is a list with one element for each zero
       entry in <structfield>partattrs</structfield>.  Null if all partition key columns
       are simple references.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>partexprs</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>
       非简单列引用的分区键列的表达式树（以<function>nodeToString()</function>的表达方式）。这是一个列表，<structfield>partattrs</structfield>中每一个零项都有一个元素。如果所有分区键列都是简单列引用，则这个域为空。
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-pltemplate">
<!--==========================orignal english content==========================
  <title><structname>pg_pltemplate</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_pltemplate</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-pltemplate">
   <primary>pg_pltemplate</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-pltemplate">
   <primary>pg_pltemplate</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_pltemplate</structname> stores
   <quote>template</quote> information for procedural languages.
   A template for a language allows the language to be created in a
   particular database by a simple <command>CREATE LANGUAGE</command> command,
   with no need to specify implementation details.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_pltemplate</structname>存储了过程语言的<quote>模板</quote>信息。一个语言的模板允许我们在一个特定数据库中以一个简单的<command>CREATE LANGUAGE</command>命令创建语言，而不需要指定实现细节。
  </para>

<!--==========================orignal english content==========================
  <para>
   Unlike most system catalogs, <structname>pg_pltemplate</structname>
   is shared across all databases of a cluster: there is only one
   copy of <structname>pg_pltemplate</structname> per cluster, not
   one per database.  This allows the information to be accessible in
   each database as it is needed.
  </para>
____________________________________________________________________________-->
  <para>
   和大部分系统目录不同，<structname>pg_pltemplate</structname>是在集簇的所有数据库之间共享的：在一个集簇中只有一份<structname>pg_pltemplate</structname>拷贝，而不是每个数据库一份。这使得在每个需要的数据库中都可以访问该信息。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_pltemplate</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_pltemplate</structname>的列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tmplname</structfield></entry>
      <entry><type>name</type></entry>
      <entry>Name of the language this template is for</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tmplname</structfield></entry>
      <entry><type>name</type></entry>
      <entry>该模板适用的语言名字</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tmpltrusted</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>True if language is considered trusted</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tmpltrusted</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>如果语言被认为是可信的则为真</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tmpldbacreate</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>True if language may be created by a database owner</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tmpldbacreate</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>如果语言可以被一个数据库拥有者创建则为真</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tmplhandler</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Name of call handler function</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tmplhandler</structfield></entry>
      <entry><type>text</type></entry>
      <entry>调用处理函数的名字</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tmplinline</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Name of anonymous-block handler function, or null if none</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tmplinline</structfield></entry>
      <entry><type>text</type></entry>
      <entry>匿名阻塞处理函数的名字，如果没有则为空</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tmplvalidator</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Name of validator function, or null if none</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tmplvalidator</structfield></entry>
      <entry><type>text</type></entry>
      <entry>验证函数的名字，如果没有则为空</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tmpllibrary</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Path of shared library that implements language</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tmpllibrary</structfield></entry>
      <entry><type>text</type></entry>
      <entry>实现语言的共享库的路径</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tmplacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry>Access privileges for template (not actually used)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tmplacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry>模板的访问权限（并未真正使用）</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   There are not currently any commands that manipulate procedural language
   templates; to change the built-in information, a superuser must modify
   the table using ordinary <command>INSERT</command>, <command>DELETE</command>,
   or <command>UPDATE</command> commands.
  </para>
____________________________________________________________________________-->
  <para>
   目前任何命令都不能操纵过程语言模板。要改变内建信息，超级用户必须使用普通的<command>INSERT</command>、<command>DELETE</command>或<command>UPDATE</command>命令修改该表。
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    It is likely that <structname>pg_pltemplate</structname> will be removed in some
    future release of <productname>PostgreSQL</productname>, in favor of
    keeping this knowledge about procedural languages in their respective
    extension installation scripts.
   </para>
____________________________________________________________________________-->
   <para>
    在<productname>PostgreSQL</productname>的某个未来版本的发布中，<structname>pg_pltemplate</structname>很有可能会被移除，而这些关于过程语言的知识可能会保持在它们相应的扩展安装脚本中。
   </para>
  </note>

 </sect1>
 
 <sect1 id="catalog-pg-policy">
<!--==========================orignal english content==========================
  <title><structname>pg_policy</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_policy</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-policy">
   <primary>pg_policy</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-policy">
   <primary>pg_policy</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_policy</structname> stores row level
   security policies for tables.  A policy includes the kind of
   command that it applies to (possibly all commands), the roles that it
   applies to, the expression to be added as a security-barrier
   qualification to queries that include the table, and the expression
   to be added as a <literal>WITH CHECK</literal> option for queries that attempt to
   add new records to the table.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_policy</structname>存储着表的行级安全性策略。
   一个策略包括它适用于的命令种类（可能适用于所有命令）、它适用于的角色、
   被作为安全屏障条件增加到包括该表的查询的表达式以及被作为
   <literal>WITH CHECK</literal>选项增加到尝试向表增加新纪录的查询的表达式。
  </para>

  <table>

<!--==========================orignal english content==========================
   <title><structname>pg_policy</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_policy</structname>列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>polname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>The name of the policy</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>polname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>策略的名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>polrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The table to which the policy applies</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>polrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>策略适用的表</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>polcmd</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>The command type to which the policy is applied:
       <literal>r</literal> for <command>SELECT</command>,
       <literal>a</literal> for <command>INSERT</command>,
       <literal>w</literal> for <command>UPDATE</command>,
       <literal>d</literal> for <command>DELETE</command>,
       or <literal>*</literal> for all</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>polcmd</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>策略适用的命令类型：
       <literal>r</literal>表示<command>SELECT</command>，
       <literal>a</literal>表示<command>INSERT</command>，
       <literal>w</literal>表示<command>UPDATE</command>，
       <literal>d</literal>表示<command>DELETE</command>，
       <literal>*</literal>表示所有命令类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>polpermissive</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry></entry>
      <entry>Is the policy permissive or restrictive?</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>polpermissive</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry></entry>
      <entry>策略是宽容性的还是限制性的？</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>polroles</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>The roles to which the policy is applied</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>polroles</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>策略适用的角色</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>polqual</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>The expression tree to be added to the security barrier qualifications for queries that use the table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>polqual</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>被作为安全屏障条件增加到使用该表的查询的表达式树</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>polwithcheck</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>The expression tree to be added to the WITH CHECK qualifications for queries that attempt to add rows to the table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>polwithcheck</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>被作为WITH CHECK 条件增加到尝试向表增加行的查询的表达式树</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <note>
<!--==========================orignal english content==========================
   <para>
    Policies stored in <structname>pg_policy</structname> are applied only when
    <structname>pg_class</structname>.<structfield>relrowsecurity</structfield> is set for
    their table.
   </para>
____________________________________________________________________________-->
   <para>
    存储在<structname>pg_policy</structname>中的策略只有在它们所适用的表的
    <structname>pg_class</structname>.<structfield>relrowsecurity</structfield>被设置时才其作用。
   </para>
  </note>

 </sect1>

 <sect1 id="catalog-pg-proc">
<!--==========================orignal english content==========================
  <title><structname>pg_proc</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_proc</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-proc">
   <primary>pg_proc</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-proc">
   <primary>pg_proc</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_proc</structname> stores information about
   functions, procedures, aggregate functions, and window functions
   (collectively also known as routines).  See <xref
   linkend="sql-createfunction"/>, <xref linkend="sql-createprocedure"/>, and
   <xref linkend="xfunc"/> for more information.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_proc</structname>存放有关函数、过程、聚集函数以及窗口函数（共称为例程）的信息。更多信息请参考<xref linkend="sql-createfunction"/>、<xref linkend="sql-createprocedure"/>和<xref linkend="xfunc"/>。
  </para>

<!--==========================orignal english content==========================
  <para>
   If <structfield>prokind</structfield> indicates that the entry is for an
   aggregate function, there should be a matching row in
   <structfield>pg_aggregate</structfield>.
  </para>
____________________________________________________________________________-->
  <para>
   如果<structfield>proisagg</structfield>为真，则该项是一个聚集函数，在<structfield>pg_aggregate</structfield>中应该有一个相匹配的行。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_proc</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_proc</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Row identifier</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>proname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the function</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>proname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>函数的名字</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>pronamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       The OID of the namespace that contains this function
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>pronamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       函数所属的名字空间的OID
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>proowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Owner of the function</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>proowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>函数的拥有者</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>prolang</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-language"><structname>pg_language</structname></link>.oid</literal></entry>
      <entry>Implementation language or call interface of this function</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>prolang</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-language"><structname>pg_language</structname></link>.oid</literal></entry>
      <entry>实现语言或该函数的调用接口</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>procost</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>Estimated execution cost (in units of
       <xref linkend="guc-cpu-operator-cost"/>); if <structfield>proretset</structfield>,
       this is cost per row returned</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>procost</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>估计的执行代价（以<xref linkend="guc-cpu-operator-cost"/>为单位），如果<structfield>proretset</structfield>为真，这是每行返回的代价</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>prorows</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>Estimated number of result rows (zero if not <structfield>proretset</structfield>)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>prorows</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>估计的结果行数量（如果<structfield>proretset</structfield>为假，该值为0）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>provariadic</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Data type of the variadic array parameter's elements,
       or zero if the function does not have a variadic parameter</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>provariadic</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>可变数组参数的元素的数据类型，如果函数没有可变参数则为0</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>prosupport</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Optional planner support function for this function
       (see <xref linkend="xfunc-optimization"/>)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>prosupport</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>对于该函数可选的计划器支持函数（见<xref linkend="xfunc-optimization"/>）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>prokind</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry><literal>f</literal> for a normal function, <literal>p</literal>
      for a procedure, <literal>a</literal> for an aggregate function, or
      <literal>w</literal> for a window function</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>prokind</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry><literal>f</literal>表示普通函数，<literal>p</literal>表示过程，<literal>a</literal>表示聚集函数，<literal>w</literal>表示窗口函数</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>prosecdef</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Function is a security definer (i.e., a <quote>setuid</quote>
      function)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>prosecdef</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>函数是一个安全性定义者（即，一个<quote>setuid</quote>函数）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>proleakproof</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       The function has no side effects.  No information about the
       arguments is conveyed except via the return value.  Any function
       that might throw an error depending on the values of its arguments
       is not leak-proof.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>proleakproof</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       该函数没有副作用。除了通过返回值，没有关于参数的信息被传播。任何会抛出基于其参数值的错误信息的函数都不是泄露验证的。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>proisstrict</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Function returns null if any call argument is null.  In that
       case the function won't actually be called at all.  Functions
       that are not <quote>strict</quote> must be prepared to handle
       null inputs.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>proisstrict</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       当任意调用函数为空时，函数是否会返回空值。在那种情况下函数实际上根本不会被调用。非<quote>strict</quote>函数必须准备好处理空值输入。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>proretset</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Function returns a set (i.e., multiple values of the specified
      data type)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>proretset</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>函数是否返回一个集合（即，指定数据类型的多个值）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>provolatile</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <structfield>provolatile</structfield> tells whether the function's
       result depends only on its input arguments, or is affected by outside
       factors.
       It is <literal>i</literal> for <quote>immutable</quote> functions,
       which always deliver the same result for the same inputs.
       It is <literal>s</literal> for <quote>stable</quote> functions,
       whose results (for fixed inputs) do not change within a scan.
       It is <literal>v</literal> for <quote>volatile</quote> functions,
       whose results might change at any time.  (Use <literal>v</literal> also
       for functions with side-effects, so that calls to them cannot get
       optimized away.)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>provolatile</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <structfield>provolatile</structfield>说明函数是仅仅只依赖于它的输入参数，还是会被外部因素影响。值<literal>i</literal>表示<quote>不变的</quote>函数，它对于相同的输入总是输出相同的结果。值<literal>s</literal>表示<quote>稳定的</quote>函数，它的结果（对于固定输入）在一次扫描内不会变化。值<literal>v</literal>表示<quote>不稳定的</quote>函数，它的结果在任何时候都可能变化（使用<literal>v</literal>页表示函数具有副作用，所以对它们的调用无法得到优化）
      </entry>
     </row>
     
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>proparallel</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <structfield>proparallel</structfield> tells whether the function
       can be safely run in parallel mode.
       It is <literal>s</literal> for functions which are safe to run in
       parallel mode without restriction.
       It is <literal>r</literal> for functions which can be run in parallel
       mode, but their execution is restricted to the parallel group leader;
       parallel worker processes cannot invoke these functions.
       It is <literal>u</literal> for functions which are unsafe in parallel
       mode; the presence of such a function forces a serial execution plan.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>proparallel</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <structfield>proparallel</structfield>说明该函数在并行模式下是否能安全地运行。对于能在并行模式下不受限制安全运行的函数，这列是<literal>s</literal>。对于可以在并行模式下运行但是只限于由并行分组的领导者执行的函数，这列是<literal>r</literal>。对于在并行模式中不安全的函数，这列是<literal>u</literal>，这种函数的存在会强制一个顺序执行计划。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>pronargs</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Number of input arguments</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>pronargs</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>输入参数的个数</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>pronargdefaults</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Number of arguments that have defaults</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>pronargdefaults</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>具有默认值的参数个数</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>prorettype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Data type of the return value</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>prorettype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>返回值的数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>proargtypes</structfield></entry>
      <entry><type>oidvector</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       An array with the data types of the function arguments.  This includes
       only input arguments (including <literal>INOUT</literal> and
       <literal>VARIADIC</literal> arguments), and thus represents
       the call signature of the function.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>proargtypes</structfield></entry>
      <entry><type>oidvector</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       一个函数参数的数据类型的数组。这只包括输入参数（含<literal>INOUT</literal>和<literal>VARIADIC</literal>参数），因此也表现了函数的调用特征。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>proallargtypes</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       An array with the data types of the function arguments.  This includes
       all arguments (including <literal>OUT</literal> and
       <literal>INOUT</literal> arguments); however, if all the
       arguments are <literal>IN</literal> arguments, this field will be null.
       Note that subscripting is 1-based, whereas for historical reasons
       <structfield>proargtypes</structfield> is subscripted from 0.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>proallargtypes</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       一个函数参数的数据类型的数组。这包括所有参数（含<literal>OUT</literal>和<literal>INOUT</literal>参数）。但是，如果所有参数都是<literal>IN</literal>参数，这个域将为空。注意下标是从1开始 ，然而由于历史原因<structfield>proargtypes</structfield>的下标是从0开始。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>proargmodes</structfield></entry>
      <entry><type>char[]</type></entry>
      <entry></entry>
      <entry>
        An array with the modes of the function arguments, encoded as
        <literal>i</literal> for <literal>IN</literal> arguments,
        <literal>o</literal> for <literal>OUT</literal> arguments,
        <literal>b</literal> for <literal>INOUT</literal> arguments,
        <literal>v</literal> for <literal>VARIADIC</literal> arguments,
        <literal>t</literal> for <literal>TABLE</literal> arguments.
        If all the arguments are <literal>IN</literal> arguments,
        this field will be null.
        Note that subscripts correspond to positions of
        <structfield>proallargtypes</structfield> not <structfield>proargtypes</structfield>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>proargmodes</structfield></entry>
      <entry><type>char[]</type></entry>
      <entry></entry>
      <entry>
        一个函数参数的模式的数组。编码为：
        <literal>i</literal>表示<literal>IN</literal>参数 ，
        <literal>o</literal>表示<literal>OUT</literal>参数，
        <literal>b</literal>表示<literal>INOUT</literal>参数，
        <literal>v</literal>表示<literal>VARIADIC</literal>参数，
        <literal>t</literal>表示<literal>TABLE</literal>参数。
        如果所有的参数都是<literal>IN</literal>参数，这个域为空。注意这里的下标对应着<structfield>proallargtypes</structfield>而不是<structfield>proargtypes</structfield>中的位置。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>proargnames</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
        An array with the names of the function arguments.
        Arguments without a name are set to empty strings in the array.
        If none of the arguments have a name, this field will be null.
        Note that subscripts correspond to positions of
        <structfield>proallargtypes</structfield> not <structfield>proargtypes</structfield>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>proargnames</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
        一个函数参数的名字的数组。没有名字的参数在数组中设置为空字符串。如果没有一个参数有名字，这个域为空。注意这里的下标对应着<structfield>proallargtypes</structfield>而不是<structfield>proargtypes</structfield>中的位置。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>proargdefaults</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>
       Expression trees (in <function>nodeToString()</function> representation)
       for default values.  This is a list with
       <structfield>pronargdefaults</structfield> elements, corresponding to the last
       <replaceable>N</replaceable> <emphasis>input</emphasis> arguments (i.e., the last
       <replaceable>N</replaceable> <structfield>proargtypes</structfield> positions).
       If none of the arguments have defaults, this field will be null.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>proargdefaults</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>
       默认值的表达式树（按照<function>nodeToString()</function>的表现方式）。这是一个<structfield>pronargdefaults</structfield>元素的列表，对应于最后<replaceable>N</replaceable>个<emphasis>input</emphasis>参数（即最后<replaceable>N</replaceable>个<structfield>proargtypes</structfield>位置）。如果没有一个参数具有默认值，这个域为空。
      </entry>
     </row>
     
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>protrftypes</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry></entry>
      <entry>
       Data type OIDs for which to apply transforms.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>protrftypes</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry></entry>
      <entry>
       要在其上应用转换的数据类型的 OID。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>prosrc</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       This tells the function handler how to invoke the function.  It
       might be the actual source code of the function for interpreted
       languages, a link symbol, a file name, or just about anything
       else, depending on the implementation language/call convention.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>prosrc</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       这个域告诉函数处理者如何调用该函数。它可能是针对解释型语言的真实源码、一个符号链接、一个文件名或任何其他东西，这取决于实现语言/调用规范。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>probin</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       Additional information about how to invoke the function.
       Again, the interpretation is language-specific.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>probin</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       关于如何调用函数的附加信息。其解释是与语言相关的。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>proconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>Function's local settings for run-time configuration variables</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>proconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>函数对于运行时配置变量的本地设置值</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>proacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       Access privileges; see <xref linkend="ddl-priv"/> for details
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>proacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       访问权限，详见<xref linkend="ddl-priv"/>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   For compiled functions, both built-in and dynamically loaded,
   <structfield>prosrc</structfield> contains the function's C-language
   name (link symbol).  For all other currently-known language types,
   <structfield>prosrc</structfield> contains the function's source
   text.  <structfield>probin</structfield> is unused except for
   dynamically-loaded C functions, for which it gives the name of the
   shared library file containing the function.
  </para>
____________________________________________________________________________-->
  <para>
   对于编译好的函数，包括内建的和动态载入的，<structfield>prosrc</structfield>包含了函数的C语言名字（链接符号）。对于所有其他已知的语言类型，<structfield>prosrc</structfield>包含函数的源码文本。除了对于动态载入的C函数之外，<structfield>probin</structfield>是不被使用的。对于动态载入的C函数，它给定了包含该函数的共享库文件的名称。
  </para>

 </sect1>

 <sect1 id="catalog-pg-publication">
<!--==========================orignal english content==========================
  <title><structname>pg_publication</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_publication</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-publication">
   <primary>pg_publication</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-publication">
   <primary>pg_publication</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_publication</structname> contains all
   publications created in the database.  For more on publications see
   <xref linkend="logical-replication-publication"/>.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_publication</structname>包含数据库中创建的所有publication。更多关于publication的内容请见<xref linkend="logical-replication-publication"/>。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_publication</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_publication</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Row identifier</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>pubname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the publication</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>pubname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>publication的名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>pubowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Owner of the publication</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>pubowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>publication的拥有者</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>puballtables</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>If true, this publication automatically includes all tables
       in the database, including any that will be created in the future.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>puballtables</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>如果为真，这个publication自动包括数据库中的所有表，包括未来将会创建的任何表。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>pubinsert</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>If true, <command>INSERT</command> operations are replicated for
       tables in the publication.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>pubinsert</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>如果为真，为publication中的表复制<command>INSERT</command>操作。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>pubupdate</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>If true, <command>UPDATE</command> operations are replicated for
       tables in the publication.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>pubupdate</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>如果为真，为publication中的表复制<command>UPDATE</command>操作。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>pubdelete</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>If true, <command>DELETE</command> operations are replicated for
       tables in the publication.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>pubdelete</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>如果为真，为publication中的表复制<command>DELETE</command>操作。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>pubtruncate</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>If true, <command>TRUNCATE</command> operations are replicated for
       tables in the publication.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>pubtruncate</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>如果为真，为publication中的表复制<command>TRUNCATE</command>操作。</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-publication-rel">
<!--==========================orignal english content==========================
  <title><structname>pg_publication_rel</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_publication_rel</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-publication-rel">
   <primary>pg_publication_rel</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-publication-rel">
   <primary>pg_publication_rel</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_publication_rel</structname> contains the
   mapping between relations and publications in the database.  This is a
   many-to-many mapping.  See also <xref linkend="view-pg-publication-tables"/>
   for a more user-friendly view of this information.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_publication_rel</structname>包含数据库中关系和publication之间的映射。这是一种多对多映射。这些信息对用户更加友好的视图请参考<xref linkend="view-pg-publication-tables"/>。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_publication_rel</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_publication_rel</structname>列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>prpubid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-publication"><structname>pg_publication</structname></link>.oid</literal></entry>
      <entry>Reference to publication</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>prpubid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-publication"><structname>pg_publication</structname></link>.oid</literal></entry>
      <entry>对publication的引用</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>prrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>Reference to relation</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>prrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>对关系的引用</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-range">
<!--==========================orignal english content==========================
  <title><structname>pg_range</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_range</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-range">
   <primary>pg_range</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-range">
   <primary>pg_range</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_range</structname> stores information about
   range types.  This is in addition to the types' entries in
   <link linkend="catalog-pg-type"><structname>pg_type</structname></link>.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_range</structname>存储关于范围类型的信息。它是类型在<link linkend="catalog-pg-type"><structname>pg_type</structname></link>中项的补充。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_range</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_range</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>rngtypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>OID of the range type</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>rngtypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>范围类型的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>rngsubtype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>OID of the element type (subtype) of this range type</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>rngsubtype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>该范围类型的元素类型（子类型）的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>rngcollation</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-collation"><structname>pg_collation</structname></link>.oid</literal></entry>
      <entry>OID of the collation used for range comparisons, or 0 if none</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>rngcollation</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-collation"><structname>pg_collation</structname></link>.oid</literal></entry>
      <entry>用于范围比较的排序规则的OID，如果没有则为0</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>rngsubopc</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.oid</literal></entry>
      <entry>OID of the subtype's operator class used for range comparisons</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>rngsubopc</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.oid</literal></entry>
      <entry>用于范围比较的子类型的操作符类的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>rngcanonical</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID of the function to convert a range value into canonical form,
      or 0 if none</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>rngcanonical</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>将一个范围值转换为规范形式的函数的OID，如果没有则为0</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>rngsubdiff</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID of the function to return the difference between two element
      values as <type>double precision</type>, or 0 if none</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>rngsubdiff</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>以<type>双精度</type>返回两个元素值不同的函数的OID，如果没有则为0</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   <structfield>rngsubopc</structfield> (plus <structfield>rngcollation</structfield>, if the
   element type is collatable) determines the sort ordering used by the range
   type.  <structfield>rngcanonical</structfield> is used when the element type is
   discrete.  <structfield>rngsubdiff</structfield> is optional but should be supplied to
   improve performance of GiST indexes on the range type.
  </para>
____________________________________________________________________________-->
  <para>
   <structfield>rngsubopc</structfield> （加上<structfield>rngcollation</structfield>，如果元素类型是可排序的）决定了被该范围类型所使用的排序顺序。<structfield>rngcanonical</structfield>用于离散类型的元素类型。<structfield>rngsubdiff</structfield>是可选的，但是提供它可以提高范围类型上的GiST索引性能。
  </para>

 </sect1>
 
 <sect1 id="catalog-pg-replication-origin">
<!--==========================orignal english content==========================
  <title><structname>pg_replication_origin</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_replication_origin</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-replication-origin">
   <primary>pg_replication_origin</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-replication-origin">
   <primary>pg_replication_origin</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_replication_origin</structname> catalog contains
   all replication origins created.  For more on replication origins
   see <xref linkend="replication-origins"/>.
  </para>
____________________________________________________________________________-->
  <para>
<structname>pg_replication_origin</structname>目录包含所有已创建的复制源。更多复制源的信息请见<xref linkend="replication-origins"/>。
  </para>

<!--==========================orignal english content==========================
  <para>
   Unlike most system catalogs, <structname>pg_replication_origin</structname>
   is shared across all databases of a cluster: there is only one copy
   of <structname>pg_replication_origin</structname> per cluster, not one per
   database.
  </para>
____________________________________________________________________________-->
  <para>
   和大部分系统目录不同，<structname>pg_replication_origin</structname>在一个集簇的所有数据库之间共享：每个集簇只有一份<structname>pg_replication_origin</structname>拷贝，而不是每个数据库一份。
  </para>

  <table>

<!--==========================orignal english content==========================
   <title><structname>pg_replication_origin</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_replication_origin</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>roident</structfield></entry>
      <entry><type>Oid</type></entry>
      <entry></entry>
      <entry>A unique, cluster-wide identifier for the replication
      origin. Should never leave the system.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>roident</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>一个集簇范围内唯一的复制源标识符。应该绝不会脱离系统。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>roname</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>The external, user defined, name of a replication
      origin.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>roname</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>外部的由用户定义的复制源名称。</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-rewrite">
<!--==========================orignal english content==========================
  <title><structname>pg_rewrite</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_rewrite</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-rewrite">
   <primary>pg_rewrite</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-rewrite">
   <primary>pg_rewrite</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_rewrite</structname> stores rewrite rules for tables and views.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_rewrite</structname>存储对于表和视图的重写规则。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_rewrite</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_rewrite</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Row identifier</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>rulename</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Rule name</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>rulename</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>规则名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>ev_class</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The table this rule is for</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>ev_class</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>使用该规则的表</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>ev_type</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Event type that the rule is for: 1 = <command>SELECT</command>, 2 =
       <command>UPDATE</command>, 3 = <command>INSERT</command>, 4 =
       <command>DELETE</command>
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>ev_type</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       使用该规则的事件类型：1 = <command>SELECT</command>，2 =
       <command>UPDATE</command>，3 = <command>INSERT</command>，4 =
       <command>DELETE</command>
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>ev_enabled</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Controls in which <xref linkend="guc-session-replication-role"/> modes
       the rule fires.
       <literal>O</literal> = rule fires in <quote>origin</quote> and <quote>local</quote> modes,
       <literal>D</literal> = rule is disabled,
       <literal>R</literal> = rule fires in <quote>replica</quote> mode,
       <literal>A</literal> = rule fires always.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>ev_enabled</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       控制在哪种<xref linkend="guc-session-replication-role"/>模式中触发该规则。
       <literal>O</literal> = 规则在<quote>origin</quote>和<quote>local</quote>模式触发，
       <literal>D</literal> = 规则被禁用，
       <literal>R</literal> = 规则在<quote>replica</quote>模式触发，
       <literal>A</literal> = 规则总是被触发。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>is_instead</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if the rule is an <literal>INSTEAD</literal> rule</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>is_instead</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>为真表示是一个<literal>INSTEAD</literal>规则</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>ev_qual</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>
       Expression tree (in the form of a
       <function>nodeToString()</function> representation) for the
       rule's qualifying condition
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>ev_qual</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>
       规则条件的表达式树（按照<function>nodeToString()</function>的表现形式）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>ev_action</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>
       Query tree (in the form of a
       <function>nodeToString()</function> representation) for the
       rule's action
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>ev_action</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>
       规则动作的查询树（按照<function>nodeToString()</function>的表现形式）
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
<!--==========================orignal english content==========================
   <para>
    <literal>pg_class.relhasrules</literal>
    must be true if a table has any rules in this catalog.
   </para>
____________________________________________________________________________-->
   <para>
    如果一个表在这个目录中有任何规则，<literal>pg_class.relhasrules</literal>必须为真。
   </para>
  </note>

 </sect1>
 
 <sect1 id="catalog-pg-seclabel">
<!--==========================orignal english content==========================
  <title><structname>pg_seclabel</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_seclabel</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-seclabel">
   <primary>pg_seclabel</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-seclabel">
   <primary>pg_seclabel</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_seclabel</structname> stores security
   labels on database objects.  Security labels can be manipulated
   with the <xref linkend="sql-security-label"/> command.  For an easier
   way to view security labels, see <xref linkend="view-pg-seclabels"/>.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_seclabel</structname>存储数据库对象上的安全标签。安全标签可以通过<xref linkend="sql-security-label"/>命令操纵。简单的查看安全标签方法请见<xref linkend="view-pg-seclabels"/>。
  </para>

<!--==========================orignal english content==========================
  <para>
   See also <link linkend="catalog-pg-shseclabel"><structname>pg_shseclabel</structname></link>,
   which performs a similar function for security labels of database objects
   that are shared across a database cluster.
  </para>
____________________________________________________________________________-->
  <para>
   同时请见<link linkend="catalog-pg-shseclabel"><structname>pg_shseclabel</structname></link>，它对集簇共享的数据库对象的安全标签执行相似的功能。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_seclabel</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_seclabel</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>any OID column</entry>
      <entry>The OID of the object this security label pertains to</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>任意OID列</entry>
      <entry>该安全标签依附的对象的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The OID of the system catalog this object appears in</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>该对象所出现的系统目录的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       For a security label on a table column, this is the column number (the
       <structfield>objoid</structfield> and <structfield>classoid</structfield> refer to
       the table itself).  For all other object types, this column is
       zero.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       对于一个在表列上的安全标签，这将是列号（<structfield>objoid</structfield>和<structfield>classoid</structfield>指表本身）。对于所有其他对象类型，本列为0。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>provider</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>The label provider associated with this label.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>provider</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>与该标签相关的标签提供者。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>label</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>The security label applied to this object.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>label</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>应用于该对象的安全标签。</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-sequence">
<!--==========================orignal english content==========================
  <title><structname>pg_sequence</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_sequence</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-sequence">
   <primary>pg_sequence</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-sequence">
   <primary>pg_sequence</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_sequence</structname> contains information about
   sequences.  Some of the information about sequences, such as the name and
   the schema, is in <structname>pg_class</structname>.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_sequence</structname>包含有关序列的信息。一些序列的信息（例如名称和方案）放在<structname>pg_class</structname>中。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_sequence</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_sequence</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>seqrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The OID of the <structname>pg_class</structname> entry for this sequence</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>seqrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>这个序列的<structname>pg_class</structname>项的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>seqtypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Data type of the sequence</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>seqtypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>序列的数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>seqstart</structfield></entry>
      <entry><type>int8</type></entry>
      <entry></entry>
      <entry>Start value of the sequence</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>seqstart</structfield></entry>
      <entry><type>int8</type></entry>
      <entry></entry>
      <entry>序列的起始值</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>seqincrement</structfield></entry>
      <entry><type>int8</type></entry>
      <entry></entry>
      <entry>Increment value of the sequence</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>seqincrement</structfield></entry>
      <entry><type>int8</type></entry>
      <entry></entry>
      <entry>序列的增量值</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>seqmax</structfield></entry>
      <entry><type>int8</type></entry>
      <entry></entry>
      <entry>Maximum value of the sequence</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>seqmax</structfield></entry>
      <entry><type>int8</type></entry>
      <entry></entry>
      <entry>序列的最大值</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>seqmin</structfield></entry>
      <entry><type>int8</type></entry>
      <entry></entry>
      <entry>Minimum value of the sequence</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>seqmin</structfield></entry>
      <entry><type>int8</type></entry>
      <entry></entry>
      <entry>序列的最小值</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>seqcache</structfield></entry>
      <entry><type>int8</type></entry>
      <entry></entry>
      <entry>Cache size of the sequence</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>seqcache</structfield></entry>
      <entry><type>int8</type></entry>
      <entry></entry>
      <entry>序列的缓冲尺寸</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>seqcycle</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Whether the sequence cycles</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>seqcycle</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>序列是否循环</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-shdepend">
<!--==========================orignal english content==========================
  <title><structname>pg_shdepend</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_shdepend</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-shdepend">
   <primary>pg_shdepend</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-shdepend">
   <primary>pg_shdepend</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_shdepend</structname> records the
   dependency relationships between database objects and shared objects,
   such as roles.  This information allows
   <productname>PostgreSQL</productname> to ensure that those objects are
   unreferenced before attempting to delete them.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_shdepend</structname>记录数据库对象和共享对象之间的依赖关系，例如角色。这些信息使得<productname>PostgreSQL</productname>可以确保对象在被删除时没有被其他对象引用。
  </para>

<!--==========================orignal english content==========================
  <para>
   See also <link linkend="catalog-pg-depend"><structname>pg_depend</structname></link>,
   which performs a similar function for dependencies involving objects
   within a single database.
  </para>
____________________________________________________________________________-->
  <para>
   另请参阅<link linkend="catalog-pg-depend"><structname>pg_depend</structname></link>，它对单个数据库中对象之间的依赖提供了相似的功能。  </para>

<!--==========================orignal english content==========================
  <para>
   Unlike most system catalogs, <structname>pg_shdepend</structname>
   is shared across all databases of a cluster: there is only one
   copy of <structname>pg_shdepend</structname> per cluster, not
   one per database.
  </para>
____________________________________________________________________________-->
  <para>
   与大部分其他系统目录不同，<structname>pg_shdepend</structname>在整个集簇的所有数据库之间共享：在每一个集簇中只有一个<structname>pg_shdepend</structname>的拷贝，而不是每个数据库一份。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_shdepend</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_shdepend</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>dbid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <entry>The OID of the database the dependent object is in,
       or zero for a shared object</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>dbid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <entry>依赖者对象所在的数据库OID，如果是一个共享对象则值为0</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>classid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The OID of the system catalog the dependent object is in</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>classid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>依赖者对象所在的系统目录的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>objid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>any OID column</entry>
      <entry>The OID of the specific dependent object</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>objid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>任意OID列</entry>
      <entry>依赖者对象的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       For a table column, this is the column number (the
       <structfield>objid</structfield> and <structfield>classid</structfield> refer to the
       table itself).  For all other object types, this column is zero.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       对于一个表列，这将是列号（<structfield>objid</structfield>和<structfield>classid</structfield>指向表本身）。对于所有其他对象类型，该列值为0。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>refclassid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The OID of the system catalog the referenced object is in
       (must be a shared catalog)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>refclassid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>被引用对象所在的系统目录的OID（必须是一个共享的目录）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>refobjid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>any OID column</entry>
      <entry>The OID of the specific referenced object</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>refobjid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>任意OID列</entry>
      <entry>被引用对象的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>deptype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       A code defining the specific semantics of this dependency relationship; see text
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>deptype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       定义该依赖关系的特定语义的代码，见表后的说明
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   In all cases, a <structname>pg_shdepend</structname> entry indicates that
   the referenced object cannot be dropped without also dropping the dependent
   object.  However, there are several subflavors identified by
   <structfield>deptype</structfield>:

   <variablelist>
    <varlistentry>
     <term><symbol>SHARED_DEPENDENCY_OWNER</symbol> (<literal>o</literal>)</term>
     <listitem>
      <para>
       The referenced object (which must be a role) is the owner of the
       dependent object.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SHARED_DEPENDENCY_ACL</symbol> (<literal>a</literal>)</term>
     <listitem>
      <para>
       The referenced object (which must be a role) is mentioned in the
       ACL (access control list, i.e., privileges list) of the
       dependent object.  (A <symbol>SHARED_DEPENDENCY_ACL</symbol> entry is
       not made for the owner of the object, since the owner will have
       a <symbol>SHARED_DEPENDENCY_OWNER</symbol> entry anyway.)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SHARED_DEPENDENCY_POLICY</symbol> (<literal>r</literal>)</term>
     <listitem>
      <para>
       The referenced object (which must be a role) is mentioned as the
       target of a dependent policy object.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SHARED_DEPENDENCY_PIN</symbol> (<literal>p</literal>)</term>
     <listitem>
      <para>
       There is no dependent object; this type of entry is a signal
       that the system itself depends on the referenced object, and so
       that object must never be deleted.  Entries of this type are
       created only by <command>initdb</command>.  The columns for the
       dependent object contain zeroes.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   Other dependency flavors might be needed in future.  Note in particular
   that the current definition only supports roles as referenced objects.
  </para>
____________________________________________________________________________-->
  <para>
   在所有情况下，一个<structname>pg_shdepend</structname>项表明被引用对象不能在没有删除其依赖对象的情况下被删除。但是，其中也有多种依赖类型，由<structfield>deptype</structfield>标识：

   <variablelist>
    <varlistentry>
     <term><symbol>SHARED_DEPENDENCY_OWNER</symbol> (<literal>o</literal>)</term>
     <listitem>
      <para>
       被引用对象（必须是一个角色）是依赖对象的拥有者。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SHARED_DEPENDENCY_ACL</symbol> (<literal>a</literal>)</term>
     <listitem>
      <para>
       被引用对象（必须是一个角色）在依赖对象的ACL（访问控制列表，即权限列表）中被提到。 (不会为对象的拥有者创建一个<symbol>SHARED_DEPENDENCY_ACL</symbol>项，因为拥有者将会有一个<symbol>SHARED_DEPENDENCY_OWNER</symbol>项。）
      </para>
     </listitem>
    </varlistentry>
    
    <varlistentry>
     <term><symbol>SHARED_DEPENDENCY_POLICY</symbol> (<literal>r</literal>)</term>
     <listitem>
      <para>
       作为一个依赖策略对象的目标被引用的对象（必须是一个角色）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SHARED_DEPENDENCY_PIN</symbol> (<literal>p</literal>)</term>
     <listitem>
      <para>
       没有依赖对象，这种类型的项是一个信号，用来指示系统本身依赖于被引用对象，并且因此该对象必须永远不能被删除。这种类型的项只能被<command>initdb</command>创建。这种项中关于依赖对象的列值都为0。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   未来可能会需要其他的依赖类型。特别要注意的是在当前定义中只支持角色作为被引用对象。
  </para>

 </sect1>

 <sect1 id="catalog-pg-shdescription">
<!--==========================orignal english content==========================
  <title><structname>pg_shdescription</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_shdescription</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-shdescription">
   <primary>pg_shdescription</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-shdescription">
   <primary>pg_shdescription</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_shdescription</structname> stores optional
   descriptions (comments) for shared database objects.  Descriptions can be
   manipulated with the <xref linkend="sql-comment"/> command and viewed with
   <application>psql</application>'s <literal>\d</literal> commands.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_shdescription</structname>存储共享数据库对象的可选描述（注释）。描述可以通过<xref linkend="sql-comment"/>命令操作，并且可以使用<application>psql</application>的<literal>\d</literal>命令来查看。
  </para>

<!--==========================orignal english content==========================
  <para>
   See also <link linkend="catalog-pg-description"><structname>pg_description</structname></link>,
   which performs a similar function for descriptions involving objects
   within a single database.
  </para>
____________________________________________________________________________-->
  <para>
   另请参阅<link linkend="catalog-pg-description"><structname>pg_description</structname></link>，它对单个数据库中对象之间的依赖提供了相似的功能。
  </para>

<!--==========================orignal english content==========================
  <para>
   Unlike most system catalogs, <structname>pg_shdescription</structname>
   is shared across all databases of a cluster: there is only one
   copy of <structname>pg_shdescription</structname> per cluster, not
   one per database.
  </para>
____________________________________________________________________________-->
  <para>
   与大部分其他系统目录不同，<structname>pg_shdescription</structname>在整个集簇的所有数据库之间共享：在每一个集簇中只有一个<structname>pg_shdescription</structname>的拷贝，而不是每个数据库一份。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_shdescription</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_shdescription</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>any OID column</entry>
      <entry>The OID of the object this description pertains to</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>任意OID列</entry>
      <entry>该描述所属的对象的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The OID of the system catalog this object appears in</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>该对象所在系统目录的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>description</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Arbitrary text that serves as the description of this object</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>description</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>作为该对象描述的任意文本</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="catalog-pg-shseclabel">
<!--==========================orignal english content==========================
  <title><structname>pg_shseclabel</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_shseclabel</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-shseclabel">
   <primary>pg_shseclabel</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-shseclabel">
   <primary>pg_shseclabel</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_shseclabel</structname> stores security
   labels on shared database objects.  Security labels can be manipulated
   with the <xref linkend="sql-security-label"/> command.  For an easier
   way to view security labels, see <xref linkend="view-pg-seclabels"/>.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_shseclabel</structname>存储共享数据库对象上的安全标签。安全标签可以通过<xref linkend="sql-security-label"/>命令操纵。更简单的查看安全标签的方式请见<xref linkend="view-pg-seclabels"/>。
  </para>

<!--==========================orignal english content==========================
  <para>
   See also <link linkend="catalog-pg-seclabel"><structname>pg_seclabel</structname></link>,
   which performs a similar function for security labels involving objects
   within a single database.
  </para>
____________________________________________________________________________-->
  <para>
   另请参阅<link linkend="catalog-pg-seclabel"><structname>pg_seclabel</structname></link>，它对单个数据库中对象的安全标签提供了相似的功能。
  </para>

<!--==========================orignal english content==========================
  <para>
   Unlike most system catalogs, <structname>pg_shseclabel</structname>
   is shared across all databases of a cluster: there is only one
   copy of <structname>pg_shseclabel</structname> per cluster, not
   one per database.
  </para>
____________________________________________________________________________-->
  <para>
   与大部分其他系统目录不同，<structname>pg_shseclabel</structname>在整个集簇的所有数据库之间共享：在每一个集簇中只有一个<structname>pg_shseclabel</structname>的拷贝，而不是每个数据库一份。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_shseclabel</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_shseclabel</structname>的列</title>
   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>any OID column</entry>
      <entry>The OID of the object this security label pertains to</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>任意OID列</entry>
      <entry>该安全标签所属对象的OID</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The OID of the system catalog this object appears in</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>对象所属系统目录的OID</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>provider</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>The label provider associated with this label.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>provider</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>与此标签关联的标签提供者</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>label</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>The security label applied to this object.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>label</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>应用到该对象的安全标签</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-statistic">
<!--==========================orignal english content==========================
  <title><structname>pg_statistic</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_statistic</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-statistic">
   <primary>pg_statistic</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-statistic">
   <primary>pg_statistic</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_statistic</structname> stores
   statistical data about the contents of the database.  Entries are
   created by <xref linkend="sql-analyze"/>
   and subsequently used by the query planner.  Note that all the
   statistical data is inherently approximate, even assuming that it
   is up-to-date.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_statistic</structname>存储有关数据库内容的统计数据。其中的项由<xref linkend="sql-analyze"/>创建，查询规划器会使用这些数据来进行查询规划。注意所有的统计数据天然就是近似的，即使它刚刚被更新。
  </para>

<!--==========================orignal english content==========================
  <para>
   Normally there is one entry, with <structfield>stainherit</structfield> =
   <literal>false</literal>, for each table column that has been analyzed.
   If the table has inheritance children, a second entry with
   <structfield>stainherit</structfield> = <literal>true</literal> is also created.  This row
   represents the column's statistics over the inheritance tree, i.e.,
   statistics for the data you'd see with
   <literal>SELECT <replaceable>column</replaceable> FROM <replaceable>table</replaceable>*</literal>,
   whereas the <structfield>stainherit</structfield> = <literal>false</literal> row represents
   the results of
   <literal>SELECT <replaceable>column</replaceable> FROM ONLY <replaceable>table</replaceable></literal>.
  </para>
____________________________________________________________________________-->
  <para>
   通常对于数据表中一个已经被 ANALYZE 过的列，在本目录中会存在一个<structfield>stainherit</structfield> = <literal>false</literal>的项。如果该列所在的表具有后代（即有其他表继承该表），对于该列还会创建第二个<structfield>stainherit</structfield> = <literal>true</literal>的项。<structfield>stainherit</structfield> = <literal>true</literal>的项表示列在整个继承树上的统计数据，即通过<literal>SELECT <replaceable>column</replaceable> FROM <replaceable>table</replaceable>*</literal>看到的数据的统计，而<structfield>stainherit</structfield> = <literal>false</literal>的项表示对<literal>SELECT <replaceable>column</replaceable> FROM ONLY <replaceable>table</replaceable></literal>的结果的统计。
  </para>

<!--==========================orignal english content==========================
  <para>
   <structname>pg_statistic</structname> also stores statistical data about
   the values of index expressions.  These are described as if they were
   actual data columns; in particular, <structfield>starelid</structfield>
   references the index.  No entry is made for an ordinary non-expression
   index column, however, since it would be redundant with the entry
   for the underlying table column.  Currently, entries for index expressions
   always have <structfield>stainherit</structfield> = <literal>false</literal>.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_statistic</structname>也存储关于索引表达式值的统计数据，就好像它们是真正的数据列，但在这种情况中<structfield>starelid</structfield>指索引。对一个普通非表达式索引列不会创建项，因为它将是底层表列的项的冗余。当前，索引表达式的项都具有<structfield>stainherit</structfield> = <literal>false</literal>。
  </para>

<!--==========================orignal english content==========================
  <para>
   Since different kinds of statistics might be appropriate for different
   kinds of data, <structname>pg_statistic</structname> is designed not
   to assume very much about what sort of statistics it stores.  Only
   extremely general statistics (such as nullness) are given dedicated
   columns in <structname>pg_statistic</structname>.  Everything else
   is stored in <quote>slots</quote>, which are groups of associated columns
   whose content is identified by a code number in one of the slot's columns.
   For more information see
   <filename>src/include/catalog/pg_statistic.h</filename>.
  </para>
____________________________________________________________________________-->
  <para>
   因为不同类型的统计信息适用于不同类型的数据， <structname>pg_statistic</structname> 被设计成不太在意自己存储的是什么类型的统计。 只有极为常用的统计信息（比如NULL的含量）才在<structname>pg_statistic</structname>里给予专用的字段。 其它所有东西都存储在<quote>槽位</quote>中，而槽位是一组相关的列， 它们的内容用槽位中的一个列里的代码表示。 更详细的信息请参阅 <filename>src/include/catalog/pg_statistic.h</filename>。
  </para>

<!--==========================orignal english content==========================
  <para>
   <structname>pg_statistic</structname> should not be readable by the
   public, since even statistical information about a table's contents
   might be considered sensitive.  (Example: minimum and maximum values
   of a salary column might be quite interesting.)
   <link linkend="view-pg-stats"><structname>pg_stats</structname></link>
   is a publicly readable view on
   <structname>pg_statistic</structname> that only exposes information
   about those tables that are readable by the current user.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_statistic</structname>不应该是公共可读的，因为即使是一个表内容的统计性信息也可能被认为是敏感的（例子：一个薪水列的最大和最小值可能是非常有趣的）。<link linkend="view-pg-stats"><structname>pg_stats</structname></link>是<structname>pg_statistic</structname>上的一个公共可读的视图，它只会显示出当前用户可读的表的信息。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_statistic</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_statistic</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>starelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The table or index that the described column belongs to</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>starelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>被描述列所属的表或索引</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>staattnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>The number of the described column</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>staattnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>被描述列的编号</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>stainherit</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>If true, the stats include inheritance child columns, not just the
       values in the specified relation</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>stainherit</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>如果为真，统计包含了继承后代的列而不仅仅是指定关系的列</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>stanullfrac</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>The fraction of the column's entries that are null</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>stanullfrac</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>列的项为空的比例</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>stawidth</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>The average stored width, in bytes, of nonnull entries</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>stawidth</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>非空项的平均存储宽度，以字节计</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>stadistinct</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>The number of distinct nonnull data values in the column.
      A value greater than zero is the actual number of distinct values.
      A value less than zero is the negative of a multiplier for the number
      of rows in the table; for example, a column in which about 80% of the
      values are nonnull and each nonnull value appears about twice on
      average could be represented by <structfield>stadistinct</structfield> = -0.4.
      A zero value means the number of distinct values is unknown.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>stadistinct</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>列中非空唯一值的数目。一个大于零的值是唯一值的真正数目。一个小于零的值是表中行数的乘数的负值；例如，对于一个 80% 的值为非空且每个非空值平均出现两次的列，可以表示为<structfield>stadistinct</structfield> = -0.4。一个0值表示唯一值的数目未知。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>stakind<replaceable>N</replaceable></structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       A code number indicating the kind of statistics stored in the
       <replaceable>N</replaceable>th <quote>slot</quote> of the
       <structname>pg_statistic</structname> row.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>stakind<replaceable>N</replaceable></structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       一个代码，它表示存储在该<structname>pg_statistic</structname>行中第<replaceable>N</replaceable>个<quote>槽位</quote>的统计类型。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>staop<replaceable>N</replaceable></structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>
       An operator used to derive the statistics stored in the
       <replaceable>N</replaceable>th <quote>slot</quote>.  For example, a
       histogram slot would show the <literal>&lt;</literal> operator
       that defines the sort order of the data.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>staop<replaceable>N</replaceable></structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>
       一个用于生成这些存储在第<replaceable>N</replaceable>个<quote>槽位</quote>的统计信息的操作符。 比如，一个柱面图槽位会用<literal>&lt;</literal>操作符，该操作符定义了该数据的排序顺序。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>stacoll<replaceable>N</replaceable></structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-collation"><structname>pg_collation</structname></link>.oid</literal></entry>
      <entry>
       The collation used to derive the statistics stored in the
       <replaceable>N</replaceable>th <quote>slot</quote>.  For example, a
       histogram slot for a collatable column would show the collation that
       defines the sort order of the data.  Zero for noncollatable data.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>stacoll<replaceable>N</replaceable></structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-collation"><structname>pg_collation</structname></link>.oid</literal></entry>
      <entry>
       排序规则用于导出存储在第<replaceable>N</replaceable>个<quote>槽</quote>中的统计信息。例如，可排序列的直方图槽将显示定义数据排序顺序的排序规则。对于不可整理数据，为零。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>stanumbers<replaceable>N</replaceable></structfield></entry>
      <entry><type>float4[]</type></entry>
      <entry></entry>
      <entry>
       Numerical statistics of the appropriate kind for the
       <replaceable>N</replaceable>th <quote>slot</quote>, or null if the slot
       kind does not involve numerical values
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>stanumbers<replaceable>N</replaceable></structfield></entry>
      <entry><type>float4[]</type></entry>
      <entry></entry>
      <entry>
       第<replaceable>N</replaceable>个<quote>槽位</quote>的类型的数值类型统计， 如果该槽位不涉及数值类型则为NULL
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>stavalues<replaceable>N</replaceable></structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>
       Column data values of the appropriate kind for the
       <replaceable>N</replaceable>th <quote>slot</quote>, or null if the slot
       kind does not store any data values.  Each array's element
       values are actually of the specific column's data type, or a related
       type such as an array's element type, so there is no way to define
       these columns' type more specifically than <type>anyarray</type>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>stavalues<replaceable>N</replaceable></structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>
        第<replaceable>N</replaceable>个<quote>槽位</quote>的类型的列值，如果该槽位类型不存储任何数据值则为 NULL。 每个数组的元素值实际上都是指定列的数据类型或者是一个相关类型（如数组元素类型）， 因此，除了把这些列的类型定义成<type>anyarray</type>之外别无他法。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="catalog-pg-statistic-ext">
<!--==========================orignal english content==========================
  <title><structname>pg_statistic_ext</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_statistic_ext</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-statistic-ext">
   <primary>pg_statistic_ext</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-statistic-ext">
   <primary>pg_statistic_ext</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_statistic_ext</structname>
   holds definitions of extended planner statistics.
   Each row in this catalog corresponds to a <firstterm>statistics object</firstterm>
   created with <xref linkend="sql-createstatistics"/>.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_statistic_ext</structname>包含了扩展的规划器统计信息的定义。这个目录中的每一行对应于一个用<xref linkend="sql-createstatistics"/>创建的<firstterm>统计信息对象</firstterm>。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_statistic_ext</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_statistic_ext</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>stxrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>Table containing the columns described by this object</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>stxrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>包含这个对象所描述的列的表</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>stxname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the statistics object</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>stxname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>统计信息对象的名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>stxnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       The OID of the namespace that contains this statistics object
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>stxnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       包含这个统计信息对象的名字空间的OID
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>stxowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Owner of the statistics object</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>stxowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>统计信息对象的拥有者</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>stxkeys</structfield></entry>
      <entry><type>int2vector</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>
       An array of attribute numbers, indicating which table columns are
       covered by this statistics object;
       for example a value of <literal>1 3</literal> would
       mean that the first and the third table columns are covered
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>stxkeys</structfield></entry>
      <entry><type>int2vector</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>
       一个属性编号的数组，表示哪些表列被这个统计信息对象覆盖。例如值<literal>1 3</literal>表示第一个和第三个表列被覆盖
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>stxkind</structfield></entry>
      <entry><type>char[]</type></entry>
      <entry></entry>
      <entry>
        An array containing codes for the enabled statistic kinds;
        valid values are:
        <literal>d</literal> for n-distinct statistics,
        <literal>f</literal> for functional dependency statistics, and
        <literal>m</literal> for most common values (MCV) list statistics
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>stxkind</structfield></entry>
      <entry><type>char[]</type></entry>
      <entry></entry>
      <entry>
        包含被启用统计类型代码的数组，可用的值有：
        <literal>d</literal>表示n-distinct统计信息，
        <literal>f</literal>表示函数依赖统计信息和
        <literal>m</literal>表示最常见值（MCV）列表的统计信息
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_statistic_ext</structname>条目在<command>CREATE STATISTICS</command>期间完全填充，但是随后不计算实际的统计值。后来<command>ANALYZE</command>命令计算所需的值，并在<link linkend="catalog-pg-statistic-ext-data"><structname>pg_statistic_ext_data</structname></link>目录中填充条目。
  </para>
 </sect1>

 <sect1 id="catalog-pg-statistic-ext-data">
  <title><structname>pg_statistic_ext_data</structname></title>

  <indexterm zone="catalog-pg-statistic-ext">
   <primary>pg_statistic_ext_data</primary>
  </indexterm>

  <para>
   目录<structname>pg_statistic_ext_data</structname>保存在<structname>pg_statistic_ext</structname>中定义的扩展规划器统计信息的数据。该目录的每一行对应用<xref linkend="sql-createstatistics"/>创建的一个<firstterm>统计信息对象</firstterm>。
  </para>

  <para>
   就像<structname>pg_statistic</structname>，<structname>pg_statistic_ext_data</structname>不应该被公众读取到，因为其内容可能被视为敏感内容。（例如：列中值的最常见组合可能非常令人关注。）<link linkend="view-pg-stats-ext"><structname>pg_stats_ext</structname></link>是<structname>pg_statistic_ext_data</structname>上的公共可读视图（与<structname>pg_statistic_ext</structname>连接后），它仅暴露有关当前用户可读的表和列的信息。
  </para>

  <table>
   <title><structname>pg_statistic_ext_data</structname> Columns</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry><structfield>stxoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-statistic-ext"><structname>pg_statistic_ext</structname></link>.oid</literal></entry>
      <entry>包含此数据定义的扩展统计信息对象</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>stxdndistinct</structfield></entry>
      <entry><type>pg_ndistinct</type></entry>
      <entry></entry>
      <entry>
       N-distinct counts, serialized as <structname>pg_ndistinct</structname> type
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>stxdndistinct</structfield></entry>
      <entry><type>pg_ndistinct</type></entry>
      <entry></entry>
      <entry>
       N-distinct计数，序列化为<structname>pg_ndistinct</structname>类型
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>stxddependencies</structfield></entry>
      <entry><type>pg_dependencies</type></entry>
      <entry></entry>
      <entry>
       Functional dependency statistics, serialized
       as <structname>pg_dependencies</structname> type
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>stxddependencies</structfield></entry>
      <entry><type>pg_dependencies</type></entry>
      <entry></entry>
      <entry>
       函数依赖统计信息，序列化为<structname>pg_dependencies</structname>类型
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>stxdmcv</structfield></entry>
      <entry><type>pg_mcv_list</type></entry>
      <entry></entry>
      <entry>
       MCV (most-common values) list statistics, serialized as
       <structname>pg_mcv_list</structname> type
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>stxdmcv</structfield></entry>
      <entry><type>pg_mcv_list</type></entry>
      <entry></entry>
      <entry>
       MCV（最频值）列表统计信息，序列化为<structname>pg_mcv_list</structname>类型
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="catalog-pg-subscription">
<!--==========================orignal english content==========================
  <title><structname>pg_subscription</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_subscription</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-subscription">
   <primary>pg_subscription</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-subscription">
   <primary>pg_subscription</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_subscription</structname> contains all existing
   logical replication subscriptions.  For more information about logical
   replication see <xref linkend="logical-replication"/>.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_subscription</structname>包含所有现有的逻辑复制订阅。更多有关逻辑复制的信息请见<xref linkend="logical-replication"/>。
  </para>

<!--==========================orignal english content==========================
  <para>
   Unlike most system catalogs, <structname>pg_subscription</structname> is
   shared across all databases of a cluster: there is only one copy
   of <structname>pg_subscription</structname> per cluster, not one per
   database.
  </para>
____________________________________________________________________________-->
  <para>
   和大部分系统目录不同，<structname>pg_subscription</structname>在集簇的所有数据库之间共享：每个集簇只有一份<structname>pg_subscription</structname>拷贝，而不是每个数据库一份。
  </para>

<!--==========================orignal english content==========================
  <para>
   Access to the column <structfield>subconninfo</structfield> is revoked from
   normal users, because it could contain plain-text passwords.
  </para>
____________________________________________________________________________-->
  <para>
   对列<structfield>subconninfo</structfield>的访问被从普通用户那里收回，因为该列可能含有明文口令。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_subscription</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_subscription</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Row identifier</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>subdbid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <entry>OID of the database which the subscription resides in</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>subdbid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <entry>订阅所在的数据库的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>subname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the subscription</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>subname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>订阅的名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>subowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Owner of the subscription</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>subowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>订阅的拥有者</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>subenabled</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>If true, the subscription is enabled and should be replicating.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>subenabled</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>如果为真，订阅被启用并且应该被复制。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>subsynccommit</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       Contains the value of the <varname>synchronous_commit</varname>
       setting for the subscription workers.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>subsynccommit</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       包含订阅工作者的<varname>synchronous_commit</varname>设置的值。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>subconninfo</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Connection string to the upstream database</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>subconninfo</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>到上游数据库的连接字符串</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>subslotname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the replication slot in the upstream database. Also used
       for local replication origin name.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>subslotname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>上游数据库中的复制槽的名称。也被用于本地复制源名称。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>subpublications</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>Array of subscribed publication names. These reference the
       publications on the publisher server. For more on publications
       see <xref linkend="logical-replication-publication"/>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>subpublications</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>被订阅的publication名称的数组。这些引用的是发布者服务器上的publication。更多有关publication的内容请见<xref linkend="logical-replication-publication"/>。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-subscription-rel">
<!--==========================orignal english content==========================
  <title><structname>pg_subscription_rel</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_subscription_rel</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-subscription-rel">
   <primary>pg_subscription_rel</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-subscription-rel">
   <primary>pg_subscription_rel</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_subscription_rel</structname> contains the
   state for each replicated relation in each subscription.  This is a
   many-to-many mapping.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_subscription_rel</structname>包含每个订阅中每个被复制关系的状态。这是一种多对多映射。
  </para>

<!--==========================orignal english content==========================
  <para>
   This catalog only contains tables known to the subscription after running
   either <command>CREATE SUBSCRIPTION</command> or
   <command>ALTER SUBSCRIPTION ... REFRESH PUBLICATION</command>.
  </para>
____________________________________________________________________________-->
  <para>
   这个目录仅包含运行<command>CREATE SUBSCRIPTION</command>或<command>ALTER SUBSCRIPTION ... REFRESH PUBLICATION</command>以后对订阅已知的表。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_subscription_rel</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_subscription_rel</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>srsubid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-subscription"><structname>pg_subscription</structname></link>.oid</literal></entry>
      <entry>Reference to subscription</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>srsubid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-subscription"><structname>pg_subscription</structname></link>.oid</literal></entry>
      <entry>对订阅的引用</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>srrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>Reference to relation</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>srrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>对关系的引用</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>srsubstate</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       State code:
       <literal>i</literal> = initialize,
       <literal>d</literal> = data is being copied,
       <literal>s</literal> = synchronized,
       <literal>r</literal> = ready (normal replication)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>srsubstate</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       状态代码：
       <literal>i</literal> = 初始化，
       <literal>d</literal> = 数据正在被拷贝，
       <literal>s</literal> = 已同步，
       <literal>r</literal> = 准备好（普通复制）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>srsublsn</structfield></entry>
      <entry><type>pg_lsn</type></entry>
      <entry></entry>
      <entry>
       End LSN for <literal>s</literal> and <literal>r</literal> states.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>srsublsn</structfield></entry>
      <entry><type>pg_lsn</type></entry>
      <entry></entry>
      <entry>
       <literal>s</literal>和<literal>r</literal>状态的结束LSN。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-tablespace">
<!--==========================orignal english content==========================
  <title><structname>pg_tablespace</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_tablespace</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-tablespace">
   <primary>pg_tablespace</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-tablespace">
   <primary>pg_tablespace</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_tablespace</structname> stores information
   about the available tablespaces.  Tables can be placed in particular
   tablespaces to aid administration of disk layout.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_tablespace</structname>存储关于可用表空间的信息。表可以被放置在特定表空间中以实现磁盘布局的管理。
  </para>

<!--==========================orignal english content==========================
  <para>
   Unlike most system catalogs, <structname>pg_tablespace</structname>
   is shared across all databases of a cluster: there is only one
   copy of <structname>pg_tablespace</structname> per cluster, not
   one per database.
  </para>
____________________________________________________________________________-->
  <para>
   与大部分其他系统目录不同，<structname>pg_tablespace</structname>在整个集簇的所有数据库之间共享：在每一个集簇中只有一个<structname>pg_tablespace</structname>的拷贝，而不是每个数据库一份。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_tablespace</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_tablespace</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Row identifier</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>spcname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Tablespace name</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>spcname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>表空间名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>spcowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Owner of the tablespace, usually the user who created it</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>spcowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>表空间的拥有者，通常是创建它的用户</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>spcacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       Access privileges; see <xref linkend="ddl-priv"/> for details
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>spcacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       访问权限，详见<xref linkend="ddl-priv"/>
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>spcoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       Tablespace-level options, as <quote>keyword=value</quote> strings
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>spcoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       表空间级别的选项，形如<quote>keyword=value</quote>的字符串
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>
 
 <sect1 id="catalog-pg-transform">
<!--==========================orignal english content==========================
  <title><structname>pg_transform</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_transform</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-transform">
   <primary>pg_transform</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-transform">
   <primary>pg_transform</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_transform</structname> stores information about
   transforms, which are a mechanism to adapt data types to procedural
   languages.  See <xref linkend="sql-createtransform"/> for more information.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_transform</structname>存储有关转换的信息，转换是
   一种让数据类型适应过程语言的机制。详见<xref linkend="sql-createtransform"/>。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_transform</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_transform</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>trftype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>OID of the data type this transform is for</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>trftype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>这个转换所针对的数据类型的 OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>trflang</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-language"><structname>pg_language</structname></link>.oid</literal></entry>
      <entry>OID of the language this transform is for</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>trflang</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-language"><structname>pg_language</structname></link>.oid</literal></entry>
      <entry>这个转换所针对的语言的 OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>trffromsql</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       The OID of the function to use when converting the data type for input
       to the procedural language (e.g., function parameters).  Zero is stored
       if this operation is not supported.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>trffromsql</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       一个函数的 OID，该函数用来将数据类型转换为过程语言的输入（例如
       函数参数）。如果不支持这种操作，这里存储零。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>trftosql</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       The OID of the function to use when converting output from the
       procedural language (e.g., return values) to the data type.  Zero is
       stored if this operation is not supported.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>trftosql</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       一个函数的 OID，该函数被用来转换过程语言的输出（例如返回值）为
       该数据类型。如果不支持这种操作，这里存储零。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-trigger">
<!--==========================orignal english content==========================
  <title><structname>pg_trigger</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_trigger</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-trigger">
   <primary>pg_trigger</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-trigger">
   <primary>pg_trigger</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_trigger</structname> stores triggers on tables
   and views.
   See <xref linkend="sql-createtrigger"/>
   for more information.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_trigger</structname>存储表和视图上的触发器。详见<xref linkend="sql-createtrigger"/>。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_trigger</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_trigger</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Row identifier</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tgrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The table this trigger is on</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tgrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>触发器所在的表</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tgname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Trigger name (must be unique among triggers of same table)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tgname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>触发器名（在同一个表的触发器中必须唯一）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tgfoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>The function to be called</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tgfoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>要被触发器调用的函数</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tgtype</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Bit mask identifying trigger firing conditions</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tgtype</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>触发器触发条件的位掩码</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tgenabled</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Controls in which <xref linkend="guc-session-replication-role"/> modes
       the trigger fires.
       <literal>O</literal> = trigger fires in <quote>origin</quote> and <quote>local</quote> modes,
       <literal>D</literal> = trigger is disabled,
       <literal>R</literal> = trigger fires in <quote>replica</quote> mode,
       <literal>A</literal> = trigger fires always.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tgenabled</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       控制触发器在<xref linkend="guc-session-replication-role"/>模式中的触发。
       <literal>O</literal> = 触发器在<quote>origin</quote>和<quote>local</quote>模式触发，
       <literal>D</literal> = 触发器被禁用，
       <literal>R</literal> = 触发器在<quote>replica</quote>模式触发，
       <literal>A</literal> = 触发器总是触发。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tgisinternal</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if trigger is internally generated (usually, to enforce
       the constraint identified by <structfield>tgconstraint</structfield>)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tgisinternal</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>为真表示触发器是内部生成的（通常是为了强制由<structfield>tgconstraint</structfield>指定的约束）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tgconstrrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The table referenced by a referential integrity constraint</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tgconstrrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>被一个引用完整性约束引用的表</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tgconstrindid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The index supporting a unique, primary key, referential integrity,
       or exclusion constraint</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tgconstrindid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>支持一个唯一、主键、引用完整性约束或者排除约束的索引</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tgconstraint</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-constraint"><structname>pg_constraint</structname></link>.oid</literal></entry>
      <entry>The <structname>pg_constraint</structname> entry associated with the trigger, if any</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tgconstraint</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-constraint"><structname>pg_constraint</structname></link>.oid</literal></entry>
      <entry>可能存在的与触发器相关的<structname>pg_constraint</structname>项</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tgdeferrable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if constraint trigger is deferrable</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tgdeferrable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>如果约束触发器可推迟则为真</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tginitdeferred</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if constraint trigger is initially deferred</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tginitdeferred</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>如果约束触发器初始可推迟则为真</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tgnargs</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Number of argument strings passed to trigger function</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tgnargs</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>传递给触发器函数的参数字符串个数</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tgattr</structfield></entry>
      <entry><type>int2vector</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>Column numbers, if trigger is column-specific; otherwise an
       empty array</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tgattr</structfield></entry>
      <entry><type>int2vector</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>如果触发器是列限定的，这里存放列号；否则这是一个空数组</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tgargs</structfield></entry>
      <entry><type>bytea</type></entry>
      <entry></entry>
      <entry>Argument strings to pass to trigger, each NULL-terminated</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tgargs</structfield></entry>
      <entry><type>bytea</type></entry>
      <entry></entry>
      <entry>传递给触发器的参数字符串，每一个都以NULL结尾</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tgqual</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>Expression tree (in <function>nodeToString()</function>
       representation) for the trigger's <literal>WHEN</literal> condition, or null
       if none</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tgqual</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>触发器<literal>WHEN</literal>条件的表达式树（以<function>nodeToString()</function>的表现形式），如果没有则为空</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tgoldtable</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry><literal>REFERENCING</literal> clause name for <literal>OLD TABLE</literal>,
       or null if none</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tgoldtable</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry><literal>OLD TABLE</literal>的<literal>REFERENCING</literal>子句名称，如果没有则为空</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tgnewtable</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry><literal>REFERENCING</literal> clause name for <literal>NEW TABLE</literal>,
       or null if none</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tgnewtable</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry><literal>NEW TABLE</literal>的<literal>REFERENCING</literal>子句名称，如果没有则为空</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   Currently, column-specific triggering is supported only for
   <literal>UPDATE</literal> events, and so <structfield>tgattr</structfield> is relevant
   only for that event type.  <structfield>tgtype</structfield> might
   contain bits for other event types as well, but those are presumed
   to be table-wide regardless of what is in <structfield>tgattr</structfield>.
  </para>
____________________________________________________________________________-->
  <para>
   当前，列限定触发器只被<literal>UPDATE</literal>事件支持，因此<structfield>tgattr</structfield>只用于这种事件类型。<structfield>tgtype</structfield>页可以包含用于其他事件类型的位，但其他事件类型是表范围的触发器且会忽略<structfield>tgattr</structfield>。
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    When <structfield>tgconstraint</structfield> is nonzero,
    <structfield>tgconstrrelid</structfield>, <structfield>tgconstrindid</structfield>,
    <structfield>tgdeferrable</structfield>, and <structfield>tginitdeferred</structfield> are
    largely redundant with the referenced <structname>pg_constraint</structname> entry.
    However, it is possible for a non-deferrable trigger to be associated
    with a deferrable constraint: foreign key constraints can have some
    deferrable and some non-deferrable triggers.
   </para>
____________________________________________________________________________-->
   <para>
    当<structfield>tgconstraint</structfield>非零时，<structfield>tgconstrrelid</structfield>、<structfield>tgconstrindid</structfield>、<structfield>tgdeferrable</structfield>和<structfield>tginitdeferred</structfield>与被引用的<structname>pg_constraint</structname>项有很大的冗余。但是，存在将一个不可延迟触发器关联到一个可延迟约束的可能性：外键约束可以有一些可延迟和一些不可延迟触发器。
   </para>
  </note>

  <note>
<!--==========================orignal english content==========================
   <para>
    <literal>pg_class.relhastriggers</literal>
    must be true if a relation has any triggers in this catalog.
   </para>
____________________________________________________________________________-->
   <para>
    如果一个关系在本目录中拥有任何触发器，其<literal>pg_class.relhastriggers</literal>必须为真。
   </para>
  </note>

 </sect1>


 <sect1 id="catalog-pg-ts-config">
<!--==========================orignal english content==========================
  <title><structname>pg_ts_config</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_ts_config</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-ts-config">
   <primary>pg_ts_config</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-ts-config">
   <primary>pg_ts_config</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_ts_config</structname> catalog contains entries
   representing text search configurations.  A configuration specifies
   a particular text search parser and a list of dictionaries to use
   for each of the parser's output token types.  The parser is shown
   in the <structname>pg_ts_config</structname> entry, but the
   token-to-dictionary mapping is defined by subsidiary entries in <link
   linkend="catalog-pg-ts-config-map"><structname>pg_ts_config_map</structname></link>.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_ts_config</structname>目录包含表示文本搜索配置的选项。一个配置指定了一个特定的文本搜索分析器和一个用于分析器输出记号的字典列表。分析器由<structname>pg_ts_config</structname>项展现，而记号到字典的映射则由<link
   linkend="catalog-pg-ts-config-map"><structname>pg_ts_config_map</structname></link>中的辅助项定义。
  </para>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname>'s text search features are
   described at length in <xref linkend="textsearch"/>.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>的文本搜索特性在<xref linkend="textsearch"/>中有更详尽的描述。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_ts_config</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_ts_config</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Row identifier</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>cfgname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Text search configuration name</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>cfgname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>文本搜索配置名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>cfgnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       The OID of the namespace that contains this configuration
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>cfgnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       包含该配置的名字空间的OID
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>cfgowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Owner of the configuration</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>cfgowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>配置的拥有者</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>cfgparser</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-ts-parser"><structname>pg_ts_parser</structname></link>.oid</literal></entry>
      <entry>The OID of the text search parser for this configuration</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>cfgparser</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-ts-parser"><structname>pg_ts_parser</structname></link>.oid</literal></entry>
      <entry>该配置的文本搜索分析器的OID</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-ts-config-map">
<!--==========================orignal english content==========================
  <title><structname>pg_ts_config_map</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_ts_config_map</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-ts-config-map">
   <primary>pg_ts_config_map</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-ts-config-map">
   <primary>pg_ts_config_map</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_ts_config_map</structname> catalog contains entries
   showing which text search dictionaries should be consulted, and in
   what order, for each output token type of each text search configuration's
   parser.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_ts_config_map</structname>目录包含的项展示了对于每一个文本搜索配置的每一种输出记号类型，有哪些文本搜索字典可供查询以及以何种顺序。
  </para>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname>'s text search features are
   described at length in <xref linkend="textsearch"/>.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>的文本搜索特性在<xref linkend="textsearch"/>中有更详尽的描述。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_ts_config_map</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_ts_config_map</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>mapcfg</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-ts-config"><structname>pg_ts_config</structname></link>.oid</literal></entry>
      <entry>The OID of the <structname>pg_ts_config</structname> entry owning this map entry</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>mapcfg</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-ts-config"><structname>pg_ts_config</structname></link>.oid</literal></entry>
      <entry>拥有该映射项的<structname>pg_ts_config</structname>项的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>maptokentype</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>A token type emitted by the configuration's parser</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>maptokentype</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>一种由配置的分析器送出的记号类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>mapseqno</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>Order in which to consult this entry (lower
       <structfield>mapseqno</structfield>s first)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>mapseqno</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>查询该项的顺序（<structfield>mapseqno</structfield>值小的优先）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>mapdict</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-ts-dict"><structname>pg_ts_dict</structname></link>.oid</literal></entry>
      <entry>The OID of the text search dictionary to consult</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>mapdict</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-ts-dict"><structname>pg_ts_dict</structname></link>.oid</literal></entry>
      <entry>查询的文本搜索字典的OID</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-ts-dict">
<!--==========================orignal english content==========================
  <title><structname>pg_ts_dict</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_ts_dict</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-ts-dict">
   <primary>pg_ts_dict</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-ts-dict">
   <primary>pg_ts_dict</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_ts_dict</structname> catalog contains entries
   defining text search dictionaries.  A dictionary depends on a text
   search template, which specifies all the implementation functions
   needed; the dictionary itself provides values for the user-settable
   parameters supported by the template.  This division of labor allows
   dictionaries to be created by unprivileged users.  The parameters
   are specified by a text string <structfield>dictinitoption</structfield>,
   whose format and meaning vary depending on the template.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_ts_dict</structname>目录包含定义文本搜索字典的项。一个字典依赖于一个文本搜索模板，它指定了所有需要的函数实现，字典本身则为模板支持的用户可设置参数提供值。这种分工允许无权限的用户创建字典。参数由一个文本串<structfield>dictinitoption</structfield>定义，其格式和意义随着模板而变化。
  </para>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname>'s text search features are
   described at length in <xref linkend="textsearch"/>.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>的文本搜索特性在<xref linkend="textsearch"/>中有更详尽的描述。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_ts_dict</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_ts_dict</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Row identifier</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>dictname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Text search dictionary name</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>dictname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>文本搜索字典名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>dictnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       The OID of the namespace that contains this dictionary
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>dictnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       包含该字典的名字空间OID
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>dictowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Owner of the dictionary</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>dictowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>字典的拥有者</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>dicttemplate</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-ts-template"><structname>pg_ts_template</structname></link>.oid</literal></entry>
      <entry>The OID of the text search template for this dictionary</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>dicttemplate</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-ts-template"><structname>pg_ts_template</structname></link>.oid</literal></entry>
      <entry>该字典的文本搜索模板的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>dictinitoption</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Initialization option string for the template</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>dictinitoption</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>模板的初始化选项串</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-ts-parser">
<!--==========================orignal english content==========================
  <title><structname>pg_ts_parser</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_ts_parser</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-ts-parser">
   <primary>pg_ts_parser</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-ts-parser">
   <primary>pg_ts_parser</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_ts_parser</structname> catalog contains entries
   defining text search parsers.  A parser is responsible for splitting
   input text into lexemes and assigning a token type to each lexeme.
   Since a parser must be implemented by C-language-level functions,
   creation of new parsers is restricted to database superusers.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_ts_parser</structname>目录包含定义文本搜索分析器的项。一个分析器负责将输入文本分割成词位并为每一个词位分配一个记号类型。由于一个分析器必须用C语言级别的函数实现，创建新分析器的工作只限于数据库的超级用户。
  </para>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname>'s text search features are
   described at length in <xref linkend="textsearch"/>.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>的文本搜索特性在<xref linkend="textsearch"/>中有更详尽的描述。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_ts_parser</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_ts_parser</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Row identifier</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>prsname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Text search parser name</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>prsname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>文本搜索分析器的名字</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>prsnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       The OID of the namespace that contains this parser
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>prsnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       包含此分析器的名字空间的OID
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>prsstart</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID of the parser's startup function</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>prsstart</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>分析器启动函数的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>prstoken</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID of the parser's next-token function</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>prstoken</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>分析器的下一记号函数的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>prsend</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID of the parser's shutdown function</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>prsend</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>分析器的关闭函数的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>prsheadline</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID of the parser's headline function</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>prsheadline</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>分析器的大标题函数的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>prslextype</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID of the parser's lextype function</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>prslextype</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>分析器的词汇类型函数的OID</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-ts-template">
<!--==========================orignal english content==========================
  <title><structname>pg_ts_template</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_ts_template</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-ts-template">
   <primary>pg_ts_template</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-ts-template">
   <primary>pg_ts_template</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_ts_template</structname> catalog contains entries
   defining text search templates.  A template is the implementation
   skeleton for a class of text search dictionaries.
   Since a template must be implemented by C-language-level functions,
   creation of new templates is restricted to database superusers.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_ts_template</structname>目录包含定义文本搜索模板的项。一个模板是一类文本搜索字典的实现骨架。由于一个模板必须用C语言级别的函数实现，新模板的创建只限于数据库超级用户。
  </para>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname>'s text search features are
   described at length in <xref linkend="textsearch"/>.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>的文本搜索特性在<xref linkend="textsearch"/>中有更详尽的描述。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_ts_template</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_ts_template</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Row identifier</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tmplname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Text search template name</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tmplname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>文本搜索模板的名字</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tmplnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       The OID of the namespace that contains this template
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tmplnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       包含此模板的名字空间的OID
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tmplinit</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID of the template's initialization function</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tmplinit</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>模板的初始化函数的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tmpllexize</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID of the template's lexize function</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tmpllexize</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>模板的词汇化函数的OID</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-type">
<!--==========================orignal english content==========================
  <title><structname>pg_type</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_type</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-type">
   <primary>pg_type</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-type">
   <primary>pg_type</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_type</structname> stores information about data
   types.  Base types and enum types (scalar types) are created with
   <xref linkend="sql-createtype"/>, and
   domains with
   <xref linkend="sql-createdomain"/>.
   A composite type is automatically created for each table in the database, to
   represent the row structure of the table.  It is also possible to create
   composite types with <command>CREATE TYPE AS</command>.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_type</structname>存储有关数据类型的信息。基类和枚举类型（标度类型）使用<xref linkend="sql-createtype"/>创建，而域使用<xref linkend="sql-createdomain"/>创建。数据库中的每一个表都会有一个自动创建的组合类型，用于表示表的行结构。也可以使用<command>CREATE TYPE AS</command>创建组合类型。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_type</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_type</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Row identifier</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>typname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Data type name</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>typname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>数据类型的名字</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>typnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       The OID of the namespace that contains this type
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>typnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       包含此类型的名字空间的OID
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>typowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Owner of the type</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>typowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>类型的拥有者</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>typlen</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       For a fixed-size type, <structfield>typlen</structfield> is the number
       of bytes in the internal representation of the type.  But for a
       variable-length type, <structfield>typlen</structfield> is negative.
       -1 indicates a <quote>varlena</quote> type (one that has a length word),
       -2 indicates a null-terminated C string.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>typlen</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       对于一个固定尺寸的类型，<structfield>typlen</structfield>是该类型内部表示的字节数。对于一个变长类型，<structfield>typlen</structfield>为负值。-1表示一个<quote>varlena</quote>类型（具有长度字），-2表示一个以空值结尾的C字符串。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>typbyval</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <structfield>typbyval</structfield> determines whether internal
       routines pass a value of this type by value or by reference.
       <structfield>typbyval</structfield> had better be false if
       <structfield>typlen</structfield> is not 1, 2, or 4 (or 8 on machines
       where Datum is 8 bytes).
       Variable-length types are always passed by reference. Note that
       <structfield>typbyval</structfield> can be false even if the
       length would allow pass-by-value.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>typbyval</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <structfield>typbyval</structfield>判断内部例程传递这个类型的数值时是通过传值还是传引用。如果<structfield>typlen</structfield>不是1、2或4（或者在Datum为8字节的机器上为8），因此<structfield>typbyval</structfield>最好是假。变长类型总是传引用。注意即使长度允许传值， <structfield>typbyval</structfield>也可以为假。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>typtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <structfield>typtype</structfield> is
       <literal>b</literal> for a base type,
       <literal>c</literal> for a composite type (e.g., a table's row type),
       <literal>d</literal> for a domain,
       <literal>e</literal> for an enum type,
       <literal>p</literal> for a pseudo-type, or
       <literal>r</literal> for a range type.
       See also <structfield>typrelid</structfield> and
       <structfield>typbasetype</structfield>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>typtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <structfield>typtype</structfield>可以是：
       <literal>b</literal>表示一个基类，
       <literal>c</literal>表示一个组合类型（例如一个表的行类型），
       <literal>d</literal>表示一个域，
       <literal>e</literal>表示一个枚举类型，
       <literal>p</literal>表示一个伪类型，或
       <literal>r</literal>表示一个范围类型。
       另请参阅<structfield>typrelid</structfield>和<structfield>typbasetype</structfield>.
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>typcategory</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <structfield>typcategory</structfield> is an arbitrary classification
       of data types that is used by the parser to determine which implicit
       casts should be <quote>preferred</quote>.
       See <xref linkend="catalog-typcategory-table"/>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>typcategory</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <structfield>typcategory</structfield>是一种任意的数据类型分类，它被分析器用来决定哪种隐式转换<quote>更好</quote>。参见<xref linkend="catalog-typcategory-table"/>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>typispreferred</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       True if the type is a preferred cast target within its
       <structfield>typcategory</structfield>
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>typispreferred</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       如果此类型在它的<structfield>typcategory</structfield>中是一个更好的转换目标，此列为真
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>typisdefined</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       True if the type is defined, false if this is a placeholder
       entry for a not-yet-defined type.  When
       <structfield>typisdefined</structfield> is false, nothing
       except the type name, namespace, and OID can be relied on.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>typisdefined</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       如果此类型已被定义则为真，如果此类型只是一个表示还未定义类型的占位符则为假。当<structfield>typisdefined</structfield>为假，除了类型名字、名字空间和OID之外什么都不能被依赖。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>typdelim</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Character that separates two values of this type when parsing
       array input.  Note that the delimiter is associated with the array
       element data type, not the array data type.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>typdelim</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       在分析数组输入时，分隔两个此类型值的字符。注意该分隔符是与数组元素数据类型相关联的， 而不是和数组的数据类型关联。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>typrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       If this is a composite type (see
       <structfield>typtype</structfield>), then this column points to
       the <structname>pg_class</structname> entry that defines the
       corresponding table.  (For a free-standing composite type, the
       <structname>pg_class</structname> entry doesn't really represent
       a table, but it is needed anyway for the type's
       <structname>pg_attribute</structname> entries to link to.)
       Zero for non-composite types.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>typrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       如果这是一个复合类型（见<structfield>typtype</structfield>）， 那么这个列指向<structname>pg_class</structname>中定义对应表的项（对于自由存在的复合类型，<structname>pg_class</structname>项并不表示一个表，但不管怎样该类型的<structname>pg_attribute</structname>项需要链接到它）。对非复合类型此列为零。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>typelem</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       If <structfield>typelem</structfield> is not 0 then it
       identifies another row in <structname>pg_type</structname>.
       The current type can then be subscripted like an array yielding
       values of type <structfield>typelem</structfield>.  A
       <quote>true</quote> array type is variable length
       (<structfield>typlen</structfield> = -1),
       but some fixed-length (<structfield>typlen</structfield> &gt; 0) types
       also have nonzero <structfield>typelem</structfield>, for example
       <type>name</type> and <type>point</type>.
       If a fixed-length type has a <structfield>typelem</structfield> then
       its internal representation must be some number of values of the
       <structfield>typelem</structfield> data type with no other data.
       Variable-length array types have a header defined by the array
       subroutines.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>typelem</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       如果<structfield>typelem</structfield>不为0，则它标识<structname>pg_type</structname>里面的另外一行。 当前类型可以被加上下标得到一个值为类型<structfield>typelem</structfield>的数组来描述。 一个<quote>真的</quote>数组类型是变长的（<structfield>typlen</structfield> = -1），但是一些定长的（<structfield>typlen</structfield> &gt; 0）类型也拥有非零的<structfield>typelem</structfield>，比如<type>name</type>和<type>point</type>。 如果一个定长类型拥有一个<structfield>typelem</structfield>， 则它的内部形式必须是某个<structfield>typelem</structfield>数据类型的值，不能有其它数据。变长数组类型有一个由该数组子例程定义的头。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>typarray</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       If <structfield>typarray</structfield> is not 0 then it
       identifies another row in <structname>pg_type</structname>, which
       is the <quote>true</quote> array type having this type as element
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>typarray</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       如果<structfield>typarray</structfield>不是0，则它标识<structname>pg_type</structname>中的另一行，这一行是一个将此类型作为元素的<quote>真的</quote>数组类型
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>typinput</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Input conversion function (text format)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>typinput</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>输入转换函数（文本格式）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>typoutput</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Output conversion function (text format)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>typoutput</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>输出转换函数（文本格式）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>typreceive</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Input conversion function (binary format), or 0 if none</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>typreceive</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>输入转换函数（二进制格式），如果没有则为0</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>typsend</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Output conversion function (binary format), or 0 if none</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>typsend</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>输出转换函数（二进制格式），如果没有则为0</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>typmodin</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Type modifier input function, or 0 if type does not support modifiers</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>typmodin</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>类型修改器输入函数，如果类型没有提供修改器则为0</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>typmodout</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Type modifier output function, or 0 to use the standard format</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>typmodout</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>类型修改器输出函数，如果类型没有提供修改器则为0</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>typanalyze</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Custom <command>ANALYZE</command> function, or 0 to use the standard function</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>typanalyze</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>自定义<command>ANALYZE</command>函数，0表示使用标准函数</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>typalign</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry><para>

       <structfield>typalign</structfield> is the alignment required
       when storing a value of this type.  It applies to storage on
       disk as well as most representations of the value inside
       <productname>PostgreSQL</productname>.
       When multiple values are stored consecutively, such
       as in the representation of a complete row on disk, padding is
       inserted before a datum of this type so that it begins on the
       specified boundary.  The alignment reference is the beginning
       of the first datum in the sequence.
      </para>

      <para>
       Possible values are:
       <itemizedlist>
        <listitem>
         <para><literal>c</literal> = <type>char</type> alignment, i.e., no alignment needed.</para>
        </listitem>
        <listitem>
         <para><literal>s</literal> = <type>short</type> alignment (2 bytes on most machines).</para>
        </listitem>
        <listitem>
         <para><literal>i</literal> = <type>int</type> alignment (4 bytes on most machines).</para>
        </listitem>
        <listitem>
         <para><literal>d</literal> = <type>double</type> alignment (8 bytes on many machines, but by no means all).</para>
        </listitem>
       </itemizedlist>
      </para><note>
       <para>
        For types used in system tables, it is critical that the size
        and alignment defined in <structname>pg_type</structname>
        agree with the way that the compiler will lay out the column in
        a structure representing a table row.
       </para>
      </note></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>typalign</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry><para>

       <structfield>typalign</structfield>是当存储此类型值时要求的对齐性质。它应用于磁盘存储以及该值在 <productname>PostgreSQL</productname>内部的大多数表现形式。 如果数值是连续存放的，比如在磁盘上的一个完整行，在这种类型的数据前会插入填充，这样它就可以按照指定边界存储。 对齐引用是该序列中第一个数据的开头。对齐引用是序列中第一个数据的开始。
      </para>

      <para>
       可能的值有：
       <itemizedlist>
        <listitem>
         <para><literal>c</literal> = <type>char</type>对齐，即不需要对齐。</para>
        </listitem>
        <listitem>
         <para><literal>s</literal> = <type>short</type>对齐（在大部分机器上为2字节）。</para>
        </listitem>
        <listitem>
         <para><literal>i</literal> = <type>int</type>对齐（在大部分机器上为4字节）。</para>
        </listitem>
        <listitem>
         <para><literal>d</literal> = <type>double</type>对齐（在很多机器上为8字节，但绝不是全部）。</para>
        </listitem>
       </itemizedlist>
      </para><note>
       <para>
        对于系统表中使用的类型，很关键的是，<structname>pg_type</structname>中定义的尺寸和对齐方式要和编译器在表示表行的结构中布局列的方式保持一致。
       </para>
      </note></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>typstorage</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry><para>
       <structfield>typstorage</structfield> tells for varlena
       types (those with <structfield>typlen</structfield> = -1) if
       the type is prepared for toasting and what the default strategy
       for attributes of this type should be.
       Possible values are
       <itemizedlist>
        <listitem>
         <para><literal>p</literal>: Value must always be stored plain.</para>
        </listitem>
        <listitem>
         <para>
          <literal>e</literal>: Value can be stored in a <quote>secondary</quote>
          relation (if relation has one, see
          <literal>pg_class.reltoastrelid</literal>).
         </para>
        </listitem>
        <listitem>
         <para><literal>m</literal>: Value can be stored compressed inline.</para>
        </listitem>
        <listitem>
         <para><literal>x</literal>: Value can be stored compressed inline or stored in <quote>secondary</quote> storage.</para>
        </listitem>
       </itemizedlist>
       Note that <literal>m</literal> columns can also be moved out to secondary
       storage, but only as a last resort (<literal>e</literal> and <literal>x</literal> columns are
       moved first).
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>typstorage</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry><para>
       如果一个变长类型（<structfield>typlen</structfield> = -1）可被TOAST，<structfield>typstorage</structfield>说明这种类型的列应采取的默认策略。可能的值是：
       <itemizedlist>
        <listitem>
         <para><literal>p</literal>：值必须平面存储。</para>
        </listitem>
        <listitem>
         <para>
          <literal>e</literal>：值可以被存储在一个<quote>二级</quote>关系（如果有，见<literal>pg_class.reltoastrelid</literal>）。
         </para>
        </listitem>
        <listitem>
         <para><literal>m</literal>：值可以被压缩线内存储。</para>
        </listitem>
        <listitem>
         <para><literal>x</literal>：值可以被压缩线内存储或存储在<quote>二级</quote>存储。</para>
        </listitem>
       </itemizedlist>
       注意<literal>m</literal>列也可以被移动到二级存储，但只能是作为最后一种方案（<literal>e</literal>和<literal>x</literal>列会先被移动）。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>typnotnull</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry><para>
       <structfield>typnotnull</structfield> represents a not-null
       constraint on a type.  Used for domains only.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>typnotnull</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry><para>
       <structfield>typnotnull</structfield>表示类型上的一个非空约束。只用于域。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>typbasetype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry><para>
       If this is a domain (see <structfield>typtype</structfield>), then
       <structfield>typbasetype</structfield> identifies the type that this
       one is based on.  Zero if this type is not a domain.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>typbasetype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry><para>
       如果这是一个域（见<structfield>typtype</structfield>），则<structfield>typbasetype</structfield>标识这个域基于的类。如果此类不是一个域则为0。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>typtypmod</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry><para>
       Domains use <structfield>typtypmod</structfield> to record the <literal>typmod</literal>
       to be applied to their base type (-1 if base type does not use a
       <literal>typmod</literal>).  -1 if this type is not a domain.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>typtypmod</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry><para>
       域使用<structfield>typtypmod</structfield>来记录被应用于它们基类型的<literal>typmod</literal>（如果基类型不使用<literal>typmod</literal>，则为-1）。如果此类型不是一个域则为-1。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>typndims</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry><para>
       <structfield>typndims</structfield> is the number of array dimensions
       for a domain over an array (that is, <structfield>typbasetype</structfield> is
       an array type).
       Zero for types other than domains over array types.
       </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>typndims</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry><para>
       对于一个数组上的域，<structfield>typndims</structfield>是数组维度数（即，<structfield>typbasetype</structfield>是一个数组类型）。除数组类型上的域之外的类型的此列为0。
       </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>typcollation</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-collation"><structname>pg_collation</structname></link>.oid</literal></entry>
      <entry><para>
       <structfield>typcollation</structfield> specifies the collation
       of the type.  If the type does not support collations, this will
       be zero.  A base type that supports collations will have a nonzero
       value here, typically <symbol>DEFAULT_COLLATION_OID</symbol>.
       A domain over a collatable type can have a collation OID different
       from its base type's, if one was specified for the domain.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>typcollation</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-collation"><structname>pg_collation</structname></link>.oid</literal></entry>
      <entry><para>
       <structfield>typcollation</structfield>指定此类型的排序规则。如果类型不支持排序规则，此列为0。一个支持排序规则的基类型此处会有一个非零值，典型值为<symbol>DEFAULT_COLLATION_OID</symbol>。可排序类型上的域可以有一个不同于其基类型的排序规则OID，如果为该域指定了一个排序规则OID的话。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>typdefaultbin</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry><para>
       If <structfield>typdefaultbin</structfield> is not null, it is the
       <function>nodeToString()</function>
       representation of a default expression for the type.  This is
       only used for domains.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>typdefaultbin</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry><para>
       如果<structfield>typdefaultbin</structfield>为非空，那么它是 该类型默认表达式的<function>nodeToString()</function>表现形式。这个列只用于域。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>typdefault</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry><para>
       <structfield>typdefault</structfield> is null if the type has no associated
       default value. If <structfield>typdefaultbin</structfield> is not null,
       <structfield>typdefault</structfield> must contain a human-readable version of the
       default expression represented by <structfield>typdefaultbin</structfield>.  If
       <structfield>typdefaultbin</structfield> is null and <structfield>typdefault</structfield> is
       not, then <structfield>typdefault</structfield> is the external representation of
       the type's default value, which can be fed to the type's input
       converter to produce a constant.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>typdefault</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry><para>
       如果某类型没有相关默认值，那么<structfield>typdefault</structfield>为空。如果<structfield>typdefaultbin</structfield>不为空， 那么<structfield>typdefault</structfield>必须包含一个<structfield>typdefaultbin</structfield>所指的默认表达式的人类可读的版本。 如果<structfield>typdefaultbin</structfield>为空但<structfield>typdefault</structfield>不为空，则<structfield>typdefault</structfield>是该类型默认值的外部表现形式， 它可以被交给该类型的输入转换器来产生一个常量。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>typacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       Access privileges; see <xref linkend="ddl-priv"/> for details
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>typacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       访问权限，另请参阅<xref linkend="ddl-priv"/>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="catalog-typcategory-table"/> lists the system-defined values
   of <structfield>typcategory</structfield>.  Any future additions to this list will
   also be upper-case ASCII letters.  All other ASCII characters are reserved
   for user-defined categories.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="catalog-typcategory-table"/>列出了<structfield>typcategory</structfield>的系统定义值。任何未来对此列表的增加都将是大写ASCII字母。所有其他ASCII字符都保留给用户定义的类别。
  </para>

  <table id="catalog-typcategory-table">
<!--==========================orignal english content==========================
   <title><structfield>typcategory</structfield> Codes</title>
____________________________________________________________________________-->
   <title><structfield>typcategory</structfield>编码</title>

   <tgroup cols="2">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Code</entry>
      <entry>Category</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>编码</entry>
      <entry>类别</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>A</literal></entry>
      <entry>Array types</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>A</literal></entry>
      <entry>数组类型</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>B</literal></entry>
      <entry>Boolean types</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>B</literal></entry>
      <entry>布尔类型</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>C</literal></entry>
      <entry>Composite types</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>C</literal></entry>
      <entry>组合类型</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>D</literal></entry>
      <entry>Date/time types</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>D</literal></entry>
      <entry>日期/时间类型</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>E</literal></entry>
      <entry>Enum types</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>E</literal></entry>
      <entry>枚举类型</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>G</literal></entry>
      <entry>Geometric types</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>G</literal></entry>
      <entry>几何类型</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>I</literal></entry>
      <entry>Network address types</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>I</literal></entry>
      <entry>网络地址类型</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>N</literal></entry>
      <entry>Numeric types</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>N</literal></entry>
      <entry>数字类型</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>P</literal></entry>
      <entry>Pseudo-types</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>P</literal></entry>
      <entry>伪类型</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>R</literal></entry>
      <entry>Range types</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>R</literal></entry>
      <entry>范围类型</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>S</literal></entry>
      <entry>String types</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>S</literal></entry>
      <entry>字符串类型</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>T</literal></entry>
      <entry>Timespan types</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>T</literal></entry>
      <entry>时间间隔类型</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>U</literal></entry>
      <entry>User-defined types</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>U</literal></entry>
      <entry>用户定义类型</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>V</literal></entry>
      <entry>Bit-string types</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>V</literal></entry>
      <entry>位串类型</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>X</literal></entry>
      <entry><type>unknown</type> type</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>X</literal></entry>
      <entry><type>未知</type>类型</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-user-mapping">
<!--==========================orignal english content==========================
  <title><structname>pg_user_mapping</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_user_mapping</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="catalog-pg-user-mapping">
   <primary>pg_user_mapping</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="catalog-pg-user-mapping">
   <primary>pg_user_mapping</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The catalog <structname>pg_user_mapping</structname> stores
   the mappings from local user to remote.  Access to this catalog is
   restricted from normal users, use the view
   <link linkend="view-pg-user-mappings"><structname>pg_user_mappings</structname></link>
   instead.
  </para>
____________________________________________________________________________-->
  <para>
   目录<structname>pg_user_mapping</structname>存储从本地用户到远程的映射。对这个目录的访问对普通用户有限制，可使用视图<link linkend="view-pg-user-mappings"><structname>pg_user_mappings</structname></link>替代。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_user_mapping</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_user_mapping</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Row identifier</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>行标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>umuser</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>OID of the local role being mapped, 0 if the user mapping is public</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>umuser</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>将要被映射的本地角色的OID，如果用户映射是公共的则为0</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>umserver</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-foreign-server"><structname>pg_foreign_server</structname></link>.oid</literal></entry>
      <entry>
       The OID of the foreign server that contains this mapping
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>umserver</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-foreign-server"><structname>pg_foreign_server</structname></link>.oid</literal></entry>
      <entry>
       包含此映射的外部服务器的OID
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>umoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       User mapping specific options, as <quote>keyword=value</quote> strings
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>umoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       用户映射相关选项，以<quote>keyword=value</quote>字符串形式
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="views-overview">
<!--==========================orignal english content==========================
  <title>System Views</title>
____________________________________________________________________________-->
  <title>系统视图</title>

<!--==========================orignal english content==========================
  <para>
   In addition to the system catalogs, <productname>PostgreSQL</productname>
   provides a number of built-in views.  Some system views provide convenient
   access to some commonly used queries on the system catalogs.  Other views
   provide access to internal server state.
  </para>
____________________________________________________________________________-->
  <para>
   除系统目录外，<productname>PostgreSQL</productname>提供了一些内建视图。一些系统视图为系统目录上一些常用查询提供了便利的访问。其他视图提供了对内部服务器状态的访问。
  </para>

<!--==========================orignal english content==========================
  <para>
   The information schema (<xref linkend="information-schema"/>) provides
   an alternative set of views which overlap the functionality of the system
   views.  Since the information schema is SQL-standard whereas the views
   described here are <productname>PostgreSQL</productname>-specific,
   it's usually better to use the information schema if it provides all
   the information you need.
  </para>
____________________________________________________________________________-->
  <para>
   信息模式（<xref linkend="information-schema"/>）提供了一组可供选择的视图，它和系统视图在功能上有所重叠。由于信息模式是SQL标准，而这里描述的视图是<productname>PostgreSQL</productname>特有的，如果信息模式能提供你所需要的信息，通常最好使用它。
  </para>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="view-table"/> lists the system views described here.
   More detailed documentation of each view follows below.
   There are some additional views that provide access to the results of
   the statistics collector; they are described in <xref
   linkend="monitoring-stats-views-table"/>.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="view-table"/>列出了这里描述的系统视图。每一个视图的详细文档都在后文中。还有一些附加视图用于提供对于统计收集器结果的访问，它们在<xref linkend="monitoring-stats-views-table"/>中描述。
  </para>

<!--==========================orignal english content==========================
  <para>
   Except where noted, all the views described here are read-only.
  </para>
____________________________________________________________________________-->
  <para>
   除了特别注明的，所有这里描述的视图都是只读的。
  </para>

  <table id="view-table">
<!--==========================orignal english content==========================
   <title>System Views</title>
____________________________________________________________________________-->
   <title>系统视图</title>

   <tgroup cols="2">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>View Name</entry>
      <entry>Purpose</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>视图名字</entry>
      <entry>用途</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="view-pg-available-extensions"><structname>pg_available_extensions</structname></link></entry>
      <entry>available extensions</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="view-pg-available-extensions"><structname>pg_available_extensions</structname></link></entry>
      <entry>可用的扩展</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="view-pg-available-extension-versions"><structname>pg_available_extension_versions</structname></link></entry>
      <entry>available versions of extensions</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="view-pg-available-extension-versions"><structname>pg_available_extension_versions</structname></link></entry>
      <entry>所有版本的扩展</entry>
     </row>
     
<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="view-pg-config"><structname>pg_config</structname></link></entry>
      <entry>compile-time configuration parameters</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="view-pg-config"><structname>pg_config</structname></link></entry>
      <entry>编译时配置参数</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="view-pg-cursors"><structname>pg_cursors</structname></link></entry>
      <entry>open cursors</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="view-pg-cursors"><structname>pg_cursors</structname></link></entry>
      <entry>打开的游标</entry>
     </row>
     
<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="view-pg-file-settings"><structname>pg_file_settings</structname></link></entry>
      <entry>summary of configuration file contents</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="view-pg-file-settings"><structname>pg_file_settings</structname></link></entry>
      <entry>配置文件内容摘要</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="view-pg-group"><structname>pg_group</structname></link></entry>
      <entry>groups of database users</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="view-pg-group"><structname>pg_group</structname></link></entry>
      <entry>数据库用户组</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="view-pg-hba-file-rules"><structname>pg_hba_file_rules</structname></link></entry>
      <entry>summary of client authentication configuration file contents</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="view-pg-hba-file-rules"><structname>pg_hba_file_rules</structname></link></entry>
      <entry>客户端认证配置文件内容的摘要</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="view-pg-indexes"><structname>pg_indexes</structname></link></entry>
      <entry>indexes</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="view-pg-indexes"><structname>pg_indexes</structname></link></entry>
      <entry>索引</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="view-pg-locks"><structname>pg_locks</structname></link></entry>
      <entry>locks currently held or awaited</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="view-pg-locks"><structname>pg_locks</structname></link></entry>
      <entry>当前保持或者等待的锁</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="view-pg-matviews"><structname>pg_matviews</structname></link></entry>
      <entry>materialized views</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="view-pg-matviews"><structname>pg_matviews</structname></link></entry>
      <entry>物化视图</entry>
     </row>
     
<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="view-pg-policies"><structname>pg_policies</structname></link></entry>
      <entry>policies</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="view-pg-policies"><structname>pg_policies</structname></link></entry>
      <entry>策略</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="view-pg-prepared-statements"><structname>pg_prepared_statements</structname></link></entry>
      <entry>prepared statements</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="view-pg-prepared-statements"><structname>pg_prepared_statements</structname></link></entry>
      <entry>预备好的语句</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="view-pg-prepared-xacts"><structname>pg_prepared_xacts</structname></link></entry>
      <entry>prepared transactions</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="view-pg-prepared-xacts"><structname>pg_prepared_xacts</structname></link></entry>
      <entry>预备好的事务</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="view-pg-publication-tables"><structname>pg_publication_tables</structname></link></entry>
      <entry>publications and their associated tables</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="view-pg-publication-tables"><structname>pg_publication_tables</structname></link></entry>
      <entry>publication和它们相关的表</entry>
     </row>
     
<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="view-pg-replication-origin-status"><structname>pg_replication_origin_status</structname></link></entry>
      <entry>information about replication origins, including replication progress</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="view-pg-replication-origin-status"><structname>pg_replication_origin_status</structname></link></entry>
      <entry>有关复制源的信息，包括复制进度</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="view-pg-replication-slots"><structname>pg_replication_slots</structname></link></entry>
      <entry>replication slot information</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="view-pg-replication-slots"><structname>pg_replication_slots</structname></link></entry>
      <entry>复制槽信息</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="view-pg-roles"><structname>pg_roles</structname></link></entry>
      <entry>database roles</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="view-pg-roles"><structname>pg_roles</structname></link></entry>
      <entry>数据库角色</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="view-pg-rules"><structname>pg_rules</structname></link></entry>
      <entry>rules</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="view-pg-rules"><structname>pg_rules</structname></link></entry>
      <entry>规则</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="view-pg-seclabels"><structname>pg_seclabels</structname></link></entry>
      <entry>security labels</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="view-pg-seclabels"><structname>pg_seclabels</structname></link></entry>
      <entry>安全标签</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="view-pg-sequences"><structname>pg_sequences</structname></link></entry>
      <entry>sequences</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="view-pg-sequences"><structname>pg_sequences</structname></link></entry>
      <entry>序列</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="view-pg-settings"><structname>pg_settings</structname></link></entry>
      <entry>parameter settings</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="view-pg-settings"><structname>pg_settings</structname></link></entry>
      <entry>参数设置</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="view-pg-shadow"><structname>pg_shadow</structname></link></entry>
      <entry>database users</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="view-pg-shadow"><structname>pg_shadow</structname></link></entry>
      <entry>数据库用户</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="view-pg-stats"><structname>pg_stats</structname></link></entry>
      <entry>planner statistics</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="view-pg-stats"><structname>pg_stats</structname></link></entry>
      <entry>规划器统计信息</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="view-pg-stats-ext"><structname>pg_stats_ext</structname></link></entry>
      <entry>extended planner statistics</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="view-pg-stats-ext"><structname>pg_stats_ext</structname></link></entry>
      <entry>扩展的计划器统计信息</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="view-pg-tables"><structname>pg_tables</structname></link></entry>
      <entry>tables</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="view-pg-tables"><structname>pg_tables</structname></link></entry>
      <entry>表</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="view-pg-timezone-abbrevs"><structname>pg_timezone_abbrevs</structname></link></entry>
      <entry>time zone abbreviations</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="view-pg-timezone-abbrevs"><structname>pg_timezone_abbrevs</structname></link></entry>
      <entry>时区简写</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="view-pg-timezone-names"><structname>pg_timezone_names</structname></link></entry>
      <entry>time zone names</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="view-pg-timezone-names"><structname>pg_timezone_names</structname></link></entry>
      <entry>时区名字</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="view-pg-user"><structname>pg_user</structname></link></entry>
      <entry>database users</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="view-pg-user"><structname>pg_user</structname></link></entry>
      <entry>数据库用户</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="view-pg-user-mappings"><structname>pg_user_mappings</structname></link></entry>
      <entry>user mappings</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="view-pg-user-mappings"><structname>pg_user_mappings</structname></link></entry>
      <entry>用户映射</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><link linkend="view-pg-views"><structname>pg_views</structname></link></entry>
      <entry>views</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><link linkend="view-pg-views"><structname>pg_views</structname></link></entry>
      <entry>视图</entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="view-pg-available-extensions">
<!--==========================orignal english content==========================
  <title><structname>pg_available_extensions</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_available_extensions</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="view-pg-available-extensions">
   <primary>pg_available_extensions</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="view-pg-available-extensions">
   <primary>pg_available_extensions</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_available_extensions</structname> view lists the
   extensions that are available for installation.
   See also the
   <link linkend="catalog-pg-extension"><structname>pg_extension</structname></link>
   catalog, which shows the extensions currently installed.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_available_extensions</structname>视图列出了可用于安装的扩展。参见<link linkend="catalog-pg-extension"><structname>pg_extension</structname></link>目录，它显示当前已安装的扩展。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_available_extensions</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_available_extensions</structname>的列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名字</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>name</type></entry>
      <entry>Extension name</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>name</type></entry>
      <entry>扩展名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>default_version</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Name of default version, or <literal>NULL</literal> if none is
       specified</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>default_version</structfield></entry>
      <entry><type>text</type></entry>
      <entry>默认版本的名字，如果没有指定则为<literal>NULL</literal></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>installed_version</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Currently installed version of the extension,
       or <literal>NULL</literal> if not installed</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>installed_version</structfield></entry>
      <entry><type>text</type></entry>
      <entry>当前已安装的扩展版本，如果没有安装则为<literal>NULL</literal></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>comment</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Comment string from the extension's control file</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>comment</structfield></entry>
      <entry><type>text</type></entry>
      <entry>来自于扩展的控制文件的注释字符串</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_available_extensions</structname> view is read only.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_available_extensions</structname>视图是只读的。
  </para>
 </sect1>

 <sect1 id="view-pg-available-extension-versions">
<!--==========================orignal english content==========================
  <title><structname>pg_available_extension_versions</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_available_extension_versions</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="view-pg-available-extension-versions">
   <primary>pg_available_extension_versions</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="view-pg-available-extension-versions">
   <primary>pg_available_extension_versions</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_available_extension_versions</structname> view lists the
   specific extension versions that are available for installation.
   See also the <link
   linkend="catalog-pg-extension"><structname>pg_extension</structname></link>
   catalog, which shows the extensions currently installed.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_available_extension_versions</structname>视图列出了可用于安装的指定扩展版本。参见<link linkend="catalog-pg-extension"><structname>pg_extension</structname></link>目录，它显示当前已安装的扩展。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_available_extension_versions</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_available_extension_versions</structname>的列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名字</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>name</type></entry>
      <entry>Extension name</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>name</type></entry>
      <entry>扩展名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>version</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Version name</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>version</structfield></entry>
      <entry><type>text</type></entry>
      <entry>版本名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>installed</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>True if this version of this extension is currently
       installed</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>installed</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>如果此版本的扩展当前已安装则为真</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>superuser</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>True if only superusers are allowed to install this extension</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>superuser</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>如果只有超级用户被允许安装此扩展则为真</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>relocatable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>True if extension can be relocated to another schema</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>relocatable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>如果扩展能被重定位到另一个模式则为真</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>schema</structfield></entry>
      <entry><type>name</type></entry>
      <entry>Name of the schema that the extension must be installed into,
       or <literal>NULL</literal> if partially or fully relocatable</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>schema</structfield></entry>
      <entry><type>name</type></entry>
      <entry>此扩展必须被安装到的模式名，如果此扩展是部分或者全部可以重定位的，此列为<literal>NULL</literal></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>requires</structfield></entry>
      <entry><type>name[]</type></entry>
      <entry>Names of prerequisite extensions,
       or <literal>NULL</literal> if none</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>requires</structfield></entry>
      <entry><type>name[]</type></entry>
      <entry>先决条件扩展的名字，如果没有则为<literal>NULL</literal></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>comment</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Comment string from the extension's control file</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>comment</structfield></entry>
      <entry><type>text</type></entry>
      <entry>来自于扩展的控制文件的注释字符串</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_available_extension_versions</structname> view is read
   only.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_available_extension_versions</structname>视图是只读的。
  </para>
 </sect1>
 
 <sect1 id="view-pg-config">
<!--==========================orignal english content==========================
  <title><structname>pg_config</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_config</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="view-pg-config">
   <primary>pg_config</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="view-pg-config">
   <primary>pg_config</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The view <structname>pg_config</structname> describes the
   compile-time configuration parameters of the currently installed
   version of <productname>PostgreSQL</productname>. It is intended, for example, to
   be used by software packages that want to interface to
   <productname>PostgreSQL</productname> to facilitate finding the required header
   files and libraries. It provides the same basic information as the
   <xref linkend="app-pgconfig"/> <productname>PostgreSQL</productname> client
   application.
  </para>
____________________________________________________________________________-->
  <para>
   视图<structname>pg_config</structname>描述了当前安装的<productname>PostgreSQL</productname>版本中的编译时配置参数。它存在的本意是用于那些要和<productname>PostgreSQL</productname>交互的软件包，让它们能找到所需要的头文件和库。它提供了和<xref linkend="app-pgconfig"/> <productname>PostgreSQL</productname>客户端应用相同的基本信息。
  </para>

<!--==========================orignal english content==========================
  <para>
   By default, the <structname>pg_config</structname> view can be read
   only by superusers.
  </para>
____________________________________________________________________________-->
  <para>
   默认情况下，<structname>pg_config</structname>视图只能由超级用户读取。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_config</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_config</structname>列</title>
   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <entry>The parameter name</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <entry>参数名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>setting</structfield></entry>
      <entry><type>text</type></entry>
      <entry>The parameter value</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>setting</structfield></entry>
      <entry><type>text</type></entry>
      <entry>参数值</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-cursors">
<!--==========================orignal english content==========================
  <title><structname>pg_cursors</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_cursors</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="view-pg-cursors">
   <primary>pg_cursors</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="view-pg-cursors">
   <primary>pg_cursors</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_cursors</structname> view lists the cursors that
   are currently available. Cursors can be defined in several ways:
   <itemizedlist>
    <listitem>
     <para>
      via the <xref linkend="sql-declare"/>
      statement in SQL
     </para>
    </listitem>

    <listitem>
     <para>
      via the Bind message in the frontend/backend protocol, as
      described in <xref linkend="protocol-flow-ext-query"/>
     </para>
    </listitem>

    <listitem>
     <para>
      via the Server Programming Interface (SPI), as described in
      <xref linkend="spi-interface"/>
     </para>
    </listitem>
   </itemizedlist>

   The <structname>pg_cursors</structname> view displays cursors
   created by any of these means. Cursors only exist for the duration
   of the transaction that defines them, unless they have been
   declared <literal>WITH HOLD</literal>. Therefore non-holdable
   cursors are only present in the view until the end of their
   creating transaction.

   <note>
    <para>
     Cursors are used internally to implement some of the components
     of <productname>PostgreSQL</productname>, such as procedural languages.
     Therefore, the <structname>pg_cursors</structname> view might include cursors
     that have not been explicitly created by the user.
    </para>
   </note>
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_cursors</structname>视图列出了当前可用的游标。游标可以以几种方式定义：
   <itemizedlist>
    <listitem>
     <para>
      通过SQL中的<xref linkend="sql-declare"/>语句
     </para>
    </listitem>

    <listitem>
     <para>
      通过前端/后端协议中的绑定消息，如<xref linkend="protocol-flow-ext-query"/>中所描述的
     </para>
    </listitem>

    <listitem>
     <para>
      通过服务器编程接口（SPI），如<xref linkend="spi-interface"/>中所描述的
     </para>
    </listitem>
   </itemizedlist>

   <structname>pg_cursors</structname>视图显示由任何这些方式创建的游标。视图只存在于定义它们的事务期间，除非声明了<literal>WITH HOLD</literal>。因此非保持游标只在它们的创建事务结束前存在于这个视图中。

   <note>
    <para>
     视图用于在内部实现<productname>PostgreSQL</productname>的某些部件，例如过程语言。因此，<structname>pg_cursors</structname>视图可能包括那些不是由用户显式创建的游标。
    </para>
   </note>
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_cursors</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_cursors</structname>的列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名字</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <entry>The name of the cursor</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <entry>游标名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>statement</structfield></entry>
      <entry><type>text</type></entry>
      <entry>The verbatim query string submitted to declare this cursor</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>statement</structfield></entry>
      <entry><type>text</type></entry>
      <entry>提交用于定义此游标的查询语句</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>is_holdable</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>
       <literal>true</literal> if the cursor is holdable (that is, it
       can be accessed after the transaction that declared the cursor
       has committed); <literal>false</literal> otherwise
       </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>is_holdable</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>
       如果游标是可保持的（即，它可以在其定义事务提交后被访问）则为<literal>true</literal>，否则为<literal>否</literal>
       </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>is_binary</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>
       <literal>true</literal> if the cursor was declared
       <literal>BINARY</literal>; <literal>false</literal>
       otherwise
       </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>is_binary</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>
       如果游标被声明为<literal>BINARY</literal>则为<literal>true</literal>，否则为<literal>false</literal>
       </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>is_scrollable</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>
       <literal>true</literal> if the cursor is scrollable (that is, it
       allows rows to be retrieved in a nonsequential manner);
       <literal>false</literal> otherwise
       </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>is_scrollable</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>
       如果游标是可滚动的（即，允许以一种非顺序的方式检索行）则为<literal>true</literal>，否则为<literal>false</literal>
       </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>creation_time</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry>The time at which the cursor was declared</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>creation_time</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry>游标被声明的时间</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_cursors</structname> view is read only.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_cursors</structname>视图是只读的。
  </para>

 </sect1>
 
 <sect1 id="view-pg-file-settings">
<!--==========================orignal english content==========================
  <title><structname>pg_file_settings</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_file_settings</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="view-pg-file-settings">
   <primary>pg_file_settings</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="view-pg-file-settings">
   <primary>pg_file_settings</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The view <structname>pg_file_settings</structname> provides a summary of
   the contents of the server's configuration file(s).  A row appears in
   this view for each <quote>name = value</quote> entry appearing in the files,
   with annotations indicating whether the value could be applied
   successfully.  Additional row(s) may appear for problems not linked to
   a <quote>name = value</quote> entry, such as syntax errors in the files.
  </para>
____________________________________________________________________________-->
  <para>
   视图<structname>pg_file_settings</structname>提供了服务器配置文件
   内容的概要。这个视图中的每一行表示配置文件中出现的一个
   <quote>name = value</quote>项，还带有注解指示该值是否被成功地应用。在
   配置文件有问题时，有可能出现额外的行，它们没有相关的
   <quote>name = value</quote>项，一个例子是配置文件中有语法错误。
  </para>

<!--==========================orignal english content==========================
  <para>
   This view is helpful for checking whether planned changes in the
   configuration files will work, or for diagnosing a previous failure.
   Note that this view reports on the <emphasis>current</emphasis> contents of the
   files, not on what was last applied by the server.  (The
   <link linkend="view-pg-settings"><structname>pg_settings</structname></link>
   view is usually sufficient to determine that.)
  </para>
____________________________________________________________________________-->
  <para>
   这个视图有助于检查在配置文件中打算做的修改是否能工作，或者用来诊断
   之前的失败。注意这个视图报告的是配置文件的<emphasis>当前</emphasis>内容，
   而不是服务器最后应用的值（这些值通常查看
   <link linkend="view-pg-settings"><structname>pg_settings</structname></link>
   视图就够了）。
  </para>

<!--==========================orignal english content==========================
  <para>
   By default, the <structname>pg_file_settings</structname> view can be read
   only by superusers.
  </para>
____________________________________________________________________________-->
  <para>
   默认情况下，<structname>pg_file_settings</structname>视图只有超级用户可读。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_file_settings</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_file_settings</structname>的列</title>

  <tgroup cols="3">
   <thead>
<!--==========================orignal english content==========================
    <row>
     <entry>Name</entry>
     <entry>Type</entry>
     <entry>Description</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry>名称</entry>
     <entry>类型</entry>
     <entry>描述</entry>
    </row>
   </thead>
   <tbody>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>sourcefile</structfield></entry>
     <entry><structfield>text</structfield></entry>
     <entry>Full path name of the configuration file</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>sourcefile</structfield></entry>
     <entry><structfield>text</structfield></entry>
     <entry>配置文件的完整路径名</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>sourceline</structfield></entry>
     <entry><structfield>integer</structfield></entry>
     <entry>
      Line number within the configuration file where the entry appears
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>sourceline</structfield></entry>
     <entry><structfield>integer</structfield></entry>
     <entry>
      该项在配置文件中出现的行号
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>seqno</structfield></entry>
     <entry><structfield>integer</structfield></entry>
     <entry>Order in which the entries are processed (1..<replaceable>n</replaceable>)</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>seqno</structfield></entry>
     <entry><structfield>integer</structfield></entry>
     <entry>项被处理的顺序（1..<replaceable>n</replaceable>）</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>name</structfield></entry>
     <entry><structfield>text</structfield></entry>
     <entry>Configuration parameter name</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>name</structfield></entry>
     <entry><structfield>text</structfield></entry>
     <entry>配置参数名</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>setting</structfield></entry>
     <entry><structfield>text</structfield></entry>
     <entry>Value to be assigned to the parameter</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>setting</structfield></entry>
     <entry><structfield>text</structfield></entry>
     <entry>被赋予给参数的值</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>applied</structfield></entry>
     <entry><structfield>boolean</structfield></entry>
     <entry>True if the value can be applied successfully</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>applied</structfield></entry>
     <entry><structfield>boolean</structfield></entry>
     <entry>为真表示值已被成功应用</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>error</structfield></entry>
     <entry><structfield>text</structfield></entry>
     <entry>If not null, an error message indicating why this entry could
      not be applied</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>error</structfield></entry>
     <entry><structfield>text</structfield></entry>
     <entry>如果非空，表示一个错误消息，它说明为什么这个项不能被应用
     </entry>
    </row>
   </tbody>
  </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   If the configuration file contains syntax errors or invalid parameter
   names, the server will not attempt to apply any settings from it, and
   therefore all the <structfield>applied</structfield> fields will read as false.
   In such a case there will be one or more rows with
   non-null <structfield>error</structfield> fields indicating the
   problem(s).  Otherwise, individual settings will be applied if possible.
   If an individual setting cannot be applied (e.g., invalid value, or the
   setting cannot be changed after server start) it will have an appropriate
   message in the <structfield>error</structfield> field.  Another way that
   an entry might have <structfield>applied</structfield> = false is that it is
   overridden by a later entry for the same parameter name; this case is not
   considered an error so nothing appears in
   the <structfield>error</structfield> field.
  </para>
____________________________________________________________________________-->
  <para>
   如果配置文件包含语法错误或者非法参数名，服务器将不会尝试从其中应用
   任何设置，并且因此所有的<structfield>applied</structfield>域都为假。在这种情
   况下，将会有一个或者多个行的<structfield>error</structfield>域为非空，
   它们说明了为什么出问题。否则，将尽可能应用每个设置。如果一个设置不能
   被应用（例如非法值或者该设置不能在服务器开始后改变），会有一个合适的
   消息存储在它的<structfield>error</structfield>域中。一个项的<structfield>applied</structfield>
   域为假的另一种情况是它被后面一个具有相同参数名的项所覆盖，这种情况不
   会被认为是一种错误，因此在<structfield>error</structfield>域中不会有
   错误消息。
  </para>

<!--==========================orignal english content==========================
  <para>
   See <xref linkend="config-setting"/> for more information about the various
   ways to change run-time parameters.
  </para>
____________________________________________________________________________-->
  <para>
   关于更改运行时参数的各种方法请见<xref linkend="config-setting"/>。
  </para>

</sect1>

 <sect1 id="view-pg-group">
<!--==========================orignal english content==========================
  <title><structname>pg_group</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_group</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="view-pg-group">
   <primary>pg_group</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="view-pg-group">
   <primary>pg_group</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The view <structname>pg_group</structname> exists for backwards
   compatibility: it emulates a catalog that existed in
   <productname>PostgreSQL</productname> before version 8.1.
   It shows the names and members of all roles that are marked as not
   <structfield>rolcanlogin</structfield>, which is an approximation to the set
   of roles that are being used as groups.
  </para>
____________________________________________________________________________-->
  <para>
   视图<structname>pg_group</structname>为向后兼容而存在：它模拟了存在于<productname>PostgreSQL</productname> 8.1之前版本中的一个目录。它显式所有角色的名称和未被标记<structfield>rolcanlogin</structfield>的成员，它是被用做组的角色集合的近似。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_group</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_group</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>groname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>Name of the group</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>groname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>组名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>grosysid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>ID of this group</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>grosysid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>组ID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>grolist</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>An array containing the IDs of the roles in this group</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>grolist</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>包含此组中角色ID的一个数组</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-hba-file-rules">
<!--==========================orignal english content==========================
  <title><structname>pg_hba_file_rules</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_hba_file_rules</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="view-pg-hba-file-rules">
   <primary>pg_hba_file_rules</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="view-pg-hba-file-rules">
   <primary>pg_hba_file_rules</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The view <structname>pg_hba_file_rules</structname> provides a summary of
   the contents of the client authentication configuration
   file, <filename>pg_hba.conf</filename>.  A row appears in this view for each
   non-empty, non-comment line in the file, with annotations indicating
   whether the rule could be applied successfully.
  </para>
____________________________________________________________________________-->
  <para>
   视图<structname>pg_hba_file_rules</structname>提供客户端认证配置文件<filename>pg_hba.conf</filename>内容的摘要。该文件中每个非空、非注释行都会在这个视图中出现一行，行中还有标记表示该规则是否被成功地应用。
  </para>

<!--==========================orignal english content==========================
  <para>
   This view can be helpful for checking whether planned changes in the
   authentication configuration file will work, or for diagnosing a previous
   failure.  Note that this view reports on the <emphasis>current</emphasis> contents
   of the file, not on what was last loaded by the server.
  </para>
____________________________________________________________________________-->
  <para>
   这个视图可用来检查认证配置文件中按计划的更改是否起作用，或者诊断之前的失败。注意这个视图报告的是该文件的<emphasis>当前</emphasis>内容，而不是服务器最后一次载入的内容。
  </para>

<!--==========================orignal english content==========================
  <para>
   By default, the <structname>pg_hba_file_rules</structname> view can be read
   only by superusers.
  </para>
____________________________________________________________________________-->
  <para>
   默认情况下，只有超级用户可以读取<structname>pg_hba_file_rules</structname>视图。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_hba_file_rules</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_hba_file_rules</structname>的列</title>

  <tgroup cols="3">
   <thead>
<!--==========================orignal english content==========================
    <row>
     <entry>Name</entry>
     <entry>Type</entry>
     <entry>Description</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry>名称</entry>
     <entry>列</entry>
     <entry>描述</entry>
    </row>
   </thead>
   <tbody>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>line_number</structfield></entry>
     <entry><structfield>integer</structfield></entry>
     <entry>
      Line number of this rule in <filename>pg_hba.conf</filename>
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>line_number</structfield></entry>
     <entry><structfield>integer</structfield></entry>
     <entry>
      这条规则在<filename>pg_hba.conf</filename>中的行号
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>type</structfield></entry>
     <entry><structfield>text</structfield></entry>
     <entry>Type of connection</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>type</structfield></entry>
     <entry><structfield>text</structfield></entry>
     <entry>连接类型</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>database</structfield></entry>
     <entry><structfield>text[]</structfield></entry>
     <entry>List of database name(s) to which this rule applies</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>database</structfield></entry>
     <entry><structfield>text[]</structfield></entry>
     <entry>这条规则应用的数据库名列表</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>user_name</structfield></entry>
     <entry><structfield>text[]</structfield></entry>
     <entry>List of user and group name(s) to which this rule applies</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>user_name</structfield></entry>
     <entry><structfield>text[]</structfield></entry>
     <entry>这条规则应用的用户及组名列表</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>address</structfield></entry>
     <entry><structfield>text</structfield></entry>
     <entry>
      Host name or IP address, or one
      of <literal>all</literal>, <literal>samehost</literal>,
      or <literal>samenet</literal>, or null for local connections
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>address</structfield></entry>
     <entry><structfield>text</structfield></entry>
     <entry>
      主机名或IP地址，或者<literal>all</literal>、<literal>samehost</literal>、<literal>samenet</literal>之一，对于本地连接为空
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>netmask</structfield></entry>
     <entry><structfield>text</structfield></entry>
     <entry>IP address mask, or null if not applicable</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>netmask</structfield></entry>
     <entry><structfield>text</structfield></entry>
     <entry>IP地址掩码，如果不适用则为空</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>auth_method</structfield></entry>
     <entry><type>text</type></entry>
     <entry>Authentication method</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>auth_method</structfield></entry>
     <entry><type>text</type></entry>
     <entry>认证方法</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>options</structfield></entry>
     <entry><type>text[]</type></entry>
     <entry>Options specified for authentication method, if any</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>options</structfield></entry>
     <entry><type>text[]</type></entry>
     <entry>为认证方法指定的选项（如果有）</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><structfield>error</structfield></entry>
     <entry><structfield>text</structfield></entry>
     <entry>
      If not null, an error message indicating why this
      line could not be processed
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><structfield>error</structfield></entry>
     <entry><structfield>text</structfield></entry>
     <entry>
      如果非空，则是一个错误消息，它表示为什么这一行无法被处理
     </entry>
    </row>
   </tbody>
  </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   Usually, a row reflecting an incorrect entry will have values for only
   the <structfield>line_number</structfield> and <structfield>error</structfield> fields.
  </para>
____________________________________________________________________________-->
  <para>
   通常，反映一个不正确项的行只有<structfield>line_number</structfield>和<structfield>error</structfield>域中有值。
  </para>

<!--==========================orignal english content==========================
  <para>
   See <xref linkend="client-authentication"/> for more information about
   client authentication configuration.
  </para>
____________________________________________________________________________-->
  <para>
   更多有关客户端认证配置的信息请参考<xref linkend="client-authentication"/>。
  </para>
 </sect1>

 <sect1 id="view-pg-indexes">
<!--==========================orignal english content==========================
  <title><structname>pg_indexes</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_indexes</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="view-pg-indexes">
   <primary>pg_indexes</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="view-pg-indexes">
   <primary>pg_indexes</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The view <structname>pg_indexes</structname> provides access to
   useful information about each index in the database.
  </para>
____________________________________________________________________________-->
  <para>
   视图<structname>pg_indexes</structname>提供对于数据库中每一个索引信息的访问。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_indexes</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_indexes</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>Name of schema containing table and index</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>包含表和索引的模式名</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Name of table the index is for</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>此索引的基表的名字</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>indexname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Name of index</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>indexname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>索引名</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tablespace</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.spcname</literal></entry>
      <entry>Name of tablespace containing index (null if default for database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tablespace</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.spcname</literal></entry>
      <entry>包含索引的表空间名（如果是数据库的默认值则为空）</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>indexdef</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Index definition (a reconstructed <command>CREATE INDEX</command>
      command)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>indexdef</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>索引定义（<command>CREATE INDEX</command>命令的重构）</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-locks">
<!--==========================orignal english content==========================
  <title><structname>pg_locks</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_locks</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="view-pg-locks">
   <primary>pg_locks</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="view-pg-locks">
   <primary>pg_locks</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The view <structname>pg_locks</structname> provides access to
   information about the locks held by active processes within the
   database server.  See <xref linkend="mvcc"/> for more discussion
   of locking.
  </para>
____________________________________________________________________________-->
  <para>
   视图<structname>pg_locks</structname>提供了数据库服务器上活动进程中保持的锁的信息。更多锁的讨论参见<xref linkend="mvcc"/>。
  </para>

<!--==========================orignal english content==========================
  <para>
   <structname>pg_locks</structname> contains one row per active lockable
   object, requested lock mode, and relevant process.  Thus, the same
   lockable object might
   appear many times, if multiple processes are holding or waiting
   for locks on it.  However, an object that currently has no locks on it
   will not appear at all.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_locks</structname>中对每一个活动可锁对象、请求锁模式和相关进程的组合都有一行。因此，如果多个进程持有或者正在等待一个可锁对象上的锁，同一个可锁对象可能出现很多次。但是，一个当前没有被锁的对象根本不会出现。
  </para>

<!--==========================orignal english content==========================
  <para>
   There are several distinct types of lockable objects:
   whole relations (e.g., tables), individual pages of relations,
   individual tuples of relations,
   transaction IDs (both virtual and permanent IDs),
   and general database objects (identified by class OID and object OID,
   in the same way as in <structname>pg_description</structname> or
   <structname>pg_depend</structname>).  Also, the right to extend a
   relation is represented as a separate lockable object.
   Also, <quote>advisory</quote> locks can be taken on numbers that have
   user-defined meanings.
  </para>
____________________________________________________________________________-->
  <para>
   有多种不同类型的可锁对象：整个关系（如表）、关系的单个页、关系的单个元组、事务ID（包括虚拟和永久ID）和普通数据库对象（由类OID和对象OID标识，和<structname>pg_description</structname>或<structname>pg_depend</structname>中的相同方式）。扩展一个关系的权力也被表示为一个独立的可锁对象。<quote>咨询</quote>锁可以具有用户定义的意义。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_locks</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_locks</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>locktype</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       Type of the lockable object:
       <literal>relation</literal>,
       <literal>extend</literal>,
       <literal>page</literal>,
       <literal>tuple</literal>,
       <literal>transactionid</literal>,
       <literal>virtualxid</literal>,
       <literal>object</literal>,
       <literal>userlock</literal>, or
       <literal>advisory</literal>
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>locktype</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       可锁对象的类型：
       <literal>relation</literal>，
       <literal>extend</literal>，
       <literal>page</literal>，
       <literal>tuple</literal>，
       <literal>transactionid</literal>，
       <literal>virtualxid</literal>，
       <literal>object</literal>，
       <literal>userlock</literal>或
       <literal>advisory</literal>
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>database</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <entry>
       OID of the database in which the lock target exists, or
       zero if the target is a shared object, or
       null if the target is a transaction ID
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>database</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <entry>
       锁目标存在的数据库的OID，如果目标是一个共享对象则为0，如果目标是一个事务ID则为空
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>relation</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       OID of the relation targeted by the lock, or null if the target is not
       a relation or part of a relation
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>relation</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       作为锁目标的关系的OID，如果目标不是一个关系或者只是关系的一部分则此列为空
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>page</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>
       Page number targeted by the lock within the relation,
       or null if the target is not a relation page or tuple
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>page</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>
       作为锁目标的页在关系中的页号，如果目标不是一个关系页或元组则此列为空
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tuple</structfield></entry>
      <entry><type>smallint</type></entry>
      <entry></entry>
      <entry>
       Tuple number targeted by the lock within the page,
       or null if the target is not a tuple
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tuple</structfield></entry>
      <entry><type>smallint</type></entry>
      <entry></entry>
      <entry>
       作为锁目标的元组在页中的元组号，如果目标不是一个元组则此列为空
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>virtualxid</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       Virtual ID of the transaction targeted by the lock,
       or null if the target is not a virtual transaction ID
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>virtualxid</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       作为锁目标的事务虚拟ID，如果目标不是一个虚拟事务ID则此列为空
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>transactionid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       ID of the transaction targeted by the lock,
       or null if the target is not a transaction ID
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>transactionid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       作为锁目标的事务ID，如果目标不是一个事务ID则此列为空ID
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>classid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       OID of the system catalog containing the lock target, or null if the
       target is not a general database object
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>classid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       包含锁目标的系统目录的OID，如果目标不是一个普通数据库对象则此列为空
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>objid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>any OID column</entry>
      <entry>
       OID of the lock target within its system catalog, or null if the
       target is not a general database object
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>objid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>任意OID列</entry>
      <entry>
       锁目标在它的系统目录中的OID，如果目标不是一个普通数据库对象则为空
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>smallint</type></entry>
      <entry></entry>
      <entry>
       Column number targeted by the lock (the
       <structfield>classid</structfield> and <structfield>objid</structfield> refer to the
       table itself),
       or zero if the target is some other general database object,
       or null if the target is not a general database object
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>smallint</type></entry>
      <entry></entry>
      <entry>
       锁的目标列号（<structfield>classid</structfield>和<structfield>objid</structfield>指表本身），如果目标是某种其他普通数据库对象则此列为0，如果目标不是一个普通数据库对象则此列为空
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>virtualtransaction</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       Virtual ID of the transaction that is holding or awaiting this lock
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>virtualtransaction</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       保持这个锁或者正在等待这个锁的事务的虚拟ID
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>pid</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>
       Process ID of the server process holding or awaiting this
       lock, or null if the lock is held by a prepared transaction
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>pid</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>
       保持这个锁或者正在等待这个锁的服务器进程的PID，如果此锁被一个预备事务所持有则此列为空
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>mode</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Name of the lock mode held or desired by this process (see <xref
      linkend="locking-tables"/> and <xref linkend="xact-serializable"/>)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>mode</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>此进程已持有或者希望持有的锁模式（参见<xref linkend="locking-tables"/>和<xref linkend="xact-serializable"/>）</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>granted</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry></entry>
      <entry>True if lock is held, false if lock is awaited</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>granted</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry></entry>
      <entry>如果锁已授予则为真，如果锁被等待则为假</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>fastpath</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry></entry>
      <entry>True if lock was taken via fast path, false if taken via main
       lock table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>fastpath</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry></entry>
      <entry>如果锁通过快速路径获得则为真，通过主锁表获得则为假</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   <structfield>granted</structfield> is true in a row representing a lock
   held by the indicated process.  False indicates that this process is
   currently waiting to acquire this lock, which implies that at least one
   other process is holding or waiting for a conflicting lock mode on the same
   lockable object.  The waiting process will sleep until the other lock is
   released (or a deadlock situation is detected).  A single process can be
   waiting to acquire at most one lock at a time.
  </para>
____________________________________________________________________________-->
  <para>
   一个行的<structfield>granted</structfield>为真表示一个被指定进程持有的锁。为假表示该进程当前正在等待获取这个锁，这意味着至少一个其他进程正持有或等待同一个可锁对象上的一个冲突锁。该等待进程将一直休眠直到其他锁被释放（或者一个死锁状态被检测到）。单个进程在同一时间只能等待最多一个锁。
  </para>

<!--==========================orignal english content==========================
  <para>
   Throughout running a transaction, a server process holds an exclusive lock
   on the transaction's virtual transaction ID.  If a permanent ID is assigned
   to the transaction (which normally happens only if the transaction changes
   the state of the database), it also holds an exclusive lock on the
   transaction's permanent transaction ID until it ends.  When a process finds
   it necessary to wait specifically for another transaction to end, it does
   so by attempting to acquire share lock on the other transaction's ID
   (either virtual or permanent ID depending on the situation). That will
   succeed only when the other transaction terminates and releases its locks.
  </para>
____________________________________________________________________________-->
  <para>
   贯穿一个事务的运行，一个服务器进程在其生存周期内都持有一个在其虚拟事务ID上的排他锁。如果一个永久ID被分配给事务（通常发生在事务改变数据库状态时），它也会持有一个在其永久事务ID上的排他锁直到它结束。当一个事务发现它需要等待另一个事务，它也会尝试获取其他事务ID上的共享锁（不管是虚拟还是永久ID，视情况而定）。这只有当其他进程终止并释放其锁后才会成功。
  </para>

<!--==========================orignal english content==========================
  <para>
   Although tuples are a lockable type of object,
   information about row-level locks is stored on disk, not in memory,
   and therefore row-level locks normally do not appear in this view.
   If a process is waiting for a
   row-level lock, it will usually appear in the view as waiting for the
   permanent transaction ID of the current holder of that row lock.
  </para>
____________________________________________________________________________-->
  <para>
   尽管元组是一种可锁对象，关于行级锁的信息被存储在磁盘而不是内存中，因此行级锁通常不在这个视图中出现。如果一个进程正在等待一个行级锁，它通常在这个视图中出现，并且表示形式为正在等待已持有该行级锁的永久事务ID上的锁。
  </para>

<!--==========================orignal english content==========================
  <para>
   Advisory locks can be acquired on keys consisting of either a single
   <type>bigint</type> value or two integer values.
   A <type>bigint</type> key is displayed with its
   high-order half in the <structfield>classid</structfield> column, its low-order half
   in the <structfield>objid</structfield> column, and <structfield>objsubid</structfield> equal
   to 1. The original <type>bigint</type> value can be reassembled with the
   expression <literal>(classid::bigint &lt;&lt; 32) |
   objid::bigint</literal>. Integer keys are displayed with the
   first key in the
   <structfield>classid</structfield> column, the second key in the <structfield>objid</structfield>
   column, and <structfield>objsubid</structfield> equal to 2.  The actual meaning of
   the keys is up to the user.  Advisory locks are local to each database,
   so the <structfield>database</structfield> column is meaningful for an advisory lock.
  </para>
____________________________________________________________________________-->
  <para>
   咨询锁可以在由一个单一<type>bigint</type>值或两个整形值构成的键上获取。一个<type>bigint</type>键被显示为其高位部分在<structfield>classid</structfield>列中，低位部分在<structfield>objid</structfield>列中，并且<structfield>objsubid</structfield>等于1。原来的<type>bigint</type>值可以使用表达式<literal>(classid::bigint &lt;&lt; 32) | objid::bigint</literal>重组。整形键被显示为第一个键在<structfield>classid</structfield>列中，第二个键在<structfield>objid</structfield>列中，并且<structfield>objsubid</structfield>等于2。键的实际意义由用户决定。咨询锁是每一个数据库的本地锁，所以<structfield>database</structfield>列对于一个咨询锁没有意义。
  </para>

<!--==========================orignal english content==========================
  <para>
   <structname>pg_locks</structname> provides a global view of all locks
   in the database cluster, not only those relevant to the current database.
   Although its <structfield>relation</structfield> column can be joined
   against <structname>pg_class</structname>.<structfield>oid</structfield> to identify locked
   relations, this will only work correctly for relations in the current
   database (those for which the <structfield>database</structfield> column
   is either the current database's OID or zero).
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_locks</structname>提供了一个对于整个数据集簇中所有锁的全局视图，而不仅仅是与当前数据库相关的锁。尽管它的<structfield>relation</structfield>列可以被连接到<structname>pg_class</structname>.<structfield>oid</structfield>来标识被锁关系，但这种方法只有在关系属于当前数据库（<structfield>database</structfield>列是当前数据库OID或者0的锁对应的关系）的情况下才会得到正确的结果。
  </para>

<!--==========================orignal english content==========================
  <para>
   The <structfield>pid</structfield> column can be joined to the
   <structfield>pid</structfield> column of the <link
   linkend="pg-stat-activity-view"><structname>pg_stat_activity</structname></link>
   view to get more
   information on the session holding or awaiting each lock,
   for example
<programlisting>
SELECT * FROM pg_locks pl LEFT JOIN pg_stat_activity psa
    ON pl.pid = psa.pid;
</programlisting>
   Also, if you are using prepared transactions, the
   <structfield>virtualtransaction</structfield> column can be joined to the
   <structfield>transaction</structfield> column of the <link
   linkend="view-pg-prepared-xacts"><structname>pg_prepared_xacts</structname></link>
   view to get more information on prepared transactions that hold locks.
   (A prepared transaction can never be waiting for a lock,
   but it continues to hold the locks it acquired while running.)
   For example:
<programlisting>
SELECT * FROM pg_locks pl LEFT JOIN pg_prepared_xacts ppx
    ON pl.virtualtransaction = '-1/' || ppx.transaction;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   <structfield>pid</structfield>列可以被连接到
   <link
   linkend="pg-stat-activity-view"><structname>pg_stat_activity</structname></link>视图的<structfield>pid</structfield>列来得到持有或等待持有每一个锁的会话的信息。
   例如
<programlisting>
SELECT * FROM pg_locks pl LEFT JOIN pg_stat_activity psa
    ON pl.pid = psa.pid;
</programlisting>
   另外，如果正在使用预备事务，<structfield>virtualtransaction</structfield>列可以被连接到<link
   linkend="view-pg-prepared-xacts"><structname>pg_prepared_xacts</structname></link>视图的<structfield>transaction</structfield>列来得到持有该锁的预备事务的信息（一个预备事务不可能正在等待一个锁，但它在运行中会一直持有已获得的锁）。
   例如：
<programlisting>
SELECT * FROM pg_locks pl LEFT JOIN pg_prepared_xacts ppx
    ON pl.virtualtransaction = '-1/' || ppx.transaction;
</programlisting>
  </para>
  
<!--==========================orignal english content==========================
  <para>
   While it is possible to obtain information about which processes block
   which other processes by joining <structname>pg_locks</structname> against
   itself, this is very difficult to get right in detail.  Such a query would
   have to encode knowledge about which lock modes conflict with which
   others.  Worse, the <structname>pg_locks</structname> view does not expose
   information about which processes are ahead of which others in lock wait
   queues, nor information about which processes are parallel workers running
   on behalf of which other client sessions.  It is better to use
   the <function>pg_blocking_pids()</function> function
   (see <xref linkend="functions-info-session-table"/>) to identify which
   process(es) a waiting process is blocked behind.
  </para>
____________________________________________________________________________-->
  <para>
   虽然通过自连接<structname>pg_locks</structname>可以获得哪些进程阻塞了其他哪些进程的信息，但是很难得到其中的细节。这样一个查询隐藏了关于哪些锁模式与其他哪些锁模式冲突的知识。更糟糕的是，<structname>pg_locks</structname>视图无法给出所等待队列中进程的等待顺序，也无法显示哪些进程是代表其他客户端会话运行的并行工作者。更好的方法是使用<function>pg_blocking_pids()</function>函数（见<xref linkend="functions-info-session-table"/>）来标识一个等待进程是被哪些进程阻塞的。
  </para>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_locks</structname> view displays data from both the
   regular lock manager and the predicate lock manager, which are
   separate systems; in addition, the regular lock manager subdivides its
   locks into regular and <firstterm>fast-path</firstterm> locks.
   This data is not guaranteed to be entirely consistent.
   When the view is queried,
   data on fast-path locks (with <structfield>fastpath</structfield> = <literal>true</literal>)
   is gathered from each backend one at a time, without freezing the state of
   the entire lock manager, so it is possible for locks to be taken or
   released while information is gathered.  Note, however, that these locks are
   known not to conflict with any other lock currently in place.  After
   all backends have been queried for fast-path locks, the remainder of the
   regular lock manager is locked as a unit, and a consistent snapshot of all
   remaining locks is collected as an atomic action.  After unlocking the
   regular lock manager, the predicate lock manager is similarly locked and all
   predicate locks are collected as an atomic action.  Thus, with the exception
   of fast-path locks, each lock manager will deliver a consistent set of
   results, but as we do not lock both lock managers simultaneously, it is
   possible for locks to be taken or released after we interrogate the regular
   lock manager and before we interrogate the predicate lock manager.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_locks</structname>视图显示来自于普通锁管理器和谓词锁管理器的数据，它们是独立的系统。此外，普通锁管理器把它的锁分为普通锁和<firstterm>快速路径</firstterm>锁。这些数据并不被保证是完全一致的。当视图被查询时，快速路径锁上的数据（<structfield>fastpath</structfield> = <literal>true</literal>）会被一次性从每一个后端收集起来，且并不冻结整个锁管理器的状态。因此有可能某些锁在上述信息被收集的过程中被获得或者释放。注意，不管怎样这些锁是已知不会和任何当前正在发生的锁冲突。在所有后端已经查询了快速路径锁后，普通锁管理器的剩余部分被作为一个单元锁住，并且所有剩余锁的一个一致快照被作为一个原子动作收集。在解锁普通锁管理器后，谓词锁管理器也被类似地锁住并且所有谓词锁被作为一个原子动作收集。因此，在快速路径锁这种特殊情况下，每一个锁管理器会传递一个一致的结果组。但由于我们并不会同时锁上两个锁管理器，  在我们询问完普通锁管理器后或者询问谓词锁管理器之前，锁可以被获得或者释放。
  </para>

<!--==========================orignal english content==========================
  <para>
   Locking the regular and/or predicate lock manager could have some
   impact on database performance if this view is very frequently accessed.
   The locks are held only for the minimum amount of time necessary to
   obtain data from the lock managers, but this does not completely eliminate
   the possibility of a performance impact.
  </para>
____________________________________________________________________________-->
  <para>
   如果对此视图频繁地访问，对普通或者谓词锁管理器加锁可能会对数据库性能产生一定影响。虽然这些锁只会在最少的时间内被保持（足以从锁管理器获得数据），但这无法完全消除可能产生的性能影响。
  </para>

 </sect1>

 <sect1 id="view-pg-matviews">
<!--==========================orignal english content==========================
  <title><structname>pg_matviews</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_matviews</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="view-pg-matviews">
   <primary>pg_matviews</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="view-pg-matviews">
   <primary>pg_matviews</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm zone="view-pg-matviews">
   <primary>materialized views</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="view-pg-matviews">
   <primary>materialized views</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The view <structname>pg_matviews</structname> provides access to
   useful information about each materialized view in the database.
  </para>
____________________________________________________________________________-->
  <para>
   视图<structname>pg_matviews</structname>提供了关于数据库中每一个物化视图的信息。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_matviews</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_matviews</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>Name of schema containing materialized view</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>包含物化视图的模式的名字</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>matviewname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Name of materialized view</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>matviewname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>物化视图的名字</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>matviewowner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>Name of materialized view's owner</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>matviewowner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>物化视图拥有者的名字</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tablespace</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.spcname</literal></entry>
      <entry>Name of tablespace containing materialized view (null if default for database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tablespace</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.spcname</literal></entry>
      <entry>包含物化视图的表空间名（如使用数据库默认表空间则为空）</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>hasindexes</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry></entry>
      <entry>True if materialized view has (or recently had) any indexes</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>hasindexes</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry></entry>
      <entry>如果物化视图有（或者最近有过）任何索引，则此列为真</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>ispopulated</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry></entry>
      <entry>True if materialized view is currently populated</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>ispopulated</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry></entry>
      <entry>如果物化视图当前已被填充，则此列为真</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>definition</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Materialized view definition (a reconstructed <command>SELECT</command> query)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>definition</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>物化视图的定义（一个重构的<command>SELECT</command>查询）</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>
 
 <sect1 id="view-pg-policies">
<!--==========================orignal english content==========================
  <title><structname>pg_policies</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_policies</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="view-pg-policies">
   <primary>pg_policies</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="view-pg-policies">
   <primary>pg_policies</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The view <structname>pg_policies</structname> provides access to
   useful information about each row-level security policy in the database.
  </para>
____________________________________________________________________________-->
  <para>
   视图<structname>pg_policies</structname>提供了有关数据库中行级
   安全性策略的信息。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_policies</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_policies</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>Name of schema containing table policy is on</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>包含策略所在表的模式的名称</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Name of table policy is on</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>策略所在表的名称</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>policyname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-policy"><structname>pg_policy</structname></link>.polname</literal></entry>
      <entry>Name of policy</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>policyname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-policy"><structname>pg_policy</structname></link>.polname</literal></entry>
      <entry>策略名称</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>polpermissive</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Is the policy permissive or restrictive?</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>polpermissive</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>策略是宽容性的还是限制性的？</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>roles</structfield></entry>
      <entry><type>name[]</type></entry>
      <entry></entry>
      <entry>The roles to which this policy applies</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>roles</structfield></entry>
      <entry><type>name[]</type></entry>
      <entry></entry>
      <entry>这个策略适用的角色</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>cmd</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>The command type to which the policy is applied</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>cmd</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>这个策略适用的命令类型</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>qual</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>The expression added to the security barrier qualifications for
      queries that this policy applies to</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>qual</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>作为这个策略适用的查询的安全屏障条件增加的表达式</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>with_check</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>The expression added to the WITH CHECK qualifications for
      queries that attempt to add rows to this table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>with_check</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>作为尝试向该表增加行的查询的 WITH CHECK 条件增加的表达式</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-prepared-statements">
<!--==========================orignal english content==========================
  <title><structname>pg_prepared_statements</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_prepared_statements</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="view-pg-prepared-statements">
   <primary>pg_prepared_statements</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="view-pg-prepared-statements">
   <primary>pg_prepared_statements</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_prepared_statements</structname> view displays
   all the prepared statements that are available in the current
   session. See <xref linkend="sql-prepare"/> for more information about prepared
   statements.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_prepared_statements</structname>视图显示在当前会话中可用的所有预备语句。关于预备语句详见<xref linkend="sql-prepare"/>。
  </para>

<!--==========================orignal english content==========================
  <para>
   <structname>pg_prepared_statements</structname> contains one row
   for each prepared statement. Rows are added to the view when a new
   prepared statement is created and removed when a prepared statement
   is released (for example, via the <xref linkend="sql-deallocate"/> command).
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_prepared_statements</structname>为每一个预备语句包含一行。当一个新的预备语句被创建时在此视图中会增加一行，反之当一个预备语句被释放时在此视图中会删除一行（例如，通过<xref linkend="sql-deallocate"/>命令）。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_prepared_statements</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_prepared_statements</structname>的列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名字</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <entry>
       The identifier of the prepared statement
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <entry>
       预备语句的标识符
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>statement</structfield></entry>
      <entry><type>text</type></entry>
      <entry>
       The query string submitted by the client to create this
       prepared statement. For prepared statements created via SQL,
       this is the <command>PREPARE</command> statement submitted by
       the client. For prepared statements created via the
       frontend/backend protocol, this is the text of the prepared
       statement itself.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>statement</structfield></entry>
      <entry><type>text</type></entry>
      <entry>
       客户端提交用于创建此预备语句的查询语句。对于通过SQL创建的预备语句，这里是由客户端提交的<command>PREPARE</command>语句。对于通过前端/后端协议创建的预备语句，这里是预备语句本身的文本。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>prepare_time</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry>
       The time at which the prepared statement was created
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>prepare_time</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry>
       预备语句被创建的时间
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>parameter_types</structfield></entry>
      <entry><type>regtype[]</type></entry>
      <entry>
       The expected parameter types for the prepared statement in the
       form of an array of <type>regtype</type>. The OID corresponding
       to an element of this array can be obtained by casting the
       <type>regtype</type> value to <type>oid</type>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>parameter_types</structfield></entry>
      <entry><type>regtype[]</type></entry>
      <entry>
       预备语句期望的参数类型，以一个<type>regtype</type>数组的形式。这个数组中一个元素所对应的OID可通过将<type>regtype</type>值转换为<type>oid</type>获得。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>from_sql</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>
       <literal>true</literal> if the prepared statement was created
       via the <command>PREPARE</command> SQL command;
       <literal>false</literal> if the statement was prepared via the
       frontend/backend protocol
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>from_sql</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>
       如果预备语句通过SQL命令<command>PREPARE</command>创建，则为<literal>true</literal>；如果预备语句通过前端/后端协议创建，则为<literal>false</literal>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_prepared_statements</structname> view is read only.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_prepared_statements</structname>视图为只读。
  </para>
 </sect1>

 <sect1 id="view-pg-prepared-xacts">
<!--==========================orignal english content==========================
  <title><structname>pg_prepared_xacts</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_prepared_xacts</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="view-pg-prepared-xacts">
   <primary>pg_prepared_xacts</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="view-pg-prepared-xacts">
   <primary>pg_prepared_xacts</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The view <structname>pg_prepared_xacts</structname> displays
   information about transactions that are currently prepared for two-phase
   commit (see <xref linkend="sql-prepare-transaction"/> for details).
  </para>
____________________________________________________________________________-->
  <para>
   视图<structname>pg_prepared_xacts</structname>显示关于两阶段提交（详见<xref linkend="sql-prepare-transaction"/>）的当前准备好事务的信息。
  </para>

<!--==========================orignal english content==========================
  <para>
   <structname>pg_prepared_xacts</structname> contains one row per prepared
   transaction.  An entry is removed when the transaction is committed or
   rolled back.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_prepared_xacts</structname>为每一个预备事务包含一行。当事务被提交或回滚时，相应的项将被移除。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_prepared_xacts</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_prepared_xacts</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>transaction</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       Numeric transaction identifier of the prepared transaction
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>transaction</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       预备事务的数字事务标识符
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>gid</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       Global transaction identifier that was assigned to the transaction
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>gid</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       分配给事务的全局标识符
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>prepared</structfield></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry></entry>
      <entry>
       Time at which the transaction was prepared for commit
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>prepared</structfield></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry></entry>
      <entry>
       此事务为提交准备好的时间
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>owner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>
       Name of the user that executed the transaction
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>owner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>
       执行此事务的用户名
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>database</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.datname</literal></entry>
      <entry>
       Name of the database in which the transaction was executed
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>database</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.datname</literal></entry>
      <entry>
       执行此事务所在数据库的名字
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   When the <structname>pg_prepared_xacts</structname> view is accessed, the
   internal transaction manager data structures are momentarily locked, and
   a copy is made for the view to display.  This ensures that the
   view produces a consistent set of results, while not blocking
   normal operations longer than necessary.  Nonetheless
   there could be some impact on database performance if this view is
   frequently accessed.
  </para>
____________________________________________________________________________-->
  <para>
   当<structname>pg_prepared_xacts</structname>视图被访问时，内部事务管理器数据结构被暂时地锁住，并为视图的显示产生一个副本。这确保了视图中是一组一致的结果，并且不会阻塞普通操作。不管怎样，当此视图被频繁访问时，会对数据库性能有所影响。
  </para>

 </sect1>

 <sect1 id="view-pg-publication-tables">
<!--==========================orignal english content==========================
  <title><structname>pg_publication_tables</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_publication_tables</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="view-pg-publication-tables">
   <primary>pg_publication_tables</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="view-pg-publication-tables">
   <primary>pg_publication_tables</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The view <structname>pg_publication_tables</structname> provides
   information about the mapping between publications and the tables they
   contain.  Unlike the underlying
   catalog <structname>pg_publication_rel</structname>, this view expands
   publications defined as <literal>FOR ALL TABLES</literal>, so for such
   publications there will be a row for each eligible table.
  </para>
____________________________________________________________________________-->
  <para>
   视图<structname>pg_publication_tables</structname>提供publication与其所包含的表之间的映射信息。和底层的目录<structname>pg_publication_rel</structname>不同，这个视图展开了定义为<literal>FOR ALL TABLES</literal>的publication，这样对这类publication来说，每一个合格的表都有一行。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_publication_tables</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_publication_tables</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>pubname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-publication"><structname>pg_publication</structname></link>.pubname</literal></entry>
      <entry>Name of publication</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>pubname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-publication"><structname>pg_publication</structname></link>.pubname</literal></entry>
      <entry>publication名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>Name of schema containing table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>包含表的方案名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Name of table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>表名</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>
 
 <sect1 id="view-pg-replication-origin-status">
<!--==========================orignal english content==========================
  <title><structname>pg_replication_origin_status</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_replication_origin_status</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="view-pg-replication-origin-status">
   <primary>pg_replication_origin_status</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="view-pg-replication-origin-status">
   <primary>pg_replication_origin_status</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_replication_origin_status</structname> view
   contains information about how far replay for a certain origin has
   progressed.  For more on replication origins
   see <xref linkend="replication-origins"/>.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_replication_origin_status</structname>视图包含有关一个特定源已经重放了多少的信息。更多有关复制源的内容请见<xref linkend="replication-origins"/>。
  </para>

  <table>

<!--==========================orignal english content==========================
   <title><structname>pg_replication_origin_status</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_replication_origin_status</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>local_id</structfield></entry>
      <entry><type>Oid</type></entry>
      <entry><literal><link linkend="catalog-pg-replication-origin"><structname>pg_replication_origin</structname></link>.roident</literal></entry>
      <entry>internal node identifier</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>local_id</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-replication-origin"><structname>pg_replication_origin</structname></link>.roident</literal></entry>
      <entry>内部的节点标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>external_id</structfield></entry>
      <entry><type>text</type></entry>
      <entry><literal><link linkend="catalog-pg-replication-origin"><structname>pg_replication_origin</structname></link>.roname</literal></entry>
      <entry>external node identifier</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>external_id</structfield></entry>
      <entry><type>text</type></entry>
      <entry><literal><link linkend="catalog-pg-replication-origin"><structname>pg_replication_origin</structname></link>.roname</literal></entry>
      <entry>外部的节点标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>remote_lsn</structfield></entry>
      <entry><type>pg_lsn</type></entry>
      <entry></entry>
      <entry>The origin node's LSN up to which data has been replicated.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>remote_lsn</structfield></entry>
      <entry><type>pg_lsn</type></entry>
      <entry></entry>
      <entry>源节点的 LSN，到这个位置的数据都已经被复制。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>local_lsn</structfield></entry>
      <entry><type>pg_lsn</type></entry>
      <entry></entry>
      <entry>
       This node's LSN at which <literal>remote_lsn</literal> has
       been replicated. Used to flush commit records before persisting
       data to disk when using asynchronous commits.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>local_lsn</structfield></entry>
      <entry><type>pg_lsn</type></entry>
      <entry></entry>
      <entry>
       这个节点的 LSN，<literal>remote_lsn</literal>已经被复制到这里。使用异步提交时，在将数据持久化到磁盘前用它来刷入提交记录。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="view-pg-replication-slots">
<!--==========================orignal english content==========================
  <title><structname>pg_replication_slots</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_replication_slots</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="view-pg-replication-slots">
   <primary>pg_replication_slots</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="view-pg-replication-slots">
   <primary>pg_replication_slots</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_replication_slots</structname> view provides a listing
   of all replication slots that currently exist on the database cluster,
   along with their current state.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_replication_slots</structname>视图提供了当前存在于数据库集簇上的所有复制槽的列表，其中也包括复制槽的当前状态。
  </para>

<!--==========================orignal english content==========================
  <para>
   For more on replication slots,
   see <xref linkend="streaming-replication-slots"/> and <xref linkend="logicaldecoding"/>.
  </para>
____________________________________________________________________________-->
  <para>
   更多关于复制槽的信息，请见<xref linkend="streaming-replication-slots"/>和<xref linkend="logicaldecoding"/>。
  </para>

  <table>

<!--==========================orignal english content==========================
   <title><structname>pg_replication_slots</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_replication_slots</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>slot_name</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>A unique, cluster-wide identifier for the replication slot</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>slot_name</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>一个唯一的、集簇范围内的复制槽标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>plugin</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>The base name of the shared object containing the output plugin this logical slot is using, or null for physical slots.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>plugin</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>包含这个逻辑槽正在使用的输出插件的共享对象基础名称，这个列对于物理槽为空值。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>slot_type</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>The slot type - <literal>physical</literal> or <literal>logical</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>slot_type</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>槽类型 - <literal>physical</literal>（物理）或者<literal>logical</literal>（逻辑）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>datoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <entry>The OID of the database this slot is associated with, or
      null. Only logical slots have an associated database.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>datoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <entry>与这个槽相关的数据库的OID，或者为空值。只有逻辑槽具有相关的数据库。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>database</structfield></entry>
      <entry><type>text</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.datname</literal></entry>
      <entry>The name of the database this slot is associated with, or
      null. Only logical slots have an associated database.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>database</structfield></entry>
      <entry><type>text</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.datname</literal></entry>
      <entry>与这个槽相关的数据库的名称，或者为空值。只有逻辑槽具有相关的数据库。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>temporary</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry></entry>
      <entry>True if this is a temporary replication slot. Temporary slots are
      not saved to disk and are automatically dropped on error or when
      the session has finished.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>temporary</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry></entry>
      <entry>如果这是一个临时复制槽则为真。临时槽不会被保存在磁盘上并且会在出错或会话结束时自动被删除掉。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>active</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry></entry>
      <entry>True if this slot is currently actively being used</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>active</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry></entry>
      <entry>如果这个槽当前正在被使用则为真</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>active_pid</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>The process ID of the session using this slot if the slot
       is currently actively being used. <literal>NULL</literal> if
       inactive.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>active_pid</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>如果槽当前正在被使用，则记录使用这个槽的会话的进程 ID。如果槽没有被使用则为<literal>NULL</literal>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>xmin</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>The oldest transaction that this slot needs the database to
      retain.  <literal>VACUUM</literal> cannot remove tuples deleted
      by any later transaction.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>xmin</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>这个槽要需要数据库保留的最旧事务。<literal>VACUUM</literal>不能移除被其后续事务删除的元组。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>catalog_xmin</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>The oldest transaction affecting the system catalogs that this
      slot needs the database to retain.  <literal>VACUUM</literal> cannot
      remove catalog tuples deleted by any later transaction.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>catalog_xmin</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>这个槽要需要数据库保留的影响系统目录的最旧事务。<literal>VACUUM</literal>不能移除被其后续事务删除的目录元组。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>restart_lsn</structfield></entry>
      <entry><type>pg_lsn</type></entry>
      <entry></entry>
      <entry>The address (<literal>LSN</literal>) of oldest WAL which still
      might be required by the consumer of this slot and thus won't be
      automatically removed during checkpoints.  <literal>NULL</literal>
      if the <literal>LSN</literal> of this slot has never been reserved.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>restart_lsn</structfield></entry>
      <entry><type>pg_lsn</type></entry>
      <entry></entry>
      <entry>可能仍被这个槽的消费者要求的最旧WAL地址（<literal>LSN</literal>），并且因此不会在检查点期间自动被移除。如果这个槽的<literal>LSN</literal>从未被保留过，则为<literal>NULL</literal>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>confirmed_flush_lsn</structfield></entry>
      <entry><type>pg_lsn</type></entry>
      <entry></entry>
      <entry>The address (<literal>LSN</literal>) up to which the logical
      slot's consumer has confirmed receiving data. Data older than this is
      not available anymore. <literal>NULL</literal> for physical slots.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>confirmed_flush_lsn</structfield></entry>
      <entry><type>pg_lsn</type></entry>
      <entry></entry>
      <entry>代表逻辑槽的消费者已经确认接收数据到什么位置的地址（<literal>LSN</literal>）。比这个地址更旧的数据已经不再可用。对于物理槽这里是<literal>NULL</literal>。
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="view-pg-roles">
<!--==========================orignal english content==========================
  <title><structname>pg_roles</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_roles</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="view-pg-roles">
   <primary>pg_roles</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="view-pg-roles">
   <primary>pg_roles</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The view <structname>pg_roles</structname> provides access to
   information about database roles.  This is simply a publicly
   readable view of
   <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>
   that blanks out the password field.
  </para>
____________________________________________________________________________-->
  <para>
   视图<structname>pg_roles</structname>提供了关于数据库角色的信息。这是<link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>的一个公共可读视图，它隐去了口令域。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_roles</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_roles</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>rolname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Role name</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>rolname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>角色名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>rolsuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Role has superuser privileges</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>rolsuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>角色是否具有超级用户权限？</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>rolinherit</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Role automatically inherits privileges of roles it is a
       member of</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>rolinherit</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>如果此角色是另一个角色的成员，角色是否能自动继承另一个角色的权限？</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>rolcreaterole</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Role can create more roles</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>rolcreaterole</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>角色能否创建更多角色？</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>rolcreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Role can create databases</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>rolcreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>角色能否创建数据库？</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>rolcanlogin</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Role can log in. That is, this role can be given as the initial
       session authorization identifier
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>rolcanlogin</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       角色是否能登录？即此角色能否被作为初始会话授权标识符？
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>rolreplication</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Role is a replication role. A replication role can initiate replication
       connections and create and drop replication slots.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>rolreplication</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       角色是一个复制角色。复制角色可以开启复制连接并且创建和删除复制槽。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>rolconnlimit</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       For roles that can log in, this sets maximum number of concurrent
       connections this role can make.  -1 means no limit.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>rolconnlimit</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       对于一个可登录的角色，这里设置角色可以发起的最大并发连接数。-1表示无限制。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>rolpassword</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Not the password (always reads as <literal>********</literal>)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>rolpassword</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>不是口令（看起来是<literal>********</literal>）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>rolvaliduntil</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry></entry>
      <entry>Password expiry time (only used for password authentication);
       null if no expiration</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>rolvaliduntil</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry></entry>
      <entry>口令失效时间（只用于口令认证），如果永不失效则为空</entry>
     </row>
     
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>rolbypassrls</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Role bypasses every row level security policy, see
       <xref linkend="ddl-rowsecurity"/> for more information.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>rolbypassrls</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       绕过每一条行级安全性策略的角色，详见<xref linkend="ddl-rowsecurity"/>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>rolconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>Role-specific defaults for run-time configuration variables</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>rolconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>运行时配置变量的角色特定默认值</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>ID of role</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>角色的ID</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-rules">
<!--==========================orignal english content==========================
  <title><structname>pg_rules</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_rules</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="view-pg-rules">
   <primary>pg_rules</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="view-pg-rules">
   <primary>pg_rules</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The view <structname>pg_rules</structname> provides access to
   useful information about query rewrite rules.
  </para>
____________________________________________________________________________-->
  <para>
   视图<structname>pg_rules</structname>提供对查询重写规则的信息访问。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_rules</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_rules</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>Name of schema containing table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>包含表的模式名</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Name of table the rule is for</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>规则适用的表名</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>rulename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-rewrite"><structname>pg_rewrite</structname></link>.rulename</literal></entry>
      <entry>Name of rule</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>rulename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-rewrite"><structname>pg_rewrite</structname></link>.rulename</literal></entry>
      <entry>规则名</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>definition</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Rule definition (a reconstructed creation command)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>definition</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>规则定义（创建命令的重构）</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_rules</structname> view excludes the <literal>ON SELECT</literal> rules
   of views and materialized views; those can be seen in
   <structname>pg_views</structname> and <structname>pg_matviews</structname>.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_rules</structname>视图排除了视图和物化视图的<literal>ON SELECT</literal>规则，它们可以在<structname>pg_views</structname>和<structname>pg_matviews</structname>中找到。
  </para>

 </sect1>

 <sect1 id="view-pg-seclabels">
<!--==========================orignal english content==========================
  <title><structname>pg_seclabels</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_seclabels</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="view-pg-seclabels">
   <primary>pg_seclabels</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="view-pg-seclabels">
   <primary>pg_seclabels</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The view <structname>pg_seclabels</structname> provides information about
   security labels.  It as an easier-to-query version of the
   <link linkend="catalog-pg-seclabel"><structname>pg_seclabel</structname></link> catalog.
  </para>
____________________________________________________________________________-->
  <para>
   视图<structname>pg_seclabels</structname>提供对安全标签的信息访问。它是<link linkend="catalog-pg-seclabel"><structname>pg_seclabel</structname></link>目录的一个便于查询的版本。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_seclabels</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_seclabels</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>any OID column</entry>
      <entry>The OID of the object this security label pertains to</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>任意OID列</entry>
      <entry>安全标签所属对象的OID</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The OID of the system catalog this object appears in</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>对象出现的系统目录的OID</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       For a security label on a table column, this is the column number (the
       <structfield>objoid</structfield> and <structfield>classoid</structfield> refer to
       the table itself).  For all other object types, this column is
       zero.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       对于一个表列上的安全标签，这里是列号（<structfield>objoid</structfield>和<structfield>classoid</structfield>指表本身）。对于所有其他对象类型，此列为0。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>objtype</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
         The type of object to which this label applies, as text.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>objtype</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
         此标签应用的对象类型，以文本方式。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>objnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       The OID of the namespace for this object, if applicable;
       otherwise NULL.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>objnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       如果适用，为此对象的名字空间的OID；否则为空。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>objname</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       The name of the object to which this label applies, as text.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>objname</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       此标签应用的对象名，以文本形式。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>provider</structfield></entry>
      <entry><type>text</type></entry>
      <entry><literal><link linkend="catalog-pg-seclabel"><structname>pg_seclabel</structname></link>.provider</literal></entry>
      <entry>The label provider associated with this label.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>provider</structfield></entry>
      <entry><type>text</type></entry>
      <entry><literal><link linkend="catalog-pg-seclabel"><structname>pg_seclabel</structname></link>.provider</literal></entry>
      <entry>与此标签相关的标签提供者。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>label</structfield></entry>
      <entry><type>text</type></entry>
      <entry><literal><link linkend="catalog-pg-seclabel"><structname>pg_seclabel</structname></link>.label</literal></entry>
      <entry>The security label applied to this object.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>label</structfield></entry>
      <entry><type>text</type></entry>
      <entry><literal><link linkend="catalog-pg-seclabel"><structname>pg_seclabel</structname></link>.label</literal></entry>
      <entry>应用于此对象的安全标签。</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="view-pg-sequences">
<!--==========================orignal english content==========================
  <title><structname>pg_sequences</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_sequences</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="view-pg-sequences">
   <primary>pg_sequences</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="view-pg-sequences">
   <primary>pg_sequences</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The view <structname>pg_sequences</structname> provides access to
   useful information about each sequence in the database.
  </para>
____________________________________________________________________________-->
  <para>
   视图<structname>pg_sequences</structname>提供对数据库中每个序列的信息的访问。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_sequences</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_sequences</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>Name of schema containing sequence</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>包含序列的方案名</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>sequencename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Name of sequence</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>sequencename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>序列的名称</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>sequenceowner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>Name of sequence's owner</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>sequenceowner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>序列的拥有者的名称</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>data_type</structfield></entry>
      <entry><type>regtype</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Data type of the sequence</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>data_type</structfield></entry>
      <entry><type>regtype</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>序列的数据类型</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>start_value</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>Start value of the sequence</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>start_value</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>序列的起始值</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>min_value</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>Minimum value of the sequence</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>min_value</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>序列的最小值</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>max_value</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>Maximum value of the sequence</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>max_value</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>序列的最大值</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>increment_by</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>Increment value of the sequence</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>increment_by</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>序列的增量值</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>cycle</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry></entry>
      <entry>Whether the sequence cycles</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>cycle</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry></entry>
      <entry>序列是否循环</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>cache_size</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>Cache size of the sequence</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>cache_size</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>序列的缓冲尺寸</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>last_value</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>The last sequence value written to disk.  If caching is used,
       this value can be greater than the last value handed out from the
       sequence.  Null if the sequence has not been read from yet.  Also, if
       the current user does not have <literal>USAGE</literal>
       or <literal>SELECT</literal> privilege on the sequence, the value is
       null.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>last_value</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>最后一个被写入到磁盘的序列值。如果使用了缓冲，这个值可能比从序列中取出的最后一个值大。如果还没有从该序列读取过，则为空。此外，如果当前用户没有该序列上的<literal>USAGE</literal>或<literal>SELECT</literal>特权，则这个值为空。</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="view-pg-settings">
<!--==========================orignal english content==========================
  <title><structname>pg_settings</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_settings</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="view-pg-settings">
   <primary>pg_settings</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="view-pg-settings">
   <primary>pg_settings</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The view <structname>pg_settings</structname> provides access to
   run-time parameters of the server.  It is essentially an alternative
   interface to the <xref linkend="sql-show"/>
   and <xref linkend="sql-set"/> commands.
   It also provides access to some facts about each parameter that are
   not directly available from <command>SHOW</command>, such as minimum and
   maximum values.
  </para>
____________________________________________________________________________-->
  <para>
   视图<structname>pg_settings</structname>提供了对服务器上运行时参数的访问。它本质上是<xref linkend="sql-show"/>和<xref linkend="sql-set"/>命令的可替换接口。它还提供了<command>SHOW</command>不能提供的关于每一个参数的一些现实，例如最大值和最小值。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_settings</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_settings</structname>的列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名字</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Run-time configuration parameter name</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <entry>运行时配置参数名</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>setting</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Current value of the parameter</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>setting</structfield></entry>
      <entry><type>text</type></entry>
      <entry>参数的当前值</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>unit</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Implicit unit of the parameter</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>unit</structfield></entry>
      <entry><type>text</type></entry>
      <entry>参数的隐式单元</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>category</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Logical group of the parameter</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>category</structfield></entry>
      <entry><type>text</type></entry>
      <entry>参数的逻辑组</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>short_desc</structfield></entry>
      <entry><type>text</type></entry>
      <entry>A brief description of the parameter</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>short_desc</structfield></entry>
      <entry><type>text</type></entry>
      <entry>参数的简短描述</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>extra_desc</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Additional, more detailed, description of the parameter</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>extra_desc</structfield></entry>
      <entry><type>text</type></entry>
      <entry>附加的参数的详细描述</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>context</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Context required to set the parameter's value (see below)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>context</structfield></entry>
      <entry><type>text</type></entry>
      <entry>要求设置此参数值的上下文</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>vartype</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Parameter type (<literal>bool</literal>, <literal>enum</literal>,
       <literal>integer</literal>, <literal>real</literal>, or <literal>string</literal>)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>vartype</structfield></entry>
      <entry><type>text</type></entry>
      <entry>参数类型（<literal>bool</literal>、<literal>enum</literal>、
       <literal>integer</literal>、<literal>real</literal>或<literal>string</literal>）
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>source</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Source of the current parameter value</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>source</structfield></entry>
      <entry><type>text</type></entry>
      <entry>当前参数值的来源</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>min_val</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Minimum allowed value of the parameter (null for non-numeric
      values)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>min_val</structfield></entry>
      <entry><type>text</type></entry>
      <entry>参数的最小允许值（对非数字值为空）</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>max_val</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Maximum allowed value of the parameter (null for non-numeric
      values)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>max_val</structfield></entry>
      <entry><type>text</type></entry>
      <entry>参数的最大允许值（对非数字值为空）</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>enumvals</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry>Allowed values of an enum parameter (null for non-enum
      values)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>enumvals</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry>一个枚举参数的允许值（对非数字值为空）</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>boot_val</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Parameter value assumed at server startup if the parameter is
      not otherwise set</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>boot_val</structfield></entry>
      <entry><type>text</type></entry>
      <entry>如果参数没有被别的其他设置，此列为在服务器启动时设定的参数值</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>reset_val</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Value that <command>RESET</command> would reset the parameter to
      in the current session</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>reset_val</structfield></entry>
      <entry><type>text</type></entry>
      <entry>在当前会话中，<command>RESET</command>将会设置的参数值</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>sourcefile</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Configuration file the current value was set in (null for
      values set from sources other than configuration files, or when
      examined by a user who is neither a superuser or a member of
      <literal>pg_read_all_settings</literal>); helpful when using
      <literal>include</literal> directives in configuration files</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>sourcefile</structfield></entry>
      <entry><type>text</type></entry>
      <entry>当前值被设置的配置文件（空值表示从非配置文件的其他来源设置，由不是超级用户也不是<literal>pg_read_all_settings</literal>成员的用户检查时也为空值），在配置文件中使用<literal>include</literal>指令时有用</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>sourceline</structfield></entry>
      <entry><type>integer</type></entry>
      <entry>Line number within the configuration file the current value was
      set at (null for values set from sources other than configuration files,
      or when examined by a user who is neither a superuser or a member of
      <literal>pg_read_all_settings</literal>).
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>sourceline</structfield></entry>
      <entry><type>integer</type></entry>
      <entry>当前值被设置的配置文件中的行号（空值表示从非配置文件的其他来源设置，由不是超级用户也不是<literal>pg_read_all_settings</literal>成员的用户检查时也为空值）。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>pending_restart</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal>true</literal> if the value has been changed in the
      configuration file but needs a restart; or <literal>false</literal>
      otherwise.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>pending_restart</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>如果配置文件中修改了该值但需要重启，则为<literal>true</literal>，
      否则为<literal>false</literal>。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   There are several possible values of <structfield>context</structfield>.
   In order of decreasing difficulty of changing the setting, they are:
  </para>
____________________________________________________________________________-->
  <para>
   对于<structfield>context</structfield>有多种可能的取值。为了降低改变设置的难度，它们是：
  </para>

  <variablelist>
   <varlistentry>
    <!-- PGC_INTERNAL -->
<!--==========================orignal english content==========================
    <term><literal>internal</literal></term>
____________________________________________________________________________-->
    <term><literal>internal</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      These settings cannot be changed directly; they reflect internally
      determined values.  Some of them may be adjustable by rebuilding the
      server with different configuration options, or by changing options
      supplied to <command>initdb</command>.
     </para>
____________________________________________________________________________-->
     <para>
      这些设置不能被直接修改，它们反映了内部决定的值。某些可能在使用不同配置选项重建系统时或者改变<command>initdb</command>的选项时可以调整。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <!-- PGC_POSTMASTER -->
<!--==========================orignal english content==========================
    <term><literal>postmaster</literal></term>
____________________________________________________________________________-->
    <term><literal>postmaster</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      These settings can only be applied when the server starts, so any change
      requires restarting the server.  Values for these settings are typically
      stored in the <filename>postgresql.conf</filename> file, or passed on
      the command line when starting the server.  Of course, settings with any
      of the lower <structfield>context</structfield> types can also be
      set at server start time.
     </para>
____________________________________________________________________________-->
     <para>
      这些设置只能在服务器启动时应用，因此任何修改都需要重启服务器。这些设置的值通常都存储在<filename>postgresql.conf</filename>文件中，或者在启动服务器时通过命令行传递。当然，具有更低<structfield>context</structfield>类型的设置也可以在服务器启动时间被设置。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <!-- PGC_SIGHUP -->
<!--==========================orignal english content==========================
    <term><literal>sighup</literal></term>
____________________________________________________________________________-->
    <term><literal>sighup</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Changes to these settings can be made in
      <filename>postgresql.conf</filename> without restarting the server.
      Send a <systemitem>SIGHUP</systemitem> signal to the postmaster to
      cause it to re-read <filename>postgresql.conf</filename> and apply
      the changes.  The postmaster will also forward the
      <systemitem>SIGHUP</systemitem> signal to its child processes so that
      they all pick up the new value.
     </para>
____________________________________________________________________________-->
     <para>
      对于这些设置的修改可以在<filename>postgresql.conf</filename>中完成并且不需要重启服务器。发送一个<systemitem>SIGHUP</systemitem>信号给postmaster会导致它重新读取<filename>postgresql.conf</filename>并应用修改。Postmaster将会把<systemitem>SIGHUP</systemitem>信号传递给它的孩子进程，这样它们也会获得新的值。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <!-- PGC_SU_BACKEND -->
<!--==========================orignal english content==========================
    <term><literal>superuser-backend</literal></term>
____________________________________________________________________________-->
    <term><literal>superuser-backend</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Changes to these settings can be made in
      <filename>postgresql.conf</filename> without restarting the server.
      They can also be set for a particular session in the connection request
      packet (for example, via <application>libpq</application>'s <literal>PGOPTIONS</literal>
      environment variable), but only if the connecting user is a superuser.
      However, these settings never change in a session after it is started.
      If you change them in <filename>postgresql.conf</filename>, send a
      <systemitem>SIGHUP</systemitem> signal to the postmaster to cause it to
      re-read <filename>postgresql.conf</filename>.  The new values will only
      affect subsequently-launched sessions.
     </para>
____________________________________________________________________________-->
     <para>
      对于这些设置的更改可以在<filename>postgresql.conf</filename>中进
      行而无需重启服务器。也可以在连接请求包（例如通过<application>libpq</application>
      的<literal>PGOPTIONS</literal>环境变量）中为一个特定的会话设定它们，但是
      只有在连接用户是超级用户时才能这样做。如果，在会话启动后这些设置就
      不会改变。如果你在<filename>postgresql.conf</filename>改变了它们，
      向 postmaster 发送一个<systemitem>SIGHUP</systemitem>信号让
      postmaster 重新读取<filename>postgresql.conf</filename>。新的值将
      只会影响后续启动的会话。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <!-- PGC_BACKEND -->
<!--==========================orignal english content==========================
    <term><literal>backend</literal></term>
____________________________________________________________________________-->
    <term><literal>backend</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Changes to these settings can be made in
      <filename>postgresql.conf</filename> without restarting the server.
      They can also be set for a particular session in the connection request
      packet (for example, via <application>libpq</application>'s <literal>PGOPTIONS</literal>
      environment variable); any user can make such a change for their session.
      However, these settings never change in a session after it is started.
      If you change them in <filename>postgresql.conf</filename>, send a
      <systemitem>SIGHUP</systemitem> signal to the postmaster to cause it to
      re-read <filename>postgresql.conf</filename>.  The new values will only
      affect subsequently-launched sessions.
     </para>
____________________________________________________________________________-->
     <para>
      对于这些设置的修改可以在<filename>postgresql.conf</filename>中完成并且不需要重启服务器。它们也可以在一个连接请求包（例如，通过<application>libpq</application>的<literal>PGOPTIONS</literal>环境变量）中为一个特定会话设置 ，任何用户都可以为这个会话做这种修改。然而，这些设置在会话启动后永不变化。如果你在<filename>postgresql.conf</filename>中修改它们，可以向postmaster发送一个<systemitem>SIGHUP</systemitem>信号让它重读<filename>postgresql.conf</filename>。新值只会影响后续启动的会话。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <!-- PGC_SUSET -->
<!--==========================orignal english content==========================
    <term><literal>superuser</literal></term>
____________________________________________________________________________-->
    <term><literal>superuser</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      These settings can be set from <filename>postgresql.conf</filename>,
      or within a session via the <command>SET</command> command; but only superusers
      can change them via <command>SET</command>.  Changes in
      <filename>postgresql.conf</filename> will affect existing sessions
      only if no session-local value has been established with <command>SET</command>.
     </para>
____________________________________________________________________________-->
     <para>
      这些设置可以从<filename>postgresql.conf</filename>设置，或者在会话中用<command>SET</command>命令设置。仅当没有通过<command>SET</command>设置会话本地值时，<filename>postgresql.conf</filename>中的改变才会影响现有的会话。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <!-- PGC_USERSET -->
<!--==========================orignal english content==========================
    <term><literal>user</literal></term>
____________________________________________________________________________-->
    <term><literal>user</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      These settings can be set from <filename>postgresql.conf</filename>,
      or within a session via the <command>SET</command> command.  Any user is
      allowed to change their session-local value.  Changes in
      <filename>postgresql.conf</filename> will affect existing sessions
      only if no session-local value has been established with <command>SET</command>.
     </para>
____________________________________________________________________________-->
     <para>
      这些设置可以从<filename>postgresql.conf</filename>设置，或者在会话中用<command>SET</command>命令设置。任何用户都被允许修改它们的会话本地值。仅当没有通过<command>SET</command>设置会话本地值时，<filename>postgresql.conf</filename>中的改变才会影响现有的会话。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

<!--==========================orignal english content==========================
  <para>
   See <xref linkend="config-setting"/> for more information about the various
   ways to change these parameters.
  </para>
____________________________________________________________________________-->
  <para>
   更多关于修改这些参数的方法的信息请见<xref linkend="config-setting"/>。
  </para>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_settings</structname> view cannot be inserted into or
   deleted from, but it can be updated.  An <command>UPDATE</command> applied
   to a row of <structname>pg_settings</structname> is equivalent to executing
   the <xref linkend="sql-set"/> command on that named
   parameter. The change only affects the value used by the current
   session. If an <command>UPDATE</command> is issued within a transaction
   that is later aborted, the effects of the <command>UPDATE</command> command
   disappear when the transaction is rolled back. Once the surrounding
   transaction is committed, the effects will persist until the end of the
   session, unless overridden by another <command>UPDATE</command> or
   <command>SET</command>.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_settings</structname>视图不能被插入或者从中删除，但是它可以被更新。在<structname>pg_settings</structname>的一行上的一个<command>UPDATE</command>等价于在该参数上执行一个<xref linkend="sql-set"/>命令。修改将只会影响当前会话使用的值。如果一个<command>UPDATE</command>在一个后来中断的事务中被发出，<command>UPDATE</command>命令的效果也会随着事务的回滚而消失。一旦所在的事务被提交，效果将一直保持到会话结束，除非有其他<command>UPDATE</command>或   <command>SET</command>重新修改它。
  </para>

 </sect1>

 <sect1 id="view-pg-shadow">
<!--==========================orignal english content==========================
  <title><structname>pg_shadow</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_shadow</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="view-pg-shadow">
   <primary>pg_shadow</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="view-pg-shadow">
   <primary>pg_shadow</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The view <structname>pg_shadow</structname> exists for backwards
   compatibility: it emulates a catalog that existed in
   <productname>PostgreSQL</productname> before version 8.1.
   It shows properties of all roles that are marked as
   <structfield>rolcanlogin</structfield> in
   <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.
  </para>
____________________________________________________________________________-->
  <para>
   视图<structname>pg_shadow</structname>的存在是为了向后兼容：它模拟了在<productname>PostgreSQL</productname>版本8.1之前的一个系统目录。它显示<link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>中所有被标记为<structfield>rolcanlogin</structfield>的角色的属性。
  </para>

<!--==========================orignal english content==========================
  <para>
   The name stems from the fact that this table
   should not be readable by the public since it contains passwords.
   <link linkend="view-pg-user"><structname>pg_user</structname></link>
   is a publicly readable view on
   <structname>pg_shadow</structname> that blanks out the password field.
  </para>
____________________________________________________________________________-->
  <para>
   由于这个表包含口令，所以不能是公众可读的，这也是采用<structname>pg_shadow</structname>这个名字的原因。
   而<link linkend="view-pg-user"><structname>pg_user</structname></link>是<structname>pg_shadow</structname>上的一个公共可读视图，它屏蔽了口令域。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_shadow</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_shadow</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>usename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>User name</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>usename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>用户名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>usesysid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>ID of this user</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>usesysid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>用户的ID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>usecreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>User can create databases</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>usecreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>用户能否创建数据库</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>usesuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>User is a superuser</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>usesuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>用户是否为一个超级用户</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>userepl</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       User can initiate streaming replication and put the system in and
       out of backup mode.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>userepl</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       用户能否开启流复制并将系统设置或者取消备份模式。
      </entry>
     </row>
     
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>usebypassrls</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       User bypasses every row level security policy, see
       <xref linkend="ddl-rowsecurity"/> for more information.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>usebypassrls</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       用户能否绕过所有的行级安全性策略，详见
       <xref linkend="ddl-rowsecurity"/>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>passwd</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Password (possibly encrypted); null if none.  See
      <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>
      for details of how encrypted passwords are stored.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>passwd</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>口令（可能被加密），如果没有则为空。关于加密口令如何存储请参见<link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>valuntil</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry></entry>
      <entry>Password expiry time (only used for password authentication)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>valuntil</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry></entry>
      <entry>口令过期时间（仅用于口令认证）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>useconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>Session defaults for run-time configuration variables</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>useconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>运行时配置变量的会话默认值</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-stats">
<!--==========================orignal english content==========================
  <title><structname>pg_stats</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_stats</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="view-pg-stats">
   <primary>pg_stats</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="view-pg-stats">
   <primary>pg_stats</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The view <structname>pg_stats</structname> provides access to
   the information stored in the <link
   linkend="catalog-pg-statistic"><structname>pg_statistic</structname></link>
   catalog.  This view allows access only to rows of
   <structname>pg_statistic</structname> that correspond to tables the
   user has permission to read, and therefore it is safe to allow public
   read access to this view.
  </para>
____________________________________________________________________________-->
  <para>
   视图<structname>pg_stats</structname>提供对存储在<link
   linkend="catalog-pg-statistic"><structname>pg_statistic</structname></link>目录中信息的访问。此视图能访问<structname>pg_statistic</structname>行是有限制的，可访问行所对应的表必须是用户有读权限的。因此让所有用户都可以读此视图是安全的。
  </para>

<!--==========================orignal english content==========================
  <para>
   <structname>pg_stats</structname> is also designed to present the
   information in a more readable format than the underlying catalog
   &mdash; at the cost that its schema must be extended whenever new slot types
   are defined for <structname>pg_statistic</structname>.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_stats</structname>也被设计为能以更适合阅读的格式显示底层目录的信息&mdash; 但代价是只要为<structname>pg_statistic</structname>定义了新的槽类型，就必须要扩展此视图的模式。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_stats</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_stats</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>Name of schema containing table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>包含表的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Name of table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>表名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>attname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attname</literal></entry>
      <entry>Name of the column described by this row</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>attname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attname</literal></entry>
      <entry>被此行描述的列名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>inherited</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>If true, this row includes inheritance child columns, not just the
       values in the specified table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>inherited</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>如果为真，表示此行包括继承子列，不仅仅是指定表中的值</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>null_frac</structfield></entry>
      <entry><type>real</type></entry>
      <entry></entry>
      <entry>Fraction of column entries that are null</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>null_frac</structfield></entry>
      <entry><type>real</type></entry>
      <entry></entry>
      <entry>列项中为空的比例</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>avg_width</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>Average width in bytes of column's entries</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>avg_width</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>列项的平均字节宽度</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>n_distinct</structfield></entry>
      <entry><type>real</type></entry>
      <entry></entry>
      <entry>
       If greater than zero, the estimated number of distinct values in the
       column.  If less than zero, the negative of the number of distinct
       values divided by the number of rows.  (The negated form is used when
       <command>ANALYZE</command> believes that the number of distinct values is
       likely to increase as the table grows; the positive form is used when
       the column seems to have a fixed number of possible values.)  For
       example, -1 indicates a unique column in which the number of distinct
       values is the same as the number of rows.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>n_distinct</structfield></entry>
      <entry><type>real</type></entry>
      <entry></entry>
      <entry>
       如果大于零，表示列中可区分值的估计个数。如果小于零，是可区分值个数除以行数的负值（当<command>ANALYZE</command>认为可区分值的数量会随着表增长而增加时采用负值的形式，而如果认为列具有固定数量的可选值时采用正值的形式）。例如，-1表示一个唯一列，即其中可区分值的个数等于行数。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>most_common_vals</structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>
       A list of the most common values in the column. (Null if
       no values seem to be more common than any others.)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>most_common_vals</structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>
       列中最常用值的一个列表（如果没有任何一个值看起来比其他值更常用，此列为空）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>most_common_freqs</structfield></entry>
      <entry><type>real[]</type></entry>
      <entry></entry>
      <entry>
       A list of the frequencies of the most common values,
       i.e., number of occurrences of each divided by total number of rows.
       (Null when <structfield>most_common_vals</structfield> is.)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>most_common_freqs</structfield></entry>
      <entry><type>real[]</type></entry>
      <entry></entry>
      <entry>
       最常用值的频率列表，即每一个常用值的出现次数除以总行数（如果<structfield>most_common_vals</structfield>为空，则此列为空）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>histogram_bounds</structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>
       A list of values that divide the column's values into groups of
       approximately equal population.  The values in
       <structfield>most_common_vals</structfield>, if present, are omitted from this
       histogram calculation.  (This column is null if the column data type
       does not have a <literal>&lt;</literal> operator or if the
       <structfield>most_common_vals</structfield> list accounts for the entire
       population.)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>histogram_bounds</structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>
       将列值划分成大小接近的组的值列表。如果存在<structfield>most_common_vals</structfield>，其中的值会被直方图计算所忽略（如果列类型没有一个<literal>&lt;</literal>操作符或者<structfield>most_common_vals</structfield>等于整个值集合，则此列为空）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>correlation</structfield></entry>
      <entry><type>real</type></entry>
      <entry></entry>
      <entry>
       Statistical correlation between physical row ordering and
       logical ordering of the column values.  This ranges from -1 to +1.
       When the value is near -1 or +1, an index scan on the column will
       be estimated to be cheaper than when it is near zero, due to reduction
       of random access to the disk.  (This column is null if the column data
       type does not have a <literal>&lt;</literal> operator.)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>correlation</structfield></entry>
      <entry><type>real</type></entry>
      <entry></entry>
      <entry>
       物理行顺序和列值逻辑顺序之间的统计关联。其范围从-1到+1。当值接近-1或+1时，在列上的一个索引扫描被认为比值接近0时的代价更低，因为这种情况减少了对磁盘的随机访问（如果列数据类型不具有一个<literal>&lt;</literal>操作符，则此列为空）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>most_common_elems</structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>
       A list of non-null element values most often appearing within values of
       the column. (Null for scalar types.)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>most_common_elems</structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>
       在列值中，最经常出现的非空元素列表（对标度类型为空）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>most_common_elem_freqs</structfield></entry>
      <entry><type>real[]</type></entry>
      <entry></entry>
      <entry>
       A list of the frequencies of the most common element values, i.e., the
       fraction of rows containing at least one instance of the given value.
       Two or three additional values follow the per-element frequencies;
       these are the minimum and maximum of the preceding per-element
       frequencies, and optionally the frequency of null elements.
       (Null when <structfield>most_common_elems</structfield> is.)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>most_common_elem_freqs</structfield></entry>
      <entry><type>real[]</type></entry>
      <entry></entry>
      <entry>
       最常用元素值的频度列表，即含有至少一个给定值实例的行的分数。在每个元素的频度之后有二至三个附加值，它们是每个元素频度的最小和最大值，以及可选的空元素的频度（如果<structfield>most_common_elems</structfield>为空，则此列为空）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>elem_count_histogram</structfield></entry>
      <entry><type>real[]</type></entry>
      <entry></entry>
      <entry>
       A histogram of the counts of distinct non-null element values within the
       values of the column, followed by the average number of distinct
       non-null elements.  (Null for scalar types.)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>elem_count_histogram</structfield></entry>
      <entry><type>real[]</type></entry>
      <entry></entry>
      <entry>
       在列值中可区分非空元素值计数的一个直方图，后面跟随可区分非空元素的平均数（对于标度类型为空）
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   The maximum number of entries in the array fields can be controlled on a
   column-by-column basis using the <command>ALTER TABLE SET STATISTICS</command>
   command, or globally by setting the
   <xref linkend="guc-default-statistics-target"/> run-time parameter.
  </para>
____________________________________________________________________________-->
  <para>
   在数组域中项的最大数目可以使用<command>ALTER TABLE SET STATISTICS</command>命令控制，或者设置<xref linkend="guc-default-statistics-target"/>运行时参数从全局上进行控制
  </para>

 </sect1>

 <sect1 id="view-pg-stats-ext">
  <title><structname>pg_stats_ext</structname></title>

  <indexterm zone="view-pg-stats-ext">
   <primary>pg_stats_ext</primary>
  </indexterm>

  <para>
   视图<structname>pg_stats_ext</structname>提供了访问存储在<link linkend="catalog-pg-statistic-ext"><structname>pg_statistic_ext</structname></link>和<link linkend="catalog-pg-statistic-ext-data"><structname>pg_statistic_ext_data</structname></link>目录中的信息的手段。该视图仅允许访问<structname>pg_statistic_ext</structname>和<structname>pg_statistic_ext_data</structname>的行，这些行对应于用户有权读取的表，因此允许公众读取该视图是安全的。
  </para>

  <para>
   <structname>pg_stats_ext</structname>也设计成以比底层目录更可读的格式来展示信息&mdash; 代价是每当有扩展的统计信息的新类型加到<structname>pg_statistic_ext</structname>中时其模式必须扩展。
  </para>

  <table>
   <title><structname>pg_stats_ext</structname>的列</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>包含表的模式名</entry>
     </row>

     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>表名</entry>
     </row>

     <row>
      <entry><structfield>statistics_schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>包含扩展的统计信息的模式名</entry>
     </row>

     <row>
      <entry><structfield>statistics_name</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-statistic-ext"><structname>pg_statistic_ext</structname></link>.stxname</literal></entry>
      <entry>扩展的统计信息的名称</entry>
     </row>

     <row>
      <entry><structfield>statistics_owner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>扩展的统计信息对的拥有者</entry>
     </row>

     <row>
      <entry><structfield>attnames</structfield></entry>
      <entry><type>name[]</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attname</literal></entry>
      <entry>扩展的统计信息定义所在的列名称</entry>
     </row>

     <row>
      <entry><structfield>kinds</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>为此记录启用的扩展统计信息类型</entry>
     </row>

     <row>
      <entry><structfield>n_distinct</structfield></entry>
      <entry><type>pg_ndistinct</type></entry>
      <entry></entry>
      <entry>
       列值组合的N-不同计数。如果大于零，则为组合中不同值的估计数量。如果小于零，则为不同值数量的负数除以行数。（当<command>ANALYZE</command> 认为随着表的增长不同值的数量可能会增加时，使用负数形式；当该列似乎具有固定数量的可能值时，则使用正数形式。）例如，-1表示列的唯一组合，其中不同组合的数量与行数相同。
      </entry>
     </row>

     <row>
      <entry><structfield>dependencies</structfield></entry>
      <entry><type>pg_dependencies</type></entry>
      <entry></entry>
      <entry>功能的依赖关系统计信息</entry>
     </row>

     <row>
      <entry><structfield>most_common_vals</structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>
       列中值的最常见组合的列表（如果没有组合看上去比其它的更常见，则为空。）
      </entry>
     </row>

     <row>
      <entry><structfield>most_common_val_nulls</structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>
       值最常见组合的NULL标志的列表（当<structfield>most_common_vals</structfield>是空值时，为空。）
      </entry>
     </row>

     <row>
      <entry><structfield>most_common_freqs</structfield></entry>
      <entry><type>real[]</type></entry>
      <entry></entry>
      <entry>
       最常见组合的频率的列表，即每个出现的数量除以行的总数（当<structfield>most_common_vals</structfield>是空值时，为空）
      </entry>
     </row>

     <row>
      <entry><structfield>most_common_base_freqs</structfield></entry>
      <entry><type>real[]</type></entry>
      <entry></entry>
      <entry>
       最常见组合的基本频率的列表，即每个值频率的乘积。（当<structfield>most_common_vals</structfield>是空值时，为空。）
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   数组字段条目的最大数量可以基于一列列地使用<command>ALTER TABLE SET STATISTICS</command>命令来控制，或者通过设置全局的<xref linkend="guc-default-statistics-target"/>运行时参数来控制。
  </para>

 </sect1>

 <sect1 id="view-pg-tables">
<!--==========================orignal english content==========================
  <title><structname>pg_tables</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_tables</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="view-pg-tables">
   <primary>pg_tables</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="view-pg-tables">
   <primary>pg_tables</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The view <structname>pg_tables</structname> provides access to
   useful information about each table in the database.
  </para>
____________________________________________________________________________-->
  <para>
   视图<structname>pg_tables</structname>提供对数据库中每个表的信息的访问。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_tables</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_tables</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>Name of schema containing table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>包含表的模式名</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Name of table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>表名</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tableowner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>Name of table's owner</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tableowner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>表拥有者的名字</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>tablespace</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.spcname</literal></entry>
      <entry>Name of tablespace containing table (null if default for database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>tablespace</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.spcname</literal></entry>
      <entry>包含表的表空间的名字（如果使用数据库的默认表空间，此列为空）</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>hasindexes</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relhasindex</literal></entry>
      <entry>True if table has (or recently had) any indexes</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>hasindexes</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relhasindex</literal></entry>
      <entry>如果表有（或最近有过）任何索引，此列为真</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>hasrules</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relhasrules</literal></entry>
      <entry>True if table has (or once had) rules</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>hasrules</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relhasrules</literal></entry>
      <entry>如果表有（或曾经有过）规则，此列为真</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>hastriggers</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relhastriggers</literal></entry>
      <entry>True if table has (or once had) triggers</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>hastriggers</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relhastriggers</literal></entry>
      <entry>如果表有（或者曾经有过）触发器，此列为真</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>rowsecurity</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relrowsecurity</literal></entry>
      <entry>True if row security is enabled on the table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>rowsecurity</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relrowsecurity</literal></entry>
      <entry>如果表上启用了行安全性则为真</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-timezone-abbrevs">
<!--==========================orignal english content==========================
  <title><structname>pg_timezone_abbrevs</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_timezone_abbrevs</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="view-pg-timezone-abbrevs">
   <primary>pg_timezone_abbrevs</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="view-pg-timezone-abbrevs">
   <primary>pg_timezone_abbrevs</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The view <structname>pg_timezone_abbrevs</structname> provides a list
   of time zone abbreviations that are currently recognized by the datetime
   input routines.  The contents of this view change when the
   <xref linkend="guc-timezone-abbreviations"/> run-time parameter is modified.
  </para>
____________________________________________________________________________-->
  <para>
   视图<structname>pg_timezone_abbrevs</structname>提供了对当前被时间输入例程识别的时区缩写的列表。当<xref linkend="guc-timezone-abbreviations"/>运行时参数被修改，此视图的内容会发生变化。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_timezone_abbrevs</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_timezone_abbrevs</structname>的列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名字</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>abbrev</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Time zone abbreviation</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>abbrev</structfield></entry>
      <entry><type>text</type></entry>
      <entry>时区缩写</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>utc_offset</structfield></entry>
      <entry><type>interval</type></entry>
      <entry>Offset from UTC (positive means east of Greenwich)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>utc_offset</structfield></entry>
      <entry><type>interval</type></entry>
      <entry>相对于UTC的偏移（正值表示格林威治东部）</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>is_dst</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>True if this is a daylight-savings abbreviation</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>is_dst</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>如果这是一个夏令时缩写，则为真</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  
<!--==========================orignal english content==========================
  <para>
   While most timezone abbreviations represent fixed offsets from UTC,
   there are some that have historically varied in value
   (see <xref linkend="datetime-config-files"/> for more information).
   In such cases this view presents their current meaning.
  </para>
____________________________________________________________________________-->
  <para>
   虽然大部分时区缩写表示从 UTC 开始的固定偏移，但是有一些在历史上有值的变化（详见<xref linkend="datetime-config-files"/>）。在这种情况下，这个视图表示它们现在的含义。
  </para>

 </sect1>

 <sect1 id="view-pg-timezone-names">
<!--==========================orignal english content==========================
  <title><structname>pg_timezone_names</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_timezone_names</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="view-pg-timezone-names">
   <primary>pg_timezone_names</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="view-pg-timezone-names">
   <primary>pg_timezone_names</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The view <structname>pg_timezone_names</structname> provides a list
   of time zone names that are recognized by <command>SET TIMEZONE</command>,
   along with their associated abbreviations, UTC offsets,
   and daylight-savings status.  (Technically,
   <productname>PostgreSQL</productname> does not use UTC because leap
   seconds are not handled.)
   Unlike the abbreviations shown in <link
   linkend="view-pg-timezone-abbrevs"><structname>pg_timezone_abbrevs</structname></link>, many of these names imply a set of daylight-savings transition
   date rules.  Therefore, the associated information changes across local DST
   boundaries.  The displayed information is computed based on the current
   value of <function>CURRENT_TIMESTAMP</function>.
  </para>
____________________________________________________________________________-->
  <para>
   视图<structname>pg_timezone_names</structname>提供了一个被<command>SET TIMEZONE</command>识别的时区名字的列表，以及它们的相关缩写、UTC偏移和夏令时状态（从技术上来说，<productname>PostgreSQL</productname>不使用UTC是因为闰秒没有被处理）。和<link
   linkend="view-pg-timezone-abbrevs"><structname>pg_timezone_abbrevs</structname></link>中展示的缩写不同，这里很多名字隐含了一组夏令时转换日期规则。因此，相关信息在本地DST边界间变化。所显示的信息基于<function>CURRENT_TIMESTAMP</function>的当前值计算得来。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_timezone_names</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_timezone_names</structname>的列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名字</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Time zone name</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <entry>时区名</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>abbrev</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Time zone abbreviation</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>abbrev</structfield></entry>
      <entry><type>text</type></entry>
      <entry>时区缩写</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>utc_offset</structfield></entry>
      <entry><type>interval</type></entry>
      <entry>Offset from UTC (positive means east of Greenwich)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>utc_offset</structfield></entry>
      <entry><type>interval</type></entry>
      <entry>相对于UTC的偏移（正值表示格林威治东部）</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>is_dst</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>True if currently observing daylight savings</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>is_dst</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>如果当前保持为夏令时则为真</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-user">
<!--==========================orignal english content==========================
  <title><structname>pg_user</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_user</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="view-pg-user">
   <primary>pg_user</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="view-pg-user">
   <primary>pg_user</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The view <structname>pg_user</structname> provides access to
   information about database users.  This is simply a publicly
   readable view of
   <link linkend="view-pg-shadow"><structname>pg_shadow</structname></link>
   that blanks out the password field.
  </para>
____________________________________________________________________________-->
  <para>
   视图<structname>pg_user</structname>提供关于数据库用户的信息。这是<link linkend="view-pg-shadow"><structname>pg_shadow</structname></link>的一个公共可读的视图，它消除了口令域。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_user</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_user</structname>的列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名字</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>usename</structfield></entry>
      <entry><type>name</type></entry>
      <entry>User name</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>usename</structfield></entry>
      <entry><type>name</type></entry>
      <entry>用户名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>usesysid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>ID of this user</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>usesysid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>用户的ID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>usecreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>User can create databases</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>usecreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>用户是否能创建数据库</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>usesuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>User is a superuser</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>usesuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>用户是否为超级用户</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>userepl</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>
       User can initiate streaming replication and put the system in and
       out of backup mode.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>userepl</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>
       用户能否开启流复制以及将系统转入/转出备份模式。
      </entry>
     </row>
     
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>usebypassrls</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>
       User bypasses every row level security policy, see
       <xref linkend="ddl-rowsecurity"/> for more information.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>usebypassrls</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>
       用户能否绕过所有的行级安全性策略，详见
       <xref linkend="ddl-rowsecurity"/>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>passwd</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Not the password (always reads as <literal>********</literal>)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>passwd</structfield></entry>
      <entry><type>text</type></entry>
      <entry>不是口令（总是显示为<literal>********</literal>）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>valuntil</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry>Password expiry time (only used for password authentication)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>valuntil</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry>口令过期时间（只用于口令认证）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>useconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry>Session defaults for run-time configuration variables</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>useconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry>运行时配置变量的会话默认值</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-user-mappings">
<!--==========================orignal english content==========================
  <title><structname>pg_user_mappings</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_user_mappings</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="view-pg-user-mappings">
   <primary>pg_user_mappings</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="view-pg-user-mappings">
   <primary>pg_user_mappings</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The view <structname>pg_user_mappings</structname> provides access
   to information about user mappings.  This is essentially a publicly
   readable view of
   <link linkend="catalog-pg-user-mapping"><structname>pg_user_mapping</structname></link>
   that leaves out the options field if the user has no rights to use
   it.
  </para>
____________________________________________________________________________-->
  <para>
   视图<structname>pg_user_mappings</structname>提供有关用户映射的信息。这是<link linkend="catalog-pg-user-mapping"><structname>pg_user_mapping</structname></link>的一个公共可读视图，它对无权使用的用户省去了选项域。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_user_mappings</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_user_mappings</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>umid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-user-mapping"><structname>pg_user_mapping</structname></link>.oid</literal></entry>
      <entry>OID of the user mapping</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>umid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-user-mapping"><structname>pg_user_mapping</structname></link>.oid</literal></entry>
      <entry>用户映射的OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>srvid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-foreign-server"><structname>pg_foreign_server</structname></link>.oid</literal></entry>
      <entry>
       The OID of the foreign server that contains this mapping
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>srvid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-foreign-server"><structname>pg_foreign_server</structname></link>.oid</literal></entry>
      <entry>
       包含该映射的外部服务器的OID
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>srvname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-foreign-server"><structname>pg_foreign_server</structname></link>.srvname</literal></entry>
      <entry>
       Name of the foreign server
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>srvname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-foreign-server"><structname>pg_foreign_server</structname></link>.srvname</literal></entry>
      <entry>
       外部服务器名
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>umuser</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>OID of the local role being mapped, 0 if the user mapping is public</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>umuser</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>将被映射的本地角色的OID，如果用户映射是公共的则为0</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>usename</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the local user to be mapped</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>usename</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>将被映射的本地用户名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>umoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       User mapping specific options, as <quote>keyword=value</quote> strings
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>umoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       用户映射指定选项，以<quote>keyword=value</quote>字符串的形式
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   To protect password information stored as a user mapping option,
   the <structfield>umoptions</structfield> column will read as null
   unless one of the following applies:
   <itemizedlist>
    <listitem>
     <para>
      current user is the user being mapped, and owns the server or
      holds <literal>USAGE</literal> privilege on it
     </para>
    </listitem>
    <listitem>
     <para>
      current user is the server owner and mapping is for <literal>PUBLIC</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      current user is a superuser
     </para>
    </listitem>
   </itemizedlist>
  </para>
____________________________________________________________________________-->
  <para>
   为了保护存储为用户映射选项的口令信息，<structfield>umoptions</structfield>列将被读作空，除非满足下列情况之一：
   <itemizedlist>
    <listitem>
     <para>
      当前用户就是被映射的用户，并且拥有该服务器或者持有其上的<literal>USAGE</literal>特权
     </para>
    </listitem>
    <listitem>
     <para>
      当前用户是服务器的拥有者并且映射是用于<literal>PUBLIC</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      当前用户是一个超级用户
     </para>
    </listitem>
   </itemizedlist>
  </para>
 </sect1>


 <sect1 id="view-pg-views">
<!--==========================orignal english content==========================
  <title><structname>pg_views</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_views</structname></title>

<!--==========================orignal english content==========================
  <indexterm zone="view-pg-views">
   <primary>pg_views</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="view-pg-views">
   <primary>pg_views</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The view <structname>pg_views</structname> provides access to
   useful information about each view in the database.
  </para>
____________________________________________________________________________-->
  <para>
   视图<structname>pg_views</structname>提供了数据库中每个视图的信息。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><structname>pg_views</structname> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_views</structname>的列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>Name of schema containing view</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>包含视图的模式名</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>viewname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Name of view</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>viewname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>视图名称</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>viewowner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>Name of view's owner</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>viewowner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>视图拥有者的名字</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>definition</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>View definition (a reconstructed <command>SELECT</command> query)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>definition</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>视图定义（一个重构的<command>SELECT</command>查询）</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

</chapter>
