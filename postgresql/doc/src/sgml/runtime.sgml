<!-- doc/src/sgml/runtime.sgml -->

<chapter id="runtime">
 <!-- 
 <title>Server Setup and Operation</title> 
 -->
<title>服务器设置和操作</title>
 <!--
<para>
  This chapter discusses how to set up and run the database server
  and its interactions with the operating system.
 </para>
-->
<para>
本章讨论如何设置和运行数据库服务器以及它如何与操作系统交互。
</para>

 <sect1 id="postgres-user">
  <!-- 
  <title>The <productname>PostgreSQL</productname> User Account</title> 
  -->
  <title><productname>PostgreSQL</productname>用户账户</title>

  <indexterm>
   <!-- 
   <primary>postgres user</primary> 
   -->
   <primary>postgres 用户</primary>
  </indexterm>

  <!--
<para>
   As with any server daemon that is accessible to the outside world,
   it is advisable to run <productname>PostgreSQL</productname> under a
   separate user account. This user account should only own the data
   that is managed by the server, and should not be shared with other
   daemons. (For example, using the user <literal>nobody</literal> is a bad
   idea.) It is not advisable to install executables owned by this
   user because compromised systems could then modify their own
   binaries.
  </para>
-->
<para>
与任何可以从外界访问的服务器守护进程一样，我们也建议用一个独立的用户帐户运行
<productname>PostgreSQL</productname>。这个用户帐户应该拥有由这个服务器管理的数据，
而且不应该与其它守护进程共享这些数据。比如，用<literal>nobody</literal>用户是个烂主意。
我们不建议把可执行文件安装为由此用户所有，因为这样一来被攻破的系统就可以修改它们自己拥有的二进制文件。
</para>

  <!--
<para>
   To add a Unix user account to your system, look for a command
   <command>useradd</command> or <command>adduser</command>. The user
   name <systemitem>postgres</systemitem> is often used, and is assumed
   throughout this book, but you can use another name if you like.
  </para>
-->
<para>
要向系统里增加用户帐户，参考<command>useradd</command>或<command>adduser</command>命令。
我们经常使用<systemitem>postgres</systemitem>的用户名，并且在本书中都假设这个名字，
但你不必这么做。
</para>
 </sect1>

 <sect1 id="creating-cluster">
  <!-- 
  <title>Creating a Database Cluster</title>
  -->
  <title>创建数据库集群</title>
  <indexterm>
   <!-- 
   <primary>database cluster</primary> 
   -->
   <primary>数据库集群</primary>
  </indexterm>

  <indexterm>
   <!-- 
   <primary>data area</primary>
   <see>database cluster</see> 
   -->
   <primary>数据区</primary>
   <see>数据库集群</see>
  </indexterm>

  <!--
<para>
   Before you can do anything, you must initialize a database storage
   area on disk. We call this a <firstterm>database cluster</firstterm>.
   (<acronym>SQL</acronym> uses the term catalog cluster.) A
   database cluster is a collection of databases that is managed by a
   single instance of a running database server. After initialization, a
   database cluster will contain a database named <literal>postgres</literal>,
   which is meant as a default database for use by utilities, users and third
   party applications.  The database server itself does not require the
   <literal>postgres</literal> database to exist, but many external utility
   programs assume it exists.  Another database created within each cluster
   during initialization is called
   <literal>template1</literal>.  As the name suggests, this will be used
   as a template for subsequently created databases; it should not be
   used for actual work.  (See <xref linkend="managing-databases"> for
   information about creating new databases within a cluster.)
  </para>
-->
<para>
在做任何事情之前，必须先初始化磁盘上的数据存储区，叫作<firstterm>数据库集群</firstterm>
(标准<acronym>SQL</acronym>术语称为"目录集群")。一个数据库集群是一系列数据库的集合，
这些数据库可以通过单个数据库服务器的实例管理。在初始化后，一个数据库集群将包含一个叫<literal>postgres</literal>
的数据库，这个库是给工具、用户和第三方程序使用的缺省数据库。数据库服务器本身并不要求<literal>postgres</literal>
数据库的存在，但是很多外部工具假设它存在。另外一个在每个集群初始化过程中创建的数据库叫<literal>template1</literal>。
正如其名一样，这个数据库将作为随后创建的数据库的模版；在实际工作中不应该使用这个库
(参阅<xref linkend="managing-databases">获取有关创建数据库的信息)。
</para>

<para>
<!-- 
   In file system terms, a database cluster will be a single directory
   under which all data will be stored. We call this the <firstterm>data
   directory</firstterm> or <firstterm>data area</firstterm>. It is
   completely up to you where you choose to store your data.  There is no
   default, although locations such as
   <filename>/usr/local/pgsql/data</filename> or
   <filename>/var/lib/pgsql/data</filename> are popular. To initialize a
   database cluster, use the command <xref
   linkend="app-initdb">,<indexterm><primary>initdb</></> which is
   installed with <productname>PostgreSQL</productname>. The desired
   file system location of your database cluster is indicated by the
   <option>-D</option> option, for example: 
-->
用文件系统的术语来说，一个数据库集群是一个目录，所有数据都将存放在这个目录中。
我们把它称做<firstterm>数据目录</firstterm>或<firstterm>数据区</firstterm>。
在哪里存放数据完全取决于你的选择，我们没有缺省值，尽管<filename>/usr/local/pgsql/data</filename>
或<filename>/var/lib/pgsql/data</filename>这样的目录很常用。要初始化一个数据库集群，
可以使用<xref linkend="app-initdb">,<indexterm><primary>initdb</></>命令，
这个命令与<productname>PostgreSQL</productname>一起安装。你可以用<option>-D</option>
选项指定数据目录的位置，例如：
<screen>
<prompt>$</> <userinput>initdb -D /usr/local/pgsql/data</userinput>
</screen>
<!-- 
   Note that you must execute this command while logged into the
   <productname>PostgreSQL</productname> user account, which is
   described in the previous section. 
-->
你必须以<productname>PostgreSQL</productname>用户的身份来执行这条命令，
这一点我们在前面一节描述过。
  </para>

  <tip>
   <!--
<para>
    As an alternative to the <option>-D</option> option, you can set
    the environment variable <envar>PGDATA</envar>.
    <indexterm><primary><envar>PGDATA</envar></primary></indexterm>
   </para>
-->
<para>
作为<option>-D</option>选项的替代品，你还可以使用<envar>PGDATA</envar>环境变量。
<indexterm><primary><envar>PGDATA</envar></primary></indexterm>
</para>
  </tip>
 
<para>
<!--
  Alternatively, you can run <command>initdb</command> via
   the <xref linkend="app-pg-ctl">
   program<indexterm><primary>pg_ctl</></> like so:
-->
可选的，你可以通过<xref linkend="app-pg-ctl">程序<indexterm><primary>pg_ctl</></>运行
<command>initdb</command>，像这样：
<screen>
<prompt>$</> <userinput>pg_ctl -D /usr/local/pgsql/data initdb</userinput>
</screen>
<!-- 
   This may be more intuitive if you are
   using <command>pg_ctl</command> for starting and stopping the
   server (see <xref linkend="server-start">), so
   that <command>pg_ctl</command> would be the sole command you use
   for managing the database server instance. 
-->
如果你使用<command>pg_ctl</command>启动或停止服务器（参阅<xref linkend="server-start">）可能会更直观，
所以<command>pg_ctl</command>将会是你管理数据库服务器实例唯一使用的命令。
  </para>
  
<para>
<!--
   <command>initdb</command> will attempt to create the directory you
   specify if it does not already exist. It is likely that it will not
   have the permission to do so (if you followed our advice and created
   an unprivileged account). In that case you should create the
   directory yourself (as root) and change the owner to be the
   <productname>PostgreSQL</productname> user. Here is how this might
   be done:
-->
如果你声明的路径还不存在，<command>initdb</command>将试图创建它。如果你按照我们的建议创建了一个非特权帐户的话，
你很有可能缺少做这些事情的权限。这时，你可以自己创建该目录(以 root 身份)然后把该目录的所有权交给
<productname>PostgreSQL</productname>用户。下面是可能有效的方法：
<screen>
root# <userinput>mkdir /usr/local/pgsql/data</userinput>
root# <userinput>chown postgres /usr/local/pgsql/data</userinput>
root# <userinput>su postgres</userinput>
postgres$ <userinput>initdb -D /usr/local/pgsql/data</userinput>
</screen>
  </para>

  <!--
<para>
   <command>initdb</command> will refuse to run if the data directory
   looks like it has already been initialized.</para>
-->
<para>
如果数据目录看起来像已经初始化过了，那么<command>initdb</command>会拒绝运行。
</para>

  <!--
<para>
   Because the data directory contains all the data stored in the
   database, it is essential that it be secured from unauthorized
   access. <command>initdb</command> therefore revokes access
   permissions from everyone but the
   <productname>PostgreSQL</productname> user.
  </para>
-->
<para>
因为数据目录包含所有存储在数据库里的数据，所以出于安全考虑，这个目录不能给任何非授权用户访问。
因此，<command>initdb</command>禁止除<productname>PostgreSQL</productname>用户帐户以外的任何用户访问这个目录。
</para>

  <!--
<para>
   However, while the directory contents are secure, the default
   client authentication setup allows any local user to connect to the
   database and even become the database superuser. If you do not
   trust other local users, we recommend you use one of
   <command>initdb</command>'s <option>-W</option>, <option>-&#045;pwprompt</option>
   or <option>&#045;-pwfile</option> options to assign a password to the
   database superuser.<indexterm>
     <primary>password</>
     <secondary>of the superuser</>
   </indexterm>
   Also, specify <option>-A md5</> or
   <option>-A password</> so that the default <literal>trust</> authentication
   mode is not used; or modify the generated <filename>pg_hba.conf</filename>
   file after running <command>initdb</command>, but
   <emphasis>before</> you start the server for the first time. (Other
   reasonable approaches include using <literal>peer</literal> authentication
   or file system permissions to restrict connections. See <xref
   linkend="client-authentication"> for more information.)
  </para>
-->
<para>
不过，因为目录的内容是安全的，所以缺省的客户端认证设置允许任意本地用户连接到数据库甚至成为超级用户。
如果你不信任本地用户，我们建议你使用<command>initdb</command>的<option>-W</option>,
 <option>--pwprompt</option>或 <option>--pwfile</option> 选项给超级用户赋予一个口令。<indexterm>
<primary>password</>
<secondary>of the superuser</>
</indexterm>还有，声明<option>-A md5</>或<option>-A password</>，这样就不会使用缺省的<literal>trust</>
身份认证。或者在执行<command>initdb</command>之后，第一次启动服务器<emphasis>之前</>
修改<filename>pg_hba.conf</filename>文件。另外一些合理的方法包括<literal>peer</literal>
认证或者用文件系统权限禁止连接。参阅<xref linkend="client-authentication">获取更多细节。
</para>

  <!--
<para>
   <command>initdb</command> also initializes the default
   locale<indexterm><primary>locale</></> for the database cluster.
   Normally, it will just take the locale settings in the environment
   and apply them to the initialized database.  It is possible to
   specify a different locale for the database; more information about
   that can be found in <xref linkend="locale">.  The default sort order used
   within the particular database cluster is set by
   <command>initdb</command>, and while you can create new databases using
   different sort order, the order used in the template databases that initdb
   creates cannot be changed without dropping and recreating them.
   There is also a performance impact for using locales
   other than <literal>C</> or <literal>POSIX</>. Therefore, it is
   important to make this choice correctly the first time.
  </para>
-->
<para>
<command>initdb</command>同时也为数据库集群初始化缺省区域<indexterm><primary>区域</></>。通常，
它将只是使用环境中的区域设置并且把它们应用于初始化的数据库。我们可以为数据库声明不同的区域；
有关这些的更多信息可以在<xref linkend="locale">中找到。在特定数据库集群里的缺省排序顺序是由
<command>initdb</command>设置的，而且当你能用不同的排序顺序创建新的数据库时，
initdb创建的模板数据库中使用的排序不能改变，除非删除并重新创建它们。使用非<literal>C</>或<literal>POSIX</>
的区域还会有性能影响。因此，第一次就选择正确很重要。
</para>

  <!--
<para>
   <command>initdb</command> also sets the default character set encoding
   for the database cluster.  Normally this should be chosen to match the
   locale setting.  For details see <xref linkend="multibyte">.
  </para>
-->
<para>
<command>initdb</command>还为数据库集群设置缺省的字符集编码。通常这个应该选择与区域匹配。
详见<xref linkend="multibyte">。
</para>

  <sect2 id="creating-cluster-nfs">
   <!-- 
   <title>Network File Systems</title> 
   -->
   <title>网络文件系统</title>

   <indexterm zone="creating-cluster-nfs">
    <!-- 
<primary>Network File Systems</primary> 
-->
<primary>网络文件系统</primary>
   </indexterm>
   <!-- 
   <indexterm><primary><acronym>NFS</></><see>Network File Systems</></>
   <indexterm><primary>Network Attached Storage (<acronym>NAS</>)</><see>Network File Systems</></>
   -->
   <indexterm><primary><acronym>NFS</></><see>网络文件系统</></>
   <indexterm><primary>网络附加存储 (<acronym>NAS</>)</><see>网络文件系统</></>

   <!--
<para>
    Many installations create database clusters on network file systems.
    Sometimes this is done directly via <acronym>NFS</>, or by using a
    Network Attached Storage (<acronym>NAS</>) device that uses
    <acronym>NFS</> internally.  <productname>PostgreSQL</> does nothing
    special for <acronym>NFS</> file systems, meaning it assumes
    <acronym>NFS</> behaves exactly like locally-connected drives
    (<acronym>DAS</>, Direct Attached Storage).  If client and server
    <acronym>NFS</> implementations have non-standard semantics, this can
    cause reliability problems (see <ulink
    url="http://www.time-travellers.org/shane/papers/NFS_considered_harmful.html"></ulink>).
    Specifically, delayed (asynchronous) writes to the <acronym>NFS</>
    server can cause reliability problems;   if possible, mount
    <acronym>NFS</> file systems synchronously (without caching) to avoid
    this.  Also, soft-mounting <acronym>NFS</> is not recommended.
    (Storage Area Networks (<acronym>SAN</>) use a low-level
    communication protocol rather than <acronym>NFS</>.)
   </para>
-->
<para>
许多安装在网络文件系统创建数据库集群。有时直接通过<acronym>NFS</>或通过使用网络附加存储(<acronym>NAS</>)
设计内部使用<acronym>NFS</>。<productname>PostgreSQL</>并不为<acronym>NFS</>文件系统做什么特别的，
意味着他假设<acronym>NFS</>和本地连接驱动器(<acronym>DAS</>,直接附加存储)的行为一样。如果客户端和服务器<acronym>NFS</>
实现有非标准的语义，会引起可靠性问题（参阅<ulink url="http://www.time-travellers.org/shane/papers/NFS_considered_harmful.html"></ulink>）。
特别的，延迟的（异步的）写入<acronym>NFS</>服务器可能会引起可靠性问题；如果可能，
同步的（没有缓存）安装<acronym>NFS</>文件系统以避免这个问题。同样，不建议软安装<acronym>NFS</>。
（存储区域网络(<acronym>SAN</>)使用一个低级的通信协议而不是<acronym>NFS</>。）
</para>

  </sect2>

 </sect1>

 <sect1 id="server-start">
  <!-- 
  <title>Starting the Database Server</title> 
  -->
  <title>启动数据库服务器</title>

<para>
<!--
   Before anyone can access the database, you must start the database
   server. The database server program is called
   <command>postgres</command>.<indexterm><primary>postgres</></>
   The <command>postgres</command> program must know where to
   find the data it is supposed to use. This is done with the
   <option>-D</option> option. Thus, the simplest way to start the
   server is:
-->
在任何人可以访问数据库前，你必须启动数据库服务器。数据库服务器程序名叫<command>postgres</command>，
<indexterm><primary>postgres</></>它必须知道在哪里能找到它要用的数据。
这是利用<option>-D</option>选项实现的。因此，启动服务器最简单的方法是像下面这样：
<screen>
$ <userinput>postgres -D /usr/local/pgsql/data</userinput>
</screen>
<!-- 
   which will leave the server running in the foreground. This must be
   done while logged into the <productname>PostgreSQL</productname> user
   account. Without <option>-D</option>, the server will try to use
   the data directory named by the environment variable <envar>PGDATA</envar>.
   If that variable is not provided either, it will fail. 
-->
这样将把服务器放在前台运行。这个步骤同样必须以<productname>PostgreSQL</productname>用户帐户登录来做。
没有<option>-D</option>选项，服务器将使用环境变量<envar>PGDATA</envar>命名的目录；
如果这个环境变量也没有，将导致失败。
  </para>
  
<para>
<!--
   Normally it is better to start <command>postgres</command> in the
   background.  For this, use the usual Unix shell syntax:
-->
通常，最好在后台启动<command>postgres</command>，使用下面的 Unix shell 语法：
<screen>
$ <userinput>postgres -D /usr/local/pgsql/data &gt;logfile 2&gt;&amp;1 &amp;</userinput>
</screen>
<!-- 
   It is important to store the server's <systemitem>stdout</> and
   <systemitem>stderr</> output somewhere, as shown above. It will help
   for auditing purposes and to diagnose problems. (See <xref
   linkend="logfile-maintenance"> for a more thorough discussion of log
   file handling.) 
-->
把服务器的<systemitem>stdout</>和<systemitem>stderr</>放到某个地方是非常重要的，
就像在上面建议的这样。这样做既可以帮助审计又可以帮助诊断问题。
参阅<xref linkend="logfile-maintenance">获取有关日志文件处理的更完整讨论。
  </para>

  <!--
<para>
   The <command>postgres</command> program also takes a number of other
   command-line options. For more information, see the
   <xref linkend="app-postgres"> reference page
   and <xref linkend="runtime-config"> below.
  </para>
-->
<para>
<command>postgres</command>还接受一些其它的一些命令行选项。
更多的信息请参考<xref linkend="app-postgres">手册页和下面的<xref linkend="runtime-config">。
</para>

  
<para>
<!--
   This shell syntax can get tedious quickly.  Therefore the wrapper
   program
   <xref linkend="app-pg-ctl"><indexterm><primary>pg_ctl</primary></indexterm>
   is provided to simplify some tasks.  For example:
-->
这些 shell 语法很容易让人觉得无聊。因此我们提供了封装程序
<xref linkend="app-pg-ctl"><indexterm><primary>pg_ctl</primary></indexterm>以简化一些任务。比如：
<programlisting>
pg_ctl start -l logfile
</programlisting>
<!-- 
   will start the server in the background and put the output into the
   named log file. The <option>-D</option> option has the same meaning
   here as for <command>postgres</command>. <command>pg_ctl</command>
   is also capable of stopping the server. 
-->
将在后台启动服务器并且把输出放到指定的日志文件中。<option>-D</option>
选项和你直接运行<command>postgres</command>时的意思是一样的。<command>pg_ctl</command>
还可以用于关闭服务器。
  </para>

  <!--
<para>
   Normally, you will want to start the database server when the
   computer boots.<indexterm>
     <primary>booting</>
     <secondary>starting the server during</>
   </indexterm>
   Autostart scripts are operating-system-specific.
   There are a few distributed with
   <productname>PostgreSQL</productname> in the
   <filename>contrib/start-scripts</> directory. Installing one will require
   root privileges.
  </para>
-->
<para>
通常，你会希望在计算机启动的时候启动数据库服务器。<indexterm>
     <primary>启动</>
     <secondary>启动服务器时</>
   </indexterm>
自动启动脚本是与操作系统相关的。<productname>PostgreSQL</productname>自己带了几个，
放在<filename>contrib/start-scripts</>目录里。需要 root 权限安装它们。
</para>

  
<para>
<!--
   Different systems have different conventions for starting up daemons
   at boot time. Many systems have a file
   <filename>/etc/rc.local</filename> or
   <filename>/etc/rc.d/rc.local</filename>. Others use <filename>init.d</filename> or
   <filename>rc.d</> directories. Whatever you do, the server must be
   run by the <productname>PostgreSQL</productname> user account
   <emphasis>and not by root</emphasis> or any other user. Therefore you
   probably should form your commands using
   <literal>su postgres -c '...'</literal>.  For example:
-->
不同的系统在引导时有不同的启动守护进程的方法，所以我们建议你先熟悉它。
许多系统有名字称为<filename>/etc/rc.local</filename>或<filename>/etc/rc.d/rc.local</filename>
这样的文件，其它的还有<filename>rc.d</>目录。不管你怎么做，都要记住服务器必须以
<productname>PostgreSQL</productname>用户帐户，<emphasis>而不是 root </emphasis>
或者任何其它用户身份运行。因此，你可能总是要用<literal>su postgres -c '...'</literal>这样的命令。比如：
<programlisting>
su postgres -c 'pg_ctl start -D /usr/local/pgsql/data -l serverlog'
</programlisting>
  </para>
  
<para>
<!--
   Here are a few more operating-system-specific suggestions. (In each
   case be sure to use the proper installation directory and user
   name where we show generic values.)
-->
下面是一些比较详细的与操作系统相关的建议。请注意把每个例子里的具体数值替换成合适的安装路径和用户名。
   <itemizedlist>
    <listitem>
     <para>
      <!-- 
  For <productname>FreeBSD</productname>, look at the file
      <filename>contrib/start-scripts/freebsd</filename> in the
      <productname>PostgreSQL</productname> source distribution.
      <indexterm><primary>FreeBSD</><secondary>start script</secondary></> 
  -->
  对于<productname>FreeBSD</productname>，看看<productname>PostgreSQL</productname>
  源代码版本里的<filename>contrib/start-scripts/freebsd</filename>文件。
  <indexterm><primary>FreeBSD</><secondary>启动脚本</secondary></>
     </para>
    </listitem>

    <listitem>
     
<para>
<!--
      On <productname>OpenBSD</productname>, add the following lines
      to the file <filename>/etc/rc.local</filename>:
      <indexterm><primary>OpenBSD</><secondary>start script</secondary></>
-->
在<productname>OpenBSD</productname>上，把下面几行加到<filename>/etc/rc.local</filename>文件里：
<indexterm><primary>OpenBSD</><secondary>启动脚本</secondary></>
<programlisting>
if [ -x /usr/local/pgsql/bin/pg_ctl -a -x /usr/local/pgsql/bin/postgres ]; then
    su -l postgres -c '/usr/local/pgsql/bin/pg_ctl start -s -l /var/postgresql/log -D /usr/local/pgsql/data'
    echo -n ' postgresql'
fi
</programlisting>
     </para>
    </listitem>

    <listitem>
     
<para>
<!--
      On <productname>Linux</productname> systems either add
      <indexterm><primary>Linux</><secondary>start script</secondary></>
-->
在<productname>Linux</productname>系统里，要么往<filename>/etc/rc.d/rc.local</filename>或
<filename>/etc/rc.local</filename>文件里加上下面几行：
<indexterm><primary>Linux</><secondary>启动脚本</secondary></>
<programlisting>
/usr/local/pgsql/bin/pg_ctl start -l logfile -D /usr/local/pgsql/data
</programlisting>
<!-- 
      to <filename>/etc/rc.d/rc.local</filename>
      or <filename>/etc/rc.local</filename> or look at the file
      <filename>contrib/start-scripts/linux</filename> in the
      <productname>PostgreSQL</productname> source distribution. 
-->
要么看看<productname>PostgreSQL</productname>源代码树里的
<filename>contrib/start-scripts/linux</filename>文件。
     </para>
    </listitem>

    <listitem>
     <!--
<para>
      On <productname>NetBSD</productname>, use either the
      <productname>FreeBSD</productname> or
      <productname>Linux</productname> start scripts, depending on
      preference.
      <indexterm><primary>NetBSD</><secondary>start script</secondary></>
     </para>
-->
<para>
在<productname>NetBSD</productname>上，你可以根据爱好选择<productname>FreeBSD</productname>
或<productname>Linux</productname>的启动脚本之一。
<indexterm><primary>NetBSD</><secondary>启动脚本</secondary></>
</para>
    </listitem>

    <listitem>
     
<para>
<!--
      On <productname>Solaris</productname>, create a file called
      <filename>/etc/init.d/postgresql</filename> that contains
      the following line:
      <indexterm><primary>Solaris</><secondary>start script</secondary></>
-->
在<productname>Solaris</productname>上，创建一个叫<filename>/etc/init.d/postgresql</filename>的文件，
包含下面行：<indexterm><primary>Solaris</><secondary>启动脚本</secondary></>
<programlisting>
su - postgres -c "/usr/local/pgsql/bin/pg_ctl start -l logfile -D /usr/local/pgsql/data"
</programlisting>
<!-- 
      Then, create a symbolic link to it in <filename>/etc/rc3.d</> as
      <filename>S99postgresql</>. 
-->
然后在<filename>/etc/rc3.d</>里创建一个指向它的符号链接，名字叫<filename>S99postgresql</>。
     </para>
    </listitem>
   </itemizedlist>

  </para>

   <!--
<para>
    While the server is running, its
    <acronym>PID</acronym> is stored in the file
    <filename>postmaster.pid</filename> in the data directory. This is
    used to prevent multiple server instances from
    running in the same data directory and can also be used for
    shutting down the server.
   </para>
-->
<para>
运行的时候，它的<acronym>PID</acronym>是保存在数据目录下的<filename>postmaster.pid</filename>
文件里的。这样做是为了避免多个服务器在同一个数据目录内运行，此文件同样可以用于关闭服务器。
</para>

   <sect2 id="server-start-failures">
    <!-- 
<title>Server Start-up Failures</title> 
-->
<title>服务器启动失败</title>

    <!--
<para>
     There are several common reasons the server might fail to
     start. Check the server's log file, or start it by hand (without
     redirecting standard output or standard error) and see what error
     messages appear. Below we explain some of the most common error
     messages in more detail.
    </para>
-->
<para>
有几个非常常见的原因会导致服务器启动失败。通过检查服务器日志或者使用手工启动的方法
(不做 stdout 和 stderr 的重定向)，就可以看到错误信息。下面我们更详细地解释了其中一些错误信息。
</para>

<para>
<screen>
LOG:  could not bind IPv4 socket: Address already in use
HINT:  Is another postmaster already running on port 5432? If not, wait a few seconds and retry.
FATAL:  could not create TCP/IP listen socket
</screen>
<!--
     This usually means just what it suggests: you tried to start
     another server on the same port where one is already running.
     However, if the kernel error message is not <computeroutput>Address
     already in use</computeroutput> or some variant of that, there might
     be a different problem. For example, trying to start a server
     on a reserved port number might draw something like:
-->
就像它提示的那样：你试图在已经有一个服务器运行着的端口上再运行了一个服务器。不过，
如果内核的错误信息不是<computeroutput> Address already in use </computeroutput>或者是其它的变种，
那就有可能是别的毛病。比如，试图在一个保留的端口上运行服务器会收到下面这样的信息：
<screen>
$ <userinput>postgres -p 666</userinput>
LOG:  could not bind IPv4 socket: Permission denied
HINT:  Is another postmaster already running on port 666? If not, wait a few seconds and retry.
FATAL:  could not create TCP/IP listen socket
</screen>
    </para>
    
<para>
<!--
     A message like:
-->
像这样的信息：
<screen>
FATAL:  could not create shared memory segment: Invalid argument
DETAIL:  Failed system call was shmget(key=5440001, size=4011376640, 03600).
</screen>
<!-- 
     probably means your kernel's limit on the size of shared memory is
     smaller than the work area <productname>PostgreSQL</productname>
     is trying to create (4011376640 bytes in this example). Or it could
     mean that you do not have System-V-style shared memory support
     configured into your kernel at all. As a temporary workaround, you
     can try starting the server with a smaller-than-normal number of
     buffers (<xref linkend="guc-shared-buffers">). You will eventually want
     to reconfigure your kernel to increase the allowed shared memory
     size. You might also see this message when trying to start multiple
     servers on the same machine, if their total space requested
     exceeds the kernel limit.
-->
可能意味着内核对共享内存区的限制小于<productname>PostgreSQL</productname>试图分配的缓冲区大小
(本例中是 4011376640 字节)。或者可能意味着你根本就没有配置 System-V 风格的共享内存支持。
作为一个临时的解决办法，你可以试着以小于正常数量的缓冲区数(<xref linkend="guc-shared-buffers">)
启动服务器。你最终还是会希望重新配置内核，以增加共享内存的尺寸。
如果你试图在同一台机器上启动多个服务器，而且它们所需的总空间超过了内核的限制，也会报这个错。
    </para>

<para>
<!--
     An error like:
-->
像下面这样的错误：
<screen>
FATAL:  could not create semaphores: No space left on device
DETAIL:  Failed system call was semget(5440126, 17, 03600).
</screen>
<!-- 
     does <emphasis>not</emphasis> mean you've run out of disk
     space. It means your kernel's limit on the number of <systemitem
     class="osname">System V</> semaphores is smaller than the number
     <productname>PostgreSQL</productname> wants to create. As above,
     you might be able to work around the problem by starting the
     server with a reduced number of allowed connections
     (<xref linkend="guc-max-connections">), but you'll eventually want to
     increase the kernel limit. 
-->
<emphasis>并不</emphasis>意味着着你已经用光磁盘空间了。它的意思是内核的
<systemitem class="osname">System V</>信号灯的限制小于<productname>PostgreSQL</productname>想创建的数量。
和上面一样，你可以通过减少允许的连接数(<xref linkend="guc-max-connections">)来绕开，
但最终你还是会希望修改内核的限制。
    </para>

    <!--
<para>
     If you get an <quote>illegal system call</> error, it is likely that
     shared memory or semaphores are not supported in your kernel at
     all. In that case your only option is to reconfigure the kernel to
     enable these features.
    </para>
-->
<para>
如果你收到一个<quote>illegal system call</>错误，那么很有可能是内核根本不支持共享内存或者信号灯。
如果是这样的话，你唯一的选择就是重新配置内核并且把这些特性打开。
</para>

    <!--
<para>
     Details about configuring <systemitem class="osname">System V</>
     <acronym>IPC</> facilities are given in <xref linkend="sysvipc">.
    </para>
-->
<para>
关于配置系统<systemitem class="osname">System V</> <acronym>IPC</>资源的细节见<xref linkend="sysvipc">。
</para>
   </sect2>

   <sect2 id="client-connection-problems">
    <!-- 
<title>Client Connection Problems</title> 
-->
<title>客户端连接问题</title>

    <!--
<para>
     Although the error conditions possible on the client side are quite
     varied and application-dependent, a few of them might be directly
     related to how the server was started. Conditions other than
     those shown below should be documented with the respective client
     application.
    </para>
-->
<para>
尽管可能在客户端出现的错误条件范围宽广，而且还和应用相关，但的确有几种错误与服务器的启动方式直接相关。
除了下面提到的几种错误以外的问题都应该在相应的客户端应用的文档中。
</para>

<para>
<screen>
psql: could not connect to server: Connection refused
        Is the server running on host "server.joe.com" and accepting
        TCP/IP connections on port 5432?
</screen>
<!-- 
     This is the generic <quote>I couldn't find a server to talk
     to</quote> failure. It looks like the above when TCP/IP
     communication is attempted. A common mistake is to forget to
     configure the server to allow TCP/IP connections. 
-->
这是纯粹的<quote>我找不到可以交谈的服务器</quote>错误。当试图进行 TCP/IP 通讯时它看起来像上面的样子。
常见的错误是忘记把服务器配置成允许 TCP/IP 连接。
    </para>


    
<para>
<!--
     Alternatively, you'll get this when attempting Unix-domain socket
     communication to a local server:
-->
另外，当试图通过一个 Unix 套接字与本机服务器通讯时，你会看到这个：
<screen>
psql: could not connect to server: No such file or directory
        Is the server running locally and accepting
        connections on Unix domain socket "/tmp/.s.PGSQL.5432"?
</screen>
    </para>

    <!--
<para>
     The last line is useful in verifying that the client is trying to
     connect to the right place. If there is in fact no server
     running there, the kernel error message will typically be either
     <computeroutput>Connection refused</computeroutput> or
     <computeroutput>No such file or directory</computeroutput>, as
     illustrated. (It is important to realize that
     <computeroutput>Connection refused</computeroutput> in this context
     does <emphasis>not</emphasis> mean that the server got your
     connection request and rejected it. That case will produce a
     different message, as shown in <xref
     linkend="client-authentication-problems">.) Other error messages
     such as <computeroutput>Connection timed out</computeroutput> might
     indicate more fundamental problems, like lack of network
     connectivity.
    </para>
-->
<para>
最后一行可以有效地验证客户端进行连接尝试时是否连对了位置。如果实际上没有服务器在那里运行，
典型的内核错误是像上面显示的那样或者是<computeroutput>Connection refused</computeroutput>或 
<computeroutput>No such file or directory</computeroutput>。尤其要注意的是这种环境下
<computeroutput>Connection refused</computeroutput>的信息显示<emphasis>并不</emphasis>
意味着服务器收到连接然后拒绝了连接。那样的话会产生一个不同的信息(像
<xref linkend="client-authentication-problems">里面显示的那样)。其它像
<computeroutput>Connection timed out</computeroutput>这样的信息表示更基本的问题，比如缺少网络连接等。
</para>
   </sect2>
  </sect1>

 <sect1 id="kernel-resources">
  <!-- 
  <title>Managing Kernel Resources</title> 
  -->
  <title>管理内核资源</title>

  <!--
<para>
   <productname>PostgreSQL</> can sometimes exhaust various operating system
   resource limits, especially when multiple copies of the server are running
   on the same system, or in very large installations.  This section explains
   the kernel resources used by <productname>PostgreSQL</> and the steps you
   can take to resolve problems related to kernel resource consumption.
  </para>
-->
<para>
<productname>PostgreSQL</>有时可能耗尽各种操作系统的资源上限，尤其是多个服务器副本在同一个系统上运行时，
或者在一个非常大的安装时。这种情况说明了<productname>PostgreSQL</>
使用的内核资源和解决问题可以采取的步骤都和内核资源消耗有关。
</para>

  <sect2 id="sysvipc">
   <!-- 
   <title>Shared Memory and Semaphores</title> 
   -->
   <title>共享内存和信号灯</title>

   <indexterm zone="sysvipc">
    <!-- 
<primary>shared memory</primary> 
-->
<primary>共享内存</primary>
   </indexterm>

   <indexterm zone="sysvipc">
    <!-- 
<primary>semaphores</primary> 
-->
<primary>信号灯</primary>
   </indexterm>

   <!--
<para>
    Shared memory and semaphores are collectively referred to as
    <quote><systemitem class="osname">System V</>
    <acronym>IPC</></quote> (together with message queues, which are not
    relevant for <productname>PostgreSQL</>).  Except on
    <systemitem class="osname">Windows</>, where <productname>PostgreSQL</>
    provides its own replacement implementation of these facilities, these
    facilities are required in order to run
    <productname>PostgreSQL</>.
   </para>
-->
<para>
共享内存和信号灯的正确叫法是<quote><systemitem class="osname">System V</> <acronym>IPC</></quote>
(还有消息队列，不过与<productname>PostgreSQL</>无关)。，
<productname>PostgreSQL</>只在<systemitem class="osname">Windows</>上自己提供这套机制的替换实现，
要运行<productname>PostgreSQL</>这些机制是必需的。
</para>

   <!--
<para>
    The complete lack of these facilities is usually manifested by an
    <errorname>Illegal system call</> error upon server start. In
    that case there is no alternative but to reconfigure your
    kernel.  <productname>PostgreSQL</> won't work without them.
    This situation is rare, however, among modern operating systems.
   </para>
-->
<para>
完全缺少这些机制的表现通常是在服务器启动时的<errorname>Illegal system call</>错误。
这时除了重新配置内核外别无选择。<productname>PostgreSQL</>没它们干不了活。
这种情况很少见，但是，在现代操作系统上会出现。
</para>

   <!--
<para>
    When <productname>PostgreSQL</> exceeds one of the various hard
    <acronym>IPC</> limits, the server will refuse to start and
    should leave an instructive error message describing the problem
    and what to do about it. (See also <xref
    linkend="server-start-failures">.) The relevant kernel
    parameters are named consistently across different systems; <xref
    linkend="sysvipc-parameters"> gives an overview. The methods to set
    them, however, vary. Suggestions for some platforms are given below.
   </para>
-->
<para>
如果<productname>PostgreSQL</>超出了这些<acronym>IPC</>资源的硬限制之一的时候就会拒绝启动，
并且留下一条相当有启发性的错误信息，描述问题以及需要为它做些什么
(又见<xref linkend="server-start-failures">)。相关的内核参数在不同系统之间有着相对固定的术语；
<xref linkend="sysvipc-parameters">是一个概况。不过，设置它们的方法却多种多样。
下面给出一些平台的建议。
</para>

   <note>
     <!--
<para>
       Prior to <productname>PostgreSQL</> 9.3, the amount of System V shared
       memory required to start the server was much larger.  If you are running
       an older version of the server, please consult the documentation for
       your server version.
     </para>
-->
<para>
<productname>PostgreSQL</> 9.3之前，System V共享内存的数量需要启动的服务器大得多。
如果你运行更老的服务器版本，请参考你的服务器版本的文档。
</para>
   </note>

   <table id="sysvipc-parameters">
    <!-- 
<title><systemitem class="osname">System V</> <acronym>IPC</> Parameters</title> 
-->
<title><systemitem class="osname">System V</> <acronym>IPC</>参数</title>

    <tgroup cols="3">
     <thead>
      <row>
       <!-- 
   <entry>Name</>
       <entry>Description</>
       <entry>Reasonable values</> 
   -->
   <entry>名字</>
       <entry>描述</>
       <entry>合理取值</>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><varname>SHMMAX</></>
       <!-- 
   <entry>Maximum size of shared memory segment (bytes)</>
       <entry>at least 1kB (more if running many copies of the server)</entry> 
   -->
   <entry>最大共享内存段尺寸(字节)</>
       <entry>至少 1kB (如果运行多个服务器副本需要更多)</entry>
      </row>

      <row>
       <entry><varname>SHMMIN</></>
       <!-- 
   <entry>Minimum size of shared memory segment (bytes)</> 
   -->
   <entry>最小共享内存段尺寸(字节)</>
       <entry>1</>
      </row>

      <row>
       <entry><varname>SHMALL</></>
       <!-- 
   <entry>Total amount of shared memory available (bytes or pages)</>
       <entry>if bytes, same as <varname>SHMMAX</varname>; if pages, <literal>ceil(SHMMAX/PAGE_SIZE)</literal></> 
   -->
   <entry>可用共享内存的总数量(字节或者页面)</>
       <entry>如果是字节，就和<varname>SHMMAX</varname>一样；如果是页面，<literal>ceil(SHMMAX/PAGE_SIZE)</literal></>
      </row>

      <row>
       <entry><varname>SHMSEG</></>
       <!-- 
   <entry>Maximum number of shared memory segments per process</>
       <entry>only 1 segment is needed, but the default is much higher</> 
   -->
   <entry>每进程最大共享内存段数量</>
       <entry>只需要 1 个段，不过缺省比这高得多。</>
      </row>

       <row>
        <entry><varname>SHMMNI</></>
        <!-- 
<entry>Maximum number of shared memory segments system-wide</>
        <entry>like <varname>SHMSEG</> plus room for other applications</> 
-->
<entry>系统范围最大共享内存段数量</>
        <entry>类似<varname>SHMSEG</>加上用于其它应用的空间</>
       </row>

       <row>
        <entry><varname>SEMMNI</></>
        <!-- 
<entry>Maximum number of semaphore identifiers (i.e., sets)</>
        <entry>at least <literal>ceil((max_connections + autovacuum_max_workers + 4) / 16)</literal></> 
-->
<entry>信号灯标识符的最小数量(也就是套)</>
        <entry>至少<literal>ceil((max_connections + autovacuum_max_workers + 4) / 16)</literal></>
       </row>

       <row>
        <entry><varname>SEMMNS</></>
        <!-- 
<entry>Maximum number of semaphores system-wide</>
        <entry><literal>ceil((max_connections + autovacuum_max_workers + 4) / 16) * 17</literal> plus room for other applications</>
-->
<entry>系统范围的最大信号灯数量</>
        <entry><literal>ceil((max_connections + autovacuum_max_workers + 4) / 16) * 17</literal>加上用于其它应用的空间</>
       </row>

       <row>
        <entry><varname>SEMMSL</></>
        <!-- 
<entry>Maximum number of semaphores per set</>
        <entry>at least 17</> 
-->
<entry>每套信号灯最小信号灯数量</>
        <entry>至少 17</>
       </row>

       <row>
        <entry><varname>SEMMAP</></>
        <!-- 
<entry>Number of entries in semaphore map</>
        <entry>see text</> 
-->
<entry>信号灯映射里的记录数量</>
        <entry>参阅本文</>
       </row>

       <row>
        <entry><varname>SEMVMX</></>
<!-- 
<entry>Maximum value of semaphore</>
        <entry>at least 1000 (The default is often 32767, don't change unless forced to)</> 
-->      
        <entry>信号灯的最大值</>
        <entry>至少 1000 ，缺省通常是 32767 ，除非被迫，否则不要修改</>
       </row>

     </tbody>
    </tgroup>
   </table>

   <!--
<para>
    <productname>PostgreSQL</> requires a few bytes of System V shared memory
    (typically 48 bytes, on 64-bit platforms) for each copy of the server.
    On most modern operating systems, this amount can easily be allocated.
    However, if you are running many copies of the server, or if other
    applications are also using System V shared memory, it may be necessary
    to increase <varname>SHMMAX</>, the maximum size in bytes of a shared
    memory segment, or <varname>SHMALL</>, the total amount of System V shared
    memory system-wide.  Note that <varname>SHMALL</> is measured in pages
    rather than bytes on many systems.
  </para>
-->
<para>
<productname>PostgreSQL</>的每个服务器的副本需要System V共享内存的少许字节（在64为平台上典型为48字节）。
在大多数现在的操作系统上，可以很容易的分配数量。然而，如果你运行了服务器的多个副本，
或者其他应用也使用System V共享内存，那么增大<varname>SHMMAX</>可能是必要的，共享内存段或<varname>SHMALL</>
的最大字节大小，为系统范围System V共享内存的总数量。注意<varname>SHMALL</>
在许多系统上是用页面数而不是字节数来计算的。
</para>

   <!--
<para>
    Less likely to cause problems is the minimum size for shared
    memory segments (<varname>SHMMIN</>), which should be at most
    approximately 32 bytes for <productname>PostgreSQL</> (it is
    usually just 1). The maximum number of segments system-wide
    (<varname>SHMMNI</>) or per-process (<varname>SHMSEG</>) are unlikely
    to cause a problem unless your system has them set to zero.
   </para>
-->
<para>
不太可能出问题的是共享内存段的最小尺寸(<varname>SHMMIN</>)，对<productname>PostgreSQL</>
来说大约是32字节左右(通常只是 1)，而系统范围(<varname>SHMMNI</>)或每进程(<varname>SHMSEG</>)
最大共享内存段数量不应该会产生问题，除非你的系统把它们设成零。
</para>

   <!--
<para>
    <productname>PostgreSQL</> uses one semaphore per allowed connection
    (<xref linkend="guc-max-connections">) and allowed autovacuum worker
    process (<xref linkend="guc-autovacuum-max-workers">), in sets of 16.
    Each such set will
    also contain a 17th semaphore which contains a <quote>magic
    number</quote>, to detect collision with semaphore sets used by
    other applications. The maximum number of semaphores in the system
    is set by <varname>SEMMNS</>, which consequently must be at least
    as high as <varname>max_connections</> plus
    <varname>autovacuum_max_workers</>, plus one extra for each 16
    allowed connections plus workers (see the formula in <xref
    linkend="sysvipc-parameters">).  The parameter <varname>SEMMNI</>
    determines the limit on the number of semaphore sets that can
    exist on the system at one time.  Hence this parameter must be at
    least <literal>ceil((max_connections + autovacuum_max_workers + 4) / 16)</>.
    Lowering the number
    of allowed connections is a temporary workaround for failures,
    which are usually confusingly worded <quote>No space
    left on device</>, from the function <function>semget</>.
   </para>
-->
<para>
<productname>PostgreSQL</>每个允许的连接使用一个信号灯(<xref linkend="guc-max-connections">)，
并且允许autovacuum工作进程(<xref linkend="guc-autovacuum-max-workers">)，以 16 个为一套。
每套信号灯还包含第 17 个信号灯，它里面存储一个<quote>magic number</quote>，
以检测和其它应用使用的信号灯集冲突。系统里的最大信号灯数目是由<varname>SEMMNS</>设置的，
因此这个值应该至少和<varname>max_connections</>加上<varname>autovacuum_max_workers</>设置一样大，
并且每 16 个连接和工作还要另外加一个(参阅<xref linkend="sysvipc-parameters">里面的公式)。
参数<varname>SEMMNI</>决定系统里一次可以存在的信号灯集的数目。
因此这个参数至少应该为<literal>ceil((max_connections + autovacuum_max_workers + 4) / 16)</>。
降低允许的连接数目是一个临时的绕开失败的方法，这个启动失败通常被来自函数<function>semget</>
的错误响应<quote>No space left on device</>搞得很让人迷惑。
</para>

   <!--
<para>
    In some cases it might also be necessary to increase
    <varname>SEMMAP</> to be at least on the order of
    <varname>SEMMNS</>. This parameter defines the size of the semaphore
    resource map, in which each contiguous block of available semaphores
    needs an entry. When a semaphore set is freed it is either added to
    an existing entry that is adjacent to the freed block or it is
    registered under a new map entry. If the map is full, the freed
    semaphores get lost (until reboot). Fragmentation of the semaphore
    space could over time lead to fewer available semaphores than there
    should be.
   </para>
-->
<para>
有时候还可能有必要增大<varname>SEMMAP</>，使之至少按照<varname>SEMMNS</>配置。
这个参数定义信号灯资源映射的尺寸，可用的每个连续的信号灯块在这个映射中存放一条记录。
每当一套信号灯被释放，那么它要么会加入到该映射中一条相连的已释放块的入口中，
要么注册成一条新的入口。如果映射填满了碎片，那么被释放的信号灯就丢失了(除非重启)。
因此信号灯空间的碎片时间长了会导致可用的信号灯比应该有的信号灯少。
</para>

   <!--
<para>
    The <varname>SEMMSL</> parameter, which determines how many
    semaphores can be in a set, must be at least 17 for
    <productname>PostgreSQL</>.
   </para>
-->
<para>
<varname>SEMMSL</>参数决定一套信号灯里可以有多少信号灯，
对于<productname>PostgreSQL</>而言应该至少是 17 。
</para>

   <!--
<para>
    Various other settings related to <quote>semaphore undo</>, such as
    <varname>SEMMNU</> and <varname>SEMUME</>, do not affect
    <productname>PostgreSQL</>.
   </para>
-->
<para>
许多设置与<quote>semaphore undo</>(信号灯恢复)有关，比如<varname>SEMMNU</>和<varname>SEMUME</>，
这些与<productname>PostgreSQL</>无关。
</para>


    <variablelist>
     <varlistentry>
      <term><systemitem class="osname">AIX</></term>
      <!-- 
  <indexterm><primary>AIX</><secondary>IPC configuration</></> 
  -->
  <indexterm><primary>AIX</><secondary>IPC 配置</></>
      <listitem>
       <!--
<para>
        At least as of version 5.1, it should not be necessary to do
        any special configuration for such parameters as
        <varname>SHMMAX</varname>, as it appears this is configured to
        allow all memory to be used as shared memory.  That is the
        sort of configuration commonly used for other databases such
        as <application>DB/2</application>.</para>
-->
<para>
至少对于版本 5.1 而言，我们没有必要为类似<varname>SHMMAX</varname>这样的参数做特殊的配置，
因为这个参数可以配置为所有内容都当作共享内存使用。这就是类似<application>DB/2</application>
这样的数据库常用的配置。
</para>
       <!--
<para> It might, however, be necessary to modify the global
       <command>ulimit</command> information in
       <filename>/etc/security/limits</filename>, as the default hard
       limits for file sizes (<varname>fsize</varname>) and numbers of
       files (<varname>nofiles</varname>) might be too low.
       </para>
-->
<para>
不过，我们可能有必要在<filename>/etc/security/limits</filename>里面修改全局<command>ulimit</command>信息，
因为文件大小的缺省硬限制(<varname>fsize</varname>)以及文件数(<varname>nofiles</varname>)可能太低了。
</para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">FreeBSD</></term>
      <!-- 
  <indexterm><primary>FreeBSD</><secondary>IPC configuration</></> 
  -->
  <indexterm><primary>FreeBSD</><secondary>IPC 配置</></>
      <listitem>
      
<para>
 <!--
        The default settings can be changed using
        the <command>sysctl</command> or
        <command>loader</command> interfaces.  The following
        parameters can be set using <command>sysctl</command>:
-->
缺省设置可以用<command>sysctl</command>或<command>loader</command>接口来修改。
下面的参数可以用<command>sysctl</command>设置：
<screen>
<prompt>#</prompt> <userinput>sysctl kern.ipc.shmall=32768</userinput>
<prompt>#</prompt> <userinput>sysctl kern.ipc.shmmax=134217728</userinput>
<prompt>#</prompt> <userinput>sysctl kern.ipc.semmap=256</userinput>
</screen>
        <!-- 
To have these settings persist over reboots, modify
        <filename>/etc/sysctl.conf</filename>. 
-->
要想让这些设置重启后有效，修改<filename>/etc/sysctl.conf</filename>文件。
       </para>

       
<para>
<!--
        The remaining semaphore settings are read-only as far as
        <command>sysctl</command> is concerned, but can be set in
        <filename>/boot/loader.conf</filename>:
-->
如果用<command>sysctl</command>，那么剩下的信号灯设置是只读的，
但是可以在<filename>/boot/loader.conf</filename>里设置：
<programlisting>
kern.ipc.semmni=256
kern.ipc.semmns=512
kern.ipc.semmnu=256
</programlisting>
<!-- 
        After modifying these values a reboot is required for the new
        settings to take affect. 
-->
修改完这些值以后需要重启以使新的设置生效。
       </para>

       <!--
<para>
        You might also want to configure your kernel to lock shared
        memory into RAM and prevent it from being paged out to swap.
        This can be accomplished using the <command>sysctl</command>
        setting <literal>kern.ipc.shm_use_phys</literal>.
       </para>
-->
<para>
你可能还想配置内核，把共享内存锁到 RAM 里，避免他们被交换到交换分区中。
这些可以通过使用<command>sysctl</command>设置<literal>kern.ipc.shm_use_phys</literal>来完成。
</para>

       <!--
<para>
        If running in FreeBSD jails by enabling <application>sysctl</>'s
        <literal>security.jail.sysvipc_allowed</>, <application>postmaster</>s
        running in different jails should be run by different operating system
        users.  This improves security because it prevents non-root users
        from interfering with shared memory or semaphores in different jails,
        and it allows the PostgreSQL IPC cleanup code to function properly.
        (In FreeBSD 6.0 and later the IPC cleanup code does not properly detect
        processes in other jails, preventing the running of postmasters on the
        same port in different jails.)
       </para>
-->
<para>
如果通过启用<application>sysctl</>的<literal>security.jail.sysvipc_allowed</>运行在 FreeBSD jail 中，
那么必须将<application>postmaster</>以不同的用户身份运行在不同的 jail 中。这样有助于增强安全性，
因为它防止了非 root 用户干扰不同 jail 中的共享内存或信号灯，并且允许 PostgreSQL IPC 清理代码功能。
在 FreeBSD 6.0 及之后的版本中，IPC 清理代码并不能正确侦测在其它 jail 中的进程，
因此无法防止其它 jail 中的 postmaster 进程占用相同的端口。
</para>

       <!--
<para>
        <systemitem class="osname">FreeBSD</> versions before 4.0 work like
        <systemitem class="osname">OpenBSD</> (see below).
       </para>
-->
<para>
<systemitem class="osname">FreeBSD</> 4.0 之前的版本类似<systemitem class="osname">OpenBSD</>(见下文)。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><systemitem class="osname">NetBSD</></term>
      <!-- 
  <indexterm><primary>NetBSD</><secondary>IPC configuration</></> 
  -->
  <indexterm><primary>NetBSD</><secondary>IPC 配置</></>
      <listitem>
       
<para>
<!--
        In <systemitem class="osname">NetBSD</> 5.0 and later,
        IPC parameters can be adjusted using <command>sysctl</command>,
        for example:
-->
<systemitem class="osname">NetBSD</> 5.0及以后，IPC参数可以用<command>sysctl</command>调整，例如：
<screen>
<prompt>$</prompt> <userinput>sysctl -w kern.ipc.shmmax=16777216</userinput>
</screen>
        <!-- 
To have these settings persist over reboots, modify
        <filename>/etc/sysctl.conf</filename>. 
-->
要想让这些设置重启后有效，修改<filename>/etc/sysctl.conf</filename>文件。
       </para>

       <!--
<para>
        You might also want to configure your kernel to lock shared
        memory into RAM and prevent it from being paged out to swap.
        This can be accomplished using the <command>sysctl</command>
        setting <literal>kern.ipc.shm_use_phys</literal>.
       </para>
-->
<para>
你可能还想配置内核，把共享内存锁到 RAM 里，避免他们被交换到交换分区中。
这些可以通过使用<command>sysctl</command>设置<literal>kern.ipc.shm_use_phys</literal>来完成。
</para>

       <!--
<para>
        <systemitem class="osname">NetBSD</> versions before 5.0 work like
        <systemitem class="osname">OpenBSD</> (see below), except that
        parameters should be set with the keyword <literal>options</> not
        <literal>option</>.
       </para>
-->
<para>
<systemitem class="osname">NetBSD</> 4.0 之前的版本类似<systemitem class="osname">OpenBSD</>(见下文)，
除了参数应该用关键字<literal>options</>而不是<literal>option</>来设置。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><systemitem class="osname">OpenBSD</></term>
      <!-- 
  <indexterm><primary>OpenBSD</><secondary>IPC configuration</></> 
  -->
  <indexterm><primary>OpenBSD</><secondary>IPC 配置</></>
      <listitem>
       
<para>
<!--
        The options <varname>SYSVSHM</> and <varname>SYSVSEM</> need
        to be enabled when the kernel is compiled. (They are by
        default.) The maximum size of shared memory is determined by
        the option <varname>SHMMAXPGS</> (in pages). The following
        shows an example of how to set the various parameters:
-->
编译内核时需要把选项<varname>SYSVSHM</>和<varname>SYSVSEM</>打开(缺省是打开的)。
共享内存的最大尺寸是由选项<varname>SHMMAXPGS</>(以页计)决定的。
下面显示了一个如何设置这些参数的例子：
<programlisting>
option        SYSVSHM
option        SHMMAXPGS=4096
option        SHMSEG=256

option        SYSVSEM
option        SEMMNI=256
option        SEMMNS=512
option        SEMMNU=256
option        SEMMAP=256
</programlisting>
       </para>

       <!--
<para>
        You might also want to configure your kernel to lock shared
        memory into RAM and prevent it from being paged out to swap.
        This can be accomplished using the <command>sysctl</command>
        setting <literal>kern.ipc.shm_use_phys</literal>.
       </para>
-->
<para>
你可能还想配置内核，把共享内存锁在 RAM 中以避免它们被交换出去，
我们可以通过使用<command>sysctl</command>设置<literal>kern.ipc.shm_use_phys</literal>来完成。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><systemitem class="osname">HP-UX</></term>
      <!-- 
  <indexterm><primary>HP-UX</><secondary>IPC configuration</></> 
  -->
  <indexterm><primary>HP-UX</><secondary>IPC 配置</></>
      <listitem>
       <!--
<para>
        The default settings tend to suffice for normal installations.
        On <productname>HP-UX</> 10, the factory default for
        <varname>SEMMNS</> is 128, which might be too low for larger
        database sites.
       </para>
-->
<para>
缺省设置看来对普通安装是足够的了。对于<productname>HP-UX</> 10 ，
<varname>SEMMNS</>的出厂缺省是 128 ，可能对大的数据库节点来说太小了。
</para>
       <!--
<para>
        <acronym>IPC</> parameters can be set in the <application>System
        Administration Manager</> (<acronym>SAM</>) under
        <menuchoice><guimenu>Kernel
        Configuration</><guimenuitem>Configurable Parameters</></>. Choose
        <guibutton>Create A New Kernel</> when you're done.
       </para>
-->
<para>
<acronym>IPC</>可以在<application>System Administration Manager</>(<acronym>SAM</>)下面的
<menuchoice><guimenu>Kernel Configuration</><guimenuitem>Configurable Parameters</></>配置。
配置完了以后选择<guibutton>Create A New Kernel</>选项。
</para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">Linux</></term>
      <!-- 
  <indexterm><primary>Linux</><secondary>IPC configuration</></> 
  -->
  <indexterm><primary>Linux</><secondary>IPC 配置</></>
      <listitem>
       <!--
<para>
        The default maximum segment size is 32 MB, and the
        default maximum total size is 2097152
        pages.  A page is almost always 4096 bytes except in unusual
        kernel configurations with <quote>huge pages</quote>
        (use <literal>getconf PAGE_SIZE</literal> to verify).
       </para>
-->
<para>
缺省最大段大小为32MB，缺省的最大总字节为2097152页。一页通常是4096字节，
除了带有<quote>huge pages</quote>的不寻常的内核配置（使用<literal>getconf PAGE_SIZE</literal>来校验）。
</para>
       
<para>
<!--
        The shared memory size settings can be changed via the
        <command>sysctl</command> interface.  For example, to allow 16 GB:
-->
共享内存大小设置可以通过<command>sysctl</command>接口改变。例如，要允许16 GB:
<screen>
<prompt>$</prompt> <userinput>sysctl -w kernel.shmmax=17179869184</userinput>
<prompt>$</prompt> <userinput>sysctl -w kernel.shmall=4194304</userinput>
</screen>
<!-- 
        In addition these settings can be preserved between reboots in
        the file <filename>/etc/sysctl.conf</filename>.  Doing that is
        highly recommended.
 -->
为了这些设置在重启后保持有效，将这些设置放到<filename>/etc/sysctl.conf</filename>里。这样做是高度推荐的。
       </para>

       
<para>
<!--
        Ancient distributions might not have the <command>sysctl</command> program,
        but equivalent changes can be made by manipulating the
        <filename>/proc</filename> file system:
-->
老版本里可能没有<command>sysctl</command>程序，但是同样的改变可以通过操作<filename>/proc</filename>文件系统来做：
<screen>
<prompt>$</prompt> <userinput>echo 17179869184 &gt;/proc/sys/kernel/shmmax</userinput>
<prompt>$</prompt> <userinput>echo 4194304 &gt;/proc/sys/kernel/shmall</userinput>
</screen>
       </para>

       <!--
<para>
        The remaining defaults are quite generously sized, and usually
        do not require changes.
       </para>
-->
<para>
剩下的缺省是相当宽松的大小，通常不需要改变。
</para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">Mac OS X</></term>
      <!-- 
  <indexterm><primary>Mac OS X</><secondary>IPC configuration</></> 
  -->
  <indexterm><primary>Mac OS X</><secondary>IPC 配置</></>
      <listitem>
      
<para>
 <!--
 The recommended method for configuring shared memory in OS X
        is to create a file named <filename>/etc/sysctl.conf</>,
        containing variable assignments such as:
-->
在 OS X 中配置共享内存推荐的方法是创建一个名为<filename>/etc/sysctl.conf</>的文件，
包含变量赋值，例如：
<programlisting>
kern.sysv.shmmax=4194304
kern.sysv.shmmin=1
kern.sysv.shmmni=32
kern.sysv.shmseg=8
kern.sysv.shmall=1024
</programlisting>
<!-- 
        Note that in some OS X versions,
        <emphasis>all five</> shared-memory parameters must be set in
        <filename>/etc/sysctl.conf</>, else the values will be ignored. 
-->
注意在某些OS X版本里，<emphasis>所有五个</>共享内存参数必须都在
<filename>/etc/sysctl.conf</>中设置，否则将会被忽略。
       </para>

       <!--
<para>
        Beware that recent releases of OS X ignore attempts to set
        <varname>SHMMAX</> to a value that isn't an exact multiple of 4096.
       </para>
-->
<para>
还要注意最近版本的 OS X 将拒绝把<varname>SHMMAX</>的数值设置为非 4096 的倍数。
</para>

       <!--
<para>
        <varname>SHMALL</> is measured in 4 kB pages on this platform.
       </para>
-->
<para>
在这个平台上，<varname>SHMALL</>是用 4KB 页来度量的。
</para>

       <!--
<para>
        In older OS X versions, you will need to reboot to have changes in the
        shared memory parameters take effect.  As of 10.5 it is possible to
        change all but <varname>SHMMNI</> on the fly, using
        <application>sysctl</>.  But it's still best to set up your preferred
        values via <filename>/etc/sysctl.conf</>, so that the values will be
        kept across reboots.
       </para>
-->
<para>
在老的OS X版本里，你将需要重启以使共享内存配置的改变生效。自OS X 10.5起，在运行中修改除了
<varname>SHMMNI</>的所有参数成为可能，使用<application>sysctl</>。但是通过<filename>/etc/sysctl.conf</>
来设置你喜欢的数值仍然是最好的，因为这样这些数值在重启以后仍然保留。
</para>
      
<para>
 <!-- 
 The file <filename>/etc/sysctl.conf</> is only honored in OS X
        10.3.9 and later.  If you are running a previous 10.3.x release,
        you must edit the file <filename>/etc/rc</>
        and change the values in the following commands:
-->
文件<filename>/etc/sysctl.conf</>只在OS X 10.3.9及以后的版本中遵守。如果你正在运行一个10.3.x之前的版本，
你必须编辑文件<filename>/etc/rc</>并在下列的命令中改变数值。
<programlisting>
sysctl -w kern.sysv.shmmax
sysctl -w kern.sysv.shmmin
sysctl -w kern.sysv.shmmni
sysctl -w kern.sysv.shmseg
sysctl -w kern.sysv.shmall
</programlisting>
<!-- 
        Note that
        <filename>/etc/rc</> is usually overwritten by OS X system updates,
        so you should expect to have to redo these edits after each update. 
-->
注意<filename>/etc/rc</>通常通过OS X系统更新重写，所以你应该预料到在每次更新后必须重做这些编辑。
       </para>

       <!--
<para>
        In OS X 10.2 and earlier, instead edit these commands in the file
        <filename>/System/Library/StartupItems/SystemTuning/SystemTuning</>.
       </para>
-->
<para>
在OS X 10.2以及更早的版本里，在<filename>/System/Library/StartupItems/SystemTuning/SystemTuning</>
里编辑这些命令。
</para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">SCO OpenServer</></term>
      <!-- 
  <indexterm><primary>SCO OpenServer</><secondary>IPC configuration</></> 
  -->
  <indexterm><primary>SCO OpenServer</><secondary>IPC 配置</></>
      <listitem>
       
<para>
<!--
        In the default configuration, only 512 kB of shared memory per
        segment is allowed. To increase the setting, first change to the
        directory <filename>/etc/conf/cf.d</>. To display the current value of
        <varname>SHMMAX</>, run:
-->
缺省配置时，只允许每段 512KB 共享内存。要增大设置，首先进入<filename>/etc/conf/cf.d</>目录。
要显示当前以字节记的<varname>SHMMAX</>，运行：
<programlisting>
./configure -y SHMMAX
</programlisting>
        <!-- 
To set a new value for <varname>SHMMAX</>, run: 
-->
设置<varname>SHMMAX</>的新值：
<programlisting>
./configure SHMMAX=<replaceable>value</>
</programlisting>
<!-- 
        where <replaceable>value</> is the new value you want to use
        (in bytes). After setting <varname>SHMMAX</>, rebuild the kernel: 
-->
这里<replaceable>value</>是你想设置的以字节记的新值。设置完<varname>SHMMAX</>以后重新编译内核：
<programlisting>
./link_unix
</programlisting>
        <!-- and reboot. -->
然后重启。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <!-- 
  <term><systemitem class="osname">Solaris</> 2.6 to 2.9 (Solaris
      6 to Solaris 9)</term>
      <indexterm><primary>Solaris</><secondary>IPC configuration</></> 
  -->
  <term><systemitem class="osname">Solaris</> 2.6 到 2.9 (Solaris
      6 到 Solaris 9)</term>
      <indexterm><primary>Solaris</><secondary>IPC 配置</></>
      <listitem>
       
<para>
<!--
        The relevant settings can be changed in
        <filename>/etc/system</>, for example:
-->
相关的设置可以在<filename>/etc/system</>里面修改，例如：
<programlisting>
set shmsys:shminfo_shmmax=0x2000000
set shmsys:shminfo_shmmin=1
set shmsys:shminfo_shmmni=256
set shmsys:shminfo_shmseg=256

set semsys:seminfo_semmap=256
set semsys:seminfo_semmni=512
set semsys:seminfo_semmns=512
set semsys:seminfo_semmsl=32
</programlisting>
<!-- 
        You need to reboot for the changes to take effect.  See also
        <ulink url="http://sunsite.uakom.sk/sunworldonline/swol-09-1997/swol-09-insidesolaris.html"></ulink>
        for information on shared memory under older versions of Solaris. 
-->
你需要重启以使这些修改生效。又见<ulink url="http://sunsite.uakom.sk/sunworldonline/swol-09-1997/swol-09-insidesolaris.html"></ulink>
获取关于老版本的Solaris共享内存的信息。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <!-- 
  <term><systemitem class="osname">Solaris</> 2.10 (Solaris
      10) and later</term> 
  -->
  <term><systemitem class="osname">Solaris</> 2.10 (Solaris
      10) 及以后</term>
      <term><systemitem class="osname">OpenSolaris</></term>
      <listitem>
      
<para>
 <!--
  In Solaris 10 and later, and OpenSolaris, the default shared memory and
        semaphore settings are good enough for most
        <productname>PostgreSQL</> applications.  Solaris now defaults
        to a <varname>SHMMAX</> of one-quarter of system <acronym>RAM</>.
        To further adjust this setting, use a project setting associated
        with the <literal>postgres</> user.  For example, run the
        following as <literal>root</>:
-->
Solaris 10及以后的版本，以及OpenSolaris，缺省的共享内存和信号灯的设置对大多数<productname>PostgreSQL</>
应用来说是足够的。Solaris现在对<varname>SHMMAX</>的缺省是系统<acronym>RAM</>的四分之一。
要进一步调整这些设置，使用一个和<literal>postgres</>用户相关的项目设置。例如，作为<literal>root</>
运行下列命令：
<programlisting>
projadd -c "PostgreSQL DB User" -K "project.max-shm-memory=(privileged,8GB,deny)" -U postgres -G postgres user.postgres
</programlisting>
       </para>

       <!--
<para>
        This command adds the <literal>user.postgres</> project and
        sets the shared memory maximum for the <literal>postgres</>
        user to 8GB, and takes effect the next time that user logs
        in, or when you restart <productname>PostgreSQL</> (not reload).
        The above assumes that <productname>PostgreSQL</> is run by
        the <literal>postgres</> user in the <literal>postgres</>
        group.  No server reboot is required.
       </para>
-->
<para>
这些命令增加<literal>user.postgres</>项目并且设置<literal>postgres</>用户的最大共享内存为8GB，
在下次用户登录时生效，或当你重启<productname>PostgreSQL</>（不是重新加载）生效。
上面的是假设<productname>PostgreSQL</>由在<literal>postgres</>组里面的<literal>postgres</>用户运行。
不需要服务器重启。
</para>
       
<para>
<!--
        Other recommended kernel setting changes for database servers which will
        have a large number of connections are:
-->
其他推荐的数据库服务器的内核设置修改将有大量的连接：
<programlisting>
project.max-shm-ids=(priv,32768,deny)
project.max-sem-ids=(priv,4096,deny)
project.max-msg-ids=(priv,4096,deny)
</programlisting>
       </para>

       <!--
<para>
        Additionally, if you are running <productname>PostgreSQL</>
        inside a zone, you may need to raise the zone resource usage
        limits as well.  See "Chapter2:  Projects and Tasks" in the
        <citetitle>System Administrator's Guide</> for more
        information on <literal>projects</> and <command>prctl</>.
       </para>
-->
<para>
此外，如果你在一个区域里面运行<productname>PostgreSQL</>，你可能也需要提高区域资源使用的限制。
参阅<citetitle>System Administrator's Guide</>里面的"Chapter2:  Projects and Tasks"
获取更多关于<literal>projects</>和<command>prctl</>的信息。
</para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">UnixWare</></term>
      <!-- 
  <indexterm><primary>UnixWare</><secondary>IPC configuration</></> 
  -->
  <indexterm><primary>UnixWare</><secondary>IPC 配置</></>
      <listitem>
      
<para>
 <!--
        On <productname>UnixWare</> 7, the maximum size for shared
        memory segments is 512 kB in the default configuration.
        To display the current value of <varname>SHMMAX</>, run:
-->
在<productname>UnixWare</> 7 上，缺省配置里的最大共享内存段是 512kB 。
要显示<varname>SHMMAX</>的当前值，运行：
<programlisting>
/etc/conf/bin/idtune -g SHMMAX
</programlisting>
<!-- 
        which displays the current, default, minimum, and maximum
        values. To set a new value for <varname>SHMMAX</>,
        run:
 -->
就会显示以字节记的当前的缺省的最小和最大值。要给<varname>SHMMAX</>设置一个新值，运行：
<programlisting>
/etc/conf/bin/idtune SHMMAX <replaceable>value</>
</programlisting>
<!-- 
        where <replaceable>value</> is the new value you want to use
        (in bytes). After setting <varname>SHMMAX</>, rebuild the
        kernel: 
-->
<replaceable>value</>是你想设置的以字节记的新值。设置完<varname>SHMMAX</>后，重建内核：
<programlisting>
/etc/conf/bin/idbuild -B
</programlisting>
        <!-- 
and reboot. 
-->
然后重启。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
  </sect2>

  <sect2>
   <!-- 
   <title>Resource Limits</title> 
   -->
   <title>资源限制</title>
  
<para>
 <!--
    Unix-like operating systems enforce various kinds of resource limits
    that might interfere with the operation of your
    <productname>PostgreSQL</productname> server. Of particular
    importance are limits on the number of processes per user, the
    number of open files per process, and the amount of memory available
    to each process. Each of these have a <quote>hard</quote> and a
    <quote>soft</quote> limit. The soft limit is what actually counts
    but it can be changed by the user up to the hard limit. The hard
    limit can only be changed by the root user. The system call
    <function>setrlimit</function> is responsible for setting these
    parameters. The shell's built-in command <command>ulimit</command>
    (Bourne shells) or <command>limit</command> (<application>csh</>) is
    used to control the resource limits from the command line. On
    BSD-derived systems the file <filename>/etc/login.conf</filename>
    controls the various resource limits set during login. See the
    operating system documentation for details. The relevant
    parameters are <varname>maxproc</varname>,
    <varname>openfiles</varname>, and <varname>datasize</varname>. For
    example:
-->
Unix 类系统强制了许多资源限制，这些限制可能干扰<productname>PostgreSQL</productname>服务器的运行。
这里尤其重要是对每个用户的进程数目的限制、每个进程打开文件数目、以及每个进程可用的内存。
这些限制中每个都有一个<quote>硬</quote>限制和一个<quote>软</quote>限制。实际使用的是软限制，
但用户可以自己修改成最大为硬限制的数目。而硬限制是只能由 root 用户修改的限制。
系统调用<function>setrlimit</function>负责设置这些参数。shell 的内建命令<command>ulimit</command>
(Bourne shells) 或<command>limit</command>(<application>csh</>) 就是用于在命令行上控制资源限制的。
在 BSD 衍生的系统上，<filename>/etc/login.conf</filename>文件控制在登录时对各种资源设置什么样的限制数值。
参阅操作系统文档获取细节。相关的参数是<varname>maxproc</varname>,<varname>openfiles</varname>,
<varname>datasize</varname> 。比如：
<programlisting>
default:\
...
        :datasize-cur=256M:\
        :maxproc-cur=256:\
        :openfiles-cur=256:\
...
</programlisting>
<!-- 
    (<literal>-cur</literal> is the soft limit.  Append
    <literal>-max</literal> to set the hard limit.) 
-->
<literal>-cur</literal>是软限制，后面附加<literal>-max</literal>就可以设置硬限制。
   </para>

   
<para>
<!--
    Kernels can also have system-wide limits on some resources.
-->
内核通常也有一些系统范围的资源限制。
    <itemizedlist>
     <listitem>
<!-- 
      <para>
      On <productname>Linux</productname>
      <filename>/proc/sys/fs/file-max</filename> determines the
      maximum number of open files that the kernel will support.  It can
      be changed by writing a different number into the file or by
      adding an assignment in <filename>/etc/sysctl.conf</filename>.
      The maximum limit of files per process is fixed at the time the
      kernel is compiled; see
      <filename>/usr/src/linux/Documentation/proc.txt</filename> for
      more information.
      </para> 
-->
<para>
在<productname>Linux</productname>上，<filename>/proc/sys/fs/file-max</filename>
决定内核可以支持的最大文件数。你可以通过往该文件写入一个不同的数值修改此值，
或者在<filename>/etc/sysctl.conf</filename>里增加一个赋值。
每个进程的最大打开文件限制是在编译内核的时候固定的；
参阅<filename>/usr/src/linux/Documentation/proc.txt</filename>获取更多信息。
</para>
     </listitem>
    </itemizedlist>
   </para>

   <!--
<para>
    The <productname>PostgreSQL</productname> server uses one process
    per connection so you should provide for at least as many processes
    as allowed connections, in addition to what you need for the rest
    of your system.  This is usually not a problem but if you run
    several servers on one machine things might get tight.
   </para>
-->
<para>
<productname>PostgreSQL</productname>服务器每个连接都使用一个进程，
所以你应该至少允许和连接数相同的进程数，再加上系统其它部分所需要的数目。
通常这个并不是什么问题，但如果你在一台机器上运行多个服务器，那你就要把事情理清楚。
</para>

   <!--
<para>
    The factory default limit on open files is often set to
    <quote>socially friendly</quote> values that allow many users to
    coexist on a machine without using an inappropriate fraction of
    the system resources.  If you run many servers on a machine this
    is perhaps what you want, but on dedicated servers you might want to
    raise this limit.
   </para>
-->
<para>
打开文件数目的出厂缺省设置通常设置为<quote>社会友好</quote>数值，
就是说允许许多用户共存一台机器，而不会导致系统资源使用的不当比例。
如果你在一台机器上运行许多服务器，这也许就是你想要的，但是在特殊的服务器上，
你可能需要提高这个限制。
</para>

   <!--
<para>
    On the other side of the coin, some systems allow individual
    processes to open large numbers of files; if more than a few
    processes do so then the system-wide limit can easily be exceeded.
    If you find this happening, and you do not want to alter the
    system-wide limit, you can set <productname>PostgreSQL</>'s <xref
    linkend="guc-max-files-per-process"> configuration parameter to
    limit the consumption of open files.
   </para>
-->
<para>
问题的另外一边，一些系统允许独立的进程打开非常多的文件；如果有几个进程这么干，
那系统范围的上限就很容易达到。如果你发现这样的现像，并且不想修改系统范围的限制，
你就可以设置<productname>PostgreSQL</>的<xref linkend="guc-max-files-per-process">
配置参数来限制打开文件数的消耗。
</para>
  </sect2>

  <sect2 id="linux-memory-overcommit">
   <!-- 
   <title>Linux Memory Overcommit</title> 
   -->
   <title>Linux 内存过提交</title>

   <!--
<para>
    In Linux 2.4 and later, the default virtual memory behavior is not
    optimal for <productname>PostgreSQL</productname>. Because of the
    way that the kernel implements memory overcommit, the kernel might
    terminate the <productname>PostgreSQL</productname> postmaster (the
    master server process) if the memory demands of either
    <productname>PostgreSQL</productname> or another process cause the
    system to run out of virtual memory.
   </para>
-->
<para>
在Linux 2.4 以及之后的版本里，缺省的虚拟内存的行为不是对<productname>PostgreSQL</productname>最优的。
原因在于内核实现内存过提交的方法，如果其它进程的内存请求导致系统用光虚拟内存，
那么内核可能会终止<productname>PostgreSQL</productname>主服务器进程。
</para>
   
<para>
<!--
    If this happens, you will see a kernel message that looks like
    this (consult your system documentation and configuration on where
    to look for such a message):
-->
如果发生了这样的事情，你会看到像下面这样的内核信息(参考你的系统文档和配置，
看看在哪里能看到这样的信息)：
<programlisting>
Out of Memory: Killed process 12345 (postgres).
</programlisting>
<!-- 
    This indicates that the <filename>postgres</filename> process
    has been terminated due to memory pressure.
    Although existing database connections will continue to function
    normally, no new connections will be accepted.  To recover,
    <productname>PostgreSQL</productname> will need to be restarted. 
-->
这表明<filename>postgres</filename>因为内存压力而终止了。尽管现有的数据连接将继续正常运转，
但是新的连接将无法接受。要想恢复，你应该重启<productname>PostgreSQL</productname>。
   </para>

   <!--
<para>
    One way to avoid this problem is to run
    <productname>PostgreSQL</productname> on a machine where you can
    be sure that other processes will not run the machine out of
    memory.  If memory is tight, increasing the swap space of the
    operating system can help avoid the problem, because the
    out-of-memory (OOM) killer is invoked only when physical memory and
    swap space are exhausted.
   </para>
-->
<para>
一个避免这个问题的方法是在一台你确信不会因为其它进程而耗尽内存的机器上运行<productname>PostgreSQL</productname>。
</para>

   <!--
<para>
    If <productname>PostgreSQL</productname> itself is the cause of the
    system running out of memory, you can avoid the problem by changing
    your configuration.  In some cases, it may help to lower memory-related
    configuration parameters, particularly
    <link linkend="guc-shared-buffers"><varname>shared_buffers</></link>
    and <link linkend="guc-work-mem"><varname>work_mem</></link>.  In
    other cases, the problem may be caused by allowing too many connections
    to the database server itself.  In many cases, it may be better to reduce
    <link linkend="guc-max-connections"><varname>max_connections</></link>
    and instead make use of external connection-pooling software.
   </para>
-->
<para>
如果<productname>PostgreSQL</productname>本身是系统耗尽内存的原因，你可以通过改变你的配置来避免这个问题。
在某些情况下，这样可能帮助降低内存相关的配置参数，尤其是<link linkend="guc-shared-buffers"><varname>shared_buffers</></link>
和<link linkend="guc-work-mem"><varname>work_mem</></link>。其他情况下，
这个问题可能是由于允许太多的连接到数据库服务器本身引起的。在许多情况下，
减少<link linkend="guc-max-connections"><varname>max_connections</></link>
而不是利用外部连接池的软件会更好。
</para>

   
<para>
<!--
    On Linux 2.6 and later, it is possible to modify the
    kernel's behavior so that it will not <quote>overcommit</> memory.
    Although this setting will not prevent the <ulink
    url="http://lwn.net/Articles/104179/">OOM killer</> from being invoked
    altogether, it will lower the chances significantly and will therefore
    lead to more robust system behavior.  This is done by selecting strict
    overcommit mode via <command>sysctl</command>:
-->
在 Linux 2.6 以及以后的版本里，可以修改内存的行为，这样它就不会再<quote>过提交</>内存。
尽管这个设置将不会完全阻止<ulink url="http://lwn.net/Articles/104179/">OOM killer</>
被引用，然是它将显著地减少并且将因此导致更稳健的系统行为。
这是通过用<command>sysctl</command>选取一个严格的过提交模式实现的：
<programlisting>
sysctl -w vm.overcommit_memory=2
</programlisting>
<!-- 
    or placing an equivalent entry in <filename>/etc/sysctl.conf</>.
    You might also wish to modify the related setting
    <varname>vm.overcommit_ratio</>.  For details see the kernel documentation
    file <filename>Documentation/vm/overcommit-accounting</>. 
-->
或者在<filename>/etc/sysctl.conf</>里放一个等效的条目。你可能还希望修改相关的
<varname>vm.overcommit_ratio</>设置。详细信息请参阅内核文档的
<filename>Documentation/vm/overcommit-accounting</>文件。
   </para>
   
<para>
<!--
    Another approach, which can be used with or without altering
    <varname>vm.overcommit_memory</>, is to set the process-specific
    <varname>oom_score_adj</> value for the postmaster process to
    <literal>-1000</>, thereby guaranteeing it will not be targeted by the OOM
    killer.  The simplest way to do this is to execute
-->
另外一种方法，改变或不改变<varname>vm.overcommit_memory</>都可以使用，
设置与进程相关的<varname>oom_score_adj</>值为主进程<literal>-1000</>，
从而保证它不会成为OOM killer的目标。
最简单的方法是在调用postmaster之前在postmaster的启动脚本执行：
<programlisting>
echo -1000 > /proc/self/oom_score_adj
</programlisting>
<!-- 
    in the postmaster's startup script just before invoking the postmaster.
    Note that this action must be done as root, or it will have no effect;
    so a root-owned startup script is the easiest place to do it.  If you
    do this, you may also wish to build <productname>PostgreSQL</>
    with <literal>-DLINUX_OOM_SCORE_ADJ=0</> added to <varname>CPPFLAGS</>.
    That will cause postmaster child processes to run with the normal
    <varname>oom_score_adj</> value of zero, so that the OOM killer can still
    target them at need. 
-->
请注意，这个操作必须由root来做，否则将不会有任何作用；所以一个root所有的启动脚本是做这个最简单的地方。
如果你这样做，你可能也希望用<literal>-DLINUX_OOM_SCORE_ADJ=0</>添加到<varname>CPPFLAGS</>
来建立<productname>PostgreSQL</>。这将导致主子进程以标准<varname>oom_score_adj</>值0来运行，
所以OOM killer仍然可以在需要时以它们为目标。
   </para>

   <!--
<para>
    Older Linux kernels do not offer <filename>/proc/self/oom_score_adj</>,
    but may have a previous version of the same functionality called
    <filename>/proc/self/oom_adj</>.  This works the same except the disable
    value is <literal>-17</> not <literal>-1000</>.  The corresponding
    build flag for <productname>PostgreSQL</> is
    <literal>-DLINUX_OOM_ADJ=0</>.
   </para>
-->
<para>
老版本的Linux内核不提供<filename>/proc/self/oom_score_adj</>，但是可能有相同功能的名为
<filename>/proc/self/oom_adj</>的以前的版本。除了禁用值为<literal>-17</>而不是<literal>-1000</>
外，它们做相同的工作。相应的<productname>PostgreSQL</>的建立标识为<literal>-DLINUX_OOM_ADJ=0</>。
</para>

   <note>
   <!--
<para>
    Some vendors' Linux 2.4 kernels are reported to have early versions
    of the 2.6 overcommit <command>sysctl</command> parameter.  However, setting
    <literal>vm.overcommit_memory</> to 2
    on a 2.4 kernel that does not have the relevant code will make
    things worse, not better.  It is recommended that you inspect
    the actual kernel source code (see the function
    <function>vm_enough_memory</> in the file <filename>mm/mmap.c</>)
    to verify what is supported in your kernel before you try this in a 2.4
    installation.  The presence of the <filename>overcommit-accounting</>
    documentation file should <emphasis>not</> be taken as evidence that the
    feature is there.  If in any doubt, consult a kernel expert or your
    kernel vendor.
   </para>
-->
<para>
有些供应商的 Linux 2.4 内核有着早期 2.6 过提交的<command>sysctl</command>。不过，
在没有相关代码的2.4内核里设置<literal>vm.overcommit_memory</>为 2 只会让事情更糟，
而不是更好。我们建议你检查一下实际的内核源代码(参阅文件<filename>mm/mmap.c</>
里面的<function>vm_enough_memory</>函数)，核实一下这个是在你的内核里存在的，
然后再在 2.4 内核里使用这个特性。文档文件<filename>overcommit-accounting</>
的存在<emphasis>不能</>当作是这个特性存在的证明。如果有问题，请询问你的内核供应商的专家。
</para>
   </note>
  </sect2>
 </sect1>


 <sect1 id="server-shutdown">
  <!-- 
  <title>Shutting Down the Server</title> 
  -->
  <title>关闭服务器</title>

  <indexterm zone="server-shutdown">
   <!-- 
   <primary>shutdown</>
   -->
   <primary>关闭</>
  </indexterm>

<para>
<!--
   There are several ways to shut down the database server. You control
   the type of shutdown by sending different signals to the master
   <command>postgres</command> process.
-->
有好几种关闭数据库服务器的方法。通过给<command>postgres</command>进程发送不同的信号，
你就可以控制关闭服务器的不同方法。
   <variablelist>
    <varlistentry>
     <term><systemitem>SIGTERM</systemitem><indexterm><primary>SIGTERM</></></term>
     <listitem>
      <para>
<!-- 
       This is the <firstterm>Smart Shutdown</firstterm> mode.
       After receiving <systemitem>SIGTERM</systemitem>, the server
       disallows new connections, but lets existing sessions end their
       work normally. It shuts down only after all of the sessions terminate.
       If the server is in online backup mode, it additionally waits
       until online backup mode is no longer active.  While backup mode is
       active, new connections will still be allowed, but only to superusers
       (this exception allows a superuser to connect to terminate
       online backup mode).  If the server is in recovery when a smart
       shutdown is requested, recovery and streaming replication will be
       stopped only after all regular sessions have terminated. 
-->
这是<firstterm>智能关闭</firstterm>模式。接收到<systemitem>SIGTERM</systemitem>以后，
服务器不再允许新的连接，但是允许所有活跃的会话正常完成他们的工作，
只有在所有会话都结束任务后才关闭。如果服务器处在在线备份模式，它另外等待在线备份模式不再活跃。
当备份模式活跃时，将仍允许新的连接，但是只针对超级用户（这个例外允许超级用户连接以终止在线备份模式）。
如果当请求智能关闭时服务器正在恢复，那么恢复和流复制将在所有普通会话终止后停止。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><systemitem>SIGINT</systemitem><indexterm><primary>SIGINT</></></term>
     <listitem>
      <!--
<para>
       This is the <firstterm>Fast Shutdown</firstterm> mode.
       The server disallows new connections and sends all existing
       server processes <systemitem>SIGTERM</systemitem>, which will cause them
       to abort their current transactions and exit promptly. It then
       waits for all server processes to exit and finally shuts down.
       If the server is in online backup mode, backup mode will be
       terminated, rendering the backup useless.
      </para>
-->
<para>
这是<firstterm>快速关闭</firstterm>模式。不再允许新的连接，向所有活跃服务器发送<systemitem>SIGTERM</systemitem>
(让它们立刻退出)，然后等待所有子进程退出并关闭数据库。如果服务器处在在线备份模式，
备份模式将终止，使得备份无效。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><systemitem>SIGQUIT</systemitem><indexterm><primary>SIGQUIT</></></term>
     <listitem>
      <!--
<para>
      This is the <firstterm>Immediate Shutdown</firstterm> mode.
      The master <command>postgres</command> process will send a
      <systemitem>SIGQUIT</systemitem> to all child processes and exit
      immediately, without properly shutting itself down. The child processes
      likewise exit immediately upon receiving
      <systemitem>SIGQUIT</systemitem>. This will lead to recovery (by
      replaying the WAL log) upon next start-up. This is recommended
      only in emergencies.
      </para>
-->
<para>
这是<firstterm>立即关闭</firstterm>模式。主<command>postgres</command>进程将向所有子进程发送
<systemitem>SIGQUIT</systemitem>并且立即退出(所有子进程也会立即退出)，而不会妥善地关闭数据库系统。
这样做会导致下次启动时的恢复(通过重放 WAL 日志)。我们推荐只在紧急的时候使用这个方法。
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  
<para>
<!--
   The <xref linkend="app-pg-ctl"> program provides a convenient
   interface for sending these signals to shut down the server.
   Alternatively, you can send the signal directly using <command>kill</>
   on non-Windows systems.
   The <acronym>PID</> of the <command>postgres</command> process can be
   found using the <command>ps</command> program, or from the file
   <filename>postmaster.pid</filename> in the data directory. For
   example, to do a fast shutdown:
-->
<xref linkend="app-pg-ctl">程序提供了一个发送这些信号关闭服务器的便利接口。
另外，你在非Windows系统上可以用<command>kill</>直接发送这些信号。
可以用<command>ps</command>命令或者从数据目录里的<filename>postmaster.pid</filename>
文件中找出<command>postgres</command>的<acronym>PID</>。所以，举例来说，要做一次快速关闭：
<screen>
$ <userinput>kill -INT `head -1 /usr/local/pgsql/data/postmaster.pid`</userinput>
</screen>
  </para>

  <important>
   <!--
<para>
    It is best not to use <systemitem>SIGKILL</systemitem> to shut down
    the server.  Doing so will prevent the server from releasing
    shared memory and semaphores, which might then have to be done
    manually before a new server can be started.  Furthermore,
    <systemitem>SIGKILL</systemitem> kills the <command>postgres</command>
    process without letting it relay the signal to its subprocesses,
    so it will be necessary to kill the individual subprocesses by hand as
    well.
   </para>
-->
<para>
最好不要用<systemitem>SIGKILL</systemitem>来关闭服务器。这样做将阻止服务器释放共享内存和信号灯，
那样的话你只能在新服务器启动前自己手动做这件事。另外，<systemitem>SIGKILL</systemitem>直接杀死<command>postgres</command>
进程而不等它传递信号给子进程，所以我们也将必须手动的杀死独立的子进程。
</para>
  </important>

  <!--
<para>
   To terminate an individual session while allowing other sessions to
   continue, use <function>pg_terminate_backend()</> (see <xref
   linkend="functions-admin-signal-table">) or send a
   <systemitem>SIGTERM</> signal to the child process associated with
   the session.
  </para>
-->
<para>
当允许其他会话继续时终止一个独立的会话，使用<function>pg_terminate_backend()</>
(参见<xref linkend="functions-admin-signal-table">)或发送一个<systemitem>SIGTERM</>
信号到与这个会话有关的子进程。
</para>
 </sect1>

 <sect1 id="upgrading">
  <!-- 
  <title>Upgrading a <productname>PostgreSQL</> Cluster</title> 
  -->
  <title>升级一个 <productname>PostgreSQL</> 集群</title>

  <indexterm zone="upgrading">
   <!-- 
   <primary>upgrading</primary> 
   -->
   <primary>升级</primary>
  </indexterm>

  <indexterm zone="upgrading">
   <!-- 
   <primary>version</primary>
   <secondary>compatibility</secondary> 
   -->
   <primary>版本</primary>
   <secondary>兼容性</secondary>
  </indexterm>

  <!--
<para>
   This section discusses how to upgrade your database data from one
   <productname>PostgreSQL</> release to a newer one.
  </para>
-->
<para>
本节讨论怎样从一个<productname>PostgreSQL</>发布到一个新的发布升级你的数据库数据。
</para>

  <!--
<para>
   <productname>PostgreSQL</> major versions are represented by the
   first two digit groups of the version number, e.g., 8.4.
   <productname>PostgreSQL</> minor versions are represented by the
   third group of version digits, e.g., 8.4.2 is the second minor
   release of 8.4.  Minor releases never change the internal storage
   format and are always compatible with earlier and later minor
   releases of the same major version number, e.g., 8.4.2 is compatible
   with 8.4, 8.4.1 and 8.4.6.  To update between compatible versions,
   you simply replace the executables while the server is down and
   restart the server.  The data directory remains unchanged &mdash;
   minor upgrades are that simple.
  </para>
-->
<para>
<productname>PostgreSQL</>主要版本由前两个数字的版本号代表，例如8.4。
<productname>PostgreSQL</>主要版本由前三个数字的版本号代表，例如8.4.2是第二个8.4的维护性发布。
维护性发布从不改变内部存储器格式并且总是与之前的和之后的相同维护性版本号的维护性版本兼容，
例如8.4.2兼容8.4,8.4.1和8.4.6。要在兼容的版本之间更新，在服务器关闭时简单的替换可执行文件并且重启服务器就可以。
数据目录保留不改变&mdash;维护性升级就这么简单。
</para>

  <!--
<para>
   For <emphasis>major</> releases of <productname>PostgreSQL</>, the
   internal data storage format is subject to change, thus complicating
   upgrades.  The traditional method for moving data to a new major version
   is to dump and reload the database.  Other methods are available,
   as discussed below.
  </para>
-->
<para>
对<productname>PostgreSQL</>的<emphasis>主要</>发布，内部数据存储格式是改变的主题，
因此并发升级。移动数据到一个新的主要版本的传统的方法是转储并重新加载数据库。
就像下面描述的那样，其他方法也适用。
</para>

  <!--
<para>
   New major versions also typically introduce some user-visible
   incompatibilities, so application programming changes might be required.
   All user-visible changes are listed in the release notes (<xref
   linkend="release">);  pay particular attention to the section
   labeled "Migration".  If you are upgrading across several major
   versions, be sure to read the release notes for each intervening
   version.
  </para>
-->
<para>
新的主要版本还通常介绍一些用户可见的不兼容性，所以可能需要改变应用程序。
所有用户可见的改变都在版本注释里面列出（<xref linkend="release">）；
尤其注意章节标签"Migration"。如果你正在几个主要版本间升级，
一定要阅读每个中间版本的版本注释。
</para>

  <!--
<para>
   Cautious users will want to test their client applications on the new
   version before switching over fully; therefore, it's often a good idea to
   set up concurrent installations of old and new versions.  When
   testing a <productname>PostgreSQL</> major upgrade, consider the
   following categories of possible changes:
  </para>
-->
<para>
谨慎的用户可能想在全面切换前在新的版本上测试他们的客户端应用；因此，
设置并发新旧版本的安装是一个好的主意。当测试一个<productname>PostgreSQL</>的主要升级时，
考虑下列类别的可能变化：
</para>

  <variablelist>

   <varlistentry>
    <term>Administration</term>
    <listitem>
     <!--
<para>
      The capabilities available for administrators to monitor and control
      the server often change and improve in each major release.
     </para>
-->
<para>
在每个主要版本中，管理员对服务器可用的监视和控制功能通常会改变和增加。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>SQL</term>
    <listitem>
     <!--
<para>
      Typically this includes new SQL command capabilities and not changes
      in behavior, unless specifically mentioned in the release notes.
     </para>
-->
<para>
通常包含新的SQL命令功能而不是行为上的改变，除非在版本注释里面特别提到。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>Library API</term>
    <listitem>
     <!--
<para>
      Typically libraries like <application>libpq</> only add new
      functionality, again unless mentioned in the release notes.
     </para>
-->
<para>
像<application>libpq</>这样典型的库只添加新的函数，同样除非在版本注释里面特别提到。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>System Catalogs</term>
    <listitem>
     <!--
<para>
      System catalog changes usually only affect database management tools.
     </para>
-->
<para>
系统目录变更通常只影响数据库管理工具。
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>Server C-language API</term>
    <listitem>
     <!--
<para>
      This involves changes in the backend function API, which is written
      in the C programming language.  Such changes affect code that
      references backend functions deep inside the server.
     </para>
-->
<para>
这涉及到后端函数API的变化，它是用C编程语言写的。这样的改变影响引用深层服务器后端函数的编码。
</para>
    </listitem>
   </varlistentry>

  </variablelist>

  <sect2 id="upgrade-methods-pgdump">
   <!-- 
   <title>Upgrading Data via <application>pg_dump</></title> 
   -->
   <title>通过<application>pg_dump</>升级数据</title>

   <!--
<para>
    To dump data from one major version of <productname>PostgreSQL</> and
    reload it in another, you must use <application>pg_dump</>; file system
    level backup methods will not work. (There are checks in place that prevent
    you from using a data directory with an incompatible version of
    <productname>PostgreSQL</productname>, so no great harm can be done by
    trying to start the wrong server version on a data directory.)
   </para>
-->
<para>
要从<productname>PostgreSQL</>的一个主要版本转储数据并加载到另一个版本，必须使用<application>pg_dump</>;
文件系统级备份方法将不能使用。（有检查防止你用不兼容的<productname>PostgreSQL</productname>
版本使用数据目录，所以在一个数据目录上尝试启动错误的服务器版本也不会造成大的伤害。）
</para>

   <!--
<para>
    It is recommended that you use the <application>pg_dump</> and
    <application>pg_dumpall</> programs from the newer version of
    <productname>PostgreSQL</>, to take advantage of enhancements
    that might have been made in these programs.  Current releases of the
    dump programs can read data from any server version back to 7.0.
   </para>
-->
<para>
建议使用新版本的<productname>PostgreSQL</> <application>pg_dump</>和<application>pg_dumpall</>程序，
利用这些程序可能的增强功能。当前转储程序版本可以从一直到7.0的任何服务器版本中读取数据。
</para>

   <!--
<para>
    These instructions assume that your existing installation is under the
    <filename>/usr/local/pgsql</> directory, and that the data area is in
    <filename>/usr/local/pgsql/data</>.  Substitute your paths
    appropriately.
   </para>
-->
<para>
这些说明假设现有的安装在<filename>/usr/local/pgsql</>目录下，数据区域在<filename>/usr/local/pgsql/data</>
目录下。适当的替代你的路径。
</para>

   <procedure>
    <step>
     <!--
<para>
      If making a backup, make sure that your database is not being updated.
      This does not affect the integrity of the backup, but the changed
      data would of course not be included. If necessary, edit the
      permissions in the file <filename>/usr/local/pgsql/data/pg_hba.conf</>
      (or equivalent) to disallow access from everyone except you.
      See <xref linkend="client-authentication"> for additional information on
      access control.
     </para>
-->
<para>
如果做一个备份，确保数据库没有被更新。这不影响备份的完整性，但是将不会包括改变了的数据。
如果必须要这样做，那么编辑文件<filename>/usr/local/pgsql/data/pg_hba.conf</>(或相等的)里的权限，
设置除了你之外的人都不可以访问。参阅<xref linkend="client-authentication">获取关于访问控制的更多信息。
</para>
     
<para>
<!--
      <indexterm>
       <primary>pg_dumpall</primary>
       <secondary>use during upgrade</secondary>
      </indexterm>

      To back up your database installation, type:
-->
 <indexterm>
       <primary>pg_dumpall</primary>
       <secondary>在升级期间使用</secondary>
      </indexterm>
  备份你的数据库安装，输入：
<screen>
<userinput>pg_dumpall &gt; <replaceable>outputfile</></userinput>
</screen>
<!-- 
      If you need to preserve OIDs (such as when using them as
      foreign keys), then use the <option>-o</option> option when running
      <application>pg_dumpall</>.
-->
如果您需要保存OID（例如当使用它们作为外键时），那么在运行<application>pg_dumpall</>
时使用<option>-o</option>选项。
     </para>

     <!--
<para>
      To make the backup, you can use the <application>pg_dumpall</application>
      command from the version you are currently running.  For best
      results, however, try to use the <application>pg_dumpall</application>
      command from <productname>PostgreSQL</productname> &version;,
      since this version contains bug fixes and improvements over older
      versions.  While this advice might seem idiosyncratic since you
      haven't installed the new version yet, it is advisable to follow
      it if you plan to install the new version in parallel with the
      old version.  In that case you can complete the installation
      normally and transfer the data later.  This will also decrease
      the downtime.
     </para>
-->
<para>
要做备份，可以使用当前运行版本的<application>pg_dumpall</application>命令。然而，
要获取最佳结果尝试使用<productname>PostgreSQL</productname> &version;的
<application>pg_dumpall</application>命令，因为这个版本包含bug修复和对老版本的改进。
虽然在你还没有安装新版本时这个建议看起来很特别，但是如果你打算同时安装新版本和老版本，
那么这个建议是可行的。在这种情况下你可以正常完成安装然后传送数据。这也将减少停机时间。
</para>
    </step>

    <step>
<para>
<!--
      Shut down the old server:
-->
关闭旧的服务器：
<screen>
<userinput>pg_ctl stop</>
</screen>
<!-- 
      On systems that have <productname>PostgreSQL</> started at boot time,
      there is probably a start-up file that will accomplish the same thing. For
      example, on a <systemitem class="osname">Red Hat Linux</> system one
      might find that this works: 
-->
系统上的<productname>PostgreSQL</>在开机时启动，可能有一个启动文件将完成同样的事情。
例如，在<systemitem class="osname">Red Hat Linux</>系统上，可能发现这个在工作：
<screen>
<userinput>/etc/rc.d/init.d/postgresql stop</userinput>
</screen>
<!-- 
      See <xref linkend="runtime"> for details about starting and
      stopping the server.
-->
参阅<xref linkend="runtime">获取关于启动和停止服务器的详细信息。
     </para>
    </step>

    <step>
     
<para>
<!--
      If restoring from backup, rename or delete the old installation
      directory.  It is a good idea to rename the directory, rather than
      delete it, in case you have trouble and need to revert to it.  Keep
      in mind the directory might consume significant disk space.  To rename
      the directory, use a command like this:
-->
如果从备份中恢复，重命名或者删除旧的安装目录。重命名目录是个好主意，而不是删掉它，
以防你有困难并且需要恢复它。记住，目录可能会占用大量磁盘空间。要重命名目录，使用像下面这样的命令：
<screen>
<userinput>mv /usr/local/pgsql /usr/local/pgsql.old</>
</screen>
<!-- 
     (Be sure to move the directory as a single unit so relative paths
     remain unchanged.) 
-->
（一定要把目录作为一个单元，所以相对路径保持不变。）
     </para>
    </step>

    <step>
     <!--
<para>
      Install the new version of <productname>PostgreSQL</productname> as
      outlined in <![%standalone-include[the next section.]]>
      <![%standalone-ignore[<xref linkend="install-procedure">.]]>
     </para>
-->
<para>
像<![%standalone-include[the next section.]]><![%standalone-ignore[<xref linkend="install-procedure">.]]>
中概述的那样安装<productname>PostgreSQL</productname>新版本。  
</para>
    </step>

    <step>
<para>
<!--
      Create a new database cluster if needed.  Remember that you must
      execute these commands while logged in to the special database user
      account (which you already have if you are upgrading).
-->
如果需要创建一个新的数据库集群。请记住，当登陆到特定的数据库用户账户
（如果已经升级，那么已经有这个账户了）时必须执行下面的命令。
<programlisting>
<userinput>/usr/local/pgsql/bin/initdb -D /usr/local/pgsql/data</>
</programlisting>
     </para>
    </step>

    <step>
     <!--
<para>
      Restore your previous <filename>pg_hba.conf</> and any
      <filename>postgresql.conf</> modifications.
     </para>
-->
<para>
恢复以前的<filename>pg_hba.conf</>和任意<filename>postgresql.conf</>修改。
</para>
    </step>

    <step>
<para>
<!--
      Start the database server, again using the special database user
      account:
-->
启动数据库服务器，再次使用特定的数据库用户账户：
<programlisting>
<userinput>/usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data</>
</programlisting>
     </para>
    </step>

    <step>
<para>
<!--
      Finally, restore your data from backup with:
-->
最终，从备份中恢复数据：
<screen>
<userinput>/usr/local/pgsql/bin/psql -d postgres -f <replaceable>outputfile</></userinput>
</screen>
      <!-- 
  using the <emphasis>new</> <application>psql</>. 
  -->
  使用<emphasis>新的</> <application>psql</>
     </para>
    </step>
   </procedure>
  
<para>
 <!--
 The least downtime can be achieved by installing the new server in
    a different directory and running both the old and the new servers
    in parallel, on different ports. Then you can use something like:
-->
最少的停机时间可以通过在一个不同的目录下安装新的服务器，并且并行在不同的端口运行旧的和新的服务器来达到。
然后就可以使用类似：
<programlisting>
pg_dumpall -p 5432 | psql -d postgres -p 5433
</programlisting>
    <!-- 
to transfer your data. 
-->
来传送数据。
   </para>
  </sect2>

  <sect2 id="upgrading-methods-other">
   <!-- 
   <title>Non-Dump Upgrade Methods</title> 
   -->
   <title>Non-Dump 升级方法</title>

   <!--
<para>
    The <link linkend="pgupgrade">pg_upgrade</link> module allows an
    installation to be migrated in-place from one major
    <productname>PostgreSQL</> version to the next.  Upgrades can be
    performed in minutes.
   </para>
-->
<para>
<link linkend="pgupgrade">pg_upgrade</link>模块允许安装从一个主<productname>PostgreSQL</>版本到下一个的迁移。
升级可以在几分钟内完成。
</para>

   <!--
<para>
    It is also possible to use certain replication methods, such as
    <productname>Slony</>, to create a standby server with the updated version of
    <productname>PostgreSQL</>.  This is possible because Slony supports
    replication between different major versions of
    <productname>PostgreSQL</>.  The standby can be on the same computer or
    a different computer.  Once it has synced up with the master server
    (running the older version of <productname>PostgreSQL</>), you can
    switch masters and make the standby the master and shut down the older
    database instance.  Such a switch-over results in only several seconds
    of downtime for an upgrade.
   </para>
-->
<para>
还可以使用特定的复制方法，比如<productname>Slony</>，创建一个更新的<productname>PostgreSQL</>
版本备用服务器。这是可能的，因为Slony支持不同<productname>PostgreSQL</>主版本间的复制。
备机可以在相同的计算机上，也可以在不同的计算机上。一旦它与主服务器（在老<productname>PostgreSQL</>
版本上运行）同步，就可以切换主机使备机成为主机，并立即关闭旧的数据库。这样的切换使升级只有几秒钟的关机时间。
</para>

  </sect2>
 </sect1>

 <sect1 id="preventing-server-spoofing">
  <!-- 
  <title>Preventing Server Spoofing</title> 
  -->
  <title>防止服务器欺骗</title>

  <indexterm zone="preventing-server-spoofing">
   <primary>服务器欺骗</primary>
  </indexterm>

  <!--
<para>
   While the server is running, it is not possible for a malicious user
   to take the place of the normal database server.  However, when the
   server is down, it is possible for a local user to spoof the normal
   server by starting their own server.  The spoof server could read
   passwords and queries sent by clients, but could not return any data
   because the <varname>PGDATA</> directory would still be secure because
   of directory permissions. Spoofing is possible because any user can
   start a database server; a client cannot identify an invalid server
   unless it is specially configured.
  </para>
-->
<para>
当服务器正在运行时，恶意用户代替正常的数据库服务器是不可能的。然而，当服务器关闭时，
本地用户通过启动他们自己的服务器欺骗正常的服务器是可能的。行骗服务器可以读取客户端发来的查询和密码，
但不能返回任何数据，因为<varname>PGDATA</>目录因为目录存取权限仍然是安全的。
因为任何用户都可以启动一个数据库服务器，所以欺骗是可能的；客户端不能识别无效的服务器，
除非它是专门配置的。
</para>

  <!--
<para>
   The simplest way to prevent spoofing for <literal>local</>
   connections is to use a Unix domain socket directory (<xref
   linkend="guc-unix-socket-directories">) that has write permission only
   for a trusted local user.  This prevents a malicious user from creating
   their own socket file in that directory.  If you are concerned that
   some applications might still reference <filename>/tmp</> for the
   socket file and hence be vulnerable to spoofing, during operating system
   startup create a symbolic link <filename>/tmp/.s.PGSQL.5432</> that points
   to the relocated socket file.  You also might need to modify your
   <filename>/tmp</> cleanup script to prevent removal of the symbolic link.
  </para>
-->
<para>
为<literal>local</>连接防止欺骗的最简单的方法是使用Unix域套接字目录
(<xref linkend="guc-unix-socket-directories">)，这个目录只为受信任的本地用户写入了权限。
如果你担心一些应用可能仍然参考<filename>/tmp</>为套接字文件，并且因此很容易受欺骗，
那么在操作系统启动时创建一个符号链接<filename>/tmp/.s.PGSQL.5432</>指向重定位的套接字文件。
您还可能需要修改<filename>/tmp</>清理脚本以防止删除符号链接。
</para>

  <!--
<para>
   To prevent spoofing on TCP connections, the best solution is to use
   SSL certificates and make sure that clients check the server's certificate.
   To do that, the server
   must be configured to accept only <literal>hostssl</> connections (<xref
   linkend="auth-pg-hba-conf">) and have SSL key and certificate files
   (<xref linkend="ssl-tcp">). The TCP client must connect using
   <literal>sslmode=verify-ca</> or
   <literal>verify-full</> and have the appropriate root certificate
   file installed (<xref linkend="libq-ssl-certificates">).
  </para>
-->
<para>
要在TCP连接上防止欺骗，最好的解决方法是使用SSL认证，并确保客户检查服务器的证书。
要做到这一点，服务器必须配置为只接受<literal>hostssl</>连接(<xref linkend="auth-pg-hba-conf">)，
并且有SSL秘钥和证书文件(<xref linkend="ssl-tcp">)。TCP客户必须使用<literal>sslmode=verify-ca</>
或<literal>verify-full</>连接，并且有适当的根证书文件安装(<xref linkend="libq-ssl-certificates">)。
</para>
 </sect1>

 <sect1 id="encryption-options">
  <!-- 
  <title>Encryption Options</title> 
  -->
  <title>加密选项</title>

  <indexterm zone="encryption-options">
   <!-- 
   <primary>encryption</primary> 
   -->
   <primary>加密</primary>
  </indexterm>

  <!--
<para>
   <productname>PostgreSQL</productname> offers encryption at several
   levels, and provides flexibility in protecting data from disclosure
   due to database server theft, unscrupulous administrators, and
   insecure networks. Encryption might also be required to secure
   sensitive data such as medical records or financial transactions.
  </para>
-->
<para>
<productname>PostgreSQL</productname>提供了几个不同级别的加密，
并且在保护数据库服务器不受数据窃贼、不道德管理员、不安全网络等因素泄漏的方面提供很高的灵活性。
加密可能也是保护一些诸如医疗记录和财务交易等敏感数据的要求。
</para>

  <variablelist>

  <varlistentry>
   <!-- 
   <term>Password Storage Encryption</term> 
   -->
   <term>口令存储加密</term>
   <listitem>

    <!--
<para>
     By default, database user passwords are stored as MD5 hashes, so
     the administrator cannot determine the actual password assigned
     to the user. If MD5 encryption is used for client authentication,
     the unencrypted password is never even temporarily present on the
     server because the client MD5-encrypts it before being sent
     across the network.
    </para>
-->
<para>
缺省的时候，数据库用户的口令以 MD5 散列的方式存储，所以管理员无法判断赋予用户的实际口令。
如果 MD5 加密用于客户端认证，那么未加密的口令甚至都不可能临时出现在服务器上，
因为客户端在透过网络发送之前，就先用 MD5 加密了。
</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <!-- 
   <term>Encryption For Specific Columns</term> 
   -->
   <term>为指定的字段加密</term>

   <listitem>
    <!--
<para>
     The <xref linkend="pgcrypto"> module allows certain fields to be
     stored encrypted.
     This is useful if only some of the data is sensitive.
     The client supplies the decryption key and the data is decrypted
     on the server and then sent to the client.
    </para>
-->
<para>
<xref linkend="pgcrypto">模块允许对某些字段进行加密存储。这个功能在某些数据是敏感的情况下有用。
客户端提供解密的密钥，然后数据在服务器端解密，然后发送给客户端。
</para>

    <!--
<para>
     The decrypted data and the decryption key are present on the
     server for a brief time while it is being decrypted and
     communicated between the client and server. This presents a brief
     moment where the data and keys can be intercepted by someone with
     complete access to the database server, such as the system
     administrator.
    </para>
-->
<para>
在数据解密和数据在服务器与客户端之间传递时，解密数据和解密密钥将会在服务器端存在短暂的一段时间。
这就给那些可以完全访问数据库服务器的人提供了一个短暂的截获密钥和数据的时间，
这样的人一般是数据库管理员。
</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <!-- 
   <term>Data Partition Encryption</term>
   -->
   <term>数据库分区加密</term>

   <listitem>
    <!--
<para>
     On Linux, encryption can be layered on top of a file system
     using a <quote>loopback device</quote>. This allows an entire
     file system partition to be encrypted on disk, and decrypted by the
     operating system. On FreeBSD, the equivalent facility is called
     GEOM Based Disk Encryption (<acronym>gbde</acronym>), and many
     other operating systems support this functionality, including Windows.
    </para>
-->
<para>
在 Linux 上，加密可以在使用<quote>回环设备</quote>(loopback device)挂载的文件系统上面进行。
这样就可以把磁盘上整个文件分区都加密，然后由操作系统解密。在 FreeBSD 上，
等效的设施叫 GEOM 基本磁盘加密(<acronym>gbde</acronym>)，并且许多其他操作系统支持这个功能，包括Windows。
</para>

    <!--
<para>
     This mechanism prevents unencrypted data from being read from the
     drives if the drives or the entire computer is stolen. This does
     not protect against attacks while the file system is mounted,
     because when mounted, the operating system provides an unencrypted
     view of the data. However, to mount the file system, you need some
     way for the encryption key to be passed to the operating system,
     and sometimes the key is stored somewhere on the host that mounts
     the disk.
    </para>
-->
<para>
这个机制避免了在整个计算机或者磁盘驱动器被窃的情况下，未加密的数据被从驱动器中读取。
它无法防止在文件系统被挂载的时候的攻击，因为在挂载之后，操作系统提供数据的解密视图。
不过，要想挂载文件系统，你需要有一些方法把解密密钥传递给操作系统，
有时候这个密钥就存储在挂载该磁盘的主机的某个地方。
</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <!-- 
   <term>Encrypting Passwords Across A Network</term> 
   -->
   <term>跨网络加密口令</term>

   <listitem>
     <!--
<para>
      The <literal>MD5</> authentication method double-encrypts the
      password on the client before sending it to the server. It first
      MD5-encrypts it based on the user name, and then encrypts it
      based on a random salt sent by the server when the database
      connection was made. It is this double-encrypted value that is
      sent over the network to the server. Double-encryption not only
      prevents the password from being discovered, it also prevents
      another connection from using the same encrypted password to
      connect to the database server at a later time.
     </para>
-->
<para>
<literal>MD5</>认证方法在客户端将口令发给服务器之前双重加密之。第一次 MD5 加密是基于用户名的，
然后在连接数据库的时候，用服务器发送的随机盐粒再次加密。
这个双重加密的数值就是从网络传递给服务器的数值。双重加密不仅可以避免口令泄漏，
还可以避免稍后其它的连接使用同样的加密口令连接数据库(回放攻击)。
</para>
    </listitem>
  </varlistentry>

  <varlistentry>
   <!-- 
   <term>Encrypting Data Across A Network</term> 
   -->
   <term>透过网络加密数据</term>

    <listitem>
     <!--
<para>
      SSL connections encrypt all data sent across the network: the
      password, the queries, and the data returned. The
      <filename>pg_hba.conf</> file allows administrators to specify
      which hosts can use non-encrypted connections (<literal>host</>)
      and which require SSL-encrypted connections
      (<literal>hostssl</>). Also, clients can specify that they
      connect to servers only via SSL. <application>Stunnel</> or
      <application>SSH</> can also be used to encrypt transmissions.
     </para>
-->
<para>
SSL 连接加密所有透过网络发送的数据：口令、查询、返回的数据。<filename>pg_hba.conf</>
文件允许管理员声明哪些主机可以使用不加密的连接(<literal>host</>)，
以及哪些主机需要使用 SSL 加密的连接(<literal>hostssl</>)。客户也可以指定只通过SSL连接到服务器。
我们也可以使用<application>Stunnel</>或<application>SSH</>加密数据传输。
</para>
    </listitem>
  </varlistentry>

  <varlistentry>
   <!-- 
   <term>SSL Host Authentication</term> 
   -->
   <term>SSL 主机认证</term>

   <listitem>
    <!--
<para>
     It is possible for both the client and server to provide SSL
     certificates to each other. It takes some extra configuration
     on each side, but this provides stronger verification of identity
     than the mere use of passwords. It prevents a computer from
     pretending to be the server just long enough to read the password
     sent by the client. It also helps prevent <quote>man in the middle</>
     attacks where a computer between the client and server pretends to
     be the server and reads and passes all data between the client and
     server.
    </para>
-->
<para>
客户端和主机都可以提供 SSL 证书给对方。这么做需要在两边都进行一些额外的配置工作，
但是这种方式提供了比简单使用用户名和口令更强的身份认证的手段。
它避免一个计算机装作是服务器，然后读取客户端口令，
只要时间长得足够读取客户端发送的口令就行了。它还避免了<quote>中间人</>
攻击(在客户端和服务器之间有台计算机，伪装成为服务器并且读取然后将所有数据在客户端和服务器之间传递)。
</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <!-- 
   <term>Client-Side Encryption</term> 
   -->
   <term>客户端加密</term>

   <listitem>
    <!--
<para>
     If the system administrator for the server's machine cannot be trusted,
     it is necessary
     for the client to encrypt the data; this way, unencrypted data
     never appears on the database server. Data is encrypted on the
     client before being sent to the server, and database results have
     to be decrypted on the client before being used.
    </para>
-->
<para>
如果服务器机器的系统管理员是不可信的，那么客户端加密数据也是必要的；这种情况下，
未加密的数据从来不会在数据库服务器上出现。数据在发送给服务器之前加密，
而数据库结果必须在客户端使用之前解密。
</para>
   </listitem>
  </varlistentry>

  </variablelist>

 </sect1>

 <sect1 id="ssl-tcp">
  <!-- 
  <title>Secure TCP/IP Connections with SSL</title> 
  -->
  <title>用 SSL 进行安全的 TCP/IP 连接</title>

  <indexterm zone="ssl-tcp">
   <primary>SSL</primary>
  </indexterm>

  <!--
<para>
   <productname>PostgreSQL</> has native support for using
   <acronym>SSL</> connections to encrypt client/server communications
   for increased security. This requires that
   <productname>OpenSSL</productname> is installed on both client and
   server systems and that support in <productname>PostgreSQL</> is
   enabled at build time (see <xref linkend="installation">).
  </para>
-->
<para>
<productname>PostgreSQL</>有一个内建的通过<acronym>SSL</>进行加密的客户端/服务器端的通讯，
这样可以增加安全性。这个特性要求在客户端和服务器端都安装<productname>OpenSSL</productname>
并且在编译<productname>PostgreSQL</>的时候打开(参阅<xref linkend="installation">)。
</para>

  <!--
<para>
   With <acronym>SSL</> support compiled in, the
   <productname>PostgreSQL</> server can be started with
   <acronym>SSL</> enabled by setting the parameter
   <xref linkend="guc-ssl"> to <literal>on</> in
   <filename>postgresql.conf</>.  The server will listen for both normal
   and <acronym>SSL</> connections on the same TCP port, and will negotiate
   with any connecting client on whether to use <acronym>SSL</>.  By
   default, this is at the client's option; see <xref
   linkend="auth-pg-hba-conf"> about how to set up the server to require
   use of <acronym>SSL</> for some or all connections.
  </para>
-->
<para>
当编译了<acronym>SSL</>进去以后，可以通过将<filename>postgresql.conf</>中的<xref linkend="guc-ssl">
设置为<literal>on</>打开<productname>PostgreSQL</>服务器的<acronym>SSL</>支持。
服务器将在同一个 TCP 端口上同时监听标准的和 SSL 的连接，
并且将与任何正在连接的客户端进行协商，协商是否使用<acronym>SSL</> 。缺省时，
这是根据客户端的选项而定的。参阅<xref linkend="auth-pg-hba-conf">
获取如何强制服务器端只使用<acronym>SSL</>进行某些或者全部连接的信息。
</para>

  <!--
<para>
   <productname>PostgreSQL</productname> reads the system-wide
   <productname>OpenSSL</productname> configuration file. By default, this
   file is named <filename>openssl.cnf</filename> and is located in the
   directory reported by <literal>openssl version -d</>.
   This default can be overridden by setting environment variable
   <envar>OPENSSL_CONF</envar> to the name of the desired configuration file.
  </para>
-->
<para>
<productname>PostgreSQL</productname>读取系统范围的<productname>OpenSSL</productname>
配置文件。缺省的，这个文件名为<filename>openssl.cnf</filename>，位于<literal>openssl version -d</>
报告的目录中。这个缺省可以通过设置环境变量<envar>OPENSSL_CONF</envar>为所需配置文件的名称重写。
</para>

  <!--
<para>
   <productname>OpenSSL</productname> supports a wide range of ciphers
   and authentication algorithms, of varying strength.  While a list of
   ciphers can be specified in the <productname>OpenSSL</productname>
   configuration file, you can specify ciphers specifically for use by
   the database server by modifying <xref linkend="guc-ssl-ciphers"> in
   <filename>postgresql.conf</>.
  </para>
-->
<para>
<productname>OpenSSL</productname>支持多种不同强度的密码和认证算法。
当一列密码可以在<productname>OpenSSL</productname>配置文件中指定时，
可以通过修改<filename>postgresql.conf</>中的<xref linkend="guc-ssl-ciphers">，
指定数据库服务器专用的密码。
</para>

  <note>
   <!--
<para>
    It is possible to have authentication without encryption overhead by
    using <literal>NULL-SHA</> or <literal>NULL-MD5</> ciphers.  However,
    a man-in-the-middle could read and pass communications between client
    and server.  Also, encryption overhead is minimal compared to the
    overhead of authentication.  For these reasons NULL ciphers are not
    recommended.
   </para>
-->
<para>
使用<literal>NULL-SHA</>或<literal>NULL-MD5</>可能有身份验证开销而没有加密开销。
不过，中间人能够读取和通过客户端和服务器的通信。此外，加密开销相比身份认证的开销是极小的。
有这些原因建议不使用NULL加密。
</para>
  </note>

  <!--
<para>
   To start in <acronym>SSL</> mode, files containing the server certificate
   and private key must exist.  By default, these files are expected to be
   named <filename>server.crt</> and <filename>server.key</>, respectively, in
   the server's data directory, but other names and locations can be specified
   using the configuration parameters <xref linkend="guc-ssl-cert-file">
   and <xref linkend="guc-ssl-key-file">.
   On Unix systems, the permissions on <filename>server.key</filename> must
   disallow any access to world or group; achieve this by the command
   <command>chmod 0600 server.key</command>.
   If the private key is protected with a passphrase, the
   server will prompt for the passphrase and will not start until it has
   been entered.
  </para>
-->
<para>
要在<acronym>SSL</>模式中启动服务器，必须包含包含服务器证书和私钥的文件。缺省的，
这些文件分别命名为<filename>server.crt</>和<filename>server.key</>，存在于服务器的数据目录里，
但是其他名字和位置可以用配置参数<xref linkend="guc-ssl-cert-file">和<xref linkend="guc-ssl-key-file">
指定。在Unix系统，<filename>server.key</filename>的权限禁止任何world或group访问；
通过命令<command>chmod 0600 server.key</command>来做。如果私钥受密码保护，服务器将会提示输入密码，
将会等到输入后启动。
</para>

  <!--
<para>
   In some cases, the server certificate might be signed by an
   <quote>intermediate</> certificate authority, rather than one that is
   directly trusted by clients.  To use such a certificate, append the
   certificate of the signing authority to the <filename>server.crt</> file,
   then its parent authority's certificate, and so on up to a <quote>root</>
   authority that is trusted by the clients.  The root certificate should
   be included in every case where <filename>server.crt</> contains more than
   one certificate.
  </para>
-->
<para>
在有些情况下，服务器证书可能由一个<quote>中间</>认证授权签名，而不是直接由受信任的客户端。
若要使用这样的证书，请追加授权签名证书到<filename>server.crt</>文件，然后其父颁发机构的证书，
然后直到一个客户端信任的<quote>根</>授权。<filename>server.crt</>包含多个证书，
在任何情况下都应包括根证书。
</para>

  <sect2 id="ssl-client-certificates">
   <!-- 
   <title>Using Client Certificates</title> 
   -->
   <title>使用客户端证书</title>

   
<para>
<!--
   To require the client to supply a trusted certificate, place
   certificates of the certificate authorities (<acronym>CA</acronym>s)
   you trust in the file <filename>root.crt</filename> in the data
   directory, set the parameter <xref linkend="guc-ssl-ca-file"> in
   <filename>postgresql.conf</filename> to <literal>root.crt</literal>,
   and set the <literal>clientcert</literal> parameter
   to 1 on the appropriate <literal>hostssl</> line(s) in
   <filename>pg_hba.conf</>.
   A certificate will then be requested from the client during
   SSL connection startup.  (See <xref linkend="libpq-ssl"> for a
   description of how to set up certificates on the client.)  The server will
   verify that the client's certificate is signed by one of the trusted
   certificate authorities.  Certificate Revocation List (CRL) entries
   are also checked if the parameter <xref linkend="guc-ssl-crl-file"> is set.
-->
如果需要客户端提供受信任的证书，把认证中心(<acronym>CA</acronym>s)的证书放在你信任的在数据目录下的
<filename>root.crt</filename>文件里，并且设置<filename>postgresql.conf</filename>里的参数
<xref linkend="guc-ssl-ca-file">为<literal>root.crt</literal>，设置<filename>pg_hba.conf</>
里适当的<literal>hostssl</>行参数<literal>clientcert</literal>为1。
然后将在SSL连接启动时从客户端请求该证书。（<xref linkend="libpq-ssl">描述了如何在客户端安装证书。) 
服务器将验证客户端的证书是由受信任的认证中心之一签发的。如果参数<xref linkend="guc-ssl-crl-file">
也设置了，那么证书撤销列表(CRL)项也要检查。
  <!-- If this URL changes replace it with a URL to www.archive.org. --> <!-- 此为原文自带备注 -->
   <!-- 
   (See <ulink
   url="http://h71000.www7.hp.com/DOC/83final/BA554_90007/ch04s02.html"></>
   for diagrams showing SSL certificate usage.) 
   -->
   (参阅<ulink
   url="http://h71000.www7.hp.com/DOC/83final/BA554_90007/ch04s02.html"></>
   图标显示SSL证书的使用。)
  </para>

  <!--
<para>
   The <literal>clientcert</literal> option in <filename>pg_hba.conf</> is
   available for all authentication methods, but only for rows specified as
   <literal>hostssl</>.  When <literal>clientcert</literal> is not specified
   or is set to 0, the server will still verify presented client
   certificates against its CA list, if one is configured,
   &mdash; but it will not insist that a client certificate be presented.
  </para>
-->
<para>
在<filename>pg_hba.conf</>文件中<literal>clientcert</literal>选项对于所有的认证方法都可用，
但仅适用<literal>hostssl</>指定的行。当<literal>clientcert</literal>没有指定或设置为0，
服务器将仍然对其CA列表验证提供的客户端证书，如果配置了，它将不会坚持提交客户端证书。
</para>

  <!--
<para>
   Note that <filename>root.crt</filename> lists the top-level CAs that are
   considered trusted for signing client certificates.  In principle it need
   not list the CA that signed the server's certificate, though in most cases
   that CA would also be trusted for client certificates.
  </para>
-->
<para>
请注意<filename>root.crt</filename>列出顶级的CA，这些CA被认为是受签约客户端证书信任的。
原则上不需要列出标记服务器证书的CA，尽管在大多数情况下，客户端证书也将信任的该CA。
</para>

  <!--
<para>
   If you are setting up client certificates, you may wish to use
   the <literal>cert</> authentication method, so that the certificates
   control user authentication as well as providing connection security.
   See <xref linkend="auth-cert"> for details.
  </para>
-->
<para>
如果你设置客户端证书，你可能希望用<literal>cert</>认证方法，因此使证书控制用户身份验证，
以及提供连接安全。参阅<xref linkend="auth-cert">获取详细信息。
</para>
  </sect2>

  <sect2 id="ssl-server-files">
   <!-- 
   <title>SSL Server File Usage</title> 
   -->
   <title>SSL服务器文件的使用</title>

   <!--
<para>
    <xref linkend="ssl-file-usage"> summarizes the files that are
    relevant to the SSL setup on the server.  (The shown file names are default
    or typical names.  The locally configured names could be different.)
   </para>
-->
<para>
<xref linkend="ssl-file-usage">概述了与在服务器上设置SSL相关的文件。（显示的文件名字是默认的或典型的名字。
本地配置的名字可能会不同。）
</para>

  <table id="ssl-file-usage">
   <!-- 
   <title>SSL Server File Usage</title> 
   -->
   <title>SSL服务器文件的使用</title>
   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>File</entry>
      <entry>Contents</entry>
      <entry>Effect</entry> 
  -->
  <entry>文件</entry>
      <entry>内容</entry>
      <entry>作用</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry><xref linkend="guc-ssl-cert-file"> (<filename>$PGDATA/server.crt</>)</entry>
      <!-- 
  <entry>server certificate</entry>
      <entry>sent to client to indicate server's identity</entry> 
  -->
  <entry>服务器证书</entry>
      <entry>发送到客户端标识服务器的身份</entry>
     </row>

     <row>
      <entry><xref linkend="guc-ssl-key-file"> (<filename>$PGDATA/server.key</>)</entry>
     <!-- 
 <entry>server private key</entry>
      <entry>proves server certificate was sent by the owner; does not indicate
      certificate owner is trustworthy</entry> 
  -->
   <entry>服务器私钥</entry>
      <entry>证明服务器证书是由所有者发送，并不表示证书所有者是可信的</entry>
     </row>

     <row>
      <entry><xref linkend="guc-ssl-ca-file"> (<filename>$PGDATA/root.crt</>)</entry>
      <!-- 
  <entry>trusted certificate authorities</entry>
      <entry>checks that client certificate is
      signed by a trusted certificate authority</entry> 
  -->
  <entry>受信任的认证中心</entry>
      <entry>检查该客户端证书由受信任的认证中心签署</entry>
     </row>

     <row>
      <entry><xref linkend="guc-ssl-crl-file"> (<filename>$PGDATA/root.crl</>)</entry>
      <!-- 
  <entry>certificates revoked by certificate authorities</entry>
      <entry>client certificate must not be on this list</entry> 
  -->
  <entry>由认证中心吊销的证书</entry>
      <entry>客户端证书不能在此列表中</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

   <!--
<para>
    The files <filename>server.key</>, <filename>server.crt</>,
    <filename>root.crt</filename>, and <filename>root.crl</filename>
    (or their configured alternative names)
    are only examined during server start; so you must restart
    the server for changes in them to take effect.
   </para>
-->
<para>
文件<filename>server.key</>，<filename>server.crt</>，<filename>root.crt</filename>和
<filename>root.crl</filename>（或他们配置的供选择的名字）仅在服务器启动时检查；
如果你修改了它们，那么必须重启服务器才能生效。
</para>
  </sect2>

  <sect2 id="ssl-certificate-creation">
   <!-- 
   <title>Creating a Self-signed Certificate</title> 
   -->
   <title>创建自签名的证书</title>
   
<para>
<!--
    To create a quick self-signed certificate for the server, use the
    following <productname>OpenSSL</productname> command:
-->
要为服务器创建一个快速自认证的证书，使用下面的<productname>OpenSSL</productname>命令： 
<programlisting>
openssl req -new -text -out server.req
</programlisting>
<!-- 
    Fill out the information that <application>openssl</> asks for. Make sure
    you enter the local host name as <quote>Common Name</>; the challenge
    password can be left blank. The program will generate a key that is
    passphrase protected; it will not accept a passphrase that is less
    than four characters long. To remove the passphrase (as you must if
    you want automatic start-up of the server), run the commands: 
-->
填充那些<application>openssl</>向你询问的信息。确保把本地主机名当做<quote>Common Name</>输入。
要求的密码可以留空。该程序将生成一把用口令保护的密钥。小于四字符的口令保护是不被接受的。
要移去密钥(如果你想自动启动服务器就得这样)，运行下面的命令：
<programlisting>
openssl rsa -in privkey.pem -out server.key
rm privkey.pem
</programlisting>
    <!-- 
Enter the old passphrase to unlock the existing key. Now do: 
-->
输入旧口令把现有密钥解锁。然后: 
<programlisting>
openssl req -x509 -in server.req -text -key server.key -out server.crt
</programlisting>
<!-- 
    to turn the certificate into a self-signed certificate and to copy
    the key and certificate to where the server will look for them.
    Finally do: 
-->
将证书变成自签名的证书，并且复制密钥和证书到服务器能找到的地方。最后执行操作： 
<programlisting>
chmod og-rwx server.key
</programlisting>
<!-- 
    because the server will reject the file if its permissions are more
    liberal than this.
    For more details on how to create your server private key and
    certificate, refer to the <productname>OpenSSL</> documentation. 
-->
因为如果其权限比这更高，服务器将拒绝该文件。更多关于怎样创建服务器私钥和证书的细节，
请参考<productname>OpenSSL</>文档。
   </para>

   <!--
<para>
    A self-signed certificate can be used for testing, but a certificate
    signed by a certificate authority (<acronym>CA</>) (either one of the
    global <acronym>CAs</> or a local one) should be used in production
    so that clients can verify the server's identity. If all the clients
    are local to the organization, using a local <acronym>CA</> is
    recommended.
   </para>
-->
<para>
你可以用一个自认证的证书进行测试，但是在生产环境中应该使用一个由认证中心(<acronym>CA</>，
全球的<acronym>CA</>或者区域的<acronym>CA</>都可以)签发的证书，
这样客户端才能够识别服务器的身份。如果所有客户都是本地组织的，建议使用本地<acronym>CA</>。
</para>

  </sect2>

 </sect1>

 <sect1 id="ssh-tunnels">
  <!-- 
  <title>Secure TCP/IP Connections with <application>SSH</application> Tunnels</title> 
  -->
  <title>用<application>SSH</application>隧道进行安全 TCP/IP 连接</title>

  <indexterm zone="ssh-tunnels">
   <primary>ssh</primary>
  </indexterm>

  <!--
<para>
   It is possible to use <application>SSH</application> to encrypt the network
   connection between clients and a
   <productname>PostgreSQL</productname> server. Done properly, this
   provides an adequately secure network connection, even for non-SSL-capable
   clients.
  </para>
-->
<para>
使用<application>SSH</application>对<productname>PostgreSQL</productname>
服务器和客户端之间的网络连接进行加密是可能的。经过适当处理后，
这样做可以获得一个足够安全的网络连接。即使是没有 SSL 的客户端上也如此。
</para>

  
<para>
<!--
   First make sure that an <application>SSH</application> server is
   running properly on the same machine as the
   <productname>PostgreSQL</productname> server and that you can log in using
   <command>ssh</command> as some user. Then you can establish a secure
   tunnel with a command like this from the client machine:
-->
首先确认<application>SSH</application>正在和<productname>PostgreSQL</productname>
服务器的同一台机器上正确地运行，而且你可以通过某个用户用<command>ssh</command>登录。
然后你可以用下面这样的命令从客户端的机器上建立一个安全通道：
   <programlisting>
ssh -L 63333:localhost:5432 joe@foo.com
</programlisting>
<!-- 
   The first number in the <option>-L</option> argument, 63333, is the
   port number of your end of the tunnel; it can be any unused port.
   (IANA reserves ports 49152 through 65535 for private use.)  The
   second number, 5432, is the remote end of the tunnel: the port
   number your server is using. The name or IP address between the
   port numbers is the host with the database server you are going to
   connect to, as seen from the host you are logging in to, which
   is <literal>foo.com</literal> in this example. In order to connect
   to the database server using this tunnel, you connect to port 63333
   on the local machine: 
-->
<option>-L</option>参数的第一个数字(63333)是你这端通道的端口号，可以是任何未使用的端口。
（IANA提供端口49152到65535位私人使用。）第二个数字(5432)是通道的远端，
也就是服务器使用的端口号。在两个端口号之间的名称或者 IP 地址是你准备连接的数据库服务器，
在例子中是<literal>foo.com</literal>。为了使用这个通道与数据库服务器连接，
你在本机于端口63333连接：
<programlisting>
psql -h localhost -p 63333 postgres
</programlisting>
<!-- 
   To the database server it will then look as though you are really
   user <literal>joe</literal> on host <literal>foo.com</literal>
   connecting to <literal>localhost</literal> in that context, and it
   will use whatever authentication procedure was configured for
   connections from this user and host.  Note that the server will not
   think the connection is SSL-encrypted, since in fact it is not
   encrypted between the
   <application>SSH</application> server and the
   <productname>PostgreSQL</productname> server.  This should not pose any
   extra security risk as long as they are on the same machine. 
-->
对于数据库服务器而言，在这种情况下，它会把你当做主机<literal>foo.com</literal>
连接到<literal>localhost</literal>的真正的用户<literal>joe</literal>，
并且使用为这个用户和主机设置的认证手段进行认证。请注意，服务器不会认为连接是 SSL 加密的，
因为实际上在<application>SSH</application>服务器和<productname>PostgreSQL</productname>
服务器之间是没有加密的。只要它们在同一台机器上，这么做并不会导致任何安全漏洞。
  </para>

  <!--
<para>
   In order for the
   tunnel setup to succeed you must be allowed to connect via
   <command>ssh</command> as <literal>joe@foo.com</literal>, just
   as if you had attempted to use <command>ssh</command> to create a
   terminal session.
  </para>
-->
<para>
为了保证能够成功地建立通道，你必须被允许作为<literal>joe@foo.com</literal>
通过<command>ssh</command>建立连接，就像你使用<command>ssh</command>创建终端会话一样。
</para>
  
<para>
<!--
   You could also have set up the port forwarding as
-->
你也可以设置端口转发
<programlisting>
ssh -L 63333:foo.com:5432 joe@foo.com
</programlisting>
<!-- 
   but then the database server will see the connection as coming in
   on its <literal>foo.com</literal> interface, which is not opened by
   the default setting <literal>listen_addresses =
   'localhost'</literal>.  This is usually not what you want. 
-->
但是随后数据库服务器将看到连接从<literal>foo.com</literal>界面进来，
这是不被缺省设置<literal>listen_addresses = 'localhost'</literal>开放的。
这通常不是你想要的。
  </para>

  
<para>
<!--
   If you have to <quote>hop</quote> to the database server via some
   login host, one possible setup could look like this:
-->
如果你必须通过某些登陆主机<quote>跳跃</quote>到数据库服务器，
一个可能的设置看起来像这样：
<programlisting>
ssh -L 63333:db.foo.com:5432 joe@shell.foo.com
</programlisting>
<!-- 
   Note that this way the connection
   from <literal>shell.foo.com</literal>
   to <literal>db.foo.com</literal> will not be encrypted by the SSH
   tunnel.
   SSH offers quite a few configuration possibilities when the network
   is restricted in various ways.  Please refer to the SSH
   documentation for details. 
-->
请注意，这个方式从<literal>shell.foo.com</literal>到<literal>db.foo.com</literal>
的连接将不会通过SSH通道加密。当网络以各种方式被限制时，SSH提供了相当多的配置可能性。
请参阅SSH文档获取详情。
  </para>

  <tip>
   <!--
<para>
    Several other applications exist that can provide secure tunnels using
    a procedure similar in concept to the one just described.
   </para>
-->
<para>
还有几种不同的产品可以提供安全的通道，所使用的过程类似我们刚刚描述的过程。
</para>
  </tip>

 </sect1>

 <sect1 id="event-log-registration">
 <!-- 
 <title>Registering <application>Event Log</> on <systemitem
  class="osname">Windows</></title> 
  -->
   <title>在<systemitem class="osname">Windows</>上注册<application>事件日志</></title>

  <indexterm zone="event-log-registration">
   <!-- 
   <primary>event log</primary>
   <secondary>event log</secondary> 
   -->
   <primary>事件日志</primary>
   <secondary>事件日志</secondary>
  </indexterm>
  
<para>
<!--
   To register a <systemitem class="osname">Windows</>
   <application>event log</> library with the operating system,
   issue this command:
-->
要注册操作系统的<systemitem class="osname">Windows</><application>事件日志</>库，发出这个命令：
<screen>
<userinput>regsvr32 <replaceable>pgsql_library_directory</>/pgevent.dll</>
</screen>
<!-- 
   This creates registry entries used by the event viewer, under the default
   event source named <literal>PostgreSQL</literal>. 
-->
这将使用事件查看器创建注册表条目，在默认的名为<literal>PostgreSQL</literal>的事件源下。
  </para>
  
<para>
<!--
   To specify a different event source name (see
   <xref linkend="guc-event-source">), use the <literal>/n</literal>
   and <literal>/i</literal> options:
-->
要指定一个不同的事件源名字（参阅<xref linkend="guc-event-source">），
使用<literal>/n</literal>和<literal>/i</literal>选项：
<screen>
<userinput>regsvr32 /n /i:<replaceable>event_source_name</> <replaceable>pgsql_library_directory</>/pgevent.dll</>
</screen>
  </para>
 
<para>
 <!--
 To unregister the <application>event log</> library from
   the operating system, issue this command:
-->
要从操作系统中注销<application>event log</>库，发出这个命令：
<screen>
<userinput>regsvr32 /u [/i:<replaceable>event_source_name</>] <replaceable>pgsql_library_directory</>/pgevent.dll</>
</screen>
  </para>

  <note>
   <!--
<para>
    To enable event logging in the database server, modify
    <xref linkend="guc-log-destination"> to include
    <literal>eventlog</literal> in <filename>postgresql.conf</filename>.
   </para>
-->
<para>
要在数据库服务器中启用事件日志记录，在<filename>postgresql.conf</filename>
中修改<xref linkend="guc-log-destination">包含<literal>eventlog</literal>。
</para>
  </note>
 </sect1>

</chapter>
