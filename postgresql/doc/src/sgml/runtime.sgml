<!-- doc/src/sgml/runtime.sgml -->

<chapter id="runtime">
 <title>服务器设置和操作</title>

 <para>
  本章讨论如何设置和运行数据库服务器，以及它与操作系统的交互。
 </para>

 <sect1 id="postgres-user">
  <title><productname>PostgreSQL</productname>用户账户</title>

  <indexterm>
   <primary>postgres user</primary>
  </indexterm>

  <para>
   和对外部世界可访问的任何服务器守护进程一样，我们也建议在一个独立的用户账户下运行<productname>PostgreSQL</productname>。这个用户账户应该只拥有被该服务器管理的数据，并且应该不能被其他守护进程共享（例如，使用用户<literal>nobody</literal>是一个坏主意）。我们不建议把可执行文件安装为属于这个用户，因为妥协系统可能接着修改它们自己的二进制文件。
  </para>

  <para>
   要在你的系统中增加一个 Unix 用户账户，查看一个命令<command>useradd</command>或<command>adduser</command>。通常会用<systemitem>postgres</systemitem>（本书中也假定用这个账户），但是你可以使用另一个名称。
  </para>
 </sect1>

 <sect1 id="creating-cluster">
  <title>创建一个数据库集簇</title>

  <indexterm>
   <primary>数据库集簇</primary>
  </indexterm>

  <indexterm>
   <primary>数据区域</primary>
   <see>数据库集簇</see>
  </indexterm>

  <para>
   在你能做任何事情之前，你必须在磁盘上初始化一个数据库存储区域。我们称之为一个<firstterm>数据库集簇</firstterm>（<acronym>SQL</acronym>使用的术语是目录集簇）。一个数据库集簇是被一个运行数据库服务器的单一实例所管理的一个数据库的集合。在初始化之后，一个数据库集簇将包含一个名为<literal>postgres</literal>的数据库，它表示被功能、用户和第三方应用所使用的默认数据库。数据库服务器本身并不要求<literal>postgres</literal>数据库存在。另一个在初始化过程中为每一个集簇创建的数据库被称为<literal>template1</literal>。顾名思义，它将被用于创建后续数据库的模板；它不应该被用于实际工作（在集簇内创建新数据库的更多信息请见<xref linkend="managing-databases">）。
  </para>

  <para>
   在文件系统术语中，一个数据库集簇将是一个单一目录，所有数据都将被存储在其中。我们称它为<firstterm>数据目录</firstterm>或<firstterm>数据区域</firstterm>。在哪里存储你的数据完全由你选择。没有默认的位置，不过<filename>/usr/local/pgsql/data</filename>或<filename>/var/lib/pgsql/data</filename>位置比较流行。要初始化一个数据库集簇，使用和<productname>PostgreSQL</productname>一起安装的命令<xref linkend="app-initdb">。<indexterm><primary>initdb</></>你的数据库集簇的文件系统位置由<option>-D</option>选项指定，例如：
<screen>
<prompt>$</> <userinput>initdb -D /usr/local/pgsql/data</userinput>
</screen>
   注意你必须在使用<productname>PostgreSQL</productname>用户账户（如前一节所示）登录后执行这个命令。
  </para>

  <tip>
   <para>
    作为<option>-D</option>选项的一种替换方案，你可以设置环境变量<envar>PGDATA</envar>。
    <indexterm><primary><envar>PGDATA</envar></primary></indexterm>
   </para>
  </tip>

  <para>
   另一种替代方案是，你可以通过<xref linkend="app-pg-ctl"><indexterm><primary>pg_ctl</></>程序来运行<command>initdb</command>：
<screen>
<prompt>$</> <userinput>pg_ctl -D /usr/local/pgsql/data initdb</userinput>
</screen>
   如果你使用<command>pg_ctl</command>来启停服务器（见<xref linkend="server-start">），这种方法可能更直观，以为这样<command>pg_ctl</command>将是你用来管理数据库服务器实例的唯一命令。
  </para>

  <para>
   如果你指定的目录还不存在，<command>initdb</command>将尝试创建它。很可能它将没有权限来创建（如果你遵照我们的建议并且创建了一个非特权的账户）。在这种情况下，你应该自己创建目录（作为 root）并且将其所有者改成<productname>PostgreSQL</productname>用户。下面是怎样做这些的命令：
<screen>
root# <userinput>mkdir /usr/local/pgsql/data</userinput>
root# <userinput>chown postgres /usr/local/pgsql/data</userinput>
root# <userinput>su postgres</userinput>
postgres$ <userinput>initdb -D /usr/local/pgsql/data</userinput>
</screen>
  </para>

  <para>
   如果数据目录看起来已经被初始化过了，<command>initdb</command>将拒绝运行。</para>

  <para>
   因为数据目录包含所有存储在数据库里的数据，所以最重要的是保护这个目录不受未授权的访问。因此，<command>initdb</command>会回收禁止除<productname>PostgreSQL</productname>用户之外所有用户的访问权限。
  </para>

  <para>
   不过，虽然目录的内容是安全的，但默认的客户端认证设置允许任意本地用户连接到数据库甚至成为数据库超级用户。如果你不信任其他本地用户， 我们建议你使用<command>initdb</command>的<option>-W</option>、<option>--pwprompt</option>或<option>--pwfile</option>选项之一给数据库超级用户赋予一个口令。<indexterm><primary>password</><secondary>of the superuser</></indexterm>还可以指定<option>-A md5</>或<option>-A password</>，这样就不会使用默认的<literal>trust</> 身份认证。或者在执行<command>initdb</command>之后、第一次启动服务器<emphasis>之前</>修改生成的<filename>pg_hba.conf</filename>文件（另外一些可行的方法包括<literal>peer</literal>认证或者用文件系统权限限制连接。更多信息见<xref linkend="client-authentication">）。
  </para>

  <para>
   <command>initdb</command>同时也为数据库集簇初始化默认区域<indexterm><primary>locale</></>。 通常，它将只是使用环境中的区域设置并且把它们应用于被初始化的数据库。 可以为数据库指定一个不同的区域；有关于此的更多信息可以在<xref linkend="locale">中找到。 特定数据库集簇中使用的默认排序顺序是通过<command>initdb</command>设置的， 虽然你可以创建使用不同排序顺序的新数据库，但在 initdb 创建的模板数据库中使用的顺序不能更改（除非删除并重建它们）。使用非<literal>C</>或<literal>POSIX</>的区域还会对性能造成影响。因此，第一次就正确地选择很重要。
  </para>

  <para>
   <command>initdb</command>还为数据库集簇设置默认的字符集编码。通常字符集编码应该选择与区域设置匹配。详见<xref linkend="multibyte">。
  </para>

  <sect2 id="creating-cluster-nfs">
   <title>网络文件系统</title>

   <indexterm zone="creating-cluster-nfs">
    <primary>网络文件系统</primary>
   </indexterm>
   <indexterm><primary><acronym>NFS</></><see>网络文件系统</></>
   <indexterm><primary>网络附加存储 (<acronym>NAS</>)</><see>网络文件系统</></>

   <para>
    许多安装会在网络文件系统上创建数据库集簇。有时直接通过<acronym>NFS</>， 或通过内部使用<acronym>NFS</>的网络附加存储设备（<acronym>NAS</>）完成。 <productname>PostgreSQL</>不对 <acronym>NFS</>文件系统做特殊处理，即它假定<acronym>NFS</>的行为和本地连接的设备完全一样（<acronym>DFS</>，直接附加存储）。如果客户端和服务器<acronym>NFS</>实现有非标准的语义，这将导致可靠性问题 （参阅<ulink url="http://www.time-travellers.org/shane/papers/NFS_considered_harmful.html"></ulink>）。 具体来说，延迟（异步）写入到<acronym>NFS</>服务器可以导致可靠性问题。 如果可能的话，把<acronym>NFS</>文件系统挂载为同步（无高速缓存）可以避免这一点。还有，我们不推荐软挂载的<acronym>NFS</>（存储区域网络（<acronym>SAN</>）使用低级别的通讯协议而不是<acronym>NFS</>）。
   </para>

  </sect2>

 </sect1>

 <sect1 id="server-start">
  <title>启动数据库服务器</title>

  <para>
   在任何人可以访问数据库前，你必须启动数据库服务器。 数据库服务器程序是<command>postgres</command><indexterm><primary>postgres</></>， 它必须知道在哪里能找到它要用的数据。这是用<option>-D</option>选项实现的。 因此，启动服务器最简单的方法是：
<screen>
$ <userinput>postgres -D /usr/local/pgsql/data</userinput>
</screen>
   这将把服务器放在前台运行。这个步骤同样必须以<productname>PostgreSQL</productname>用户帐户登录来操作。如果没有<option>-D</option>选项，服务器将尝试使用环境变量<envar>PGDATA</envar>命名的目录。如果这个环境变量也没有提供则导致失败。
  </para>

  <para>
   通常最好在后台启动<command>postgres</command>。要这样做，使用常用的 Unix shell 语法：
<screen>
$ <userinput>postgres -D /usr/local/pgsql/data &gt;logfile 2&gt;&amp;1 &amp;</userinput>
</screen>
   如上所示，把服务器的<systemitem>stdout</>和<systemitem>stderr</>输出存储到某个地方是非常重要的。这将对审计目的和诊断问题有所帮助（更深入的有关日志文件处理的讨论请见（<xref linkend="logfile-maintenance">）。
  </para>

  <para>
   <command>postgres</command>还接受其它一些命令行选项。更多的信息请见<xref linkend="app-postgres">参考页 和下面的<xref linkend="runtime-config">。
  </para>

  <para>
   这些 shell 语法很容易让人觉得无聊。因此我们提供了包装器程序<xref linkend="app-pg-ctl"><indexterm><primary>pg_ctl</primary></indexterm>以简化一些任务。例如：
<programlisting>
pg_ctl start -l logfile
</programlisting>
   将在后台启动服务器并且把输出放到指定的日志文件中。<option>-D</option>选项和<command>postgres</command>中的一样。<command>pg_ctl</command>还可以用于停止服务器。
  </para>

  <para>
   通常，你会希望在计算机启动的时候启动数据库服务器。<indexterm><primary>booting</><secondary>starting the server during</></indexterm>自动启动脚本是操作系统相关的。<productname>PostgreSQL</productname>在<filename>contrib/start-scripts</>目录中提供了几种。安装将需要 root 权限。
  </para>

  <para>
   不同的系统在引导时有不同的启动守护进程的习惯。许多系统有一个文件<filename>/etc/rc.local</filename>或<filename>/etc/rc.d/rc.local</filename>。其他的使用<filename>init.d</filename>或<filename>rc.d</>目录。不管你做什么，服务器必须由<productname>PostgreSQL</productname>用户账户<emphasis>而不是 root</emphasis>或任何其他用户启动。因此你可能应该在你的命令中使用<literal>su postgres -c '...'</literal>这种形式。例如：
<programlisting>
su postgres -c 'pg_ctl start -D /usr/local/pgsql/data -l serverlog'
</programlisting>
  </para>

  <para>
   下面是一些更加与操作系统相关的建议（在每一种情况中要确保在我们展示通用值的地方使用正确的安装目录和用户名）。

   <itemizedlist>
    <listitem>
     <para>
      对于<productname>FreeBSD</productname>，找找<productname>PostgreSQL</productname>源码发布中的文件<filename>contrib/start-scripts/freebsd</filename>。<indexterm><primary>FreeBSD</><secondary>start script</secondary></>
     </para>
    </listitem>

    <listitem>
     <para>
      在<productname>OpenBSD</productname>上， 把下面几行加到<filename>/etc/rc.local</filename>文件中：
      <indexterm><primary>OpenBSD</><secondary>启动脚本</secondary></>
<programlisting>
if [ -x /usr/local/pgsql/bin/pg_ctl -a -x /usr/local/pgsql/bin/postgres ]; then
    su -l postgres -c '/usr/local/pgsql/bin/pg_ctl start -s -l /var/postgresql/log -D /usr/local/pgsql/data'
    echo -n ' postgresql'
fi
</programlisting>
     </para>
    </listitem>

    <listitem>
     <para>
      在<productname>Linux</productname>系统上将
      <indexterm><primary>Linux</><secondary>启动脚本</secondary></>
<programlisting>
/usr/local/pgsql/bin/pg_ctl start -l logfile -D /usr/local/pgsql/data
</programlisting>
      加入到<filename>/etc/rc.d/rc.local</filename>或<filename>/etc/rc.local</filename>中，还可以在<productname>PostgreSQL</productname>的源码发布中找找文件<filename>contrib/start-scripts/linux</filename>。
     </para>
    </listitem>

    <listitem>
     <para>
      在<productname>NetBSD</productname>上，你可以根据爱好选择<productname>FreeBSD</productname>或<productname>Linux</productname>的启动脚本。
      <indexterm><primary>NetBSD</><secondary>启动脚本</secondary></>
     </para>
    </listitem>

    <listitem>
     <para>
      在<productname>Solaris</productname>上，创建一个名为<filename>/etc/init.d/postgresql</filename>的文件，其中包含下列行：
      <indexterm><primary>Solaris</><secondary>启动脚本</secondary></>
<programlisting>
su - postgres -c "/usr/local/pgsql/bin/pg_ctl start -l logfile -D /usr/local/pgsql/data"
</programlisting>
      然后在<filename>/etc/rc3.d</>中创建一个符号链接<filename>S99postgresql</>指向它。
     </para>
    </listitem>
   </itemizedlist>

  </para>

   <para>
    当服务器在运行时，它的<acronym>PID</acronym>被保存在数据目录中的<filename>postmaster.pid</filename>文件。这样做 可以防止多个服务器实例运行在同一个数据目录中，并且也可以被用来关闭服务器。
   </para>

   <sect2 id="server-start-failures">
    <title>服务器启动失败</title>

    <para>
     有几个常见的原因会导致服务器启动失败。通过检查服务器日志或使用手工启动的方法（不做标准输出或标准错误的重定向）， 就可以看到出现什么错误消息。下面我们详细地解释一些最常见的错误消息。
    </para>

    <para>
<screen>
LOG:  could not bind IPv4 socket: Address already in use
HINT:  Is another postmaster already running on port 5432? If not, wait a few seconds and retry.
FATAL:  could not create TCP/IP listen socket
</screen>
     正如这个消息所说的，这表示：你试图在一个已经有服务器运行着的端口上再启动另一个服务器。不过，如果核心错误消息不是<computeroutput>Address already in use</computeroutput>或其变体，那就有可能是别的问题。 例如，试图在一个被保留的端口上启动服务器会收到下面这样的消息：
<screen>
$ <userinput>postgres -p 666</userinput>
LOG:  could not bind IPv4 socket: Permission denied
HINT:  Is another postmaster already running on port 666? If not, wait a few seconds and retry.
FATAL:  could not create TCP/IP listen socket
</screen>
    </para>

    <para>
     像这样的消息：
<screen>
FATAL:  could not create shared memory segment: Invalid argument
DETAIL:  Failed system call was shmget(key=5440001, size=4011376640, 03600).
</screen>
     可能意味着你的内核对共享内存区的限制小于<productname>PostgreSQL</productname>试图创建的工作区域（本例中是 4011376640 字节）。或者可能意味着根本就没有 System-V 风格的共享内存支持被配置在你的内核中。作为一种临时的解决方案， 你可以试着以小于正常数量的缓冲区（<xref linkend="guc-shared-buffers">）启动服务器。 你最终还是会希望重新配置内核以增加共享内存允许的尺寸。 当你试图在同一台机器上启动多个服务器，并且它们所需的总空间超过了内核的限制，也会报这个错。
    </para>

    <para>
     一个这样的错误：
<screen>
FATAL:  could not create semaphores: No space left on device
DETAIL:  Failed system call was semget(5440126, 17, 03600).
</screen>
     并<emphasis>不</emphasis>意味着你已经用光了磁盘空间。它的意思是你的内核对<systemitem class="osname">System V</>信号量的限制小于<productname>PostgreSQL</productname>想创建的数量。和上面一样，你可以通过减少允许的连接数（<xref linkend="guc-max-connections">）来绕开这个限制，但最终你还是会希望提高内核的限制。
    </para>

    <para>
     如果你收到一个<quote>illegal system call</>错误， 那么很有可能是你的内核根本不支持共享内存或者信号量。这种情况下你唯一的选择就是重新配置内核并且把这些特性打开。
    </para>

    <para>
     关于配置<systemitem class="osname">System V</> <acronym>IPC</>功能的细节请见<xref linkend="sysvipc">。
    </para>
   </sect2>

   <sect2 id="client-connection-problems">
    <title>客户端连接问题</title>

    <para>
     尽管可能在客户端出现的错误情况范围宽广而且是应用相关的，但的确有几种与服务器的启动方式直接相关。除了下面提到的几种错误之外的问题都应该在相应的客户端应用文档中。
    </para>

    <para>
<screen>
psql: could not connect to server: Connection refused
        Is the server running on host "server.joe.com" and accepting
        TCP/IP connections on port 5432?
</screen>
     这是常见的<quote>I couldn't find a server to talk to</quote>失败。上面的情况看起来是发生在尝试 TCP/IP 通信时。常见的错误是忘记把服务器配置成允许 TCP/IP 连接。
    </para>

    <para>
     另外，当试图通过 Unix 域套接字与本地服务器通信时，你会看到这个：
<screen>
psql: could not connect to server: No such file or directory
        Is the server running locally and accepting
        connections on Unix domain socket "/tmp/.s.PGSQL.5432"?
</screen>
    </para>

    <para>
     最后一行可以验证客户端是不是尝试连接到正确的位置。如果实际上没有服务器在那里运行，典型的核心错误消息将是<computeroutput>Connection refused</computeroutput>或<computeroutput>No such file or directory</computeroutput>（值得注意的是这种环境中的<computeroutput>Connection refused</computeroutput>并<emphasis>不</emphasis>表示服务器得到了你的连接请求并拒绝了它。那种情况会产生一个不同的消息，如<xref linkend="client-authentication-problems">中所示）。其它像<computeroutput>Connection timed out</computeroutput>这样的消息可能表示更基础的问题，如缺少网络连接。
    </para>
   </sect2>
  </sect1>

 <sect1 id="kernel-resources">
  <title>管理内核资源</title>

  <para>
   <productname>PostgreSQL</>某些时候会耗尽操作系统的各种资源限制，当同一个系统上运行着多个拷贝的服务器或在一个非常大的安装中时尤其如此。本节解释了<productname>PostgreSQL</>使用的内核资源以及你可以采取的用于解决内核资源消耗相关问题的步骤。
  </para>

  <sect2 id="sysvipc">
   <title>共享内存和信号量</title>

   <indexterm zone="sysvipc">
    <primary>共享内存</primary>
   </indexterm>

   <indexterm zone="sysvipc">
    <primary>信号量</primary>
   </indexterm>

   <para>
    共享内存和信号量一起被称为<quote><systemitem class="osname">System V</> <acronym>IPC</></quote>（其中还有消息队列，不过它与<productname>PostgreSQL</>无关）。除了在<systemitem class="osname">Windows</>上（<productname>PostgreSQL</>提供了自己的实现），这些功能都是运行<productname>PostgreSQL</>所必需的。
   </para>

   <para>
    完全缺少这些功能通常表现为服务器启动时的<errorname>Illegal system call</>错误。这种情况下，除了重新配置内核之外别无选择。<productname>PostgreSQL</>没有它们就不能工作。 不过，在现代操作系统中这种情况是罕见的。
   </para>

   <para>
    当<productname>PostgreSQL</>超出了这些<acronym>IPC</>的硬限制之一时，服务器会拒绝启动并且并且留下一条有指导性的错误消息，其中描述了问题以及应该怎么做（又见<xref linkend="server-start-failures">）。相关的内核参数在不同系统之间的命名方式一致，<xref linkend="sysvipc-parameters">给出了一个概述。不过，设置它们的方法却多种多样。下面给出了对于某些平台的建议：
   </para>

   <note>
     <para>
       在<productname>PostgreSQL</> 9.3 之前，启动服务器所要求的 System V 共享内存的量要更大。如果你在运行着一个老版本的服务器，请参考该服务器版本的文档。
     </para>
   </note>

   <table id="sysvipc-parameters">
    <title><systemitem class="osname">System V</> <acronym>IPC</>参数</title>

    <tgroup cols="3">
     <thead>
      <row>
       <entry>名称</>
       <entry>描述</>
       <entry>合理值</>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><varname>SHMMAX</></>
       <entry>共享内存段的最大尺寸（字节）</>
       <entry>至少 1kB （如果运行服务器的多个版本应该设置更大）</entry>
      </row>

      <row>
       <entry><varname>SHMMIN</></>
       <entry>共享内存段的最小尺寸（字节）</>
       <entry>1</>
      </row>

      <row>
       <entry><varname>SHMALL</></>
       <entry>可用共享内存的总量（字节或页面）</>
       <entry>如果是字节，同<varname>SHMMAX</varname>；如果是页面，为<literal>ceil(SHMMAX/PAGE_SIZE)</literal></>
      </row>

      <row>
       <entry><varname>SHMSEG</></>
       <entry>每个进程的最大共享内存段数目</>
       <entry>只需要 1 段，但是默认值高很多</>
      </row>

       <row>
        <entry><varname>SHMMNI</></>
        <entry>系统范围内的最大共享内存段数目</>
        <entry>像<varname>SHMSEG</>外加其他应用的空间</>
       </row>

       <row>
        <entry><varname>SEMMNI</></>
        <entry>信号量标识符（即，集合）的最大数目</>
        <entry>至少<literal>ceil((max_connections + autovacuum_max_workers + 4) / 16)</literal></>
       </row>

       <row>
        <entry><varname>SEMMNS</></>
        <entry>系统范围内的最大信号量数目</>
        <entry><literal>ceil((max_connections + autovacuum_max_workers + 4) / 16) * 17</literal>外加其他应用的空间</>
       </row>

       <row>
        <entry><varname>SEMMSL</></>
        <entry>每个集合中信号量的最大数目</>
        <entry>至少 17</>
       </row>

       <row>
        <entry><varname>SEMMAP</></>
        <entry>信号量映射中的项数</>
        <entry>见文本</>
       </row>

       <row>
        <entry><varname>SEMVMX</></>
        <entry>信号量的最大值</>
        <entry>至少 1000 （默认值常常是 32767，如非必要不要更改）</>
       </row>

     </tbody>
    </tgroup>
   </table>

   <para>
    <productname>PostgreSQL</>要求少量字节的 System V 共享内存（在 64 位平台上通常是 48 字节）用于每一个服务器拷贝。在大多数现代操作系统上，这个量很容易得到。但是，如果你运行了很多个服务器拷贝，或者其他应用也在使用 System V 共享内存，可能需要增加<varname>SHMMAX</>（以字节计的共享内存段的最大尺寸）或<varname>SHMALL</>（系统范围内 System V 共享内存的总量）。注意在很多系统上<varname>SHMALL</>是以页面而不是字节来度量。
   </para>

   <para>
    不太可能出问题的是共享内存段的最小尺寸（<varname>SHMMIN</>），对<productname>PostgreSQL</>来说应该最多大约是 32 字节（通常只是1）。而系统范围（<varname>SHMMNI</>）或每个进程（<varname>SHMSEG</>）的最大共享内存段数目不太可能会导致问题，除非你的系统把它们设成零。
   </para>

   <para>
    <productname>PostgreSQL</>对每个允许的连接（<xref linkend="guc-max-connections">）和每个允许的自动清理工作者进程（<xref linkend="guc-autovacuum-max-workers">）使用一个信号量， 以16个为一个集合。每个这种集合还包含第 17 个信号量， 其中存储一个<quote>magic number</quote>，以检测和其它应用使用的信号量集合的冲突。 系统里的最大信号量数目是由<varname>SEMMNS</>设置的， 因此这个值必须至少和<varname>max_connections</>加<varname>autovacuum_max_workers</>一样大， 并且每 16 个连接外加工作者还要另外加一个（见<xref linkend="sysvipc-parameters">中的公式）。参数<varname>SEMMNI</> 决定系统中同一时刻可以存在的信号量集合的数目限制。因此这个参数必须至少为<literal>ceil((max_connections + autovacuum_max_workers + 4) / 16)</>。降低允许的连接数目是一种临时的绕开失败（来自函数<function>semget</>）的方法，通常使用让人混乱的措辞<quote>No space left on device</>。
   </para>

   <para>
    在某些情况下可能还有必要增大<varname>SEMMAP</>，使之至少与<varname>SEMMNS</>相近。 这个参数定义信号量资源映射的尺寸，在其中每个连续的可用信号量块都需要一项。 每当一个信号量集合被释放，那么它要么会被加入到该与被释放块相邻的一个现有项，或者它会被注册在一个新映射项中。如果映射被填满，被释放的信号量将丢失（直到重启）。因此信号量空间的碎片时间长了会导致可用的信号量比应有的信号量少。
   </para>

   <para>
    <varname>SEMMSL</>参数决定一个信号量集合中可以有多少信号量，对于<productname>PostgreSQL</>而言必须至少是 17。
   </para>

   <para>
    许多其他设置与<quote>semaphore undo</>（信号量撤销）有关，例如<varname>SEMMNU</>和<varname>SEMUME</>，但不影响<productname>PostgreSQL</>。
   </para>


    <variablelist>
     <varlistentry>
      <term><systemitem class="osname">AIX</>
      <indexterm><primary>AIX</><secondary>IPC 配置</></>
      </term>
      <listitem>
       <para>
        至少到版本 5.1 为止，不再需要对这些参数（例如<varname>SHMMAX</varname>）做任何特殊的配置，这看起来就像是被配置成允许所有内存都被用作共享内存。这是一种通常被用于其他数据库（<application>DB/2</application>）的配置。</para>

       <para>但是，可能需要修改<filename>/etc/security/limits</filename>中的全局<command>ulimit</command>信息，默认的文件尺寸硬限制（<varname>fsize</varname>）和文件数量（<varname>nofiles</varname>）可能太低。
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">FreeBSD</>
      <indexterm><primary>FreeBSD</><secondary>IPC 配置</></>
      </term>
      <listitem>
       <para>
        可以使用<command>sysctl</command>或<command>loader</command>接口来改变默认配置。下列参数可以使用<command>sysctl</command>设置：
<screen>
<prompt>#</prompt> <userinput>sysctl kern.ipc.shmall=32768</userinput>
<prompt>#</prompt> <userinput>sysctl kern.ipc.shmmax=134217728</userinput>
<prompt>#</prompt> <userinput>sysctl kern.ipc.semmap=256</userinput>
</screen>
        要让这些设置在重启之后也保持，请修改<filename>/etc/sysctl.conf</filename>。
       </para>

       <para>
        对于<command>sysctl</command>所关心的来说这些信号量相关的设置都是只读的，但是可以在<filename>/boot/loader.conf</filename>中设置：
<programlisting>
kern.ipc.semmni=256
kern.ipc.semmns=512
kern.ipc.semmnu=256
</programlisting>
        修改这些值后需要一次重启让新设置能生效。
        （注意：FreeBSD 不使用<varname>SEMMAP</>。较老的版本
        会接受并且忽略<literal>kern.ipc.semmap</>的设置，而较新的
        版本会完全拒绝它）。
       </para>

       <para>
        你可能也希望你的内核将共享内存锁定在 RAM 中并且防止它被换页到交换分区。这可以使用<command>sysctl</command>的设置
<literal>kern.ipc.shm_use_phys</literal>来完成。
       </para>

       <para>
        如果通过启用<application>sysctl</>的<literal>security.jail.sysvipc_allowed</>运行在 FreeBSD jail 中，运行在不同 jail 中的<application>postmaster</>应当被不同的操作系统用户运行。这可以提高安全性，因为它阻止非 root 用户干涉不同 jail 中的共享内存或信号量，并且它允许 PostgreSQL IPC 清理代码正确地工作（在 FreeBSD 6.0 及其后的版本中，IPC 清理代码不能正确地检测到其他 jail 中的进程，也不能阻止不同 jail 中的 postmaster 运行在相同的端口）。
       </para>

       <para>
        <systemitem class="osname">FreeBSD</> 4.0 之前的版本的工作与<systemitem class="osname">OpenBSD</>相似（见下文）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><systemitem class="osname">NetBSD</>
      <indexterm><primary>NetBSD</><secondary>IPC 配置</></>
      </term>
      <listitem>
       <para>
        在<systemitem class="osname">NetBSD</> 5.0 及其后的版本中，IPC 参数可以使用<command>sysctl</command>调整。例如：
<screen>
<prompt>$</prompt> <userinput>sysctl -w kern.ipc.shmmax=16777216</userinput>
</screen>
        要使这些设置在重启后保持，请修改<filename>/etc/sysctl.conf</filename>。
       </para>

       <para>
        你可能也希望你的内核将共享内存锁定在 RAM 中并且防止它被换页到交换分区。这可以使用<command>sysctl</command>的设置
<literal>kern.ipc.shm_use_phys</literal>来完成。
       </para>

       <para>
        <systemitem class="osname">NetBSD</> 5.0 以前的版本的工作与<systemitem class="osname">OpenBSD</>相似（见下文），除了那些参数应该用关键词<literal>options</>设置而不是<literal>option</>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><systemitem class="osname">OpenBSD</>
      <indexterm><primary>OpenBSD</><secondary>IPC 配置</></>
      </term>
      <listitem>
       <para>
        当内核被编译时，选项<varname>SYSVSHM</>和<varname>SYSVSEM</>需要被启用（它们默认值）。共享内存的最大尺寸由选项<varname>SHMMAXPGS</>（以页面计）决定。下面展示了一个如何设置多个参数的例子：
<programlisting>
option        SYSVSHM
option        SHMMAXPGS=4096
option        SHMSEG=256

option        SYSVSEM
option        SEMMNI=256
option        SEMMNS=512
option        SEMMNU=256
option        SEMMAP=256
</programlisting>
       </para>

       <para>
        你可能也希望你的内核将共享内存锁定在 RAM 中并且防止它被换页到交换分区。这可以使用<command>sysctl</command>的设置
<literal>kern.ipc.shm_use_phys</literal>来完成。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><systemitem class="osname">HP-UX</>
      <indexterm><primary>HP-UX</><secondary>IPC 配置</></>
      </term>
      <listitem>
       <para>
        默认的设置可以满足正常的安装。在<productname>HP-UX</> 10 上，<varname>SEMMNS</>的出厂默认值是 128，这可能对大型数据库站点太低。
       </para>
       <para>
        <acronym>IPC</>参数可以在<menuchoice><guimenu>Kernel Configuration</><guimenuitem>Configurable Parameters</></>下的<application>System Administration Manager</>（<acronym>SAM</>）中被设置。当你完成时选择<guibutton>Create A New Kernel</>。
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">Linux</>
      <indexterm><primary>Linux</><secondary>IPC 配置</></>
      </term>
      <listitem>
       <para>
        默认的最大段尺寸是 32 MB，并且默认的最大总尺寸是 2097152 个页面。一个页面几乎总是 4096 字节，除了在使用少见<quote>huge pages</quote>的内核配置中（使用<literal>getconf PAGE_SIZE</literal>来验证）。
       </para>

       <para>
        共享内存尺寸设置可以通过<command>sysctl</command>接口来更改。例如，要允许 16 GB：
<screen>
<prompt>$</prompt> <userinput>sysctl -w kernel.shmmax=17179869184</userinput>
<prompt>$</prompt> <userinput>sysctl -w kernel.shmall=4194304</userinput>
</screen>
        另外在重启之间这些设置可以被保存在文件<filename>/etc/sysctl.conf</filename>中。我们强烈推荐这样做。
       </para>

       <para>
        古老的发型可能没有<command>sysctl</command>程序，但是可以通过操纵<filename>/proc</filename>文件系统来得到等效的更改：
<screen>
<prompt>$</prompt> <userinput>echo 17179869184 &gt;/proc/sys/kernel/shmmax</userinput>
<prompt>$</prompt> <userinput>echo 4194304 &gt;/proc/sys/kernel/shmall</userinput>
</screen>
       </para>

       <para>
        剩下的默认值都被设置得很宽大，并且通常不需要更改。
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">OS X</>
      <indexterm><primary>OS X</><secondary>IPC 配置</></>
      </term>
      <listitem>
       <para>
        在 OS X 中配置共享内存的推荐方法是创建一个名为<filename>/etc/sysctl.conf</>的文件，其中包含这样的变量赋值：
<programlisting>
kern.sysv.shmmax=4194304
kern.sysv.shmmin=1
kern.sysv.shmmni=32
kern.sysv.shmseg=8
kern.sysv.shmall=1024
</programlisting>
        注意在某些 OS X 版本中，<emphasis>所有五个</>共享内存参数必须在<filename>/etc/sysctl.conf</>中设置，否则值将会被忽略。
       </para>

       <para>
        注意近期的 OS X 版本会忽略把<varname>SHMMAX</>设置成非 4096 倍数值的尝试。
       </para>

       <para>
        在这个平台上，<varname>SHMALL</>以 4kB 的页面度量。
       </para>

       <para>
        在更老的 OS X 版本中，你将需要重启来让共享内存参数的更改生效。到了 10.5，可以使用<application>sysctl</>随时改变除了<varname>SHMMNI</>之外的所有参数。但是最好还是通过<filename>/etc/sysctl.conf</>来设置你喜欢的值，这样重启之后这些值还能被保持。
       </para>

       <para>
        只有在 OS X 10.3.9 及以后的版本中才遵循<filename>/etc/sysctl.conf</>文件。如果你正在使用 10.3.x 之前的发布，你必须编辑文件<filename>/etc/rc</>并且在下列命令中改变值：
<programlisting>
sysctl -w kern.sysv.shmmax
sysctl -w kern.sysv.shmmin
sysctl -w kern.sysv.shmmni
sysctl -w kern.sysv.shmseg
sysctl -w kern.sysv.shmall
</programlisting>
        注意<filename>/etc/rc</>通常会被 OS X 的系统更新所覆盖，因此你应该在每次更新之后重做这些编辑。
       </para>

       <para>
        在 OS X 10.2 及更早的版本中，应该在文件<filename>/System/Library/StartupItems/SystemTuning/SystemTuning</>中编辑这些命令。
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">SCO OpenServer</>
      <indexterm><primary>SCO OpenServer</><secondary>IPC 配置</></>
      </term>
      <listitem>
       <para>
        在默认的配置中，只允许每个段有 512kB 的共享内存。要增加这个设置，首先更改到目录<filename>/etc/conf/cf.d</>。要显示<varname>SHMMAX</>的当前值，运行：
<programlisting>
./configure -y SHMMAX
</programlisting>
        要为<varname>SHMMAX</>设置一个新值，运行：
<programlisting>
./configure SHMMAX=<replaceable>value</>
</programlisting>
        这里<replaceable>value</>是你要使用的新值（以字节计）。在设置<varname>SHMMAX</>之后，重新编译内核：
<programlisting>
./link_unix
</programlisting>
        并且重启。
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">Solaris</> 2.6 至 2.9 (Solaris
      6 至 Solaris 9)
      <indexterm><primary>Solaris</><secondary>IPC 配置</></>
      </term>
      <listitem>
       <para>
        相似的设置可以在<filename>/etc/system</>中更改，例如：
<programlisting>
set shmsys:shminfo_shmmax=0x2000000
set shmsys:shminfo_shmmin=1
set shmsys:shminfo_shmmni=256
set shmsys:shminfo_shmseg=256

set semsys:seminfo_semmap=256
set semsys:seminfo_semmni=512
set semsys:seminfo_semmns=512
set semsys:seminfo_semmsl=32
</programlisting>
        你需要重启来让更改生效。关于更老版本的 Solaris 下的共享内存的信息请见<ulink url="http://sunsite.uakom.sk/sunworldonline/swol-09-1997/swol-09-insidesolaris.html"></ulink>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><systemitem class="osname">Solaris</> 2.10 (Solaris
      10) 及以后</term>
      <term><systemitem class="osname">OpenSolaris</></term>
      <listitem>
       <para>
        在 Solaris 10 及以后的版本以及 OpenSolaris 中，默认的共享内存和信号量设置已经足以应付大部分<productname>PostgreSQL</>应用。Solaris 现在将<varname>SHMMAX</>的默认值设置为系统 <acronym>RAM</>的四分之一。要进一步调整这个设置，使用与<literal>postgres</>用户有关的一个项目设置。例如，以<literal>root</>运行下列命令：
<programlisting>
projadd -c "PostgreSQL DB User" -K "project.max-shm-memory=(privileged,8GB,deny)" -U postgres -G postgres user.postgres
</programlisting>
       </para>

       <para>
        这个命令增加<literal>user.postgres</>项目并且将用于<literal>postgres</>用户的最大共享内存设置为 8GB，并且在下次用户登录进来时或重启<productname>PostgreSQL</>（不是重新载入）时生效。上述假定<productname>PostgreSQL</>是由<literal>postgres</>组中的<literal>postgres</>用户所运行。不需要重新启动服务器。
       </para>

       <para>
        对于将有巨大数量连接的数据库服务器，我们推荐的其他内核设置修改是：
<programlisting>
project.max-shm-ids=(priv,32768,deny)
project.max-sem-ids=(priv,4096,deny)
project.max-msg-ids=(priv,4096,deny)
</programlisting>
       </para>

       <para>
        此外，如果你正在在一个区中运行<productname>PostgreSQL</>，你可能也需要提升该区的资源使用限制。更多关于<literal>projects</> 和<command>prctl</>的信息请见<citetitle>System Administrator's Guide</>中的 "Chapter2:  Projects and Tasks"。
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">UnixWare</>
      <indexterm><primary>UnixWare</><secondary>IPC 配置</></>
      </term>
      <listitem>
       <para>
        在<productname>UnixWare</> 7 上，默认配置中共享内存段的最大尺寸是 512 kB。要显示<varname>SHMMAX</>的当前值，运行：
<programlisting>
/etc/conf/bin/idtune -g SHMMAX
</programlisting>
        这将显示当前值、默认值、最小值和最大值。要为<varname>SHMMAX</>设置一个新值，运行：
<programlisting>
/etc/conf/bin/idtune SHMMAX <replaceable>value</>
</programlisting>
        这里<replaceable>value</>是你想要使用的新值（以字节计）。在设置<varname>SHMMAX</>之后，重新编译内核：
<programlisting>
/etc/conf/bin/idbuild -B
</programlisting>
        并且重启。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>

  </sect2>

  <sect2>
   <title>资源限制</title>

   <para>
    Unix类操作系统强制了许多种资源限制，这些限制可能干扰你的<productname>PostgreSQL</productname>服务器的操作。尤其重要的是对每个用户的进程数目的限制、每个进程打开文件数目的限制以及每个进程可用的内存的限制。这些限制中每个都有一个<quote>硬</quote>限制和一个<quote>软</quote>限制。实际使用的是软限制，但用户可以自己修改成最大为硬限制的数目。而硬限制只能由root用户修改。系统调用<function>setrlimit</function>负责设置这些参数。 shell的内建命令<command>ulimit</command>（Bourne shells）或<command>limit</command>（<application>csh</>）被用来从命令行控制资源限制。 在 BSD 衍生的系统上，<filename>/etc/login.conf</filename>文件控制在登录期间设置的各种资源限制。详见操作系统文档。相关的参数是<varname>maxproc</varname>、<varname>openfiles</varname>和<varname>datasize</varname>。例如：
<programlisting>
default:\
...
        :datasize-cur=256M:\
        :maxproc-cur=256:\
        :openfiles-cur=256:\
...
</programlisting>
    （<literal>-cur</literal>是软限制。增加<literal>-max</literal>可设置硬限制）。
   </para>

   <para>
    内核也可以在某些资源上有系统范围的限制。
    <itemizedlist>
     <listitem>
      <para>
      在<productname>Linux</productname>上，<filename>/proc/sys/fs/file-max</filename>决定内核可以支持打开的最大文件数。你可以通过往该文件写入一个不同的数值修改此值， 或者通过在<filename>/etc/sysctl.conf</filename>中增加一个赋值来修改。 每个进程的最大打开文件数限制是在编译内核的时候固定的；更多信息请见<filename>/usr/src/linux/Documentation/proc.txt</filename>。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    <productname>PostgreSQL</productname>服务器为每个连接都使用一个进程， 所以你应该至少和允许的连接同样多的进程，再加上系统其它部分所需要的进程数目。 通常这个并不是什么问题，但如果你在一台机器上运行多个服务器，资源使用可能就会紧张。
   </para>

   <para>
    打开文件的出厂默认限制通常设置为<quote>socially friendly</quote>的值， 它允许许多用户在一台机器上共存，而不会导致不成比例的系统资源使用。 如果你在一台机器上运行许多服务器，这也许就是你想要的，但是在专门的服务器上， 你可能需要提高这个限制。
   </para>

   <para>
    在另一方面，一些系统允许独立的进程打开非常多的文件；如果不止几个进程这么干，那系统范围的限制就很容易被超过。如果你发现这样的现像， 并且不想修改系统范围的限制，你就可以设置<productname>PostgreSQL</>的 <xref linkend="guc-max-files-per-process">配置参数来限制打开文件数的消耗。
   </para>
  </sect2>

  <sect2 id="linux-memory-overcommit">
   <title>Linux 内存过量使用</title>

   <para>
    在 Linux 2.4 及其后的版本中，默认的虚拟内存行为对<productname>PostgreSQL</productname>不是最优的。由于内核实现内存过量使用的方法，如果<productname>PostgreSQL</productname>或其它进程的内存要求导致系统用光虚拟内存，那么内核可能会终止<productname>PostgreSQL</productname>的 postmaster 进程（主服务器进程）。
   </para>

   <para>
    如果发生了这样的事情，你会看到像下面这样的内核消息（参考你的系统文档和配置，看看在哪里能看到这样的消息）：
<programlisting>
Out of Memory: Killed process 12345 (postgres).
</programlisting>
    这表明<filename>postgres</filename>进程因为内存压力而被终止了。尽管现有的数据库连接将继续正常运转，但是新的连接将无法被接受。要想恢复，<productname>PostgreSQL</productname>应该被重启。
   </para>

   <para>
    一种避免这个问题的方法是在一台你确信其它进程不会耗尽内存的机器上运行<productname>PostgreSQL</productname>。 如果内存资源紧张，增加操作系统的交换空间可以帮助避免这个问题，因为内存不足（OOM）杀手（即终止进程这种行为）只有当物理内存和交换空间都被用尽时才会被调用。
   </para>

   <para>
    如果<productname>PostgreSQL</productname>本身是导致系统内存耗尽的原因，你可以通过改变你的配置来避免该问题。在某些情况中，降低内存相关的配置参数可能有所帮助，特别是<link linkend="guc-shared-buffers"><varname>shared_buffers</></link>
和<link linkend="guc-work-mem"><varname>work_mem</></link>两个参数。在其他情况中，允许太多连接到数据库服务器本身也可能导致该问题。在很多情况下，最好减小<link linkend="guc-max-connections"><varname>max_connections</></link>并且转而利用外部连接池软件。
   </para>

   <para>
    在 Linux 2.6 及其后的版本中，可以修改内核的行为，这样它将不会<quote>过量使用</>内存。尽管此设置不会阻止<ulink url="http://lwn.net/Articles/104179/">OOM 杀手</>被调用，但它可以显著地降低其可能性并且将因此得到更鲁棒的系统行为。这可以通过用<command>sysctl</command>选择严格的过量使用模式来实现：
<programlisting>
sysctl -w vm.overcommit_memory=2
</programlisting>
    或者在<filename>/etc/sysctl.conf</>中放置一个等效的项。你可能还希望修改相关的设置<varname>vm.overcommit_ratio</>。 详细信息请参阅内核文档的<filename>Documentation/vm/overcommit-accounting</>文件。
   </para>

   <para>
    另一种方法，可以在改变或不改变<varname>vm.overcommit_memory</>的情况下使用。它将 postmaster 进程的进程相关的<varname>oom_score_adj</>值设置为<literal>-1000</>，从而保证它不会成为 OOM 杀手的目标。 这样做最简单的方法是在 postmaster 的启动脚本中执行
<programlisting>
echo -1000 > /proc/self/oom_score_adj
</programlisting>
    并且要在调用 postmaster 之前执行。请注意这个动作必须以 root 完成，否则它将不会产生效果。所以一个被 root 拥有的启动脚本是放置这个动作最容易的地方。如果这样做，你可能还要将<literal>-DLINUX_OOM_SCORE_ADJ=0</>添加到<varname>CPPFLAGS</>中来编译<productname>PostgreSQL</>。 这样将导致 postmaster 子进程以正常的<varname>oom_score_adj</>值（为 0）运行，所以 OOM 杀手仍然可以在需要的时候以它们作为目标。
   </para>

   <para>
    更老的 Linux 内核不提供<filename>/proc/self/oom_score_adj</>，但是可能有一个具有相同功能的早期版本，它被称为<filename>/proc/self/oom_adj</>。这种方式工作起来完全相同，除了禁用值是<literal>-17</>而不是<literal>-1000</>。对应的<productname>PostgreSQL</>的编译标志是<literal>-DLINUX_OOM_ADJ=0</>。
   </para>

   <note>
   <para>
    有些厂商的 Linux 2.4 内核被报告有着 2.6 过量使用<command>sysctl</command>参数的早期版本。不过，在没有相关代码的 2.4 内核里设置<literal>vm.overcommit_memory</>为 2 将会让事情更糟。我们推荐你检查一下实际的内核源代码（见文件<filename>mm/mmap.c</>中的<function>vm_enough_memory</>函数），验证一下这个是在你的内核中是被支持的， 然后再在 2.4 安装中使用它。文档文件<filename>overcommit-accounting</>的存在<emphasis>不</>能当作是这个特性存在的证明。如果有疑问，请咨询一位内核专家或你的内核厂商。
   </para>
   </note>
  </sect2>
  
  <sect2 id="linux-huge-pages">
   <title>Linux 大页面</title>

   <para>
    在<productname>PostgreSQL</productname>使用大量
    连续内存块时利用大页面来降低开销。要在
    <productname>PostgreSQL</productname>中启用这个
    特性，你需要一个
    <varname>CONFIG_HUGETLBFS=y</varname>并且
    <varname>CONFIG_HUGETLB_PAGE=y</varname>的内核。
    你也还必须调节系统设置
    <varname>vm.nr_hugepages</varname>。要估计所需的
    大页面的数量，关闭大页面启动
    <productname>PostgreSQL</productname>并且从 proc
    文件系统检查<varname>VmPeak</varname>值：
<programlisting>
$ <userinput>head -1 /path/to/data/directory/postmaster.pid</userinput>
4170
$ <userinput>grep ^VmPeak /proc/4170/status</userinput>
VmPeak:  6490428 kB
</programlisting>
     <literal>6490428</literal> / <literal>2048</literal>
     （在这种情况下<varname>PAGE_SIZE</varname>是
     <literal>2MB</literal>）大约是
     <literal>3169.154</literal>个大页面，因此你将需要至少
     <literal>3170</literal>个大页面：
<programlisting>
$ <userinput>sysctl -w vm.nr_hugepages=3170</userinput>
</programlisting>
    有时候内核会无法分配想要的数量的大页面，所以可能有必要
    重复该命令或者重新启动。不要忘了向
    <filename>/etc/sysctl.conf</filename>中增加一个项来让这
    个设置重启后也能保持。
   </para>

   <para>
    <productname>PostgreSQL</productname>中大页面的默认行为是
    尽可能使用它们并且在失败时转回到正常页面。要强制使用大页面，你可
    以把<link linkend="guc-huge-pages">
    <varname>huge_pages</varname></link>设置成
    <literal>on</literal>。注意在这种情况下如果没有足够的大页面可用，
    <productname>PostgreSQL</productname>将会启动失败。
   </para>

   <para>
    <productname>Linux</productname>大页面特性的详细描述可见<ulink url="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt">https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt</ulink>.
   </para>

  </sect2>
 </sect1>


 <sect1 id="server-shutdown">
  <title>关闭服务器</title>

  <indexterm zone="server-shutdown">
   <primary>关闭</>
  </indexterm>

  <para>
   有几种关闭数据库服务器的方法。通过给<command>postgres</command>进程发送不同的信号，你就可以控制关闭类型。

   <variablelist>
    <varlistentry>
     <term><systemitem>SIGTERM</systemitem><indexterm><primary>SIGTERM</></></term>
     <listitem>
      <para>
       这是<firstterm>智能关闭</firstterm>模式。在接收<systemitem>SIGTERM</systemitem>后， 服务器将不允许新连接，但是会让现有的会话正常结束它们的工作。仅当所有的会话终止后它才关闭。 如果服务器处在线备份模式，它将等待直到在线备份模式不再被激活。当在线备份模式被激活时， 仍然允许新的连接，但是只能是超级用户的连接（这一例外允许超级用户连接来终止在线备份模式）。 如果服务器在恢复时请求智能关闭，恢复和流复制只有在所有正常会话都终止后才停止。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><systemitem>SIGINT</systemitem><indexterm><primary>SIGINT</></></term>
     <listitem>
      <para>
       这是<firstterm>快速关闭</firstterm>模式。服务器不再允许新的连接，并向所有现有服务器进程发送<systemitem>SIGTERM</systemitem>，让它们中断当前事务并立刻退出。然后服务器等待所有服务器进程退出并最终关闭。 如果服务处于在线备份模式，备份模式将被终止并致使备份无用。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><systemitem>SIGQUIT</systemitem><indexterm><primary>SIGQUIT</></></term>
     <listitem>
      <para>
      这是<firstterm>立即关闭</firstterm>模式。服务器将给所有子进程发送
      <systemitem>SIGQUIT</systemitem>并且等待它们终止。那些没有在
      5 秒内终止的子进程将被主<command>postgres</command>进程发送
      <systemitem>SIGKILL</systemitem>，这样那些进程会终止而不做进一
      步等待。这将导致在下一次启动时（通过重放 WAL 日志）恢复。只在紧急
      时才推荐这种方式。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   <xref linkend="app-pg-ctl">程序提供了一个发送这些信号关闭服务器的方便的接口。 另外，你在非 Windows 系统上可以用<command>kill</>直接发送这些信号。可以用<command>ps</command>程序或者从数据目录的<filename>postmaster.pid</filename>文件中找到<command>postgres</command>进程的<acronym>PID</>。例如，要做一次快速关闭：
<screen>
$ <userinput>kill -INT `head -1 /usr/local/pgsql/data/postmaster.pid`</userinput>
</screen>
  </para>

  <important>
   <para>
    最好不要使用<systemitem>SIGKILL</systemitem>关闭服务器。 这样做将会阻止服务器释放共享内存和信号量，那么在开始一个新的服务器之前，可能需要手动完成这些释放。 此外，使用<systemitem>SIGKILL</systemitem>杀掉<command>postgres</command>进程时，<command>postgres</command>不会有机会将信号传播到它的子进程，所以也必须手工杀掉单个的子进程。
   </para>
  </important>

  <para>
   要终止单个会话同时允许其他会话继续，使用<function>pg_terminate_backend()</>（参阅<xref linkend="functions-admin-signal-table">） 或发送<systemitem>SIGTERM</>信号到该会话相关的子进程。
  </para>
 </sect1>

 <sect1 id="upgrading">
  <title>升级一个<productname>PostgreSQL</>集簇</title>

  <indexterm zone="upgrading">
   <primary>upgrading</primary>
  </indexterm>

  <indexterm zone="upgrading">
   <primary>version</primary>
   <secondary>compatibility</secondary>
  </indexterm>

  <para>
   本节讨论如何把你的数据库数据从一个<productname>PostgreSQL</>发行升级到一个更新的发行。
  </para>

  <para>
   <productname>PostgreSQL</>主版本用版本号的前两个数字组表示，例如 8.4。<productname>PostgreSQL</>次要版本则由第三组版本数字表示，例如 8.4.2 是 8.4 的第二个次要发行。次要发行从来不改变内部存储格式并且总是向前并向后兼容同一主版本号中的次要发行，例如 8.4.2 与 8.4、8.4.1、8.4.6 兼容。要在兼容的版本间升级，你只需要简单地在服务器关闭时替换可执行文件并重启服务器。数据目录则保持不变 &mdash; 次要升级就这么简单。
  </para>

  <para>
   对于<productname>PostgreSQL</>的<emphasis>主</>发行， 
   内部数据存储格式常被改变，这使升级复杂化。传统的把数据移动到
   新主版本的方法是先转储然后重新载入到数据库，不过这可能会很慢。
   一种更快的方式是<xref linkend="pgupgrade">。如下文所讨论的，
   复制方法也能被用于升级。
  </para>

  <para>
   新的主版本也通常会引入一些用户可见的不兼容性，因此可能需要应用程序编程上的改变。所有用户可见的更改都被列在发行注记（<xref linkend="release">）中，请特别注意标有 "Migration" 的小节。如果你正在跨越几个主版本升级，一定要阅读每个中间版本的发行注记。
  </para>

  <para>
   小心的用户在完全切换过去之前将希望在新版本上测试他们的客户端应用。因此，建立一个新旧版本的并存安装通常是一个好主意。在测试一个<productname>PostgreSQL</>主要升级时，考虑下列可能的改变类别：
  </para>

  <variablelist>

   <varlistentry>
    <term>管理</term>
    <listitem>
     <para>
      用于管理员监控和控制服务器的功能在每一个主发行中经常会改变和增加。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>SQL</term>
    <listitem>
     <para>
      通常这包括新的 SQL 命令功能并且在行为上没有更改，除非在发行注记中有特别提到。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>库 API</term>
    <listitem>
     <para>
      通常<application>libpq</>等库值增加新功能，除非在发行注记中有特别提到。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>系统目录</term>
    <listitem>
     <para>
      系统目录改变通常只影响数据库管理工具。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>服务器 C-语言 API</term>
    <listitem>
     <para>
      这涉及到后端函数 API 中的改变，它使用 C 编程语言编写。这些改变影响引用服务器内部后端函数的代码。
     </para>
    </listitem>
   </varlistentry>

  </variablelist>

  <sect2 id="upgrading-via-pgdumpall">
   <title>通过<application>pg_dumpall</>升级数据</title>

   <para>
    一种升级方法是从<productname>PostgreSQL</>的一个主版本转储数据并将它重新载入到另一个主版本中 &mdash; 要这样做，你必须使用<application>pg_dumpall</>这样的<emphasis>逻辑</>备份工具，文件系统级别的备份方法将不会有用（这也阻止你在一个不兼容版本的<productname>PostgreSQL</>中使用一个数据目录，因此在一个数据目录上尝试启动一个错误的服务器版本不会造成很大的危害）。
   </para>

   <para>
    我们推荐你从<emphasis>较新</>版本的<productname>PostgreSQL</>中使用<application>pg_dump</>和<application>pg_dumpall</>程序，这样可以利用在这些程序中可能存在的改进。当前发行的转储程序可以读取任何 7.0 以上版本服务器中的数据。
   </para>

   <para>
    这些指令假定你现有的安装位于<filename>/usr/local/pgsql</>目录，并且数据区域在<filename>/usr/local/pgsql/data</>。请用你的路径进行适当的替换。
   </para>

   <procedure>
    <step>
     <para>
      如果在创建一个备份，确认你的数据库没有在被更新。这不会影响备份的完整性，但是那些更改当然不会被包括在备份中。如果必要，编辑<filename>/usr/local/pgsql/data/pg_hba.conf</>文件中的权限（或等效的方法）来不允许除你之外的任何人使用数据库。关于访问控制的额外信息请见<xref linkend="client-authentication">。
     </para>

     <para>
      <indexterm>
       <primary>pg_dumpall</primary>
       <secondary>use during upgrade</secondary>
      </indexterm>

      要备份你的数据库安装，键入：
<screen>
<userinput>pg_dumpall &gt; <replaceable>outputfile</></userinput>
</screen>
     </para>

     <para>
      要制作备份，你可以使用你正在运行版本的<application>pg_dumpall</application>命令，详见<xref linkend="backup-dump-all">。但是，要得到最好的结果，试试使用<productname>PostgreSQL</productname> &version; 的<application>pg_dumpall</application>命令，因为这个版本包含了对旧版本的缺陷修复和改进。虽然这个建议可能看起来很奇怪，因为你还没有安装新版本，但如果你计划平行地安装新版本，遵循这个建议是很明智的。在这种情况下，你可以正常完成安装并且稍后再来传输数据。这也将减少停机时间。
     </para>
    </step>

    <step>
     <para>
      关闭就服务器：
<screen>
<userinput>pg_ctl stop</>
</screen>
      在那些自动启动<productname>PostgreSQL</>的系统上，可能有一个启动文件将完成同样的事情。例如，在一个<systemitem class="osname">Red Hat Linux</>系统中，我们会发现这也能用：
<screen>
<userinput>/etc/rc.d/init.d/postgresql stop</userinput>
</screen>
      关于启动和停止服务器的细节请见<xref linkend="runtime">。
     </para>
    </step>

    <step>
     <para>
      如果从备份恢复，重命名或删除旧的安装目录（如果它不是针对特定版本的）。重命名该目录是一个好主意，而不是删除它，因为如果你碰到问题并需要返回到它，它还存在。记住该目录可能消耗可观的磁盘空间。要重命名该目录，使用类似的命令：
<screen>
<userinput>mv /usr/local/pgsql /usr/local/pgsql.old</>
</screen>
     （注意将该目录作为一个单一单元移动，这样相对路径可以保持不变）。
     </para>
    </step>

    <step>
     <para>
      安装新版本的<productname>PostgreSQL</productname>在<![%standalone-include[下一节中介绍。]]>
      <![%standalone-ignore[<xref linkend="install-procedure">.]]>
     </para>
    </step>

    <step>
     <para>
      如果需要，创建一个新的数据库集簇。记住你必须在登录到一个特殊的数据库用户账户（如果你在升级，你就已经有了这个账户）时执行这些命令。
<programlisting>
<userinput>/usr/local/pgsql/bin/initdb -D /usr/local/pgsql/data</>
</programlisting>
     </para>
    </step>

    <step>
     <para>
      恢复你之前的<filename>pg_hba.conf</>以及任何<filename>postgresql.conf</>修改。
     </para>
    </step>

    <step>
     <para>
      启动数据库服务器，也要使用特殊的数据库用户账户：
<programlisting>
<userinput>/usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data</>
</programlisting>
     </para>
    </step>

    <step>
     <para>
      最后，使用<emphasis>新的</> <application>psql</>从备份恢复你的数据：
<screen>
<userinput>/usr/local/pgsql/bin/psql -d postgres -f <replaceable>outputfile</></userinput>
</screen>
     </para>
    </step>
   </procedure>

   <para>
    通过在一个不同的目录中安装新的服务器并且并行地在不同的端口运行新旧两个服务器可以达到最低的停机时间。那么你可以这样用：

<programlisting>
pg_dumpall -p 5432 | psql -d postgres -p 5433
</programlisting>
    来转移你的数据。
   </para>

  </sect2>

  <sect2 id="upgrading-via-pg-upgrade">
   <title>通过<application>pg_upgrade</>升级数据</title>

   <para>
    <xref linkend="pgupgrade">模块允许一个安装从一个
    <productname>PostgreSQL</>主版本“就地”升级成另一个主版本。
    升级可以在数分钟内被执行，特别是使用<option>--link</>模式时。它
    要求和上面的<application>pg_dumpall</>相似的步骤，例如启动/停止
    服务器、运行<application>initdb</>。<application>pg_upgrade</>
    <link linkend="pgupgrade">文档</>概述了所需的步骤。
   </para>

  </sect2>

  <sect2 id="upgrading-via-replication">
   <title>通过复制升级数据</title>

   <para>
    也可以使用某些复制方法来使用<productname>PostgreSQL</>的已更新版本创建一个后备服务器，例如<productname>Slony</>，它支持在不同主版本的<productname>PostgreSQL</>之间的复制。后备服务器可以在同一台计算机或者不同的计算机上。一旦它和主服务器（运行旧版本的<productname>PostgreSQL</>）同步好，你可以切换主机并且将后备服务器作为主机，然后关闭旧的数据库实例。这样一种切换使得一次升级的停机时间只有数秒。
   </para>

  </sect2>
 </sect1>

 <sect1 id="preventing-server-spoofing">
  <title>阻止服务器欺骗</title>

  <indexterm zone="preventing-server-spoofing">
   <primary>服务器欺骗</primary>
  </indexterm>

  <para>
   服务器在运行时，它不可能让恶意用户取代正常的数据库服务器。然而，当服务器关闭时， 一个本地用户可以通过启动它们自己的服务器来欺骗正常的服务器。行骗的服务器可以读取客户端发送的密码和查询语句， 但是不会返回任何数据，因为<varname>PGDATA</>这个目录是安全的（它有目录权限）。 欺骗是可能的，因为任何用户都可以启动一个数据库服务器；客户端无法识别一个无效的服务器，除非它被专门配置。
  </para>

  <para>
   阻止<literal>local</>的连接欺骗最简单方法是使用一个 Unix 域套接字目录 （<xref
   linkend="guc-unix-socket-directories">），该目录只对一个被信任的本地用户有写权限。 这可以防止恶意用户在该目录中创建自己的套接字文件。如果你担心有些应用程序可能仍然引用<filename>/tmp</>下的套接字文件并且因此容易受到欺骗，可在操作系统启动时创建一个符号链接<filename>/tmp/.s.PGSQL.5432</>指向一个被重定位的套接字文件。你也可能需要修改<filename>/tmp</>清除脚本防止删除这个符号链接。
  </para>

  <para>
   要在TCP连接上防止欺骗，最好的解决方案是使用 SSL 证书，并且确保客户检查服务器的证书。 要做到这点，服务器必须配置为仅接受<literal>hostssl</>连接（<xref linkend="auth-pg-hba-conf">），并且有 SSL 密钥和证书文件（<xref linkend="ssl-tcp">）。 TCP 客户端连接必须使用<literal>sslmode=verify-ca</>或<literal>verify-full</>进行连接，并且安装有适当的根证书文件<xref linkend="libq-ssl-certificates">）。
  </para>
 </sect1>

 <sect1 id="encryption-options">
  <title>加密选项</title>

  <indexterm zone="encryption-options">
   <primary>加密</primary>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname>提供了几个不同级别的加密， 并且在保护数据不会因为数据库服务器偷窃、不道德的管理员、不安全网络等因素而泄漏方面 提供很高的灵活性。加密可能也是保护一些诸如医疗记录或财务交易等敏感数据所要求的。
  </para>

  <variablelist>

  <varlistentry>
   <term>口令存储加密</term>
   <listitem>

    <para>
     默认情况下，数据库用户的口令以 MD5 哈希的方式存储， 所以管理员无法判断赋予用户的实际口令。如果 MD5 被加密用于客户端认证， 那么未加密的口令甚至都不可能临时出现在服务器上，因为客户端在透过网络发送口令之前，就先用 MD5 加密过。
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>指定列加密</term>

   <listitem>
    <para>
     <xref linkend="pgcrypto">模块允许对特定域进行加密存储。这个功能只对某些敏感数据有用。 客户端提供解密的密钥，然后数据在服务器端解密并发送给客户端。
    </para>

    <para>
     在数据被解密和在服务器与客户端之间传递时，解密数据和解密密钥将会在服务器端存在短暂的一段时间。 这就给那些能完全访问数据库服务器的人提供了一个短暂的截获密钥和数据的时间，例如系统管理员。
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>数据分区加密</term>

   <listitem>
    <para>
     存储加密可以在文件系统层面或者块层面上执行。Linux 文件系统加密
     选项包括 eCryptfs 和 EncFS，而 FreeBSD 使用 PEFS。快层面或者全
     盘加密选项包括 Linux 上的 dm-crypt + LUKS 以及 FreeBSD 上的
     GEOM 模块 geli 及 gbde。很多其他操作系统也支持这个功能，包括
     Windows。
    </para>

    <para>
     这个机制避免了在整个计算机或者驱动器被盗的情况下， 未加密的数据被从驱动器中读取。它无法防止在文件系统被挂 载时的攻击，因为在挂载之后，操作系统提供数据的解密视图。不过，要想挂载该文件系统，你需要有一些方法把加密密钥传递给操作 系统，并且有时候这个密钥就存储在挂载该磁盘的主机上的某处。
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>跨网络加密口令</term>

   <listitem>
     <para>
      <literal>MD5</>认证方法在将口令发送给服务器之前由客户端对它进行双重加密。第一次 MD5 加密是基于用户名的， 然后在建立数据库连接时，用服务器发送的随机盐粒再次加密口令。通过网络传递给服务器的就是这个双重加密的值。双重加密 不仅可以防止口令被发现，还可以防止稍后另一个连接使用同样的加密口令连接数据库。
     </para>
    </listitem>
  </varlistentry>

  <varlistentry>
   <term>跨网络加密数据</term>

    <listitem>
     <para>
      SSL 连接加密所有跨网络发送的数据：口令、查询以及返回的数据。<filename>pg_hba.conf</>文件允许管理员指定哪些主机可以使用 非加密连接（<literal>host</>），以及哪些主机需要使用 SSL 加密的连接（<literal>hostssl</>）。客户端还可以指定它们只通过 SSL 连接到服务器。我们还可以使用<application>Stunnel</>或<application>SSH</>加密传输。
     </para>
    </listitem>
  </varlistentry>

  <varlistentry>
   <term>SSL 主机认证</term>

   <listitem>
    <para>
     客户端和主机都可以提供 SSL 证书给对方。这在两边都需要一些额外的配置， 但是这种方式提供了比仅使用口令更强的身份验证。 它避免一个计算机伪装成服务器，这个时长只要足够读取客户端发送的口令就行了。它还避免了 <quote>中间人</>攻击，在其中有一台计算机处于客户端和服务器之间并伪装成服务器读取和传递两者之间的所有数据。
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term>客户端加密</term>

   <listitem>
    <para>
     如果服务器所在机器的系统管理员是不可信的，那么客户端加密数据也是必要的。在这种情况下，未加密的数据从来不会在数据库服务器上出现。数据在发送给服务器之前加密，而数据库结果在能使用之前必须在客户端上解密。
    </para>
   </listitem>
  </varlistentry>

  </variablelist>

 </sect1>

 <sect1 id="ssl-tcp">
  <title>用 SSL 进行安全的 TCP/IP 连接</title>

  <indexterm zone="ssl-tcp">
   <primary>SSL</primary>
  </indexterm>

  <para>
   <productname>PostgreSQL</>有一个对使用<acronym>SSL</>连接加密客户端/服务器通讯的本地支持，它可以增加安全性。这个特性要求在客户端和服务器端都安装<productname>OpenSSL</productname>并且在编译<productname>PostgreSQL</>的时候打开这个支持（见<xref linkend="installation">）。
  </para>

  <para>
   当<acronym>SSL</>支持被编译在<productname>PostgreSQL</>中时，可以通过将<filename>postgresql.conf</>中的 <xref linkend="guc-ssl">设置为<literal>on</>让<productname>PostgreSQL</>服务器带着<acronym>SSL</>支持被启动。 服务器在同一个 TCP 端口监听普通连接和<acronym>SSL</>连接，并且将与任何正在连接的客户端协商是否使用<acronym>SSL</>。默认情况下，这是客户端的选项，关于如何设置服务器来要求某些或者所有连接使用<acronym>SSL</>请见<xref linkend="auth-pg-hba-conf">。
  </para>

  <para>
   <productname>PostgreSQL</productname>读取系统范围的<productname>OpenSSL</productname>配置文件。默认情况下，这个文件名为<filename>openssl.cnf</filename>并且被放置在<literal>openssl version -d</>所报告的目录中。通过设置环境变量<envar>OPENSSL_CONF</envar>指定你想要的配置文件名可以覆盖此默认配置。
  </para>

  <para>
   <productname>OpenSSL</productname>支持范围广泛的密码和认证算法。而在<productname>OpenSSL</productname>配置文件可以指定一个密码列表， 你可以通过在<filename>postgresql.conf</>中修改<xref linkend="guc-ssl-ciphers">来指定数据库服务器使用的专用密码。
  </para>

  <note>
   <para>
    使用<literal>NULL-SHA</>或<literal>NULL-MD5</>可以得到身份验证但没有加密开销。不过，中间人能够读取和传递客户端和服务器之间的通信。此外，加密开销相比身份认证的开销是最小的。出于这些原因，我们建议不要使用 NULL 密码。
   </para>
  </note>

  <para>
   要<acronym>SSL</>模式中启动服务器，包含服务器证书和私钥的文件必须存在。默认情况下，这些文件应该分别被命名为<filename>server.crt</>和<filename>server.key</>并且被放在服务器的数据目录中，但是可以通过配置参数<xref linkend="guc-ssl-cert-file">和<xref linkend="guc-ssl-key-file">指定其他名称和位置。在 Unix 系统上，<filename>server.key</filename>上的权限必须不允许所有人或组的任何访问，通过命令<command>chmod 0600 server.key</command>可以做到。如果私钥被一个密码保护着，服务器将提示要求这个密码，并且在它被输入前不会启动。
  </para>

  <para>
   在有些情况下，服务器证书可能由一个<quote>中间</>
   证书颁发机构签名，而不是直接由客户端信任的证书颁发
   机构直接签名。要使用这样的证书，请追加该签发权的证书到<filename>server.crt</>文件，然后追加其父签发权的证书，以此类推一直到一个被客户端所信任的<quote>根</>或<quote>中间</>颁发机构，即由一个位于客户端<filename>root.crt</filename>文件中的证书签发。
  </para>

  <sect2 id="ssl-client-certificates">
   <title>使用客户端证书</title>

   <para>
   要求客户端提供受信任的证书，把你信任的证书颁发机构
   （<acronym>CA</acronym>）的证书放置在数据目录的
   文件<filename>root.crt</filename>中。并且修改
   <filename>postgresql.conf</filename>中的参数
   <xref linkend="guc-ssl-ca-file">为
   <literal>root.crt</literal>，还要设置
   <filename>pg_hba.conf</>文件中合适的
   <literal>hostssl</>行上的<literal>clientcert</literal>
   参数为 1。然后将在 SSL 连接启动时从客户端请求该证书
   （一段对于如何在客户端设置证书的描述请见
   <xref linkend="libpq-ssl">）。服务器将验
   证客户端的证书是由受信任的证书颁发机构之一签名。
   如果中间<acronym>CA</>出现在
   <filename>root.crt</filename>中，该文件必须也包含
   到它们的根<acronym>CA</>的证书链。如果参数
   <xref linkend="guc-ssl-crl-file">被设置，证书撤销列表
   （CRL）项也要被检查（显示 SSL 证书用法的图标见<ulink
   url="http://h71000.www7.hp.com/DOC/83final/BA554_90007/ch04s02.html"></>）。
  </para>

  <para>
   <filename>pg_hba.conf</>文件中<literal>clientcert</literal>选项适用于所有的认证方法，但仅适用<literal>hostssl</>指定的行。 当<literal>clientcert</literal>没有指定或设置为 0时，如果配置了 CA 列表，服务器将仍然会根据其 CAL 列表验证客户端证书 &mdash; 但是它将不会坚持要求出示一个客户端证书。
  </para>

  <para>
   请注意服务器的<filename>root.crt</filename>列出了顶级的 CA，它们对客户端证书的签名被认为是可信的。 原则上不需要列出签名服务器证书的 CA，然而在大多数情况下，这些 CA 对于客户端证书也是可信的。
  </para>

  <para>
   如果你在设置客户端证书，你可能希望用<literal>cert</>认证方法，这样证书控制用户认证以及提供连接安全。详见<xref linkend="auth-cert">。
  </para>
  </sect2>

  <sect2 id="ssl-server-files">
   <title>SSL 服务器文件用法</title>

   <para>
    <xref linkend="ssl-file-usage">总结了与服务器上 SSL 配置有关的文件（显示的文件名是默认的或者是经典名称。本地配置的名称可能会不同）。
   </para>

  <table id="ssl-file-usage">
   <title>SSL 服务器文件用法</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>文件</entry>
      <entry>内容</entry>
      <entry>效果</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry><xref linkend="guc-ssl-cert-file"> (<filename>$PGDATA/server.crt</>)</entry>
      <entry>服务器证书</entry>
      <entry>发送给客户端来说明服务器的身份</entry>
     </row>

     <row>
      <entry><xref linkend="guc-ssl-key-file"> (<filename>$PGDATA/server.key</>)</entry>
      <entry>服务器私钥</entry>
      <entry>证明服务器证书是其所有者发送的，并不说明证书所有者是值得信任的</entry>
     </row>

     <row>
      <entry><xref linkend="guc-ssl-ca-file"> (<filename>$PGDATA/root.crt</>)</entry>
      <entry>可信的证书颁发机构</entry>
      <entry>检查客户端证书是由一个可信的证书颁发机构签名的</entry>
     </row>

     <row>
      <entry><xref linkend="guc-ssl-crl-file"> (<filename>$PGDATA/root.crl</>)</entry>
      <entry>被证书授权机构撤销的证书</entry>
      <entry>客户端证书不能出现在这个列表上</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

   <para>
    文件<filename>server.key</>、<filename>server.crt</>、<filename>root.crt</filename>和<filename>root.crl</filename>（或者被配置的其他名字）只在服务器启动期间被检查，所以要使对它们的修改生效，你必须重启服务器。
   </para>
  </sect2>

  <sect2 id="ssl-certificate-creation">
   <title>创建自签名的证书</title>

   <para>
    要为服务器创建一个快速的自签名的证书，可以使用下面的<productname>OpenSSL</productname>命令：
<programlisting>
openssl req -new -text -out server.req
</programlisting>
    填充那些<application>openssl</>要求的信息。确保把本地主机名当做<quote>Common Name</>输入；挑战密码可以留空。 该程序将生成一个用口令保护的密钥，它不会接受小于四字符的口令。要移去密钥（如果你想自动启动服务器就必须这样），运行下面的命令：
<programlisting>
openssl rsa -in privkey.pem -out server.key
rm privkey.pem
</programlisting>
    输入旧口令解锁现有密钥。然后：
<programlisting>
openssl req -x509 -in server.req -text -key server.key -out server.crt
</programlisting>
    将一个证书变成自签名的证书并复制密钥和证书到服务器将要查找它们的地方。最后执行：
<programlisting>
chmod og-rwx server.key
</programlisting>
    如果文件的权限比这个更自由，服务器将拒绝该文件。要了解更多关于如何创建你的服务器私钥和证书的细节， 请参考<productname>OpenSSL</>文档。
   </para>

   <para>
    自签名的证书可以被用于测试，但由证书颁发机构（<acronym>CA</>）（要么是全局<acronym>CA</>中的一个或者一个本地 <acronym>CA</>）签名的证书应该被用在生产中，这样客户端可以验证服务器的身份。如果对于组织来说所有的客户端都是本地的，建议使用本地<acronym>CA</>。
   </para>

  </sect2>

 </sect1>

 <sect1 id="ssh-tunnels">
  <title>使用<application>SSH</application>隧道的安全 TCP/IP 连接</title>

  <indexterm zone="ssh-tunnels">
   <primary>ssh</primary>
  </indexterm>

  <para>
   可以使用<application>SSH</application>来加密客户端和<productname>PostgreSQL</productname>服务器之间的网络连接。如果处理得当，这将提供一个足够安全的网络连接，即使是对那些无 SSL 能力的客户端。
  </para>

  <para>
   首先确认在<productname>PostgreSQL</productname>服务器的同一台机器上正确运行着一个<application>SSH</application>服务器，并且你可以使用<command>ssh</command>作为某个用户登入。然后你可以从客户端机器采用下面这种形式的命令建立一个安全的隧道：
<programlisting>
ssh -L 63333:localhost:5432 joe@foo.com
</programlisting>
   <option>-L</option>参数中的第一个数（63333）是隧道在你那一端的端口号，它可以是任意未用过的端口（IANA 把端口 49152 到 65535 保留为个人使用）。第二个数（5432）是隧道的远端：你的服务器所使用的端口号。在端口号之间的名字或 IP 地址是你准备连接的数据库服务器的主机，至于你是从哪个主机登入的，在这个例子中则由<literal>foo.com</literal>表示。为了使用这个隧道连接到数据库服务器，你在本地机器上连接到端口 63333：
<programlisting>
psql -h localhost -p 63333 postgres
</programlisting>
   对于数据库服务器，在这个环境中它将把你看做是连接到<literal>localhost</literal>的主机<literal>foo.com</literal>上的真实用户<literal>joe</literal>，并且它会使用被配置用于来自这个用户和主机的连接的认证过程。注意服务器将不会认为连接是 SSL 加密的，因为事实上<application>SSH</application>服务器和<productname>PostgreSQL</productname>服务器之间没有加密。只要它们在同一台机器上，这就不会造成任何额外的安全风险。
  </para>

  <para>
   为了让隧道设置成功，你必须允许通过<command>ssh</command>作为<literal>joe@foo.com</literal>连接，就像你已经尝试使用<command>ssh</command>来创建一个终端会话。
  </para>

  <para>
   你应当也已经设定好了端口转发：
<programlisting>
ssh -L 63333:foo.com:5432 joe@foo.com
</programlisting>
   但是数据库服务器则将会看到连接从它的<literal>foo.com</literal>接口进来，它没有被默认设置<literal>listen_addresses = 'localhost'</literal>所打开。这通常不是你想要的。
  </para>

  <para>
   如果你必须通过某个登录主机<quote>跳</quote>到数据库服务器，一个可能的设置看起来像：
<programlisting>
ssh -L 63333:db.foo.com:5432 joe@shell.foo.com
</programlisting>
   注意这种从<literal>shell.foo.com</literal>到<literal>db.foo.com</literal>的连接的方法将不会被 SSH 隧道加密。当网络被限制于各种方法时，SSH 提供了相当多的配置可能性。详情请参考 SSH 的文档。
  </para>

  <tip>
   <para>
    一些其他的应用可以提供安全隧道，它们使用和刚刚描述的 SSH 概念上相似的过程。
   </para>
  </tip>

 </sect1>

 <sect1 id="event-log-registration">
  <title>在<systemitem class="osname">Windows</>上注册<application>Event Log</></title>

  <indexterm zone="event-log-registration">
   <primary>事件日志</primary>
   <secondary>事件日志</secondary>
  </indexterm>

  <para>
   要为操作系统注册一个<systemitem class="osname">Windows</> <application>事件日志</>库，发出这个命令：
<screen>
<userinput>regsvr32 <replaceable>pgsql_library_directory</>/pgevent.dll</>
</screen>
   这会创建被事件查看器使用的注册表项，默认事件源命名为<literal>PostgreSQL</literal>。
  </para>

  <para>
   要指定一个不同的事件源名称（见<xref linkend="guc-event-source">）。使用<literal>/n</literal>和<literal>/i</literal>选项：
<screen>
<userinput>regsvr32 /n /i:<replaceable>event_source_name</> <replaceable>pgsql_library_directory</>/pgevent.dll</>
</screen>
  </para>

  <para>
   要从操作系统反注册<application>事件日志</>库，发出这个命令：
<screen>
<userinput>regsvr32 /u [/i:<replaceable>event_source_name</>] <replaceable>pgsql_library_directory</>/pgevent.dll</>
</screen>
  </para>

  <note>
   <para>
    要启用数据库服务器中的事件日志，在<filename>postgresql.conf</filename>中修改<xref linkend="guc-log-destination">来包括<literal>eventlog</literal>。
   </para>
  </note>
 </sect1>

</chapter>
