<!-- doc/src/sgml/datatype.sgml -->

 <chapter id="datatype">
  <!-- 
  <title>Data Types</title> 
  -->
<title>数据类型</title>
  <indexterm zone="datatype">
   <!-- 
   <primary>data type</primary> 
   -->
   <primary>数据类型</primary>
  </indexterm>

  <indexterm>
<!-- 
   <primary>type</primary>
   <see>data type</see> 
-->
   <primary>类型</primary>
   <see>数据类型</see>
  </indexterm>

  <!--
<para>
   <productname>PostgreSQL</productname> has a rich set of native data
   types available to users.  Users can add new types to
   <productname>PostgreSQL</productname> using the <xref
   linkend="sql-createtype"> command.
  </para>
-->
<para>
<productname>PostgreSQL</productname>有着丰富的内置数据类型可用。
用户还可以使用<xref linkend="sql-createtype">命令增加新的数据类型。
</para>

  <!--
<para>
   <xref linkend="datatype-table"> shows all the built-in general-purpose data
   types. Most of the alternative names listed in the
   <quote>Aliases</quote> column are the names used internally by
   <productname>PostgreSQL</productname> for historical reasons.  In
   addition, some internally used or deprecated types are available,
   but are not listed here.
  </para>
-->
<para>
<xref linkend="datatype-table">显示了所有内置的泛用数据类型。
在<quote>别名</quote>列里列出的大多数可选名字都是因历史原因在<productname>PostgreSQL</productname>
内部使用。另外，还有一些内部使用的或者废弃的类型也是可用的，
但没有在这里列出。
</para>

   <table id="datatype-table">
    <!-- 
<title>Data Types</title> 
-->
<title>数据类型</title>
    <tgroup cols="3">
     <thead>
      <row>
       <!-- 
   <entry>Name</entry>
       <entry>Aliases</entry>
       <entry>Description</entry> 
   -->
   <entry>名字</entry>
       <entry>别名</entry>
       <entry>描述</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><type>bigint</type></entry>
       <entry><type>int8</type></entry>
       <!-- 
   <entry>signed eight-byte integer</entry> 
   -->
   <entry>有符号8字节整数</entry>
      </row>

      <row>
       <entry><type>bigserial</type></entry>
       <entry><type>serial8</type></entry>
       <!-- 
   <entry>autoincrementing eight-byte integer</entry> 
   -->
   <entry>自增8字节整数</entry>
      </row>

      <row>
       <entry><type>bit [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry></entry>
       <!-- 
   <entry>fixed-length bit string</entry> 
   -->
   <entry>定长位串</entry>
      </row>

      <row>
       <entry><type>bit varying [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry><type>varbit</type></entry>
       <!-- 
   <entry>variable-length bit string</entry>
   -->
   <entry>可变长位串</entry>
      </row>

      <row>
       <entry><type>boolean</type></entry>
       <entry><type>bool</type></entry>
       <!-- 
   <entry>logical Boolean (true/false)</entry> 
   -->
   <entry>逻辑布尔值(真/假)</entry>
      </row>

      <row>
       <entry><type>box</type></entry>
       <entry></entry>
       <!-- 
   <entry>rectangular box on a plane</entry> 
   -->
   <entry>平面上的矩形</entry>
      </row>

      <row>
       <entry><type>bytea</type></entry>
       <entry></entry>
       <!-- 
   <entry>binary data (<quote>byte array</>)</entry> 
   -->
   <entry>二进制数据(<quote>字节数组</>)</entry>
      </row>

      <row>
       <entry><type>character [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry><type>char [ (<replaceable>n</replaceable>) ]</type></entry>
       <!-- 
   <entry>fixed-length character string</entry> 
   -->
   <entry>定长字符串</entry>
      </row>      
      
      <row>
       <entry><type>character varying [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry><type>varchar [ (<replaceable>n</replaceable>) ]</type></entry>
       <!-- 
   <entry>variable-length character string</entry> 
   -->
   <entry>可变长字符串</entry>
      </row>

      <row>
       <entry><type>cidr</type></entry>
       <entry></entry>
       <!-- 
   <entry>IPv4 or IPv6 network address</entry>
   -->
   <entry>IPv4 或 IPv6 网络地址</entry>
      </row>

      <row>
       <entry><type>circle</type></entry>
       <entry></entry>
       <!-- 
   <entry>circle on a plane</entry> 
   -->
   <entry>平面上的圆</entry>
      </row>

      <row>
       <entry><type>date</type></entry>
       <entry></entry>
       <!-- 
   <entry>calendar date (year, month, day)</entry> 
   -->
   <entry>日历日期(年, 月, 日)</entry>
      </row>

      <row>
       <entry><type>double precision</type></entry>
       <entry><type>float8</type></entry>
       <!-- 
   <entry>double precision floating-point number (8 bytes)</entry> 
   -->
   <entry>双精度浮点数(8字节)</entry>
      </row>

      <row>
       <entry><type>inet</type></entry>
       <entry></entry>
       <!-- 
   <entry>IPv4 or IPv6 host address</entry> 
   -->
   <entry>IPv4 或 IPv6 主机地址</entry>
      </row>

      <row>
       <entry><type>integer</type></entry>
       <entry><type>int</type>, <type>int4</type></entry>
       <!-- 
   <entry>signed four-byte integer</entry> 
   -->
   <entry>有符号 4 字节整数</entry>
      </row>

      <row>
       <entry><type>interval [ <replaceable>fields</replaceable> ] [ (<replaceable>p</replaceable>) ]</type></entry>
       <entry></entry>
       <!-- 
   <entry>time span</entry> 
   -->
   <entry>时间间隔</entry>
      </row>

      <row>
       <entry><type>json</type></entry>
       <entry></entry>
       <!-- 
       <entry>textual JSON data</entry> 
       -->
       <entry>文本的JSON数据</entry>
      </row>

      <row>
       <entry><type>jsonb</type></entry>
       <entry></entry>
       <!-- 
       <entry>binary JSON data, decomposed</entry> 
       -->
       <entry>二进制JSON数据，已分解的</entry>
      </row>      
      
      <row>
       <entry><type>line</type></entry>
       <entry></entry>
       <!-- 
   <entry>infinite line on a plane</entry> 
   -->
   <entry>平面上的无限长直线</entry>
      </row>

      <row>
       <entry><type>lseg</type></entry>
       <entry></entry>
       <!-- 
   <entry>line segment on a plane</entry> 
   -->
   <entry>平面上的线段</entry>
      </row>

      <row>
       <entry><type>macaddr</type></entry>
       <entry></entry>
       <!-- 
   <entry>MAC (Media Access Control) address</entry> 
   -->
   <entry>MAC (Media Access Control)地址</entry>
      </row>

      <row>
       <entry><type>money</type></entry>
       <entry></entry>
       <!-- 
   <entry>currency amount</entry> 
   -->
   <entry>货币金额</entry>
      </row>

      <row>
       <entry><type>numeric [ (<replaceable>p</replaceable>,
         <replaceable>s</replaceable>) ]</type></entry>
       <entry><type>decimal [ (<replaceable>p</replaceable>,
         <replaceable>s</replaceable>) ]</type></entry>
       <!-- 
   <entry>exact numeric of selectable precision</entry> 
   -->
   <entry>可选精度的准确数值数据类型</entry>
      </row>

      <row>
       <entry><type>path</type></entry>
       <entry></entry>
       <!-- 
   <entry>geometric path on a plane</entry>
   -->
   <entry>平面上的几何路径</entry>
      </row>

      <row>
       <entry><type>pg_lsn</type></entry>
       <entry></entry>
       <!--
       <entry><productname>PostgreSQL</productname> Log Sequence Number</entry>
       -->
       <entry><productname>PostgreSQL</productname>日志序列号</entry>
      </row>      
      
      <row>
       <entry><type>point</type></entry>
       <entry></entry>
       <!-- 
   <entry>geometric point on a plane</entry> 
   -->
   <entry>平面上的点</entry>
      </row>

      <row>
       <entry><type>polygon</type></entry>
       <entry></entry>
       <!-- 
   <entry>closed geometric path on a plane</entry> 
   -->
   <entry>平面上的封闭几何路径</entry>
      </row>

      <row>
       <entry><type>real</type></entry>
       <entry><type>float4</type></entry>
       <!-- 
   <entry>single precision floating-point number (4 bytes)</entry> 
   -->
   <entry>单精度浮点数(4 字节)</entry>
      </row>

      <row>
       <entry><type>smallint</type></entry>
       <entry><type>int2</type></entry>
       <!-- 
   <entry>signed two-byte integer</entry> 
   -->
   <entry>有符号 2 字节整数</entry>
      </row>

      <row>
       <entry><type>smallserial</type></entry>
       <entry><type>serial2</type></entry>
       <!-- 
   <entry>autoincrementing two-byte integer</entry> 
   -->
   <entry>自增 2 字节整数</entry>
      </row>

      <row>
       <entry><type>serial</type></entry>
       <entry><type>serial4</type></entry>
       <!-- 
   <entry>autoincrementing four-byte integer</entry>
   -->
   <entry>自增 4 字节整数</entry>
      </row>

      <row>
       <entry><type>text</type></entry>
       <entry></entry>
       <!-- 
   <entry>variable-length character string</entry> 
   -->
   <entry>可变长字符串</entry>
      </row>

      <row>
       <entry><type>time [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
       <entry></entry>
       <!-- 
   <entry>time of day (no time zone)</entry> 
   -->
   <entry>一天中的时刻(无时区)</entry>
      </row>

      <row>
       <entry><type>time [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
       <entry><type>timetz</type></entry>
       <!-- 
   <entry>time of day, including time zone</entry> 
   -->
   <entry>一天中的时刻，含时区</entry>
      </row>

      <row>
       <entry><type>timestamp [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
       <entry></entry>
       <!-- 
   <entry>date and time (no time zone)</entry> 
   -->
   <entry>日期与时刻(无时区)</entry>
      </row>

      <row>
       <entry><type>timestamp [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
       <entry><type>timestamptz</type></entry>
       <!-- 
   <entry>date and time, including time zone</entry> 
   -->
   <entry>日期与时刻，含时区</entry>
      </row>

      <row>
       <entry><type>tsquery</type></entry>
       <entry></entry>
       <!-- 
   <entry>text search query</entry> 
   -->
   <entry>文本检索查询</entry>
      </row>

      <row>
       <entry><type>tsvector</type></entry>
       <entry></entry>
       <!-- 
   <entry>text search document</entry>
   -->
   <entry>文本检索文档</entry>
      </row>

      <row>
       <entry><type>txid_snapshot</type></entry>
       <entry></entry>
       <!-- 
   <entry>user-level transaction ID snapshot</entry> 
   -->
   <entry>用户级别的事务ID快照</entry>
      </row>

      <row>
       <entry><type>uuid</type></entry>
       <entry></entry>
       <!-- 
   <entry>universally unique identifier</entry> 
   -->
   <entry>通用唯一标识符</entry>
      </row>

      <row>
       <entry><type>xml</type></entry>
       <entry></entry>
       <!-- 
   <entry>XML data</entry> 
   -->
   <entry>XML 数据</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <note>
   <!--
<title>Compatibility</title>
-->
<title>兼容性</title>
   <!--
<para>
    The following types (or spellings thereof) are specified by
    <acronym>SQL</acronym>: <type>bigint</type>, <type>bit</type>, <type>bit
    varying</type>, <type>boolean</type>, <type>char</type>,
    <type>character varying</type>, <type>character</type>,
    <type>varchar</type>, <type>date</type>, <type>double
    precision</type>, <type>integer</type>, <type>interval</type>,
    <type>numeric</type>, <type>decimal</type>, <type>real</type>,
    <type>smallint</type>, <type>time</type> (with or without time zone),
    <type>timestamp</type> (with or without time zone),
    <type>xml</type>.
   </para>
-->
<para>
下列类型(或那样的拼写)是<acronym>SQL</acronym>规范声明的：
<type>bigint</type>, <type>bit</type>, <type>bit
    varying</type>, <type>boolean</type>, <type>char</type>,
    <type>character varying</type>, <type>character</type>,
    <type>varchar</type>, <type>date</type>, <type>double
    precision</type>, <type>integer</type>, <type>interval</type>,
    <type>numeric</type>, <type>decimal</type>, <type>real</type>,
    <type>smallint</type>, <type>time</type> (有时区或无时区),
    <type>timestamp</type> (有时区或无时区),
    <type>xml</type>。
</para>
  </note>

  <!--
<para>
   Each data type has an external representation determined by its input
   and output functions.  Many of the built-in types have
   obvious external formats.  However, several types are either unique
   to <productname>PostgreSQL</productname>, such as geometric
   paths, or have several possible formats, such as the date
   and time types.
   Some of the input and output functions are not invertible, i.e.,
   the result of an output function might lose accuracy when compared to
   the original input.
  </para>
-->
<para>
每种数据类型都有一个由其输入和输出函数决定的外部表现形式。
许多内置的类型有明显的外部格式。不过，一些数据类型要么是<productname>PostgreSQL</productname>
所特有的，比如几何路径，要么是有若干种不同的格式，比如日期和时刻类型。
有些输入和输出函数是不可逆的，也就是说，
输出函数的输出结果和原始的输入比较的时候可能丢失精度。
</para>

  <sect1 id="datatype-numeric">
   <!-- 
   <title>Numeric Types</title> 
   -->
<title>数值类型</title>
   <indexterm zone="datatype-numeric">
    <!-- 
<primary>data type</primary>
    <secondary>numeric</secondary> 
-->
<primary>数据类型</primary>
    <secondary>数值</secondary>
   </indexterm>

   <!--
<para>
    Numeric types consist of two-, four-, and eight-byte integers,
    four- and eight-byte floating-point numbers, and selectable-precision
    decimals.  <xref linkend="datatype-numeric-table"> lists the
    available types.
   </para>
-->
<para>
数值类型由 2 字节、4 字节或 8 字节的整数以及 4 字节或 8 字节的浮点数和可选精度的十进制数组成。
<xref linkend="datatype-numeric-table">列出了所有可用类型。
</para>

    <table id="datatype-numeric-table">
     <!-- 
 <title>Numeric Types</title> 
 -->
 <title>数值类型</title>
     <tgroup cols="4">
      <thead>
       <row>
        <!-- 
<entry>Name</entry>
        <entry>Storage Size</entry>
        <entry>Description</entry>
        <entry>Range</entry> 
-->
<entry>名字</entry>
        <entry>存储长度</entry>
        <entry>描述</entry>
        <entry>范围</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><type>smallint</></entry>
        <!-- 
<entry>2 bytes</entry>
        <entry>small-range integer</entry>
        <entry>-32768 to +32767</entry> 
-->
<entry>2 字节</entry>
        <entry>小范围整数</entry>
        <entry>-32768 到 +32767</entry>
       </row>
       <row>
        <entry><type>integer</></entry>
        <!-- 
<entry>4 bytes</entry>
        <entry>typical choice for integer</entry>
        <entry>-2147483648 to +2147483647</entry> 
-->
<entry>4 字节</entry>
        <entry>常用的整数</entry>
        <entry>-2147483648 到 +2147483647</entry>
       </row>
       <row>
        <entry><type>bigint</></entry>
        <!-- 
<entry>8 bytes</entry>
        <entry>large-range integer</entry>
        <entry>-9223372036854775808 to +9223372036854775807</entry> 
-->
<entry>8 字节</entry>
        <entry>大范围整数</entry>
        <entry>-9223372036854775808 到 +9223372036854775807</entry>
       </row>

       <row>
        <entry><type>decimal</></entry>
        <!-- 
<entry>variable</entry>
        <entry>user-specified precision, exact</entry>
        <entry>up to 131072 digits before the decimal point; up to 16383 digits after the decimal point</entry> 
-->
<entry>可变长</entry>
        <entry>用户指定的精度，精确</entry>
        <entry>小数点前 131072 位；小数点后 16383 位</entry>
       </row>
       <row>
        <entry><type>numeric</></entry>
        <!-- 
<entry>variable</entry>
        <entry>user-specified precision, exact</entry>
        <entry>up to 131072 digits before the decimal point; up to 16383 digits after the decimal point</entry>
-->
<entry>可变长</entry>
        <entry>用户指定的精度，精确</entry>
        <entry>小数点前 131072 位；小数点后 16383 位</entry>
       </row>

       <row>
        <entry><type>real</></entry>
        <!-- 
<entry>4 bytes</entry>
        <entry>variable-precision, inexact</entry>
        <entry>6 decimal digits precision</entry> 
-->
<entry>4 字节</entry>
        <entry>可变精度，不精确</entry>
        <entry>6 位十进制数字精度</entry>
       </row>
       <row>
        <entry><type>double precision</></entry>
<!-- 
        <entry>8 bytes</entry>
        <entry>variable-precision, inexact</entry>
        <entry>15 decimal digits precision</entry>
-->
        <entry>8 字节</entry>
        <entry>可变精度，不精确</entry>
        <entry>15 位十进制数字精度</entry>
       </row>

       <row>
        <entry><type>smallserial</type></entry>


        <entry>2 字节</entry>
<!-- 
        <entry>2 bytes</entry>
        <entry>small autoincrementing integer</entry>
        <entry>1 to 32767</entry>
-->
        <entry>2 字节</entry>
        <entry>自增的小范围整数</entry>
        <entry>1 到 32767</entry>
       </row>

       <row>
        <entry><type>serial</></entry>
<!-- 
        <entry>4 bytes</entry>
        <entry>autoincrementing integer</entry>
        <entry>1 to 2147483647</entry>
-->
        <entry>4 字节</entry>
        <entry>自增整数</entry>
        <entry>1 到 2147483647</entry>
       </row>

       <row>
        <entry><type>bigserial</type></entry>
<!-- 
        <entry>8 bytes</entry>
        <entry>large autoincrementing integer</entry>
        <entry>1 to 9223372036854775807</entry>
-->
        <entry>8 字节</entry>
        <entry>自增的大范围整数</entry>
        <entry>1 到 9223372036854775807</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <!--
<para>
    The syntax of constants for the numeric types is described in
    <xref linkend="sql-syntax-constants">.  The numeric types have a
    full set of corresponding arithmetic operators and
    functions. Refer to <xref linkend="functions"> for more
    information.  The following sections describe the types in detail.
   </para>
-->
<para>
数值类型常量的语法在<xref linkend="sql-syntax-constants">里描述。
对应数值类型有一套完整的数学操作符和函数。相关信息请参考<xref linkend="functions">。
下面的几节详细描述这些类型。
</para>

   <sect2 id="datatype-int">
    <!-- 
<title>Integer Types</title> 
-->
<title>整数类型</title>
    <indexterm zone="datatype-int">
     <!-- 
 <primary>integer</primary> 
 -->
 <primary>整型</primary>
    </indexterm>

    <indexterm zone="datatype-int">
     <primary>smallint</primary>
    </indexterm>

    <indexterm zone="datatype-int">
     <primary>bigint</primary>
    </indexterm>

    <indexterm>
     <primary>int4</primary>
     <see>integer</see>
    </indexterm>

    <indexterm>
     <primary>int2</primary>
     <see>smallint</see>
    </indexterm>

    <indexterm>
     <primary>int8</primary>
     <see>bigint</see>
    </indexterm>

    <!--
<para>
     The types <type>smallint</type>, <type>integer</type>, and
     <type>bigint</type> store whole numbers, that is, numbers without
     fractional components, of various ranges.  Attempts to store
     values outside of the allowed range will result in an error.
    </para>
-->
<para>
<type>smallint</type>，<type>integer</type>和<type>bigint</type>类型存储各种取值范围的整数，
即，没有小数部分的数字。试图存储超出取值范围以外的数值将导致一个错误。
</para>

    <!--
<para>
     The type <type>integer</type> is the common choice, as it offers
     the best balance between range, storage size, and performance.
     The <type>smallint</type> type is generally only used if disk
     space is at a premium.  The <type>bigint</type> type is designed to be
     used when the range of the <type>integer</type> type is insufficient.
    </para>
-->
<para>
常用的类型是<type>integer</type>，因为它在取值范围、存储空间、性能之间最为平衡。
一般只有在磁盘空间紧张的时候才使用<type>smallint</type>。
当<type>integer</type>的取值范围不够用的时候才使用<type>bigint</type>。
</para>

    <!--
<para>
     <acronym>SQL</acronym> only specifies the integer types
     <type>integer</type> (or <type>int</type>),
     <type>smallint</type>, and <type>bigint</type>.  The
     type names <type>int2</type>, <type>int4</type>, and
     <type>int8</type> are extensions, which are also used by some
     other <acronym>SQL</acronym> database systems.
    </para>
-->
<para>
<acronym>SQL</acronym>标准只定义了整型<type>integer</type>(或<type>int</type>)，
<type>smallint</type>和<type>bigint</type>。名为<type>int2</type>, <type>int4</type>
和<type>int8</type>的类型都是扩展，它们也在许多其它符合<acronym>SQL</acronym>标准的数据库系统中使用。
</para>

   </sect2>

   <sect2 id="datatype-numeric-decimal">
    <!-- 
<title>Arbitrary Precision Numbers</title> 
-->
<title>任意精度数值</title>

    <indexterm>
     <!-- 
 <primary>numeric (data type)</primary> 
 -->
 <primary>数值 (数据类型)</primary>
    </indexterm>

   <indexterm>
    <!-- 
<primary>arbitrary precision numbers</primary> 
-->
<primary>任意精度数值</primary>
   </indexterm>

    <indexterm>
     <!-- 
 <primary>decimal</primary>
     <see>numeric</see> 
 -->
 <primary>小数</primary>
     <see>数值</see>
    </indexterm>

    <!--
<para>
     The type <type>numeric</type> can store numbers with a
     very large number of digits and perform calculations exactly. It is
     especially recommended for storing monetary amounts and other
     quantities where exactness is required. However, arithmetic on
     <type>numeric</type> values is very slow compared to the integer
     types, or to the floating-point types described in the next section.
    </para>
-->
<para>
<type>numeric</type>类型可以存储非常大的数字并且准确地进行计算。
我们特别建议将它用于货币金额和其它要求精确计算的场合。不过，
<type>numeric</type>类型上的算术运算比整数类型或者我们下一节描述的浮点数类型要慢很多。
</para>

    <!--
<para>
     We use the following terms below:  The
     <firstterm>scale</firstterm> of a <type>numeric</type> is the
     count of decimal digits in the fractional part, to the right of
     the decimal point.  The <firstterm>precision</firstterm> of a
     <type>numeric</type> is the total count of significant digits in
     the whole number, that is, the number of digits to both sides of
     the decimal point.  So the number 23.5141 has a precision of 6
     and a scale of 4.  Integers can be considered to have a scale of
     zero.
    </para>
-->
<para>
在随后的内容里，我们使用下述术语：一个<type>numeric</type>类型的标度
(<firstterm>scale</firstterm>)是小数部分的位数，精度(<firstterm>precision</firstterm>)
是全部数据位的数目，也就是小数点两边的位数总和。
因此数字 23.5141 的精度为 6 而标度为 4 。你可以认为整数的标度为零。
</para>

   
<para>
 <!--
     Both the maximum precision and the maximum scale of a
     <type>numeric</type> column can be
     configured.  To declare a column of type <type>numeric</type> use
     the syntax:
-->
<type>numeric</type>字段的最大精度和最大标度都是可以配置的。
要声明一个字段的类型为<type>numeric</type>，你可以用下面的语法： 
<programlisting>
NUMERIC(<replaceable>precision</replaceable>, <replaceable>scale</replaceable>)
</programlisting>
     <!-- 
 The precision must be positive, the scale zero or positive.
     Alternatively: 
 -->
 精度必须为正数，标度可以为零或者正数。另外:
<programlisting>
NUMERIC(<replaceable>precision</replaceable>)
</programlisting>
     <!-- 
 selects a scale of 0.  Specifying: 
 -->
 选择了标度为 0 。不带任何精度与标度的声明
<programlisting>
NUMERIC
</programlisting>
     <!-- 
 without any precision or scale creates a column in which numeric
     values of any precision and scale can be stored, up to the
     implementation limit on precision.  A column of this kind will
     not coerce input values to any particular scale, whereas
     <type>numeric</type> columns with a declared scale will coerce
     input values to that scale.  (The <acronym>SQL</acronym> standard
     requires a default scale of 0, i.e., coercion to integer
     precision.  We find this a bit useless.  If you're concerned
     about portability, always specify the precision and scale
     explicitly.)
 -->
 则创建一个可以存储一个直到实现精度上限的任意精度和标度的数值，
 一个这样类型的字段将不会把输入数值转化成任何特定的标度，
 而带有标度声明的<type>numeric</type>字段将把输入值转化为该标度。
 <acronym>SQL</acronym>标准要求缺省的标度是 0(也就是转化成整数精度)。
 我们觉得这样做有点没用。如果你关心移植性，
 那你最好总是明确声明精度和标度。
    </para>


    <note>
     <!--
<para>
      The maximum allowed precision when explicitly specified in the
      type declaration is 1000; <type>NUMERIC</type> without a specified
      precision is subject to the limits described in <xref
      linkend="datatype-numeric-table">.
     </para>
-->
<para>
当在类型声明中显示指定精度时允许的最大值为1000；没有指定精度的
<type>NUMERIC</type>遵从<xref linkend="datatype-numeric-table">里的描述。
</para>
    </note>

    <!--
<para>
     If the scale of a value to be stored is greater than the declared
     scale of the column, the system will round the value to the specified
     number of fractional digits.  Then, if the number of digits to the
     left of the decimal point exceeds the declared precision minus the
     declared scale, an error is raised.
    </para>
-->
<para>
如果一个要存储的数值的标度比字段声明的标度高，
那么系统将尝试圆整(四舍五入)该数值到指定的小数位。然后，
如果小数点左边的数据位数超过了声明的精度减去声明的标度，那么将抛出一个错误。
</para>

    <!--
<para>
     Numeric values are physically stored without any extra leading or
     trailing zeroes.  Thus, the declared precision and scale of a column
     are maximums, not fixed allocations.  (In this sense the <type>numeric</>
     type is more akin to <type>varchar(<replaceable>n</>)</type>
     than to <type>char(<replaceable>n</>)</type>.)  The actual storage
     requirement is two bytes for each group of four decimal digits,
     plus three to eight bytes overhead.
    </para>
-->
<para>
numeric 类型的数据值在物理上是不带任何前导或者后缀零的形式存储的。
因此，字段上声明的精度和标度都是最大值，而不是固定分配的。在这个方面，
<type>numeric</>类型更类似于<type>varchar(<replaceable>n</>)</type>而不是
<type>char(<replaceable>n</>)</type>。实际存储是每四个十进制位两个字节，
然后在整个数据上加上三到八个字节的额外开销。
</para>

    <indexterm>
     <primary>NaN</primary>
     <see>not a number</see>
   </indexterm>

    <indexterm>
     <!-- 
 <primary>not a number</primary>
     <secondary>numeric (data type)</secondary> 
 -->
 <primary>不是一个数字</primary>
     <secondary>数值 (数据类型)</secondary>
    </indexterm>

    <!--
<para>
     In addition to ordinary numeric values, the <type>numeric</type>
     type allows the special value <literal>NaN</>, meaning
     <quote>not-a-number</quote>.  Any operation on <literal>NaN</>
     yields another <literal>NaN</>.  When writing this value
     as a constant in an SQL command, you must put quotes around it,
     for example <literal>UPDATE table SET x = 'NaN'</>.  On input,
     the string <literal>NaN</> is recognized in a case-insensitive manner.
    </para>
-->
<para>
除了普通的数字值之外，<type>numeric</type>类型允许用特殊值<literal>NaN</>
表示<quote>不是一个数字</quote>。任何在<literal>NaN</>上面的操作都生成另外一个
<literal>NaN</>。如果在 SQL 命令里把这些值当作一个常量写，
你必须在其周围放上单引号，比如<literal>UPDATE table SET x = 'NaN'</>。
在输入时，字符串<literal>NaN</>是大小写无关的。
</para>

    <note>
     <!--
<para>
      In most implementations of the <quote>not-a-number</> concept,
      <literal>NaN</> is not considered equal to any other numeric
      value (including <literal>NaN</>).  In order to allow
      <type>numeric</> values to be sorted and used in tree-based
      indexes, <productname>PostgreSQL</> treats <literal>NaN</>
      values as equal, and greater than all non-<literal>NaN</>
      values.
     </para>
-->
<para>
在大多数<quote>not-a-number</>概念中，不认为<literal>NaN</>等于其他数值类型
（包括<literal>NaN</>）。为了能够存储<type>numeric</>类型的值，
并且使用Tree索引，<productname>PostgreSQL</>认为<literal>NaN</>相等，
并且大于所有非<literal>NaN</>值。 
</para>
    </note>

    <!--
<para>
     The types <type>decimal</type> and <type>numeric</type> are
     equivalent.  Both types are part of the <acronym>SQL</acronym>
     standard.
    </para>
-->
<para>
类型<type>decimal</type>和<type>numeric</type>是等效的。
两种类型都是<acronym>SQL</acronym>标准。
</para>
   </sect2>


   <sect2 id="datatype-float">
    <!-- 
<title>Floating-Point Types</title> 
-->
<title>浮点数类型</title>
    <indexterm zone="datatype-float">
     <primary>real</primary>
    </indexterm>

    <indexterm zone="datatype-float">
     <!-- 
 <primary>double precision</primary> 
 -->
 <primary>双精度</primary>
    </indexterm>

    <indexterm>
     <primary>float4</primary>
     <see>real</see>
    </indexterm>

    <indexterm>
     <primary>float8</primary>
     <see>double precision</see>
    </indexterm>

    <indexterm zone="datatype-float">
     <!-- 
 <primary>floating point</primary> 
 -->
 <primary>浮点数</primary>
    </indexterm>

    <!--
<para>
     The data types <type>real</type> and <type>double
     precision</type> are inexact, variable-precision numeric types.
     In practice, these types are usually implementations of
     <acronym>IEEE</acronym> Standard 754 for Binary Floating-Point
     Arithmetic (single and double precision, respectively), to the
     extent that the underlying processor, operating system, and
     compiler support it.
    </para>
-->
<para>
数据类型<type>real</type>和<type>double precision</type>是不精确的、变精度的数字类型。
实际上，这些类型是<acronym>IEEE</acronym> 754标准二进制浮点数算术(分别对应单和双精度)的一般实现，
外加下层处理器、操作系统和编译器对它的支持。
</para>

    
<para>
<!--
     Inexact means that some values cannot be converted exactly to the
     internal format and are stored as approximations, so that storing
     and retrieving a value might show slight discrepancies.
     Managing these errors and how they propagate through calculations
     is the subject of an entire branch of mathematics and computer
     science and will not be discussed here, except for the
     following points:
-->
不精确意味着一些数值不能精确地转换成内部格式并且是以近似值存储的，
因此存储后再把数据打印出来可能有一些差异。
处理这些错误以及这些错误是如何在计算中传播的属于数学和计算机科学的一个完整的分支，
我们不会在这里进一步讨论它，这里的讨论仅限于如下几点： 
     <itemizedlist>
      <listitem>
<!--
       <para>
        If you require exact storage and calculations (such as for
        monetary amounts), use the <type>numeric</type> type instead.
       </para>
-->
<para>
如果你要求精确的计算(比如计算货币金额)，应使用<type>numeric</type>类型。
</para>
      </listitem>

      <listitem>
       <!--
<para>
        If you want to do complicated calculations with these types
        for anything important, especially if you rely on certain
        behavior in boundary cases (infinity, underflow), you should
        evaluate the implementation carefully.
       </para>
-->
<para>
如果你想用这些类型做任何重要的复杂计算，
尤其是那些你对范围情况(无穷/下溢)严重依赖的事情，那你应该仔细评诂你的实现。
</para>
      </listitem>

      <listitem>
       <!--
<para>
        Comparing two floating-point values for equality might not
        always work as expected.
       </para>
-->
<para>
拿两个浮点数值进行相等性比较可能不像你想像那样运转。 
</para>
      </listitem>
     </itemizedlist>
    </para>

    <!--
<para>
     On most platforms, the <type>real</type> type has a range of at least
     1E-37 to 1E+37 with a precision of at least 6 decimal digits.  The
     <type>double precision</type> type typically has a range of around
     1E-307 to 1E+308 with a precision of at least 15 digits.  Values that
     are too large or too small will cause an error.  Rounding might
     take place if the precision of an input number is too high.
     Numbers too close to zero that are not representable as distinct
     from zero will cause an underflow error.
    </para>
-->
<para>
在大多数平台上，<type>real</type>类型的范围是至少1E-37到1E+37，
精度至少是6位小数。<type>double precision</type>的范围通常是1E-307到1E+308，
精度是至少15位数字。太大或者太小的数值都会导致错误。如果输入数据的精度太高，
那么将会发生圆整。太接近零的数字，如果无法与零值的表现形式相区分就会产生下溢错误。
</para>

    <note>
     <!--
<para>
      The <xref linkend="guc-extra-float-digits"> setting controls the
      number of extra significant digits included when a floating point
      value is converted to text for output.  With the default value of
      <literal>0</literal>, the output is the same on every platform
      supported by PostgreSQL.  Increasing it will produce output that
      more accurately represents the stored value, but may be unportable.
     </para>
-->
<para>
当一个浮点数值转化为文本输出时，<xref linkend="guc-extra-float-digits">
设置控制额外有效数字的位数。默认值是<literal>0</literal>，PostgreSQL
支持的平台上的输出是一样的。增加这个值产生的输出将更精确的表示存储值，
但是可能不利于移植。
</para>
    </note>

    <indexterm>
     <!-- 
 <primary>not a number</primary>
     <secondary>double precision</secondary> 
 -->
 <primary>不是一个数字</primary>
     <secondary>双精度</secondary>
    </indexterm>

    
<para>
<!--
     In addition to ordinary numeric values, the floating-point types
     have several special values:
 -->
 除了普通的数字值之外，浮点类型还有几个特殊值： 
<literallayout>
<literal>Infinity</literal>
<literal>-Infinity</literal>
<literal>NaN</literal>
</literallayout>
     <!-- 
 These represent the IEEE 754 special values
     <quote>infinity</quote>, <quote>negative infinity</quote>, and
     <quote>not-a-number</quote>, respectively.  (On a machine whose
     floating-point arithmetic does not follow IEEE 754, these values
     will probably not work as expected.)  When writing these values
     as constants in an SQL command, you must put quotes around them,
     for example <literal>UPDATE table SET x = 'Infinity'</>.  On input,
     these strings are recognized in a case-insensitive manner. 
 -->
 这些值分别表示 IEEE 754 特殊值<quote>正无穷大</quote>、<quote>负无穷大</quote>、
 <quote>不是一个数字</quote>。在不遵循 IEEE 754 浮点算术的机器上，
 这些值的含义可能不是预期的。如果在 SQL 命令里把这些数值当作常量写，
 你必须在它们周围放上单引号，像这样：<literal>UPDATE table SET x = 'Infinity'</>。
 输入时，这些值是以大小写无关的方式识别的。
    </para>


    <note>
     <!--
<para>
      IEEE754 specifies that <literal>NaN</> should not compare equal
      to any other floating-point value (including <literal>NaN</>).
      In order to allow floating-point values to be sorted and used
      in tree-based indexes, <productname>PostgreSQL</> treats
      <literal>NaN</> values as equal, and greater than all
      non-<literal>NaN</> values.
     </para>
-->
<para>
IEEE754声明<literal>NaN</>不应该等于任何其他浮点值（包括<literal>NaN</>）。
为了能存储浮点值，并且使用Tree索引，<productname>PostgreSQL</>认为<literal>NaN</>
相等，并且大于所有非<literal>NaN</>值。 
</para>
    </note>

    <!--
<para>
     <productname>PostgreSQL</productname> also supports the SQL-standard
     notations <type>float</type> and
     <type>float(<replaceable>p</replaceable>)</type> for specifying
     inexact numeric types.  Here, <replaceable>p</replaceable> specifies
     the minimum acceptable precision in <emphasis>binary</> digits.
     <productname>PostgreSQL</productname> accepts
     <type>float(1)</type> to <type>float(24)</type> as selecting the
     <type>real</type> type, while
     <type>float(25)</type> to <type>float(53)</type> select
     <type>double precision</type>.  Values of <replaceable>p</replaceable>
     outside the allowed range draw an error.
     <type>float</type> with no precision specified is taken to mean
     <type>double precision</type>.
    </para>
-->
<para>
<productname>PostgreSQL</productname>还支持 SQL 标准表示法<type>float</type>
和<type>float(<replaceable>p</replaceable>)</type>用于声明非精确的数值类型。
其中的<replaceable>p</replaceable>声明以<emphasis>二进制</>位表示的最低可接受精度。
在选取<type>real</type>类型的时候，<productname>PostgreSQL</productname>接受
<type>float(1)</type>到<type>float(24)</type>，在选取<type>double precision</type>
的时候，接受<type>float(25)</type>到<type>float(53)</type>。
在允许范围之外的<replaceable>p</replaceable>值将导致一个错误。
没有声明精度的<type>float</type>将被当作<type>double precision</type>。
</para>

    <note>
     <!--
<para>
      The assumption that <type>real</type> and
      <type>double precision</type> have exactly 24 and 53 bits in the
      mantissa respectively is correct for IEEE-standard floating point
      implementations.  On non-IEEE platforms it might be off a little, but
      for simplicity the same ranges of <replaceable>p</replaceable> are used
      on all platforms.
     </para>
-->
<para>
假设<type>real</type>和<type>double precision</type>
分别有 24 和 53 个二进制位的位数对 IEEE 标准的浮点实现来说是正确的。在非 IEEE 平台上，
这个数值可能略有偏差，但是为了简化，我们在所有平台上都用了同样的<replaceable>p</replaceable>值范围。
</para>
    </note>

   </sect2>

   <sect2 id="datatype-serial">
    <!-- 
<title>Serial Types</title> 
-->
<title>序列号类型</title>

    <indexterm zone="datatype-serial">
     <primary>smallserial</primary>
    </indexterm>

    <indexterm zone="datatype-serial">
     <primary>serial</primary>
    </indexterm>

    <indexterm zone="datatype-serial">
     <primary>bigserial</primary>
    </indexterm>

    <indexterm zone="datatype-serial">
     <primary>serial2</primary>
    </indexterm>

    <indexterm zone="datatype-serial">
     <primary>serial4</primary>
    </indexterm>

    <indexterm zone="datatype-serial">
     <primary>serial8</primary>
    </indexterm>

    <indexterm>
     <!-- 
 <primary>auto-increment</primary>
     <see>serial</see> 
 -->
 <primary>自增</primary>
     <see>序列号</see> 
    </indexterm>

    <indexterm>
     <!-- 
 <primary>sequence</primary>
     <secondary>and serial type</secondary> 
 -->
 <primary>序列</primary>
     <secondary>序列类型</secondary>
    </indexterm>

    
<para>
<!--
     The data types <type>smallserial</type>, <type>serial</type> and
     <type>bigserial</type> are not true types, but merely
     a notational convenience for creating unique identifier columns
     (similar to the <literal>AUTO_INCREMENT</literal> property
     supported by some other databases). In the current
     implementation, specifying:
-->
<type>smallserial</type>,<type>serial</type>和<type>bigserial</type>类型不是真正的类型，
只是为在表中创建唯一标识做的概念上的便利。类似其它一些数据库中的<literal>AUTO_INCREMENT</literal>
属性。在目前的实现中，下面一个语句：
<programlisting>
CREATE TABLE <replaceable class="parameter">tablename</replaceable> (
    <replaceable class="parameter">colname</replaceable> SERIAL
);
</programlisting>

     <!-- 
 is equivalent to specifying: 
 -->
 等价于声明下面几个语句：

<programlisting>
CREATE SEQUENCE <replaceable class="parameter">tablename</replaceable>_<replaceable class="parameter">colname</replaceable>_seq;
CREATE TABLE <replaceable class="parameter">tablename</replaceable> (
    <replaceable class="parameter">colname</replaceable> integer NOT NULL DEFAULT nextval('<replaceable class="parameter">tablename</replaceable>_<replaceable class="parameter">colname</replaceable>_seq')
);
ALTER SEQUENCE <replaceable class="parameter">tablename</replaceable>_<replaceable class="parameter">colname</replaceable>_seq OWNED BY <replaceable class="parameter">tablename</replaceable>.<replaceable class="parameter">colname</replaceable>;
</programlisting>
<!-- 
     Thus, we have created an integer column and arranged for its default
     values to be assigned from a sequence generator.  A <literal>NOT NULL</>
     constraint is applied to ensure that a null value cannot be
     inserted.  (In most cases you would also want to attach a
     <literal>UNIQUE</> or <literal>PRIMARY KEY</> constraint to prevent
     duplicate values from being inserted by accident, but this is
     not automatic.)  Lastly, the sequence is marked as <quote>owned by</>
     the column, so that it will be dropped if the column or table is dropped.
 -->
 因此，我们就创建了一个整数字段并且把它的缺省数值安排为从一个序列发生器读取。
 应用了一个<literal>NOT NULL</>约束以确保 NULL 不会被插入。
 在大多数情况下你可能还希望附加一个<literal>UNIQUE</>或<literal>PRIMARY KEY</>
 约束避免意外地插入重复的数值，但这个不是自动的。最后，
 将序列发生器<quote>从属于</>那个字段，这样当该字段或表被删除的时候也一并删除它。
    </para>


    <note>
      <!--
<para>
        Because <type>smallserial</type>, <type>serial</type> and
        <type>bigserial</type> are implemented using sequences, there may
        be "holes" or gaps in the sequence of values which appears in the
        column, even if no rows are ever deleted.  A value allocated
        from the sequence is still "used up" even if a row containing that
        value is never successfully inserted into the table column.  This
        may happen, for example, if the inserting transaction rolls back.
        See <literal>nextval()</literal> in <xref linkend="functions-sequence">
        for details.
      </para>
-->
<para>
因为<type>smallserial</type>, <type>serial</type>和<type>bigserial</type>
是使用序列实现的，所以显示在字段里的序列值可能有“漏洞”或者缺口，即使没有列曾经被删除。
一个从序列中分配的值仍然会“使用”，即使包含这个值的行没有成功的插入到表格的字段中。
这种情况是有可能发生的，比如，插入事务回滚。参阅<xref linkend="functions-sequence">
中的<literal>nextval()</literal>获取详细信息。
</para>
    </note>

    <note>
     <!--
<para>
     To insert the next value of the sequence into the <type>serial</type>
     column, specify that the <type>serial</type>
     column should be assigned its default value. This can be done
     either by excluding the column from the list of columns in
     the <command>INSERT</command> statement, or through the use of
     the <literal>DEFAULT</literal> key word.
    </para>
-->
<para>
要在<type>serial</type>字段中插入序列中的下一个数值，主要是要注意<type>serial</type>
字段应该赋予缺省值。我们可以通过在<command>INSERT</command>
语句中把该字段排除在字段列表之外来实现，也可以通过使用<literal>DEFAULT</literal>关键字来实现。
</para>

    <!--
<para>
     The type names <type>serial</type> and <type>serial4</type> are
     equivalent: both create <type>integer</type> columns.  The type
     names <type>bigserial</type> and <type>serial8</type> work
     the same way, except that they create a <type>bigint</type>
     column.  <type>bigserial</type> should be used if you anticipate
     the use of more than 2<superscript>31</> identifiers over the
     lifetime of the table. The type names <type>smallserial</type> and
     <type>serial2</type> also work the same way, except that they
     create a <type>smallint</type> column.
    </para>
-->
<para>
类型名<type>serial</type>和<type>serial4</type>是等效的：
两者都创建<type>integer</type>字段。类型名<type>bigserial</type>和<type>serial8</type>
也一样，只不过它创建一个<type>bigint</type>字段。
如果你预计在表的生存期中使用的标识数目可能超过 2<superscript>31</> 个，
那么你应该使用<type>bigserial</type>。类型名<type>smallserial</type>和
<type>serial2</type>也一样，只不过它创建一个<type>smallint</type>字段。
</para>

    <!--
<para>
     The sequence created for a <type>serial</type> column is
     automatically dropped when the owning column is dropped.
     You can drop the sequence without dropping the column, but this
     will force removal of the column default expression.
    </para>
-->
<para>
一个<type>serial</type>类型创建的序列在所属的字段被删除的时候自动删除。
你可以只删除序列而不删除字段，不过这将删除该字段的缺省值表达式。
</para>
   </sect2>
  </sect1>

  <sect1 id="datatype-money">
   <!-- 
   <title>Monetary Types</title> 
   -->
<title>货币类型</title>
   <!--
<para>
    The <type>money</type> type stores a currency amount with a fixed
    fractional precision; see <xref
    linkend="datatype-money-table">.  The fractional precision is
    determined by the database's <xref linkend="guc-lc-monetary"> setting.
    The range shown in the table assumes there are two fractional digits.
    Input is accepted in a variety of formats, including integer and
    floating-point literals, as well as typical
    currency formatting, such as <literal>'$1,000.00'</literal>.
    Output is generally in the latter form but depends on the locale.
   </para>
-->
<para>
<type>money</type>类型存储带有固定小数精度的货币金额，可查阅
<xref linkend="datatype-money-table">。小数精度由<xref linkend="guc-lc-monetary">
的设置来决定。表格中显示的范围假设有两位小数。可以以任意格式输入，包括整型，
浮点型，或者典型的货币格式，如<literal>'$1,000.00'</literal>。
根据区域字符集，输出一般是最后一种形式。 
</para>

    <table id="datatype-money-table">
     <!-- 
 <title>Monetary Types</title> 
 -->
 <title>货币类型</title>
     <tgroup cols="4">
      <thead>
       <row>
        <!-- 
<entry>Name</entry>
        <entry>Storage Size</entry>
        <entry>Description</entry>
        <entry>Range</entry> 
-->
<entry>名字</entry>
        <entry>存储容量</entry>
        <entry>描述</entry>
        <entry>范围</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <!-- 
<entry>money</entry>
        <entry>8 bytes</entry>
        <entry>currency amount</entry>
        <entry>-92233720368547758.08 to +92233720368547758.07</entry> 
-->
<entry>money</entry>
        <entry>8 字节</entry>
        <entry>货币金额</entry>
        <entry>-92233720368547758.08 到 +92233720368547758.07</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <!--
<para>
    Since the output of this data type is locale-sensitive, it might not
    work to load <type>money</> data into a database that has a different
    setting of <varname>lc_monetary</>.  To avoid problems, before
    restoring a dump into a new database make sure <varname>lc_monetary</> has
    the same or equivalent value as in the database that was dumped.
   </para>
-->
<para>
由于输出的数据类型对语言环境要求很细，因此，<varname>lc_monetary</>
设置的不同可能会造成无法将<type>money</>数据输入到数据库中。
为了避免这种问题的发生，在向一个新数据库进行转储之前，确保
<varname>lc_monetary</>与原数据库相同，或具有等价值。
</para>
   
<para>
<!--
    Values of the <type>numeric</type>, <type>int</type>, and
    <type>bigint</type> data types can be cast to <type>money</type>.
    Conversion from the <type>real</type> and <type>double precision</type>
    data types can be done by casting to <type>numeric</type> first, for
    example:
-->
<type>numeric</type>, <type>int</type>和<type>bigint</type>数据类型的值可以转化为
<type>money</type>类型。从<type>real</type>和<type>double precision</type>
数据类型的转换可以通过先转化为<type>numeric</type>类型，例如：
<programlisting>
SELECT '12.34'::float8::numeric::money;
</programlisting>
<!-- 
    However, this is not recommended.  Floating point numbers should not be
    used to handle money due to the potential for rounding errors. 
-->
然而，这是不被建议的。浮点数不应该用来处理货币类型，因为潜在的圆整可能导致错误。
   </para>

  
<para>
 <!--
    A <type>money</type> value can be cast to <type>numeric</type> without
    loss of precision. Conversion to other types could potentially lose
    precision, and must also be done in two stages:
-->
<type>money</type>值可以被转换为<type>numeric</type>而不丢失精度。
转换为其他类型可能丢失精度，并且必须通过两步来完成：
<programlisting>
SELECT '52093.89'::money::numeric::float8;
</programlisting>
   </para>

   <!--
<para>
    When a <type>money</type> value is divided by another <type>money</type>
    value, the result is <type>double precision</type> (i.e., a pure number,
    not money); the currency units cancel each other out in the division.
   </para>
-->
<para>
当一个<type>money</type>值被另一个<type>money</type>值除时，
结果是<type>double precision</type>（也就是，一个纯数字，而不是money）；
在结果中货币单位相互取消。
</para>
  </sect1>


  <sect1 id="datatype-character">
   <!-- 
   <title>Character Types</title> 
   -->
   <title>字符类型</title>

   <indexterm zone="datatype-character">
    <!-- 
<primary>character string</primary>
    <secondary>data types</secondary> 
-->
<primary>字符类型</primary>
    <secondary>数据类型</secondary>
   </indexterm>

   <indexterm>
    <!-- 
<primary>string</primary>
    <see>character string</see>
-->
<primary>字符串</primary>
    <see>字符串</see>
   </indexterm>

   <indexterm zone="datatype-character">
    <!-- 
<primary>character</primary> 
-->
<primary>字符</primary>
   </indexterm>

   <indexterm zone="datatype-character">
    <!-- 
<primary>character varying</primary> 
-->
<primary>字符变化</primary>
   </indexterm>

   <indexterm zone="datatype-character">
    <primary>text</primary>
   </indexterm>

   <indexterm zone="datatype-character">
    <primary>char</primary>
   </indexterm>

   <indexterm zone="datatype-character">
    <primary>varchar</primary>
   </indexterm>

    <table id="datatype-character-table">
     <!-- 
 <title>Character Types</title> 
 -->
 <title>字符类型</title>
     <tgroup cols="2">
      <thead>
       <row>
        <!-- 
<entry>Name</entry>
        <entry>Description</entry>
-->
<entry>名字</entry>
        <entry>描述</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><type>character varying(<replaceable>n</>)</type>, <type>varchar(<replaceable>n</>)</type></entry>
        <!-- 
<entry>variable-length with limit</entry> 
-->
<entry>变长，有长度限制</entry>
       </row>
       <row>
        <entry><type>character(<replaceable>n</>)</type>, <type>char(<replaceable>n</>)</type></entry>
        <!-- 
<entry>fixed-length, blank padded</entry> 
-->
<entry>定长，不足补空白</entry>
       </row>
       <row>
        <entry><type>text</type></entry>
        <!-- 
<entry>variable unlimited length</entry>
-->
<entry>变长，无长度限制</entry>
       </row>
     </tbody>
     </tgroup>
    </table>

   <!--
<para>
    <xref linkend="datatype-character-table"> shows the
    general-purpose character types available in
    <productname>PostgreSQL</productname>.
   </para>
-->
<para>
<xref linkend="datatype-character-table">显示了在<productname>PostgreSQL</productname>
里可用于一般用途的字符类型。 
</para>

   <!--
<para>
    <acronym>SQL</acronym> defines two primary character types:
    <type>character varying(<replaceable>n</>)</type> and
    <type>character(<replaceable>n</>)</type>, where <replaceable>n</>
    is a positive integer.  Both of these types can store strings up to
    <replaceable>n</> characters (not bytes) in length.  An attempt to store a
    longer string into a column of these types will result in an
    error, unless the excess characters are all spaces, in which case
    the string will be truncated to the maximum length. (This somewhat
    bizarre exception is required by the <acronym>SQL</acronym>
    standard.) If the string to be stored is shorter than the declared
    length, values of type <type>character</type> will be space-padded;
    values of type <type>character varying</type> will simply store the
    shorter
    string.
   </para>
-->
<para>
<acronym>SQL</acronym>定义了两种基本的字符类型：<type>character varying(<replaceable>n</>)</type>
和<type>character(<replaceable>n</>)</type>，这里的<replaceable>n</>
是一个正整数。两种类型都可以存储最多<replaceable>n</>个字符的字符串（没有字节）。
试图存储更长的字符串到这些类型的字段里会产生一个错误，
除非超出长度的字符都是空白，这种情况下该字符串将被截断为最大长度。
这个看上去有点怪异的例外是<acronym>SQL</acronym>标准要求的。
如果要存储的字符串比声明的长度短，类型为<type>character</type>的数值将会用空白填满；
而类型为<type>character varying</type>的数值将只是存储短些的字符串。 
</para>

   <!--
<para>
    If one explicitly casts a value to <type>character
    varying(<replaceable>n</>)</type> or
    <type>character(<replaceable>n</>)</type>, then an over-length
    value will be truncated to <replaceable>n</> characters without
    raising an error. (This too is required by the
    <acronym>SQL</acronym> standard.)
   </para>
-->
<para>
如果我们明确地把一个数值转换成<type>character varying(<replaceable>n</>)</type>
或<type>character(<replaceable>n</>)</type>，那么超长的数值将被截断成<replaceable>n</>
个字符，且不会抛出错误。这也是<acronym>SQL</acronym>标准的要求。 
</para>

   <!--
<para>
    The notations <type>varchar(<replaceable>n</>)</type> and
    <type>char(<replaceable>n</>)</type> are aliases for <type>character
    varying(<replaceable>n</>)</type> and
    <type>character(<replaceable>n</>)</type>, respectively.
    <type>character</type> without length specifier is equivalent to
    <type>character(1)</type>. If <type>character varying</type> is used
    without length specifier, the type accepts strings of any size. The
    latter is a <productname>PostgreSQL</> extension.
   </para>
-->
<para>
<type>varchar(<replaceable>n</>)</type>和<type>char(<replaceable>n</>)</type>
分别是<type>character varying(<replaceable>n</>)</type>
和<type>character(<replaceable>n</>)</type>的别名，
没有声明长度的<type>character</type>等于<type>character(1)</type>；
如果不带长度说明词使用<type>character varying</type>，
那么该类型接受任何长度的字符串。后者是<productname>PostgreSQL</>的扩展。 
</para>

   <!--
<para>
    In addition, <productname>PostgreSQL</productname> provides the
    <type>text</type> type, which stores strings of any length.
    Although the type <type>text</type> is not in the
    <acronym>SQL</acronym> standard, several other SQL database
    management systems have it as well.
   </para>
-->
<para>
另外，<productname>PostgreSQL</productname>提供<type>text</type>类型，
它可以存储任何长度的字符串。尽管类型<type>text</type>不是<acronym>SQL</acronym>
标准，但是许多其它SQL数据库系统也有它。
</para>

   <!--
<para>
    Values of type <type>character</type> are physically padded
    with spaces to the specified width <replaceable>n</>, and are
    stored and displayed that way.  However, trailing spaces are treated as
    semantically insignificant and disregarded when comparing two values
    of type <type>character</type>.  In collations where whitespace
    is significant, this behavior can produce unexpected results,
    e.g. <command>SELECT 'a '::CHAR(2) collate "C" &lt;
    'a\n'::CHAR(2)</command> returns true.
    Trailing spaces are removed when converting a <type>character</type> value
    to one of the other string types.  Note that trailing spaces
    <emphasis>are</> semantically significant in
    <type>character varying</type> and <type>text</type> values, and
    when using pattern matching, e.g. <literal>LIKE</>,
    regular expressions.
   </para>
-->
<para>
<type>character</type>类型的数值物理上都用空白填充到指定的长度<replaceable>n</>，
并且以这种方式存储和显示。不过，在比较两个<type>character</type>
类型的值时，尾随的空白是无关紧要的，不需要理会。
在空白比较重要的排序规则中，这个行为会导致意想不到的结果，
比如<command>SELECT 'a '::CHAR(2) collate "C" &lt;
    'a\n'::CHAR(2)</command>返回真。
在将<type>character</type>值转换成其它字符串类型的时候，
它后面的空白会被删除。请注意，
在<type>character varying</type>和<type>text</type>数值里，
结尾的空白是<emphasis>有语意</>的。
并且当使用模式匹配时，如<literal>LIKE</>，使用正则表达式。 
</para>

   <!--
<para>
    The storage requirement for a short string (up to 126 bytes) is 1 byte
    plus the actual string, which includes the space padding in the case of
    <type>character</type>.  Longer strings have 4 bytes of overhead instead
    of 1.  Long strings are compressed by the system automatically, so
    the physical requirement on disk might be less. Very long values are also
    stored in background tables so that they do not interfere with rapid
    access to shorter column values. In any case, the longest
    possible character string that can be stored is about 1 GB. (The
    maximum value that will be allowed for <replaceable>n</> in the data
    type declaration is less than that. It wouldn't be useful to
    change this because with multibyte character encodings the number of
    characters and bytes can be quite different. If you desire to
    store long strings with no specific upper limit, use
    <type>text</type> or <type>character varying</type> without a length
    specifier, rather than making up an arbitrary length limit.)
   </para>
-->
<para>
一个简短的字符串（最多126个字节）的存储要求是1个字节加上实际的字符串，
其中包括空格填充的<type>character</type>。更长的字符串有4个字节的开销，
而不是1。长的字符串将会自动被系统压缩，因此在磁盘上的物理需求可能会更少些。
更长的数值也会存储在后台表里面，这样它们就不会干扰对短字段值的快速访问。
不管怎样，允许存储的最长字符串大概是1GB 。允许在数据类型声明中出现的<replaceable>n</>
的最大值比这还小。修改这个行为没有什么意义，因为在多字节编码下字符和字节的数目可能差别很大。
如果你想存储没有特定上限的长字符串，那么使用<type>text</type>
或没有长度声明的<type>character varying</type>，而不要选择一个任意长度限制。
</para>

   <tip>
    <!--
<para>
     There is no performance difference among these three types,
     apart from increased storage space when using the blank-padded
     type, and a few extra CPU cycles to check the length when storing into
     a length-constrained column.  While
     <type>character(<replaceable>n</>)</type> has performance
     advantages in some other database systems, there is no such advantage in
     <productname>PostgreSQL</productname>; in fact
     <type>character(<replaceable>n</>)</type> is usually the slowest of
     the three because of its additional storage costs.  In most situations
     <type>text</type> or <type>character varying</type> should be used
     instead.
    </para>
-->
<para>
这三种类型之间没有性能差别，除了当使用填充空白类型时的增加存储空间，
和当存储长度约束的列时一些检查存入时长度的额外的CPU周期。
虽然在某些其它的数据库系统里，<type>character(<replaceable>n</>)</type>
有一定的性能优势，但在<productname>PostgreSQL</productname>里没有。
事实上，<type>character(<replaceable>n</>)</type>通常是这三个中最慢的，
因为额外存储成本。在大多数情况下，应该使用<type>text</type>
或<type>character varying</type>。
</para>
   </tip>

   <!--
<para>
    Refer to <xref linkend="sql-syntax-strings"> for information about
    the syntax of string literals, and to <xref linkend="functions">
    for information about available operators and functions. The
    database character set determines the character set used to store
    textual values; for more information on character set support,
    refer to <xref linkend="multibyte">.
   </para>
-->
<para>
请参考<xref linkend="sql-syntax-strings">获取关于字符串文本的语法的信息，
以及<xref linkend="functions">获取关于可用操作符和函数的信息。
数据库的字符集决定用于存储文本值的字符集；有关字符集支持的更多信息，
请参考<xref linkend="multibyte">。
</para>

   <example>
    <!-- 
<title>Using the Character Types</title> 
-->
<title>使用字符类型</title>

<programlisting>
CREATE TABLE test1 (a character(4));
INSERT INTO test1 VALUES ('ok');
SELECT a, char_length(a) FROM test1; -- <co id="co.datatype-char">
<computeroutput>
  a   | char_length
------+-------------
 ok   |           2
</computeroutput>

CREATE TABLE test2 (b varchar(5));
INSERT INTO test2 VALUES ('ok');
INSERT INTO test2 VALUES ('good      ');
INSERT INTO test2 VALUES ('too long');
<computeroutput>ERROR:  value too long for type character varying(5)</computeroutput>
INSERT INTO test2 VALUES ('too long'::varchar(5)); -- <!-- explicit truncation -->明确截断
SELECT b, char_length(b) FROM test2;
<computeroutput>
   b   | char_length
-------+-------------
 ok    |           2
 good  |           5
 too l |           5
</computeroutput>
</programlisting>
    <calloutlist>
     <callout arearefs="co.datatype-char">
      <!--
<para>
       The <function>char_length</function> function is discussed in
       <xref linkend="functions-string">.
      </para>
-->
<para>
<function>char_length</function>函数在<xref linkend="functions-string">中讨论。
</para>
     </callout>
    </calloutlist>
   </example>

   <!--
<para>
    There are two other fixed-length character types in
    <productname>PostgreSQL</productname>, shown in <xref
    linkend="datatype-character-special-table">. The <type>name</type>
    type exists <emphasis>only</emphasis> for the storage of identifiers
    in the internal system catalogs and is not intended for use by the general user. Its
    length is currently defined as 64 bytes (63 usable characters plus
    terminator) but should be referenced using the constant
    <symbol>NAMEDATALEN</symbol> in <literal>C</> source code.
    The length is set at compile time (and
    is therefore adjustable for special uses); the default maximum
    length might change in a future release. The type <type>"char"</type>
    (note the quotes) is different from <type>char(1)</type> in that it
    only uses one byte of storage. It is internally used in the system
    catalogs as a simplistic enumeration type.
   </para>
-->
<para>
在<productname>PostgreSQL</productname>里另外还有两种定长字符类型。
在<xref linkend="datatype-character-special-table">里显示。<type>name</type>
类型<emphasis>只</emphasis>用于在内部系统表中存储标识符并且不是给一般用户使用的。
该类型长度当前定为 64 字节(63 可用字符加结束符)但应该使用<literal>C</>源码中的常量
<symbol>NAMEDATALEN</symbol>引用。这个长度是在编译的时候设置的，
因而可以为特殊用途调整，缺省的最大长度在以后的版本可能会改变。
类型<type>"char"</type>(注意引号)和<type>char(1)</type>是不一样的，
它只用了一个字节的存储空间。它在系统内部用于系统表当做过分简单化的枚举类型用。
</para>

    <table id="datatype-character-special-table">
     <!-- 
 <title>Special Character Types</title> 
 -->
 <title>特殊字符类型</title>
     <tgroup cols="3">
      <thead>
       <row>
        <!-- 
<entry>Name</entry>
        <entry>Storage Size</entry>
        <entry>Description</entry> 
-->
<entry>名字</entry>
        <entry>存储空间</entry>
        <entry>描述</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><type>"char"</type></entry>
        <!-- 
<entry>1 byte</entry>
        <entry>single-byte internal type</entry> 
-->
<entry>1 字节</entry>
        <entry>单字节内部类型</entry>
       </row>
       <row>
        <entry><type>name</type></entry>
        <!-- 
<entry>64 bytes</entry>
        <entry>internal type for object names</entry> 
-->
<entry>64 字节</entry>
        <entry>用于对象名的内部类型</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  </sect1>

 <sect1 id="datatype-binary">
  <!-- 
  <title>Binary Data Types</title>
  -->
<title>二进制数据类型</title>
  <indexterm zone="datatype-binary">
   <!-- 
   <primary>binary data</primary> 
   -->
   <primary>二进制数据</primary>
  </indexterm>

  <indexterm zone="datatype-binary">
   <primary>bytea</primary>
  </indexterm>

   <!--
<para>
    The <type>bytea</type> data type allows storage of binary strings;
    see <xref linkend="datatype-binary-table">.
   </para>
-->
<para>
<type>bytea</type>数据类型允许存储二进制字符串。参阅<xref linkend="datatype-binary-table">。
</para>

   <table id="datatype-binary-table">
    <!-- 
<title>Binary Data Types</title> 
-->
<title>二进制数据类型</title>
    <tgroup cols="3">
     <thead>
      <row>
       <!-- 
   <entry>Name</entry>
       <entry>Storage Size</entry>
       <entry>Description</entry>
   -->
   <entry>名字</entry>
       <entry>存储空间</entry>
       <entry>描述</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><type>bytea</type></entry>
       <!-- 
   <entry>1 or 4 bytes plus the actual binary string</entry>
       <entry>variable-length binary string</entry> 
   -->
   <entry>1或4字节加上实际的二进制字符串</entry>
       <entry>变长的二进制字符串</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <!--
<para>
    A binary string is a sequence of octets (or bytes).  Binary
    strings are distinguished from character strings in two
    ways.  First, binary strings specifically allow storing
    octets of value zero and other <quote>non-printable</quote>
    octets (usually, octets outside the range 32 to 126).
    Character strings disallow zero octets, and also disallow any
    other octet values and sequences of octet values that are invalid
    according to the database's selected character set encoding.
    Second, operations on binary strings process the actual bytes,
    whereas the processing of character strings depends on locale settings.
    In short, binary strings are appropriate for storing data that the
    programmer thinks of as <quote>raw bytes</>, whereas character
    strings are appropriate for storing text.
   </para>
-->
<para>
二进制字符串是一个字节序列。二进制字符串和普通字符字符串的区别有两个：
首先，二进制字符串完全可以存储字节零值以及其它<quote>不可打印的</quote>
字节(定义在 32 到 126 范围之外的字节)。字符串不允许字节零值，
并且也不允许那些不符合选定的字符集编码的非法字节值或者字节序列。
第二，对二进制字符串的处理实际上就是处理字节，而对字符串的处理则取决于区域设置。
简单说，二进制字符串适用于存储那些程序员认为是<quote>原始字节</>的数据，
而字符串适合存储文本。
</para>

   <!--
<para>
    The <type>bytea</type> type supports two external formats for
    input and output: <productname>PostgreSQL</productname>'s historical
    <quote>escape</quote> format, and <quote>hex</quote> format.  Both
    of these are always accepted on input.  The output format depends
    on the configuration parameter <xref linkend="guc-bytea-output">;
    the default is hex.  (Note that the hex format was introduced in
    <productname>PostgreSQL</productname> 9.0; earlier versions and some
    tools don't understand it.)
   </para>
-->
<para>
<type>bytea</type>类型支持两种输入输出的外部格式：<quote>hex</quote>
格式和<productname>PostgreSQL</productname>的历史<quote>escape</quote>格式。
这两种格式通常在输入中使用，输出格式由<xref linkend="guc-bytea-output">
配置参数决定，默认是hex。（需要注意的是hex格式是在<productname>PostgreSQL</productname>
 9.0中引入的，早期版本和一些工具中不识别。） 
</para>

   <!--
<para>
    The <acronym>SQL</acronym> standard defines a different binary
    string type, called <type>BLOB</type> or <type>BINARY LARGE
    OBJECT</type>.  The input format is different from
    <type>bytea</type>, but the provided functions and operators are
    mostly the same.
   </para>
-->
<para>
<acronym>SQL</acronym>标准定义了一个不同的二进制字符串格式，称为<type>BLOB</type>
或<type>BINARY LARGE OBJECT</type>。输入格式与<type>bytea</type>不同，
但提供的函数和操作符基本一致。
</para>

  <sect2>
   <!-- 
   <title><type>bytea</> Hex Format</title> 
   -->
   <title><type>bytea</>十六进制格式</title>

   <!--
<para>
    The <quote>hex</> format encodes binary data as 2 hexadecimal digits
    per byte, most significant nibble first.  The entire string is
    preceded by the sequence <literal>\x</literal> (to distinguish it
    from the escape format).  In some contexts, the initial backslash may
    need to be escaped by doubling it, in the same cases in which backslashes
    have to be doubled in escape format; details appear below.
    The hexadecimal digits can
    be either upper or lower case, and whitespace is permitted between
    digit pairs (but not within a digit pair nor in the starting
    <literal>\x</literal> sequence).
    The hex format is compatible with a wide
    range of external applications and protocols, and it tends to be
    faster to convert than the escape format, so its use is preferred.
   </para>
-->
<para>
<quote>hex</>格式将二进制数据编码为每字节2位十六进制数字，
最重要的四位（半字节）放在开始。整条字符串以<literal>\x</literal>开始
（与转义格式相区别）。在某些情况下，最初的反斜杠需要再写一次，以转义，
同样，在转义格式中，反斜杠需要写两个，下面会详细介绍。
十六进制数字可以大写也可以小写，并且数字对之间允许有空格（但不能是在一个数对，
也不能是在<literal>\x</literal>起始序列）。
十六进制格式能够与许多的外部应用程序和协议兼容，并且转换往往比转义快，
因此更倾向于这种用法。 
</para>
   
<para>
<!--
    Example:
-->
例子：
<programlisting>
SELECT E'\\xDEADBEEF';
</programlisting>
   </para>

  </sect2>

  <sect2>
   <!-- 
   <title><type>bytea</> Escape Format</title> 
   -->
   <title><type>bytea</>转义格式</title>

   <!--
<para>
    The <quote>escape</quote> format is the traditional
    <productname>PostgreSQL</productname> format for the <type>bytea</type>
    type.  It
    takes the approach of representing a binary string as a sequence
    of ASCII characters, while converting those bytes that cannot be
    represented as an ASCII character into special escape sequences.
    If, from the point of view of the application, representing bytes
    as characters makes sense, then this representation can be
    convenient.  But in practice it is usually confusing because it
    fuzzes up the distinction between binary strings and character
    strings, and also the particular escape mechanism that was chosen is
    somewhat unwieldy.  So this format should probably be avoided
    for most new applications.
   </para>
-->
<para>
对于<type>bytea</type>格式来说，<quote>escape</quote>格式是一种传统的
<productname>PostgreSQL</productname>格式。它采用以ASCII字符序列来表示二进制串的方法，
同时将那些无法表示成ASCII字符的二进制串转换成特殊的转义序列。从应用的角度看，
如果代表字节的字符有意义，那么这种表示方法会很方便。但实际上，
这样做会模糊二进制字符串和字符字符串之间的区别，从而造成困扰，
同时筛选出的转义机制会显得很臃肿。因此对一些新应用应该恰当的避免这种格式。 
</para>

   <!--
<para>
    When entering <type>bytea</type> values in escape format,
    octets of certain
    values <emphasis>must</emphasis> be escaped, while all octet
    values <emphasis>can</emphasis> be escaped.  In
    general, to escape an octet, convert it into its three-digit
    octal value and precede it
    by a backslash (or two backslashes, if writing the value as a
    literal using escape string syntax).
    Backslash itself (octet value 92) can alternatively be represented by
    double backslashes.
    <xref linkend="datatype-binary-sqlesc">
    shows the characters that must be escaped, and gives the alternative
    escape sequences where applicable.
   </para>
-->
<para>
当以转义格式录入<type>bytea</type>值时，你<emphasis>必须</emphasis>转义某些字节值，
同时<emphasis>可以</emphasis>转义所有字节值。通常，要转义一个字节值，
将它转换成反斜杠+三位八进制值的形式（或两个反斜杠，如果用转义字符串语法将值写成文本形式）。
另外，反斜杠本身（字节值92）可以用双反斜杠表示。<xref linkend="datatype-binary-sqlesc">
给出了必须转义的字符串，和替代的转义序列（如适用）。 
</para>

   <table id="datatype-binary-sqlesc">
    <!-- 
<title><type>bytea</> Literal Escaped Octets</title> 
-->
<title><type>bytea</>文本转义八进制</title>
    <tgroup cols="5">
     <thead>
      <row>
       <!-- 
   <entry>Decimal Octet Value</entry>
       <entry>Description</entry>
       <entry>Escaped Input Representation</entry>
       <entry>Example</entry>
       <entry>Output Representation</entry> 
   -->
   <entry>十进制数值</entry>
       <entry>描述</entry>
       <entry>输入转义形式</entry>
       <entry>例子</entry>
       <entry>输出形式</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>0</entry>
       <!-- 
   <entry>zero octet</entry> 
   -->
   <entry>八进制的零</entry>
       <entry><literal>E'\\000'</literal></entry>
       <entry><literal>SELECT E'\\000'::bytea;</literal></entry>
       <entry><literal>\000</literal></entry>
      </row>

      <row>
       <entry>39</entry>
       <!-- 
   <entry>single quote</entry>
       <entry><literal>''''</literal> or <literal>E'\\047'</literal></entry> 
   -->
   <entry>单引号</entry>
       <entry><literal>''''</literal> 或 <literal>E'\\047'</literal></entry>
       <entry><literal>SELECT E'\''::bytea;</literal></entry>
       <entry><literal>'</literal></entry>
      </row>

      <row>
       <entry>92</entry>
       <!-- 
   <entry>backslash</entry>
       <entry><literal>E'\\\\'</literal> or <literal>E'\\134'</literal></entry> 
   -->
   <entry>反斜杠</entry>
       <entry><literal>E'\\\\'</literal> 或 <literal>E'\\134'</literal></entry>
       <entry><literal>SELECT E'\\\\'::bytea;</literal></entry>
       <entry><literal>\\</literal></entry>
      </row>

      <row>
       <entry>0 to 31 and 127 to 255</entry>
       <!-- 
   <entry><quote>non-printable</quote> octets</entry>
       <entry><literal>E'\\<replaceable>xxx'</></literal> (octal value)</entry> 
   -->
   <entry><quote>不可打印</quote>八进制字符</entry>
       <entry><literal>E'\\<replaceable>xxx'</></literal> (八进制值)</entry>
       <entry><literal>SELECT E'\\001'::bytea;</literal></entry>
       <entry><literal>\001</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <!--
<para>
    The requirement to escape <emphasis>non-printable</emphasis> octets
    varies depending on locale settings. In some instances you can get away
    with leaving them unescaped. Note that the result in each of the examples
    in <xref linkend="datatype-binary-sqlesc"> was exactly one octet in
    length, even though the output representation is sometimes
    more than one character.
   </para>
-->
<para>
转义<emphasis>不可打印</emphasis>字节的要求因区域设置而异。在某些场合下，
你可以不转义它们。请注意<xref linkend="datatype-binary-sqlesc">
里的每个例子都是刚好一个字节长，虽然输出形式比一个字符要长。
</para>

   <!--
<para>
    The reason multiple backslashes are required, as shown
    in <xref linkend="datatype-binary-sqlesc">, is that an input
    string written as a string literal must pass through two parse
    phases in the <productname>PostgreSQL</productname> server.
    The first backslash of each pair is interpreted as an escape
    character by the string-literal parser (assuming escape string
    syntax is used) and is therefore consumed, leaving the second backslash of the
    pair.  (Dollar-quoted strings can be used to avoid this level
    of escaping.)  The remaining backslash is then recognized by the
    <type>bytea</type> input function as starting either a three
    digit octal value or escaping another backslash.  For example,
    a string literal passed to the server as <literal>E'\\001'</literal>
    becomes <literal>\001</literal> after passing through the
    escape string parser. The <literal>\001</literal> is then sent
    to the <type>bytea</type> input function, where it is converted
    to a single octet with a decimal value of 1.  Note that the
    single-quote character is not treated specially by <type>bytea</type>,
    so it follows the normal rules for string literals.  (See also
    <xref linkend="sql-syntax-strings">.)
   </para>
-->
<para>
你必须写这么多反斜杠的原因，如<xref linkend="datatype-binary-sqlesc">所示，
是因为一个写成字符串文本的输入字符串必须通过<productname>PostgreSQL</productname>
服务器里的两个分析阶段。每一对反斜杠中的第一个会被字符串文本分析器理解成一个转义字符而消耗掉，
于是剩下的第二个反斜杠被<type>bytea</type>输入函数当作一个三位八进制值或者是转义另外一个反斜杠的开始。
比如，一个传递给服务器的字符串文本<literal>E'\\001'</literal>在通过字符串分析器之后会当作<literal>\001</literal>
发送给<type>bytea</type>输入函数，在这里它被转换成一个十进制值为 1 的单个字节。请注意，
单引号字符(')不会被<type>bytea</type>特殊对待，它遵循字符串文本的普通规则。又见<xref linkend="sql-syntax-strings">。
</para>

   <!--
<para>
    <type>Bytea</type> octets are sometimes escaped when output. In general, each
    <quote>non-printable</quote> octet is converted into
    its equivalent three-digit octal value and preceded by one backslash.
    Most <quote>printable</quote> octets are represented by their standard
    representation in the client character set. The octet with decimal
    value 92 (backslash) is doubled in the output.
    Details are in <xref linkend="datatype-binary-resesc">.
   </para>
-->
<para>
<type>Bytea</type>字节也在输出中转义。通常，每个<quote>不可打印</quote>
的字节值都转化成对应的前导反斜杠的三位八进制数值。大多数<quote>可打印的</quote>
字节值是以客户端字符集的标准表现形式出现的。十进制值为 92(反斜杠)的字节在输出中双写。
细节在<xref linkend="datatype-binary-resesc">里描述。
</para>

   <table id="datatype-binary-resesc">
    <!-- 
<title><type>bytea</> Output Escaped Octets</title> 
-->
<title><type>bytea</>输出转义序列</title>
    <tgroup cols="5">
     <thead>
      <row>
       <!-- 
   <entry>Decimal Octet Value</entry>
       <entry>Description</entry>
       <entry>Escaped Output Representation</entry>
       <entry>Example</entry>
       <entry>Output Result</entry> 
   -->
   <entry>字节的十进制值</entry>
       <entry>描述</entry>
       <entry>转义的输出形式</entry>
       <entry>例子</entry>
       <entry>输出结果</entry>
      </row>
     </thead>

     <tbody>

      <row>
       <entry>92</entry>
       <!-- 
   <entry>backslash</entry>
   -->
   <entry>反斜杠</entry>
       <entry><literal>\\</literal></entry>
       <entry><literal>SELECT E'\\134'::bytea;</literal></entry>
       <entry><literal>\\</literal></entry>
      </row>

      <row>
       <entry>0 to 31 and 127 to 255</entry>
       <!-- 
   <entry><quote>non-printable</quote> octets</entry>
       <entry><literal>\<replaceable>xxx</></literal> (octal value)</entry> 
   -->
   <entry><quote>不可打印</quote>八进制字符</entry>
       <entry><literal>\<replaceable>xxx</></literal> (八进制值)</entry>
       <entry><literal>SELECT E'\\001'::bytea;</literal></entry>
       <entry><literal>\001</literal></entry>
      </row>

      <row>
       <entry>32 to 126</entry>
       <!-- 
   <entry><quote>printable</quote> octets</entry>
       <entry>client character set representation</entry> 
   -->
   <entry><quote>可打印</quote>八进制字符</entry>
       <entry>客户端字符集表现形式</entry>
       <entry><literal>SELECT E'\\176'::bytea;</literal></entry>
       <entry><literal>~</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <!--
<para>
    Depending on the front end to <productname>PostgreSQL</> you use,
    you might have additional work to do in terms of escaping and
    unescaping <type>bytea</type> strings. For example, you might also
    have to escape line feeds and carriage returns if your interface
    automatically translates these.
   </para>
-->
<para>
根据你使用的前端不同，在是否转义<type>bytea</type>字符串的问题上你可能有一些额外的工作要做。
比如，如果你的接口自动转换换行和回车，那你可能还要转义它们。
</para>
  </sect2>
 </sect1>


  <sect1 id="datatype-datetime">
   <!-- 
   <title>Date/Time Types</title> 
   -->
   <title>日期/时间类型</title>

   <indexterm zone="datatype-datetime">
    <!-- 
<primary>date</primary> 
-->
<primary>日期</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <!-- 
<primary>time</primary> 
-->
<primary>时间</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <!-- 
<primary>time without time zone</primary> 
-->
<primary>无时区</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <!-- 
<primary>time with time zone</primary> 
-->
<primary>有时区</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <!-- 
<primary>timestamp</primary>
-->
<primary>时间戳</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>timestamptz</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <!-- 
<primary>timestamp with time zone</primary> 
-->
<primary>带时区的时间戳</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <!-- 
<primary>timestamp without time zone</primary> 
-->
<primary>不带时区的时间戳</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <!-- 
<primary>interval</primary> 
-->
<primary>间隔</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <!-- 
<primary>time span</primary> 
-->
<primary>时间间隔</primary>
   </indexterm>

   <!--
<para>
    <productname>PostgreSQL</productname> supports the full set of
    <acronym>SQL</acronym> date and time types, shown in <xref
    linkend="datatype-datetime-table">.  The operations available
    on these data types are described in
    <xref linkend="functions-datetime">.
    Dates are counted according to the Gregorian calendar, even in
    years before that calendar was introduced (see <xref
    linkend="datetime-units-history"> for more information).
   </para>
-->
<para>
<xref linkend="datatype-datetime-table">显示了<productname>PostgreSQL</productname>
支持的<acronym>SQL</acronym>中所有日期和时间类型。
这些数据类型上可以进行的操作在<xref linkend="functions-datetime">中描述。
日期是按照公历计算的，甚至日历之前的年份也介绍了
（参阅<xref linkend="datetime-units-history">获取更多信息）。
</para>

    <table id="datatype-datetime-table">
     <!-- 
 <title>Date/Time Types</title> 
 -->
 <title>日期/时间类型</title>
     <tgroup cols="6">
      <thead>
       <row>
        <!-- 
<entry>Name</entry>
        <entry>Storage Size</entry>
        <entry>Description</entry>
        <entry>Low Value</entry>
        <entry>High Value</entry>
        <entry>Resolution</entry> 
-->
<entry>名字</entry>
        <entry>存储空间</entry>
        <entry>描述</entry>
        <entry>最低值</entry>
        <entry>最高值</entry>
        <entry>分辨率</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><type>timestamp [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
        <!-- 
<entry>8 bytes</entry>
        <entry>both date and time (no time zone)</entry>
        <entry>4713 BC</entry>
        <entry>294276 AD</entry>
        <entry>1 microsecond / 14 digits</entry> 
-->
<entry>8 字节</entry>
        <entry>日期和时间(无时区)</entry>
        <entry>4713 BC</entry>
        <entry>294276 AD</entry>
        <entry>1 毫秒 / 14 位</entry>
       </row>
       <row>
        <entry><type>timestamp [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
        <!-- 
<entry>8 bytes</entry>
        <entry>both date and time, with time zone</entry>
        <entry>4713 BC</entry>
        <entry>294276 AD</entry>
        <entry>1 microsecond / 14 digits</entry> 
-->
<entry>8 字节</entry>
        <entry>日期和时间，有时区</entry>
        <entry>4713 BC</entry>
        <entry>294276 AD</entry>
        <entry>1 毫秒 / 14 位</entry>
       </row>
       <row>
        <entry><type>date</type></entry>
        <!-- 
<entry>4 bytes</entry>
        <entry>date (no time of day)</entry>
        <entry>4713 BC</entry>
        <entry>5874897 AD</entry>
        <entry>1 day</entry> 
-->
<entry>4 字节</entry>
        <entry>只用于日期</entry>
        <entry>4713 BC</entry>
        <entry>5874897 AD</entry>
        <entry>1 天</entry>
       </row>
       <row>
        <entry><type>time [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
        <!-- 
<entry>8 bytes</entry>
        <entry>time of day (no date)</entry>
        <entry>00:00:00</entry>
        <entry>24:00:00</entry>
        <entry>1 microsecond / 14 digits</entry>
-->
<entry>8 字节</entry>
        <entry>只用于一日内时间</entry>
        <entry>00:00:00</entry>
        <entry>24:00:00</entry>
        <entry>1 毫秒 / 14 位</entry>
       </row>
       <row>
        <entry><type>time [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
        <!-- 
<entry>12 bytes</entry>
        <entry>times of day only, with time zone</entry>
        <entry>00:00:00+1459</entry>
        <entry>24:00:00-1459</entry>
        <entry>1 microsecond / 14 digits</entry> 
-->
<entry>12 字节</entry>
        <entry>只用于一日内时间，带时区</entry>
        <entry>00:00:00+1459</entry>
        <entry>24:00:00-1459</entry>
        <entry>1 毫秒 / 14 位</entry>
       </row>
       <row>
        <entry><type>interval [ <replaceable>fields</replaceable> ] [ (<replaceable>p</replaceable>) ]</type></entry>
        <!-- 
<entry>16 bytes</entry>
        <entry>time interval</entry>
        <entry>-178000000 years</entry>
        <entry>178000000 years</entry>
        <entry>1 microsecond / 14 digits</entry> 
-->
<entry>16 字节</entry>
        <entry>时间间隔</entry>
        <entry>-178000000 年</entry>
        <entry>178000000 年</entry>
        <entry>1 毫秒 / 14 位</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <note>
    <!--
<para>
     The SQL standard requires that writing just <type>timestamp</type>
     be equivalent to <type>timestamp without time
     zone</type>, and <productname>PostgreSQL</productname> honors that
     behavior.<type>timestamptz</type> is accepted as an
     abbreviation for <type>timestamp with time zone</type>; this is a
     <productname>PostgreSQL</productname> extension.
    </para>
-->
<para>

SQL标准要求仅仅将<type>timestamp</type>类型等于<type>timestamp without time zone</type>
类型，<productname>PostgreSQL</productname>遵守这个行为。
<type>timestamptz</type>作为
<type>timestamp with time zone</type>的缩写被接受；这是<productname>PostgreSQL</productname>
的一个扩展。
</para>
   </note>

   <!--
<para>
    <type>time</type>, <type>timestamp</type>, and
    <type>interval</type> accept an optional precision value
    <replaceable>p</replaceable> which specifies the number of
    fractional digits retained in the seconds field. By default, there
    is no explicit bound on precision.  The allowed range of
    <replaceable>p</replaceable> is from 0 to 6 for the
    <type>timestamp</type> and <type>interval</type> types.
   </para>
-->
<para>
<type>time</type>, <type>timestamp</type>和<type>interval</type>接受一个可选的精度值
<replaceable>p</replaceable>以指明秒域中小数部分的位数。没有明确的缺省精度，
<replaceable>p</replaceable>的范围对<type>timestamp</type>和<type>interval</type>类型是从0到6。 

</para>

   <note>
   <!--
<para>
    When <type>timestamp</> values are stored as eight-byte integers
    (currently the default), microsecond precision is available over
    the full range of values. When <type>timestamp</> values are
    stored as double precision floating-point numbers instead (a
    deprecated compile-time option), the effective limit of precision
    might be less than 6. <type>timestamp</type> values are stored as
    seconds before or after midnight 2000-01-01.  When
    <type>timestamp</type> values are implemented using floating-point
    numbers, microsecond precision is achieved for dates within a few
    years of 2000-01-01, but the precision degrades for dates further
    away. Note that using floating-point datetimes allows a larger
    range of <type>timestamp</type> values to be represented than
    shown above: from 4713 BC up to 5874897 AD.
   </para>
-->
<para>
如果<type>timestamp</>数值是以8字节整数(目前的缺省)的方式存储的，
那么微秒的精度就可以在数值的全部范围内都可以获得。如果<type>timestamp</>
数值是以双精度浮点数(一个废弃的编译时的选项)的方式存储的，
那么有效精度会小于 6 。<type>timestamp</type>值是以 2000-01-01 午夜之前或之后的秒数存储的。
当<type>timestamp</type>值用浮点数实现时，微秒的精度是为那些在 2000-01-01 前后几年的日期实现的，
对于那些远一些的日子，精度会下降。注意，使用浮点时间允许一个比上面显示的更大的
<type>timestamp</type>值变化范围：从4713BC到5874897AD。
</para>

   <!--
<para>
    The same compile-time option also determines whether
    <type>time</type> and <type>interval</type> values are stored as
    floating-point numbers or eight-byte integers.  In the
    floating-point case, large <type>interval</type> values degrade in
    precision as the size of the interval increases.
   </para>
-->
<para>
同一个编译时选项也决定<type>time</type>和<type>interval</type>值是保存成浮点数还是八字节整数。
在以浮点数存储的时候，随着时间间隔的增加，大的 <type>interval</type>数值的精度会降低。
</para>
   </note>

   <!--
<para>
    For the <type>time</type> types, the allowed range of
    <replaceable>p</replaceable> is from 0 to 6 when eight-byte integer
    storage is used, or from 0 to 10 when floating-point storage is used.
   </para>
-->
<para>
对于<type>time</type>类型，如果使用了八字节的整数存储，那么<replaceable>p</replaceable>
允许的范围是从 0 到 6 ，如果使用的是浮点数存储，那么这个范围是 0 到 10 。
</para>

   
<para>
<!--
    The <type>interval</type> type has an additional option, which is
    to restrict the set of stored fields by writing one of these phrases:
-->
<type>interval</type>类型有一个额外的选项，通过下下面词组之一限制存储的字段值：
<literallayout class="monospaced">
YEAR
MONTH
DAY
HOUR
MINUTE
SECOND
YEAR TO MONTH
DAY TO HOUR
DAY TO MINUTE
DAY TO SECOND
HOUR TO MINUTE
HOUR TO SECOND
MINUTE TO SECOND
</literallayout>
<!-- 
    Note that if both <replaceable>fields</replaceable> and
    <replaceable>p</replaceable> are specified, the
    <replaceable>fields</replaceable> must include <literal>SECOND</>,
    since the precision applies only to the seconds. 
-->
注意如果同时指定了<replaceable>fields</replaceable>和<replaceable>p</replaceable>，
<replaceable>fields</replaceable>必须包含<literal>SECOND</>，因为精度只应用于秒。
   </para>


   <!--
<para>
    The type <type>time with time zone</type> is defined by the SQL
    standard, but the definition exhibits properties which lead to
    questionable usefulness. In most cases, a combination of
    <type>date</type>, <type>time</type>, <type>timestamp without time
    zone</type>, and <type>timestamp with time zone</type> should
    provide a complete range of date/time functionality required by
    any application.
   </para>
-->
<para>
<type>time with time zone</type>类型是 SQL 标准定义的，
但是完整定义的有些方面会导致有问题的用法。在大多数情况下，<type>date</type>, <type>time</type>,
 <type>timestamp without time zone</type>, 和<type>timestamp with time zone</type>
 的组合就应该能提供一切应用需要的日期/时间的完整功能。
</para>

   <!--
<para>
    The types <type>abstime</type>
    and <type>reltime</type> are lower precision types which are used internally.
    You are discouraged from using these types in
    applications;  these internal types
    might disappear in a future release.
   </para>
-->
<para>
<type>abstime</type>和<type>reltime</type>类型是低分辨率类型，它们被用于系统内部。
我们反对你在应用中使用这些类型，因为这些内部类型可能会在未来的版本里消失。
</para>

   <sect2 id="datatype-datetime-input">
    <!-- 
<title>Date/Time Input</title>
-->
<title>日期/时间输入</title>

    <!--
<para>
     Date and time input is accepted in almost any reasonable format, including
     ISO 8601, <acronym>SQL</acronym>-compatible,
     traditional <productname>POSTGRES</productname>, and others.
     For some formats, ordering of day, month, and year in date input is
     ambiguous and there is support for specifying the expected
     ordering of these fields.  Set the <xref linkend="guc-datestyle"> parameter
     to <literal>MDY</> to select month-day-year interpretation,
     <literal>DMY</> to select day-month-year interpretation, or
     <literal>YMD</> to select year-month-day interpretation.
    </para>
-->
<para>
日期和时间的输入几乎可以是任何合理的格式，包括 ISO-8601 格式、<acronym>SQL</acronym>-兼容格式、
传统<productname>POSTGRES</productname>格式、其它的形式。对于一些格式，
日期输入里的日、月、年可能会让人迷惑，因此系统支持自定义这些字段的顺序。
把<xref linkend="guc-datestyle">参数设置为<literal>MDY</>就按照"月-日-年"解析，
设置为<literal>DMY</>就按照"日-月-年"解析，设置为<literal>YMD</>就按照"年-月-日"解析。
</para>

    <!--
<para>
     <productname>PostgreSQL</productname> is more flexible in
     handling date/time input than the
     <acronym>SQL</acronym> standard requires.
     See <xref linkend="datetime-appendix">
     for the exact parsing rules of date/time input and for the
     recognized text fields including months, days of the week, and
     time zones.
    </para>
-->
<para>
<productname>PostgreSQL</productname>在处理日期/时间输入上比<acronym>SQL</acronym>
标准要求的更灵活。参阅<xref linkend="datetime-appendix">
获取关于日期/时间输入的准确分析规则和可识别文本字段，包括月份、星期几、时区。
</para>

    
<para>
<!--
     Remember that any date or time literal input needs to be enclosed
     in single quotes, like text strings.  Refer to
     <xref linkend="sql-syntax-constants-generic"> for more
     information.
     <acronym>SQL</acronym> requires the following syntax
 -->
请记住任何日期或者时间的文本输入需要由单引号包围，就像一个文本字符串一样。
参考<xref linkend="sql-syntax-constants-generic">获取更多信息。
<acronym>SQL</acronym>要求使用下面的语法： 
<synopsis>
<replaceable>type</replaceable> [ (<replaceable>p</replaceable>) ] '<replaceable>value</replaceable>'
</synopsis>
<!-- 
     where <replaceable>p</replaceable> is an optional precision
     specification giving the number of
     fractional digits in the seconds field. Precision can be
     specified for <type>time</type>, <type>timestamp</type>, and
     <type>interval</type> types.  The allowed values are mentioned
     above.  If no precision is specified in a constant specification,
     it defaults to the precision of the literal value. 
 -->
可选的精度声明中的<replaceable>p</replaceable>是一个整数，表示在秒域中小数部分的位数，
我们可以对<type>time</type>,<type>timestamp</type>,<type>interval</type>类型声明精度。
允许的精度在上面已经说明。如果在常量声明中没有声明精度，缺省是文本值的精度。 
    </para>

    <sect3>
    <!-- 
<title>Dates</title> 
-->
<title>日期</title>

    <indexterm>
     <!-- 
 <primary>date</primary> 
 -->
 <primary>日期</primary>
    </indexterm>

    <!--
<para>
     <xref linkend="datatype-datetime-date-table"> shows some possible
     inputs for the <type>date</type> type.
    </para>
-->
<para>
<xref linkend="datatype-datetime-date-table">显示了<type>date</type>类型可能的输入方式。
</para>

     <table id="datatype-datetime-date-table">
      <!-- 
      <title>Date Input</title> 
      -->
      <title>日期输入</title>
      <tgroup cols="2">
       <thead>
        <row>
         <!-- 
 <entry>Example</entry>
         <entry>Description</entry> 
 -->
 <entry>例子</entry>
         <entry>描述</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>1999-01-08</entry>
         <!-- 
 <entry>ISO 8601; January 8 in any mode
         (recommended format)</entry> 
 -->
 <entry>ISO 8601格式(建议格式)，任何方式下都是 1999 年 1 月 8 号</entry>
        </row>
        <row>
         <entry>January 8, 1999</entry>
         <!-- 
 <entry>unambiguous in any <varname>datestyle</varname> input mode</entry> 
 -->
 <entry>在任何<varname>datestyle</varname>输入模式下都无歧义</entry>
        </row>
        <row>
         <entry>1/8/1999</entry>
         <!-- 
 <entry>January 8 in <literal>MDY</> mode;
          August 1 in <literal>DMY</> mode</entry> 
  -->
  <entry>有歧义，在<literal>MDY</>下是一月八号；在<literal>DMY</>模式下是八月一日</entry>
        </row>
        <row>
         <entry>1/18/1999</entry>
         <!-- 
 <entry>January 18 in <literal>MDY</> mode;
          rejected in other modes</entry> 
  -->
  <entry><literal>MDY</>模式下是一月十八日，其它模式下被拒绝</entry>
        </row>
        <row>
         <entry>01/02/03</entry>
         <!-- 
 <entry>January 2, 2003 in <literal>MDY</> mode;
          February 1, 2003 in <literal>DMY</> mode;
          February 3, 2001 in <literal>YMD</> mode
         </entry> 
 -->
 <entry><literal>MDY</>模式下的 2003 年 1 月 2 日；
 <literal>DMY</>模式下的 2003 年 2 月 1 日；
 <literal>YMD</>模式下的 2001 年 2 月 3 日
         </entry>
        </row>
        <row>
         <entry>1999-Jan-08</entry>
         <!-- 
 <entry>January 8 in any mode</entry> 
 -->
 <entry>任何模式下都是 1 月 8 日</entry>
        </row>
        <row>
         <entry>Jan-08-1999</entry>
         <!-- 
 <entry>January 8 in any mode</entry> 
 -->
 <entry>任何模式下都是 1 月 8 日</entry>
        </row>
        <row>
         <entry>08-Jan-1999</entry>
         <!-- 
 <entry>January 8 in any mode</entry> 
 -->
 <entry>任何模式下都是 1 月 8 日</entry>
        </row>
        <row>
         <entry>99-Jan-08</entry>
         <!-- 
 <entry>January 8 in <literal>YMD</> mode, else error</entry> 
 -->
 <entry><literal>YMD</>模式下是 1 月 8 日，否则错误</entry>
        </row>
        <row>
         <entry>08-Jan-99</entry>
         <!-- 
 <entry>January 8, except error in <literal>YMD</> mode</entry> 
 -->
 <entry>一月八日，除了在<literal>YMD</>模式下是错误的之外</entry>
        </row>
        <row>
         <entry>Jan-08-99</entry>
         <!-- 
 <entry>January 8, except error in <literal>YMD</> mode</entry> 
 -->
 <entry>一月八日，除了在<literal>YMD</>模式下是错误的之外</entry>
        </row>
        <row>
         <entry>19990108</entry>
         <!-- 
 <entry>ISO 8601; January 8, 1999 in any mode</entry>
 -->
 <entry>ISO 8601；任何模式下都是 1999 年 1 月 8 日</entry>
        </row>
        <row>
         <entry>990108</entry>
         <!-- 
 <entry>ISO 8601; January 8, 1999 in any mode</entry>
 -->
 <entry>ISO 8601；任何模式下都是 1999 年 1 月 8 日</entry>
        </row>
        <row>
         <entry>1999.008</entry>
         <!-- 
 <entry>year and day of year</entry> 
 -->
 <entry>年和年里的第几天</entry>
        </row>
        <row>
         <entry>J2451187</entry>
         <!-- 
 <entry>Julian date</entry> 
 -->
 <entry>儒略日</entry>
        </row>
        <row>
         <entry>January 8, 99 BC</entry>
         <!-- 
 <entry>year 99 BC</entry> 
 -->
 <entry>公元前 99 年</entry> 
        </row>
       </tbody>
      </tgroup>
     </table>
    </sect3>

    <sect3>
     <!-- 
 <title>Times</title> 
 -->
 <title>时间</title>

     <indexterm>
      <!-- 
  <primary>time</primary> 
  -->
  <primary>时间</primary>
     </indexterm>
     <indexterm>
      <!-- 
  <primary>time without time zone</primary> 
  -->
  <primary>无时区时间</primary>
     </indexterm>
     <indexterm>
      <!-- 
  <primary>time with time zone</primary> 
  -->
  <primary>有时区时间</primary>
     </indexterm>

     <!--
<para>
      The time-of-day types are <type>time [
      (<replaceable>p</replaceable>) ] without time zone</type> and
      <type>time [ (<replaceable>p</replaceable>) ] with time
      zone</type>.  <type>time</type> alone is equivalent to
      <type>time without time zone</type>.
     </para>
-->
<para>
当日时间类型是<type>time [ (<replaceable>p</replaceable>) ] without time zone</type>
和<type>time [ (<replaceable>p</replaceable>) ] with time zone</type>。
只写<type>time</type>等效于<type>time without time zone</type>。
</para>

     <!--
<para>
      Valid input for these types consists of a time of day followed
      by an optional time zone. (See <xref
      linkend="datatype-datetime-time-table">
      and <xref linkend="datatype-timezone-table">.)  If a time zone is
      specified in the input for <type>time without time zone</type>,
      it is silently ignored. You can also specify a date but it will
      be ignored, except when you use a time zone name that involves a
      daylight-savings rule, such as
      <literal>America/New_York</literal>. In this case specifying the date
      is required in order to determine whether standard or daylight-savings
      time applies.  The appropriate time zone offset is recorded in the
      <type>time with time zone</type> value.
     </para>
-->
<para>
这些类型的有效输入由当日时间后面跟着可选的时区组成(参阅
<xref linkend="datatype-datetime-time-table">和<xref linkend="datatype-timezone-table">)。
如果在<type>time without time zone</type>类型的输入中声明了时区，那么它会被悄悄地忽略。
同样指定的日期也会被忽略，除非使用了一个包括夏令时规则的时区名，比如
<literal>America/New_York</literal>，在这种情况下，
必须指定日期以确定这个时间是标准时间还是夏令时。时区偏移将记录在
<type>time with time zone</type>中。
</para>

      <table id="datatype-datetime-time-table">
       <!-- 
   <title>Time Input</title> 
   -->
   <title>时间输入</title>
       <tgroup cols="2">
        <thead>
         <row>
          <!-- 
  <entry>Example</entry>
          <entry>Description</entry> 
  -->
  <entry>例子</entry>
          <entry>描述</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><literal>04:05:06.789</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05:06</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>040506</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05 AM</literal></entry>
          <!-- 
  <entry>same as 04:05; AM does not affect value</entry> 
  -->
  <entry>与 04:05 一样；AM 不影响数值</entry>
         </row>
         <row>
          <entry><literal>04:05 PM</literal></entry>
          <!-- 
  <entry>same as 16:05; input hour must be &lt;= 12</entry> 
  -->
  <entry>与 16:05 一样；输入小时数必须&lt;= 12</entry>
         </row>
         <row>
          <entry><literal>04:05:06.789-8</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05:06-08:00</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05-08:00</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>040506-08</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05:06 PST</literal></entry>
          <!-- 
  <entry>time zone specified by abbreviation</entry> 
  -->
  <entry>缩写的时区</entry>
         </row>
         <row>
          <entry><literal>2003-04-12 04:05:06 America/New_York</literal></entry>
          <!-- 
  <entry>time zone specified by full name</entry> 
  -->
  <entry>用名字声明的时区</entry>
         </row>
        </tbody>
       </tgroup>
      </table>

      <table tocentry="1" id="datatype-timezone-table">
       <!-- 
   <title>Time Zone Input</title> 
   -->
   <title>时区输入</title>
       <tgroup cols="2">
        <thead>
         <row>
          <!-- 
  <entry>Example</entry>
          <entry>Description</entry> 
  -->
  <entry>例子</entry>
          <entry>描述</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><literal>PST</literal></entry>
          <!-- 
  <entry>Abbreviation (for Pacific Standard Time)</entry> 
  -->
  <entry>太平洋标准时间(Pacific Standard Time)</entry>
         </row>
         <row>
          <entry><literal>America/New_York</literal></entry>
          <!-- 
  <entry>Full time zone name</entry> 
  -->
  <entry>完整时区名称</entry>
         </row>
         <row>
          <entry><literal>PST8PDT</literal></entry>
          <!-- 
  <entry>POSIX-style time zone specification</entry> 
  -->
  <entry>POSIX 风格的时区</entry>
         </row>
         <row>
          <entry><literal>-8:00</literal></entry>
          <!-- 
  <entry>ISO-8601 offset for PST</entry> 
  -->
  <entry>ISO-8601 与 PST 的偏移</entry>
         </row>
         <row>
          <entry><literal>-800</literal></entry>
          <!-- 
  <entry>ISO-8601 offset for PST</entry> 
  -->
  <entry>ISO-8601 与 PST 的偏移</entry>
         </row>
         <row>
          <entry><literal>-8</literal></entry>
          <!-- 
  <entry>ISO-8601 offset for PST</entry> 
  -->
  <entry>ISO-8601 与 PST 的偏移</entry>
         </row>
         <row>
          <entry><literal>zulu</literal></entry>
          <!-- 
  <entry>Military abbreviation for UTC</entry> 
  -->
  <entry>军方对 UTC 的缩写(译注：可能是美军)</entry>
         </row>
         <row>
          <entry><literal>z</literal></entry>
          <!-- 
  <entry>Short form of <literal>zulu</literal></entry> 
  -->
  <entry><literal>zulu</literal>的缩写</entry>
         </row>
        </tbody>
       </tgroup>
      </table>

     <!--
<para>
     Refer to <xref linkend="datatype-timezones"> for more information on how
     to specify time zones.
    </para>
-->
<para>
参考<xref linkend="datatype-timezones">以获取如何指定时区的更多信息。
</para>
    </sect3>

    <sect3>
    <!-- 
<title>Time Stamps</title> 
-->
<title>时间戳</title>

    <indexterm>
     <!-- 
 <primary>timestamp</primary> 
 -->
 <primary>时间戳</primary>
    </indexterm>

    <indexterm>
     <!-- 
 <primary>timestamp with time zone</primary> 
 -->
 <primary>有时区的时间戳</primary>
    </indexterm>

    <indexterm>
     <!-- 
 <primary>timestamp without time zone</primary> 
 -->
 <primary>无时区的时间戳</primary>
    </indexterm>

     
<para>
<!--
      Valid input for the time stamp types consists of the concatenation
      of a date and a time, followed by an optional time zone,
      followed by an optional <literal>AD</literal> or <literal>BC</literal>.
      (Alternatively, <literal>AD</literal>/<literal>BC</literal> can appear
      before the time zone, but this is not the preferred ordering.)
      Thus:
-->
时间戳类型的有效输入由一个日期和时间的连接组成，后面跟着一个可选的时区，
一个可选的<literal>AD</literal>或<literal>BC</literal>。另外，
<literal>AD</literal>/<literal>BC</literal>可以出现在时区前面，
但这个顺序并非最佳的。因此：
<programlisting>
1999-01-08 04:05:06
</programlisting>
      <!-- 
  and: 
  -->
和：
<programlisting>
1999-01-08 04:05:06 -8:00
</programlisting>

<!-- 
      are valid values, which follow the <acronym>ISO</acronym> 8601
      standard.  In addition, the common format: 
  -->
都是有效的数值，它是兼容<acronym>ISO</acronym>-8601 的。另外，
也支持下面这种使用广泛的格式：  
<programlisting>
January 8 04:05:06 1999 PST
</programlisting>
      <!-- 
  is supported. 
  -->
     </para>

     <!--
<para>
      The <acronym>SQL</acronym> standard differentiates
      <type>timestamp without time zone</type>
      and <type>timestamp with time zone</type> literals by the presence of a
      <quote>+</quote> or <quote>-</quote> symbol and time zone offset after
      the time.  Hence, according to the standard,
      <programlisting>TIMESTAMP '2004-10-19 10:23:54'</programlisting>
      is a <type>timestamp without time zone</type>, while
      <programlisting>TIMESTAMP '2004-10-19 10:23:54+02'</programlisting>
      is a <type>timestamp with time zone</type>.
      <productname>PostgreSQL</productname> never examines the content of a
      literal string before determining its type, and therefore will treat
      both of the above as <type>timestamp without time zone</type>.  To
      ensure that a literal is treated as <type>timestamp with time
      zone</type>, give it the correct explicit type:
      <programlisting>TIMESTAMP WITH TIME ZONE '2004-10-19 10:23:54+02'</programlisting>
      In a literal that has been determined to be <type>timestamp without time
      zone</type>, <productname>PostgreSQL</productname> will silently ignore
      any time zone indication.
      That is, the resulting value is derived from the date/time
      fields in the input value, and is not adjusted for time zone.
     </para>
-->
<para>
<acronym>SQL</acronym>标准通过<quote>+</quote>或者<quote>-</quote>是否存在和时间后的失去偏移来区分
<type>timestamp without time zone</type>和<type>timestamp with time zone</type>文本。因此，
根据标准，<programlisting>TIMESTAMP '2004-10-19 10:23:54'</programlisting>是一个
<type>timestamp without time zone</type>，而<programlisting>TIMESTAMP '2004-10-19 10:23:54+02'</programlisting>
是一个<type>timestamp with time zone</type>。<productname>PostgreSQL</productname>
从来不会在确定文本的类型之前检查文本内容，因此会把上面两个都看做是
<type>timestamp without time zone</type>。因此要保证把上面的第二个当作
<type>timestamp with time zone</type>看待，就要给它明确的类型：
<programlisting>TIMESTAMP WITH TIME ZONE '2004-10-19 10:23:54+02'</programlisting>
如果一个文本已被确定是<type>timestamp without time zone</type>，<productname>PostgreSQL</productname>
将悄悄忽略任何文本中指出的时区。因此，生成的日期/时间值是从输入值的日期/时间字段衍生出来的，
并且没有就时区进行调整。
</para>

     <!--
<para>
      For <type>timestamp with time zone</type>, the internally stored
      value is always in UTC (Universal
      Coordinated Time, traditionally known as Greenwich Mean Time,
      <acronym>GMT</>).  An input value that has an explicit
      time zone specified is converted to UTC using the appropriate offset
      for that time zone.  If no time zone is stated in the input string,
      then it is assumed to be in the time zone indicated by the system's
      <xref linkend="guc-timezone"> parameter, and is converted to UTC using the
      offset for the <varname>timezone</> zone.
     </para>
-->
<para>
对于<type>timestamp with time zone</type>，内部存储的数值总是 UTC(全球统一时间，
以前也叫格林威治时间<acronym>GMT</>)。如果一个输入值有明确的时区声明，
那么它将用该时区合适的偏移量转换成 UTC 。如果在输入字符串里没有时区声明，
那么它就假设是在系统的<xref linkend="guc-timezone">参数里的那个时区，
然后使用这个<varname>timezone</>时区转换成 UTC 。
</para>

     <!--
<para>
      When a <type>timestamp with time
      zone</type> value is output, it is always converted from UTC to the
      current <varname>timezone</> zone, and displayed as local time in that
      zone.  To see the time in another time zone, either change
      <varname>timezone</> or use the <literal>AT TIME ZONE</> construct
      (see <xref linkend="functions-datetime-zoneconvert">).
     </para>
-->
<para>
如果输出一个<type>timestamp with time zone</type>，那么它总是从 UTC 转换成当前的
<varname>timezone</>时区，并且显示为该时区的本地时间。要看其它时区的该时间，
要么修改<varname>timezone</>，要么使用<literal>AT TIME ZONE</>构造
(参阅<xref linkend="functions-datetime-zoneconvert">)。
</para>

     <!--
<para>
      Conversions between <type>timestamp without time zone</type> and
      <type>timestamp with time zone</type> normally assume that the
      <type>timestamp without time zone</type> value should be taken or given
      as <varname>timezone</> local time.  A different time zone can
      be specified for the conversion using <literal>AT TIME ZONE</>.
     </para>
-->
<para>
在<type>timestamp without time zone</type>和<type>timestamp with time zone</type>
之间的转换通常假设<type>timestamp without time zone</type>数值应该以
<varname>timezone</>本地时间的形式接受或者写出。其它的时区可以用
<literal>AT TIME ZONE</>的方式为转换声明。
</para>
    </sect3>

    <sect3>
     <!-- 
 <title>Special Values</title> 
 -->
 <title>特殊值</title>

     <indexterm>
      <!-- 
  <primary>time</primary>
      <secondary>constants</secondary> 
  -->
  <primary>时间</primary>
      <secondary>常量</secondary>
     </indexterm>

     <indexterm>
      <!-- 
  <primary>date</primary>
      <secondary>constants</secondary> 
  -->
  <primary>日期</primary>
      <secondary>常量</secondary>
     </indexterm>

     <!--
<para>
      <productname>PostgreSQL</productname> supports several
      special date/time input values for convenience, as shown in <xref
      linkend="datatype-datetime-special-table">.  The values
      <literal>infinity</literal> and <literal>-infinity</literal>
      are specially represented inside the system and will be displayed
      unchanged; but the others are simply notational shorthands
      that will be converted to ordinary date/time values when read.
      (In particular, <literal>now</> and related strings are converted
      to a specific time value as soon as they are read.)
      All of these values need to be enclosed in single quotes when used
      as constants in SQL commands.
     </para>
-->
<para>
<productname>PostgreSQL</productname>为方便起见支持在
<xref linkend="datatype-datetime-special-table">里面显示的几个特殊输入值。
值<literal>infinity</literal>和<literal>-infinity</literal>是特别在系统内部表示的，
并且将按照同样的方式显示；但是其它的都只是符号缩写，
在读取的时候将被转换成普通的日期/时间值。特别是<literal>now</>
和相关的字符串在读取的时候就被转换成对应的数值。
所有这些值在 SQL 命令里当作普通常量对待时，都需要包围在单引号里面。
</para>

      <table id="datatype-datetime-special-table">
       <!-- 
   <title>Special Date/Time Inputs</title> 
   -->
   <title>特殊日期/时间输入</title>
       <tgroup cols="3">
        <thead>
         <row>
          <!-- 
  <entry>Input String</entry>
          <entry>Valid Types</entry>
          <entry>Description</entry> 
  -->
  <entry>输入字符串</entry>
          <entry>适用类型</entry>
          <entry>描述</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><literal>epoch</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <!-- 
  <entry>1970-01-01 00:00:00+00 (Unix system time zero)</entry> 
  -->
  <entry>1970-01-01 00:00:00+00 (Unix 系统零时)</entry>
         </row>
         <row>
          <entry><literal>infinity</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <!-- 
  <entry>later than all other time stamps</entry> 
  -->
  <entry>比任何其它时间戳都晚</entry>
         </row>
         <row>
          <entry><literal>-infinity</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <!-- 
  <entry>earlier than all other time stamps</entry> 
  -->
  <entry>比任何其它时间戳都早</entry>
         </row>
         <row>
          <entry><literal>now</literal></entry>
          <entry><type>date</type>, <type>time</type>, <type>timestamp</type></entry>
          <!-- 
  <entry>current transaction's start time</entry> 
  -->
  <entry>当前事务的开始时间</entry>
         </row>
         <row>
          <entry><literal>today</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <!-- 
  <entry>midnight today</entry> 
  -->
  <entry>今日午夜</entry>
         </row>
         <row>
          <entry><literal>tomorrow</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <!-- 
  <entry>midnight tomorrow</entry>
  -->
  <entry>明日午夜</entry>
         </row>
         <row>
          <entry><literal>yesterday</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <!-- 
  <entry>midnight yesterday</entry> 
  -->
  <entry>昨日午夜</entry>
         </row>
         <row>
          <entry><literal>allballs</literal></entry>
          <entry><type>time</type></entry>
          <entry>00:00:00.00 UTC</entry>
         </row>
        </tbody>
       </tgroup>
      </table>

     <!--
<para>
      The following <acronym>SQL</acronym>-compatible functions can also
      be used to obtain the current time value for the corresponding data
      type:
      <literal>CURRENT_DATE</literal>, <literal>CURRENT_TIME</literal>,
      <literal>CURRENT_TIMESTAMP</literal>, <literal>LOCALTIME</literal>,
      <literal>LOCALTIMESTAMP</literal>.  The latter four accept an
      optional subsecond precision specification.  (See <xref
      linkend="functions-datetime-current">.)  Note that these are
      SQL functions and are <emphasis>not</> recognized in data input strings.
     </para>
-->
<para>
下列<acronym>SQL</acronym>兼容函数也可以用于获取对应数据类型的当前时间值：
<literal>CURRENT_DATE</literal>, <literal>CURRENT_TIME</literal>,
<literal>CURRENT_TIMESTAMP</literal>, <literal>LOCALTIME</literal>,
<literal>LOCALTIMESTAMP</literal>。后四个接受一个可选的精度声明(
<xref linkend="functions-datetime-current">)。不过，请注意这些 SQL 函数<emphasis>不是</>
被当作数据输入字符串识别的。
</para>

    </sect3>
   </sect2>

   <sect2 id="datatype-datetime-output">
    <!-- 
<title>Date/Time Output</title> 
-->
<title>日期/时间输出</title>

    <indexterm>
     <!-- 
 <primary>date</primary>
     <secondary>output format</secondary>
     <seealso>formatting</seealso> 
 -->
 <primary>日期</primary>
     <secondary>输出格式</secondary>
     <seealso>格式</seealso>
    </indexterm>

    <indexterm>
     <!-- 
 <primary>time</primary>
     <secondary>output format</secondary>
     <seealso>formatting</seealso> 
 -->
 <primary>时间</primary>
     <secondary>输出格式</secondary>
     <seealso>格式</seealso>
    </indexterm>

    <!--
<para>
     The output format of the date/time types can be set to one of the four
     styles ISO 8601,
     <acronym>SQL</acronym> (Ingres), traditional <productname>POSTGRES</>
     (Unix <application>date</> format), or
     German.  The default
     is the <acronym>ISO</acronym> format.  (The
     <acronym>SQL</acronym> standard requires the use of the ISO 8601
     format.  The name of the <quote>SQL</quote> output format is a
     historical accident.)  <xref
     linkend="datatype-datetime-output-table"> shows examples of each
     output style.  The output of the <type>date</type> and
     <type>time</type> types is generally only the date or time part
     in accordance with the given examples.  However, the
     <productname>POSTGRES</> style outputs date-only values in
     <acronym>ISO</acronym> format.
    </para>
-->
<para>
日期/时间类型的输出格式可以设成 ISO 8601(默认)、<acronym>SQL</acronym>(Ingres)、
传统的<productname>POSTGRES</>(Unix <application>date</>格式)或German四种风格之一。
<acronym>SQL</acronym>标准要求使用 ISO 8601 格式。<quote>SQL</quote>输出格式的名字是历史偶然。
<xref linkend="datatype-datetime-output-table">显示了每种输出风格的例子。
<type>date</type>和<type>time</type>类型的输出通常只是给出的例子里面的日期和时间部分。
不过，<productname>POSTGRES</>风格以<acronym>ISO</acronym>
格式只输出数据值。
</para>

     <table id="datatype-datetime-output-table">
      <!-- 
  <title>Date/Time Output Styles</title> 
  -->
  <title>日期/时间输出风格</title>
      <tgroup cols="3">
       <thead>
        <row>
         <!-- 
 <entry>Style Specification</entry>
         <entry>Description</entry>
         <entry>Example</entry>
 -->
 <entry>风格</entry>
         <entry>描述</entry>
         <entry>例子</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>ISO</literal></entry>
         <!-- 
 <entry>ISO 8601, SQL standard</entry> 
 -->
 <entry>ISO 8601，SQL 标准</entry>
         <entry><literal>1997-12-17 07:37:16-08</literal></entry>
        </row>
        <row>
         <entry><literal>SQL</literal></entry>
         <!-- 
 <entry>traditional style</entry> 
 -->
 <entry>传统风格</entry>
         <entry><literal>12/17/1997 07:37:16.00 PST</literal></entry>
        </row>
        <row>
         <entry><literal>Postgres</literal></entry>
         <!-- 
 <entry>original style</entry> 
 -->
 <entry>原始风格</entry>
         <entry><literal>Wed Dec 17 07:37:16 1997 PST</literal></entry>
        </row>
        <row>
         <entry><literal>German</literal></entry>
         <!-- 
 <entry>regional style</entry> 
 -->
 <entry>地区风格</entry>
         <entry><literal>17.12.1997 07:37:16.00 PST</literal></entry>
        </row>
       </tbody>
      </tgroup>
     </table>

    <note>
     <!--
<para>
      ISO 8601 specifies the use of uppercase letter <literal>T</> to separate
      the date and time.  <productname>PostgreSQL</> accepts that format on
      input, but on output it uses a space rather than <literal>T</>, as shown
      above.  This is for readability and for consistency with RFC 3339 as
      well as some other database systems.
     </para>
-->
<para>
ISO 8601指定用大写字母<literal>T</>分隔日期和时间。<productname>PostgreSQL</>
在输入上接受这种格式，但是在输出上使用一个空格而不是<literal>T</>，就像上面显示的。
这样更易读而且和RFC 3399或者其他的数据库系统一致。
</para>
    </note>

    <!--
<para>
     In the <acronym>SQL</acronym> and POSTGRES styles, day appears before
     month if DMY field ordering has been specified, otherwise month appears
     before day.
     (See <xref linkend="datatype-datetime-input">
     for how this setting also affects interpretation of input values.)
     <xref linkend="datatype-datetime-output2-table"> shows examples.
    </para>
-->
<para>
如果声明了 DMY 顺序，那么在<acronym>SQL</acronym>和 POSTGRES 风格里，
日期在月份之前出现，否则月份出现在日期之前(参阅<xref linkend="datatype-datetime-input">
看看这个设置如何影响对输入值的解释)。<xref linkend="datatype-datetime-output2-table">
显示了一个例子。
</para>

     <table id="datatype-datetime-output2-table">
      <!-- 
  <title>Date Order Conventions</title> 
  -->
  <title>日期顺序习惯</title>
      <tgroup cols="3">
       <thead>
        <row>
         <!-- 
 <entry><varname>datestyle</varname> Setting</entry>
         <entry>Input Ordering</entry>
         <entry>Example Output</entry> 
 -->
 <entry><varname>datestyle</varname>设置</entry>
         <entry>输入顺序</entry>
         <entry>输出样例</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>SQL, DMY</></entry>
         <!-- 
 <entry><replaceable>day</replaceable>/<replaceable>month</replaceable>/<replaceable>year</replaceable></entry>
 -->
 <entry><replaceable>日</replaceable>/<replaceable>月</replaceable>/<replaceable>年</replaceable></entry>
         <entry><literal>17/12/1997 15:37:16.00 CET</literal></entry>
        </row>
        <row>
         <entry><literal>SQL, MDY</></entry>
         <!-- 
 <entry><replaceable>month</replaceable>/<replaceable>day</replaceable>/<replaceable>year</replaceable></entry> 
 -->
 <entry><replaceable>月</replaceable>/<replaceable>日</replaceable>/<replaceable>年</replaceable></entry>
         <entry><literal>12/17/1997 07:37:16.00 PST</literal></entry>
        </row>
        <row>
         <entry><literal>Postgres, DMY</></entry>
         <!-- 
 <entry><replaceable>day</replaceable>/<replaceable>month</replaceable>/<replaceable>year</replaceable></entry>
 -->
 <entry><replaceable>日</replaceable>/<replaceable>月</replaceable>/<replaceable>年</replaceable></entry>
         <entry><literal>Wed 17 Dec 07:37:16 1997 PST</literal></entry>
        </row>
       </tbody>
      </tgroup>
     </table>

    <!--
<para>
     The date/time style can be selected by the user using the
     <command>SET datestyle</command> command, the <xref
     linkend="guc-datestyle"> parameter in the
     <filename>postgresql.conf</filename> configuration file, or the
     <envar>PGDATESTYLE</envar> environment variable on the server or
     client.
    </para>
-->
<para>
用户可以用<command>SET datestyle</command>命令选取日期/时间的风格，
也可以在配置文件<filename>postgresql.conf</filename>
中的<xref linkend="guc-datestyle">参数中设置，或者在服务器或客户端的
<envar>PGDATESTYLE</envar>环境变量中设置。
</para>

    <!--
<para>
     The formatting function <function>to_char</function>
     (see <xref linkend="functions-formatting">) is also available as
     a more flexible way to format date/time output.
    </para>
-->
<para>
我们也可以用格式化函数<function>to_char</function>(参见<xref linkend="functions-formatting">)
来更灵活地控制时间/日期地输出。
</para>
   </sect2>

   <sect2 id="datatype-timezones">
    <!-- 
<title>Time Zones</title> 
-->
<title>时区</title>

    <indexterm zone="datatype-timezones">
     <!-- 
 <primary>time zone</primary> 
 -->
 <primary>时区</primary>
    </indexterm>

   <!--
<para>
    Time zones, and time-zone conventions, are influenced by
    political decisions, not just earth geometry. Time zones around the
    world became somewhat standardized during the 1900s,
    but continue to be prone to arbitrary changes, particularly with
    respect to daylight-savings rules.
    <productname>PostgreSQL</productname> uses the widely-used
    IANA (Olson) time zone database for information about
    historical time zone rules.  For times in the future, the assumption
    is that the latest known rules for a given time zone will
    continue to be observed indefinitely far into the future.
   </para>
-->
<para>
时区和时区习惯不仅仅受地球几何形状的影响，还受到政治决定的影响。
到了 19 世纪，全球的时区变得稍微标准化了些，但是还是易于遭受随意的修改，
部分是因为夏时制规则。<productname>PostgreSQL</productname>
使用广泛使用的IANA（Olson）时区信息数据库有关历史时区的规则。
对于未来的时间，假设对于给定时区最近的规则将在未来继续无期限的遵守。
</para>
   
<para>
 <!--
     <productname>PostgreSQL</productname> endeavors to be compatible with
     the <acronym>SQL</acronym> standard definitions for typical usage.
     However, the <acronym>SQL</acronym> standard has an odd mix of date and
     time types and capabilities. Two obvious problems are:
-->
<productname>PostgreSQL</productname>在典型应用中尽可能与<acronym>SQL</acronym>
的定义相兼容。但<acronym>SQL</acronym>标准在日期/时间类型和功能上有一些奇怪的混淆。
两个显而易见的问题是：
     <itemizedlist>
      <listitem>
       <!-- 
   <para>
        Although the <type>date</type> type
        cannot have an associated time zone, the
        <type>time</type> type can.
        Time zones in the real world have little meaning unless
        associated with a date as well as a time,
        since the offset can vary through the year with daylight-saving
        time boundaries.
       </para> 
   -->
<para>
<type>date</type>类型与时区没有联系，而<type>time</type>类型却有或可以有。
然而，现实世界的时区只有在与时间和日期都关联时才有意义，
因为时间偏移量(时差)可能因为实行类似夏时制这样的制度而在一年里有所变化。
</para>
      </listitem>

      <listitem>
       <!--
<para>
        The default time zone is specified as a constant numeric offset
        from <acronym>UTC</>. It is therefore impossible to adapt to
        daylight-saving time when doing date/time arithmetic across
        <acronym>DST</acronym> boundaries.
       </para>
-->
<para>
缺省的时区用一个数字常量表示与<acronym>UTC</>的偏移(时差)。因此，
当跨<acronym>DST</acronym>(夏时制)界限做日期/时间算术时，
我们根本不可能把夏时制这样的因素计算进去。
</para>
      </listitem>

     </itemizedlist>
    </para>

    <!--
<para>
     To address these difficulties, we recommend using date/time types
     that contain both date and time when using time zones. We
     do <emphasis>not</> recommend using the type <type>time with
     time zone</type> (though it is supported by
     <productname>PostgreSQL</productname> for legacy applications and
     for compliance with the <acronym>SQL</acronym> standard).
     <productname>PostgreSQL</productname> assumes
     your local time zone for any type containing only date or time.
    </para>
-->
<para>
为了克服这些困难，我们建议在使用时区的时候，使用那些同时包含日期和时间的日期/时间类型。
我们建议<emphasis>不要</>使用<type>time with time zone</type>类型(尽管
<productname>PostgreSQL</productname>出于合理应用以及为了与<acronym>SQL</acronym>
标准兼容的考虑支持这个类型)。<productname>PostgreSQL</productname>
假设你用于任何类型的本地时区都只包含日期或时间(而不包含时区)。
</para>

    <!--
<para>
     All timezone-aware dates and times are stored internally in
     <acronym>UTC</acronym>.  They are converted to local time
     in the zone specified by the <xref linkend="guc-timezone"> configuration
     parameter before being displayed to the client.
    </para>
-->
<para>
在系统内部，所有日期和时间都用全球统一时间<acronym>UTC</acronym>格式存储，
时间在发给客户前端前由数据库服务器根据<xref linkend="guc-timezone">
配置参数声明的时区转换成本地时间。
</para>

   
<para>
 <!--
     <productname>PostgreSQL</productname> allows you to specify time zones in
     three different forms:
 -->
<productname>PostgreSQL</productname>允许你用三种方法指定时区：
     <itemizedlist>
      <listitem>
<!-- 
       <para>
        A full time zone name, for example <literal>America/New_York</>.
        The recognized time zone names are listed in the
        <literal>pg_timezone_names</literal> view (see <xref
        linkend="view-pg-timezone-names">).
        <productname>PostgreSQL</productname> uses the widely-used IANA
        time zone data for this purpose, so the same time zone
        names are also recognized by much other software.
       </para>
 -->
<para>
完整的时区名。例如<literal>America/New_York</>。所有可以识别的时区名在
<literal>pg_timezone_names</literal>视图中列出(参见
<xref linkend="view-pg-timezone-names">)。<productname>PostgreSQL</productname>
使用广泛使用的IANA时区数据，
所以这些时区名在其它软件里也能被轻松的识别。
</para>
      </listitem>
      <listitem>
       <!--
<para>
        A time zone abbreviation, for example <literal>PST</>.  Such a
        specification merely defines a particular offset from UTC, in
        contrast to full time zone names which can imply a set of daylight
        savings transition-date rules as well.  The recognized abbreviations
        are listed in the <literal>pg_timezone_abbrevs</> view (see <xref
        linkend="view-pg-timezone-abbrevs">).  You cannot set the
        configuration parameters <xref linkend="guc-timezone"> or
        <xref linkend="guc-log-timezone"> to a time
        zone abbreviation, but you can use abbreviations in
        date/time input values and with the <literal>AT TIME ZONE</>
        operator.
       </para>
-->
<para>
时区缩写。例如<literal>PST</>。这种缩写名通常只是定义了相对于 UTC 的偏移量，
而前一种完整的时区名可能还隐含着一组夏时制转换规则。
所有可以识别的时区缩写在<literal>pg_timezone_abbrevs</>视图中列出(参见
<xref linkend="view-pg-timezone-abbrevs">)。你不能设置
<xref linkend="guc-timezone">或<xref linkend="guc-log-timezone">
配置参数为时区缩写，但是你可以在日期/时间输入值中结合<literal>AT TIME ZONE</>
操作符使用时区缩写。
</para>
      </listitem>
      <listitem>
       <!--
<para>
        In addition to the timezone names and abbreviations,
        <productname>PostgreSQL</productname> will accept POSIX-style time zone
        specifications of the form <replaceable>STD</><replaceable>offset</> or
        <replaceable>STD</><replaceable>offset</><replaceable>DST</>, where
        <replaceable>STD</> is a zone abbreviation, <replaceable>offset</> is a
        numeric offset in hours west from UTC, and <replaceable>DST</> is an
        optional daylight-savings zone abbreviation, assumed to stand for one
        hour ahead of the given offset. For example, if <literal>EST5EDT</>
        were not already a recognized zone name, it would be accepted and would
        be functionally equivalent to United States East Coast time.  In this
        syntax, a zone abbreviation can be a string of letters, or an
        arbitrary string surrounded by angle brackets (<literal>&lt;&gt;</>).
        When a daylight-savings zone abbreviation is present,
        it is assumed to be used
        according to the same daylight-savings transition rules used in the
        IANA time zone database's <filename>posixrules</> entry.
        In a standard <productname>PostgreSQL</productname> installation,
        <filename>posixrules</> is the same as <literal>US/Eastern</>, so
        that POSIX-style time zone specifications follow USA daylight-savings
        rules.  If needed, you can adjust this behavior by replacing the
        <filename>posixrules</> file.
       </para>
-->
<para>
除完整的时区名及其缩写之外，<productname>PostgreSQL</productname>还接受 POSIX 风格的
<replaceable>STD</><replaceable>offset</>或<replaceable>STD</><replaceable>offset</><replaceable>DST</>
格式的时区，其中的<replaceable>STD</>是时区缩写、<replaceable>offset</>
是一个相对于 UTC 的小时偏移量、<replaceable>DST</>是一个可选的夏时制时区缩写
(假定相对于给定的偏移量提前一小时)。例如，如果<literal>EST5EDT</>不是一个已识别的时区名，
那么它将等同于美国东部时间。在这个语法中，一个时区缩写可以是字母字符串，
或者尖括号(<literal>&lt;&gt;</>)包围的任意字符串。
如果存在夏时制时区缩写，根据IANA
时区数据库的 <filename>posixrules</>条目中相同的夏时制事务规则，可以考虑使用这个特性。
在一个<productname>PostgreSQL</productname>标准安装中，<filename>posixrules</>与<literal>US/Eastern</>
相同，因此POSIX格式的时区声明遵循USA夏时制规则。如果需要，可以通过替换<filename>posixrules</>
文件来调整该习惯。
</para>
      </listitem>
     </itemizedlist>
<!-- 
     In short, this is the difference between abbreviations
     and full names: abbreviations represent a specific offset from UTC,
     whereas many of the full names imply a local daylight-savings time
     rule, and so have two possible UTC offsets.  As an example,
     <literal>2014-06-04 12:00 America/New_York</> represents noon local
     time in New York, which for this particular date was Eastern Daylight
     Time (UTC-4).  So <literal>2014-06-04 12:00 EDT</> specifies that
     same time instant.  But <literal>2014-06-04 12:00 EST</> specifies
     noon Eastern Standard Time (UTC-5), regardless of whether daylight
     savings was nominally in effect on that date.
-->
简言之，这就是完整的时区名与时区缩写之间的差异：时区缩写代表一个相对于 UTC 的特定偏移量，
然而许多完整的时区名隐含着一个本地夏令时规则，因此就有可能有两个相对于 UTC 的不同偏移量。
例如，<literal>2014-06-04 12:00 America/New_York</>代表纽约本地的正午时间，
这个特殊的时间是东部时间(UTC-4)。所以<literal>2014-06-04 12:00 EDT</>
指定相同的时间。但是<literal>2014-06-04 12:00 EST</>
指定东部标准时间(UTC-5)，不管该时间是否使用的是夏令时。
    </para>

<!-- 
    <para>
     To complicate matters, some jurisdictions have used the same timezone
     abbreviation to mean different UTC offsets at different times; for
     example, in Moscow <literal>MSK</> has meant UTC+3 in some years and
     UTC+4 in others.  <application>PostgreSQL</> interprets such
     abbreviations according to whatever they meant (or had most recently
     meant) on the specified date; but, as with the <literal>EST</> example
     above, this is not necessarily the same as local civil time on that date.
    </para>
-->
<para>
使问题更加复杂的是，一些国家使用同一个时区缩写表示不同时间不同的UTC偏移；
例如，莫斯科<literal>MSK</>在某些年份使用UTC+3，其他时候使用UTC+4。
<application>PostgreSQL</>根据它们在指定时间的含义（或最近的含义）
解释这样的缩写；但是，和上面的<literal>EST</>示例一样，
它们不一定和该时间的民用时间相同。
</para>
    
    <!--
<para>
     One should be wary that the POSIX-style time zone feature can
     lead to silently accepting bogus input, since there is no check on the
     reasonableness of the zone abbreviations.  For example, <literal>SET
     TIMEZONE TO FOOBAR0</> will work, leaving the system effectively using
     a rather peculiar abbreviation for UTC.
     Another issue to keep in mind is that in POSIX time zone names,
     positive offsets are used for locations <emphasis>west</> of Greenwich.
     Everywhere else, <productname>PostgreSQL</productname> follows the
     ISO-8601 convention that positive timezone offsets are <emphasis>east</>
     of Greenwich.
    </para>
-->
<para>
需要警惕的是，由于没有合理的时区缩写检查，POSIX格式的时区特点能导致静默的伪输入。
例如，使用<literal>SET TIMEZONE TO FOOBAR0</>时，实际上系统使用的是一个很特别的UTC缩写。
另一个需要注意的是，在POSIX时区名中，积极的偏移用于<emphasis>west</>格林尼治位置。
在其他地方，<productname>PostgreSQL</productname>遵循ISO-8601规定，
即积极的时区偏移<emphasis>east</>格林威治。
</para>

    <!--
<para>
     In all cases, timezone names and abbreviations are recognized
     case-insensitively.  (This is a change from <productname>PostgreSQL</>
     versions prior to 8.2, which were case-sensitive in some contexts but
     not others.)
</para>
-->
<para>
总体而言，<productname>PostgreSQL</productname>
 8.2 版本以后时区名和缩写在所有情况下都是大小写无关的。
而之前的版本在某些情况下是大小写敏感的。
</para>

    <!--
<para>
     Neither timezone names nor abbreviations are hard-wired into the server;
     they are obtained from configuration files stored under
     <filename>.../share/timezone/</> and <filename>.../share/timezonesets/</>
     of the installation directory
     (see <xref linkend="datetime-config-files">).
    </para>
-->
<para>
无论是时区名还是时区缩写都不是硬连接进服务器的，它们都是从安装目录下的
<filename>.../share/timezone/</>和<filename>.../share/timezonesets/</>
配置文件中获取的(参见<xref linkend="datetime-config-files">)。
</para>

   
<para>
 <!--
     The <xref linkend="guc-timezone"> configuration parameter can
     be set in the file <filename>postgresql.conf</>, or in any of the
     other standard ways described in <xref linkend="runtime-config">.
     There are also some special ways to set it:
-->
可以在<filename>postgresql.conf</>文件里设置<xref linkend="guc-timezone">
配置参数，或者用任何其它在<xref linkend="runtime-config">描述的标准方法。
除此之外，还有好几种特殊方法可以设置它：
     <itemizedlist>
      <listitem>
<!-- 
       <para>
        The <acronym>SQL</acronym> command <command>SET TIME ZONE</command>
        sets the time zone for the session.  This is an alternative spelling
        of <command>SET TIMEZONE TO</> with a more SQL-spec-compatible syntax.
       </para>
 -->
<para>
使用<acronym>SQL</acronym>命令<command>SET TIME ZONE</command>为会话设置时区，
这是<command>SET TIMEZONE TO</>的一个可选的拼写方式，更加兼容标准。
</para>
      </listitem>

      <listitem>
       <!--
<para>
        The <envar>PGTZ</envar> environment variable is used by
        <application>libpq</application> clients
        to send a <command>SET TIME ZONE</command>
        command to the server upon connection.
       </para>
-->
<para>
如果在客户端设置了<envar>PGTZ</envar>环境变量，那么<application>libpq</application>
在连接时将使用这个环境变量给后端发送一个<command>SET TIME ZONE</command>命令。
</para>
      </listitem>
     </itemizedlist>
    </para>
   </sect2>

   <sect2 id="datatype-interval-input">
    <!-- 
<title>Interval Input</title> 
-->
<title>间隔输入</title>

    <indexterm>
     <!-- 
 <primary>interval</primary> 
 -->
 <primary>间隔</primary>
    </indexterm>

     
<para>
<!--
      <type>interval</type> values can be written using the following
      verbose syntax:
-->
<type>interval</type>类型值可以用下面的详细语法写：
<synopsis>
<optional>@</> <replaceable>quantity</> <replaceable>unit</> <optional><replaceable>quantity</> <replaceable>unit</>...</> <optional><replaceable>direction</></optional>
</synopsis>
<!-- 
     where <replaceable>quantity</> is a number (possibly signed);
     <replaceable>unit</> is <literal>microsecond</literal>,
     <literal>millisecond</literal>, <literal>second</literal>,
     <literal>minute</literal>, <literal>hour</literal>, <literal>day</literal>,
     <literal>week</literal>, <literal>month</literal>, <literal>year</literal>,
     <literal>decade</literal>, <literal>century</literal>, <literal>millennium</literal>,
     or abbreviations or plurals of these units;
     <replaceable>direction</> can be <literal>ago</literal> or
     empty.  The at sign (<literal>@</>) is optional noise.  The amounts
     of the different units are implicitly added with appropriate
     sign accounting.  <literal>ago</literal> negates all the fields.
     This syntax is also used for interval output, if
     <xref linkend="guc-intervalstyle"> is set to
     <literal>postgres_verbose</>.
 -->
这里<replaceable>quantity</>是一个数字（可能已标记）；<replaceable>unit</>
可以是<literal>microsecond</literal>，<literal>millisecond</literal>，<literal>second</literal>，
<literal>minute</literal>，<literal>hour</literal>，<literal>day</literal>，
<literal>week</literal>，<literal>month</literal>，<literal>year</literal>，
<literal>decade</literal>，<literal>century</literal>，<literal>millennium</literal>
或这些单位的缩写或复数。<replaceable>direction</>可以是<literal>ago</literal>或为空。
<literal>@</>标记是可选的。不同的单位的数量被隐式地添加适当的计算符号。
<literal>ago</literal>否定所有。如果<xref linkend="guc-intervalstyle">
设置为<literal>postgres_verbose</>，那么这个语法同样用于间隔输出。 
    </para>

    <!--
<para>
     Quantities of days, hours, minutes, and seconds can be specified without
     explicit unit markings.  For example, <literal>'1 12:59:10'</> is read
     the same as <literal>'1 day 12 hours 59 min 10 sec'</>.  Also,
     a combination of years and months can be specified with a dash;
     for example <literal>'200-10'</> is read the same as <literal>'200 years
     10 months'</>.  (These shorter forms are in fact the only ones allowed
     by the <acronym>SQL</acronym> standard, and are used for output when
     <varname>IntervalStyle</> is set to <literal>sql_standard</literal>.)
    </para>
-->
<para>
可以在没有明确单位标记的情况下声明天，小时，分钟和秒。例如，<literal>'1 12:59:10'</>
等同于<literal>'1 day 12 hours 59 min 10 sec'</>。同样，
可以用一个破折号来声明一个年和月的组合，例如<literal>'200-10'</>等同于
<literal>'200 years 10 months'</>。（事实上，<acronym>SQL</acronym>标准值允许短的格式，
并且当<varname>IntervalStyle</>设置为<literal>sql_standard</literal>时，用于输出）。
</para>
    
<para>
<!--
     Interval values can also be written as ISO 8601 time intervals, using
     either the <quote>format with designators</> of the standard's section
     4.4.3.2 or the <quote>alternative format</> of section 4.4.3.3.  The
     format with designators looks like this:
-->
要么使用4.4.3.2的<quote>format with designators</>，要么使用4.4.3.3的
<quote>alternative format</>，间隔值可以写为ISO 8601的时间间隔。格式如下： 
<synopsis>
P <replaceable>quantity</> <replaceable>unit</> <optional> <replaceable>quantity</> <replaceable>unit</> ...</optional> <optional> T <optional> <replaceable>quantity</> <replaceable>unit</> ...</optional></optional>
</synopsis>
<!-- 
      The string must start with a <literal>P</>, and may include a
      <literal>T</> that introduces the time-of-day units.  The
      available unit abbreviations are given in <xref
      linkend="datatype-interval-iso8601-units">.  Units may be
      omitted, and may be specified in any order, but units smaller than
      a day must appear after <literal>T</>.  In particular, the meaning of
      <literal>M</> depends on whether it is before or after
      <literal>T</>. 
  -->
字符串必须以<literal>P</>开始，并且可以含有一个<literal>T</>用以指明一天中时间的格式。
可用单位的缩写在<xref linkend="datatype-interval-iso8601-units">有说明。可以忽略单位，
也可以以任意顺序声明，但单位小于一天时必须在<literal>T</>之后。
尤其<literal>M</>的含义依赖于它在<literal>T</>之前或之后。  
     </para>

     <table id="datatype-interval-iso8601-units">
      <!-- 
  <title>ISO 8601 Interval Unit Abbreviations</title> 
  -->
  <title>ISO 8601 间隔单位的缩写</title>
     <tgroup cols="2">
       <thead>
        <row>
         <!-- 
 <entry>Abbreviation</entry>
         <entry>Meaning</entry> 
 -->
 <entry>缩写</entry>
         <entry>含义</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>Y</entry>
         <!-- 
 <entry>Years</entry> 
 -->
 <entry>年</entry>
        </row>
        <row>
         <entry>M</entry>
         <!-- 
 <entry>Months (in the date part)</entry> 
 -->
 <entry>月（日期部分）</entry>
        </row>
        <row>
         <entry>W</entry>
         <!-- 
 <entry>Weeks</entry> 
 -->
 <entry>周</entry>
        </row>
        <row>
         <entry>D</entry>
         <!-- 
 <entry>Days</entry> 
 -->
 <entry>日</entry>
        </row>
        <row>
         <entry>H</entry>
         <!-- 
 <entry>Hours</entry> 
 -->
 <entry>小时</entry>
        </row>
        <row>
         <entry>M</entry>
         <!-- 
 <entry>Minutes (in the time part)</entry> 
 -->
 <entry>分钟（时间部分）</entry>
        </row>
        <row>
         <entry>S</entry>
         <!-- 
 <entry>Seconds</entry> 
 -->
 <entry>秒</entry>
        </row>
       </tbody>
      </tgroup>
     </table>

     
<para>
<!--
      In the alternative format:
  -->
以缩写格式：  
<synopsis>
P <optional> <replaceable>years</>-<replaceable>months</>-<replaceable>days</> </optional> <optional> T <replaceable>hours</>:<replaceable>minutes</>:<replaceable>seconds</> </optional>
</synopsis>
<!-- 
      the string must begin with <literal>P</literal>, and a
      <literal>T</> separates the date and time parts of the interval.
      The values are given as numbers similar to ISO 8601 dates. 
  -->
一个字符串必须以<literal>P</literal>开始，然后以<literal>T</>隔开日期和时间。
给出的值是如同ISO 8601日期的数字。
    </para>

    <!--
<para>
     When writing an interval constant with a <replaceable>fields</>
     specification, or when assigning a string to an interval column that was
     defined with a <replaceable>fields</> specification, the interpretation of
     unmarked quantities depends on the <replaceable>fields</>.  For
     example <literal>INTERVAL '1' YEAR</> is read as 1 year, whereas
     <literal>INTERVAL '1'</> means 1 second.  Also, field values
     <quote>to the right</> of the least significant field allowed by the
     <replaceable>fields</> specification are silently discarded.  For
     example, writing <literal>INTERVAL '1 day 2:03:04' HOUR TO MINUTE</>
     results in dropping the seconds field, but not the day field.
    </para>
-->
<para>
当用<replaceable>fields</>规范写一个时间间隔常数，或将一个字符串标记为用
<replaceable>fields</>规范定义的一个间隔列时，未标记单位的解释由<replaceable>fields</>
解释。如<literal>INTERVAL '1' YEAR</>读作1年，然而<literal>INTERVAL '1'</>代表1秒。
同样，<replaceable>fields</>规范中<quote>最低</>有效字段值规定会被静默的忽略。
如，<literal>INTERVAL '1 day 2:03:04' HOUR TO MINUTE</>会导致删除秒字段，而不是天字段。
</para>

    <!--
<para>
     According to the <acronym>SQL</> standard all fields of an interval
     value must have the same sign, so a leading negative sign applies to all
     fields; for example the negative sign in the interval literal
     <literal>'-1 2:03:04'</> applies to both the days and hour/minute/second
     parts.  <productname>PostgreSQL</> allows the fields to have different
     signs, and traditionally treats each field in the textual representation
     as independently signed, so that the hour/minute/second part is
     considered positive in this example.  If <varname>IntervalStyle</> is
     set to <literal>sql_standard</literal> then a leading sign is considered
     to apply to all fields (but only if no additional signs appear).
     Otherwise the traditional <productname>PostgreSQL</> interpretation is
     used.  To avoid ambiguity, it's recommended to attach an explicit sign
     to each field if any field is negative.
    </para>
-->
<para>
根据<acronym>SQL</>标准，间隔值的所有字段必须有相同的符号，因此前导负号可以用于所有字段；
如<literal>'-1 2:03:04'</>中负号同时应用于天和小时/分钟/秒。<productname>PostgreSQL</> 
允许字段有不同的标记，并且传统上，文本表述中的每个字段会被认为是独立标记的，
因此在这个例子中的小时/分钟/秒被认为是正值。如果<varname>IntervalStyle</>被设置为
<literal>sql_standard</literal>，那么前导标记被认为是应用于所有字段的
（当然前提是没有再出现其他标记），否则会使用传统的<productname>PostgreSQL</>解释。
为了避免这种歧义，如果任何字段是负的，建议为每个字段附上一个明确的标记。
</para>

    <!--
<para>
     Internally <type>interval</> values are stored as months, days,
     and seconds. This is done because the number of days in a month
     varies, and a day can have 23 or 25 hours if a daylight savings
     time adjustment is involved.  The months and days fields are integers
     while the seconds field can store fractions.  Because intervals are
     usually created from constant strings or <type>timestamp</> subtraction,
     this storage method works well in most cases. Functions
     <function>justify_days</> and <function>justify_hours</> are
     available for adjusting days and hours that overflow their normal
     ranges.
    </para>
-->
<para>
<productname>PostgreSQL</>内部，<type>interval</>值被存储为月，日，秒的格式，
这是因为月中包含天数不同，并且如果进行了夏令时调整，那么一天可以有23或25小时。
当秒字段可以存储分数时，月和天字段可以是整数型。
由于时间间隔通常是由常量字符串或<type>timestamp</>减法来定义的，
这种存储方法在大多数情况下很有效。<function>justify_days</>和<function>justify_hours</>
函数可用于调整溢出正常范围值的天和小时。
</para>

    <!--
<para>
     In the verbose input format, and in some fields of the more compact
     input formats, field values can have fractional parts; for example
     <literal>'1.5 week'</> or <literal>'01:02:03.45'</>.  Such input is
     converted to the appropriate number of months, days, and seconds
     for storage.  When this would result in a fractional number of
     months or days, the fraction is added to the lower-order fields
     using the conversion factors 1 month = 30 days and 1 day = 24 hours.
     For example, <literal>'1.5 month'</> becomes 1 month and 15 days.
     Only seconds will ever be shown as fractional on output.
    </para>
-->
<para>
在详细的输入格式，以及更紧凑的输入格式中，字段值可以有小数部分，
例如<literal>'1.5 week'</>或<literal>'01:02:03.45'</>。这种输入被转换成恰当的月，
天和秒来存储。由于这样会产生小数的月或天，因此在低阶字段中引入了分数，
使用1 month = 30 days 和 1 day = 24 hours的转换。例如，<literal>'1.5 month'</>
即1个月15天。输出中，只有秒可以写成分数形式。
</para>

    <!--
<para>
     <xref linkend="datatype-interval-input-examples"> shows some examples
     of valid <type>interval</> input.
    </para>
-->
<para>
<xref linkend="datatype-interval-input-examples">中有一些有效的<type>interval</>输入的例子。
</para>

     <table id="datatype-interval-input-examples">
      <!-- 
  <title>Interval Input</title> 
  -->
  <title>间隔输入</title>
      <tgroup cols="2">
       <thead>
        <row>
         <!-- 
 <entry>Example</entry>
         <entry>Description</entry> 
 -->
 <entry>示例</entry>
         <entry>说明</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>1-2</entry>
         <!-- 
 <entry>SQL standard format: 1 year 2 months</entry> 
 -->
 <entry>SQL标准格式：一年两个月</entry>
        </row>
        <row>
         <entry>3 4:05:06</entry>
         <!-- 
 <entry>SQL standard format: 3 days 4 hours 5 minutes 6 seconds</entry> 
 -->
 <entry>SQL标准格式：3天4小时5分6秒</entry>
        </row>
        <row>
         <entry>1 year 2 months 3 days 4 hours 5 minutes 6 seconds</entry>
         <!-- 
 <entry>Traditional Postgres format: 1 year 2 months 3 days 4 hours 5 minutes 6 seconds</entry> 
 -->
 <entry>传统Postgres格式: 1年2个月3天4小时5分钟6秒</entry>
        </row>
        <row>
         <entry>P1Y2M3DT4H5M6S</entry>
         <!-- 
 <entry>ISO 8601 <quote>format with designators</>: same meaning as above</entry> 
 -->
 <entry>ISO 8601 <quote>带标识符格式</>:与上面相同含义</entry>
        </row>
        <row>
         <entry>P0001-02-03T04:05:06</entry>
         <!-- 
 <entry>ISO 8601 <quote>alternative format</>: same meaning as above</entry> 
 -->
 <entry>ISO 8601 <quote>缩写格式</>:与上面相同含义</entry>
        </row>
       </tbody>
      </tgroup>
     </table>

   </sect2>

   <sect2 id="datatype-interval-output">
    <!-- 
<title>Interval Output</title> 
-->
<title>间隔输出</title>

    <indexterm>
     <!-- 
 <primary>interval</primary>
     <secondary>output format</secondary>
     <seealso>formatting</seealso> 
 -->
 <primary>间隔</primary>
     <secondary>输出格式</secondary>
     <seealso>格式</seealso>
    </indexterm>

    <!--
<para>
     The output format of the interval type can be set to one of the
     four styles <literal>sql_standard</>, <literal>postgres</>,
     <literal>postgres_verbose</>, or <literal>iso_8601</>,
     using the command <literal>SET intervalstyle</literal>.
     The default is the <literal>postgres</> format.
     <xref linkend="interval-style-output-table"> shows examples of each
     output style.
    </para>
-->
<para>
间隔类型的输出格式可以用命令<literal>SET intervalstyle</literal>设置为下面四种类型：
<literal>sql_standard</>，<literal>postgres</>，<literal>postgres_verbose</>或
<literal>iso_8601</>。默认是<literal>postgres</>格式，
<xref linkend="interval-style-output-table">中有每种格式的示例。
</para>

    <!--
<para>
     The <literal>sql_standard</> style produces output that conforms to
     the SQL standard's specification for interval literal strings, if
     the interval value meets the standard's restrictions (either year-month
     only or day-time only, with no mixing of positive
     and negative components).  Otherwise the output looks like a standard
     year-month literal string followed by a day-time literal string,
     with explicit signs added to disambiguate mixed-sign intervals.
    </para>
-->
<para>
<literal>sql_standard</>格式产生的输出结果符合SQL的间隔字符串标准，
如果间隔值满足标准的限制（无论只有年-月，或只有天-时间，没有积极和消极的构成的混合）。
否则输出类似一个标准年-月文本字符串后跟有一个天-时间文本字符串，
带有添加明确标记的消除歧义混合信号的时间间隔。
</para>

    <!--
<para>
     The output of the <literal>postgres</> style matches the output of
     <productname>PostgreSQL</> releases prior to 8.4 when the
     <xref linkend="guc-datestyle"> parameter was set to <literal>ISO</>.
    </para>
-->
<para>
当参数<xref linkend="guc-datestyle">设置为<literal>ISO</>时，
<literal>postgres</>格式的输出与<productname>PostgreSQL</> 8.4之前的版本一致。
</para>

    <!--
<para>
     The output of the <literal>postgres_verbose</> style matches the output of
     <productname>PostgreSQL</> releases prior to 8.4 when the
     <varname>DateStyle</> parameter was set to non-<literal>ISO</> output.
    </para>
-->
<para>
当参数<varname>DateStyle</>设置为非-<literal>ISO</>，
<literal>postgres_verbose</>格式的输出与<productname>PostgreSQL</> 8.4之前的版本一致。
</para>

    <!--
<para>
     The output of the <literal>iso_8601</> style matches the <quote>format
     with designators</> described in section 4.4.3.2 of the
     ISO 8601 standard.
    </para>
-->
<para>
<literal>iso_8601</>格式的输出与ISO 8601标准4.4.3.2节中的<quote>format with designators</>一致。
</para>

     <table id="interval-style-output-table">
       <!-- 
   <title>Interval Output Style Examples</title> 
   -->
   <title>间隔输出格式示例</title>
       <tgroup cols="4">
        <thead>
         <row>
          <!-- 
  <entry>Style Specification</entry>
          <entry>Year-Month Interval</entry>
          <entry>Day-Time Interval</entry>
          <entry>Mixed Interval</entry> 
  -->
  <entry>格式</entry>
          <entry>年-月间隔</entry>
          <entry>天-时间间隔</entry>
          <entry>混合间隔</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><literal>sql_standard</></entry>
          <entry>1-2</entry>
          <entry>3 4:05:06</entry>
          <entry>-1-2 +3 -4:05:06</entry>
         </row>
         <row>
          <entry><literal>postgres</></entry>
          <!-- 
  <entry>1 year 2 mons</entry>
          <entry>3 days 04:05:06</entry>
          <entry>-1 year -2 mons +3 days -04:05:06</entry> 
  -->
  <entry>1 年 2 个月</entry>
          <entry>3 天 04:05:06</entry>
          <entry>-1 年 -2 个月 +3 天 -04:05:06</entry>
         </row>
         <row>
          <entry><literal>postgres_verbose</></entry>
          <!-- 
  <entry>@ 1 year 2 mons</entry>
          <entry>@ 3 days 4 hours 5 mins 6 secs</entry>
          <entry>@ 1 year 2 mons -3 days 4 hours 5 mins 6 secs ago</entry> 
  -->
  <entry>@ 1 年 2 个月</entry>
          <entry>@ 3 天 4 小时 5 分 6 秒</entry>
          <entry>@ 1 年 2 个月 -3 天 4 小时 5 分 6 秒以前</entry>
         </row>
         <row>
          <entry><literal>iso_8601</></entry>
          <entry>P1Y2M</entry>
          <entry>P3DT4H5M6S</entry>
          <entry>P-1Y-2M3DT-4H-5M-6S</entry>
         </row>
        </tbody>
       </tgroup>
    </table>

   </sect2>

  </sect1>

  <sect1 id="datatype-boolean">
   <!-- 
   <title>Boolean Type</title> 
   -->
   <title>布尔类型</title>

   <indexterm zone="datatype-boolean">
    <!-- 
<primary>Boolean</primary>
    <secondary>data type</secondary> 
-->
<primary>布尔</primary>
    <secondary>数据类型</secondary>
   </indexterm>

   <indexterm zone="datatype-boolean">
    <primary>true</primary>
   </indexterm>

   <indexterm zone="datatype-boolean">
    <primary>false</primary>
   </indexterm>

   <!--
<para>
    <productname>PostgreSQL</productname> provides the
    standard <acronym>SQL</acronym> type <type>boolean</type>;
    see <xref linkend="datatype-boolean-table">.
    The <type>boolean</type> type can have several states:
    <quote>true</quote>, <quote>false</quote>, and a third state,
    <quote>unknown</quote>, which is represented by the
    <acronym>SQL</acronym> null value.
   </para>
-->
<para>
<productname>PostgreSQL</productname>支持<acronym>SQL</acronym>标准的
<type>boolean</type>数据类型。参阅<xref linkend="datatype-boolean-table">。
<type>boolean</type>只能有<quote>true</quote>(真)或<quote>false</quote>(假)两个状态，
或第三种<quote>unknown</quote>(未知)状态，用 NULL 表示。
</para>

   <table id="datatype-boolean-table">
    <!-- 
<title>Boolean Data Type</title> 
-->
<title>布尔数据类型</title>
    <tgroup cols="3">
     <thead>
      <row>
       <!-- 
   <entry>Name</entry>
       <entry>Storage Size</entry>
       <entry>Description</entry> 
   -->
   <entry>名称</entry>
       <entry>存储格式</entry>
       <entry>描述</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><type>boolean</type></entry>
       <!-- 
   <entry>1 byte</entry>
       <entry>state of true or false</entry> 
   -->
   <entry>1 字节</entry>
       <entry>真/假</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   
<para>
<!--
    Valid literal values for the <quote>true</quote> state are:
-->
<quote>真</quote>值的有效文本值是： 
    <simplelist>
     <member><literal>TRUE</literal></member>
     <member><literal>'t'</literal></member>
     <member><literal>'true'</literal></member>
     <member><literal>'y'</literal></member>
     <member><literal>'yes'</literal></member>
     <member><literal>'on'</literal></member>
     <member><literal>'1'</literal></member>
    </simplelist>
<!-- 
    For the <quote>false</quote> state, the following values can be
    used: 
-->
对于<quote>假</quote>，你可以使用下面这些：
    <simplelist>
     <member><literal>FALSE</literal></member>
     <member><literal>'f'</literal></member>
     <member><literal>'false'</literal></member>
     <member><literal>'n'</literal></member>
     <member><literal>'no'</literal></member>
     <member><literal>'off'</literal></member>
     <member><literal>'0'</literal></member>
    </simplelist>
<!-- 
    Leading or trailing whitespace is ignored, and case does not matter.
    The key words
    <literal>TRUE</literal> and <literal>FALSE</literal> are the preferred
    (<acronym>SQL</acronym>-compliant) usage. 
-->
前导或尾随空白将被忽略，大小写无关。使用<literal>TRUE</literal>和<literal>FALSE</literal>
这样的字眼比较好(也是<acronym>SQL</acronym>兼容的用法)。
   </para>

   <!--
<para>
    <xref linkend="datatype-boolean-example"> shows that
    <type>boolean</type> values are output using the letters
    <literal>t</literal> and <literal>f</literal>.
   </para>
-->
<para>
<xref linkend="datatype-boolean-example">显示了用字母<literal>t</literal>
和<literal>f</literal>输出<type>boolean</type>值的例子。
</para>

   <example id="datatype-boolean-example">
    <!-- 
<title>Using the <type>boolean</type> Type</title> 
-->
<title>使用 <type>boolean</type> 类型</title>

<programlisting>
CREATE TABLE test1 (a boolean, b text);
INSERT INTO test1 VALUES (TRUE, 'sic est');
INSERT INTO test1 VALUES (FALSE, 'non est');
SELECT * FROM test1;
 a |    b
---+---------
 t | sic est
 f | non est

SELECT * FROM test1 WHERE a;
 a |    b
---+---------
 t | sic est
</programlisting>
   </example>
  </sect1>

  <sect1 id="datatype-enum">
   <!-- 
   <title>Enumerated Types</title> 
   -->
   <title>枚举类型</title>

   <indexterm zone="datatype-enum">
    <!-- 
<primary>data type</primary>
    <secondary>enumerated (enum)</secondary> 
-->
<primary>数据类型</primary>
    <secondary>枚举 (enum)</secondary>
   </indexterm>

   <indexterm zone="datatype-enum">
    <!-- 
<primary>enumerated types</primary> 
-->
<primary>枚举类型</primary>
   </indexterm>

   <!--
<para>
    Enumerated (enum) types are data types that
    comprise a static, ordered set of values.
    They are equivalent to the <type>enum</type>
    types supported in a number of programming languages. An example of an enum
    type might be the days of the week, or a set of status values for
    a piece of data.
   </para>
-->
<para>
枚举类型是一个包含静态和值的有序集合的数据类型。等于某些编程语言中的<type>enum</type>
类型。一个枚举类型可以是一周中的天，或者一块数据的状态值的集合。
</para>

   <sect2>
    <!-- 
<title>Declaration of Enumerated Types</title> 
-->
<title>枚举类型的声明</title>

    
<para>
<!--
     Enum types are created using the <xref
     linkend="sql-createtype"> command,
     for example:
-->
用<xref linkend="sql-createtype">创建枚举类型，如：
<programlisting>
CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');
</programlisting>
<!-- 
     Once created, the enum type can be used in table and function
     definitions much like any other type:
 -->
就像其他类型一样，一旦创建，枚举类型可以用于表和函数定义。 
<programlisting>
CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');
CREATE TABLE person (
    name text,
    current_mood mood
);
INSERT INTO person VALUES ('Moe', 'happy');
SELECT * FROM person WHERE current_mood = 'happy';
 name | current_mood 
------+--------------
 Moe  | happy
(1 row)
</programlisting>
    </para>

    </sect2>

    <sect2>
     <!-- 
 <title>Ordering</title> 
 -->
 <title>排序</title>

     
<para>
<!--
      The ordering of the values in an enum type is the
      order in which the values were listed when the type was created.
      All standard comparison operators and related
      aggregate functions are supported for enums.  For example:
-->
枚举类型中，值的顺序是创建枚举类型时定义的顺序。
所有的比较标准运算符及其相关的聚合函数都可支持枚举类型，例如：
<programlisting>
INSERT INTO person VALUES ('Larry', 'sad');
INSERT INTO person VALUES ('Curly', 'ok');
SELECT * FROM person WHERE current_mood > 'sad';
 name  | current_mood 
-------+--------------
 Moe   | happy
 Curly | ok
(2 rows)

SELECT * FROM person WHERE current_mood > 'sad' ORDER BY current_mood;
 name  | current_mood 
-------+--------------
 Curly | ok
 Moe   | happy
(2 rows)

SELECT name
FROM person
WHERE current_mood = (SELECT MIN(current_mood) FROM person);
 name  
-------
 Larry
(1 row)
</programlisting>
     </para>

   </sect2>

   <sect2>
    <!-- 
<title>Type Safety</title> 
-->
<title>类型安全</title>

   
<para>
 <!--
     Each enumerated data type is separate and cannot
     be compared with other enumerated types.  See this example:
-->
每个枚举类型都是独立的，不能与其他枚举类型结合，如：
<programlisting>
CREATE TYPE happiness AS ENUM ('happy', 'very happy', 'ecstatic');
CREATE TABLE holidays (
    num_weeks integer,
    happiness happiness
);
INSERT INTO holidays(num_weeks,happiness) VALUES (4, 'happy');
INSERT INTO holidays(num_weeks,happiness) VALUES (6, 'very happy');
INSERT INTO holidays(num_weeks,happiness) VALUES (8, 'ecstatic');
INSERT INTO holidays(num_weeks,happiness) VALUES (2, 'sad');
ERROR:  invalid input value for enum happiness: "sad"
SELECT person.name, holidays.num_weeks FROM person, holidays
  WHERE person.current_mood = holidays.happiness;
ERROR:  operator does not exist: mood = happiness
</programlisting>
    </para>

    
<para>
<!--
     If you really need to do something like that, you can either
     write a custom operator or add explicit casts to your query:
-->
如果真的需要那么做，可以要么自定义运算符，要么为查询添加显式转换：
<programlisting>
SELECT person.name, holidays.num_weeks FROM person, holidays
  WHERE person.current_mood::text = holidays.happiness::text;
 name | num_weeks 
------+-----------
 Moe  |         4
(1 row)

</programlisting>
    </para>
   </sect2>

   <sect2>
    <!-- 
<title>Implementation Details</title> 
-->
<title>实施细则</title>

    <!--
<para>
     An enum value occupies four bytes on disk.  The length of an enum
     value's textual label is limited by the <symbol>NAMEDATALEN</symbol>
     setting compiled into <productname>PostgreSQL</productname>; in standard
     builds this means at most 63 bytes.
    </para>
-->
<para>
一个枚举值在磁盘上占4字节。一个枚举值的文本标签长度由编译到<productname>PostgreSQL</productname>
中的<symbol>NAMEDATALEN</symbol>设置，以标准方式编译意味着最多63字节。
</para>

    <!--
<para>
     Enum labels are case sensitive, so
     <type>'happy'</type> is not the same as <type>'HAPPY'</type>.
     White space in the labels is significant too.
    </para>
-->
<para>
枚举标签对大小写是敏感的，因此<type>'happy'</type>不等于<type>'HAPPY'</type>。
标签中的空格也是一样。
</para>

    <!--
<para>
     The translations from internal enum values to textual labels are
     kept in the system catalog
     <link linkend="catalog-pg-enum"><structname>pg_enum</structname></link>.
     Querying this catalog directly can be useful.
    </para>
-->
<para>
从内部枚举值到文本标签的翻译是保存在系统目录
<link linkend="catalog-pg-enum"><structname>pg_enum</structname></link>中。
可以直接查询这个目录。
</para>

   </sect2>
  </sect1>

  <sect1 id="datatype-geometric">
   <!-- 
   <title>Geometric Types</title> 
   -->
   <title>几何类型</title>

   <!--
<para>
    Geometric data types represent two-dimensional spatial
    objects. <xref linkend="datatype-geo-table"> shows the geometric
    types available in <productname>PostgreSQL</productname>.
   </para>
-->
<para>
几何数据类型表示二维的平面物体。<xref linkend="datatype-geo-table">
显示了<productname>PostgreSQL</productname>里面可用的几何类型。
</para>

    <table id="datatype-geo-table">
     <!-- 
 <title>Geometric Types</title> 
 -->
 <title>几何类型</title>
     <tgroup cols="4">
      <thead>
       <row>
        <!-- 
<entry>Name</entry>
        <entry>Storage Size</entry>
        <entry>Description</entry> 
        <entry>Representation</entry>
-->
<entry>名字</entry>
        <entry>存储空间</entry>
        <entry>说明</entry>
        <entry>表现形式</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><type>point</type></entry>
        <!-- 
<entry>16 bytes</entry>
        <entry>Point on a plane</entry> 
-->
<entry>16 字节</entry>
        <entry>平面中的点</entry>
        <entry>(x,y)</entry>
       </row>
       <row>
        <entry><type>line</type></entry>
        <!-- 
<entry>32 bytes</entry>
        <entry>Infinite line</entry> 
-->
<entry>32 字节</entry>
        <entry>(无穷)直线</entry>
        <entry>{A,B,C}</entry>
       </row>
       <row>
        <entry><type>lseg</type></entry>
        <!-- 
<entry>32 bytes</entry>
        <entry>Finite line segment</entry> 
-->
<entry>32 字节</entry>
        <entry>(有限)线段</entry>
        <entry>((x1,y1),(x2,y2))</entry>
       </row>
       <row>
        <entry><type>box</type></entry>
        <!-- 
<entry>32 bytes</entry>
        <entry>Rectangular box</entry>
-->
<entry>32 字节</entry>
        <entry>矩形</entry>
        <entry>((x1,y1),(x2,y2))</entry>
       </row>
       <row>
        <entry><type>path</type></entry>
        <!-- 
<entry>16+16n bytes</entry>
        <entry>Closed path (similar to polygon)</entry> 
-->
<entry>16+16n 字节</entry>
        <entry>闭合路径(与多边形类似)</entry>
        <entry>((x1,y1),...)</entry>
       </row>
       <row>
        <entry><type>path</type></entry>
        <!-- 
<entry>16+16n bytes</entry>
        <entry>Open path</entry> 
-->
<entry>16+16n 字节</entry>
        <entry>开放路径</entry>
        <entry>[(x1,y1),...]</entry>
       </row>
       <row>
        <entry><type>polygon</type></entry>
        <!-- 
<entry>40+16n bytes</entry>
        <entry>Polygon (similar to closed path)</entry> 
-->
<entry>40+16n 字节</entry>
        <entry>多边形(与闭合路径相似)</entry>
        <entry>((x1,y1),...)</entry>
       </row>
       <row>
        <entry><type>circle</type></entry>
        <!-- 
<entry>24 bytes</entry>
        <entry>Circle</entry>
        <entry>&lt;(x,y),r&gt; (center point and radius)</entry> 
-->
<entry>24 字节</entry>
        <entry>圆</entry>
        <entry>&lt;(x,y),r&gt; (圆心和半径)</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <!--
<para>
    A rich set of functions and operators is available to perform various geometric
    operations such as scaling, translation, rotation, and determining
    intersections.  They are explained in <xref linkend="functions-geometry">.
   </para>
-->
<para>
我们有一系列丰富的函数和操作符可用来进行各种几何计算，如拉伸、转换、旋转、计算相交等。
它们在<xref linkend="functions-geometry">里有解释。
</para>

   <sect2>
    <!-- 
<title>Points</title>
-->
<title>点</title>

    <indexterm>
     <!-- 
 <primary>point</primary> 
 -->
 <primary>点</primary>
    </indexterm>
    
<para>
<!--
     Points are the fundamental two-dimensional building block for geometric
     types.  Values of type <type>point</type> are specified using either of
     the following syntaxes:
-->
点是几何类型的基本二维构造单位。用下面语法描述<type>point</type>的数值：
<synopsis>
( <replaceable>x</replaceable> , <replaceable>y</replaceable> )
  <replaceable>x</replaceable> , <replaceable>y</replaceable>
</synopsis>
<!-- 
     where <replaceable>x</> and <replaceable>y</> are the respective
     coordinates, as floating-point numbers.
 -->
这里的<replaceable>x</>和<replaceable>y</>是用浮点数表示的点的坐标。 
    </para>

    <!--
<para>
     Points are output using the first syntax.
    </para>
-->
<para>
点输出使用第一种语法。
</para>
   </sect2>

   <sect2 id="datatype-line">
    <!-- 
    <title>Lines</title> 
    -->
    <title>线</title>

    <indexterm>
     <!-- 
     <primary>line</primary> 
     -->
     <primary>线</primary>
    </indexterm>

    <para>
<!-- 
     Lines are represented by the linear
     equation <replaceable>A</>x + <replaceable>B</>y + <replaceable>C</> = 0,
     where <replaceable>A</> and <replaceable>B</> are not both zero.  Values
     of type <type>line</type> are input and output in the following form:
-->
线是由线的方程式<replaceable>A</>x + <replaceable>B</>y + <replaceable>C</> = 0
表示的，这里的<replaceable>A</>和<replaceable>B</>都不是0。
类型<type>line</type>的值以下列的形式输入和输出：
<synopsis>
{ <replaceable>A</replaceable>, <replaceable>B</replaceable>, <replaceable>C</replaceable> }
</synopsis>

<!-- 
     Alternatively, any of the following forms can be used for input:
-->
作为选择，下列的任意一种格式都可以用作输入：

<synopsis>
[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) ]
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   <replaceable>x2</replaceable> , <replaceable>y2</replaceable>
</synopsis>

<!-- 
     where
     <literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>
     and
     <literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>
     are two different points on the line.
-->
这里的<literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>
和<literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>
是线上的两个不同的点。

    </para>    
    
    
    
    
   </sect2>

   <sect2 id="datatype-lseg">
    <!-- 
<title>Line Segments</title>
-->
<title>线段</title>

    <indexterm>
     <primary>lseg</primary>
    </indexterm>

    <indexterm>
     <!-- 
 <primary>line segment</primary> 
 -->
 <primary>线段</primary>
    </indexterm>

    
<para>
<!--
     Line segments are represented by pairs of points that are the endpoints
     of the segment.  Values of type <type>lseg</type> are specified using any
     of the following syntaxes:
-->
线段是用线段的一对端点来代表的。<type>lseg</type>的值用下面语法声明：
<synopsis>
[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) ]
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   <replaceable>x2</replaceable> , <replaceable>y2</replaceable>
</synopsis>
<!-- 
     where
     <literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>
     and
     <literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>
     are the end points of the line segment.
 -->
这里的<literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>
和<literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>是线段的端点。 
    </para>

    <!--
<para>
     Line segments are output using the first syntax.
    </para>
-->
<para>
线段输出使用第一种语法。
</para>
   </sect2>

   <sect2>
    <!-- 
<title>Boxes</title> 
-->
<title>矩形</title>

    <indexterm>
     <!-- 
 <primary>box (data type)</primary>
 -->
 <primary>矩形(数据类型)</primary>
    </indexterm>

    <indexterm>
<!-- 
    <primary>rectangle</primary>
-->
     <primary>矩形</primary>
    </indexterm>

    
<para>
<!--
     Boxes are represented by pairs of points that are opposite
     corners of the box.
     Values of type <type>box</type> are specified using any of the following
     syntaxes:
-->
矩形是用一对对角点来表示的。<type>box</type>的值用下面语法声明：
<synopsis>
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   <replaceable>x2</replaceable> , <replaceable>y2</replaceable>
</synopsis>
<!-- 
     where
     <literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>
     and
     <literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>
     are any two opposite corners of the box.
 -->
这里的<literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>
和<literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>
是矩形的一对对角点。 
    </para>

    <!--
<para>
     Boxes are output using the second syntax.
    </para>
-->
<para>
矩形的输出使用第二种语法。
</para>

    <!--
<para>
     Any two opposite corners can be supplied on input, but the values
     will be reordered as needed to store the
     upper right and lower left corners, in that order.
    </para>
-->
<para>
任何两个对角都可以出现在输入中，但按照那样的顺序，
右上角和左下角的值会被重新排序以存储。
</para>
   </sect2>

   <sect2>
    <!-- 
<title>Paths</title>
-->
<title>路径</title>

    <indexterm>
     <!-- 
 <primary>path (data type)</primary> 
 -->
 <primary>路径(数据类型)</primary>
    </indexterm>

    <!--
<para>
     Paths are represented by lists of connected points. Paths can be
     <firstterm>open</firstterm>, where
     the first and last points in the list are considered not connected, or
     <firstterm>closed</firstterm>,
     where the first and last points are considered connected.
    </para>
-->
<para>
路径由一系列连接的点组成。路径可能是<firstterm>开放</firstterm>的，
也就是认为列表中第一个点和最后一个点没有连接，也可能是<firstterm>闭合</firstterm>的，
这时认为第一个和最后一个点连接起来。
</para>

    
<para>
<!--
     Values of type <type>path</type> are specified using any of the following
     syntaxes:
-->
<type>path</type>的数值用下面语法声明：
<synopsis>
[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) ]
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable>
</synopsis>
<!-- 
     where the points are the end points of the line segments
     comprising the path.  Square brackets (<literal>[]</>) indicate
     an open path, while parentheses (<literal>()</>) indicate a
     closed path.  When the outermost parentheses are omitted, as
     in the third through fifth syntaxes, a closed path is assumed.
 -->
这里的点是组成路径的线段的端点。方括弧(<literal>[]</>)表明一个开放的路径，
圆括弧(<literal>()</>)表明一个闭合的路径。当最外层的括号被省略，
如在第三至第五语法，会假定一个封闭的路径。
    </para>

    <!--
<para>
     Paths are output using the first or second syntax, as appropriate.
    </para>
-->
<para>
路径的输出使用第一种或第二种语法输出，在适当的时候。
</para>
   </sect2>

   <sect2 id="datatype-polygon">
    <!-- 
<title>Polygons</title>
-->
<title>多边形</title>

    <indexterm>
     <!-- 
 <primary>polygon</primary> 
 -->
 <primary>多边形</primary>
    </indexterm>

    <!--
<para>
     Polygons are represented by lists of points (the vertexes of the
     polygon). Polygons are very similar to closed paths, but are
     stored differently and have their own set of support routines.
    </para>
-->
<para>
多边形由一系列点代表(多边形的顶点)。多边形可以认为与闭合路径一样，但是存储方式不一样而且有自己的一套支持函数。
</para>

    
<para>
<!--
     Values of type <type>polygon</type> are specified using any of the
     following syntaxes:
-->
<type>polygon</type>的数值用下列语法声明：
<synopsis>
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable>
</synopsis>
<!-- 
     where the points are the end points of the line segments
     comprising the boundary of the polygon.
 -->
这里的点是多边形的端点。 
    </para>
    <!--
<para>
     Polygons are output using the first syntax.
    </para>
-->
<para>
多边形输出使用第一种语法。
</para>
   </sect2>

   <sect2 id="datatype-circle">
    <!-- 
<title>Circles</title> 
-->
<title>圆</title>

    <indexterm>
     <!-- 
 <primary>circle</primary> 
 -->
 <primary>圆</primary>
    </indexterm>

    
<para>
<!--
     Circles are represented by a center point and radius.
     Values of type <type>circle</type> are specified using any of the
     following syntaxes:
-->
圆由一个圆心和半径标识。<type>circle</type>的数值用下面语法表示：
<synopsis>
&lt; ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable> &gt;
( ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable> )
  ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable>
    <replaceable>x</replaceable> , <replaceable>y</replaceable>   , <replaceable>r</replaceable>
</synopsis>
<!-- 
     where
     <literal>(<replaceable>x</replaceable>,<replaceable>y</replaceable>)</>
     is the center point and <replaceable>r</replaceable> is the radius of the
     circle.
 -->
这里的<literal>(<replaceable>x</replaceable>,<replaceable>y</replaceable>)</>
是圆心，<replaceable>r</replaceable>是半径。 
    </para>

    <!--
<para>
     Circles are output using the first syntax.
    </para>
-->
<para>
圆的输出用第一种格式。
</para>
   </sect2>

  </sect1>

  <sect1 id="datatype-net-types">
   <!-- 
   <title>Network Address Types</title> 
   -->
   <title>网络地址类型</title>

   <indexterm zone="datatype-net-types">
    <!-- 
<primary>network</primary>
    <secondary>data types</secondary> 
-->
<primary>网络</primary>
    <secondary>数据类型</secondary>
   </indexterm>

   <!--
<para>
    <productname>PostgreSQL</> offers data types to store IPv4, IPv6, and MAC
    addresses, as shown in <xref linkend="datatype-net-types-table">.  It
    is better to use these types instead of plain text types to store
    network addresses, because
    these types offer input error checking and specialized
    operators and functions (see <xref linkend="functions-net">).
   </para>
-->
<para>
<productname>PostgreSQL</>提供用于存储 IPv4 、IPv6 、MAC 地址的数据类型，
在<xref linkend="datatype-net-types-table">里显示。
用这些数据类型存储网络地址比用纯文本类型好，
因为这些类型提供输入错误检查和特殊的操作和功能(见<xref linkend="functions-net">)。
</para>

    <table tocentry="1" id="datatype-net-types-table">
     <!-- 
 <title>Network Address Types</title> 
 -->
 <title>网络地址类型</title>
     <tgroup cols="3">
      <thead>
       <row>
        <!-- 
<entry>Name</entry>
        <entry>Storage Size</entry>
        <entry>Description</entry> 
-->
<entry>名字</entry>
        <entry>存储空间</entry>
        <entry>描述</entry>
       </row>
      </thead>
      <tbody>

       <row>
        <entry><type>cidr</type></entry>
        <!-- 
<entry>7 or 19 bytes</entry>
        <entry>IPv4 and IPv6 networks</entry> 
-->
<entry>7 或 19 字节</entry>
        <entry>IPv4 或 IPv6 网络</entry>
       </row>

       <row>
        <entry><type>inet</type></entry>
        <!-- 
<entry>7 or 19 bytes</entry>
        <entry>IPv4 and IPv6 hosts and networks</entry> 
-->
<entry>7 或 19 字节</entry>
        <entry>IPv4 或 IPv6 主机和网络</entry>
       </row>

       <row>
        <entry><type>macaddr</type></entry>
        <!-- 
<entry>6 bytes</entry>
        <entry>MAC addresses</entry> 
-->
<entry>6 字节</entry>
        <entry>MAC 地址</entry>
       </row>

      </tbody>
     </tgroup>
    </table>

   <!--
<para>
    When sorting <type>inet</type> or <type>cidr</type> data types,
    IPv4 addresses will always sort before IPv6 addresses, including
    IPv4 addresses encapsulated or mapped to IPv6 addresses, such as
    ::10.2.3.4 or ::ffff:10.4.3.2.
   </para>
-->
<para>
在对<type>inet</type>或<type>cidr</type>数据类型进行排序的时候，
IPv4 地址总是排在 IPv6 地址前面，包括那些封装或者是映射在 IPv6 地址里的 IPv4 地址，
比如 ::10.2.3.4 或 ::ffff:10.4.3.2。
</para>


   <sect2 id="datatype-inet">
    <title><type>inet</type></title>

    <indexterm>
     <!-- 
 <primary>inet (data type)</primary> 
 -->
 <primary>inet (数据类型)</primary>
    </indexterm>

    <!--
<para>
     The <type>inet</type> type holds an IPv4 or IPv6 host address, and
     optionally its subnet, all in one field.
     The subnet is represented by the number of network address bits
     present in the host address (the
     <quote>netmask</quote>).  If the netmask is 32 and the address is IPv4,
     then the value does not indicate a subnet, only a single host.
     In IPv6, the address length is 128 bits, so 128 bits specify a
     unique host address.  Note that if you
     want to accept only networks, you should use the
     <type>cidr</type> type rather than <type>inet</type>.
    </para>
-->
<para>
<type>inet</type>在一个数据域里保存主机的 IPv4 或 IPv6 地址，以及一个可选的等效子网。
子网的等效是通过计算主机地址中有多少位表示网络地址的方法来表示的(<quote>子网掩码</quote>)。
如果子网掩码是 32 并且地址是 IPv4 ，那么不表示任何子网，只是一台主机。
在 IPv6 里，地址长度是 128 位，因此 128 位表明一个唯一的主机地址。
请注意如果你想只接受网络地址，你应该使用<type>cidr</type>类型而不是<type>inet</type>类型。
</para>

    <!--
<para>
      The input format for this type is
      <replaceable class="parameter">address/y</replaceable>
      where
      <replaceable class="parameter">address</replaceable>
      is an IPv4 or IPv6 address and
      <replaceable class="parameter">y</replaceable>
      is the number of bits in the netmask.  If the
      <replaceable class="parameter">/y</replaceable>
      portion is missing, the
      netmask is 32 for IPv4 and 128 for IPv6, so the value represents
      just a single host.  On display, the
      <replaceable class="parameter">/y</replaceable>
      portion is suppressed if the netmask specifies a single host.
    </para>
-->
<para>
该类型的输入格式是<replaceable class="parameter">address/y</replaceable>，
这里的<replaceable class="parameter">address</replaceable>
是 IPv4 或者 IPv6 地址，<replaceable class="parameter">y</replaceable>
是子网掩码的二进制位数。如果<replaceable class="parameter">/y</replaceable>
部分未填，则子网掩码对 IPv4 而言是 32 ，对 IPv6 而言是 128 ，
所以该值表示只有一台主机。显示时，如果该值表示只有一台主机，
<replaceable class="parameter">/y</replaceable>将不会显示。
</para>
   </sect2>

   <sect2 id="datatype-cidr">
    <title><type>cidr</></title>

    <indexterm>
     <primary>cidr</primary>
    </indexterm>

    <!--
<para>
     The <type>cidr</type> type holds an IPv4 or IPv6 network specification.
     Input and output formats follow Classless Internet Domain Routing
     conventions.
     The format for specifying networks is <replaceable
     class="parameter">address/y</> where <replaceable
     class="parameter">address</> is the network represented as an
     IPv4 or IPv6 address, and <replaceable
     class="parameter">y</> is the number of bits in the netmask.  If
     <replaceable class="parameter">y</> is omitted, it is calculated
     using assumptions from the older classful network numbering system, except
     it will be at least large enough to include all of the octets
     written in the input.  It is an error to specify a network address
     that has bits set to the right of the specified netmask.
    </para>
-->
<para>
<type>cidr</type>保存一个 IPv4 或 IPv6 网络地址。其输入和输出遵循无类别的互联网域路由习惯。
声明一个网络的格式是<replaceable class="parameter">address/y</>，
这里的<replaceable class="parameter">address</>是 IPv4 或者 IPv6 地址，
<replaceable class="parameter">y</>是子网掩码的二进制位数。如果省略<replaceable class="parameter">y</>，
那么掩码部分用旧的有类别的网络编号系统进行计算，但要求输入的数据已经包括了确定掩码所需的所有字节。
声明一个指定掩码的网络地址是错误的。
</para>

    <!--
<para>
     <xref linkend="datatype-net-cidr-table"> shows some examples.
    </para>
-->
<para>
<xref linkend="datatype-net-cidr-table"> 是些例子。
</para>

     <table id="datatype-net-cidr-table">
      <!-- 
  <title><type>cidr</> Type Input Examples</title> 
  -->
  <title><type>cidr</> 类型输入举例</title>
      <tgroup cols="3">
       <thead>
        <row>
         <!-- 
 <entry><type>cidr</type> Input</entry>
         <entry><type>cidr</type> Output</entry> 
 -->
 <entry><type>cidr</type> 输入</entry>
         <entry><type>cidr</type> 输出</entry>
         <entry><literal><function>abbrev(<type>cidr</type>)</function></literal></entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>192.168.100.128/25</entry>
         <entry>192.168.100.128/25</entry>
         <entry>192.168.100.128/25</entry>
        </row>
        <row>
         <entry>192.168/24</entry>
         <entry>192.168.0.0/24</entry>
         <entry>192.168.0/24</entry>
        </row>
        <row>
         <entry>192.168/25</entry>
         <entry>192.168.0.0/25</entry>
         <entry>192.168.0.0/25</entry>
        </row>
        <row>
         <entry>192.168.1</entry>
         <entry>192.168.1.0/24</entry>
         <entry>192.168.1/24</entry>
        </row>
        <row>
         <entry>192.168</entry>
         <entry>192.168.0.0/24</entry>
         <entry>192.168.0/24</entry>
        </row>
        <row>
         <entry>128.1</entry>
         <entry>128.1.0.0/16</entry>
         <entry>128.1/16</entry>
        </row>
        <row>
         <entry>128</entry>
         <entry>128.0.0.0/16</entry>
         <entry>128.0/16</entry>
        </row>
        <row>
         <entry>128.1.2</entry>
         <entry>128.1.2.0/24</entry>
         <entry>128.1.2/24</entry>
        </row>
        <row>
         <entry>10.1.2</entry>
         <entry>10.1.2.0/24</entry>
         <entry>10.1.2/24</entry>
        </row>
        <row>
         <entry>10.1</entry>
         <entry>10.1.0.0/16</entry>
         <entry>10.1/16</entry>
        </row>
        <row>
         <entry>10</entry>
         <entry>10.0.0.0/8</entry>
         <entry>10/8</entry>
        </row>
        <row>
         <entry>10.1.2.3/32</entry>
         <entry>10.1.2.3/32</entry>
         <entry>10.1.2.3/32</entry>
        </row>
        <row>
         <entry>2001:4f8:3:ba::/64</entry>
         <entry>2001:4f8:3:ba::/64</entry>
         <entry>2001:4f8:3:ba::/64</entry>
        </row>
        <row>
         <entry>2001:4f8:3:ba:2e0:81ff:fe22:d1f1/128</entry>
         <entry>2001:4f8:3:ba:2e0:81ff:fe22:d1f1/128</entry>
         <entry>2001:4f8:3:ba:2e0:81ff:fe22:d1f1</entry>
        </row>
        <row>
         <entry>::ffff:1.2.3.0/120</entry>
         <entry>::ffff:1.2.3.0/120</entry>
         <entry>::ffff:1.2.3/120</entry>
        </row>
        <row>
         <entry>::ffff:1.2.3.0/128</entry>
         <entry>::ffff:1.2.3.0/128</entry>
         <entry>::ffff:1.2.3.0/128</entry>
        </row>
       </tbody>
      </tgroup>
     </table>
   </sect2>

   <sect2 id="datatype-inet-vs-cidr">
    <!-- 
<title><type>inet</type> vs. <type>cidr</type></title> 
-->
<title><type>inet</type> 对比 <type>cidr</type></title>

    <!--
<para>
    The essential difference between <type>inet</type> and <type>cidr</type>
    data types is that <type>inet</type> accepts values with nonzero bits to
    the right of the netmask, whereas <type>cidr</type> does not.
    </para>
-->
<para>
<type>inet</type>和<type>cidr</type>类型之间的基本区别是<type>inet</type>
接受子网掩码，而<type>cidr</type>不接受。
</para>

      <tip>
        <!--
<para>
        If you do not like the output format for <type>inet</type> or
        <type>cidr</type> values, try the functions <function>host</>,
        <function>text</>, and <function>abbrev</>.
        </para>
-->
<para>
如果你不喜欢<type>inet</type>或<type>cidr</type>值的输出格式，
请试一下<function>host</>,<function>text</>和<function>abbrev</>函数。
</para>
      </tip>
   </sect2>

   <sect2 id="datatype-macaddr">
    <title><type>macaddr</type></title>

    <indexterm>
     <!-- 
 <primary>macaddr (data type)</primary> 
 -->
 <primary>macaddr (数据类型)</primary>
    </indexterm>

    <indexterm>
     <!-- 
 <primary>MAC address</primary> 
 -->
 <primary>MAC 地址</primary>
     <see>macaddr</see>
    </indexterm>

    
<para>
<!--
     The <type>macaddr</> type stores MAC addresses, known for example
     from Ethernet card hardware addresses (although MAC addresses are
     used for other purposes as well).  Input is accepted in the
     following formats:
-->
<type>macaddr</>类型存储 MAC 地址，也就是以太网卡硬件地址(尽管 MAC 地址还用于其它用途)。
可以接受下列格式：
     <simplelist>
      <member><literal>'08:00:2b:01:02:03'</></member>
      <member><literal>'08-00-2b-01-02-03'</></member>
      <member><literal>'08002b:010203'</></member>
      <member><literal>'08002b-010203'</></member>
      <member><literal>'0800.2b01.0203'</></member>
      <member><literal>'08002b010203'</></member>
     </simplelist>
<!-- 
     These examples would all specify the same address.  Upper and
     lower case is accepted for the digits
     <literal>a</> through <literal>f</>.  Output is always in the
     first of the forms shown.
 -->
它们声明的都是同一个地址。对于数据位<literal>a</>到<literal>f</>，
大小写都行。输出总是我们上面给出的第一种形式。 
    </para>

    <!--
<para>
     IEEE Std 802-2001 specifies the second shown form (with hyphens)
     as the canonical form for MAC addresses, and specifies the first
     form (with colons) as the bit-reversed notation, so that
     08-00-2b-01-02-03 = 01:00:4D:08:04:0C.  This convention is widely
     ignored nowadays, and it is relevant only for obsolete network
     protocols (such as Token Ring).  PostgreSQL makes no provisions
     for bit reversal, and all accepted formats use the canonical LSB
     order.
    </para>
-->
<para>
IEEE标准802-2001指定第二种形式（带连字符）为MAC地址的标准格式，
并指定的第一种形式（用冒号）为位反转符号，因此08-00-2b-01-02-03=01:00:4D:08:04:0C。
这个条约现在已很少使用，它和过时的网络协议（如令牌环）有关。
PostgreSQL对位反转没有规定，并且所有接受的格式使用LSB协议顺序。
</para>

    <!--
<para>
     The remaining four input formats are not part of any standard.
    </para>
-->
<para>
其余四个输入格式不是任何标准的一部分。
</para>
   </sect2>

  </sect1>

  <sect1 id="datatype-bit">
   <!-- 
   <title>Bit String Types</title>
   -->
   <title>位串类型</title>

   <indexterm zone="datatype-bit">
    <!-- 
<primary>bit string</primary>
    <secondary>data type</secondary> 
-->
<primary>位串</primary>
    <secondary>数据类型</secondary>
   </indexterm>

   <!--
<para>
    Bit strings are strings of 1's and 0's.  They can be used to store
    or visualize bit masks.  There are two SQL bit types:
    <type>bit(<replaceable>n</replaceable>)</type> and <type>bit
    varying(<replaceable>n</replaceable>)</type>, where
    <replaceable>n</replaceable> is a positive integer.
   </para>
-->
<para>
位串就是一串 1 和 0 的字符串。它们可以用于存储和直观化位掩码。
我们有两种 SQL 位类型：<type>bit(<replaceable>n</replaceable>)</type>
 和<type>bit varying(<replaceable>n</replaceable>)</type>，
 这里的<replaceable>n</replaceable>是一个正整数。
</para>

   <!--
<para>
    <type>bit</type> type data must match the length
    <replaceable>n</replaceable> exactly; it is an error to attempt to
    store shorter or longer bit strings.  <type>bit varying</type> data is
    of variable length up to the maximum length
    <replaceable>n</replaceable>; longer strings will be rejected.
    Writing <type>bit</type> without a length is equivalent to
    <literal>bit(1)</literal>, while <type>bit varying</type> without a length
    specification means unlimited length.
   </para>
-->
<para>
<type>bit</type>类型的数据必须准确匹配长度<replaceable>n</replaceable>，
试图存储短些或者长一些的数据都是错误的。<type>bit varying</type>
类型数据是最长<replaceable>n</replaceable>的变长类型；更长的串会被拒绝。
写一个没有长度的<type>bit</type>等效于<literal>bit(1)</literal>，
没有长度的<type>bit varying</type>意思是没有长度限制。
</para>

   <note>
    <!--
<para>
     If one explicitly casts a bit-string value to
     <type>bit(<replaceable>n</>)</type>, it will be truncated or
     zero-padded on the right to be exactly <replaceable>n</> bits,
     without raising an error.  Similarly,
     if one explicitly casts a bit-string value to
     <type>bit varying(<replaceable>n</>)</type>, it will be truncated
     on the right if it is more than <replaceable>n</> bits.
    </para>
-->
<para>
如果我们明确地把一个位串值转换成<type>bit(<replaceable>n</>)</type>，
那么它的右边将被截断或者在右边补齐零，直到刚好<replaceable>n</>位，
而不会抛出任何错误。类似地，如果我们明确地把一个位串数值转换成
<type>bit varying(<replaceable>n</>)</type>，如果它超过了<replaceable>n</>位，
那么它的右边将被截断。
</para>
   </note>

   <!--
<para>
    Refer to <xref
    linkend="sql-syntax-bit-strings"> for information about the syntax
    of bit string constants.  Bit-logical operators and string
    manipulation functions are available; see <xref
    linkend="functions-bitstring">.
   </para>
-->
<para>
请参考<xref linkend="sql-syntax-bit-strings">获取有关位串常量的语法信息。
还有一些位逻辑操作符和位处理函数可用；参见<xref linkend="functions-bitstring">。
</para>

   <example>
    <!-- 
<title>Using the Bit String Types</title> 
-->
<title>使用位串类型</title>

<programlisting>
CREATE TABLE test (a BIT(3), b BIT VARYING(5));
INSERT INTO test VALUES (B'101', B'00');
INSERT INTO test VALUES (B'10', B'101');
<computeroutput>
ERROR:  bit string length 2 does not match type bit(3)
</computeroutput>
INSERT INTO test VALUES (B'10'::bit(3), B'101');
SELECT * FROM test;
<computeroutput>
  a  |  b
-----+-----
 101 | 00
 100 | 101
</computeroutput>
</programlisting>
   </example>

   <!--
<para>
    A bit string value requires 1 byte for each group of 8 bits, plus
    5 or 8 bytes overhead depending on the length of the string
    (but long values may be compressed or moved out-of-line, as explained
    in <xref linkend="datatype-character"> for character strings).
   </para>
-->
<para>
位字符串值需要1字节，每组8位，增加5或8字节的开销取决于字符串的长度
（但是长值会被压缩或移动到另外一条线上，
<xref linkend="datatype-character">中有相关字符串的解释）。
</para>
  </sect1>

  <sect1 id="datatype-textsearch">
   <!-- 
   <title>Text Search Types</title> 
   -->
   <title>文本搜索类型</title>

   <indexterm zone="datatype-textsearch">
    <!-- 
<primary>full text search</primary>
    <secondary>data types</secondary> 
-->
<primary>全文检索</primary>
    <secondary>数据类型</secondary>
   </indexterm>

   <indexterm zone="datatype-textsearch">
    <!-- 
<primary>text search</primary>
    <secondary>data types</secondary> 
-->
<primary>文本搜索</primary>
    <secondary>数据类型</secondary>
   </indexterm>

   <!--
<para>
    <productname>PostgreSQL</productname> provides two data types that
    are designed to support full text search, which is the activity of
    searching through a collection of natural-language <firstterm>documents</>
    to locate those that best match a <firstterm>query</>.
    The <type>tsvector</type> type represents a document in a form optimized
    for text search; the <type>tsquery</type> type similarly represents
    a text query.
    <xref linkend="textsearch"> provides a detailed explanation of this
    facility, and <xref linkend="functions-textsearch"> summarizes the
    related functions and operators.
   </para>
-->
<para>
<productname>PostgreSQL</productname>提供了两种数据类型用于支持全文检索，
即通过自然语言<firstterm>documents</>的集合来找到那些匹配一个<firstterm>query</>
的检索。<type>tsvector</type>类型产生一个文档（以优化了全文检索的形式），
<type>tsquery</type>类型用于代表查询。<xref linkend="textsearch">
中说明了这两个类型，同时<xref linkend="functions-textsearch">
总结了相关的函数和操作符。
</para>

   <sect2 id="datatype-tsvector">
    <title><type>tsvector</type></title>

    <indexterm>
     <!-- 
 <primary>tsvector (data type)</primary> 
 -->
 <primary>tsvector (数据类型)</primary>
    </indexterm>
    
<para>
<!--
     A <type>tsvector</type> value is a sorted list of distinct
     <firstterm>lexemes</>, which are words that have been
     <firstterm>normalized</> to merge different variants of the same word
     (see <xref linkend="textsearch"> for details).  Sorting and
     duplicate-elimination are done automatically during input, as shown in
     this example:
-->
<type>tsvector</type>的值是一个无重复值的<firstterm>lexemes</>排序列表，
即一些同一个词的不同变种的<firstterm>标准化</> （可参阅<xref linkend="textsearch">）。
在输入的同时会自动排序和消除重复，如：
<programlisting>
SELECT 'a fat cat sat on a mat and ate a fat rat'::tsvector;
                      tsvector
----------------------------------------------------
 'a' 'and' 'ate' 'cat' 'fat' 'mat' 'on' 'rat' 'sat'
</programlisting>
<!-- 
     To represent
     lexemes containing whitespace or punctuation, surround them with quotes:
 -->
 为了包含空格或标点符号，可以用引号标记：
<programlisting>
SELECT $$the lexeme '    ' contains spaces$$::tsvector;
                 tsvector                  
-------------------------------------------
 '    ' 'contains' 'lexeme' 'spaces' 'the'
</programlisting>
<!-- 
     (We use dollar-quoted string literals in this example and the next one
     to avoid the confusion of having to double quote marks within the
     literals.)  Embedded quotes and backslashes must be doubled:
 -->
（在这个例子中，我们使用了双引号美元字符串文本，
下一个例子是为了避免文本中双引号的混淆。）枚举的引号和反斜杠必须双倍： 
<programlisting>
SELECT $$the lexeme 'Joe''s' contains a quote$$::tsvector;
                    tsvector                    
------------------------------------------------
 'Joe''s' 'a' 'contains' 'lexeme' 'quote' 'the'
</programlisting>
<!-- 
     Optionally, integer <firstterm>positions</>
     can be attached to lexemes:
 -->
可选的，整型<firstterm>positions</>也可以放到词汇中： 
<programlisting>
SELECT 'a:1 fat:2 cat:3 sat:4 on:5 a:6 mat:7 and:8 ate:9 a:10 fat:11 rat:12'::tsvector;
                                  tsvector
-------------------------------------------------------------------------------
 'a':1,6,10 'and':8 'ate':9 'cat':3 'fat':2,11 'mat':7 'on':5 'rat':12 'sat':4
</programlisting>
<!-- 
     A position normally indicates the source word's location in the
     document.  Positional information can be used for
     <firstterm>proximity ranking</firstterm>.  Position values can
     range from 1 to 16383; larger numbers are silently set to 16383.
     Duplicate positions for the same lexeme are discarded.
 -->
位置通常表示文档中的源字的位置。位置信息可以用于<firstterm>proximity ranking</firstterm>。
位置值的范围是1到16383，最大值默认是16383。相同词的重复位会被忽略掉。  
    </para>
    
<para>
<!--
     Lexemes that have positions can further be labeled with a
     <firstterm>weight</>, which can be <literal>A</literal>,
     <literal>B</literal>, <literal>C</literal>, or <literal>D</literal>.
     <literal>D</literal> is the default and hence is not shown on output:
-->
拥有位置的词汇甚至可以用一个<firstterm>权</>来标记，这个权可以是<literal>A</literal>，
<literal>B</literal>，<literal>C</literal>或<literal>D</literal>。
默认的是<literal>D</literal>，因此输出中不会出现：
<programlisting>
SELECT 'a:1A fat:2B,4C cat:5D'::tsvector;
          tsvector          
----------------------------
 'a':1A 'cat':5 'fat':2B,4C
</programlisting>
<!-- 
     Weights are typically used to reflect document structure, for example
     by marking title words differently from body words.  Text search
     ranking functions can assign different priorities to the different
     weight markers.
 -->
权可以用来反映文档结构，如：标记标题以与主体相区别。
全文检索排序函数可以为不同的权标记来分配不同的优先级。 
    </para>
    
<para>
<!--
     It is important to understand that the
     <type>tsvector</type> type itself does not perform any normalization;
     it assumes the words it is given are normalized appropriately
     for the application.  For example,
-->
充分理解<type>tsvector</type>类型不能自己标准化这一点是很重要的，
它假设传递给它的单词对应用程序来说是恰当的标准化了的，如：
<programlisting>
select 'The Fat Rats'::tsvector;
      tsvector      
--------------------
 'Fat' 'Rats' 'The'
</programlisting>
<!-- 
     For most English-text-searching applications the above words would
     be considered non-normalized, but <type>tsvector</type> doesn't care.
     Raw document text should usually be passed through
     <function>to_tsvector</> to normalize the words appropriately
     for searching:
 -->
对大多数的英文全文检索应用来说，上面的单词会被认为非规范化的，
但<type>tsvector</type>并不关心这些。原始文件中的文字应该通过<function>to_tsvector</>
来为检索恰当的规范化这些单词: 
<programlisting>
SELECT to_tsvector('english', 'The Fat Rats');
   to_tsvector   
-----------------
 'fat':2 'rat':3
</programlisting>
<!-- 
     Again, see <xref linkend="textsearch"> for more detail.
 -->
 详细信息可参阅<xref linkend="textsearch">。
    </para>

   </sect2>

   <sect2 id="datatype-tsquery">
    <title><type>tsquery</type></title>

    <indexterm>
     <!-- 
 <primary>tsquery (data type)</primary> 
 -->
 <primary>tsquery (数据类型)</primary>
    </indexterm>
   
<para>
<!--
     A <type>tsquery</type> value stores lexemes that are to be
     searched for, and combines them honoring the Boolean operators
     <literal>&amp;</literal> (AND), <literal>|</literal> (OR), and
     <literal>!</> (NOT).  Parentheses can be used to enforce grouping
     of the operators:
-->
<type>tsquery</type>存储用于检索的词汇，并且使用布尔操作符
<literal>&amp;</literal>(AND)，<literal>|</literal>(OR)和<literal>!</>(NOT)
来组合它们。括号用来强调操作符的分组：
<programlisting>
SELECT 'fat &amp; rat'::tsquery;
    tsquery    
---------------
 'fat' &amp; 'rat'

SELECT 'fat &amp; (rat | cat)'::tsquery;
          tsquery          
---------------------------
 'fat' &amp; ( 'rat' | 'cat' )

SELECT 'fat &amp; rat &amp; ! cat'::tsquery;
        tsquery         
------------------------
 'fat' &amp; 'rat' &amp; !'cat'
</programlisting>
<!-- 
     In the absence of parentheses, <literal>!</> (NOT) binds most tightly,
     and <literal>&amp;</literal> (AND) binds more tightly than
     <literal>|</literal> (OR).
 -->
在没有括号的情况下，<literal>!</>(NOT)结合的最紧密，
而<literal>&amp;</literal>(AND)结合的比<literal>|</literal>(OR)紧密。 
    </para>

   
<para>
 <!--
     Optionally, lexemes in a <type>tsquery</type> can be labeled with
     one or more weight letters, which restricts them to match only
     <type>tsvector</> lexemes with matching weights:
-->
可选的，<type>tsquery</type>中的词汇可以被一个或多个权字母来标记，
这些权字母用来限制它们只能与带有匹配权的<type>tsvector</>词汇进行匹配。
<programlisting>
SELECT 'fat:ab &amp; cat'::tsquery;
    tsquery
------------------
 'fat':AB &amp; 'cat'
</programlisting>
    </para>
    
<para>
<!--
     Also, lexemes in a <type>tsquery</type> can be labeled with <literal>*</>
     to specify prefix matching:
 -->
同样，<type>tsquery</type>中的词汇可以用<literal>*</>进行标记来指定前缀匹配： 
<programlisting>
SELECT 'super:*'::tsquery;
  tsquery  
-----------
 'super':*
</programlisting>
<!-- 
     This query will match any word in a <type>tsvector</> that begins
     with <quote>super</>.  Note that prefixes are first processed by
     text search configurations, which means this comparison returns
     true: 
-->
这个查询可以匹配<type>tsvector</>中以<quote>super</>开始的任意单词。
请注意，前缀首先被文本搜索配置处理，这也就意味着下面的结果为真：
<programlisting>
SELECT to_tsvector( 'postgraduate' ) @@ to_tsquery( 'postgres:*' );
 ?column? 
----------
 t
(1 row)
</programlisting>
     <!-- 
 because <literal>postgres</> gets stemmed to <literal>postgr</>: 
 -->
 因为<literal>postgres</>去掉后面后得到<literal>postgr</>:
<programlisting>
SELECT to_tsquery('postgres:*');
 to_tsquery 
------------
 'postgr':*
(1 row)
</programlisting>
     <!-- 
 which then matches <literal>postgraduate</>. 
 -->
这样就匹配<literal>postgraduate</>了。 
    </para>

    
<para>
<!--
     Quoting rules for lexemes are the same as described previously for
     lexemes in <type>tsvector</>; and, as with <type>tsvector</>,
     any required normalization of words must be done before converting
     to the <type>tsquery</> type.  The <function>to_tsquery</>
     function is convenient for performing such normalization:
-->
词汇的引用规则与之前<type>tsvector</>中词汇的描述一样；并且，
与<type>tsvector</>一样，任何单词必须在转换为<type>tsquery</>类型前规范化。
<function>to_tsquery</>函数可以方便的用来执行规范化。
<programlisting>
SELECT to_tsquery('Fat:ab &amp; Cats');
    to_tsquery    
------------------
 'fat':AB &amp; 'cat'
</programlisting>
    </para>
   </sect2>

  </sect1>

  <sect1 id="datatype-uuid">
   <!-- 
   <title><acronym>UUID</acronym> Type</title>
   -->
   <title><acronym>UUID</acronym> 类型</title>

   <indexterm zone="datatype-uuid">
    <primary>UUID</primary>
   </indexterm>

   <!--
<para>
    The data type <type>uuid</type> stores Universally Unique Identifiers
    (UUID) as defined by RFC 4122, ISO/IEC 9834-8:2005, and related standards.
    (Some systems refer to this data type as a globally unique identifier, or
    GUID,<indexterm><primary>GUID</primary></indexterm> instead.)  This
    identifier is a 128-bit quantity that is generated by an algorithm chosen
    to make it very unlikely that the same identifier will be generated by
    anyone else in the known universe using the same algorithm.  Therefore,
    for distributed systems, these identifiers provide a better uniqueness
    guarantee than sequence generators, which
    are only unique within a single database.
   </para>
-->
<para>
<type>uuid</type>数据类型用来存储RFC 4122，ISO/IEF 9834-8:2005以及相关标准定义的通用唯一标识符（UUID）。
（一些系统认为这个数据类型为全球唯一标识符，或GUID。<indexterm><primary>GUID</primary></indexterm>）
这个标识符是一个由算法产生的128位标识符，使它不可能在已知使用相同算法的模块中和其他方式产生的标识符相同。
因此，对分布式系统而言，这种标识符比序列能更好的提供唯一性保证，因为序列只能在单一数据库中保证唯一。
</para>
   
<para>
<!--
    A UUID is written as a sequence of lower-case hexadecimal digits,
    in several groups separated by hyphens, specifically a group of 8
    digits followed by three groups of 4 digits followed by a group of
    12 digits, for a total of 32 digits representing the 128 bits.  An
    example of a UUID in this standard form is:
-->
UUID被写成一个小写十六进制数字的序列，由分字符分成几组，
特别是一组8位数字+3组4位数字+一组12位数字，总共32个数字代表128位，
一个这种标准的UUID例子如下：
<programlisting>
a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11
</programlisting>
<!-- 
    <productname>PostgreSQL</productname> also accepts the following
    alternative forms for input:
    use of upper-case digits, the standard format surrounded by
    braces, omitting some or all hyphens, adding a hyphen after any
    group of four digits.  Examples are: 
-->
<productname>PostgreSQL</productname>同样支持以其他方式输入：大写数字，
由花括号包围的标准格式，省略部分或所有连字符，在任意一组四位数字之后加一个连字符。如：
<programlisting>
A0EEBC99-9C0B-4EF8-BB6D-6BB9BD380A11
{a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11}
a0eebc999c0b4ef8bb6d6bb9bd380a11
a0ee-bc99-9c0b-4ef8-bb6d-6bb9-bd38-0a11
{a0eebc99-9c0b4ef8-bb6d6bb9-bd380a11}
</programlisting>
   <!-- 
   Output is always in the standard form. 
   -->
 一般是以标准格式输出。  
   </para>

   <!--
<para>
    <productname>PostgreSQL</productname> provides storage and comparison
    functions for UUIDs, but the core database does not include any
    function for generating UUIDs, because no single algorithm is well
    suited for every application.  The <xref
    linkend="uuid-ossp"> module
    provides functions that implement several standard algorithms.
    The <xref linkend="pgcrypto"> module also provides a generation
    function for random UUIDs.
    Alternatively, UUIDs could be generated by client applications or
    other libraries invoked through a server-side function.
   </para>
-->
<para>
<productname>PostgreSQL</productname>为UUID提供了存储和比较函数，
但核心数据库不包括能生成UUID的函数，因为没有单一的算法非常适合于每一个应用程序。
<xref linkend="uuid-ossp">模块提供了实施几个标准算法的函数。
<xref linkend="pgcrypto">模块也为随机UUID提供了一个生成函数。另外，
UUID可以由客户端应用或通过服务器端函数库调用而生成。
</para>
  </sect1>

  <sect1 id="datatype-xml">
   <!-- 
   <title><acronym>XML</> Type</title> 
   -->
   <title><acronym>XML</> 类型</title>

   <indexterm zone="datatype-xml">
    <primary>XML</primary>
   </indexterm>

   <!--
<para>
    The <type>xml</type> data type can be used to store XML data.  Its
    advantage over storing XML data in a <type>text</type> field is that it
    checks the input values for well-formedness, and there are support
    functions to perform type-safe operations on it; see <xref
    linkend="functions-xml">.  Use of this data type requires the
    installation to have been built with <command>configure
    &#045；-with-libxml</>.
   </para>
-->
<para>
<type>xml</type>数据类型可以用于存储XML数据。
将XML数据存到<type>text</type>类型中的优势在于它能够为结构良好性来检查输入值，
并且还支持函数对其进行类型安全性检查，可参阅<xref linkend="functions-xml">。
要使用这个数据类型，编译时必须使用<command>configure --with-libxml</>。
</para>

   <!--
<para>
    The <type>xml</type> type can store well-formed
    <quote>documents</quote>, as defined by the XML standard, as well
    as <quote>content</quote> fragments, which are defined by the
    production <literal>XMLDecl? content</literal> in the XML
    standard.  Roughly, this means that content fragments can have
    more than one top-level element or character node.  The expression
    <literal><replaceable>xmlvalue</replaceable> IS DOCUMENT</literal>
    can be used to evaluate whether a particular <type>xml</type>
    value is a full document or only a content fragment.
   </para>
-->
<para>
<type>xml</type>可以存储由XML标准定义的格式良好的<quote>文档</quote>，
以及由XML标准中的<literal>XMLDecl? content</literal>定义的<quote>内容</quote>片段，
大致上，这意味着内容片段可以有多个顶级元素或字符节点。
<literal><replaceable>xmlvalue</replaceable> IS DOCUMENT</literal>
表达式可以用来判断一个特定的<type>xml</type>值是一个完整的文件还是内容片段。
</para>

   <sect2>
    <!-- 
<title>Creating XML Values</title> 
-->
<title>创建XML值</title>
  
<para>
 <!--
    To produce a value of type <type>xml</type> from character data,
    use the function
    <function>xmlparse</function>:<indexterm><primary>xmlparse</primary></indexterm>
-->
使用函数<function>xmlparse</function>:<indexterm><primary>xmlparse</primary></indexterm>
来从字符数据产生<type>xml</type>类型的值：
<synopsis>
XMLPARSE ( { DOCUMENT | CONTENT } <replaceable>value</replaceable>)
</synopsis>
    <!-- 
Examples: 
-->
例子：
<programlisting><![CDATA[
XMLPARSE (DOCUMENT '<?xml version="1.0"?><book><title>Manual</title><chapter>...</chapter></book>')
XMLPARSE (CONTENT 'abc<foo>bar</foo><bar>foo</bar>')
]]></programlisting>
    <!-- 
While this is the only way to convert character strings into XML
    values according to the SQL standard, the PostgreSQL-specific
    syntaxes: 
-->
然而根据SQL标准，这是唯一的用于将字符串转换成XML值的方式，PostgreSQL特有的语法也可以使用：
<programlisting><![CDATA[
xml '<foo>bar</foo>'
'<foo>bar</foo>'::xml
]]></programlisting>
    <!-- 
can also be used. 
-->
   </para>

   <!--
<para>
    The <type>xml</type> type does not validate input values
    against a document type declaration
    (DTD),<indexterm><primary>DTD</primary></indexterm>
    even when the input value specifies a DTD.
    There is also currently no built-in support for validating against
    other XML schema languages such as XML Schema.
   </para>
-->
<para>
<type>xml</type>类型对一个文档类型声明（DTD）不会验证输入值，<indexterm><primary>DTD</primary></indexterm>
即使输入值声明了一个DTD。目前没有内置支持用于对其他XML架构语言（如XML Schema）验证。 
</para>

   
<para>
<!--
    The inverse operation, producing a character string value from
    <type>xml</type>, uses the function
    <function>xmlserialize</function>:<indexterm><primary>xmlserialize</primary></indexterm>
-->
使用函数<function>xmlserialize</function>:<indexterm><primary>xmlserialize</primary></indexterm>
来从<type>xml</type>产生一个字符串。
<synopsis>
XMLSERIALIZE ( { DOCUMENT | CONTENT } <replaceable>value</replaceable> AS <replaceable>type</replaceable> )
</synopsis>
<!-- 
    <replaceable>type</replaceable> can be
    <type>character</type>, <type>character varying</type>, or
    <type>text</type> (or an alias for one of those).  Again, according
    to the SQL standard, this is the only way to convert between type
    <type>xml</type> and character types, but PostgreSQL also allows
    you to simply cast the value.
-->
<replaceable>type</replaceable>可以是<type>character</type>，<type>character varying</type>
或<type>text</type>(或其中某个的变种)。同时，根据SQL标准，
这是<type>xml</type>和字符类型之间的唯一的转换方式，但PostgreSQL仍支持简单的值转换。
   </para>
   
<para>
<!--
    When a character string value is cast to or from type
    <type>xml</type> without going through <type>XMLPARSE</type> or
    <type>XMLSERIALIZE</type>, respectively, the choice of
    <literal>DOCUMENT</literal> versus <literal>CONTENT</literal> is
    determined by the <quote>XML option</quote>
    <indexterm><primary>XML option</primary></indexterm>
    session configuration parameter, which can be set using the
    standard command:
-->
当一个字符串值在没有通过<type>XMLPARSE</type>或<type>XMLSERIALIZE</type>的情况下，
与<type>xml</type>类型进行转换时，分别的，选择<literal>DOCUMENT</literal>与<literal>CONTENT</literal>
是由<quote>XML option</quote><indexterm><primary>XML option</primary></indexterm>
会话配置参数决定，这个配置参数可以由标准命令来设置：
<synopsis>
SET XML OPTION { DOCUMENT | CONTENT };
</synopsis>
    <!-- 
or the more PostgreSQL-like syntax 
-->
或更多类似的PostgreSQL语法：
<synopsis>
SET xmloption TO { DOCUMENT | CONTENT };
</synopsis>
<!-- 
    The default is <literal>CONTENT</literal>, so all forms of XML
    data are allowed. 
-->
默认是<literal>CONTENT</literal>，因此所有的XML数据格式都能支持。
   </para>

   <note>
    <!--
<para>
     With the default XML option setting, you cannot directly cast
     character strings to type <type>xml</type> if they contain a
     document type declaration, because the definition of XML content
     fragment does not accept them.  If you need to do that, either
     use <literal>XMLPARSE</literal> or change the XML option.
    </para>
-->
<para>
随着默认XML选项的设置，如果字符串中包含一个文档类型声明，
那么你不能直接将其转换成<type>xml</type>类型，因为XML内容片断的定义不支持。
如果非得需要这么做，要么使用<literal>XMLPARSE</literal>，要么更改XML选项。
</para>
   </note>

   </sect2>

   <sect2>
    <!-- 
<title>Encoding Handling</title> 
-->
<title>编码处理</title>
   <!--
<para>
    Care must be taken when dealing with multiple character encodings
    on the client, server, and in the XML data passed through them.
    When using the text mode to pass queries to the server and query
    results to the client (which is the normal mode), PostgreSQL
    converts all character data passed between the client and the
    server and vice versa to the character encoding of the respective
    end; see <xref linkend="multibyte">.  This includes string
    representations of XML values, such as in the above examples.
    This would ordinarily mean that encoding declarations contained in
    XML data can become invalid as the character data is converted
    to other encodings while traveling between client and server,
    because the embedded encoding declaration is not changed.  To cope
    with this behavior, encoding declarations contained in
    character strings presented for input to the <type>xml</type> type
    are <emphasis>ignored</emphasis>, and content is assumed
    to be in the current server encoding.  Consequently, for correct
    processing, character strings of XML data must be sent
    from the client in the current client encoding.  It is the
    responsibility of the client to either convert documents to the
    current client encoding before sending them to the server, or to
    adjust the client encoding appropriately.  On output, values of
    type <type>xml</type> will not have an encoding declaration, and
    clients should assume all data is in the current client
    encoding.
   </para>
-->
<para>
在对客户端和服务器端进行多字符编码，以及在通过它们传递XML数据时需要格外注意。
当使用文本模式（正常模式）在服务器端和客户端之间传递查询和查询结果时，
PostgreSQL在各自终端对所有传递的字符数据和字符编码进行相互转换，参阅<xref linkend="multibyte">。
这包括XML值的字符串表示形式，如上面的例子。这通常意味着XML数据中的编码声明，
在客户端和服务器之间传递时，可以成为无效字符数据转换为其他编码。
这是因为枚举编码声明没有改变。为了应对该问题，
提交输入到<type>xml</type> 类型的字符串中的编码声明会被<emphasis>ignored</emphasis>，
同时，内容会被认为是在当前服务器编码中。所以，对正确的处理来说，
XML数据的字符串必须从在当前客户端编码中的客户端发送。客户端有责任，
要么在传递到服务器之前将文档转换成当前客户端编码，要么适当的调整客户端编码。
输出时，<type>xml</type>类型的值不会有编码声明，
同时客户端会认为所有的数据都是在当前客户端编码之中的。
</para>

   <!--
<para>
    When using binary mode to pass query parameters to the server
    and query results back to the client, no character set conversion
    is performed, so the situation is different.  In this case, an
    encoding declaration in the XML data will be observed, and if it
    is absent, the data will be assumed to be in UTF-8 (as required by
    the XML standard; note that PostgreSQL does not support UTF-16).
    On output, data will have an encoding declaration
    specifying the client encoding, unless the client encoding is
    UTF-8, in which case it will be omitted.
   </para>
-->
<para>
当使用二进制模式在服务器和客户端之间传递查询参数和查询结果，没有执行字符集转换，
因此解决方法是不同的。在这种情况下，将会遵守XML数据中的编码声明，
并且如果声明不存在，数据会被假定为UTF-8格式(如同XML标准要求那样，
但需要注意的是PostgreSQL不支持UTF-16)。输出时，会对数据进行编码声明以指定客户端编码，
除非客户端编码格式是UTF-8。
</para>

   <!--
<para>
    Needless to say, processing XML data with PostgreSQL will be less
    error-prone and more efficient if the XML data encoding, client encoding,
    and server encoding are the same.  Since XML data is internally
    processed in UTF-8, computations will be most efficient if the
    server encoding is also UTF-8.
   </para>
-->
<para>
不用说，如果XML数据编码格式，客户端编码格式，以及服务器编码格式都一样，
那么用PostgreSQL处理XML数据将会减少错误，并且效率会很高。在内部，
XML数据是用UTF-8编码格式处理的，因此，如果服务器端编码也是UTF-8时，计算性能会很高。
</para>

   <caution>
    <!--
<para>
     Some XML-related functions may not work at all on non-ASCII data
     when the server encoding is not UTF-8.  This is known to be an
     issue for <function>xpath()</> in particular.
    </para>
-->
<para>
当服务器编码非UTF-8格式时，一些XML相关的函数可能完全不支持非ASCII数据，
特别是<function>xpath()</> 函数。
</para>
   </caution>
   </sect2>

   <sect2>
   <!-- 
   <title>Accessing XML Values</title> 
   -->
   <title>访问XML值</title>

   <!--
<para>
    The <type>xml</type> data type is unusual in that it does not
    provide any comparison operators.  This is because there is no
    well-defined and universally useful comparison algorithm for XML
    data.  One consequence of this is that you cannot retrieve rows by
    comparing an <type>xml</type> column against a search value.  XML
    values should therefore typically be accompanied by a separate key
    field such as an ID.  An alternative solution for comparing XML
    values is to convert them to character strings first, but note
    that character string comparison has little to do with a useful
    XML comparison method.
   </para>
-->
<para>
<type>xml</type>数据类型有些特殊，因为它不提供比较运算符。这是因为对XML数据，
没有很好的定义和通用的比较运算符。这样做的一个后果是，
不能通过<type>xml</type>与检索值的比较来检索行。因此XML值必须带有一个单独的关键值，
如一个ID。另一个解决比较XML值的方法是，先将它们转换成字符串，
但需要注意的是字符串比较与一个有用的XML比较方法无关。
</para>

   <!--
<para>
    Since there are no comparison operators for the <type>xml</type>
    data type, it is not possible to create an index directly on a
    column of this type.  If speedy searches in XML data are desired,
    possible workarounds include casting the expression to a
    character string type and indexing that, or indexing an XPath
    expression.  Of course, the actual query would have to be adjusted
    to search by the indexed expression.
   </para>
-->
<para>
因为没有针对<type>xml</type>数据类型的比较运算符，因此不能在这种类型的字段上直接创建索引。
如果需要对XML数据进行快速搜索，可能的解决方法包括将表达式转换成一个字符串类型，
然后对它进行索引，或索引一个XPath表达式。当然，实际查询是不得不进行调整，
以使用一个索引表达式进行检索。
</para>

   <!--
<para>
    The text-search functionality in PostgreSQL can also be used to speed
    up full-document searches of XML data.  The necessary
    preprocessing support is, however, not yet available in the PostgreSQL
    distribution.
   </para>
-->
<para>
PostgreSQL中的文本检索功能也可用于加快XML数据的全文搜索。
但必要的预处理支持在PostgreSQL中还不能获得。
</para>
   </sect2>
  </sect1>

  &json;

  &array;

  &rowtypes;

  &rangetypes;

  <sect1 id="datatype-oid">
   <!-- 
   <title>Object Identifier Types</title>
   -->
   <title>对象标识符类型</title>

   <indexterm zone="datatype-oid">
    <!-- 
<primary>object identifier</primary>
    <secondary>data type</secondary> 
-->
<primary>对象标识符</primary>
    <secondary>数据类型</secondary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>oid</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regproc</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regprocedure</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regoper</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regoperator</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regclass</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regtype</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regconfig</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regdictionary</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>xid</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>cid</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>tid</primary>
   </indexterm>

   <!--
<para>
    Object identifiers (OIDs) are used internally by
    <productname>PostgreSQL</productname> as primary keys for various
    system tables.  OIDs are not added to user-created tables, unless
    <literal>WITH OIDS</literal> is specified when the table is
    created, or the <xref linkend="guc-default-with-oids">
    configuration variable is enabled.  Type <type>oid</> represents
    an object identifier.  There are also several alias types for
    <type>oid</>: <type>regproc</>, <type>regprocedure</>,
    <type>regoper</>, <type>regoperator</>, <type>regclass</>,
    <type>regtype</>, <type>regconfig</>, and <type>regdictionary</>.
    <xref linkend="datatype-oid-table"> shows an overview.
   </para>
-->
<para>
<productname>PostgreSQL</productname>在内部使用对象标识符(OID)作为各种系统表的主键。
同时，系统不会给用户创建的表增加一个 OID 系统字段(除非在建表时声明了<literal>WITH OIDS</literal>
或者配置参数<xref linkend="guc-default-with-oids">设置为开启)。<type>oid</>
类型代表一个对象标识符。除此以外<type>oid</>还有几个别名：<type>regproc</>, 
<type>regprocedure</>, <type>regoper</>, <type>regoperator</>, <type>regclass</>,
<type>regtype</>, <type>regconfig</>, 和<type>regdictionary</>。
<xref linkend="datatype-oid-table">显示了概览。
</para>

   <!--
<para>
    The <type>oid</> type is currently implemented as an unsigned
    four-byte integer.  Therefore, it is not large enough to provide
    database-wide uniqueness in large databases, or even in large
    individual tables.  So, using a user-created table's OID column as
    a primary key is discouraged.  OIDs are best used only for
    references to system tables.
   </para>
-->
<para>
目前<type>oid</>类型用一个四字节的无符号整数实现。因此，
它不够提供大数据库范围内的唯一性保证，甚至在单个的大表中也不行。
因此，我们不鼓励在用户创建的表中使用 OID 字段做主键。OID 最好只是用于系统表。
</para>

   <!--
<para>
    The <type>oid</> type itself has few operations beyond comparison.
    It can be cast to integer, however, and then manipulated using the
    standard integer operators.  (Beware of possible
    signed-versus-unsigned confusion if you do this.)
   </para>
-->
<para>
<type>oid</>类型本身除了比较之外还有几个操作。不过，它可以转换为整数，
然后用标准的整数操作符操作。如果你这么干，请注意可能的有符号和无符号之间的混淆。
</para>
   
<para>
<!--
    The OID alias types have no operations of their own except
    for specialized input and output routines.  These routines are able
    to accept and display symbolic names for system objects, rather than
    the raw numeric value that type <type>oid</> would use.  The alias
    types allow simplified lookup of OID values for objects.  For example,
    to examine the <structname>pg_attribute</> rows related to a table
    <literal>mytable</>, one could write:
-->
OID 别名类型除了输入和输出过程之外没有自己的操作。
这些过程可以为系统对象接受和显示符号名，而不仅仅是类型<type>oid</>
将要使用的行数值。别名类型允许我们简化为对象查找 OID 值的过程。比如，
检查和一个表<literal>mytable</>相关的<structname>pg_attribute</>行，我们可以这样写:
<programlisting>
SELECT * FROM pg_attribute WHERE attrelid = 'mytable'::regclass;
</programlisting>
    <!-- 
rather than: 
-->
而不用:
<programlisting>
SELECT * FROM pg_attribute
  WHERE attrelid = (SELECT oid FROM pg_class WHERE relname = 'mytable');
</programlisting>
<!-- 
    While that doesn't look all that bad by itself, it's still oversimplified.
    A far more complicated sub-select would be needed to
    select the right OID if there are multiple tables named
    <literal>mytable</> in different schemas.
    The <type>regclass</> input converter handles the table lookup according
    to the schema path setting, and so it does the <quote>right thing</>
    automatically.  Similarly, casting a table's OID to
    <type>regclass</> is handy for symbolic display of a numeric OID. 
-->
虽然看上去不坏，但是这个例子还是简化了好多，如果在不同的模式里有好多叫
<literal>mytable</>的表，那么我们需要写一个更复杂的子查询。<type>regclass</>
的输入转换器处理根据模式路径设置的表检索工作，所以它自动干了<quote>正确的事情</>。
类似的还有，把一个表的 OID 转换成<type>regclass</>是查找一个 OID 对应的符号名称的最简单方法。
   </para>

    <table id="datatype-oid-table">
     <!-- 
 <title>Object Identifier Types</title> 
 -->
 <title>对象标识符类型</title>
     <tgroup cols="4">
      <thead>
       <row>
        <!-- 
<entry>Name</entry>
        <entry>References</entry>
        <entry>Description</entry>
        <entry>Value Example</entry> 
-->
<entry>名字</entry>
        <entry>引用</entry>
        <entry>描述</entry>
        <entry>数值例子</entry>
       </row>
      </thead>

      <tbody>

       <row>
        <entry><type>oid</></entry>
        <!-- 
<entry>any</entry>
        <entry>numeric object identifier</entry> 
-->
<entry>任意</entry>
        <entry>数字化的对象标识符</entry>
        <entry><literal>564182</></entry>
       </row>

       <row>
        <entry><type>regproc</></entry>
        <entry><structname>pg_proc</></entry>
        <!-- 
<entry>function name</entry> 
-->
<entry>函数名字</entry>
        <entry><literal>sum</></entry>
       </row>

       <row>
        <entry><type>regprocedure</></entry>
        <entry><structname>pg_proc</></entry>
        <!-- 
<entry>function with argument types</entry> 
-->
<entry>带参数类型的函数</entry>
        <entry><literal>sum(int4)</></entry>
       </row>

       <row>
        <entry><type>regoper</></entry>
        <entry><structname>pg_operator</></entry>
        <!-- 
<entry>operator name</entry> 
-->
<entry>操作符名</entry>
        <entry><literal>+</></entry>
       </row>

       <row>
        <entry><type>regoperator</></entry>
        <entry><structname>pg_operator</></entry>
        <!-- 
<entry>operator with argument types</entry>
        <entry><literal>*(integer,integer)</> or <literal>-(NONE,integer)</></entry> 
-->
<entry>带参数类型的操作符</entry>
        <entry><literal>*(integer,integer)</> 或 <literal>-(NONE,integer)</></entry>
       </row>

       <row>
        <entry><type>regclass</></entry>
        <entry><structname>pg_class</></entry>
        <!-- 
<entry>relation name</entry> 
-->
<entry>关系名</entry>
        <entry><literal>pg_type</></entry>
       </row>

       <row>
        <entry><type>regtype</></entry>
        <entry><structname>pg_type</></entry>
        <!-- 
<entry>data type name</entry>
-->
<entry>数据类型名</entry>
        <entry><literal>integer</></entry>
       </row>

       <row>
        <entry><type>regconfig</></entry>
        <entry><structname>pg_ts_config</></entry>
        <!-- 
<entry>text search configuration</entry>
-->
<entry>文本搜索配置</entry>
        <entry><literal>english</></entry>
       </row>

       <row>
        <entry><type>regdictionary</></entry>
        <entry><structname>pg_ts_dict</></entry>
        <!-- 
<entry>text search dictionary</entry> 
-->
<entry>文本搜索字典</entry>
        <entry><literal>simple</></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <!--
<para>
    All of the OID alias types accept schema-qualified names, and will
    display schema-qualified names on output if the object would not
    be found in the current search path without being qualified.
    The <type>regproc</> and <type>regoper</> alias types will only
    accept input names that are unique (not overloaded), so they are
    of limited use; for most uses <type>regprocedure</> or
    <type>regoperator</> are more appropriate.  For <type>regoperator</>,
    unary operators are identified by writing <literal>NONE</> for the unused
    operand.
   </para>
-->
<para>
所有 OID 别名类型都接受有模式修饰的名字，
并且如果在当前搜索路径中不增加修饰无法找到该对象的话，
那么在输出时将显示有模式修饰的名字。<type>regproc</>和<type>regoper</>
别名类型将只接受唯一的输入名字(不能重载)，因此它们的用途有限。
对于大多数应用，<type>regprocedure</>或<type>regoperator</>更合适。
对于<type>regoperator</>，单目操作符是通过在那些未用的操作数上写<literal>NONE</>
来标识的。
</para>

   <!--
<para>
    An additional property of the OID alias types is the creation of
    dependencies.  If a
    constant of one of these types appears in a stored expression
    (such as a column default expression or view), it creates a dependency
    on the referenced object.  For example, if a column has a default
    expression <literal>nextval('my_seq'::regclass)</>,
    <productname>PostgreSQL</productname>
    understands that the default expression depends on the sequence
    <literal>my_seq</>; the system will not let the sequence be dropped
    without first removing the default expression.
   </para>
-->
<para>
OID 别名类型的一个额外的属性是依赖关系的创建。
如果这些类型之一的常量出现在一个存储的表达式里(比如字段缺省表达式或者视图)，
它在被引用的对象上创建一个依赖性。比如，如果一个字段有缺省的
<literal>nextval('my_seq'::regclass)</>表达式，<productname>PostgreSQL</productname>
理解缺省表达式依赖于序列<literal>my_seq</>；系统将不允许在删除缺省的表达式之前删除该序列。
</para>

   <!--
<para>
    Another identifier type used by the system is <type>xid</>, or transaction
    (abbreviated <abbrev>xact</>) identifier.  This is the data type of the system columns
    <structfield>xmin</> and <structfield>xmax</>.  Transaction identifiers are 32-bit quantities.
   </para>
-->
<para>
系统使用的另外一个标识符类型是事务(缩写<abbrev>xact</>)标识符<type>xid</>。
它是系统字段<structfield>xmin</>和<structfield>xmax</>的数据类型。事务标识符是 32 位的量。
</para>

   <!--
<para>
    A third identifier type used by the system is <type>cid</>, or
    command identifier.  This is the data type of the system columns
    <structfield>cmin</> and <structfield>cmax</>. Command identifiers are also 32-bit quantities.
   </para>
-->
<para>
系统需要的第三种标识符类型是命令标识符<type>cid</>。
它是系统字段<structfield>cmin</>和<structfield>cmax</>的数据类型。命令标识符也是 32 位的量。
</para>

   <!--
<para>
    A final identifier type used by the system is <type>tid</>, or tuple
    identifier (row identifier).  This is the data type of the system column
    <structfield>ctid</>.  A tuple ID is a pair
    (block number, tuple index within block) that identifies the
    physical location of the row within its table.
   </para>
-->
<para>
系统使用的最后一个标识符类型是行标识符<type>tid</>。
它是系统表字段<structfield>ctid</>的数据类型。行 ID 是一对数值(块号，块内的行索引)，
它标识该行在其所在表内的物理位置。
</para>
   <!--
<para>
    (The system columns are further explained in <xref
    linkend="ddl-system-columns">.)
   </para>
-->
<para>
系统字段在<xref linkend="ddl-system-columns">里有更多解释。
</para>
  </sect1>

  <sect1 id="datatype-pg-lsn">
<!-- 
   <title><acronym>pg_lsn Type</acronym></title> 
-->
   <title><acronym>pg_lsn 类型</acronym></title>

   <indexterm zone="datatype-pg-lsn">
    <primary>pg_lsn</primary>
   </indexterm>


<!-- 
   <para>
    The <type>pg_lsn</type> data type can be used to store LSN (Log Sequence
    Number) data which is a pointer to a location in the XLOG. This type is a
    representation of <type>XLogRecPtr</type> and an internal system type of
    <productname>PostgreSQL</productname>.
   </para>
-->
<para>
<type>pg_lsn</type>数据类型可以用来存储LSN（Log Sequencce Number日志序列数字）
数据，它是一个指向XLOG中的位置的指针。这个类型是<type>XLogRecPtr</type>
的表示，是<productname>PostgreSQL</productname>的一种内部系统类型。
</para>

<!-- 
   <para>
    Internally, an LSN is a 64-bit integer, representing a byte position in
    the write-ahead log stream.  It is printed as two hexadecimal numbers of
    up to 8 digits each, separated by a slash; for example,
    <literal>16/B374D848</>.  The <type>pg_lsn</type> type supports the
    standard comparison operators, like <literal>=</literal> and
    <literal>&gt;</literal>.  Two LSNs can be subtracted using the
    <literal>-</literal> operator; the result is the number of bytes separating
    those write-ahead log positions.
   </para>
-->
<para>
在内部，一个LSN是一个64位整数，表示预写式日志流中的一个字节位置。
它打印出来是两个8数字位的十六进制数，由斜线隔开；例如<literal>16/B374D848</>。
<type>pg_lsn</type>类型支持标准比较运算符，比如<literal>=</literal>和
<literal>&gt;</literal>。两个LSN可以使用<literal>-</literal>操作符进行减法；
结果是分离那些预写式日志位置的字节数。
</para>
  </sect1>

  <sect1 id="datatype-pseudo">
   <!-- 
   <title>Pseudo-Types</title> 
   -->
   <title>伪类型</title>

   <indexterm zone="datatype-pseudo">
    <primary>record</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>any</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anyelement</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anyarray</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anynonarray</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anyenum</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anyrange</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>void</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>trigger</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>language_handler</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>fdw_handler</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>cstring</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>internal</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>opaque</primary>
   </indexterm>

   <!--
<para>
    The <productname>PostgreSQL</productname> type system contains a
    number of special-purpose entries that are collectively called
    <firstterm>pseudo-types</>.  A pseudo-type cannot be used as a
    column data type, but it can be used to declare a function's
    argument or result type.  Each of the available pseudo-types is
    useful in situations where a function's behavior does not
    correspond to simply taking or returning a value of a specific
    <acronym>SQL</acronym> data type.  <xref
    linkend="datatype-pseudotypes-table"> lists the existing
    pseudo-types.
   </para>
-->
<para>
<productname>PostgreSQL</productname>类型系统包含一系列特殊用途的条目，
它们按照类别来说叫做<firstterm>伪类型</>。伪类型不能作为字段的数据类型，
但是它可以用于声明一个函数的参数或者结果类型。
伪类型在一个函数不只是简单地接受并返回某种<acronym>SQL</acronym>
数据类型的情况下很有用。<xref linkend="datatype-pseudotypes-table">列出了所有的伪类型。
</para>

    <table id="datatype-pseudotypes-table">
     <!-- 
 <title>Pseudo-Types</title>
 -->
 <title>伪类型</title>
     <tgroup cols="2">
      <thead>
       <row>
        <!-- 
<entry>Name</entry>
        <entry>Description</entry> 
-->
<entry>名字</entry>
        <entry>描述</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><type>any</></entry>
        <!-- 
<entry>Indicates that a function accepts any input data type.</entry> 
-->
<entry>表示一个函数接受任何输入数据类型。</entry>
       </row>

       <row>
        <entry><type>anyelement</></entry>
        <!-- 
<entry>Indicates that a function accepts any data type
        (see <xref linkend="extend-types-polymorphic">).</entry> 
-->
<entry>表示一个函数接受任何数据类型
        (参阅<xref linkend="extend-types-polymorphic">)。</entry>
       </row>

       <row>
        <entry><type>anyarray</></entry>
        <!-- 
<entry>Indicates that a function accepts any array data type
        (see <xref linkend="extend-types-polymorphic">).</entry> 
-->
<entry>表示一个函数接受任意数组数据类型
        (参阅<xref linkend="extend-types-polymorphic">)。</entry>
       </row>

       <row>
        <entry><type>anynonarray</></entry>
        <!-- 
<entry>Indicates that a function accepts any non-array data type
        (see <xref linkend="extend-types-polymorphic">).</entry> 
-->
<entry>表示一个函数接受任意非数组数据类型
        (参阅<xref linkend="extend-types-polymorphic">)。</entry>
       </row>

       <row>
        <entry><type>anyenum</></entry>
        <!-- 
<entry>Indicates that a function accepts any enum data type
        (see <xref linkend="extend-types-polymorphic"> and
        <xref linkend="datatype-enum">).</entry> 
-->
<entry>表示一个函数接受任意枚举数据类型
        (参阅<xref linkend="extend-types-polymorphic"> 和
        <xref linkend="datatype-enum">)。</entry>
       </row>

       <row>
        <entry><type>anyrange</></entry>
        <!-- 
<entry>Indicates that a function accepts any range data type
        (see <xref linkend="extend-types-polymorphic"> and
        <xref linkend="rangetypes">).</entry> 
-->
<entry>表示一个函数接受任意范围数据类型
        (参阅 <xref linkend="extend-types-polymorphic"> 和
        <xref linkend="rangetypes">)。</entry>
       </row>

       <row>
        <entry><type>cstring</></entry>
       <!-- 
   <entry>Indicates that a function accepts or returns a null-terminated C string.</entry> 
   -->
    <entry>表示一个函数接受或者返回一个空结尾的 C 字符串。</entry>
       </row>

       <row>
        <entry><type>internal</></entry>
        <!-- 
<entry>Indicates that a function accepts or returns a server-internal
        data type.</entry> 
-->
<entry>表示一个函数接受或者返回一种服务器内部的数据类型。</entry>
       </row>

       <row>
        <entry><type>language_handler</></entry>
        <!-- 
<entry>A procedural language call handler is declared to return <type>language_handler</>.</entry> 
-->
<entry>一个过程语言调用处理器声明为返回<type>language_handler</>。</entry>
       </row>

       <row>
        <entry><type>fdw_handler</></entry>
        <!-- 
<entry>A foreign-data wrapper handler is declared to return <type>fdw_handler</>.</entry> 
-->
<entry>一个外部数据封装器声明为返回<type>fdw_handler</>。</entry>
       </row>

       <row>
        <entry><type>record</></entry>
        <!-- 
<entry>Identifies a function returning an unspecified row type.</entry> 
-->
<entry>标识一个函数返回一个未声明的行类型。</entry>
       </row>

       <row>
        <entry><type>trigger</></entry>
        <!-- 
<entry>A trigger function is declared to return <type>trigger.</></entry> 
-->
<entry>一个触发器函数声明为返回<type>trigger</>。</entry>
       </row>

       <row>
        <entry><type>void</></entry>
        <!-- 
<entry>Indicates that a function returns no value.</entry> 
-->
<entry>表示一个函数不返回数值。</entry>
       </row>

       <row>
        <entry><type>opaque</></entry>
        <!-- 
<entry>An obsolete type name that formerly served all the above purposes.</entry> 
-->
<entry>一个已经过时的类型，以前用于所有上面这些用途。</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <!--
<para>
    Functions coded in C (whether built-in or dynamically loaded) can be
    declared to accept or return any of these pseudo data types.  It is up to
    the function author to ensure that the function will behave safely
    when a pseudo-type is used as an argument type.
   </para>
-->
<para>
用 C 编写的函数(不管是内置的还是动态装载的)都可以声明为接受或者返回这样的伪数据类型。
在把伪类型用做函数参数类型的时候，保证函数行为正常就是函数作者的任务了。
</para>

   <!--
<para>
    Functions coded in procedural languages can use pseudo-types only as
    allowed by their implementation languages.  At present the procedural
    languages all forbid use of a pseudo-type as argument type, and allow
    only <type>void</> and <type>record</> as a result type (plus
    <type>trigger</> when the function is used as a trigger).  Some also
    support polymorphic functions using the types <type>anyelement</>,
    <type>anyarray</>, <type>anynonarray</>, <type>anyenum</>, and
    <type>anyrange</>.
   </para>
-->
<para>
用过程语言编写的函数只能根据它们的实现语言是否可以使用伪类型而使用它。
目前，过程语言都不允许使用伪类型作为参数类型，并且只允许使用<type>void</>
和<type>record</>作为结果类型(如果函数用做触发器，那么加上<type>trigger</>)。
一些多态的函数还支持使用<type>anyelement</>，<type>anyarray</>，<type>anynonarray</>
<type>anyenum</>和<type>anyrange</>类型。
</para>

   <!--
<para>
    The <type>internal</> pseudo-type is used to declare functions
    that are meant only to be called internally by the database
    system, and not by direct invocation in an <acronym>SQL</acronym>
    query.  If a function has at least one <type>internal</>-type
    argument then it cannot be called from <acronym>SQL</acronym>.  To
    preserve the type safety of this restriction it is important to
    follow this coding rule: do not create any function that is
    declared to return <type>internal</> unless it has at least one
    <type>internal</> argument.
   </para>
-->
<para>
伪类型<type>internal</>用于声明那种只能在数据库系统内部调用的函数，
它们不能直接在<acronym>SQL</acronym>查询里调用。如果函数至少有一个
<type>internal</>类型的参数，那么我们就不能从<acronym>SQL</acronym>
里调用它。为了保留这个限制的类型安全，我们一定要遵循这样的编码规则：
不要创建任何声明为返回<type>internal</>的函数，
除非它至少有一个<type>internal</>参数。
</para>

  </sect1>

 </chapter>
