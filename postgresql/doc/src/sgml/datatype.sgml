<!-- doc/src/sgml/datatype.sgml -->

 <chapter id="datatype">
  <title>数据类型</title>

  <indexterm zone="datatype">
   <primary>数据类型</primary>
  </indexterm>

  <indexterm>
   <primary>类型</primary>
   <see>数据类型</see>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname>有着丰富的本地数据类型可用。用户可以使用<xref linkend="sql-createtype">命令为 <productname>PostgreSQL</productname>增加新的数据类型。
  </para>

  <para>
   <xref linkend="datatype-table">显示了所有内建的普通数据类型。大部分在<quote>别名</quote>列里列出的可选名字都是因历史原因 被<productname>PostgreSQL</productname>在内部使用的名字。另外，还有一些内部使用的或者废弃的类型也可以用，但没有在这里列出。
  </para>

   <table id="datatype-table">
    <title>数据类型</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>名字</entry>
       <entry>别名</entry>
       <entry>描述</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><type>bigint</type></entry>
       <entry><type>int8</type></entry>
       <entry>有符号的8字节整数</entry>
      </row>

      <row>
       <entry><type>bigserial</type></entry>
       <entry><type>serial8</type></entry>
       <entry>自动增长的8字节整数</entry>
      </row>

      <row>
       <entry><type>bit [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry></entry>
       <entry>定长位串</entry>
      </row>

      <row>
       <entry><type>bit varying [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry><type>varbit</type></entry>
       <entry>变长位串</entry>
      </row>

      <row>
       <entry><type>boolean</type></entry>
       <entry><type>bool</type></entry>
       <entry>逻辑布尔值（真/假）</entry>
      </row>

      <row>
       <entry><type>box</type></entry>
       <entry></entry>
       <entry>平面上的普通方框</entry>
      </row>

      <row>
       <entry><type>bytea</type></entry>
       <entry></entry>
       <entry>二进制数据（<quote>字节数组</>）</entry>
      </row>

      <row>
       <entry><type>character [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry><type>char [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry>定长字符串</entry>
      </row>

      <row>
       <entry><type>character varying [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry><type>varchar [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry>变长字符串</entry>
      </row>

      <row>
       <entry><type>cidr</type></entry>
       <entry></entry>
       <entry>IPv4或IPv6网络地址</entry>
      </row>

      <row>
       <entry><type>circle</type></entry>
       <entry></entry>
       <entry>平面上的圆</entry>
      </row>

      <row>
       <entry><type>date</type></entry>
       <entry></entry>
       <entry>日历日期（年、月、日）</entry>
      </row>

      <row>
       <entry><type>double precision</type></entry>
       <entry><type>float8</type></entry>
       <entry>双精度浮点数（8字节）</entry>
      </row>

      <row>
       <entry><type>inet</type></entry>
       <entry></entry>
       <entry>IPv4或IPv6主机地址</entry>
      </row>

      <row>
       <entry><type>integer</type></entry>
       <entry><type>int</type>, <type>int4</type></entry>
       <entry>有符号4字节整数</entry>
      </row>

      <row>
       <entry><type>interval [ <replaceable>fields</replaceable> ] [ (<replaceable>p</replaceable>) ]</type></entry>
       <entry></entry>
       <entry>时间段</entry>
      </row>

      <row>
       <entry><type>json</type></entry>
       <entry></entry>
       <entry>文本 JSON 数据</entry>
      </row>

      <row>
       <entry><type>jsonb</type></entry>
       <entry></entry>
       <entry>二进制 JSON 数据，已分解</entry>
      </row>

      <row>
       <entry><type>line</type></entry>
       <entry></entry>
       <entry>平面上的无限长的线</entry>
      </row>

      <row>
       <entry><type>lseg</type></entry>
       <entry></entry>
       <entry>平面上的线段</entry>
      </row>

      <row>
       <entry><type>macaddr</type></entry>
       <entry></entry>
       <entry>MAC（Media Access Control）地址</entry>
      </row>

      <row>
       <entry><type>money</type></entry>
       <entry></entry>
       <entry>货币数量</entry>
      </row>

      <row>
       <entry><type>numeric [ (<replaceable>p</replaceable>,
         <replaceable>s</replaceable>) ]</type></entry>
       <entry><type>decimal [ (<replaceable>p</replaceable>,
         <replaceable>s</replaceable>) ]</type></entry>
       <entry>可选择精度的精确数字</entry>
      </row>

      <row>
       <entry><type>path</type></entry>
       <entry></entry>
       <entry>平面上的几何路径</entry>
      </row>

      <row>
       <entry><type>pg_lsn</type></entry>
       <entry></entry>
       <entry><productname>PostgreSQL</productname>日志序列号</entry>
      </row>

      <row>
       <entry><type>point</type></entry>
       <entry></entry>
       <entry>平面上的几何点</entry>
      </row>

      <row>
       <entry><type>polygon</type></entry>
       <entry></entry>
       <entry>平面上的封闭几何路径</entry>
      </row>

      <row>
       <entry><type>real</type></entry>
       <entry><type>float4</type></entry>
       <entry>单精度浮点数（4字节）</entry>
      </row>

      <row>
       <entry><type>smallint</type></entry>
       <entry><type>int2</type></entry>
       <entry>有符号2字节整数</entry>
      </row>

      <row>
       <entry><type>smallserial</type></entry>
       <entry><type>serial2</type></entry>
       <entry>自动增长的2字节整数</entry>
      </row>

      <row>
       <entry><type>serial</type></entry>
       <entry><type>serial4</type></entry>
       <entry>自动增长的4字节整数</entry>
      </row>

      <row>
       <entry><type>text</type></entry>
       <entry></entry>
       <entry>变长字符串</entry>
      </row>

      <row>
       <entry><type>time [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
       <entry></entry>
       <entry>一天中的时间（无时区）</entry>
      </row>

      <row>
       <entry><type>time [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
       <entry><type>timetz</type></entry>
       <entry>一天中的时间，包括时区</entry>
      </row>

      <row>
       <entry><type>timestamp [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
       <entry></entry>
       <entry>日期和时间（无时区）</entry>
      </row>

      <row>
       <entry><type>timestamp [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
       <entry><type>timestamptz</type></entry>
       <entry>日期和时间，包括时区</entry>
      </row>

      <row>
       <entry><type>tsquery</type></entry>
       <entry></entry>
       <entry>文本搜索查询</entry>
      </row>

      <row>
       <entry><type>tsvector</type></entry>
       <entry></entry>
       <entry>文本搜索文档</entry>
      </row>

      <row>
       <entry><type>txid_snapshot</type></entry>
       <entry></entry>
       <entry>用户级别事务ID快照</entry>
      </row>

      <row>
       <entry><type>uuid</type></entry>
       <entry></entry>
       <entry>通用唯一标识码</entry>
      </row>

      <row>
       <entry><type>xml</type></entry>
       <entry></entry>
       <entry>XML数据</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <note>
   <title>兼容性</title>
   <para>
    下列类型（或者及其拼写）是<acronym>SQL</acronym>指定的：<type>bigint</type>、<type>bit</type>、<type>bit varying</type>、<type>boolean</type>、<type>char</type>、<type>character varying</type>、<type>character</type>、<type>varchar</type>、<type>date</type>、<type>double precision</type>、<type>integer</type>、<type>interval</type>、<type>numeric</type>、<type>decimal</type>、<type>real</type>、<type>smallint</type>、<type>time</type>（有时区或无时区）、<type>timestamp</type>（有时区或无时区）、<type>xml</type>。
   </para>
  </note>

  <para>
   每种数据类型都有一个由其输入和输出函数决定的外部表现形式。许多内建的类型有明显的格式。不过，许多类型要么是<productname>PostgreSQL</productname>所特有的（例如几何路径），要么可能是有几种不同的格式（例如日期和时间类型）。 有些输入和输出函数是不可逆的，即输出函数的结果和原始输入比较时可能丢失精度。
  </para>

  <sect1 id="datatype-numeric">
   <title>数字类型</title>

   <indexterm zone="datatype-numeric">
    <primary>数据类型</primary>
    <secondary>数字</secondary>
   </indexterm>

   <para>
    数字类型由2、4或8字节的整数以及4或8字节的浮点数和可选精度小数组成。<xref linkend="datatype-numeric-table">列出了所有可用类型。
   </para>

    <table id="datatype-numeric-table">
     <title>数字类型</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>名字</entry>
        <entry>存储尺寸</entry>
        <entry>描述</entry>
        <entry>范围</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><type>smallint</></entry>
        <entry>2字节</entry>
        <entry>小范围整数</entry>
        <entry>-32768 to +32767</entry>
       </row>
       <row>
        <entry><type>integer</></entry>
        <entry>4字节</entry>
        <entry>整数的典型选择</entry>
        <entry>-2147483648 to +2147483647</entry>
       </row>
       <row>
        <entry><type>bigint</></entry>
        <entry>8字节</entry>
        <entry>大范围整数</entry>
        <entry>-9223372036854775808 to +9223372036854775807</entry>
       </row>

       <row>
        <entry><type>decimal</></entry>
        <entry>可变</entry>
        <entry>用户指定精度，精确</entry>
        <entry>最高小数点前131072位，以及小数点后16383位</entry>
       </row>
       <row>
        <entry><type>numeric</></entry>
        <entry>可变</entry>
        <entry>用户指定精度，精确</entry>
        <entry>最高小数点前131072位，以及小数点后16383位</entry>
       </row>

       <row>
        <entry><type>real</></entry>
        <entry>4字节</entry>
        <entry>可变精度，不精确</entry>
        <entry>6位十进制精度</entry>
       </row>
       <row>
        <entry><type>double precision</></entry>
        <entry>8字节</entry>
        <entry>可变精度，不精确</entry>
        <entry>15位十进制精度</entry>
       </row>

       <row>
        <entry><type>smallserial</type></entry>
        <entry>2字节</entry>
        <entry>自动增加的小整数</entry>
        <entry>1到32767</entry>
       </row>

       <row>
        <entry><type>serial</></entry>
        <entry>4字节</entry>
        <entry>自动增加的整数</entry>
        <entry>1到2147483647</entry>
       </row>

       <row>
        <entry><type>bigserial</type></entry>
        <entry>8字节</entry>
        <entry>自动增长的大整数</entry>
        <entry>1到9223372036854775807</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    数字类型常量的语法在<xref linkend="sql-syntax-constants">里描述。数字类型有一整套对应的数学操作符和函数。相关信息请参考 <xref linkend="functions">。下面的几节详细描述这些类型。
   </para>

   <sect2 id="datatype-int">
    <title>整数类型</title>

    <indexterm zone="datatype-int">
     <primary>整数</primary>
    </indexterm>

    <indexterm zone="datatype-int">
     <primary>smallint</primary>
    </indexterm>

    <indexterm zone="datatype-int">
     <primary>bigint</primary>
    </indexterm>

    <indexterm>
     <primary>int4</primary>
     <see>整数</see>
    </indexterm>

    <indexterm>
     <primary>int2</primary>
     <see>smallint</see>
    </indexterm>

    <indexterm>
     <primary>int8</primary>
     <see>bigint</see>
    </indexterm>

    <para>
     类型<type>smallint</type>、<type>integer</type>和<type>bigint</type>存储各种范围的全部是数字的数，也就是没有小数部分的数字。试图存储超出范围以外的值将导致一个错误。
    </para>

    <para>
     常用的类型是<type>integer</type>，因为它提供了在范围、存储空间和性能之间的最佳平衡。一般只有在磁盘空间紧张的时候才使用 <type>smallint</type>类型。而只有在<type>integer</type>的范围不够的时候才使用<type>bigint</type>。
    </para>

    <para>
     <acronym>SQL</acronym>只声明了整数类型<type>integer</type>（或<type>int</type>）、<type>smallint</type>和<type>bigint</type>。类型<type>int2</type>、<type>int4</type>和<type>int8</type>都是扩展，也在许多其它<acronym>SQL</acronym>数据库系统中使用。
    </para>

   </sect2>

   <sect2 id="datatype-numeric-decimal">
    <title>任意精度数字</title>

    <indexterm>
     <primary>数字（数据类型）</primary>
    </indexterm>

   <indexterm>
    <primary>任意精度数字</primary>
   </indexterm>

    <indexterm>
     <primary>decimal</primary>
     <see>numeric</see>
    </indexterm>

    <para>
     类型<type>numeric</type>可以存储非常多位的数字。我们特别建议将它用于货币金额和其它要求计算准确的数量。<type>numeric</type>值的计算产生准确结果，比如加法，减法，乘法。不过，<type>numeric</type>类型上的算术运算比整数类型或者下一节描述的浮点数类型要慢很多。
    </para>

    <para>
     在随后的内容里，我们使用了下述术语：一个<type>numeric</type>的<firstterm>比例</firstterm>是到小数部分的位数，<type>numeric</type>的<firstterm>精度</firstterm>是整个数字里全部位的数目，也就是小数点两边的位数目。因此数字 23.5141 的精度为6而比例为4。你可以认为整数的比例为零。
    </para>

    <para>
     <type>numeric</type>列的最大精度和最大比例都是可以配置的。要声明一个类型为<type>numeric</type>的列，你可以用下面的语法：
<programlisting>
NUMERIC(<replaceable>precision</replaceable>, <replaceable>scale</replaceable>)
</programlisting>
     精度必须为正数，比例可以为零或者正数。另外：
<programlisting>
NUMERIC(<replaceable>precision</replaceable>)
</programlisting>
     选择比例为 0 。如果使用
<programlisting>
NUMERIC
</programlisting>
     创建一个列时不使用精度或比例，则该列可以存储任何精度和比例的数字值，并且值的范围最多可以到实现精度的上限。一个这种列将不会把输入值转化成任何特定的比例，而带有比例声明的<type>numeric</type>列将把输入值转化为该比例（<acronym>SQL</acronym>标准要求缺省的比例是 0，即转化成整数精度。我们觉得这样做有点没用。如果你关心移植性，那你最好总是显式声明精度和比例）。
    </para>

    <note>
     <para>
      显式指定类型精度时的最大允许精度为 1000，没有指定精度的<type>NUMERIC</type>受到<xref linkend="datatype-numeric-table">中描述的限制所控制。
     </para>
    </note>

    <para>
     如果一个要存储的值的比例比列声明的比例高，那么系统将尝试圆整（四舍五入）该值到指定的分数位数。 然后，如果小数点左边的位数超过了声明的精度减去声明的比例，那么抛出一个错误。
    </para>

    <para>
     数字值在物理上是以不带任何前导或者后缀零的形式存储。 因此，列上声明的精度和比例都是最大值，而不是固定分配的 （在这个方面，<type>numeric</>类型更类似于<type>varchar(<replaceable>n</>)</type>， 而不像<type>char(<replaceable>n</>)</type>）。 实际存储要求是每四个十进制位组用两个字节，
     plus three to eight bytes overhead.
    </para>

    <indexterm>
     <primary>NaN</primary>
     <see>不是一个数字</see>
   </indexterm>

    <indexterm>
     <primary>不是一个数字</primary>
     <secondary>数字（数据类型）</secondary>
    </indexterm>

    <para>
     除了普通的数字值之外，<type>numeric</type>类型允许特殊值<literal>NaN</>， 表示<quote>不是一个数字</quote>。任何在 <literal>NaN</>上面的操作都生成另外一个<literal>NaN</>。 如果在 SQL 命令里把这些值当作一个常量写，你必须在其周围放上单引号，例如<literal>UPDATE table SET x = 'NaN'</>。在输入时，字串<literal>NaN</>被识别为大小写无关。
    </para>

    <note>
     <para>
      在<quote>不是一个数字</quote>概念的大部分实现中，<literal>NaN</>被认为不等于任何其他数字值（包括<literal>NaN</>）。为了允许<type>numeric</>值可以被排序和使用基于树的索引，<productname>PostgreSQL</>把<literal>NaN</>值视为相等，并且比所有非<literal>NaN</>值都要大。
     </para>
    </note>

    <para>
     类型<type>decimal</type>和<type>numeric</type>是等效的。两种类型都是<acronym>SQL</acronym>标准的一部分。
    </para>
   </sect2>


   <sect2 id="datatype-float">
    <title>浮点类型</title>

    <indexterm zone="datatype-float">
     <primary>real</primary>
    </indexterm>

    <indexterm zone="datatype-float">
     <primary>双精度</primary>
    </indexterm>

    <indexterm>
     <primary>float4</primary>
     <see>real</see>
    </indexterm>

    <indexterm>
     <primary>float8</primary>
     <see>双精度</see>
    </indexterm>

    <indexterm zone="datatype-float">
     <primary>浮点</primary>
    </indexterm>

    <para>
     数据类型<type>real</type>和<type>double precision</type>是不准确的、变精度的数字类型。实际上，这些类型是<acronym>IEEE</acronym>标准 754 二进制浮点算术（分别对应单精度和双精度）的一般实现， 一直到下层处理器、操作系统和编译器对它的支持。
    </para>

    <para>
     不准确意味着一些值不能准确地转换成内部格式并且是以近似的形式存储的，因此存储和检索一个值可能出现一些缺失。 处理这些错误以及这些错误是如何在计算中传播的主题属于数学和计算机科学的一个完整的分支， 我们不会在这里进一步讨论它，这里的讨论仅限于如下几点：
     <itemizedlist>
      <listitem>
       <para>
        如果你要求准确的存储和计算（例如计算货币金额），应使用<type>numeric</type>类型。
       </para>
      </listitem>

      <listitem>
       <para>
        如果你想用这些类型做任何重要的复杂计算，尤其是那些你对范围情况（无穷、下溢）严重依赖的事情，那你应该仔细评诂你的实现。
       </para>
      </listitem>

      <listitem>
       <para>
        用两个浮点数值进行等值比较不可能总是按照期望地进行。
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <para>
     在大部分平台上，<type>real</type>类型的范围是至少 -1E+37 到 +1E+37，精度至少是 6 位小数。<type>double precision</type>类型通常有 -1E+308 到 +1E+308 的范围，精度是至少 15 位数字。太大或者太小的值都会导致错误。 如果输入数字的精度太高，那么可能发生园整。太接近零的数字，如果无法与零值的表现形式相区分就会产生下溢错误。
    </para>

    <note>
     <para>
      <xref linkend="guc-extra-float-digits">设置控制当一个浮点值被转换为文本输出时要包括的额外有效数字的数目。其默认值为<literal>0</literal>，在每一个PostgreSQL支持的平台上输出都相同。增加该设置将产生能更精确表示存储值的输出，但是可能无法移植。
     </para>
    </note>

    <indexterm>
     <primary>不是一个数字</primary>
     <secondary>双精度</secondary>
    </indexterm>

    <para>
     除了普通的数字值之外，浮点类型还有几个特殊值：
<literallayout>
<literal>Infinity</literal>
<literal>-Infinity</literal>
<literal>NaN</literal>
</literallayout>
     这些值分别表示 IEEE 754 特殊值<quote>正无穷大</quote>、<quote>负无穷大</quote>以及<quote>不是一个数字</quote>（在不遵循 IEEE 754 浮点算术的机器上，这些值的含义可能不是预期的）。如果在 SQL 命令里把这些数值当作常量写，你必须在它们周围放上单引号，例如<literal>UPDATE table SET x = 'Infinity'</>。 在输入时，这些串是以大小写无关的方式识别的。
    </para>

    <note>
     <para>
      IEEE754指定<literal>NaN</>不应该与任何其他浮点值（包括<literal>NaN</>）相等。为了允许浮点值被排序或者在基于树的索引中使用，<productname>PostgreSQL</>将<literal>NaN</>值视为相等，并且比所有非<literal>NaN</>值要更大。
     </para>
    </note>

    <para>
     <productname>PostgreSQL</productname>还支持 SQL 标准表示法<type>float</type>和<type>float(<replaceable>p</replaceable>)</type>用于声明非精确的数字类型。在这里，<replaceable>p</replaceable>指定以<emphasis>二进制</>位表示的最低可接受精度。 在选取<type>real</type>类型的时候，<productname>PostgreSQL</productname>接受<type>float(1)</type>到<type>float(24)</type>，在选取<type>double precision</type>的时候，接受<type>float(25)</type>到<type>float(53)</type>。在允许范围之外的<replaceable>p</replaceable>值将导致一个错误。没有指定精度的<type>float</type>将被当作是<type>double precision</type>。
    </para>

    <note>
     <para>
      认为<type>real</type>和<type>double precision</type>分别有 24 和 53 个二进制位的假设对 IEEE 标准的浮点实现来说是正确的。在非 IEEE 平台上，这个数值可能略有偏差，但是为了简化，我们在所有平台上都用了同样的<replaceable>p</replaceable>值范围。
     </para>
    </note>

   </sect2>

   <sect2 id="datatype-serial">
    <title>序数类型</title>

    <indexterm zone="datatype-serial">
     <primary>smallserial</primary>
    </indexterm>

    <indexterm zone="datatype-serial">
     <primary>serial</primary>
    </indexterm>

    <indexterm zone="datatype-serial">
     <primary>bigserial</primary>
    </indexterm>

    <indexterm zone="datatype-serial">
     <primary>serial2</primary>
    </indexterm>

    <indexterm zone="datatype-serial">
     <primary>serial4</primary>
    </indexterm>

    <indexterm zone="datatype-serial">
     <primary>serial8</primary>
    </indexterm>

    <indexterm>
     <primary>auto-increment</primary>
     <see>serial</see>
    </indexterm>

    <indexterm>
     <primary>sequence</primary>
     <secondary>and serial type</secondary>
    </indexterm>

    <para>
     <type>smallserial</type>、<type>serial</type>和<type>bigserial</type>类型不是真正的类型，它们只是为了创建唯一标识符列而存在的方便符号（类似其它一些数据库中支持的<literal>AUTO_INCREMENT</literal>属性）。 在目前的实现中，下面一个语句：

<programlisting>
CREATE TABLE <replaceable class="parameter">tablename</replaceable> (
    <replaceable class="parameter">colname</replaceable> SERIAL
);
</programlisting>

     等价于以下语句：

<programlisting>
CREATE SEQUENCE <replaceable class="parameter">tablename</replaceable>_<replaceable class="parameter">colname</replaceable>_seq;
CREATE TABLE <replaceable class="parameter">tablename</replaceable> (
    <replaceable class="parameter">colname</replaceable> integer NOT NULL DEFAULT nextval('<replaceable class="parameter">tablename</replaceable>_<replaceable class="parameter">colname</replaceable>_seq')
);
ALTER SEQUENCE <replaceable class="parameter">tablename</replaceable>_<replaceable class="parameter">colname</replaceable>_seq OWNED BY <replaceable class="parameter">tablename</replaceable>.<replaceable class="parameter">colname</replaceable>;
</programlisting>

     因此，我们就创建了一个整数列并且把它的缺省值安排为从一个序列发生器取值。应用了一个<literal>NOT NULL</>约束以确保空值不会被插入（在大多数情况下你可能还希望附加一个<literal>UNIQUE</>或者<literal>PRIMARY KEY</>约束避免意外地插入重复的值，但这个不是自动发生的）。最后，该序列被标记为<quote>属于</>该列，这样当列或表被删除时该序列也会被删除。
    </para>

    <note>
      <para>
        因为<type>smallserial</type>、<type>serial</type>和<type>bigserial</type>是用序列实现的，所以即使没有删除过行，在出现在列中的序列值可能有“空洞”或者间隙。如果一个从序列中分配的值被用在一行中，即使该行最终没有被成功地插入到表中，该值也被“用掉”了。例如，当插入事务回滚时就会发生这种情况。更多信息参见<xref linkend="functions-sequence">中的<literal>nextval()</literal>。
      </para>
    </note>

    <para>
     要使用<type>serial</type>列插入序列的下一个数值到表中， 请指定<type>serial</type>列应该被赋予其缺省值。我们可以通过在<command>INSERT</command>语句中把该列排除在列列表之外来实现，也可以通过使用<literal>DEFAULT</literal>关键字来实现。
    </para>

    <para>
     类型名<type>serial</type>和<type>serial4</type>是等效的： 两个都创建<type>integer</type>列。类型名<type>bigserial</type>和<type>serial8</type>也一样，只不过它们创建一个 <type>bigint</type>列。如果你预计在表的生存期中使用的标识符数目超过 2<superscript>31</> 个，那么你应该使用<type>bigserial</type>。类型名<type>smallserial</type>和<type>serial2</type>也以相同方式工作，只不过它们创建一个<type>smallint</type>列。
    </para>

    <para>
     为一个<type>serial</type>列创建的序列在所属的列被删除的时候自动删除。你可以在不删除列的情况下删除序列，但是这会强制删除该列的默认值表达式。
    </para>
   </sect2>
  </sect1>

  <sect1 id="datatype-money">
   <title>货币类型</title>

   <para>
    <type>money</type>类型存储固定小数精度的货币数字，参阅<xref linkend="datatype-money-table">。小数的精度由数据库的<xref linkend="guc-lc-monetary">设置决定。表中展示的范围假设有两个小数位。可接受的输入格式很多，包括整数和浮点数文字，以及常用的货币格式，如<literal>'$1,000.00'</literal>。 输出通常是最后一种形式，但和区域相关。
   </para>

    <table id="datatype-money-table">
     <title>货币类型</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>名字</entry>
        <entry>存储尺寸</entry>
        <entry>描述</entry>
        <entry>范围</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>money</entry>
        <entry>8 bytes</entry>
        <entry>货币额</entry>
        <entry>-92233720368547758.08到+92233720368547758.07</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    由于这种数据类型的输出是区域敏感的，因此将<type>money</>数据装入到一个具有不同<varname>lc_monetary</>设置的数据库是不起作用的。为了避免这种问题，在恢复一个转储到一个新数据库中之前，应确保新数据库的<varname>lc_monetary</>设置和被转储数据库的相同或者具有等效值。
   </para>

   <para>
    数据类型<type>numeric</type>、<type>int</type>和<type>bigint</type>的值可以被造型成<type>money</type>。从数据类型<type>real</type>和<type>double precision</type>的转换可以通过先造型成<type>numeric</type>来实现，例如：
<programlisting>
SELECT '12.34'::float8::numeric::money;
</programlisting>
    但是，我们不推荐这样做。浮点数不应该被用来处理货币，因为浮点数可能会有圆整错误。
   </para>

   <para>
    一个<type>money</type>值可以在不损失精度的情况下被造型成<type>numeric</type>。转换到其他类型可能会丢失精度，并且必须采用两个阶段完成：
<programlisting>
SELECT '52093.89'::money::numeric::float8;
</programlisting>
   </para>

   <para>
    当一个<type>money</type>值被另一个<type>money</type>值除时，结果是<type>double precision</type>（即一个纯数字，而不是金额），在除法中货币单位被约掉了。
   </para>
  </sect1>


  <sect1 id="datatype-character">
   <title>字符类型</title>

   <indexterm zone="datatype-character">
    <primary>字符串</primary>
    <secondary>数据类型</secondary>
   </indexterm>

   <indexterm>
    <primary>string</primary>
    <see>字符串</see>
   </indexterm>

   <indexterm zone="datatype-character">
    <primary>字符</primary>
   </indexterm>

   <indexterm zone="datatype-character">
    <primary>character varying</primary>
   </indexterm>

   <indexterm zone="datatype-character">
    <primary>text</primary>
   </indexterm>

   <indexterm zone="datatype-character">
    <primary>char</primary>
   </indexterm>

   <indexterm zone="datatype-character">
    <primary>varchar</primary>
   </indexterm>

    <table id="datatype-character-table">
     <title>字符类型</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>名字</entry>
        <entry>描述</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><type>character varying(<replaceable>n</>)</type>, <type>varchar(<replaceable>n</>)</type></entry>
        <entry>有限制的变长</entry>
       </row>
       <row>
        <entry><type>character(<replaceable>n</>)</type>, <type>char(<replaceable>n</>)</type></entry>
        <entry>定长，空格填充</entry>
       </row>
       <row>
        <entry><type>text</type></entry>
        <entry>无限变长</entry>
       </row>
     </tbody>
     </tgroup>
    </table>

   <para>
    <xref linkend="datatype-character-table">显示了在<productname>PostgreSQL</productname>里可用的一般用途的字符类型。
   </para>

   <para>
    <acronym>SQL</acronym>定义了两种基本的字符类型： <type>character varying(<replaceable>n</>)</type>和<type>character(<replaceable>n</>)</type>， 其中<replaceable>n</>是一个正整数。两种类型都可以存储最多<replaceable>n</>个字符长的串。试图存储更长的串到这些类型的列里会产生一个错误， 除非超出长度的字符都是空白，这种情况下该串将被截断为最大长度（这个看上去有点怪异的例外是<acronym>SQL</acronym>标准要求的）。 如果要存储的串比声明的长度短，类型为<type>character</type>的值将会用空白填满；而类型为<type>character varying</type>的值将只是存储短些的串。
   </para>

   <para>
    如果我们明确地把一个值造型成<type>character varying(<replaceable>n</>)</type>或者<type>character(<replaceable>n</>)</type>， 那么超长的值将被截断成<replaceable>n</>个字符，而不会抛出错误（这也是<acronym>SQL</acronym>标准的要求）。
   </para>

   <para>
    <type>varchar(<replaceable>n</>)</type>和<type>char(<replaceable>n</>)</type>的概念分别是<type>character varying(<replaceable>n</>)</type>和<type>character(<replaceable>n</>)</type>的别名。没有长度声明词的<type>character</type>等效于<type>character(1)</type>。如果不带长度说明词使用<type>character varying</type>，那么该类型接受任何长度的串。后者是一个<productname>PostgreSQL</>的扩展。
   </para>

   <para>
    另外，<productname>PostgreSQL</productname>提供<type>text</type>类型，它可以存储任何长度的串。尽管类型<type>text</type>不是<acronym>SQL</acronym>标准，但是许多其它 SQL 数据库系统也有它。
   </para>

   <para>
    类型<type>character</type>的值物理上都用空白填充到指定的长度<replaceable>n</>， 并且以这种方式存储和显示。不过，拖尾的空白被当作是没有意义的，并且在比较两个
    <type>character</type>类型值时不会考虑它们。在空白有意义的排序规则中，这种行为可能会
    产生意料之外的结果，例如<command>SELECT 'a '::CHAR(2) collate "C" &lt;
    'a\n'::CHAR(2)</command>会返回真。尽管<literal>C</>语言认为空格大于换行符。当把一个<type>character</type>值转换成其他
    字符串类型之一时，拖尾的空白会被移除。请注意，在<type>character varying</type>和<type>text</type>值里， 结尾的空白语意上<emphasis>是</>有含义的，并且在使用模式匹配（如<literal>LIKE</>）正则表达式时也会被考虑。
   </para>

   <para>
    这些类型的存储需求是 4 字节加上实际的字串，如果是 character 的话再加上填充的字节。长的字串将会自动被系统压缩， 因此在磁盘上的物理需求可能会更少些。长的数值也会存储在后台表里面，这样它们就不会干扰对短字段值的快速访问。 不管怎样，允许存储的最长字串大概是 1 GB。 （允许在数据类型声明中出现的的 n 的最大值比这还小。 修改这个行为没有甚么意义，因为在多字节编码下字符和字节的数目可能差别很大。 如果你想存储没有特定上限的长字串，那么使用 text 或者没有长度声明词的 character varying， 而不要选择一个任意长度限制。）
    一个短串（最长126字节）的存储要求是1个字节外加实际的串，该串在<type>character</type>情况下包含填充的空白。长一些的串在前面需要4个字节而不是1个字节。长串会被系统自动压缩，这样在磁盘上的物理需求可能会更少。非常长的值也会被存储在背景表中，这样它们不会干扰对较短的列值的快速访问。在任何情况下，能被存储的最长的字符串是1GB（数据类型定义中<replaceable>n</>能允许的最大值比这个值要小。修改它没有用处，因为对于多字节字符编码来说，字符的数量和字节数可能完全不同。如果你想要存储没有指定上限的长串，使用<type>text</type>或没有长度声明的<type>character varying</type>，而不是给出一个任意长度限制）。
   </para>

   <tip>
    <para>
     这三种类型之间没有性能差别，只不过是在使用填充空白的类型的时候需要更多存储尺寸，以及在存储到一个有长度约束的列时需要少量额外CPU周期来检查长度。虽然在某些其它的数据库系统里，<type>character(<replaceable>n</>)</type>有一定的性能优势，但在<productname>PostgreSQL</productname>里没有。事实上，<type>character(<replaceable>n</>)</type>通常是这三种类型之中最慢的一个，因为它需要额外的存储开销以及较慢排序。在大多数情况下，应该使用<type>text</type>或者<type>character varying</type>。
    </para>
   </tip>

   <para>
    请参考<xref linkend="sql-syntax-strings">获取关于串文本的语法的信息，以及参阅<xref linkend="functions">获取关于可用操作符和函数的信息。 数据库的字符集决定用于存储文本值的字符集；有关字符集支持的更多信息，请参考<xref linkend="multibyte">。
   </para>

   <example>
    <title>使用字符类型</title>

<programlisting>
CREATE TABLE test1 (a character(4));
INSERT INTO test1 VALUES ('ok');
SELECT a, char_length(a) FROM test1; -- <co id="co.datatype-char">
<computeroutput>
  a   | char_length
------+-------------
 ok   |           2
</computeroutput>

CREATE TABLE test2 (b varchar(5));
INSERT INTO test2 VALUES ('ok');
INSERT INTO test2 VALUES ('good      ');
INSERT INTO test2 VALUES ('too long');
<computeroutput>ERROR:  value too long for type character varying(5)</computeroutput>
INSERT INTO test2 VALUES ('too long'::varchar(5)); -- explicit truncation
SELECT b, char_length(b) FROM test2;
<computeroutput>
   b   | char_length
-------+-------------
 ok    |           2
 good  |           5
 too l |           5
</computeroutput>
</programlisting>
    <calloutlist>
     <callout arearefs="co.datatype-char">
      <para>
       函数<function>char_length</function>在<xref linkend="functions-string">中讨论。
      </para>
     </callout>
    </calloutlist>
   </example>

   <para>
    在<productname>PostgreSQL</productname>里另外还有两种定长字符类型，在<xref linkend="datatype-character-special-table">里显示。 <type>name</type>类型<emphasis>只</emphasis>用于在内部系统目录中存储标识符并且不是给一般用户使用的。该类型长度当前定为 64 字节（63 可用字符加结束符）但在<literal>C</>源代码应该使用常量 <symbol>NAMEDATALEN</symbol>引用。这个长度是在编译的时候设置的（因而可以为特殊用途调整），缺省的最大长度在以后的版本可能会改变。类型<type>"char"</type>（注意引号）和 <type>char(1)</type>是不一样的，它只用了一个字节的存储空间。它在系统内部用于系统目录当做简化的枚举类型用。
   </para>

    <table id="datatype-character-special-table">
     <title>特殊字符类型</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>名字</entry>
        <entry>存储尺寸</entry>
        <entry>描述</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><type>"char"</type></entry>
        <entry>1字节</entry>
        <entry>单字节内部类型</entry>
       </row>
       <row>
        <entry><type>name</type></entry>
        <entry>64字节</entry>
        <entry>用于对象名的内部类型</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  </sect1>

 <sect1 id="datatype-binary">
  <title>二进制数据类型</title>

  <indexterm zone="datatype-binary">
   <primary>二进制数据</primary>
  </indexterm>

  <indexterm zone="datatype-binary">
   <primary>bytea</primary>
  </indexterm>

   <para>
    <type>bytea</type>数据类型允许存储二进制串，参见<xref linkend="datatype-binary-table">。
   </para>

   <table id="datatype-binary-table">
    <title>二进制数据类型</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>名字</entry>
       <entry>存储尺寸</entry>
       <entry>描述</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><type>bytea</type></entry>
       <entry>1或4字节外加真正的二进制串</entry>
       <entry>变长二进制串</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    二进制串是一个八位位组（或字节）的序列。 二进制串和字符串的区别有两个： 首先，二进制串明确允许存储零值的字节以及其它<quote>不可打印的</quote>字节（通常是位于范围 32 到 126 之外的字节）。 字符串不允许零字节，并且也不允许那些对于数据库的选定字符集编码是非法的任何其它字节值或者字节值序列。 第二，对二进制串的操作会处理实际上的字节，而字符串的处理和取决于区域设置。 简单说，二进制字串适用于存储那些程序员认为是<quote>裸字节</>的数据，而字符串适合存储文本。
   </para>

   <para>
    <type>bytea</type>类型支持两种用于输入和输出的外部格式：<productname>PostgreSQL</productname>的历史的<quote>逃逸</quote>格式和<quote>十六进制</quote>格式。在输入时这两种格式总是会被接受。输出格式则取决于配置参数<xref linkend="guc-bytea-output">，其默认值为十六进制（注意十六进制格式是在<productname>PostgreSQL</productname> 9.0中被引入的，早期的版本和某些工具无法理解它）。
   </para>

   <para>
    <acronym>SQL</acronym>标准定义了一种不同的二进制串类型， 叫做<type>BLOB</type>或者<type>BINARY LARGE OBJECT</type>。其输入格式和<type>bytea</type>不同，但是提供的函数和操作符大多一样。
   </para>

  <sect2>
   <title><type>bytea</>的十六进制格式</title>

   <para>
    <quote>十六进制</>格式将二进制数据编码为每个字节2个十六进制位，最高有效位在前。整个串以序列<literal>\x</literal>开头（用以和逃逸格式区分）。在某些情景中，开头的反斜线可能需要通过双写来逃逸，在相同的情况中逃逸格式必须要双写反斜线，下文描述了细节。十六进制位可以是大写也可以是小写，在位对之间可以有空白（但是在位对内部以及开头的<literal>\x</literal>序列中不能有空白）。十六进制格式和很多外部应用及协议相兼容，并且其转换速度要比逃逸格式更快，因此人们更愿意用它。
   </para>

   <para>
    例子：
<programlisting>
SELECT E'\\xDEADBEEF';
</programlisting>
   </para>
  </sect2>

  <sect2>
   <title><type>bytea</>的逃逸格式</title>

   <para>
    <quote>逃逸</quote>格式是<type>bytea</type>类型的传统<productname>PostgreSQL</productname>格式。它采用将二进制串表示成ASCII字符序列的方法，而将那些无法用ASCII字符表示的字节转换成特殊的逃逸语句。从应用的角度来看，如果将字节表示为字符有意义，那么这种表示将很方便。但是在实际中，这常常是令人困扰的，因为它使二进制串和字符串之间的区别变得模糊，并且这种特别的逃逸机制也有点难于处理。因此这种格式可能会在大部分新应用中避免使用。
   </para>

   <para>
    在逃逸模式下输入<type>bytea</type>值时，某些值的字节<emphasis>必须</emphasis>被逃逸，而所有的字节值都<emphasis>可以</emphasis>被逃逸。通常，要逃逸一个字节，需要把它转换成与它的三位八进制值， 并且前导一个反斜线（或者两个反斜线，如果使用逃逸串语法将值写成一个字面含义）。反斜线本身（字节值92）也可以用双写的反斜线表示。<xref linkend="datatype-binary-sqlesc">显示了必须被逃逸的字符，并给出了可以使用的替代逃逸序列。
   </para>

   <table id="datatype-binary-sqlesc">
    <title><type>bytea</>文字逃逸字节</title>
    <tgroup cols="5">
     <thead>
      <row>
       <entry>十进制字节值</entry>
       <entry>描述</entry>
       <entry>逃逸输入表示</entry>
       <entry>例子</entry>
       <entry>输出表示</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>0</entry>
       <entry>0字节</entry>
       <entry><literal>E'\\000'</literal></entry>
       <entry><literal>SELECT E'\\000'::bytea;</literal></entry>
       <entry><literal>\000</literal></entry>
      </row>

      <row>
       <entry>39</entry>
       <entry>单引号</entry>
       <entry><literal>''''</literal>或<literal>E'\\047'</literal></entry>
       <entry><literal>SELECT E'\''::bytea;</literal></entry>
       <entry><literal>'</literal></entry>
      </row>

      <row>
       <entry>92</entry>
       <entry>反斜线</entry>
       <entry><literal>E'\\\\'</literal>或<literal>E'\\134'</literal></entry>
       <entry><literal>SELECT E'\\\\'::bytea;</literal></entry>
       <entry><literal>\\</literal></entry>
      </row>

      <row>
       <entry>0到31和127到255</entry>
       <entry><quote>不可打印的</quote>字节</entry>
       <entry><literal>E'\\<replaceable>xxx'</></literal>（八进制值）</entry>
       <entry><literal>SELECT E'\\001'::bytea;</literal></entry>
       <entry><literal>\001</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>
    逃逸<quote>不可打印的</quote>字节的要求取决于区域设置。在某些实例中，你可以不理睬它们，让它们保持未逃逸的状态。注意在<xref linkend="datatype-binary-sqlesc">的每一个例子中的结果的长度正好是一个字节，即使其输出表示有时超过一个字符。
   </para>

   <para>
    如<xref linkend="datatype-binary-sqlesc">中所示，要求多个反斜线的原因是写成一个串文字的输入串在<productname>PostgreSQL</productname>服务器中必须经过两个分析阶段。每一对中的第一个反斜线被串文字分析器（假设使用了逃逸串语法）解释为一个逃逸字符并且因此被消耗，只留下该对中的第二个反斜线（美元符号包围的串可以被用于防止这一层的逃逸）。剩下的反斜线接着被<type>bytea</type>输入函数识别为开始一个三位八进制值或逃逸另一个反斜线。例如，一个传递给服务器的串文字是<literal>E'\\001'</literal>，它在通过逃逸串分析器后变成<literal>\001</literal>。<literal>\001</literal>接着被送给<type>bytea</type>输入函数，这里它被转换成一个十进制值为1的单字节。注意单引号字符串不会被<type>bytea</type>特殊对待，因此它遵循串文字的正常规则（参见<xref linkend="sql-syntax-strings">）。
   </para>

   <para>
    <type>Bytea</type>字节有时在输出时被逃逸。通常，每一个<quote>不可打印的</quote>字节会被转换成与之等效的三位八进制值并且前置一个反斜线。大部分<quote>可打印的</quote>字节被表示为它们在客户端字符集中的标准表示形式。十进制值为92（反斜线）的字节在输出时被双写。详情请见<xref linkend="datatype-binary-resesc">。
   </para>

   <table id="datatype-binary-resesc">
    <title><type>bytea</>输出逃逸字节</title>
    <tgroup cols="5">
     <thead>
      <row>
       <entry>十进制字节值</entry>
       <entry>描述</entry>
       <entry>逃逸的输出表示</entry>
       <entry>例子</entry>
       <entry>输出结果</entry>
      </row>
     </thead>

     <tbody>

      <row>
       <entry>92</entry>
       <entry>反斜线</entry>
       <entry><literal>\\</literal></entry>
       <entry><literal>SELECT E'\\134'::bytea;</literal></entry>
       <entry><literal>\\</literal></entry>
      </row>

      <row>
       <entry>0到31和127到255</entry>
       <entry><quote>不可打印的</quote>字节</entry>
       <entry><literal>\<replaceable>xxx</></literal>（八进制值）</entry>
       <entry><literal>SELECT E'\\001'::bytea;</literal></entry>
       <entry><literal>\001</literal></entry>
      </row>

      <row>
       <entry>32到126</entry>
       <entry><quote>可打印的</quote>字节</entry>
       <entry>客户端字符集表示</entry>
       <entry><literal>SELECT E'\\176'::bytea;</literal></entry>
       <entry><literal>~</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>
    根据你使用的<productname>PostgreSQL</>前端，你在逃逸和未逃逸<type>bytea</type>串方面可能需要做额外的工作。例如，如果你的接口自动翻译换行和回车，你可能也不得不逃逸它们。
   </para>
  </sect2>
 </sect1>


  <sect1 id="datatype-datetime">
   <title>日期/时间类型</title>

   <indexterm zone="datatype-datetime">
    <primary>date</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>time</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>不带时区的时间</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>带时区的时间</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>timestamp</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>timestamptz</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>带时区的时间戳</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>不带时区的时间戳</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>间隔</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>时间跨度</primary>
   </indexterm>

   <para>
    <productname>PostgreSQL</productname>支持<acronym>SQL</acronym>中所有的日期和时间类型，如<xref linkend="datatype-datetime-table">所示。这些数据类型上可用的操作如<xref linkend="functions-datetime">所述。日期根据公历来计算，即使对于该历法被引入之前的年份也一样（见<xref linkend="datetime-units-history">）。
   </para>

    <table id="datatype-datetime-table">
     <title>日期/时间类型</title>
     <tgroup cols="6">
      <thead>
       <row>
        <entry>名字</entry>
        <entry>存储尺寸</entry>
        <entry>描述</entry>
        <entry>最小值</entry>
        <entry>最大值</entry>
        <entry>解析度</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><type>timestamp [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
        <entry>8字节</entry>
        <entry>包括日期和时间（无时区）</entry>
        <entry>4713 BC</entry>
        <entry>294276 AD</entry>
        <entry>1毫秒 / 14位</entry>
       </row>
       <row>
        <entry><type>timestamp [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
        <entry>8字节</entry>
        <entry>包括日期和时间，有时区</entry>
        <entry>4713 BC</entry>
        <entry>294276 AD</entry>
        <entry>1毫秒 / 14位</entry>
       </row>
       <row>
        <entry><type>date</type></entry>
        <entry>4字节</entry>
        <entry>日期（没有一天中的时间）</entry>
        <entry>4713 BC</entry>
        <entry>5874897 AD</entry>
        <entry>1日</entry>
       </row>
       <row>
        <entry><type>time [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
        <entry>8字节</entry>
        <entry>一天中的时间（无日期）</entry>
        <entry>00:00:00</entry>
        <entry>24:00:00</entry>
        <entry>1毫秒 / 14位</entry>
       </row>
       <row>
        <entry><type>time [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
        <entry>12字节</entry>
        <entry>仅仅是一天中的时间，带有时区</entry>
        <entry>00:00:00+1459</entry>
        <entry>24:00:00-1459</entry>
        <entry>1毫秒 / 14位</entry>
       </row>
       <row>
        <entry><type>interval [ <replaceable>fields</replaceable> ] [ (<replaceable>p</replaceable>) ]</type></entry>
        <entry>16字节</entry>
        <entry>时间间隔</entry>
        <entry>-178000000年</entry>
        <entry>178000000年</entry>
        <entry>1毫秒 / 14位</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <note>
    <para>
     SQL要求只写<type>timestamp</type>等效于<type>timestamp without time zone</type>，并且<productname>PostgreSQL</productname>鼓励这种行为。<type>timestamptz</type>被接受为<type>timestamp with time zone</type>的一种简写，这是一种<productname>PostgreSQL</productname>的扩展。
    </para>
   </note>

   <para>
    <type>time</type>、<type>timestamp</type>和<type>interval</type>接受一个可选的精度值 <replaceable>p</replaceable>，这个精度值声明在秒域中小数点之后保留的位数。缺省情况下，在精度上没有明确的边界，<replaceable>p</replaceable>允许的范围对<type>timestamp</type>和<type>interval</type>类型是从 0 到 6。
   </para>

   <note>
   <para>
    当<type>timestamp</>值被存储为八字节整数（目前是默认情况）时，在整个值的范围上微妙精度是可用的。当<type>timestamp</>值被存储为双精度浮点数（一个已被启用的编译时选项）时，那么精度的有效限制会小于 6。<type>timestamp</>值是以 2000-01-01 午夜之前或之后以来的秒数存储的。当<type>timestamp</type>值被用浮点数实现时，在2000-01-01前后几年的日期可以达到微秒的精度，但是对于远一些的日子，精度会下降。注意使用浮点日期时间允许显示比上文所述更大范围的<type>timestamp</type>值：从 4713 BC 到 5874897 AD。
   </para>

   <para>
    同一个编译时选项也决定了<type>time</type>和<type>interval</type>值被存储为浮点数或八字节整数。在浮点数的情况中，当间隔的尺寸增长时，大<type>interval</type>值在精度上会下降。
   </para>
   </note>

   <para>
    对于<type>time</type>类型，如果使用了八字节的整数存储，允许的<replaceable>p</replaceable>的范围是从 0 到 6，如果使用的是浮点数存储，那么这个范围是 0 到 10。
   </para>

   <para>
    <type>interval</type>类型有一个附加选项，它可以通过写下面之一的短语来限制存储的fields的集合：
<literallayout class="monospaced">
YEAR
MONTH
DAY
HOUR
MINUTE
SECOND
YEAR TO MONTH
DAY TO HOUR
DAY TO MINUTE
DAY TO SECOND
HOUR TO MINUTE
HOUR TO SECOND
MINUTE TO SECOND
</literallayout>
    注意如果<replaceable>fields</replaceable>和<replaceable>p</replaceable>被指定，<replaceable>fields</replaceable>必须包括<literal>SECOND</>，因为精度只应用于秒。
   </para>

   <para>
    类型<type>time with time zone</type>是 SQL 标准定义的，但是该定义显示出了一些会影响可用性的性质。在大多数情况下， <type>date</type>、<type>time</type>、<type>timestamp without time zone</type>和<type>timestamp with time zone</type>的组合就应该能提供任何应用所需的全范围的日期/时间功能。
   </para>

   <para>
    类型<type>abstime</type>和<type>reltime</type>是低精度类型，它们被用于系统内部。 我们不鼓励你在应用里面使用这些类型，这些内部类型可能会在未来的版本里消失。
   </para>

   <sect2 id="datatype-datetime-input">
    <title> 日期/时间输入</title>

    <para>
     日期和时间的输入可以接受几乎任何合理的格式，包括 ISO 8601、<acronym>SQL</acronym>-兼容的、传统<productname>POSTGRES</productname>的和其他的形式。 对于一些格式，日期输入里的日、月和年的顺序会让人混淆， 并且支持指定所预期的这些域的顺序。把<xref linkend="guc-datestyle">参数设置为<literal>MDY</>，就是选择“月－日－年”的解释，设置为<literal>DMY</>就是 “日－月－年”，而<literal>YMD</>是 “年－月－日”。
    </para>

    <para>
     <productname>PostgreSQL</productname>在处理日期/时间输入上比<acronym>SQL</acronym>标准要求的更灵活。 参阅<xref linkend="datetime-appendix">获取关于日期/时间输入的准确的分析规则和可识别文本域，包括月份、星期几和时区。
    </para>

    <para>
     请记住任何日期或者时间的文字输入需要由单引号包围，就象一个文本字符串一样。参考<xref linkend="sql-syntax-constants-generic">获取更多信息。<acronym>SQL</acronym>要求下面的语法
<synopsis>
<replaceable>type</replaceable> [ (<replaceable>p</replaceable>) ] '<replaceable>value</replaceable>'
</synopsis>
     其中<replaceable>p</replaceable>是一个可选的精度声明，它给出了在秒域中的小数位数目。精度可以被指定给<type>time</type>、<type>timestamp</type>和<type>interval</type>类型。这允许前文所述的值。如果在一个常数声明中没有指定任何精度，它将默认取文字值的精度。
    </para>

    <sect3>
    <title>日期</title>

    <indexterm>
     <primary>date</primary>
    </indexterm>

    <para>
     <xref linkend="datatype-datetime-date-table">显示了<type>date</type>类型可能的输入方式。
    </para>

     <table id="datatype-datetime-date-table">
      <title>日期输入</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>例子</entry>
         <entry>描述</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>1999-01-08</entry>
         <entry>ISO 8601; 任何模式下的1月8日
         （推荐格式）</entry>
        </row>
        <row>
         <entry>January 8, 1999</entry>
         <entry>在任何<varname>datestyle</varname>输入模式下都无歧义</entry>
        </row>
        <row>
         <entry>1/8/1999</entry>
         <entry><literal>MDY</>模式中的1月8日；<literal>DMY</>模式中的8月1日</entry>
        </row>
        <row>
         <entry>1/18/1999</entry>
         <entry><literal>MDY</>模式中的1月18日；在其他模式中被拒绝</entry>
        </row>
        <row>
         <entry>01/02/03</entry>
         <entry><literal>MDY</>模式中的2003年1月2日；
          <literal>DMY</>模式中的2003年2月1日；
          <literal>YMD</>模式中的2001年2月3日
         </entry>
        </row>
        <row>
         <entry>1999-Jan-08</entry>
         <entry>任何模式下的1月8日</entry>
        </row>
        <row>
         <entry>Jan-08-1999</entry>
         <entry>任何模式下的1月8日</entry>
        </row>
        <row>
         <entry>08-Jan-1999</entry>
         <entry>任何模式下的1月8日</entry>
        </row>
        <row>
         <entry>99-Jan-08</entry>
         <entry><literal>YMD</>模式中的1月8日，否则错误</entry>
        </row>
        <row>
         <entry>08-Jan-99</entry>
         <entry>1月8日，除了在<literal>YMD</>模式中错误</entry>
        </row>
        <row>
         <entry>Jan-08-99</entry>
         <entry>1月8日，除了在<literal>YMD</>模式中错误</entry>
        </row>
        <row>
         <entry>19990108</entry>
         <entry>ISO 8601; 任何模式中的1999年1月8日</entry>
        </row>
        <row>
         <entry>990108</entry>
         <entry>ISO 8601; 任何模式中的1999年1月8日</entry>
        </row>
        <row>
         <entry>1999.008</entry>
         <entry>年和一年中的日子</entry>
        </row>
        <row>
         <entry>J2451187</entry>
         <entry>儒略日期</entry>
        </row>
        <row>
         <entry>January 8, 99 BC</entry>
         <entry>公元前99年</entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </sect3>

    <sect3>
     <title>时间</title>

     <indexterm>
      <primary>time</primary>
     </indexterm>
     <indexterm>
      <primary>time without time zone</primary>
     </indexterm>
     <indexterm>
      <primary>time with time zone</primary>
     </indexterm>

     <para>
      当日时间类型是<type>time [ (<replaceable>p</replaceable>) ] without time zone</type>和<type>time [ (<replaceable>p</replaceable>) ] with time zone</type>。 只写<type>time</type>等效于<type>time without time zone</type>。
     </para>

     <para>
      这些类型的有效输入由当日时间后面跟着可选的时区组成（参阅<xref linkend="datatype-datetime-time-table">和<xref linkend="datatype-timezone-table">）。 如果在<type>time without time zone</type>的输入中指定了时区，那么它会被无声地忽略。你也可以指定一个日期但是它会被忽略，除非你使用了一个涉及到夏令时规则的时区，例如<literal>America/New_York</literal>。在这种情况下，为了判断是应用了标准时间还是夏令时时间，要求指定该日期。适当的时区偏移被记录在<type>time with time zone</type>值中。
     </para>

      <table id="datatype-datetime-time-table">
       <title>时间输入</title>
       <tgroup cols="2">
        <thead>
         <row>
          <entry>例子</entry>
          <entry>描述</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><literal>04:05:06.789</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05:06</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>040506</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05 AM</literal></entry>
          <entry>和04:05一样，AM并不影响值</entry>
         </row>
         <row>
          <entry><literal>04:05 PM</literal></entry>
          <entry>和16:05一样，输入的小时必须为 &lt;= 12</entry>
         </row>
         <row>
          <entry><literal>04:05:06.789-8</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05:06-08:00</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05-08:00</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>040506-08</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05:06 PST</literal></entry>
          <entry>缩写指定的时区</entry>
         </row>
         <row>
          <entry><literal>2003-04-12 04:05:06 America/New_York</literal></entry>
          <entry>全名指定的时区</entry>
         </row>
        </tbody>
       </tgroup>
      </table>

      <table tocentry="1" id="datatype-timezone-table">
       <title>时区输入</title>
       <tgroup cols="2">
        <thead>
         <row>
          <entry>例子</entry>
          <entry>描述</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><literal>PST</literal></entry>
          <entry>缩写（太平洋标准时间）</entry>
         </row>
         <row>
          <entry><literal>America/New_York</literal></entry>
          <entry>完整时区名</entry>
         </row>
         <row>
          <entry><literal>PST8PDT</literal></entry>
          <entry>POSIX风格的时区声明</entry>
         </row>
         <row>
          <entry><literal>-8:00</literal></entry>
          <entry>PST的ISO-8601偏移</entry>
         </row>
         <row>
          <entry><literal>-800</literal></entry>
          <entry>PST的ISO-8601偏移</entry>
         </row>
         <row>
          <entry><literal>-8</literal></entry>
          <entry>PST的ISO-8601偏移</entry>
         </row>
         <row>
          <entry><literal>zulu</literal></entry>
          <entry>UTC的军方缩写</entry>
         </row>
         <row>
          <entry><literal>z</literal></entry>
          <entry><literal>zulu</literal>的短形式</entry>
         </row>
        </tbody>
       </tgroup>
      </table>

     <para>
     参考<xref linkend="datatype-timezones">可以了解如何指定时区。
    </para>
    </sect3>

    <sect3>
    <title>时间戳</title>

    <indexterm>
     <primary>timestamp</primary>
    </indexterm>

    <indexterm>
     <primary>timestamp with time zone</primary>
    </indexterm>

    <indexterm>
     <primary>timestamp without time zone</primary>
    </indexterm>

     <para>
      时间戳类型的有效输入由一个日期和时间的串接组成，后面跟着一个可选的时区，一个可选的<literal>AD</literal>或者<literal>BC</literal>（另外，<literal>AD</literal>/<literal>BC</literal>可以出现在时区前面，但这个顺序并非最佳）。 因此：

<programlisting>
1999-01-08 04:05:06
</programlisting>
      和：
<programlisting>
1999-01-08 04:05:06 -8:00
</programlisting>

      都是有效的值，它遵循<acronym>ISO</acronym> 8601 标准。另外，使用广泛的格式：
<programlisting>
January 8 04:05:06 1999 PST
</programlisting>
      也被支持。
     </para>

     <para>
      <acronym>SQL</acronym>标准通过<quote>+</quote>或者<quote>-</quote>符号的存在以及时间后面的时区偏移来区分<type>timestamp without time zone</type>和<type>timestamp with time zone</type>文字。因此，根据标准，

      <programlisting>TIMESTAMP '2004-10-19 10:23:54'</programlisting>

      是一个<type>timestamp without time zone</type>， 而

      <programlisting>TIMESTAMP '2004-10-19 10:23:54+02'</programlisting>

      是一个<type>timestamp with time zone</type>。<productname>PostgreSQL</productname>从来不会在确定文字串的类型之前检查其内容，因此会把上面两个都看做是 <type>timestamp without time zone</type>。因此要保证把上面的文字当作<type>timestamp with time zone</type>看待， 就要给它正确的显式类型：

      <programlisting>TIMESTAMP WITH TIME ZONE '2004-10-19 10:23:54+02'</programlisting>

      如果一个文字已被确定是<type>timestamp without time zone</type>，<productname>PostgreSQL</productname>将不声不响忽略任何其中指出的时区。 即，结果值是从输入值的日期/时间域衍生出来的，并且没有就时区进行调整。
     </para>

     <para>
      对于<type>timestamp with time zone</type>，内部存储的值总是 UTC （全球统一时间，以前也叫格林威治时间<acronym>GMT</>）。如果一个输入值有明确的时区声明， 那么它将用该时区合适的偏移量转换成 UTC。如果在输入串里没有时区声明， 那么它就被假设是在系统的<xref linkend="guc-timezone">参数里的那个时区，然后使用这个 <varname>timezone</>时区的偏移转换成 UTC。
     </para>

     <para>
      如果一个<type>timestamp with time zone</type>值被输出，那么它总是从 UTC 转换成当前的<varname>timezone</>时区，并且显示为该时区的本地时间。要看其它时区的时间，要么修改<varname>timezone</>，要么使用<literal>AT TIME ZONE</>构造（参阅<xref linkend="functions-datetime-zoneconvert">）。
     </para>

     <para>
      在<type>timestamp without time zone</type>和<type>timestamp with time zone</type>之间的转换通常假设<type>timestamp without time zone</type>值应该以<varname>timezone</>本地时间的形式接受或者写出。为该转换指定一个不同的可以用<literal>AT TIME ZONE</>。
     </para>
    </sect3>

    <sect3>
     <title>特殊值</title>

     <indexterm>
      <primary>time</primary>
      <secondary>constants</secondary>
     </indexterm>

     <indexterm>
      <primary>date</primary>
      <secondary>constants</secondary>
     </indexterm>

     <para>
      为了方便，<productname>PostgreSQL</productname>支持一些特殊日期/时间输入值，如<xref linkend="datatype-datetime-special-table">所示。这些值中<literal>infinity</literal>和<literal>-infinity</literal>被在系统内部以特殊方式表示并且将被原封不动地显示。但是其他的仅仅只是概念上的速写，当被读到的时候会被转换为正常的日期/时间值（特殊地，<literal>now</>及相关串在被读到时立刻被转换到一个指定的时间值）。在作为常量在SQL命令中使用时，所有这些值需要被包括在单引号内。
     </para>

      <table id="datatype-datetime-special-table">
       <title>特殊日期/时间输入</title>
       <tgroup cols="3">
        <thead>
         <row>
          <entry>输入串</entry>
          <entry>合法类型</entry>
          <entry>描述</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><literal>epoch</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>1970-01-01 00:00:00+00（Unix系统时间0）</entry>
         </row>
         <row>
          <entry><literal>infinity</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>比任何其他时间戳都晚</entry>
         </row>
         <row>
          <entry><literal>-infinity</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>比任何其他时间戳都早</entry>
         </row>
         <row>
          <entry><literal>now</literal></entry>
          <entry><type>date</type>, <type>time</type>, <type>timestamp</type></entry>
          <entry>当前事务的开始时间</entry>
         </row>
         <row>
          <entry><literal>today</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>当日午夜</entry>
         </row>
         <row>
          <entry><literal>tomorrow</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>明日午夜</entry>
         </row>
         <row>
          <entry><literal>yesterday</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>昨日午夜</entry>
         </row>
         <row>
          <entry><literal>allballs</literal></entry>
          <entry><type>time</type></entry>
          <entry>00:00:00.00 UTC</entry>
         </row>
        </tbody>
       </tgroup>
      </table>

     <para>
      下列<acronym>SQL</acronym>-兼容的函数可以被用来为相应的数据类型获得当前时间值：
      <literal>CURRENT_DATE</literal>、<literal>CURRENT_TIME</literal>、
      <literal>CURRENT_TIMESTAMP</literal>、<literal>LOCALTIME</literal>、
      <literal>LOCALTIMESTAMP</literal>。后四种接受一个可选的亚秒精度声明（参见<xref
      linkend="functions-datetime-current">）。注意这些是SQL函数并且在数据输入串中<emphasis>不</>被识别。
     </para>

    </sect3>
   </sect2>

   <sect2 id="datatype-datetime-output">
    <title>日期/时间输出</title>

    <indexterm>
     <primary>date</primary>
     <secondary>输出格式</secondary>
     <seealso>formatting</seealso>
    </indexterm>

    <indexterm>
     <primary>time</primary>
     <secondary>输出格式</secondary>
     <seealso>formatting</seealso>
    </indexterm>

    <para>
     时间/日期类型的输出格式可以设成四种风格之一： ISO 8601、<acronym>SQL</acronym>（Ingres）、传统的<productname>POSTGRES</>（Unix的<application>date</>格式）或 German 。缺省是<acronym>ISO</acronym>格式（<acronym>ISO</acronym>标准要求使用 ISO 8601 格式。<acronym>ISO</acronym>输出格式的名字是历史偶然）。<xref linkend="datatype-datetime-output-table">显示了每种输出风格的例子。<type>date</type>和<type>time</type>类型的 输出通常只有日期或时间部分和例子中一致。不过，<productname>POSTGRES</>风格输出的是<acronym>ISO</acronym>格式的只有日期的值。
    </para>

     <table id="datatype-datetime-output-table">
      <title>日期/时间输出风格</title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>风格声明</entry>
         <entry>描述</entry>
         <entry>例子</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>ISO</literal></entry>
         <entry>ISO 8601, SQL标准</entry>
         <entry><literal>1997-12-17 07:37:16-08</literal></entry>
        </row>
        <row>
         <entry><literal>SQL</literal></entry>
         <entry>传统风格</entry>
         <entry><literal>12/17/1997 07:37:16.00 PST</literal></entry>
        </row>
        <row>
         <entry><literal>Postgres</literal></entry>
         <entry>原始风格</entry>
         <entry><literal>Wed Dec 17 07:37:16 1997 PST</literal></entry>
        </row>
        <row>
         <entry><literal>German</literal></entry>
         <entry>地区风格</entry>
         <entry><literal>17.12.1997 07:37:16.00 PST</literal></entry>
        </row>
       </tbody>
      </tgroup>
     </table>

    <note>
     <para>
      ISO 8601指定使用大写字母<literal>T</>来分隔日期和时间。<productname>PostgreSQL</>在输入上接受这种格式，但是在输出时它采用一个空格而不是<literal>T</>，如上所示。和一些其他数据库系统一样，这是为了可读性以及与RFC 3339的一致性。
     </para>
    </note>

    <para>
     <acronym>SQL</acronym>和POSTGRES风格中，如果DMY域顺序被指定，“日”将出现在“月”之前，否则“月”出现在“日”之前（有关该设置如何影响输入值的解释，请参考<xref linkend="datatype-datetime-input">）。<xref linkend="datatype-datetime-output2-table">给出了例子。
    </para>

     <table id="datatype-datetime-output2-table">
      <title>日期顺序习惯</title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry><varname>datestyle</varname>设置</entry>
         <entry>输入顺序</entry>
         <entry>例子输出</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>SQL, DMY</></entry>
         <entry><replaceable>日</replaceable>/<replaceable>月</replaceable>/<replaceable>年</replaceable></entry>
         <entry><literal>17/12/1997 15:37:16.00 CET</literal></entry>
        </row>
        <row>
         <entry><literal>SQL, MDY</></entry>
         <entry><replaceable>月</replaceable>/<replaceable>日</replaceable>/<replaceable>年</replaceable></entry>
         <entry><literal>12/17/1997 07:37:16.00 PST</literal></entry>
        </row>
        <row>
         <entry><literal>Postgres, DMY</></entry>
         <entry><replaceable>日</replaceable>/<replaceable>月</replaceable>/<replaceable>年</replaceable></entry>
         <entry><literal>Wed 17 Dec 07:37:16 1997 PST</literal></entry>
        </row>
       </tbody>
      </tgroup>
     </table>

    <para>
     日期/时间风格可以由用户使用<command>SET datestyle</command>命令选取，在<filename>postgresql.conf</filename>配置文件里的参数<xref linkend="guc-datestyle">设置或者在服务器或客户端的<envar>PGDATESTYLE</envar>环境变量里设置。
    </para>

    <para>
     格式化函数<function>to_char</function>（见<xref linkend="functions-formatting">）也可以作为一个更灵活的方式来格式化日期/时间输出。
    </para>
   </sect2>

   <sect2 id="datatype-timezones">
    <title> 时区</title>

    <indexterm zone="datatype-timezones">
     <primary>time zone</primary>
    </indexterm>

   <para>
    时区和时区习惯不仅仅受地球几何形状的影响，还受到政治决定的影响。 到了19世纪，全球的时区变得稍微标准化了些，但是还是易于遭受随意的修改，部分是因为夏时制规
    则。<productname>PostgreSQL</productname>使用广泛使用的 IANA (Olson) 时区数据库来得到有关历史时区规则的信息。对于未来的时间，我们假设关于一个给定时区的最新已知
    规则将会一直持续到无穷远的未来。
   </para>

    <para>
     <productname>PostgreSQL</productname>努力在典型使用中与<acronym>SQL</acronym>标准的定义相兼容。但<acronym>SQL</acronym>标准在日期和时间类型和功能上有一些奇怪的混淆。两个显而易见的问题是：

     <itemizedlist>
      <listitem>
       <para>
        尽管<type>date</type>类型与时区没有联系，而<type>time</type>类型却可以有。 然而，现实世界的时区只有在与时间和日期都关联时才有意义， 因为偏移（时差）可能因为实行类似夏时制这样的制度而在一年里有所变化。
       </para>
      </listitem>

      <listitem>
       <para>
        缺省的时区会指定一个到<acronym>UTC</>的数字常量偏移（时差）。因此，当跨<acronym>DST</acronym>边界做日期/时间算术时， 我们根本不可能适应于夏时制时间。
       </para>
      </listitem>

     </itemizedlist>
    </para>

    <para>
     为了克服这些困难，我们建议在使用时区的时候，使用那些同时包含日期和时间的日期/时间类型。我们<emphasis>不</>建议使用类型 <type>time with time zone</type> （尽管<productname>PostgreSQL</productname>出于遗留应用以及与<acronym>SQL</acronym>标准兼容性的考虑支持这个类型）。 <productname>PostgreSQL</productname>假设你用于任何类型的本地时区都只包含日期或时间。
    </para>

    <para>
     在系统内部，所有时区相关的日期和时间都用<acronym>UTC</acronym>存储。它们在被显示给客户端之前会被转换成由<xref linkend="guc-timezone">配置参数指定的本地时间。
    </para>

    <para>
     <productname>PostgreSQL</productname>允许你使用三种不同形式指定时区：
     <itemizedlist>
      <listitem>
       <para>
        一个完整的时区名字，例如<literal>America/New_York</>。能被识别的时区名字被列在<literal>pg_timezone_names</literal>视图中（参见<xref linkend="view-pg-timezone-names">）。<productname>PostgreSQL</productname>用广泛使用的 IANA 时区数据来实现该目的，因此相同的时区名字也可以在很多其他软件中被识别。
       </para>
      </listitem>
      <listitem>
       <para>
        一个时区缩写，例如<literal>PST</>。这样一种声明仅仅定义了到UTC的一个特定偏移，而不像完整时区名那样指出整套夏令时转换日期规则。能被识别的缩写被列在<literal>pg_timezone_abbrevs</>视图中（参见<xref linkend="view-pg-timezone-abbrevs">）。你不能将配置参数<xref linkend="guc-timezone">或<xref linkend="guc-log-timezone">设置成一个时区缩写，但是你可以在日期/时间输入值和<literal>AT TIME ZONE</>操作符中使用时区缩写。
       </para>
      </listitem>
      <listitem>
       <para>
        除了时区名和缩写，<productname>PostgreSQL</productname>将接受POSIX-风格的
        时区声明，形式为<replaceable>STD</><replaceable>offset</>或
        <replaceable>STD</><replaceable>offset</><replaceable>DST</>，
        其中<replaceable>STD</>是一个区域缩写、<replaceable>offset</>是从UTC西
        起的以小时计的数字偏移量、<replaceable>DST</>是一个可选的夏令时区域缩
        写（被假定为给定偏移量提前一小时）。例如，如果<literal>EST5EDT</>还不是一
        个被识别的区域名，它可以被接受并且可能和美国东海岸时间的功效相同。在这种语法中，
        一个时区缩写可以是一个字母的字符串或者由尖括号（<literal>&lt;&gt;</>）包围
        的任意字符串。当一个夏令时区域缩写出现时，会假定根据 IANA 时区数据库的
        <filename>posixrules</>条目中使用的同一个夏令时转换规则使用它。
        在一个标准的<productname>PostgreSQL</productname>安装中，
        <filename>posixrules</>和<literal>US/Eastern</>相同，
        因此POSIX-风格的时区声明遵循美国的夏令时规则。如果需要，你可以通过替换
        <filename>posixrules</>文件来调整这种行为。
       </para>
      </listitem>
     </itemizedlist>

     简而言之，在缩写和全称之间是有不同的：缩写表示从UTC开始的一个特定偏移量，
     而很多全称表示一个本地夏令时规则并且因此具有两种可能的UTC偏移量。例如，
     <literal>2014-06-04 12:00 America/New_York</>表示纽约本地时间的中午，
     这个特殊的日期是东部夏令时间（UTC-4）。因此<literal>2014-06-04 12:00 EDT</>
     指定的是同一个时间点。但是<literal>2014-06-04 12:00 EST</>指定东部标准时间的
     中午（UTC-5），不管在那个日期夏令时是否生效。
    </para>

    <para>
     更要命的是，某些行政区已经使用相同的时区缩写在不同的时间表示不同的 UTC 偏移量。例如，
     在莫斯科<literal>MSK</>在某些年份表示 UTC+3 而在另一些年份表示 UTC+4。 <application>PostgreSQL</> 会根据在指定的日期它们到底表示什么（或者最近表示什么）
     来解释这种缩写。但是，正如上面的<literal>EST</>例子所示，这并不是必须和那一天的本地
     标准时间相同。
    </para>

    <para>
     你应该注意到POSIX-风格的时区特性可能导致伪造的输入被接受，因为它没有对区域缩写合理性的检查。例如<literal>SET TIMEZONE TO FOOBAR0</>将会正常工作，让系统实际使用一个相当奇怪的UTC缩写。另一个需要记住的问题是在POSIX时区名中，正值的偏移量被用于格林威治<emphasis>以西</>的位置。在其他情况下，<productname>PostgreSQL</productname>将遵循 ISO-8601 惯例，认为正值的时区偏移量是格林威治<emphasis>以东</>。
    </para>

    <para>
     在所有情况下，时区名及其缩写都是大小写不敏感的（这是对<productname>PostgreSQL</productname> 8.2之前版本的一个修改，在这些版本中某些环境下时区名是大小写敏感的而在另外一些环境中却是大小写不敏感的）。
    </para>

    <para>
     时区名和缩写都不是硬写在服务器中的，它们是从存储在安装目录下的<filename>.../share/timezone/</>和<filename>.../share/timezonesets/</>子目录中获取的（参见<xref linkend="datetime-config-files">）。
    </para>

    <para>
     <xref linkend="guc-timezone">配置参数可以在文件<filename>postgresql.conf</>中被设置，或者使用<xref linkend="runtime-config">中描述的任何一种标准方法设置。同时也有一些特殊的方法来设置它：

     <itemizedlist>
      <listitem>
       <para>
        <acronym>SQL</acronym>命令<command>SET TIME ZONE</command>为会话设置时区。它是<command>SET TIMEZONE TO</>的另一种拼写，它更加符合SQL的语法。
       </para>
      </listitem>

      <listitem>
       <para>
        <application>libpq</application>客户端使用<envar>PGTZ</envar>环境变量来通过连接发送一个<command>SET TIME ZONE</command>命令给服务器。
       </para>
      </listitem>
     </itemizedlist>
    </para>
   </sect2>

   <sect2 id="datatype-interval-input">
    <title>间隔输入</title>

    <indexterm>
     <primary>interval</primary>
    </indexterm>

     <para>
      <type>interval</type>值可以使用下列语法书写：

<synopsis>
<optional>@</> <replaceable>quantity</> <replaceable>unit</> <optional><replaceable>quantity</> <replaceable>unit</>...</> <optional><replaceable>direction</></optional>
</synopsis>

     其中<replaceable>quantity</>是一个数字（很可能是有符号的）；
     <replaceable>unit</>是<literal>毫秒</literal>、
     <literal>millisecond</literal>、<literal>second</literal>、
     <literal>minute</literal>、<literal>hour</literal>、<literal>day</literal>、
     <literal>week</literal>、<literal>month</literal>、<literal>year</literal>、
     <literal>decade</literal>、<literal>century</literal>、<literal>millennium</literal>
     或者缩写或者这些单位的复数；
     <replaceable>direction</>可以是<literal>ago</literal>或者为空。At符号（<literal>@</>）是一个可选的噪声。不同单位的数量通过合适的符号计数被隐式地添加。<literal>ago</literal>对所有域求反。如果<xref linkend="guc-intervalstyle">被设置为<literal>postgres_verbose</>，该语法也被用于间隔输出。
    </para>

    <para>
     日、小时、分钟和秒的数量可以不适用显式的单位标记指定。例如，<literal>'1 12:59:10'</>被读作<literal>'1 day 12 hours 59 min 10 sec'</>。同样，一个年和月的组合可以使用一个横线指定，例如<literal>'200-10'</>被读作<literal>'200年10个月'</>（这些较短的形式事实上是<acronym>SQL</acronym>标准唯一许可的形式，并且在<varname>IntervalStyle</>被设置为<literal>sql_standard</literal>时用于输出）。
    </para>

    <para>
     间隔值也可以被写成 ISO 8601 时间间隔，使用该标准4.4.3.2小节的<quote>带标志符的格式</>或者4.4.3.3小节的<quote>替代格式</>。带标志符的格式看起来像这样：
<synopsis>
P <replaceable>quantity</> <replaceable>unit</> <optional> <replaceable>quantity</> <replaceable>unit</> ...</optional> <optional> T <optional> <replaceable>quantity</> <replaceable>unit</> ...</optional></optional>
</synopsis>
      该串必须以一个<literal>P</>开始，并且可以包括一个引入当日时间单位的<literal>T</>。可用的单位缩写在<xref linkend="datatype-interval-iso8601-units">中给出。单位可以被忽略，并且可以以任何顺序指定，但是小于一天的单位必须出现在<literal>T</>之后。特别地，<literal>M</>的含义取决于它出现在<literal>T</>之前还是之后。
     </para>

     <table id="datatype-interval-iso8601-units">
      <title>ISO 8601 间隔单位缩写</title>
     <tgroup cols="2">
       <thead>
        <row>
         <entry>缩写</entry>
         <entry>含义</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>Y</entry>
         <entry>年</entry>
        </row>
        <row>
         <entry>M</entry>
         <entry>月（在日期部分中）</entry>
        </row>
        <row>
         <entry>W</entry>
         <entry>周</entry>
        </row>
        <row>
         <entry>D</entry>
         <entry>日</entry>
        </row>
        <row>
         <entry>H</entry>
         <entry>小时</entry>
        </row>
        <row>
         <entry>M</entry>
         <entry>分钟 (在时间部分中）</entry>
        </row>
        <row>
         <entry>S</entry>
         <entry>秒</entry>
        </row>
       </tbody>
      </tgroup>
     </table>

     <para>
      如果使用替代格式：
<synopsis>
P <optional> <replaceable>years</>-<replaceable>months</>-<replaceable>days</> </optional> <optional> T <replaceable>hours</>:<replaceable>minutes</>:<replaceable>seconds</> </optional>
</synopsis>
      串必须以<literal>P</literal>开始，并且一个<literal>T</>分隔间隔的日期和时间部分。其值按照类似于 ISO 8601日期的数字给出。
    </para>

    <para>
     在用一个<replaceable>域</>声明书写一个间隔常量时，或者为一个用<replaceable>域</>声明定义的间隔列赋予一个串时，对于为标记的量的解释依赖于<replaceable>域</>。例如<literal>INTERVAL '1' YEAR</>被解读成1年，而<literal>INTERVAL '1'</>表示1秒。同样，<replaceable>域</>声明允许的最后一个有效域<quote>右边</>的域值会被无声地丢弃掉。例如书写<literal>INTERVAL '1 day 2:03:04' HOUR TO MINUTE</>将会导致丢弃秒域，而不是日域。
    </para>

    <para>
     根据<acronym>SQL</>标准，一个间隔值的所有域都必须由相同的符号，这样一个领头的负号将会应用到所有域；例如在间隔文字<literal>'-1 2:03:04'</>中的负号会被应用于日、小时、分钟和秒部分。<productname>PostgreSQL</>允许域具有不同的符号，并且在习惯上认为以文本表示的每个域具有独立的符号，因此在这个例子中小时、分钟和秒部分被认为是正值。如果<varname>IntervalStyle</>被设置为<literal>sql_standard</literal>，则一个领头的符号将被认为是应用于所有域（但是仅当没有额外符号出现）。否则将使用传统的<productname>PostgreSQL</>解释。为了避免混淆，我们推荐在任何域为负值时为每一个域都附加一个显式的符号。
    </para>

    <para>
     内部的<type>interval</>值被存储为月、日和秒。这是因为一个月中的天数是变化的，并且在涉及到夏令时调整时一天可以有23或25小时。月和日域是整数，而秒域可以存储分数。因为间隔通常都是从常数字符串或<type>timestamp</>减法创建而来，这种存储方法在大部分情况都工作良好。函数<function>justify_days</>和<function>justify_hours</>可用于调整超过其常见范围的日数和小时数。
    </para>

    <para>
     在冗长的输入格式中，以及在更紧凑输入格式的某些域中，域值可以有分数部分；例如<literal>'1.5 week'</>或<literal>'01:02:03.45'</>。这样的输入被转换为合适的月数、日数和秒数用于存储。当这样会导致月和日中的分数时，分数被加到低序域中，使用的转换因子是1月=30日和1日=24小时。例如，<literal>'1.5 month'</>会变成1月和15日。只有秒总是在输出时被显示为分数。
    </para>

    <para>
     <xref linkend="datatype-interval-input-examples">展示了一些有效<type>interval</>输入的例子。
    </para>

     <table id="datatype-interval-input-examples">
      <title>间隔输入</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>例子</entry>
         <entry>描述</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>1-2</entry>
         <entry>SQL标准格式：1年2个月</entry>
        </row>
        <row>
         <entry>3 4:05:06</entry>
         <entry>SQL标准格式：3日4小时5分钟6秒</entry>
        </row>
        <row>
         <entry>1 year 2 months 3 days 4 hours 5 minutes 6 seconds</entry>
         <entry>传统Postgres格式：1年2个月3日4小时5分钟6秒钟</entry>
        </row>
        <row>
         <entry>P1Y2M3DT4H5M6S</entry>
         <entry><quote>带标志符的</>ISO 8601 格式：含义同上</entry>
        </row>
        <row>
         <entry>P0001-02-03T04:05:06</entry>
         <entry>ISO 8601 的<quote>替代格式</>：含义同上</entry>
        </row>
       </tbody>
      </tgroup>
     </table>

   </sect2>

   <sect2 id="datatype-interval-output">
    <title>间隔输出</title>

    <indexterm>
     <primary>interval</primary>
     <secondary>输出格式</secondary>
     <seealso>formatting</seealso>
    </indexterm>

    <para>
     间隔类型的输出格式可以被设置为四种风格之一：<literal>sql_standard</>、<literal>postgres</>、<literal>postgres_verbose</>或<literal>iso_8601</>，设置方法使用<literal>SET intervalstyle</literal>命令。默认值为<literal>postgres</>格式。<xref linkend="interval-style-output-table">展示了每种输出风格的例子。
    </para>

    <para>
     如果间隔值符合SQL标准的限制（仅年-月或仅日-时间，没有正负值部分的混合），<literal>sql_standard</>风格为间隔文字串产生符合SQL标准规范的输出。否则输出将看起来像一个标准的年-月文字串跟着一个日-时间文字串，并且带有显式添加的符号以区分混合符号的间隔。
    </para>

    <para>
     当<xref linkend="guc-datestyle">参数被设置为<literal>ISO</>时，<literal>postgres</>风格的输出匹配<productname>PostgreSQL</> 8.4版本以前的输出。
    </para>

    <para>
     当<varname>DateStyle</>参数被设置为非<literal>ISO</>输出时，<literal>postgres_verbose</>风格的输出匹配<productname>PostgreSQL</> 8.4版本以前的输出。
    </para>

    <para>
     <literal>iso_8601</>风格的输出匹配在ISO 8601标准的4.4.3.2小节中描述的<quote>带标志符的格式</>。
    </para>

     <table id="interval-style-output-table">
       <title>间隔输出风格例子</title>
       <tgroup cols="4">
        <thead>
         <row>
          <entry>风格声明</entry>
          <entry>年-月间隔</entry>
          <entry>日-时间间隔</entry>
          <entry>混合间隔</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><literal>sql_standard</></entry>
          <entry>1-2</entry>
          <entry>3 4:05:06</entry>
          <entry>-1-2 +3 -4:05:06</entry>
         </row>
         <row>
          <entry><literal>postgres</></entry>
          <entry>1 year 2 mons</entry>
          <entry>3 days 04:05:06</entry>
          <entry>-1 year -2 mons +3 days -04:05:06</entry>
         </row>
         <row>
          <entry><literal>postgres_verbose</></entry>
          <entry>@ 1 year 2 mons</entry>
          <entry>@ 3 days 4 hours 5 mins 6 secs</entry>
          <entry>@ 1 year 2 mons -3 days 4 hours 5 mins 6 secs ago</entry>
         </row>
         <row>
          <entry><literal>iso_8601</></entry>
          <entry>P1Y2M</entry>
          <entry>P3DT4H5M6S</entry>
          <entry>P-1Y-2M3DT-4H-5M-6S</entry>
         </row>
        </tbody>
       </tgroup>
    </table>

   </sect2>

  </sect1>

  <sect1 id="datatype-boolean">
   <title>布尔类型</title>

   <indexterm zone="datatype-boolean">
    <primary>Boolean</primary>
    <secondary>数据类型</secondary>
   </indexterm>

   <indexterm zone="datatype-boolean">
    <primary>true</primary>
   </indexterm>

   <indexterm zone="datatype-boolean">
    <primary>false</primary>
   </indexterm>

   <para>
    <productname>PostgreSQL</productname>提供标准的<acronym>SQL</acronym>类型<type>boolean</type>，参见<xref linkend="datatype-boolean-table">。<type>boolean</type>可以有多个状态：<quote>true（真）</quote>、<quote>false（假）</quote>和第三种状态<quote>unknown（未知）</quote>，未知状态由<acronym>SQL</acronym>空值表示。
   </para>

   <table id="datatype-boolean-table">
    <title>布尔数据类型</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>名字</entry>
       <entry>存储字节</entry>
       <entry>描述</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><type>boolean</type></entry>
       <entry>1字节</entry>
       <entry>状态为真或假</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    <quote>真</quote>状态的有效文字值是：
    <simplelist>
     <member><literal>TRUE</literal></member>
     <member><literal>'t'</literal></member>
     <member><literal>'true'</literal></member>
     <member><literal>'y'</literal></member>
     <member><literal>'yes'</literal></member>
     <member><literal>'on'</literal></member>
     <member><literal>'1'</literal></member>
    </simplelist>
    而对于<quote>假</quote>状态，你可以使用下面这些值：
    <simplelist>
     <member><literal>FALSE</literal></member>
     <member><literal>'f'</literal></member>
     <member><literal>'false'</literal></member>
     <member><literal>'n'</literal></member>
     <member><literal>'no'</literal></member>
     <member><literal>'off'</literal></member>
     <member><literal>'0'</literal></member>
    </simplelist>
    前导或者末尾的空白将被忽略，并且大小写也无关紧要。使用<literal>TRUE</literal>和<literal>FALSE</literal>这样的关键词比较好（<acronym>SQL</acronym>兼容）。
   </para>

   <para>
    <xref linkend="datatype-boolean-example">显示了使用字母<literal>t</literal>和<literal>f</literal>输出<type>boolean</type>值的例子。
   </para>

   <example id="datatype-boolean-example">
    <title>使用<type>boolean</type>类型</title>

<programlisting>
CREATE TABLE test1 (a boolean, b text);
INSERT INTO test1 VALUES (TRUE, 'sic est');
INSERT INTO test1 VALUES (FALSE, 'non est');
SELECT * FROM test1;
 a |    b
---+---------
 t | sic est
 f | non est

SELECT * FROM test1 WHERE a;
 a |    b
---+---------
 t | sic est
</programlisting>
   </example>
  </sect1>

  <sect1 id="datatype-enum">
   <title>枚举类型</title>

   <indexterm zone="datatype-enum">
    <primary>数据类型</primary>
    <secondary>enumerated (enum)</secondary>
   </indexterm>

   <indexterm zone="datatype-enum">
    <primary>enumerated types</primary>
   </indexterm>

   <para>
    枚举（enum）类型是由一个静态、值的有序集合构成的数据类型。它们等效于很多编程语言所支持的<type>enum</type>类型。枚举类型的一个例子可以是一周中的日期，或者一个数据的状态值集合。
   </para>

   <sect2>
    <title>枚举类型的声明</title>

    <para>
     枚举类型可以使用<xref linkend="sql-createtype">命令创建，例如：

<programlisting>
CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');
</programlisting>

     一旦被创建，枚举类型可以像很多其他类型一样在表和函数定义中使用：
<programlisting>
CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');
CREATE TABLE person (
    name text,
    current_mood mood
);
INSERT INTO person VALUES ('Moe', 'happy');
SELECT * FROM person WHERE current_mood = 'happy';
 name | current_mood
------+--------------
 Moe  | happy
(1 row)
</programlisting>
    </para>
    </sect2>

    <sect2>
     <title>排序</title>

     <para>
      一个枚举类型的值的排序是该类型被创建时所列出的值的顺序。枚举类型的所有标准的比较操作符以及相关聚集函数都被支持。例如：

<programlisting>
INSERT INTO person VALUES ('Larry', 'sad');
INSERT INTO person VALUES ('Curly', 'ok');
SELECT * FROM person WHERE current_mood > 'sad';
 name  | current_mood
-------+--------------
 Moe   | happy
 Curly | ok
(2 rows)

SELECT * FROM person WHERE current_mood > 'sad' ORDER BY current_mood;
 name  | current_mood
-------+--------------
 Curly | ok
 Moe   | happy
(2 rows)

SELECT name
FROM person
WHERE current_mood = (SELECT MIN(current_mood) FROM person);
 name
-------
 Larry
(1 row)
</programlisting>
     </para>
   </sect2>

   <sect2>
    <title>类型安全性</title>

    <para>
     每一种枚举数据类型都是独立的并且不能和其他枚举类型相比较。看这样一个例子：

<programlisting>
CREATE TYPE happiness AS ENUM ('happy', 'very happy', 'ecstatic');
CREATE TABLE holidays (
    num_weeks integer,
    happiness happiness
);
INSERT INTO holidays(num_weeks,happiness) VALUES (4, 'happy');
INSERT INTO holidays(num_weeks,happiness) VALUES (6, 'very happy');
INSERT INTO holidays(num_weeks,happiness) VALUES (8, 'ecstatic');
INSERT INTO holidays(num_weeks,happiness) VALUES (2, 'sad');
ERROR:  invalid input value for enum happiness: "sad"
SELECT person.name, holidays.num_weeks FROM person, holidays
  WHERE person.current_mood = holidays.happiness;
ERROR:  operator does not exist: mood = happiness
</programlisting>
    </para>

    <para>
     如果你确实需要做这样的事情，你可以写一个自定义的操作符或者在查询中加上显式造型：

<programlisting>
SELECT person.name, holidays.num_weeks FROM person, holidays
  WHERE person.current_mood::text = holidays.happiness::text;
 name | num_weeks
------+-----------
 Moe  |         4
(1 row)

</programlisting>
    </para>
   </sect2>

   <sect2>
    <title>实现细节</title>

    <para>
     一个枚举值在磁盘上占据4个字节。一个枚举值的文本标签的长度受限于<symbol>NAMEDATALEN</symbol>设置，该设置被编译在<productname>PostgreSQL</productname>中，在标准编译下它表示最多63字节。
    </para>

    <para>
     枚举标签是大小写敏感的，因此<type>'happy'</type>是不同于<type>'HAPPY'</type>的。标签内的空白也是有效的。
    </para>

    <para>
     从内部枚举值到文本标签的翻译被保存在系统目录<link linkend="catalog-pg-enum"><structname>pg_enum</structname></link>中。可以直接查询该目录。
    </para>

   </sect2>
  </sect1>

  <sect1 id="datatype-geometric">
   <title>几何类型</title>

   <para>
    几何数据类型表示二维的空间物体。<xref linkend="datatype-geo-table">展示了<productname>PostgreSQL</productname>中可以用的几何类型。
   </para>

    <table id="datatype-geo-table">
     <title>几何类型</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>名字</entry>
        <entry>存储尺寸</entry>
        <entry>表示</entry>
        <entry>描述</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><type>point</type></entry>
        <entry>16字节</entry>
        <entry>平面上的点</entry>
        <entry>(x,y)</entry>
       </row>
       <row>
        <entry><type>line</type></entry>
        <entry>32字节</entry>
        <entry>无限长的线</entry>
        <entry>{A,B,C}</entry>
       </row>
       <row>
        <entry><type>lseg</type></entry>
        <entry>32字节</entry>
        <entry>有限线段</entry>
        <entry>((x1,y1),(x2,y2))</entry>
       </row>
       <row>
        <entry><type>box</type></entry>
        <entry>32字节</entry>
        <entry>矩形框</entry>
        <entry>((x1,y1),(x2,y2))</entry>
       </row>
       <row>
        <entry><type>path</type></entry>
        <entry>16+16n字节</entry>
        <entry>封闭路径（类似于多边形）</entry>
        <entry>((x1,y1),...)</entry>
       </row>
       <row>
        <entry><type>path</type></entry>
        <entry>16+16n字节</entry>
        <entry>开放路径</entry>
        <entry>[(x1,y1),...]</entry>
       </row>
       <row>
        <entry><type>polygon</type></entry>
        <entry>40+16n字节</entry>
        <entry>多边形（类似于封闭路径）</entry>
        <entry>((x1,y1),...)</entry>
       </row>
       <row>
        <entry><type>circle</type></entry>
        <entry>24字节</entry>
        <entry>圆</entry>
        <entry>&lt;(x,y),r&gt; (center point and radius)</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    我们有一系列丰富的函数和操作符可用来进行各种几何操作， 如缩放、平移、旋转和计算相交等 它们在<xref linkend="functions-geometry">中解释。
   </para>

   <sect2>
    <title>点</title>

    <indexterm>
     <primary>point</primary>
    </indexterm>

    <para>
     点是几何类型的基本二维构造块。用下面的语法描述<type>point</type>类型的值：

<synopsis>
( <replaceable>x</replaceable> , <replaceable>y</replaceable> )
  <replaceable>x</replaceable> , <replaceable>y</replaceable>
</synopsis>

     其中<replaceable>x</>和<replaceable>y</>分别是坐标，都是浮点数。
    </para>

    <para>
     点使用第一种语法输出。
    </para>
   </sect2>

   <sect2 id="datatype-line">
    <title>线</title>

    <indexterm>
     <primary>line</primary>
    </indexterm>

    <para>
     线由线性方程<replaceable>A</>x + <replaceable>B</>y + <replaceable>C</> = 0
     表示，其中<replaceable>A</>和<replaceable>B</>都不为零。类型<type>line</type>
     的值采用以下形式输入和输出：
<synopsis>
{ <replaceable>A</replaceable>, <replaceable>B</replaceable>, <replaceable>C</replaceable> }
</synopsis>

     另外，还可以用下列任一形式输入：

<synopsis>
[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) ]
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   <replaceable>x2</replaceable> , <replaceable>y2</replaceable>
</synopsis>

     其中
     <literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>
     和
     <literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>
     是线上不同的两点。
    </para>
   </sect2>

   <sect2 id="datatype-lseg">
    <title>线段</title>

    <indexterm>
     <primary>lseg</primary>
    </indexterm>

    <indexterm>
     <primary>线段</primary>
    </indexterm>

    <para>
     线段用一对线段的端点来表示。<type>lseg</type>类型的值用下面的语法声明：

<synopsis>
[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) ]
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   <replaceable>x2</replaceable> , <replaceable>y2</replaceable>
</synopsis>

     其中<literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>
     和
     <literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>
     是线段的端点。
    </para>

    <para>
     线段使用第一种语法输出。
    </para>
   </sect2>

   <sect2>
    <title>方框</title>

    <indexterm>
     <primary>box (data type)</primary>
    </indexterm>

    <indexterm>
     <primary>rectangle</primary>
    </indexterm>

    <para>
     方框用其对角的点对表示。<type>box</type>类型的值使用下面的语法指定：

<synopsis>
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   <replaceable>x2</replaceable> , <replaceable>y2</replaceable>
</synopsis>

     其中<literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>
     和
     <literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>
     是方框的对角点。
    </para>

    <para>
     方框使用第二种语法输出。
    </para>

    <para>
     在输入时可以提供任意两个对角，但是值将根据需要被按顺序记录为右上角和左下角。
    </para>
   </sect2>

   <sect2>
    <title>路径</title>

    <indexterm>
     <primary>path (data type)</primary>
    </indexterm>

    <para>
     路径由一系列连接的点组成。路径可能是<firstterm>开放</firstterm>的，也就是认为列表中第一个点和最后一个点没有被连接起来；也可能是<firstterm>封闭</firstterm>的，这时认为第一个和最后一个点被连接起来。
    </para>

    <para>
     <type>path</type>类型的值用下面的语法声明：

<synopsis>
[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) ]
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable>
</synopsis>

     其中的点是组成路径的线段的端点。方括弧（<literal>[]</>）表示一个开放的路径，圆括弧（<literal>()</>）表示一个封闭的路径。如第三种到第五种语法所示，当最外面的圆括号被忽略时，路径将被假定为封闭。
    </para>

    <para>
     路径的输出使用第一种或第二种语法。
    </para>
   </sect2>

   <sect2 id="datatype-polygon">
    <title>多边形</title>

    <indexterm>
     <primary>polygon</primary>
    </indexterm>

    <para>
     多边形由一系列点代表（多边形的顶点）。多边形和封闭路径很像，但是存储方式不一样而且有自己的一套支持例程。
    </para>

    <para>
     <type>polygon</type>类型的值用下列语法声明：

<synopsis>
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable>
</synopsis>

     其中的点是组成多边形边界的线段的端点。
    </para>

    <para>
     多边形的输出使用第一种语法。
    </para>
   </sect2>

   <sect2 id="datatype-circle">
    <title>圆</title>

    <indexterm>
     <primary>circle</primary>
    </indexterm>

    <para>
     圆由一个圆心和一个半径代表。<type>circle</type>类型的值用下面的语法指定：

<synopsis>
&lt; ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable> &gt;
( ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable> )
  ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable>
    <replaceable>x</replaceable> , <replaceable>y</replaceable>   , <replaceable>r</replaceable>
</synopsis>

     其中<literal>(<replaceable>x</replaceable>,<replaceable>y</replaceable>)</>是圆心，而<replaceable>r</replaceable>是圆的半径。
    </para>

    <para>
     圆的输出用第一种语法。
    </para>
   </sect2>

  </sect1>

  <sect1 id="datatype-net-types">
   <title>网络地址类型</title>

   <indexterm zone="datatype-net-types">
    <primary>network</primary>
    <secondary>数据类型</secondary>
   </indexterm>

   <para>
    <productname>PostgreSQL</>提供用于存储 IPv4、IPv6 和 MAC 地址的数据类型，如<xref linkend="datatype-net-types-table">所示。 用这些数据类型存储网络地址比用纯文本类型好，因为这些类型提供输入错误检查以及特殊的操作符和函数（见<xref linkend="functions-net">）
   </para>

    <table tocentry="1" id="datatype-net-types-table">
     <title>网络地址类型</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>名字</entry>
        <entry>存储尺寸</entry>
        <entry>描述</entry>
       </row>
      </thead>
      <tbody>

       <row>
        <entry><type>cidr</type></entry>
        <entry>7或19字节</entry>
        <entry>IPv4和IPv6网络</entry>
       </row>

       <row>
        <entry><type>inet</type></entry>
        <entry>7或19字节</entry>
        <entry>IPv4和IPv6主机以及网络</entry>
       </row>

       <row>
        <entry><type>macaddr</type></entry>
        <entry>6字节</entry>
        <entry>MAC地址</entry>
       </row>

      </tbody>
     </tgroup>
    </table>

   <para>
    在对<type>inet</type>或者<type>cidr</type>数据类型进行排序的时候， IPv4 地址将总是排在 IPv6 地址前面，包括那些封装或者是映射在 IPv6 地址里 的 IPv4 地址，例如 ::10.2.3.4 或者 ::ffff::10.4.3.2。
   </para>


   <sect2 id="datatype-inet">
    <title><type>inet</type></title>

    <indexterm>
     <primary>inet（数据类型）</primary>
    </indexterm>

    <para>
     <type>inet</type>在一个数据域里保存一个 IPv4 或 IPv6 主机地址，以及一个可选的它的子网。 子网由主机地址中表示的网络地址位数表示（<quote>网络掩码</quote>）。 如果网络掩码为 32 并且地址是 IPv4 ，那么该值不表示任何子网，只是一台主机。在 IPv6 中地址长度是 128 位，因此 128 位指定一个唯一的主机地址。 请注意如果你想只接受网络地址，你应该使用<type>cidr</type>类型而不是<type>inet</type>。
    </para>

    <para>
      该类型的输入格式是<replaceable class="parameter">地址/y</replaceable>，其中<replaceable class="parameter">地址</replaceable>是一个 IPv4 或者 IPv6 地址，<replaceable class="parameter">y</replaceable>是网络掩码的位数。如果<replaceable class="parameter">/y</replaceable>部分缺失， 则网络掩码对 IPv4 而言是 32，对 IPv6 而言是 128，所以该值表示只有一台主机。在显示时，如果<replaceable class="parameter">/y</replaceable>部分指定一个单台主机，它将不会被显示出来。
    </para>
   </sect2>

   <sect2 id="datatype-cidr">
    <title><type>cidr</></title>

    <indexterm>
     <primary>cidr</primary>
    </indexterm>

    <para>
     <type>cidr</type>类型保存一个 IPv4 或 IPv6 网络地址声明。其输入和输出遵循无类的互联网域路由（Classless Internet Domain Routing）习惯。声明一个网络的格式是<replaceable class="parameter">地址/y</>，其中<replaceable class="parameter">address</>是 IPv4 或 IPv6 网络地址而<replaceable class="parameter">y</>是网络掩码的位数。如果省略<replaceable class="parameter">y</>， 那么掩码部分用旧的有类的网络编号系统进行计算，否则它将至少大到足以包括写在输入中的所有字节。声明一个在其指定的掩码右边置了位的网络地址会导致错误。
    </para>

    <para>
     <xref linkend="datatype-net-cidr-table">展示了一些例子。
    </para>

     <table id="datatype-net-cidr-table">
      <title><type>cidr</>类型输入例子</title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry><type>cidr</type>输入</entry>
         <entry><type>cidr</type>输出</entry>
         <entry><literal><function>abbrev(<type>cidr</type>)</function></literal></entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>192.168.100.128/25</entry>
         <entry>192.168.100.128/25</entry>
         <entry>192.168.100.128/25</entry>
        </row>
        <row>
         <entry>192.168/24</entry>
         <entry>192.168.0.0/24</entry>
         <entry>192.168.0/24</entry>
        </row>
        <row>
         <entry>192.168/25</entry>
         <entry>192.168.0.0/25</entry>
         <entry>192.168.0.0/25</entry>
        </row>
        <row>
         <entry>192.168.1</entry>
         <entry>192.168.1.0/24</entry>
         <entry>192.168.1/24</entry>
        </row>
        <row>
         <entry>192.168</entry>
         <entry>192.168.0.0/24</entry>
         <entry>192.168.0/24</entry>
        </row>
        <row>
         <entry>128.1</entry>
         <entry>128.1.0.0/16</entry>
         <entry>128.1/16</entry>
        </row>
        <row>
         <entry>128</entry>
         <entry>128.0.0.0/16</entry>
         <entry>128.0/16</entry>
        </row>
        <row>
         <entry>128.1.2</entry>
         <entry>128.1.2.0/24</entry>
         <entry>128.1.2/24</entry>
        </row>
        <row>
         <entry>10.1.2</entry>
         <entry>10.1.2.0/24</entry>
         <entry>10.1.2/24</entry>
        </row>
        <row>
         <entry>10.1</entry>
         <entry>10.1.0.0/16</entry>
         <entry>10.1/16</entry>
        </row>
        <row>
         <entry>10</entry>
         <entry>10.0.0.0/8</entry>
         <entry>10/8</entry>
        </row>
        <row>
         <entry>10.1.2.3/32</entry>
         <entry>10.1.2.3/32</entry>
         <entry>10.1.2.3/32</entry>
        </row>
        <row>
         <entry>2001:4f8:3:ba::/64</entry>
         <entry>2001:4f8:3:ba::/64</entry>
         <entry>2001:4f8:3:ba::/64</entry>
        </row>
        <row>
         <entry>2001:4f8:3:ba:2e0:81ff:fe22:d1f1/128</entry>
         <entry>2001:4f8:3:ba:2e0:81ff:fe22:d1f1/128</entry>
         <entry>2001:4f8:3:ba:2e0:81ff:fe22:d1f1</entry>
        </row>
        <row>
         <entry>::ffff:1.2.3.0/120</entry>
         <entry>::ffff:1.2.3.0/120</entry>
         <entry>::ffff:1.2.3/120</entry>
        </row>
        <row>
         <entry>::ffff:1.2.3.0/128</entry>
         <entry>::ffff:1.2.3.0/128</entry>
         <entry>::ffff:1.2.3.0/128</entry>
        </row>
       </tbody>
      </tgroup>
     </table>
   </sect2>

   <sect2 id="datatype-inet-vs-cidr">
    <title><type>inet</type> vs. <type>cidr</type></title>

    <para>
    <type>inet</type>和<type>cidr</type>类型之间的本质区别是<type>inet</type>接受右边有非零位的网络掩码， 而<type>cidr</type>不接受。
    </para>

      <tip>
        <para>
        如果你不喜欢<type>inet</type>或<type>cidr</type>值的输出格式，可以尝试函数<function>host</>、<function>text</>和<function>abbrev</>。
        </para>
      </tip>
   </sect2>

   <sect2 id="datatype-macaddr">
    <title><type>macaddr</type></title>

    <indexterm>
     <primary>macaddr（数据类型）</primary>
    </indexterm>

    <indexterm>
     <primary>MAC地址</primary>
     <see>macaddr</see>
    </indexterm>

    <para>
     <type>macaddr</>类型存储 MAC 地址，也就是以太网卡硬件地址 （尽管 MAC 地址还用于其它用途）。可以接受下列格式的输入：

     <simplelist>
      <member><literal>'08:00:2b:01:02:03'</></member>
      <member><literal>'08-00-2b-01-02-03'</></member>
      <member><literal>'08002b:010203'</></member>
      <member><literal>'08002b-010203'</></member>
      <member><literal>'0800.2b01.0203'</></member>
      <member><literal>'08002b010203'</></member>
     </simplelist>

     这些例子指定的都是同一个地址。对于位<literal>a</>到<literal>f</>，大小写都可以接受。输出总是使用展示的第一种形式。    </para>

    <para>
     IEEE Std 802-2001 指定第二种展示的形式（带有连字符）作为MAC地址的标准形式，并且指定第一种形式（带有分号）作为位翻转的记号，因此 08-00-2b-01-02-03 = 01:00:4D:08:04:0C。这种习惯目前已经被广泛地忽略，并且它只与废弃的网络协议（如令牌环）相关。PostgreSQL 没有对位翻转做任何规定，并且所有可接受的格式都使用标准的LSB顺序。
    </para>

    <para>
     剩下的五种输入格式不属于任何标准。
    </para>
   </sect2>

  </sect1>

  <sect1 id="datatype-bit">
   <title>位串类型</title>

   <indexterm zone="datatype-bit">
    <primary>位串</primary>
    <secondary>数据类型</secondary>
   </indexterm>

   <para>
    位串就是一串 1 和 0 的串。它们可以用于存储和可视化位掩码。我们有两种类型的 SQL 位类型：<type>bit(<replaceable>n</replaceable>)</type>和<type>bit varying(<replaceable>n</replaceable>)</type>，其中 <replaceable>n</replaceable>是一个正整数。
   </para>

   <para>
    <type>bit</type>类型的数据必须准确匹配长度<replaceable>n</replaceable>; 试图存储短些或者长一些的位串都是错误的。<type>bit varying</type>数据是最长<replaceable>n</replaceable>的变长类型，更长的串会被拒绝。写一个没有长度的<type>bit</type>等效于 <literal>bit(1)</literal>，没有长度的<type>bit varying</type>意味着没有长度限制。
   </para>

   <note>
    <para>
     如果我们显式地把一个位串值转换成<type>bit(<replaceable>n</>)</type>， 那么它的右边将被截断或者在右边补齐零，直到刚好<replaceable>n</>位， 而且不会抛出任何错误。类似地，如果我们显式地把一个位串数值转换成<type>bit varying(<replaceable>n</>)</type>，如果它超过了<replaceable>n</>位， 那么它的右边将被截断。
    </para>
   </note>

   <para>
    请参考<xref linkend="sql-syntax-bit-strings">获取有关位串常量的语法的信息。还有一些位逻辑操作符和串操作函数可用，请见<xref linkend="functions-bitstring">。
   </para>

   <example>
    <title>使用位串类型</title>

<programlisting>
CREATE TABLE test (a BIT(3), b BIT VARYING(5));
INSERT INTO test VALUES (B'101', B'00');
INSERT INTO test VALUES (B'10', B'101');
<computeroutput>
ERROR:  bit string length 2 does not match type bit(3)
</computeroutput>
INSERT INTO test VALUES (B'10'::bit(3), B'101');
SELECT * FROM test;
<computeroutput>
  a  |  b
-----+-----
 101 | 00
 100 | 101
</computeroutput>
</programlisting>
   </example>

   <para>
    一个位串值对于每8位的组需要一个字节，外加总共5个或8个字节，这取决于串的长度（但是长值可能被压缩或者移到线外，如<xref linkend="datatype-character">中对字符串的解释一样）。
   </para>
  </sect1>

  <sect1 id="datatype-textsearch">
   <title>文本搜索类型</title>

   <indexterm zone="datatype-textsearch">
    <primary>全文搜索</primary>
    <secondary>数据类型</secondary>
   </indexterm>

   <indexterm zone="datatype-textsearch">
    <primary>文本搜索</primary>
    <secondary>数据类型</secondary>
   </indexterm>

   <para>
    <productname>PostgreSQL</productname>提供两种数据类型，它们被设计用来支持全文搜索，全文搜索是一种在自然语言的<firstterm>文档</>集合中搜索以定位那些最匹配一个<firstterm>查询</>的文档的活动。<type>tsvector</type>类型表示一个为文本搜索优化的形式下的文档，<type>tsquery</type>类型表示一个文本查询。<xref linkend="textsearch">提供了对于这种功能的详细解释，并且<xref linkend="functions-textsearch">总结了相关的函数和操作符。
   </para>

   <sect2 id="datatype-tsvector">
    <title><type>tsvector</type></title>

    <indexterm>
     <primary>tsvector（数据类型）</primary>
    </indexterm>

    <para>
     一个<type>tsvector</type>值是一个排序的可区分<firstterm>词位</>的列表，<firstterm>词位</>是被<firstterm>正规化</>合并了同一个词的不同变种的词（详见<xref linkend="textsearch">）。排序和去重是在输入期间自动完成的，如下例所示：

<programlisting>
SELECT 'a fat cat sat on a mat and ate a fat rat'::tsvector;
                      tsvector
----------------------------------------------------
 'a' 'and' 'ate' 'cat' 'fat' 'mat' 'on' 'rat' 'sat'
</programlisting>

     要表示包含空白或标点的词位，将它们用引号包围：

<programlisting>
SELECT $$the lexeme '    ' contains spaces$$::tsvector;
                 tsvector
-------------------------------------------
 '    ' 'contains' 'lexeme' 'spaces' 'the'
</programlisting>

     （我们在这个例子中使用美元符号包围的串文字并且下一个用来避免在文字中包含双引号记号产生的混淆）。嵌入的引号和反斜线必须被双写：

<programlisting>
SELECT $$the lexeme 'Joe''s' contains a quote$$::tsvector;
                    tsvector
------------------------------------------------
 'Joe''s' 'a' 'contains' 'lexeme' 'quote' 'the'
</programlisting>

     可选的，整数<firstterm>位置</>可以被附加给词位：

<programlisting>
SELECT 'a:1 fat:2 cat:3 sat:4 on:5 a:6 mat:7 and:8 ate:9 a:10 fat:11 rat:12'::tsvector;
                                  tsvector
-------------------------------------------------------------------------------
 'a':1,6,10 'and':8 'ate':9 'cat':3 'fat':2,11 'mat':7 'on':5 'rat':12 'sat':4
</programlisting>

     一个位置通常表示源词在文档中的定位。位置信息可以被用于<firstterm>邻近排名</firstterm>。位置值可以从 1 到 16383，更大的数字会被 16383。对于相同的词位出现的重复位置将被丢弃。
    </para>

    <para>
     具有位置的词位可以进一步地被标注一个<firstterm>权重</>，它可以是<literal>A</literal>、
     <literal>B</literal>、<literal>C</literal>或<literal>D</literal>。
     <literal>D</literal>是默认值并且因此在输出中不会显示：

<programlisting>
SELECT 'a:1A fat:2B,4C cat:5D'::tsvector;
          tsvector
----------------------------
 'a':1A 'cat':5 'fat':2B,4C
</programlisting>

     权重通常被用来反映文档结构，例如将主题词标记成与正文词不同。文本搜索排名函数可以为不同的权重标记器分配不同的优先级。
    </para>

    <para>
     了解<type>tsvector</type>类型本身并不执行任何正规化这一点很重要，它假定给它的词已经被恰当地为应用正规化过。例如，

<programlisting>
select 'The Fat Rats'::tsvector;
      tsvector
--------------------
 'Fat' 'Rats' 'The'
</programlisting>

     对于大部分英语文本搜索应用，上面的词将会被认为是非正规化的，但是<type>tsvector</type>并不在乎这一点。原始文档文本通常应该经过<function>to_tsvector</>以恰当地为搜索正规化其中的词：

<programlisting>
SELECT to_tsvector('english', 'The Fat Rats');
   to_tsvector
-----------------
 'fat':2 'rat':3
</programlisting>

     再次地，详情请参阅<xref linkend="textsearch">。
    </para>

   </sect2>

   <sect2 id="datatype-tsquery">
    <title><type>tsquery</type></title>

    <indexterm>
     <primary>tsquery（数据类型）</primary>
    </indexterm>

    <para>
     一个<type>tsquery</type>值存储要用于搜索的词位，并且使用布尔操作符<literal>&amp;</literal>（AND）、<literal>|</literal>（OR）和<literal>!</>（NOT）来组合它们。圆括号可以被用来强制对操作符分组：

<programlisting>
SELECT 'fat &amp; rat'::tsquery;
    tsquery
---------------
 'fat' &amp; 'rat'

SELECT 'fat &amp; (rat | cat)'::tsquery;
          tsquery
---------------------------
 'fat' &amp; ( 'rat' | 'cat' )

SELECT 'fat &amp; rat &amp; ! cat'::tsquery;
        tsquery
------------------------
 'fat' &amp; 'rat' &amp; !'cat'
</programlisting>

     如果没有圆括号，则<literal>!</>（NOT）优先级最高，<literal>&amp;</literal>（AND）次之，<literal>|</literal>（OR）最低。
    </para>

    <para>
     可选地，一个<type>tsquery</type>中的词位可以被标注一个或多个权重字母，这将限制它们只能和具有匹配权重的<type>tsvector</>词位相匹配：

<programlisting>
SELECT 'fat:ab &amp; cat'::tsquery;
    tsquery
------------------
 'fat':AB &amp; 'cat'
</programlisting>
    </para>

    <para>
     此外，一个<type>tsquery</type>中的词位可以被标注为<literal>*</>来指定前缀匹配：
<programlisting>
SELECT 'super:*'::tsquery;
  tsquery
-----------
 'super':*
</programlisting>
     这个查询将匹配一个<type>tsvector</type>中以<quote>super</>开头的任意词。注意前缀首先会被文本搜索配置所处理，它意味着这个比较返回真值：
<programlisting>
SELECT to_tsvector( 'postgraduate' ) @@ to_tsquery( 'postgres:*' );
 ?column?
----------
 t
(1 row)
</programlisting>
     因为<literal>postgres</>起源于<literal>postgr</>：
<programlisting>
SELECT to_tsquery('postgres:*');
 to_tsquery
------------
 'postgr':*
(1 row)
</programlisting>
     则匹配<literal>postgraduate</>。
    </para>

    <para>
     词位的引号规则和之前描述的<type>tsvector</>中的词位相同；并且，正如<type>tsvector</>，任何请求的词正规化必须在转换到<type>tsquery</>类型之前完成。<function>to_tsquery</>函数可以方便地执行这种正规化：

<programlisting>
SELECT to_tsquery('Fat:ab &amp; Cats');
    to_tsquery
------------------
 'fat':AB &amp; 'cat'
</programlisting>
    </para>

   </sect2>

  </sect1>

  <sect1 id="datatype-uuid">
   <title><acronym>UUID</acronym>类型</title>

   <indexterm zone="datatype-uuid">
    <primary>UUID</primary>
   </indexterm>

   <para>
    数据类型<type>uuid</type>存储由RFC 4122、ISO/IEC 9834-8:2005以及相关标准定义的通用唯一标识符（UUID）（某些系统将这种数据类型引用为全局唯一标识符GUID<indexterm><primary>GUID</primary></indexterm>）。这种标识符是一个128位的量，它由一个精心选择的算法产生，该算法能保证在已知空间中任何其他使用相同算法的人能够产生同一个标识符的可能性非常非常小。因此，对于分布式系统，这些标识符相比序列生成器而言提供了一种很好的唯一性保障，序列生成器只能在一个数据库中保证唯一。
   </para>

   <para>
    一个UUID被写成一个小写十六进制位的序列，该序列被连字符分隔成多个组：首先是一个8位组，接下来是三个4位组，最后是一个12位组。总共的32位（十六进制位）表示了128个二进制位。一个标准形式的UUID类似于：
<programlisting>
a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11
</programlisting>
    <productname>PostgreSQL</productname>也接受另一种输入形式：
    使用大写位、标准格式被花括号包围、忽略某些或者全部连字符、在任意4位组后面增加一个连字符。例如：
<programlisting>
A0EEBC99-9C0B-4EF8-BB6D-6BB9BD380A11
{a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11}
a0eebc999c0b4ef8bb6d6bb9bd380a11
a0ee-bc99-9c0b-4ef8-bb6d-6bb9-bd38-0a11
{a0eebc99-9c0b4ef8-bb6d6bb9-bd380a11}
</programlisting>
    输出总是采用标准形式。
   </para>

   <para>
    <productname>PostgreSQL</productname>为UUID提供了存储和比较函数，但是核心数据库不包含任何用于产生UUID的函数，因为没有一个单一算法能够很好地适应每一个应用。<xref linkend="uuid-ossp">模块提供了实现一些标准算法的函数。
    <xref linkend="pgcrypto">模块也为随机 UUID 提供了一个生成函数。
    此外，UUID可以由客户端应用产生，或者由通过服务器端函数调用的其他库生成。
   </para>
  </sect1>

  <sect1 id="datatype-xml">
   <title><acronym>XML</>类型</title>

   <indexterm zone="datatype-xml">
    <primary>XML</primary>
   </indexterm>

   <para>
    <type>xml</type>数据类型可以被用来存储XML数据。它比直接在一个<type>text</type>域中存储XML数据的优势在于，它会检查输入值的结构是不是良好，并且有支持函数用于在其上执行类型安全的操作，参见<xref linkend="functions-xml">。使用这种数据类型要求在安装时用<command>configure --with-libxml</>选项编译。
   </para>

   <para>
    <type>xml</type>类型可以存储结构良好（如XML标准所定义）的<quote>文档</quote>，以及<quote>内容</quote>片段，它们由XML标准中的<literal>XMLDecl? content</literal>产品所定义。粗略地看，这意味着内容片段中可以有多于一个的顶层元素或字符节点。表达式<literal><replaceable>xmlvalue</replaceable> IS DOCUMENT</literal>可以被用来评估一个特定的<type>xml</type>值是一个完整文档或者仅仅是一个文档片段。
   </para>

   <sect2>
    <title>创建XML值</title>
   <para>
    要从字符数据中生成一个<type>xml</type>类型的值，可以使用函数<function>xmlparse</function>:<indexterm><primary>xmlparse</primary></indexterm>
<synopsis>
XMLPARSE ( { DOCUMENT | CONTENT } <replaceable>value</replaceable>)
</synopsis>
    例子：
<programlisting><![CDATA[
XMLPARSE (DOCUMENT '<?xml version="1.0"?><book><title>Manual</title><chapter>...</chapter></book>')
XMLPARSE (CONTENT 'abc<foo>bar</foo><bar>foo</bar>')
]]></programlisting>
    然而根据SQL标准这是唯一将字符串转换为XML值的方法，PostgreSQL特有的语法：
<programlisting><![CDATA[
xml '<foo>bar</foo>'
'<foo>bar</foo>'::xml
]]></programlisting>
    也可以被使用。
   </para>

   <para>
    即便输入值指定了一个文档类型声明（DTD），<type>xml</type>类型也不根据DTD来验证输入值<indexterm><primary>DTD</primary></indexterm>。目前也没有内建的支持用于根据其他XML模式语言（如XML模式）来进行验证。
   </para>

   <para>
    作为一个逆操作，从<type>xml</type>产生一个字符串可以使用函数<function>xmlserialize</function>:<indexterm><primary>xmlserialize</primary></indexterm>
<synopsis>
XMLSERIALIZE ( { DOCUMENT | CONTENT } <replaceable>value</replaceable> AS <replaceable>type</replaceable> )
</synopsis>
    <replaceable>type</replaceable>可以是
    <type>character</type>、<type>character varying</type>或
    <type>text</type>（或者其中之一的一个别名）。再次地，根据SQL标准，这也是在<type>xml</type>类型和字符类型间做转换的唯一方法，但是PostgreSQL也允许你简单地造型这些值。
   </para>

   <para>
    当一个字符串不是使用<type>XMLPARSE</type>造型成<type>xml</type>或者不是使用<type>XMLSERIALIZE</type>从<type>xml</type>造型得到，对于<literal>DOCUMENT</literal>和<literal>CONTENT</literal>两者的选择是根据<quote>XML option</quote>
    <indexterm><primary>XML option</primary></indexterm>会话配置参数决定的，它可以使用标准命令来设置：
<synopsis>
SET XML OPTION { DOCUMENT | CONTENT };
</synopsis>
    或者是更具有PostgreSQL风格的语法
<synopsis>
SET xmloption TO { DOCUMENT | CONTENT };
</synopsis>
    默认值是<literal>CONTENT</literal>，因此所有形式的XML数据都被允许。
   </para>

   <note>
    <para>
     在使用默认XML option设置时，如果字符串包含一个文档类型声明，你就不能直接将字符串造型成类型<type>xml</type>，因为XML内容片断的定义不接受它们。如果你需要这样做，要么使用<literal>XMLPARSE</literal>，要么修改XML option。
    </para>
   </note>

   </sect2>

   <sect2>
    <title>编码处理</title>
   <para>
    在客户端、服务器以及其中流过的XML数据上处理多字符编码时必须要注意。在使用文本模式向服务器传递查询以及向客户端传递查询结果（在普通模式）时，PostgreSQL将所有在客户端和服务器之间传递的字符数据转换为目标端的字符编码，参见<xref linkend="multibyte">。这也包括了表示XML值的串，正如上面的例子所述。这也通常意味着由于字符数据会在客户端和服务器之间传递时被转换成其他编码，包含在XML数据中的编码声明可能是无效的，因为内嵌的编码声明没有被改变。为了处理这种行为，包含在表示<type>xml</type>类型输入的字符串中包含的编码声明会被<emphasis>忽略</emphasis>，并且其内容被假定为当前服务器的编码。接着，为了正确处理，XML数据的字符串必须以当前客户端编码从客户端发出。客户端负责在把文档发送给服务器之前将它们转换为当前客户端编码，或者适当地调整客户端编码。在输出时，<type>xml</type>类型的值将不会有一个编码声明，并且客户端将会假设所有数据都是当前客户端编码。
   </para>

   <para>
    在使用二进制模式传送查询参数给服务器以及传回查询结果给客户端时，不会执行字符集转换，因此情况就有所不同。在这种情况下，XML数据中的编码声明将被注意到，并且如果缺少编码声明时该数据会被假定为UTF-8（由于XML标准的要求，注意PostgreSQL不支持UTF-16）。在输出时，数据将会有一个编码声明来指定客户端编码，除非客户端编码为UTF-8（这种情况下编码声明会被忽略）。
   </para>

   <para>
    不用说，在PostgreSQL中处理XML数据产生错误的可能性更小，并且在XML数据编码、客户端编码和服务器编码三者相同时效率更高。因为XML数据在内部是以UTF-8处理的，如果服务器编码也是UTF-8时，计算效率将会最高。
   </para>

   <caution>
    <para>
     当服务器编码不是UTF-8时，某些XML相关的函数可能在非ASCII数据上完全无法工作。尤其在<function>xpath()</>上，这是一个已知的问题。
    </para>
   </caution>
   </sect2>

   <sect2>
   <title>访问XML值</title>

   <para>
    <type>xml</type>数据类型有些不同寻常，因为它不提供任何比较操作符。这是因为对于XML数据不存在良定义的和通用的比较算法。这种状况造成的后果就是，你无法通过比较一个<type>xml</type>和一个搜索值来检索行。XML值因此通常应该伴随着一个独立键值域，如一个ID。另一种比较XML值的方案是将它们先转换为字符串，但注意字符串比较对于XML比较方法没有什么帮助。
   </para>

   <para>
    由于没有可以用于<type>xml</type>数据类型的比较操作符，因此无法直接在这种类型上创建索引。如果需要在XML中快速的搜索，可能的解决方案包括将表达式造型为一个字符串类型然后索引之，或者在一个XPath表达式上索引。当然，实际的查询必须被调整为使用被索引的表达式。
   </para>

   <para>
    PostgreSQL中的文本搜索功能也可以被用来加速XML数据的全文搜索。但是，所需的预处理支持目前在PostgreSQL发布中还不可用。
   </para>
   </sect2>
  </sect1>

  &json;

  &array;

  &rowtypes;

  &rangetypes;

  <sect1 id="datatype-oid">
   <title>对象标识符类型</title>

   <indexterm zone="datatype-oid">
    <primary>对象标识符</primary>
    <secondary>数据类型</secondary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>oid</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regproc</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regprocedure</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regoper</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regoperator</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regclass</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regtype</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regconfig</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regdictionary</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>xid</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>cid</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>tid</primary>
   </indexterm>

   <para>
    对象标识符（OID）被<productname>PostgreSQL</productname>用来在内部作为多个系统表的主键。OID不会被添加到用户创建的表中，除非在创建表时指定了<literal>WITH OIDS</literal>或者<xref linkend="guc-default-with-oids">配置变量被启用。类型<type>oid</>表示一个对象标识符。也有多个<type>oid</>的别名类型：<type>regproc</>、<type>regprocedure</>、<type>regoper</>、<type>regoperator</>、<type>regclass</>、<type>regtype</>，<type>regrole</>，<type>regnamespace</>，
    <type>regconfig</>和<type>regdictionary</>。<xref linkend="datatype-oid-table">显示了一个概览。
   </para>

   <para>
    <type>oid</>类型目前被实现为一个无符号4字节整数。因此，在大型数据库中它并不足以提供数据库范围内的唯一性，甚至在一些大型的表中也无法提供表范围内的唯一性。于是，我们不鼓励使用一个用户定义表的OID列作为主键。OID最好只被用于引用系统表。
   </para>

   <para>
    <type>oid</>类型本身除了比较之外只有很少的操作。不过，它可以被造型成整数，并且接着可以使用标准的整数操作符进行操纵（这样做时要注意有符号和无符号之间可能出现的混乱）。
   </para>

   <para>
    OID的别名类型除了特定的输入和输出例程之外没有别的操作。这些例程可以接受并显示系统对象的符号名，而不是类型<type>oid</>使用的原始数字值。别名类型使查找对象的OID值变得简单。例如，要检查与一个表<literal>mytable</>有关的<structname>pg_attribute</>行，你可以写：
<programlisting>
SELECT * FROM pg_attribute WHERE attrelid = 'mytable'::regclass;
</programlisting>
    而不是：
<programlisting>
SELECT * FROM pg_attribute
  WHERE attrelid = (SELECT oid FROM pg_class WHERE relname = 'mytable');
</programlisting>
    虽然从它本身看起来并没有那么糟，它仍然被过度简化了。如果有多个名为<literal>mytable</>的表存在于不同的模式中，就可能需要一个更复杂的子选择来选择右边的OID。<type>regclass</>输入转换器会根据模式路径设置处理表查找，并且因此它会自动地完成这种<quote>右边的事情</>。类似地，对于一个数字OID的符号化显示可以很方便地通过将表OID造型成<type>regclass</>来实现。
   </para>

    <table id="datatype-oid-table">
     <title>对象标识符类型</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>名字</entry>
        <entry>引用</entry>
        <entry>描述</entry>
        <entry>值示例</entry>
       </row>
      </thead>

      <tbody>

       <row>
        <entry><type>oid</></entry>
        <entry>任意</entry>
        <entry>数字形式的对象标识符</entry>
        <entry><literal>564182</></entry>
       </row>

       <row>
        <entry><type>regproc</></entry>
        <entry><structname>pg_proc</></entry>
        <entry>函数名字</entry>
        <entry><literal>sum</></entry>
       </row>

       <row>
        <entry><type>regprocedure</></entry>
        <entry><structname>pg_proc</></entry>
        <entry>带参数类型的函数</entry>
        <entry><literal>sum(int4)</></entry>
       </row>

       <row>
        <entry><type>regoper</></entry>
        <entry><structname>pg_operator</></entry>
        <entry>操作符名字</entry>
        <entry><literal>+</></entry>
       </row>

       <row>
        <entry><type>regoperator</></entry>
        <entry><structname>pg_operator</></entry>
        <entry>带参数类型的操作符</entry>
        <entry><literal>*(integer,integer)</> or <literal>-(NONE,integer)</></entry>
       </row>

       <row>
        <entry><type>regclass</></entry>
        <entry><structname>pg_class</></entry>
        <entry>关系名字</entry>
        <entry><literal>pg_type</></entry>
       </row>

       <row>
        <entry><type>regtype</></entry>
        <entry><structname>pg_type</></entry>
        <entry>数据类型名字</entry>
        <entry><literal>integer</></entry>
       </row>

       <row>
        <entry><type>regrole</></entry>
        <entry><structname>pg_authid</></entry>
        <entry>角色名</entry>
        <entry><literal>smithee</></entry>
       </row>

       <row>
        <entry><type>regnamespace</></entry>
        <entry><structname>pg_namespace</></entry>
        <entry>表空间名称</entry>
        <entry><literal>pg_catalog</></entry>
       </row>
       
       <row>
        <entry><type>regconfig</></entry>
        <entry><structname>pg_ts_config</></entry>
        <entry>文本搜索配置</entry>
        <entry><literal>english</></entry>
       </row>

       <row>
        <entry><type>regdictionary</></entry>
        <entry><structname>pg_ts_dict</></entry>
        <entry>文本搜索字典</entry>
        <entry><literal>simple</></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    所有的通过表空间分组对象的OID别名类型都接受模式限定的名字，如果没有被限定的对象在当前搜索路径中无法找到时，将会在输出时显示模式限定的名字。<type>regproc</>和<type>regoper</>别名类型将只接受唯一的（非重载的）输入名字，因此它们的使用是受限的；对于大多数使用，<type>regprocedure</>或<type>regoperator</>更合适。对于<type>regoperator</>，通过使用<literal>NONE</>来替代未使用的操作数可以标识一元操作符。
   </para>

   <para>
    OID别名类型的一个附加性质是依赖性的创建。如果这些类型之一的一个常量出现在一个存储的表达式（如一个列默认值表达式或视图）中，它会在被引用的对象上创建一个依赖。例如，如果一个列有一个默认值表达式<literal>nextval('my_seq'::regclass)</>，<productname>PostgreSQL</productname>会理解该默认值表达式是依赖于序列<literal>my_seq</>的，在删除该默认值表达式之前系统将不允许删除该序列。
    <type>regrole</>是唯一例外的属性。这种类型的常量不允许这种表达式。
   </para>

   <note>
   <para>
    OID别名类型不完全遵循事务隔离规则。规划器也将它们视为简单的常数，这可能优化规划结果。
   </para>
   </note>
   
   <para>
    另一种系统中使用的标识符类型是<type>xid</>，或者称为事务（简写为<abbrev>xact</>）标识符。这是系统列<structfield>xmin</>和<structfield>xmax</>使用的数据类型。事务标识符是32位量。
   </para>

   <para>
    系统使用的第三种标识符类型是<type>cid</>，或者称为命令标识符。这是系统列<structfield>cmin</>和<structfield>cmax</>使用的数据类型。命令标识符也是32位量。
   </para>

   <para>
    系统使用的最后一种标识符类型是<type>tid</>，或者称为元组标识符（行标识符）。这是系统列<structfield>ctid</>使用的数据类型。一个元组ID是一个（块号，块内元组索引）对，它标识了行在它的表中的物理位置。
   </para>

   <para>
    （这些系统列在<xref linkend="ddl-system-columns">中有进一步的解释）。
   </para>
  </sect1>

  <sect1 id="datatype-pg-lsn">
   <title><acronym>pg_lsn Type</acronym></title>

   <indexterm zone="datatype-pg-lsn">
    <primary>pg_lsn</primary>
   </indexterm>

   <para>
    <type>pg_lsn</type>数据类型可以被用来存储 LSN（日志序列号）数据，LSN 是一个指向
    XLOG 中的位置的指针。这个类型是<type>XLogRecPtr</type>的一种表达并且是
    <productname>PostgreSQL</productname>的一种内部系统类型。
   </para>

   <para>
    在内部，一个 LSN 是一个 64 位整数，表示在预写式日志流中的一个字节位置。它被打印成
    两个最高 8 位的十六进制数，中间用斜线分隔，例如<literal>16/B374D848</>。
    <type>pg_lsn</type>类型支持标准的比较操作符，如<literal>=</literal>和
    <literal>&gt;</literal>。两个 LSN 可以用<literal>-</literal>操作符做减法，
    结果将是分隔两个预写式日志位置的字节数。
   </para>
  </sect1>

  <sect1 id="datatype-pseudo">
   <title>伪类型</title>

   <indexterm zone="datatype-pseudo">
    <primary>record</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>any</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anyelement</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anyarray</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anynonarray</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anyenum</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anyrange</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>void</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>trigger</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
   <primary>event_trigger</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>pg_ddl_command</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo"> 
    <primary>language_handler</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>fdw_handler</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
   <primary>tsm_handler</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>cstring</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>internal</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>opaque</primary>
   </indexterm>

   <para>
    <productname>PostgreSQL</productname>类型系统包含了一些特殊目的的项，它们被统称为<firstterm>伪类型</>。一个伪类型不能被用作一个列的数据类型，但是它可以被用来定义一个函数的参数或者结果类型。每一种可用的伪类型都有其可以发挥作用的情况，这些情况的特点是一个函数的行为并不能符合于简单使用或者返回一种特定<acronym>SQL</acronym>数据类型的值。<xref linkend="datatype-pseudotypes-table">列出了现有的伪类型。
   </para>

    <table id="datatype-pseudotypes-table">
     <title>伪类型</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>名字</entry>
        <entry>描述</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><type>any</></entry>
        <entry>表示一个函数可以接受任意输入数据类型。</entry>
       </row>

       <row>
        <entry><type>anyelement</></entry>
        <entry>表示一个函数可以接受任意数据类型（参见<xref linkend="extend-types-polymorphic">）。</entry>
       </row>

       <row>
        <entry><type>anyarray</></entry>
        <entry>表示一个函数可以接受任意数组数据类型（参见<xref linkend="extend-types-polymorphic">）</entry>
       </row>

       <row>
        <entry><type>anynonarray</></entry>
        <entry>表示一个函数可以接受任意非数组数据类型（参见<xref linkend="extend-types-polymorphic">）。</entry>
       </row>

       <row>
        <entry><type>anyenum</></entry>
        <entry>表示一个函数可以接受任意枚举数据类型（参见<xref linkend="extend-types-polymorphic">和<xref linkend="datatype-enum">）。</entry>
       </row>

       <row>
        <entry><type>anyrange</></entry>
        <entry>表示一个函数可以接受任意范围数据类型（参见<xref linkend="extend-types-polymorphic">和<xref linkend="rangetypes">）。</entry>
       </row>

       <row>
        <entry><type>cstring</></entry>
        <entry>表示一个函数接受或者返回一个非空结尾的C字符串。</entry>
       </row>

       <row>
        <entry><type>internal</></entry>
        <entry>表示一个函数接受或返回一个服务器内部数据类型。</entry>
       </row>

       <row>
        <entry><type>language_handler</></entry>
        <entry>一个被声明为返回<type>language_handler</>的过程语言调用处理器。</entry>
       </row>

       <row>
        <entry><type>fdw_handler</></entry>
        <entry>一个被声明为返回<type>fdw_handler</>的外部数据包装器处理器。</entry>
       </row>
       
       <row>
        <entry><type>tsm_handler</></entry>
        <entry>声明tablesample方法处理程序返回<type>tsm_handler</>。</entry>
       </row>
       
       <row>
        <entry><type>record</></entry>
        <entry>标识一个函数抓取或者返回一个未指定的行类型。</entry>
       </row>

       <row>
        <entry><type>trigger</></entry>
        <entry>一个被声明为返回<type>trigger</>的触发器函数。</entry>
       </row>

       <row>
        <entry><type>event_trigger</></entry>
        <entry>声明事件触发函数返回<type>event_trigger。</></entry>
       </row>

       <row>
        <entry><type>pg_ddl_command</></entry>
        <entry>确定用于事件触发器的DDL命令表示形式。</entry>
       </row>
       
       <row>
        <entry><type>void</></entry>
        <entry>表示一个函数不返回值。</entry>
       </row> 

       <row>
        <entry><type>opaque</></entry>
        <entry>一种已被废弃的类型名称，以前它用于实现所有以上的目的。</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    用C编写的函数（不管是内建的还是动态载入的）可以被声明为接受或返回这些为数据类型的任意一种。函数的作者应当保证当一个伪类型被用作一个参数类型时函数的行为是安全的。
   </para>

   <para>
    用过程语言编写的函数只有在其实现语言允许的情况下才能使用伪类型。目前所有的过程语言都禁止使用伪类型作为参数类型，并且只允许使用<type>void</>和<type>record</>作为结果类型（如果函数被用于一个触发器或者事件触发器， <type>trigger</>或者<type>event_trigger</>也被允许作为结果类型）。某些过程语言也支持在多态函数中使用类型<type>anyelement</>、<type>anyarray</>、<type>anynonarray</>、<type>anyenum</>和<type>anyrange</>。
   </para>

   <para>
    <type>internal</>伪类型用于定义只在数据库系统内部调用的函数，这些函数不会被<acronym>SQL</acronym>直接调用。如果一个函数拥有至少一个<type>internal</>类型的参数，则它不能从<acronym>SQL</acronym>中被调用。为了保持这种限制的类型安全性，遵循以下编码规则非常重要：不要创建任何被声明要返回<type>internal</>的函数，除非它有至少一个<type>internal</>参数。
   </para>

  </sect1>

 </chapter>
