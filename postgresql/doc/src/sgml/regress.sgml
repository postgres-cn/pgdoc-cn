<!-- doc/src/sgml/regress.sgml -->

 <chapter id="regress">
  <!-- 
  <title>Regression Tests</title> 
  -->
  <title>回归测试</title>

  <indexterm zone="regress">
   <!-- 
   <primary>regression tests</primary> 
   -->
   <primary>回归测试</primary>
  </indexterm>

  <indexterm zone="regress">
   <!-- 
   <primary>test</primary> 
   -->
   <primary>测试</primary>
  </indexterm>

  <!--
<para>
   The regression tests are a comprehensive set of tests for the SQL
   implementation in <productname>PostgreSQL</productname>.  They test
   standard SQL operations as well as the extended capabilities of
   <productname>PostgreSQL</productname>.
  </para>
-->
<para>
回归测试是一套复杂完整的测试，用来测试嵌入在<productname>PostgreSQL</productname>
里的 SQL 实现。它同时测试标准 SQL 操作和<productname>PostgreSQL</productname>的扩展 SQL 。
</para>

  <sect1 id="regress-run">
   <!-- 
   <title>Running the Tests</title> 
   -->
   <title>运行测试</title>

  <!--
<para>
   The regression tests can be run against an already installed and
   running server, or using a temporary installation within the build
   tree.  Furthermore, there is a <quote>parallel</quote> and a
   <quote>sequential</quote> mode for running the tests.  The
   sequential method runs each test script alone, while the
   parallel method starts up multiple server processes to run groups
   of tests in parallel.  Parallel testing adds confidence that
   interprocess communication and locking are working correctly.
  </para>
-->
<para>
回归测试可以对一套已经安装好并且在运行中的服务器进行测试，
也可以对编译树里面即将安装的服务器进行测试。详细些说，有<quote>并行</quote>
和<quote>串行</quote>运行测试之分。串行模式顺序运行每个测试，而并行模式启动多个服务器进程，
并发地运行一组测试。并发测试增加了我们对进程内部通讯和锁的正确工作的信心。
</para>

  <sect2>
   <!-- 
   <title>Running the Tests Against a Temporary Installation</title> 
   -->
   <title>对临时安装运行测试</title>

  
<para>
<!-- 
  To run the parallel regression tests after building but before installation,
   type:
-->
编译之后和安装之前运行回归测试，你可以在顶级目录运行(或者进入
<filename>src/test/regress</filename>子目录然后在那里运行)：
<screen>
make check
</screen>
<!-- 
   in the top-level directory.  (Or you can change to
   <filename>src/test/regress</filename> and run the command there.)
   At the end you should see something like: 
-->
最后你会看到类似下面的东西：
<screen>
<computeroutput>
=======================
 All 115 tests passed.
=======================
</computeroutput>
</screen>
<!-- 
   or otherwise a note about which tests failed.  See <xref
   linkend="regress-evaluation"> below before assuming that a
   <quote>failure</> represents a serious problem. 
-->
或者是一些关于某项测试失败的信息。先看看<xref linkend="regress-evaluation">
然后再想想一个<quote>失败</>是否代表严重的错误。
  </para>
   
<para>
<!--
    Because this test method runs a temporary server, it will not work
    if you did the build as the root user, since the server will not start as
    root.  Recommended procedure is not to do the build as root, or else to
    perform testing after completing the installation.
-->
因为这个测试方法运行临时的服务器，所以如果你作为 root 用户编译，
那这个方法不能运行，因为服务器不是以 root 身份启动的。
建议的过程是不要作为root编译，或者在完成安装之后执行测试。
   </para>

   <!--
<para>
    If you have configured <productname>PostgreSQL</productname> to install
    into a location where an older <productname>PostgreSQL</productname>
    installation already exists, and you perform <literal>make check</>
    before installing the new version, you might find that the tests fail
    because the new programs try to use the already-installed shared
    libraries.  (Typical symptoms are complaints about undefined symbols.)
    If you wish to run the tests before overwriting the old installation,
    you'll need to build with <literal>configure &#045;-disable-rpath</>.
    It is not recommended that you use this option for the final installation,
    however.
   </para>
-->
<para>
如果你配置<productname>PostgreSQL</productname>安装到一个原来安装有老版本
<productname>PostgreSQL</productname>的目录里，然后在安装新版本之前执行<literal>make check</>，
那么你可能发现测试失败，因为新程序试图使用已经存在的共享库，典型的症状是抱怨未定义的符号。
如果你想在覆盖老版本之前运行测试，那么你需要使用<literal>configure --disable-rpath</>进行编译。
不过，我们不建议你使用这个选项编译作为最终安装的数据库。
</para>
   
<para>
<!--
    The parallel regression test starts quite a few processes under your
    user ID.  Presently, the maximum concurrency is twenty parallel test
    scripts, which means forty processes: there's a server process and a
    <application>psql</> process for each test script.
    So if your system enforces a per-user limit on the number of processes,
    make sure this limit is at least fifty or so, else you might get
    random-seeming failures in the parallel test.  If you are not in
    a position to raise the limit, you can cut down the degree of parallelism
    by setting the <literal>MAX_CONNECTIONS</> parameter.  For example:
-->
并发的回归测试会在你的用户 ID 下启动相当多的进程。目前，最大的并发数是 20 个并发测试脚本，
这意味着 40 个进程：一个服务器进程、每个脚本一个<application>psql</>进程。因此，
如果你的系统有针对每个用户的进程数限制，那么请确保这个限制至少是 50 ，
否则你就可能在并发测试时看到随机出现的失败。如果你没有办法提升该限制，
那么可以通过设置<literal>MAX_CONNECTIONS</>参数降低并发测试程度。比如：
<screen>
make MAX_CONNECTIONS=10 check
</screen>
    <!-- 
runs no more than ten tests concurrently. 
-->
将运行最多不超过 10 个并发进程。
   </para>
  </sect2>

  <sect2>
   <!-- 
   <title>Running the Tests Against an Existing Installation</title> 
   -->
   <title>对现有安装运行测试</title>
  
<para>
<!--
   To run the tests after installation (see <xref linkend="installation">),
   initialize a data area and start the
   server as explained in <xref linkend="runtime">, then type:
-->
安装后(参见<xref linkend="installation">)运行测试，
像<xref linkend="runtime">
描述的那样初始化一个数据区并启动服务器，然后键入：
<screen>
make installcheck
</screen>
<!-- 
or for a parallel test: 
-->
或者是运行一个并发测试：
<screen>
make installcheck-parallel
</screen>
<!-- 
   The tests will expect to contact the server at the local host and the
   default port number, unless directed otherwise by <envar>PGHOST</envar> and
   <envar>PGPORT</envar> environment variables.  The tests will be run in a
   database named <literal>regression</>; any existing database by this name
   will be dropped.
   The tests will also transiently create some cluster-wide objects, such as
   user identities named <literal>regressuser<replaceable>N</></literal>.
-->
该测试将与在本地主机和缺省端口号上运行的服务器进行连接，除非你用<envar>PGHOST</envar>
和<envar>PGPORT</envar>环境变量设置为其它值。该测试将在一个名为
<literal>regression</>的数据库中运行；任何现有的以此命名的数据库都将被删除。
该测试暂时还将创建一些群集范围的对象，比如命名为
<literal>regressuser<replaceable>N</></literal>的用户身份。
  </para>
  </sect2>

  <sect2>
   <!-- 
   <title>Additional Test Suites</title> 
   -->
   <title>额外的测试套件</title>

<!-- 
  <para>
   The <literal>make check</> and <literal>make installcheck</> commands
   run only the <quote>core</> regression tests, which test built-in
   functionality of the <productname>PostgreSQL</> server.  The source
   distribution also contains additional test suites, most of them having
   to do with add-on functionality such as optional procedural languages.
  </para>
-->
<para>
<literal>make check</>和<literal>make installcheck</>
命令只运行<quote>核心</>回归测试，它测试<productname>PostgreSQL</>
服务器的内建功能。源代码分布也包含额外的测试套件，
它们中的大多数必须和附加功能比如可选的过程语言一起工作。
</para>
  
  
<para>
<!--
   To run all test suites applicable to the modules that have been selected
   to be built, including the core tests, type one of these commands at the
   top of the build tree:
-->
要在已经选择了要建立的模块上运行所有测试套件应用，包括内核测试，
在建立树的顶部输入下列命令之一：
<screen>
make check-world
make installcheck-world
</screen>
<!-- 
   These commands run the tests using temporary servers or an
   already-installed server, respectively, just as previously explained
   for <literal>make check</> and <literal>make installcheck</>.  Other
   considerations are the same as previously explained for each method.
   Note that <literal>make check-world</> builds a separate temporary
   installation tree for each tested module, so it requires a great deal
   more time and disk space than <literal>make installcheck-world</>. 
-->
这些命令分别使用临时服务器或者一个已经安装的服务器运行测试，
就像之前解释的<literal>make check</>和<literal>make installcheck</>。
其他注意事项和之前解释的每个方法相同。请注意，<literal>make check-world</>
为每个测试的模块建立一个单独的临时安装树，所以它比
<literal>make installcheck-world</>需要更多的时间和磁盘空间。
  </para>
  
<!-- 
  <para>
   Alternatively, you can run individual test suites by typing
   <literal>make check</> or <literal>make installcheck</> in the appropriate
   subdirectory of the build tree.  Keep in mind that <literal>make
   installcheck</> assumes you've installed the relevant module(s), not
   only the core server.
  </para>
--> 
  <para>
可选择的，你可以在建立树的适当子目录下输入<literal>make check</>或
<literal>make installcheck</>运行单独的测试套件。记住，
<literal>make installcheck</>假设你已经安装了相关的模块，
不只是内核服务器。
  </para>
  
<!-- 
  <para>
   The additional tests that can be invoked this way include:
  </para>
--> 
  <para>
可以通过这种方式调用的额外测试包括：
  </para> 
  
  <itemizedlist>
   <listitem>  
<!-- 
    <para>
     Regression tests for optional procedural languages (other than
     <application>PL/pgSQL</>, which is tested by the core tests).
     These are located under <filename>src/pl</>.
    </para>
-->
<para>
可选的过程语言的回归测试（除了<application>PL/pgSQL</>，
它是通过内核测试测试的）。它们位于<filename>src/pl</>。
</para>
   </listitem>
   <listitem>  
<!-- 
    <para>
     Regression tests for <filename>contrib</> modules,
     located under <filename>contrib</>.
     Not all <filename>contrib</> modules have tests.
    </para>
-->
<para>
<filename>contrib</>模块的回归测试，位于<filename>contrib</>下面。
并不是所有的<filename>contrib</>模块都要测试。
</para>
   </listitem>
   <listitem>  
<!-- 
     <para>
     Regression tests for the ECPG interface library,
     located in <filename>src/interfaces/ecpg/test</>.
   </para>
-->
<para>
ECPG接口库的回归测试，位于<filename>src/interfaces/ecpg/test</>。
</para>
   </listitem>
   <listitem> 
<!-- 
     <para>
     Tests stressing behavior of concurrent sessions,
     located in <filename>src/test/isolation</>.
    </para>
-->
<para>
测试并发会话的压力行为，位于<filename>src/test/isolation</>。
</para>
   </listitem>
   <listitem> 
<!-- 
    <para>
     Tests of client programs under <filename>src/bin</filename>.  See
     also <xref linkend="regress-tap">.
    </para>
-->
<para>
在<filename>src/bin</filename>下面测试客户端程序。又见
<xref linkend="regress-tap">。
</para>
   </listitem>
  </itemizedlist>
<!-- 
  <para>
   When using <literal>installcheck</> mode, these tests will destroy any
   existing databases named <literal>pl_regression</>,
   <literal>contrib_regression</>, <literal>isolationtest</>,
   <literal>regress1</>, or <literal>connectdb</>, as well as
   <literal>regression</>.
  </para>
-->
<para>
当使用<literal>installcheck</>模式时，这些测试将毁坏任何名为
<literal>pl_regression</>、<literal>contrib_regression</>、
<literal>isolationtest</>、<literal>regress1</>或<literal>connectdb</>，
还有<literal>regression</>的现有数据库，
</para>  
  </sect2>

  <sect2>
   <!-- 
   <title>Locale and Encoding</title> 
   -->
   <title>区域和编码</title>
   
<para>
<!--
    By default, tests using a temporary installation use the
    locale defined in the current environment and the corresponding
    database encoding as determined by <command>initdb</command>.  It
    can be useful to test different locales by setting the appropriate
    environment variables, for example:
-->
默认的，使用临时安装的测试使用在当前环境中定义的区域并且由<command>initdb</command>
决定相应的数据库编码。通过设置适当的环境变量来测试不同的区域是有用的，例如：
<screen>
make check LANG=C
make check LC_COLLATE=en_US.utf8 LC_CTYPE=fr_CA.utf8
</screen>
<!-- 
    For implementation reasons, setting <envar>LC_ALL</envar> does not
    work for this purpose; all the other locale-related environment
    variables do work. 
-->
由于实现原因，设置<envar>LC_ALL</envar>并不能为此工作；所有其他区域相关的环境变量可以。
   </para>

   <!--
<para>
    When testing against an existing installation, the locale is
    determined by the existing database cluster and cannot be set
    separately for the test run.
   </para>
-->
<para>
当对现有安装测试时，区域是由现有数据库集群决定的，并且不能单独为测试运行设置。
</para>
   
<para>
<!--
    You can also choose the database encoding explicitly by setting
    the variable <envar>ENCODING</envar>, for example:
-->
你也可以通过设置变量<envar>ENCODING</envar>明确的选择数据库编码，例如：
<screen>
make check LANG=C ENCODING=EUC_JP
</screen>
<!-- 
    Setting the database encoding this way typically only makes sense
    if the locale is C; otherwise the encoding is chosen automatically
    from the locale, and specifying an encoding that does not match
    the locale will result in an error. 
-->
用这种方式设置数据库编码通常只在区域是C的情况下有用；否则编码自动从区域中选择，
并且指定不匹配区域的编码将会导致错误。
   </para>

   <!--
<para>
    The database encoding can be set for tests against either a temporary or
    an existing installation, though in the latter case it must be
    compatible with the installation's locale.
   </para>
-->
<para>
可以为临时或现有安装测试设置数据库编码，尽管在后一种情况下它必须和安装的环境兼容。
</para>
  </sect2>

  <sect2>
   <!-- 
   <title>Extra Tests</title> 
   -->
   <title>额外的测试</title>
  
<para>
<!--
The core regression test suite contains a few test files that are not
    run by default, because they might be platform-dependent or take a
    very long time to run.  You can run these or other extra test
    files by setting the variable <envar>EXTRA_TESTS</envar>.  For
    example, to run the <literal>numeric_big</literal> test:
-->
内核回归测试包含的一些测试文件默认是不运行的，因为它们可能是依赖于平台的或运行需要很长的时间。
你可以通过设置变量<envar>EXTRA_TESTS</envar>运行它们或其他额外测试文件。
例如，运行<literal>numeric_big</literal>测试：
<screen>
make check EXTRA_TESTS=numeric_big
</screen>
    <!-- 
To run the collation tests: 
-->
运行排序测试：
<screen>
make check EXTRA_TESTS=collate.linux.utf8 LANG=en_US.utf8
</screen>
<!-- 
    The <literal>collate.linux.utf8</> test works only on Linux/glibc
    platforms, and only when run in a database that uses UTF-8 encoding. 
-->
<literal>collate.linux.utf8</>测试只在Linux/glibc平台工作，
并且只在数据库使用UTF-8编码时运行。
   </para>
  </sect2>
  <sect2>
   <!-- 
   <title>Testing Hot Standby</title>
   -->
   <title>测试热备份</title>

<!-- 
  <para>
   The source distribution also contains regression tests for the static
   behavior of Hot Standby. These tests require a running primary server
   and a running standby server that is accepting new WAL changes from the
   primary (using either file-based log shipping or streaming replication).
   Those servers are not automatically created for you, nor is replication
   setup documented here. Please check the various sections of the
   documentation devoted to the required commands and related issues.
  </para>
-->
<para>
源码分布也包含对热备份的静态行为的回归测试。
这些测试需要运行中的主服务器和运行中的备用服务器，
备用服务器接受来自主服务器的新WAL修改（使用基于文档的日志传送或流复制）。
这些服务器不是自动创建的，也不是这里记录的复制设置。
请查阅所需命令和相关问题的文档的各种章节。
</para>
  
  <para>
<!-- 
   To run the Hot Standby tests, first create a database
   called <literal>regression</> on the primary:
-->
要运行热备份测试，首先在主服务器上创建一个名为
<literal>regression</>的数据库：
<screen>
psql -h primary -c "CREATE DATABASE regression"
</screen>
<!-- 
   Next, run the preparatory script
   <filename>src/test/regress/sql/hs_primary_setup.sql</filename>
   on the primary in the regression database, for example:
-->
然后，在主服务器上的回归数据库中运行预备脚本
<filename>src/test/regress/sql/hs_primary_setup.sql</filename>，
例如：
<screen>
psql -h primary -f src/test/regress/sql/hs_primary_setup.sql regression
</screen>
<!-- 
   Allow these changes to propagate to the standby.
-->
允许这些修改传递到备用服务器。
  </para>  

  <para>
<!-- 
   Now arrange for the default database connection to be to the standby
   server under test (for example, by setting the <envar>PGHOST</envar> and
   <envar>PGPORT</envar> environment variables).
   Finally, run <literal>make standbycheck</> in the regression directory:
-->
现在为缺省数据库连接成为测试下的备用服务器做安排（例如，
通过设置<envar>PGHOST</envar>和<envar>PGPORT</envar>环境变量）。
最后，在回归路径下运行<literal>make standbycheck</>：
<screen>
cd src/test/regress
make standbycheck
</screen>
  </para>
<!-- 
  <para>
   Some extreme behaviors can also be generated on the primary using the
   script <filename>src/test/regress/sql/hs_primary_extremes.sql</filename>
   to allow the behavior of the standby to be tested.
  </para>
-->
<para>
一些极端行为也会在主服务器上产生，使用脚本
<filename>src/test/regress/sql/hs_primary_extremes.sql</filename>
允许测试备用服务器的行为。
</para>
  </sect2>  
  </sect1>

  <sect1 id="regress-evaluation">
   <!-- 
   <title>Test Evaluation</title> 
   -->
   <title>测试评估</title>

   <!--
<para>
    Some properly installed and fully functional
    <productname>PostgreSQL</productname> installations can
    <quote>fail</quote> some of these regression tests due to
    platform-specific artifacts such as varying floating-point representation
    and message wording. The tests are currently evaluated using a simple
    <command>diff</command> comparison against the outputs
    generated on a reference system, so the results are sensitive to
    small system differences.  When a test is reported as
    <quote>failed</quote>, always examine the differences between
    expected and actual results; you might find that the
    differences are not significant.  Nonetheless, we still strive to
    maintain accurate reference files across all supported platforms,
    so it can be expected that all tests pass.
   </para>
-->
<para>
有一些正确安装并且具有完整功能的<productname>PostgreSQL</productname>
可能会在一些回归测试中<quote>失效</quote>，这主要是因为浮点数的形式和时区支持的问题。
目前的测试只是简单的用<command>diff</command>与参考系统的输出进行比较，
因而对一些细小的系统区别很敏感。当一项测试报告<quote>失败</quote>时，
只要检查一下预期和实际的结果，你就会发现区别并不大。当然，
我们仍然在努力维护所有我们支持的平台的准确参考文件，这样我们就可以假定所有测试都通过。
</para>

   <!--
<para>
    The actual outputs of the regression tests are in files in the
    <filename>src/test/regress/results</filename> directory. The test
    script uses <command>diff</command> to compare each output
    file against the reference outputs stored in the
    <filename>src/test/regress/expected</filename> directory.  Any
    differences are saved for your inspection in
    <filename>src/test/regress/regression.diffs</filename>.  
    (When running a test suite other than the core tests, these files
    of course appear in the relevant subdirectory,
    not <filename>src/test/regress</>.)
   </para>
-->
<para>
回归测试的实际输出在<filename>src/test/regress/results</filename>目录里的文件里。
测试脚本使用<command>diff</command>比较每个输出文件和存放在<filename>src/test/regress/expected</filename>
目录里的参考输出。任何区别都存放在<filename>src/test/regress/regression.diffs</filename>
里面供你检查。（当运行一个测试套件而不是内核测试时，
这些文件当然会显示在相关的子目录中，而不是在<filename>src/test/regress</>中。）
</para>
<!-- 
   <para>        
    If you don't
    like the <command>diff</command> options that are used by default, set the
    environment variable <envar>PG_REGRESS_DIFF_OPTS</envar>, for
    instance <literal>PG_REGRESS_DIFF_OPTS='-u'</literal>.  (Or you
    can run <command>diff</command> yourself, if you prefer.)
   </para>
-->

<para>
如果你不喜欢默认的<command>diff</command>选项，设置环境变量
<envar>PG_REGRESS_DIFF_OPTS</envar>为<literal>PG_REGRESS_DIFF_OPTS='-u'</literal>。
你也可以自己运行<command>diff</command>。
</para>

   <!--
<para>
    If for some reason a particular platform generates a <quote>failure</>
    for a given test, but inspection of the output convinces you that
    the result is valid, you can add a new comparison file to silence
    the failure report in future test runs.  See
    <xref linkend="regress-variant"> for details.
   </para>
-->
<para>
如果获得一个<quote>失败</>的测试结果，但实际上输出结果是正确的，
你可以通过添加新的比较文件来抑制错误报告。参见<xref linkend="regress-variant">获取更多细节。
</para>

   <sect2>
    <!-- 
<title>Error Message Differences</title> 
-->
<title>错误消息差别</title>

    <!--
<para>
     Some of the regression tests involve intentional invalid input
     values.  Error messages can come from either the
     <productname>PostgreSQL</productname> code or from the host
     platform system routines. In the latter case, the messages can
     vary between platforms, but should reflect similar
     information. These differences in messages will result in a
     <quote>failed</quote> regression test that can be validated by
     inspection.
    </para>
-->
<para>
有一些回归测试涉及到有意的非法输入值。错误消息可能会来自<productname>PostgreSQL</productname>
代码或来自主机平台系统过程。对于后者，信息可能在平台之间区别比较大，
但应该反映相似的信息。这些信息上的差别将会导致一个<quote>失败</quote>的回归测试，
我们可以通过检查文件发现这一点。
</para>
   </sect2>

   <sect2>
    <!-- 
<title>Locale Differences</title> 
-->
<title>环境差别</title>

    <!--
<para>
     If you run the tests against a server that was
     initialized with a collation-order locale other than C, then
     there might be differences due to sort order and subsequent
     failures.  The regression test suite is set up to handle this
     problem by providing alternate result files that together are
     known to handle a large number of locales.
    </para>
-->
<para>
如果你在一台服务器上运行测试，而该服务器是用一种非 C 区域设置初始化的，
那么可能因为有排序顺序和其它类似的差别导致的失败。
回归测试套件处理这种问题的方法是提供可选的结果文件，这些文件一起处理一大堆的区域。
</para>
    
<para>
<!--
     To run the tests in a different locale when using the
     temporary-installation method, pass the appropriate
     locale-related environment variables on
     the <command>make</command> command line, for example:
-->
当使用临时安装在一个不同的区域中运行测试时，在<command>make</command>
命令行传递适当的区域相关的环境变量，例如：
<programlisting>
make check LANG=de_DE.utf8
</programlisting>
<!--
      (The regression test driver unsets <envar>LC_ALL</envar>, so it
     does not work to choose the locale using that variable.)  To use
     no locale, either unset all locale-related environment variables
     (or set them to <literal>C</literal>) or use the following
     special invocation: 
-->
回归测试驱动附件<envar>LC_ALL</envar>，所以它不使用那个变量选择区域。
要不使用区域，取消所有区域相关的环境变量（或设置它们为<literal>C</literal>）
或使用下列的特殊调用：
<programlisting>
make check NO_LOCALE=1
</programlisting>
<!-- 
     When running the tests against an existing installation, the
     locale setup is determined by the existing installation.  To
     change it, initialize the database cluster with a different
     locale by passing the appropriate options
     to <command>initdb</command>. 
-->
当对一个现有安装运行测试时，区域设置取决于现有安装。要改变它，
通过传递适当的选项到<command>initdb</command>，用一个不同的区域初始化数据库集群。
    </para>

    <!--
<para>
     In general, it is advisable to try to run the
     regression tests in the locale setup that is wanted for
     production use, as this will exercise the locale- and
     encoding-related code portions that will actually be used in
     production.  Depending on the operating system environment, you
     might get failures, but then you will at least know what
     locale-specific behaviors to expect when running real
     applications.
    </para>
-->
<para>
通常，作为生产用的区域设置上运行回归测试是明智的，因为这将练习区域和编码相关的代码部分，
并将实际在生产中使用。取决于操作系统环境，你可能会得到错误，
但是然后你将至少知道在运行实际应用时，预期什么区域特定的行为。
</para>
   </sect2>

   <sect2>
    <!-- 
<title>Date and Time Differences</title> 
-->
<title>日期和时间差别</title>

    <!--
<para>
     Most of the date and time results are dependent on the time zone
     environment.  The reference files are generated for time zone
     <literal>PST8PDT</literal> (Berkeley, California), and there will be
     apparent failures if the tests are not run with that time zone setting.
     The regression test driver sets environment variable
     <envar>PGTZ</envar> to <literal>PST8PDT</literal>, which normally
     ensures proper results.
    </para>
-->
<para>
大多数日期和时间测试结果依赖于时区设置。参考文件是为<literal>PST8PDT</literal>
时区(伯克利，加州)准备的，因而如果测试没有设置为那个时区是显然会失败的。
回归测试的驱动器把<envar>PGTZ</envar>环境变量设置为<literal>PST8PDT</literal>，
基本可以保证正确的测试。
</para>
   </sect2>

   <sect2>
    <!-- 
<title>Floating-Point Differences</title> 
-->
<title>浮点数差别</title>

    <!--
<para>
     Some of the tests involve computing 64-bit floating-point numbers (<type>double
     precision</type>) from table columns. Differences in
     results involving mathematical functions of <type>double
     precision</type> columns have been observed.  The <literal>float8</> and
     <literal>geometry</> tests are particularly prone to small differences
     across platforms, or even with different compiler optimization settings.
     Human eyeball comparison is needed to determine the real
     significance of these differences which are usually 10 places to
     the right of the decimal point.
    </para>
-->
<para>
有些测试涉及到对表中的数据列进行 64 位浮点数(<type>double precision</type>)计算的问题。
我们观察了涉及到计算<type>double precision</type>字段的数学函数的结果差别。
<literal>float8</>和<literal>geometry</>测试尤其容易在不同平台，
或者甚至是不同的编译器最优化设置之间产生小差别。
这时需要肉眼对这些差别进行比较，以判断这些差别究竟有多大，我们发现是在小数点右边 10 位左右。
</para>

    <!--
<para>
     Some systems display minus zero as <literal>-0</>, while others
     just show <literal>0</>.
    </para>
-->
<para>
有些系统把负零显示为<literal>-0</>，而其它的只是显示<literal>0</>。
</para>

    <!--
<para>
     Some systems signal errors from <function>pow()</function> and
     <function>exp()</function> differently from the mechanism
     expected by the current <productname>PostgreSQL</productname>
     code.
    </para>
-->
<para>
有些系统在<function>pow()</function>和<function>exp()</function>
出错时产生的信号与目前<productname>PostgreSQL</productname>代码里期望的机制不一样。
</para>
   </sect2>

   <sect2>
    <!-- 
<title>Row Ordering Differences</title> 
-->
<title>行顺序差别</title>

    <!--
<para>
You might see differences in which the same rows are output in a
different order than what appears in the expected file.  In most cases
this is not, strictly speaking, a bug.  Most of the regression test
scripts are not so pedantic as to use an <literal>ORDER BY</> for every single
<literal>SELECT</>, and so their result row orderings are not well-defined
according to the SQL specification.  In practice, since we are
looking at the same queries being executed on the same data by the same
software, we usually get the same result ordering on all platforms,
so the lack of <literal>ORDER BY</> is not a problem.  Some queries do exhibit
cross-platform ordering differences, however.  When testing against an
already-installed server, ordering differences can also be caused by
non-C locale settings or non-default parameter settings, such as custom values
of <varname>work_mem</> or the planner cost parameters.
    </para>
-->
<para>
你可能会看见同样的行以与预期文件的不同的顺序输出。在大多数情况下，严格说来这不算Bug。
大多数回归测试脚本都不会迂腐到在每个<literal>SELECT</>中都使用<literal>ORDER BY</>的地步，
因此根据 SQL 规范，它们的结果行顺序并非定义得非常好的。实际上，
因为我们是在同样的数据上用同样的软件运行同样的查询，所以在所有平台上通常都获得同样的结果，
因此即使缺少<literal>ORDER BY</>也不算什么大问题。不过有些查询的确存在跨平台的排序问题。
在测试一台已安装的服务器的时候，排序的差别也可能因为非 C 区域设置，或者非缺省的参数设置，
比如客户自己设置的<varname>work_mem</>或者规划器开销参数设置受影响。
</para>

    <!--
<para>
Therefore, if you see an ordering difference, it's not something to
worry about, unless the query does have an <literal>ORDER BY</> that your
result is violating.  However, please report it anyway, so that we can add an
<literal>ORDER BY</> to that particular query to eliminate the bogus
<quote>failure</quote> in future releases.
    </para>
-->
<para>
因此，如果你看到一个排序差异，应该不是什么要担心的问题(除非明确使用了<literal>ORDER BY</>)。
不过，如果有这样的现像，请告诉我们，这样我们就可以在那条查询上加一个<literal>ORDER BY</>
从而在以后的版本里消除这种伪<quote>失败</quote>。
</para>

    <!--
<para>
You might wonder why we don't order all the regression test queries explicitly
to get rid of this issue once and for all.  The reason is that that would
make the regression tests less useful, not more, since they'd tend
to exercise query plan types that produce ordered results to the
exclusion of those that don't.
    </para>
-->
<para>
你可能会问，为什么我们不对所有回归测试的 SELECT 进行排序以一次性消灭所有这类问题。
原因是这样做只能让回归测试用处更少，而不是更多，
因为它们会试图使用那些生成顺序结果的查询规划，而不再使用那些不排序的查询规划。
</para>
   </sect2>

   <sect2>
    <!-- 
<title>Insufficient Stack Depth</title> 
-->
<title>堆栈深度不够</title>

    <!--
<para>
     If the <literal>errors</literal> test results in a server crash
     at the <literal>select infinite_recurse()</> command, it means that
     the platform's limit on process stack size is smaller than the
     <xref linkend="guc-max-stack-depth"> parameter indicates.  This
     can be fixed by running the server under a higher stack
     size limit (4MB is recommended with the default value of
     <varname>max_stack_depth</>).  If you are unable to do that, an
     alternative is to reduce the value of <varname>max_stack_depth</>.
    </para>
-->
<para>
如果<literal>errors</literal>测试导致在<literal>select infinite_recurse()</>
命令的时候服务器崩溃，这就意味着平台对进程堆栈的限制小于
<xref linkend="guc-max-stack-depth">参数值。
我们可以通过在更高的堆栈限制的数值上运行服务器绕开这个问题(缺省
<varname>max_stack_depth</>建议值是 4MB)。如果你无法这么做，
那么另外一个方法是减少<varname>max_stack_depth</>的值。
</para>

<!-- 
    <para>
     On platforms supporting <function>getrlimit()</>, the server should
     automatically choose a safe value of <varname>max_stack_depth</>;
     so unless you've manually overridden this setting, a failure of this
     kind is a reportable bug.
    </para>
-->
<para>
在支持<function>getrlimit()</>的平台上，服务器应该自动选择一个
<varname>max_stack_depth</>安全值；所以除非你已经手动重写这个设置，
否则这种类型的失败是一个可报告的bug。
</para>
   </sect2>

   <sect2>
    <!-- 
<title>The <quote>random</quote> Test</title> 
-->
<title><quote>随机</quote> 测试</title>

    
<para>
<!--
     The <literal>random</literal> test script is intended to produce
     random results.   In very rare cases, this causes that regression
     test to fail.  Typing:
-->
<literal>random</literal>测试脚本的目的是生成随机结果。在很罕见的情况下，
这会导致回归测试失败。键入：
<programlisting>
diff results/random.out expected/random.out
</programlisting>
<!-- 
     should produce only one or a few lines of differences.  You need
     not worry unless the random test fails repeatedly. 
-->
会产生仅仅一行或几行差别。你不必担心这些，除非随机测试在重复测试中总是失败。
    </para>
   </sect2>
   
   <sect2>
    <!-- 
    <title>Configuration Parameters</title>
    -->
    <title>配置参数</title>

<!-- 
    <para>
     When running the tests against an existing installation, some non-default
     parameter settings could cause the tests to fail.  For example, changing
     parameters such as <varname>enable_seqscan</varname> or
     <varname>enable_indexscan</varname> could cause plan changes that would
     affect the results of tests that use <command>EXPLAIN</>.
    </para>
-->
<para>
当针对现有的安装运行测试时，一些非缺省的参数设置会导致测试失败。
例如，修改了参数比如<varname>enable_seqscan</varname>或
<varname>enable_indexscan</varname>会导致规划改变，
影响使用<command>EXPLAIN</>的测试的结果。
</para>
   </sect2>
  </sect1>

<!-- We might want to move the following section into the developer's guide. --><!--原文自带注释-->
  <sect1 id="regress-variant">
   <!-- 
   <title>Variant Comparison Files</title> 
   -->
   <title>平台相关的比较文件</title>

   <!--
<para>
    Since some of the tests inherently produce environment-dependent
    results, we have provided ways to specify alternate <quote>expected</>
    result files.  Each regression test can have several comparison files
    showing possible results on different platforms.  There are two
    independent mechanisms for determining which comparison file is used
    for each test.
   </para>
-->
<para>
因为一些测试天生会产生平台相关的结果，我们提供了明确指定与该平台相关的比较文件的方法。
每个回归测试都可以有针对不同平台的多个比较文件。有两个独立的机制可以用于确定究竟应该使用哪个比较文件。
</para>

   <!--
<para>
    The first mechanism allows comparison files to be selected for
    specific platforms.  There is a mapping file,
    <filename>src/test/regress/resultmap</filename>, that defines
    which comparison file to use for each platform.
    To eliminate bogus test <quote>failures</quote> for a particular platform,
    you first choose or make a variant result file, and then add a line to the
    <filename>resultmap</filename> file.
   </para>
-->
<para>
第一个机制是根据特定的平台选择比较文件。通过一个映射文件<filename>src/test/regress/resultmap</filename>
定义每个平台使用的比较文件。要消除某特定平台的虚假的测试<quote>失败</quote>，
可以先选择或创建一个结果文件的变种，然后在<filename>resultmap</filename>文件中添加一行指定映射关系即可。
</para>

   
<para>
<!--
    Each line in the mapping file is of the form
-->
映射文件里的每行都是如下形式
<synopsis>
testname:output:platformpattern=comparisonfilename
</synopsis>
<!-- 
    The test name is just the name of the particular regression test
    module. The output value indicates which output file to check. For the
    standard regression tests, this is always <literal>out</literal>. The
    value corresponds to the file extension of the output file.
    The platform pattern is a pattern in the style of the Unix
    tool <command>expr</> (that is, a regular expression with an implicit
    <literal>^</literal> anchor at the start).  It is matched against the
    platform name as printed by <command>config.guess</command>.
    The comparison file name is the base name of the substitute result
    comparison file. 
-->
测试名称只是特定回归测试模块的名称。输出值表明要检查哪个输出文件。
对于标准回归测试，这里总是<literal>out</literal>。这个值对应输出文件的文件扩展名。
平台名称模式是 Unix 工具<command>expr</>风格的模式(一个开头带有隐含<literal>^</literal>
锚符号的正则表达式)。它与<command>config.guess</command>打印出来的平台名匹配。
比较文件名是替换结果比较文件的基本名。
   </para>
   
<para>
<!--
    For example: some systems interpret very small floating-point values
    as zero, rather than reporting an underflow error.  This causes a
    few differences in the <filename>float8</> regression test.
    Therefore, we provide a variant comparison file,
    <filename>float8-small-is-zero.out</filename>, which includes
    the results to be expected on these systems.  To silence the bogus
    <quote>failure</quote> message on <systemitem>OpenBSD</systemitem>
    platforms, <filename>resultmap</filename> includes:
-->
比如：一些系统把很小的浮点数解析成为零，而不是报告一个下溢的错误。
这会导致在<filename>float8</>回归测试中的一些差别。因此，我们提供了一个比较文件的变种
<filename>float8-small-is-zero.out</filename>，它包含在这些平台上的预期结果。
要在<systemitem>OpenBSD</systemitem>平台上消除这些虚假的<quote>错误</quote>信息，
可以在<filename>resultmap</filename>中包含：
<programlisting>
float8:out:i.86-.*-openbsd=float8-small-is-zero.out
</programlisting>
<!-- 
    which will trigger on any machine where the output of
    <command>config.guess</command> matches <literal>i.86-.*-openbsd</literal>.
    Other lines
    in <filename>resultmap</> select the variant comparison file for other
    platforms where it's appropriate. 
-->
它将在那些<command>config.guess</command>的输出匹配<literal>i.86-.*-openbsd</literal>
的任何机器上触发。在<filename>resultmap</>里的其它行同样为其它合适的平台选取相应的比较文件变种。
   </para>
   <!--
<para>
    The second selection mechanism for variant comparison files is
    much more automatic: it simply uses the <quote>best match</> among
    several supplied comparison files.  The regression test driver
    script considers both the standard comparison file for a test,
    <literal><replaceable>testname</>.out</>, and variant files named
    <literal><replaceable>testname</>_<replaceable>digit</>.out</>
    (where the <replaceable>digit</> is any single digit
    <literal>0</>-<literal>9</>).  If any such file is an exact match,
    the test is considered to pass; otherwise, the one that generates
    the shortest diff is used to create the failure report.  (If
    <filename>resultmap</filename> includes an entry for the particular
    test, then the base <replaceable>testname</> is the substitute
    name given in <filename>resultmap</filename>.)
   </para>
-->
<para>
第二个选择比较文件的机制更加自动化：它简单的在多个比较文件中使用<quote>最佳匹配</>。
回归测试的驱动脚本同时考虑标准比较文件、<literal><replaceable>testname</>.out</>、
以及名为<literal><replaceable>testname</>_<replaceable>digit</>.out</>(<replaceable>digit</>
是<literal>0</>-<literal>9</>的任意一个)的变种文件。如果其中之一完全符合就认为测试通过，
否则将差异最小的比较输出写入失败报告。如果<filename>resultmap</filename>包含某个特定测试的项，
那么基准<replaceable>testname</>就是<filename>resultmap</filename>中给出的替换名。
</para>

   <!--
<para>
    For example, for the <literal>char</literal> test, the comparison file
    <filename>char.out</filename> contains results that are expected
    in the <literal>C</> and <literal>POSIX</> locales, while
    the file <filename>char_1.out</filename> contains results sorted as
    they appear in many other locales.
   </para>
-->
<para>
例如，对于<literal>char</literal>测试，比较文件<filename>char.out</filename>
包含使用<literal>C</>和<literal>POSIX</>区域设置的结果，而<filename>char_1.out</filename>
文件则包含使用其它区域设置的结果。
</para>

   <!--
<para>
    The best-match mechanism was devised to cope with locale-dependent
    results, but it can be used in any situation where the test results
    cannot be predicted easily from the platform name alone.  A limitation of
    this mechanism is that the test driver cannot tell which variant is
    actually <quote>correct</> for the current environment; it will just pick
    the variant that seems to work best.  Therefore it is safest to use this
    mechanism only for variant results that you are willing to consider
    equally valid in all contexts.
   </para>
-->
<para>
最佳匹配机制主要目的是用于匹配区域相关的测试结果，但也可以用于仅凭平台名称难以预计测试结果的场合。
这个机制的一个缺点是测试脚本无法确定当前环境下究竟哪个变种是<quote>确切</>的，
它只能选择最贴近的变种。因此最好将这个机制仅仅用于多个变种在所有上下文环境中都可以被认为是等价的场合。
</para>
  </sect1>

  <sect1 id="regress-tap">
   <!-- 
   <title>TAP Tests</title>
   -->
   <title>TAP 测试</title>
   <para>
<!-- 
    The client program tests under <filename>src/bin</filename> use the Perl
    TAP tools and are run by <command>prove</command>.  You can pass
    command-line options to <command>prove</command> by setting
    the <command>make</command> variable <varname>PROVE_FLAGS</>, for example:
-->
<filename>src/bin</filename>下的客户端程序测试使用Perl TAP工具并且通过
<command>prove</command>运行。你可以通过设置<command>make</command>变量
<varname>PROVE_FLAGS</>传递命令行选项到<command>prove</command>，例如：
<programlisting>
make -C src/bin check PROVE_FLAGS='--reverse'
</programlisting>
<!-- 
    The default is <literal>&#045;-verbose</literal>.  See the manual page
    of <command>prove</command> for more information.
-->
缺省是<literal>--verbose</literal>。参阅<command>prove</command>
的手册页获取更多信息。
   </para>
   
<!-- 
   <para>
    The tests written in Perl require the Perl
    module <literal>IPC::Run</literal>.
    This module is available from CPAN or an operating system package.
   </para>
--> 
<para>
以Perl写的测试需要Prel模块<literal>IPC::Run</literal>。
这个模块可以从CPAN或者一个操作系统包中获得。
</para>  
  </sect1>

  <sect1 id="regress-coverage">
   <!-- 
   <title>Test Coverage Examination</title> 
   -->
   <title>测试覆盖率检查</title>

   <!--
<para>
    The PostgreSQL source code can be compiled with coverage testing
    instrumentation, so that it becomes possible to examine which
    parts of the code are covered by the regression tests or any other
    test suite that is run with the code.  This is currently supported
    when compiling with GCC and requires the <command>gcov</command>
    and <command>lcov</command> programs.
   </para>
-->
<para>
PostgreSQL源代码可以编译有覆盖测试设备，
所以检查回归测试包含哪部分代码或任何其他测试组件运行代码是可能的。
使用GCC编译并且需要<command>gcov</command>和<command>lcov</command>程序是目前支持的。
</para>
   
<para>
<!--
    A typical workflow would look like this:
-->
一个典型的工作流应该像这样：
<screen>
./configure --enable-coverage ... OTHER OPTIONS ...
make
make check # or other test suite
make coverage-html
</screen>
<!-- 
    Then point your HTML browser
    to <filename>coverage/index.html</filename>.
    The <command>make</command> commands also work in subdirectories. 
-->
然后你的HTML浏览器跳转到<filename>coverage/index.html</filename>。
<command>make</command>命令在子目录中也能工作。
   </para>
   
<para>
<!--
    To reset the execution counts between test runs, run:
-->
要重置测试运行之间的执行计数，运行：
<screen>
make coverage-clean
</screen>
   </para>
  </sect1>

</chapter>
