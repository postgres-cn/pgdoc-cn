<!-- doc/src/sgml/xaggr.sgml -->

 <sect1 id="xaggr">
<!--==========================orignal english content==========================
  <title>User-defined Aggregates</title>
____________________________________________________________________________-->
  <title>用户定义的聚集</title>

<!--==========================orignal english content==========================
  <indexterm zone="xaggr">
   <primary>aggregate function</primary>
   <secondary>user-defined</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="xaggr">
   <primary>聚集函数</primary>
   <secondary>用户定义的</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   Aggregate functions in <productname>PostgreSQL</productname>
   are defined in terms of <firstterm>state values</firstterm>
   and <firstterm>state transition functions</firstterm>.
   That is, an aggregate operates using a state value that is updated
   as each successive input row is processed.
   To define a new aggregate
   function, one selects a data type for the state value,
   an initial value for the state, and a state transition
   function.  The state transition function takes the previous state
   value and the aggregate's input value(s) for the current row, and
   returns a new state value.
   A <firstterm>final function</firstterm>
   can also be specified, in case the desired result of the aggregate
   is different from the data that needs to be kept in the running
   state value.  The final function takes the ending state value
   and returns whatever is wanted as the aggregate result.
   In principle, the transition and final functions are just ordinary
   functions that could also be used outside the context of the
   aggregate.  (In practice, it's often helpful for performance reasons
   to create specialized transition functions that can only work when
   called as part of an aggregate.)
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>中的聚集函数用<firstterm>状态值</firstterm>和<firstterm>状态转换函数</firstterm>定义。也就是，一个聚集操作使用一个状态值，它在每一个后续输入行被处理时被更新。要定义一个新的聚集函数，我们要为状态值选择一种数据类型、一个状态的初始值和一个状态转换函数。状态转换函数接收前一个状态值和该聚集当前行的输入值，并且返回一个新的状态值。万一该聚集的预期结果与需要保存在运行状态之中的数据不同，还能指定一个<firstterm>最终函数</firstterm>。最终函数接受结束状态值并且返回作为聚集结果的任何东西。原则上，转换函数和最终函数只是也可以在聚集环境之外使用的普通函数（实际上，通常出于性能的原因，会创建特殊的只能作为聚集的一部分工作的转换函数）。
  </para>

<!--==========================orignal english content==========================
  <para>
   Thus, in addition to the argument and result data types seen by a user
   of the aggregate, there is an internal state-value data type that
   might be different from both the argument and result types.
  </para>
____________________________________________________________________________-->
  <para>
   因此，除了该聚集的用户所见的参数和结果数据类型之外，还有一种可能不同于参数和结果状态的内部状态值数据类型。
  </para>

<!--==========================orignal english content==========================
  <para>
   If we define an aggregate that does not use a final function,
   we have an aggregate that computes a running function of
   the column values from each row.  <function>sum</>  is  an
   example  of  this  kind  of aggregate.  <function>sum</> starts at
   zero and always adds the current  row's  value  to
   its  running  total.  For example, if we want to make a <function>sum</>
   aggregate to work on a data type for complex numbers,
   we only need the addition function for that data type.
   The aggregate definition would be:

<programlisting>
CREATE AGGREGATE sum (complex)
(
    sfunc = complex_add,
    stype = complex,
    initcond = '(0,0)'
);
</programlisting>

   which we might use like this:

<programlisting>
SELECT sum(a) FROM test_complex;

   sum
-&minus;-&minus;-&minus;-&minus;-&minus;-
 (34,53.9)
</programlisting>

   (Notice that we are relying on function overloading: there is more than
    one aggregate named <function>sum</>, but
   <productname>PostgreSQL</productname> can figure out which kind
   of sum applies to a column of type <type>complex</type>.)
  </para>
____________________________________________________________________________-->
  <para>
   如果我们定义一个聚集但不使用一个最终函数，我们就得到了一个从每一行的列值计算一个运行函数的聚集。<function>sum</>是这类聚集的一个例子。<function>sum</>从零开始，并且总是把当前行的值加到它的运行总和上。例如，如果我们希望让一个<function>sum</>聚集能工作在复数数据类型上，我们只需要该数据类型的加法函数。聚集定义是：

<programlisting>
CREATE AGGREGATE sum (complex)
(
    sfunc = complex_add,
    stype = complex,
    initcond = '(0,0)'
);
</programlisting>

   我们可以这样使用：

<programlisting>
SELECT sum(a) FROM test_complex;

   sum
-----------
 (34,53.9)
</programlisting>

   （注意我们依赖于函数重载：有多于一个名为<function>sum</>的聚集，但是<productname>PostgreSQL</productname>能够找出哪种 sum 适用于一个类型为<type>complex</type>的列）。
  </para>

<!--==========================orignal english content==========================
  <para>
   The above definition of <function>sum</function> will return zero
   (the initial state value) if there are no nonnull input values.
   Perhaps we want to return null in that case instead &mdash; the SQL standard
   expects <function>sum</function> to behave that way.  We can do this simply by
   omitting the <literal>initcond</literal> phrase, so that the initial state
   value is null.  Ordinarily this would mean that the <literal>sfunc</literal>
   would need to check for a null state-value input.  But for
   <function>sum</function> and some other simple aggregates like
   <function>max</> and <function>min</>,
   it is sufficient to insert the first nonnull input value into
   the state variable and then start applying the transition function
   at the second nonnull input value.  <productname>PostgreSQL</productname>
   will do that automatically if the initial state value is null and
   the transition function is marked <quote>strict</> (i.e., not to be called
   for null inputs).
  </para>
____________________________________________________________________________-->
  <para>
   如果没有非空输入值，上述的<function>sum</function>定义将返回零（初始状态值）。也许我们想要在这种情况下返回空 &mdash;  SQL 标准期望<function>sum</function>以这种方式行事。我们可以通过忽略<literal>initcond</literal>阶段简单地做到这一点，这样初始状态值就为空。通常这表示<literal>sfunc</literal>将需要检查一个空状态值输入。但是对于<function>sum</function>和一些其他简单聚集（如<function>max</>和<function>min</>），把第一个非空输入值插入到状态变量中并且接着在第二个非空输入值上开始应用转换函数就足够了。如果初始状态值为空并且转换函数被标记为<quote>strict</>（即不为空输入调用），<productname>PostgreSQL</productname>会自动这样做。
  </para>

<!--==========================orignal english content==========================
  <para>
   Another bit of default behavior for a <quote>strict</> transition function
   is that the previous state value is retained unchanged whenever a
   null input value is encountered.  Thus, null values are ignored.  If you
   need some other behavior for null inputs, do not declare your
   transition function as strict; instead code it to test for null inputs and
   do whatever is needed.
  </para>
____________________________________________________________________________-->
  <para>
   <quote>strict</>转换函数的另一点默认行为是只要碰到了一个空输入值，之前的状态值就保持不变。因此，空值会被忽略。如果你需要某些其他用于空输入的行为，不要把你的转换函数声明为 strict，而是把它编码为测试空输入并且做所需要的事情。
  </para>

<!--==========================orignal english content==========================
  <para>
   <function>avg</> (average) is a more complex example of an aggregate.
   It requires
   two pieces of running state: the sum of the inputs and the count
   of the number of inputs.  The final result is obtained by dividing
   these quantities.  Average is typically implemented by using an
   array as the state value.  For example,
   the built-in implementation of <function>avg(float8)</function>
   looks like:

<programlisting>
CREATE AGGREGATE avg (float8)
(
    sfunc = float8_accum,
    stype = float8[],
    finalfunc = float8_avg,
    initcond = '{0,0,0}'
);
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   <function>avg</>（均值）是一种更复杂的聚集例子。它要求两份运行状态：输入的总和以及输入的计数。最终结果通过将这些量相除而得到。均值是使用一个数组作为状态值的典型实现。例如，内建的<function>avg(float8)</function>实现看起来像：

<programlisting>
CREATE AGGREGATE avg (float8)
(
    sfunc = float8_accum,
    stype = float8[],
    finalfunc = float8_avg,
    initcond = '{0,0,0}'
);
</programlisting>
   </para>

   <note>
<!--==========================orignal english content==========================
   <para>
   <function>float8_accum</> requires a three-element array, not just
   two elements, because it accumulates the sum of squares as well as
   the sum and count of the inputs.  This is so that it can be used for
   some other aggregates as well as <function>avg</>.
   </para>
____________________________________________________________________________-->
   <para>
   （<function>float8_accum</>要求一个三元素的数组，而不只是两个元素，因为它累积平方和以及输入的总和以及计数。因此它也可以被用于其他聚集函数以及<function>avg</>）。
  </para>
  </note>

<!--==========================orignal english content==========================
  <para>
   Aggregate function calls in SQL allow <literal>DISTINCT</>
   and <literal>ORDER BY</> options that control which rows are fed
   to the aggregate's transition function and in what order.  These
   options are implemented behind the scenes and are not the concern
   of the aggregate's support functions.
  </para>
____________________________________________________________________________-->
  <para>
   SQL 中的聚集函数调用允许用<literal>DISTINCT</>和<literal>ORDER BY</>选项控制以什么顺序把行传递给该聚集的转换函数。这些选项的实现不需要该聚集的支持函数关心。
  </para>

<!--==========================orignal english content==========================
  <para>
   For further details see the
   <xref linkend="sql-createaggregate">
   command.
  </para>
____________________________________________________________________________-->
  <para>
   进一步的细节可见<xref linkend="sql-createaggregate">命令。   
  </para>

 <sect2 id="xaggr-moving-aggregates">
<!--==========================orignal english content==========================
  <title>Moving-Aggregate Mode</title>
____________________________________________________________________________-->
  <title>移动聚集模式</title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>moving-aggregate mode</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>移动聚集模式</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>aggregate function</primary>
   <secondary>moving aggregate</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>聚集函数</primary>
   <secondary>移动聚集</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   Aggregate functions can optionally support <firstterm>moving-aggregate
   mode</>, which allows substantially faster execution of aggregate
   functions within windows with moving frame starting points.
   (See <xref linkend="tutorial-window">
   and <xref linkend="syntax-window-functions"> for information about use of
   aggregate functions as window functions.)
   The basic idea is that in addition to a normal <quote>forward</>
   transition function, the aggregate provides an <firstterm>inverse
   transition function</>, which allows rows to be removed from the
   aggregate's running state value when they exit the window frame.
   For example a <function>sum</> aggregate, which uses addition as the
   forward transition function, would use subtraction as the inverse
   transition function.  Without an inverse transition function, the window
   function mechanism must recalculate the aggregate from scratch each time
   the frame starting point moves, resulting in run time proportional to the
   number of input rows times the average frame length.  With an inverse
   transition function, the run time is only proportional to the number of
   input rows.
  </para>
____________________________________________________________________________-->
  <para>
   聚集函数可以选择性地支持<firstterm>移动聚集模式</>，这种模式允许很大程度上提高在具有移动帧起点的窗口中执行的聚集函数的速度（有关把聚集函数用作窗口函数请见<xref linkend="tutorial-window">和<xref linkend="syntax-window-functions">）。基本思想是在通常的<quote>前向</>转换函数之外，聚集提供一个<firstterm>逆向转换函数</>，该函数允许当行退出窗口帧时从聚集的运行状态值中移除它们的值。例如一个<function>sum</>聚集使用加法作为前向转换函数，它可以使用减法作为逆向转换函数。如果没有一个逆向转换函数，每一次帧起点移动时，窗口函数机制必须重新从头计算该聚集，这会导致运行时间与输入行的数量乘以平均帧长度成比例。如果有一个逆向转换函数，运行时间只与输入行的数量成比例。
  </para>

<!--==========================orignal english content==========================
  <para>
   The inverse transition function is passed the current state value and the
   aggregate input value(s) for the earliest row included in the current
   state.  It must reconstruct what the state value would have been if the
   given input row had never been aggregated, but only the rows following
   it.  This sometimes requires that the forward transition function keep
   more state than is needed for plain aggregation mode.  Therefore, the
   moving-aggregate mode uses a completely separate implementation from the
   plain mode: it has its own state data type, its own forward transition
   function, and its own final function if needed.  These can be the same as
   the plain mode's data type and functions, if there is no need for extra
   state.
  </para>
____________________________________________________________________________-->
  <para>
   当前状态值和包含在当前状态中最早的行的聚集输入值被传递给逆向转换函数。它必须重新构建出如果给定的输入行不再被聚集（只聚集其后的行）时状态值会是什么样。这有时要求前向转换函数保存比普通聚集模式下更多的状态。因此，移动聚集模式使用一种完全不同于普通模式的实现：它有自己的状态数据类型、自己的前向转换函数以及自己的状态函数（如果需要）。如果不需要额外的状态，这些可以和普通模式的数据类型和函数相同。
  </para>

<!--==========================orignal english content==========================
  <para>
   As an example, we could extend the <function>sum</> aggregate given above
   to support moving-aggregate mode like this:

<programlisting>
CREATE AGGREGATE sum (complex)
(
    sfunc = complex_add,
    stype = complex,
    initcond = '(0,0)',
    msfunc = complex_add,
    minvfunc = complex_sub,
    mstype = complex,
    minitcond = '(0,0)'
);
</programlisting>

   The parameters whose names begin with <literal>m</> define the
   moving-aggregate implementation.  Except for the inverse transition
   function <literal>minvfunc</>, they correspond to the plain-aggregate
   parameters without <literal>m</>.
  </para>
____________________________________________________________________________-->
  <para>
   作为一个例子，我们可以把上面给定的<function>sum</>聚集扩展成支持移动聚集模式：

<programlisting>
CREATE AGGREGATE sum (complex)
(
    sfunc = complex_add,
    stype = complex,
    initcond = '(0,0)',
    msfunc = complex_add,
    minvfunc = complex_sub,
    mstype = complex,
    minitcond = '(0,0)'
);
</programlisting>

   名称以<literal>m</>开始的参数定义移动聚集实现。除了逆向转换函数<literal>minvfunc</>，它们都对应于没有<literal>m</>的普通聚集参数。
  </para>

<!--==========================orignal english content==========================
  <para>
   The forward transition function for moving-aggregate mode is not allowed
   to return null as the new state value.  If the inverse transition
   function returns null, this is taken as an indication that the inverse
   function cannot reverse the state calculation for this particular input,
   and so the aggregate calculation will be redone from scratch for the
   current frame starting position.  This convention allows moving-aggregate
   mode to be used in situations where there are some infrequent cases that
   are impractical to reverse out of the running state value.  The inverse
   transition function can <quote>punt</> on these cases, and yet still come
   out ahead so long as it can work for most cases.  As an example, an
   aggregate working with floating-point numbers might choose to punt when
   a <literal>NaN</> (not a number) input has to be removed from the running
   state value.
  </para>
____________________________________________________________________________-->
  <para>
   用于移动聚集模式的前向转换函数不允许返回空值作为新状态值。如果逆向转换函数返回空值，这被当作一种指示，它表明该逆向函数无法为这个特定输入逆转状态计算，因此该聚集计算将根据当前的帧开始位置重新从头计算。这种习惯允许移动聚集模式被用在一些不适合逆转运行状态值的少数情况下。逆向转换函数在这些情况下可以<quote>撒手不管</>，然后在它能够工作的大部分情况中再出来干活。例如，一个浮点数的聚集可能会在必须从运行状态值中移除一个<literal>NaN</>（不是一个数字）输入时撒手不管。
  </para>

<!--==========================orignal english content==========================
  <para>
   When writing moving-aggregate support functions, it is important to be
   sure that the inverse transition function can reconstruct the correct
   state value exactly.  Otherwise there might be user-visible differences
   in results depending on whether the moving-aggregate mode is used.
   An example of an aggregate for which adding an inverse transition
   function seems easy at first, yet where this requirement cannot be met
   is <function>sum</> over <type>float4</> or <type>float8</> inputs.  A
   naive declaration of <function>sum(<type>float8</>)</function> could be

<programlisting>
CREATE AGGREGATE unsafe_sum (float8)
(
    stype = float8,
    sfunc = float8pl,
    mstype = float8,
    msfunc = float8pl,
    minvfunc = float8mi
);
</programlisting>

   This aggregate, however, can give wildly different results than it would
   have without the inverse transition function. For example, consider

<programlisting>
SELECT
  unsafe_sum(x) OVER (ORDER BY n ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING)
FROM (VALUES (1, 1.0e20::float8),
             (2, 1.0::float8)) AS v (n,x);
</programlisting>

   This query returns <literal>0</> as its second result, rather than the
   expected answer of <literal>1</>.  The cause is the limited precision of
   floating-point values: adding <literal>1</> to <literal>1e20</> results
   in <literal>1e20</> again, and so subtracting <literal>1e20</> from that
   yields <literal>0</>, not <literal>1</>.  Note that this is a limitation
   of floating-point arithmetic in general, not a limitation
   of <productname>PostgreSQL</>.
  </para>
____________________________________________________________________________-->
  <para>
   在编写移动聚集支持函数时，很重要的是确保逆向转换函数能够准确地重构正确的状态值。否则会导致用不用移动聚集模式时结果中产生用户可见的差别。为一个聚集增加一个逆向转换函数的例子最初看起来很简单，但是却无法满足<type>float4</>或者<type>float8</>输入上的<function>sum</>的要求。<function>sum(<type>float8</>)</function>的一种未经考虑的定义可以是

<programlisting>
CREATE AGGREGATE unsafe_sum (float8)
(
    stype = float8,
    sfunc = float8pl,
    mstype = float8,
    msfunc = float8pl,
    minvfunc = float8mi
);
</programlisting>

   但是，这个聚集可能给出与没有逆向转换函数时很不同的结果。例如，考虑

<programlisting>
SELECT
  unsafe_sum(x) OVER (ORDER BY n ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING)
FROM (VALUES (1, 1.0e20::float8),
             (2, 1.0::float8)) AS v (n,x);
</programlisting>

   这个查询返回<literal>0</>作为它的第二个结果，而不是我们期待的<literal>1</>。其原因是浮点值的有限精度：把<literal>1</>加到<literal>1e20</>还是会得到<literal>1e20</>，因此从中减去<literal>1e20</>会得到<literal>0</>而不是<literal>1</>。这是对于浮点计算的一种一般性限制，而不是<productname>PostgreSQL</>的限制。
  </para>

 </sect2>

 <sect2 id="xaggr-polymorphic-aggregates">
<!--==========================orignal english content==========================
  <title>Polymorphic and Variadic Aggregates</title>
____________________________________________________________________________-->
  <title>多态和可变聚集</title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>aggregate function</primary>
   <secondary>polymorphic</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>聚集函数</primary>
   <secondary>多态</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>aggregate function</primary>
   <secondary>variadic</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>聚集函数</primary>
   <secondary>可变</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   Aggregate functions can use polymorphic
   state transition functions or final functions, so that the same functions
   can be used to implement multiple aggregates.
   See <xref linkend="extend-types-polymorphic">
   for an explanation of polymorphic functions.
   Going a step further, the aggregate function itself can be specified
   with polymorphic input type(s) and state type, allowing a single
   aggregate definition to serve for multiple input data types.
   Here is an example of a polymorphic aggregate:

<programlisting>
CREATE AGGREGATE array_accum (anyelement)
(
    sfunc = array_append,
    stype = anyarray,
    initcond = '{}'
);
</programlisting>

   Here, the actual state type for any given aggregate call is the array type
   having the actual input type as elements.  The behavior of the aggregate
   is to concatenate all the inputs into an array of that type.
   (Note: the built-in aggregate <function>array_agg</> provides similar
   functionality, with better performance than this definition would have.)
  </para>
____________________________________________________________________________-->
  <para>
   聚集函数可以使用多态状态转换函数或最终函数，这样同样的函数能被用来实现多个聚集。关于多态函数的解释可参见<xref linkend="extend-types-polymorphic">。更进一步，聚集函数本身可以被指定为具有多态输入类型和状态类型，允许一个聚集函数服务于多种输入数据类型。这里是一个多态聚集的例子：

<programlisting>
CREATE AGGREGATE array_accum (anyelement)
(
    sfunc = array_append,
    stype = anyarray,
    initcond = '{}'
);
</programlisting>

   这里，每一次给定聚集调用的实际状态类型是把实际输入类型作为元素的数组类型。该聚集的行为是串接所有输入成一个该类型的数组（注意：内建的聚集<function>array_agg</>提供了相似的功能，但是具有比上述定义更好的性能）。
  </para>

<!--==========================orignal english content==========================
  <para>
   Here's the output using two different actual data types as arguments:

<programlisting>
SELECT attrelid::regclass, array_accum(attname)
    FROM pg_attribute
    WHERE attnum &gt; 0 AND attrelid = 'pg_tablespace'::regclass
    GROUP BY attrelid;

   attrelid    |              array_accum              
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 pg_tablespace | {spcname,spcowner,spcacl,spcoptions}
(1 row)

SELECT attrelid::regclass, array_accum(atttypid::regtype)
    FROM pg_attribute
    WHERE attnum &gt; 0 AND attrelid = 'pg_tablespace'::regclass
    GROUP BY attrelid;

   attrelid    |        array_accum        
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 pg_tablespace | {name,oid,aclitem[],text[]}
(1 row)
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   这里是使用两种不同实际数据类型作为参数的输出：

<programlisting>
SELECT attrelid::regclass, array_accum(attname)
    FROM pg_attribute
    WHERE attnum &gt; 0 AND attrelid = 'pg_tablespace'::regclass
    GROUP BY attrelid;

   attrelid    |              array_accum              
---------------+---------------------------------------
 pg_tablespace | {spcname,spcowner,spcacl,spcoptions}
(1 row)

SELECT attrelid::regclass, array_accum(atttypid::regtype)
    FROM pg_attribute
    WHERE attnum &gt; 0 AND attrelid = 'pg_tablespace'::regclass
    GROUP BY attrelid;

   attrelid    |        array_accum        
---------------+---------------------------
 pg_tablespace | {name,oid,aclitem[],text[]}
(1 row)
</programlisting>
  </para>
  
<!--==========================orignal english content==========================
  <para>
   Ordinarily, an aggregate function with a polymorphic result type has a
   polymorphic state type, as in the above example.  This is necessary
   because otherwise the final function cannot be declared sensibly: it
   would need to have a polymorphic result type but no polymorphic argument
   type, which <command>CREATE FUNCTION</> will reject on the grounds that
   the result type cannot be deduced from a call.  But sometimes it is
   inconvenient to use a polymorphic state type.  The most common case is
   where the aggregate support functions are to be written in C and the
   state type should be declared as <type>internal</> because there is
   no SQL-level equivalent for it.  To address this case, it is possible to
   declare the final function as taking extra <quote>dummy</> arguments
   that match the input arguments of the aggregate.  Such dummy arguments
   are always passed as null values since no specific value is available when the
   final function is called.  Their only use is to allow a polymorphic
   final function's result type to be connected to the aggregate's input
   type(s).  For example, the definition of the built-in
   aggregate <function>array_agg</> is equivalent to

<programlisting>
CREATE FUNCTION array_agg_transfn(internal, anynonarray)
  RETURNS internal ...;
CREATE FUNCTION array_agg_finalfn(internal, anynonarray)
  RETURNS anyarray ...;

CREATE AGGREGATE array_agg (anynonarray)
(
    sfunc = array_agg_transfn,
    stype = internal,
    finalfunc = array_agg_finalfn,
    finalfunc_extra
);
</programlisting>

   Here, the <literal>finalfunc_extra</> option specifies that the final
   function receives, in addition to the state value, extra dummy
   argument(s) corresponding to the aggregate's input argument(s).
   The extra <type>anynonarray</> argument allows the declaration
   of <function>array_agg_finalfn</> to be valid.
  </para>
____________________________________________________________________________-->
  <para>
   如上述例子所示，通常一个具有多态结果类型的聚集函数有一个多态状态类型。这是必须的，因为否则就无法有意义地声明最终函数：它会需要有一个多态结果类型但是不能有多态参数类型，<command>CREATE FUNCTION</>将当场拒绝那些无法从调用中推断结果类型的函数。但是使用一个多态状态类型有时并不方便。最常见的情况是，聚集支持函数使用 C 编写并且状态类型应该被声明为<type>internal</>，因为在 SQL 层面上没有与它等效的类型。为了表述这种情况，可以声明最终函数为接受额外的匹配该聚集输入参数的<quote>dummy</>参数。这种假参数总是被传递为空值，因为当最终函数被调用时没有特定的值可用。它们的唯一用途是允许一个多态最终函数的结果类型被连接到该聚集的输入类型。例如，内建聚集<function>array_agg</>的定义等效于：

<programlisting>
CREATE FUNCTION array_agg_transfn(internal, anynonarray)
  RETURNS internal ...;
CREATE FUNCTION array_agg_finalfn(internal, anynonarray)
  RETURNS anyarray ...;

CREATE AGGREGATE array_agg (anynonarray)
(
    sfunc = array_agg_transfn,
    stype = internal,
    finalfunc = array_agg_finalfn,
    finalfunc_extra
);
</programlisting>

   这里，<literal>finalfunc_extra</>选项指定该最终函数接收除了状态值之外，还接收对应于该聚集输入参数的额外假参数。额外的<type>anynonarray</>参数允许<function>array_agg_finalfn</>的声明成为合法。
  </para>

<!--==========================orignal english content==========================
  <para>
   An aggregate function can be made to accept a varying number of arguments
   by declaring its last argument as a <literal>VARIADIC</> array, in much
   the same fashion as for regular functions; see
   <xref linkend="xfunc-sql-variadic-functions">.  The aggregate's transition
   function(s) must have the same array type as their last argument.  The
   transition function(s) typically would also be marked <literal>VARIADIC</>,
   but this is not strictly required.
  </para>
____________________________________________________________________________-->
  <para>
   与常规函数的习惯大致相同，可以通过把一个聚集函数的最后一个参数声明为一个<literal>VARIADIC</>数组，这样可以让该函数接受可变数量的参数（见<xref linkend="xfunc-sql-variadic-functions">）。该聚集的转换函数也必须有相同的数组类型作为它们的最后一个参数。通常这类转换函数也会被标上<literal>VARIADIC</>，但这不被严格要求。
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    Variadic aggregates are easily misused in connection with
    the <literal>ORDER BY</> option (see <xref linkend="syntax-aggregates">),
    since the parser cannot tell whether the wrong number of actual arguments
    have been given in such a combination.  Keep in mind that everything to
    the right of <literal>ORDER BY</> is a sort key, not an argument to the
    aggregate.  For example, in
<programlisting>
SELECT myaggregate(a ORDER BY a, b, c) FROM ...
</programlisting>
    the parser will see this as a single aggregate function argument and
    three sort keys.  However, the user might have intended
<programlisting>
SELECT myaggregate(a, b, c ORDER BY a) FROM ...
</programlisting>
    If <literal>myaggregate</> is variadic, both these calls could be
    perfectly valid.
   </para>
____________________________________________________________________________-->
   <para>
    可变聚集最容易被误用的情况是与<literal>ORDER BY</>选项（见<xref linkend="syntax-aggregates">）一起使用，因为解析器无法在这样一种组合中是否给出了错误的实际参数数量。要记住在<literal>ORDER BY</>右侧的任何东西都是一个排序键，而不是一个聚集的参数。例如，在
<programlisting>
SELECT myaggregate(a ORDER BY a, b, c) FROM ...
</programlisting>
    中，解析器将认为看到的是一个聚集函数参数和三个排序键。但是，用户可能想要的是
<programlisting>
SELECT myaggregate(a, b, c ORDER BY a) FROM ...
</programlisting>
    如果<literal>myaggregate</>是可变的，两种调用都是合法的。
   </para>

<!--==========================orignal english content==========================
   <para>
    For the same reason, it's wise to think twice before creating aggregate
    functions with the same names and different numbers of regular arguments.
   </para>
____________________________________________________________________________-->
   <para>
    出于相同的原因，在创建具有相同名称以及不同数量的常规参数的聚集函数时一定要三思而后行。
   </para>
  </note>

 </sect2>

 <sect2 id="xaggr-ordered-set-aggregates">
<!--==========================orignal english content==========================
  <title>Ordered-Set Aggregates</title>
____________________________________________________________________________-->
  <title>有序集聚集</title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>aggregate function</primary>
   <secondary>ordered set</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>聚集函数</primary>
   <secondary>有序集</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The aggregates we have been describing so far are <quote>normal</>
   aggregates.  <productname>PostgreSQL</> also
   supports <firstterm>ordered-set aggregates</>, which differ from
   normal aggregates in two key ways.  First, in addition to ordinary
   aggregated arguments that are evaluated once per input row, an
   ordered-set aggregate can have <quote>direct</> arguments that are
   evaluated only once per aggregation operation.  Second, the syntax
   for the ordinary aggregated arguments specifies a sort ordering
   for them explicitly.  An ordered-set aggregate is usually
   used to implement a computation that depends on a specific row
   ordering, for instance rank or percentile, so that the sort ordering
   is a required aspect of any call.  For example, the built-in
   definition of <function>percentile_disc</> is equivalent to:

<programlisting>
CREATE FUNCTION ordered_set_transition(internal, anyelement)
  RETURNS internal ...;
CREATE FUNCTION percentile_disc_final(internal, float8, anyelement)
  RETURNS anyelement ...;

CREATE AGGREGATE percentile_disc (float8 ORDER BY anyelement)
(
    sfunc = ordered_set_transition,
    stype = internal,
    finalfunc = percentile_disc_final,
    finalfunc_extra
);
</programlisting>

   This aggregate takes a <type>float8</> direct argument (the percentile
   fraction) and an aggregated input that can be of any sortable data type.
   It could be used to obtain a median household income like this:

<programlisting>
SELECT percentile_disc(0.5) WITHIN GROUP (ORDER BY income) FROM households;
 percentile_disc
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
           50489
</programlisting>

   Here, <literal>0.5</> is a direct argument; it would make no sense
   for the percentile fraction to be a value varying across rows.
  </para>
____________________________________________________________________________-->
  <para>
   目前为止我们已经描述的聚集都是<quote>普通</>聚集。<productname>PostgreSQL</>还支持<firstterm>有序集聚集</>，它和普通聚集在两个关键点上相区别。首先，除了对每个输入行都要计算一次的普通聚集参数之外，一个有序集聚集可以有<quote>直接</>参数，这类参数针对每次聚集操作只计算一次。其次，用于普通聚集参数的语法需要显式地为它们指定一个排序顺序。一个有续集聚集通常被用来实现一种依赖于特定行序的计算（例如排名或者百分位数），因此排序是任何调用都要求的。例如，<function>percentile_disc</>的内建定义等效于：

<programlisting>
CREATE FUNCTION ordered_set_transition(internal, anyelement)
  RETURNS internal ...;
CREATE FUNCTION percentile_disc_final(internal, float8, anyelement)
  RETURNS anyelement ...;

CREATE AGGREGATE percentile_disc (float8 ORDER BY anyelement)
(
    sfunc = ordered_set_transition,
    stype = internal,
    finalfunc = percentile_disc_final,
    finalfunc_extra
);
</programlisting>
   这个聚集接受一个<type>float8</>直接参数（百分位数分数）以及一个可以是任意可排序数据类型的聚集输入。它可以用来得到一个家庭收入的中位数：

<programlisting>
SELECT percentile_disc(0.5) WITHIN GROUP (ORDER BY income) FROM households;
 percentile_disc
-----------------
           50489
</programlisting>

   这里<literal>0.5</>是一个直接参数，它对于要作为一个在行之间变化的百分位数分数没有意义。
  </para>

<!--==========================orignal english content==========================
  <para>
   Unlike the case for normal aggregates, the sorting of input rows for
   an ordered-set aggregate is <emphasis>not</> done behind the scenes,
   but is the responsibility of the aggregate's support functions.
   The typical implementation approach is to keep a reference to
   a <quote>tuplesort</> object in the aggregate's state value, feed the
   incoming rows into that object, and then complete the sorting and
   read out the data in the final function.  This design allows the
   final function to perform special operations such as injecting
   additional <quote>hypothetical</> rows into the data to be sorted.
   While normal aggregates can often be implemented with support
   functions written in <application>PL/pgSQL</application> or another
   PL language, ordered-set aggregates generally have to be written in
   C, since their state values aren't definable as any SQL data type.
   (In the above example, notice that the state value is declared as
   type <type>internal</> &mdash; this is typical.)
  </para>
____________________________________________________________________________-->
  <para>
   和普通聚集的情况不同，用于有序集聚集的输入行排序<emphasis>不是</>在幕后完成的，而是由该聚集的支持函数负责完成。典型的实现方法是在该聚集的状态值中保持对于一个<quote>tuplesort</>对象的引用，把到来的行输入给该对象，然后完成排序并且在最终函数中读出该数据。这种设计允许最终函数能够执行特殊操作，例如把附加的<quote>假想</>行注入到被排序的数据中。虽然用由<application>PL/pgSQL</application>或另一种 PL 语言编写的支持函数通常能够实现普通聚集，但是有序集聚集通常必须用 C 编写，因为它们的状态值无法用任何 SQL 数据类型来定义（在上面的例子中，注意状态值被声明为类型<type>internal</> &mdash; 这很典型）。
  </para>

<!--==========================orignal english content==========================
  <para>
   The state transition function for an ordered-set aggregate receives
   the current state value plus the aggregated input values for
   each row, and returns the updated state value.  This is the
   same definition as for normal aggregates, but note that the direct
   arguments (if any) are not provided.  The final function receives
   the last state value, the values of the direct arguments if any,
   and (if <literal>finalfunc_extra</> is specified) null values
   corresponding to the aggregated input(s).  As with normal
   aggregates, <literal>finalfunc_extra</> is only really useful if the
   aggregate is polymorphic; then the extra dummy argument(s) are needed
   to connect the final function's result type to the aggregate's input
   type(s).
  </para>
____________________________________________________________________________-->
  <para>
   用于一个有序集聚集的状态转移函数接收当前状态值外加对于每一行的聚集输入值，并且返回更新后的状态值。这和普通聚集的定义相同，但是注意没有提供直接参数（如果有）。最终函数接收最后的状态值、直接参数（如果有）的值以及对应于聚集输入的空值（如果指定了<literal>finalfunc_extra</>）。正如普通聚集，只有聚集是多态时<literal>finalfunc_extra</>才真正有用，那时就需要额外的假参数把最终函数的结果类型连接到该聚集的输入类型。
  </para>

<!--==========================orignal english content==========================
  <para>
   Currently, ordered-set aggregates cannot be used as window functions,
   and therefore there is no need for them to support moving-aggregate mode.
  </para>
____________________________________________________________________________-->
  <para>
   当前，有序集聚集不能被用做窗口函数，并且因此没有必要让它们支持移动聚集模式。
  </para>

 </sect2>
 
 <sect2 id="xaggr-partial-aggregates">
<!--==========================orignal english content==========================
  <title>Partial Aggregation</title>
____________________________________________________________________________-->
  <title>部分聚集</title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>aggregate function</primary>
   <secondary>partial aggregation</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>聚集函数</primary>
   <secondary>部分聚集</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   Optionally, an aggregate function can support <firstterm>partial
   aggregation</>.  The idea of partial aggregation is to run the aggregate's
   state transition function over different subsets of the input data
   independently, and then to combine the state values resulting from those
   subsets to produce the same state value that would have resulted from
   scanning all the input in a single operation.  This mode can be used for
   parallel aggregation by having different worker processes scan different
   portions of a table.  Each worker produces a partial state value, and at
   the end those state values are combined to produce a final state value.
   (In the future this mode might also be used for purposes such as combining
   aggregations over local and remote tables; but that is not implemented
   yet.)
  </para>
____________________________________________________________________________-->
  <para>
   可选地，一个聚集函数可以支持<firstterm>部分聚集</>。部分聚集的思想是在输入数据的不同子集上独立的运行该聚集的状态转移函数，然后把从这些子集得到的状态值组合起来产生最终的状态值，这样得到的状态值与在单次聚集操作中扫描所有输入得到的状态值相同。这种模式可以被用来进行并行聚集，用不同的工作者进程扫描表的不同部分。每一个工作者产生一个部分状态值，最后把这些部分状态值组合产生最终状态值（在未来，这种模式可能也会被用于组合在本地表和远程表上的聚集，但目前还未实现）。
  </para>

<!--==========================orignal english content==========================
  <para>
   To support partial aggregation, the aggregate definition must provide
   a <firstterm>combine function</>, which takes two values of the
   aggregate's state type (representing the results of aggregating over two
   subsets of the input rows) and produces a new value of the state type,
   representing what the state would have been after aggregating over the
   combination of those sets of rows.  It is unspecified what the relative
   order of the input rows from the two sets would have been.  This means
   that it's usually impossible to define a useful combine function for
   aggregates that are sensitive to input row order.
  </para>
____________________________________________________________________________-->
  <para>
   为了支持部分聚集，聚集定义必须提供一个<firstterm>组合函数</>，这个函数接收两个该聚集的状态类型（表示在输入行的两个不同子集上得到的聚集结果）并且产生一个该状态类型的新值，该结果表示组合哪些聚集结果后的状态。至于来自两个集合的输入行的相对顺序则并没有指定。这意味着通常不可能为对输入行顺序敏感的聚集定义出可用的组合函数。
  </para>

<!--==========================orignal english content==========================
  <para>
   As simple examples, <literal>MAX</> and <literal>MIN</> aggregates can be
   made to support partial aggregation by specifying the combine function as
   the same greater-of-two or lesser-of-two comparison function that is used
   as their transition function.  <literal>SUM</> aggregates just need an
   addition function as combine function.  (Again, this is the same as their
   transition function, unless the state value is wider than the input data
   type.)
  </para>
____________________________________________________________________________-->
  <para>
   作为简单的例子，通过指定组合函数为与其转移函数中相同的“两者中较大者”和“两者中较小者”比较函数，<literal>MAX</>和<literal>MIN</>聚集可以支持部分聚集。<literal>SUM</>聚集则只需要一个额外的函数作为组合函数（同样，组合函数与其转移函数相同，除非状态值的宽度比输入数据类型更宽）。
  </para>

<!--==========================orignal english content==========================
  <para>
   The combine function is treated much like a transition function that
   happens to take a value of the state type, not of the underlying input
   type, as its second argument.  In particular, the rules for dealing
   with null values and strict functions are similar.  Also, if the aggregate
   definition specifies a non-null <literal>initcond</>, keep in mind that
   that will be used not only as the initial state for each partial
   aggregation run, but also as the initial state for the combine function,
   which will be called to combine each partial result into that state.
  </para>
____________________________________________________________________________-->
  <para>
   组合函数很像一个把状态类型值而不是底层输入类型值作为其第二个参数的转移函数。尤其是处理空值和严格函数的规则是相似的。此外，如果聚集定义指定了非空的<literal>initcond</>，记住那不仅会被作为每一次部分聚集运行的初始状态，还会被作为组合函数的初始状态，对每一个部分结果都会调用组合函数将部分结果组合到该初始状态中。
  </para>

<!--==========================orignal english content==========================
  <para>
   If the aggregate's state type is declared as <type>internal</>, it is
   the combine function's responsibility that its result is allocated in
   the correct memory context for aggregate state values.  This means in
   particular that when the first input is <literal>NULL</> it's invalid
   to simply return the second input, as that value will be in the wrong
   context and will not have sufficient lifespan.
  </para>
____________________________________________________________________________-->
  <para>
   如果聚集的状态类型被声明为<type>internal</>，则组合函数应负责在用于聚集状态值的内存上下文中分配其结果。这意味着当第一个输入为<literal>NULL</>时，不能简单地返回第二个输入，因为那个值将会在错误的上下文中并且将不具有足够的寿命。
  </para>

<!--==========================orignal english content==========================
  <para>
   When the aggregate's state type is declared as <type>internal</>, it is
   usually also appropriate for the aggregate definition to provide a
   <firstterm>serialization function</> and a <firstterm>deserialization
   function</>, which allow such a state value to be copied from one process
   to another.  Without these functions, parallel aggregation cannot be
   performed, and future applications such as local/remote aggregation will
   probably not work either.
  </para>
____________________________________________________________________________-->
  <para>
   当聚集的状态类型被声明为<type>internal</>时，通常聚集定义提供<firstterm>序列化函数</>和<firstterm>反序列化函数</>也是合适的，这两个函数允许这样一种状态值被从一个进程复制到另一个进程。如果没有这些函数就无法执行并行聚集，并且未来的本地/远程聚集之类的应用也可能无法工作。
  </para>

<!--==========================orignal english content==========================
  <para>
   A serialization function must take a single argument of
   type <type>internal</> and return a result of type <type>bytea</>, which
   represents the state value packaged up into a flat blob of bytes.
   Conversely, a deserialization function reverses that conversion.  It must
   take two arguments of types <type>bytea</> and <type>internal</>, and
   return a result of type <type>internal</>.  (The second argument is unused
   and is always zero, but it is required for type-safety reasons.)  The
   result of the deserialization function should simply be allocated in the
   current memory context, as unlike the combine function's result, it is not
   long-lived.
  </para>
____________________________________________________________________________-->
  <para>
   一个序列化函数必须接收一个单一的<type>internal</>类型参数并且返回一个<type>bytea</>类型的结果，它表示把状态值打包成一个平面化的字节串。反过来，反序列化函数是上述转换的逆变换。反序列化函数必须接收两个类型为<type>bytea</>和<type>internal</>的参数，并且返回类型为<type>internal</>的结果（第二个参数没有被使用并且总是为零，它的存在是由于类型安全性的原因）。反序列化函数的结果应该直接在当前内存上下文中分配，这与组合函数的结果不同，因为它不需要长期存在。
  </para>

<!--==========================orignal english content==========================
  <para>
   Worth noting also is that for an aggregate to be executed in parallel,
   the aggregate itself must be marked <literal>PARALLEL SAFE</>.  The
   parallel-safety markings on its support functions are not consulted.
  </para>
____________________________________________________________________________-->
  <para>
   还有一点值得提示的是关于要被并行执行的聚集，聚集本身必须被标记上<literal>PARALLEL SAFE</>。其支持函数上的并行安全性标记不会被参考。
  </para>

 </sect2>

 <sect2 id="xaggr-support-functions">
<!--==========================orignal english content==========================
  <title>Support Functions for Aggregates</title>
____________________________________________________________________________-->
  <title>聚集的支持函数</title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>aggregate function</primary>
   <secondary>support functions for</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>聚集函数</primary>
   <secondary>support functions for</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   A function written in C can detect that it is being called as an
   aggregate support function by calling
   <function>AggCheckCallContext</>, for example:
<programlisting>
if (AggCheckCallContext(fcinfo, NULL))
</programlisting>
   One reason for checking this is that when it is true for a transition
   function, the first input
   must be a temporary state value and can therefore safely be modified
   in-place rather than allocating a new copy.
   See <function>int8inc()</> for an example.
   (This is the <emphasis>only</>
   case where it is safe for a function to modify a pass-by-reference input.
   In particular, final functions for normal aggregates must not
   modify their inputs in any case, because in some cases they will be
   re-executed on the same final state value.)
  </para>
____________________________________________________________________________-->
  <para>
   用 C 编写的函数能够通过调用<function>AggCheckCallContext</>检测它是作为聚集支持函数调用的，例如：
<programlisting>
if (AggCheckCallContext(fcinfo, NULL))
</programlisting>
   检查这个区别的原因是当它为真（即一个转换函数）时，第一个输入必须是一个临时状态值并且可以因此安全地被就地修改而不是分配一个新的副本。例子可见<function>int8inc()</>（这是一个函数能够安全地修改一个传引用输入的<emphasis>唯一</>情况。特别地，任何情况下用于普通聚集的最终函数不能修改它们的输入，因为在某些情况下它们将会在相同的最终状态值上被重新执行）。
  </para>
<!--==========================orignal english content==========================
  <para>
   The second argument of <function>AggCheckCallContext</> can be used to
   retrieve the memory context in which aggregate state values are being kept.
   This is useful for transition functions that wish to use <quote>expanded</>
   objects (see <xref linkend="xtypes-toast">) as their state values.
   On first call, the transition function should return an expanded object
   whose memory context is a child of the aggregate state context, and then
   keep returning the same expanded object on subsequent calls.  See
   <function>array_append()</> for an example.  (<function>array_append()</>
   is not the transition function of any built-in aggregate, but it is written
   to behave efficiently when used as transition function of a custom
   aggregate.)
  </para>
____________________________________________________________________________-->
  <para>
   <function>AggCheckCallContext</>的第二个参数可以用来检索保存聚合状态值的内存上下文。
    这对于希望使用<quote>expanded</>对象（参见<xref linkend="xtypes-toast">）
	作为其状态值的转换函数很有用。在第一次调用时，转换函数应该返回一个扩展对象，
	其内存上下文是聚合状态上下文的子项，然后在随后的调用中保持返回相同的扩展对象。
	有关示例，请参阅<function>array_append()</>。
	（<function>array_append()</>不是任何内置聚合的转换函数，
	但是它被编写为在用作自定义聚合的转换函数时有效运行。）
  </para>

<!--==========================orignal english content==========================
  <para>
   Another support routine available to aggregate functions written in C
   is <function>AggGetAggref</>, which returns the <literal>Aggref</>
   parse node that defines the aggregate call.  This is mainly useful
   for ordered-set aggregates, which can inspect the substructure of
   the <literal>Aggref</> node to find out what sort ordering they are
   supposed to implement.  Examples can be found
   in <filename>orderedsetaggs.c</> in the <productname>PostgreSQL</>
   source code.
  </para>
____________________________________________________________________________-->
  <para>
   另一种可用于由 C 编写的聚集函数的支持例程是<function>AggGetAggref</>，它返回定义该聚集调用的<literal>Aggref</>解析节点。这主要对有序集聚集有用，它能检查<literal>Aggref</>的子结构来找出它们本应实现的排序顺序。在<productname>PostgreSQL</>源代码的<filename>orderedsetaggs.c</>中可以找到例子。
  </para>

 </sect2>
 </sect1>
