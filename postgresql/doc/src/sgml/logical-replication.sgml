<!-- doc/src/sgml/logical-replication.sgml -->

<chapter id="logical-replication">
<!--==========================orignal english content==========================
 <title>Logical Replication</title>
____________________________________________________________________________-->
 <title>逻辑复制</title>

<!--==========================orignal english content==========================
 <para>
  Logical replication is a method of replicating data objects and their
  changes, based upon their replication identity (usually a primary key).  We
  use the term logical in contrast to physical replication, which uses exact
  block addresses and byte-by-byte replication.  PostgreSQL supports both
  mechanisms concurrently, see <xref linkend="high-availability"/>.  Logical
  replication allows fine-grained control over both data replication and
  security.
 </para>
____________________________________________________________________________-->
 <para>
  逻辑复制是一种基于数据对象的复制标识（通常是主键）复制数据对象及其更改的方法。我们使用术语“逻辑”来与物理复制加以区分，后者使用准确的块地址以及逐字节的复制方式。PostgreSQL两种机制都支持，请见<xref linkend="high-availability"/>。逻辑复制允许在数据复制和安全性上更细粒度的控制。
 </para>

<!--==========================orignal english content==========================
 <para>
  Logical replication uses a <firstterm>publish</firstterm>
  and <firstterm>subscribe</firstterm> model with one or
  more <firstterm>subscribers</firstterm> subscribing to one or more
  <firstterm>publications</firstterm> on a <firstterm>publisher</firstterm>
  node.  Subscribers pull data from the publications they subscribe to and may
  subsequently re-publish data to allow cascading replication or more complex
  configurations.
 </para>
____________________________________________________________________________-->
 <para>
  逻辑复制使用一种<firstterm>发布</firstterm>和<firstterm>订阅</firstterm>模型，其中有一个或者更多<firstterm>订阅者</firstterm>订阅一个<firstterm>发布者</firstterm>节点上的一个或者更多<firstterm>发布</firstterm> 。订阅者从它们所订阅的发布拉取数据并且可能后续重新发布这些数据以允许级联复制或者更复杂的配置。
 </para>

<!--==========================orignal english content==========================
 <para>
  Logical replication of a table typically starts with taking a snapshot
  of the data on the publisher database and copying that to the subscriber.
  Once that is done, the changes on the publisher are sent to the subscriber
  as they occur in real-time.  The subscriber applies the data in the same
  order as the publisher so that transactional consistency is guaranteed for
  publications within a single subscription.  This method of data replication
  is sometimes referred to as transactional replication.
 </para>
____________________________________________________________________________-->
 <para>
  一个表的逻辑复制通常开始于对发布者服务器上的数据取得一个快照并且将快照拷贝给订阅者。一旦这项工作完成，发布者上的更改会被实时发送给订阅者。订阅者以与发布者相同的顺序应用那些数据，这样在一个订阅中能够保证发布的事务一致性。这种数据复制的方法有时候也被称为事务性复制。
 </para>

<!--==========================orignal english content==========================
 <para>
  The typical use-cases for logical replication are:

  <itemizedlist>
   <listitem>
    <para>
     Sending incremental changes in a single database or a subset of a
     database to subscribers as they occur.
    </para>
   </listitem>

   <listitem>
    <para>
     Firing triggers for individual changes as they arrive on the
     subscriber.
    </para>
   </listitem>

   <listitem>
    <para>
     Consolidating multiple databases into a single one (for example for
     analytical purposes).
    </para>
   </listitem>

   <listitem>
    <para>
     Replicating between different major versions of PostgreSQL.
    </para>
   </listitem>

   <listitem>
    <para>
     Replicating between PostgreSQL instances on different platforms (for
     example Linux to Windows)
    </para>
   </listitem>

   <listitem>
    <para>
     Giving access to replicated data to different groups of users.
    </para>
   </listitem>

   <listitem>
    <para>
     Sharing a subset of the database between multiple databases.
    </para>
   </listitem>
  </itemizedlist>
 </para>
____________________________________________________________________________-->
 <para>
  逻辑复制的典型用法是：

  <itemizedlist>
   <listitem>
    <para>
     在一个数据库或者一个数据库的子集中发生更改时，把增量的改变发送给订阅者。
    </para>
   </listitem>

   <listitem>
    <para>
     在更改到达订阅者时引发触发器。
    </para>
   </listitem>

   <listitem>
    <para>
     把多个数据库联合到单一数据库中（例如用于分析目的）。
    </para>
   </listitem>

   <listitem>
    <para>
     在PostgreSQL的不同主版本之间进行复制。
    </para>
   </listitem>

   <listitem>
    <para>
     在不同平台上（例如Linux到Windows）的PostgreSQL实例之间进行复制。
    </para>
   </listitem>

   <listitem>
    <para>
     将复制数据的访问给予不同的用户组。
    </para>
   </listitem>

   <listitem>
    <para>
     在多个数据库间共享数据库的一个子集。
    </para>
   </listitem>
  </itemizedlist>
 </para>

<!--==========================orignal english content==========================
 <para>
  The subscriber database behaves in the same way as any other PostgreSQL
  instance and can be used as a publisher for other databases by defining its
  own publications.  When the subscriber is treated as read-only by
  application, there will be no conflicts from a single subscription.  On the
  other hand, if there are other writes done either by an application or by other
  subscribers to the same set of tables, conflicts can arise.
 </para>
____________________________________________________________________________-->
 <para>
  订阅者数据库的行为与任何其他PostgreSQL实例相同，并且可以被用作其他数据库的发布者，只需要定义它自己的发布。当订阅者被应用当作只读时，单一的订阅中不会有冲突。在另一方面，如果应用或者对相同表集合的订阅者执行了其他的写动作，冲突可能会发生。
 </para>

 <sect1 id="logical-replication-publication">
<!--==========================orignal english content==========================
  <title>Publication</title>
____________________________________________________________________________-->
  <title>发布</title>

<!--==========================orignal english content==========================
  <para>
   A <firstterm>publication</firstterm> can be defined on any physical
   replication master.  The node where a publication is defined is referred to
   as <firstterm>publisher</firstterm>.  A publication is a set of changes
   generated from a table or a group of tables, and might also be described as
   a change set or replication set.  Each publication exists in only one database.
  </para>
____________________________________________________________________________-->
  <para>
   <firstterm>发布</firstterm>可以被定义在任何物理复制的主服务器上。定义有发布的节点被称为<firstterm>发布者</firstterm>。发布是从一个表或者一组表生成的改变的集合，也可以被描述为更改集合或者复制集合。每个发布都只存在于一个数据库中。
  </para>

<!--==========================orignal english content==========================
  <para>
   Publications are different from schemas and do not affect how the table is
   accessed.  Each table can be added to multiple publications if needed.
   Publications may currently only contain tables.  Objects must be added
   explicitly, except when a publication is created for <literal>ALL
   TABLES</literal>.
  </para>
____________________________________________________________________________-->
  <para>
   发布与模式不同，不会影响表的访问方式。如果需要，每个表都可以被加入到多个发布。当前，发布只能包含表。对象必须被明确地加入到发布，除非发布是用<literal>ALL TABLES</literal>创建的。
  </para>

<!--==========================orignal english content==========================
  <para>
   Publications can choose to limit the changes they produce to
   any combination of <command>INSERT</command>, <command>UPDATE</command>,
   <command>DELETE</command>, and <command>TRUNCATE</command>, similar to how triggers are fired by
   particular event types.  By default, all operation types are replicated.
  </para>
____________________________________________________________________________-->
  <para>
   Publication可以选择把它们产生的更改限制为<command>INSERT</command>、<command>UPDATE</command>、<command>DELETE</command>以及<command>TRUNCATE</command>的任意组合，类似于触发器如何被特定事件类型触发的方式。默认情况下，所有操作类型都会被复制。
  </para>

<!--==========================orignal english content==========================
  <para>
   A published table must have a <quote>replica identity</quote> configured in
   order to be able to replicate <command>UPDATE</command>
   and <command>DELETE</command> operations, so that appropriate rows to
   update or delete can be identified on the subscriber side.  By default,
   this is the primary key, if there is one.  Another unique index (with
   certain additional requirements) can also be set to be the replica
   identity.  If the table does not have any suitable key, then it can be set
   to replica identity <quote>full</quote>, which means the entire row becomes
   the key.  This, however, is very inefficient and should only be used as a
   fallback if no other solution is possible.  If a replica identity other
   than <quote>full</quote> is set on the publisher side, a replica identity
   comprising the same or fewer columns must also be set on the subscriber
   side.  See <xref linkend="sql-createtable-replica-identity"/> for details on
   how to set the replica identity.  If a table without a replica identity is
   added to a publication that replicates <command>UPDATE</command>
   or <command>DELETE</command> operations then
   subsequent <command>UPDATE</command> or <command>DELETE</command>
   operations will cause an error on the publisher.  <command>INSERT</command>
   operations can proceed regardless of any replica identity.
  </para>
____________________________________________________________________________-->
  <para>
   为了能够复制<command>UPDATE</command>和<command>DELETE</command>操作，被发布的表必须配置有一个<quote>复制标识</quote>，这样在订阅者那一端才能标识对于更新或删除合适的行。默认情况下，复制标识就是主键（如果有主键）。也可以在复制标识上设置另一个唯一索引（有特定的额外要求）。如果表没有合适的键，那么可以设置成复制标识<quote>full</quote>，它表示整个行都成为那个键。不过，这样做效率很低，只有在没有其他方案的情况下才应该使用。如果在发布者端设置了<quote>full</quote>之外的复制标识，在订阅者端也必须设置一个复制标识，它应该由相同的或者少一些的列组成。如何设置复制标识的细节请参考<xref linkend="sql-createtable-replica-identity"/>。如果在复制<command>UPDATE</command>或<command>DELETE</command>操作的发布中加入了没有复制标识的表，那么订阅者上后续的<command>UPDATE</command>或<command>DELETE</command>操作将导致错误。不管有没有复制标识，<command>INSERT</command>操作都能继续下去。
  </para>

<!--==========================orignal english content==========================
  <para>
   Every publication can have multiple subscribers.
  </para>
____________________________________________________________________________-->
  <para>
   每一个发布都可以由多个订阅者。
  </para>

<!--==========================orignal english content==========================
  <para>
   A publication is created using the <xref linkend="sql-createpublication"/>
   command and may later be altered or dropped using corresponding commands.
  </para>
____________________________________________________________________________-->
  <para>
   Publication通过使用<xref linkend="sql-createpublication"/>命令创建并且可以在之后使用相应的命令进行修改或者删除。
  </para>

<!--==========================orignal english content==========================
  <para>
   The individual tables can be added and removed dynamically using
   <xref linkend="sql-alterpublication"/>.  Both the <literal>ADD
   TABLE</literal> and <literal>DROP TABLE</literal> operations are
   transactional; so the table will start or stop replicating at the correct
   snapshot once the transaction has committed.
  </para>
____________________________________________________________________________-->
  <para>
   表可以使用<xref linkend="sql-alterpublication"/>动态地增加或者移除。<literal>ADD TABLE</literal>以及<literal>DROP TABLE</literal>操作都是事务性的，因此一旦该事务提交，该表将以正确的快照开始或者停止复制。
  </para>
 </sect1>

 <sect1 id="logical-replication-subscription">
<!--==========================orignal english content==========================
  <title>Subscription</title>
____________________________________________________________________________-->
  <title>订阅</title>

<!--==========================orignal english content==========================
  <para>
   A <firstterm>subscription</firstterm> is the downstream side of logical
   replication.  The node where a subscription is defined is referred to as
   the <firstterm>subscriber</firstterm>.  A subscription defines the connection
   to another database and set of publications (one or more) to which it wants
   to subscribe.
  </para>
____________________________________________________________________________-->
  <para>
   <firstterm>订阅</firstterm>是逻辑复制的下游端。订阅被定义在其中的节点被称为<firstterm>订阅者</firstterm>。一个订阅会定义到另一个数据库的连接以及它想要订阅的发布集合（一个或者多个）。
  </para>

<!--==========================orignal english content==========================
  <para>
   The subscriber database behaves in the same way as any other PostgreSQL
   instance and can be used as a publisher for other databases by defining its
   own publications.
  </para>
____________________________________________________________________________-->
  <para>
   订阅者数据库的行为与任何其他PostgreSQL实例相同，并且可以被用作其他数据库的发布者，只需要定义它自己的发布。
  </para>

<!--==========================orignal english content==========================
  <para>
   A subscriber node may have multiple subscriptions if desired.  It is
   possible to define multiple subscriptions between a single
   publisher-subscriber pair, in which case care must be taken to ensure
   that the subscribed publication objects don't overlap.
  </para>
____________________________________________________________________________-->
  <para>
   如果需要，一个订阅者节点可以有多个订阅。可以在一对发布者-订阅者之间定义多个订阅，在这种情况下要确保被订阅的发布对象不会重叠。
  </para>

<!--==========================orignal english content==========================
  <para>
   Each subscription will receive changes via one replication slot (see
   <xref linkend="streaming-replication-slots"/>).  Additional temporary
   replication slots may be required for the initial data synchronization
   of pre-existing table data.
  </para>
____________________________________________________________________________-->
  <para>
   每一个订阅都将通过一个复制槽（见<xref linkend="streaming-replication-slots"/>）接收更改。预先存在的表数据的初始数据同步过程可能会要求额外的临时复制槽。
  </para>

<!--==========================orignal english content==========================
  <para>
   A logical replication subscription can be a standby for synchronous
   replication (see <xref linkend="synchronous-replication"/>).  The standby
   name is by default the subscription name.  An alternative name can be
   specified as <literal>application_name</literal> in the connection
   information of the subscription.
  </para>
____________________________________________________________________________-->
  <para>
   逻辑复制订阅可以是同步复制（见<xref linkend="synchronous-replication"/>）的后备服务器。后备名称默认是该订阅的名称。可以在订阅的连接信息中用<literal>application_name</literal>指定一个可供选择的名称。
  </para>

<!--==========================orignal english content==========================
  <para>
   Subscriptions are dumped by <command>pg_dump</command> if the current user
   is a superuser.  Otherwise a warning is written and subscriptions are
   skipped, because non-superusers cannot read all subscription information
   from the <structname>pg_subscription</structname> catalog.
  </para>
____________________________________________________________________________-->
  <para>
   如果当前用户是一个超级用户，则订阅会被<command>pg_dump</command>转储。否则订阅会被跳过并且写出一个警告，因为非超级用户不能从<structname>pg_subscription</structname>目录中读取所有的订阅信息。
  </para>

<!--==========================orignal english content==========================
  <para>
   The subscription is added using <xref linkend="sql-createsubscription"/> and
   can be stopped/resumed at any time using the
   <xref linkend="sql-altersubscription"/> command and removed using
   <xref linkend="sql-dropsubscription"/>.
  </para>
____________________________________________________________________________-->
  <para>
   可以使用<xref linkend="sql-createsubscription"/>增加订阅，并且使用<xref linkend="sql-altersubscription"/>在任何时刻停止/继续订阅，还可以使用<xref linkend="sql-dropsubscription"/>删除订阅。
  </para>

<!--==========================orignal english content==========================
  <para>
   When a subscription is dropped and recreated, the synchronization
   information is lost.  This means that the data has to be resynchronized
   afterwards.
  </para>
____________________________________________________________________________-->
  <para>
   在一个订阅被删除并且重建时，同步信息会丢失。这意味着数据必须被重新同步。
  </para>

<!--==========================orignal english content==========================
  <para>
   The schema definitions are not replicated, and the published tables must
   exist on the subscriber.  Only regular tables may be
   the target of replication.  For example, you can't replicate to a view.
  </para>
____________________________________________________________________________-->
  <para>
   模式定义不会被复制，并且被发布的表必须在订阅者上存在。只有常规表可以成为复制的目标。例如，不能复制视图。
  </para>

<!--==========================orignal english content==========================
  <para>
   The tables are matched between the publisher and the subscriber using the
   fully qualified table name.  Replication to differently-named tables on the
   subscriber is not supported.
  </para>
____________________________________________________________________________-->
  <para>
   表在发布者和订阅者之间使用完全限定的表名进行匹配。不支持复制到订阅者上命名不同的表。
  </para>

<!--==========================orignal english content==========================
  <para>
   Columns of a table are also matched by name.  The order of columns in the
   subscriber table does not need to match that of the publisher.  The data
   types of the columns do not need to match, as long as the text
   representation of the data can be converted to the target type.  For
   example, you can replicate from a column of type <type>integer</type> to a
   column of type <type>bigint</type>.  The target table can also have
   additional columns not provided by the published table.  Any such columns
   will be filled with the default value as specified in the definition of the
   target table.
  </para>
____________________________________________________________________________-->
  <para>
   表的列也通过名称匹配。订阅表中的列顺序不需要与发布表中的顺序一样。
   列的数据类型也不需要一样，只要可以将数据的文本表示形式转换为目标类型即可。
   例如，您可以从<type>integer</type>类型的列复制到<type>bigint</type>类型的列。
   目标表还可以具有发布表中不存在的额外列。额外列都将使用目标表的定义中指定的默认值填充。
  </para>

  <sect2 id="logical-replication-subscription-slot">
<!--==========================orignal english content==========================
   <title>Replication Slot Management</title>
____________________________________________________________________________-->
   <title>复制槽管理</title>

<!--==========================orignal english content==========================
   <para>
    As mentioned earlier, each (active) subscription receives changes from a
    replication slot on the remote (publishing) side.  Normally, the remote
    replication slot is created automatically when the subscription is created
    using <command>CREATE SUBSCRIPTION</command> and it is dropped
    automatically when the subscription is dropped using <command>DROP
    SUBSCRIPTION</command>.  In some situations, however, it can be useful or
    necessary to manipulate the subscription and the underlying replication
    slot separately.  Here are some scenarios:

    <itemizedlist>
     <listitem>
      <para>
       When creating a subscription, the replication slot already exists.  In
       that case, the subscription can be created using
       the <literal>create_slot = false</literal> option to associate with the
       existing slot.
      </para>
     </listitem>

     <listitem>
      <para>
       When creating a subscription, the remote host is not reachable or in an
       unclear state.  In that case, the subscription can be created using
       the <literal>connect = false</literal> option.  The remote host will then not
       be contacted at all.  This is what <application>pg_dump</application>
       uses.  The remote replication slot will then have to be created
       manually before the subscription can be activated.
      </para>
     </listitem>

     <listitem>
      <para>
       When dropping a subscription, the replication slot should be kept.
       This could be useful when the subscriber database is being moved to a
       different host and will be activated from there.  In that case,
       disassociate the slot from the subscription using <command>ALTER
       SUBSCRIPTION</command> before attempting to drop the subscription.
      </para>
     </listitem>

     <listitem>
      <para>
       When dropping a subscription, the remote host is not reachable.  In
       that case, disassociate the slot from the subscription
       using <command>ALTER SUBSCRIPTION</command> before attempting to drop
       the subscription.  If the remote database instance no longer exists, no
       further action is then necessary.  If, however, the remote database
       instance is just unreachable, the replication slot should then be
       dropped manually; otherwise it would continue to reserve WAL and might
       eventually cause the disk to fill up.  Such cases should be carefully
       investigated.
      </para>
     </listitem>
    </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    如早前所提到的，每一个（活跃的）订阅会从远（发布）端上的一个复制槽接收更改。通常，远程复制槽是在使用<command>CREATE SUBSCRIPTION</command>创建订阅是自动创建的，并且在使用<command>DROP SUBSCRIPTION</command>删除订阅时，复制槽也会自动被删除。不过，在一些情况下，有必要单独操纵订阅以及其底层的复制槽。下面是一些场景：

    <itemizedlist>
     <listitem>
      <para>
       在创建一个订阅时，复制槽已经存在。在这种情况下，可以使用<literal>create_slot = false</literal>选项创建订阅并关联到现有的槽。
      </para>
     </listitem>

     <listitem>
      <para>
       在创建一个订阅时，远程主机不可达或者处于一种不明状态。在这种情况下，可以使用<literal>connect = false</literal>选项创建订阅。那么远程主机将根本不会被联系。这是<application>pg_dump</application>所使用的方式。这样，在订阅可以被激活之前，必须手工创建远程复制槽。
      </para>
     </listitem>

     <listitem>
      <para>
       在删除一个订阅时，复制槽应该被保留。当订阅者数据库正在被移动到一台不同的主机并且将从那里再被激活时，这种行为很有用。在这种情况下，可以在尝试删除该订阅之前，使用<command>ALTER SUBSCRIPTION</command>将复制槽解除关联。
      </para>
     </listitem>

     <listitem>
      <para>
       在删除一个订阅是，远程主机不可达。在这种情况下，可以在尝试删除该订阅之前，使用<command>ALTER SUBSCRIPTION</command>将复制槽解除关联。如果远程数据库实例不再存在，那么不需要进一步的行动。不过，如果远程数据库实例只是不可达，那么复制槽应该被手动删除。否则它将会继续保留WAL并且最终可能会导致磁盘被填满。这种情况应该要仔细地研究。
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </sect2>
 </sect1>

 <sect1 id="logical-replication-conflicts">
<!--==========================orignal english content==========================
  <title>Conflicts</title>
____________________________________________________________________________-->
  <title>冲突</title>

<!--==========================orignal english content==========================
  <para>
   Logical replication behaves similarly to normal DML operations in that
   the data will be updated even if it was changed locally on the subscriber
   node.  If incoming data violates any constraints the replication will
   stop.  This is referred to as a <firstterm>conflict</firstterm>.  When
   replicating <command>UPDATE</command> or <command>DELETE</command>
   operations, missing data will not produce a conflict and such operations
   will simply be skipped.
  </para>
____________________________________________________________________________-->
  <para>
   逻辑复制的行为类似于正常的DML操作，即便数据在订阅者节点本地被修改，逻辑复制也会根据收到的更改来更新数据。如果流入的数据违背了任何约束，复制将停止。这种情况被称为一个<firstterm>冲突</firstterm>。在复制<command>UPDATE</command>或<command>DELETE</command>操作时，缺失的数据将不会产生冲突并且这类操作将被简单地跳过。
  </para>

<!--==========================orignal english content==========================
  <para>
   A conflict will produce an error and will stop the replication; it must be
   resolved manually by the user.  Details about the conflict can be found in
   the subscriber's server log.
  </para>
____________________________________________________________________________-->
  <para>
   冲突将会产生错误并且停止复制，它必须由用户手工解决。在订阅者的服务器日志中可以找到有关冲突的详细情况。
  </para>

<!--==========================orignal english content==========================
  <para>
   The resolution can be done either by changing data on the subscriber so
   that it does not conflict with the incoming change or by skipping the
   transaction that conflicts with the existing data.  The transaction can be
   skipped by calling the <link linkend="pg-replication-origin-advance">
   <function>pg_replication_origin_advance()</function></link> function with
   a <parameter>node_name</parameter> corresponding to the subscription name,
   and a position.  The current position of origins can be seen in the
   <link linkend="view-pg-replication-origin-status">
   <structname>pg_replication_origin_status</structname></link> system view.
  </para>
____________________________________________________________________________-->
  <para>
   通过更改订阅者上的数据（这样它就不会与到来的数据发生冲突）或者跳过与已有数据冲突的事务可以解决这种冲突。通过调用<link linkend="pg-replication-origin-advance"><function>pg_replication_origin_advance()</function></link>函数可以跳过该事务，函数的参数是对应于该订阅名称的<parameter>node_name</parameter>以及一个位置。复制源头的当前位置可以在<link linkend="view-pg-replication-origin-status"><structname>pg_replication_origin_status</structname></link>系统视图中看到。
  </para>
 </sect1>

 <sect1 id="logical-replication-restrictions">
<!--==========================orignal english content==========================
  <title>Restrictions</title>
____________________________________________________________________________-->
  <title>限制</title>

<!--==========================orignal english content==========================
  <para>
   Logical replication currently has the following restrictions or missing
   functionality.  These might be addressed in future releases.
  </para>
____________________________________________________________________________-->
  <para>
   逻辑复制当前有下列限制或者缺失的功能。这些可能在未来的发行中解决。
  </para>

  <itemizedlist>
   <listitem>
<!--==========================orignal english content==========================
    <para>
     The database schema and DDL commands are not replicated.  The initial
     schema can be copied by hand using <literal>pg_dump
     -&minus;schema-only</literal>.  Subsequent schema changes would need to be kept
     in sync manually.  (Note, however, that there is no need for the schemas
     to be absolutely the same on both sides.)  Logical replication is robust
     when schema definitions change in a live database: When the schema is
     changed on the publisher and replicated data starts arriving at the
     subscriber but does not fit into the table schema, replication will error
     until the schema is updated.  In many cases, intermittent errors can be
     avoided by applying additive schema changes to the subscriber first.
    </para>
____________________________________________________________________________-->
    <para>
     数据库模式和DDL命令不会被复制。初始模式可以手工使用<literal>pg_dump --schema-only</literal>进行拷贝。后续的模式改变需要手工保持同步（不过值得注意的是，模式其实不需要在两端保持绝对相同）。当一个活跃的数据库中模式定义改变时，逻辑复制是鲁棒的：当模式在发布者上发生改变并且被复制的数据开始到达订阅者但却不适合表模式时，复制将报错，直至模式被更新。在很多情况下，可以通过先对订阅者应用额外的模式更改来避免间歇性的错误。
    </para>
   </listitem>

   <listitem>
<!--==========================orignal english content==========================
    <para>
     Sequence data is not replicated.  The data in serial or identity columns
     backed by sequences will of course be replicated as part of the table,
     but the sequence itself would still show the start value on the
     subscriber.  If the subscriber is used as a read-only database, then this
     should typically not be a problem.  If, however, some kind of switchover
     or failover to the subscriber database is intended, then the sequences
     would need to be updated to the latest values, either by copying the
     current data from the publisher (perhaps
     using <command>pg_dump</command>) or by determining a sufficiently high
     value from the tables themselves.
    </para>
____________________________________________________________________________-->
    <para>
     序列数据不被复制。后台由序列支撑的serial或者标识列中的数据当然将被作为表的一部分复制，但是序列本身在订阅者上仍将显示开始值。如果订阅者被用作一个只读数据库，那么这通常不会是什么问题。不过，如果订阅者数据库预期有某种转换或者容错，那么序列需要被更新到最后的值，要么通过从发布者拷贝当前数据的防范（也许使用<command>pg_dump</command>），要么从表本身决定一个足够高的值。
    </para>
   </listitem>

   <listitem>
<!--==========================orignal english content==========================
    <para>
     Replication of <command>TRUNCATE</command> commands is supported, but
     some care must be taken when truncating groups of tables connected by
     foreign keys.  When replicating a truncate action, the subscriber will
     truncate the same group of tables that was truncated on the publisher,
     either explicitly specified or implicitly collected via
     <literal>CASCADE</literal>, minus tables that are not part of the
     subscription.  This will work correctly if all affected tables are part
     of the same subscription.  But if some tables to be truncated on the
     subscriber have foreign-key links to tables that are not part of the same
     (or any) subscription, then the application of the truncate action on the
     subscriber will fail.
    </para>
____________________________________________________________________________-->
    <para>
     支持<command>TRUNCATE</command>命令的复制，但是在截断由外键连接在一起的表群体时必须要小心。在复制截断动作时，订阅者将截断与发布者上被截断的相同的表群体，这些表或者被明确指定或者通过<literal>CASCADE</literal>隐含地收集而来，然后还要减去不属于该订阅的表。如果所有受影响的表都属于同一个订阅，这会正确地工作。但是如果订阅者上要被截断的某些表有外键链接到不属于同一订阅的表，那么在订阅者上该截断动作的应用将会失败。
    </para>
   </listitem>

   <listitem>
<!--==========================orignal english content==========================
    <para>
     Large objects (see <xref linkend="largeobjects"/>) are not replicated.
     There is no workaround for that, other than storing data in normal
     tables.
    </para>
____________________________________________________________________________-->
    <para>
     大对象（见<xref linkend="largeobjects"/>）不会被复制。没有办法可以解决这个问题，除非把数据存储在普通表中。
    </para>
   </listitem>

   <listitem>
<!--==========================orignal english content==========================
    <para>
     Replication is only possible from base tables to base tables.  That is,
     the tables on the publication and on the subscription side must be normal
     tables, not views, materialized views, partition root tables, or foreign
     tables.  In the case of partitions, you can therefore replicate a
     partition hierarchy one-to-one, but you cannot currently replicate to a
     differently partitioned setup.  Attempts to replicate tables other than
     base tables will result in an error.
    </para>
____________________________________________________________________________-->
    <para>
     复制只能从基表到基表。也就是说，发布端和订阅端上的表都必须是普通表，而不是视图、物化视图、分区根表或者外部表。如果是分区，可以一一对应地复制分区层次，但当前不能复制成一种不同的分区设置。尝试复制不是基表的表将会导致错误。
    </para>
   </listitem>
  </itemizedlist>
 </sect1>

 <sect1 id="logical-replication-architecture">
<!--==========================orignal english content==========================
  <title>Architecture</title>
____________________________________________________________________________-->
  <title>架构</title>

<!--==========================orignal english content==========================
  <para>
   Logical replication starts by copying a snapshot of the data on the
   publisher database.  Once that is done, changes on the publisher are sent
   to the subscriber as they occur in real time.  The subscriber applies data
   in the order in which commits were made on the publisher so that
   transactional consistency is guaranteed for the publications within any
   single subscription.
  </para>
____________________________________________________________________________-->
  <para>
   逻辑复制从拷贝发布者数据库上的数据库快照开始。拷贝一旦完成，发布者上的更改会在它们发生时实时传送给订阅者。订阅者按照数据在发布者上被提交的顺序应用数据，这样任意单一订阅中的发布的事务一致性才能得到保证。
  </para>

<!--==========================orignal english content==========================
  <para>
   Logical replication is built with an architecture similar to physical
   streaming replication (see <xref linkend="streaming-replication"/>).  It is
   implemented by <quote>walsender</quote> and <quote>apply</quote>
   processes.  The walsender process starts logical decoding (described
   in <xref linkend="logicaldecoding"/>) of the WAL and loads the standard
   logical decoding plugin (pgoutput).  The plugin transforms the changes read
   from WAL to the logical replication protocol
   (see <xref linkend="protocol-logical-replication"/>) and filters the data
   according to the publication specification.  The data is then continuously
   transferred using the streaming replication protocol to the apply worker,
   which maps the data to local tables and applies the individual changes as
   they are received, in correct transactional order.
  </para>
____________________________________________________________________________-->
  <para>
   逻辑复制被构建在一种类似于物理流复制（见<xref linkend="streaming-replication"/>）的架构上。它由<quote>walsender</quote>和<quote>apply</quote>进程实现。walsender进程开始对WAL的逻辑解码（在<xref linkend="logicaldecoding"/>中描述）并且载入标准逻辑解码插件（pgoutput）。该插件把从WAL中读取的更改转换成逻辑复制协议（见<xref linkend="protocol-logical-replication"/>）并且根据发布说明过滤数据。然后数据会被连续地使用流复制协议传输到应用工作者，应用工作者会把数据映射到本地表并且以正确的事务顺序应用它们接收到的更改。
  </para>

<!--==========================orignal english content==========================
  <para>
   The apply process on the subscriber database always runs with
   <varname>session_replication_role</varname> set
   to <literal>replica</literal>, which produces the usual effects on triggers
   and constraints.
  </para>
____________________________________________________________________________-->
  <para>
   订阅者数据库上的应用进程总是将<varname>session_replication_role</varname>设置为<literal>replica</literal>运行，这会产生触发器和约束上通常的效果。
  </para>

<!--==========================orignal english content==========================
  <para>
   The logical replication apply process currently only fires row triggers,
   not statement triggers.  The initial table synchronization, however, is
   implemented like a <command>COPY</command> command and thus fires both row
   and statement triggers for <command>INSERT</command>.
  </para>
____________________________________________________________________________-->
  <para>
   逻辑复制应用进程当前仅会引发行触发器，而不会引发语句触发器。不过，初始的表同步是以类似一个<command>COPY</command>命令的方式实现的，因此会引发<command>INSERT</command>的行触发器和语句触发器。
  </para>

  <sect2 id="logical-replication-snapshot">
<!--==========================orignal english content==========================
    <title>Initial Snapshot</title>
____________________________________________________________________________-->
    <title>初始快照</title>
<!--==========================orignal english content==========================
    <para>
      The initial data in existing subscribed tables are snapshotted and
      copied in a parallel instance of a special kind of apply process.
      This process will create its own temporary replication slot and
      copy the existing data. Once existing data is copied, the worker
      enters synchronization mode, which ensures that the table is brought
      up to a synchronized state with the main apply process by streaming
      any changes that happened during the initial data copy using standard
      logical replication. Once the synchronization is done, the control
      of the replication of the table is given back to the main apply
      process where the replication continues as normal.
    </para>
____________________________________________________________________________-->
    <para>
      已有的被订阅表中的初始数据会被快照并且以一种特殊类型的应用进程的并行实例进行拷贝。这种进程将创建自己的临时复制槽并且拷贝现有的数据。一旦现有的数据被拷贝完，工作者会进入到同步模式，主应用进程会流式传递在使用标准逻辑复制拷贝初始数据期间发生的任意改变，这会确保表被带到一种已同步的状态。一旦同步完成，该表的复制的控制权会被交回给主应用进程，其中复制会照常继续。
    </para>
  </sect2>
 </sect1>

 <sect1 id="logical-replication-monitoring">
<!--==========================orignal english content==========================
  <title>Monitoring</title>
____________________________________________________________________________-->
  <title>监控</title>

<!--==========================orignal english content==========================
  <para>
   Because logical replication is based on a similar architecture as
   <link linkend="streaming-replication">physical streaming replication</link>,
   the monitoring on a publication node is similar to monitoring of a
   physical replication master
   (see <xref linkend="streaming-replication-monitoring"/>).
  </para>
____________________________________________________________________________-->
  <para>
   因为逻辑复制是基于与<link linkend="streaming-replication">物理流复制</link>相似的架构的，一个发布节点上的监控也类似于对物理复制主节点（见<xref linkend="streaming-replication-monitoring"/>）的监控。
  </para>

<!--==========================orignal english content==========================
  <para>
   The monitoring information about subscription is visible in
   <link linkend="pg-stat-subscription"><literal>pg_stat_subscription</literal></link>.
   This view contains one row for every subscription worker.  A subscription
   can have zero or more active subscription workers depending on its state.
  </para>
____________________________________________________________________________-->
  <para>
   有关订阅的监控信息在<link linkend="pg-stat-subscription"><literal>pg_stat_subscription</literal></link>中可以看到。每一个订阅工作者在这个视图都有一行。一个订阅能有零个或者多个活跃订阅工作者取决于它的状态。
  </para>

<!--==========================orignal english content==========================
  <para>
   Normally, there is a single apply process running for an enabled
   subscription.  A disabled subscription or a crashed subscription will have
   zero rows in this view.  If the initial data synchronization of any
   table is in progress, there will be additional workers for the tables
   being synchronized.
  </para>
____________________________________________________________________________-->
  <para>
   通常，对于一个已启用的订阅会有单一的应用进程运行。一个被禁用的订阅或者崩溃的订阅在这个视图中不会有行存在。如果有任何表的数据同步正在进行，对正在被同步的表会有额外的工作者。
  </para>
 </sect1>

 <sect1 id="logical-replication-security">
<!--==========================orignal english content==========================
  <title>Security</title>
____________________________________________________________________________-->
  <title>安全性</title>

<!--==========================orignal english content==========================
  <para>
   The role used for the replication connection must have
   the <literal>REPLICATION</literal> attribute (or be a superuser).  Access for the role must be
   configured in <filename>pg_hba.conf</filename> and it must have the
   <literal>LOGIN</literal> attribute.
  </para>
____________________________________________________________________________-->
  <para>
   用于复制连接的角色必须有<literal>REPLICATION</literal>属性（或者是一个超级用户）。该角色的访问必须被配置在<filename>pg_hba.conf</filename>中，并且它必须有<literal>LOGIN</literal>属性。
  </para>

<!--==========================orignal english content==========================
  <para>
   In order to be able to copy the initial table data, the role used for the
   replication connection must have the <literal>SELECT</literal> privilege on
   a published table (or be a superuser).
  </para>
____________________________________________________________________________-->
  <para>
   为了能够拷贝初始表数据，用于复制连接的角色必须在被发布的表上具有<literal>SELECT</literal>特权（或者是一个超级用户）。
  </para>

<!--==========================orignal english content==========================
  <para>
   To create a publication, the user must have the <literal>CREATE</literal>
   privilege in the database.
  </para>
____________________________________________________________________________-->
  <para>
   要创建发布，用户必须在数据库中有<literal>CREATE</literal>特权。
  </para>

<!--==========================orignal english content==========================
  <para>
   To add tables to a publication, the user must have ownership rights on the
   table.  To create a publication that publishes all tables automatically,
   the user must be a superuser.
  </para>
____________________________________________________________________________-->
  <para>
   要把表加入到一个发布，用户必须在该表上有拥有权。要创建一个自动发布所有表的发布，用户必须是一个超级用户。
  </para>

<!--==========================orignal english content==========================
  <para>
   To create a subscription, the user must be a superuser.
  </para>
____________________________________________________________________________-->
  <para>
   要创建订阅，用户必须是一个超级用户。
  </para>

<!--==========================orignal english content==========================
  <para>
   The subscription apply process will run in the local database with the
   privileges of a superuser.
  </para>
____________________________________________________________________________-->
  <para>
   订阅的应用过程将在本地数据库上以超级用户的特权运行。
  </para>

<!--==========================orignal english content==========================
  <para>
   Privileges are only checked once at the start of a replication connection.
   They are not re-checked as each change record is read from the publisher,
   nor are they re-checked for each change when applied.
  </para>
____________________________________________________________________________-->
  <para>
   特权检查仅在复制连接开始时被执行一次。在从发布者读到每一个更改记录时不会重新检查特权，在每一个更改被应用时也不会重新检查特权。
  </para>
 </sect1>

 <sect1 id="logical-replication-config">
<!--==========================orignal english content==========================
  <title>Configuration Settings</title>
____________________________________________________________________________-->
  <title>配置设置</title>

<!--==========================orignal english content==========================
  <para>
   Logical replication requires several configuration options to be set.
  </para>
____________________________________________________________________________-->
  <para>
   逻辑复制要求设置一些配置选项。
  </para>

<!--==========================orignal english content==========================
  <para>
   On the publisher side, <varname>wal_level</varname> must be set to
   <literal>logical</literal>, and <varname>max_replication_slots</varname>
   must be set to at least the number of subscriptions expected to connect,
   plus some reserve for table synchronization.  And
   <varname>max_wal_senders</varname> should be set to at least the same as
   <varname>max_replication_slots</varname> plus the number of physical
   replicas that are connected at the same time.
  </para>
____________________________________________________________________________-->
  <para>
   在发布者端，<varname>wal_level</varname>必须被设置为<literal>logical</literal>，而<varname>max_replication_slots</varname>中设置的值必须至少是预期要连接的订阅数加上保留给表同步的连接数。<varname>max_wal_senders</varname>应该至少被设置为<varname>max_replication_slots</varname>加上同时连接的物理复制体的数量。
  </para>

<!--==========================orignal english content==========================
  <para>
   The subscriber also requires the <varname>max_replication_slots</varname>
   to be set.  In this case it should be set to at least the number of
   subscriptions that will be added to the subscriber.
   <varname>max_logical_replication_workers</varname> must be set to at
   least the number of subscriptions, again plus some reserve for the table
   synchronization.  Additionally the <varname>max_worker_processes</varname>
   may need to be adjusted to accommodate for replication workers, at least
   (<varname>max_logical_replication_workers</varname>
   + <literal>1</literal>).  Note that some extensions and parallel queries
   also take worker slots from <varname>max_worker_processes</varname>.
  </para>
____________________________________________________________________________-->
  <para>
   订阅者还要求<varname>max_replication_slots</varname>被设置。在这种情况下，它必须至少被设置为将被加入到该订阅者的订阅数。<varname>max_logical_replication_workers</varname>必须至少被设置为订阅数加上保留给表同步的连接数。此外，可能需要调整<varname>max_worker_processes</varname>以容纳复制工作者，至少为(<varname>max_logical_replication_workers</varname> + <literal>1</literal>)。注意，一些扩展和并行查询也会从<varname>max_worker_processes</varname>中取得工作者槽。
  </para>
 </sect1>

 <sect1 id="logical-replication-quick-setup">
<!--==========================orignal english content==========================
  <title>Quick Setup</title>
____________________________________________________________________________-->
  <title>快速设置</title>

<!--==========================orignal english content==========================
  <para>
   First set the configuration options in <filename>postgresql.conf</filename>:
<programlisting>
wal_level = logical
</programlisting>
   The other required settings have default values that are sufficient for a
   basic setup.
  </para>
____________________________________________________________________________-->
  <para>
   首先在<filename>postgresql.conf</filename>中设置配置选项：
<programlisting>
wal_level = logical
</programlisting>
   对于一个基础设置来说，其他所需的设置使用默认值就足够了。
  </para>

<!--==========================orignal english content==========================
  <para>
   <filename>pg_hba.conf</filename> needs to be adjusted to allow replication
   (the values here depend on your actual network configuration and user you
   want to use for connecting):
<programlisting>
host     all     repuser     0.0.0.0/0     md5
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   需要调整<filename>pg_hba.conf</filename>以允许复制（这里的值取决于实际的网络配置以及用于连接的用户）：
<programlisting>
host     all     repuser     0.0.0.0/0     md5
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Then on the publisher database:
<programlisting>
CREATE PUBLICATION mypub FOR TABLE users, departments;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   然后在发布者数据库上：
<programlisting>
CREATE PUBLICATION mypub FOR TABLE users, departments;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   And on the subscriber database:
<programlisting>
CREATE SUBSCRIPTION mysub CONNECTION 'dbname=foo host=bar user=repuser' PUBLICATION mypub;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   并且在订阅者数据库上：
<programlisting>
CREATE SUBSCRIPTION mysub CONNECTION 'dbname=foo host=bar user=repuser' PUBLICATION mypub;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   The above will start the replication process, which synchronizes the
   initial table contents of the tables <literal>users</literal> and
   <literal>departments</literal> and then starts replicating
   incremental changes to those tables.
  </para>
____________________________________________________________________________-->
  <para>
   上面的语句将开始复制过程，它会同步表<literal>users</literal>以及<literal>departments</literal>的初始表内容，然后开始复制对那些表的增量更改。
  </para>
 </sect1>
</chapter>
