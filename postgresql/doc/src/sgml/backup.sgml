<!-- doc/src/sgml/backup.sgml -->

<chapter id="backup">
<!--
 <title>Backup and Restore</title>
 -->
 <title>备份与恢复</title>

 <indexterm zone="backup"><primary>backup</></>

 <!--
<para>
  As with everything that contains valuable data, <productname>PostgreSQL</>
  databases should be backed up regularly. While the procedure is
  essentially simple, it is important to have a clear understanding of
  the underlying techniques and assumptions.
 </para>
-->
<para>
  和任何包含珍贵数据的东西一样，<productname>PostgreSQL</>数据库也应该经常备份。
  尽管这个过程相当简单，但是我们还是应该理解做这件事所用的一些技巧和假设。 
</para>

 
<para>
  <!--
  There are three fundamentally different approaches to backing up
  <productname>PostgreSQL</> data:
  备份 PostgreSQL 数据有三种完全不同的方法：
-->

  
  <itemizedlist>
   <listitem>
   <!--
   <para><acronym>SQL</> dump</para>
   -->
   <para><acronym>SQL</>转储</para>
   </listitem>
   <listitem><!--
<para>File system level backup</para>
-->
<para>
 文件系统级别备份
</para></listitem>
   <listitem><!--
<para>Continuous archiving</para>
-->
<para>
  在线备份
</para></listitem>
  </itemizedlist>
  <!--
  Each has its own strengths and weaknesses; each is discussed in turn
  in the following sections.
  -->
  每种备份都有自己的优点和缺点。在下面的章节中依次进行讨论。
 </para>

 <sect1 id="backup-dump">
 <!--
  <title><acronym>SQL</> Dump</title>
  -->
   <title><acronym>SQL</>转储</title>

  
<para>
   <!--
   The idea behind this dump method is to generate a text file with SQL
   commands that, when fed back to the server, will recreate the
   database in the same state as it was at the time of the dump.
   <productname>PostgreSQL</> provides the utility program
   <xref linkend="app-pgdump"> for this purpose. The basic usage of this
   command is:
   -->
   SQL转储的方法是创建一个文本文件，里面都是SQL命令，
   当把这个文件回馈给服务器时，将重建与转储时状态一样的数据库。
   <productname>PostgreSQL</>为这个用途提供了<xref linkend="app-pgdump">工具。
   这条命令的基本用法是：
   
<synopsis>
pg_dump <replaceable class="parameter">dbname</replaceable> &gt; <replaceable class="parameter">outfile</replaceable>
</synopsis>
   <!--
   As you see, <application>pg_dump</> writes its result to the
   standard output. We will see below how this can be useful.
   -->
   正如你所见，<application>pg_dump</>把结果输出到标准输出。
   我们下面就可以看到这样做有什么好处。

  </para>

  <!--
<para>
   <application>pg_dump</> is a regular <productname>PostgreSQL</>
   client application (albeit a particularly clever one). This means
   that you can perform this backup procedure from any remote host that has
   access to the database. But remember that <application>pg_dump</>
   does not operate with special permissions. In particular, it must
   have read access to all tables that you want to back up, so in
   practice you almost always have to run it as a database superuser.
  </para>
-->
<para>
  <application>pg_dump</>是一个普通的<productname>PostgreSQL</>
  客户端应用(尽管是个相当聪明的东西)。
  这就意味着你可以从任何可以访问该数据库的远端主机上面进行备份工作。
  但是请记住<application>pg_dump</>不会以任何特殊权限运行。具体说来，
  就是它必须要有你想备份的表的读权限，因此，
  实际上你几乎总是要成为数据库超级用户。
</para>

  <!--
<para>
   To specify which database server <application>pg_dump</> should
   contact, use the command line options <option>-h
   <replaceable>host</></> and <option>-p <replaceable>port</></>. The
   default host is the local host or whatever your
   <envar>PGHOST</envar> environment variable specifies. Similarly,
   the default port is indicated by the <envar>PGPORT</envar>
   environment variable or, failing that, by the compiled-in default.
   (Conveniently, the server will normally have the same compiled-in
   default.)
  </para>
-->
<para>
  要声明<application>pg_dump</>应该以哪个用户身份进行连接，
  使用命令行选项<option>-h<replaceable>host</></>和<option>-p <replaceable>port</></>。
  缺省主机是本地主机或环境变量
  <envar>PGPORT</envar>声明的值。类似的，缺省端口是环境变量<envar>PGPORT</envar>或
  (如果它不存在的话)编译好了的缺省值。服务器通常都有相同的缺省，
  所以还算方便。
</para>

  <!--
<para>
   Like any other <productname>PostgreSQL</> client application,
   <application>pg_dump</> will by default connect with the database
   user name that is equal to the current operating system user name. To override
   this, either specify the <option>-U</option> option or set the
   environment variable <envar>PGUSER</envar>. Remember that
   <application>pg_dump</> connections are subject to the normal
   client authentication mechanisms (which are described in <xref
   linkend="client-authentication">).
  </para>
-->
<para>
  和任何其它<productname>PostgreSQL</>客户端应用一样，<application>pg_dump</>缺省时用
  与当前操作系统用户名同名的数据库用户名进行连接。
  要覆盖这个名字，要么声明<option>-U</option>选项，
  要么设置环境变量<envar>PGUSER</envar>。请注意<application>pg_dump</> 
  的连接也和普通客户应用一样要通过客户认证机制(在<xref linkend="client-authentication">里描述)。
</para>

  <!--
<para>
   An important advantage of <application>pg_dump</> over the other backup
   methods described later is that <application>pg_dump</>'s output can
   generally be re-loaded into newer versions of <productname>PostgreSQL</>,
   whereas file-level backups and continuous archiving are both extremely
   server-version-specific.  <application>pg_dump</> is also the only method
   that will work when transferring a database to a different machine
   architecture, such as going from a 32-bit to a 64-bit server.
  </para>
-->
<para>
  <application>pg_dump</>超过后边描述的其它备份方法的一个重要优点 
  是<application>pg_dump</>的输出通常可以 
  重新载入<productname>PostgreSQL</>新版本， 
  然而文件级别备份和连续归档都因 
  服务器版本而异。<application>pg_dump</>是
  将传输数据库到另一台机器体系结构工作时唯一的方法，
  如从32位变到64位服务器。
</para>

  <!--
<para>
   Dumps created by <application>pg_dump</> are internally consistent,
   meaning, the dump represents a snapshot of the database at the time
   <application>pg_dump</> began running. <application>pg_dump</> does not
   block other operations on the database while it is working.
   (Exceptions are those operations that need to operate with an
   exclusive lock, such as most forms of <command>ALTER TABLE</command>.)
  </para>
-->
<para>
   由<application>pg_dump</>创建的备份在内部是一致的，
   也就是说，在<application>pg_dump</>运行的时候转储的是数据库的快照。
   <application>pg_dump</>工作的时候并不阻塞其它的对数据库的操作
   (但是会阻塞那些需要排它锁的操作，比如<command>ALTER TABLE</command>)。

</para>

  <important>
   <!--
<para>
    If your database schema relies on OIDs (for instance, as foreign
    keys) you must instruct <application>pg_dump</> to dump the OIDs
    as well. To do this, use the <option>-o</option> command-line
    option.
   </para>
-->
<para>
   如果你的数据库结构依赖于OID(比如说用做外键)，
   那么你必须告诉<application>pg_dump</>把OID也导出来。要导出OID，
   可以使用<option>-o</option>命令行选项。

</para>
  </important>

  <sect2 id="backup-dump-restore">
  <!--
   <title>Restoring the Dump</title>
   -->
   <title>从转储中恢复</title>

   
<para>
   <!--
    The text files created by <application>pg_dump</> are intended to
    be read in by the <application>psql</application> program. The
    general command form to restore a dump is
<application>pg_dump</>生成的文本文件可以由<application>psql</application>程序读取。
从转储中恢复的常用命令是:
-->
<synopsis>
psql <replaceable class="parameter">dbname</replaceable> &lt; <replaceable class="parameter">infile</replaceable>
</synopsis>
   <!--
    where <replaceable class="parameter">infile</replaceable> is the
    file output by the <application>pg_dump</> command. The database <replaceable
    class="parameter">dbname</replaceable> will not be created by this
    command, so you must create it yourself from <literal>template0</>
    before executing <application>psql</> (e.g., with
    <literal>createdb -T template0 <replaceable
    class="parameter">dbname</></literal>).  <application>psql</>
    supports options similar to <application>pg_dump</> for specifying
    the database server to connect to and the user name to use. See
    the <xref linkend="app-psql"> reference page for more information.
-->
这里的<replaceable class="parameter">infile</replaceable>
就是通过<application>pg_dump</>命令的文件输出。
这条命令不会创建<replaceable class="parameter">dbname</replaceable>数据库，
你必须在执行<application>psql</>前自己从
<literal>template0</>创建(也就是用<literal>createdb -T template0 <replaceable class="parameter">dbname</></literal>命令)。
<application>psql</>支持类似<application>pg_dump</>的选项用以控制数据库服务器位置和用户名。
参阅<xref linkend="app-psql">的手册获取更多信息。
   </para>

   <!--
<para>
    Before restoring an SQL dump, all the users who own objects or were
    granted permissions on objects in the dumped database must already
    exist. If they do not, the restore will fail to recreate the
    objects with the original ownership and/or permissions.
    (Sometimes this is what you want, but usually it is not.)
   </para>
-->
<para>
   在开始运行恢复之前，目标库和所有在转储出来的库中拥有对象的用户，
   以及曾经在某些对象上被赋予权限的用户都必须已经存在。如果这些不存在，
   那么恢复将失败，因为恢复过程无法把这些对象恢复成原有的所有权和/或权限。
   有时候你希望恢复权限，不过通常你不需要这么做。
</para>

   
<para>
    <!--
    By default, the <application>psql</> script will continue to
    execute after an SQL error is encountered. You might wish to run
    <application>psql</application> with
    the <literal>ON_ERROR_STOP</> variable set to alter that
    behavior and have <application>psql</application> exit with an
    exit status of 3 if an SQL error occurs:
-->
缺省时，<application>psql</>脚本将在遇到错误的时候仍然继续执行。
你可能希望运行带有<literal>ON_ERROR_STOP</>变量设置的
<application>psql</application>以改变操作，并且如果发生SQL错误则带有
退出状态码3的<application>psql</application>退出。

<programlisting>
psql --set ON_ERROR_STOP=on dbname &lt; infile
</programlisting>
    <!--
    Either way, you will only have a partially restored database.
    Alternatively, you can specify that the whole dump should be
    restored as a single transaction, so the restore is either fully
    completed or fully rolled back. This mode can be specified by
    passing the <option>-1</> or <option>&#045;-single-transaction</>
    command-line options to <application>psql</>. When using this
    mode, be aware that even a minor error can rollback a
    restore that has already run for many hours. However, that might
    still be preferable to manually cleaning up a complex database
    after a partially restored dump.
-->
不管上述哪种方法都只能得到部分恢复了的数据库。另外，
你可以将整个恢复过程当成一个单独的事务，这样就能够保证要么全部恢复成功，
要么全部回滚。可以通过向<application>psql</>传递<option>-1</>或者<option>--single-transaction</>命令行
参数达到此目的。使用这个模式的时候即使一个很微小的错误也将导致已经运行
了好几个小时的恢复过程回滚。尽管如此，这种模式也比手动清除哪些不完整的
恢复数据强。

   </para>

   
<para>
    <!--
    The ability of <application>pg_dump</> and <application>psql</> to
    write to or read from pipes makes it possible to dump a database
    directly from one server to another, for example:
-->
<application>pg_dump</>和<application>psql</>可以通过管道读写，
这样我们就可能从一台主机上将数据库目录转储到另一台主机上，比如：

<programlisting>
pg_dump -h <replaceable>host1</> <replaceable>dbname</> | psql -h <replaceable>host2</> <replaceable>dbname</>
</programlisting>
   </para>

   <important>
    <!--
<para>
     The dumps produced by <application>pg_dump</> are relative to
     <literal>template0</>. This means that any languages, procedures,
     etc. added via <literal>template1</> will also be dumped by
     <application>pg_dump</>. As a result, when restoring, if you are
     using a customized <literal>template1</>, you must create the
     empty database from <literal>template0</>, as in the example
     above.
    </para>
-->
<para>
   <application>pg_dump</>生成的转储输出是相对于<literal>template0</>的。
   这就意味着任何加入到<literal>template1</>的语言、
   过程等都会经由<application>pg_dump</>转储。
   这样在恢复的时候，如果你使用的是自定义的<literal>template1</>，
   那么你必须从<literal>template0</>中创建空的数据库，
   就像我们上面的例子那样。

</para>
   </important>

   <!--
<para>
    After restoring a backup, it is wise to run <xref
    linkend="sql-analyze"> on each
    database so the query optimizer has useful statistics;
    see <xref linkend="vacuum-for-statistics">
    and <xref linkend="autovacuum"> for more information.
    For more advice on how to load large amounts of data
    into <productname>PostgreSQL</> efficiently, refer to <xref
    linkend="populate">.
   </para>
-->
<para>
   一旦完成恢复，在每个数据库上运行<xref  linkend="sql-analyze">是明智的举动，
   这样优化器就有可用的统计数据了。
   <xref linkend="vacuum-for-statistics">
    和<xref linkend="autovacuum">获取更多信息。
   关于如何有效加载海量数据到<productname>PostgreSQL</>的更多信息，
   参考<xref linkend="populate">。

</para>
  </sect2>

  <sect2 id="backup-dump-all">
  <!--
   <title>Using <application>pg_dumpall</></title>
   -->
   <title>使用<application>pg_dumpall</></title>

   
<para>
   <!--
    <application>pg_dump</> dumps only a single database at a time,
    and it does not dump information about roles or tablespaces
    (because those are cluster-wide rather than per-database).
    To support convenient dumping of the entire contents of a database
    cluster, the <xref linkend="app-pg-dumpall"> program is provided.
    <application>pg_dumpall</> backs up each database in a given
    cluster, and also preserves cluster-wide data such as role and
    tablespace definitions. The basic usage of this command is:
-->
<application>pg_dump</>在一个时间只转储一个单独的数据库， 
   它不转储有关角色或表空间信息（因为这些是集群范围，而不是每个数据库）。 
   为了支持 方便转储整个数据库集群的全部内容。
   因此我们提供了<xref linkend="app-pg-dumpall">程序。
   <application>pg_dumpall</>备份一个给出的集群中
   的每个数据库，同时还确保保留像角色和表空间这样的全局数据状态。
   这个命令的基本用法是：

<synopsis>
pg_dumpall &gt; <replaceable>outfile</>
</synopsis>
   <!--
    The resulting dump can be restored with <application>psql</>:
-->
生成的转储可以用<application>psql</>恢复：
<synopsis>
psql -f <replaceable class="parameter">infile</replaceable> postgres
</synopsis>
    <!--
    (Actually, you can specify any existing database name to start from,
    but if you are loading into an empty cluster then <literal>postgres</>
    should usually be used.)  It is always necessary to have
    database superuser access when restoring a <application>pg_dumpall</>
    dump, as that is required to restore the role and tablespace information.
    If you use tablespaces, make sure that the tablespace paths in the
    dump are appropriate for the new installation.
-->
实际上，你可以声明任意现有的数据库进行连接，
但是如果你是向一个空的数据库集群装载，
那么<literal>postgres</>应该是比较好的选择。
恢复<application>pg_dumpall</>的转储的时候通常需要数据库超级用户权限，
因为我们需要它来恢复角色和表空间信息。如果使用了表空间，
需要注意转储中的表空间路径必须适合新的安装。
   </para>

   <!--
<para>
    <application>pg_dumpall</> works by emitting commands to re-create
    roles, tablespaces, and empty databases, then invoking
    <application>pg_dump</> for each database.  This means that while
    each database will be internally consistent, the snapshots of
    different databases might not be exactly in-sync.
   </para>
-->
<para>
   <application>pg_dumpall</>的工作原理是发射命令来重新创建角色，
   表空间和空数据库，然后为每个数据库调用<application>pg_dump</>。
   这意味着，虽然每个数据库内部一致， 但不同的数据库快照可能不是恰好同步。
</para>
  </sect2>

  <sect2 id="backup-dump-large">
  <!--
   <title>Handling Large Databases</title>
   -->
   <title>处理大数据库</title>
   <!--
<para>
    Some operating systems have maximum file size limits that cause
    problems when creating large <application>pg_dump</> output files.
    Fortunately, <application>pg_dump</> can write to the standard
    output, so you can use standard Unix tools to work around this
    potential problem.  There are several possible methods:
   </para>
-->
<para>
    当创建大的<application>pg_dump</>输出文件时，
限制产生问题的一些操作系统允许最大文件大小。   
   因为<application>pg_dump</>输出到标准输出，
   你可以用标准的Unix工具绕开这个问题：有一些可能的方法：
</para>

   <formalpara>
   <!--
    <title>Use compressed dumps.</title>
-->
<title>使用压缩转储</title>
    
<para>
     <!--
     You can use your favorite compression program, for example
     <application>gzip</application>:
 -->
     使用你熟悉的压缩程序(比如<application>gzip</application>)：
<programlisting>
pg_dump <replaceable class="parameter">dbname</replaceable> | gzip &gt; <replaceable class="parameter">filename</replaceable>.gz
</programlisting>
    <!--
     Reload with:
    -->
使用下面命令恢复：
<programlisting>
gunzip -c <replaceable class="parameter">filename</replaceable>.gz | psql <replaceable class="parameter">dbname</replaceable>
</programlisting>
     <!--
     or:
    -->
     或者：
<programlisting>
cat <replaceable class="parameter">filename</replaceable>.gz | gunzip | psql <replaceable class="parameter">dbname</replaceable>
</programlisting>
    </para>

   </formalpara>

   <formalpara>
   <!--
    <title>Use <command>split</>.</title>
-->
<title>使用<command>split</>.</title>
   
<para>
     <!--
     The <command>split</command> command
     allows you to split the output into smaller files that are
     acceptable in size to the underlying file system. For example, to
     make chunks of 1 megabyte:
 -->
     <command>split</command>允许用下面的方法把输出分解成操作系统可以接受的大小。
 比如，让每个块大小为1MB：
 
<programlisting>
pg_dump <replaceable class="parameter">dbname</replaceable> | split -b 1m - <replaceable class="parameter">filename</replaceable>
</programlisting>
      <!--
     Reload with:
     -->
 用下面命令恢复：
<programlisting>
cat <replaceable class="parameter">filename</replaceable>* | psql <replaceable class="parameter">dbname</replaceable>
</programlisting>
    </para>

   </formalpara>

   <formalpara>
   <!--
    <title>Use <application>pg_dump</>'s custom dump format.</title>
-->
<title>使用<application>pg_dump</>自定义转储格式</title>
    
<para>
    <!--
     If <productname>PostgreSQL</productname> was built on a system with the
     <application>zlib</> compression library installed, the custom dump
     format will compress data as it writes it to the output file. This will
     produce dump file sizes similar to using <command>gzip</command>, but it
     has the added advantage that tables can be restored selectively. The
     following command dumps a database using the custom dump format:
    -->
 如果<productname>PostgreSQL</productname>是在一个安装了<application>zlib</>
 压缩库的系统上制作的，
 那么自定义转储格式将在写入输出文件的时候压缩数据。
 它会生成和使用<command>gzip</command>类似大小的转储文件，但是还附加了一个优点：
 你可以有选择地恢复库中的表。下面的命令用自定义转储格式转储一个数据库：
 
<programlisting>
pg_dump -Fc <replaceable class="parameter">dbname</replaceable> &gt; <replaceable class="parameter">filename</replaceable>
</programlisting>
    <!--
     A custom-format dump is not a script for <application>psql</>, but
     instead must be restored with <application>pg_restore</>, for example:
     -->
 自定义格式的转储不是脚本，不能用于<application>psql</>，而是需要使用<application>pg_restore</>转储。
 比如：

<programlisting>
pg_restore -d <replaceable class="parameter">dbname</replaceable> <replaceable class="parameter">filename</replaceable>
</programlisting>
    <!--
     See the <xref linkend="app-pgdump"> and <xref
     linkend="app-pgrestore"> reference pages for details.
 -->
 请参阅<xref linkend="app-pgdump">和<xref  linkend="app-pgrestore">手册获取细节。
    </para>
   </formalpara>

   <!--
<para>
    For very large databases, you might need to combine <command>split</>
    with one of the other two approaches.
   </para>
-->
<para>
   对于非常大的数据库，你可能需要结合<command>split</>以及其他两种方法之一。
</para>

   <formalpara>
   <!--
    <title>Use <application>pg_dump</>'s parallel dump feature.</title>
-->
<title>使用<application>pg_dump</>的并行转储功能</title>
    
<para>
    <!--
     To speed up the dump of a large database, you can use
     <application>pg_dump</application>'s parallel mode. This will dump
     multiple tables at the same time. You can control the degree of
     parallelism with the <command>-j</command> parameter. Parallel dumps
     are only supported for the "directory" archive format.
    -->
为了加快大数据库的转储，你可以使用<application>pg_dump</application>并行模式。
这将同时转储多个表。你可以使用<command>-j</command>参数控制并行性程度。
并行转储只支持"目录"归档模式。
<programlisting>
pg_dump -j <replaceable class="parameter">num</replaceable> -F d -f <replaceable class="parameter">out.dir</replaceable> <replaceable class="parameter">dbname</replaceable>
</programlisting>
     <!--
     You can use <command>pg_restore -j</command> to restore a dump in parallel.
     This will work for any archive of either the "custom" or the "directory"
     archive mode, whether or not it has been created with <command>pg_dump -j</command>.
 -->
 你可以使用<command>pg_restore -j</command>并行恢复转储。这将为任何"自定义"或者
 "目录"归档模式工作，是否它已经使用<command>pg_dump -j</command>创建。
    </para>
   </formalpara>
  </sect2>
 </sect1>

 <sect1 id="backup-file">
 <!--
  <title>File System Level Backup</title>
  -->
  <title>文件系统级别备份</title>

  
<para>
   <!--
   An alternative backup strategy is to directly copy the files that
   <productname>PostgreSQL</> uses to store the data in the database;
   <xref linkend="creating-cluster"> explains where these files
   are located.  You can use whatever method you prefer
   for doing file system backups; for example:
   -->
   另一个备份的策略是直接拷贝<productname>PostgreSQL</>用于存放数据库数据的文件。
   我们在<xref linkend="creating-cluster">里解释了这些文件的位置，
   你可以用自己喜欢的任何常用文件系统备份的方法，
   例如：

<programlisting>
tar -cf backup.tar /usr/local/pgsql/data
</programlisting>
  </para>

  
<para>
   <!--
   There are two restrictions, however, which make this method
   impractical, or at least inferior to the <application>pg_dump</>
   method:
   -->
   不过，你要受到两个限制，令这个方法不那么实用，或者至少比<application>pg_dump</>的方法逊色一些：

   <orderedlist>
    <listitem>
     <para>
 <!--
      The database server <emphasis>must</> be shut down in order to
      get a usable backup. Half-way measures such as disallowing all
      connections will <emphasis>not</emphasis> work
      (in part because <command>tar</command> and similar tools do not take
      an atomic snapshot of the state of the file system,
      but also because of internal buffering within the server).
      Information about stopping the server can be found in
      <xref linkend="server-shutdown">.  Needless to say, you
      also need to shut down the server before restoring the data.
  -->
  为了进行有效的备份，数据库服务器<emphasis>必须</>被关闭。
  像拒绝所有连接这样的折衷的方法是<emphasis>不行</emphasis>的，
  （部分因为<command>tar</command>和类似的工具在做备份的时候并不对文件系统的状态做原子快照。
  但也因为服务器内部缓冲数据）。
  有关关闭服务器的信息可以在<xref linkend="server-shutdown">里面找到。
  不用说，你在恢复数据之前，
  同样必须关闭服务器。  
     </para>

    </listitem>

    <listitem>
     <!--
<para>
      If you have dug into the details of the file system layout of the
      database, you might be tempted to try to back up or restore only certain
      individual tables or databases from their respective files or
      directories. This will <emphasis>not</> work because the
      information contained in these files is not usable without
      the commit log files,
      <filename>pg_clog/*</filename>, which contain the commit status of
      all transactions. A table file is only usable with this
      information. Of course it is also impossible to restore only a
      table and the associated <filename>pg_clog</filename> data
      because that would render all other tables in the database
      cluster useless.  So file system backups only work for complete
      backup and restoration of an entire database cluster.
     </para>
-->
<para> 
   如果你曾经深入了解了数据库在文件系统布局的细节，
   你可能试图从对应的文件或目录里备份几个表或者数据库。
   这样做是<emphasis>没用</>的，因为包含在这些文件里的信息只是部分信息。
   还有一半信息在提交日志文件<filename>pg_clog/*</filename>里面，
   它包含所有事务的提交状态。
   只有拥有这些信息，表文件的信息才是可用的。当然，
   试图只恢复表和相关的<filename>pg_clog</filename>数据也是徒劳的，
   因为这样会把数据库集群里的所有其它没有用的表的信息都拿出来。
   所以文件系统的备份只适用于一个数据库集群的完整恢复。

</para>
    </listitem>
   </orderedlist>
  </para>

  <!--
<para>
   An alternative file-system backup approach is to make a
   <quote>consistent snapshot</quote> of the data directory, if the
   file system supports that functionality (and you are willing to
   trust that it is implemented correctly).  The typical procedure is
   to make a <quote>frozen snapshot</> of the volume containing the
   database, then copy the whole data directory (not just parts, see
   above) from the snapshot to a backup device, then release the frozen
   snapshot.  This will work even while the database server is running.
   However, a backup created in this way saves
   the database files in a state as if the database server was not
   properly shut down; therefore, when you start the database server
   on the backed-up data, it will think the previous server instance
   crashed and will replay the WAL log.  This is not a problem; just
   be aware of it (and be sure to include the WAL files in your backup).
   You can perform a <command>CHECKPOINT</command> before taking the
   snapshot to reduce recovery time.
  </para>
-->
<para>
  另外一个文件系统备份的方法是给数据目录做一个<quote>一致的快照</quote>，
  条件是文件系统支持这个功能(并且你愿意相信它是实现正确的)。
  典型的过程是制作一个包含数据库的卷的<quote>冻结快照</>，
  然后把整个数据库目录(不仅仅是部分，见上文)从快照拷贝到备份设备，
  然后释放冻结快照。这样甚至在数据库服务器在运行的时候都可以运转。
  不过，这样创建的备份会把数据库文件保存在一个没有恰当关闭数据库服务器的状态下；
  因此，如果你在这个备份目录下启动数据库服务器，
  它就会认为数据库服务器经历过崩溃并且重放WAL日志。
  这不是个问题，只要意识到它即可(并且确信在自己的备份中包含WAL文件)。
  在采用快照减少恢复时间之前，你可以执行<command>CHECKPOINT</command>。
</para>

  <!--
<para>
   If your database is spread across multiple file systems, there might not
   be any way to obtain exactly-simultaneous frozen snapshots of all
   the volumes.  For example, if your data files and WAL log are on different
   disks, or if tablespaces are on different file systems, it might
   not be possible to use snapshot backup because the snapshots
   <emphasis>must</> be simultaneous.
   Read your file system documentation very carefully before trusting
   the consistent-snapshot technique in such situations.
  </para>
-->
<para>
  如果你的数据库分布在多个文件系统上，
  那么可能就没有任何方法获取所有卷上准确的同步冻结快照。比如，
  你的数据文件和WAL日志在不同的磁盘上，或者表空间在不同的文件系统上，
  这种情况下就不可能使用快照，因为快照<emphasis>必须</>是同时的。
  在你信任这样的情况下的一致性快照的技术之前，仔细阅读你的文件系统文档。


</para>

  <!--
<para>
   If simultaneous snapshots are not possible, one option is to shut down
   the database server long enough to establish all the frozen snapshots.
   Another option is to perform a continuous archiving base backup (<xref
   linkend="backup-base-backup">) because such backups are immune to file
   system changes during the backup.  This requires enabling continuous
   archiving just during the backup process; restore is done using
   continuous archive recovery (<xref linkend="backup-pitr-recovery">).
  </para>
-->
<para>
   如果同步快照是不可能的，该选项关闭数据库服务器足够长的时间来建立所有冰冻的快照。
   另一种选择是执行一个连续归档基础备份(<xref linkend="backup-base-backup">)
   因为这样的备份在备份过程中免于文件系统变化。这需要在备份过程中启动连续归档。
   恢复是通过使用连续存档恢复(<xref linkend="backup-pitr-recovery">)完成的。
</para>

  <!--
<para>
   Another option is to use <application>rsync</> to perform a file
   system backup.  This is done by first running <application>rsync</>
   while the database server is running, then shutting down the database
   server just long enough to do a second <application>rsync</>.  The
   second <application>rsync</> will be much quicker than the first,
   because it has relatively little data to transfer, and the end result
   will be consistent because the server was down.  This method
   allows a file system backup to be performed with minimal downtime.
  </para>
-->
<para>
   另外一个选择是使用<application>rsync</>执行一次文件系统备份。
   这是通过在数据库服务器正在运行的时候运行第一次<application>rsync</>，
   然后关闭数据库服务器一段足够的时间长度，用于运行第二次<application>rsync</>。
   第二次<application>rsync</>会比第一次快很多，因为它要传输的数据相对较少，
   并且最后的结果是一致的，
   因为服务器已经停止运行了。这个方法允许用很少的时间执行一次文件系统备份。

</para>

  <!--
<para>
   Note that a file system backup will typically be larger
   than an SQL dump. (<application>pg_dump</application> does not need to dump
   the contents of indexes for example, just the commands to recreate
   them.)  However, taking a file system backup might be faster.
  </para>
-->
<para>
   需要注意的是文件系统备份往往比SQL转储大。
   比如<application>pg_dump</application>不用导出索引，
   只是创建它们的命令。然而，文件系统备份可能会更快。
</para>
 </sect1>

 <sect1 id="continuous-archiving">
 <!--
  <title>Continuous Archiving and Point-in-Time Recovery (PITR)</title>
  -->
  <title>在线备份以及即时恢复(PITR)</title>

  <indexterm zone="backup">
   <primary>continuous archiving</primary>
  </indexterm>

  <indexterm zone="backup">
   <primary>point-in-time recovery</primary>
  </indexterm>

  <indexterm zone="backup">
   <primary>PITR</primary>
  </indexterm>

  
<para>
   <!--
   At all times, <productname>PostgreSQL</> maintains a
   <firstterm>write ahead log</> (WAL) in the <filename>pg_xlog/</>
   subdirectory of the cluster's data directory. The log records
   every change made to the database's data files.  This log exists
   primarily for crash-safety purposes: if the system crashes, the
   database can be restored to consistency by <quote>replaying</> the
   log entries made since the last checkpoint.  However, the existence
   of the log makes it possible to use a third strategy for backing up
   databases: we can combine a file-system-level backup with backup of
   the WAL files.  If recovery is needed, we restore the file system backup and
   then replay from the backed-up WAL files to bring the system to a
   current state.  This approach is more complex to administer than
   either of the previous approaches, but it has some significant
   benefits:
   -->
   在任何时候，<productname>PostgreSQL</>都在集群的数据目录的<filename>pg_xlog/</>
   子目录里维护着一套<firstterm>预写日志</>(WAL)。
   这些日志记录着每一次对数据库的修改细节。
   这些日志存在是为了防止崩溃：
   如果系统崩溃，数据库可以通过<quote>重放</>上次检查点以来的日志记录以恢复数据库的完整性。
   但是，日志的存在让它还可以用于第三种备份数据库的策略：
   我们可以组合文件系统备份与WAL文件的备份。如果需要恢复，我们就恢复备份，
   然后重放备份了的WAL文件，把备份恢复到当前的时间。这个方法对管理员来说，
   明显比以前的方法更复杂，但是有非常明显的优势：
   
  <itemizedlist>
   <listitem>
    <para>
<!--
     We do not need a perfectly consistent file system backup as the starting point.
     Any internal inconsistency in the backup will be corrected by log
     replay (this is not significantly different from what happens during
     crash recovery).  So we do not need a file system snapshot capability,
     just <application>tar</> or a similar archiving tool.
 -->
 在开始的时候我们不需要一个非常完美的一致的备份。
 任何备份内部的不一致都会被日志重放动作修改正确
 (这个和崩溃恢复时发生的事情没什么区别)。因此我们不需要文件系统快照的功能，
 只需要<application>tar</>或者类似的归档工具。
    </para>


   </listitem>
   <listitem>
    <!--
<para>
     Since we can combine an indefinitely long sequence of WAL files
     for replay, continuous backup can be achieved simply by continuing to archive
     the WAL files.  This is particularly valuable for large databases, where
     it might not be convenient to take a full backup frequently.
    </para>
-->
<para>
   因为我们可以把无限长的WAL文件序列连接起来，
   所以连续的备份简化为连续地对WAL文件归档来实现。
   这个功能对大数据库特别有用，因为大数据库的全备份可能并不方便。
</para>
   </listitem>
   <listitem>
    <!--
<para>
     It is not necessary to replay the WAL entries all the
     way to the end.  We could stop the replay at any point and have a
     consistent snapshot of the database as it was at that time.  Thus,
     this technique supports <firstterm>point-in-time recovery</>: it is
     possible to restore the database to its state at any time since your base
     backup was taken.
    </para>
-->
<para>
   我们可没说重放WAL记录的时候我们必须重放到结尾。
   我们可以在任意点停止重放，这样就有一个在任意时间的数据库一致的快照。
   因此，这个技术支持<firstterm>即时恢复</>：
   我们可以把数据库恢复到你开始备份以来的任意时刻的状态。
</para>
   </listitem>
   <listitem>
    <!--
<para>
     If we continuously feed the series of WAL files to another
     machine that has been loaded with the same base backup file, we
     have a <firstterm>warm standby</> system: at any point we can bring up
     the second machine and it will have a nearly-current copy of the
     database.
    </para>
-->
<para>
   如果我们持续把WAL文件序列填充给其它装载了同样的基础备份文件的机器，
   我们就有了一套<firstterm>热备份</>系统：在任何点我们都可以启动第二台机器，
   而它拥有近乎当前的数据库拷贝。
</para>
   </listitem>
  </itemizedlist>
  </para>

  <note>
   <!--
<para>
    <application>pg_dump</application> and
    <application>pg_dumpall</application> do not produce file-system-level
    backups and cannot be used as part of a continuous-archiving solution.
    Such dumps are <emphasis>logical</> and do not contain enough
    information to be used by WAL replay.
   </para>
-->
<para>
    <application>pg_dump</application>和
    <application>pg_dumpall</application>没有产生文件系统级别备份，并且不能作为
连续归档解决方案的一部分。比如备份是<emphasis>符合逻辑的</>并且不包含
    WAL重放使用的足够信息。
</para>
  </note>

  <!--
<para>
   As with the plain file-system-backup technique, this method can only
   support restoration of an entire database cluster, not a subset.
   Also, it requires a lot of archival storage: the base backup might be bulky,
   and a busy system will generate many megabytes of WAL traffic that
   have to be archived.  Still, it is the preferred backup technique in
   many situations where high reliability is needed.
  </para>
-->
<para>
   和简单的文件系统备份技术一样，这个方法只能支持整个数据库集群的恢复，
   而不是一个子集。同样，它还要求大量的归档存储：基础备份量可能很大，
   而且忙碌的系统将生成许多兆需要备份的的WAL流量。但是，
   它仍然时在需要高可靠性的场合下的最好的备份技术。
</para>

  <!--
<para>
   To recover successfully using continuous archiving (also called
   <quote>online backup</> by many database vendors), you need a continuous
   sequence of archived WAL files that extends back at least as far as the
   start time of your backup.  So to get started, you should set up and test
   your procedure for archiving WAL files <emphasis>before</> you take your
   first base backup.  Accordingly, we first discuss the mechanics of
   archiving WAL files.
  </para>
-->
<para>
  要想从连续归档中成功恢复（也被许多数据库供应商称为<quote>在线备份</>），
  你需要一套连续的WAL归档文件，
  它们最远回朔到你开始备份的时刻。因此，要想开始备份，
  你应该在开始第一次基础备份<emphasis>之前</>根据我们讨论过的归档WAL文件机制设置并测试你的步骤。
</para>

  <sect2 id="backup-archiving-wal">
  <!--
   <title>Setting Up WAL Archiving</title>
   -->
   <title>设置WAL归档</title>

   <!--
<para>
    In an abstract sense, a running <productname>PostgreSQL</> system
    produces an indefinitely long sequence of WAL records.  The system
    physically divides this sequence into WAL <firstterm>segment
    files</>, which are normally 16MB apiece (although the segment size
    can be altered when building <productname>PostgreSQL</>).  The segment
    files are given numeric names that reflect their position in the
    abstract WAL sequence.  When not using WAL archiving, the system
    normally creates just a few segment files and then
    <quote>recycles</> them by renaming no-longer-needed segment files
    to higher segment numbers.  It's assumed that segment files whose
    contents precede the checkpoint-before-last are no longer of
    interest and can be recycled.
   </para>
-->
<para>
   抽象来看，一个运行着的<productname>PostgreSQL</>系统生成一个无限长的WAL日志序列。
   系统物理上把这个序列分隔成WAL<firstterm>段文件</>，通常每段16M(在编译<productname>PostgreSQL</>的
   时候可以改变其大小)。这些段文件的名字是数值命名的，这些数值反映他们在抽取出来的
   WAL 序列中的位置。在不适用WAL归档的时候，系统通常只是创建几个段文件然
   后<quote>循环</>使用它们，方法是把不再使用的段文件的名字重命名为更高的段编号。
   系统假设那些内容比前一次检查点更老的段文件已经没用了，然后就可以循环利用。
</para>

   <!--
<para>
    When archiving WAL data, we need to capture the contents of each segment
    file once it is filled, and save that data somewhere before the segment
    file is recycled for reuse.  Depending on the application and the
    available hardware, there could be many different ways of <quote>saving
    the data somewhere</>: we could copy the segment files to an NFS-mounted
    directory on another machine, write them onto a tape drive (ensuring that
    you have a way of identifying the original name of each file), or batch
    them together and burn them onto CDs, or something else entirely.  To
    provide the database administrator with flexibility,
    <productname>PostgreSQL</> tries not to make any assumptions about how
    the archiving will be done.  Instead, <productname>PostgreSQL</> lets
    the administrator specify a shell command to be executed to copy a
    completed segment file to wherever it needs to go.  The command could be
    as simple as a <literal>cp</>, or it could invoke a complex shell
    script &mdash; it's all up to you.
   </para>
-->
<para>
   在归档WAL数据的时候，我们希望在每个段文件填充满之后捕获之，
   并且把这些数据在段文件被循环利用之前保存在某处。
   根据应用以及可用的硬件的不同，我们可以有许多不同的方法<quote>把数据保存在某处</>：
   我们可以把段文件拷贝到一个 NFS 挂载的目录，把它们放到另外一台机器上，
   或者把它们写入磁带机里(需要保证你有办法把文件恢复为原名)，或者把它们打成包，
   烧录到 CD 里，或者是其它的什么方法。为了给数据库管理员提供最大可能性的灵活性，
   <productname>PostgreSQL</>试图不对如何归档做任何假设。取而代之的是，
   <productname>PostgreSQL</>让管理员声明一个shell命令执行来拷贝一个完整的段文件到它需要去的地方。
   该命令可以简单得就是一个<literal>cp</>，或者它可以调用一个复杂的shell脚本&mdash;
   这些都由管理员决定。

</para>

   
<para>
    <!--
    To enable WAL archiving, set the <xref linkend="guc-wal-level">
    configuration parameter to <literal>archive</> (or <literal>hot_standby</>),
    <xref linkend="guc-archive-mode"> to <literal>on</>,
    and specify the shell command to use in the <xref
    linkend="guc-archive-command"> configuration parameter.  In practice
    these settings will always be placed in the
    <filename>postgresql.conf</filename> file.
    In <varname>archive_command</>,
    <literal>%p</> is replaced by the path name of the file to
    archive, while <literal>%f</> is replaced by only the file name.
    (The path name is relative to the current working directory,
    i.e., the cluster's data directory.)
    Use <literal>%%</> if you need to embed an actual <literal>%</>
    character in the command.  The simplest useful command is something
    like:
-->
为了启动WAL归档，设置<xref linkend="guc-wal-level">
    配置参数到<literal>archive</> (或者<literal>hot_standby</>),
    <xref linkend="guc-archive-mode">为<literal>on</>，
并且所使用的shell命令由配置参数<xref linkend="guc-archive-command">声明，
它实际上总是放在<filename>postgresql.conf</filename>文件里的。在<varname>archive_command</>中，
任何<literal>%p</>都被要归档文件的绝对路径代替，而任何<literal>%f</>只是被文件名代替。
如果你需要在命令里嵌入一个真正的<literal>%</>字符，那么必须双写(<literal>%%</>)。
最简单的有用命令类似下面这样：


<programlisting>
archive_command = 'test ! -f /mnt/server/archivedir/%f &amp;&amp; cp %p /mnt/server/archivedir/%f'  # Unix
archive_command = 'copy "%p" "C:\\server\\archivedir\\%f"'  # Windows
</programlisting>
    <!--
    which will copy archivable WAL segments to the directory
    <filename>/mnt/server/archivedir</>.  (This is an example, not a
    recommendation, and might not work on all platforms.)  After the
    <literal>%p</> and <literal>%f</> parameters have been replaced,
    the actual command executed might look like this:
-->

它将把WAL段拷贝到<filename>/mnt/server/archivedir</>目录。
这个只是一个例子，并非我们建议的方法，
<literal>%p</>和<literal>%f</>参数被取代之后，实际执行的命令看起来这样：

<programlisting>
test ! -f /mnt/server/archivedir/00000001000000A900000065 &amp;&amp; cp pg_xlog/00000001000000A900000065 /mnt/server/archivedir/00000001000000A900000065
</programlisting>
    <!--
    A similar command will be generated for each new file to be archived.
-->
为每一个归档的新文件产生类似的命令。
   </para>


   <!--
<para>
    The archive command will be executed under the ownership of the same
    user that the <productname>PostgreSQL</> server is running as.  Since
    the series of WAL files being archived contains effectively everything
    in your database, you will want to be sure that the archived data is
    protected from prying eyes; for example, archive into a directory that
    does not have group or world read access.
   </para>
-->
<para>
   归档命令将在运行<productname>PostgreSQL</>服务器的同一个用户的权限下执行。
   因此被归档的WAL文件实际上包含你的数据库里的所有东西，
   所以你应该确保自己的归档数据不会被别人窥探；比如，
   归档到一个没有组或者全局读权限的目录里。
</para>

   <!--
<para>
    It is important that the archive command return zero exit status if and
    only if it succeeds.  Upon getting a zero result,
    <productname>PostgreSQL</> will assume that the file has been
    successfully archived, and will remove or recycle it.  However, a nonzero
    status tells <productname>PostgreSQL</> that the file was not archived;
    it will try again periodically until it succeeds.
   </para>
-->
<para>
   有一点很重要：当且仅当归档命令成功时，它才返回零。
   在得到一个零值结果之后，<productname>PostgreSQL</>将假设该WAL段文件已经成功归档，
   因此它稍后将被删除或者被新的数据覆盖。但是，
   一个非零值告诉<productname>PostgreSQL</>该文件没有被归档；
   因此它会周期性的重试直到成功。
</para>

   <!--
<para>
    The archive command should generally be designed to refuse to overwrite
    any pre-existing archive file.  This is an important safety feature to
    preserve the integrity of your archive in case of administrator error
    (such as sending the output of two different servers to the same archive
    directory).
   </para>
-->
<para>
    归档命令通常应该设计成拒绝覆盖已经存在的归档文件。
这是一个非常重要的安全特性，可以在管理员操作失误
(比如把两个不同的服务器的输出发送到同一个归档目录)的时候保持你的归档的完整性
</para>

   <!--
<para>
    It is advisable to test your proposed archive command to ensure that it
    indeed does not overwrite an existing file, <emphasis>and that it returns
    nonzero status in this case</>.
    The example command above for Unix ensures this by including a separate
    <command>test</> step.  On some Unix platforms, <command>cp</> has
    switches such as <option>-i</> that can be used to do the same thing
    less verbosely, but you should not rely on these without verifying that
    the right exit status is returned.  (In particular, GNU <command>cp</>
    will return status zero when <option>-i</> is used and the target file
    already exists, which is <emphasis>not</> the desired behavior.)
   </para>
-->
<para>
   我们建议你首先要测试你准备使用的归档命令，以保证它实际上不会覆盖现有的文件，
   并且<emphasis>在这种情况下它返回非零状态</>。
   上边Unix例子中的命令包含单独的<command>测试</>步骤。在一些Unix平台上，<command>cp</>
   有可以使用的开关比如<option>-i</>可以做同样的简单的事情。
   但是你不应该依靠这些而不验证返回的正确退出状态。
   （尤其是，当使用<option>-i</>并且已经存在目标文件时，GNU <command>cp</>将返回状态零，
   这<emphasis>不是</>期望的操作。）
</para>

   <!--
<para>
    While designing your archiving setup, consider what will happen if
    the archive command fails repeatedly because some aspect requires
    operator intervention or the archive runs out of space. For example, this
    could occur if you write to tape without an autochanger; when the tape
    fills, nothing further can be archived until the tape is swapped.
    You should ensure that any error condition or request to a human operator
    is reported appropriately so that the situation can be
    resolved reasonably quickly. The <filename>pg_xlog/</> directory will
    continue to fill with WAL segment files until the situation is resolved.
    (If the file system containing <filename>pg_xlog/</> fills up,
    <productname>PostgreSQL</> will do a PANIC shutdown.  No committed
    transactions will be lost, but the database will remain offline until
    you free some space.)
   </para>
-->
<para>
   在设计你的归档环境的时候，请考虑一下如果归档命令不停失败会发生什么情况，
   因为有些方面要求操作者的干涉，或者是归档空间不够了。比如，
   如果你往磁带机上写，但是没有自动换带机，那么就有可能发生这种情况；
   如果磁带满了，那就除非换磁带，否则啥事也做不了。
   你应该确保任何错误条件或者要求操作员干涉的错误都会正确报告，
   这样才能迅速解决这些问题。否则<filename>pg_xlog/</>目录会不停地填充WAL段文件，
   直到问题解决。（如果文件系统由<filename>pg_xlog/</>填充，<productname>PostgreSQL</>将执行
   PANIC关机。没有提交的事务将丢失，但是数据库将保持未连接直到你释放一些空间）。
</para>

   <!--
<para>
    The speed of the archiving command is unimportant as long as it can keep up
    with the average rate at which your server generates WAL data.  Normal
    operation continues even if the archiving process falls a little behind.
    If archiving falls significantly behind, this will increase the amount of
    data that would be lost in the event of a disaster. It will also mean that
    the <filename>pg_xlog/</> directory will contain large numbers of
    not-yet-archived segment files, which could eventually exceed available
    disk space. You are advised to monitor the archiving process to ensure that
    it is working as you intend.
   </para>
-->
<para>
   归档命令的速度并不要紧，只要它能跟上你的服务器生成WAL数据的平均速度即可。
   即使归档进程落在了后面一点，正常的操作也会继续进行。如果归档进程慢很多，
   就会增加灾难发生时的数据丢失量。同时也意味着<filename>pg_xlog/</>
   目录包含大量未归档的日志段文件，并且可能最后超出了磁盘空间。
   我们建议你监控归档进程，确保它是按照你的意识运转的。

</para>

   <!--
<para>
    In writing your archive command, you should assume that the file names to
    be archived can be up to 64 characters long and can contain any
    combination of ASCII letters, digits, and dots.  It is not necessary to
    preserve the original relative path (<literal>%p</>) but it is necessary to
    preserve the file name (<literal>%f</>).
   </para>
-->
<para>
   在写自己的归档命令的时候，你应该假设被归档的文件最多
   64个字符长并且可以包含ASCII字母、数字、点的任意组合。
   我们不必要记住原始的全路径(<literal>%p</>)，但是有必要记住文件名(<literal>%f</>。

</para>

   <!--
<para>
    Note that although WAL archiving will allow you to restore any
    modifications made to the data in your <productname>PostgreSQL</> database,
    it will not restore changes made to configuration files (that is,
    <filename>postgresql.conf</>, <filename>pg_hba.conf</> and
    <filename>pg_ident.conf</>), since those are edited manually rather
    than through SQL operations.
    You might wish to keep the configuration files in a location that will
    be backed up by your regular file system backup procedures.  See
    <xref linkend="runtime-config-file-locations"> for how to relocate the
    configuration files.
   </para>
-->
<para>
   请注意尽管WAL归档允许你恢复任何对<productname>PostgreSQL</>数据库的修改，
   在最初的基础备份之后，它还是不会恢复对配置文件的修改
   (<filename>postgresql.conf</>, <filename>pg_hba.conf</>和
    <filename>pg_ident.conf</>)，
   因为这些文件都是手工编辑的，而不是通过SQL操作来编辑的。
   所以你可能会需要把你的配置文件放在一个日常文件系统备份过程即可处理到的地方。
   参阅<xref linkend="runtime-config-file-locations">获取如何重定位配置文件的知识。

</para>

   <!--
<para>
    The archive command is only invoked on completed WAL segments.  Hence,
    if your server generates only little WAL traffic (or has slack periods
    where it does so), there could be a long delay between the completion
    of a transaction and its safe recording in archive storage.  To put
    a limit on how old unarchived data can be, you can set
    <xref linkend="guc-archive-timeout"> to force the server to switch
    to a new WAL segment file at least that often.  Note that archived
    files that are archived early due to a forced switch are still the same
    length as completely full files.  It is therefore unwise to set a very
    short <varname>archive_timeout</> &mdash; it will bloat your archive
    storage.  <varname>archive_timeout</> settings of a minute or so are
    usually reasonable.
   </para>
-->
<para>
   因为归档命令仅在已经完成的WAL段上调用，因此，
   如果你的服务器只产生很小的WAL流量或段之间的间隔很长，
   那么在事务完成之后与其被安全归档之间就会存在很长的延时。
   为了限制未归档数据的最长期限，可以设置<xref linkend="guc-archive-timeout">强制服务器在切换
   WAL段之间的时间间隔。需要注意的是，
   由于强制切换而提早结束的已归档文件的大小与完整的归档文件相同。
   因此将<varname>archive_timeout</>设为一个很小的值是不明智的&mdash;
   它将很快耗尽归档空间。将<varname>archive_timeout</>设置为60秒左右通常是比较合理的。

</para>

   <!--
<para>
    Also, you can force a segment switch manually with
    <function>pg_switch_xlog</> if you want to ensure that a
    just-finished transaction is archived as soon as possible.  Other utility
    functions related to WAL management are listed in <xref
    linkend="functions-admin-backup-table">.
   </para>
-->
<para>
   同样，如果你想确保刚刚完成的事务被立即归档，
   那么也可以通过<function>pg_switch_xlog</>手动强制切换段文件。
   其它与WAL管理相关的工具函数在<xref linkend="functions-admin-backup-table">中列出。
</para>

   <!--
<para>
    When <varname>wal_level</> is <literal>minimal</> some SQL commands
    are optimized to avoid WAL logging, as described in <xref
    linkend="populate-pitr">.  If archiving or streaming replication were
    turned on during execution of one of these statements, WAL would not
    contain enough information for archive recovery.  (Crash recovery is
    unaffected.)  For this reason, <varname>wal_level</> can only be changed at
    server start.  However, <varname>archive_command</> can be changed with a
    configuration file reload.  If you wish to temporarily stop archiving,
    one way to do it is to set <varname>archive_command</> to the empty
    string (<literal>''</>).
    This will cause WAL files to accumulate in <filename>pg_xlog/</> until a
    working <varname>archive_command</> is re-established.
   </para>
-->
<para>
    当<varname>wal_level</>是<literal>minimal</>的时候，一些SQL命令进行优化以避免WAL日志，
正如<xref linkend="populate-pitr">所描述的。
如果在这些语句之一执行过程中打开归档或者流复制，WAL不包含归档恢复的足够信息。
(崩溃恢复不受影响)，出于这些原因，在服务器开始改变<varname>wal_level</>。
然而，重新加载配置文件时改变<varname>archive_command</>。
如果你希望暂时停止归档，这样做的一个方法是设置<varname>archive_command</>为空字符串
    (<literal>''</>)。这将导致WAL文件在<filename>pg_xlog/</>中积累直到<varname>archive_command</>重新建立。
</para>
  </sect2>

  <sect2 id="backup-base-backup">
   <!--
   <title>Making a Base Backup</title>
   -->
   <title>进行一次基础备份</title>

   <!--
<para>
    The easiest way to perform a base backup is to use the
    <xref linkend="app-pgbasebackup"> tool. It can create
    a base backup either as regular files or as a tar archive. If more
    flexibility than <xref linkend="app-pgbasebackup"> can provide is
    required, you can also make a base backup using the low level API
    (see <xref linkend="backup-lowlevel-base-backup">).
   </para>
-->
<para>
     执行基础备份最简单方式是使用<xref linkend="app-pgbasebackup">工具，
 它使用普通文件或者tar归档创建基础备份。
 如果比<xref linkend="app-pgbasebackup">提供更多的灵活性，你也可以使用
 低水平API（参阅<xref linkend="backup-lowlevel-base-backup">）创建基础备份。
 
</para>

   <!--
<para>
    It is not necessary to be concerned about the amount of time it takes
    to make a base backup. However, if you normally run the
    server with <varname>full_page_writes</> disabled, you might notice a drop
    in performance while the backup runs since <varname>full_page_writes</> is
    effectively forced on during backup mode.
   </para>
-->
<para>
    不必担心基础备份需要大量时间。然而，
如果你正常运行禁用了<varname>full_page_writes</>的服务器，
当运行备份时，你可能注意到性能方面，
因为<varname>full_page_writes</>有效强加在备份方式中。
</para>

   <!--
<para>
    To make use of the backup, you will need to keep all the WAL
    segment files generated during and after the file system backup.
    To aid you in doing this, the base backup process
    creates a <firstterm>backup history file</> that is immediately
    stored into the WAL archive area. This file is named after the first
    WAL segment file that you need for the file system backup.
    For example, if the starting WAL file is
    <literal>0000000100001234000055CD</> the backup history file will be
    named something like
    <literal>0000000100001234000055CD.007C9330.backup</>. (The second
    part of the file name stands for an exact position within the WAL
    file, and can ordinarily be ignored.) Once you have safely archived
    the file system backup and the WAL segment files used during the
    backup (as specified in the backup history file), all archived WAL
    segments with names numerically less are no longer needed to recover
    the file system backup and can be deleted. However, you should
    consider keeping several backup sets to be absolutely certain that
    you can recover your data.
   </para>
-->
<para>
   要使用这个备份，你需要保存所有备份开始以及之后的WAL段文件。
   为了帮助你实现这个任务，基础备份过程创建一个<firstterm>备份历史文件</>，
   它马上存储到WAL归档区域。这个文件的名字是以你在使用文件系统备份的时候需要的第一个
   WAL段文件的名字命名的。比如，如果开始 WAL 文件是<literal>0000000100001234000055CD</>，
   那么备份历史文件将命名为类似<literal>0000000100001234000055CD.007C9330.backup</>这样的东西。
   这个文件名的第二部分表示在该WAL文件里面的准确位置，通常可以被忽略。
   一旦你安全地把这些日志段文件归了档，
   那么你就可以删除所有那些数值名字在这个文件前面的归档的WAL段。
   文件系统备份不再需要它们了。当然，你应当保留几套备份以绝对确保可以恢复先前的数据。


</para>

   <!--
<para>
    The backup history file is just a small text file. It contains the
    label string you gave to <xref linkend="app-pgbasebackup">, as well as
    the starting and ending times and WAL segments of the backup.
    If you used the label to identify the associated dump file,
    then the archived history file is enough to tell you which dump file to
    restore.
   </para>
-->
<para>
  备份历史文件只是一个小的文本文件。它包含你给予<xref linkend="app-pgbasebackup">的标签字符串，
  以及备份的起始时间和终止时间。如果你使用这个标签来表示转储文件放在哪里，
  则在需要的时候，归档的历史文件就足够告诉你转储文件存放在哪里了。
</para>

   <!--
<para>
    Since you have to keep around all the archived WAL files back to your
    last base backup, the interval between base backups should usually be
    chosen based on how much storage you want to expend on archived WAL
    files.  You should also consider how long you are prepared to spend
    recovering, if recovery should be necessary &mdash; the system will have to
    replay all those WAL segments, and that could take awhile if it has
    been a long time since the last base backup.
   </para>
-->
<para>
   因为你必须保留直到最后一次基础备份的所有归档的WAL文件，
   那么两次基础备份之间的间隔通常是根据你想在归档WAL 
   文件上花多少存储空间来定的。
   你还应该考虑你准备在恢复上花多少时间。如果需要恢复的话&mdash;
   系统将需要重放所有那些段，
   而如果最后一次基础备份以来，时间已经很长了，
   那么那些动作可能会花掉好些时间。


</para>
  </sect2>

  <sect2 id="backup-lowlevel-base-backup">
  <!--
   <title>Making a Base Backup Using the Low Level API</title>
   -->
   <title>使用低级别API进行基础备份</title>
   
<para>
   <!--
    The procedure for making a base backup using the low level
    APIs contains a few more steps than
    the <xref linkend="app-pgbasebackup"> method, but is relatively
    simple. It is very important that these steps are executed in
    sequence, and that the success of a step is verified before
    proceeding to the next step.
-->
使用包含多个步骤的低水平API而不是<xref linkend="app-pgbasebackup">方法，
但是相对简单。在序列中执行这些步骤非常重要，并且在进行下一步之前需要验证当前步成功。
  <orderedlist>
   <listitem>
    <para>
 <!--
     Ensure that WAL archiving is enabled and working.
 -->
 确保WAL归档打开并且可以运转。
    </para>


   </listitem>
   <listitem>
    
<para>
     <!--
     Connect to the database as a superuser and issue the command:
 -->
 以数据库超级用户身份连接到数据库，发出命令:
<programlisting>
SELECT pg_start_backup('label');
</programlisting>
     <!--
     where <literal>label</> is any string you want to use to uniquely
     identify this backup operation.  (One good practice is to use the
     full path where you intend to put the backup dump file.)
     <function>pg_start_backup</> creates a <firstterm>backup label</> file,
     called <filename>backup_label</>, in the cluster directory with
     information about your backup, including the start time and label
     string.  The file is critical to the integrity of the backup, should
     you need to restore from it.
 -->
 这里的<literal>label</>是任意你想使用的这次备份操作的唯一标识
 (一个好习惯是使用备份转储文件的放置地全路径)。
 <function>pg_start_backup</>用备份信息在集群目录里
 创建一个<firstterm>备份标签</>文件<filename>backup_label</>。
 包含起始时间和标签字符串。该文件对于备份完整性是非常重要的，你需要从中恢复。
    </para>

    <!--
<para>
     It does not matter which database within the cluster you connect to to
     issue this command.  You can ignore the result returned by the function;
     but if it reports an error, deal with that before proceeding.
    </para>
-->
<para>
   至于你连接到集群中的那个数据库没什么关系。
   你可以忽略函数返回的结果；但是如果它报告错误，
   那么在继续之前先处理它。
</para>

    
<para>
    <!--
     By default, <function>pg_start_backup</> can take a long time to finish.
     This is because it performs a checkpoint, and the I/O
     required for the checkpoint will be spread out over a significant
     period of time, by default half your inter-checkpoint interval
     (see the configuration parameter
     <xref linkend="guc-checkpoint-completion-target">).  This is
     usually what you want, because it minimizes the impact on query
     processing.  If you want to start the backup as soon as
     possible, use:
 -->
 默认情况下，<function>pg_start_backup</>可能需要很长的时间才能完成。 
     这是因为它会执行一个检查点，并且I/O所需的检查点会被分散在一个显著的时间段，
    默认情况下，使用一半你的相互检查点间隔（参见配置参数
<xref linkend="guc-checkpoint-completion-target">）。
这是你想要的，因为它最大限度地减少对查询处理的影响。
如果你想尽快开始备份，使用：
<programlisting>
SELECT pg_start_backup('label', true);
</programlisting>
     <!--
     This forces the checkpoint to be done as quickly as possible.
 -->
 这强制检查点尽快完成。
    </para>
   </listitem>
   <listitem>
    <!--
<para>
     Perform the backup, using any convenient file-system-backup tool
     such as <application>tar</> or <application>cpio</> (not
     <application>pg_dump</application> or
     <application>pg_dumpall</application>).  It is neither
     necessary nor desirable to stop normal operation of the database
     while you do this.
    </para>
-->
<para>
     执行备份，使用任何方便的文件系统工具，比如<application>tar</>或者<application>cpio</>
 （而不是<application>pg_dump</application>或者
     <application>pg_dumpall</application>）。
 这些操作过程中既不需要关闭数据库，也不需要关闭数据库的操作。
</para>
   </listitem>
   <listitem>
    
<para>
     <!--
     Again connect to the database as a superuser, and issue the command:
 -->
 再次以数据库超级用户身份连接数据库，然后发出命令：
<programlisting>
SELECT pg_stop_backup();
</programlisting>
     <!--
     This terminates the backup mode and performs an automatic switch to
     the next WAL segment.  The reason for the switch is to arrange for
     the last WAL segment file written during the backup interval to be
     ready to archive.
 -->
 这将中止备份模式并自动切换到下一个WAL段。
 自动切换是为了在备份间隔中写入的最后一个WAL 
 段文件可以立即为下次备份作好准备。
    </para>
   </listitem>
   <listitem>
    <!--
<para>
     Once the WAL segment files active during the backup are archived, you are
     done.  The file identified by <function>pg_stop_backup</>'s result is
     the last segment that is required to form a complete set of backup files.
     If <varname>archive_mode</> is enabled,
     <function>pg_stop_backup</> does not return until the last segment has
     been archived.
     Archiving of these files happens automatically since you have
     already configured <varname>archive_command</>. In most cases this
     happens quickly, but you are advised to monitor your archive
     system to ensure there are no delays.
     If the archive process has fallen behind
     because of failures of the archive command, it will keep retrying
     until the archive succeeds and the backup is complete.
     If you wish to place a time limit on the execution of
     <function>pg_stop_backup</>, set an appropriate
     <varname>statement_timeout</varname> value.
    </para>
-->
<para>
    只要在备份过程中使用的WAL段文件备份完毕，你的备份工作就完成了。
通过<function>pg_stop_backup</>的结果标识的文件是需要形成一套完整备份文件的最后一段。 
    如果<varname>archive_mode</>已启用，
<function>pg_stop_backup</>不返回，直到最后段被归档。 
    这些文件的归档是自动发生的，因为已配置<varname>archive_command</>。
在大多数情况下，这将迅速发生，但建议您监控您的存档系统以确保没有延迟。 
如果归档进程已经落后，因为存档命令失败，它会继续重试直到存档成功，备份完成。
如果您希望在执行<function>pg_stop_backup</>时有时间限制，则设定适当的 
    <varname>statement_timeout</varname>值。
</para>
   </listitem>
  </orderedlist>
   </para>

   <!--
<para>
    Some file system backup tools emit warnings or errors
    if the files they are trying to copy change while the copy proceeds.
    When taking a base backup of an active database, this situation is normal
    and not an error.  However, you need to ensure that you can distinguish
    complaints of this sort from real errors.  For example, some versions
    of <application>rsync</> return a separate exit code for
    <quote>vanished source files</>, and you can write a driver script to
    accept this exit code as a non-error case.  Also, some versions of
    GNU <application>tar</> return an error code indistinguishable from
    a fatal error if a file was truncated while <application>tar</> was
    copying it.  Fortunately, GNU <application>tar</> versions 1.16 and
    later exit with 1 if a file was changed during the backup,
    and 2 for other errors.  With GNU <application>tar</> version 1.23 and
    later, you can use the warning options <literal>&#045;-warning=no-file-changed
    &#045;-warning=no-file-removed</literal> to hide the related warning messages.
   </para>
-->
<para>
   一些文件系统备份工具发出警告或错误，
   如果这些文件他们正试图复制副本处理的变化。
   当执行活动数据库的基础备份，这种情况是正常的并且不发生错误。 
   但是，你需要确保你能辨别这种从实际错误中的投诉。例如，<application>rsync</>某些版本
   返回一个<quote>消失源文件</>单独的退出代码，你可以写一个驱动程序脚本接受这个退出代码作为一个非错误情况。   
   此外，当<application>tar</>复制它，如果一个文件被截断时，
   GNU <application>tar</>某些版本返回一个错误代码区分致命的错误，  
   幸运的是，如果文件在备份过程中改变，GNU <application>tar</>版本1.16和
   后期版本退出1，其他错误则返回2。对于GNU <application>tar</>版本1.23版和
   后期版本，您可以使用警告选项的<literal>--warning=no-file-changed
    --warning=no-file-removed</literal>隐藏相关的警告信息。



</para>

   <!--
<para>
    Be certain that your backup dump includes all of the files under
    the database cluster directory (e.g., <filename>/usr/local/pgsql/data</>).
    If you are using tablespaces that do not reside underneath this directory,
    be careful to include them as well (and be sure that your backup dump
    archives symbolic links as links, otherwise the restore will corrupt
    your tablespaces).
   </para>
-->
<para>
   
  要保证你的备份转储包括所有数据库集群目录里的文件
  (比如<filename>/usr/local/pgsql/data</>)。如果你在使用并未放置在这个目录里的表空间，
  也要小心地包含它们，并且要确保你的备份转储归档符号连接是符号连接，
  否则，恢复会把你的表空间搞乱。


</para>

   <!--
<para>
    You can, however, omit from the backup dump the files within the
    cluster's <filename>pg_xlog/</> subdirectory.  This
    slight adjustment is worthwhile because it reduces the risk
    of mistakes when restoring.  This is easy to arrange if
    <filename>pg_xlog/</> is a symbolic link pointing to someplace outside
    the cluster directory, which is a common setup anyway for performance
    reasons.  You might also want to exclude <filename>postmaster.pid</>
    and <filename>postmaster.opts</>, which record information
    about the running <application>postmaster</>, not about the
    <application>postmaster</> which will eventually use this backup.
    (These files can confuse <application>pg_ctl</>.)
   </para>
-->
<para>
   不过，你可以在备份转储文件里省略集群目录下的<filename>pg_xlog/</>子目录。
   这个略微复杂些的动作是值得的，因为它减少了恢复时候的错误。
   如果<filename>pg_xlog/</>是一个指向集群目录之外的符号连接，
   那么这件事情很容易处理，出于性能考虑的时候经常这么做。
   你可能还想排除<filename>postmaster.pid</>和<filename>postmaster.opts</>，
   记录有关运行<application>postmaster</>的信息，而不谈<application>postmaster</>。
   它最终将使用这个备份。（这些文件可以混淆<application>pg_ctl</>）。
</para>

   <!--
<para>
    It's also worth noting that the <function>pg_start_backup</> function
    makes a file named <filename>backup_label</> in the database cluster
    directory, which is removed by <function>pg_stop_backup</>.
    This file will of course be archived as a part of your backup dump file.
    The backup label file includes the label string you gave to
    <function>pg_start_backup</>, as well as the time at which
    <function>pg_start_backup</> was run, and the name of the starting WAL
    file.  In case of confusion it is therefore possible to look inside a
    backup dump file and determine exactly which backup session the dump file
    came from.  However, this file is not merely for your information; its
    presence and contents are critical to the proper operation of the system's
    recovery process.
   </para>
-->
<para>
    还有一件事值得一提，那就是<function>pg_start_backup</>函数在数据库集群目录里创建了
一个叫<filename>backup_label</>的文件，它被<function>pg_stop_backup</>删除。
这个文件当然也会作为备份转储文件的一部分归档。
这个备份标签文件包含你给予<function>pg_start_backup</>的标签字符串，
以及<function>pg_start_backup</>运行的时刻，以及起始WAL文件的名字。
如果有混淆，那么我们可以看看备份转储文件里面然后
判断转储文件来自那个备份会话。
然而，这些文件不仅仅是你的信息，它的存在和内容对系统的恢复过程的正确操作是关键的。
</para>

   <!--
<para>
    It is also possible to make a backup dump while the server is
    stopped.  In this case, you obviously cannot use
    <function>pg_start_backup</> or <function>pg_stop_backup</>, and
    you will therefore be left to your own devices to keep track of which
    backup dump is which and how far back the associated WAL files go.
    It is generally better to follow the continuous archiving procedure above.
   </para>
-->
<para>
    我们还可以在服务器停止的时候制作一个备份转储。
在这种条件下，很明显你不能使用<function>pg_start_backup</>
或者<function>pg_stop_backup</>，
并且因此你必须靠自己的手段来跟踪备份转储文件都是那些，
以及相关的WAL文件最远走到哪里。
通常使用上面的在线备份步骤更好些。
</para>
  </sect2>

  <sect2 id="backup-pitr-recovery">
  <!--
   <title>Recovering Using a Continuous Archive Backup</title>
   -->
    <title>从在线备份中恢复</title>

   
<para>
   <!--
    Okay, the worst has happened and you need to recover from your backup.
    Here is the procedure:
-->
好，最糟糕的事情发生了，现在你需要从备份中恢复。下面是步骤：

  <orderedlist>
   <listitem>
    <para>
<!--
     Stop the server, if it's running.
 -->
 停止服务器，如果它还在运行的话。
    </para>
   </listitem>
   <listitem>
    <!--
<para>
     If you have the space to do so,
     copy the whole cluster data directory and any tablespaces to a temporary
     location in case you need them later. Note that this precaution will
     require that you have enough free space on your system to hold two
     copies of your existing database. If you do not have enough space,
     you should at least save the contents of the cluster's <filename>pg_xlog</>
     subdirectory, as it might contain logs which
     were not archived before the system went down.
    </para>
-->
<para>
   如果你还有足够的空间，把整个集群数据目录和所有表空间拷贝到一个临时位置，
   以防万一你之后还需要它们。请注意这个预防措施要求你在系统里有足够的剩余
   空间来现有库的保持两份拷贝。如果你没有足够的空间，
   那么你至少需要把集群数据目录的<filename>pg_xlog</>子目录的内容拷贝到安全的地方，
   因为它们可能包含系统宕掉的时候还没有归档的日志。
</para>
   </listitem>
   <listitem>
    <!--
<para>
     Remove all existing files and subdirectories under the cluster data
     directory and under the root directories of any tablespaces you are using.
    </para>
-->
<para>
    然后清理掉所有在该集群数据目录里的现存文件，
以及所有你使用的表空间里根目录下的现存文件。
</para>
   </listitem>
   <listitem>
    <!--
<para>
     Restore the database files from your file system backup.  Be sure that they
     are restored with the right ownership (the database system user, not
     <literal>root</>!) and with the right permissions.  If you are using
     tablespaces,
     you should verify that the symbolic links in <filename>pg_tblspc/</>
     were correctly restored.
    </para>
-->
<para>
    从你的备份转储中恢复数据库文件。
要小心用正确的所有者(数据库系统用户，而不是<literal>root</>!)和权限恢复它们。
如果你使用了表空间，你可能需要核实在<filename>pg_tblspc/</>里的符号连接都得到正确恢复。
</para>
   </listitem>
   <listitem>
    <!--
<para>
     Remove any files present in <filename>pg_xlog/</>; these came from the
     file system backup and are therefore probably obsolete rather than current.
     If you didn't archive <filename>pg_xlog/</> at all, then recreate
     it with proper permissions,
     being careful to ensure that you re-establish it as a symbolic link
     if you had it set up that way before.
    </para>
-->
<para>
    删除任何目前还在<filename>pg_xlog/</>里的文件；这些文件来自备份转储，
因此它们可能比目前的老。如果你就根本没有归档<filename>pg_xlog/</>，那么重建之，
它具有合适的权限，如果你已经像从前那样建立了，小心确保你重新建立它作为符号链接，

</para>
   </listitem>
   <listitem>
    <!--
<para>
     If you have unarchived WAL segment files that you saved in step 2,
     copy them into <filename>pg_xlog/</>.  (It is best to copy them,
     not move them, so you still have the unmodified files if a
     problem occurs and you have to start over.)
    </para>
-->
<para>
   如果你有在步骤 2 里面保存的WAL段文件，那么把它们拷贝到<filename>pg_xlog/</>。
   最好是拷贝它们，而不是把它们移动回来，这样即使发生了糟糕的事情，你需要重启的时候，
   你也依然拥有未修改的文件。

</para>
   </listitem>
   <listitem>
    <!--
<para>
     Create a recovery command file <filename>recovery.conf</> in the cluster
     data directory (see <xref linkend="recovery-config">). You might
     also want to temporarily modify <filename>pg_hba.conf</> to prevent
     ordinary users from connecting until you are sure the recovery was successful.
    </para>
-->
<para>
    在集群数据目录里创建一个恢复命令文件<filename>recovery.conf</>(参阅<xref linkend="recovery-config">)。
你可能还需要临时修改<filename>pg_hba.conf</>以避免普通用户连接，
直到你确信恢复已经正常了为止。
</para>
   </listitem>
   <listitem>
    <!--
<para>
     Start the server.  The server will go into recovery mode and
     proceed to read through the archived WAL files it needs.  Should the
     recovery be terminated because of an external error, the server can
     simply be restarted and it will continue recovery.  Upon completion
     of the recovery process, the server will rename
     <filename>recovery.conf</> to <filename>recovery.done</> (to prevent
     accidentally re-entering recovery mode later) and then
     commence normal database operations.
    </para>
-->
<para>
    启动服务器。服务器将进入恢复模式并且继续读取它需要的 WAL 归档文件。
在遇见外部错误的应当中止恢复过程，然后重新启动服务器，
这样它会自动继续进行恢复工作。在恢复过程完成后，
服务器将把<filename>recovery.conf</>改名为<filename>recovery.done</>
以避免不小心因后面的崩溃再次进入恢复模式，
然后开始正常的数据库操作。

</para>
   </listitem>
   <listitem>
    <!--
<para>
     Inspect the contents of the database to ensure you have recovered to
     the desired state.  If not, return to step 1.  If all is well,
     allow your users to connect by restoring <filename>pg_hba.conf</> to normal.
    </para>
-->
<para>
    检查数据库的内容以确保你已经恢复到你期望的位置。
如果还没有，
回到步骤1。如果全部正常，则恢复<filename>pg_hba.conf</>
成正常状态以允许普通用户登录。
</para>
   </listitem>
  </orderedlist>
   </para>

  
<para>
     <!--
    The key part of all this is to set up a recovery configuration file that
    describes how you want to recover and how far the recovery should
    run.  You can use <filename>recovery.conf.sample</> (normally
    located in the installation's <filename>share/</> directory) as a
    prototype.  The one thing that you absolutely must specify in
    <filename>recovery.conf</> is the <varname>restore_command</>,
    which tells <productname>PostgreSQL</> how to retrieve archived
    WAL file segments.  Like the <varname>archive_command</>, this is
    a shell command string.  It can contain <literal>%f</>, which is
    replaced by the name of the desired log file, and <literal>%p</>,
    which is replaced by the path name to copy the log file to.
    (The path name is relative to the current working directory,
    i.e., the cluster's data directory.)
    Write <literal>%%</> if you need to embed an actual <literal>%</>
    character in the command.  The simplest useful command is
    something like:
-->
所有这些操作的关键是设置一个恢复命令文件，
这个文件描述你希望如何恢复以及恢复应该走到哪里。
你可以使用<filename>recovery.conf.sample</>(通常安装在安装目录的<filename>share/</>
子目录里)作为原型。你必须在<filename>recovery.conf</>里面声明的一个东西是<varname>restore_command</>，
它告诉系统如何拿回归档的WAL文件段。类似<varname>archive_command</>，
这个是一个脚本命令字符串。它可以包含<literal>%f</>，这个变量会被需要的日志文件名替换，
以及<literal>%p</>，它会被要拷贝去的日志文件的绝对路径代替。
如果需要在命令里替换真正的<literal>%</>字符，那么就双写(<literal>%%</>)。
最简单的有用命令是类似下面的东西：

<programlisting>
restore_command = 'cp /mnt/server/archivedir/%f %p'
</programlisting>
     <!--
    which will copy previously archived WAL segments from the directory
    <filename>/mnt/server/archivedir</>.  Of course, you can use something
    much more complicated, perhaps even a shell script that requests the
    operator to mount an appropriate tape.
-->
这个命令将把以前归档的WAL段从<filename>/mnt/server/archivedir</>目录拷贝过来。
你当然可以使用某些更复杂的东西，甚至是一个要求操作者挂载合适的磁带的shell脚本。
   </para>

   <!--
<para>
    It is important that the command return nonzero exit status on failure.
    The command <emphasis>will</> be called requesting files that are not present
    in the archive; it must return nonzero when so asked.  This is not an
    error condition.  Not all of the requested files will be WAL segment
    files; you should also expect requests for files with a suffix of
    <literal>.backup</> or <literal>.history</>. Also be aware that
    the base name of the <literal>%p</> path will be different from
    <literal>%f</>; do not expect them to be interchangeable.
   </para>
-->
<para>
    重要的一点是：该命令在失败的时候返回非零值。
如果日志文件没有出现在规档中，
那么该系统<emphasis>将要</>询问该命令；在问到的时候，它必须返回非零。这个不是错误条件。
并不是所有需要的文件都是WAL分段文件；你应该希望请求<literal>.backup</>或者
<literal>.history</>的后缀文件。
还要注意<literal>%p</>路径的基础名将和<literal>%f</>不一样；不要认为它们是可以互换的。
</para>

   <!--
<para>
    WAL segments that cannot be found in the archive will be sought in
    <filename>pg_xlog/</>; this allows use of recent un-archived segments.
    However, segments that are available from the archive will be used in
    preference to files in <filename>pg_xlog/</>.
   </para>
-->
<para>
    在归档中没有的WAL分段将在<filename>pg_xlog/</>中；
这样就允许使用最近没有归档的段。但是在归档中的段将比<filename>pg_xlog/</>中的优先。
</para>

   <!--
<para>
    Normally, recovery will proceed through all available WAL segments,
    thereby restoring the database to the current point in time (or as
    close as possible given the available WAL segments).  Therefore, a normal
    recovery will end with a <quote>file not found</> message, the exact text
    of the error message depending upon your choice of
    <varname>restore_command</>.  You may also see an error message
    at the start of recovery for a file named something like
    <filename>00000001.history</>.  This is also normal and does not
    indicate a problem in simple recovery situations; see
    <xref linkend="backup-timelines"> for discussion.
   </para>
-->
<para>
     通常，恢复将处理所有可用的 WAL 段，
 因此将把数据库恢复到当前时间(或者是在所给出的可用 WAL 段数的情况下，
 我们能走到的最近的地方)。
     因此，一个正常恢复以<quote>文件没找到</>信息结束，
 错误信息的确切文本依赖于<varname>restore_command</>
 你的选择。你也可能在类似于<filename>00000001.history</>文件恢复开头看到错误信息。
 这也是正常的，并不表明简单恢复情况下的问题。参阅<xref linkend="backup-timelines">
 获取更多信息。
</para>

   <!--
<para>
    If you want to recover to some previous point in time (say, right before
    the junior DBA dropped your main transaction table), just specify the
    required stopping point in <filename>recovery.conf</>.  You can specify
    the stop point, known as the <quote>recovery target</>, either by
    date/time, named restore point or by completion of a specific transaction
    ID.  As of this writing only the date/time and named restore point options
    are very usable, since there are no tools to help you identify with any
    accuracy which transaction ID to use.
   </para>
-->
<para>
    但是如果你想恢复到某些以前的时刻点(比如，
在菜鸟DBA删除你的主要事务表之前)，
那么只需要在<filename>recovery.conf</>里声明要求的停止点。
你可以通过日期/时间来声明，也可以通过特定事务ID的结束来声明这个停止点，
我们叫做<quote>恢复目标</>。目前，只有日期/时间和称为恢复点选项比较有用，
因为我们没有工具来帮助你精确地标识应该使用哪个事务ID。
</para>

   <note>
     <!--
<para>
      The stop point must be after the ending time of the base backup, i.e.,
      the end time of <function>pg_stop_backup</>.  You cannot use a base backup
      to recover to a time when that backup was in progress.  (To
      recover to such a time, you must go back to your previous base backup
      and roll forward from there.)
     </para>
-->
<para>
     请注意停止点必须在备份的终止时间之后(也就是<function>pg_stop_backup</>的时间)。
 你无法使用一个基础备份恢复到备份正在进行中的某个时刻。要想恢复到该时刻，
 你必须回到你以前的基础备份，然后从那个位置向前滚动。
</para>
   </note>

   <!--
<para>
    If recovery finds corrupted WAL data, recovery will
    halt at that point and the server will not start. In such a case the
    recovery process could be re-run from the beginning, specifying a
    <quote>recovery target</> before the point of corruption so that recovery
    can complete normally.
    If recovery fails for an external reason, such as a system crash or
    if the WAL archive has become inaccessible, then the recovery can simply
    be restarted and it will restart almost from where it failed.
    Recovery restart works much like checkpointing in normal operation:
    the server periodically forces all its state to disk, and then updates
    the <filename>pg_control</> file to indicate that the already-processed
    WAL data need not be scanned again.
   </para>
-->
<para>
   如果在恢复过程中发现在 WAL 数据中存在错误，那么恢复将在错误的地方停止，
   并且不会启动服务器。在这种情况下，可以指定一个位于错误点之前的<quote>恢复目标</>，
   然后从起始点开始重新运行恢复进程，这样恢复就可以正常完成。
   如果由于外部原因(系统崩溃、无法读取 WAL 归档)导致恢复失败，
   那么可以简单的重新启动恢复过程即可，它将从上次失败的地方继续。
   重新启动恢复过程与检查点的操作非常类似：
   服务器周期性的强制将其状态记录到磁盘上并更新<filename>pg_control</>文件以标识已经处理的
   WAL 数据不需要被再次扫描。


</para>

  </sect2>

  <sect2 id="backup-timelines">
  <!--
   <title>Timelines</title>
   -->
   <title>时间线</title>

  <indexterm zone="backup">
   <primary>timelines</primary>
  </indexterm>

   <!--
<para>
    The ability to restore the database to a previous point in time creates
    some complexities that are akin to science-fiction stories about time
    travel and parallel universes.  For example, in the original history of the database,
    suppose you dropped a critical table at 5:15PM on Tuesday evening, but
    didn't realize your mistake until Wednesday noon.
    Unfazed, you get out your backup, restore to the point-in-time 5:14PM
    Tuesday evening, and are up and running.  In <emphasis>this</> history of
    the database universe, you never dropped the table.  But suppose
    you later realize this wasn't such a great idea, and would like
    to return to sometime Wednesday morning in the original history.
    You won't be able
    to if, while your database was up-and-running, it overwrote some of the
    WAL segment files that led up to the time you now wish you
    could get back to.  Thus, to avoid this, you need to distinguish the series of
    WAL records generated after you've done a point-in-time recovery from
    those that were generated in the original database history.
   </para>
-->
<para>
   能够把数据库恢复到以前的某个时间点的能力导致了一些类似科幻小说里的时间跟踪
   和并行宇宙这样的复杂情况。在数据库最初的历史里，
   可能你在周二下午5:15删除掉了一个非常关键的表。但是没有意识到你自己的错误直到周三中午。
   有条不紊地拿出备份，恢复到周二晚上5:14的即时备份。在<emphasis>这个</>数据库宇宙的历史里，
   你从来没有删除过那个表。但是假如你后来认识到这么干是错误的，
   并且想回到最初的历史中的稍后的点。你没法这么干，因为在数据库运行的时候，
   它覆盖了一些WAL段文件的序列，这些序列就在你希望回去的区间里。
   因此你的确需要区分在你从那些原始数据库历史生成的WAL中完成即时恢复之
   后生成的WAL序列。
</para>

   <!--
<para>
    To deal with this problem, <productname>PostgreSQL</> has a notion
    of <firstterm>timelines</>.  Whenever an archive recovery completes,
    a new timeline is created to identify the series of WAL records
    generated after that recovery.  The timeline
    ID number is part of WAL segment file names so a new timeline does
    not overwrite the WAL data generated by previous timelines.  It is
    in fact possible to archive many different timelines.  While that might
    seem like a useless feature, it's often a lifesaver.  Consider the
    situation where you aren't quite sure what point-in-time to recover to,
    and so have to do several point-in-time recoveries by trial and error
    until you find the best place to branch off from the old history.  Without
    timelines this process would soon generate an unmanageable mess.  With
    timelines, you can recover to <emphasis>any</> prior state, including
    states in timeline branches that you abandoned earlier.
   </para>
-->
<para>
    为了处理这些问题，<productname>PostgreSQL</>有个叫<firstterm>时间线</>的概念。
当完成一个归档恢复时，那么就创建一个新的时间线，以表示在该次恢复之后生成的 WAL 记录序列。
    时间线ID号是WAL段文件名的一部分，
因此新的时间线并不会覆盖以前的时间线生成的 WAL 数据。
实际上我们可以归档许多不同的时间线。虽然这些看起来像没用的特性，
但它却可能常常是救命稻草。考虑一下你并不很确信应该恢复到那个时刻的情况，
这个时候你不得不做好几次试验性即时恢复然后从中找到旧历史中最好的分支。
如果没有时间线，那么这个过程可能很快就会导致无法管理的混乱。
有了时间线，你可以恢复到<emphasis>任意</>以前的状态，
包括恢复到你后来放弃的时间线分支的状态。
</para>

   <!--
<para>
    Every time a new timeline is created, <productname>PostgreSQL</> creates
    a <quote>timeline history</> file that shows which timeline it branched
    off from and when.  These history files are necessary to allow the system
    to pick the right WAL segment files when recovering from an archive that
    contains multiple timelines.  Therefore, they are archived into the WAL
    archive area just like WAL segment files.  The history files are just
    small text files, so it's cheap and appropriate to keep them around
    indefinitely (unlike the segment files which are large).  You can, if
    you like, add comments to a history file to record your own notes about
    how and why this particular timeline was created.  Such comments will be
    especially valuable when you have a thicket of different timelines as
    a result of experimentation.
   </para>
-->
<para>
   每当创建一个新的时间线的时候，<productname>PostgreSQL</>都创建一个<quote>时间线历史</>文件，
   它显示自己从哪个时间线分出来，以及何时分出来的。
   这些历史文件是在从包含多个时间线的归档中进行恢复时，
   允许系统选取正确 WAL 段文件的必要文件。因此，
   它们像 WAL 段文件一样归档到 WAL 归档里。
   历史文件只是很小的文本文件(不像段文件很大)，
   所以独立地保存他们代价很小，也值得做。如果你喜欢，
   你可以在历史文件里加入注释，记录自己为什么设置这个时间线以及如何设置的等信息。
   这样的注释会在你有厚厚一堆不同的时间线需要选择和分析的时候特别有价值。
</para>

   <!--
<para>
    The default behavior of recovery is to recover along the same timeline
    that was current when the base backup was taken.  If you wish to recover
    into some child timeline (that is, you want to return to some state that
    was itself generated after a recovery attempt), you need to specify the
    target timeline ID in <filename>recovery.conf</>.  You cannot recover into
    timelines that branched off earlier than the base backup.
   </para>
-->
<para>
    恢复的缺省的行为是沿着与基础备份的同一个时间线恢复。
如果你想恢复到某些子时间线，也就是，你想回到某些本身就是在开始恢复之后发生的状态。
你需要在<filename>recovery.conf</>里声明目标时间线ID。
你无法恢复到比基础备份更早的时间线分支。
</para>
  </sect2>

  <sect2 id="backup-tips">
  <!--
   <title>Tips and Examples</title>
   -->
   <title>技巧和例子</title>

   <!--
<para>
    Some tips for configuring continuous archiving are given here.
   </para>
-->
<para>
   给出了配置连续归档的一些技巧。
</para>

    <sect3 id="backup-standalone">
<!--
     <title>Standalone Hot Backups</title>
 -->
 <title>单机热备</title>

     <!--
<para>
      It is possible to use <productname>PostgreSQL</>'s backup facilities to
      produce standalone hot backups. These are backups that cannot be used
      for point-in-time recovery, yet are typically much faster to backup and
      restore than <application>pg_dump</> dumps.  (They are also much larger
      than <application>pg_dump</> dumps, so in some cases the speed advantage
      might be negated.)
     </para>
-->
<para>
    可以使用<productname>PostgreSQL</>备份工具产生单机热备。这些都是不能使用时间点恢复的备份，
往往备份和恢复比<application>pg_dump</>转储速度更快。
（他们也比<application>pg_dump</>转储更大，因此在某些情况下速度优势可能是否定的
）。
</para>

     <!--
<para>
      As with base backups, the easiest way to produce a standalone
      hot backup is to use the <xref linkend="app-pgbasebackup">
      tool. If you include the <literal>-X</> parameter when calling
      it, all the transaction log required to use the backup will be
      included in the backup automatically, and no special action is
      required to restore the backup.
     </para>
-->
<para>
     作为基础备份，最简单的方式是使用<xref linkend="app-pgbasebackup">工具产生单机热备份。
 当调用它时，如果你有<literal>-X</>参数，那么所有需要使用备份的事务日志将包含在自动备份中，
 并且不需要特殊操作恢复备份。
</para>

     
<para>
     <!--
      If more flexibility in copying the backup files is needed, a lower
      level process can be used for standalone hot backups as well.
      To prepare for low level standalone hot backups, set <varname>wal_level</> to
      <literal>archive</> (or <literal>hot_standby</>), <varname>archive_mode</> to
      <literal>on</>, and set up an <varname>archive_command</> that performs
      archiving only when a <emphasis>switch file</> exists.  For example:
  -->
  如果在复制备份文件中需要更大的灵活性，较低的水平过程可更好用于单机热备份。 
  为了准备低水平单机热备份，设置<varname>wal_level</>到
      <literal>archive</> (或者<literal>hot_standby</>), <varname>archive_mode</>为
      <literal>on</>，并且只有当<emphasis>开关文件</>存在时，
  建立<varname>archive_command</>执行存档。例如：

<programlisting>
archive_command = 'test ! -f /var/lib/pgsql/backup_in_progress || (test ! -f /var/lib/pgsql/archive/%f &amp;&amp; cp %p /var/lib/pgsql/archive/%f)'
</programlisting>
      <!--
      This command will perform archiving when
      <filename>/var/lib/pgsql/backup_in_progress</> exists, and otherwise
      silently return zero exit status (allowing <productname>PostgreSQL</>
      to recycle the unwanted WAL file).
  -->
  当<filename>/var/lib/pgsql/backup_in_progress</>存在时，这个命令将执行归档。
  否则默默返回零退出状态（允许<productname>PostgreSQL</>回收不需要的WAL文件）。
     </para>
     
<para>
     <!--
      With this preparation, a backup can be taken using a script like the
      following:
  -->
  有了这个准备，备份可以使用如下脚本：

<programlisting>
touch /var/lib/pgsql/backup_in_progress
psql -c "select pg_start_backup('hot_backup');"
tar -cf /var/lib/pgsql/backup.tar /var/lib/pgsql/data/
psql -c "select pg_stop_backup();"
rm /var/lib/pgsql/backup_in_progress
tar -rf /var/lib/pgsql/backup.tar /var/lib/pgsql/archive/
</programlisting>
      <!--
      The switch file <filename>/var/lib/pgsql/backup_in_progress</> is
      created first, enabling archiving of completed WAL files to occur.
      After the backup the switch file is removed. Archived WAL files are
      then added to the backup so that both base backup and all required
      WAL files are part of the same <application>tar</> file.
      Please remember to add error handling to your backup scripts.
  -->
  开关文件<filename>/var/lib/pgsql/backup_in_progress</>是第一次创建，  
  使已完成的WAL文件的归档发生。在备份后删除开关文件。归档的WAL文件然后添加至备份，
  使两个基础备份和所有必需的WAL文件是相同的<application>tar</>文件的一部分。
  请记住，错误处理添加到您的备份脚本中。
     </para>
    </sect3>

    <sect3 id="compressed-archive-logs">
 <!--
     <title>Compressed Archive Logs</title>
 -->
 <title>压缩归档日志</title>

     
<para>
     <!--
      If archive storage size is a concern, you can use
      <application>gzip</application> to compress the archive files:
 --> 
 如果归档存储大小是一个问题，你可以使用<application>gzip</application>
 压缩归档文件：
<programlisting>
archive_command = 'gzip &lt; %p &gt; /var/lib/pgsql/archive/%f'
</programlisting>
      <!--
      You will then need to use <application>gunzip</> during recovery:
  -->
  在恢复过程中你需要使用<application>gunzip</>：
<programlisting>
restore_command = 'gunzip &lt; /mnt/server/archivedir/%f &gt; %p'
</programlisting>
     </para>
    </sect3>

    <sect3 id="backup-scripts">
 <!--
     <title><varname>archive_command</varname> Scripts</title>
 -->
  <title><varname>archive_command</varname>脚本</title>

     
<para>
     <!--
      Many people choose to use scripts to define their
      <varname>archive_command</varname>, so that their
      <filename>postgresql.conf</> entry looks very simple:
  -->
  许多人选择使用脚本定义他们的<varname>archive_command</varname>，
  因此<filename>postgresql.conf</>记录看起来很简单：
<programlisting>
archive_command = 'local_backup_script.sh "%p" "%f"'
</programlisting>
       <!--
      Using a separate script file is advisable any time you want to use
      more than a single command in the archiving process.
      This allows all complexity to be managed within the script, which
      can be written in a popular scripting language such as
      <application>bash</> or <application>perl</>.
  -->
   任何你想在归档过程中使用不只是独立命令时。
   使用一个单独的脚本文件是可取的，这允许所有的复杂性在脚本中管理，
   这可以使用流行的脚本语言书写，如<application>bash</>或者<application>perl</>。
     </para>

     
<para>
     <!--
      Examples of requirements that might be solved within a script include:
  -->
  可能在脚本中解决的所需例子包含：
      <itemizedlist>
       <listitem>
        <para>
 <!--
         Copying data to secure off-site data storage
 -->
 拷贝数据到安全异地数据存储
        </para>

       </listitem>
       <listitem>
        <!--
<para>
         Batching WAL files so that they are transferred every three hours,
         rather than one at a time
        </para>
-->
<para>
     计量WAL文件以致于他们每三个小时改变，而不是一个时间。
</para>
       </listitem>
       <listitem>
        <!--
<para>
         Interfacing with other backup and recovery software
        </para>
-->
<para>
      其他备份和恢复软件接口
</para>
       </listitem>
       <listitem>
        <!--
<para>
         Interfacing with monitoring software to report errors
        </para>
-->
<para>
      监控软件报告错误接口
</para>
       </listitem>
      </itemizedlist>
     </para>

     <tip>
      <!--
<para>
       When using an <varname>archive_command</varname> script, it's desirable
       to enable <xref linkend="guc-logging-collector">.
       Any messages written to <systemitem>stderr</> from the script will then
       appear in the database server log, allowing complex configurations to
       be diagnosed easily if they fail.
      </para>
-->
<para>
    当使用<varname>archive_command</varname>脚本时，期望启动<xref linkend="guc-logging-collector">。
来自脚本写入<systemitem>stderr</>中的任何消息将出现在数据库服务器日志中，
如果失败，则允许简单地诊断复杂配置。
</para>
     </tip>
    </sect3>
  </sect2>

  <sect2 id="continuous-archiving-caveats">
  <!--
   <title>Caveats</title>
  -->
   <title>警告</title>
  
<para>
     <!--
    At this writing, there are several limitations of the continuous archiving
    technique.  These will probably be fixed in future releases:
-->
    目前，在线备份技术还有几个局限。它们可能在将来的版本中修补：

  <itemizedlist>
   <listitem>
    <para>
  <!--
     Operations on hash indexes are not presently WAL-logged, so
     replay will not update these indexes.  This will mean that any new inserts
     will be ignored by the index, updated rows will apparently disappear and
     deleted rows will still retain pointers. In other words, if you modify a
     table with a hash index on it then you will get incorrect query results
     on a standby server.  When recovery completes it is recommended that you
     manually <xref linkend="sql-reindex">
     each such index after completing a recovery operation.
 -->
 在Hash索引上的操作目前没有使用WAL记录日志，所以重放就不会更新这些索引类型。
 这将意味着任何新的插入被索引忽略，已更新行显然会消失，并且已删除行将仍然保留指针。
 换句话说，如果你修改了带有hash索引的表，那么你将获得备用服务器上不正确的查询结果。
 当完成恢复时，建议是在完成恢复操作之后手工<xref linkend="sql-reindex">每个这样的索引。
    </para>
   </listitem>

   <listitem>
    <!--
<para>
     If a <xref linkend="sql-createdatabase">
     command is executed while a base backup is being taken, and then
     the template database that the <command>CREATE DATABASE</> copied
     is modified while the base backup is still in progress, it is
     possible that recovery will cause those modifications to be
     propagated into the created database as well.  This is of course
     undesirable.  To avoid this risk, it is best not to modify any
     template databases while taking a base backup.
    </para>
-->
<para>
    如果在进行数据库备份的时候发出一个<xref linkend="sql-createdatabase">命令，
然后在这个过程中<command>CREATE DATABASE</>命令拷贝的模板数据库被修改了，
那么用这个备份进行恢复的数据库很有可能导致这些修改也传播到新创建的数据库中去。
这个行为当然是不愿意看到的。为了避免这个风险，
最好在进行数据库备份的时候不要修改任何模板数据库。

</para>
   </listitem>

   <listitem>
    <!--
<para>
     <xref linkend="sql-createtablespace">
     commands are WAL-logged with the literal absolute path, and will
     therefore be replayed as tablespace creations with the same
     absolute path.  This might be undesirable if the log is being
     replayed on a different machine.  It can be dangerous even if the
     log is being replayed on the same machine, but into a new data
     directory: the replay will still overwrite the contents of the
     original tablespace.  To avoid potential gotchas of this sort,
     the best practice is to take a new base backup after creating or
     dropping tablespaces.
    </para>
-->
<para>
   <xref linkend="sql-createtablespace">命令是用文本的绝对路径记录WAL日志的，
   因此会以相同的绝对路径重新创建。如果日志是在另外一台机器上重放，
   那么这个行为可能不是我们想要的。即使在同一台机器，
   但是在一个新的数据目录里重放日志，都很可能是危险的：
   重放仍将会覆盖原来的表空间的内容。
   为了避免这类的潜在问题，
   最好的方法是在创建或者删除表空间之后进行一次新的基础备份。
</para>
   </listitem>
  </itemizedlist>
   </para>

   <!--
<para>
    It should also be noted that the default <acronym>WAL</acronym>
    format is fairly bulky since it includes many disk page snapshots.
    These page snapshots are designed to support crash recovery, since
    we might need to fix partially-written disk pages.  Depending on
    your system hardware and software, the risk of partial writes might
    be small enough to ignore, in which case you can significantly
    reduce the total volume of archived logs by turning off page
    snapshots using the <xref linkend="guc-full-page-writes">
    parameter.  (Read the notes and warnings in <xref linkend="wal">
    before you do so.)  Turning off page snapshots does not prevent
    use of the logs for PITR operations.  An area for future
    development is to compress archived WAL data by removing
    unnecessary page copies even when <varname>full_page_writes</> is
    on.  In the meantime, administrators might wish to reduce the number
    of page snapshots included in WAL by increasing the checkpoint
    interval parameters as much as feasible.
   </para>
-->
<para>
  还要注意，缺省的<acronym>WAL</acronym>格式体积相当大，因为它包含许多磁盘页快照。
  这些磁盘页快照是设计来支持崩溃恢复的，
  因为我们可能需要修补部分写入的磁盘页。根据你的系统硬件和软件的不同，
  这种部分写入的危险可能是微乎其微的。这种情况下，
  你可以通过使用<xref linkend="guc-full-page-writes">关闭磁盘页面快照，
  从而大大减少归档日志的总尺寸(在你这么做之前，阅读<xref linkend="wal">里面的注意和警告)。
  关闭页面快照并不阻止日志使用PITR操作。
  一个将来需要开发的功能是在<varname>full_page_writes</>打开的时候，
  通过删除不需要的磁盘页拷贝来压缩归档的 WAL 数据。同时，
  管理员可以通过尽量合理地增加检查点的时间间隔来减少包含在WAL里的页面快照。
</para>
  </sect2>
 </sect1>

</chapter>
