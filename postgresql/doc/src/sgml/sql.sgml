<!-- doc/src/sgml/sql.sgml -->

 <chapter id="sql-intro">
  <title>SQL</title>

  <abstract>
   <para>
    本章介绍关系数据库背后的数学概念。本章不是必读章节，因此如果你在这里停滞不前或者想直接看一些简单的例子，请随便跳到下一章并且在你有更多时间和耐心时再返回本章。这里的材料应该是有趣的！
   </para>

   <para>
    这份材料最初是作为 Stefan Simkovic 的硕士学位论文（<xref linkend="SIM98" endterm="SIM98">）的一部分出现。
   </para>
  </abstract>

  <para>
   <acronym>SQL</acronym>已经成为最流行的关系型查询语言。名字<quote><acronym>SQL</acronym></quote>是<firstterm>Structured Query Language</firstterm>的一个缩写。在 1974 年，Donald Chamberlin 和其他人在 IBM 的研究中定义了语言 SEQUEL （<firstterm>Structured English Query Language</firstterm>）。这种语言最早在一个 IBM 原型中实现，在 1974-1975 年被称为 SEQUEL-XRM。在 1976-1977 一个被称为 SEQUEL/2 的修改版 SEQUEL 被定义并且名字随后被改成了<acronym>SQL</acronym>。
  </para>

  <para>
   一个新的被称为系统 R 的原型在 1977 年被 IBM 开发出来。系统 R 实现了 SEQUEL/2（现在的<acronym>SQL</acronym>）的一个大的子集并且在该项目期间对<acronym>SQL</acronym>做出了一些改变。系统 R 被安装在了一些用户站点上，包括内部的 IBM 站点以及某些选择的客户站点。感谢在那些用户站点上对系统 R 的成功和接受，IBM 开始基于系统 R 的技术开发实现了<acronym>SQL</acronym>的商业产品。
  </para>

  <para>
   在接下来的数年内 IBM 和一些其他提供商宣布了各种<acronym>SQL</acronym>产品，例如
   <productname>SQL/DS</productname>（IBM）、
   <productname>DB2</productname>（IBM）、
   <productname>ORACLE</productname>（Oracle Corp.）、
   <productname>DG/SQL</productname>（Data General Corp.）和<productname>SYBASE</productname>（Sybase Inc.）。
  </para>

  <para>
   <acronym>SQL</acronym>现在也是一个官方标准。在 1982 年，美国国家标准协会（<acronym>ANSI</acronym>）特许它的数据库委员会 X3H2 来开发一个用于标准关系语言的提案。这个提案在 1986 年被批准并且组成了 IBM 的<acronym>SQL</acronym>的核心部分。在 1987 年这个<acronym>ANSI</acronym>标准也被国际标准化组织（<acronym>ISO</acronym>）接受为一项国际标准。<acronym>SQL</acronym>的这个最早的标准版本常常被非正式地称作<quote><abbrev>SQL/86</abbrev></quote>。在 1989 年最早的版本被扩展并且这个新标准常常被非正式地称为<quote><abbrev>SQL/89</abbrev></quote>。也是在 1989 年，一个被称作<firstterm>数据库语言嵌入式<acronym>SQL</acronym></firstterm>（<acronym>ESQL</acronym>）的相关标准被开发出来。
  </para>

  <para>
   <acronym>ISO</acronym>和<acronym>ANSI</acronym>委员会已经工作了多年来扩展原始的标准，这个大幅度扩展过的版本被非正式地称为<firstterm><acronym>SQL2</acronym></firstterm>或<firstterm><acronym>SQL/92</acronym></firstterm>。这个版本在 1992 年后期被批准为一项标准 - <quote>International Standard ISO/IEC 9075:1992,
   Database Language <acronym>SQL</acronym></quote>。<acronym>SQL/92</acronym>就是人们通常所指的<quote>那个<acronym>SQL</acronym>标准</quote>。关于<acronym>SQL/92</acronym>的详细描述在<xref linkend="DATE97" endterm="DATE97">中可以找到。在编写这份文档时，一项新的标准也正在开发中，它被非正式地称为<firstterm><acronym>SQL3</acronym></firstterm>。它计划将<acronym>SQL</acronym>变成一种图灵完全语言，即所有可计算的查询（例如递归查询）都会成为可能。这已经作为 SQL:2003 完成。
  </para>

  <sect1 id="rel-model">
   <title>关系数据模型</title>

  <para>
    如前所述，<acronym>SQL</acronym>是一种关系型语言。这意味着它基于由 E. F. Codd 于 1970 年最早发表的<firstterm>关系数据模型</firstterm>。我们将稍后给出一些关系模型的形式化描述（在<xref linkend="formal-notion" endterm="formal-notion">中），但是首先我们想要从一种更直观的视角看看这个模型。
  </para>

  <para>
    一个<firstterm>关系数据库</firstterm>在其用户看来是一个<firstterm>表的集合</firstterm>（并且没有除了表之外的其他东西）。一个表由行和列组成，其中每一行表示一个记录而每一列表示表中所含记录的一个属性。<xref linkend="supplier-fig" endterm="supplier-fig">展示了一个由三个表组成的数据库的例子：

    <itemizedlist>
     <listitem>
      <para>
       SUPPLIER 是一个存储提供商的号码（SNO）、名称（SNAME）和城市（CITY）的表。
      </para>
     </listitem>

     <listitem>
      <para>
       PART 是一个存储部件的号码（PNO）、名称（PNAME）和价格（PRICE）的表。
      </para>
     </listitem>

     <listitem>
      <para>
       SELLS 存储有关哪个提供商（SNO）销售哪种部件（PNO）的信息。它的作用在某种意义上是把其他两个表连接起来。
      </para>
     </listitem>
    </itemizedlist>

    <example>
     <title id="supplier-fig">提供商和部件数据库</title>
<screen>
SUPPLIER:                   SELLS:
 SNO |  SNAME  |  CITY       SNO | PNO
----+---------+--------     -----+-----
 1  |  Smith  | London        1  |  1
 2  |  Jones  | Paris         1  |  2
 3  |  Adams  | Vienna        2  |  4
 4  |  Blake  | Rome          3  |  1
                              3  |  3
                              4  |  2
PART:                         4  |  3
 PNO |  PNAME  |  PRICE       4  |  4
----+---------+---------
 1  |  Screw  |   10
 2  |  Nut    |    8
 3  |  Bolt   |   15
 4  |  Cam    |   25
</screen>
    </example>
   </para>

   <para>
    表 PART 和 SUPPLIER 可以被看成是<firstterm>实体</firstterm>而 SELLS 可以被看成是一个特定部件和一个特定提供商之间的一个<firstterm>关系</firstterm>。
   </para>

   <para>
    正如我们后面将看到的，<acronym>SQL</acronym>在表上操作，但是在那之前我们将先学习关系模型的理论。
   </para>
  </sect1>

  <sect1 id="relmodel-formal">
   <title id="formal-notion">关系数据模型形式</title>

   <para>
    关系模型底层的数学概念是集合论的<firstterm>关系</firstterm>，它是一个域列表的笛卡尔积的一个子集。这种集合论的关系（不要把它和<firstterm>Entity-Relationship model</firstterm>中的关系弄混）为该模型带来了它的名称。形式上一个域就是一个值的集合。例如，整数集合就是一个域。长度为 20 的字符串的集合以及实数的集合也是域的例子。
   </para>

   <para>
<!--
\begin{definition}
The <firstterm>Cartesian product</firstterm> of domains $D_{1},
    D_{2},\ldots, D_{k}$ written
\mbox{$D_{1} \times D_{2} \times \ldots \times D_{k}$} is the set of
all $k$-tuples $(v_{1},v_{2},\ldots,v_{k})$ such that \mbox{$v_{1} \in
D_{1}, v_{2} \in D_{2}, \ldots, v_{k} \in D_{k}$}.
\end{definition}
-->
    域
    <parameter>D<subscript>1</subscript></parameter>、
    <parameter>D<subscript>2</subscript></parameter>、
    ...
    <parameter>D<subscript>k</subscript></parameter>的<firstterm>笛卡尔积</firstterm>集被写成
    <parameter>D<subscript>1</subscript></parameter> &times;
    <parameter>D<subscript>2</subscript></parameter> &times;
    ... &times;
    <parameter>D<subscript>k</subscript></parameter>，它是一个所有 k 元组
    <parameter>v<subscript>1</subscript></parameter>、
    <parameter>v<subscript>2</subscript></parameter>、
    ...
    <parameter>v<subscript>k</subscript></parameter>的集合
    这样
    <parameter>v<subscript>1</subscript></parameter> &isin;
    <parameter>D<subscript>1</subscript></parameter>、
    <parameter>v<subscript>2</subscript></parameter> &isin;
    <parameter>D<subscript>2</subscript></parameter>、
    ...
    <parameter>v<subscript>k</subscript></parameter> &isin;
    <parameter>D<subscript>k</subscript></parameter>。
   </para>

   <para>
    例如，当我们有
<!--
 $k=2$, $D_{1}=\{0,1\}$ and
$D_{2}=\{a,b,c\}$, then $D_{1} \times D_{2}$ is
$\{(0,a),(0,b),(0,c),(1,a),(1,b),(1,c)\}$.
-->
    <parameter>k</parameter>=2、
    <parameter>D<subscript>1</subscript></parameter>=<literal>{0,1}</literal>并且
    <parameter>D<subscript>2</subscript></parameter>=<literal>{a,b,c}</literal>那么
    <parameter>D<subscript>1</subscript></parameter> &times;
    <parameter>D<subscript>2</subscript></parameter>是
    <literal>{(0,a),(0,b),(0,c),(1,a),(1,b),(1,c)}</literal>。
   </para>

   <para>
<!--
\begin{definition}
A Relation is any subset of the Cartesian product of one or more
domains: $R \subseteq$ \mbox{$D_{1} \times D_{2} \times \ldots \times D_{k}$}
\end{definition}
-->
    一个关系是一个或多个域的笛卡尔积的任意子集：<parameter>R</parameter> &sube;
    <parameter>D<subscript>1</subscript></parameter> &times;
    <parameter>D<subscript>2</subscript></parameter> &times;
    ... &times;
    <parameter>D<subscript>k</subscript></parameter>。
   </para>

   <para>
    例如<literal>{(0,a),(0,b),(1,a)}</literal>是一个关系，它实际上是上面提到的
    <parameter>D<subscript>1</subscript></parameter> &times;
    <parameter>D<subscript>2</subscript></parameter>的一个子集。
   </para>

   <para>
    一个关系的成员被称为元组。某个笛卡尔积
    <parameter>D<subscript>1</subscript></parameter> &times;
    <parameter>D<subscript>2</subscript></parameter> &times;
    ... &times;
    <parameter>D<subscript>k</subscript></parameter>的每一个关系被说成有元数<literal>k</literal>并且因此是一个<literal>k</literal>-元组的集合。
   </para>

   <para>
    一个关系可以被视为一个表（和我们已经做过的一样，记住<xref linkend="supplier-fig" endterm="supplier-fig">中每一个元组被表示为一行并且每一列对应一个元组的一个部分。为列命名（称为属性）就得到了一个<firstterm>关系模式</firstterm>的定义。
   </para>

   <para>
<!--
\begin{definition}
A {\it relation scheme} $R$ is a finite set of attributes
\mbox{$\{A_{1},A_{2},\ldots,A_{k}\}$}. There is a domain $D_{i}$ for
each attribute $A_{i}, 1 \le i \le k$ where the values of the
attributes are taken from. We often write a relation scheme as
\mbox{$R(A_{1},A_{2},\ldots,A_{k})$}.
\end{definition}
-->
    一个<firstterm>关系模式</firstterm> <literal>R</literal>是一个属性
    <parameter>A<subscript>1</subscript></parameter>、
    <parameter>A<subscript>2</subscript></parameter>、
    ...
    <parameter>A<subscript>k</subscript></parameter>的有限集合。
    对每一个属性<parameter>A<subscript>i</subscript></parameter>（
    1 &lt;= <literal>i</literal> &lt;= <literal>k</literal>）有一个域
    <parameter>D<subscript>i</subscript></parameter>，属性的值来自于对应的域中。我们常常把一个关系模式写成
    <literal>R(<parameter>A<subscript>1</subscript></parameter>,
    <parameter>A<subscript>2</subscript></parameter>,
    ...
    <parameter>A<subscript>k</subscript></parameter>)</literal>。

    <note>
     <para>
      一个<firstterm>关系模式</firstterm>只是一种模板，而一个<firstterm>关系</firstterm>是一种<firstterm>关系模式</firstterm>的一个实例。关系由元组构成（并且因此能被看成是一个表），但关系模式不是这样。
     </para>
    </note>
   </para>

   <sect2>
    <title id="domains">域 vs. 数据类型</title>

    <para>
     我们在上一节里经常谈到<firstterm>域</firstterm>。回想一下，形式化地来说，一个域就是一个值的集合（例如整数集合或实数集合）。在数据库系统的术语中，我们经常用<firstterm>数据类型</firstterm>来代替域。当我们定义一个表时，我们必须决定包括哪些属性。另外我们还必须决定将存储哪种数据来作为属性值。例如表<classname>SUPPLIER</classname>中<classname>SNAME</classname>的值将是字符串，而<classname>SNO</classname>将存储整数。我们通过为每一个属性分派一种数据类型来定义这些。<classname>SNAME</classname>的类型将是<type>VARCHAR(20)</type>（这是<acronym>SQL</acronym>对于长度 &lt;= 20 的字符串的类型），<classname>SNO</classname>的类型将是<type>INTEGER</type>。通过一个数据类型的指派，我们还可以为一个属性选择一个域。<classname>SNAME</classname>的域是所有长度 &lt;= 20 的字符串的集合，<classname>SNO</classname>的域是所有整数的集合。
    </para>
   </sect2>
  </sect1>

  <sect1 id="relmodel-oper">
   <title id="operations">关系数据模型中的操作</title>

   <para>
    在前一节（<xref linkend="formal-notion" endterm="formal-notion">）中，我们定义了关系模型的数学符号。现在我们知道数据是如何使用一个关系数据模型存储的，但是我们还不知道如何操作所有这些表来从数据库中检索一些东西。例如，某人可能会询问所有出售部件 'Screw' 的供应商的名字。因此有两种不同的表达关系上操作的记号法：

    <itemizedlist>
     <listitem>
      <para>
       <firstterm>关系代数</firstterm>是一种代数记号法，在其中查询被表达为在关系上应用专门的操作符。
      </para>
     </listitem>

     <listitem>
      <para>
       <firstterm>关系演算</firstterm>是一种逻辑记号法，在其中通过用公式表示答案中元组应该满足的一些逻辑限制来表达查询。
      </para>
    </listitem>
    </itemizedlist>
   </para>

   <sect2>
    <title id="rel-alg">关系代数</title>

    <para>
     <firstterm>关系代数</firstterm>由 E. F. Codd 于 1972 年引入。它由一组关系上的操作构成：

     <itemizedlist>
      <listitem>
       <para>
        SELECT (&sigma;)：从一个关系中抽取满足一个给定限制的<firstterm>元组</firstterm>。令<parameter>R</parameter>是一个包含属性<parameter>A</parameter>的表。
&sigma;<subscript>A=a</subscript>(R) = {t &isin; R &mid; t(A) = a}
        其中<literal>t</literal>表示<parameter>R</parameter>的一个元组并且<literal>t(A)</literal>表示元组<literal>t</literal>中属性<parameter>A</parameter>的值。
       </para>
      </listitem>

      <listitem>
       <para>
        PROJECT (&pi;)：从一个关系中抽取指定的<firstterm>属性</firstterm>（列）。令<classname>R</classname>是一个包含属性<classname>X</classname>的关系。
        &pi;<subscript>X</subscript>(<classname>R</classname>) = {t(X) &mid; t &isin; <classname>R</classname>}
        其中<literal>t</literal>(<classname>X</classname>) 表示元组<literal>t</literal>中属性<classname>X</classname>的值。
       </para>
      </listitem>

      <listitem>
       <para>
        PRODUCT (&times;)：构建两个关系的笛卡尔积。令<classname>R</classname>是一个元数为<literal>k</literal><subscript>1</subscript>的表并且令<classname>S</classname>是一个元数为<literal>k</literal><subscript>2</subscript>的表。<classname>R</classname> &times; <classname>S</classname>是所有<literal>k</literal><subscript>1</subscript>
        + <literal>k</literal><subscript>2</subscript>-元组的集合，这种元组的前<literal>k</literal><subscript>1</subscript>个分量来自于<classname>R</classname>中的一个元组并且后<literal>k</literal><subscript>2</subscript>个分量来自<classname>S</classname>中的一个元组。
       </para>
      </listitem>

      <listitem>
       <para>
        UNION (&cup;)：构建两个表的集合论并。给定表<classname>R</classname>和<classname>S</classname>（都必须具有相同的元数），并<classname>R</classname> &cup; <classname>S</classname>是由来自<classname>R</classname>的元组和来自<classname>S</classname>的元组构成的集合。
       </para>
      </listitem>

      <listitem>
       <para>
        INTERSECT (&cap;)：构建两个表的集合论交。给定表<classname>R</classname>和<classname>S</classname>，<classname>R</classname> &cap; <classname>S</classname>是同时在<classname>R</classname>和<classname>S</classname>中的元组的集合。这里我们再次要求<classname>R</classname>和<classname>S</classname>具有相同的元数。
       </para>
      </listitem>

      <listitem>
       <para>
        DIFFERENCE (&minus; or &setmn;)：构建两个表的集合差。令<classname>R</classname>和<classname>S</classname>是具有相同元数的两个表。<classname>R</classname> - <classname>S</classname>是在<classname>R</classname>中但不在<classname>S</classname>中的元组的集合。
       </para>
      </listitem>

      <listitem>
       <para>
        JOIN (&prod;)：通过两个表的公共属性连接它们。令<classname>R</classname>是一个有属性<classname>A</classname>、<classname>B</classname>和<classname>C</classname>的表，并且令<classname>S</classname>是一个有属性<classname>C</classname>、<classname>D</classname>和<classname>E</classname>的表。在两个表之间有一个公共属性<classname>C</classname>。
<!--
        <classname>R</classname> &prod; <classname>S</classname> =
        &pi;<subscript><classname>R</classname>.<classname>A</classname>,<classname>R</classname>.<classname>B</classname>,<classname>R</classname>.<classname>C</classname>,<classname>S</classname>.<classname>D</classname>,<classname>S</classname>.<classname>E</classname></subscript>(&sigma;<subscript><classname>R</classname>.<classname>C</classname>=<classname>S</classname>.<classname>C</classname></subscript>(<classname>R</classname> &times; <classname>S</classname>)).
-->
        R &prod; S = &pi;<subscript>R.A,R.B,R.C,S.D,S.E</subscript>(&sigma;<subscript>R.C=S.C</subscript>(R &times; S))。
        这里我们要做什么呢？我们首先计算笛卡尔积<classname>R</classname> &times; <classname>S</classname>。然后我们选择那些在公共属性<classname>C</classname>上值相等（&sigma;<subscript>R.C = S.C</subscript>）的元组。现在我们得到一个表，它包含了属性<classname>C</classname>两次，并且我们会将重复列投影掉。
       </para>

       <example>
        <title id="join-example">一个内连接</title>

        <para>
         让我们看看通过计算一次连接所需的步骤产生的表。给定下面的两个表：

<screen>
R:                 S:
 A | B | C          C | D | E
---+---+---        ---+---+---
 1 | 2 | 3          3 | a | b
 4 | 5 | 6          6 | c | d
 7 | 8 | 9
</screen>
        </para>
       </example>

       <para>
        首先我们计算笛卡尔积<classname>R</classname> &times; <classname>S</classname>，并且得到：

<screen>
R x S:
 A | B | R.C | S.C | D | E
---+---+-----+-----+---+---
 1 | 2 |  3  |  3  | a | b
 1 | 2 |  3  |  6  | c | d
 4 | 5 |  6  |  3  | a | b
 4 | 5 |  6  |  6  | c | d
 7 | 8 |  9  |  3  | a | b
 7 | 8 |  9  |  6  | c | d
</screen>
       </para>

       <para>
        在进行选择
        &sigma;<subscript>R.C=S.C</subscript>(R &times; S)
        后我们得到：

<screen>
 A | B | R.C | S.C | D | E
---+---+-----+-----+---+---
 1 | 2 |  3  |  3  | a | b
 4 | 5 |  6  |  6  | c | d
</screen>
       </para>

       <para>
        为了消除重复列<classname>S</classname>.<classname>C</classname>，我们通过下面的操作将它投影掉：
        &pi;<subscript>R.A,R.B,R.C,S.D,S.E</subscript>(&sigma;<subscript>R.C=S.C</subscript>(R &times; S))
        并且得到：

<screen>
 A | B | C | D | E
---+---+---+---+---
 1 | 2 | 3 | a | b
 4 | 5 | 6 | c | d
</screen>
       </para>
      </listitem>

      <listitem>
       <para>
        DIVIDE (&divide;)：令<classname>R</classname>是一个有属性 A、B、C 和 D 的表并且另<classname>S</classname>是一个有属性 C 和 D 的表。那么我们定义除为：

<programlisting>
R &divide; S = {t &mid; &forall; t<subscript>s</subscript> &isin; S &exist; t<subscript>r</subscript> &isin; R
</programlisting>

        这样
t<subscript>r</subscript>(A,B)=t&and;t<subscript>r</subscript>(C,D)=t<subscript>s</subscript>}
        其中
        t<subscript>r</subscript>(x,y)
        表示一个表<classname>R</classname>的元组，它由两个分量<literal>x</literal>和<literal>y</literal>组成。注意该元组<literal>t</literal>只由关系<classname>R</classname>的分量<classname>A</classname>和<classname>B</classname>组成。
       </para>

       <para id="divide-example">
        给定下列表

<screen>
R:                    S:
 A | B | C | D         C | D
---+---+---+---       ---+---
 a | b | c | d         c | d
 a | b | e | f         e | f
 b | c | e | f
 e | d | c | d
 e | d | e | f
 a | b | d | e
</screen>

        R &divide; S
        会得到

<screen>
 A | B
---+---
 a | b
 e | d
</screen>
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <para>
     关于关系代数的详细描述和定义可以参考 [<xref linkend="ULL88" endterm="ULL88">] 或 [<xref linkend="DATE04" endterm="DATE04">]。
    </para>

    <example>
     <title id="suppl-rel-alg">使用关系代数的一个查询</title>
     <para>
      回顾一下，我们形式化了所有那些能从数据库中检索数据的操作符。让我们回到前一节（<xref linkend="operations" endterm="operations">）中的例子，其中某人想要知道所有销售部件<literal>Screw</literal>的供应商的名称。这个问题可以通过使用下列操作的关系代数来回答：

<programlisting>
&pi;<subscript>SUPPLIER.SNAME</subscript>(&sigma;<subscript>PART.PNAME='Screw'</subscript>(SUPPLIER &prod; SELLS &prod; PART))
</programlisting>
     </para>

     <para>
      我们称这样一种操作为查询。如果我们针对我们的例子表（<xref linkend="supplier-fig" endterm="supplier-fig">）计算上面的查询，我们将得到下面的结果：

<screen>
 SNAME
-------
 Smith
 Adams
</screen>
     </para>
    </example>
   </sect2>

   <sect2 id="rel-calc">
    <title>关系演算</title>

    <para>
     关系演算基于<firstterm>一阶逻辑</firstterm>。关系演算有两种变体：

     <itemizedlist>
      <listitem>
       <para>
        <firstterm>域关系演算</firstterm>（<acronym>DRC</acronym>），其中变量代表元组的分量（属性）。
       </para>
      </listitem>

      <listitem>
       <para>
        <firstterm>元组关系演算</firstterm>（<acronym>TRC</acronym>），其中变量代表元组。
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <para>
     我们只想讨论元组关系演算，因为它是处于大部分关系语言底层的一种语言。关于<acronym>DRC</acronym>（以及还有<acronym>TRC</acronym>）的详细讨论可以见
     <xref linkend="DATE04" endterm="DATE04">
     或
     <xref linkend="ULL88" endterm="ULL88">。
    </para>
   </sect2>

   <sect2>
    <title>元组关系演算</title>

    <para>
     <acronym>TRC</acronym>中用到的查询具有下面的形式：

<programlisting>
x(A) &mid; F(x)
</programlisting>

     其中<literal>x</literal>是一个元组变量，<classname>A</classname>是一个属性集合而<literal>F</literal>是一个公式。由所有满足<literal>F(t)</literal>的元组<literal>t(A)</literal>构成结果关系。
    </para>

    <para>
     如果我们想要使用<acronym>TRC</acronym>来回答例子<xref linkend="suppl-rel-alg" endterm="suppl-rel-alg">中的问题，我们可以构造下面的查询：

<programlisting>
{x(SNAME) &mid; x &isin; SUPPLIER &and;
    &exist; y &isin; SELLS &exist; z &isin; PART (y(SNO)=x(SNO) &and;
    z(PNO)=y(PNO) &and;
    z(PNAME)='Screw')}
</programlisting>
    </para>

    <para>
     针对<xref linkend="supplier-fig" endterm="supplier-fig">中的表计算该查询会再次得到<xref linkend="suppl-rel-alg" endterm="suppl-rel-alg">中相同的结果。
    </para>
   </sect2>

   <sect2 id="alg-vs-calc">
    <title>关系代数 vs. 关系演算</title>

    <para>
     关系代数和关系演算具有相同的<firstterm>表达能力</firstterm>，即所有能用关系代数表达的查询也能使用关系演算表达，反之亦然。这最初被 E. F. Codd 在 1972 年所证明。这个证明基于一个算法（<quote>Codd 的规约算法</quote>），通过它一个任意关系演算表达式可以被规约到一个语义上等价的关系代数表达式。关于此的详细讨论可以参考
     <xref linkend="DATE04" endterm="DATE04">
     和
     <xref linkend="ULL88" endterm="ULL88">。
    </para>

    <para>
     有时候我们说基于关系演算的语言比基于关系代数的语言<quote>更高层</quote>或者<quote>更具说明性</quote>，因为代数（部分地）指定了操作的顺序，而演算把决定最有效计算顺序的工作留给一个编译器或解释器来做。
    </para>
   </sect2>
  </sect1>

  <sect1 id="sql-language">
   <title><acronym>SQL</acronym>语言</title>

   <para>
    作为一种现代关系语言，<acronym>SQL</acronym>基于元组关系演算。因此每一个能用元组关系演算（或者等价的关系代数）表达的查询也能用<acronym>SQL</acronym>表达。但是，它有超出关系代数或演算范围的能力。这里是<acronym>SQL</acronym>提供的一些额外特性的列表，它们不是关系代数或演算的一部分：

    <itemizedlist>
     <listitem>
      <para>
       用于插入、删除或修改数据的命令。
      </para>
     </listitem>

     <listitem>
      <para>
       算术能力：在<acronym>SQL</acronym>中能够和比较一样涉及算术操作，例如：

<programlisting>
A &lt; B + 3.
</programlisting>

       注意在关系代数或关系演算中不出现 + 或其他算术操作符。
      </para>
     </listitem>

     <listitem>
      <para>
       赋值和打印命令：可以打印由一个查询构造的关系并且为一个计算的关系指派一个关系名。
      </para>
     </listitem>

     <listitem>
      <para>
       聚集函数：诸如<firstterm>average</firstterm>、<firstterm>sum</firstterm>、<firstterm>max</firstterm>等操作可以被应用在一个关系的列上来得到一个单一量。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <sect2 id="select">
    <title id="select-title">选择</title>

    <para>
     <acronym>SQL</acronym>中最常用的命令是<command>SELECT</command>语句，它被用来检索数据。语法是：

<synopsis>
SELECT [ ALL | DISTINCT [ ON ( <replaceable class="PARAMETER">expression</replaceable> [, ...] ) ] ]
    * | <replaceable class="PARAMETER">expression</replaceable> [ [ AS ] <replaceable class="PARAMETER">output_name</replaceable> ] [, ...]
    [ INTO [ TEMPORARY | TEMP ] [ TABLE ] <replaceable class="PARAMETER">new_table</replaceable> ]
    [ FROM <replaceable class="PARAMETER">from_item</replaceable> [, ...] ]
    [ WHERE <replaceable class="PARAMETER">condition</replaceable> ]
    [ GROUP BY <replaceable class="PARAMETER">expression</replaceable> [, ...] ]
    [ HAVING <replaceable class="PARAMETER">condition</replaceable> [, ...] ]
    [ { UNION | INTERSECT | EXCEPT } [ ALL ] <replaceable class="PARAMETER">select</replaceable> ]
    [ ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC | USING <replaceable class="parameter">operator</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...] ]
    [ LIMIT { <replaceable class="PARAMETER">count</replaceable> | ALL } ]
    [ OFFSET <replaceable class="PARAMETER">start</replaceable> ]
    [ FOR { UPDATE | SHARE } [ OF <replaceable class="parameter">table_name</replaceable> [, ...] ] [ NOWAIT ] [...] ]
</synopsis>
    </para>

    <para>
     现在我们将通过多个例子阐述<command>SELECT</command>语句的复杂语法。这些例子中用到的表被定义在<xref linkend="supplier-fig" endterm="supplier-fig">中。
    </para>

    <sect3>
     <title>简单选择</title>

     <para>
      这里是一些使用<command>SELECT</command>语句的简单例子：

      <example>
       <title id="simple-query">带条件的简单查询</title>
       <para>
        要从表 PART 中检索属性 PRICE 大于 10 的所有元组，我们可以用下面的查询：

<programlisting>
SELECT * FROM PART
    WHERE PRICE &gt; 10;
</programlisting>

        并且得到表：

<screen>
 PNO |  PNAME  |  PRICE
-----+---------+--------
  3  |  Bolt   |   15
  4  |  Cam    |   25
</screen>
       </para>

       <para>
        在<command>SELECT</command>中使用<quote>*</quote>将会显示表中所有的属性。如果我们想只检索表 PART 中的 PNAME 和 PRICE 属性，我们使用语句：

<programlisting>
SELECT PNAME, PRICE
    FROM PART
    WHERE PRICE &gt; 10;
</programlisting>

        在这种情况下结果是：

<screen>
                      PNAME  |  PRICE
                     --------+--------
                      Bolt   |   15
                      Cam    |   25
</screen>

        注意<acronym>SQL</acronym> <command>SELECT</command>对应于关系代数中的<quote>投影</quote>而不是<quote>选择</quote>（详见<xref linkend="rel-alg" endterm="rel-alg">）。
       </para>

       <para>
        WHERE 子句中的条件也可以用关键词 OR、AND 和 NOT 进行连接：

<programlisting>
SELECT PNAME, PRICE
    FROM PART
    WHERE PNAME = 'Bolt' AND
         (PRICE = 0 OR PRICE &lt;= 15);
</programlisting>

        将会得到结果：

<screen>
 PNAME  |  PRICE
--------+--------
 Bolt   |   15
</screen>
       </para>

       <para>
        算术运算可以被用在目标列表和 WHERE 子句中。例如我们想要知道买两份部件的价格，我们可以使用下面的查询：

<programlisting>
SELECT PNAME, PRICE * 2 AS DOUBLE
    FROM PART
    WHERE PRICE * 2 &lt; 50;
</programlisting>

        并且我们得到：

<screen>
 PNAME  |  DOUBLE
--------+---------
 Screw  |    20
 Nut    |    16
 Bolt   |    30
</screen>

        注意关键词 AS 后面的词 DOUBLE 是第二列的新标题。这种技术可以被用在目标列表中的每一个元素上来为结果列指派一个新标题。这种新标题通常被称为别名。别名不能被用在该查询的剩余部分。
       </para>
      </example>
     </para>
    </sect3>

    <sect3>
     <title>连接</title>

     <para id="simple-join">
      下面的例子展示了<firstterm>连接</firstterm>在<acronym>SQL</acronym>中是如何实现的。
     </para>

     <para>
      要在三个表 SUPPLIER、PART 和 SELLS 的公共属性上连接它们，我们可以用下面的语句：

<programlisting>
SELECT S.SNAME, P.PNAME
    FROM SUPPLIER S, PART P, SELLS SE
    WHERE S.SNO = SE.SNO AND
          P.PNO = SE.PNO;
</programlisting>

      并且得到下面的结果表：

<screen>
 SNAME | PNAME
-------+-------
 Smith | Screw
 Smith | Nut
 Jones | Cam
 Adams | Screw
 Adams | Bolt
 Blake | Nut
 Blake | Bolt
 Blake | Cam
</screen>
     </para>

     <para>
      在 FROM 子句中我们为每一个关系引入了一个别名，因为在关系之间有公共命名属性（SNO 和 PNO）。现在我们可以通过在属性名前面放上别名及一个句点来区分公共命名属性。连接采用<xref linkend="join-example" endterm="join-example">中所示的相同方式计算。首先是生成笛卡尔积

      SUPPLIER &times; PART &times; SELLS

      。现在只选择那些满足 WHERE 子句中给定条件的元组（即公共命名属性必须相等）。最后我们投影掉除 S.SNAME 和 P.PNAME 之外的其他列。
     </para>

     <para>
     另一种执行连接的方法是使用如下的 SQL JOIN 语法：
<programlisting>
SELECT sname, pname from supplier
    JOIN sells USING (sno)
    JOIN part USING (pno);
</programlisting>
    再次得到：
<screen>
 sname | pname
-------+-------
 Smith | Screw
 Adams | Screw
 Smith | Nut
 Blake | Nut
 Adams | Bolt
 Blake | Bolt
 Jones | Cam
 Blake | Cam
(8 rows)
</screen>
     </para>

     <para>
     使用 JOIN 语法创建的一个连接表，是一个出现在 FROM 子句中的表引用列表项并且它位于任何 WHERE、GROUP BY 或 HAVING 子句之前。其他表引用（包括表名或其他 JOIN 子句）可以用逗号分隔的方式被包括在 FROM 子句中。JOIN 的表逻辑上和列在 FROM 子句中的其他表是相似的。
     </para>

     <para>
      SQL JOIN 有两种主要类型：CROSS JOIN（无条件连接）和<firstterm>条件 JOIN</>。条件连接可以进一步被按照<firstterm>连接条件</>被指定的方式（ON、USING 或 NATURAL）和被应用的方式（INNER 或 OUTER 连接）来划分。
     </para>

    <variablelist>
        <title>连接类型</title>
        <varlistentry>
            <term>CROSS JOIN</term>
            <listitem>
            <cmdsynopsis>
                <arg choice="req"> <replaceable class="parameter">T1</replaceable> </arg>
                <command> CROSS JOIN </command>
                <arg choice="req"> <replaceable class="parameter">T2</replaceable> </arg>
            </cmdsynopsis>

            <para>
            一个交叉连接采用两个表 T1 和 T2，它们分别有 N 和 M 行，并且返回一个连接表，其中包含所有的 N*M 个可能的连接行。对于 T1 的每一行 R1，T2 的每一行 R2 都会与 R1 连接来得到一个连接表行 JR，JR 由 R1 和 R2 中所有的域组成。一个 CROSS JOIN 等价于一个 INNER JOIN ON TRUE。
            </para>
            </listitem>
        </varlistentry>

        <varlistentry>
            <term>条件 JOIN</term>
            <listitem>

            <cmdsynopsis>
            <arg choice="req"> <replaceable class="parameter">T1</replaceable> </arg>
            <arg choice="opt"> NATURAL </arg>
            <group choice="opt">
                <arg choice="opt"> INNER </arg>
                <arg choice="plain">
                <group choice="req">
                    <arg choice="plain"> LEFT </arg>
                    <arg choice="plain"> RIGHT </arg>
                    <arg choice="plain"> FULL </arg>
                </group>
                <arg choice="opt"> OUTER </arg>
                    </arg>
                </group>
            <command> JOIN </command>
            <arg choice="req"> <replaceable class="parameter">T2</replaceable> </arg>
            <group choice="req">
                <arg choice="plain"> ON <replaceable>搜索条件</replaceable></arg>
                <arg choice="plain"> USING ( <replaceable>连接列列表</replaceable> ) </arg>
            </group>
            </cmdsynopsis>

            <para>
            一个条件 JOIN 必须通过提供一个（并且只要一个）NATURAL、ON 或 USING 来指定它的连接条件。ON 子句用一个和 WHERE 子句中相同的<replaceable>搜索条件</replaceable>。USING 子句采用一个用逗号分隔的列名列表，其中的列是被连接表必须公有的并且将连接要求在那些列上相等。NATURAL 是一个列出两个表公共列名的 USING 子句的简写。USING 和 NATURAL 都有的一个副作用是每种被连接列只会有一个拷贝被发送到结果表中（比较一下先前关系代数中对 JOIN 的定义）。
            </para>

            <!-- begin join semantics -->
            <variablelist>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <arg choice="opt"> INNER </arg>
                        <command> JOIN </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                <para>
                对 T1 的每一行 R1，连接表为 T2 中与 R1 满足连接条件的每一行都有一个行。
                </para>
                <tip>
                <para>
                    单词 INNER 和 OUTER 对于所有 JOIN 都是可选的。INNER 是默认值。LEFT、RIGHT 和 FULL 暗示一个 OUTER JOIN。
                    </para>
                </tip>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <arg choice="plain"> LEFT </arg>
                        <arg choice="opt"> OUTER </arg>
                        <command> JOIN </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                <para>
                首先执行一个 INNER JOIN。然后对于 T1 中每一个与 T2 中任意行都不满足连接条件的行，将返回一个额外的连接行，它在来自于 T2 的列上取空值。
                </para>
                <tip>
                    <para>
                    连接表对于 T1 的每一行都无条件地有一行。
                    </para>
                </tip>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <arg choice="plain"> RIGHT </arg>
                        <arg choice="opt"> OUTER </arg>
                        <command> JOIN </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                <para>
                首先执行一个 INNER JOIN。然后对于 T2 中每一个与 T1 中任意行都不满足连接条件的行，将返回一个额外的连接行，它在来自于 T1 的列上取空值。
                </para>
                <tip>
                    <para>
                    连接表对于 T2 的每一行都无条件地有一行。
                    </para>
                </tip>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <arg choice="plain"> FULL </arg>
                        <arg choice="opt"> OUTER </arg>
                        <command> JOIN </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                <para>
                首先执行一个 INNER JOIN。然后对于 T1 中每一个与 T2 中任意行都不满足连接条件的行，将返回一个额外的连接行，它在来自于 T2 的列上取空值。此外，对于 T2 中每一个与 T1 中任意行都不满足连接条件的行，将返回一个额外的连接行，它在来自于 T1 的列上取空值。
                </para>
                <tip>
                    <para>
                    连接表对于 T1 的每一行和 T2 的每一行都无条件地有一行。
                    </para>
                </tip>
                </listitem>
            </varlistentry>
            </variablelist>
            <!-- end join semantics -->

            </listitem>
        </varlistentry>
     </variablelist>

     <para>
     所有类型的 JOIN 都可以被串在一起或者嵌套，其中<replaceable class="parameter">T1</replaceable>和<replaceable class="parameter">T2</replaceable>的其中之一或两者都能作为 要连接的表。圆括号可以被用在 JOIN 子句周围来控制 JOIN 的顺序，否则将按照从左至右的顺序处理。
     </para>

    </sect3>

    <sect3>
     <title id="aggregates-tutorial">聚集函数</title>

     <para>
      <acronym>SQL</acronym>提供了诸如 AVG、COUNT、SUM、MIN 和 MAX 之类的聚集函数。一个聚集函数的参数会在每一个满足 WHERE 子句的行上计算，并且该聚集函数会在这个输入值的集合上进行计算。通常，对于一整个<command>SELECT</command>语句，一个聚集只会发送一个单一结果。但是如果在该查询中指定了分组，那么在每一个组的行上会完成一次独立的计算，并且会为每一个组发送一个聚集结果（见下一节）。

      <example>
       <title id="aggregates-example">聚集</title>

       <para>
        如果我们想知道表 PART 中所有部件的平均花销，我们可以使用下面的查询：

<programlisting>
SELECT AVG(PRICE) AS AVG_PRICE
    FROM PART;
</programlisting>
       </para>

       <para>
        结果是：

<screen>
 AVG_PRICE
-----------
   14.5
</screen>
       </para>

       <para>
        如果我们想了解在表 PART 中定义了多少种部件，我们可以用这个语句：

<programlisting>
SELECT COUNT(PNO)
    FROM PART;
</programlisting>

        并且得到：

<screen>
 COUNT
-------
   4
</screen>

       </para>
      </example>
     </para>
    </sect3>

    <sect3>
     <title>通过分组聚集</title>

     <para>
      <acronym>SQL</acronym>允许我们把一个表的元组划分成分组。那么上述的聚集函数就可以被应用到分组上 &mdash; 即聚集函数的值不再是根据指定列上的所有值计算，而是根据一个分组的所有值计算。因此聚集函数是为每一个分组独立计算的。
     </para>

     <para>
      要将元组划分成分组，可以使用关键词<command>GROUP BY</command>及其后定义分组的属性列表。如果我们有<command>GROUP BY A<subscript>1</subscript>, &tdot;, A<subscript>k</subscript></command>，我们就将关系划分成了分组，这样只有当两个元组在所有的属性 A<subscript>1</subscript>, &tdot;, A<subscript>k</subscript> 上达成一致时，它们才属于同一个分组。

      <example>
       <title id="aggregates-groupby">聚集</title>
       <para>
        如果我们想知道每一个供应商销售多少种部件，我们可以构造查询：

<programlisting>
SELECT S.SNO, S.SNAME, COUNT(SE.PNO)
    FROM SUPPLIER S, SELLS SE
    WHERE S.SNO = SE.SNO
    GROUP BY S.SNO, S.SNAME;
</programlisting>

        并且得到：

<screen>
 SNO | SNAME | COUNT
-----+-------+-------
  1  | Smith |   2
  2  | Jones |   1
  3  | Adams |   2
  4  | Blake |   3
</screen>
       </para>

       <para>
        现在让我们看看这里发生了什么。首先表 SUPPLIER 和 SELLS 的连接被生成：

<screen>
 S.SNO | S.SNAME | SE.PNO
-------+---------+--------
   1   |  Smith  |   1
   1   |  Smith  |   2
   2   |  Jones  |   4
   3   |  Adams  |   1
   3   |  Adams  |   3
   4   |  Blake  |   2
   4   |  Blake  |   3
   4   |  Blake  |   4
</screen>
       </para>

       <para>
        接着我们把元组划分成分组，做法是把所有在属性 S.SNO 和 S.SNAME 上相等的元组放在一起：

<screen>
 S.SNO | S.SNAME | SE.PNO
-------+---------+--------
   1   |  Smith  |   1
                 |   2
--------------------------
   2   |  Jones  |   4
--------------------------
   3   |  Adams  |   1
                 |   3
--------------------------
   4   |  Blake  |   2
                 |   3
                 |   4
</screen>
       </para>

       <para>
        在我们的例子中得到了四个分组并且现在我们可以将聚集函数 COUNT 应用在每一个分组上来得到上面给定查询的最终结果。
       </para>
      </example>
     </para>

     <para>
      注意要使一个使用 GROUP BY 和聚集函数的查询有意义，目标列表只能直接引用被分组的属性。其他属性只能被用在聚集函数的参数中。否则将不会有唯一的值与其他属性相关联。
     </para>

     <para>
      还可以观察到，求一个聚集的聚集是没有意义的，例如 AVG(MAX(sno))，因为一个<command>SELECT</command>只做一趟分组以及聚集。你可以在 FROM 子句中使用一个临时表或者子-SELECT 来做第一层聚集，然后再来得到这类查询的结果。
     </para>
    </sect3>

    <sect3>
     <title>Having</title>

     <para>
      HAVING 子句工作起来非常像 WHERE 子句并且被用来只考虑那些满足 HAVING 子句中给定条件的分组。本质上，WHERE 会在分组和聚集完成之前过滤掉不需要的输入行，而 HAVING 则会过滤掉分组之后的不需要的分组行。因此，WHERE 不能饮用聚集函数的结果。从另一方面来说，写一个不涉及聚集函数的 HAVING 条件是没有意义的！如果你的条件不涉及聚集，你应该把它写在 WHERE 中，并且因此可以避免在那些你本来准备丢弃掉的分组上计算聚集。

      <example>
       <title id="having-example">Having</title>

       <para>
        如果我们还想要那些销售超过一种部件的供应商，我们可以使用查询：

<programlisting>
SELECT S.SNO, S.SNAME, COUNT(SE.PNO)
    FROM SUPPLIER S, SELLS SE
    WHERE S.SNO = SE.SNO
    GROUP BY S.SNO, S.SNAME
    HAVING COUNT(SE.PNO) &gt; 1;
</programlisting>

        并且得到：

<screen>
 SNO | SNAME | COUNT
-----+-------+-------
  1  | Smith |   2
  3  | Adams |   2
  4  | Blake |   3
</screen>
       </para>
      </example>
     </para>
    </sect3>

    <sect3>
     <title>子查询</title>

     <para>
      在 WHERE 和 HAVING 子句中，可以在任何需要一个值的地方使用子查询（子选择）。在这种情况下，必须先计算子查询来得到该值。子查询的使用扩展了<acronym>SQL</acronym>的表达能力。

      <example>
       <title id="subselect-example">子选择</title>

       <para>
        如果我们想要知道所有价格比名为 'Screw' 的部件高的部件，我们可以使用查询：

<programlisting>
SELECT *
    FROM PART
    WHERE PRICE &gt; (SELECT PRICE FROM PART
                   WHERE PNAME='Screw');
</programlisting>
       </para>

       <para>
        结果是：

<screen>
 PNO |  PNAME  |  PRICE
-----+---------+--------
  3  |  Bolt   |   15
  4  |  Cam    |   25
</screen>
       </para>

       <para>
        当我们查看上述查询时，我们可以看到关键词<command>SELECT</command>两次。第一个出现在该查询的开始 - 我们将称之为外部<command>SELECT</command> - 以及另外一个出现在 WHERE 子句中，它开始了一个嵌套的查询 - 我们将称之为内部<command>SELECT</command>。对于外部<command>SELECT</command>的每一个元组，内部<command>SELECT</command>都必须被计算一次。在每一次计算后我们就知道名为 'Screw' 的元组的价格，并且我们能够检查实际元组的价格是否超过之（实际上，在这个例子中内部查询只需要被计算一次，因为它不依赖于外部查询）。
       </para>

       <para>
        如果我们想知道所有不销售任何部件的供应商（例如这样可以从数据库中移除这些供应商），我们可以使用：

<programlisting>
SELECT *
    FROM SUPPLIER S
    WHERE NOT EXISTS
        (SELECT * FROM SELLS SE
         WHERE SE.SNO = S.SNO);
</programlisting>
       </para>

       <para>
        在我们的例子中，结果将为空，因为每一个供应商至少销售一种部件。注意我们在内部<command>SELECT</command>的 WHERE 子句中使用了来自于外部<command>SELECT</command>的 S.SNO。这里子查询必须为来自于外部查询的每一个元组都计算一次以得到最新值，即 S.SNO 的值总是从外部<command>SELECT</command>的当前元组中取得。
       </para>
      </example>
     </para>
    </sect3>

    <sect3>
     <title>FROM 中的子查询</title>

     <para>
      一种使用子查询的不同方式是把它们放在 FROM 子句中。这是一种有用的特性，因为一个这种形式的子查询可以输出多列和多行，而被用在表达式中的一个子查询只能给出一个单一结果。它也让我们可以在无需依靠一个临时表就可以多轮次的分组/聚集。

      <example>
       <title id="subselect-in-from-example">FROM 中的子选择</title>

       <para>
        如果我们想知道所有供应商中最高的平均部件价格，我们不能写成 MAX(AVG(PRICE))，但我们可以写：

<programlisting>
SELECT MAX(subtable.avgprice)
    FROM (SELECT AVG(P.PRICE) AS avgprice
          FROM SUPPLIER S, PART P, SELLS SE
          WHERE S.SNO = SE.SNO AND
                P.PNO = SE.PNO
          GROUP BY S.SNO) subtable;
</programlisting>

        子查询为每一个供应商返回一行（因为它有 GROUP BY），并且我们在外部查询中对那些行进行聚集。
       </para>
      </example>
     </para>
    </sect3>

    <sect3>
     <title>并、交、差</title>

     <para>
      These operations calculate the union, intersection and set theoretic
      difference of the tuples derived by two subqueries.

      <example>
       <title id="union-example">并、交、差</title>

       <para>
        下面的查询是一个 UNION 的例子：

<programlisting>
SELECT S.SNO, S.SNAME, S.CITY
    FROM SUPPLIER S
    WHERE S.SNAME = 'Jones'
UNION
    SELECT S.SNO, S.SNAME, S.CITY
    FROM SUPPLIER S
    WHERE S.SNAME = 'Adams';
</programlisting>

给出结果：

<screen>
 SNO | SNAME |  CITY
-----+-------+--------
  2  | Jones | Paris
  3  | Adams | Vienna
</screen>
       </para>

       <para>
        下面是 INTERSECT 的一个例子：

<programlisting>
SELECT S.SNO, S.SNAME, S.CITY
    FROM SUPPLIER S
    WHERE S.SNO &gt; 1
INTERSECT
    SELECT S.SNO, S.SNAME, S.CITY
    FROM SUPPLIER S
    WHERE S.SNO &lt; 3;
</programlisting>

        给出结果：

<screen>
 SNO | SNAME |  CITY
-----+-------+--------
  2  | Jones | Paris
</screen>

        该查询的两部分会返回的唯一元组是具有 SNO=2 的那一个。
       </para>

       <para>
        最后是 EXCEPT 的一个例子：

<programlisting>
SELECT S.SNO, S.SNAME, S.CITY
    FROM SUPPLIER S
    WHERE S.SNO &gt; 1
EXCEPT
    SELECT S.SNO, S.SNAME, S.CITY
    FROM SUPPLIER S
    WHERE S.SNO &gt; 3;
</programlisting>

        给出结果：

<screen>
 SNO | SNAME |  CITY
-----+-------+--------
  2  | Jones | Paris
  3  | Adams | Vienna
</screen>
       </para>
      </example>
     </para>
    </sect3>
   </sect2>

   <sect2 id="datadef">
    <title>数据定义</title>

    <para>
     这是包括在<acronym>SQL</acronym>语言中的一组用于数据定义的命令。
    </para>

    <sect3 id="create">
     <title id="create-title">创建表</title>

     <para>
      数据定义中最基础的命令是创建一个新关系（一个新表）的命令。<command>CREATE TABLE</command>命令的语法是：

<synopsis>
CREATE TABLE <replaceable class="parameter">table_name</replaceable>
    (<replaceable class="parameter">name_of_attr_1</replaceable> <replaceable class="parameter">type_of_attr_1</replaceable>
     [, <replaceable class="parameter">name_of_attr_2</replaceable> <replaceable class="parameter">type_of_attr_2</replaceable>
     [, ...]]);
</synopsis>

      <example>
       <title id="table-create">表创建</title>

       <para>
        要创建<xref linkend="supplier-fig" endterm="supplier-fig">中定义的表，使用下面的<acronym>SQL</acronym>语句：

<programlisting>
CREATE TABLE SUPPLIER
    (SNO   INTEGER,
     SNAME VARCHAR(20),
     CITY  VARCHAR(20));
</programlisting>

<programlisting>
CREATE TABLE PART
    (PNO   INTEGER,
     PNAME VARCHAR(20),
     PRICE DECIMAL(4 , 2));
</programlisting>

<programlisting>
CREATE TABLE SELLS
    (SNO INTEGER,
     PNO INTEGER);
</programlisting>
       </para>
      </example>
     </para>
    </sect3>

    <sect3>
     <title><acronym>SQL</acronym>中的数据类型</title>

     <para>
      下面是<acronym>SQL</acronym>所支持的一些数据类型的列表：

      <itemizedlist>
       <listitem>
        <para>
         INTEGER：有符号全字二进制整数（31 位精度）。
        </para>
       </listitem>

       <listitem>
        <para>
         SMALLINT：有符号半字二进制整数（15 位精度）。
        </para>
       </listitem>

       <listitem>
        <para>
         DECIMAL (<replaceable class="parameter">p</replaceable>[,<replaceable class="parameter">q</replaceable>])：带符号压缩十进制数字，最高<replaceable class="parameter">p</replaceable>个数位，其中<replaceable class="parameter">q</replaceable>个数位位于小数点右边。如果<replaceable class="parameter">q</replaceable>被忽略，则它被假定为 0。
        </para>
       </listitem>

       <listitem>
        <para>
         FLOAT：有符号双字浮点数字。
        </para>
       </listitem>

       <listitem>
        <para>
         VARCHAR(<replaceable class="parameter">n</replaceable>)：最大长度为<replaceable class="parameter">n</replaceable>的变长字符串。
        </para>
       </listitem>

       <listitem>
        <para>
         CHAR(<replaceable class="parameter">n</replaceable>)：长度为<replaceable class="parameter">n</replaceable>的定长字符串。
        </para>
       </listitem>

      </itemizedlist>
     </para>
    </sect3>

    <sect3>
     <title>创建索引</title>

     <para>
      索引被用来加速对一个关系的访问。如果一个关系<classname>R</classname>在属性<classname>A</classname>上有一个索引，那么我们可以检索所有<replaceable>t</replaceable>(<classname>A</classname>) = <replaceable>a</replaceable>的元组<replaceable>t</replaceable>，所花费的时间大约与这类元组<replaceable>t</replaceable>的数量成比例，而不是与<classname>R</classname>的尺寸成比例。
     </para>

     <para>
      要在<acronym>SQL</acronym>中创建一个索引，可以使用<command>CREATE INDEX</command>命令。语法是：

<programlisting>
CREATE INDEX <replaceable class="parameter">index_name</replaceable>
    ON <replaceable class="parameter">table_name</replaceable> ( <replaceable class="parameter">name_of_attribute</replaceable> );
</programlisting>
     </para>

     <para>
      <example>
       <title id="index-create">创建索引</title>

       <para>
        要在关系 SUPPLIER 的 SNAME 属性上创建一个名为 I 的索引，我们使用下面的语句：

<programlisting>
CREATE INDEX I ON SUPPLIER (SNAME);
</programlisting>
     </para>

       <para>
        被创建的索引将被自动维护，即不管什么时候一个新元组被插入到关系 SUPPLIER 中，索引 I 也会被更改。注意当一个索引存在时，一个用户唯一能观察到的改变是<command>SELECT</command>的速度增加了并且更新的速度降低了。
       </para>
      </example>
     </para>
    </sect3>

    <sect3>
     <title>创建视图</title>

     <para>
      一个视图可以被认为是一个<firstterm>虚拟表</firstterm>，即一个表在数据库中并不<emphasis>物理</emphasis>存在，但用户看起来却觉得它在物理上存在。相反，当我们谈论<firstterm>基本表</firstterm>时，对于该表的每一行在物理存储的某处被物理存储着。
     </para>

     <para>
      视图自己没有物理上独立的、可区分的已存储数据。相反，系统会在系统目录（见<xref linkend="tutorial-catalogs-title" endterm="tutorial-catalogs-title">）中的某处存储视图的定义（即关于如何访问物理上存储的基本表来物化视图的规则）。关于实现视图的不同技术的讨论可以参考
<!--
      section
      <xref linkend="view-impl" endterm="view-impl">.
-->
      <citetitle>SIM98</citetitle>。
     </para>

     <para>
      在<acronym>SQL</acronym>中<command>CREATE VIEW</command>命令被用来定义一个视图。语法是：

<programlisting>
CREATE VIEW <replaceable class="parameter">view_name</replaceable>
    AS <replaceable class="parameter">select_stmt</replaceable>
</programlisting>

      其中<replaceable class="parameter">select_stmt</replaceable>是一个按照<xref linkend="select-title" endterm="select-title">中定义的合法的选择语句。注意在视图被创建时，<replaceable class="parameter">select_stmt</replaceable>不会被执行。它只是被存储在<firstterm>系统目录</firstterm>中，并且在针对该视图执行一个查询时被执行。
     </para>

     <para>
      给定下面的视图定义（我们再次使用来自<xref linkend="supplier-fig" endterm="supplier-fig">中的表）：

<programlisting>
CREATE VIEW London_Suppliers
    AS SELECT S.SNAME, P.PNAME
        FROM SUPPLIER S, PART P, SELLS SE
        WHERE S.SNO = SE.SNO AND
              P.PNO = SE.PNO AND
              S.CITY = 'London';
</programlisting>
     </para>

     <para>
      现在我们可以把这个<firstterm>虚拟关系</firstterm><classname>London_Suppliers</classname>当作一个基本表来使用：

<programlisting>
SELECT * FROM London_Suppliers
    WHERE PNAME = 'Screw';
</programlisting>

      这将返回下面的表：

<screen>
 SNAME | PNAME
-------+-------
 Smith | Screw                 
</screen>
     </para>

     <para>
      要计算这个结果，数据库系统必须先做一次对基本表 SUPPLIER、SELLS 和 PART 的<emphasis>隐藏</emphasis>访问。它通过对那些基本表执行视图定义中给出的查询来这样做。之后附加的条件（在针对视图的查询中给出）可以被应用来得到结果表。
     </para>
    </sect3>

    <sect3>
     <title>删除表、删除索引、删除视图</title>

     <para>
      要摧毁一个表（包括其中存储的所有元组），可以使用<command>DROP TABLE</command>命令：

<programlisting>
DROP TABLE <replaceable class="parameter">table_name</replaceable>;
</programlisting>
      </para>

     <para>
      要毁掉 SUPPLIER 表可以使用下面的语句：

<programlisting>
DROP TABLE SUPPLIER;
</programlisting>
     </para>

     <para>
      <command>DROP INDEX</command>命令被用来毁掉一个索引：

<programlisting>
DROP INDEX <replaceable class="parameter">index_name</replaceable>;
</programlisting>
     </para>

     <para>
      最后使用命令<command>DROP VIEW</command>毁掉一个给定的视图：

<programlisting>
DROP VIEW <replaceable class="parameter">view_name</replaceable>;
</programlisting>
     </para>
    </sect3>
   </sect2>

   <sect2>
    <title>数据操纵</title>

    <sect3>
     <title>Insert Into</title>

     <para>
      一旦一个表被创建（见<xref linkend="create-title" endterm="create-title">），可以使用<command>INSERT INTO</command>命令为它填充元组。语法是：

<programlisting>
INSERT INTO <replaceable class="parameter">table_name</replaceable> (<replaceable class="parameter">name_of_attr_1</replaceable>
    [, <replaceable class="parameter">name_of_attr_2</replaceable> [, ...]])
    VALUES (<replaceable class="parameter">val_attr_1</replaceable> [, <replaceable class="parameter">val_attr_2</replaceable> [, ...]]);
</programlisting>
     </para>

     <para>
      要向关系 SUPPLIER（来自<xref linkend="supplier-fig" endterm="supplier-fig">）插入第一个元组，我们使用下面的语句：

<programlisting>
INSERT INTO SUPPLIER (SNO, SNAME, CITY)
    VALUES (1, 'Smith', 'London');
</programlisting>
     </para>

     <para>
      要向关系 SELLS 插入第一个元组：

<programlisting>
INSERT INTO SELLS (SNO, PNO)
    VALUES (1, 1);
</programlisting>
     </para>
    </sect3>

    <sect3>
     <title>更新</title>

     <para>
      要改变一个关系中一个或者多个属性值，可以使用<command>UPDATE</command>命令。语法是：

<programlisting>
UPDATE <replaceable class="parameter">table_name</replaceable>
    SET <replaceable class="parameter">name_of_attr_1</replaceable> = <replaceable class="parameter">value_1</replaceable>
        [, ... [, <replaceable class="parameter">name_of_attr_k</replaceable> = <replaceable class="parameter">value_k</replaceable>]]
    WHERE <replaceable class="parameter">condition</replaceable>;
</programlisting>
     </para>

     <para>
      要在关系 PART 中改变部件 'Screw' 的属性 PRICE 的值，使用：

<programlisting>
UPDATE PART
    SET PRICE = 15
    WHERE PNAME = 'Screw';
</programlisting>
     </para>

     <para>
      名字为 'Screw' 的属性 PRICE 的新值现在是 15。
     </para>
    </sect3>

    <sect3>
     <title>删除</title>

     <para>
      要从一个特定表中删除一个元组，使用命令 DELETE FROM。语法是：

<programlisting>
DELETE FROM <replaceable class="parameter">table_name</replaceable>
    WHERE <replaceable class="parameter">condition</replaceable>;
</programlisting>
     </para>

     <para>
      要在表 SUPPLIER 中删除名为 'Smith' 的供应商，可以使用下面的语句：

<programlisting>
DELETE FROM SUPPLIER
    WHERE SNAME = 'Smith';
</programlisting>
     </para>
    </sect3>
   </sect2>

   <sect2 id="tutorial-catalogs">
    <title id="tutorial-catalogs-title">系统目录</title>

    <para>
     在每一个<acronym>SQL</acronym>数据库系统中，<firstterm>系统目录</firstterm>被用来跟踪数据库中定义了哪些表、视图、索引等等。这些系统目录可以和普通关系一样被查询。例如，有一个目录被用来存放视图的定义。这个目录存储来自视图定义的查询。任何时候发生一个针对视图的查询时，系统首先会从该系统目录中得到<firstterm>视图定义查询</firstterm>，并且在处理用户查询之前物化该视图（详见
     and materializes the view
     before proceeding with the user query (see
<!--
      section
      <xref linkend="view-impl" endterm="view-impl">.
    <citetitle>SIM98</citetitle>
-->
     <xref linkend="SIM98" endterm="SIM98">）。更多关于系统目录的信息可参考<xref linkend="DATE04" endterm="DATE04">。
    </para>
   </sect2>

   <sect2>
    <title>嵌入式<acronym>SQL</acronym></title>

    <para>
     在这一节中，我们将介绍如何把<acronym>SQL</acronym>嵌入到一种宿主语言中（例如<literal>C</literal>）。有两个原因促使我们在一个宿主语言中使用<acronym>SQL</acronym>：

     <itemizedlist>
      <listitem>
       <para>
        有些查询无法使用纯<acronym>SQL</acronym>（即递归查询）写出。要能够执行这种查询，我们需要一种比<acronym>SQL</acronym>具有更强表达能力的宿主语言。
       </para>
      </listitem>

      <listitem>
       <para>
        我们只是想在用宿主语言编写的应用中访问一个数据库（例如，一个用 C 编写的有图形用户接口的订票系统中，有关哪些票还有剩余的信息被存储在数据库中，可以使用嵌入式<acronym>SQL</acronym>访问）。
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <para>
     一个在宿主语言中使用嵌入式<acronym>SQL</acronym>的程序由宿主语言的语句和<firstterm>嵌入式<acronym>SQL</acronym></firstterm>（<acronym>ESQL</acronym>）构成。每一个<acronym>ESQL</acronym>语句开始于关键词<command>EXEC SQL</command>。<acronym>ESQL</acronym>语句会被一个<firstterm>预编译器</firstterm>（它通常将执行多个<acronym>SQL</acronym>命令的调用插入到库例程中）转换成宿主语言的语句。
    </para>

    <para>
     当我们从头到尾查看<xref linkend="select-title" endterm="select-title">的例子时，我们意识到查询的结果常常是一个元组集合。大部分的宿主语言并非被设计用于在集合上操作，因此我们需要一种机制来访问一个 SELECT 语句返回的元组集合中的每一个元组。这种机制可以通过声明一个<firstterm>游标</firstterm>来提供。之后我们可以使用<command>FETCH</command>命令来检索一个元组，并且把游标指向像一个元组。
    </para>

    <para>
     嵌入式<acronym>SQL</acronym>的详细讨论请见<xref linkend="DATE97" endterm="DATE97">、<xref linkend="DATE04" endterm="DATE04">或<xref linkend="ULL88" endterm="ULL88">。
    </para>
   </sect2>
  </sect1>
 </chapter>
