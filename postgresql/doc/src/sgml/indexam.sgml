<!-- doc/src/sgml/indexam.sgml -->

<chapter id="indexam">
 <title>索引访问方法接口定义</title>

  <para>
   本章定义核心<productname>PostgreSQL</productname>系统和管理个别索引类型的<firstterm>索引访问方法</>之间的接口。除 了在这里指定的内容之外，核心系统对索引一无所知，因此可以通过编写附加代码来开发全新的索引类型。
  </para>

  <para>
   <productname>PostgreSQL</productname>中所有的索引在技术上都叫做<firstterm>二级索引</>。也就是说，索引在物理上与它描述的表文件分离。每个索引被存储为它自己的物理<firstterm>关系</>并且被<structname>pg_class</>目录中的一个项所描述。一个索引的内容完全受到其索引访问方法控制。实际上，所有索引访问方法都把索引划分成标准大小的页面， 这样它们就可以使用常规的存储管理器和缓冲区管理器来访问索引内容（所有现有的索引访问方法还使用<xref linkend="storage-page-layout">中描述的标准页面布局，并且它们都对索引元组头部使用相同的格式；但是这些决定都不是强制在访问方法上的）。
  </para>

  <para>
   索引实际上是一些数据键值与索引父表中行版本（元组）的<firstterm>元组标识符</>或<acronym>TIDs</>之间的映射。一个 TID 由一个块号和一个块内的项编号组成（见<xref linkend="storage-page-layout">）。 这对于从表中取一个特定行就足够了。索引并不直接知道在 MVCC下，同一个逻辑行可能有多个现存的版本；对于索引而言，每个 行都是一个独立的对象，都需要自己的索引项。因此，对一行的更新总是为该行创建全新的索引项，即使键值没有改变（HOT 元组对这段陈述来说是个异常，但是索引也不会处理这些）。死亡元组的索引项将在随着死亡元组的回收而被回收（通过清理）。
  </para>

 <sect1 id="index-catalog">
  <title>索引的目录项</title>

  <para>
   每个索引访问方法都在系统目录<structname>pg_am</structname>中用一行来描述（见<xref linkend="catalog-pg-am">）。一个 <structname>pg_am</structname>行的主要内容是引用<link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>中的项，它们标识索引访问方法提供的索引 访问函数。这些函数的 API 在本章稍后的部分中描述。另外，<structname>pg_am</structname>行指定了几个索引访问方法的固定属性，例如它是否 支持多列索引。目前还没有对创建或删除<structname>pg_am</structname>项提供特殊支持；任何能够编写一种新访问方法的人都需要能够为他们自己插入一个合适的行。
  </para>

  <para>
   要想真正有用，一个索引访问方法还必须有一个或多个定义在<link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>、
   <link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>、
   <link linkend="catalog-pg-amop"><structname>pg_amop</structname></link>和
   <link linkend="catalog-pg-amproc"><structname>pg_amproc</structname></link>中的<firstterm>操作符族</>和<firstterm>操作符类</>。这些项允许规划器判断哪种查询条件适用于这个索引访问方法的索引。操作符族和类在<xref linkend="xindex">中描述，它是阅读本章所需的前导材料。
  </para>

  <para>
   一个独立的索引是由一个<link linkend="catalog-pg-class"><structname>pg_class</structname></link>项定义的，该项描述索引为一个物理关系。还要加上一个<link linkend="catalog-pg-index"><structname>pg_index</structname></link>项来显示索引的逻辑内容 &mdash; 也就是说，它所拥有的索引列集以及这些列的语义是被相关操作符类刻画的。索引列（键值）可以是底层表的 简单列，也可以是该表行上的表达式。索引访问方法通常不关心索引的键值来自那里（它总是操作预计算过的键值），但是它会对<structname>pg_index</structname>中的操作符类信息很感兴趣。所有这些目录项都可以被当作<structname>关系</>数据结构的一部分访问，这个数据结构会被传递给索引上的所有操作。
  </para>

  <para>
   <structname>pg_am</structname>中的有些标志列的含义并不那么直观。<structfield>amcanunique</structfield>的要求在<xref linkend="index-unique-checks">中讨论。<structfield>amcanmulticol</structfield>标志断言该索引访问方法支持多列索引， <structfield>amoptionalkey</structfield>断言它允许对那种在第一个索引列上没有给出可索引限制子句的扫描。如果<structfield>amcanmulticol</structfield>为假，那么<structfield>amoptionalkey</structfield>实际上说的是该访问方法是否允许不带限制子句的全索引扫描。 那些支持多索引列的访问方法<emphasis>必须</>支持那些在省略了除第一个列之外的任何或所有其它列上约束的扫描；不过，它们被允许去要求在第一个列上出现一些限制，并且这一点是以把<structfield>amoptionalkey</structfield>设置为假作为标志的。一个索引 AM 可能将<structfield>amoptionalkey</structfield>设置为假的一种原因是，如果它不索引空值。因为大多数可索引的操作符都是严格的并且因此不能对空输入返回真，所以不为空值存储索引项咋看上去很吸引人：因为它们不 可能被一个索引扫描返回。不过，当一个索引扫描对于一个给定索引列上没有约束子句时，这种讨论就不成立了。实际上，这意 味着设置了<structfield>amoptionalkey</structfield>为真的索引必须索引空值，因为规划器可能会决定在根本没有扫描键的时候使用这样的索引。一个相关的限制是一个支持 多索引列的索引访问方法<emphasis>必须</>支持索引第一列之后的列中的空值，因 为规划器会认为这个索引可以用于在那些列上没有限制的查询。例如，考虑一个在(a,b)上的索引和一个有<literal>WHERE a = 4</literal>的查询。系统会认为该索引可以用于扫描 <literal>a = 4</literal>的行， 如果索引忽略了 b 为空的行，那么就是错误的。不过，忽略那些在第一个索引列上值为空的行是 OK 的。一个索引空的索引访问方法可能也会设置<structfield>amsearchnulls</structfield>，表明它支持将<literal>IS NULL</>和<literal>IS NOT NULL</>子句作为搜索条件。
  </para>

 </sect1>

 <sect1 id="index-functions">
  <title>索引访问方法函数</title>

  <para>
   索引访问方法必须提供的索引构造和维护函数有：
  </para>

  <para>
<programlisting>
IndexBuildResult *
ambuild (Relation heapRelation,
         Relation indexRelation,
         IndexInfo *indexInfo);
</programlisting>
   创建一个新索引。索引关系已经被物理创建，但是是空的。必须用索引访问方法要求的固定数据填充它，外加所有已经在表里的行的项。通常，<function>ambuild</>函数会调用<function>IndexBuildHeapScan()</>来扫描表以获取现有元组并计算需要被插入到索引的键。该函数必须返回一个已分配内存的结构，其中包含关于新索引的统计信息。
  </para>

  <para>
<programlisting>
void
ambuildempty (Relation indexRelation);
</programlisting>
<<<<<<< HEAD
<!--
   Build an empty index, and write it to the initialization fork (<symbol>INIT_FORKNUM</symbol>)
   of the given relation.  This method is called only for unlogged tables; the
   empty index written to the initialization fork will be copied over the main
   relation fork on each server restart.
-->
创建一个空的索引，并写到给定关系的初始fork(<symbol>INIT_FORKNUM</symbol>)中。
这个方法只会为unlogged表调用;在服务器重启动时写入到初始fork的空索引会被复制到主关系。
=======
   构建一个空索引，并且把它写入到给定关系的初始化分叉中（
   <symbol>INIT_FORKNUM</symbol>）。只会为不做日志的表调用这个方法，被写入到
   初始化分叉的空索引在每次服务器启动时将被复制到主关系分叉中。
>>>>>>> upstream/master
  </para>

  <para>
<programlisting>
bool
aminsert (Relation indexRelation,
          Datum *values,
          bool *isnull,
          ItemPointer heap_tid,
          Relation heapRelation,
          IndexUniqueCheck checkUnique);
</programlisting>
   向现有索引插入一个新元组。<literal>values</>和<literal>isnull</>数组给出需要被索引的键值，而<literal>heap_tid</>是要被索引的 TID。 如果该访问方法支持唯一索引（它的<structname>pg_am</>.<structfield>amcanunique</>标志为真），那么<literal>checkUnique</>指示要执行的唯一性检查类型。这根据唯一约束是否为可推迟的而变化，详见<xref linkend="index-unique-checks">。通常在执行唯一性检查时访问方法仅需要<literal>heapRelation</>参数（因为那时它将不得不到堆中验证元组的存活性）。
  </para>

  <para>
   该函数的布尔结果值仅仅在<literal>checkUnique</>为<literal>UNIQUE_CHECK_PARTIAL</>时才有意义。这种情况下一个 TRUE 结果意味着这个新项是已知唯一的，反之 FALSE 意味着它可能不 是唯一的（并且一个延迟的唯一性校验必须是预定的）。对于其他情况，建议使用一个常量 FALSE 结果。
  </para>

  <para>
   有些索引可能不会索引所有元组。如果元组不被索引，<function>aminsert</>应该仅返回而什么都不做。
  </para>

  <para>
<programlisting>
IndexBulkDeleteResult *
ambulkdelete (IndexVacuumInfo *info,
              IndexBulkDeleteResult *stats,
              IndexBulkDeleteCallback callback,
              void *callback_state);
</programlisting>
   从索引中删除元组。这是一个<quote>批量删除</>操作，它的意图是通过扫描整个索引并检查每个项看它是否需要被删除。被传递进来的<literal>callback</>函数必须被调用（调用风格是：<literal>callback(<replaceable>TID</>, callback_state) returns bool</literal>）来判断任何其引用的 TID 标识的索引项是否需要删除。必须返回 NULL 或者是一个 palloc 过的、 包含删除操作效果的统计信息的结构。如果不需要向<function>amvacuumcleanup</>传递信息，返回 NULL 也是 OK 的。
  </para>

  <para>
   由于<varname>maintenance_work_mem</>被限制，在删除多行的时候<function>ambulkdelete</>可能需要被调用多次。<literal>stats</>参数是对这个索引上一次调用的结果（在一个<command>VACUUM</>操作中第一次调用时是 NULL）。这将允许 AM 在整个操作过程中积累统计信息。典型的，如果被传递的<literal>stats</>非空，<function>ambulkdelete</>将会修改并返回相同的结构。
  </para>

  <para>
<programlisting>
IndexBulkDeleteResult *
amvacuumcleanup (IndexVacuumInfo *info,
                 IndexBulkDeleteResult *stats);
</programlisting>
   在一个<command>VACUUM</command>操作（零个或更多次<function>ambulkdelete</>调用）后清空。虽然不必做任何返回索引统计信息之外的事情，但是它可能执行批量清理，例如回收空索引页面。<literal>stats</>是最后一次<function>ambulkdelete</> 调用返回的东西或者 NULL（如果没有元组需要删除而未调用<function>ambulkdelete</>）。如果结果不是 NULL，那么它必须是一个已经被 palloc 的结构。它包含的统计信息将用于更新<structname>pg_class</>并且由<command>VACUUM</>报 告（如果给出了<literal>VERBOSE</>）。如果索引在<command>VACUUM</command>操作期间根本没有改变，那么返回 NULL 也是可以的，否则必须返回正确的统计信息。
  </para>

  <para>
   从<productname>PostgreSQL</productname> 8.4 开始，<function>amvacuumcleanup</>将也会在一个<command>ANALYZE</>操作结束时被调用。这种情况中<literal>stats</>总是 NULL 并且任何返回值都将会被忽略。这种情况可以通过检测<literal>info-&gt;analyze_only</literal>来区分。我们建议，在这样的调用中访问方法除了做插入后的清理之外什么也不做，并且那是仅仅是在一个自动清理工作者进程中。
  </para>

  <para>
<programlisting>
bool
amcanreturn (Relation indexRelation);
</programlisting>
<<<<<<< HEAD
<!--
   Check whether the index can support <firstterm>index-only scans</> by
   returning the indexed column values for an index entry in the form of an
   <structname>IndexTuple</structname>.  Return TRUE if so, else FALSE.  If the index AM can never
   support index-only scans (an example is hash, which stores only
   the hash values not the original data), it is sufficient to set its
   <structfield>amcanreturn</> field to zero in <structname>pg_am</>.
-->
检查索引是否支持<firstterm>index-only扫描</>，通过为一个索引项以<structname>IndexTuple</structname>的形式返回被索引的列值。
如果支持返回TRUE，否则返回FALSE。
如果索引AM永远不支持index-only扫描（比如hash，它只存储哈希值而不是原始数据），
可以有充分的理由把<structname>pg_am</>中的<structfield>amcanreturn</>字段设置为零。
=======
   通过返回型为一个<structname>IndexTuple</structname>的索引项的被索引列值，检查索引是否能支持<firstterm>只用索引的扫描</>。如果支持返回 TRUE，否则返回 FALSE。如果索引 AM 不能支持只用索引的扫描（一个例子是哈希，它只存储哈希值而不是原始数据），在<structname>pg_am</>中把它的<structfield>amcanreturn</>域设置为零就足够了。
>>>>>>> upstream/master
  </para>

  <para>
<programlisting>
void
amcostestimate (PlannerInfo *root,
                IndexPath *path,
                double loop_count,
                Cost *indexStartupCost,
                Cost *indexTotalCost,
                Selectivity *indexSelectivity,
                double *indexCorrelation);
</programlisting>
   估计一次索引扫描的开销。这个函数在下面的<xref linkend="index-cost-estimation">中有完整的讨论。
  </para>

  <para>
<programlisting>
bytea *
amoptions (ArrayType *reloptions,
           bool validate);
</programlisting>
   分析和验证一个索引的 reloptions 数组。仅当一个索引存在非空 reloptions 数组时才会被调用。<parameter>reloptions</>是一个<type>text</>数组，包含<replaceable>name</><literal>=</><replaceable>value</>形式的项。 该函数应当构建一个<type>bytea</>值，该值将被拷贝进索引的 relcache 项的<structfield>rd_options</>域。<type>bytea</>值的数据内容是开放由访问方法定义的， 大部分的标准访问方法都使用<structname>StdRdOptions</>结构。当<parameter>validate</>为真时，如果任何一个选项都不可识别或者含有非法值，该函数都应当报告一个适当的错误消息；当<parameter>validate</>为假时，非法 项应该被安静地忽略（当正在载入的选项已经在<structname>pg_catalog</>中时， <parameter>validate</>为假；仅在访问方法已经改变了选项的规则时才可能找 到非法项，并且在此情况下忽略废弃的项是合适的）。如果想要默认行为，那么返回 NULL 也 OK。
  </para>

  <para>
   当然，索引的目的是支持扫描那些匹配一个可索引<literal>WHERE</>情况的元组，常常也被称为<firstterm>限定词</>或<firstterm>扫描键</>。索引扫描的语义在下面的<xref linkend="index-scanning">中有完整的描述。一个索引访问方法可以支持<quote>普通</>索引扫描、<quote>位图</>索引扫描或者两者。一个索引访问方法必须或可能提供的与扫描相关的函数是：
  </para>

  <para>
<programlisting>
IndexScanDesc
ambeginscan (Relation indexRelation,
             int nkeys,
             int norderbys);
</programlisting>
   为一个索引扫描做准备。<literal>nkeys</>和<literal>norderbys</>参数说明要被用在扫描中的条件和排序操作符的数目，它们可以用于空间分配目的。注意扫描键的实际值还没有被提供。结果必须是一个 palloc 过的结构。由于实现的原因，索引访问方法<emphasis>必须</>通过调用<function>RelationGetIndexScan()</>来创建这个结构。在大多数情况中，<function>ambeginscan</>除了做这个调用和获取锁之外不会做很多工作，索引扫描启动中有趣的部分在<function>amrescan</>中。
  </para>

  <para>
<programlisting>
void
amrescan (IndexScanDesc scan,
          ScanKey keys,
          int nkeys,
          ScanKey orderbys,
          int norderbys);
</programlisting>
   开始或者重新开始一个索引扫描，可能使用的是一个新的扫描键（要想使用之前传递的键重新开始，给<literal>keys</> 和/或<literal>orderbys</>传递 NULL）。请注意，使用的键或排序操作符的个数不能大于传递给<function>ambeginscan</>的个数。实际上这个重新开始特性的使用场景是：在一个嵌套循环连接选取了一个新的 outer 元组时，因此需要一个新的键比较值，但扫描键结构仍然保持相同。
  </para>

  <para>
<programlisting>
boolean
amgettuple (IndexScanDesc scan,
            ScanDirection direction);
</programlisting>
   在给定扫描中取下一个元组，向给定方向移动（在索引中向前或者向后）。如果取到了元组，则返回 TRUE，如果取到匹配的元组，返回 FALSE。在 TRUE 的情况中，该元组的 TID 被存储在<literal>scan</>结构中。请注意<quote>成功</>只 意味着索引包含一个匹配扫描键的项，并不意味该元组仍然在堆中存在， 或者是能够通过调用者的快照测试。在成功时，<function>amgettuple</>也必须把<literal>scan-&gt;xs_recheck</>设 置成 TRUE 或者 FALSE。FALSE 意味着它确定索引项匹配扫描键。TRUE 意味着它并不确定，而且必须在取得堆元组之后对它重新检查扫描键表示的条件。 这条规定支持<quote>有损的</>索引操作符。注意重新检查仅仅对扫描条件扩展；一个部分索引谓语（如果有）从不被<function>amgettuple</>调用者重新检查。
  </para>

  <para>
   如果索引支持只用索引扫描（即<function>amcanreturn</function>对它返回 TRUE），则在成功时 AM 也必须检查<literal>scan-&gt;xs_want_itup</>，并且如果检查为真它必须返回索引项（存储在<literal>scan-&gt;xs_itup</>中的<structname>IndexTuple</>指针）的原始被索引数据，原始数据的形式按照元组描述符<literal>scan-&gt;xs_itupdesc</>来解释（由指针引用的数据的管理是访问方法的责任。至少在为扫描下一次调用<function>amgettuple</>、<function>amrescan</>或<function>amendscan</>之前，该数据必须是完好的）。
  </para>

  <para>
   如果访问方法支持<quote>普通</>索引扫描，只需要提供<function>amgettuple</>函数。如果不支持，它的<structname>pg_am</>行的<structfield>amgettuple</>域必须被设置为零。
  </para>

  <para>
<programlisting>
int64
amgetbitmap (IndexScanDesc scan,
             TIDBitmap *tbm);
</programlisting>
   在给定扫描中取所有元组并且把它们添加到调用者提供的<type>TIDBitmap</type>中（即，把元组 ID 的集合 OR 到已经存在于位图中的东西里面）。返回被取得的元组的数量（这可能仅仅是一个近似计数，例如一些 AM 不会去重）。在把元组 ID 插入到位图时，<function>amgetbitmap</>可以指明对指定元组 ID 要求重新检查扫描条件。这与<function>amgettuple</>的 <literal>xs_recheck</>输出参数类似。注意：在当前的实现中，这个特性的支持是和对位图本身有损存储的支持合并在一起的，并且调用者会对可重新检查的元组检查扫描条件和部分索引谓词（如果有）。但是，那不会总是真的。<function>amgetbitmap</>和 <function>amgettuple</>不能被用于同一个索引扫描；正如<xref linkend="index-scanning">中所解释的，在使用<function>amgetbitmap</>时也有其他的限制条件。
  </para>

  <para>
   如果访问方法支持<quote>bitmap</>索引扫描，则仅需要提供<function>amgetbitmap</>函数。如果不支持，它的<structname>pg_am</>行中的<structfield>amgetbitmap</>域必须被设置为零。
  </para>

  <para>
<programlisting>
void
amendscan (IndexScanDesc scan);
</programlisting>
   结束扫描并释放资源。不应该释放<literal>scan</>结构本身，但访问方法内部使用的任何锁或者 pin 都应该被释放。
  </para>

  <para>
<programlisting>
void
ammarkpos (IndexScanDesc scan);
</programlisting>
   标记当前扫描位置。访问方法只需要支持每个扫描里面有一个被标记的扫描位置。
  </para>

  <para>
<programlisting>
void
amrestrpos (IndexScanDesc scan);
</programlisting>
   把扫描恢复到最近标记的位置。
  </para>

  <para>
   通常，一个索引访问方法函数的<literal>pg_proc</literal>项都应该显示参数的正确 数目，但是把它们都声明为类型<type>internal</>（因为大多数参数的类型对于 SQL 都是未知的，并且我们不希望用户以任何方式直接调用这些函数）。返回类型根据具体情况被声明为<type>void</>、<type>internal</>或<type>boolean</>。唯一的例外是<function>amoptions</>，它应当被正确地声明为接受<type>text[]</>和<type>bool</>并返回 <type>bytea</>。这个规定允许客户端代码执行<function>amoptions</>来测试选项设置的有效性。
  </para>

 </sect1>

 <sect1 id="index-scanning">
  <title>索引扫描</title>

  <para>
   在一个索引扫描中，索引访问方法负责把它拿到的那些据说匹配<firstterm>扫描键</>的所有元组的 TID 的regurgitating。访问方法<emphasis>不</>会涉及从索引的父表中实际取得那些元组，也不会涉及判断它们是否通过了扫描的时间条件测试或者是其它条件。
  </para>

  <para>
   一个扫描键是一个<literal>WHERE</>子句的内部表示，<literal>WHERE</>子句的形式是<replaceable>index_key</> <replaceable>operator</> <replaceable>constant</>，其中索引键字索引中的一个列，而操作符是和该索引列相关联的操作符族的一个成员。一个索引扫描拥有零个或者多个扫描键，它们是隐式 AND 关系 &mdash; 返回的元组被认为满足所有列出的条件。
  </para>

  <para>
   对于一个特定查询，访问方法可能报告索引是<firstterm>有损的</>或者要求重新检查。这就暗示着该索引扫 描会返回所有通过扫描键的项，外加上一些可能没通过扫描键的项。核心系统的索引扫描机制然后就会再次在堆元组上应用索引条件来验证它是否真地应该被选择。如果没有指定重新检查选项，索引扫描必须返回准确的匹配项集合。
  </para>

  <para>
   请注意，确保找到所有（只有）通过所有给定扫描键的条目的工作完全由访问方法负责。还有，核心系统将只是简单地 hand off 所有匹配扫描键和操作符族的<literal>WHERE</>子句，而不会做任何语义分析来判断它们是否冗余或者矛盾。例如，给定<literal>WHERE x &gt; 4 AND x &gt; 14</>（其中<literal>x</>是一个 b-tree 索引列，它被留给 b-tree <function>amrescan</>函数来发现第一个扫描键是冗余并且可以被丢弃。<function>amrescan</>期间需要的预处理的范围将取决于索引访问方法需要什么来把扫描键缩减为一种<quote>正规化的</>形式。
  </para>

  <para>
   一些访问方法按照一个良定义的顺序来返回索引项，其他的则不会。实际上一个访问方法可以有两种不同的方式支持排序输出：

    <itemizedlist>
     <listitem>
      <para>
       总是按数据的自然序返回项的访问方法应该设置<structname>pg_am</>.<structfield>amcanorder</>为真。当前，这样的访问方法必须对它们的等值和排序操作符使用b-tree兼容的策略号。
      </para>
     </listitem>
     <listitem>
      <para>
       支持排序操作符的访问方法应该设置<structname>pg_am</>.<structfield>amcanorderbyop</>为真。这表示索引有能力按照满足<literal>ORDER BY</> <replaceable>index_key</> <replaceable>operator</> <replaceable>constant</>的一种顺序返回项。如前所述，这种形式的扫描修饰符可以被传递给<function>amrescan</>。
      </para>
     </listitem>
    </itemizedlist>
  </para>

  <para>
   <function>amgettuple</>函数有一个<literal>direction</>参数，它可以是 <literal>ForwardScanDirection</>（正常情况）或者<literal>BackwardScanDirection</>。如果<function>amrescan</>之后的第一次调用指定了<literal>BackwardScanDirection</>，那么匹配条件的索引项集合是从后向前扫描的，而 不是通常的从前向后扫描，因此<function>amgettuple</>必须返回索引中最后一个匹配元组，而不是通常情况下的第一个（这只对设置了<structfield>amcanorder</>为真访问方法发生）。在第一次调用后，<function>amgettuple</>必须被准备好从最近被返回项的位置按照任何一种方向推进扫描（但是如果<structname>pg_am</>.<structfield>amcanbackward</>为假，所有后续调用将使用第一次相同的方向）。
  </para>

  <para>
   支持排序扫描的访问方法必须支持在扫描里<quote>标记</>一个位置并且随后返回到这个标记过的位置。同一个位置可能会被重复多次还原。但是，每个扫描中只有一个位置需要被记住；一个新的<function>ammarkpos</>调用将重写之前标记的位置。一个不支持排序扫描的访问方法仍然应该在<structname>pg_am</>中提供标记和还原函数，在它们被调用时抛出错误就足够了。
  </para>

  <para>
   扫描位置和标记位置（如果存在)）都必须在面对索引中的并发插入和删除时保持一致性。如果一个新插入的项并未被一个扫描返回（如果该扫描开始的时候该项已经存在，该扫描将已经找到该项），或者说扫描通过重新扫描或者反向扫描返回这样一个项（即使它第一次没有返回这样一个项），这些情况都是可以接受的。类似的还有，一个并发的删除可能或不可能被反映在一个扫描的结果中。重要的是，插入或者删除不会导致扫描错过或者多次返回本身不是被插入或者删除的项。
  </para>

  <para>
   如果索引存储原始被索引的数据值（并且不是它们的某种有损表示），它可用来支持只用索引的扫描，着这种扫描中索引返回的就是实际的数据而不只是堆元组的 TID。这只有在可见性映射显示该 TID 位于一个全部可见的页面时才工作；否则必须访问堆元组来检查 MVCC 可见性。但是这就不用访问方法操心了。
  </para>

  <para>
   除了使用<function>amgettuple</>，一个索引扫描可以通过<function>amgetbitmap</>在一次调用中取得所有元组来完成。这样做可能会比<function>amgettuple</>有显著的效率提升，因为它可以避免在访问方法内的加锁/解锁循环。原则上<function>amgetbitmap</>应该和重复调用<function>amgettuple</>的效果相同， 不过我们强加了一些限制来简化这件事。首先，<function>amgetbitmap</>一次返回 所有元组并且标记并且不支持标记或恢复扫描位置。第二，在一个位图中返回的元组没有任何指定的顺序，这也是为什么<function>amgetbitmap</>没有一个<literal>direction</>参数的原因（排序操作符也将永远不会提供给这种扫描）。还有，对于使用<function>amgetbitmap</>的只用索引扫描没有规定，因为没有办法返回索引元组的内容。最后，如<xref linkend="index-locking">中所说的，<function>amgetbitmap</>不保证被返回元组上的任何锁。
  </para>

  <para>
   注意如果访问方法的内部实现不适合一个 API 或其他 API，允许一个访问方法只实现<function>amgetbitmap</>而不实现<function>amgettuple</>，或者反过来。
  </para>

 </sect1>

 <sect1 id="index-locking">
  <title>索引锁定考虑</title>

  <para>
   索引访问方法必须支持多个进程对索引的并发更新。在索引扫描期间，核心<productname>PostgreSQL</productname>系统在索引上获取 <literal>AccessShareLock</>，并且在更新索引时（包括普通<command>VACUUM</>）获取<literal>RowExclusiveLock</>。因为这些锁类型不会冲突，所以访问方法负责处理它可能需要的任何细粒度锁。把索引作为一个整体的排他锁只会在索引创建、删除或<command>REINDEX</>时被使用。
  </para>

  <para>
   创建一个支持并发更新的索引类型通常要求对所需的行为进行广泛并且细致的分析。对于b-tree 和哈希索引类型，你可以阅读<filename>src/backend/access/nbtree/README</>和<filename>src/backend/access/hash/README</>中的设计决策。
  </para>

  <para>
   除了索引自己内部的一致性要求之外，并发更新带来了一些父表（<firstterm>堆</>）和索引之 间的一致性问题。因为 <productname>PostgreSQL</productname>是把堆的访问和 更新与索引的访问和更新分开的，所以存在一些窗口期，在其间索引可能会与堆不一致。我们用下面的规则处理这样的问题：

    <itemizedlist>
     <listitem>
      <para>
       一个新堆项在其索引项之前被制作（因此并发的索引扫描很可能看不到堆项。这么做应该是可以的，因为索引的读取者对未提交的行不感兴趣。见<xref linkend="index-unique-checks">）。
      </para>
     </listitem>
     <listitem>
      <para>
       当一个堆项要被删除（通过<command>VACUUM</>）时，它的所有索引项都必须首先删除。
      </para>
     </listitem>
     <listitem>
      <para>
       一次索引扫描必须在保存有<function>amgettuple</>最后返回项的索引页面上维护一个 pin， 并且<function>ambulkdelete</>不能从页面中删除被其他后端加 pin 的项。下面会解释需要这条规则的原因。
      </para>
     </listitem>
    </itemizedlist>

   没有第三条规则，那么一个索引读取者是可以在一条索引项被<command>VACUUM</>删除之前看到它的，并且然后在<command>VACUUM</>删除它之后找到其对应的堆项。如果读取者到达该项时，该项编号仍然没有被使用，那么这种 情况不会导致严重的问题，因为空的项槽位会被<function>heap_fetch()</>忽略。 但是如果第三个后端已经为其它什么东西重用了这个项槽位又会怎样？在使用 MVCC  兼容的快照时，那么就不会有问题，因为槽位的新占据者太新了以至于无法通过快照测试。但是，对于非 MVCC 兼容的快照（例如 <literal>SnapshotAny</>），那么就有可能接受并返回一个实际上并不匹配扫描键的行。可以通过要求扫描键在所有情况下都在堆行上重新检查来避免这种情况，但是这种方法开销太大了。取而 代之的是，通过在索引页面上使用一个 pin 作为一个代理来表示，读取者可能还处于从索引项到匹配的堆项的<quote>飞行中</>。用<function>ambulkdelete</>来操作这样一个 pin 上的块确保<command>VACUUM</>无法在读取者完成之前删除堆项。这种解决方案在运行时只有一点开销，而只是在真有一个冲突的非常罕见情况下才导致阻塞开销。
  </para>

  <para>
   这个解决方法要求索引扫描是<quote>同步的</>：我们不得不在扫描完对应的索引项之后马上去取每个堆元组。这样的方案开销比较大，原因有多个。而一个<quote>异步的</>扫描可以先从索引里收集很多 TID ，并且在稍后的某个时间只访问堆元组，这样要求更少的索引锁定负荷并且能够允许一种更高效的堆访问模式。但是按照上面的分析，在非 MVCC 兼容的快照上我们必须使用同步方法，而异步扫描则适合于使用 MVCC 快照的查询。
  </para>

  <para>
   在一个<function>amgetbitmap</>索引扫描中，访问方法不会在任何被返回的元组上保持一个索引 pin。因此只有把这种扫描与 MVCC 兼容的快照一起使用才是安全的。
  </para>

  <para>
   当<structfield>ampredlocks</>标志没有被设置时，在一个可序列化事务中使用该索引访问方法的任何扫描将在整个索引上获取一个非阻塞的谓词锁。这将和一个并发可序列化事务中项索引中插入任何元组发生读-写冲突。如果在一组并发可序列化事务之间检测到特定模式的读-写冲突，其中一个事务可能会被取消来保护数据完整性。当该标志被设置，它表示该索引访问方法实现了细粒度的谓词锁，这将有望缩减这种事务取消的频率。
  </para>

 </sect1>

 <sect1 id="index-unique-checks">
  <title>索引唯一性检查</title>

  <para>
   <productname>PostgreSQL</productname>使用<firstterm>唯一索引</>来强制 SQL 唯一性约束，唯一 索引实际上是不允许多个项有相同键的索引。一个支持这个特性的访问方法要 设置<structname>pg_am</>.<structfield>amcanunique</>为真（目前，只有 b-tree 支持它）。
  </para>

  <para>
   因为 MVCC，必须允许重复的项在物理上存在于索引之中：这些项可能指向某个单一逻辑行的后继版本。实际想强制的行为是，任何 MVCC 快照都不能包含两个具有相同索引键的行。在向一个唯一索引中插入一个新行时需要被检查的情况可分解成：

    <itemizedlist>
     <listitem>
      <para>
       如果一个有冲突的合法行已被当前事务删除，这是可以的（特别是因为一个  UPDATE 总是在插入新版本之前删除旧版本，这样就允许一个行上的UPDATE 不改变键）。
      </para>
     </listitem>
     <listitem>
      <para>
       如果一个有冲突的行已经被还未提交的事务插入，那么准备插入的事务必须等待看看前面那个事务是否提交。如果它回滚额不会有冲突。如果它提交并且没有删除存在冲突的行，则有一个唯一性违背（实际上我们只是等待那个其他事务结束，然后在全部事务里重做可见性检查）。
      </para>
     </listitem>
     <listitem>
      <para>
       类似的，如果一个有冲突的有效行被一个准备提交的事务删除，那么另外一个准备插入的事务必须等待该事务提交或者退出，然后重做测试。
      </para>
     </listitem>
    </itemizedlist>
  </para>

  <para>
   此外，在根据上述规则报告唯一性违背之前，访问方法必须重新检查刚被插入的行的存活性。如果已经因为事务的提交而死亡，那么不应当报告任何违背（这种情况不可能出现在插入在同一事务中创建的行的普通场景中。但是在<command>CREATE UNIQUE INDEX CONCURRENTLY</>的过程中是可能发生的）。
  </para>

  <para>
   要求索引访问方法自己应用这些测试，这就意味着它必须到达堆来查看那些根据 索引内容有重复键的任意行的提交状态。这无疑是丑陋并且非模块化的，但是这样可以节约重复的工作：如果我们进行一次独立的探测，那么查找一个冲突行的索引查找本质上将在查找插入新行索引项位置时被重复。此外，没有很明显的方法来避免竞争情况，除非冲突检查是插入新索引项动作的一部分。
  </para>

  <para>
   如果唯一约束是可延迟的，就存在额外的复杂性：我们需要能够为一个新行插入一个索引项，但是推迟任何唯一性违背错误直到语句结束或者更晚。为了避免对索引不必要的重复搜索，索引访问方法应该在初始插入过程中做一次初步的唯一性检查。如果显示绝对不会有冲突的活元组，就可以完成。否则，我们计划一次重新检查，它将在强制约束的时候发生。在重新检查时，如果具有相同键的被插入元组和某个其他元组都活着，则必须报告错误（注意为了这个目的，“活着”实际意味着“在索引项的 HOT 链上的任何元组都活着”）。要实现这一点，需要给 aminsert 传递一个 checkUnique 参数，其中包含下列值之一：

    <itemizedlist>
     <listitem>
      <para>
       <literal>UNIQUE_CHECK_NO</>表明不需要做唯一性检测（这不是一个唯一索引）。
      </para>
     </listitem>
     <listitem>
      <para>
       如上所述，<literal>UNIQUE_CHECK_YES</>表明有一个不可延迟的唯 一索引，并且必须立即做唯一性检测。
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>UNIQUE_CHECK_PARTIAL</>表明唯一性约束是可延迟的。<productname>PostgreSQL</productname>将会用这个模式来插入每一行的索引项。访问方法必须允许重复的项进入索引，并且通过从 <function>aminsert</>返回 FALSE 来报告任何可能的重复。对于返回 FALSE 的每一行，将计划一个延迟的重新检查。
      </para>

      <para>
       访问方法必须能够标识任何可能违反唯一约束的行，但是对它来说假阳性报告不是错误。这样就允许检查不用等到其他事务都结束；这里报告的冲突不会被当做错误来看待，并且随后将会被重新检查，而到那时它们可能不再是冲突了。
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>UNIQUE_CHECK_EXISTING</>表明这是一个行的延迟重新检查，该行被报告为一个潜在的唯一性违背。尽管这会通过调用<function>aminsert</>来实现，在这种情况下这个访问方法<emphasis>不</>能插入一个新索引项。该索引项已经存在。 当然，访问方法必须检查是否有另一个活着的索引项。如果有，并且如果目标行也仍然存活，那么报告错误。
      </para>

      <para>
       我们推荐，在一个<literal>UNIQUE_CHECK_EXISTING</>调用中，访问方法进一步验证目标行真的在索引中有一个现有的项，并且如果不是这样就报错。这是个好主意，因为被传到<function>aminsert</>的索引元组值将已经被重新计算过。如果索引定义涉及不是真正不变的函数，我们可能正在检查索引的错误区域。对重新检查中找到的目标行的检查会验证我们正在扫描之前被用于原始插入的同一元组值。
      </para>
     </listitem>
    </itemizedlist>
  </para>

 </sect1>

 <sect1 id="index-cost-estimation">
  <title>索引开销估计函数</title>

  <para>
   <function>amcostestimate</>函数被给定描述一个可能的索引扫描的信息，包括决定在索引中使用的 WHERE 和 ORDER BY 子句的列表。它必须返回访问该索引的开销估计以及 WHERE 子句的选择度（也就是说，在索引扫描期间将检索的行在父表中所占据的比例）。对于简单情况，几乎开销估计器的所有工作都可以通过调用优化器中的标准过程完成；有<function>amcostestimate</>函数的目的是允许索引访问方法提供和索引类型相关的知识，这种情况下可以改进标准的估计。
  </para>

  <para>
   每个<function>amcostestimate</>函数必须有 signature：

<programlisting>
void
amcostestimate (PlannerInfo *root,
                IndexPath *path,
                double loop_count,
                Cost *indexStartupCost,
                Cost *indexTotalCost,
                Selectivity *indexSelectivity,
                double *indexCorrelation);
</programlisting>

   前三个参数是输入参数：

   <variablelist>
    <varlistentry>
     <term><parameter>root</></term>
     <listitem>
      <para>
       规划器的有关正在被处理的查询的信息。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>path</></term>
     <listitem>
      <para>
       被考虑的索引访问路径。其中除了开销和选择度值之外的域都有效。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>loop_count</></term>
     <listitem>
      <para>
       应该被开销估计所考虑的索引扫描重复次数。当考虑用在一个嵌套循环连接中的参数化扫描时，这个参数通常会大于 1 。注意代价估计应该仍然是对于一次扫描的，一个更大的<parameter>loop_count</>意味着可能在多次扫描间允许一些缓冲效果比较合适。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   后四个参数是传引用的输出参数：

   <variablelist>
    <varlistentry>
     <term><parameter>*indexStartupCost</></term>
     <listitem>
      <para>
       设置为索引启动处理的开销。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>*indexTotalCost</></term>
     <listitem>
      <para>
       设置为索引处理的总开销。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>*indexSelectivity</></term>
     <listitem>
      <para>
       设置为索引的选择度。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>*indexCorrelation</></term>
     <listitem>
      <para>
       设置为索引扫描顺序和下层的表的顺序之间的相关性。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   请注意开销估计函数必须用 C 编写，而不能用 SQL 或者任何可用的过程语言，因为它们必须访问规划器/优化器的内部数据结构。
  </para>

  <para>
   索引访问开销应该采用被<filename>src/backend/optimizer/path/costsize.c</filename>使用的参数进行计算：一次顺序磁盘块获取的开销是<varname>seq_page_cost</>、一次非顺序获取的开销是<varname>random_page_cost</>并且处理一个索引行的开销通常应该是<varname>cpu_index_tuple_cost</>。另外，在索引处理期间（尤其是索引条件本身的计算）调用的任何比较操作符都会耗费<varname>cpu_operator_cost</>倍数的开销。
  </para>

  <para>
   访问开销应该包括所有与扫描索引本身相关的磁盘和 CPU 开销，但是<emphasis>不</>包括检索或者处理被索引标识出来的父表行的开销。
  </para>

  <para>
   <quote>启动开销</quote>是整个扫描开销中的一部分：在能够开始取第一行之前必须花掉的开销。对于大多数索引这个开销是零，但 是那些启动开销很大的索引类型不会把它设置为零。
  </para>

  <para>
   <parameter>indexSelectivity</>应该设置成在索引扫描期间，父表行被检索的估计比例。在一个有损查询的情况下，这个值通常高于实际通过 给定查询条件的行的比例。
  </para>

  <para>
   <parameter>indexCorrelation</>应该被设置成索引顺序和表顺序之间的相关性（范围从 -1.0 到 1.0）。这个数值被用于调整从父表中取出行的开销估计。
  </para>

  <para>
   当<parameter>loop_count</>大于一时，返回的数应该是该索引任何一次扫描的平均期望值。
  </para>

  <procedure>
   <title>开销估计</title>
   <para>
    一个典型的开销估计器会像下面这样进行处理：
   </para>

   <step>
    <para>
     基于给出的条件情况，估计并返回父表行将被访问的比例。如果缺乏索引类型相关的知识，那么使用标准的优化器函数<function>clauselist_selectivity()</function>：

<programlisting>
*indexSelectivity = clauselist_selectivity(root, path-&gt;indexquals,
                                           path-&gt;indexinfo-&gt;rel-&gt;relid,
                                           JOIN_INNER, NULL);
</programlisting>
    </para>
   </step>

   <step>
    <para>
     估计在扫描过程中将被访问的索引行数。对于许多索引类型，这个等于<parameter>indexSelectivity</>乘以索引中的行数，但是可能更多（请注意，页面和行中的索引尺寸从<literal>path-&gt;indexinfo</>结构中获得）。
    </para>
   </step>

   <step>
    <para>
     估计在扫描中将检索的索引页面数量。这个可能就是<parameter>indexSelectivity</>乘以索引的总页面数。
    </para>
   </step>

   <step>
    <para>
     计算索引访问开销。一个通用的估计器可能会：

<programlisting>
/*
 * Our generic assumption is that the index pages will be read
 * sequentially, so they cost seq_page_cost each, not random_page_cost.
 * Also, we charge for evaluation of the indexquals at each index row.
 * All the costs are assumed to be paid incrementally during the scan.
 */
cost_qual_eval(&amp;index_qual_cost, path-&gt;indexquals, root);
*indexStartupCost = index_qual_cost.startup;
*indexTotalCost = seq_page_cost * numIndexPages +
    (cpu_index_tuple_cost + index_qual_cost.per_tuple) * numIndexTuples;
</programlisting>

     不过，上面没有考虑重复索引扫描间的索引读分期补偿（amortization）。
    </para>
   </step>

   <step>
    <para>
     估计索引的相关性。对于一个简单的在单列有序索引，这个值可以从 pg_statistic 中检索。如果相关性是未知，那么保守的估计是零（没有相关性）。
    </para>
   </step>
  </procedure>

  <para>
   开销估计器函数的例子可以在<filename>src/backend/utils/adt/selfuncs.c</filename>中找到。
  </para>
 </sect1>
</chapter>
