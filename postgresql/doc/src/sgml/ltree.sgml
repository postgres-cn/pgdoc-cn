<!-- doc/src/sgml/ltree.sgml -->

<sect1 id="ltree" xreflabel="ltree">
 <title>ltree</title>

 <indexterm zone="ltree">
  <primary>ltree</primary>
 </indexterm>

 <para>
  这个模块实现了一种数据类型<type>ltree</>用于表示存储在一个层次树状结构中的数据的标签。还提供了在标签树中搜索的扩展功能。
 </para>

 <sect2>
  <title>定义</title>

  <para>
   一个<firstterm>标签</firstterm>是一个字母数字字符和下划线的序列（例如，在 C 区域中允许字符<literal>A-Za-z0-9_</>）。标签长度必须少于 256 字节。
  </para>

  <para>
   例子： <literal>42</>, <literal>Personal_Services</>
  </para>

  <para>
   一个<firstterm>标签路径</firstterm>是由点号分隔的零个或者更多个标签的序列，例如<literal>L1.L2.L3</>，它表示一个从层次树的根到一个特定节点的路径。一个标签路径的长度必须小于 65Kb，但是最好将它保持在 2Kb 以下。实际上这不是一个主要限制，例如在 DMOZ 目录（<ulink
   url="http://www.dmoz.org"></ulink>）中最长的标签路径大约是 240 字节。
  </para>

  <para>
   例子：<literal>Top.Countries.Europe.Russia</literal>
  </para>

  <para>
   <filename>ltree</>模块提供多种数据类型：
  </para>

  <itemizedlist>
   <listitem>
    <para>
     <type>ltree</type>存储一个标签路径。
    </para>
   </listitem>

   <listitem>
    <para>
     <type>lquery</type>表示一个用于匹配<type>ltree</>值的类正则表达式的模式。一个简单词匹配一个路径中的那个标签。一个星号（<literal>*</>）匹配零个或更多个标签。例如：
<synopsis>
foo         <lineannotation>正好匹配标签路径<literal>foo</></lineannotation>
*.foo.*     <lineannotation>匹配任何包含标签<literal>foo</>的标签路径</lineannotation>
*.foo       <lineannotation>匹配任何最后一个标签是<literal>foo</>的标签路径</lineannotation>
</synopsis>
    </para>

    <para>
     星号也可以被限定来限制它能匹配多少标签：
<synopsis>
*{<replaceable>n</>}        <lineannotation>匹配正好<replaceable>n</>个标签</lineannotation>
*{<replaceable>n</>,}       <lineannotation>匹配至少<replaceable>n</>个标签</lineannotation>
*{<replaceable>n</>,<replaceable>m</>}      <lineannotation>匹配至少<replaceable>n</>个但是最多<replaceable>m</>个标签</lineannotation>
*{,<replaceable>m</>}       <lineannotation>匹配最多<replaceable>m</>个标签 &mdash; 与*{0,<replaceable>m</>}相同</lineannotation> 
</synopsis>
    </para>

    <para>
     在<type>lquery</>中，有多种修饰符可以被放在一个非星号标签的末尾来让它不仅仅能准确匹配：
<synopsis>
@           <lineannotation>不区分大小写匹配，例如<literal>a@</>匹配<literal>A</></lineannotation>
*           <lineannotation>匹配带此前缀的任何标签，例如<literal>foo*</>匹配<literal>foobar</></lineannotation>
%           <lineannotation>匹配开头以下划线分隔的词</lineannotation>
</synopsis>
     <literal>%</>的行为有点复杂。它尝试匹配词而不是整个标签。例如，<literal>foo_bar%</>匹配<literal>foo_bar_baz</>但是不匹配<literal>foo_barbaz</>。如果和<literal>*</>组合，前缀匹配可以单独应用于每一个词，例如<literal>foo_bar%*</>匹配<literal>foo1_bar2_baz</>但不匹配<literal>foo1_br2_baz</>。
    </para>

    <para>
     此外，你可以写多个带有<literal>|</>（OR）的可能改过的标签来匹配那些标签中的任何一个（或几个），并且你可以在最前面放上<literal>!</>（NOT）来匹配任何不匹配那些分支的标签。
    </para>

    <para>
     这里是一个<type>lquery</type>的例子：
<programlisting>
Top.*{0,2}.sport*@.!football|tennis.Russ*|Spain
a.  b.     c.      d.               e.
</programlisting>
     这个查询将匹配任何这样的标签路径：
    </para>
    <orderedlist numeration="loweralpha">
     <listitem>
      <para>
       开始于标签<literal>Top</literal>
      </para>
     </listitem>
     <listitem>
      <para>
       并且接着具有 0 到 2 个标签
      </para>
     </listitem>
     <listitem>
      <para>
       之后是一个开始于大小写无关的前缀<literal>sport</literal>的标签
      </para>
     </listitem>
     <listitem>
      <para>
       再后是一个不匹配<literal>football</literal>和<literal>tennis</literal>的标签
      </para>
     </listitem>
     <listitem>
      <para>
       并且结尾是一个开始于<literal>Russ</literal>的标签，或者完全匹配<literal>Spain</literal>的标签。
      </para>
     </listitem>
    </orderedlist>
   </listitem>

   <listitem>
    <para><type>ltxtquery</type>表示一种用于匹配<type>ltree</>值的类全文搜索的模式。一个<type>ltxtquery</type>值包含词，也可能在末尾带有修饰符<literal>@</>、<literal>*</>、<literal>%</>，修饰符具有和<type>lquery</>中相同的含义。词可以用<literal>&amp;</>（AND）、<literal>|</>（OR）、<literal>!</>（NOT）以及圆括号组合。<type>lquery</>和<type>ltxtquery</type>的关键区别是前者匹配词时不考虑它们在标签路径中的位置。
    </para>

    <para>
     这是一个<type>ltxtquery</type>的例子：
<programlisting>
Europe &amp; Russia*@ &amp; !Transportation
</programlisting>
     这将匹配包含标签<literal>Europe</literal>以及任何以<literal>Russia</literal>开始（大小写不敏感）的标签的路径，但是不匹配包含标签<literal>Transportation</literal>的路径。这些词在路径中的位置并不重要。还有，当使用<literal>%</>时，该次可以与一个标签中任何下划线分隔的词匹配，而不管它们的位置如何。
    </para>
   </listitem>

  </itemizedlist>

  <para>
   注意：<type>ltxtquery</>允许符号之间的空白，但是<type>ltree</>和<type>lquery</>不允许。
  </para>
 </sect2>

 <sect2>
  <title>操作符和函数</title>

  <para>
   类型<type>ltree</>有普通比较操作符
   <literal>=</>、<literal>&lt;&gt;</literal>、
   <literal>&lt;</>、<literal>&gt;</>、<literal>&lt;=</>、<literal>&gt;=</>。
   比较会按照树遍历的顺序排序，一个节点的子女按照标签文本排序。另外，还有<xref linkend="ltree-op-table">中显示的特殊操作符。
  </para>

  <table id="ltree-op-table">
   <title><type>ltree</> 操作符</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>操作符</entry>
      <entry>返回值</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><type>ltree</> <literal>@&gt;</> <type>ltree</></entry>
      <entry><type>boolean</type></entry>
      <entry>左参数是不是右参数的一个祖先（或者相等）？</entry>
     </row>

     <row>
      <entry><type>ltree</> <literal>&lt;@</> <type>ltree</></entry>
      <entry><type>boolean</type></entry>
      <entry>左参数是不是右参数的一个后代（或者相等）？</entry>
     </row>

     <row>
      <entry><type>ltree</> <literal>~</> <type>lquery</></entry>
      <entry><type>boolean</type></entry>
      <entry><type>ltree</>匹配<type>lquery</>吗？</entry>
     </row>

     <row>
      <entry><type>lquery</> <literal>~</> <type>ltree</></entry>
      <entry><type>boolean</type></entry>
      <entry><type>ltree</>匹配<type>lquery</>吗？</entry>
     </row>

     <row>
      <entry><type>ltree</> <literal>?</> <type>lquery[]</></entry>
      <entry><type>boolean</type></entry>
      <entry><type>ltree</>匹配数组中的任意<type>lquery</>吗？</entry>
     </row>

     <row>
      <entry><type>lquery[]</> <literal>?</> <type>ltree</></entry>
      <entry><type>boolean</type></entry>
      <entry><type>ltree</>匹配数组中的任意<type>lquery</>吗？</entry>
     </row>

     <row>
      <entry><type>ltree</> <literal>@</> <type>ltxtquery</></entry>
      <entry><type>boolean</type></entry>
      <entry><type>ltree</>匹配<type>ltxtquery</>吗？</entry>
     </row>

     <row>
      <entry><type>ltxtquery</> <literal>@</> <type>ltree</></entry>
      <entry><type>boolean</type></entry>
      <entry><type>ltree</>匹配<type>ltxtquery</>吗？</entry>
     </row>

     <row>
      <entry><type>ltree</> <literal>||</> <type>ltree</></entry>
      <entry><type>ltree</type></entry>
      <entry>串接<type>ltree</>路径</entry>
     </row>

     <row>
      <entry><type>ltree</> <literal>||</> <type>text</></entry>
      <entry><type>ltree</type></entry>
      <entry>把文本转换成<type>ltree</>并且串接</entry>
     </row>

     <row>
      <entry><type>text</> <literal>||</> <type>ltree</></entry>
      <entry><type>ltree</type></entry>
      <entry>把文本转换成<type>ltree</>并且串接</entry>
     </row>

     <row>
      <entry><type>ltree[]</> <literal>@&gt;</> <type>ltree</></entry>
      <entry><type>boolean</type></entry>
      <entry>数组是否包含<type>ltree</>的一个祖先？</entry>
     </row>

     <row>
      <entry><type>ltree</> <literal>&lt;@</> <type>ltree[]</></entry>
      <entry><type>boolean</type></entry>
      <entry>数组是否包含<type>ltree</>的一个祖先？</entry>
     </row>

     <row>
      <entry><type>ltree[]</> <literal>&lt;@</> <type>ltree</></entry>
      <entry><type>boolean</type></entry>
      <entry>数组是否包含<type>ltree</>的一个后代？</entry>
     </row>

     <row>
      <entry><type>ltree</> <literal>@&gt;</> <type>ltree[]</></entry>
      <entry><type>boolean</type></entry>
      <entry>数组是否包含<type>ltree</>的一个后代？</entry>
     </row>

     <row>
      <entry><type>ltree[]</> <literal>~</> <type>lquery</></entry>
      <entry><type>boolean</type></entry>
      <entry>数组是否包含匹配<type>lquery</>的路径？</entry>
     </row>

     <row>
      <entry><type>lquery</> <literal>~</> <type>ltree[]</></entry>
      <entry><type>boolean</type></entry>
      <entry>数组是否包含匹配<type>lquery</>的路径？</entry>
     </row>

     <row>
      <entry><type>ltree[]</> <literal>?</> <type>lquery[]</></entry>
      <entry><type>boolean</type></entry>
      <entry><type>ltree</>数组是否包含匹配任意<type>lquery</>的路径？</entry>
     </row>

     <row>
      <entry><type>lquery[]</> <literal>?</> <type>ltree[]</></entry>
      <entry><type>boolean</type></entry>
      <entry><type>ltree</>数组是否包含匹配任意<type>lquery</>的路径？</entry>
     </row>

     <row>
      <entry><type>ltree[]</> <literal>@</> <type>ltxtquery</></entry>
      <entry><type>boolean</type></entry>
      <entry>数组是否包含匹配<type>ltxtquery</>的路径？</entry>
     </row>

     <row>
      <entry><type>ltxtquery</> <literal>@</> <type>ltree[]</></entry>
      <entry><type>boolean</type></entry>
      <entry>数组是否包含匹配<type>ltxtquery</>的路径？</entry>
     </row>

     <row>
      <entry><type>ltree[]</> <literal>?@&gt;</> <type>ltree</></entry>
      <entry><type>ltree</type></entry>
      <entry>是<type>ltree</>祖先的第一个数组项；如果没有则是 NULL</entry>
     </row>

     <row>
      <entry><type>ltree[]</> <literal>?&lt;@</> <type>ltree</></entry>
      <entry><type>ltree</type></entry>
      <entry>是<type>ltree</>祖先的第一个数组项；如果没有则是 NULL</entry>
     </row>

     <row>
      <entry><type>ltree[]</> <literal>?~</> <type>lquery</></entry>
      <entry><type>ltree</type></entry>
      <entry>匹配<type>lquery</>的第一个数组项；如果没有则是 NULL</entry>
     </row>

     <row>
      <entry><type>ltree[]</> <literal>?@</> <type>ltxtquery</></entry>
      <entry><type>ltree</type></entry>
      <entry>匹配<type>lquery</>的第一个数组项；如果没有则是 NULL</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   操作符<literal>&lt;@</literal>、<literal>@&gt;</literal>、
   <literal>@</literal>以及<literal>~</literal>有类似的、
   <literal>^&lt;@</>、<literal>^@&gt;</>、<literal>^@</>、
   <literal>^~</literal>，只是它们不适用索引。它们只对测试目的有用。
  </para>

  <para>
   可用的函数在<xref linkend="ltree-func-table">中。
  </para>

  <table id="ltree-func-table">
   <title><type>ltree</> 函数</title>

   <tgroup cols="5">
    <thead>
     <row>
      <entry>函数</entry>
      <entry>返回类型</entry>
      <entry>描述</entry>
      <entry>例子</entry>
      <entry>结果</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><function>subltree(ltree, int start, int end)</function><indexterm><primary>subltree</primary></indexterm></entry>
      <entry><type>ltree</type></entry>
      <entry><type>ltree</>的从位置<parameter>start</>到位置<parameter>end</>-1（从 0 开始计）的子路径</entry>
      <entry><literal>subltree('Top.Child1.Child2',1,2)</literal></entry>
      <entry><literal>Child1</literal></entry>
     </row>

     <row>
      <entry><function>subpath(ltree, int offset, int len)</function><indexterm><primary>subpath</primary></indexterm></entry>
      <entry><type>ltree</type></entry>
      <entry><type>ltree</>从位置<parameter>offset</>开始长度为<parameter>len</>的子路径。如果<parameter>offset</>为负，则子路径开始于距离路径尾部那么远的位置。如果<parameter>len</>为负，则从路径的尾部开始丢掉那么多个标签。</entry>
      <entry><literal>subpath('Top.Child1.Child2',0,2)</literal></entry>
      <entry><literal>Top.Child1</literal></entry>
     </row>

     <row>
      <entry><function>subpath(ltree, int offset)</function></entry>
      <entry><type>ltree</type></entry>
      <entry><type>ltree</>从位置<parameter>offset</>开始一直延伸到路径末尾的子路径。如果<parameter>offset</>为负，则子路径开始于距离路径尾部那么远的位置。</entry>
      <entry><literal>subpath('Top.Child1.Child2',1)</literal></entry>
      <entry><literal>Child1.Child2</literal></entry>
     </row>

     <row>
      <entry><function>nlevel(ltree)</function><indexterm><primary>nlevel</primary></indexterm></entry>
      <entry><type>integer</type></entry>
      <entry>路径中标签的数量</entry>
      <entry><literal>nlevel('Top.Child1.Child2')</literal></entry>
      <entry><literal>3</literal></entry>
     </row>

     <row>
      <entry><function>index(ltree a, ltree b)</function><indexterm><primary>index</primary></indexterm></entry>
      <entry><type>integer</type></entry>
      <entry><parameter>a</>中第一次出现<parameter>b</>的位置，如果没有找到则为 -1</entry>
      <entry><literal>index('0.1.2.3.5.4.5.6.8.5.6.8','5.6')</literal></entry>
      <entry><literal>6</literal></entry>
     </row>

     <row>
      <entry><function>index(ltree a, ltree b, int offset)</function></entry>
      <entry><type>integer</type></entry>
      <entry><parameter>a</>中第一次出现<parameter>b</>的位置，搜索从<parameter>offset</>开始。负的<parameter>offset</>表示从距路径尾部<parameter>-offset</>个标签的位置开始</entry>
      <entry><literal>index('0.1.2.3.5.4.5.6.8.5.6.8','5.6',-4)</literal></entry>
      <entry><literal>9</literal></entry>
     </row>

     <row>
      <entry><function>text2ltree(text)</function><indexterm><primary>text2ltree</primary></indexterm></entry>
      <entry><type>ltree</type></entry>
      <entry>把<type>text</>转换成<type>ltree</></entry>
      <entry><literal></literal></entry>
      <entry><literal></literal></entry>
     </row>

     <row>
      <entry><function>ltree2text(ltree)</function><indexterm><primary>ltree2text</primary></indexterm></entry>
      <entry><type>text</type></entry>
      <entry>把<type>ltree</>转换成<type>text</></entry>
      <entry><literal></literal></entry>
      <entry><literal></literal></entry>
     </row>

     <row>
      <entry><function>lca(ltree, ltree, ...)</function><indexterm><primary>lca</primary></indexterm></entry>
      <entry><type>ltree</type></entry>
      <entry>最低公共祖先，即最长的公共路径前缀（最多支持 8 个参数）</entry>
      <entry><literal>lca('1.2.2.3','1.2.3.4.5.6')</literal></entry>
      <entry><literal>1.2</literal></entry>
     </row>

     <row>
      <entry><function>lca(ltree[])</function></entry>
      <entry><type>ltree</type></entry>
      <entry>最低公共祖先，即最长的公共路径前缀</entry>
      <entry><literal>lca(array['1.2.2.3'::ltree,'1.2.3'])</literal></entry>
      <entry><literal>1.2</literal></entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect2>

 <sect2>
  <title>索引</title>
  <para>
   <filename>ltree</>支持一些能加速上述操作符的索引类型：
  </para>

  <itemizedlist>
   <listitem>
    <para>
     <type>ltree</>上的 B-树索引：
     <literal>&lt;</>、<literal>&lt;=</>、<literal>=</>、
     <literal>&gt;=</>、<literal>&gt;</literal>
    </para>
   </listitem>
   <listitem>
    <para>
     <type>ltree</>上的 GiST 索引：
     <literal>&lt;</>、<literal>&lt;=</>、<literal>=</>、
     <literal>&gt;=</>、<literal>&gt;</>、
     <literal>@&gt;</>、<literal>&lt;@</>、
     <literal>@</>、<literal>~</>、<literal>?</literal>
    </para>
    <para>
     创建这样一个索引的例子：
    </para>
<programlisting>
CREATE INDEX path_gist_idx ON test USING GIST (path);
</programlisting>
   </listitem>
   <listitem>
    <para>
     <type>ltree[]</>上的 GiST 索引：
     <literal>ltree[] &lt;@ ltree</>、<literal>ltree @&gt; ltree[]</>、
     <literal>@</>、<literal>~</>、<literal>?</literal>
    </para>
    <para>
     创建这样一个索引的例子：
    </para>
<programlisting>
CREATE INDEX path_gist_idx ON test USING GIST (array_path);
</programlisting>
    <para>
     注意：这种索引类型是有损的。
    </para>
   </listitem>
  </itemizedlist>
 </sect2>

 <sect2>
  <title>例子</>

  <para>
   这个例子使用下列数据（在源代码发布的<filename>contrib/ltree/ltreetest.sql</>文件中也有）：
  </para>

<programlisting>
CREATE TABLE test (path ltree);
INSERT INTO test VALUES ('Top');
INSERT INTO test VALUES ('Top.Science');
INSERT INTO test VALUES ('Top.Science.Astronomy');
INSERT INTO test VALUES ('Top.Science.Astronomy.Astrophysics');
INSERT INTO test VALUES ('Top.Science.Astronomy.Cosmology');
INSERT INTO test VALUES ('Top.Hobbies');
INSERT INTO test VALUES ('Top.Hobbies.Amateurs_Astronomy');
INSERT INTO test VALUES ('Top.Collections');
INSERT INTO test VALUES ('Top.Collections.Pictures');
INSERT INTO test VALUES ('Top.Collections.Pictures.Astronomy');
INSERT INTO test VALUES ('Top.Collections.Pictures.Astronomy.Stars');
INSERT INTO test VALUES ('Top.Collections.Pictures.Astronomy.Galaxies');
INSERT INTO test VALUES ('Top.Collections.Pictures.Astronomy.Astronauts');
CREATE INDEX path_gist_idx ON test USING gist(path);
CREATE INDEX path_idx ON test USING btree(path);
</programlisting>

  <para>
   现在，我们有一个表<structname>test</>，它被填充了描述下列层次的数据：
  </para>

<literallayout class="monospaced">
                        Top
                     /   |  \
             Science Hobbies Collections
                 /       |              \
        Astronomy   Amateurs_Astronomy Pictures
           /  \                            |
Astrophysics  Cosmology                Astronomy
                                        /  |    \
                                 Galaxies Stars Astronauts
</literallayout>

  <para>
   我们可以做继承：
<screen>
ltreetest=&gt; SELECT path FROM test WHERE path &lt;@ 'Top.Science';
                path
------------------------------------
 Top.Science
 Top.Science.Astronomy
 Top.Science.Astronomy.Astrophysics
 Top.Science.Astronomy.Cosmology
(4 rows)
</screen>
  </para>

  <para>
   这里是一些路径匹配的例子：
<screen>
ltreetest=&gt; SELECT path FROM test WHERE path ~ '*.Astronomy.*';
                     path
-----------------------------------------------
 Top.Science.Astronomy
 Top.Science.Astronomy.Astrophysics
 Top.Science.Astronomy.Cosmology
 Top.Collections.Pictures.Astronomy
 Top.Collections.Pictures.Astronomy.Stars
 Top.Collections.Pictures.Astronomy.Galaxies
 Top.Collections.Pictures.Astronomy.Astronauts
(7 rows)

ltreetest=&gt; SELECT path FROM test WHERE path ~ '*.!pictures@.*.Astronomy.*';
                path
------------------------------------
 Top.Science.Astronomy
 Top.Science.Astronomy.Astrophysics
 Top.Science.Astronomy.Cosmology
(3 rows)
</screen>
  </para>

  <para>
   这里是一些全文搜索的例子：
<screen>
ltreetest=&gt; SELECT path FROM test WHERE path @ 'Astro*% &amp; !pictures@';
                path
------------------------------------
 Top.Science.Astronomy
 Top.Science.Astronomy.Astrophysics
 Top.Science.Astronomy.Cosmology
 Top.Hobbies.Amateurs_Astronomy
(4 rows)

ltreetest=&gt; SELECT path FROM test WHERE path @ 'Astro* &amp; !pictures@';
                path
------------------------------------
 Top.Science.Astronomy
 Top.Science.Astronomy.Astrophysics
 Top.Science.Astronomy.Cosmology
(3 rows)
</screen>
  </para>

  <para>
   使用函数的路径构建：
<screen>
ltreetest=&gt; SELECT subpath(path,0,2)||'Space'||subpath(path,2) FROM test WHERE path &lt;@ 'Top.Science.Astronomy';
                 ?column?
------------------------------------------
 Top.Science.Space.Astronomy
 Top.Science.Space.Astronomy.Astrophysics
 Top.Science.Space.Astronomy.Cosmology
(3 rows)
</screen>
  </para>

  <para>
   我们可以通过常见一个在路径中指定位置插入标签的 SQL 函数来简化：
<screen>
CREATE FUNCTION ins_label(ltree, int, text) RETURNS ltree
    AS 'select subpath($1,0,$2) || $3 || subpath($1,$2);'
    LANGUAGE SQL IMMUTABLE;

ltreetest=&gt; SELECT ins_label(path,2,'Space') FROM test WHERE path &lt;@ 'Top.Science.Astronomy';
                ins_label
------------------------------------------
 Top.Science.Space.Astronomy
 Top.Science.Space.Astronomy.Astrophysics
 Top.Science.Space.Astronomy.Cosmology
(3 rows)
</screen>
  </para>
 </sect2>

 <sect2>
  <title>作者</title>

  <para>
   所有工作都是 Teodor Sigaev（<email>teodor@stack.net</email>）和
   Oleg Bartunov（<email>oleg@sai.msu.su</email>）完成的。额外信息可见
   <ulink url="http://www.sai.msu.su/~megera/postgres/gist/"></ulink>。作者还要感谢 Eugeny Rodichev 参与讨论。欢迎评论和缺陷报告。
  </para>
 </sect2>

</sect1>
