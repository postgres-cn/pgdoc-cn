<!-- doc/src/sgml/plperl.sgml -->

 <chapter id="plperl">
<!--==========================orignal english content==========================
  <title>PL/Perl &mdash; Perl Procedural Language</title>
____________________________________________________________________________-->
  <title>PL/Perl &mdash; Perl 过程语言</title>

<!--==========================orignal english content==========================
  <indexterm zone="plperl">
   <primary>PL/Perl</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="plperl">
   <primary>PL/Perl</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm zone="plperl">
   <primary>Perl</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="plperl">
   <primary>Perl</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   PL/Perl is a loadable procedural language that enables you to write
   <productname>PostgreSQL</productname> functions in the
   <ulink url="https://www.perl.org">Perl programming language</ulink>.
  </para>
____________________________________________________________________________-->
  <para>
   PL/Perl 是一种可载入过程语言，它允许我们用
   <ulink url="https://www.perl.org">Perl 编程语言</ulink>编写
   <productname>PostgreSQL</productname>函数。
  </para>

<!--==========================orignal english content==========================
  <para>
   The main advantage to using PL/Perl is that this allows use,
   within stored functions, of the manyfold <quote>string
   munging</quote> operators and functions available for Perl.  Parsing
   complex strings might be easier using Perl than it is with the
   string functions and control structures provided in PL/pgSQL.
  </para>
____________________________________________________________________________-->
  <para>
   使用 PL/Perl 的主要优势它允许在存储函数中使用大量 Perl 的
   <quote>串整理</quote>操作符和函数。使用 Perl 解析复杂
   串比使用 PL/pgSQL 中提供的串函数和控制结构要更容易。
  </para>

<!--==========================orignal english content==========================
  <para>
   To install PL/Perl in a particular database, use
   <literal>CREATE EXTENSION plperl</literal>.
  </para>
____________________________________________________________________________-->
  <para>
   要在一个特定数据库中安装 PL/Perl，使用
   <literal>CREATE EXTENSION plperl</literal>。
  </para>

  <tip>
<!--==========================orignal english content==========================
   <para>
    If a language is installed into <literal>template1</literal>, all subsequently
    created databases will have the language installed automatically.
   </para>
____________________________________________________________________________-->
   <para>
    如果把语言安装在<literal>template1</literal>中，所有后续创建的数据库
    都将自动地安装有该语言。
   </para>
  </tip>

  <note>
<!--==========================orignal english content==========================
   <para>
    Users of source packages must specially enable the build of
    PL/Perl during the installation process.  (Refer to <xref
    linkend="installation"/> for more information.)  Users of
    binary packages might find PL/Perl in a separate subpackage.
   </para>
____________________________________________________________________________-->
   <para>
    使用源码包安装的用户必须在安装过程中开启对 PL/Perl 的编译（
    更多信息请参考<xref linkend="installation"/>）。使用二进制包
    安装的用户可能会在独立的子包中找到 PL/Perl。
   </para>
  </note>

 <sect1 id="plperl-funcs">
<!--==========================orignal english content==========================
  <title>PL/Perl Functions and Arguments</title>
____________________________________________________________________________-->
  <title>PL/Perl 函数和参数</title>

<!--==========================orignal english content==========================
  <para>
   To create a function in the PL/Perl language, use the standard
   <xref linkend="sql-createfunction"/>
   syntax:

<programlisting>
CREATE FUNCTION <replaceable>funcname</replaceable> (<replaceable>argument-types</replaceable>)
RETURNS <replaceable>return-type</replaceable>
-&minus; function attributes can go here
AS $$
    # PL/Perl function body goes here
$$ LANGUAGE plperl;
</programlisting>

   The body of the function is ordinary Perl code. In fact, the PL/Perl
   glue code wraps it inside a Perl subroutine.  A PL/Perl function is
   called in a scalar context, so it can't return a list.  You can return
   non-scalar values (arrays, records, and sets) by returning a reference,
   as discussed below.
  </para>
____________________________________________________________________________-->
  <para>
   要用 PL/Perl 语言创建一个函数，可使用标准的
   <xref linkend="sql-createfunction"/>语法：

<programlisting>
CREATE FUNCTION <replaceable>funcname</replaceable> (<replaceable>argument-types</replaceable>)
RETURNS <replaceable>return-type</replaceable>
-- function attributes can go here
AS $$
    # PL/Perl function body goes here
$$ LANGUAGE plperl;
</programlisting>

   函数的主体就是普通的 Perl 代码。事实上，PL/Perl 的粘合代码会把它
   包裹在一个 Perl 子程序中。一个 PL/Perl 函数会在一种标量上下文中
   被调用，因此它无法返回列表。如下文所述，可以通过返回引用来返回
   非标量值（数组、记录和集合）。
  </para>

<!--==========================orignal english content==========================
  <para>
   In a PL/Perl procedure, any return value from the Perl code is ignored.
  </para>
____________________________________________________________________________-->
  <para>
   在一个PL/Perl过程中，任何从Perl代码返回的值都会被忽略。
  </para>

<!--==========================orignal english content==========================
  <para>
   PL/Perl also supports anonymous code blocks called with the
   <xref linkend="sql-do"/> statement:

<programlisting>
DO $$
    # PL/Perl code
$$ LANGUAGE plperl;
</programlisting>

   An anonymous code block receives no arguments, and whatever value it
   might return is discarded.  Otherwise it behaves just like a function.
  </para>
____________________________________________________________________________-->
  <para>
   PL/Perl 也支持用<xref linkend="sql-do"/>语句调用的匿名代码块：

<programlisting>
DO $$
    # PL/Perl 代码
$$ LANGUAGE plperl;
</programlisting>

   一个匿名代码块没有参数，并且它返回的任何值都会被抛弃。否则
   其行为就像一个函数。
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    The use of named nested subroutines is dangerous in Perl, especially if
    they refer to lexical variables in the enclosing scope. Because a PL/Perl
    function is wrapped in a subroutine, any named subroutine you place inside
    one will be nested. In general, it is far safer to create anonymous
    subroutines which you call via a coderef. For more information, see the
    entries for <literal>Variable "%s" will not stay shared</literal> and
    <literal>Variable "%s" is not available</literal> in the
    <citerefentry><refentrytitle>perldiag</refentrytitle></citerefentry> man page, or
    search the Internet for <quote>perl nested named subroutine</quote>.
   </para>
____________________________________________________________________________-->
   <para>
    在 Perl 中使用命名嵌套子程序是有危险的，特别是当它们在作用域内
    引用局部变量时。因为 PL/Perl 函数被包装成一个子程序，任何放在
    其中的命名子程序都会被嵌套。总之，创建通过 coderef 调用的匿名
    子程序要安全得多。更多信息可见
    <citerefentry><refentrytitle>perldiag</refentrytitle></citerefentry>手册页
    中的<literal>Variable "%s" will not stay shared</literal>以及
    <literal>Variable "%s" is not available</literal>，或者在互联网上
    搜索<quote>perl nested named subroutine</quote>。
   </para>
  </note>

<!--==========================orignal english content==========================
  <para>
   The syntax of the <command>CREATE FUNCTION</command> command requires
   the function body to be written as a string constant.  It is usually
   most convenient to use dollar quoting (see <xref
   linkend="sql-syntax-dollar-quoting"/>) for the string constant.
   If you choose to use escape string syntax <literal>E''</literal>,
   you must double any single quote marks (<literal>'</literal>) and backslashes
   (<literal>\</literal>) used in the body of the function
   (see <xref linkend="sql-syntax-strings"/>).
  </para>
____________________________________________________________________________-->
  <para>
   <command>CREATE FUNCTION</command>命令的语法要求函数
   体被写作一个字符串常量。通常对字符串常量使用美元引用（见
   <xref linkend="sql-syntax-dollar-quoting"/>）最方便。如果选择使用
   转义字符串语法<literal>E''</literal>，必须双写任何在函数体中使用的单引号
   （<literal>'</literal>）和反斜线（<literal>\</literal>）（见
   <xref linkend="sql-syntax-strings"/>）。
  </para>

<!--==========================orignal english content==========================
  <para>
   Arguments and results are handled as in any other Perl subroutine:
   arguments are passed in <varname>@_</varname>, and a result value
   is returned with <literal>return</literal> or as the last expression
   evaluated in the function.
  </para>
____________________________________________________________________________-->
  <para>
   参数和结果的处理和在任何其他 Perl 子程序中一样：参数被传递到
   <varname>@_</varname>中，并且结果值用<literal>return</literal>
   返回或者把函数中计算的最后一个表达式作为结果值。
  </para>

<!--==========================orignal english content==========================
  <para>
   For example, a function returning the greater of two integer values
   could be defined as:

<programlisting>
CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS $$
    if ($_[0] &gt; $_[1]) { return $_[0]; }
    return $_[1];
$$ LANGUAGE plperl;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   例如，一个返回两个整数值中较大值的函数可以定义为：

<programlisting>
CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS $$
    if ($_[0] &gt; $_[1]) { return $_[0]; }
    return $_[1];
$$ LANGUAGE plperl;
</programlisting>
  </para>

  <note>
<!--==========================orignal english content==========================
    <para>
      Arguments will be converted from the database's encoding to UTF-8
      for use inside PL/Perl, and then converted from UTF-8 back to the
      database encoding upon return.
    </para>
____________________________________________________________________________-->
    <para>
      参数将被从数据库的编码转换到 PL/Perl 中使用的 UTF-8，返回时再从
      UTF-8 转回到数据库编码。
    </para>
  </note>

<!--==========================orignal english content==========================
  <para>
   If an SQL null value<indexterm><primary>null value</primary><secondary
   sortas="PL/Perl">in PL/Perl</secondary></indexterm> is passed to a function,
   the argument value will appear as <quote>undefined</quote> in Perl.  The
   above function definition will not behave very nicely with null
   inputs (in fact, it will act as though they are zeroes).  We could
   add <literal>STRICT</literal> to the function definition to make
   <productname>PostgreSQL</productname> do something more reasonable:
   if a null value is passed, the function will not be called at all,
   but will just return a null result automatically.  Alternatively,
   we could check for undefined inputs in the function body.  For
   example, suppose that we wanted <function>perl_max</function> with
   one null and one nonnull argument to return the nonnull argument,
   rather than a null value:

<programlisting>
CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS $$
    my ($x, $y) = @_;
    if (not defined $x) {
        return undef if not defined $y;
        return $y;
    }
    return $x if not defined $y;
    return $x if $x &gt; $y;
    return $y;
$$ LANGUAGE plperl;
</programlisting>
   As shown above, to return an SQL null value from a PL/Perl
   function, return an undefined value.  This can be done whether the
   function is strict or not.
  </para>
____________________________________________________________________________-->
  <para>
   如果一个 SQL 空值<indexterm><primary>空值</primary><secondary
   sortas="PL/Perl">in PL/Perl</secondary></indexterm>被传给一个函数，在
   Perl 中该参数值将呈现为<quote>undefined</quote>。上述函数定义对于
   空输入的行为不太好（实际上，它会把它们当作零）。我们可以为函数
   定义增加<literal>STRICT</literal>让<productname>PostgreSQL</productname>
   干得更合理：如果空值被传入，函数将根本不会被调用，而只是自动
   返回一个空结果。另外一种方式，我们可以在函数体中检查未定义的
   输入。例如，假设我们想让带有一个空参数或者一个非空参数的
   <function>perl_max</function>返回非空参数而不是空值：

<programlisting>
CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS $$
    my ($x, $y) = @_;
    if (not defined $x) {
        return undef if not defined $y;
        return $y;
    }
    return $x if not defined $y;
    return $x if $x &gt; $y;
    return $y;
$$ LANGUAGE plperl;
</programlisting>
   如上所述，要从一个 PL/Perl 函数返回一个 SQL 空值，就返回一个未定义值。
   不管函数是严格的还是非严格的都可以这样做。
  </para>

<!--==========================orignal english content==========================
  <para>
   Anything in a function argument that is not a reference is
   a string, which is in the standard <productname>PostgreSQL</productname>
   external text representation for the relevant data type. In the case of
   ordinary numeric or text types, Perl will just do the right thing and
   the programmer will normally not have to worry about it. However, in
   other cases the argument will need to be converted into a form that is
   more usable in Perl. For example, the <function>decode_bytea</function>
   function can be used to convert an argument of
   type <type>bytea</type> into unescaped binary.
  </para>
____________________________________________________________________________-->
  <para>
   一个非引用的函数参数中的任何东西都是一个串，是相关数据类型的标准
   <productname>PostgreSQL</productname>外部文本表达。在普通
   数字或文本类型的情况下，Perl 将会做正确的事情并且程序员通常不需要
   操心。不过，在其他情况下将需要被转换成在 Perl 中更可用的形式。例如，
   <function>decode_bytea</function>函数可以被用来把类型
   <type>bytea</type>的参数转换成未转义的二进制形式。
  </para>

<!--==========================orignal english content==========================
  <para>
   Similarly, values passed back to <productname>PostgreSQL</productname>
   must be in the external text representation format. For example, the
   <function>encode_bytea</function> function can be used to
   escape binary data for a return value of type <type>bytea</type>.
  </para>
____________________________________________________________________________-->
  <para>
   类似地，回传给<productname>PostgreSQL</productname>的值必须
   是外部文本表达格式。例如，<function>encode_bytea</function>
   函数可以被用来转义二进制数据得到类型<type>bytea</type>的返回值。
  </para>

<!--==========================orignal english content==========================
  <para>
   One case that is particularly important is boolean values.  As just
   stated, the default behavior for <type>bool</type> values is that they
   are passed to Perl as text, thus either <literal>'t'</literal>
   or <literal>'f'</literal>.  This is problematic, since Perl will not
   treat <literal>'f'</literal> as false!  It is possible to improve matters
   by using a <quote>transform</quote> (see
   <xref linkend="sql-createtransform"/>).  Suitable transforms are provided
   by the <filename>bool_plperl</filename> extension.  To use it, install
   the extension:
<programlisting>
CREATE EXTENSION bool_plperl;  -&minus; or bool_plperlu for PL/PerlU
</programlisting>
   Then use the <literal>TRANSFORM</literal> function attribute for a
   PL/Perl function that takes or returns <type>bool</type>, for example:
<programlisting>
CREATE FUNCTION perl_and(bool, bool) RETURNS bool
TRANSFORM FOR TYPE bool
AS $$
  my ($a, $b) = @_;
  return $a &amp;&amp; $b;
$$ LANGUAGE plperl;
</programlisting>
   When this transform is applied, <type>bool</type> arguments will be seen
   by Perl as being <literal>1</literal> or empty, thus properly true or
   false.  If the function result is type <type>bool</type>, it will be true
   or false according to whether Perl would evaluate the returned value as
   true.
   Similar transformations are also performed for boolean query arguments
   and results of SPI queries performed inside the function
   (<xref linkend="plperl-database"/>).
  </para>
____________________________________________________________________________-->
  <para>
   一种特别重要的情况是布尔值。如前所述，<type>bool</type>值的默认行为是它们作为文本传递给 Perl，
   因此要么<literal>'t'</literal>要么<literal>'f'</literal>。
   这是有问题的，因为 Perl 不会将<literal>'f'</literal>视为假！
   可以通过使用<quote>transform</quote>来改善问题（参见<xref linkend="sql-createtransform"/>）。
   <filename>bool_plperl</filename>扩展提供了合适的转换。要使用它，请安装扩展：
<programlisting>
CREATE EXTENSION bool_plperl;  -- or bool_plperlu for PL/PerlU
</programlisting>
   然后将<literal>TRANSFORM</literal>函数属性用于接受或返回<type>bool</type>的 PL/Perl 函数，例如：
<programlisting>
CREATE FUNCTION perl_and(bool, bool) RETURNS bool
TRANSFORM FOR TYPE bool
AS $$
  my ($a, $b) = @_;
  return $a &amp;&amp; $b;
$$ LANGUAGE plperl;
</programlisting>
   当应用这个转换时，<type>bool</type>参数将被 Perl 视为<literal>1</literal>或空，因此正确或错误。
   如果函数结果是<type>bool</type>类型，它会根据 Perl 是否将返回值评估为真来判断为真或假。
   函数内部执行的 SPI 查询的布尔查询参数和结果也执行类似的转换(<xref linkend="plperl-database"/>)。
  </para>

<!--==========================orignal english content==========================
  <para>
   Perl can return <productname>PostgreSQL</productname> arrays as
   references to Perl arrays.  Here is an example:

<programlisting>
CREATE OR REPLACE function returns_array()
RETURNS text[][] AS $$
    return [['a&quot;b','c,d'],['e\\f','g']];
$$ LANGUAGE plperl;

select returns_array();
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   Perl 可以把<productname>PostgreSQL</productname>数组返回为对
   Perl 数组的引用。这里有一个例子：

<programlisting>
CREATE OR REPLACE function returns_array()
RETURNS text[][] AS $$
    return [['a&quot;b','c,d'],['e\\f','g']];
$$ LANGUAGE plperl;

select returns_array();
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Perl passes <productname>PostgreSQL</productname> arrays as a blessed
   <type>PostgreSQL::InServer::ARRAY</type> object. This object may be treated as an array
   reference or a string, allowing for backward compatibility with Perl
   code written for <productname>PostgreSQL</productname> versions below 9.1 to
   run.  For example:

<programlisting>
CREATE OR REPLACE FUNCTION concat_array_elements(text[]) RETURNS TEXT AS $$
    my $arg = shift;
    my $result = "";
    return undef if (!defined $arg);

    # as an array reference
    for (@$arg) {
        $result .= $_;
    }

    # also works as a string
    $result .= $arg;

    return $result;
$$ LANGUAGE plperl;

SELECT concat_array_elements(ARRAY['PL','/','Perl']);
</programlisting>

  <note>
   <para>
    Multidimensional arrays are represented as references to
    lower-dimensional arrays of references in a way common to every Perl
    programmer.
   </para>
  </note>
  </para>
____________________________________________________________________________-->
  <para>
   Perl 把<productname>PostgreSQL</productname>数组作为被 bless 过的
   <type>PostgreSQL::InServer::ARRAY</type>对象传递。这个对象可以被当作
   一个数组引用或者一个串，允许为了向后兼容性与为 9.1 以下版本的
   <productname>PostgreSQL</productname>编写的 Perl 代码一起运行。
   例如：

<programlisting>
CREATE OR REPLACE FUNCTION concat_array_elements(text[]) RETURNS TEXT AS $$
    my $arg = shift;
    my $result = "";
    return undef if (!defined $arg);

    # as an array reference
    for (@$arg) {
        $result .= $_;
    }

    # also works as a string
    $result .= $arg;

    return $result;
$$ LANGUAGE plperl;

SELECT concat_array_elements(ARRAY['PL','/','Perl']);
</programlisting>

  <note>
   <para>
    多维数组被以一种对每一个 Perl 程序员都公认的方法表示为对较低维引用数组
    的引用。
   </para>
  </note>
  </para>

<!--==========================orignal english content==========================
  <para>
   Composite-type arguments are passed to the function as references
   to hashes.  The keys of the hash are the attribute names of the
   composite type.  Here is an example:

<programlisting>
CREATE TABLE employee (
    name text,
    basesalary integer,
    bonus integer
);

CREATE FUNCTION empcomp(employee) RETURNS integer AS $$
    my ($emp) = @_;
    return $emp-&gt;{basesalary} + $emp-&gt;{bonus};
$$ LANGUAGE plperl;

SELECT name, empcomp(employee.*) FROM employee;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   组合类型参数被作为哈希的引用传递给函数。哈希的键是组合类型的
   属性名。这里是一个例子：

<programlisting>
CREATE TABLE employee (
    name text,
    basesalary integer,
    bonus integer
);

CREATE FUNCTION empcomp(employee) RETURNS integer AS $$
    my ($emp) = @_;
    return $emp-&gt;{basesalary} + $emp-&gt;{bonus};
$$ LANGUAGE plperl;

SELECT name, empcomp(employee.*) FROM employee;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   A PL/Perl function can return a composite-type result using the same
   approach: return a reference to a hash that has the required attributes.
   For example:

<programlisting>
CREATE TYPE testrowperl AS (f1 integer, f2 text, f3 text);

CREATE OR REPLACE FUNCTION perl_row() RETURNS testrowperl AS $$
    return {f2 =&gt; 'hello', f1 =&gt; 1, f3 =&gt; 'world'};
$$ LANGUAGE plperl;

SELECT * FROM perl_row();
</programlisting>

   Any columns in the declared result data type that are not present in the
   hash will be returned as null values.
  </para>
____________________________________________________________________________-->
  <para>
   PL/Perl 函数可以使用相同的方法返回组合类型：返回具有所要求属性的
   哈希的引用。例如：

<programlisting>
CREATE TYPE testrowperl AS (f1 integer, f2 text, f3 text);

CREATE OR REPLACE FUNCTION perl_row() RETURNS testrowperl AS $$
    return {f2 =&gt; 'hello', f1 =&gt; 1, f3 =&gt; 'world'};
$$ LANGUAGE plperl;

SELECT * FROM perl_row();
</programlisting>

   任何所要求结果数据类型中不存在于哈希中的列将被返回为空值。
  </para>

<!--==========================orignal english content==========================
  <para>
   Similarly, output arguments of procedures can be returned as a hash
   reference:

<programlisting>
CREATE PROCEDURE perl_triple(INOUT a integer, INOUT b integer) AS $$
    my ($a, $b) = @_;
    return {a =&gt; $a * 3, b =&gt; $b * 3};
$$ LANGUAGE plperl;

CALL perl_triple(5, 10);
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   类似的，过程的输出参数也可以被返回为哈希引用：

<programlisting>
CREATE PROCEDURE perl_triple(INOUT a integer, INOUT b integer) AS $$
    my ($a, $b) = @_;
    return {a =&gt; $a * 3, b =&gt; $b * 3};
$$ LANGUAGE plperl;

CALL perl_triple(5, 10);
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
    PL/Perl functions can also return sets of either scalar or
    composite types.  Usually you'll want to return rows one at a
    time, both to speed up startup time and to keep from queuing up
    the entire result set in memory.  You can do this with
    <function>return_next</function> as illustrated below.  Note that
    after the last <function>return_next</function>, you must put
    either <literal>return</literal> or (better) <literal>return
    undef</literal>.

<programlisting>
CREATE OR REPLACE FUNCTION perl_set_int(int)
RETURNS SETOF INTEGER AS $$
    foreach (0..$_[0]) {
        return_next($_);
    }
    return undef;
$$ LANGUAGE plperl;

SELECT * FROM perl_set_int(5);

CREATE OR REPLACE FUNCTION perl_set()
RETURNS SETOF testrowperl AS $$
    return_next({ f1 =&gt; 1, f2 =&gt; 'Hello', f3 =&gt; 'World' });
    return_next({ f1 =&gt; 2, f2 =&gt; 'Hello', f3 =&gt; 'PostgreSQL' });
    return_next({ f1 =&gt; 3, f2 =&gt; 'Hello', f3 =&gt; 'PL/Perl' });
    return undef;
$$ LANGUAGE plperl;
</programlisting>

    For small result sets, you can return a reference to an array that
    contains either scalars, references to arrays, or references to
    hashes for simple types, array types, and composite types,
    respectively.  Here are some simple examples of returning the entire
    result set as an array reference:

<programlisting>
CREATE OR REPLACE FUNCTION perl_set_int(int) RETURNS SETOF INTEGER AS $$
    return [0..$_[0]];
$$ LANGUAGE plperl;

SELECT * FROM perl_set_int(5);

CREATE OR REPLACE FUNCTION perl_set() RETURNS SETOF testrowperl AS $$
    return [
        { f1 =&gt; 1, f2 =&gt; 'Hello', f3 =&gt; 'World' },
        { f1 =&gt; 2, f2 =&gt; 'Hello', f3 =&gt; 'PostgreSQL' },
        { f1 =&gt; 3, f2 =&gt; 'Hello', f3 =&gt; 'PL/Perl' }
    ];
$$ LANGUAGE plperl;

SELECT * FROM perl_set();
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
    PL/Perl 函数也能返回标量或者组合类型集合。为了加速启动并且避免在
    内存中让整个结果集排队等候，我们通常希望能一次返回一行。可以按
    下文所说的用<function>return_next</function>来这样做。注意在
    最后一次<function>return_next</function>后，必须放上
    <literal>return</literal>或者<literal>return
    undef</literal>（后者更好）。

<programlisting>
CREATE OR REPLACE FUNCTION perl_set_int(int)
RETURNS SETOF INTEGER AS $$
    foreach (0..$_[0]) {
        return_next($_);
    }
    return undef;
$$ LANGUAGE plperl;

SELECT * FROM perl_set_int(5);

CREATE OR REPLACE FUNCTION perl_set()
RETURNS SETOF testrowperl AS $$
    return_next({ f1 =&gt; 1, f2 =&gt; 'Hello', f3 =&gt; 'World' });
    return_next({ f1 =&gt; 2, f2 =&gt; 'Hello', f3 =&gt; 'PostgreSQL' });
    return_next({ f1 =&gt; 3, f2 =&gt; 'Hello', f3 =&gt; 'PL/Perl' });
    return undef;
$$ LANGUAGE plperl;
</programlisting>

    对于小结果集，可以返回到一个数组的引用，该数组分别包含用于
    简单类型、数组类型和组合类型的标量、数组引用或者哈希引用。
    这里有一些简单的例子把整个结果集作为数组引用返回：

<programlisting>
CREATE OR REPLACE FUNCTION perl_set_int(int) RETURNS SETOF INTEGER AS $$
    return [0..$_[0]];
$$ LANGUAGE plperl;

SELECT * FROM perl_set_int(5);

CREATE OR REPLACE FUNCTION perl_set() RETURNS SETOF testrowperl AS $$
    return [
        { f1 =&gt; 1, f2 =&gt; 'Hello', f3 =&gt; 'World' },
        { f1 =&gt; 2, f2 =&gt; 'Hello', f3 =&gt; 'PostgreSQL' },
        { f1 =&gt; 3, f2 =&gt; 'Hello', f3 =&gt; 'PL/Perl' }
    ];
$$ LANGUAGE plperl;

SELECT * FROM perl_set();
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   If you wish to use the <literal>strict</literal> pragma with your code you
   have a few options. For temporary global use you can <command>SET</command>
   <literal>plperl.use_strict</literal> to true.
   This will affect subsequent compilations of <application>PL/Perl</application>
   functions, but not functions already compiled in the current session.
   For permanent global use you can set <literal>plperl.use_strict</literal>
   to true in the <filename>postgresql.conf</filename> file.
  </para>
____________________________________________________________________________-->
  <para>
   如果你想要对你的代码使用<literal>strict</literal>编译指示，有几种选项可用。
   对于临时的全局使用，你可以<command>SET</command>
   <literal>plperl.use_strict</literal>为真。这将影响后续
   <application>PL/Perl</application>函数的编译，但是对当前会话中已经编译过的
   函数没有影响。对于持久的全局使用，可以在
   <filename>postgresql.conf</filename>文件中设置
   <literal>plperl.use_strict</literal>为真。
  </para>

<!--==========================orignal english content==========================
  <para>
   For permanent use in specific functions you can simply put:
<programlisting>
use strict;
</programlisting>
   at the top of the function body.
  </para>
____________________________________________________________________________-->
  <para>
   对于在特定函数中的持久使用，可以简单地把
<programlisting>
use strict;
</programlisting>
   放在函数体的顶层。
  </para>

<!--==========================orignal english content==========================
  <para>
  The <literal>feature</literal> pragma is also available to <function>use</function> if your Perl is version 5.10.0 or higher.
  </para>
____________________________________________________________________________-->
  <para>
  如果 Perl 版本是 5.10.0 或者更高，也可以<function>使用</function>
  <literal>feature</literal>编译指示。
  </para>

 </sect1>

 <sect1 id="plperl-data">
<!--==========================orignal english content==========================
  <title>Data Values in PL/Perl</title>
____________________________________________________________________________-->
  <title>PL/Perl 中的数据值</title>

<!--==========================orignal english content==========================
  <para>
   The argument values supplied to a PL/Perl function's code are
   simply the input arguments converted to text form (just as if they
   had been displayed by a <command>SELECT</command> statement).
   Conversely, the <function>return</function> and <function>return_next</function>
   commands will accept any string that is acceptable input format
   for the function's declared return type.
  </para>
____________________________________________________________________________-->
  <para>
   提供给 PL/Perl 函数代码的参数值是被转换成文本形式的输入参数（就像它们
   被<command>SELECT</command>语句显示的那样）。反过来，
   <function>return</function>和<function>return_next</function>命令
   将接受任何该函数返回类型可接受的输入格式的串。
  </para>
<!--==========================orignal english content==========================
  <para>
   If this behavior is inconvenient for a particular case, it can be
   improved by using a transform, as already illustrated
   for <type>bool</type> values.  Several examples of transform modules
   are included in the <productname>PostgreSQL</productname> distribution.
  </para>
____________________________________________________________________________-->
  <para>
   如果这种行为在特定情况下不方便，可以通过使用转换来改进，正如已经针对<type>bool</type>值说明的那样。
   <productname>PostgreSQL</productname> 发行版中包含了几个转换模块的示例。
  </para>
 </sect1>

 <sect1 id="plperl-builtins">
<!--==========================orignal english content==========================
  <title>Built-in Functions</title>
____________________________________________________________________________-->
  <title>内建函数</title>

 <sect2 id="plperl-database">
<!--==========================orignal english content==========================
  <title>Database Access from PL/Perl</title>
____________________________________________________________________________-->
  <title>从 PL/Perl 访问数据库</title>

<!--==========================orignal english content==========================
  <para>
   Access to the database itself from your Perl function can be done
   via the following functions:
  </para>
____________________________________________________________________________-->
  <para>
   可以通过下列函数从 Perl 函数中访问数据库本身：
  </para>

   <variablelist>
    <varlistentry>
<!--==========================orignal english content==========================
     <term>
      <literal><function>spi_exec_query</function>(<replaceable>query</replaceable> [, <replaceable>max-rows</replaceable>])</literal>
      <indexterm>
       <primary>spi_exec_query</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <literal><function>spi_exec_query</function>(<replaceable>query</replaceable> [, <replaceable>max-rows</replaceable>])</literal>
      <indexterm>
       <primary>spi_exec_query</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       <literal>spi_exec_query</literal> executes an SQL command and
returns the entire row set as a reference to an array of hash
references.  <emphasis>You should only use this command when you know
that the result set will be relatively small.</emphasis>  Here is an
example of a query (<command>SELECT</command> command) with the
optional maximum number of rows:

<programlisting>
$rv = spi_exec_query('SELECT * FROM my_table', 5);
</programlisting>
        This returns up to 5 rows from the table
        <literal>my_table</literal>.  If <literal>my_table</literal>
        has a column <literal>my_column</literal>, you can get that
        value from row <literal>$i</literal> of the result like this:
<programlisting>
$foo = $rv-&gt;{rows}[$i]-&gt;{my_column};
</programlisting>
       The total number of rows returned from a <command>SELECT</command>
       query can be accessed like this:
<programlisting>
$nrows = $rv-&gt;{processed}
</programlisting>
      </para>
____________________________________________________________________________-->
      <para>
       <literal>spi_exec_query</literal>执行一个 SQL 命令并且以哈希引用数组
       的引用的形式返回整个行集。<emphasis>只有在知道结果集相对较小时才
       应该使用这个命令。</emphasis>这里是一个带有可选最大行数的查询（
       <command>SELECT</command>命令）的例子：

<programlisting>
$rv = spi_exec_query('SELECT * FROM my_table', 5);
</programlisting>
        这会从表<literal>my_table</literal>.返回最多 5 行。如果
        <literal>my_table</literal>有一个列<literal>my_column</literal>，
        可以从结果的<literal>$i</literal>行得到值：
<programlisting>
$foo = $rv-&gt;{rows}[$i]-&gt;{my_column};
</programlisting>
       可以这样访问从一个<command>SELECT</command>查询返回
       的总行数：
<programlisting>
$nrows = $rv-&gt;{processed}
</programlisting>
      </para>

<!--==========================orignal english content==========================
      <para>
       Here is an example using a different command type:
<programlisting>
$query = "INSERT INTO my_table VALUES (1, 'test')";
$rv = spi_exec_query($query);
</programlisting>
       You can then access the command status (e.g.,
       <literal>SPI_OK_INSERT</literal>) like this:
<programlisting>
$res = $rv-&gt;{status};
</programlisting>
       To get the number of rows affected, do:
<programlisting>
$nrows = $rv-&gt;{processed};
</programlisting>
      </para>
____________________________________________________________________________-->
      <para>
       这里是使用不同命令类型的一个例子：
<programlisting>
$query = "INSERT INTO my_table VALUES (1, 'test')";
$rv = spi_exec_query($query);
</programlisting>
       你可以这样访问命令状态（例如<literal>SPI_OK_INSERT</literal>）：
<programlisting>
$res = $rv-&gt;{status};
</programlisting>
       要得到受影响的行数：
<programlisting>
$nrows = $rv-&gt;{processed};
</programlisting>
      </para>

<!--==========================orignal english content==========================
      <para>
       Here is a complete example:
<programlisting>
CREATE TABLE test (
    i int,
    v varchar
);

INSERT INTO test (i, v) VALUES (1, 'first line');
INSERT INTO test (i, v) VALUES (2, 'second line');
INSERT INTO test (i, v) VALUES (3, 'third line');
INSERT INTO test (i, v) VALUES (4, 'immortal');

CREATE OR REPLACE FUNCTION test_munge() RETURNS SETOF test AS $$
    my $rv = spi_exec_query('select i, v from test;');
    my $status = $rv-&gt;{status};
    my $nrows = $rv-&gt;{processed};
    foreach my $rn (0 .. $nrows - 1) {
        my $row = $rv-&gt;{rows}[$rn];
        $row-&gt;{i} += 200 if defined($row-&gt;{i});
        $row-&gt;{v} =~ tr/A-Za-z/a-zA-Z/ if (defined($row-&gt;{v}));
        return_next($row);
    }
    return undef;
$$ LANGUAGE plperl;

SELECT * FROM test_munge();
</programlisting>
    </para>
____________________________________________________________________________-->
      <para>
       这里是一个完整的例子：
<programlisting>
CREATE TABLE test (
    i int,
    v varchar
);

INSERT INTO test (i, v) VALUES (1, 'first line');
INSERT INTO test (i, v) VALUES (2, 'second line');
INSERT INTO test (i, v) VALUES (3, 'third line');
INSERT INTO test (i, v) VALUES (4, 'immortal');

CREATE OR REPLACE FUNCTION test_munge() RETURNS SETOF test AS $$
    my $rv = spi_exec_query('select i, v from test;');
    my $status = $rv-&gt;{status};
    my $nrows = $rv-&gt;{processed};
    foreach my $rn (0 .. $nrows - 1) {
        my $row = $rv-&gt;{rows}[$rn];
        $row-&gt;{i} += 200 if defined($row-&gt;{i});
        $row-&gt;{v} =~ tr/A-Za-z/a-zA-Z/ if (defined($row-&gt;{v}));
        return_next($row);
    }
    return undef;
$$ LANGUAGE plperl;

SELECT * FROM test_munge();
</programlisting>
    </para>
    </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term>
      <literal><function>spi_query(<replaceable>command</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_query</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <literal><function>spi_query(<replaceable>command</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_query</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
<!--==========================orignal english content==========================
     <term>
      <literal><function>spi_fetchrow(<replaceable>cursor</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_fetchrow</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <literal><function>spi_fetchrow(<replaceable>cursor</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_fetchrow</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
<!--==========================orignal english content==========================
     <term>
      <literal><function>spi_cursor_close(<replaceable>cursor</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_cursor_close</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <literal><function>spi_cursor_close(<replaceable>cursor</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_cursor_close</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>

    <listitem>
<!--==========================orignal english content==========================
    <para>
    <literal>spi_query</literal> and <literal>spi_fetchrow</literal>
    work together as a pair for row sets which might be large, or for cases
    where you wish to return rows as they arrive.
    <literal>spi_fetchrow</literal> works <emphasis>only</emphasis> with
    <literal>spi_query</literal>. The following example illustrates how
    you use them together:

<programlisting>
CREATE TYPE foo_type AS (the_num INTEGER, the_text TEXT);

CREATE OR REPLACE FUNCTION lotsa_md5 (INTEGER) RETURNS SETOF foo_type AS $$
    use Digest::MD5 qw(md5_hex);
    my $file = '/usr/share/dict/words';
    my $t = localtime;
    elog(NOTICE, "opening file $file at $t" );
    open my $fh, '&lt;', $file # ooh, it's a file access!
        or elog(ERROR, "cannot open $file for reading: $!");
    my @words = &lt;$fh&gt;;
    close $fh;
    $t = localtime;
    elog(NOTICE, "closed file $file at $t");
    chomp(@words);
    my $row;
    my $sth = spi_query("SELECT * FROM generate_series(1,$_[0]) AS b(a)");
    while (defined ($row = spi_fetchrow($sth))) {
        return_next({
            the_num =&gt; $row-&gt;{a},
            the_text =&gt; md5_hex($words[rand @words])
        });
    }
    return;
$$ LANGUAGE plperlu;

SELECT * from lotsa_md5(500);
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
    <literal>spi_query</literal>和<literal>spi_fetchrow</literal>
    结对用于可能比较大的行集合，或者用于希望在行到达时返回的情况。
    <literal>spi_fetchrow</literal><emphasis>只</emphasis>和
    <literal>spi_query</literal>一起工作。下面的例子展示了如何使用
    它们：

<programlisting>
CREATE TYPE foo_type AS (the_num INTEGER, the_text TEXT);

CREATE OR REPLACE FUNCTION lotsa_md5 (INTEGER) RETURNS SETOF foo_type AS $$
    use Digest::MD5 qw(md5_hex);
    my $file = '/usr/share/dict/words';
    my $t = localtime;
    elog(NOTICE, "opening file $file at $t" );
    open my $fh, '&lt;', $file # ooh, it's a file access!
        or elog(ERROR, "cannot open $file for reading: $!");
    my @words = &lt;$fh&gt;;
    close $fh;
    $t = localtime;
    elog(NOTICE, "closed file $file at $t");
    chomp(@words);
    my $row;
    my $sth = spi_query("SELECT * FROM generate_series(1,$_[0]) AS b(a)");
    while (defined ($row = spi_fetchrow($sth))) {
        return_next({
            the_num =&gt; $row-&gt;{a},
            the_text =&gt; md5_hex($words[rand @words])
        });
    }
    return;
$$ LANGUAGE plperlu;

SELECT * from lotsa_md5(500);
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     Normally, <function>spi_fetchrow</function> should be repeated until it
     returns <literal>undef</literal>, indicating that there are no more
     rows to read.  The cursor returned by <literal>spi_query</literal>
     is automatically freed when
     <function>spi_fetchrow</function> returns <literal>undef</literal>.
     If you do not wish to read all the rows, instead call
     <function>spi_cursor_close</function> to free the cursor.
     Failure to do so will result in memory leaks.
    </para>
____________________________________________________________________________-->
    <para>
     通常，<function>spi_fetchrow</function>应该重复执行直到它返回
     <literal>undef</literal>（表示没有更多行要读取）。当
     <function>spi_fetchrow</function>返回<literal>undef</literal>时，
     <literal>spi_query</literal>返回的游标会自动被释放。如果不
     想读取所有的行，可以调用<function>spi_cursor_close</function>来
     释放游标。如果没有这样做会导致内存泄露。
    </para>

    </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term>
      <literal><function>spi_prepare(<replaceable>command</replaceable>, <replaceable>argument types</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_prepare</primary>
       <secondary>in PL/Perl</secondary>
     </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <literal><function>spi_prepare(<replaceable>command</replaceable>, <replaceable>argument types</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_prepare</primary>
       <secondary>in PL/Perl</secondary>
     </indexterm>
     </term>
<!--==========================orignal english content==========================
     <term>
      <literal><function>spi_query_prepared(<replaceable>plan</replaceable>, <replaceable>arguments</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_query_prepared</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <literal><function>spi_query_prepared(<replaceable>plan</replaceable>, <replaceable>arguments</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_query_prepared</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
<!--==========================orignal english content==========================
     <term>
      <literal><function>spi_exec_prepared(<replaceable>plan</replaceable> [, <replaceable>attributes</replaceable>], <replaceable>arguments</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_exec_prepared</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <literal><function>spi_exec_prepared(<replaceable>plan</replaceable> [, <replaceable>attributes</replaceable>], <replaceable>arguments</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_exec_prepared</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
<!--==========================orignal english content==========================
     <term>
      <literal><function>spi_freeplan(<replaceable>plan</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_freeplan</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <literal><function>spi_freeplan(<replaceable>plan</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_freeplan</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>

    <listitem>
<!--==========================orignal english content==========================
    <para>
    <literal>spi_prepare</literal>, <literal>spi_query_prepared</literal>, <literal>spi_exec_prepared</literal>,
    and <literal>spi_freeplan</literal> implement the same functionality but for prepared queries.
    <literal>spi_prepare</literal> accepts a query string with numbered argument placeholders ($1, $2, etc)
    and a string list of argument types:
<programlisting>
$plan = spi_prepare('SELECT * FROM test WHERE id &gt; $1 AND name = $2',
                                                     'INTEGER', 'TEXT');
</programlisting>
    Once a query plan is prepared by a call to <literal>spi_prepare</literal>, the plan can be used instead
    of the string query, either in <literal>spi_exec_prepared</literal>, where the result is the same as returned
    by <literal>spi_exec_query</literal>, or in <literal>spi_query_prepared</literal> which returns a cursor
    exactly as <literal>spi_query</literal> does, which can be later passed to <literal>spi_fetchrow</literal>.
    The optional second parameter to <literal>spi_exec_prepared</literal> is a hash reference of attributes;
    the only attribute currently supported is <literal>limit</literal>, which sets the maximum number of rows returned by a query.
    </para>
____________________________________________________________________________-->
    <para>
    <literal>spi_prepare</literal>、<literal>spi_query_prepared</literal>、
    <literal>spi_exec_prepared</literal>和<literal>spi_freeplan</literal>
    为预备查询实现了相同的功能。<literal>spi_prepare</literal>接受一个查询
    字符串，其中包括编好号的参数占位符（$1、$2 等）以及参数类型的字符串
    列表：
<programlisting>
$plan = spi_prepare('SELECT * FROM test WHERE id &gt; $1 AND name = $2',
                                                     'INTEGER', 'TEXT');
</programlisting>
    一旦通过调用<literal>spi_prepare</literal>准备好一个查询计划，就可以在
    <literal>spi_exec_prepared</literal>（返回的结果和
    <literal>spi_exec_query</literal>相同）或者<literal>spi_query_prepared</literal>
    （返回的结果和<literal>spi_query</literal>一样，后面会被传给
    <literal>spi_fetchrow</literal>）中用该计划来取代字符串查询。
    <literal>spi_exec_prepared</literal>可选的第二个参数是属性的哈希引用，
    当前唯一支持的属性是<literal>limit</literal>，它限定了一个查询返回的最大
    行数。
    </para>

<!--==========================orignal english content==========================
    <para>
    The advantage of prepared queries is that is it possible to use one prepared plan for more
    than one query execution. After the plan is not needed anymore, it can be freed with
    <literal>spi_freeplan</literal>:
<programlisting>
CREATE OR REPLACE FUNCTION init() RETURNS VOID AS $$
        $_SHARED{my_plan} = spi_prepare('SELECT (now() + $1)::date AS now',
                                        'INTERVAL');
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION add_time( INTERVAL ) RETURNS TEXT AS $$
        return spi_exec_prepared(
                $_SHARED{my_plan},
                $_[0]
        )->{rows}->[0]->{now};
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION done() RETURNS VOID AS $$
        spi_freeplan( $_SHARED{my_plan});
        undef $_SHARED{my_plan};
$$ LANGUAGE plperl;

SELECT init();
SELECT add_time('1 day'), add_time('2 days'), add_time('3 days');
SELECT done();

  add_time  |  add_time  |  add_time
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 2005-12-10 | 2005-12-11 | 2005-12-12
</programlisting>
    Note that the parameter subscript in <literal>spi_prepare</literal> is defined via
    $1, $2, $3, etc, so avoid declaring query strings in double quotes that might easily
    lead to hard-to-catch bugs.
    </para>
____________________________________________________________________________-->
    <para>
    预备查询的有点是可以把一个准备好的计划用于多次查询执行。不再需要该计划后，
    可以用<literal>spi_freeplan</literal>释放它：
<programlisting>
CREATE OR REPLACE FUNCTION init() RETURNS VOID AS $$
        $_SHARED{my_plan} = spi_prepare('SELECT (now() + $1)::date AS now',
                                        'INTERVAL');
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION add_time( INTERVAL ) RETURNS TEXT AS $$
        return spi_exec_prepared(
                $_SHARED{my_plan},
                $_[0]
        )->{rows}->[0]->{now};
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION done() RETURNS VOID AS $$
        spi_freeplan( $_SHARED{my_plan});
        undef $_SHARED{my_plan};
$$ LANGUAGE plperl;

SELECT init();
SELECT add_time('1 day'), add_time('2 days'), add_time('3 days');
SELECT done();

  add_time  |  add_time  |  add_time
------------+------------+------------
 2005-12-10 | 2005-12-11 | 2005-12-12
</programlisting>
    注意<literal>spi_prepare</literal>中的参数下标通过 $1、$2、$3 等定义，
    这样避免了用双引号来声明查询串（容易导致难以捕捉的缺陷）。
    </para>

<!--==========================orignal english content==========================
    <para>
    Another example illustrates usage of an optional parameter in <literal>spi_exec_prepared</literal>:
<programlisting>
CREATE TABLE hosts AS SELECT id, ('192.168.1.'||id)::inet AS address
                      FROM generate_series(1,3) AS id;

CREATE OR REPLACE FUNCTION init_hosts_query() RETURNS VOID AS $$
        $_SHARED{plan} = spi_prepare('SELECT * FROM hosts
                                      WHERE address &lt;&lt; $1', 'inet');
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION query_hosts(inet) RETURNS SETOF hosts AS $$
        return spi_exec_prepared(
                $_SHARED{plan},
                {limit =&gt; 2},
                $_[0]
        )->{rows};
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION release_hosts_query() RETURNS VOID AS $$
        spi_freeplan($_SHARED{plan});
        undef $_SHARED{plan};
$$ LANGUAGE plperl;

SELECT init_hosts_query();
SELECT query_hosts('192.168.1.0/30');
SELECT release_hosts_query();

    query_hosts    
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 (1,192.168.1.1)
 (2,192.168.1.2)
(2 rows)
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
    另一个展示<literal>spi_exec_prepared</literal>中可选参数用法的例子：
<programlisting>
CREATE TABLE hosts AS SELECT id, ('192.168.1.'||id)::inet AS address
                      FROM generate_series(1,3) AS id;

CREATE OR REPLACE FUNCTION init_hosts_query() RETURNS VOID AS $$
        $_SHARED{plan} = spi_prepare('SELECT * FROM hosts
                                      WHERE address &lt;&lt; $1', 'inet');
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION query_hosts(inet) RETURNS SETOF hosts AS $$
        return spi_exec_prepared(
                $_SHARED{plan},
                {limit =&gt; 2},
                $_[0]
        )->{rows};
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION release_hosts_query() RETURNS VOID AS $$
        spi_freeplan($_SHARED{plan});
        undef $_SHARED{plan};
$$ LANGUAGE plperl;

SELECT init_hosts_query();
SELECT query_hosts('192.168.1.0/30');
SELECT release_hosts_query();

    query_hosts    
-----------------
 (1,192.168.1.1)
 (2,192.168.1.2)
(2 rows)
</programlisting>
    </para>
    </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term>
      <literal><function>spi_commit()</function></literal>
      <indexterm>
       <primary>spi_commit</primary>
       <secondary>in PL/Perl</secondary>
     </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <literal><function>spi_commit()</function></literal>
      <indexterm>
       <primary>spi_commit</primary>
       <secondary>in PL/Perl</secondary>
     </indexterm>
     </term>
<!--==========================orignal english content==========================
     <term>
      <literal><function>spi_rollback()</function></literal>
      <indexterm>
       <primary>spi_rollback</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <literal><function>spi_rollback()</function></literal>
      <indexterm>
       <primary>spi_rollback</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       Commit or roll back the current transaction.  This can only be called
       in a procedure or anonymous code block (<command>DO</command> command)
       called from the top level.  (Note that it is not possible to run the
       SQL commands <command>COMMIT</command> or <command>ROLLBACK</command>
       via <function>spi_exec_query</function> or similar.  It has to be done
       using these functions.)  After a transaction is ended, a new
       transaction is automatically started, so there is no separate function
       for that.
      </para>
____________________________________________________________________________-->
      <para>
       提交或者回滚当前事务。只能在从顶层调用的过程或者匿名代码块（<command>DO</command>命令）中调用这个函数（注意不能通过<function>spi_exec_query</function>或者类似的函数运行SQL命令<command>COMMIT</command>或者<command>ROLLBACK</command>。这样的工作只能使用这些函数完成）。在一个事务结束后，一个新的事务会自动开始，因此没有单独的函数来开始新事务。
      </para>

<!--==========================orignal english content==========================
      <para>
       Here is an example:
<programlisting>
CREATE PROCEDURE transaction_test1()
LANGUAGE plperl
AS $$
foreach my $i (0..9) {
    spi_exec_query("INSERT INTO test1 (a) VALUES ($i)");
    if ($i % 2 == 0) {
        spi_commit();
    } else {
        spi_rollback();
    }
}
$$;

CALL transaction_test1();
</programlisting>
      </para>
____________________________________________________________________________-->
      <para>
       这里是一个例子：
<programlisting>
CREATE PROCEDURE transaction_test1()
LANGUAGE plperl
AS $$
foreach my $i (0..9) {
    spi_exec_query("INSERT INTO test1 (a) VALUES ($i)");
    if ($i % 2 == 0) {
        spi_commit();
    } else {
        spi_rollback();
    }
}
$$;

CALL transaction_test1();
</programlisting>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
 </sect2>

 <sect2 id="plperl-utility-functions">
<!--==========================orignal english content==========================
  <title>Utility Functions in PL/Perl</title>
____________________________________________________________________________-->
  <title>PL/Perl 中的工具函数</title>

   <variablelist>
    <varlistentry>
<!--==========================orignal english content==========================
     <term>
      <literal><function>elog(<replaceable>level</replaceable>, <replaceable>msg</replaceable>)</function></literal>
      <indexterm>
       <primary>elog</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <literal><function>elog(<replaceable>level</replaceable>, <replaceable>msg</replaceable>)</function></literal>
      <indexterm>
       <primary>elog</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       Emit a log or error message. Possible levels are
       <literal>DEBUG</literal>, <literal>LOG</literal>, <literal>INFO</literal>,
       <literal>NOTICE</literal>, <literal>WARNING</literal>, and <literal>ERROR</literal>.
       <literal>ERROR</literal>
        raises an error condition; if this is not trapped by the surrounding
        Perl code, the error propagates out to the calling query, causing
        the current transaction or subtransaction to be aborted.  This
        is effectively the same as the Perl <literal>die</literal> command.
        The other levels only generate messages of different
        priority levels.
        Whether messages of a particular priority are reported to the client,
        written to the server log, or both is controlled by the
        <xref linkend="guc-log-min-messages"/> and
        <xref linkend="guc-client-min-messages"/> configuration
        variables. See <xref linkend="runtime-config"/> for more
        information.
      </para>
____________________________________________________________________________-->
      <para>
       发出一个日志或者错误消息。可用的级别有
       <literal>DEBUG</literal>、<literal>LOG</literal>、<literal>INFO</literal>、
       <literal>NOTICE</literal>、<literal>WARNING</literal>以及<literal>ERROR</literal>。
       <literal>ERROR</literal>产生一种错误情况，如果它没有被周围的 Perl 代码
       捕获，错误会传播到调用查询中，导致当前事务或者子事务被中止。这实际
       上和 Perl 的<literal>die</literal> 命令相同。其他级别只产生不同优先级的消息。
       特定优先级的消息是被报告给客户端、写到服务器日志或者两者都做由
        配置变量<xref linkend="guc-log-min-messages"/>和
        <xref linkend="guc-client-min-messages"/>控制。详见
        <xref linkend="runtime-config"/>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term>
      <literal><function>quote_literal(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>quote_literal</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <literal><function>quote_literal(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>quote_literal</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
        Return the given string suitably quoted to be used as a string literal in an SQL
        statement string. Embedded single-quotes and backslashes are properly doubled.
        Note that <function>quote_literal</function> returns undef on undef input; if the argument
        might be undef, <function>quote_nullable</function> is often more suitable.
      </para>
____________________________________________________________________________-->
      <para>
        返回给定字符串的被适当引用后的形式，这种形式能被用作 SQL 语句字符串中的字符串。
        嵌入的引号和反斜线会被正确地双写。注意对 undef 输入<function>quote_literal</function>
        会返回 undef。如果参数可能是 undef，<function>quote_nullable</function>通常更合适。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term>
      <literal><function>quote_nullable(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>quote_nullable</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <literal><function>quote_nullable(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>quote_nullable</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
        Return the given string suitably quoted to be used as a string literal in an SQL
        statement string; or, if the argument is undef, return the unquoted string "NULL".
        Embedded single-quotes and backslashes are properly doubled.
      </para>
____________________________________________________________________________-->
      <para>
        返回给定字符串的被适当引用后的形式，这种形式能被用作 SQL 语句字符串中的字符串。
        或者在参数为 undef 时，返回未引用的串 "NULL"。
        嵌入的引号和反斜线会被正确地双写。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term>
      <literal><function>quote_ident(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>quote_ident</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <literal><function>quote_ident(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>quote_ident</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
        Return the given string suitably quoted to be used as an identifier in
        an SQL statement string. Quotes are added only if necessary (i.e., if
        the string contains non-identifier characters or would be case-folded).
        Embedded quotes are properly doubled.
      </para>
____________________________________________________________________________-->
      <para>
        返回给定字符串的被适当引用后的形式，这种形式能被用作 SQL 语句字符串
        中的标识符。只有在必要时才增加引号（即，如果串包含非标识符字符或者是
        大小写折叠的）。嵌入的引号会被正确地双写。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term>
      <literal><function>decode_bytea(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>decode_bytea</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <literal><function>decode_bytea(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>decode_bytea</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
        Return the unescaped binary data represented by the contents of the given string,
        which should be <type>bytea</type> encoded.
        </para>
____________________________________________________________________________-->
      <para>
        返回由给定串的内容（应该用<type>bytea</type>编码）表示的未转义二进制数据。
        </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term>
      <literal><function>encode_bytea(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>encode_bytea</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <literal><function>encode_bytea(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>encode_bytea</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
        Return the <type>bytea</type> encoded form of the binary data contents of the given string.
        </para>
____________________________________________________________________________-->
      <para>
        返回给定串的二进制数据内容的<type>bytea</type>编码形式。
        </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term>
      <literal><function>encode_array_literal(<replaceable>array</replaceable>)</function></literal>
      <indexterm>
       <primary>encode_array_literal</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <literal><function>encode_array_literal(<replaceable>array</replaceable>)</function></literal>
      <indexterm>
       <primary>encode_array_literal</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
<!--==========================orignal english content==========================
     <term>
      <literal><function>encode_array_literal(<replaceable>array</replaceable>, <replaceable>delimiter</replaceable>)</function></literal>
     </term>
____________________________________________________________________________-->
     <term>
      <literal><function>encode_array_literal(<replaceable>array</replaceable>, <replaceable>delimiter</replaceable>)</function></literal>
     </term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
        Returns the contents of the referenced array as a string in array literal format
        (see <xref linkend="arrays-input"/>).
        Returns the argument value unaltered if it's not a reference to an array.
        The delimiter used between elements of the array literal defaults to "<literal>, </literal>"
        if a delimiter is not specified or is undef.
        </para>
____________________________________________________________________________-->
      <para>
        把被引用的数组的内容返回成数组文字格式（见<xref linkend="arrays-input"/>）
        的一个串。如果它不是一个数组的引用，则不加修改地返回参数值。如果没有指定
        定界符或者定界符为 undef，则默认把"<literal>, </literal>"用作数组文字的元素
        之间的定界符。
        </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term>
      <literal><function>encode_typed_literal(<replaceable>value</replaceable>, <replaceable>typename</replaceable>)</function></literal>
      <indexterm>
       <primary>encode_typed_literal</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <literal><function>encode_typed_literal(<replaceable>value</replaceable>, <replaceable>typename</replaceable>)</function></literal>
      <indexterm>
       <primary>encode_typed_literal</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
         Converts a Perl variable to the value of the data type passed as a
         second argument and returns a string representation of this value.
         Correctly handles nested arrays and values of composite types.
       </para>
____________________________________________________________________________-->
       <para>
         把一个 Perl 变量转换为由第二个参数传入的数据类型的值，并且返回该值
         的字符串表达。它能正确地处理嵌套数组和组合类型的值。
       </para>
      </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term>
      <literal><function>encode_array_constructor(<replaceable>array</replaceable>)</function></literal>
      <indexterm>
       <primary>encode_array_constructor</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <literal><function>encode_array_constructor(<replaceable>array</replaceable>)</function></literal>
      <indexterm>
       <primary>encode_array_constructor</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
        Returns the contents of the referenced array as a string in array constructor format
        (see <xref linkend="sql-syntax-array-constructors"/>).
        Individual values are quoted using <function>quote_nullable</function>.
        Returns the argument value, quoted using <function>quote_nullable</function>,
        if it's not a reference to an array.
        </para>
____________________________________________________________________________-->
      <para>
        把被引用数组的内容返回为数组构造器格式（
        <xref linkend="sql-syntax-array-constructors"/>）的一个串。其中的个体值用
        <function>quote_nullable</function>引用。如果参数不是一个数组引用，则
        返回用<function>quote_nullable</function>引用的该参数值。
        </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term>
      <literal><function>looks_like_number(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>looks_like_number</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <literal><function>looks_like_number(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>looks_like_number</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
        Returns a true value if the content of the given string looks like a
        number, according to Perl, returns false otherwise.
        Returns undef if the argument is undef.  Leading and trailing space is
        ignored. <literal>Inf</literal> and <literal>Infinity</literal> are regarded as numbers.
        </para>
____________________________________________________________________________-->
      <para>
        如果给定串的内容对于 Perl 看起来像是数字则返回真，否则返回假。如果
        参数是 undef 则返回 undef。前导和结尾的空格会被忽略。
        <literal>Inf</literal>和<literal>Infinity</literal>被视作数字。
        </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term>
      <literal><function>is_array_ref(<replaceable>argument</replaceable>)</function></literal>
      <indexterm>
       <primary>is_array_ref</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
____________________________________________________________________________-->
     <term>
      <literal><function>is_array_ref(<replaceable>argument</replaceable>)</function></literal>
      <indexterm>
       <primary>is_array_ref</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
        Returns a true value if the given argument may be treated as an
        array reference, that is, if ref of the argument is <literal>ARRAY</literal> or
        <literal>PostgreSQL::InServer::ARRAY</literal>.  Returns false otherwise.
      </para>
____________________________________________________________________________-->
      <para>
        如果给定参数可以被当作一个数组引用对待则返回真值，即该参数的定义为
        <literal>ARRAY</literal>或者<literal>PostgreSQL::InServer::ARRAY</literal>时返回
        真。否则返回假。
      </para>
     </listitem>
    </varlistentry>

   </variablelist>
  </sect2>
 </sect1>

 <sect1 id="plperl-global">
<!--==========================orignal english content==========================
  <title>Global Values in PL/Perl</title>
____________________________________________________________________________-->
  <title>PL/Perl 中的全局值</title>

<!--==========================orignal english content==========================
  <para>
    You can use the global hash <varname>%_SHARED</varname> to store
    data, including code references, between function calls for the
    lifetime of the current session.
  </para>
____________________________________________________________________________-->
  <para>
    可以在函数调用之间或者当前会话的生命期中用全局哈希
    <varname>%_SHARED</varname>来存储数据，包括代码引用。
  </para>

<!--==========================orignal english content==========================
  <para>
    Here is a simple example for shared data:
<programlisting>
CREATE OR REPLACE FUNCTION set_var(name text, val text) RETURNS text AS $$
    if ($_SHARED{$_[0]} = $_[1]) {
        return 'ok';
    } else {
        return "cannot set shared variable $_[0] to $_[1]";
    }
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION get_var(name text) RETURNS text AS $$
    return $_SHARED{$_[0]};
$$ LANGUAGE plperl;

SELECT set_var('sample', 'Hello, PL/Perl!  How''s tricks?');
SELECT get_var('sample');
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
    这是共享数据的一个简单例子：
<programlisting>
CREATE OR REPLACE FUNCTION set_var(name text, val text) RETURNS text AS $$
    if ($_SHARED{$_[0]} = $_[1]) {
        return 'ok';
    } else {
        return "cannot set shared variable $_[0] to $_[1]";
    }
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION get_var(name text) RETURNS text AS $$
    return $_SHARED{$_[0]};
$$ LANGUAGE plperl;

SELECT set_var('sample', 'Hello, PL/Perl!  How''s tricks?');
SELECT get_var('sample');
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Here is a slightly more complicated example using a code reference:

<programlisting>
CREATE OR REPLACE FUNCTION myfuncs() RETURNS void AS $$
    $_SHARED{myquote} = sub {
        my $arg = shift;
        $arg =~ s/(['\\])/\\$1/g;
        return "'$arg'";
    };
$$ LANGUAGE plperl;

SELECT myfuncs(); /* initializes the function */

/* Set up a function that uses the quote function */

CREATE OR REPLACE FUNCTION use_quote(TEXT) RETURNS text AS $$
    my $text_to_quote = shift;
    my $qfunc = $_SHARED{myquote};
    return &amp;$qfunc($text_to_quote);
$$ LANGUAGE plperl;
</programlisting>

   (You could have replaced the above with the one-liner
   <literal>return $_SHARED{myquote}-&gt;($_[0]);</literal>
   at the expense of readability.)
  </para>
____________________________________________________________________________-->
  <para>
   这是一个使用代码引用的稍微复杂一点的例子：

<programlisting>
CREATE OR REPLACE FUNCTION myfuncs() RETURNS void AS $$
    $_SHARED{myquote} = sub {
        my $arg = shift;
        $arg =~ s/(['\\])/\\$1/g;
        return "'$arg'";
    };
$$ LANGUAGE plperl;

SELECT myfuncs(); /* 初始化函数 */

/* 设置一个使用引用函数的函数 */

CREATE OR REPLACE FUNCTION use_quote(TEXT) RETURNS text AS $$
    my $text_to_quote = shift;
    my $qfunc = $_SHARED{myquote};
    return &amp;$qfunc($text_to_quote);
$$ LANGUAGE plperl;
</programlisting>

   （你可以把上面的代码用一行
   <literal>return $_SHARED{myquote}-&gt;($_[0]);</literal>替换，
   代价是牺牲了可读性）。
  </para>

<!--==========================orignal english content==========================
  <para>
   For security reasons, PL/Perl executes functions called by any one SQL role
   in a separate Perl interpreter for that role.  This prevents accidental or
   malicious interference by one user with the behavior of another user's
   PL/Perl functions.  Each such interpreter has its own value of the
   <varname>%_SHARED</varname> variable and other global state.  Thus, two
   PL/Perl functions will share the same value of <varname>%_SHARED</varname>
   if and only if they are executed by the same SQL role.  In an application
   wherein a single session executes code under multiple SQL roles (via
   <literal>SECURITY DEFINER</literal> functions, use of <command>SET ROLE</command>, etc)
   you may need to take explicit steps to ensure that PL/Perl functions can
   share data via <varname>%_SHARED</varname>.  To do that, make sure that
   functions that should communicate are owned by the same user, and mark
   them <literal>SECURITY DEFINER</literal>.  You must of course take care that
   such functions can't be used to do anything unintended.
  </para>
____________________________________________________________________________-->
  <para>
   处于安全原因，PL/Perl 一个 SQL 角色独立的 Perl 解释器中执行该角色调用
   的任何一个函数。这可以避免一个用户无意或者恶意地干涉另一个用户的
   PL/Perl 函数的行为。每一个这样的解释器都具有其自身的
   <varname>%_SHARED</varname>变量值和其他全局状态。因此，只有当
   两个 PL/Perl 函数是由同一个 SQL 角色执行时，它们才能共享同一个
   <varname>%_SHARED</varname>值。在使用单个会话执行多个 SQL 角色
   的代码（通过<literal>SECURITY DEFINER</literal>函数、使用
   <command>SET ROLE</command>等）的应用中，需要采取显式的步骤以保证 PL/Perl
   函数能够通过<varname>%_SHARED</varname>共享数据。要这样做，需要
   确保要通信的函数都属于同一个用户，并且把它们标记为
   <literal>SECURITY DEFINER</literal>。当然，要小心这样的函数被滥用。
  </para>
 </sect1>

 <sect1 id="plperl-trusted">
<!--==========================orignal english content==========================
  <title>Trusted and Untrusted PL/Perl</title>
____________________________________________________________________________-->
  <title>可信的和不可信的 PL/Perl</title>

<!--==========================orignal english content==========================
  <indexterm zone="plperl-trusted">
   <primary>trusted</primary>
   <secondary>PL/Perl</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="plperl-trusted">
   <primary>trusted</primary>
   <secondary>PL/Perl</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   Normally, PL/Perl is installed as a <quote>trusted</quote> programming
   language named <literal>plperl</literal>.  In this setup, certain Perl
   operations are disabled to preserve security.  In general, the
   operations that are restricted are those that interact with the
   environment. This includes file handle operations,
   <literal>require</literal>, and <literal>use</literal> (for
   external modules).  There is no way to access internals of the
   database server process or to gain OS-level access with the
   permissions of the server process,
   as a C function can do.  Thus, any unprivileged database user can
   be permitted to use this language.
  </para>
____________________________________________________________________________-->
  <para>
   通常，PL/Perl 被作为一种<quote>可信的</quote>编程语言安装，其名称
   为<literal>plperl</literal>。在这种设置下，为了保持安全性禁用了某些
   Perl 操作。一般来说，被限制的操作是那些与环境交互的操作。它们
   包括文件处理操作、<literal>require</literal>以及
   <literal>use</literal>（外部模块）。没有办法像 C 函数那样访问
   数据库服务器进程的内部或者用服务器进程的权限得到 OS 级别的访问。
   因此，任何没有特权的数据库用户也被允许使用这种语言。
  </para>

<!--==========================orignal english content==========================
  <para>
   Here is an example of a function that will not work because file
   system operations are not allowed for security reasons:
<programlisting>
CREATE FUNCTION badfunc() RETURNS integer AS $$
    my $tmpfile = "/tmp/badfile";
    open my $fh, '&gt;', $tmpfile
        or elog(ERROR, qq{could not open the file "$tmpfile": $!});
    print $fh "Testing writing to a file\n";
    close $fh or elog(ERROR, qq{could not close the file "$tmpfile": $!});
    return 1;
$$ LANGUAGE plperl;
</programlisting>
    The creation of this function will fail as its use of a forbidden
    operation will be caught by the validator.
  </para>
____________________________________________________________________________-->
  <para>
   下面例子中的函数将无法工作，因为出于安全原因不允许它做文件操作：
<programlisting>
CREATE FUNCTION badfunc() RETURNS integer AS $$
    my $tmpfile = "/tmp/badfile";
    open my $fh, '&gt;', $tmpfile
        or elog(ERROR, qq{could not open the file "$tmpfile": $!});
    print $fh "Testing writing to a file\n";
    close $fh or elog(ERROR, qq{could not close the file "$tmpfile": $!});
    return 1;
$$ LANGUAGE plperl;
</programlisting>
    这个函数的创建会失败，因为验证器会捕捉到它使用了禁用的操作。
  </para>

<!--==========================orignal english content==========================
  <para>
   Sometimes it is desirable to write Perl functions that are not
   restricted.  For example, one might want a Perl function that sends
   mail.  To handle these cases, PL/Perl can also be installed as an
   <quote>untrusted</quote> language (usually called
   <application>PL/PerlU</application><indexterm><primary>PL/PerlU</primary></indexterm>).
   In this case the full Perl language is available.  When installing the
   language, the language name <literal>plperlu</literal> will select
   the untrusted PL/Perl variant.
  </para>
____________________________________________________________________________-->
  <para>
   有些时候需要编写不受限制的 Perl 函数。例如，我们可能想要一个能发送
   电子邮件的 Perl 函数。要处理这些情况，可以把 PL/Perl 安装成一种
   <quote>不可信的</quote>语言（通常被称作
   <application>PL/PerlU</application><indexterm><primary>PL/PerlU</primary></indexterm>）。
   在这种情况下整个 Perl 语言的特性都可以使用。在安装语言时，用语言
   名称<literal>plperlu</literal>将会选择不可信的 PL/Perl 变体。
  </para>

<!--==========================orignal english content==========================
  <para>
   The writer of a <application>PL/PerlU</application> function must take care that the function
   cannot be used to do anything unwanted, since it will be able to do
   anything that could be done by a user logged in as the database
   administrator.  Note that the database system allows only database
   superusers to create functions in untrusted languages.
  </para>
____________________________________________________________________________-->
  <para>
   <application>PL/PerlU</application>函数的编写者必须注意该函数不能被用来做
   其设计目的之外的事情，因为该函数能做一个作为数据库管理员登录的用户
   可以做的任何事情。注意数据库系统只允许数据库超级用户用不可信语言
   创建函数。
  </para>

<!--==========================orignal english content==========================
  <para>
   If the above function was created by a superuser using the language
   <literal>plperlu</literal>, execution would succeed.
  </para>
____________________________________________________________________________-->
  <para>
   如果上述函数是一个超级用户用语言<literal>plperlu</literal>创建的，则可以
   执行成功。
  </para>

<!--==========================orignal english content==========================
  <para>
   In the same way, anonymous code blocks written in Perl can use
   restricted operations if the language is specified as
   <literal>plperlu</literal> rather than <literal>plperl</literal>, but the caller
   must be a superuser.
  </para>
____________________________________________________________________________-->
  <para>
   以和<literal>plperl</literal>语言同样的方式，可以用<literal>plperlu</literal>
   编写 Perl 中的匿名代码块，这样的代码块能够使用受限的操作，不过调用
   者必须是超级用户。
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    While <application>PL/Perl</application> functions run in a separate Perl
    interpreter for each SQL role, all <application>PL/PerlU</application> functions
    executed in a given session run in a single Perl interpreter (which is
    not any of the ones used for <application>PL/Perl</application> functions).
    This allows <application>PL/PerlU</application> functions to share data freely,
    but no communication can occur between <application>PL/Perl</application> and
    <application>PL/PerlU</application> functions.
   </para>
____________________________________________________________________________-->
   <para>
    虽然对每个 SQL 角色会在一个独立的 Perl 解释器中运行
    <application>PL/Perl</application>函数，但是在一个给定会话中执行的所有
    <application>PL/PerlU</application>函数都运行在一个 Perl 解释器中（与用于
    任何<application>PL/Perl</application>函数的解释器不同）。这允许
    <application>PL/PerlU</application>函数自由地共享数据，但是
    <application>PL/Perl</application>和<application>PL/PerlU</application>函数之间不会
    发生任何交流。
   </para>
  </note>

  <note>
<!--==========================orignal english content==========================
   <para>
    Perl cannot support multiple interpreters within one process unless
    it was built with the appropriate flags, namely either
    <literal>usemultiplicity</literal> or <literal>useithreads</literal>.
    (<literal>usemultiplicity</literal> is preferred unless you actually need
    to use threads.  For more details, see the
    <citerefentry><refentrytitle>perlembed</refentrytitle></citerefentry> man page.)
    If <application>PL/Perl</application> is used with a copy of Perl that was not built
    this way, then it is only possible to have one Perl interpreter per
    session, and so any one session can only execute either
    <application>PL/PerlU</application> functions, or <application>PL/Perl</application> functions
    that are all called by the same SQL role.
   </para>
____________________________________________________________________________-->
   <para>
    Perl 不支持一个进程中的多个解释器，除非编译它时使用了合适的标志，
    即<literal>usemultiplicity</literal>或者<literal>useithreads</literal>（
    <literal>usemultiplicity</literal>会更好，除非你确实需要使用线程。更多细节，
    请见<citerefentry><refentrytitle>perlembed</refentrytitle></citerefentry>手册页）。
    如果<application>PL/Perl</application>用的是一份没有这样编译的 Perl 拷贝，那么
    在每个会话中只能有一个 Perl 解释器，并且因此任一会话只能要么执行
    <application>PL/PerlU</application>函数，要么执行同一个 SQL 角色调用的
    <application>PL/Perl</application>函数。
   </para>
  </note>

 </sect1>

 <sect1 id="plperl-triggers">
<!--==========================orignal english content==========================
  <title>PL/Perl Triggers</title>
____________________________________________________________________________-->
  <title>PL/Perl 触发器</title>

<!--==========================orignal english content==========================
  <para>
   PL/Perl can be used to write trigger functions.  In a trigger function,
   the hash reference <varname>$_TD</varname> contains information about the
   current trigger event. <varname>$_TD</varname> is a global variable,
   which gets a separate local value for each invocation of the trigger.
   The fields of the <varname>$_TD</varname> hash reference are:

   <variablelist>
    <varlistentry>
     <term><literal>$_TD-&gt;{new}{foo}</literal></term>
     <listitem>
      <para>
       <literal>NEW</literal> value of column <literal>foo</literal>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{old}{foo}</literal></term>
     <listitem>
      <para>
       <literal>OLD</literal> value of column <literal>foo</literal>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{name}</literal></term>
     <listitem>
      <para>
       Name of the trigger being called
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{event}</literal></term>
     <listitem>
      <para>
       Trigger event: <literal>INSERT</literal>, <literal>UPDATE</literal>,
       <literal>DELETE</literal>, <literal>TRUNCATE</literal>, or <literal>UNKNOWN</literal>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{when}</literal></term>
     <listitem>
      <para>
       When the trigger was called: <literal>BEFORE</literal>,
       <literal>AFTER</literal>, <literal>INSTEAD OF</literal>, or
       <literal>UNKNOWN</literal>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{level}</literal></term>
     <listitem>
      <para>
       The trigger level: <literal>ROW</literal>, <literal>STATEMENT</literal>, or <literal>UNKNOWN</literal>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{relid}</literal></term>
     <listitem>
      <para>
       OID of the table on which the trigger fired
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{table_name}</literal></term>
     <listitem>
      <para>
       Name of the table on which the trigger fired
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{relname}</literal></term>
     <listitem>
      <para>
       Name of the table on which the trigger fired. This has been deprecated,
       and could be removed in a future release.
       Please use $_TD-&gt;{table_name} instead.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{table_schema}</literal></term>
     <listitem>
      <para>
       Name of the schema in which the table on which the trigger fired, is
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{argc}</literal></term>
     <listitem>
      <para>
       Number of arguments of the trigger function
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>@{$_TD-&gt;{args}}</literal></term>
     <listitem>
      <para>
       Arguments of the trigger function.  Does not exist if <literal>$_TD-&gt;{argc}</literal> is 0.
      </para>
     </listitem>
    </varlistentry>

   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   PL/Perl 可以被用来编写触发器函数。在触发器函数中，哈希引用
   <varname>$_TD</varname>包含有关当前触发器事件的信息。
   <varname>$_TD</varname>是一个全局变量，对触发器的每一次调用它都会
   得到一个独立的本地值。<varname>$_TD</varname>哈希引用的域有：

   <variablelist>
    <varlistentry>
     <term><literal>$_TD-&gt;{new}{foo}</literal></term>
     <listitem>
      <para>
       列<literal>foo</literal>的<literal>NEW</literal>值
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{old}{foo}</literal></term>
     <listitem>
      <para>
       列<literal>foo</literal>的<literal>OLD</literal>值
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{name}</literal></term>
     <listitem>
      <para>
       要被调用的触发器的名称
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{event}</literal></term>
     <listitem>
      <para>
       触发器事件：<literal>INSERT</literal>、<literal>UPDATE</literal>、
       <literal>DELETE</literal>、<literal>TRUNCATE</literal>或者<literal>UNKNOWN</literal>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{when}</literal></term>
     <listitem>
      <para>
       什么时候调用触发器：<literal>BEFORE</literal>、
       <literal>AFTER</literal>、<literal>INSTEAD OF</literal>或者
       <literal>UNKNOWN</literal>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{level}</literal></term>
     <listitem>
      <para>
       触发器级别：<literal>ROW</literal>、<literal>STATEMENT</literal>或者<literal>UNKNOWN</literal>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{relid}</literal></term>
     <listitem>
      <para>
       触发器定义在其上的表的 OID
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{table_name}</literal></term>
     <listitem>
      <para>
       触发器定义在其上的表的名称
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{relname}</literal></term>
     <listitem>
      <para>
       触发器定义在其上的表的名称。这已经被废弃，并且可能会在
       未来的发布中被移除。请使用
       $_TD-&gt;{table_name}。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{table_schema}</literal></term>
     <listitem>
      <para>
       触发器定义在其上的表所在的模式的名称
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{argc}</literal></term>
     <listitem>
      <para>
       触发器函数的参数数目
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>@{$_TD-&gt;{args}}</literal></term>
     <listitem>
      <para>
       触发器函数的参数。如果<literal>$_TD-&gt;{argc}</literal>为 0 则不存在
      </para>
     </listitem>
    </varlistentry>

   </variablelist>
  </para>

<!--==========================orignal english content==========================
  <para>
   Row-level triggers can return one of the following:

   <variablelist>
    <varlistentry>
     <term><literal>return;</literal></term>
     <listitem>
      <para>
       Execute the operation
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>"SKIP"</literal></term>
     <listitem>
      <para>
       Don't execute the operation
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>"MODIFY"</literal></term>
     <listitem>
      <para>
       Indicates that the <literal>NEW</literal> row was modified by
       the trigger function
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   行级触发器可以返回下列之一：

   <variablelist>
    <varlistentry>
     <term><literal>return;</literal></term>
     <listitem>
      <para>
       执行操作
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>"SKIP"</literal></term>
     <listitem>
      <para>
       不执行操作
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>"MODIFY"</literal></term>
     <listitem>
      <para>
       指示触发器函数修改了<literal>NEW</literal>行
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

<!--==========================orignal english content==========================
  <para>
   Here is an example of a trigger function, illustrating some of the
   above:
<programlisting>
CREATE TABLE test (
    i int,
    v varchar
);

CREATE OR REPLACE FUNCTION valid_id() RETURNS trigger AS $$
    if (($_TD-&gt;{new}{i} &gt;= 100) || ($_TD-&gt;{new}{i} &lt;= 0)) {
        return "SKIP";    # skip INSERT/UPDATE command
    } elsif ($_TD-&gt;{new}{v} ne "immortal") {
        $_TD-&gt;{new}{v} .= "(modified by trigger)";
        return "MODIFY";  # modify row and execute INSERT/UPDATE command
    } else {
        return;           # execute INSERT/UPDATE command
    }
$$ LANGUAGE plperl;

CREATE TRIGGER test_valid_id_trig
    BEFORE INSERT OR UPDATE ON test
    FOR EACH ROW EXECUTE FUNCTION valid_id();
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   这里是一个触发器函数的例子，展示上文所说的一些东西：
<programlisting>
CREATE TABLE test (
    i int,
    v varchar
);

CREATE OR REPLACE FUNCTION valid_id() RETURNS trigger AS $$
    if (($_TD-&gt;{new}{i} &gt;= 100) || ($_TD-&gt;{new}{i} &lt;= 0)) {
        return "SKIP";    # skip INSERT/UPDATE command
    } elsif ($_TD-&gt;{new}{v} ne "immortal") {
        $_TD-&gt;{new}{v} .= "(modified by trigger)";
        return "MODIFY";  # 修改行并且执行 INSERT/UPDATE 命令
    } else {
        return;           # 执行 INSERT/UPDATE 命令
    }
$$ LANGUAGE plperl;

CREATE TRIGGER test_valid_id_trig
    BEFORE INSERT OR UPDATE ON test
    FOR EACH ROW EXECUTE FUNCTION valid_id();
</programlisting>
  </para>
 </sect1>

 <sect1 id="plperl-event-triggers">
<!--==========================orignal english content==========================
  <title>PL/Perl Event Triggers</title>
____________________________________________________________________________-->
  <title>PL/Perl 事件触发器</title>

<!--==========================orignal english content==========================
  <para>
   PL/Perl can be used to write event trigger functions.  In an event trigger
   function, the hash reference <varname>$_TD</varname> contains information
   about the current trigger event.  <varname>$_TD</varname> is a global variable,
   which gets a separate local value for each invocation of the trigger.  The
   fields of the <varname>$_TD</varname> hash reference are:

   <variablelist>
    <varlistentry>
     <term><literal>$_TD-&gt;{event}</literal></term>
     <listitem>
      <para>
       The name of the event the trigger is fired for.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{tag}</literal></term>
     <listitem>
      <para>
       The command tag for which the trigger is fired.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   PL/Perl 可以被用来编写事件触发器函数。在事件触发器函数中，哈希引用
   <varname>$_TD</varname>包含有关当前触发器事件的信息。
   <varname>$_TD</varname>是一个全局变量，对触发器的每一次调用它都会
   得到一个独立的本地值。<varname>$_TD</varname>哈希引用的域有：

   <variablelist>
    <varlistentry>
     <term><literal>$_TD-&gt;{event}</literal></term>
     <listitem>
      <para>
       触发器为其触发的事件名称。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{tag}</literal></term>
     <listitem>
      <para>
       触发器为其触发的命令标签。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

<!--==========================orignal english content==========================
  <para>
   The return value of the trigger function is ignored.
  </para>
____________________________________________________________________________-->
  <para>
   触发器函数的返回值会被忽略。
  </para>

<!--==========================orignal english content==========================
  <para>
   Here is an example of an event trigger function, illustrating some of the
   above:
<programlisting>
CREATE OR REPLACE FUNCTION perlsnitch() RETURNS event_trigger AS $$
  elog(NOTICE, "perlsnitch: " . $_TD->{event} . " " . $_TD->{tag} . " ");
$$ LANGUAGE plperl;

CREATE EVENT TRIGGER perl_a_snitch
    ON ddl_command_start
    EXECUTE FUNCTION perlsnitch();
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   这里是一个事件触发器函数的例子，展示了上文所说的一些东西：
<programlisting>
CREATE OR REPLACE FUNCTION perlsnitch() RETURNS event_trigger AS $$
  elog(NOTICE, "perlsnitch: " . $_TD->{event} . " " . $_TD->{tag} . " ");
$$ LANGUAGE plperl;

CREATE EVENT TRIGGER perl_a_snitch
    ON ddl_command_start
    EXECUTE FUNCTION perlsnitch();
</programlisting>
  </para>
 </sect1>

 <sect1 id="plperl-under-the-hood">
<!--==========================orignal english content==========================
  <title>PL/Perl Under the Hood</title>
____________________________________________________________________________-->
  <title>PL/Perl 下面的东西</title>

 <sect2 id="plperl-config">
<!--==========================orignal english content==========================
  <title>Configuration</title>
____________________________________________________________________________-->
  <title>配置</title>

<!--==========================orignal english content==========================
  <para>
  This section lists configuration parameters that affect <application>PL/Perl</application>.
  </para>
____________________________________________________________________________-->
  <para>
  这一节列出了影响<application>PL/Perl</application>的配置参数。
  </para>

  <variablelist>

     <varlistentry id="guc-plperl-on-init" xreflabel="plperl.on_init">
<!--==========================orignal english content==========================
      <term>
       <varname>plperl.on_init</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>plperl.on_init</varname> configuration parameter</primary>
      </indexterm>
      </term>
____________________________________________________________________________-->
      <term>
       <varname>plperl.on_init</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>plperl.on_init</varname> 配置参数</primary>
      </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies Perl code to be executed when a Perl interpreter is first
        initialized, before it is specialized for use by <literal>plperl</literal> or
        <literal>plperlu</literal>.
        The SPI functions are not available when this code is executed.
        If the code fails with an error it will abort the initialization of
        the interpreter and propagate out to the calling query, causing the
        current transaction or subtransaction to be aborted.
       </para>
____________________________________________________________________________-->
       <para>
        指定当第一次初始化一个 Perl 解释器时要执行的 Perl 代码，这会在
        具体用于<literal>plperl</literal>或<literal>plperlu</literal>之前做完。当
        这段代码被执行时 SPI 函数不可用。如果该代码由于错误失败，它
        将中止解释器的初始化并且把错误传播到调用查询，最终导致当前
        事务或者子事务被中止。
       </para>
<!--==========================orignal english content==========================
       <para>
       The Perl code is limited to a single string. Longer code can be placed
       into a module and loaded by the <literal>on_init</literal> string.
       Examples:
<programlisting>
plperl.on_init = 'require "plperlinit.pl"'
plperl.on_init = 'use lib "/my/app"; use MyApp::PgInit;'
</programlisting>
       </para>
____________________________________________________________________________-->
       <para>
       该 Perl 代码被限制为一个单一的字符串。更长的代码可以放在一个
       模块中，然后由<literal>on_init</literal>字符串载入。例子：
<programlisting>
plperl.on_init = 'require "plperlinit.pl"'
plperl.on_init = 'use lib "/my/app"; use MyApp::PgInit;'
</programlisting>
       </para>
<!--==========================orignal english content==========================
       <para>
       Any modules loaded by <literal>plperl.on_init</literal>, either directly or
       indirectly, will be available for use by <literal>plperl</literal>.  This may
       create a security risk. To see what modules have been loaded you can use:
<programlisting>
DO 'elog(WARNING, join ", ", sort keys %INC)' LANGUAGE plperl;
</programlisting>
       </para>
____________________________________________________________________________-->
       <para>
       任何被<literal>plperl.on_init</literal>载入的模块（不管是直接还是间接）都
       可以被<literal>plperl</literal>使用。这可能会导致安全性风险。要看哪些模块
       已经被载入，可以使用：
<programlisting>
DO 'elog(WARNING, join ", ", sort keys %INC)' LANGUAGE plperl;
</programlisting>
       </para>
<!--==========================orignal english content==========================
       <para>
        Initialization will happen in the postmaster if the <literal>plperl</literal> library is
        included in <xref linkend="guc-shared-preload-libraries"/>, in which
        case extra consideration should be given to the risk of destabilizing
        the postmaster.  The principal reason for making use of this feature
        is that Perl modules loaded by <literal>plperl.on_init</literal> need be
        loaded only at postmaster start, and will be instantly available
        without loading overhead in individual database sessions.  However,
        keep in mind that the overhead is avoided only for the first Perl
        interpreter used by a database session &mdash; either PL/PerlU, or
        PL/Perl for the first SQL role that calls a PL/Perl function.  Any
        additional Perl interpreters created in a database session will have
        to execute <literal>plperl.on_init</literal> afresh.  Also, on Windows there
        will be no savings whatsoever from preloading, since the Perl
        interpreter created in the postmaster process does not propagate to
        child processes.
       </para>
____________________________________________________________________________-->
       <para>
        如果 plperl 库被包括在<xref linkend="guc-shared-preload-libraries"/>
        中，那么初始化将发生在 postmaster 中，在这种情况下要特别地考虑对
        postmaster 带来的不稳定风险。使用这种特性的主要原因是，
        <literal>plperl.on_init</literal>载入的 Perl 模块只需要在 postmaster 开始时
        被载入，并且在数据库会话中不需要任何工作就立刻可用。不过，要记住这
        只免除了一个数据库会话中使用的第一个 Perl 解释器的负载 &mdash; 不管
        是 PL/PerlU 还是用于第一个 SQL 角色调用 PL/Perl 函数的 PL/Perl。在一个
        数据库会话中创建的任何额外的 Perl 解释器将不得不重新执行
        <literal>plperl.on_init</literal>。还有，在 Windows 上无论从什么里面进行
        预先载入，都不会有这种节约，因为在 postmaster 进程中创建的 Perl 解释器
        不会传播到子进程中。
       </para>
<!--==========================orignal english content==========================
       <para>
       This parameter can only be set in the <filename>postgresql.conf</filename> file or on the server command line.
       </para>
____________________________________________________________________________-->
       <para>
       这个参数只能在<filename>postgresql.conf</filename>文件或者服务器命令中设置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-plperl-on-plperl-init" xreflabel="plperl.on_plperl_init">
<!--==========================orignal english content==========================
      <term>
       <varname>plperl.on_plperl_init</varname> (<type>string</type>)
       <indexterm>
        <primary><varname>plperl.on_plperl_init</varname> configuration parameter</primary>
       </indexterm>
      </term>
____________________________________________________________________________-->
      <term>
       <varname>plperl.on_plperl_init</varname> (<type>string</type>)
       <indexterm>
        <primary><varname>plperl.on_plperl_init</varname> 配置参数</primary>
       </indexterm>
      </term>
<!--==========================orignal english content==========================
      <term>
       <varname>plperl.on_plperlu_init</varname> (<type>string</type>)
       <indexterm>
        <primary><varname>plperl.on_plperlu_init</varname> configuration parameter</primary>
       </indexterm>
      </term>
____________________________________________________________________________-->
      <term>
       <varname>plperl.on_plperlu_init</varname> (<type>string</type>)
       <indexterm>
        <primary><varname>plperl.on_plperlu_init</varname> 配置参数</primary>
       </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        These parameters specify Perl code to be executed when a Perl
        interpreter is specialized for <literal>plperl</literal> or
        <literal>plperlu</literal> respectively.  This will happen when a PL/Perl or
        PL/PerlU function is first executed in a database session, or when
        an additional interpreter has to be created because the other language
        is called or a PL/Perl function is called by a new SQL role.  This
        follows any initialization done by <literal>plperl.on_init</literal>.
        The SPI functions are not available when this code is executed.
        The Perl code in <literal>plperl.on_plperl_init</literal> is executed after
        <quote>locking down</quote> the interpreter, and thus it can only perform
        trusted operations.
       </para>
____________________________________________________________________________-->
       <para>
        这些参数分别指定当为<literal>plperl</literal>或<literal>plperlu</literal>专门准备好
        一个 Perl 解释器时要执行的 Perl 代码。当一个 PL/Perl 或者 PL/PerlU 函数
        第一次在一个数据库会话中被执行时会发生这种动作，或者由于调用其他语言
        或者新的 SQL 角色调用 PL/Perl 函数导致创建额外的解释器时也会发生这种
        动作。这些初始化跟随着<literal>plperl.on_init</literal>所作的初始化。当这段
        代码被执行时，SPI 函数不可用。<literal>plperl.on_plperl_init</literal>中的 Perl
        代码在<quote>锁闭</quote>解释器之后被执行，因此它只能执行可信的操作。
       </para>
<!--==========================orignal english content==========================
       <para>
        If the code fails with an error it will abort the initialization and
        propagate out to the calling query, causing the current transaction or
        subtransaction to be aborted.  Any actions already done within Perl
        won't be undone; however, that interpreter won't be used again.
        If the language is used again the initialization will be attempted
        again within a fresh Perl interpreter.
       </para>
____________________________________________________________________________-->
       <para>
        如果该代码由于错误失败，它将中止初始化并且把错误传播到调用查询，
        最终导致当前事务或者子事务被中止。在 Perl 中已经完成的任何动作都
        不会被撤销。不过，该解释器将不能被再次使用。如果再次使用该语言，
        将在一个新鲜的 Perl 解释器中再次尝试初始化。
       </para>
<!--==========================orignal english content==========================
       <para>
        Only superusers can change these settings.  Although these settings
        can be changed within a session, such changes will not affect Perl
        interpreters that have already been used to execute functions.
       </para>
____________________________________________________________________________-->
       <para>
        只有超级用户能够更改这些设置。尽管这些设置可以在会话中被修改，
        但是这类更改将不会影响已经被用来执行函数的 Perl 解释器。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-plperl-use-strict" xreflabel="plperl.use_strict">
<!--==========================orignal english content==========================
      <term>
       <varname>plperl.use_strict</varname> (<type>boolean</type>)
       <indexterm>
        <primary><varname>plperl.use_strict</varname> configuration parameter</primary>
       </indexterm>
      </term>
____________________________________________________________________________-->
      <term>
       <varname>plperl.use_strict</varname> (<type>boolean</type>)
       <indexterm>
        <primary><varname>plperl.use_strict</varname> 配置参数</primary>
       </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        When set true subsequent compilations of PL/Perl functions will have
        the <literal>strict</literal> pragma enabled.  This parameter does not affect
        functions already compiled in the current session.
       </para>
____________________________________________________________________________-->
       <para>
        如果被设置为真，则后续的 PL/Perl 函数编译将会启用
        <literal>strict</literal>编译指示。这个参数不影响当前会话中已编译的函数。
       </para>
      </listitem>
     </varlistentry>

  </variablelist>
</sect2>

 <sect2 id="plperl-missing">
<!--==========================orignal english content==========================
  <title>Limitations and Missing Features</title>
____________________________________________________________________________-->
  <title>限制和缺失的特性</title>

<!--==========================orignal english content==========================
  <para>
   The following features are currently missing from PL/Perl, but they
   would make welcome contributions.

   <itemizedlist>
    <listitem>
     <para>
      PL/Perl functions cannot call each other directly.
     </para>
    </listitem>

    <listitem>
     <para>
      SPI is not yet fully implemented.
     </para>
    </listitem>

    <listitem>
     <para>
      If you are fetching very large data sets using
      <literal>spi_exec_query</literal>, you should be aware that
      these will all go into memory.  You can avoid this by using
      <literal>spi_query</literal>/<literal>spi_fetchrow</literal> as
      illustrated earlier.
     </para>
     <para>
        A similar problem occurs if a set-returning function passes a
        large set of rows back to PostgreSQL via <literal>return</literal>. You
        can avoid this problem too by instead using
        <literal>return_next</literal> for each row returned, as shown
        previously.
     </para>
    </listitem>

     <listitem>
      <para>
        When a session ends normally, not due to a fatal error, any
        <literal>END</literal> blocks that have been defined are executed.
        Currently no other actions are performed. Specifically,
        file handles are not automatically flushed and objects are
        not automatically destroyed.
      </para>
     </listitem>
   </itemizedlist>
  </para>
____________________________________________________________________________-->
  <para>
   PL/Perl 中目前缺少下列特性，但是欢迎大家对此作出贡献。

   <itemizedlist>
    <listitem>
     <para>
      PL/Perl 函数不能直接调用彼此。
     </para>
    </listitem>

    <listitem>
     <para>
      SPI 还没有被完全实现。
     </para>
    </listitem>

    <listitem>
     <para>
      如果正在使用<literal>spi_exec_query</literal>取一个非常大的数据集，
      你应该注意它们都会进入到内存中。可以按先前所述，通过使用
      <literal>spi_query</literal>/<literal>spi_fetchrow</literal>来避免发生
      这类情况。
     </para>
     <para>
        如果一个集合返回函数通过<literal>return</literal>把一个大型的行集合
        返回给 PostgreSQL，同样会发生这种情况。同样如前所述，可以为每一个
        要返回的行使用<literal>return_next</literal>来避免这种问题。
     </para>
    </listitem>

     <listitem>
      <para>
        当会话正常结束（而不是由于致命错误结束）时，任何已经定义的
        <literal>END</literal>块将被执行。当前不会执行其他动作。特别地，
        此时文件句柄不会被自动刷写并且对象不会被自动销毁。
      </para>
     </listitem>
   </itemizedlist>
  </para>
 </sect2>

 </sect1>

</chapter>
