<!-- doc/src/sgml/dblink.sgml -->

<sect1 id="dblink" xreflabel="dblink">
 <title>dblink</title>

 <indexterm zone="dblink">
  <primary>dblink</primary>
 </indexterm>

 <para>
  <filename>dblink</>是一个支持在一个数据库会话中连接到其他<productname>PostgreSQL</>数据库的模块。
 </para>

 <para>
  还可以看看<xref linkend="postgres-fdw">，它以一种更现代和更加兼容标准的架构提供了相同的功能。
 </para>

 <refentry id="CONTRIB-DBLINK-CONNECT">
  <indexterm>
    <primary>dblink_connect</primary>
  </indexterm>

  <refmeta>
   <refentrytitle>dblink_connect</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_connect</refname>
   <refpurpose>打开一个到远程数据库的持久连接</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<synopsis>
dblink_connect(text connstr) 返回 text
dblink_connect(text connname, text connstr) 返回 text
</synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>描述</title>

   <para>
    <function>dblink_connect()</>建立一个到远程<productname>PostgreSQL</>数据库的连接。要联系的服务器和数据库通过一个标准的<application>libpq</>连接串来标识。可以选择将一个名字赋予给该连接。多个命名的连接可以被一次打开，但是一次只允许一个未命名连接。连接将会持续直到被关闭或者数据库会话结束。
   </para>

   <para>
    连接串也可以是一个现存外部服务器的名字。在使用外部服务器时，我们推荐使用外部数据包装器<literal>dblink_fdw</literal>。见下面的例子，以及<xref linkend="sql-createserver">和<xref linkend="sql-createusermapping">。
   </para>

  </refsect1>

  <refsect1>
   <title>参数</title>

   <variablelist>
    <varlistentry>
     <term><parameter>connname</parameter></term>
     <listitem>
      <para>
       要用于这个连接的名字。如果被忽略，将打开一个未命名连接并且替换掉任何现有的未命名连接。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>connstr</parameter></term>
     <listitem>
      <para><application>libpq</>-风格的连接信息串，例如
       <literal>hostaddr=127.0.0.1 port=5432 dbname=mydb user=postgres
       password=mypasswd</>。详见<xref linkend="libpq-connstring">。此外，还可以是一个外部服务器的名字。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>返回值</title>

   <para>
    返回状态，它总是<literal>OK</>（因为任何错误会导致该函数抛出一个错误而不是返回）。
   </para>
  </refsect1>

  <refsect1>
   <title>注解</title>

   <para>
    只有超级用户能够使用<function>dblink_connect</>来创建无口令认证连接。如果非超级用户需要这种能力，使用<function>dblink_connect_u</>。
   </para>

   <para>
    选择包含等号的连接名是不明智的，因为这会产生与在其他<filename>dblink</>函数中的连接信息串混淆的风险。
   </para>
  </refsect1>

  <refsect1>
   <title>例子</title>

<screen>
SELECT dblink_connect('dbname=postgres');
 dblink_connect
----------------
 OK
(1 row)

SELECT dblink_connect('myconn', 'dbname=postgres');
 dblink_connect
----------------
 OK
(1 row)

-- FOREIGN DATA WRAPPER functionality
-- Note: local connection must require password authentication for this to work properly
--       Otherwise, you will receive the following error from dblink_connect():
--       ----------------------------------------------------------------------
--       ERROR:  password is required
--       DETAIL:  Non-superuser cannot connect if the server does not request a password.
--       HINT:  Target server's authentication method must be changed.

CREATE SERVER fdtest FOREIGN DATA WRAPPER dblink_fdw OPTIONS (hostaddr '127.0.0.1', dbname 'contrib_regression');

CREATE USER dblink_regression_test WITH PASSWORD 'secret';
CREATE USER MAPPING FOR dblink_regression_test SERVER fdtest OPTIONS (user 'dblink_regression_test', password 'secret');
GRANT USAGE ON FOREIGN SERVER fdtest TO dblink_regression_test;
GRANT SELECT ON TABLE foo TO dblink_regression_test;

\set ORIGINAL_USER :USER
\c - dblink_regression_test
SELECT dblink_connect('myconn', 'fdtest');
 dblink_connect
----------------
 OK
(1 row)

SELECT * FROM dblink('myconn','SELECT * FROM foo') AS t(a int, b text, c text[]);
 a  | b |       c
----+---+---------------
  0 | a | {a0,b0,c0}
  1 | b | {a1,b1,c1}
  2 | c | {a2,b2,c2}
  3 | d | {a3,b3,c3}
  4 | e | {a4,b4,c4}
  5 | f | {a5,b5,c5}
  6 | g | {a6,b6,c6}
  7 | h | {a7,b7,c7}
  8 | i | {a8,b8,c8}
  9 | j | {a9,b9,c9}
 10 | k | {a10,b10,c10}
(11 rows)

\c - :ORIGINAL_USER
REVOKE USAGE ON FOREIGN SERVER fdtest FROM dblink_regression_test;
REVOKE SELECT ON TABLE foo FROM dblink_regression_test;
DROP USER MAPPING FOR dblink_regression_test SERVER fdtest;
DROP USER dblink_regression_test;
DROP SERVER fdtest;
</screen>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-CONNECT-U">
  <indexterm>
    <primary>dblink_connect_u</primary>
  </indexterm>

  <refmeta>
   <refentrytitle>dblink_connect_u</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_connect_u</refname>
   <refpurpose>不安全地打开一个到远程数据库的持久连接</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<synopsis>
dblink_connect_u(text connstr) 返回 text
dblink_connect_u(text connname, text connstr) 返回 text
</synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>描述</title>

   <para>
    <function>dblink_connect_u()</>和<function>dblink_connect()</>一样，不过它将允许非超级用户使用任意认证方式来连接。
   </para>

   <para>
    如果远程服务器选择了一种不涉及口令的认证方式，那么可能发生模仿以及后续的扩大权限，因为该会话看起来像由运行<productname>PostgreSQL</>的用户发起的。此外，即使远程服务器不要求一个口令，也可能从服务器环境提供该口令，例如一个属于服务器用户的<filename>~/.pgpass</>文件。这带来的不只是模仿的风险，而且还有将口令暴露给不可信的远程服务器的风险。因此，<function>dblink_connect_u()</>最初是用所有从<literal>PUBLIC</>撤销的特权安装的，这让它只能被超级用户调用。在某些情况中，为<function>dblink_connect_u()</>授予<literal>EXECUTE</>权限给可信的指定用户是合适的，但是必须小心。我们也推荐任何属于服务器用户的<filename>~/.pgpass</>文件<emphasis>不能</>包含任何指定了一个通配符主机名的记录。
   </para>

   <para>
    详见<function>dblink_connect()</>。
   </para>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-DISCONNECT">
  <indexterm>
    <primary>dblink_disconnect</primary>
  </indexterm>

  <refmeta>
   <refentrytitle>dblink_disconnect</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_disconnect</refname>
   <refpurpose>关闭一个到远程数据库的持久连接</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<synopsis>
dblink_disconnect() 返回 text
dblink_disconnect(text connname) 返回 text
</synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>描述</title>

   <para>
    <function>dblink_disconnect()</>关闭一个之前被<function>dblink_connect()</>打开的连接。不带参数的形式关闭一个未命名连接。
   </para>
  </refsect1>

  <refsect1>
   <title>参数</title>

   <variablelist>
    <varlistentry>
     <term><parameter>connname</parameter></term>
     <listitem>
      <para>
       要被关闭的命名连接的名字。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>返回值</title>

   <para>
    它总是<literal>OK</>（因为任何错误会导致该函数抛出一个错误而不是返回）。
   </para>
  </refsect1>

  <refsect1>
   <title>例子</title>

<screen>
SELECT dblink_disconnect();
 dblink_disconnect
-------------------
 OK
(1 row)

SELECT dblink_disconnect('myconn');
 dblink_disconnect
-------------------
 OK
(1 row)
</screen>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-FUNCTION">
  <indexterm>
    <primary>dblink</primary>
  </indexterm>

  <refmeta>
   <refentrytitle>dblink</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink</refname>
   <refpurpose>在一个远程数据库中执行一个查询</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<synopsis>
dblink(text connname, text sql [, bool fail_on_error]) 返回记录集
dblink(text connstr, text sql [, bool fail_on_error]) 返回记录集
dblink(text sql [, bool fail_on_error]) 返回记录集
</synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>描述</title>

   <para>
    <function>dblink</>在一个远程数据库中执行一个查询（通常是一个<command>SELECT</>，但是也可以是任意返回行的 SQL 语句）。
   </para>

   <para>
    当给定两个<type>text</>参数时，第一个被首先作为一个持久连接的名称进行查找；如果找到，该命令会在该连接上被执行。如果没有找到，第一个参数被视作一个用于<function>dblink_connect</>的连接信息字符串，并且被指出的连接只是在这个命令的持续期间被建立。
   </para>
  </refsect1>

  <refsect1>
   <title>参数</title>

   <variablelist>
    <varlistentry>
     <term><parameter>connname</parameter></term>
     <listitem>
      <para>
       要使用的连接名。忽略这个参数将使用未命名连接。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>connstr</parameter></term>
     <listitem>
      <para>
       如之前为<function>dblink_connect</>所描述的一个连接信息字符串。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>sql</parameter></term>
     <listitem>
      <para>
       你希望在远程数据库中执行的 SQL 查询，例如<literal>select * from foo</>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>fail_on_error</parameter></term>
     <listitem>
      <para>
       如果为真（忽略时的默认值），那么在连接的远端抛出的一个错误也会导致本地抛出一个错误。如果为假，远程错误只在本地被报告为一个 NOTICE，并且该函数不反回行。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>返回值</title>

   <para>
    该函数返回查询产生的行。因为<function>dblink</>能与任何查询一起使用，它被声明为返回<type>record</>，而不是指定任意特定的列集合。这意味着你必须指定在调用的查询中所期待的列集合 &mdash; 否则<productname>PostgreSQL</>将不知道会得到什么。这里是一个例子：

<programlisting>
SELECT *
    FROM dblink('dbname=mydb', 'select proname, prosrc from pg_proc')
      AS t1(proname name, prosrc text)
    WHERE proname LIKE 'bytea%';
</programlisting>

    <literal>FROM</>子句的<quote>alias</>部分必须指定函数将返回的列名及类型（在一个别名中指定列名实际上是标准 SQL 语法，但是指定列类型是一种<productname>PostgreSQL</>扩展）。这允许系统在尝试执行该函数之前就理解<literal>*</>将展开成什么，以及<literal>WHERE</>子句中的<structname>proname</>指的什么。在运行时，如果来自远程数据库的实际查询结果和<literal>FROM</>子句中显示的列数不同，将会抛出一个错误。不过，列名不需要匹配，并且<function>dblink</>并不坚持精确地匹配类型。只要被返回的数据字符串是<literal>FROM</>子句中声明的列类型的合法输入，它就将会成功。
   </para>
  </refsect1>

  <refsect1>
   <title>注解</title>

   <para>
    一种将预定义查询用于<function>dblink</>的方便方法是创建一个视图。这允许列类型信息被埋藏在该视图中，而不是在每一个查询中都拼写出来。例如：

<programlisting>
CREATE VIEW myremote_pg_proc AS
  SELECT *
    FROM dblink('dbname=postgres', 'select proname, prosrc from pg_proc')
    AS t1(proname name, prosrc text);

SELECT * FROM myremote_pg_proc WHERE proname LIKE 'bytea%';
</programlisting></para>
  </refsect1>

  <refsect1>
   <title>例子</title>

<screen>
SELECT * FROM dblink('dbname=postgres', 'select proname, prosrc from pg_proc')
  AS t1(proname name, prosrc text) WHERE proname LIKE 'bytea%';
  proname   |   prosrc
------------+------------
 byteacat   | byteacat
 byteaeq    | byteaeq
 bytealt    | bytealt
 byteale    | byteale
 byteagt    | byteagt
 byteage    | byteage
 byteane    | byteane
 byteacmp   | byteacmp
 bytealike  | bytealike
 byteanlike | byteanlike
 byteain    | byteain
 byteaout   | byteaout
(12 rows)

SELECT dblink_connect('dbname=postgres');
 dblink_connect
----------------
 OK
(1 row)

SELECT * FROM dblink('select proname, prosrc from pg_proc')
  AS t1(proname name, prosrc text) WHERE proname LIKE 'bytea%';
  proname   |   prosrc
------------+------------
 byteacat   | byteacat
 byteaeq    | byteaeq
 bytealt    | bytealt
 byteale    | byteale
 byteagt    | byteagt
 byteage    | byteage
 byteane    | byteane
 byteacmp   | byteacmp
 bytealike  | bytealike
 byteanlike | byteanlike
 byteain    | byteain
 byteaout   | byteaout
(12 rows)

SELECT dblink_connect('myconn', 'dbname=regression');
 dblink_connect
----------------
 OK
(1 row)

SELECT * FROM dblink('myconn', 'select proname, prosrc from pg_proc')
  AS t1(proname name, prosrc text) WHERE proname LIKE 'bytea%';
  proname   |   prosrc
------------+------------
 bytearecv  | bytearecv
 byteasend  | byteasend
 byteale    | byteale
 byteagt    | byteagt
 byteage    | byteage
 byteane    | byteane
 byteacmp   | byteacmp
 bytealike  | bytealike
 byteanlike | byteanlike
 byteacat   | byteacat
 byteaeq    | byteaeq
 bytealt    | bytealt
 byteain    | byteain
 byteaout   | byteaout
(14 rows)
</screen>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-EXEC">
  <indexterm>
    <primary>dblink_exec</primary>
  </indexterm>

  <refmeta>
   <refentrytitle>dblink_exec</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_exec</refname>
   <refpurpose>在一个远程数据库中执行一个命令</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<synopsis>
dblink_exec(text connname, text sql [, bool fail_on_error]) returns text
dblink_exec(text connstr, text sql [, bool fail_on_error]) returns text
dblink_exec(text sql [, bool fail_on_error]) returns text
</synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>描述</title>

   <para>
    <function>dblink_exec</>在一个远程数据库中执行一个命令（也就是，任何不返回行的 SQL 语句）。
   </para>

   <para>
    当给定两个<type>text</>参数时，第一个被首先作为一个持久连接的名称进行查找；如果找到，该命令会在该连接上被执行。如果没有找到，第一个参数被视作一个用于<function>dblink_connect</>的连接信息字符串，并且被指出的连接只是在这个命令的持续期间被建立。
   </para>
  </refsect1>

  <refsect1>
   <title>参数</title>

   <variablelist>
    <varlistentry>
     <term><parameter>connname</parameter></term>
     <listitem>
      <para>
       要使用的连接名。忽略这个参数将使用未命名连接。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>connstr</parameter></term>
     <listitem>
      <para>
       如之前为<function>dblink_connect</>所描述的一个连接信息字符串。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>sql</parameter></term>
     <listitem>
      <para>
       你希望在远程数据库中执行的 SQL 命令，例如<literal>insert into foo values(0,'a','{"a0","b0","c0"}')</>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>fail_on_error</parameter></term>
     <listitem>
      <para>
       如果为真（忽略时的默认值），那么在连接的远端抛出的一个错误也会导致本地抛出一个错误。如果为假，远程错误只在本地被报告为一个 NOTICE，并且该函数的返回值被设置为<literal>ERROR</>。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>返回值</title>

   <para>
    返回状态，可能是命令的状态字符串或<literal>ERROR</>。
   </para>
  </refsect1>

  <refsect1>
   <title>例子</title>

<screen>
SELECT dblink_connect('dbname=dblink_test_standby');
 dblink_connect
----------------
 OK
(1 row)

SELECT dblink_exec('insert into foo values(21,''z'',''{"a0","b0","c0"}'');');
   dblink_exec
-----------------
 INSERT 943366 1
(1 row)

SELECT dblink_connect('myconn', 'dbname=regression');
 dblink_connect
----------------
 OK
(1 row)

SELECT dblink_exec('myconn', 'insert into foo values(21,''z'',''{"a0","b0","c0"}'');');
   dblink_exec
------------------
 INSERT 6432584 1
(1 row)

SELECT dblink_exec('myconn', 'insert into pg_class values (''foo'')',false);
NOTICE:  sql error
DETAIL:  ERROR:  null value in column "relnamespace" violates not-null constraint

 dblink_exec
-------------
 ERROR
(1 row)
</screen>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-OPEN">
  <indexterm>
    <primary>dblink_open</primary>
  </indexterm>

  <refmeta>
   <refentrytitle>dblink_open</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_open</refname>
   <refpurpose>在一个远程数据库中打开一个游标</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<synopsis>
dblink_open(text cursorname, text sql [, bool fail_on_error]) 返回 text
dblink_open(text connname, text cursorname, text sql [, bool fail_on_error]) 返回 text
</synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>描述</title>

   <para>
    <function>dblink_open()</>在一个远程数据库中打开一个游标。该游标能够随后使用<function>dblink_fetch()</>和<function>dblink_close()</>进行操纵。
   </para>
  </refsect1>

  <refsect1>
   <title>参数</title>

   <variablelist>
    <varlistentry>
     <term><parameter>connname</parameter></term>
     <listitem>
      <para>
       要使用的连接名。忽略这个参数将使用未命名连接。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>cursorname</parameter></term>
     <listitem>
      <para>
       要赋予给这个游标的名称。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>sql</parameter></term>
     <listitem>
      <para>
       你希望在远程数据库中执行的<command>SELECT</>语句，例如<literal>select * from pg_class</>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>fail_on_error</parameter></term>
     <listitem>
      <para>
       如果为真（忽略时的默认值），那么在连接的远端抛出的一个错误也会导致本地抛出一个错误。如果为假，远程错误只在本地被报告为一个 NOTICE，并且该函数的返回值被设置为<literal>ERROR</>。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>返回值</title>

   <para>
    返回状态，<literal>OK</>或者<literal>ERROR</>。
   </para>
  </refsect1>

  <refsect1>
   <title>注解</title>

   <para>
    因为一个游标只能在一个事务中持续，如果远端还没有在一个事务中，<function>dblink_open</>会在远端开始一个显式事务块（<command>BEGIN</>）。当匹配的<function>dblink_close</>被执行时，这个事务将再次被关闭。注意如果你使用<function>dblink_exec</>在<function>dblink_open</>和<function>dblink_close</>之间改变数据，并且接着发生了一个错误或者你在<function>dblink_close</>之前使用了<function>dblink_disconnect</>，你的更改<emphasis>将被丢失</>，因为事务将被中止。
   </para>
  </refsect1>

  <refsect1>
   <title>例子</title>

<screen>
SELECT dblink_connect('dbname=postgres');
 dblink_connect
----------------
 OK
(1 row)

SELECT dblink_open('foo', 'select proname, prosrc from pg_proc');
 dblink_open
-------------
 OK
(1 row)
</screen>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-FETCH">
  <indexterm>
    <primary>dblink_fetch</primary>
  </indexterm>

  <refmeta>
   <refentrytitle>dblink_fetch</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_fetch</refname>
   <refpurpose>从一个远程数据库中的打开的游标返回行</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<synopsis>
dblink_fetch(text cursorname, int howmany [, bool fail_on_error]) 返回 record 集合
dblink_fetch(text connname, text cursorname, int howmany [, bool fail_on_error]) 返回 record 集合
</synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>描述</title>

   <para>
    <function>dblink_fetch</>从一个之前由<function>dblink_open</>建立的游标中取得行。
   </para>
  </refsect1>

  <refsect1>
   <title>参数</title>

   <variablelist>
    <varlistentry>
     <term><parameter>connname</parameter></term>
     <listitem>
      <para>
       要使用的连接名。忽略这个参数将使用未命名连接。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>cursorname</parameter></term>
     <listitem>
      <para>
       要从中取数据的游标名。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>howmany</parameter></term>
     <listitem>
      <para>
       要检索的最大行数。从当前游标位置向前的接下来<parameter>howmany</>个行会被取出。一旦该游标已经到达了它的末端，将不会产生更多行。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>fail_on_error</parameter></term>
     <listitem>
      <para>
       如果为真（忽略时的默认值），那么在连接的远端抛出的一个错误也会导致本地抛出一个错误。如果为假，远程错误只在本地被报告为一个 NOTICE，并且该函数不反回行。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>返回值</title>

   <para>
    该函数返回从游标中取出的行。要使用这个函数，你将需要指定想要的列集合，如前面<function>dblink</>中所讨论的。
   </para>
  </refsect1>

  <refsect1>
   <title>注解</title>

   <para>
    当<literal>FROM</>子句中指定的返回列的数量和远程游标返回的实际列数不匹配时，将抛出一个错误。在这个事件中，远程游标仍会被前进错误没发生时应该前进的行数。对于远程<command>FETCH</>完成之后在本地查询中发生的任何其他错误，情况也是一样。
   </para>
  </refsect1>

  <refsect1>
   <title>例子</title>

<screen>
SELECT dblink_connect('dbname=postgres');
 dblink_connect
----------------
 OK
(1 row)

SELECT dblink_open('foo', 'select proname, prosrc from pg_proc where proname like ''bytea%''');
 dblink_open
-------------
 OK
(1 row)

SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);
 funcname |  source
----------+----------
 byteacat | byteacat
 byteacmp | byteacmp
 byteaeq  | byteaeq
 byteage  | byteage
 byteagt  | byteagt
(5 rows)

SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);
 funcname  |  source
-----------+-----------
 byteain   | byteain
 byteale   | byteale
 bytealike | bytealike
 bytealt   | bytealt
 byteane   | byteane
(5 rows)

SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);
  funcname  |   source
------------+------------
 byteanlike | byteanlike
 byteaout   | byteaout
(2 rows)

SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);
 funcname | source
----------+--------
(0 rows)
</screen>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-CLOSE">
  <indexterm>
    <primary>dblink_close</primary>
  </indexterm>

  <refmeta>
   <refentrytitle>dblink_close</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_close</refname>
   <refpurpose>关闭一个远程数据库中的游标</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<synopsis>
dblink_close(text cursorname [, bool fail_on_error]) 返回 text
dblink_close(text connname, text cursorname [, bool fail_on_error]) 返回 text
</synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>描述</title>

   <para>
    <function>dblink_close</>关闭一个之前由<function>dblink_open</>打开的游标。
   </para>
  </refsect1>

  <refsect1>
   <title>参数</title>

   <variablelist>
    <varlistentry>
     <term><parameter>connname</parameter></term>
     <listitem>
      <para>
       要使用的连接名。忽略这个参数将使用未命名连接。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>cursorname</parameter></term>
     <listitem>
      <para>
       要关闭的游标名。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>fail_on_error</parameter></term>
     <listitem>
      <para>
       如果为真（忽略时的默认值），那么在连接的远端抛出的一个错误也会导致本地抛出一个错误。如果为假，远程错误只在本地被报告为一个 NOTICE，并且该函数的返回值被设置为<literal>ERROR</>。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>返回值</title>

   <para>
    返回状态，<literal>OK</>或者<literal>ERROR</>。
   </para>
  </refsect1>

  <refsect1>
   <title>注解</title>

   <para>
    如果<function>dblink_open</>开始了一个显式事务块，并且这是这个连接中最后一个保持打开的游标，<function>dblink_close</>将发出匹配的<command>COMMIT</>。
   </para>
  </refsect1>

  <refsect1>
   <title>例子</title>

<screen>
SELECT dblink_connect('dbname=postgres');
 dblink_connect
----------------
 OK
(1 row)

SELECT dblink_open('foo', 'select proname, prosrc from pg_proc');
 dblink_open
-------------
 OK
(1 row)

SELECT dblink_close('foo');
 dblink_close
--------------
 OK
(1 row)
</screen>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-GET-CONNECTIONS">
  <indexterm>
    <primary>dblink_get_connections</primary>
  </indexterm>

  <refmeta>
   <refentrytitle>dblink_get_connections</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_get_connections</refname>
   <refpurpose>返回所有打开的命名 dblink 连接的名称</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<synopsis>
dblink_get_connections() 返回 text[]
</synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>描述</title>

   <para>
    <function>dblink_get_connections</>返回一个数组，其中是所有打开的命名<filename>dblink</>连接的名称。
   </para>
  </refsect1>

  <refsect1>
   <title>返回值</title>

   <para>返回一个连接名称的文本数组，如果没有则为 NULL。</para>
  </refsect1>

  <refsect1>
   <title>例子</title>

<programlisting>
SELECT dblink_get_connections();
</programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-ERROR-MESSAGE">
  <indexterm>
    <primary>dblink_error_message</primary>
  </indexterm>

  <refmeta>
   <refentrytitle>dblink_error_message</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_error_message</refname>
   <refpurpose>得到在命名连接上的最后一个错误消息</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<synopsis>
dblink_error_message(text connname) 返回 text
</synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>描述</title>

   <para>
    <function>dblink_error_message</>为一个给定连接取得最近的远程错误消息。
   </para>
  </refsect1>

  <refsect1>
   <title>参数</title>

   <variablelist>
    <varlistentry>
     <term><parameter>connname</parameter></term>
     <listitem>
      <para>
       要使用的连接名。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>返回值</title>

   <para>
    返回最后一个错误消息，如果在这个连接上没有错误则返回一个空字符串。
   </para>
  </refsect1>

  <refsect1>
   <title>例子</title>

<programlisting>
SELECT dblink_error_message('dtest1');
</programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-SEND-QUERY">
  <indexterm>
    <primary>dblink_send_query</primary>
  </indexterm>

  <refmeta>
   <refentrytitle>dblink_send_query</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_send_query</refname>
   <refpurpose>发送一个异步查询到远程数据库</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<synopsis>
dblink_send_query(text connname, text sql) 返回 int
</synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>描述</title>

   <para>
    <function>dblink_send_query</>发送一个要被异步执行的查询，也就是不需要立即等待结果。在该连接上不能有还在处理中的异步查询。
   </para>

   <para>
    在成功地派送一个异步查询后，可以用<function>dblink_is_busy</>检查完成状态，并且结果最终由<function>dblink_get_result</>收集。也可以使用<function>dblink_cancel_query</>尝试取消一个活动中的异步查询。
   </para>
  </refsect1>

  <refsect1>
   <title>参数</title>

   <variablelist>
    <varlistentry>
     <term><parameter>connname</parameter></term>
     <listitem>
      <para>
       要使用的连接名。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>sql</parameter></term>
     <listitem>
      <para>
       你希望在远程数据库中执行的 SQL 语句，例如<literal>select * from pg_class</>。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>返回值</title>

   <para>
    如果查询被成功地派送返回 1，否则返回 0。
   </para>
  </refsect1>

  <refsect1>
   <title>例子</title>

<programlisting>
SELECT dblink_send_query('dtest1', 'SELECT * FROM foo WHERE f1 &lt; 3');
</programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-IS-BUSY">
  <indexterm>
    <primary>dblink_is_busy</primary>
  </indexterm>

  <refmeta>
   <refentrytitle>dblink_is_busy</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_is_busy</refname>
   <refpurpose>检查连接是否正在忙于一个异步查询</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<synopsis>
dblink_is_busy(text connname) 返回 int
</synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>描述</title>

   <para>
    <function>dblink_is_busy</>测试是否一个异步查询正在进行中。
   </para>
  </refsect1>

  <refsect1>
   <title>参数</title>

   <variablelist>
    <varlistentry>
     <term><parameter>connname</parameter></term>
     <listitem>
      <para>
       要检查的连接名。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>返回值</title>

   <para>
    如果连接正忙则返回 1，如果不忙则返回 0。如果这个函数返回 0，<function>dblink_get_result</>将被保证不会阻塞。
   </para>
  </refsect1>

  <refsect1>
   <title>例子</title>

<programlisting>
SELECT dblink_is_busy('dtest1');
</programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-GET-NOTIFY">
  <indexterm>
    <primary>dblink_get_notify</primary>
  </indexterm>

  <refmeta>
   <refentrytitle>dblink_get_notify</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_get_notify</refname>
   <refpurpose>在一个连接上检索异步通知</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<synopsis>
dblink_get_notify() 返回 (notify_name text, be_pid int, extra text) 集合
dblink_get_notify(text connname) 返回 (notify_name text, be_pid int, extra text) 集合
</synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>描述</title>

   <para>
    <function>dblink_get_notify</>在一个未命名连接或者一个指定的命名连接上检索通知。要通过 dblink 接收通知，首先必须使用<function>dblink_exec</>发出<function>LISTEN</>。详见<xref linkend="sql-listen">和<xref linkend="sql-notify">。
   </para>

  </refsect1>

  <refsect1>
   <title>参数</title>

   <variablelist>
    <varlistentry>
     <term><parameter>connname</parameter></term>
     <listitem>
      <para>
       要在其上得到通知的命名连接的名称。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>返回值</title>
    <para>返回 <type>(notify_name text, be_pid int, extra text) 集合</type>，或者一个空集。</para>
  </refsect1>

  <refsect1>
   <title>例子</title>

<screen>
SELECT dblink_exec('LISTEN virtual');
 dblink_exec
-------------
 LISTEN
(1 row)

SELECT * FROM dblink_get_notify();
 notify_name | be_pid | extra
-------------+--------+-------
(0 rows)

NOTIFY virtual;
NOTIFY

SELECT * FROM dblink_get_notify();
 notify_name | be_pid | extra
-------------+--------+-------
 virtual     |   1229 |
(1 row)
</screen>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-GET-RESULT">
  <indexterm>
    <primary>dblink_get_result</primary>
  </indexterm>

  <refmeta>
   <refentrytitle>dblink_get_result</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_get_result</refname>
   <refpurpose>得到一个异步查询结果</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<synopsis>
dblink_get_result(text connname [, bool fail_on_error]) 返回 record 集合
</synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>描述</title>

   <para>
    <function>dblink_get_result</>收集之前<function>dblink_send_query</>发送的一个异步查询的结果。如果该查询还没有完成，<function>dblink_get_result</>将等待直到它完成。
   </para>
  </refsect1>

  <refsect1>
   <title>参数</title>

   <variablelist>
    <varlistentry>
     <term><parameter>connname</parameter></term>
     <listitem>
      <para>
       要使用的连接名。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>fail_on_error</parameter></term>
     <listitem>
      <para>
       如果为真（忽略时的默认值），那么在连接的远端抛出的一个错误也会导致本地抛出一个错误。如果为假，远程错误只在本地被报告为一个 NOTICE，并且该函数不返回行。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>返回值</title>

   <para>
    对于一个异步查询（也就是一个返回行的 SQL 语句），该函数返回查询产生的行。要使用这个函数，你将需要指定所期待的列集合，如前面为<function>dblink</>所讨论的那样。
   </para>

   <para>
    对于一个异步命令（也就是一个不返回行的 SQL 语句），该函数返回一个只有单个文本列的单行，其中包含了该命令的状态字符串。仍必须在调用的<literal>FROM</>子句中指定结果将具有一个单一文本行。
   </para>
  </refsect1>

  <refsect1>
   <title>注解</title>

   <para>
    如果<function>dblink_send_query</>返回 1，这个函数就<emphasis>必须</>被调用。对每一个已发送的查询都必须调用一次这个函数，并且在连接再次可用之前还要多调用一次来得到一个空结果集。
   </para>

   <para>
    当使用<function>dblink_send_query</>和<function>dblink_get_result</>时，在将结果集中的任何一行返回给本地查询处理器之前，<application>dblink</>将取得整个远程查询结果。如果该查询返回大量的行，这可能会导致本地会话中短暂的内存膨胀。最好将这样的一个查询用<function>dblink_open</>打开成一个游标并且接着每次取得数量可管理的行。也可以使用简单的<function>dblink()</>，它会避免缓冲大型结果集到磁盘上导致的内存膨胀。
   </para>
  </refsect1>

  <refsect1>
   <title>例子</title>

<screen>
contrib_regression=# SELECT dblink_connect('dtest1', 'dbname=contrib_regression');
 dblink_connect
----------------
 OK
(1 row)

contrib_regression=# SELECT * FROM
contrib_regression-# dblink_send_query('dtest1', 'select * from foo where f1 &lt; 3') AS t1;
 t1
----
  1
(1 row)

contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text, f3 text[]);
 f1 | f2 |     f3
----+----+------------
  0 | a  | {a0,b0,c0}
  1 | b  | {a1,b1,c1}
  2 | c  | {a2,b2,c2}
(3 rows)

contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text, f3 text[]);
 f1 | f2 | f3
----+----+----
(0 rows)

contrib_regression=# SELECT * FROM
contrib_regression-# dblink_send_query('dtest1', 'select * from foo where f1 &lt; 3; select * from foo where f1 &gt; 6') AS t1;
 t1
----
  1
(1 row)

contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text, f3 text[]);
 f1 | f2 |     f3
----+----+------------
  0 | a  | {a0,b0,c0}
  1 | b  | {a1,b1,c1}
  2 | c  | {a2,b2,c2}
(3 rows)

contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text, f3 text[]);
 f1 | f2 |      f3
----+----+---------------
  7 | h  | {a7,b7,c7}
  8 | i  | {a8,b8,c8}
  9 | j  | {a9,b9,c9}
 10 | k  | {a10,b10,c10}
(4 rows)

contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text, f3 text[]);
 f1 | f2 | f3
----+----+----
(0 rows)
</screen>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-CANCEL-QUERY">
  <indexterm>
    <primary>dblink_cancel_query</primary>
  </indexterm>

  <refmeta>
   <refentrytitle>dblink_cancel_query</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_cancel_query</refname>
   <refpurpose>在命名连接上取消任何活动查询</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<synopsis>
dblink_cancel_query(text connname) 返回 text
</synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>描述</title>

   <para>
    <function>dblink_cancel_query</>尝试命名连接上正在进行的任何查询。注意这不一定会成功（例如，远程查询可能已经结束）。一个取消请求仅仅提高了该查询将很快失败的几率。你仍必须完成通常的查询协议，例如通过调用<function>dblink_get_result</>。
   </para>
  </refsect1>

  <refsect1>
   <title>参数</title>

   <variablelist>
    <varlistentry>
     <term><parameter>connname</parameter></term>
     <listitem>
      <para>
       要使用的连接名。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>返回值</title>

   <para>
    如果取消请求已经被发送，则返回<literal>OK</>；如果失败，则返回一个错误消息的文本。
   </para>
  </refsect1>

  <refsect1>
   <title>例子</title>

<programlisting>
SELECT dblink_cancel_query('dtest1');
</programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-GET-PKEY">
  <indexterm>
    <primary>dblink_get_pkey</primary>
  </indexterm>

  <refmeta>
   <refentrytitle>dblink_get_pkey</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_get_pkey</refname>
   <refpurpose>返回一个关系的主键域的位置和域名称
   </refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<synopsis>
dblink_get_pkey(text relname) 返回 dblink_pkey_results 集合
</synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>描述</title>

   <para>
    <function>dblink_get_pkey</>提供有关于本地数据库中一个关系的主键的信息。这有时候有助于生成要被发送到远程数据库的查询。
   </para>
  </refsect1>

  <refsect1>
   <title>参数</title>

   <variablelist>
    <varlistentry>
     <term><parameter>relname</parameter></term>
     <listitem>
      <para>
       一个本地关系的名称，例如<literal>foo</>或者<literal>myschema.mytab</>。如果该名称是大小写混合的或包含特殊字符，要包括双引号，例如<literal>"FooBar"</>；如果没有引号，字符串将被折叠到小写形式。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>返回值</title>

   <para>
    为每一个主键域返回一行，如果该关系没有主键则不返回行。结果行类型被定义为：

<programlisting>
CREATE TYPE dblink_pkey_results AS (position int, colname text);
</programlisting>

    <literal>position</>列值可以从 1 到 <replaceable>N</>，它是该域在主键中的编号，而不是在表列中的编号。
   </para>
  </refsect1>

  <refsect1>
   <title>例子</title>

<screen>
CREATE TABLE foobar (
    f1 int,
    f2 int,
    f3 int,
    PRIMARY KEY (f1, f2, f3)
);
CREATE TABLE

SELECT * FROM dblink_get_pkey('foobar');
 position | colname
----------+---------
        1 | f1
        2 | f2
        3 | f3
(3 rows)
</screen>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-BUILD-SQL-INSERT">
  <indexterm>
    <primary>dblink_build_sql_insert</primary>
  </indexterm>

  <refmeta>
   <refentrytitle>dblink_build_sql_insert</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_build_sql_insert</refname>
   <refpurpose>
    使用一个本地元组构建一个 INSERT 语句，将主键域值替换为提供的值
   </refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<synopsis>
dblink_build_sql_insert(text relname,
                        int2vector primary_key_attnums,
                        integer num_primary_key_atts,
                        text[] src_pk_att_vals_array,
                        text[] tgt_pk_att_vals_array) 返回 text
</synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>描述</title>

   <para>
    <function>dblink_build_sql_insert</>在选择性地将一个本地表复制到一个远程数据库时很有用。它基于主键从本地表选择一行，并且接着构建一个复制该行的<command>INSERT</>命令，但是其中主键值被替换为最后一个参数中的值（要创建该行的一个准确拷贝，只要为最后两个参数指定相同的值）。
   </para>
  </refsect1>

  <refsect1>
   <title>参数</title>

   <variablelist>
    <varlistentry>
     <term><parameter>relname</parameter></term>
     <listitem>
      <para>
       一个本地关系的名称，例如<literal>foo</>或者<literal>myschema.mytab</>。如果该名称是大小写混合的或包含特殊字符，要包括双引号，例如<literal>"FooBar"</>；如果没有引号，字符串将被折叠到小写形式。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>primary_key_attnums</parameter></term>
     <listitem>
      <para>
       主键域的属性号（从 1 开始），例如<literal>1 2</>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>num_primary_key_atts</parameter></term>
     <listitem>
      <para>
       主键域的数量。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>src_pk_att_vals_array</parameter></term>
     <listitem>
      <para>
       要被用来查找本地元组的主键域值。每一个域都被表示为文本形式。如果没有行具有这些主键值，则抛出一个错误。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>tgt_pk_att_vals_array</parameter></term>
     <listitem>
      <para>
       要被替换到结果<command>INSERT</>命令中的主键域值。每一个域被表示为文本形式。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>返回值</title>

   <para>将要求的 SQL 语句返回为文本。</para>
  </refsect1>

  <refsect1>
   <title>注解</title>

   <para>
    自<productname>PostgreSQL</> 9.0 开始，<parameter>primary_key_attnums</parameter>中的属性号被解释为逻辑列号，对应于列在<literal>SELECT * FROM relname</>中的位置。之前的版本将属性号解释为物理列位置。如果指示出的列的左边有任意列在该表的生存期内被删除，这两种解释就有区别。
   </para>
  </refsect1>

  <refsect1>
   <title>例子</title>

<screen>
SELECT dblink_build_sql_insert('foo', '1 2', 2, '{"1", "a"}', '{"1", "b''a"}');
             dblink_build_sql_insert
--------------------------------------------------
 INSERT INTO foo(f1,f2,f3) VALUES('1','b''a','1')
(1 row)
</screen>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-BUILD-SQL-DELETE">
  <indexterm>
    <primary>dblink_build_sql_delete</primary>
  </indexterm>

  <refmeta>
   <refentrytitle>dblink_build_sql_delete</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_build_sql_delete</refname>
   <refpurpose>使用所提供的主键域值构建一个 DELETE 语句
   </refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<synopsis>
dblink_build_sql_delete(text relname,
                        int2vector primary_key_attnums,
                        integer num_primary_key_atts,
                        text[] tgt_pk_att_vals_array) 返回 text
</synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>描述</title>

   <para>
    <function>dblink_build_sql_delete</>在选择性地将一个本地表复制到一个远程数据库时很有用。它构建一个 SQL <command>DELETE</>命令用来删除具有给定主键值的行。
   </para>
  </refsect1>

  <refsect1>
   <title>参数</title>

   <variablelist>
    <varlistentry>
     <term><parameter>relname</parameter></term>
     <listitem>
      <para>
       一个本地关系的名称，例如<literal>foo</>或者<literal>myschema.mytab</>。如果该名称是大小写混合的或包含特殊字符，要包括双引号，例如<literal>"FooBar"</>；如果没有引号，字符串将被折叠到小写形式。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>primary_key_attnums</parameter></term>
     <listitem>
      <para>
       主键域的属性号（从 1 开始），例如<literal>1 2</>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>num_primary_key_atts</parameter></term>
     <listitem>
      <para>
       主键域的数量。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>tgt_pk_att_vals_array</parameter></term>
     <listitem>
      <para>
       要用在结果<command>DELETE</>命令中的主键域值。每一个域都被表示为文本形式。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>返回值</title>

   <para>将要求的 SQL 语句返回为文本。</para>
  </refsect1>

  <refsect1>
   <title>注解</title>

   <para>
    自<productname>PostgreSQL</> 9.0 开始，<parameter>primary_key_attnums</parameter>中的属性号被解释为逻辑列号，对应于列在<literal>SELECT * FROM relname</>中的位置。之前的版本将属性号解释为物理列位置。如果指示出的列的左边有任意列在该表的生存期内被删除，这两种解释就有区别。
   </para>
  </refsect1>

  <refsect1>
   <title>例子</title>

<screen>
SELECT dblink_build_sql_delete('"MyFoo"', '1 2', 2, '{"1", "b"}');
           dblink_build_sql_delete
---------------------------------------------
 DELETE FROM "MyFoo" WHERE f1='1' AND f2='b'
(1 row)
</screen>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-BUILD-SQL-UPDATE">
  <indexterm>
    <primary>dblink_build_sql_update</primary>
  </indexterm>

  <refmeta>
   <refentrytitle>dblink_build_sql_update</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_build_sql_update</refname>
   <refpurpose>使用一个本地元组构建一个 UPDATE 语句，将主键域值替换为提供的值
   </refpurpose>
  </refnamediv>

  <refsynopsisdiv>
<synopsis>
dblink_build_sql_update(text relname,
                        int2vector primary_key_attnums,
                        integer num_primary_key_atts,
                        text[] src_pk_att_vals_array,
                        text[] tgt_pk_att_vals_array) 返回 text
</synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>描述</title>

   <para>
    <function>dblink_build_sql_update</>在选择性地将一个本地表复制到一个远程数据库时很有用。它从本地表基于主键选择一行，并且接着构建一个 SQL <command>UPDATE</>命令来复制该行，但是其中的主键值被替换为最后一个参数中的值（要创建该行的一个准确拷贝，只要为最后两个参数指定相同的值）。<command>UPDATE</>命令总是为该行的所有域赋值 &mdash; 这个函数与<function>dblink_build_sql_insert</>之间的主要区别是它假定目标行已经存在于远程表中。
   </para>
  </refsect1>

  <refsect1>
   <title>参数</title>

   <variablelist>
    <varlistentry>
     <term><parameter>relname</parameter></term>
     <listitem>
      <para>
       一个本地关系的名称，例如<literal>foo</>或者<literal>myschema.mytab</>。如果该名称是大小写混合的或包含特殊字符，要包括双引号，例如<literal>"FooBar"</>；如果没有引号，字符串将被折叠到小写形式。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>primary_key_attnums</parameter></term>
     <listitem>
      <para>
       主键域的属性号（从 1 开始），例如<literal>1 2</>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>num_primary_key_atts</parameter></term>
     <listitem>
      <para>
       主键域的数量。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>src_pk_att_vals_array</parameter></term>
     <listitem>
      <para>
       要被用来查找本地元组的主键域值。每一个域都被表示为文本形式。如果没有行具有这些主键值，则抛出一个错误。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>tgt_pk_att_vals_array</parameter></term>
     <listitem>
      <para>
       要用在结果<command>UPDATE</>命令中的主键域值。每一个域都被表示为文本形式。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
   <title>返回值</title>

   <para>将要求的 SQL 语句返回为文本。</para>
  </refsect1>

  <refsect1>
   <title>注解</title>

   <para>
    自<productname>PostgreSQL</> 9.0 开始，<parameter>primary_key_attnums</parameter>中的属性号被解释为逻辑列号，对应于列在<literal>SELECT * FROM relname</>中的位置。之前的版本将属性号解释为物理列位置。如果指示出的列的左边有任意列在该表的生存期内被删除，这两种解释就有区别。
   </para>
  </refsect1>

  <refsect1>
   <title>例子</title>

<screen>
SELECT dblink_build_sql_update('foo', '1 2', 2, '{"1", "a"}', '{"1", "b"}');
                   dblink_build_sql_update
-------------------------------------------------------------
 UPDATE foo SET f1='1',f2='b',f3='1' WHERE f1='1' AND f2='b'
(1 row)
</screen>
  </refsect1>
 </refentry>

</sect1>
